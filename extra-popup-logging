# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4c058a6bf21a95400ddfc3e2fd0f7f0941128567

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1447,16 +1447,17 @@ var gBrowserInit = {
     }
 
     // Call this after we set attributes that might change toolbars' computed
     // text color.
     ToolbarIconColor.init();
   },
 
   onDOMContentLoaded() {
+    document.getElementById("mainPopupSet").hidden = false;
     // This needs setting up before we create the first remote browser.
     window.docShell.treeOwner
           .QueryInterface(Ci.nsIInterfaceRequestor)
           .getInterface(Ci.nsIXULWindow)
           .XULBrowserWindow = window.XULBrowserWindow;
     window.browserDOMWindow = new nsBrowserAccess();
 
     gBrowser = window._gBrowser;
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -122,17 +122,17 @@
 # top level windows in macWindow.inc.xul.
 #include browser-sets.inc
 
 </head>
 <body>
 
 <vbox id="browser-ui-wrapper"
       xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-  <popupset id="mainPopupSet">
+  <popupset id="mainPopupSet" hidden="true">
     <menupopup id="tabContextMenu"
                onpopupshowing="if (event.target == this) TabContextMenu.updateContextMenu(this);"
                onpopuphidden="if (event.target == this) TabContextMenu.contextTab = null;">
       <menuitem id="context_reloadTab" data-lazy-l10n-id="reload-tab"
                 oncommand="gBrowser.reloadTab(TabContextMenu.contextTab);"/>
       <menuitem id="context_reloadSelectedTabs" data-lazy-l10n-id="reload-tabs" hidden="true"
                 oncommand="gBrowser.reloadMultiSelectedTabs();"/>
       <menuitem id="context_toggleMuteTab" oncommand="TabContextMenu.contextTab.toggleMuteAudio();"/>
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -5424,18 +5424,20 @@ void nsCSSFrameConstructor::AddFrameCons
   }
 
   bool isPopup = false;
 
 #ifdef MOZ_XUL
   if ((data->mBits & FCDATA_IS_POPUP) && (!aParentFrame ||  // Parent is inline
                                           !aParentFrame->IsMenuFrame())) {
     if (!aState.mPopupList.containingBlock && !aState.mHavePendingPopupgroup) {
+      printf("XXX Brian - Early return 1 %s\n", aContent->OwnerDoc()->GetDocumentURI()->GetSpecOrDefault().get());
       return;
     }
+      printf("XXX Brian - NO Early return 1 %s\n", aContent->OwnerDoc()->GetDocumentURI()->GetSpecOrDefault().get());
 
     isPopup = true;
   }
 #endif /* MOZ_XUL */
 
   uint32_t bits = data->mBits;
 
   // Inside colgroups, suppress everything except columns.
@@ -5478,16 +5480,17 @@ void nsCSSFrameConstructor::AddFrameCons
   if (isGeneratedContent) {
     // We need to keep this alive until the frame takes ownership.
     // This corresponds to the Release in ConstructFramesFromItem.
     item->mContent->AddRef();
   }
   item->mIsRootPopupgroup = aContent->IsRootOfNativeAnonymousSubtree() &&
                             aContent->IsXULElement(nsGkAtoms::popupgroup);
   if (item->mIsRootPopupgroup) {
+    printf("XXX Brian - Creating mIsRootPopupgroup %s\n", aContent->OwnerDoc()->GetDocumentURI()->GetSpecOrDefault().get());
     aState.mHavePendingPopupgroup = true;
   }
   item->mIsPopup = isPopup;
 
   if (canHavePageBreak && display.BreakAfter()) {
     AddPageBreakItem(aContent, aItems);
   }
 
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -146,16 +146,17 @@ nsresult nsCanvasFrame::CreateAnonymousC
     mCustomContentContainer->AppendChildTo(&anonContent->ContentNode(), false);
   }
 
   // Create a popupgroup element for chrome privileged top level non-XUL
   // documents to support context menus and tooltips.
   if (PresContext()->IsChrome() && PresContext()->IsRoot() &&
       doc->AllowXULXBL() && !doc->IsXULDocument()) {
     nsNodeInfoManager* nodeInfoManager = doc->NodeInfoManager();
+    printf("Making popupgroup for non null\n");
     RefPtr<NodeInfo> nodeInfo =
         nodeInfoManager->GetNodeInfo(nsGkAtoms::popupgroup, nullptr,
                                      kNameSpaceID_XUL, nsINode::ELEMENT_NODE);
 
     nsresult rv = NS_NewXULElement(getter_AddRefs(mPopupgroupContent),
                                    nodeInfo.forget(), dom::NOT_FROM_PARSER);
     NS_ENSURE_SUCCESS(rv, rv);
 
