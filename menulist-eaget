# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f65b1bab3935d49ee8d54ec6429d2154e5225150
Eagerly render menuitems inside menulist

diff --git a/toolkit/content/widgets/menu.js b/toolkit/content/widgets/menu.js
--- a/toolkit/content/widgets/menu.js
+++ b/toolkit/content/widgets/menu.js
@@ -203,46 +203,47 @@ class MozMenuItem extends MozMenuItemBas
     return frag;
   }
 
   get isIconic() {
     let type = this.getAttribute("type");
     return type == "checkbox" || type == "radio" || this.classList.contains("menuitem-iconic");
   }
 
-  get isIconicNoAccel() {
+  get isMenulistChild() {
     return this.matches("menulist > menupopup > menuitem");
   }
 
   get isInHiddenMenupopup() {
     return this.matches("menupopup:not([hasbeenopened]) menuitem");
   }
 
   render() {
     if (this.renderedOnce) {
       return;
     }
     this.renderedOnce = true;
     this.textContent = "";
-    if (this.isIconicNoAccel) {
+    if (this.isMenulistChild) {
       this.append(this.constructor.iconicNoAccelFragment.cloneNode(true));
     } else if (this.isIconic) {
       this.append(this.constructor.iconicFragment.cloneNode(true));
     } else {
       this.append(this.constructor.plainFragment.cloneNode(true));
     }
 
     this.initializeAttributeInheritance();
   }
 
   connectedCallback() {
-    // If we are being inserted into an already-opened menupopup then eagerly render.
+    // Eagerly render if we are being inserted into a menulist (since we likely need to
+    // size it), or into an already-opened menupopup (since we are already visible).
     // Checking isConnectedAndReady is an optimization that will let us quickly skip
-    // everything that's being connected during parse.
-    if (this.isConnectedAndReady && !this.isInHiddenMenupopup) {
+    // non-menulists that are being connected during parse.
+    if (this.isMenulistChild || (this.isConnectedAndReady && !this.isInHiddenMenupopup)) {
       this.render();
     }
   }
 }
 
 customElements.define("menuitem", MozMenuItem);
 
 const isHiddenWindow = document.documentURI == "chrome://browser/content/hiddenWindow.xul";
@@ -258,25 +259,25 @@ class MozMenu extends MozMenuBaseMixin(M
       ".menu-iconic-icon": "src=image,triggeringprincipal=iconloadingprincipal,validate",
       ".menu-iconic-accel": "value=acceltext",
       ".menu-right": "_moz-menuactive,disabled",
       ".menu-accel": "value=acceltext",
     };
   }
 
   get needsEagerRender() {
-    return this.isMenubarChild || this.isSizingPopup || !this.isInHiddenMenupopup;
+    return this.isMenubarChild || this.isMenulistChild || !this.isInHiddenMenupopup;
   }
 
   get isMenubarChild() {
     return this.matches("menubar > menu");
   }
 
-  get isSizingPopup() {
-    return this.matches("[sizetopopup] menu") || this.matches("menulist menu");
+  get isMenulistChild() {
+    return this.matches("menulist > menupopup > menu");
   }
 
   get isInHiddenMenupopup() {
     return this.matches("menupopup:not([hasbeenopened]) menu");
   }
 
   get isIconic() {
     return this.classList.contains("menu-iconic");
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -247,21 +247,21 @@ toolbarspring {
 
 menubar > menu:empty {
   visibility: collapse;
 }
 
 /********* menuitem ***********/
 
 /* menuitems that haven't gotten rendered should still take up space for sizetopopup behavior */
-menulist > menupopup > menuitem:empty:after {
+/* menulist > menupopup > menuitem:empty:after {
   content: attr(label);
   display: -moz-box;
   visibility: hidden;
-}
+} */
 
 .menu-text {
   -moz-box-flex: 1;
 }
 
 /********* menupopup, panel, & tooltip ***********/
 
 menupopup {
