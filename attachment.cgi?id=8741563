# HG changeset patch
# User Morgan Phillips <winter2718@gmail.com>
# Date 1460678490 25200
#      Thu Apr 14 17:01:30 2016 -0700
# Node ID 958c9e8d59a880a25d5d8fe5a1f8d4e8796ab303
# Parent  8c251e28fe64810ff60acaa7627f8231ea38ccdf
Bug 1264780 - Handle destructuring cases when forcing binding initialization; r=bgrins

diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -1297,20 +1297,60 @@ WebConsoleActor.prototype =
         // since it's already being handled elsewhere and we are only interested
         // in initializing bindings.
         try {
           ast = Parser.reflectionAPI.parse(aString);
         } catch (ex) {
           ast = {"body": []};
         }
         for (let line of ast.body) {
-          if (line.type == "VariableDeclaration" &&
-            (line.kind == "let" || line.kind == "const")) {
-            for (let decl of line.declarations)
-              dbgWindow.forceLexicalInitializationByName(decl.id.name);
+          console.log(line.kind);
+          if (!(line.kind == "let" || line.kind == "const")) {
+                continue;
+          }
+
+          let identifiers = [];
+          for (let decl of line.declarations) {
+            console.log(decl.id.type);
+            switch (decl.id.type) {
+              case "Identifier": {
+
+                // let foo = bar;
+                identifiers.push(decl.id.name);
+                break;
+              };
+              case "ArrayPattern": {
+
+                // let [foo, bar] = [1, 2];
+                for (let e of decl.id.elements) {
+                    if (e.type == "Identifier") {
+                      identifiers.push(e.name);
+                    } else if (e.type == "AssignmentExpression") {
+                      identifiers.push(e.left.name);
+                    }
+                }
+                break;
+              };
+              case "ObjectPattern": {
+
+                // let {bilbo, my} = {bilbo: "baggins", my: "precious"};
+                for (let prop of decl.id.properties) {
+                  debugger;
+                  console.log("Prop: ", prop.key.type, prop.key.name, prop);
+                  if (prop.key.type == "Identifier") {
+                    identifiers.push(prop.key.name);
+                  }
+                }
+                break;
+              };
+            }
+          }
+
+          for (let name of identifiers) {
+            dbgWindow.forceLexicalInitializationByName(name);
           }
         }
       }
     }
 
     let helperResult = helpers.helperResult;
     delete helpers.evalInput;
     delete helpers.helperResult;
diff --git a/devtools/shared/webconsole/test/test_jsterm.html b/devtools/shared/webconsole/test/test_jsterm.html
--- a/devtools/shared/webconsole/test/test_jsterm.html
+++ b/devtools/shared/webconsole/test/test_jsterm.html
@@ -220,31 +220,68 @@ function* doEvalWithBindingFrame() {
     "Global matches the top global with bindObjectActor");
   ok(!frameWin.temp1,
     "Global doesn't match the object's global with bindObjectActor");
 
   nextTest()
 }
 
 function* forceLexicalInit() {
-  info("test `let x = SomeError` results in x being initialized to undefined");
-  let response = yield evaluateJS("let foopie = wubbalubadubdub;");
-  checkObject(response, {
-    from: gState.actor,
-    input: "let foopie = wubbalubadubdub;",
-    result: undefined,
-  });
-  ok(response.exception, "expected exception");
-  let response2 = yield evaluateJS("foopie;");
-  checkObject(response2, {
-    from: gState.actor,
-    input: "foopie;",
-    result: undefined,
-  });
-  ok(!response2.exception, "unexpected exception");
+  info("test that failed let/const bindings are initialized to undefined");
+
+  const testData = [
+    {
+        stmt: "let foopie = wubbalubadubdub",
+        vars: ["foopie"]
+    },
+    {
+        stmt: "let {z, w={n}=null} = {}",
+        vars: ["z", "w"]
+    },
+    {
+        stmt: "let [a, b, c] = null",
+        vars: ["a", "b", "c"]
+    },
+    {
+        stmt: "const nein1 = rofl, nein2 = copter",
+        vars: ["nein1", "nein2"]
+    },
+    {
+        stmt: "const {ha} = null",
+        vars: ["ha"]
+    },
+    {
+        stmt: "const [haw=[lame]=null] = []",
+        vars: ["haw"]
+    },
+    {
+        stmt: "const [rawr, wat=[lame]=null] = []",
+        vars: ["rawr", "haw"]
+    }
+  ];
+
+  for (let data of testData) {
+      let response = yield evaluateJS(data.stmt);
+      checkObject(response, {
+        from: gState.actor,
+        input: data.stmt,
+        result: undefined,
+      });
+      ok(response.exception, "expected exception");
+      for (let varName of data.vars) {
+          let response2 = yield evaluateJS(varName);
+          checkObject(response2, {
+            from: gState.actor,
+            input: varName,
+            result: undefined,
+          });
+          ok(!response2.exception, "unexpected exception");
+      }
+  }
+
   nextTest();
 }
 
 function testEnd()
 {
   // If this is the first run, reload the page and do it again.
   // Otherwise, end the test.
   closeDebugger(gState, function() {
