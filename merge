# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a7aa621ef38ca83c02ca36d64ee5ab9ae4510f86
Bug 1441935 - Fold together remote browser and browser classes

diff --git a/toolkit/content/widgets/browser.js b/toolkit/content/widgets/browser.js
--- a/toolkit/content/widgets/browser.js
+++ b/toolkit/content/widgets/browser.js
@@ -2,17 +2,143 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 {
 
 class MozBrowser extends XULFrameElement {
+
+  constructor() {
+    super();
+    // Remote browsers override webNavigation. Store the normal XULFrameElement
+    // webNavigation so it can be returned for non-remote browsers.
+    this._webNavigation = this.__lookupGetter__("webNavigation");
+    Object.defineProperty(this, 'webNavigation', {
+      get() {
+        if (this.isRemoteBrowser) {
+          return this._remoteWebNavigation;
+        }
+        return this._webNavigation.call(this);
+      }
+    });
+  }
+
   connectedCallback() {
+
+    if (this.isRemoteBrowser) {
+      this.setupRemoteBrowser();
+    } else {
+      this.setupNonRemoteBrowser();
+    }
+  }
+
+  setupRemoteBrowser() {
+    this._securityUI = null;
+
+    this._controller = null;
+
+    this._selectParentHelper = null;
+
+    this._remoteWebNavigation = null;
+
+    this._remoteWebProgress = null;
+
+    this._remoteFinder = null;
+
+    this._documentURI = null;
+
+    this._documentContentType = null;
+
+    this._contentTitle = "";
+
+    this._characterSet = "";
+
+    this._mayEnableCharacterEncodingMenu = null;
+
+    this._contentWindow = null;
+
+    this._contentPrincipal = null;
+
+    this._contentRequestContextID = null;
+
+    this._contentDocument = null;
+
+    this._imageDocument = null;
+
+    this._fullZoom = 1;
+
+    this._textZoom = 1;
+
+    this._isSyntheticDocument = false;
+
+    this._outerWindowID = null;
+
+    this._innerWindowID = null;
+
+    this.mDestroyed = false;
+
+    this._permitUnloadId = 0;
+
+    /*
+     * Don't try to send messages from this function. The message manager for
+     * the <browser> element may not be initialized yet.
+     */
+
+    this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
+      .createInstance(Ci.nsIWebNavigation);
+    this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
+    this._remoteWebNavigationImpl.swapBrowser(this);
+
+    // Initialize contentPrincipal to the about:blank principal for this loadcontext
+    let { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
+    let aboutBlank = Services.io.newURI("about:blank");
+    let ssm = Services.scriptSecurityManager;
+    this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
+
+    this.messageManager.addMessageListener("Browser:Init", this);
+    this.messageManager.addMessageListener("DOMTitleChanged", this);
+    this.messageManager.addMessageListener("ImageDocumentLoaded", this);
+    this.messageManager.addMessageListener("FullZoomChange", this);
+    this.messageManager.addMessageListener("TextZoomChange", this);
+    this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
+    this.messageManager.addMessageListener("DOMFullscreen:RequestExit", this);
+    this.messageManager.addMessageListener("DOMFullscreen:RequestRollback", this);
+    this.messageManager.addMessageListener("MozApplicationManifest", this);
+
+    // browser-child messages, such as Content:LocationChange, are handled in
+    // RemoteWebProgress, ensure it is loaded and ready.
+    let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
+    let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
+    this._remoteWebProgressManager = new RemoteWebProgressManager(this);
+    this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
+
+    this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
+
+    if (this.hasAttribute("selectmenulist")) {
+      this.messageManager.addMessageListener("Forms:ShowDropDown", this);
+      this.messageManager.addMessageListener("Forms:HideDropDown", this);
+    }
+
+    if (!this.hasAttribute("disablehistory")) {
+      Services.obs.addObserver(this, "browser:purge-session-history", true);
+    }
+
+    let rc_js = "resource://gre/modules/RemoteController.js";
+    let scope = {};
+    Services.scriptloader.loadSubScript(rc_js, scope);
+    let RemoteController = scope.RemoteController;
+    this._controller = new RemoteController(this);
+    this.controllers.appendController(this._controller);
+
+    this._setupEventListeners();
+  }
+
+  setupNonRemoteBrowser() {
     /**
      * Weak reference to an optional frame loader that can be used to influence
      * process selection for this browser.
      * See nsIBrowser.sameProcessAsFrameLoader.
      */
     this._sameProcessAsFrameLoader = null;
 
     this._loadContext = null;
@@ -169,20 +295,26 @@ class MozBrowser extends XULFrameElement
   get currentURI() {
     if (this.webNavigation) {
       return this.webNavigation.currentURI;
     }
     return null;
   }
 
   get documentURI() {
+    if (this.isRemoteBrowser) {
+      return this._documentURI;
+    }
     return this.contentDocument.documentURIObject;
   }
 
   get documentContentType() {
+    if (this.isRemoteBrowser) {
+      return this._documentContentType;
+    }
     return this.contentDocument ? this.contentDocument.contentType : null;
   }
 
   set sameProcessAsFrameLoader(val) {
     this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
   }
 
   get sameProcessAsFrameLoader() {
@@ -204,38 +336,71 @@ class MozBrowser extends XULFrameElement
     return document.getElementById(this.getAttribute('autocompletepopup'))
   }
 
   get dateTimePicker() {
     return document.getElementById(this.getAttribute('datetimepicker'))
   }
 
   set docShellIsActive(val) {
+    if (this.isRemoteBrowser) {
+      this.frameLoader.tabParent.docShellIsActive = val;
+      return val;
+    }
+
     if (this.docShell)
       return this.docShell.isActive = val;
     return false;
   }
 
   get docShellIsActive() {
+    if (this.isRemoteBrowser) {
+      return this.frameLoader.tabParent.docShellIsActive;
+    }
     return this.docShell && this.docShell.isActive;
   }
 
   set renderLayers(val) {
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader && frameLoader.tabParent) {
+        return frameLoader.tabParent.renderLayers = val;
+      }
+      return false;
+    }
     return this.docShellIsActive = val;
   }
 
   get renderLayers() {
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader && frameLoader.tabParent) {
+        return frameLoader.tabParent.renderLayers;
+      }
+      return false;
+    }
     return this.docShellIsActive;
   }
 
   get hasLayers() {
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader.tabParent) {
+        return frameLoader.tabParent.hasLayers;
+      }
+      return false;
+    }
+
     return this.docShellIsActive;
   }
 
   get imageDocument() {
+    if (this.isRemoteBrowser) {
+      return this._imageDocument;
+    }
     var document = this.contentDocument;
     if (!document || !(document instanceof Ci.nsIImageDocument))
       return null;
 
     try {
       return { width: document.imageRequest.image.width, height: document.imageRequest.image.height };
     } catch (e) {}
     return null;
@@ -268,16 +433,29 @@ class MozBrowser extends XULFrameElement
 
   get webBrowserFind() {
     if (!this._webBrowserFind)
       this._webBrowserFind = this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebBrowserFind);
     return this._webBrowserFind;
   }
 
   get finder() {
+    if (this.isRemoteBrowser) {
+      if (!this._remoteFinder) {
+        // Don't attempt to create the remote finder if the
+        // messageManager has already gone away
+        if (!this.messageManager)
+          return null;
+
+        let jsm = "resource://gre/modules/RemoteFinder.jsm";
+        let { RemoteFinder } = ChromeUtils.import(jsm, {});
+        this._remoteFinder = new RemoteFinder(this);
+      }
+      return this._remoteFinder;
+    }
     if (!this._finder) {
       if (!this.docShell)
         return null;
 
       let Finder = ChromeUtils.import("resource://gre/modules/Finder.jsm", {}).Finder;
       this._finder = new Finder(this.docShell);
     }
     return this._finder;
@@ -298,31 +476,40 @@ class MozBrowser extends XULFrameElement
       this._fastFind = Cc["@mozilla.org/typeaheadfind;1"]
         .createInstance(Ci.nsITypeAheadFind);
       this._fastFind.init(this.docShell);
     }
     return this._fastFind;
   }
 
   get outerWindowID() {
+    if (this.isRemoteBrowser) {
+      return this._outerWindowID;
+    }
     return this.contentWindow.windowUtils.outerWindowID;
   }
 
   get innerWindowID() {
+    if (this.isRemoteBrowser) {
+      return this._innerWindowID;
+    }
     try {
       return this.contentWindow.windowUtils.currentInnerWindowID;
     } catch (e) {
       if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {
         throw e;
       }
       return null;
     }
   }
 
   get webProgress() {
+    if (this.isRemoteBrowser) {
+      return this._remoteWebProgress;
+    }
     return this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);
   }
 
   get contentWindowAsCPOW() {
     return this.contentWindow;
   }
 
   get sessionHistory() {
@@ -333,37 +520,58 @@ class MozBrowser extends XULFrameElement
     return this.docShell.contentViewer;
   }
 
   get contentDocumentAsCPOW() {
     return this.contentDocument;
   }
 
   get contentTitle() {
+    if (this.isRemoteBrowser) {
+      return this._contentTitle;
+    }
     return this.contentDocument.title;
   }
 
   set characterSet(val) {
-    this.docShell.charset = val;
-    this.docShell.gatherCharsetMenuTelemetry();
+    if (this.isRemoteBrowser) {
+      this.messageManager.sendAsyncMessage("UpdateCharacterSet", { value: val });
+      this._characterSet = val;
+    } else {
+      this.docShell.charset = val;
+      this.docShell.gatherCharsetMenuTelemetry();
+    }
   }
 
   get characterSet() {
+    if (this.isRemoteBrowser) {
+      return this._characterSet;
+    }
     return this.docShell.charset;
   }
 
   get mayEnableCharacterEncodingMenu() {
+    if (this.isRemoteBrowser) {
+      return this._mayEnableCharacterEncodingMenu;
+    }
     return this.docShell.mayEnableCharacterEncodingMenu;
   }
 
   get contentPrincipal() {
+    if (this.isRemoteBrowser) {
+      return this._contentPrincipal;
+    }
     return this.contentDocument.nodePrincipal;
   }
 
   get contentRequestContextID() {
+    if (this.isRemoteBrowser) {
+      return this._contentRequestContextID;
+    }
+
     try {
       return this.contentDocument.documentLoadGroup
         .requestContextID;
     } catch (e) {
       return null;
     }
   }
 
@@ -373,36 +581,76 @@ class MozBrowser extends XULFrameElement
     return val;
   }
 
   get showWindowResizer() {
     return this.getAttribute('showresizer') == 'true';
   }
 
   set fullZoom(val) {
-    this.markupDocumentViewer.fullZoom = val;
+    if (this.isRemoteBrowser) {
+      let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
+
+      this._fullZoom = val;
+      try {
+        this.messageManager.sendAsyncMessage("FullZoom", { value: val });
+      } catch (ex) {}
+
+      if (changed) {
+        let event = new Event("FullZoomChange", { bubbles: true });
+        this.dispatchEvent(event);
+      }
+    } else {
+      this.markupDocumentViewer.fullZoom = val;
+    }
   }
 
   get fullZoom() {
+    if (this.isRemoteBrowser) {
+      return this._fullZoom;
+    }
     return this.markupDocumentViewer.fullZoom;
   }
 
   set textZoom(val) {
-    this.markupDocumentViewer.textZoom = val;
+    if (this.isRemoteBrowser) {
+      let changed = val.toFixed(2) != this._textZoom.toFixed(2);
+
+      this._textZoom = val;
+      try {
+        this.messageManager.sendAsyncMessage("TextZoom", { value: val });
+      } catch (ex) {}
+
+      if (changed) {
+        let event = new Event("TextZoomChange", { bubbles: true });
+        this.dispatchEvent(event);
+      }
+    } else {
+      this.markupDocumentViewer.textZoom = val;
+    }
   }
 
   get textZoom() {
+    if (this.isRemoteBrowser) {
+      return this._textZoom;
+    }
     return this.markupDocumentViewer.textZoom;
   }
 
   get isSyntheticDocument() {
+    if (this.isRemoteBrowser) {
+      return this._isSyntheticDocument;
+    }
     return this.contentDocument.mozSyntheticDocument;
   }
 
   get hasContentOpener() {
+    if (this.isRemoteBrowser) {
+      return this.frameLoader.tabParent.hasContentOpener;
+    }
     return !!this.contentWindow.opener;
   }
 
   get mStrBundle() {
     if (!this._mStrBundle) {
       // need to create string bundle manually instead of using <xul:stringbundle/>
       // see bug 63370 for details
       this._mStrBundle = Cc["@mozilla.org/intl/stringbundle;1"]
@@ -420,16 +668,35 @@ class MozBrowser extends XULFrameElement
     return this._shouldSendUnselectedTabHover;
   }
 
   set securityUI(val) {
     this.docShell.securityUI = val;
   }
 
   get securityUI() {
+    if (this.isRemoteBrowser) {
+      if (!this._securityUI) {
+        // Don't attempt to create the remote web progress if the
+        // messageManager has already gone away
+        if (!this.messageManager)
+          return null;
+
+        let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
+        let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
+        this._securityUI = new RemoteSecurityUI();
+      }
+
+      // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
+      var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
+        .createInstance(Ci.nsISupportsInterfacePointer);
+      ptr.data = this._securityUI;
+      return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
+    }
+
     if (!this.docShell.securityUI) {
       const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
       if (!this.hasAttribute("disablesecurity") &&
         SECUREBROWSERUI_CONTRACTID in Cc) {
         var securityUI = Cc[SECUREBROWSERUI_CONTRACTID]
           .createInstance(Ci.nsISecureBrowserUI);
         securityUI.init(this.contentWindow);
       }
@@ -525,21 +792,30 @@ class MozBrowser extends XULFrameElement
 
   /**
    * Used by session restore to ensure that currentURI is set so
    * that switch-to-tab works before the tab is fully
    * restored. This function also invokes onLocationChanged
    * listeners in tabbrowser.xml.
    */
   _setCurrentURI(aURI) {
-    this.docShell.setCurrentURI(aURI);
+    if (this.isRemoteBrowser) {
+      this._remoteWebProgressManager.setCurrentURI(aURI);
+    } else {
+      this.docShell.setCurrentURI(aURI);
+    }
   }
 
   preserveLayers(preserve) {
-    // Only useful for remote browsers.
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader.tabParent) {
+        frameLoader.tabParent.preserveLayers(preserve);
+      }
+    }
   }
 
   getTabBrowser() {
     if (this.ownerGlobal.gBrowser &&
       this.ownerGlobal.gBrowser.getTabForBrowser &&
       this.ownerGlobal.gBrowser.getTabForBrowser(this)) {
       return this.ownerGlobal.gBrowser;
     }
@@ -690,30 +966,46 @@ class MozBrowser extends XULFrameElement
   didStartLoadSinceLastUserTyping() {
     return !this.inLoadURI &&
       this.urlbarChangeTracker._startedLoadSinceLastUserTyping;
   }
 
   /**
    * This is necessary because the destructor doesn't always get called when
    * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
-   *
-   * Note: this function is overriden in remote-browser.xml, so any clean-up that
-   * also applies to browser.isRemoteBrowser = true must be duplicated there.
    */
   destroy() {
     // Make sure that any open select is closed.
     if (this._selectParentHelper) {
       let menulist = document.getElementById(this.getAttribute("selectmenulist"));
       this._selectParentHelper.hide(menulist, this);
     }
     if (this.mDestroyed)
       return;
     this.mDestroyed = true;
 
+    if (this.isRemoteBrowser) {
+      try {
+        this.controllers.removeController(this._controller);
+      } catch (ex) {
+        // This can fail when this browser element is not attached to a
+        // BrowserDOMWindow.
+      }
+
+      if (!this.hasAttribute("disablehistory")) {
+        let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
+        try {
+          Services.obs.removeObserver(this, "browser:purge-session-history");
+        } catch (ex) {
+          // It's not clear why this sometimes throws an exception.
+        }
+      }
+      return;
+    }
+
     if (this.docShell && this.webNavigation.sessionHistory) {
       var os = Cc["@mozilla.org/observer-service;1"]
         .getService(Ci.nsIObserverService);
       try {
         os.removeObserver(this, "browser:purge-session-history");
       } catch (ex) {
         // It's not clear why this sometimes throws an exception.
       }
@@ -831,17 +1123,106 @@ class MozBrowser extends XULFrameElement
           break;
         }
 
     }
     return undefined;
   }
 
   receiveMessage(aMessage) {
-    return this._receiveMessage(aMessage);
+    let handledByRemote = false;
+    if (this.isRemoteBrowser) {
+      let data = aMessage.data;
+      handledByRemote = true;
+      switch (aMessage.name) {
+        case "Browser:Init":
+          this._outerWindowID = data.outerWindowID;
+          break;
+        case "DOMTitleChanged":
+          this._contentTitle = data.title;
+          break;
+        case "ImageDocumentLoaded":
+          this._imageDocument = {
+            width: data.width,
+            height: data.height
+          };
+          break;
+
+        case "Forms:ShowDropDown":
+          {
+            if (!this._selectParentHelper) {
+              this._selectParentHelper =
+                ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
+            }
+
+            let menulist = document.getElementById(this.getAttribute("selectmenulist"));
+            menulist.menupopup.style.direction = data.direction;
+
+            let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
+              this.isSyntheticDocument ? this._fullZoom : this._textZoom;
+            this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
+              zoom, data.uaBackgroundColor, data.uaColor,
+              data.uaSelectBackgroundColor, data.uaSelectColor,
+              data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
+            this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
+            break;
+          }
+
+        case "FullZoomChange":
+          {
+            this._fullZoom = data.value;
+            let event = document.createEvent("Events");
+            event.initEvent("FullZoomChange", true, false);
+            this.dispatchEvent(event);
+            break;
+          }
+
+        case "TextZoomChange":
+          {
+            this._textZoom = data.value;
+            let event = document.createEvent("Events");
+            event.initEvent("TextZoomChange", true, false);
+            this.dispatchEvent(event);
+            break;
+          }
+
+        case "ZoomChangeUsingMouseWheel":
+          {
+            let event = document.createEvent("Events");
+            event.initEvent("ZoomChangeUsingMouseWheel", true, false);
+            this.dispatchEvent(event);
+            break;
+          }
+
+        case "DOMFullscreen:RequestExit":
+          {
+            let windowUtils = window.windowUtils;
+            windowUtils.exitFullscreen();
+            break;
+          }
+
+        case "DOMFullscreen:RequestRollback":
+          {
+            let windowUtils = window.windowUtils;
+            windowUtils.remoteFrameFullscreenReverted();
+            break;
+          }
+
+        case "MozApplicationManifest":
+          this._manifestURI = aMessage.data.manifest;
+          break;
+
+      default:
+        handledByRemote = false;
+      }
+
+      if (!handledByRemote) {
+        return this._receiveMessage(aMessage);
+      }
+    }
   }
 
   observe(aSubject, aTopic, aState) {
     if (aTopic == "browser:purge-session-history") {
       this.purgeSessionHistory();
     } else if (aTopic == "apz:cancel-autoscroll") {
       if (aState == this._autoScrollScrollId) {
         // Set this._autoScrollScrollId to null, so in stopScroll() we
@@ -851,22 +1232,46 @@ class MozBrowser extends XULFrameElement
         this._autoScrollPresShellId = null;
 
         this._autoScrollPopup.hidePopup();
       }
     }
   }
 
   purgeSessionHistory() {
-    this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+    if (this.isRemoteBrowser) {
+      try {
+        this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+      } catch (ex) {
+        // This can throw if the browser has started to go away.
+        if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
+          throw ex;
+        }
+      }
+      this._remoteWebNavigationImpl.canGoBack = false;
+      this._remoteWebNavigationImpl.canGoForward = false;
+    } else {
+      this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+    }
   }
 
   createAboutBlankContentViewer(aPrincipal) {
-    let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
-    this.docShell.createAboutBlankContentViewer(principal);
+    if (this.isRemoteBrowser) {
+      // Ensure that the content process has the permissions which are
+      // needed to create a document with the given principal.
+      let permissionPrincipal =
+        BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
+      this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
+
+      // Create the about blank content viewer in the content process
+      this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
+    } else {
+      let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
+      this.docShell.createAboutBlankContentViewer(principal);
+    }
   }
 
   stopScroll() {
     if (this._scrolling) {
       this._scrolling = false;
       window.removeEventListener("mousemove", this, true);
       window.removeEventListener("mousedown", this, true);
       window.removeEventListener("mouseup", this, true);
@@ -1178,24 +1583,101 @@ class MozBrowser extends XULFrameElement
 
     event = new CustomEvent("EndSwapDocShells", { "detail": aOtherBrowser });
     this.dispatchEvent(event);
     event = new CustomEvent("EndSwapDocShells", { "detail": this });
     aOtherBrowser.dispatchEvent(event);
   }
 
   getInPermitUnload(aCallback) {
-    if (!this.docShell || !this.docShell.contentViewer) {
-      aCallback(false);
-      return;
+    if (this.isRemoteBrowser) {
+      let id = this._permitUnloadId++;
+      let mm = this.messageManager;
+      mm.sendAsyncMessage("InPermitUnload", { id });
+      mm.addMessageListener("InPermitUnload", function listener(msg) {
+        if (msg.data.id != id) {
+          return;
+        }
+        aCallback(msg.data.inPermitUnload);
+      });
+    } else {
+      if (!this.docShell || !this.docShell.contentViewer) {
+        aCallback(false);
+        return;
+      }
+      aCallback(this.docShell.contentViewer.inPermitUnload);
     }
-    aCallback(this.docShell.contentViewer.inPermitUnload);
   }
 
   permitUnload(aPermitUnloadFlags) {
+    if (this.isRemoteBrowser) {
+      let { tabParent } = this.frameLoader;
+
+      if (!tabParent.hasBeforeUnload) {
+        return { permitUnload: true, timedOut: false };
+      }
+
+      const kTimeout = 1000;
+
+      let finished = false;
+      let responded = false;
+      let permitUnload;
+      let id = this._permitUnloadId++;
+      let mm = this.messageManager;
+      let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
+
+      let msgListener = msg => {
+        if (msg.data.id != id) {
+          return;
+        }
+        if (msg.data.kind == "start") {
+          responded = true;
+          return;
+        }
+        done(msg.data.permitUnload);
+      };
+
+      let observer = subject => {
+        if (subject == mm) {
+          done(true);
+        }
+      };
+
+      function done(result) {
+        finished = true;
+        permitUnload = result;
+        mm.removeMessageListener("PermitUnload", msgListener);
+        Services.obs.removeObserver(observer, "message-manager-close");
+      }
+
+      mm.sendAsyncMessage("PermitUnload", { id, aPermitUnloadFlags });
+      mm.addMessageListener("PermitUnload", msgListener);
+      Services.obs.addObserver(observer, "message-manager-close");
+
+      let timedOut = false;
+
+      function timeout() {
+        if (!responded) {
+          timedOut = true;
+        }
+
+        // Dispatch something to ensure that the main thread wakes up.
+        Services.tm.dispatchToMainThread(function() {});
+      }
+
+      let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+      timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
+
+      while (!finished && !timedOut) {
+        Services.tm.currentThread.processNextEvent(true);
+      }
+
+      return { permitUnload, timedOut };
+    }
+
     if (!this.docShell || !this.docShell.contentViewer) {
       return { permitUnload: true, timedOut: false };
     }
     return {
       permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),
       timedOut: false
     };
   }
@@ -1221,16 +1703,33 @@ class MozBrowser extends XULFrameElement
         name: aLinks[i + 1],
         type: aLinks[i + 2],
       });
     }
     this.droppedLinkHandler(null, links, aTriggeringPrincipal);
     return true;
   }
 
+  // Remote browser specific methods:
+
+  enableDisableCommands(aAction, aEnabledLength, aEnabledCommands, aDisabledLength, aDisabledCommands) {
+    if (this._controller) {
+      this._controller.enableDisableCommands(aAction,
+        aEnabledLength, aEnabledCommands,
+        aDisabledLength, aDisabledCommands);
+    }
+  }
+
+  forceRepaint() {
+    let { frameLoader } = this;
+    if (frameLoader && frameLoader.tabParent) {
+      frameLoader.tabParent.forceRepaint();
+    }
+  }
+
   disconnectedCallback() {
     this.destroy();
   }
 
   _setupEventListeners() {
     this.addEventListener("keypress", (event) => {
       if (event.defaultPrevented || !event.isTrusted)
         return;
@@ -1319,570 +1818,28 @@ class MozBrowser extends XULFrameElement
         return;
       }
 
       if (links.length) {
         let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
         this.droppedLinkHandler(event, links, triggeringPrincipal);
       }
     });
-  }
-}
 
-class MozRemoteBrowser extends MozBrowser {
-  connectedCallback() {
-    super.connectedCallback()
-
-    this._securityUI = null;
-
-    this._controller = null;
-
-    this._selectParentHelper = null;
-
-    this._remoteWebNavigation = null;
-
-    this._remoteWebProgress = null;
-
-    this._remoteFinder = null;
-
-    this._documentURI = null;
-
-    this._documentContentType = null;
-
-    this._contentTitle = "";
-
-    this._characterSet = "";
-
-    this._mayEnableCharacterEncodingMenu = null;
-
-    this._contentWindow = null;
-
-    this._contentPrincipal = null;
-
-    this._contentRequestContextID = null;
-
-    this._contentDocument = null;
-
-    this._imageDocument = null;
-
-    this._fullZoom = 1;
-
-    this._textZoom = 1;
-
-    this._isSyntheticDocument = false;
-
-    this._outerWindowID = null;
-
-    this._innerWindowID = null;
-
-    this.mDestroyed = false;
-
-    this._permitUnloadId = 0;
-
-    /*
-     * Don't try to send messages from this function. The message manager for
-     * the <browser> element may not be initialized yet.
-     */
-
-    this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
-      .createInstance(Ci.nsIWebNavigation);
-    this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
-    this._remoteWebNavigationImpl.swapBrowser(this);
-
-    // Initialize contentPrincipal to the about:blank principal for this loadcontext
-    let { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
-    let aboutBlank = Services.io.newURI("about:blank");
-    let ssm = Services.scriptSecurityManager;
-    this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
-
-    this.messageManager.addMessageListener("Browser:Init", this);
-    this.messageManager.addMessageListener("DOMTitleChanged", this);
-    this.messageManager.addMessageListener("ImageDocumentLoaded", this);
-    this.messageManager.addMessageListener("FullZoomChange", this);
-    this.messageManager.addMessageListener("TextZoomChange", this);
-    this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
-    this.messageManager.addMessageListener("DOMFullscreen:RequestExit", this);
-    this.messageManager.addMessageListener("DOMFullscreen:RequestRollback", this);
-    this.messageManager.addMessageListener("MozApplicationManifest", this);
-
-    // browser-child messages, such as Content:LocationChange, are handled in
-    // RemoteWebProgress, ensure it is loaded and ready.
-    let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
-    let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
-    this._remoteWebProgressManager = new RemoteWebProgressManager(this);
-    this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
-
-    this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
-
-    if (this.hasAttribute("selectmenulist")) {
-      this.messageManager.addMessageListener("Forms:ShowDropDown", this);
-      this.messageManager.addMessageListener("Forms:HideDropDown", this);
-    }
-
-    if (!this.hasAttribute("disablehistory")) {
-      Services.obs.addObserver(this, "browser:purge-session-history", true);
-    }
-
-    let rc_js = "resource://gre/modules/RemoteController.js";
-    let scope = {};
-    Services.scriptloader.loadSubScript(rc_js, scope);
-    let RemoteController = scope.RemoteController;
-    this._controller = new RemoteController(this);
-    this.controllers.appendController(this._controller);
-
-    this._setupEventListeners();
-  }
-
-  get securityUI() {
-    if (!this._securityUI) {
-      // Don't attempt to create the remote web progress if the
-      // messageManager has already gone away
-      if (!this.messageManager)
-        return null;
-
-      let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
-      let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
-      this._securityUI = new RemoteSecurityUI();
-    }
-
-    // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
-    var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
-      .createInstance(Ci.nsISupportsInterfacePointer);
-    ptr.data = this._securityUI;
-    return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
-  }
-
-  get webNavigation() {
-    return this._remoteWebNavigation;
-  }
-
-  get webProgress() {
-    return this._remoteWebProgress;
-  }
-
-  get finder() {
-    if (!this._remoteFinder) {
-      // Don't attempt to create the remote finder if the
-      // messageManager has already gone away
-      if (!this.messageManager)
-        return null;
-
-      let jsm = "resource://gre/modules/RemoteFinder.jsm";
-      let { RemoteFinder } = ChromeUtils.import(jsm, {});
-      this._remoteFinder = new RemoteFinder(this);
-    }
-    return this._remoteFinder;
-  }
-
-  get documentURI() {
-    return this._documentURI;
-  }
-
-  get documentContentType() {
-    return this._documentContentType;
-  }
-
-  get contentTitle() {
-    return this._contentTitle
-  }
-
-  set characterSet(val) {
-    this.messageManager.sendAsyncMessage("UpdateCharacterSet", { value: val });
-    this._characterSet = val;
-  }
-
-  get characterSet() {
-    return this._characterSet
-  }
-
-  get mayEnableCharacterEncodingMenu() {
-    return this._mayEnableCharacterEncodingMenu;
-  }
-
-  get contentWindow() {
-    return null
-  }
-
-  get contentWindowAsCPOW() {
-    return this._contentWindow
-  }
-
-  get contentDocument() {
-    return null
-  }
-
-  get contentPrincipal() {
-    return this._contentPrincipal
-  }
-
-  get contentRequestContextID() {
-    return this._contentRequestContextID
-  }
-
-  get contentDocumentAsCPOW() {
-    return this._contentDocument
-  }
-
-  get imageDocument() {
-    return this._imageDocument
-  }
-
-  set fullZoom(val) {
-    let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
-
-    this._fullZoom = val;
-    try {
-      this.messageManager.sendAsyncMessage("FullZoom", { value: val });
-    } catch (ex) {}
-
-    if (changed) {
-      let event = new Event("FullZoomChange", { bubbles: true });
-      this.dispatchEvent(event);
-    }
-  }
-
-  get fullZoom() {
-    return this._fullZoom;
-  }
-
-  set textZoom(val) {
-    let changed = val.toFixed(2) != this._textZoom.toFixed(2);
-
-    this._textZoom = val;
-    try {
-      this.messageManager.sendAsyncMessage("TextZoom", { value: val });
-    } catch (ex) {}
-
-    if (changed) {
-      let event = new Event("TextZoomChange", { bubbles: true });
-      this.dispatchEvent(event);
-    }
-  }
-
-  get textZoom() {
-    return this._textZoom;
-  }
-
-  get isSyntheticDocument() {
-    return this._isSyntheticDocument;
-  }
-
-  get hasContentOpener() {
-    return this.frameLoader.tabParent.hasContentOpener;
-  }
-
-  get outerWindowID() {
-    return this._outerWindowID
-  }
-
-  get innerWindowID() {
-    return this._innerWindowID;
-  }
-
-  set docShellIsActive(val) {
-    this.frameLoader.tabParent.docShellIsActive = val;
-    return val;
-  }
-
-  get docShellIsActive() {
-    return this.frameLoader.tabParent.docShellIsActive;
-  }
-
-  set renderLayers(val) {
-    let { frameLoader } = this;
-    if (frameLoader && frameLoader.tabParent) {
-      return frameLoader.tabParent.renderLayers = val;
-    }
-    return false;
-  }
-
-  get renderLayers() {
-    let { frameLoader } = this;
-    if (frameLoader && frameLoader.tabParent) {
-      return frameLoader.tabParent.renderLayers;
-    }
-    return false;
-  }
-
-  get hasLayers() {
-    let { frameLoader } = this;
-    if (frameLoader.tabParent) {
-      return frameLoader.tabParent.hasLayers;
-    }
-    return false;
-  }
-
-  /**
-   * Used by session restore to ensure that currentURI is set so
-   * that switch-to-tab works before the tab is fully
-   * restored. This function also invokes onLocationChanged
-   * listeners in tabbrowser.xml.
-   */
-  _setCurrentURI(aURI) {
-    this._remoteWebProgressManager.setCurrentURI(aURI);
-  }
-
-  preserveLayers(preserve) {
-    let { frameLoader } = this;
-    if (frameLoader.tabParent) {
-      frameLoader.tabParent.preserveLayers(preserve);
-    }
-  }
-
-  forceRepaint() {
-    let { frameLoader } = this;
-    if (frameLoader && frameLoader.tabParent) {
-      frameLoader.tabParent.forceRepaint();
-    }
-  }
-
-  getInPermitUnload(aCallback) {
-    let id = this._permitUnloadId++;
-    let mm = this.messageManager;
-    mm.sendAsyncMessage("InPermitUnload", { id });
-    mm.addMessageListener("InPermitUnload", function listener(msg) {
-      if (msg.data.id != id) {
-        return;
-      }
-      aCallback(msg.data.inPermitUnload);
-    });
-  }
-
-  permitUnload(aPermitUnloadFlags) {
-    let { tabParent } = this.frameLoader;
-
-    if (!tabParent.hasBeforeUnload) {
-      return { permitUnload: true, timedOut: false };
-    }
-
-    const kTimeout = 1000;
-
-    let finished = false;
-    let responded = false;
-    let permitUnload;
-    let id = this._permitUnloadId++;
-    let mm = this.messageManager;
-    let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-
-    let msgListener = msg => {
-      if (msg.data.id != id) {
-        return;
-      }
-      if (msg.data.kind == "start") {
-        responded = true;
-        return;
-      }
-      done(msg.data.permitUnload);
-    };
-
-    let observer = subject => {
-      if (subject == mm) {
-        done(true);
-      }
-    };
-
-    function done(result) {
-      finished = true;
-      permitUnload = result;
-      mm.removeMessageListener("PermitUnload", msgListener);
-      Services.obs.removeObserver(observer, "message-manager-close");
-    }
-
-    mm.sendAsyncMessage("PermitUnload", { id, aPermitUnloadFlags });
-    mm.addMessageListener("PermitUnload", msgListener);
-    Services.obs.addObserver(observer, "message-manager-close");
-
-    let timedOut = false;
-
-    function timeout() {
-      if (!responded) {
-        timedOut = true;
-      }
-
-      // Dispatch something to ensure that the main thread wakes up.
-      Services.tm.dispatchToMainThread(function() {});
-    }
-
-    let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-    timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
-
-    while (!finished && !timedOut) {
-      Services.tm.currentThread.processNextEvent(true);
-    }
-
-    return { permitUnload, timedOut };
-  }
-
-  /**
-   * This is necessary because the destructor doesn't always get called when
-   * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
-   *
-   * Note: This overrides the destroy() method from browser.xml.
-   */
-  destroy() {
-    // Make sure that any open select is closed.
-    if (this._selectParentHelper) {
-      let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-      this._selectParentHelper.hide(menulist, this);
-    }
-
-    if (this.mDestroyed)
-      return;
-    this.mDestroyed = true;
-
-    try {
-      this.controllers.removeController(this._controller);
-    } catch (ex) {
-      // This can fail when this browser element is not attached to a
-      // BrowserDOMWindow.
-    }
-
-    if (!this.hasAttribute("disablehistory")) {
-      let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-      try {
-        Services.obs.removeObserver(this, "browser:purge-session-history");
-      } catch (ex) {
-        // It's not clear why this sometimes throws an exception.
-      }
-    }
-  }
-
-  receiveMessage(aMessage) {
-    let data = aMessage.data;
-    switch (aMessage.name) {
-      case "Browser:Init":
-        this._outerWindowID = data.outerWindowID;
-        break;
-      case "DOMTitleChanged":
-        this._contentTitle = data.title;
-        break;
-      case "ImageDocumentLoaded":
-        this._imageDocument = {
-          width: data.width,
-          height: data.height
-        };
-        break;
-
-      case "Forms:ShowDropDown":
-        {
-          if (!this._selectParentHelper) {
-            this._selectParentHelper =
-              ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
-          }
-
-          let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-          menulist.menupopup.style.direction = data.direction;
-
-          let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
-            this.isSyntheticDocument ? this._fullZoom : this._textZoom;
-          this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
-            zoom, data.uaBackgroundColor, data.uaColor,
-            data.uaSelectBackgroundColor, data.uaSelectColor,
-            data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
-          this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
-          break;
-        }
-
-      case "FullZoomChange":
-        {
-          this._fullZoom = data.value;
-          let event = document.createEvent("Events");
-          event.initEvent("FullZoomChange", true, false);
-          this.dispatchEvent(event);
-          break;
-        }
-
-      case "TextZoomChange":
-        {
-          this._textZoom = data.value;
-          let event = document.createEvent("Events");
-          event.initEvent("TextZoomChange", true, false);
-          this.dispatchEvent(event);
-          break;
-        }
-
-      case "ZoomChangeUsingMouseWheel":
-        {
-          let event = document.createEvent("Events");
-          event.initEvent("ZoomChangeUsingMouseWheel", true, false);
-          this.dispatchEvent(event);
-          break;
-        }
-
-      case "DOMFullscreen:RequestExit":
-        {
-          let windowUtils = window.windowUtils;
-          windowUtils.exitFullscreen();
-          break;
-        }
-
-      case "DOMFullscreen:RequestRollback":
-        {
-          let windowUtils = window.windowUtils;
-          windowUtils.remoteFrameFullscreenReverted();
-          break;
-        }
-
-      case "MozApplicationManifest":
-        this._manifestURI = aMessage.data.manifest;
-        break;
-
-      default:
-        // Delegate to browser.xml.
-        return this._receiveMessage(aMessage);
-    }
-    return undefined;
-  }
-
-  enableDisableCommands(aAction, aEnabledLength, aEnabledCommands, aDisabledLength, aDisabledCommands) {
-    if (this._controller) {
-      this._controller.enableDisableCommands(aAction,
-        aEnabledLength, aEnabledCommands,
-        aDisabledLength, aDisabledCommands);
-    }
-  }
-
-  purgeSessionHistory() {
-    try {
-      this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
-    } catch (ex) {
-      // This can throw if the browser has started to go away.
-      if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
-        throw ex;
-      }
-    }
-    this._remoteWebNavigationImpl.canGoBack = false;
-    this._remoteWebNavigationImpl.canGoForward = false;
-  }
-
-  createAboutBlankContentViewer(aPrincipal) {
-    // Ensure that the content process has the permissions which are
-    // needed to create a document with the given principal.
-    let permissionPrincipal =
-      BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
-    this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
-
-    // Create the about blank content viewer in the content process
-    this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
-  }
-
-  disconnectedCallback() {
-    this.destroy();
-  }
-
-  _setupEventListeners() {
     this.addEventListener("dragstart", (event) => {
       // If we're a remote browser dealing with a dragstart, stop it
       // from propagating up, since our content process should be dealing
       // with the mouse movement.
-      event.stopPropagation();
+      if (this.isRemoteBrowser) {
+        event.stopPropagation();
+      }
     });
   }
 }
 
-// customElements.define("browser", MozBrowser);
-// MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIBrowser, Ci.nsIObserver]);
+customElements.define("browser", MozBrowser);
+MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIBrowser, Ci.nsIObserver]);
 
 // customElements.define("remote-browser", MozRemoteBrowser,
 //   { extends: "browser" });
 // MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIBrowser, Ci.nsIRemoteBrowser, Ci.nsIObserver]);
 
 }
