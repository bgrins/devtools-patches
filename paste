# HG changeset patch
# Parent 50a2220b70bf0d9eb6a57cd86daae7f6af8ef834
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 913630 - [rule view] Pasting in multiple CSS declarations should automatically split them up;r=pbrosset

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -532,21 +532,31 @@ Rule.prototype = {
    * Create a new TextProperty to include in the rule.
    *
    * @param {string} aName
    *        The text property name (such as "background" or "border-top").
    * @param {string} aValue
    *        The property's value (not including priority).
    * @param {string} aPriority
    *        The property's priority (either "important" or an empty string).
+   * @param {TextProperty} aSiblingProp
+   *        Optional, property next to which the new property will be added.
    */
-  createProperty: function Rule_createProperty(aName, aValue, aPriority)
+  createProperty: function Rule_createProperty(aName, aValue, aPriority, aSiblingProp)
   {
     let prop = new TextProperty(this, aName, aValue, aPriority);
-    this.textProps.push(prop);
+
+    if (aSiblingProp) {
+      let ind = this.textProps.indexOf(aSiblingProp);
+      this.textProps.splice(ind + 1, 0, prop);
+    }
+    else {
+      this.textProps.push(prop);
+    }
+
     this.applyProperties();
     return prop;
   },
 
   /**
    * Reapply all the properties in this rule, and update their
    * computed styles.  Store disabled properties in the element
    * style's store.  Will re-mark overridden properties.
@@ -589,17 +599,17 @@ Rule.prototype = {
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
     let promise = aModifications.apply().then(() => {
       let cssProps = {};
-      for (let cssProp of this._parseCSSText(this.style.cssText)) {
+      for (let cssProp of parseCSSText(this.style.cssText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
         if (!textProp.enabled) {
           continue;
         }
         let cssProp = cssProps[textProp.name];
@@ -696,45 +706,25 @@ Rule.prototype = {
     this.textProps = this.textProps.filter(function(prop) prop != aProperty);
     let modifications = this.style.startModifyingProperties();
     modifications.removeProperty(aProperty.name);
     // Need to re-apply properties in case removing this TextProperty
     // exposes another one.
     this.applyProperties(modifications);
   },
 
-  _parseCSSText: function Rule_parseProperties(aCssText)
-  {
-    let lines = aCssText.match(CSS_LINE_RE);
-    let props = [];
-
-    for (let line of lines) {
-      let [, name, value, priority] = CSS_PROP_RE.exec(line) || [];
-      if (!name || !value) {
-        continue;
-      }
-
-      props.push({
-        name: name,
-        value: value,
-        priority: priority || ""
-      });
-    }
-    return props;
-  },
-
   /**
    * Get the list of TextProperties from the style.  Needs
    * to parse the style's cssText.
    */
   _getTextProperties: function Rule_getTextProperties()
   {
     let textProps = [];
     let store = this.elementStyle.store;
-    let props = this._parseCSSText(this.style.cssText);
+    let props = parseCSSText(this.style.cssText);
     for (let prop of props) {
       let name = prop.name;
       if (this.inherited && !domUtils.isInheritedProperty(name)) {
         continue;
       }
       let value = store.userProperties.getProperty(this.style, name, prop.value);
       let textProp = new TextProperty(this, name, value, prop.priority);
       textProps.push(textProp);
@@ -1725,19 +1715,19 @@ RuleEditor.prototype = {
 
     this.closeBrace = createChild(code, "div", {
       class: "ruleview-ruleclose",
       tabindex: "0",
       textContent: "}"
     });
 
     // Create a property editor when the close brace is clicked.
-    editableItem({ element: this.closeBrace }, function(aElement) {
+    editableItem({ element: this.closeBrace }, (aElement) => {
       this.newProperty();
-    }.bind(this));
+    });
   },
 
   updateSourceLink: function RuleEditor_updateSourceLink()
   {
     let sourceLabel = this.element.querySelector(".source-link-label");
     sourceLabel.setAttribute("value", this.rule.title);
     sourceLabel.setAttribute("tooltiptext", this.rule.title);
 
@@ -1798,28 +1788,73 @@ RuleEditor.prototype = {
    * Programatically add a new property to the rule.
    *
    * @param {string} aName
    *        Property name.
    * @param {string} aValue
    *        Property value.
    * @param {string} aPriority
    *        Property priority.
+   * @param {TextProperty} aSiblingProp
+   *        Optional, property next to which the new property will be added.
    * @return {TextProperty}
    *        The new property
    */
-  addProperty: function RuleEditor_addProperty(aName, aValue, aPriority)
+  addProperty: function RuleEditor_addProperty(aName, aValue, aPriority, aSiblingProp)
   {
-    let prop = this.rule.createProperty(aName, aValue, aPriority);
+    let prop = this.rule.createProperty(aName, aValue, aPriority, aSiblingProp);
+    let index = this.rule.textProps.indexOf(prop);
     let editor = new TextPropertyEditor(this, prop);
-    this.propertyList.appendChild(editor.element);
+
+    // Insert this node before the DOM node that is currently at its new index
+    // in the property list.  There is currently one less node in the DOM than
+    // in the property list, so this causes it to appear after aSiblingProp.
+    // If there is no node at its index, as is the case where this is the last
+    // node being inserted, then this behaves as appendChild.
+    this.propertyList.insertBefore(editor.element,
+      this.propertyList.children[index]);
+
     return prop;
   },
 
   /**
+   * Programatically add a list of new properties to the rule.  Focus the UI
+   * to the proper location after adding (either focus the value on the
+   * last property if it is empty, or create a new property and focus it).
+   *
+   * @param {Array} aProperties
+   *        Array of properties, which are objects with this signature:
+   *        {
+   *          name: {string},
+   *          value: {string},
+   *          priority: {string}
+   *        }
+   * @param {TextProperty} aSiblingProp
+   *        Optional, the property next to which all new props should be added.
+   */
+  addProperties: function RuleEditor_addProperties(aProperties, aSiblingProp)
+  {
+    if (!aProperties || !aProperties.length) {
+      return;
+    }
+
+    let lastProp = aSiblingProp;
+    for (let p of aProperties) {
+      lastProp = this.addProperty(p.name, p.value, p.priority, lastProp);
+    }
+
+    // Either focus on the last value if incomplete, or start a new one.
+    if (lastProp && lastProp.value.trim() === "") {
+      lastProp.editor.valueSpan.click();
+    } else {
+      this.newProperty();
+    }
+  },
+
+  /**
    * Create a text input for a property name.  If a non-empty property
    * name is given, we'll create a real TextProperty and add it to the
    * rule.
    */
   newProperty: function RuleEditor_newProperty()
   {
     // If we're already creating a new property, ignore this.
     if (!this.closeBrace.hasAttribute("tabindex")) {
@@ -1835,59 +1870,81 @@ RuleEditor.prototype = {
       class: "ruleview-property ruleview-newproperty",
     });
 
     this.newPropSpan = createChild(this.newPropItem, "span", {
       class: "ruleview-propertyname",
       tabindex: "0"
     });
 
-    new InplaceEditor({
+    this.multipleAddedProperties = null;
+
+    this.editor = new InplaceEditor({
       element: this.newPropSpan,
       done: this._onNewProperty,
       destroy: this._newPropertyDestroy,
       advanceChars: ":",
       contentType: InplaceEditor.CONTENT_TYPES.CSS_PROPERTY,
       popup: this.ruleView.popup
     });
+
+    // Auto-close the input if multiple rules get pasted into new property.
+    this.editor.input.addEventListener("paste",
+      blurOnMultipleProperties, false);
   },
 
   /**
    * Called when the new property input has been dismissed.
-   * Will create a new TextProperty if necessary.
    *
    * @param {string} aValue
    *        The value in the editor.
    * @param {bool} aCommit
    *        True if the value should be committed.
    */
   _onNewProperty: function RuleEditor__onNewProperty(aValue, aCommit)
   {
     if (!aValue || !aCommit) {
       return;
     }
 
-    // Create an empty-valued property and start editing it.
-    let prop = this.rule.createProperty(aValue, "", "");
-    let editor = new TextPropertyEditor(this, prop);
-    this.propertyList.appendChild(editor.element);
-    editor.valueSpan.click();
+    // Deal with adding declarations later (once editor has been destroyed).
+    // If aValue is just a name, will make a new property with empty value.
+    this.multipleAddedProperties = parseCSSText(aValue);
+    if (!this.multipleAddedProperties.length) {
+      this.multipleAddedProperties = [{
+        name: aValue,
+        value: "",
+        priority: ""
+      }];
+    }
+
+    this.editor.input.blur();
   },
 
   /**
    * Called when the new property editor is destroyed.
+   * This is where the properties (type TextProperty) are actually being
+   * added, since we want to wait until after the inplace editor `destroy`
+   * event has been fired to keep consistent UI state.
    */
   _newPropertyDestroy: function RuleEditor__newPropertyDestroy()
   {
     // We're done, make the close brace focusable again.
     this.closeBrace.setAttribute("tabindex", "0");
 
     this.propertyList.removeChild(this.newPropItem);
     delete this.newPropItem;
     delete this.newPropSpan;
+
+    // If properties were added, we want to focus the proper element.
+    // If the last new property has no value, focus the value on it.
+    // Otherwise, start a new property and focus that field.
+    if (this.multipleAddedProperties && this.multipleAddedProperties.length) {
+      this.addProperties(this.multipleAddedProperties);
+    }
   }
 };
 
 /**
  * Create a TextPropertyEditor.
  *
  * @param {RuleEditor} aRuleEditor
  *        The rule editor that owns this TextPropertyEditor.
@@ -1911,17 +1968,18 @@ function TextPropertyEditor(aRuleEditor,
     this.sheetURI = IOService.newURI(href, null, null);
   }
 
   this._onEnableClicked = this._onEnableClicked.bind(this);
   this._onExpandClicked = this._onExpandClicked.bind(this);
   this._onStartEditing = this._onStartEditing.bind(this);
   this._onNameDone = this._onNameDone.bind(this);
   this._onValueDone = this._onValueDone.bind(this);
-  this._onValidate = throttle(this._livePreview, 10, this, this.browserWindow);
+  this._onValidate = throttle(this._livePreview, 10, this);
+  this.update = this.update.bind(this);
 
   this._create();
   this.update();
 }
 
 TextPropertyEditor.prototype = {
   /**
    * Boolean indicating if the name or value is being currently edited.
@@ -1969,22 +2027,26 @@ TextPropertyEditor.prototype = {
       class: "ruleview-propertyname theme-fg-color5",
       tabindex: "0",
     });
 
     editableField({
       start: this._onStartEditing,
       element: this.nameSpan,
       done: this._onNameDone,
-      destroy: this.update.bind(this),
+      destroy: this.update,
       advanceChars: ':',
       contentType: InplaceEditor.CONTENT_TYPES.CSS_PROPERTY,
       popup: this.popup
     });
 
+    // Auto blur name field on multiple CSS rules get pasted in.
+    this.nameContainer.addEventListener("paste",
+      blurOnMultipleProperties, false);
+
     appendText(this.nameContainer, ": ");
 
     // Create a span that will hold the property and semicolon.
     // Use this span to create a slightly larger click target
     // for the value.
     let propertyContainer = createChild(this.element, "span", {
       class: "ruleview-propertycontainer"
     });
@@ -2039,17 +2101,17 @@ TextPropertyEditor.prototype = {
     this.computed = createChild(this.element, "ul", {
       class: "ruleview-computedlist",
     });
 
     editableField({
       start: this._onStartEditing,
       element: this.valueSpan,
       done: this._onValueDone,
-      destroy: this.update.bind(this),
+      destroy: this.update,
       validate: this._onValidate,
       advanceChars: ';',
       contentType: InplaceEditor.CONTENT_TYPES.CSS_VALUE,
       property: this.prop,
       popup: this.popup
     });
   },
 
@@ -2257,40 +2319,37 @@ TextPropertyEditor.prototype = {
    * @param {string} aValue
    *        The value contained in the editor.
    * @param {boolean} aCommit
    *        True if the change should be applied.
    */
   _onNameDone: function TextPropertyEditor_onNameDone(aValue, aCommit)
   {
     if (aCommit) {
+      // Unlike the value editor, if a name is empty the entire property
+      // should always be removed.
       if (aValue.trim() === "") {
         this.remove();
       } else {
-        this.prop.setName(aValue);
+
+        // Adding multiple rules inside of name field overwrites the current
+        // property with the first, then adds any more onto the property list.
+        let properties = parseCSSText(aValue);
+        if (properties.length > 0) {
+          this.prop.setName(properties[0].name);
+          this.prop.setValue(properties[0].value, properties[0].priority);
+
+          this.ruleEditor.addProperties(properties.slice(1), this.prop);
+        } else {
+          this.prop.setName(aValue);
+        }
       }
     }
   },
 
-  /**
-   * Pull priority (!important) out of the value provided by a
-   * value editor.
-   *
-   * @param {string} aValue
-   *        The value from the text editor.
-   * @return {object} an object with 'value' and 'priority' properties.
-   */
-  _parseValue: function TextPropertyEditor_parseValue(aValue)
-  {
-    let pieces = aValue.split("!", 2);
-    return {
-      value: pieces[0].trim(),
-      priority: (pieces.length > 1 ? pieces[1].trim() : "")
-    };
-  },
 
   /**
    * Remove property from style and the editors from DOM.
    * Begin editing next available property.
    */
   remove: function TextPropertyEditor_remove()
   {
     if (this._swatchSpans && this._swatchSpans.length) {
@@ -2311,34 +2370,107 @@ TextPropertyEditor.prototype = {
    *
    * @param {string} aValue
    *        The value contained in the editor.
    * @param {bool} aCommit
    *        True if the change should be applied.
    */
    _onValueDone: function PropertyEditor_onValueDone(aValue, aCommit)
   {
-    if (aCommit) {
-      this._applyNewValue(aValue);
-    } else {
-      // A new property should be removed when escape is pressed.
-      if (this.removeOnRevert) {
-        this.remove();
-      } else {
-        // We use this.valueSpan.textContent instead of this.committed.value
-        // because otherwise pressing escape to revert a color value will result
-        // in an unparsed property value.
-        this.prop.setValue(this.valueSpan.textContent, this.committed.priority);
-      }
+    if (!aCommit) {
+       // A new property should be removed when escape is pressed.
+       if (this.removeOnRevert) {
+         this.remove();
+       } else {
+         this.prop.setValue(this.committed.value, this.committed.priority);
+       }
+       return;
+    }
+
+    let {propertiesToAdd,firstValue} = this._getValueAndExtraProperties(aValue);
+
+    // First, set this property value (common case, only modified a property)
+    let val = parseCSSValue(firstValue);
+    this.prop.setValue(val.value, val.priority);
+    this.removeOnRevert = false;
+    this.committed.value = this.prop.value;
+    this.committed.priority = this.prop.priority;
+
+    // If needed, add any new properties after this.prop.
+    this.ruleEditor.addProperties(propertiesToAdd, this.prop);
+
+    // If the name or value is not actively being edited, and the value is
+    // empty, then remove the whole property.
+    // A timeout is used here to accurately check the state, since the inplace
+    // editor `done` and `destroy` events fire before the next editor
+    // is focused.
+    if (val.value.trim() === "") {
+      setTimeout(() => {
+        if (!this.editing) {
+          this.remove();
+        }
+      }, 0);
     }
   },
 
+  /**
+   * Parse a value string and break it into pieces, starting with the
+   * first value, and into an array of additional properties (if any).
+   *
+   * Example: Calling with "red; width: 100px" would return
+   * { firstValue: "red", propertiesToAdd: [{ name: "width", value: "100px" }] }
+   *
+   * @param {string} aValue
+   *        The string to parse
+   * @return {object} An object with the following properties:
+   *        firstValue: A string containing a simple value, like
+   *                    "red" or "100px!important"
+   *        propertiesToAdd: An array with additional properties, following the
+   *                         parseCSSText format of {name,value,priority}
+   */
+  _getValueAndExtraProperties: function PropetyEditor_getValueAndExtraProperties(aValue) {
+
+    // The inplace editor will prevent manual typing of multiple properties,
+    // but we need to deal with the case during a paste event.
+    // Adding multiple properties inside of value editor sets value with the
+    // first, then adds any more onto the property list (below this property).
+    let properties = parseCSSText(aValue);
+    let propertiesToAdd = [];
+    let firstValue = aValue;
+
+    if (properties.length > 0) {
+      // If text like "red; width: 1px;" was entered in, handle this as two
+      // separate properties (setting value here to red and adding a new prop).
+      let propertiesNoName = parseCSSText("a:" + aValue);
+      let enteredValueFirst = propertiesNoName.length > properties.length;
+
+      let firstProp = properties[0];
+      propertiesToAdd = properties.slice(1);
+
+      if (enteredValueFirst) {
+        firstProp = propertiesNoName[0];
+        propertiesToAdd = propertiesNoName.slice(1);
+      }
+
+      // If "red; width: 1px", then set value to "red"
+      // If "color: red; width: 1px;", then set value to "color: red;"
+      firstValue = enteredValueFirst ?
+        firstProp.value + "!" + firstProp.priority :
+        firstProp.name + ": " + firstProp.value + "!" + firstProp.priority;
+    }
+
+    return {
+      propertiesToAdd: propertiesToAdd,
+      firstValue: firstValue
+    };
+  },
+
   _applyNewValue: function PropetyEditor_applyNewValue(aValue)
   {
-    let val = this._parseValue(aValue);
+    let val = parseCSSValue(aValue);
     // Any property should be removed if has an empty value.
     if (val.value.trim() === "") {
       this.remove();
     } else {
       this.prop.setValue(val.value, val.priority);
       this.removeOnRevert = false;
       this.committed.value = this.prop.value;
       this.committed.priority = this.prop.priority;
@@ -2353,17 +2485,17 @@ TextPropertyEditor.prototype = {
    */
   _livePreview: function TextPropertyEditor_livePreview(aValue)
   {
     // Since function call is throttled, we need to make sure we are still editing
     if (!this.editing) {
       return;
     }
 
-    let val = this._parseValue(aValue);
+    let val = parseCSSValue(aValue);
 
     // Live previewing the change without committing just yet, that'll be done in _onValueDone
     // If it was not a valid value, apply an empty string to reset the live preview
     this.ruleEditor.rule.setPropertyValue(this.prop, val.value, val.priority);
   },
 
   /**
    * Validate this property. Does it make sense for this value to be assigned
@@ -2374,17 +2506,17 @@ TextPropertyEditor.prototype = {
    *        Defaults to the current value for this.prop
    *
    * @return {bool} true if the property value is valid, false otherwise.
    */
   isValid: function TextPropertyEditor_isValid(aValue)
   {
     let name = this.prop.name;
     let value = typeof aValue == "undefined" ? this.prop.value : aValue;
-    let val = this._parseValue(value);
+    let val = parseCSSValue(value);
 
     let style = this.doc.createElementNS(HTML_NS, "div").style;
     let prefs = Services.prefs;
 
     // We toggle output of errors whilst the user is typing a property value.
     let prefVal = prefs.getBoolPref("layout.css.report_errors");
     prefs.setBoolPref("layout.css.report_errors", false);
 
@@ -2519,31 +2651,108 @@ function createMenuItem(aMenu, aAttribut
   item.setAttribute("accesskey", _strings.GetStringFromName(aAttributes.accesskey));
   item.addEventListener("command", aAttributes.command);
 
   aMenu.appendChild(item);
 
   return item;
 }
 
-
-function throttle(func, wait, scope, window) {
+function setTimeout()
+{
+  let window = Services.appShell.hiddenDOMWindow;
+  return window.setTimeout.apply(window, arguments);
+}
+
+function clearTimeout()
+{
+  let window = Services.appShell.hiddenDOMWindow;
+  return window.clearTimeout.apply(window, arguments);
+}
+
+function throttle(func, wait, scope)
+{
   var timer = null;
   return function() {
     if(timer) {
-      window.clearTimeout(timer);
+      clearTimeout(timer);
     }
     var args = arguments;
-    timer = window.setTimeout(function() {
+    timer = setTimeout(function() {
       timer = null;
       func.apply(scope, args);
     }, wait);
   };
 }
 
+/**
+ * Pull priority (!important) out of the value provided by a
+ * value editor.
+ *
+ * @param {string} aValue
+ *        The value from the text editor.
+ * @return {object} an object with 'value' and 'priority' properties.
+ */
+function parseCSSValue(aValue)
+{
+  let pieces = aValue.split("!", 2);
+  return {
+    value: pieces[0].trim(),
+    priority: (pieces.length > 1 ? pieces[1].trim() : "")
+  };
+}
+
+/**
+ * Return an array of CSS properties given an input string
+ * For example, parseCSSText("width: 1px; height: 1px") would return
+ * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
+ *
+ * @param {string} aCssText
+ *        An input string of CSS
+ * @return {Array} an array of objects with the following signature:
+ *         [{"name": string, "value": string, "priority": string}, ...]
+ */
+function parseCSSText(aCssText)
+{
+  let lines = aCssText.match(CSS_LINE_RE);
+  let props = [];
+
+  [].forEach.call(lines, (line, i) => {
+    let [, name, value, priority] = CSS_PROP_RE.exec(line) || [];
+
+    // If this is ending with an unfinished line, add it onto the end
+    // with an empty value
+    if (!name && line && i > 0) {
+      name = line;
+    }
+
+    if (name) {
+      props.push({
+        name: name.trim(),
+        value: value || "",
+        priority: priority || ""
+      });
+    }
+  });
+
+  return props;
+}
+
+/**
+ * Event handler that causes a blur on the target if the input has
+ * multiple CSS properties as the value.
+ */
+function blurOnMultipleProperties(e)
+{
+  setTimeout(() => {
+    if (parseCSSText(e.target.value).length) {
+      e.target.blur();
+    }
+  }, 0);
+}
 
 /**
  * Append a text node to an element.
  */
 function appendText(aParent, aText)
 {
   aParent.appendChild(aParent.ownerDocument.createTextNode(aText));
 }
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -14,16 +14,17 @@ skip-if = true # awaiting promise-based 
 [browser_csslogic_inherited.js]
 [browser_ruleview_734259_style_editor_link.js]
 [browser_ruleview_editor.js]
 [browser_ruleview_editor_changedvalues.js]
 [browser_ruleview_copy.js]
 [browser_ruleview_focus.js]
 [browser_ruleview_inherit.js]
 [browser_ruleview_manipulation.js]
+[browser_ruleview_multiple_properties.js]
 [browser_ruleview_override.js]
 [browser_ruleview_ui.js]
 [browser_ruleview_update.js]
 [browser_ruleview_livepreview.js]
 [browser_bug705707_is_content_stylesheet.js]
 support-files =
   browser_bug705707_is_content_stylesheet.html
   browser_bug705707_is_content_stylesheet_imported.css
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js b/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js
@@ -16,16 +16,17 @@ let originalValue = "#00F";
 //  value: what char sequence to type,
 //  commitKey: what key to type to "commit" the change,
 //  modifiers: commitKey modifiers,
 //  expected: what value is expected as a result
 // }
 let testData = [
   {value: "red", commitKey: "VK_ESCAPE", modifiers: {}, expected: originalValue},
   {value: "red", commitKey: "VK_RETURN", modifiers: {}, expected: "#F00"},
+  {value: "invalid", commitKey: "VK_RETURN", modifiers: {}, expected: "invalid"},
   {value: "blue", commitKey: "VK_TAB", modifiers: {shiftKey: true}, expected: "blue"}
 ];
 
 function startTests()
 {
   let style = '' +
     '#testid {' +
     '  color: ' + originalValue + ';' +
@@ -54,21 +55,32 @@ function runTestData(index)
   let idRuleEditor = ruleView.element.children[1]._ruleEditor;
   let propEditor = idRuleEditor.rule.textProps[0].editor;
   waitForEditorFocus(propEditor.element, function(aEditor) {
     is(inplaceEditor(propEditor.valueSpan), aEditor, "Focused editor should be the value span.");
 
     for (let ch of testData[index].value) {
       EventUtils.sendChar(ch, ruleWindow);
     }
-    EventUtils.synthesizeKey(testData[index].commitKey, testData[index].modifiers);
 
-    is(propEditor.valueSpan.textContent, testData[index].expected);
-
-    runTestData(index + 1);
+    // Need to wait for the change to be finished before the next test starts
+    // if not cancelling the change (the previous modification can change which
+    // color format is shown).
+    if (testData[index].commitKey === "VK_ESCAPE") {
+      EventUtils.synthesizeKey(testData[index].commitKey, testData[index].modifiers);
+      is(propEditor.valueSpan.textContent, testData[index].expected, "Value is same as expected: " + testData[index].expected);
+      runTestData(index + 1);
+    } else {
+      ruleView.element.addEventListener("CssRuleViewChanged", function nextTest() {
+        ruleView.element.removeEventListener("CssRuleViewChanged", nextTest);
+        is(propEditor.valueSpan.textContent, testData[index].expected, "Value is same as expected: " + testData[index].expected);
+        runTestData(index + 1);
+      });
+      EventUtils.synthesizeKey(testData[index].commitKey, testData[index].modifiers);
+    }
   });
 
   EventUtils.synthesizeMouse(propEditor.valueSpan, 1, 1, {}, ruleWindow);
 }
 
 function finishTest()
 {
   inspector = ruleWindow = ruleView = null;
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties.js b/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties.js
@@ -0,0 +1,274 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+let doc;
+let ruleWindow;
+let ruleView;
+let inspector;
+let elementRuleEditor;
+
+function startTest()
+{
+  doc.body.innerHTML = '<h1>Testing Multiple Properties</h1>';
+
+  openRuleView((aInspector, aRuleView) => {
+    inspector = aInspector;
+    ruleView = aRuleView;
+    ruleWindow = aRuleView.doc.defaultView;
+    selectNewElement().then(testCreateNewMulti);
+  });
+}
+
+/*
+ * Add a new node to the DOM and resolve the promise once it is ready to use
+ */
+function selectNewElement()
+{
+  let newElement = doc.createElement("div");
+  newElement.textContent = "Test Element";
+  doc.body.appendChild(newElement);
+  inspector.selection.setNode(newElement);
+  let def = promise.defer();
+  ruleView.element.addEventListener("CssRuleViewRefreshed", function changed() {
+    ruleView.element.removeEventListener("CssRuleViewRefreshed", changed);
+    elementRuleEditor = ruleView.element.children[0]._ruleEditor;
+    def.resolve();
+  });
+  return def.promise;
+}
+
+/*
+ * Begin the creation of a new property, resolving after the editor
+ * has been created.
+ */
+function beginNewProp()
+{
+  let def = promise.defer();
+  waitForEditorFocus(elementRuleEditor.element, function onNewElement(aEditor) {
+
+    is(inplaceEditor(elementRuleEditor.newPropSpan), aEditor, "Next focused editor should be the new property editor.");
+    is(elementRuleEditor.rule.textProps.length,  0, "Should be starting with one new text property.");
+    is(elementRuleEditor.propertyList.children.length, 1, "Should be starting with two property editors.");
+
+    def.resolve(aEditor);
+  });
+  elementRuleEditor.closeBrace.scrollIntoView();
+  EventUtils.synthesizeMouse(elementRuleEditor.closeBrace, 1, 1,
+                             { },
+                             ruleWindow);
+  return def.promise;
+}
+
+/*
+ * Fully create a new property, given some text input
+ */
+function createNewProp(inputValue)
+{
+  let def = promise.defer();
+  beginNewProp().then((aEditor)=>{
+    aEditor.input.value = inputValue;
+
+    waitForEditorFocus(elementRuleEditor.element, function onNewValue(aEditor) {
+      promiseDone(expectRuleChange(elementRuleEditor.rule).then(() => {
+        def.resolve();
+      }));
+    });
+
+    EventUtils.synthesizeKey("VK_RETURN", {}, ruleWindow);
+  });
+
+  return def.promise;
+}
+
+function testCreateNewMulti()
+{
+  createNewProp(
+    "color:blue;background : orange   ; text-align:center; border-color: green;"
+  ).then(()=>{
+    is(elementRuleEditor.rule.textProps.length, 4, "Should have created a new text property.");
+    is(elementRuleEditor.propertyList.children.length, 5, "Should have created a new property editor.");
+
+    is(elementRuleEditor.rule.textProps[0].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[0].value, "blue", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[1].name, "background", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[1].value, "orange", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[2].name, "text-align", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[2].value, "center", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[3].name, "border-color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[3].value, "green", "Should have correct property value");
+
+    selectNewElement().then(testCreateNewMultiDuplicates);
+  });
+}
+
+function testCreateNewMultiDuplicates()
+{
+  createNewProp(
+    "color:red;color:orange;color:yellow;color:green;color:blue;color:indigo;color:violet;"
+  ).then(()=>{
+    is(elementRuleEditor.rule.textProps.length, 7, "Should have created new text properties.");
+    is(elementRuleEditor.propertyList.children.length, 8, "Should have created new property editors.");
+
+    is(elementRuleEditor.rule.textProps[0].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[0].value, "red", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[1].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[1].value, "orange", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[2].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[2].value, "yellow", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[3].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[3].value, "green", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[4].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[4].value, "blue", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[5].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[5].value, "indigo", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[6].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[6].value, "violet", "Should have correct property value");
+
+    selectNewElement().then(testCreateNewMultiPriority);
+  });
+}
+
+function testCreateNewMultiPriority()
+{
+  createNewProp(
+    "color:red;width:100px;height: 100px;"
+  ).then(()=>{
+    is(elementRuleEditor.rule.textProps.length, 3, "Should have created new text properties.");
+    is(elementRuleEditor.propertyList.children.length, 4, "Should have created new property editors.");
+
+    is(elementRuleEditor.rule.textProps[0].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[0].value, "red", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[1].name, "width", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[1].value, "100px", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[2].name, "height", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[2].value, "100px", "Should have correct property value");
+
+    selectNewElement().then(testCreateNewMultiUnfinished);
+  });
+}
+
+function testCreateNewMultiUnfinished()
+{
+  createNewProp(
+    "color:blue;background : orange   ; text-align:center; border-color: "
+  ).then(()=>{
+    is(elementRuleEditor.rule.textProps.length, 4, "Should have created new text properties.");
+    is(elementRuleEditor.propertyList.children.length, 4, "Should have created property editors.");
+
+    for (let ch of "red") {
+      EventUtils.sendChar(ch, ruleWindow);
+    }
+    EventUtils.synthesizeKey("VK_RETURN", {}, ruleWindow);
+
+    is(elementRuleEditor.rule.textProps.length, 4, "Should have the same number of text properties.");
+    is(elementRuleEditor.propertyList.children.length, 5, "Should have added the changed value editor.");
+
+    is(elementRuleEditor.rule.textProps[0].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[0].value, "blue", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[1].name, "background", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[1].value, "orange", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[2].name, "text-align", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[2].value, "center", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[3].name, "border-color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[3].value, "red", "Should have correct property value");
+
+    selectNewElement().then(testCreateNewMultiPartialUnfinished);
+  });
+}
+
+
+function testCreateNewMultiPartialUnfinished()
+{
+  createNewProp(
+    "width: 100px; heig"
+  ).then(()=>{
+    is(elementRuleEditor.rule.textProps.length, 2, "Should have created a new text property.");
+    is(elementRuleEditor.propertyList.children.length, 2, "Should have created a property editor.");
+
+    // Value is focused, lets add multiple rules here and make sure they get added
+    let valueEditor = elementRuleEditor.propertyList.children[1].querySelector("input");
+    valueEditor.value = "10px;background:orangered;color: black;";
+    EventUtils.synthesizeKey("VK_RETURN", {}, ruleWindow);
+
+    is(elementRuleEditor.rule.textProps.length, 4, "Should have added the changed value.");
+    is(elementRuleEditor.propertyList.children.length, 5, "Should have added the changed value editor.");
+
+    is(elementRuleEditor.rule.textProps[0].name, "width", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[0].value, "100px", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[1].name, "heig", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[1].value, "10px", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[2].name, "background", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[2].value, "orangered", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[3].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[3].value, "black", "Should have correct property value");
+
+    selectNewElement().then(testMultiValues);
+  });
+}
+
+function testMultiValues()
+{
+  createNewProp(
+    "width:"
+  ).then(()=>{
+    is(elementRuleEditor.rule.textProps.length, 1, "Should have created a new text property.");
+    is(elementRuleEditor.propertyList.children.length, 1, "Should have created a property editor.");
+
+    // Value is focused, lets add multiple rules here and make sure they get added
+    let valueEditor = elementRuleEditor.propertyList.children[0].querySelector("input");
+    valueEditor.value = "height: 10px;color:blue"
+    EventUtils.synthesizeKey("VK_RETURN", {}, ruleWindow);
+
+    is(elementRuleEditor.rule.textProps.length, 2, "Should have added the changed value.");
+    is(elementRuleEditor.propertyList.children.length, 3, "Should have added the changed value editor.");
+
+    EventUtils.synthesizeKey("VK_ESCAPE", {}, ruleWindow);
+    is(elementRuleEditor.propertyList.children.length, 2, "Should have removed the value editor.");
+
+    is(elementRuleEditor.rule.textProps[0].name, "width", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[0].value, "height: 10px", "Should have correct property value");
+
+    is(elementRuleEditor.rule.textProps[1].name, "color", "Should have correct property name");
+    is(elementRuleEditor.rule.textProps[1].value, "blue", "Should have correct property value");
+
+    finishTest();
+  });
+}
+
+function finishTest()
+{
+  inspector = ruleWindow = ruleView = doc = elementRuleEditor = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function test()
+{
+  waitForExplicitFinish();
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function changedValues_load(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, changedValues_load, true);
+    doc = content.document;
+    waitForFocus(startTest, content);
+  }, true);
+
+  content.location = "data:text/html,test rule view user changes";
+}
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_ui.js b/browser/devtools/styleinspector/test/browser_ruleview_ui.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_ui.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_ui.js
@@ -50,19 +50,44 @@ function testCancelNew()
 
   let elementRuleEditor = ruleView.element.children[0]._ruleEditor;
   waitForEditorFocus(elementRuleEditor.element, function onNewElement(aEditor) {
     is(inplaceEditor(elementRuleEditor.newPropSpan), aEditor, "Next focused editor should be the new property editor.");
     waitForEditorBlur(aEditor, function () {
       ok(!elementRuleEditor.rule._applyingModifications, "Shouldn't have an outstanding modification request after a cancel.");
       is(elementRuleEditor.rule.textProps.length,  0, "Should have canceled creating a new text property.");
       ok(!elementRuleEditor.propertyList.hasChildNodes(), "Should not have any properties.");
+      testCancelNewOnEscape();
+    });
+    aEditor.input.blur();
+  });
+
+  EventUtils.synthesizeMouse(elementRuleEditor.closeBrace, 1, 1,
+                             { },
+                             ruleWindow);
+}
+
+function testCancelNewOnEscape()
+{
+  // Start at the beginning: start to add a rule to the element's style
+  // declaration, add some text, then press escape.
+
+  let elementRuleEditor = ruleView.element.children[0]._ruleEditor;
+  waitForEditorFocus(elementRuleEditor.element, function onNewElement(aEditor) {
+    is(inplaceEditor(elementRuleEditor.newPropSpan), aEditor, "Next focused editor should be the new property editor.");
+    for (let ch of "background") {
+      EventUtils.sendChar(ch, ruleWindow);
+    }
+    waitForEditorBlur(aEditor, function () {
+      ok(!elementRuleEditor.rule._applyingModifications, "Shouldn't have an outstanding modification request after a cancel.");
+      is(elementRuleEditor.rule.textProps.length,  0, "Should have canceled creating a new text property.");
+      ok(!elementRuleEditor.propertyList.hasChildNodes(), "Should not have any properties.");
       testCreateNew();
     });
-    aEditor.input.blur();
+    EventUtils.synthesizeKey("VK_ESCAPE", { });
   });
 
   EventUtils.synthesizeMouse(elementRuleEditor.closeBrace, 1, 1,
                              { },
                              ruleWindow);
 }
 
 function testCreateNew()
