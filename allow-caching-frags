# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  adc32d869e58d0c052094f718bc9e4cff8390be4
Cache parseXULToFragment results for future use

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -192,16 +192,17 @@ window.addEventListener("DOMContentLoade
     } catch (ex) { console.error(ex); }
     element.isRunningDelayedConnectedCallback = false;
   }
   gElementsPendingConnection.clear();
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
+const gXULDOMFragmentCache = {};
 
 MozElements.MozElementMixin = Base => {
   let MozElementBase = class extends Base {
   constructor() {
     super();
 
     if (instrumentClasses) {
       let proto = this.constructor;
@@ -426,35 +427,44 @@ MozElements.MozElementMixin = Base => {
    * get XBL attached. After that point, even if the node is inserted into a
    * document, it won't get XBL attached until either the frame is constructed or
    * the reflector is garbage collected and the element is touched again.
    *
    * @param {string} str
    *        String with the XML representation of XUL elements.
    * @param {string[]} [entities]
    *        An array of DTD URLs containing entity definitions.
+   * @param {bool} cache
+   *        Store and retrieve this for future use.
    *
    * @return {DocumentFragment} `DocumentFragment` instance containing
    *         the corresponding element tree, including element nodes
    *         but excluding any text node.
    */
-  static parseXULToFragment(str, entities = []) {
-    let doc = gXULDOMParser.parseFromString(`
+  static parseXULToFragment(str, entities, cache = true) {
+    entities = entities || [];
+    let markup = `
       ${entities.length ? `<!DOCTYPE bindings [
         ${entities.reduce((preamble, url, index) => {
           return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}">
             %_dtd-${index};
             `;
         }, "")}
       ]>` : ""}
       <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-           xmlns:html="http://www.w3.org/1999/xhtml">
+          xmlns:html="http://www.w3.org/1999/xhtml">
         ${str}
       </box>
-    `, "application/xml");
+    `;
+
+    if (gXULDOMFragmentCache[markup]) {
+      return gXULDOMFragmentCache[markup].cloneNode(true);
+    }
+
+    let doc = gXULDOMParser.parseFromString(markup, "application/xml");
     // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
     // does not do this. Most XUL code assumes that the whitespace has been
     // stripped out, so we simply remove all text nodes after using the parser.
     let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
     let currentNode = nodeIterator.nextNode();
     while (currentNode) {
       // Remove whitespace-only nodes. Regex is taken from:
       // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace_in_the_DOM
@@ -463,19 +473,26 @@ MozElements.MozElementMixin = Base => {
       }
 
       currentNode = nodeIterator.nextNode();
     }
     // We use a range here so that we don't access the inner DOM elements from
     // JavaScript before they are imported and inserted into a document.
     let range = doc.createRange();
     range.selectNodeContents(doc.querySelector("box"));
-    return range.extractContents();
+    let frag = range.extractContents();
+
+    if (cache) {
+      gXULDOMFragmentCache[markup] = frag;
+    }
+
+    return frag.cloneNode(true);
   }
 
+
   /**
    * Insert a localization link to an FTL file. This is used so that
    * a Custom Element can wait to inject the link until it's connected,
    * and so that consuming documents don't require the correct <link>
    * present in the markup.
    *
    * @param path
    *        The path to the FTL file
