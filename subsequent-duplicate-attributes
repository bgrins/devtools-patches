# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  05fc78055eaaf79ac10b4912cf5f1878e54a3b45
Bug 1147734 - Overwrite subsequent duplicate attribute mutations

diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1143,16 +1143,17 @@ var WalkerActor = protocol.ActorClass({
    */
   initialize: function(conn, tabActor, options) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
+    this._pendingAttributeChanges = {};
     this._activePseudoClassLocks = new Set();
     this.showAllAnonymousContent = options.showAllAnonymousContent;
 
     this.layoutHelpers = new LayoutHelpers(this.rootWin);
 
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
@@ -1198,16 +1199,17 @@ var WalkerActor = protocol.ActorClass({
   },
 
   destroy: function() {
     try {
       this._destroyed = true;
 
       this.clearPseudoClassLocks();
       this._activePseudoClassLocks = null;
+      this._pendingAttributeChanges = null;
 
       this._hoveredNode = null;
       this.rootDoc = null;
 
       this.reflowObserver.off("reflows", this._onReflows);
       this.reflowObserver = null;
       releaseLayoutChangesObserver(this.tabActor);
 
@@ -2391,49 +2393,28 @@ var WalkerActor = protocol.ActorClass({
    * Keep in mind that if a node that the client hasn't seen is moved
    * into or out of the target node, it will not be included in the
    * removedNodes and addedNodes list, so if the client is interested
    * in the new set of children it needs to issue a `children` request.
    */
   getMutations: method(function(options={}) {
     let pending = this._pendingMutations || [];
     this._pendingMutations = [];
+    this._pendingAttributeChanges = {};
 
     if (options.cleanup) {
       for (let node of this._orphaned) {
         // Release the orphaned node.  Nodes or children that have been
         // retained will be moved to this._retainedOrphans.
         this.releaseNode(node);
       }
       this._orphaned = new Set();
     }
 
-
-    // Clear out any duplicate attribute mutations before sending them over
-    // the protocol.  Keep only the most recent change for each attribute.
-    let targetMap = {};
-    let filtered = pending.reverse().filter(mutation => {
-      if (mutation.type === "attributes") {
-        if (!targetMap[mutation.target]) {
-          targetMap[mutation.target] = {};
-        }
-        let attributesForTarget = targetMap[mutation.target];
-
-        if (attributesForTarget[mutation.attributeName]) {
-          // Since the array was reversed, if we've seen this attribute already
-          // then this one is a duplicate and can be skipped.
-          return false;
-        }
-
-        attributesForTarget[mutation.attributeName] = true;
-      }
-      return true;
-    }).reverse();
-
-    return filtered;
+    return pending.filter(mutation=>mutation);
   }, {
     request: {
       cleanup: Option(0)
     },
     response: {
       mutations: RetVal("array:dommutation")
     }
   }),
@@ -2444,16 +2425,28 @@ var WalkerActor = protocol.ActorClass({
       return;
     }
     // We only send the `new-mutations` notification once, until the client
     // fetches mutations with the `getMutations` packet.
     let needEvent = this._pendingMutations.length === 0;
 
     this._pendingMutations.push(mutation);
 
+    if (mutation.type === "attributes") {
+      // Null out any irrelevant mutations in the queue.
+      let id = mutation.target + "-" + mutation.attributeName;
+      let oldIndex = this._pendingAttributeChanges[id];
+      if (this._pendingMutations[oldIndex]) {
+        this._pendingMutations[oldIndex] = null;
+      }
+
+      // Remember this one so it can be nulled out later if necessary.
+      this._pendingAttributeChanges[id] = this._pendingMutations.length - 1;
+    }
+
     if (needEvent) {
       events.emit(this, "new-mutations");
     }
   },
 
   /**
    * Handles mutations from the DOM mutation observer API.
    *
diff --git a/toolkit/devtools/server/tests/mochitest/test_inspector-mutations-attr.html b/toolkit/devtools/server/tests/mochitest/test_inspector-mutations-attr.html
--- a/toolkit/devtools/server/tests/mochitest/test_inspector-mutations-attr.html
+++ b/toolkit/devtools/server/tests/mochitest/test_inspector-mutations-attr.html
@@ -115,16 +115,17 @@ function testQueuedMutations() {
   attrNode.removeAttribute("data-newattr");
   attrNode.setAttribute("data-newattr", "1");
   attrNode.removeAttribute("data-newattr");
   attrNode.setAttribute("data-newattr", "2");
   attrNode.removeAttribute("data-newattr");
 
   for (var i = 0; i <= 1000; i++) {
     attrNode.setAttribute("data-newattr2", i);
+    attrNode.setAttribute("data-newattr3", i);
   }
 
   attrNode.removeAttribute("data-newattr3");
   attrNode.setAttribute("data-newattr3", "1");
   attrNode.removeAttribute("data-newattr3");
   attrNode.setAttribute("data-newattr3", "2");
   attrNode.removeAttribute("data-newattr3");
   attrNode.setAttribute("data-newattr3", "3");
