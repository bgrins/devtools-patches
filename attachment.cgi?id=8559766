# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  e31a48f67a62d7e7f4a387108be705b1a575338d
Bug 1123851 - 1 - Element geometry highlighter

diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -52,17 +52,17 @@
 :-moz-native-anonymous .box-model-margin {
   stroke: none;
 }
 
 :-moz-native-anonymous .box-model-guide-top,
 :-moz-native-anonymous .box-model-guide-right,
 :-moz-native-anonymous .box-model-guide-bottom,
 :-moz-native-anonymous .box-model-guide-left {
-  stroke: #08C;
+  stroke: #08c;
   stroke-dasharray: 5 3;
   shape-rendering: crispEdges;
 }
 
 /* Highlighter - Node Infobar */
 
 :-moz-native-anonymous .box-model-nodeinfobar-container {
   position: absolute;
@@ -161,20 +161,90 @@
 :-moz-native-anonymous .css-transform-untransformed {
   fill: #66cc52;
   opacity: 0.8;
 }
 
 :-moz-native-anonymous .css-transform-transformed,
 :-moz-native-anonymous .css-transform-untransformed,
 :-moz-native-anonymous .css-transform-line {
-  stroke: #08C;
+  stroke: #08c;
   stroke-dasharray: 5 3;
   stroke-width: 2;
 }
 
 /* Rect highlighter */
 
 :-moz-native-anonymous .highlighted-rect {
   position: absolute;
   background: #80d4ff;
   opacity: 0.8;
 }
+
+/* Element transformer */
+
+:-moz-native-anonymous .geometry-editor-arrow {
+  position: absolute;
+  background: #08c;
+}
+
+:-moz-native-anonymous .geometry-editor-label {
+  background: white;
+  font: message-box;
+  font-size: 10px;
+  color: #08c;
+  padding: 2px;
+  border-radius: 2px;
+  position: absolute;
+}
+
+:-moz-native-anonymous .geometry-editor-label.left,
+:-moz-native-anonymous .geometry-editor-label.width,
+:-moz-native-anonymous .geometry-editor-label.right {
+  top: 4px;
+}
+
+:-moz-native-anonymous .geometry-editor-label.top,
+:-moz-native-anonymous .geometry-editor-label.height,
+:-moz-native-anonymous .geometry-editor-label.bottom {
+  left: 4px;
+}
+
+:-moz-native-anonymous .geometry-editor-label.bottom {
+  bottom: 0;
+}
+
+:-moz-native-anonymous .geometry-editor-label.right {
+  right: 0;
+}
+
+:-moz-native-anonymous .geometry-editor-handle {
+  position: absolute;
+  width: 10px;
+  height: 10px;
+}
+
+:-moz-native-anonymous .geometry-editor-handle::before {
+  content: "";
+
+  display: block;
+  /* Make the handle::before as big as its container but offset by 50% so its
+     centered on the element's edge */
+  position: relative;
+  top: -50%;
+  left: -50%;
+  width: 100%;
+  height: 100%;
+  border-radius: 2px;
+  background: #08c;
+}
+
+:-moz-native-anonymous .geometry-editor-handle.height,
+:-moz-native-anonymous .geometry-editor-arrow:not([invert]) .geometry-editor-handle.top,
+:-moz-native-anonymous .geometry-editor-arrow:not([invert]) .geometry-editor-handle.bottom {
+  top: 100%;
+}
+
+:-moz-native-anonymous .geometry-editor-handle.width,
+:-moz-native-anonymous .geometry-editor-arrow:not([invert]) .geometry-editor-handle.left,
+:-moz-native-anonymous .geometry-editor-arrow:not([invert]) .geometry-editor-handle.right {
+  left: 100%;
+}
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -39,16 +39,18 @@ const MAX_HIGHLIGHTED_ELEMENTS = 100;
 const HIGHLIGHTED_PSEUDO_CLASS = ":-moz-devtools-highlighted";
 const SIMPLE_OUTLINE_SHEET = ".__fx-devtools-hide-shortcut__ {" +
                              "  visibility: hidden !important" +
                              "}" +
                              HIGHLIGHTED_PSEUDO_CLASS + " {" +
                              "  outline: 2px dashed #F06!important;" +
                              "  outline-offset: -2px!important;" +
                              "}";
+// Distance of the width or height handles from the node's edge.
+const SIZE_ARROW_OFFSET = .25; // 25%
 
 /**
  * The registration mechanism for highlighters provide a quick way to
  * have modular highlighters, instead of a hard coded list.
  * It allow us to split highlighers in sub modules, and add them dynamically
  * using add-on (useful for 3rd party developers, or prototyping)
  *
  * Note that currently, highlighters added using add-ons, can only work on
@@ -270,44 +272,27 @@ let HighlighterActor = exports.Highlight
 
     let x = event.clientX;
     let y = event.clientY;
 
     let node = doc.elementFromPoint(x, y);
     return this._walker.attachElement(node);
   },
 
-  /**
-   * Get the right target for listening to mouse events while in pick mode.
-   * - On a firefox desktop content page: tabActor is a BrowserTabActor from
-   *   which the browser property will give us a target we can use to listen to
-   *   events, even in nested iframes.
-   * - On B2G: tabActor is a ContentActor which doesn't have a browser but
-   *   since it overrides BrowserTabActor, it does get a browser property
-   *   anyway, which points to its window object.
-   * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
-   *   the RootActor, in which case, the window property can be used to listen
-   *   to events
-   */
-  _getPickerListenerTarget: function() {
-    let actor = this._tabActor;
-    return actor.isRootActor ? actor.window : actor.chromeEventHandler;
-  },
-
   _startPickerListeners: function() {
-    let target = this._getPickerListenerTarget();
+    let target = getPageListenerTarget(this._tabActor);
     target.addEventListener("mousemove", this._onHovered, true);
     target.addEventListener("click", this._onPick, true);
     target.addEventListener("mousedown", this._preventContentEvent, true);
     target.addEventListener("mouseup", this._preventContentEvent, true);
     target.addEventListener("dblclick", this._preventContentEvent, true);
   },
 
   _stopPickerListeners: function() {
-    let target = this._getPickerListenerTarget();
+    let target = getPageListenerTarget(this._tabActor);
     target.removeEventListener("mousemove", this._onHovered, true);
     target.removeEventListener("click", this._onPick, true);
     target.removeEventListener("mousedown", this._preventContentEvent, true);
     target.removeEventListener("mouseup", this._preventContentEvent, true);
     target.removeEventListener("dblclick", this._preventContentEvent, true);
   },
 
   _highlighterReady: function() {
@@ -727,17 +712,17 @@ AutoRefreshHighlighter.prototype = {
   },
 
   _hide: function() {
     // To be implemented by sub classes
     // When called, sub classes should actually hide the highlighter
   },
 
   _startRefreshLoop: function() {
-    let win = this.currentNode.ownerDocument.defaultView;
+    let win = getWindow(this.currentNode);
     this.rafID = win.requestAnimationFrame(this._startRefreshLoop.bind(this));
     this.rafWin = win;
     this.update();
   },
 
   _stopRefreshLoop: function() {
     if (this.rafID && !Cu.isDeadWrapper(this.rafWin)) {
       this.rafWin.cancelAnimationFrame(this.rafID);
@@ -1012,17 +997,17 @@ BoxModelHighlighter.prototype = Heritage
   },
 
   /**
    * Track the current node markup mutations so that the node info bar can be
    * updated to reflects the node's attributes
    */
   _trackMutations: function() {
     if (isNodeValid(this.currentNode)) {
-      let win = this.currentNode.ownerDocument.defaultView;
+      let win = getWindow(this.currentNode);
       this.currentNodeObserver = new win.MutationObserver(this.update);
       this.currentNodeObserver.observe(this.currentNode, {attributes: true});
     }
   },
 
   _untrackMutations: function() {
     if (isNodeValid(this.currentNode) && this.currentNodeObserver) {
       this.currentNodeObserver.disconnect();
@@ -1152,17 +1137,17 @@ BoxModelHighlighter.prototype = Heritage
     let hasNoQuads = !this.currentQuads.margin &&
                      !this.currentQuads.border &&
                      !this.currentQuads.padding &&
                      !this.currentQuads.content;
     if (!this.currentNode ||
         Cu.isDeadWrapper(this.currentNode) ||
         this.currentNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE ||
         !this.currentNode.ownerDocument ||
-        !this.currentNode.ownerDocument.defaultView ||
+        !getWindow(this.currentNode) ||
         hasNoQuads) {
       return false;
     }
 
     if (!this._computedStyle) {
       this._computedStyle = CssLogic.getComputedStyle(this.currentNode);
     }
 
@@ -1750,16 +1735,392 @@ RectHighlighter.prototype = {
   hide: function() {
     this.markup.setAttributeForElement("highlighted-rect", "hidden", "true");
   }
 };
 register(RectHighlighter);
 exports.RectHighlighter = RectHighlighter;
 
 /**
+ * Element geometry properties helper that gives names of position and size
+ * properties.
+ */
+let GeoProp = {
+  SIDES: ["top", "right", "bottom", "left"],
+  SIZES: ["width", "height"],
+
+  allProps: function() {
+    return [...this.SIDES, ...this.SIZES];
+  },
+
+  isSide: function(name) {
+    return this.SIDES.indexOf(name) !== -1;
+  },
+
+  isSize: function(name) {
+    return this.SIZES.indexOf(name) !== -1;
+  },
+
+  isHorizontal: function(name) {
+    return name === "left" || name === "right" || name === "width";
+  },
+
+  isInverted: function(name) {
+    return name === "right" || name === "bottom";
+  },
+
+  mainAxisStart: function(name) {
+    return this.isHorizontal(name) ? "left" : "top";
+  },
+
+  crossAxisStart: function(name) {
+    return this.isHorizontal(name) ? "top" : "left";
+  },
+
+  mainAxisSize: function(name) {
+    return this.isHorizontal(name) ? "width" : "height";
+  },
+
+  crossAxisSize: function(name) {
+    return this.isHorizontal(name) ? "height" : "width";
+  }
+};
+
+/**
+ * The GeometryEditor highlights an elements's top, left, bottom, right, width
+ * and height dimensions, when they are set.
+ *
+ * To determine if an element has a set size and position, the highlighter lists
+ * the CSS rules that apply to the element and checks for the top, left, bottom,
+ * right, width and height properties.
+ * The highlighter won't be shown if the element doesn't have any of these
+ * properties set, but will be shown when at least 1 property is defined.
+ *
+ * The highlighter displays lines and labels for each of the defined properties
+ * in and around the element (relative to the offset parent when one exists).
+ * The highlighter also highlights the element itself and its offset parent if
+ * there is one.
+ *
+ * Note that the class name contains the word Editor because the aim is for the
+ * handles to be draggable in content to make the geometry editable.
+ */
+function GeometryEditorHighlighter(tabActor) {
+  AutoRefreshHighlighter.call(this, tabActor);
+
+  // The list of element geometry properties that can be set.
+  this.definedProperties = new Map();
+
+  // The offsetParent highlighters highlights the node's offsetParent in case
+  // the current node has one.
+  this.offsetParentNodeHighlighter = new BoxModelHighlighter(tabActor);
+  // Make only the guides visible.
+  this.offsetParentNodeHighlighter.regionFill.padding = "transparent";
+
+  // Used to highlight the current node.
+  this.nodeHighlighter = new BoxModelHighlighter(tabActor);
+
+  this.markup = new CanvasFrameAnonymousContentHelper(tabActor,
+    this._buildMarkup.bind(this));
+}
+
+GeometryEditorHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
+  typeName: "GeometryEditorHighlighter",
+
+  ID_CLASS_PREFIX: "geometry-editor-",
+
+  _buildMarkup: function() {
+    let container = createNode(this.win, {
+      attributes: {"class": "highlighter-container"}
+    });
+
+    let root = createNode(this.win, {
+      parent: container,
+      attributes: {
+        "id": "root",
+        "class": "root"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
+    // Build the 6 side/size arrows, labels and handles.
+    for (let name of GeoProp.allProps()) {
+      let arrow = createNode(this.win, {
+        parent: root,
+        attributes: {
+          "id": "arrow-" + name,
+          "class": "arrow " + name,
+          "hidden": true
+        },
+        prefix: this.ID_CLASS_PREFIX
+      });
+
+      createNode(this.win, {
+        parent: arrow,
+        attributes: {
+          "id": "handle-" + name,
+          "class": "handle " + name
+        },
+        prefix: this.ID_CLASS_PREFIX
+      });
+
+      createNode(this.win, {
+        parent: arrow,
+        nodeType: "span",
+        attributes: {
+          "id": "label-" + name,
+          "class": "label " + name
+        },
+        prefix: this.ID_CLASS_PREFIX
+      });
+    }
+
+    return container;
+  },
+
+  destroy: function() {
+    AutoRefreshHighlighter.prototype.destroy.call(this);
+
+    this.nodeHighlighter.destroy();
+    this.offsetParentNodeHighlighter.destroy();
+    this.markup.destroy();
+    this.definedProperties.clear();
+    this.definedProperties = null;
+    this.offsetParent = null;
+  },
+
+  /**
+   * Get the list of geometry properties that are actually set on the current
+   * node.
+   * @return {Map} A map indexed by property name and where the value is an
+   * object having the cssRule property.
+   */
+  getDefinedGeometryProperties: function() {
+    let props = new Map();
+    if (!this.currentNode) {
+      return props;
+    }
+
+    // Get the list of css rules applying to the current node.
+    let cssRules = DOMUtils.getCSSStyleRules(this.currentNode);
+    for (let i = 0; i < cssRules.Count(); i++) {
+      let rule = cssRules.GetElementAt(i);
+      for (let name of GeoProp.allProps()) {
+        let value = rule.style.getPropertyValue(name);
+        if (value && value !== "auto") {
+          // getCSSStyleRules returns rules ordered from least-specific to
+          // most-specific, so just override any previous properties we have set.
+          props.set(name, {
+            cssRule: rule
+          });
+        }
+      }
+    }
+
+    // Go through the inline styles last.
+    for (let name of GeoProp.allProps()) {
+      let value = this.currentNode.style.getPropertyValue(name);
+      if (value && value !== "auto") {
+        props.set(name, {
+          // There's no cssRule to store here, so store the node instead since
+          // node.style exists.
+          cssRule: this.currentNode
+        });
+      }
+    }
+
+    return props;
+  },
+
+  _show: function() {
+    let hasUpdated = this._update();
+    if (!hasUpdated) {
+      this.hide();
+      return;
+    }
+
+    // Highlight the node itself.
+    this.nodeHighlighter.show(this.currentNode, {
+      hideInfoBar: true,
+      hideGuides: true
+    });
+  },
+
+  _update: function() {
+    // At each update, the position or/and size may have changed, so here, we
+    // get the list of defined properties, get their values, and re-position the
+    // arrows.
+    this.definedProperties.clear();
+    this.definedProperties = this.getDefinedGeometryProperties();
+    if (!this.definedProperties.size) {
+      console.warn("The element does not have editable geometry properties");
+      return false;
+    }
+
+    // Get the offsetParent, if any.
+    this.offsetParent = getOffsetParent(this.currentNode);
+
+    this.showArrows();
+    // Avoid zooming the arrows when content is zoomed.
+    this.markup.scaleRootElement(this.currentNode, this.ID_CLASS_PREFIX + "root");
+
+    // If the node is fixed or absolute positioned and has a positioned
+    // offsetParent, highlight the offsetParent.
+    let isPositioned = ["absolute", "fixed"].indexOf(
+      CssLogic.getComputedStyle(this.currentNode).position) !== -1;
+
+    if (this.offsetParent.element && isPositioned) {
+      this.offsetParentNodeHighlighter.show(this.offsetParent.element, {
+        hideInfoBar: true,
+        region: "padding",
+        showOnly: "padding"
+      });
+    } else {
+      this.offsetParentNodeHighlighter.hide();
+    }
+
+    return true;
+  },
+
+  _hide: function() {
+    setIgnoreLayoutChanges(true);
+
+    // Hide the node and its offsetParent.
+    this.nodeHighlighter.hide();
+    this.offsetParentNodeHighlighter.hide();
+
+    // And hide the arrows.
+    this.hideArrows();
+
+    this.definedProperties.clear();
+
+    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+  },
+
+  hideArrows: function() {
+    for (let side of GeoProp.allProps()) {
+      let id = this.ID_CLASS_PREFIX + "arrow-" + side;
+      this.markup.removeAttributeForElement(id, "invert");
+      this.markup.setAttributeForElement(id, "hidden", "true");
+    }
+  },
+
+  showArrows: function() {
+    setIgnoreLayoutChanges(true);
+    let id = this.ID_CLASS_PREFIX;
+
+    this.hideArrows();
+
+    let parentQuads = this.layoutHelpers
+                          .getAdjustedQuads(this.offsetParent.element, "padding");
+    let marginBounds = this.currentQuads.margin.bounds;
+    let paddingBounds = this.currentQuads.padding.bounds;
+
+    // Position the side arrows which need to be visible.
+    // Arrows always start at the offsetParent edge, and end at the middle
+    // position of the node's margin edge.
+    // Note that for relative positioning, the offsetParent is considered to be
+    // the node itself, where it would have been originally.
+    // +------------------+----------------+
+    // | offsetparent     | top            |
+    // | or viewport      |                |
+    // |         +--------o--------+       |
+    // |         | node            |       |
+    // +---------o                 o-------+
+    // | left    |                 | right |
+    // |         +--------o--------+       |
+    // |                  | bottom         |
+    // +------------------+----------------+
+    let getSideArrowStartPos = side => {
+      if (parentQuads) {
+        return parentQuads.bounds[side];
+      }
+
+      if (GeoProp.isInverted(side)) {
+        return this.offsetParent.dimension[GeoProp.mainAxisSize(side)];
+      } else {
+        return 0;
+      }
+    };
+
+    for (let side of GeoProp.SIDES) {
+      let sideProp = this.definedProperties.get(side);
+      if (!sideProp) {
+        continue;
+      }
+
+      let mainAxisStartPos = getSideArrowStartPos(side);
+      let mainAxisEndPos = marginBounds[side];
+      if (GeoProp.isInverted(side)) {
+        let tmp = mainAxisStartPos;
+        mainAxisStartPos = mainAxisEndPos;
+        mainAxisEndPos = tmp;
+      }
+      let crossAxisPos = marginBounds[GeoProp.crossAxisStart(side)] +
+                         marginBounds[GeoProp.crossAxisSize(side)] / 2;
+
+      // Build the inline style string to position the arrow.
+      let style = GeoProp.mainAxisStart(side) + ":" + mainAxisStartPos + "px;" +
+                  GeoProp.mainAxisSize(side) + ":" + (mainAxisEndPos - mainAxisStartPos) + "px;" +
+                  GeoProp.crossAxisStart(side) + ":" + crossAxisPos + "px;" +
+                  GeoProp.crossAxisSize(side) + ":1px;";
+
+      this.markup.setAttributeForElement(id + "arrow-" + side, "style", style);
+      if (GeoProp.isInverted(side)) {
+        this.markup.setAttributeForElement(id + "arrow-" + side, "invert", "true");
+      }
+      this.markup.removeAttributeForElement(id + "arrow-" + side, "hidden");
+      this.markup.setTextContentForElement(id + "label-" + side,
+        sideProp.cssRule.style.getPropertyValue(side));
+    }
+
+    // Position and show the width/height arrows.
+    // Arrows are displayed within the element's padding box and are positioned
+    // closer to the top/left corner (see SIZE_ARROW_OFFSET) to avoid being
+    // aligned with the other, side, arrows.
+    // +---+---------------+
+    // |   |   width arrow |
+    // +---+---------------o
+    // |   |               |
+    // |   | height        |
+    // |   | arrow         |
+    // |   |               |
+    // |   |          node |
+    // +---o---------------+
+    for (let dim of GeoProp.SIZES) {
+      let sizeProp = this.definedProperties.get(dim);
+      if (!sizeProp) {
+        continue
+      }
+
+      let mainAxisStartPos = paddingBounds[GeoProp.mainAxisStart(dim)];
+      let mainAxisSize = paddingBounds[GeoProp.mainAxisSize(dim)];
+      let crossAxisPos = GeoProp.isHorizontal(dim)
+                         ? paddingBounds.top + paddingBounds.height * SIZE_ARROW_OFFSET
+                         : paddingBounds.left + paddingBounds.width * SIZE_ARROW_OFFSET;
+
+      // Build the inline style string to position the arrow.
+      let arrowStyle = GeoProp.mainAxisStart(dim) + ":" + mainAxisStartPos + "px;" +
+                       GeoProp.mainAxisSize(dim) + ":" + mainAxisSize + "px;" +
+                       GeoProp.crossAxisStart(dim) + ":" + crossAxisPos + "px;" +
+                       GeoProp.crossAxisSize(dim) + ":1px;";
+      let handleStyle = GeoProp.mainAxisStart(dim) + ":" + mainAxisSize + "px";
+
+      this.markup.setAttributeForElement(id + "arrow-" + dim, "style", arrowStyle);
+      this.markup.removeAttributeForElement(id + "arrow-" + dim, "hidden");
+      this.markup.setTextContentForElement(id + "label-" + dim,
+        sizeProp.cssRule.style.getPropertyValue(dim));
+    }
+
+    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+  }
+});
+register(GeometryEditorHighlighter);
+exports.GeometryEditorHighlighter = GeometryEditorHighlighter;
+
+/**
  * The SimpleOutlineHighlighter is a class that has the same API than the
  * BoxModelHighlighter, but adds a pseudo-class on the target element itself
  * to draw a simple css outline around the element.
  * It is used by the HighlighterActor when canvasframe-based highlighters can't
  * be used. This is the case for XUL windows.
  */
 function SimpleOutlineHighlighter(tabActor) {
   this.chromeDoc = tabActor.window.document;
@@ -1777,17 +2138,17 @@ SimpleOutlineHighlighter.prototype = {
   /**
    * Show the highlighter on a given node
    * @param {DOMNode} node
    */
   show: function(node) {
     if (!this.currentNode || node !== this.currentNode) {
       this.hide();
       this.currentNode = node;
-      installHelperSheet(node.ownerDocument.defaultView, SIMPLE_OUTLINE_SHEET);
+      installHelperSheet(getWindow(node), SIMPLE_OUTLINE_SHEET);
       DOMUtils.addPseudoClassLock(node, HIGHLIGHTED_PSEUDO_CLASS);
     }
   },
 
   /**
    * Hide the highlighter, the outline and the infobar.
    */
   hide: function() {
@@ -1899,11 +2260,69 @@ function createNode(win, options) {
 
   if (options.parent) {
     options.parent.appendChild(node);
   }
 
   return node;
 }
 
+/**
+ * Get the right target for listening to events on the page (while picking an
+ * element for instance).
+ * - On a firefox desktop content page: tabActor is a BrowserTabActor from
+ *   which the browser property will give us a target we can use to listen to
+ *   events, even in nested iframes.
+ * - On B2G: tabActor is a ContentActor which doesn't have a browser but
+ *   since it overrides BrowserTabActor, it does get a browser property
+ *   anyway, which points to its window object.
+ * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
+ *   the RootActor, in which case, the window property can be used to listen
+ *   to events
+ */
+function getPageListenerTarget(tabActor) {
+  return tabActor.isRootActor ? tabActor.window : tabActor.chromeEventHandler;
+}
+
+/**
+ * Get a node's owner window.
+ */
+function getWindow(node) {
+  return node.ownerDocument.defaultView;
+}
+
+/**
+ * Get the provided node's offsetParent dimensions.
+ * Returns an object with the {parent, dimension} properties.
+ * Note that the returned parent will be null if the offsetParent is the
+ * default, non-positioned, body or html node.
+ *
+ * node.offsetParent returns the nearest positioned ancestor but if it is
+ * non-positioned itself, we just return null to let consumers know the node is
+ * actually positioned relative to the viewport.
+ *
+ * @return {Object}
+ */
+function getOffsetParent(node) {
+  let offsetParent = node.offsetParent;
+  if (offsetParent &&
+      CssLogic.getComputedStyle(offsetParent).position === "static") {
+    offsetParent = null;
+  }
+
+  let width, height;
+  if (!offsetParent) {
+    height = getWindow(node).innerHeight;
+    width = getWindow(node).innerWidth;
+  } else {
+    height = offsetParent.offsetHeight;
+    width = offsetParent.offsetWidth;
+  }
+
+  return {
+    element: offsetParent,
+    dimension: {width, height}
+  };
+}
+
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
 });
