# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f3da8ae9d1a3e74cd273746da51a035ddc572bee

diff --git a/browser/actors/BrowserTabParent.jsm b/browser/actors/BrowserTabParent.jsm
--- a/browser/actors/BrowserTabParent.jsm
+++ b/browser/actors/BrowserTabParent.jsm
@@ -33,17 +33,19 @@ class BrowserTabParent extends JSWindowA
       // about:addons, browserAction and pageAction popup panels.
       // (Ideally we could call gBrowser.getTabForBrowser, but it returns undefined early in
       // the tab browser creation and we would ignore browsers related to newly created tabs).
       return;
     }
 
     switch (message.name) {
       case "Browser:WindowCreated": {
-        gBrowser.announceWindowCreated(browser, message.data.userContextId);
+        if (!browser.hostBrowser) {
+          gBrowser.announceWindowCreated(browser, message.data.userContextId);
+        }
         break;
       }
 
       case "Browser:FirstPaint": {
         browser.ownerGlobal.gBrowserInit._firstBrowserPaintDeferred.resolve();
         break;
       }
 
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,23 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  width: 75%;
+  justify-self: end;
+}
+
+.browserStack > .a11ymode {
+  justify-self: start;
+  width: 25%;
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -5477,16 +5477,17 @@ var XULBrowserWindow = {
         gCustomizeMode.exit();
       }
 
       CFRPageActions.updatePageActions(gBrowser.selectedBrowser);
     }
     Services.obs.notifyObservers(null, "touchbar-location-change", location);
     UpdateBackForwardCommands(gBrowser.webNavigation);
     ReaderParent.updateReaderButton(gBrowser.selectedBrowser);
+    document.querySelector("#a11y-mode-button").setAttribute("hidden", false);
 
     if (!gMultiProcessBrowser) {
       // Bug 1108553 - Cannot rotate images with e10s
       gGestureSupport.restoreRotationState();
     }
 
     // See bug 358202, when tabs are switched during a drag operation,
     // timers don't fire on windows (bug 203573)
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -999,16 +999,21 @@
                   <image id="cfr-button"
                          class="urlbar-icon urlbar-page-action"
                          role="presentation"/>
                 </hbox>
                 <hbox id="userContext-icons" hidden="true">
                   <label id="userContext-label"/>
                   <image id="userContext-indicator"/>
                 </hbox>
+                <image id="a11y-mode-button"
+                       class="urlbar-icon urlbar-page-action"
+                       tooltip="dynamic-shortcut-tooltip"
+                       role="button"
+                       onclick="ReaderParent.buttonClick(event);"/>
                 <image id="reader-mode-button"
                        class="urlbar-icon urlbar-page-action"
                        tooltip="dynamic-shortcut-tooltip"
                        role="button"
                        hidden="true"
                        onclick="ReaderParent.buttonClick(event);"/>
                 <toolbarbutton id="urlbar-zoom-button"
                        onclick="FullZoom.reset();"
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -1883,16 +1883,18 @@
       let oldUserTypedValue = aBrowser.userTypedValue;
       let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
       let parent = aBrowser.parentNode;
 
       // Change the "remote" attribute.
 
       // Make sure the browser is destroyed so it unregisters from observer notifications
       aBrowser.destroy();
+      // XXX: also destroy a11ymode browser?
+
       // Only remove the node if we're not rebuilding the frameloader via nsFrameLoaderOwner.
       let rebuildFrameLoaders =
         E10SUtils.rebuildFrameloadersOnRemotenessChange ||
         window.docShell.nsILoadContext.useRemoteSubframes;
       if (!rebuildFrameLoaders) {
         aBrowser.remove();
       }
 
@@ -2077,32 +2079,53 @@
       remoteType,
       replayExecution,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+
+      // if (!isPreloadBrowser && remoteType) {
+      //   // This will let us go from tab to a11ymode browser:
+      //   b.a11ymodeBrowser = document.createXULElement("browser");
+      //   b.a11ymodeBrowser.setAttribute("remoteType", remoteType);
+      //   b.a11ymodeBrowser.setAttribute("remote", "true");
+      //   // This will let us go from a11ymode to tab:
+      //   b.a11ymodeBrowser.linkedBrowser = b;
+      // }
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
       b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
         type: "content",
       };
       for (let attribute in defaultBrowserAttributes) {
         b.setAttribute(attribute, defaultBrowserAttributes[attribute]);
+
+        if (
+          b.a11ymodeBrowser &&
+          attribute != "messagemanagergroup" &&
+          attribute != "message"
+        ) {
+          b.a11ymodeBrowser.setAttribute(
+            attribute,
+            defaultBrowserAttributes[attribute]
+          );
+        }
       }
 
       if (userContextId) {
         b.setAttribute("usercontextid", userContextId);
       }
 
       if (remoteType) {
         b.setAttribute("remoteType", remoteType);
@@ -2121,19 +2144,31 @@
         if (remoteType) {
           throw new Error("Cannot set opener window on a remote browser!");
         }
         b.presetOpenerWindow(openerWindow);
       }
 
       if (!isPreloadBrowser) {
         b.setAttribute("autocompletepopup", "PopupAutoComplete");
+        if (b.a11ymodeBrowser) {
+          b.a11ymodeBrowser.setAttribute(
+            "autocompletepopup",
+            "PopupAutoComplete"
+          );
+        }
       }
       if (this._autoScrollPopup) {
         b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
+        if (b.a11ymodeBrowser) {
+          b.a11ymodeBrowser.setAttribute(
+            "autoscrollpopup",
+            this._autoScrollPopup.id
+          );
+        }
       }
 
       /*
        * This attribute is meant to describe if the browser is the
        * preloaded browser. There are 2 defined states: "preloaded" or
        * "consumed". The order of events goes as follows:
        *   1. The preloaded browser is created and the 'preloadedState'
        *      attribute for that browser is set to "preloaded".
@@ -2152,20 +2187,25 @@
 
       if (nextRemoteTabId) {
         if (!remoteType) {
           throw new Error("Cannot have nextRemoteTabId without a remoteType");
         }
         // Gecko is going to read this attribute and use it.
         b.setAttribute("nextRemoteTabId", nextRemoteTabId.toString());
       }
-
+      // if (!isPreloadBrowser && remoteType) {
+      //   b.createA11YModeBrowser();
+      // }
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
+      // if (b.a11ymodeBrowser) {
+      //   b.a11ymodeBrowser.sameProcessAsFrameLoader = b.frameLoader;
+      // }
 
       // This will be used by gecko to control the name of the opened
       // window.
       if (name) {
         // XXX: The `name` property is special in HTML and XUL. Should
         // we use a different attribute name for this?
         b.setAttribute("name", name);
       }
@@ -2176,19 +2216,38 @@
       // We set large flex on both containers to allow the devtools toolbox to
       // set a flex attribute. We don't want the toolbox to actually take up free
       // space, but we do want it to collapse when the window shrinks, and with
       // flex=0 it can't. When the toolbox is on the bottom it's a sibling of
       // browserStack, and when it's on the side it's a sibling of
       // browserContainer.
       let stack = document.createXULElement("stack");
       stack.className = "browserStack";
+      // if (b.a11ymodeBrowser) {
+      //   stack.appendChild(b.a11ymodeBrowser);
+      // }
       stack.appendChild(b);
       stack.setAttribute("flex", "10000");
 
+      // console.log(isPreloadBrowser);
+      // if (!isPreloadBrowser) {
+      // }
+      // if (b.a11ymodeBrowser) {
+      //   b.a11ymodeBrowser.classList.add("a11ymode");
+      //   stack.appendChild(b.a11ymodeBrowser);
+      // }
+
+      // try {
+      //   a11ymodeBrowser.loadURI("about:a11ymode", {
+      //     triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+      //   });
+      // } catch (ex) {
+      //   Cu.reportError(ex);
+      // }
+
       let browserContainer = document.createXULElement("vbox");
       browserContainer.className = "browserContainer";
       browserContainer.appendChild(notificationbox);
       browserContainer.appendChild(stack);
       browserContainer.setAttribute("flex", "10000");
 
       let browserSidebarContainer = document.createXULElement("hbox");
       browserSidebarContainer.className = "browserSidebarContainer";
@@ -3779,16 +3838,19 @@
       if (this._switcher) {
         this._switcher.onTabRemoved(aTab);
       }
 
       // This will unload the document. An unload handler could remove
       // dependant tabs, so it's important that the tabbrowser is now in
       // a consistent state (tab removed, tab positions updated, etc.).
       browser.remove();
+      if (browser.a11ymodeBrowser) {
+        browser.a11ymodeBrowser.remove();
+      }
 
       // Release the browser in case something is erroneously holding a
       // reference to the tab after its removal.
       this._tabForBrowser.delete(aTab.linkedBrowser);
       aTab.linkedBrowser = null;
 
       panel.remove();
 
@@ -4172,16 +4234,21 @@
 
     announceWindowCreated(browser, userContextId) {
       let tab = this.getTabForBrowser(browser);
       if (tab && userContextId) {
         ContextualIdentityService.telemetry(userContextId);
         tab.setUserContextId(userContextId);
       }
 
+      if (tab) {
+        if (!browser.a11ymodeBrowser) {
+          browser.before(browser.createA11YModeBrowser());
+        }
+      }
       // We don't want to update the container icon and identifier if
       // this is not the selected browser.
       if (browser == gBrowser.selectedBrowser) {
         updateUserContextUIIndicator();
       }
     },
 
     reloadMultiSelectedTabs() {
@@ -5160,17 +5227,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
@@ -5500,16 +5566,22 @@
 
       this.addEventListener("oop-browser-crashed", event => {
         if (!event.isTrusted) {
           return;
         }
 
         let browser = event.originalTarget;
 
+        if (browser.hostBrowser) {
+          console.error("a11ymode crashed");
+          return;
+        }
+
+
         // Preloaded browsers do not actually have any tabs. If one crashes,
         // it should be released and removed.
         if (browser === this.preloadedBrowser) {
           NewTabPagePreloading.removePreloadedBrowser(window);
           return;
         }
 
         let icon = browser.mIconURL;
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -65,16 +65,32 @@ let ACTORS = {
         AboutLoginsSyncEnable: { wantUntrusted: true },
         AboutLoginsSyncOptions: { wantUntrusted: true },
         AboutLoginsUpdateLogin: { wantUntrusted: true },
       },
     },
     matches: ["about:logins", "about:logins?*"],
   },
 
+  A11YMode: {
+    parent: {
+      moduleURI: "resource:///actors/A11YModeParent.jsm",
+    },
+    child: {
+      moduleURI: "resource:///actors/A11YModeChild.jsm",
+      events: {
+        DOMWindowCreated: {},
+        A11YModeContentLoaded: { wantUntrusted: true },
+        A11YModeContentClicked: { wantUntrusted: true },
+      },
+    },
+    matches: ["about:a11ymode", "about:a11ymode?*"],
+    // allFrames: true,
+  },
+
   BlockedSite: {
     parent: {
       moduleURI: "resource:///actors/BlockedSiteParent.jsm",
     },
     child: {
       moduleURI: "resource:///actors/BlockedSiteChild.jsm",
       events: {
         AboutBlockedLoaded: { wantUntrusted: true },
diff --git a/browser/components/a11ymode/A11YModeChild.jsm b/browser/components/a11ymode/A11YModeChild.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/A11YModeChild.jsm
@@ -0,0 +1,443 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["A11YModeChild"];
+
+let a11yModes = new Map();
+let hostWindows = new Map();
+
+
+const {
+  EVENT_TEXT_CHANGED,
+  EVENT_DOCUMENT_LOAD_COMPLETE,
+  EVENT_TEXT_INSERTED,
+  EVENT_TEXT_REMOVED,
+  EVENT_ACCELERATOR_CHANGE,
+  EVENT_ACTION_CHANGE,
+  EVENT_DEFACTION_CHANGE,
+  EVENT_DESCRIPTION_CHANGE,
+  EVENT_DOCUMENT_ATTRIBUTES_CHANGED,
+  EVENT_HIDE,
+  EVENT_NAME_CHANGE,
+  EVENT_OBJECT_ATTRIBUTE_CHANGED,
+  EVENT_REORDER,
+  EVENT_STATE_CHANGE,
+  EVENT_TEXT_ATTRIBUTE_CHANGED,
+  EVENT_VALUE_CHANGE,
+} = Ci.nsIAccessibleEvent;
+
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+
+const RELATIONS_TO_IGNORE = new Set([
+  Ci.nsIAccessibleRelation.RELATION_CONTAINING_APPLICATION,
+  Ci.nsIAccessibleRelation.RELATION_CONTAINING_TAB_PANE,
+  Ci.nsIAccessibleRelation.RELATION_CONTAINING_WINDOW,
+  Ci.nsIAccessibleRelation.RELATION_PARENT_WINDOW_OF,
+  Ci.nsIAccessibleRelation.RELATION_SUBWINDOW_OF,
+]);
+
+const nsIAccessibleRole = Ci.nsIAccessibleRole;
+const TEXT_ROLES = new Set([
+  nsIAccessibleRole.ROLE_TEXT_LEAF,
+  nsIAccessibleRole.ROLE_STATICTEXT,
+]);
+
+const STATE_DEFUNCT = Ci.nsIAccessibleStates.EXT_STATE_DEFUNCT;
+
+/**
+ * Helper function that determines if nsIAccessible object is in defunct state.
+ *
+ * @param  {nsIAccessible}  accessible
+ *         object to be tested.
+ * @return {Boolean}
+ *         True if accessible object is defunct, false otherwise.
+ */
+function isDefunct(accessible) {
+  // If accessibility is disabled, safely assume that the accessible object is
+  // now dead.
+  if (!Services.appinfo.accessibilityEnabled) {
+    return true;
+  }
+
+  let defunct = false;
+
+  try {
+    const extraState = {};
+    accessible.getState({}, extraState);
+    // extraState.value is a bitmask. We are applying bitwise AND to mask out
+    // irrelevant states.
+    defunct = !!(extraState.value & Ci.nsIAccessibleStates.EXT_STATE_DEFUNCT);
+  } catch (e) {
+    defunct = true;
+  }
+
+  return defunct;
+}
+
+/**
+ * Get a snapshot of the nsIAccessible object including its subtree. None of the subtree
+ * queried here is cached via accessible walker's refMap.
+ * @param  {nsIAccessible} acc
+ *         Accessible object to take a snapshot of.
+ * @param  {nsIAccessibilityService} a11yService
+ *         Accessibility service instance in the current process, used to get localized
+ *         string representation of various accessible properties.
+ * @return {JSON}
+ *         JSON snapshot of the accessibility tree with root at current accessible.
+ */
+function getSnapshot(acc, a11yService) {
+  if (isDefunct(acc)) {
+    return {
+      states: [a11yService.getStringStates(0, STATE_DEFUNCT)],
+    };
+  }
+
+  const actions = [];
+  for (let i = 0; i < acc.actionCount; i++) {
+    actions.push(acc.getActionDescription(i));
+  }
+
+  const attributes = {};
+  if (acc.attributes) {
+    for (const { key, value } of acc.attributes.enumerate()) {
+      attributes[key] = value;
+    }
+  }
+
+  const state = {};
+  const extState = {};
+  acc.getState(state, extState);
+  const states = [...a11yService.getStringStates(state.value, extState.value)];
+
+  const children = [];
+  for (let child = acc.firstChild; child; child = child.nextSibling) {
+    children.push(getSnapshot(child, a11yService));
+  }
+
+  return {
+    name: acc.name,
+    role: a11yService.getStringRole(acc.role),
+    actions,
+    value: acc.value,
+    nodeType: acc.DOMNode.nodeType,
+    description: acc.description,
+    keyboardShortcut: acc.accessKey || acc.keyboardShortcut,
+    childCount: acc.childCount,
+    indexInParent: acc.indexInParent,
+    states,
+    children,
+    attributes,
+  };
+}
+
+/**
+ * Helper function that determines if nsIAccessible object is in stale state. When an
+ * object is stale it means its subtree is not up to date.
+ *
+ * @param  {nsIAccessible}  accessible
+ *         object to be tested.
+ * @return {Boolean}
+ *         True if accessible object is stale, false otherwise.
+ */
+function isStale(accessible) {
+  const extraState = {};
+  accessible.getState({}, extraState);
+  // extraState.value is a bitmask. We are applying bitwise AND to mask out
+  // irrelevant states.
+  return !!(extraState.value & Ci.nsIAccessibleStates.EXT_STATE_STALE);
+}
+
+class A11YWalker {
+  constructor(a11YModeChild, hostBrowsingContext) {
+    this.a11YModeChild = a11YModeChild;
+    this.hostBrowsingContext = hostBrowsingContext;
+    console.log(
+      this.hostBrowsingContext,
+      this.hostBrowsingContext.window,
+      this.a11yService
+    );
+  }
+
+  get a11yService() {
+    if (!this._a11yService) {
+      // This turns on accessibility automatically (see Services.appinfo.accessibilityEnabled)
+      // See https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/accessibility-parent.js#135 for more lifecycle
+      this._a11yService = Cc["@mozilla.org/accessibilityService;1"].getService(
+        Ci.nsIAccessibilityService
+      );
+
+      Services.obs.addObserver(this, "accessible-event");
+    }
+    return this._a11yService;
+  }
+
+  /**
+   * Get a raw accessible object for a raw node.
+   * @param  {DOMNode} rawNode
+   *         Raw node for which accessible object is being retrieved.
+   * @return {nsIAccessible}
+   *         Accessible object for a given DOMNode.
+   */
+  getRawAccessibleFor(rawNode) {
+    // Accessible can only be retrieved iff accessibility service is enabled.
+    if (!Services.appinfo.accessibilityEnabled) {
+      return null;
+    }
+
+    return this.a11yService.getAccessibleFor(rawNode);
+  }
+
+  getSnapshot(acc) {
+    return getSnapshot(acc, this.a11yService);
+  }
+
+  /**
+   * Accessible event observer function.
+   *
+   * @param {Ci.nsIAccessibleEvent} subject
+   *                                      accessible event object.
+   */
+  // eslint-disable-next-line complexity
+  observe(subject) {
+    const event = subject.QueryInterface(Ci.nsIAccessibleEvent);
+    const rawAccessible = event.accessible;
+
+    if (
+      event.eventType == EVENT_DOCUMENT_LOAD_COMPLETE &&
+      event.accessibleDocument &&
+      event.accessibleDocument.DOMDocument ==
+        this.hostBrowsingContext.window.document
+    ) {
+      if (rawAccessible instanceof Ci.nsIAccessibleDocument) {
+        if (!isStale(rawAccessible) && !this.sentOnce) {
+          // this.sentOnce = true;
+          // If it's a top level document notify listeners about the document
+          // being ready.
+
+          // let start = this.a11YModeChild.document.defaultView.performance.now();
+          // let snapshot = this.getSnapshot(rawAccessible);
+          // console.log(
+          //   "Created snapshot",
+          //   event.eventType,
+          //   this.a11YModeChild.document.defaultView.performance.now() - start
+          // );
+          // this.a11YModeChild.sendToContent("TreeChanged", snapshot);
+        }
+      }
+    }
+    // if (rawAccessible instanceof Ci.nsIAccessibleDocument && !accessible) {
+    //   const rootDocAcc = this.getRawAccessibleFor(this.rootDoc);
+    //   if (rawAccessible === rootDocAcc && !isStale(rawAccessible)) {
+    //     this.clearRefs();
+    //     // If it's a top level document notify listeners about the document
+    //     // being ready.
+    //     events.emit(this, "document-ready", rawAccessible);
+    //   }
+    // }
+
+    // switch (event.eventType) {
+    //   case EVENT_STATE_CHANGE:
+    //     const { state, isEnabled } = event.QueryInterface(
+    //       Ci.nsIAccessibleStateChangeEvent
+    //     );
+    //     const isBusy = state & Ci.nsIAccessibleStates.STATE_BUSY;
+    //     if (accessible) {
+    //       // Only propagate state change events for active accessibles.
+    //       if (isBusy && isEnabled) {
+    //         if (rawAccessible instanceof Ci.nsIAccessibleDocument) {
+    //           // Remove existing cache from tree.
+    //           this.clearRefs();
+    //         }
+    //         return;
+    //       }
+    //       events.emit(accessible, "states-change", accessible.states);
+    //     }
+
+    //     break;
+    //   case EVENT_NAME_CHANGE:
+    //     if (accessible) {
+    //       events.emit(
+    //         accessible,
+    //         "name-change",
+    //         rawAccessible.name,
+    //         event.DOMNode == this.rootDoc
+    //           ? undefined
+    //           : this.getRef(rawAccessible.parent)
+    //       );
+    //     }
+    //     break;
+    //   case EVENT_VALUE_CHANGE:
+    //     if (accessible) {
+    //       events.emit(accessible, "value-change", rawAccessible.value);
+    //     }
+    //     break;
+    //   case EVENT_DESCRIPTION_CHANGE:
+    //     if (accessible) {
+    //       events.emit(
+    //         accessible,
+    //         "description-change",
+    //         rawAccessible.description
+    //       );
+    //     }
+    //     break;
+    //   case EVENT_REORDER:
+    //     if (accessible) {
+    //       accessible
+    //         .children()
+    //         .forEach(child =>
+    //           events.emit(child, "index-in-parent-change", child.indexInParent)
+    //         );
+    //       events.emit(accessible, "reorder", rawAccessible.childCount);
+    //     }
+    //     break;
+    //   case EVENT_HIDE:
+    //     if (event.DOMNode == this.rootDoc) {
+    //       this.clearRefs();
+    //     } else {
+    //       this.purgeSubtree(rawAccessible);
+    //     }
+    //     break;
+    //   case EVENT_DEFACTION_CHANGE:
+    //   case EVENT_ACTION_CHANGE:
+    //     if (accessible) {
+    //       events.emit(accessible, "actions-change", accessible.actions);
+    //     }
+    //     break;
+    //   case EVENT_TEXT_CHANGED:
+    //   case EVENT_TEXT_INSERTED:
+    //   case EVENT_TEXT_REMOVED:
+    //     if (accessible) {
+    //       events.emit(accessible, "text-change");
+    //       if (NAME_FROM_SUBTREE_RULE_ROLES.has(rawAccessible.role)) {
+    //         events.emit(
+    //           accessible,
+    //           "name-change",
+    //           rawAccessible.name,
+    //           event.DOMNode == this.rootDoc
+    //             ? undefined
+    //             : this.getRef(rawAccessible.parent)
+    //         );
+    //       }
+    //     }
+    //     break;
+    //   case EVENT_DOCUMENT_ATTRIBUTES_CHANGED:
+    //   case EVENT_OBJECT_ATTRIBUTE_CHANGED:
+    //   case EVENT_TEXT_ATTRIBUTE_CHANGED:
+    //     if (accessible) {
+    //       events.emit(accessible, "attributes-change", accessible.attributes);
+    //     }
+    //     break;
+    //   // EVENT_ACCELERATOR_CHANGE is currently not fired by gecko accessibility.
+    //   case EVENT_ACCELERATOR_CHANGE:
+    //     if (accessible) {
+    //       events.emit(
+    //         accessible,
+    //         "shortcut-change",
+    //         accessible.keyboardShortcut
+    //       );
+    //     }
+    //     break;
+    //   default:
+    //     break;
+    // }
+  }
+}
+
+A11YWalker.prototype.QueryInterface = ChromeUtils.generateQI([
+  Ci.nsIObserver,
+  Ci.nsISupportsWeakReference,
+]);
+
+// See stuff like https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/walker.js#499
+
+// Basic idea here is to use this actor to receive the accessibility tree and
+// subsequent events from a 'host' browser, and then to send them along to an
+// 'a11ymode' browser (which are running in the same content process)
+// Maybe this should be two different actors?
+class A11YModeChild extends JSWindowActorChild {
+  receiveMessage(message) {
+    console.log("A11YModeChild::receiveMessage", message.name);
+    switch (message.name) {
+      case "A11YMode:UpdateBrowsingContext":
+        const { browsingContext } = message.data;
+        this.walker = new A11YWalker(this, browsingContext);
+        break;
+    }
+  }
+
+  handleEvent(event) {
+    // if (this.document.documentURI == "about:a11ymode") {
+    //   a11yModes.set()
+    //   gA11YModeMap
+    // }
+
+    // console.log(this, this.docShell.messageManager);
+    switch (event.type) {
+      case "DOMWindowCreated":
+        this.sendAsyncMessage("A11YMode:WindowCreated");
+
+        console.log(
+          "Created",
+          Services.appinfo.processID,
+          this.document.location.toString()
+        );
+        // let { docShell } = this.browsingContext;
+
+        // let context = this.manager.browsingContext;
+        // console.log(
+        //   this.document.documentURI,
+        //   this.document.location,
+        //   docShell.outerWindowID,
+        //   context,
+        //   Services.appinfo.processID
+        // );
+
+        // if (
+        //   this.document.location.protocol == "about:" &&
+        //   this.document.location.pathname == "a11ymode"
+        // ) {
+        //   const url = new this.document.defaultView.URL(this.document.location);
+        //   const searchParams = new this.document.defaultView.URLSearchParams(
+        //     url.search
+        //   );
+        //   const hostOuterWindowID = parseInt(searchParams.get("outerWindowID"));
+        //   if (!hostOuterWindowID) {
+        //     throw new Error("Error: Missing outerWindowID");
+        //   }
+        //   console.log("Setting!", hostOuterWindowID)
+        //   if (hostWindows.has(hostOuterWindowID)) {
+        //     console.log("Found match", hostWindows.get(hostOuterWindowID))
+        //   }
+        //   a11yModes.set(hostOuterWindowID, this.browsingContext);
+
+        // } else {
+        //   hostWindows.set(docShell.outerWindowID, this.browsingContext)
+        //   console.log([...a11yModes.keys()], docShell.outerWindowID);
+        //   if (a11yModes.has(docShell.outerWindowID)) {
+        //     console.log("Found match", a11yModes.get(docShell.outerWindowID))
+        //   }
+        // }
+        break;
+      case "A11YModeContentLoaded":
+        let title = this.document.querySelector("#title");
+        title.textContent = `Hello, a11ymode from ${
+          Services.appinfo.processID
+        }`;
+        break;
+      // case "A11YModeContentClicked":
+      //   this.sendToContent("TreeChanged");
+      //   break;
+    }
+  }
+  sendToContent(messageType, detail) {
+    let win = this.document.defaultView;
+    let message = Object.assign({ messageType }, { value: detail });
+    let event = new win.CustomEvent("A11YModeChromeToContent", {
+      detail: Cu.cloneInto(message, win),
+    });
+    win.dispatchEvent(event);
+  }
+}
diff --git a/browser/components/a11ymode/A11YModeParent.jsm b/browser/components/a11ymode/A11YModeParent.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/A11YModeParent.jsm
@@ -0,0 +1,37 @@
+/* vim: set ts=2 sw=2 sts=2 et tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+var EXPORTED_SYMBOLS = ["A11YModeParent"];
+
+const { BrowserWindowTracker } = ChromeUtils.import(
+  "resource:///modules/BrowserWindowTracker.jsm"
+);
+const { E10SUtils } = ChromeUtils.import(
+  "resource://gre/modules/E10SUtils.jsm"
+);
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+const { AppConstants } = ChromeUtils.import(
+  "resource://gre/modules/AppConstants.jsm"
+);
+
+class A11YModeParent extends JSWindowActorParent {
+  receiveMessage(message) {
+    console.log("A11YModeParent::receiveMessage", message);
+    let browser = this.manager.browsingContext.embedderElement;
+    if (!browser) {
+      return; // Can happen sometimes if browser is being destroyed
+    }
+
+    switch (message.name) {
+      case "A11YMode:WindowCreated": {
+        if (browser.hostBrowser) {
+          browser.connectToHost();
+        }
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/a11ymode/content/a11ymode.css b/browser/components/a11ymode/content/a11ymode.css
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/content/a11ymode.css
@@ -0,0 +1,14 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+/* 
+html,
+body,
+#browser-container,
+#browser {
+  width: 100%;
+  height: 100%;
+  margin: 0;
+  padding: 0;
+  overflow: hidden;
+} */
diff --git a/browser/components/a11ymode/content/a11ymode.html b/browser/components/a11ymode/content/a11ymode.html
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/content/a11ymode.html
@@ -0,0 +1,20 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE html>
+
+<html>
+<head>
+  <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'" />
+  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
+  <meta name="viewport" content="width=device-width; user-scalable=0" />
+  <link rel="stylesheet" href="chrome://browser/content/a11ymode/a11ymode.css">
+</head>
+<body>
+  <div id="title"></div>
+  <div id="content"></div>
+  <script src="chrome://browser/content/a11ymode/a11ymode.js"></script>
+  <script src="chrome://browser/content/a11ymode/roles.js"></script>
+</body>
+</html>
diff --git a/browser/components/a11ymode/content/a11ymode.js b/browser/components/a11ymode/content/a11ymode.js
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/content/a11ymode.js
@@ -0,0 +1,132 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+document.addEventListener(
+  "click",
+  e => {
+    e.preventDefault();
+    // XXX: Send this up with accessible id to do command
+  },
+  { capture: true }
+);
+
+function isDebug() {
+  return false;
+  // return debugCheckbox.checked;
+}
+
+// let debugCheckbox = document.querySelector("#debug");
+// debugCheckbox.onchange = () => {
+//   buildAccTree(ACTIVE_ACC_TREE);
+// };
+
+function renderDebugContainer(treeItem, children) {
+  let details = document.createElement("details");
+  details.toggleAttribute("open");
+  details.setAttribute(
+    "title",
+    JSON.stringify(
+      Object.assign({}, treeItem, { children: undefined }),
+      null,
+      2
+    )
+  );
+  let summary = document.createElement("summary");
+  summary.textContent = `${treeItem.role}: ${treeItem.name}`;
+  details.append(summary, ...children);
+  return [details];
+}
+
+function buildAccTree(accTree) {
+  // document.querySelector("#content").textContent = buildAccTreeElement(accTree);
+  let content = document.querySelector("#content");
+  content.innerHTML = "";
+  let element = buildAccTreeElement(accTree);
+  content.append(...element);
+}
+
+function buildAccTreeElement(accTree) {
+  let children = accTree.children
+    .map(c => {
+      return buildAccTreeElement(c);
+    })
+    .flat();
+  let currentNode = accTree;
+  // console.log(currentNode.role, children);
+  let role = ROLE_MAP[currentNode.role];
+
+  if (!role) {
+    throw new Error(`Unknown role: ${currentNode.role}`);
+  }
+
+  if (isDebug()) {
+    return renderDebugContainer(currentNode, children);
+  }
+
+  return role.render(currentNode, children);
+}
+
+function throttle(callback, limit) {
+  var wait = false;
+  return function() {
+    if (!wait) {
+      callback.apply(null, arguments);
+      wait = true;
+      setTimeout(function() {
+        wait = false;
+      }, limit);
+    }
+  };
+}
+
+async function renderFull(snapshot) {
+  console.trace();
+  buildAccTree(snapshot);
+}
+
+const throttledRender = throttle(renderFull, 1000);
+
+window.addEventListener("DOMContentLoaded", function() {
+  // startListeningForAccessibilityEvents({
+  //   reorder: function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  //   "name-change": function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  //   "text-change": function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  //   "document-ready": function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  // });
+  // console.log(window.ROLE_MAP);
+
+  document.dispatchEvent(
+    new CustomEvent("A11YModeContentLoaded", { bubbles: true })
+  );
+});
+
+document.addEventListener("click", function() {
+  document.dispatchEvent(
+    new CustomEvent("A11YModeContentClicked", { bubbles: true })
+  );
+});
+
+window.addEventListener("A11YModeChromeToContent", event => {
+  switch (event.detail.messageType) {
+    case "TreeChanged": {
+      renderFull(event.detail.value);
+      // document.querySelector("#container").textContent = Date.now();
+      break;
+    }
+  }
+});
diff --git a/browser/components/a11ymode/content/jar.mn b/browser/components/a11ymode/content/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/content/jar.mn
@@ -0,0 +1,9 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+    content/browser/a11ymode/a11ymode.html
+    content/browser/a11ymode/a11ymode.js
+    content/browser/a11ymode/roles.js
+    content/browser/a11ymode/a11ymode.css
diff --git a/browser/components/a11ymode/moz.build b/browser/components/a11ymode/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/components/a11ymode/moz.build
@@ -0,0 +1,12 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ['content/jar.mn']
+
+FINAL_TARGET_FILES.actors += [
+    'A11YModeChild.jsm',
+    'A11YModeParent.jsm',
+]
diff --git a/browser/components/about/AboutRedirector.cpp b/browser/components/about/AboutRedirector.cpp
--- a/browser/components/about/AboutRedirector.cpp
+++ b/browser/components/about/AboutRedirector.cpp
@@ -111,16 +111,20 @@ static const RedirEntry kRedirMap[] = {
      nsIAboutModule::ALLOW_SCRIPT},
     {"downloads",
      "chrome://browser/content/downloads/contentAreaDownloadsView.xhtml",
      nsIAboutModule::ALLOW_SCRIPT},
     {"reader", "chrome://global/content/reader/aboutReader.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::HIDE_FROM_ABOUTABOUT},
+    {"a11ymode", "chrome://browser/content/a11ymode/a11ymode.html",
+     nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
+         nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
+         nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"restartrequired", "chrome://browser/content/aboutRestartRequired.xhtml",
      nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"newinstall", "chrome://browser/content/newInstallPage.html",
      nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"protections", "chrome://browser/content/protections.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
diff --git a/browser/components/about/components.conf b/browser/components/about/components.conf
--- a/browser/components/about/components.conf
+++ b/browser/components/about/components.conf
@@ -1,15 +1,16 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 pages = [
+    'a11ymode',
     'blocked',
     'certerror',
     'config',
     'downloads',
     'framecrashed',
     'home',
     'library',
     'logins',
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -25,16 +25,17 @@ with Files("safebrowsing/**"):
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
 
 
 DIRS += [
     'about',
     'aboutconfig',
     'aboutlogins',
+    'a11ymode',
     'attribution',
     'contextualidentity',
     'customizableui',
     'dirprovider',
     'doh',
     'downloads',
     'enterprisepolicies',
     'extensions',
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -809,16 +809,29 @@
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input {
   mask-position-x: calc(var(--cfr-label-width) * -1);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input:-moz-locale-dir(rtl) {
   mask-position-x: calc(var(--cfr-label-width));
 }
 
+/* a11y mode icon */
+
+#a11y-mode-button {
+  list-style-image: url(chrome://browser/skin/readerMode.svg);
+  fill: orange;
+  fill-opacity: 1;
+}
+
+#a11y-mode-button[readeractive] {
+  fill: var(--toolbarbutton-icon-fill-attention);
+  fill-opacity: 1;
+}
+
 /* Reader mode icon */
 
 #reader-mode-button {
   list-style-image: url(chrome://browser/skin/readerMode.svg);
 }
 
 #reader-mode-button[readeractive] {
   fill: var(--toolbarbutton-icon-fill-attention);
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -463,18 +463,62 @@
         if (this.isRemoteBrowser) {
           this._documentContentType = aContentType;
         } else {
           this.contentDocument.documentContentType = aContentType;
         }
       }
     }
 
+    createA11YModeBrowser() {
+      if (!this.a11ymodeBrowser) {
+        this.a11ymodeBrowser = document.createXULElement("browser");
+        this.a11ymodeBrowser.classList.add("a11ymode");
+        this.a11ymodeBrowser.setAttribute("nodefaultsrc", "true");
+        this.a11ymodeBrowser.setAttribute("remoteType", this.remoteType);
+        this.a11ymodeBrowser.setAttribute("remote", "true");
+        this.a11ymodeBrowser.setAttribute("type", "content");
+        this.a11ymodeBrowser.setAttribute(
+          "contextmenu",
+          this.getAttribute("contextmenu")
+        );
+        this.a11ymodeBrowser.setAttribute(
+          "datetimepicker",
+          this.getAttribute("datetimepicker")
+        );
+        this.a11ymodeBrowser.setAttribute(
+          "selectmenulist",
+          this.getAttribute("selectmenulist")
+        );
+        this.a11ymodeBrowser.setAttribute(
+          "tooltip",
+          this.getAttribute("tooltip")
+        );
+        this.a11ymodeBrowser.setAttribute(
+          "autocompletepopup",
+          this.getAttribute("autocompletepopup")
+        );
+        this.a11ymodeBrowser.setAttribute(
+          "autoscrollpopup",
+          this.getAttribute("autoscrollpopup")
+        );
+        this.a11ymodeBrowser.sameProcessAsFrameLoader = this.frameLoader;
+        this.a11ymodeBrowser.hostBrowser = this;
+        this.a11ymodeBrowser.src = "about:a11ymode";
+      }
+      return this.a11ymodeBrowser;
+    }
+
     set sameProcessAsFrameLoader(val) {
       this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+      if (this.a11ymodeBrowser) {
+        this.a11ymodeBrowser.sameProcessAsFrameLoader = Cu.getWeakReference(
+          val
+        );
+      }
     }
 
     get sameProcessAsFrameLoader() {
       return (
         this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get()
       );
     }
 
@@ -1321,16 +1365,48 @@
       }
 
       if (this.messageManager) {
         this.messageManager.addMessageListener(
           "UnselectedTabHover:Toggle",
           this
         );
       }
+
+      // if (this.hostBrowser) {
+      //   console.log("Created a11ymode");
+
+      //   let load = () => {
+      //     this.loadURI(`about:a11ymode`, {
+      //       triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+      //     });
+      //   };
+
+      //   load();
+      //   this.hostBrowser.addEventListener("XULFrameLoaderCreated", () => {
+      //     // load();
+      //     console.log(
+      //       "XULFrameLoaderCreated",
+      //       this.webNavigation,
+      //       this.isConnected
+      //     );
+      //   });
+      // }
+    }
+
+    connectToHost() {
+      if (!this.hostBrowser) {
+        return;
+      }
+
+      let hostBC = this.hostBrowser.browsingContext;
+      console.log(hostBC, this.browsingContext, this.documentURI);
+      this.browsingContext.currentWindowGlobal
+        .getActor("A11YMode")
+        .sendAsyncMessage("A11YMode:UpdateBrowsingContext", { browsingContext: hostBC });
     }
 
     /**
      * This is necessary because the destructor doesn't always get called when
      * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
      */
     destroy() {
       elementsToDestroyOnUnload.delete(this);
