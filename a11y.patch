# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c9955025d4a5353568a56a1048292c665312fa95

diff --git a/accessible/interfaces/nsIAccessible.idl b/accessible/interfaces/nsIAccessible.idl
--- a/accessible/interfaces/nsIAccessible.idl
+++ b/accessible/interfaces/nsIAccessible.idl
@@ -80,16 +80,21 @@ interface nsIAccessible : nsISupports
   readonly attribute Node DOMNode;
 
   /**
     * For remote accessibles the id of the related DOM node.
     */
   readonly attribute AString id;
 
   /**
+    *
+    */
+  readonly attribute uint64_t uniqueID;
+
+  /**
    * The document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument document;
 
   /**
    * The root document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument rootDocument;
diff --git a/accessible/xpcom/xpcAccessible.cpp b/accessible/xpcom/xpcAccessible.cpp
--- a/accessible/xpcom/xpcAccessible.cpp
+++ b/accessible/xpcom/xpcAccessible.cpp
@@ -92,16 +92,28 @@ xpcAccessible::GetLastChild(nsIAccessibl
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   NS_IF_ADDREF(*aLastChild = ToXPC(IntlGeneric().LastChild()));
   return NS_OK;
 }
 
 NS_IMETHODIMP
+xpcAccessible::GetUniqueID(uint64_t* aUniqueID) {
+  NS_ENSURE_ARG_POINTER(aUniqueID);
+
+  if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
+
+  void* uniqueID = static_cast<void*>(this);
+  *aUniqueID = reinterpret_cast<uint64_t>(uniqueID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 xpcAccessible::GetChildCount(int32_t* aChildCount) {
   NS_ENSURE_ARG_POINTER(aChildCount);
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   *aChildCount = IntlGeneric().ChildCount();
   return NS_OK;
 }
diff --git a/accessible/xpcom/xpcAccessible.h b/accessible/xpcom/xpcAccessible.h
--- a/accessible/xpcom/xpcAccessible.h
+++ b/accessible/xpcom/xpcAccessible.h
@@ -25,16 +25,17 @@ class xpcAccessible : public nsIAccessib
  public:
   // nsIAccessible
   NS_IMETHOD GetParent(nsIAccessible** aParent) final;
   NS_IMETHOD GetNextSibling(nsIAccessible** aNextSibling) final;
   NS_IMETHOD GetPreviousSibling(nsIAccessible** aPreviousSibling) final;
   NS_IMETHOD GetFirstChild(nsIAccessible** aFirstChild) final;
   NS_IMETHOD GetLastChild(nsIAccessible** aLastChild) final;
   NS_IMETHOD GetChildCount(int32_t* aChildCount) final;
+  NS_IMETHOD GetUniqueID(uint64_t* aUniqueID) final;
   NS_IMETHOD GetChildAt(int32_t aChildIndex, nsIAccessible** aChild) final;
   NS_IMETHOD GetChildren(nsIArray** aChildren) final;
   NS_IMETHOD GetIndexInParent(int32_t* aIndexInParent) final;
 
   NS_IMETHOD GetDOMNode(nsINode** aDOMNode) final;
   NS_IMETHOD GetId(nsAString& aID) final;
   NS_IMETHOD GetDocument(nsIAccessibleDocument** aDocument) final;
   NS_IMETHOD GetRootDocument(nsIAccessibleDocument** aRootDocument) final;
diff --git a/browser/actors/BrowserTabParent.jsm b/browser/actors/BrowserTabParent.jsm
--- a/browser/actors/BrowserTabParent.jsm
+++ b/browser/actors/BrowserTabParent.jsm
@@ -11,16 +11,20 @@ class BrowserTabParent extends JSWindowA
     if (!browser) {
       return; // Can happen sometimes if browser is being destroyed
     }
 
     if (browser.outerBrowser) {
       browser = browser.outerBrowser; // handle RDM mode
     }
 
+    if (browser.hostBrowser) {
+      return;
+    }
+
     let gBrowser = browser.ownerGlobal.gBrowser;
 
     if (!gBrowser) {
       // Note: gBrowser might be null because this message might be received
       // from the extension process. There's still an embedderElement involved,
       // but it's the one coming from dummy.xul.
       // This should probably be fixed by adding support to specifying "group: 'browsers"
       // in the registerWindowActor options/. See bug 1557118.
diff --git a/browser/base/content/browser-sets.inc b/browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc
+++ b/browser/base/content/browser-sets.inc
@@ -38,16 +38,17 @@
     <command id="cmd_CustomizeToolbars" oncommand="gCustomizeMode.enter()"/>
     <command id="cmd_toggleOfflineStatus" oncommand="BrowserOffline.toggleOfflineStatus();"/>
     <command id="cmd_quitApplication" oncommand="goQuitApplication()"/>
 
     <command id="View:PageSource" oncommand="BrowserViewSource(window.gBrowser.selectedBrowser);"/>
     <command id="View:PageInfo" oncommand="BrowserPageInfo();"/>
     <command id="View:FullScreen" oncommand="BrowserFullScreen();"/>
     <command id="View:ReaderView" oncommand="ReaderParent.toggleReaderMode(event);"/>
+    <command id="View:SecondaryBrowser" oncommand="ReaderParent.toggleSecondaryBrowser(event);"/>
     <command id="View:PictureInPicture" oncommand="PictureInPicture.onCommand(event);"/>
     <command id="cmd_find" oncommand="gLazyFindCommand('onFindCommand')"/>
     <command id="cmd_findAgain" oncommand="gLazyFindCommand('onFindAgainCommand', false)"/>
     <command id="cmd_findPrevious" oncommand="gLazyFindCommand('onFindAgainCommand', true)"/>
 #ifdef XP_MACOSX
     <command id="cmd_findSelection" oncommand="gLazyFindCommand('onFindSelectionCommand')"/>
 #endif
     <!-- work-around bug 392512 -->
@@ -228,16 +229,20 @@
          command="View:ReaderView"
 #ifdef XP_WIN
          data-l10n-id="reader-mode-toggle-shortcut-windows"
 #else
          data-l10n-id="reader-mode-toggle-shortcut-other"
          modifiers="accel,alt"
 #endif
          disabled="true"/>
+    <key id="key_toggleSecondaryBrowser"
+         command="View:SecondaryBrowser"
+         key="o"
+         modifiers="accel,shift"/>
 
 #ifndef XP_MACOSX
     <key id="key_togglePictureInPicture" data-l10n-id="picture-in-picture-toggle-shortcut" command="View:PictureInPicture" modifiers="accel,shift"/>
     <key                                 data-l10n-id="picture-in-picture-toggle-shortcut-alt" command="View:PictureInPicture" modifiers="accel,shift"/>
 #endif
 
     <key data-l10n-id="nav-reload-shortcut" command="Browser:Reload" modifiers="accel" id="key_reload"/>
     <key data-l10n-id="nav-reload-shortcut" command="Browser:ReloadSkipCache" modifiers="accel,shift" id="key_reload_skip_cache"/>
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,82 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  /* margin-inline-start: 32px;
+  width: calc(100% - 32px); */
+}
+.browserStack:not([secondarybrowser]) > .secondarybrowser {
+  display: none;
+}
+/* 
+.browserStack > .secondarybrowser-controls {
+  justify-self: start;
+  width: 32px;
+  background: rgba(255, 255, 255, .8);
+}
+
+.browserStack > .secondarybrowser-controls > toolbarbutton {
+  width: 32px;
+  height: 32px;
+}
+.browserStack > .secondarybrowser-controls > toolbarbutton:hover,
+.browserStack > .secondarybrowser-controls > toolbarbutton[active] {
+  background-color: hsla(240,5%,5%,.1);
+} */
+
+  /* icons grabbed from https://www.iconfinder.com/iconsets/material-core */
+.secondarybrowser-on {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-split {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxNnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAxNiIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01MDYuMDAwMDAwLCAtMTMwLjAwMDAwMCkiPjxnIGlkPSJkcmF3ZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwNi4wMDAwMDAsIDEzMC4wMDAwMDApIj48cGF0aCBkPSJNMTgsMCBMMiwwIEMwLjgsMCAwLDAuOCAwLDIgTDAsMTQgQzAsMTUuMiAwLjgsMTYgMiwxNiBMMTgsMTYgQzE5LDE2IDIwLDE1LjIgMjAsMTQgTDIwLDIgQzIwLDAuOCAxOSwwIDE4LDAgTDE4LDAgWiBNMTgsMTQgTDEyLDE0IEwxMiwyIEwxOCwyIEwxOCwxNCBMMTgsMTQgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-off {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAyMCIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTYuMDAwMDAwLCAtMjk2LjAwMDAwMCkiPjxnIGlkPSJsYW5ndWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk2LjAwMDAwMCwgMjk2LjAwMDAwMCkiPjxwYXRoIGQ9Ik0xMCwwIEM0LjUsMCAwLDQuNSAwLDEwIEMwLDE1LjUgNC41LDIwIDEwLDIwIEMxNS41LDIwIDIwLDE1LjUgMjAsMTAgQzIwLDQuNSAxNS41LDAgMTAsMCBMMTAsMCBaIE0xNi45LDYgTDE0LDYgQzEzLjcsNC43IDEzLjIsMy42IDEyLjYsMi40IEMxNC40LDMuMSAxNiw0LjMgMTYuOSw2IEwxNi45LDYgWiBNMTAsMiBDMTAuOCwzLjIgMTEuNSw0LjUgMTEuOSw2IEw4LjEsNiBDOC41LDQuNiA5LjIsMy4yIDEwLDIgTDEwLDIgWiBNMi4zLDEyIEMyLjEsMTEuNCAyLDEwLjcgMiwxMCBDMiw5LjMgMi4xLDguNiAyLjMsOCBMNS43LDggQzUuNiw4LjcgNS42LDkuMyA1LjYsMTAgQzUuNiwxMC43IDUuNywxMS4zIDUuNywxMiBMMi4zLDEyIEwyLjMsMTIgWiBNMy4xLDE0IEw2LDE0IEM2LjMsMTUuMyA2LjgsMTYuNCA3LjQsMTcuNiBDNS42LDE2LjkgNCwxNS43IDMuMSwxNCBMMy4xLDE0IFogTTYsNiBMMy4xLDYgQzQuMSw0LjMgNS42LDMuMSA3LjQsMi40IEM2LjgsMy42IDYuMyw0LjcgNiw2IEw2LDYgWiBNMTAsMTggQzkuMiwxNi44IDguNSwxNS41IDguMSwxNCBMMTEuOSwxNCBDMTEuNSwxNS40IDEwLjgsMTYuOCAxMCwxOCBMMTAsMTggWiBNMTIuMywxMiBMNy43LDEyIEM3LjYsMTEuMyA3LjUsMTAuNyA3LjUsMTAgQzcuNSw5LjMgNy42LDguNyA3LjcsOCBMMTIuNCw4IEMxMi41LDguNyAxMi42LDkuMyAxMi42LDEwIEMxMi42LDEwLjcgMTIuNCwxMS4zIDEyLjMsMTIgTDEyLjMsMTIgWiBNMTIuNiwxNy42IEMxMy4yLDE2LjUgMTMuNywxNS4zIDE0LDE0IEwxNi45LDE0IEMxNiwxNS43IDE0LjQsMTYuOSAxMi42LDE3LjYgTDEyLjYsMTcuNiBaIE0xNC40LDEyIEMxNC41LDExLjMgMTQuNSwxMC43IDE0LjUsMTAgQzE0LjUsOS4zIDE0LjQsOC43IDE0LjQsOCBMMTcuOCw4IEMxOCw4LjYgMTguMSw5LjMgMTguMSwxMCBDMTguMSwxMC43IDE4LDExLjQgMTcuOCwxMiBMMTQuNCwxMiBMMTQuNCwxMiBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-media {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxOHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxOCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzEuMDAwMDAwLCAtMTcxLjAwMDAwMCkiPjxnIGlkPSJkcml2ZS1pbWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTcxLjAwMDAwMCkiPjxwYXRoIGQ9Ik0xOCwxNiBMMTgsMiBDMTgsMC45IDE3LjEsMCAxNiwwIEwyLDAgQzAuOSwwIDAsMC45IDAsMiBMMCwxNiBDMCwxNy4xIDAuOSwxOCAyLDE4IEwxNiwxOCBDMTcuMSwxOCAxOCwxNy4xIDE4LDE2IEwxOCwxNiBaIE01LjUsMTAuNSBMOCwxMy41IEwxMS41LDkgTDE2LDE1IEwyLDE1IEw1LjUsMTAuNSBMNS41LDEwLjUgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-outline {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00MjMuMDAwMDAwLCAtMzAxLjAwMDAwMCkiPjxnIGlkPSJsaXN0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjMuMDAwMDAwLCAzMDEuMDAwMDAwKSI+PHBhdGggZD0iTTAsNiBMMiw2IEwyLDQgTDAsNCBMMCw2IEwwLDYgWiBNMCwxMCBMMiwxMCBMMiw4IEwwLDggTDAsMTAgTDAsMTAgWiBNMCwyIEwyLDIgTDIsMCBMMCwwIEwwLDIgTDAsMiBaIE00LDYgTDE4LDYgTDE4LDQgTDQsNCBMNCw2IEw0LDYgWiBNNCwxMCBMMTgsMTAgTDE4LDggTDQsOCBMNCwxMCBMNCwxMCBaIE00LDAgTDQsMiBMMTgsMiBMMTgsMCBMNCwwIEw0LDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-reader {
+  background: no-repeat center center url(chrome://browser/skin/readerMode.svg);
+}
+
+.browserStack[secondarybrowser="split"] > browser {
+  width: 50%;
+  justify-self: end;
+}
+.browserStack[secondarybrowser="split"] > .secondarybrowser {
+  /* width: calc(50% - 33px); */
+  /* margin-inline-start: 32px; */
+  width: calc(50% - 1px);
+  justify-self: start;
+  border-right: solid 1px rgba(0, 0, 0, .1);
+}
+.browserStack[secondarybrowser="on"] > browser[messagemanagergroup="browsers"] {
+  z-index: -1;
+}
+.browserStack[secondarybrowser="on"] > .secondarybrowser {
+  /* width: calc(100% - 32px); */
+}
+.browserStack[secondarybrowser="overlay"] > .secondarybrowser {
+  width: 80%;
+  height: 80%;
+  z-index: 1;
+  justify-self: center;
+  align-self: center;
+  outline: solid 2px;
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -1014,16 +1014,21 @@
                   <image id="cfr-button"
                          class="urlbar-icon urlbar-page-action"
                          role="presentation"/>
                 </hbox>
                 <hbox id="userContext-icons" hidden="true">
                   <label id="userContext-label"/>
                   <image id="userContext-indicator"/>
                 </hbox>
+                <image id="secondary-browser-button"
+                       class="urlbar-icon urlbar-page-action"
+                       tooltip="Open secondary browser"
+                       role="button"
+                       onclick="ReaderParent.secondaryBrowserButtonClick(event);"/>
                 <image id="reader-mode-button"
                        class="urlbar-icon urlbar-page-action"
                        tooltip="dynamic-shortcut-tooltip"
                        role="button"
                        hidden="true"
                        onclick="ReaderParent.buttonClick(event);"/>
                 <toolbarbutton id="urlbar-zoom-button"
                        onclick="FullZoom.reset();"
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -607,16 +607,19 @@
     /**
      * Create a findbar instance.
      * @param aTab the tab to create the find bar for.
      * @return the created findbar, or null if the window or tab is closed/closing.
      */
     async _createFindBar(aTab) {
       let findBar = document.createXULElement("findbar");
       let browser = this.getBrowserForTab(aTab);
+      if (browser.secondaryBrowser) {
+        browser = browser.secondaryBrowser;
+      }
 
       // The findbar should be inserted after the browserStack and, if present for
       // this tab, after the StatusPanel as well.
       let insertAfterElement = browser.parentNode;
       if (insertAfterElement.nextElementSibling == StatusPanel.panel) {
         insertAfterElement = StatusPanel.panel;
       }
       insertAfterElement.insertAdjacentElement("afterend", findBar);
@@ -1852,16 +1855,17 @@
       let oldUserTypedValue = aBrowser.userTypedValue;
       let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
       let parent = aBrowser.parentNode;
 
       // Change the "remote" attribute.
 
       // Make sure the browser is destroyed so it unregisters from observer notifications
       aBrowser.destroy();
+
       // Only remove the node if we're not rebuilding the frameloader via nsFrameLoaderOwner.
       let rebuildFrameLoaders =
         E10SUtils.rebuildFrameloadersOnRemotenessChange ||
         window.docShell.nsILoadContext.useRemoteSubframes;
       if (!rebuildFrameLoaders) {
         aBrowser.remove();
       }
 
@@ -2042,20 +2046,21 @@
       openWindowInfo,
       remoteType,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
-      b.permanentKey = new (Cu.getGlobalForObject(Services).Object)();
+      b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
@@ -2094,17 +2099,16 @@
        *      browsers will attempt to switch to a new content process,
        *      therefore the 'preloadedState' attribute is removed from
        *      that browser altogether
        * See more details on Bug 1420285.
        */
       if (isPreloadBrowser) {
         b.setAttribute("preloadedState", "preloaded");
       }
-
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
 
       // Propagate information about the opening content window to the browser.
       if (openWindowInfo) {
         b.openWindowInfo = openWindowInfo;
       }
@@ -2123,19 +2127,156 @@
       // We set large flex on both containers to allow the devtools toolbox to
       // set a flex attribute. We don't want the toolbox to actually take up free
       // space, but we do want it to collapse when the window shrinks, and with
       // flex=0 it can't. When the toolbox is on the bottom it's a sibling of
       // browserStack, and when it's on the side it's a sibling of
       // browserContainer.
       let stack = document.createXULElement("stack");
       stack.className = "browserStack";
+/*
+      let secondaryBrowserControls = document.createXULElement("vbox");
+      secondaryBrowserControls.classList.add("secondarybrowser-controls");
+
+      function createSecondaryBrowserButton(classList, tooltiptext, onClick) {
+        let button = document.createXULElement("toolbarbutton");
+        button.onclick = event => {
+          for (let active of stack.querySelectorAll(
+            ".secondarybrowser-controls toolbarbutton[active]"
+          )) {
+            active.removeAttribute("active");
+          }
+          button.setAttribute("active", "true");
+          onClick(event);
+        };
+        button.classList.add(classList);
+        button.setAttribute("tooltiptext", tooltiptext);
+        return button;
+      }
+
+      let closeSecondaryBrowser = () => {
+        stack.removeAttribute("secondarybrowser");
+        if (b.secondaryBrowser) {
+          this.closeFindbarForTab(this.getTabForBrowser(b));
+          b.destroySecondaryBrowser();
+        }
+        for (let active of stack.querySelectorAll(
+          ".secondarybrowser-controls toolbarbutton[active]"
+        )) {
+          active.removeAttribute("active");
+        }
+      };
+      b.closeSecondaryBrowser = closeSecondaryBrowser;
+
+      let openSecondaryBrowser = () => {
+        if (!b.secondaryBrowser) {
+          this.closeFindbarForTab(this.getTabForBrowser(b));
+          b.before(b.createSecondaryBrowser());
+        }
+        if (!stack.hasAttribute("secondarybrowser")) {
+          stack.setAttribute("secondarybrowser", "on");
+        }
+      };
+      b.openSecondaryBrowser = openSecondaryBrowser;
+
+      let buttonOn = createSecondaryBrowserButton(
+        "secondarybrowser-on",
+        "a11y view",
+        () => {
+          if (stack.getAttribute("secondarybrowser") == "on") {
+            closeSecondaryBrowser();
+          } else {
+            openSecondaryBrowser();
+            b.secondaryBrowser.browsingContext.currentWindowGlobal
+              .getActor("SecondaryBrowser")
+              .sendAsyncMessage("SecondaryBrowser:SetA11YView");
+            stack.setAttribute("secondarybrowser", "on");
+          }
+        }
+      );
+
+      let buttonSplit = createSecondaryBrowserButton(
+        "secondarybrowser-split",
+        "split view",
+        () => {
+          if (stack.getAttribute("secondarybrowser") == "split") {
+            closeSecondaryBrowser();
+          } else {
+            openSecondaryBrowser();
+            b.secondaryBrowser.browsingContext.currentWindowGlobal
+              .getActor("SecondaryBrowser")
+              .sendAsyncMessage("SecondaryBrowser:SetA11YView");
+            stack.setAttribute("secondarybrowser", "split");
+          }
+        }
+      );
+
+      let buttonOff = createSecondaryBrowserButton(
+        "secondarybrowser-off",
+        "default web view",
+        closeSecondaryBrowser
+      );
+
+      let buttonOutline = createSecondaryBrowserButton(
+        "secondarybrowser-outline",
+        "outline view",
+        () => {
+          if (stack.getAttribute("secondarybrowser") == "split") {
+            closeSecondaryBrowser();
+          } else {
+            openSecondaryBrowser();
+
+            b.secondaryBrowser.browsingContext.currentWindowGlobal
+              .getActor("SecondaryBrowser")
+              .sendAsyncMessage("SecondaryBrowser:SetOutlineView");
+
+              stack.setAttribute("secondarybrowser", "split");
+            // XXX: This could be used if we have an 'overlay' view
+            // stack.setAttribute("secondarybrowser", "overlay");
+          }
+        }
+      );
+
+      // let buttonReader = createSecondaryBrowserButton(
+      //   "secondarybrowser-reader",
+      //   "reader mode",
+      //   event => {
+      //     closeSecondaryBrowser();
+      //     ReaderParent.buttonClick(event);
+      //   }
+      // );
+
+      secondaryBrowserControls.append(
+        buttonOff,
+        buttonOn,
+        buttonSplit,
+        buttonOutline
+        // buttonReader
+      );
+      stack.appendChild(secondaryBrowserControls);
+*/
       stack.appendChild(b);
       stack.setAttribute("flex", "10000");
 
+      // console.log(isPreloadBrowser);
+      // if (!isPreloadBrowser) {
+      // }
+      // if (b.secondaryBrowser) {
+      //   b.secondaryBrowser.classList.add("secondarybrowser");
+      //   stack.appendChild(b.secondaryBrowser);
+      // }
+
+      // try {
+      //   secondaryBrowser.loadURI("about:secondarybrowser", {
+      //     triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+      //   });
+      // } catch (ex) {
+      //   Cu.reportError(ex);
+      // }
+
       let browserContainer = document.createXULElement("vbox");
       browserContainer.className = "browserContainer";
       browserContainer.appendChild(notificationbox);
       browserContainer.appendChild(stack);
       browserContainer.setAttribute("flex", "10000");
 
       let browserSidebarContainer = document.createXULElement("hbox");
       browserSidebarContainer.className = "browserSidebarContainer";
@@ -2392,16 +2533,25 @@
         !browser.permitUnload(permitUnloadFlags).permitUnload
       ) {
         return false;
       }
 
       return true;
     },
 
+    closeFindbarForTab(aTab) {
+      // Reset the findbar and remove it if it is attached to the tab.
+      if (aTab._findBar) {
+        aTab._findBar.close(true);
+        aTab._findBar.remove();
+        delete aTab._findBar;
+      }
+    },
+
     discardBrowser(aTab, aForceDiscard) {
       "use strict";
       let browser = aTab.linkedBrowser;
 
       if (!this._mayDiscardBrowser(aTab, aForceDiscard)) {
         return false;
       }
 
@@ -2429,22 +2579,17 @@
       let listener = this._tabListeners.get(aTab);
       browser.webProgress.removeProgressListener(filter);
       filter.removeProgressListener(listener);
       listener.destroy();
 
       this._tabListeners.delete(aTab);
       this._tabFilters.delete(aTab);
 
-      // Reset the findbar and remove it if it is attached to the tab.
-      if (aTab._findBar) {
-        aTab._findBar.close(true);
-        aTab._findBar.remove();
-        delete aTab._findBar;
-      }
+      this.closeFindbarForTab();
 
       // Remove stale loading attributes.
       let attributesToRemove = ["busy", "progress", "pendingicon"];
       let removedAttributes = [];
       for (let attr of attributesToRemove) {
         if (aTab.hasAttribute(attr)) {
           removedAttributes.push(attr);
           aTab.removeAttribute(attr);
@@ -4145,16 +4290,26 @@
 
     announceWindowCreated(browser, userContextId) {
       let tab = this.getTabForBrowser(browser);
       if (tab && userContextId) {
         ContextualIdentityService.telemetry(userContextId);
         tab.setUserContextId(userContextId);
       }
 
+      // Automatically create the secondaryBrowser:
+      // XXX: this should only happen if the tab previously had it or if
+      // there's some global state
+      if (tab) {
+        // if (!browser.secondaryBrowser) {
+        //   // XXX: Make a module to control the sidebar here instead of random clicking
+        //   browser.parentNode.querySelector(".secondarybrowser-split").click();
+        // }
+      }
+
       // We don't want to update the container icon and identifier if
       // this is not the selected browser.
       if (browser == gBrowser.selectedBrowser) {
         updateUserContextUIIndicator();
       }
     },
 
     reloadMultiSelectedTabs() {
@@ -5133,17 +5288,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
@@ -5473,16 +5627,21 @@
 
       let onTabCrashed = event => {
         if (!event.isTrusted || !event.isTopFrame) {
           return;
         }
 
         let browser = event.originalTarget;
 
+        if (browser.hostBrowser) {
+          console.error("secondarybrowser crashed");
+          return;
+        }
+
         // Preloaded browsers do not actually have any tabs. If one crashes,
         // it should be released and removed.
         if (browser === this.preloadedBrowser) {
           NewTabPagePreloading.removePreloadedBrowser(window);
           return;
         }
 
         let isRestartRequiredCrash =
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -87,16 +87,32 @@ let ACTORS = {
         AboutLoginsSyncEnable: { wantUntrusted: true },
         AboutLoginsSyncOptions: { wantUntrusted: true },
         AboutLoginsUpdateLogin: { wantUntrusted: true },
       },
     },
     matches: ["about:logins", "about:logins?*"],
   },
 
+  SecondaryBrowser: {
+    parent: {
+      moduleURI: "resource:///actors/secondarybrowserParent.jsm",
+    },
+    child: {
+      moduleURI: "resource:///actors/SecondaryBrowserChild.jsm",
+      events: {
+        SecondaryBrowserContentView: { wantUntrusted: true },
+        SecondaryBrowserContentLoaded: { wantUntrusted: true },
+        SecondaryBrowserContentClicked: { wantUntrusted: true },
+        SecondaryBrowserContentScroll: { wantUntrusted: true },
+        SecondaryBrowserContentEvent: { wantUntrusted: true },
+      },
+    },
+  },
+
   AboutNewTab: {
     child: {
       moduleURI: "resource:///actors/AboutNewTabChild.jsm",
       events: {
         DOMContentLoaded: {},
       },
     },
     // The wildcard on about:newtab is for the ?endpoint query parameter
diff --git a/browser/components/about/AboutRedirector.cpp b/browser/components/about/AboutRedirector.cpp
--- a/browser/components/about/AboutRedirector.cpp
+++ b/browser/components/about/AboutRedirector.cpp
@@ -103,16 +103,20 @@ static const RedirEntry kRedirMap[] = {
      nsIAboutModule::ALLOW_SCRIPT},
     {"downloads",
      "chrome://browser/content/downloads/contentAreaDownloadsView.xhtml",
      nsIAboutModule::ALLOW_SCRIPT},
     {"reader", "chrome://global/content/reader/aboutReader.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::HIDE_FROM_ABOUTABOUT},
+    {"secondarybrowser", "chrome://browser/content/secondarybrowser/secondaryui.html",
+     nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
+         nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_CAN_LOAD_IN_CHILD |
+         nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"restartrequired", "chrome://browser/content/aboutRestartRequired.xhtml",
      nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"newinstall", "chrome://browser/content/newInstallPage.html",
      nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"protections", "chrome://browser/content/protections.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
diff --git a/browser/components/about/components.conf b/browser/components/about/components.conf
--- a/browser/components/about/components.conf
+++ b/browser/components/about/components.conf
@@ -1,15 +1,16 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 pages = [
+    'secondarybrowser',
     'blocked',
     'certerror',
     'config',
     'downloads',
     'framecrashed',
     'home',
     'logins',
     'newinstall',
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -25,16 +25,17 @@ with Files("safebrowsing/**"):
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
 
 
 DIRS += [
     'about',
     'aboutconfig',
     'aboutlogins',
+    'secondarybrowser',
     'attribution',
     'contextualidentity',
     'customizableui',
     'dirprovider',
     'doh',
     'downloads',
     'enterprisepolicies',
     'extensions',
diff --git a/browser/components/secondarybrowser/A11YMode.jsm b/browser/components/secondarybrowser/A11YMode.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/A11YMode.jsm
@@ -0,0 +1,547 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["A11YWalker"];
+
+const { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+const { setTimeout } = ChromeUtils.import("resource://gre/modules/Timer.jsm");
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+
+
+const SCROLL_TYPE_ANYWHERE = Ci.nsIAccessibleScrollType.SCROLL_TYPE_ANYWHERE;
+
+const {
+  EVENT_SHOW,
+  EVENT_HIDE,
+  EVENT_REORDER,
+  EVENT_ACTIVE_DECENDENT_CHANGED,
+  EVENT_FOCUS,
+  EVENT_STATE_CHANGE,
+  EVENT_LOCATION_CHANGE,
+  EVENT_NAME_CHANGE,
+  EVENT_DESCRIPTION_CHANGE,
+  EVENT_VALUE_CHANGE,
+  EVENT_HELP_CHANGE,
+  EVENT_DEFACTION_CHANGE,
+  EVENT_ACTION_CHANGE,
+  EVENT_ACCELERATOR_CHANGE,
+  EVENT_SELECTION,
+  EVENT_SELECTION_ADD,
+  EVENT_SELECTION_REMOVE,
+  EVENT_SELECTION_WITHIN,
+  EVENT_ALERT,
+  EVENT_FOREGROUND,
+  EVENT_MENU_START,
+  EVENT_MENU_END,
+  EVENT_MENUPOPUP_START,
+  EVENT_MENUPOPUP_END,
+  EVENT_CAPTURE_START,
+  EVENT_CAPTURE_END,
+  EVENT_MOVESIZE_START,
+  EVENT_MOVESIZE_END,
+  EVENT_CONTEXTHELP_START,
+  EVENT_CONTEXTHELP_END,
+  EVENT_DRAGDROP_START,
+  EVENT_DRAGDROP_END,
+  EVENT_DIALOG_START,
+  EVENT_DIALOG_END,
+  EVENT_SCROLLING_START,
+  EVENT_SCROLLING_END,
+  EVENT_MINIMIZE_START,
+  EVENT_MINIMIZE_END,
+  EVENT_DOCUMENT_LOAD_COMPLETE,
+  EVENT_DOCUMENT_RELOAD,
+  EVENT_DOCUMENT_LOAD_STOPPED,
+  EVENT_DOCUMENT_ATTRIBUTES_CHANGED,
+  EVENT_DOCUMENT_CONTENT_CHANGED,
+  EVENT_PROPERTY_CHANGED,
+  EVENT_PAGE_CHANGED,
+  EVENT_TEXT_ATTRIBUTE_CHANGED,
+  EVENT_TEXT_CARET_MOVED,
+  EVENT_TEXT_CHANGED,
+  EVENT_TEXT_INSERTED,
+  EVENT_TEXT_REMOVED,
+  EVENT_TEXT_UPDATED,
+  EVENT_TEXT_SELECTION_CHANGED,
+  EVENT_VISIBLE_DATA_CHANGED,
+  EVENT_TEXT_COLUMN_CHANGED,
+  EVENT_SECTION_CHANGED,
+  EVENT_TABLE_CAPTION_CHANGED,
+  EVENT_TABLE_MODEL_CHANGED,
+  EVENT_TABLE_SUMMARY_CHANGED,
+  EVENT_TABLE_ROW_DESCRIPTION_CHANGED,
+  EVENT_TABLE_ROW_HEADER_CHANGED,
+  EVENT_TABLE_ROW_INSERT,
+  EVENT_TABLE_ROW_DELETE,
+  EVENT_TABLE_ROW_REORDER,
+  EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED,
+  EVENT_TABLE_COLUMN_HEADER_CHANGED,
+  EVENT_TABLE_COLUMN_INSERT,
+  EVENT_TABLE_COLUMN_DELETE,
+  EVENT_TABLE_COLUMN_REORDER,
+  EVENT_WINDOW_ACTIVATE,
+  EVENT_WINDOW_CREATE,
+  EVENT_WINDOW_DEACTIVATE,
+  EVENT_WINDOW_DESTROY,
+  EVENT_WINDOW_MAXIMIZE,
+  EVENT_WINDOW_MINIMIZE,
+  EVENT_WINDOW_RESIZE,
+  EVENT_WINDOW_RESTORE,
+  EVENT_HYPERLINK_END_INDEX_CHANGED,
+  EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED,
+  EVENT_HYPERLINK_SELECTED_LINK_CHANGED,
+  EVENT_HYPERTEXT_LINK_ACTIVATED,
+  EVENT_HYPERTEXT_LINK_SELECTED,
+  EVENT_HYPERLINK_START_INDEX_CHANGED,
+  EVENT_HYPERTEXT_CHANGED,
+  EVENT_HYPERTEXT_NLINKS_CHANGED,
+  EVENT_OBJECT_ATTRIBUTE_CHANGED,
+  EVENT_VIRTUALCURSOR_CHANGED,
+  EVENT_TEXT_VALUE_CHANGE,
+  EVENT_SCROLLING,
+  EVENT_ANNOUNCEMENT,
+} = Ci.nsIAccessibleEvent;
+
+const RELATIONS_TO_IGNORE = new Set([
+  Ci.nsIAccessibleRelation.RELATION_CONTAINING_APPLICATION,
+  Ci.nsIAccessibleRelation.RELATION_CONTAINING_TAB_PANE,
+  Ci.nsIAccessibleRelation.RELATION_CONTAINING_WINDOW,
+  Ci.nsIAccessibleRelation.RELATION_PARENT_WINDOW_OF,
+  Ci.nsIAccessibleRelation.RELATION_SUBWINDOW_OF,
+]);
+
+const nsIAccessibleRole = Ci.nsIAccessibleRole;
+const TEXT_ROLES = new Set([
+  nsIAccessibleRole.ROLE_TEXT_LEAF,
+  nsIAccessibleRole.ROLE_STATICTEXT,
+]);
+
+const STATE_DEFUNCT = Ci.nsIAccessibleStates.EXT_STATE_DEFUNCT;
+
+function throttle(that, callback, limit) {
+  var wait = false;
+  return function() {
+    if (!wait) {
+      callback.apply(that, arguments);
+      wait = true;
+      setTimeout(function() {
+        wait = false;
+      }, limit);
+    }
+  };
+}
+
+/**
+ * Helper function that determines if nsIAccessible object is in defunct state.
+ *
+ * @param  {nsIAccessible}  accessible
+ *         object to be tested.
+ * @return {Boolean}
+ *         True if accessible object is defunct, false otherwise.
+ */
+function isDefunct(accessible) {
+  // If accessibility is disabled, safely assume that the accessible object is
+  // now dead.
+  if (!Services.appinfo.accessibilityEnabled) {
+    return true;
+  }
+
+  let defunct = false;
+
+  try {
+    const extraState = {};
+    accessible.getState({}, extraState);
+    // extraState.value is a bitmask. We are applying bitwise AND to mask out
+    // irrelevant states.
+    defunct = !!(extraState.value & Ci.nsIAccessibleStates.EXT_STATE_DEFUNCT);
+  } catch (e) {
+    defunct = true;
+  }
+
+  return defunct;
+}
+
+/**
+ * Helper function that determines if nsIAccessible object is in stale state. When an
+ * object is stale it means its subtree is not up to date.
+ *
+ * @param  {nsIAccessible}  accessible
+ *         object to be tested.
+ * @return {Boolean}
+ *         True if accessible object is stale, false otherwise.
+ */
+function isStale(accessible) {
+  const extraState = {};
+  accessible.getState({}, extraState);
+  // extraState.value is a bitmask. We are applying bitwise AND to mask out
+  // irrelevant states.
+  return !!(extraState.value & Ci.nsIAccessibleStates.EXT_STATE_STALE);
+}
+
+function sendToContent(browsingContext, messageType, detail = {}) {
+  let win = browsingContext.window;
+  let message = Object.assign({ messageType }, { value: detail });
+  // console.log(message);
+  let event = new win.CustomEvent("SecondaryBrowserChromeToContent", {
+    detail: Cu.cloneInto(message, win),
+  });
+  win.dispatchEvent(event);
+}
+
+const gSingletonObserver = {
+  QueryInterface: ChromeUtils.generateQI([
+    Ci.nsIObserver,
+    Ci.nsISupportsWeakReference,
+  ]),
+
+  get a11yService() {
+    if (!this._a11yService) {
+      // This turns on accessibility automatically (see Services.appinfo.accessibilityEnabled)
+      // See https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/accessibility-parent.js#135 for more lifecycle
+      this._a11yService = Cc["@mozilla.org/accessibilityService;1"].getService(
+        Ci.nsIAccessibilityService
+      );
+    }
+    return this._a11yService;
+  },
+
+  on(listener) {
+    if (!this._listeners) {
+      this._listeners = new Set();
+    }
+    if (!this._listeners.size) {
+      this.a11yService;
+      console.log("Adding listener");
+      Services.obs.addObserver(this, "accessible-event");
+    }
+    this._listeners.add(listener);
+    console.log(this._listeners.size, "listenesr");
+  },
+
+  off(listener) {
+    if (this._listeners.has(listener) && this._listeners.size == 1) {
+      console.log("Removing observer");
+      Services.obs.removeObserver(this, "accessible-event");
+    }
+    this._listeners.delete(listener);
+  },
+
+  observe(subject) {
+    const event = subject.QueryInterface(Ci.nsIAccessibleEvent);
+    for (let listener of this._listeners.values()) {
+      try {
+        if (
+          event.accessibleDocument &&
+          listener.hostBrowsingContext.window.document ==
+            event.accessibleDocument.DOMDocument
+        ) {
+          listener.changeObserved(event);
+        }
+      } catch (e) {
+        Cu.reportError(e);
+      }
+    }
+  },
+};
+
+class A11YWalker {
+  constructor(hostBrowsingContext, overlayBrowsingContext) {
+    this.overlayBrowsingContext = overlayBrowsingContext;
+    this.hostBrowsingContext = hostBrowsingContext;
+    this.accToAccId = new WeakMap();
+    this.accIdToAcc = new Map();
+    // XXX: this causes some stuff to get missed since we only get the event for
+    // first or last node. We really need to optimize hide / textRemoved
+    this.changeObserved = throttle(this, this.changeObserved, 50);
+
+    // overlayToAccMap.set(this.overlayBrowsingContext, new WeakMap());
+    gSingletonObserver.on(this);
+  }
+
+  destruct() {
+    gSingletonObserver.off(this);
+    this.overlayBrowsingContext = this.hostBrowsingContext = null;
+  }
+
+  get a11yService() {
+    return gSingletonObserver.a11yService;
+  }
+
+  getStringRole(role) {
+    if (!this.KNOWN_ROLES) {
+      this.KNOWN_ROLES = {};
+    }
+    if (!this.KNOWN_ROLES[role]) {
+      this.KNOWN_ROLES[role] = this.a11yService.getStringRole(role);
+    }
+    return this.KNOWN_ROLES[role];
+  }
+
+  /**
+   * Get a snapshot of the nsIAccessible object including its subtree. None of the subtree
+   * queried here is cached via accessible walker's refMap.
+   * @param  {nsIAccessible} acc
+   *         Accessible object to take a snapshot of.
+   * @param  {nsIAccessibilityService} a11yService
+   *         Accessibility service instance in the current process, used to get localized
+   *         string representation of various accessible properties.
+   * @return {JSON}
+   *         JSON snapshot of the accessibility tree with root at current accessible.
+   */
+  doSnapshot(acc, a11yService) {
+    if (isDefunct(acc)) {
+      return {
+        states: [a11yService.getStringStates(0, STATE_DEFUNCT)],
+      };
+    }
+    if (!this.accToAccId.has(acc)) {
+      this.accToAccId.set(acc, acc.uniqueID);
+    }
+    this.accIdToAcc.set(acc.uniqueID, acc);
+
+    const actions = [];
+    for (let i = 0; i < acc.actionCount; i++) {
+      actions.push(acc.getActionDescription(i));
+    }
+
+    const attributes = {};
+    // console.log(acc.attributes);
+    if (acc.attributes) {
+      // This is slow:
+      // for (const { key, value } of acc.attributes.enumerate()) {
+      //   attributes[key] = value;
+      // }
+      // let's only grab what's necesssary
+      try {
+        attributes["xml-roles"] = acc.attributes.getStringProperty("xml-roles");
+      } catch (e) {}
+      try {
+        attributes.tag = acc.attributes.getStringProperty("tag");
+      } catch (e) {}
+      try {
+        attributes.src = acc.attributes.getStringProperty("src");
+      } catch (e) {}
+    }
+
+    if (acc.DOMNode.tagName == "IMG") {
+      // Would be nice to blob url this if there was a way to keep exact format
+      // and ideally sync. In the meantime let's just use the abs path and have the
+      // view re-fetch it.
+      attributes.src = acc.DOMNode.src;
+      // let {
+      //   width,
+      //   height,
+      // } = acc.DOMNode.ownerGlobal.windowUtils.getBoundsWithoutFlushing(
+      //   acc.DOMNode
+      // );
+      // attributes.width = width;
+      // attributes.height = height;
+    }
+
+    // const state = {};
+    // const extState = {};
+    // acc.getState(state, extState);
+    const states = [
+      // ...a11yService.getStringStates(state.value, extState.value),
+    ];
+
+    const children = [];
+    for (let child = acc.firstChild; child; child = child.nextSibling) {
+      children.push(this.doSnapshot(child, a11yService));
+    }
+
+    return {
+      name: acc.name,
+      role: this.getStringRole(acc.role),
+      actions,
+      value: acc.value,
+      // nodeType: acc.DOMNode.nodeType,
+      description: acc.description,
+      keyboardShortcut: acc.accessKey || acc.keyboardShortcut,
+      // childCount: acc.childCount,
+      // indexInParent: acc.indexInParent, // XXX: Crash on cdc page when navigating to french
+      states,
+      children,
+      attributes,
+      id: acc.uniqueID,
+    };
+  }
+
+  /**
+   * Get a raw accessible object for a raw node.
+   * @param  {DOMNode} rawNode
+   *         Raw node for which accessible object is being retrieved.
+   * @return {nsIAccessible}
+   *         Accessible object for a given DOMNode.
+   */
+  getRawAccessibleFor(rawNode) {
+    // Accessible can only be retrieved iff accessibility service is enabled.
+    if (!Services.appinfo.accessibilityEnabled) {
+      return null;
+    }
+
+    return this.a11yService.getAccessibleFor(rawNode);
+  }
+
+  getAccessibleForAccID(accId) {
+    return this.accIdToAcc.get(parseInt(accId));
+  }
+
+  scrollTo(accId) {
+    let acc = this.getAccessibleForAccID(accId);
+    if (!acc) {
+      throw new Error(
+        `No accId ${accId}. We should be sending down actual ids from platform so this doesn't happen.`
+      );
+    }
+
+    acc.DOMNode.scrollIntoView();
+    // OR:
+    // acc.scrollTo(SCROLL_TYPE_ANYWHERE);
+  }
+
+  doAction(accId) {
+    let acc = this.getAccessibleForAccID(accId);
+    if (!acc) {
+      throw new Error(
+        `No accId ${accId}. We should be sending down actual ids from platform so this doesn't happen.`
+      );
+    }
+
+    for (let i = 0; i < acc.actionCount; i++) {
+      console.log(i, acc.getActionName(i));
+    }
+
+    console.log(acc, acc.DOMNode, acc.actionCount);
+    acc.doAction(0);
+  }
+
+  getSnapshot(acc) {
+    this.accIdToAcc.clear();
+    console.log(acc);
+    return this.doSnapshot(acc, this.a11yService);
+  }
+
+  // getSnapshot2(acc, parent) {
+  //   overlayToAccIdMap.set(this.overlayBrowsingContext, new Map());
+  //   let el = overlayToAccMap.get(this.overlayBrowsingContext).get(acc)
+  //     ? overlayToAccMap.get(this.overlayBrowsingContext).get(acc).el
+  //     : null;
+
+  //   // let yuck = acc.toString().match(/ \@ (.*) \(/)[1];
+  //   // console.log(this.a11yService.getStringRole(acc.role), acc.toString(), yuck);
+  //   if (el) {
+  //     // console.log(el);
+  //   } else {
+  //     el = this.overlayBrowsingContext.window.document.createElement("div");
+  //     el.textContent = this.getStringRole(acc.role);
+  //     el.addEventListener("click", () => {
+  //       // console.log("CLICKED", el);
+  //     });
+  //   }
+
+  //   const children = [];
+  //   let ret = {
+  //     self: acc,
+  //     children,
+  //     el,
+  //   };
+  //   overlayToAccMap.get(this.overlayBrowsingContext).set(acc, ret);
+
+  //   for (let child = acc.firstChild; child; child = child.nextSibling) {
+  //     children.push(this.getSnapshot2(child, ret));
+  //   }
+
+  //   // let container = parent
+  //   //   ? parent.el
+  //   //   : this.overlayBrowsingContext.window.document.body;
+  //   // container.appendChild(el);
+
+  //   return ret;
+  // }
+  sendSnapshot() {
+    let start = this.overlayBrowsingContext.window.performance.now();
+
+    // this.overlayBrowsingContext.window.document.body.innerHTML = "";
+    // let snapshot = this.getSnapshot(
+    //   this.getRawAccessibleFor(this.hostBrowsingContext.window.document)
+    // );
+    let snapshot = this.getSnapshot(
+      this.getRawAccessibleFor(this.hostBrowsingContext.window.document)
+    );
+
+    console.log(
+      `Created snapshot (traversed ${this.accIdToAcc.size} nodes)`,
+
+      this.overlayBrowsingContext.window.performance.now() - start
+    );
+    sendToContent(this.overlayBrowsingContext, "TreeChanged", snapshot);
+  }
+
+  /**
+   * Accessible event observer function.
+   *
+   * @param {Ci.nsIAccessibleEvent} subject
+   *                                      accessible event object.
+   */
+  // eslint-disable-next-line complexity
+  changeObserved(event) {
+    // See https://searchfox.org/mozilla-central/rev/c79c0d65a183d9d38676855f455a5c6a7f7dadd3/devtools/server/actors/accessibility/walker.js#621
+    // for a more complete example
+
+    // Don't worry about scrolling. The overlay view doesn't care about it.
+    // XXX: Instead of opting out of events we are opting in to only the ones
+    // we care about below. Leaving this since there are so many events
+    // we may want to go back to something like this
+    // if (
+    //   event.eventType == EVENT_SCROLLING_START ||
+    //   event.eventType == EVENT_SCROLLING_END ||
+    //   event.eventType == EVENT_SCROLLING
+    // ) {
+    //   return;
+    // }
+
+    // XXX: Always sending the whole snapshot for everything.
+    // Some of these should be relatively easy to keep a data source
+    // up to date for example name_change. Then the trick will be doing
+    // a minimal amount of updates from that tree into DOM (maybe vdom).
+    if (
+      event.eventType == EVENT_DOCUMENT_RELOAD ||
+      event.eventType == EVENT_DOCUMENT_LOAD_STOPPED ||
+      event.eventType == EVENT_DOCUMENT_LOAD_COMPLETE ||
+      event.eventType == EVENT_TEXT_CHANGED ||
+      event.eventType == EVENT_TEXT_INSERTED ||
+      event.eventType == EVENT_TEXT_REMOVED ||
+      event.eventType == EVENT_ACCELERATOR_CHANGE ||
+      event.eventType == EVENT_ACTION_CHANGE ||
+      event.eventType == EVENT_DEFACTION_CHANGE ||
+      event.eventType == EVENT_DESCRIPTION_CHANGE ||
+      event.eventType == EVENT_DOCUMENT_ATTRIBUTES_CHANGED ||
+      event.eventType == EVENT_HIDE ||
+      event.eventType == EVENT_SHOW ||
+      event.eventType == EVENT_NAME_CHANGE ||
+      event.eventType == EVENT_OBJECT_ATTRIBUTE_CHANGED ||
+      event.eventType == EVENT_REORDER ||
+      event.eventType == EVENT_STATE_CHANGE ||
+      event.eventType == EVENT_TEXT_ATTRIBUTE_CHANGED ||
+      event.eventType == EVENT_VALUE_CHANGE
+    ) {
+      console.log(
+        "Processing change",
+        this.a11yService.getStringEventType(event.eventType)
+      );
+      this.sendSnapshot();
+    } else {
+      console.log(
+        "Ignoring change",
+        this.a11yService.getStringEventType(event.eventType),
+        event.accessible.DOMNode
+      );
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/SecondaryBrowserChild.jsm b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
@@ -0,0 +1,185 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/* TODOS:
+
+General:
+- Move 'split mode' into the default a11y view (alongside debug checkbox)
+   This will need to signal up via message manager to parent
+- Fix state initialization between outline and a11y view
+- Maybe move all controls into the secondary browser page instead of
+   as sidebars in parent, then add page action button. Control split
+   state from the about page (automatcally for outline and then via
+   toggle for a11y view)
+- videos (maybe PiP can do something to render in the a11y view?)
+- vdom or some other way to prevent innerHTML from being wiped out due to incremental change (which would break text selection, input focus, etc)
+--- exposing some kind of unique id for nsIAccessible might help here.
+    x this has been done (at least hackily), and our consumers just need to be updated (see nsIAccessible.uniqueID)
+- render svgs. Data URI? See Page Info for rendering remote resources (triggeringprinciple on img?)
+- context menu for secondary browser
+
+A11Y View:
+- send scroll / mouse events occasionally to trigger lazy loading
+  for instance on reddit.com
+- forward key events?
+- scroll to top of page on document navigation from host
+- make fragment links (i.e. "skip to content") work in secondary view
+- integrate reader view controls for text rendering and voice over (if possible)
+- Narrate -> Will read everything in the DOM
+- Convert "label for" into uniqueID reference so we can properly associate <label> and <input> and/or use placeholder text instead
+- form controls interactivity (a start is there for text inputs)
+- Individual interface attributes aren't exposed to tree and so we can't render irregular table headers, for instance
+    https://searchfox.org/mozilla-central/source/accessible/generic/TableAccessible.h
+
+Outline View:
+- See the old preexisting bug: https://bugzilla.mozilla.org/show_bug.cgi?id=670928 / https://bugzilla.mozilla.org/show_bug.cgi?id=321634
+- Keyboard optimizations: "Virtual cursor" aka highlight individual nodes and navigate with keys, then have a shortcut
+  to move back and forth between the element on the page and the controls (i.e. one shortcut
+    to scroll to a link and focus the main browser window, and another to click the link).
+
+*/
+
+const EXPORTED_SYMBOLS = ["SecondaryBrowserChild"];
+ChromeUtils.defineModuleGetter(
+  this,
+  "A11YWalker",
+  "resource:///modules/A11YMode.jsm"
+);
+
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+
+const hostToSecondaryBrowserMap = new WeakMap();
+const overlayToA11YWalkerMap = new WeakMap();
+
+function sendToContent(browsingContext, messageType, detail = {}) {
+  let win = browsingContext.window;
+  let message = Object.assign({ messageType }, { value: detail });
+  let event = new win.CustomEvent("SecondaryBrowserChromeToContent", {
+    detail: Cu.cloneInto(message, win),
+  });
+  win.dispatchEvent(event);
+}
+
+// See stuff like https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/walker.js#499
+
+// Basic idea here is to use this actor to receive the accessibility tree and
+// subsequent events from a 'host' browser, and then to send them along to an
+// 'secondarybrowser' browser (which are running in the same content process)
+// Maybe this should be two different actors?
+class SecondaryBrowserChild extends JSWindowActorChild {
+  willDestroy(e) {
+    // Overlay is destroyed. Kill observing:
+    if (overlayToA11YWalkerMap.has(this.browsingContext)) {
+      overlayToA11YWalkerMap.get(this.browsingContext).destruct();
+      overlayToA11YWalkerMap.delete(this.browsingContext);
+    }
+  }
+  actorCreated(e) {
+    // I think it's better to wait for SecondaryBrowserContentLoaded to
+    // signal the connection so there's no races.. but maybe this
+    // would come in handy somehow?
+  }
+
+  receiveMessage(message) {
+    console.log(
+      "SecondaryBrowserChild::receiveMessage",
+      message.name,
+      Services.appinfo.processID,
+      this.browsingContext.window.location.toString()
+    );
+    switch (message.name) {
+      case "SecondaryBrowser:UpdateBrowsingContext":
+        const { browsingContext, initialView } = message.data;
+        const walker = new A11YWalker(this.browsingContext, browsingContext);
+        hostToSecondaryBrowserMap.set(this.browsingContext, browsingContext);
+        overlayToA11YWalkerMap.set(browsingContext, walker);
+
+        if (initialView == "outline") {
+          sendToContent(this.browsingContext, "SetOutlineView");
+        }
+
+        // This is only called aftter the initial SecondaryBrowserContentLoaded happens,
+        // so send an entire snapshot now (we can then observe and signal incrementtal
+        // changes later).
+        walker.sendSnapshot();
+        break;
+      case "SecondaryBrowser:SetA11YView":
+        sendToContent(this.browsingContext, "SetA11YView");
+        break;
+      case "SecondaryBrowser:SetOutlineView":
+        sendToContent(this.browsingContext, "SetOutlineView");
+        break;
+    }
+  }
+  handleEvent(event) {
+    console.log(event);
+    switch (event.type) {
+      case "SecondaryBrowserContentView":
+        if (event.detail.split) {
+          this.sendAsyncMessage("SecondaryBrowser:Split");
+        } else {
+          this.sendAsyncMessage("SecondaryBrowser:Unsplit");
+        }
+        break;
+      case "SecondaryBrowserContentLoaded":
+        // We can either sendToContent or directly change the DOM:
+        console.log(
+          "SecondaryBrowserContentLoaded, PID:",
+          Services.appinfo.processID
+        );
+        let title = this.document.querySelector("#debug-title");
+        title.textContent = `PID: ${Services.appinfo.processID}`;
+        this.sendAsyncMessage("SecondaryBrowser:WindowCreated");
+        break;
+      case "SecondaryBrowserContentEvent":
+        // XXX: Either accept input on the overlay then use nsIAccessibleEditableText
+        // to set it on the host. Or prevent default on the overlay then EventUtils.synthesizeKey
+        // on the host and wait for a round trip to update the overlay.
+
+        // Also, we could maybe create the DOM for secondaryui.js in this file and keep a direct
+        // reference to overlay DOM node and host DOM node, hooking together key events
+        // that way somehow?
+
+        // XXX: Also check pagehide/pageshow on host
+
+        // XXX: also test findbar wiring with overlay
+
+        // XXX: Unique acc to DOMnode weakmap?
+        if (overlayToA11YWalkerMap.has(this.browsingContext)) {
+          let input = overlayToA11YWalkerMap
+            .get(this.browsingContext)
+            .getAccessibleForAccID(event.detail.accId).DOMNode;
+
+          if (input.tagName == "INPUT") {
+            input.setUserInput(event.detail.event.target.value);
+          }
+
+          // overlayToA11YWalkerMap
+          //   .get(this.browsingContext)
+          //   .doAction(event.detail.accId);
+        }
+        break;
+      case "SecondaryBrowserContentClicked":
+        // console.log("Received command for ", event.detail.accId);
+        if (overlayToA11YWalkerMap.has(this.browsingContext)) {
+          overlayToA11YWalkerMap
+            .get(this.browsingContext)
+            .doAction(event.detail.accId);
+        }
+        break;
+      case "SecondaryBrowserContentScroll":
+        if (overlayToA11YWalkerMap.has(this.browsingContext)) {
+          overlayToA11YWalkerMap
+            .get(this.browsingContext)
+            .scrollTo(event.detail.accId);
+
+          // XXX: This could be used if we have an 'overlay' view
+          // this.sendAsyncMessage("SecondaryBrowser:Close");
+        }
+        break;
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/SecondaryBrowserParent.jsm b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
@@ -0,0 +1,59 @@
+/* vim: set ts=2 sw=2 sts=2 et tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+var EXPORTED_SYMBOLS = ["SecondaryBrowserParent"];
+
+class SecondaryBrowserParent extends JSWindowActorParent {
+  receiveMessage(message) {
+    // console.log("SecondaryBrowserParent::receiveMessage", message);
+    let browser = this.manager.browsingContext.embedderElement;
+    if (!browser) {
+      return; // Can happen sometimes if browser is being destroyed
+    }
+    if (!browser.hostBrowser) {
+      // This shouldn't really happen - the message is coming from a secondary browser
+      // which by definition should have a host.
+      return;
+    }
+
+    switch (message.name) {
+      // XXX: This could be used if we have an 'overlay' view
+      case "SecondaryBrowser:Close": {
+        browser.hostBrowser.closeSecondaryBrowser();
+        break;
+      }
+      case "SecondaryBrowser:Split": {
+        browser.hostBrowser.parentNode.setAttribute(
+          "secondarybrowser",
+          "split"
+        );
+        break;
+      }
+      case "SecondaryBrowser:Unsplit": {
+        browser.hostBrowser.parentNode.setAttribute("secondarybrowser", "on");
+        break;
+      }
+
+      case "SecondaryBrowser:WindowCreated": {
+        let initialView;
+        // XXX: We need a cleaner way to signal initial state (or just build a prototype
+        // that only deals with outline)
+        initialView = "outline";
+        if (browser.parentNode.getAttribute("secondarybrowser") == "overlay") {
+          initialView = "outline";
+        }
+
+        browser.hostBrowser.browsingContext.currentWindowGlobal
+          .getActor("SecondaryBrowser")
+          .sendAsyncMessage("SecondaryBrowser:UpdateBrowsingContext", {
+            browsingContext: browser.browsingContext,
+            initialView,
+          });
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/content/jar.mn b/browser/components/secondarybrowser/content/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/jar.mn
@@ -0,0 +1,9 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+    content/browser/secondarybrowser/secondaryui.html
+    content/browser/secondarybrowser/secondaryui.js
+    content/browser/secondarybrowser/roles.js
+    content/browser/secondarybrowser/secondaryui.css
diff --git a/browser/components/secondarybrowser/content/roles.js b/browser/components/secondarybrowser/content/roles.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/roles.js
@@ -0,0 +1,1597 @@
+// Built from https://searchfox.org/mozilla-central/source/accessible/base/RoleMap.h
+// Copy in the contents of that file and then
+// VSCode: Find with regex ".*" and then alt+enter to select all
+"use strict";
+
+window.ROLE_MAP = {
+  nothing: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  titlebar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  menubar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  scrollbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grip: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  sound: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  cursor: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  caret: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  alert: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  window: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "internal frame": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.classList.add("internal-frame");
+      container.append(...children);
+      return [container];
+    },
+  },
+  menupopup: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  menuitem: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  tooltip: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHelpTag: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  application: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  document: {
+    render(treeItem, children) {
+      return [...children];
+      // let container = document.createElement("h1");
+      // container.textContent = `${treeItem.name}`;
+      // return [container, ...children];
+    },
+  },
+  AXWebArea: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  pane: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  chart: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  dialog: {
+    render(treeItem, children) {
+      // XXX: Use something like https://github.com/edenspiekermann/a11y-dialog/tree/master/example?
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  border: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grouping: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  separator: {
+    render(treeItem, children) {
+      let container = document.createElement("hr");
+      return [container];
+    },
+  },
+  toolbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  statusbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  table: {
+    render(treeItem, children) {
+      let container = document.createElement("table");
+      container.append(...children);
+      return [container];
+    },
+  },
+  columnheader: {
+    // See https://www.w3.org/WAI/tutorials/tables/irregular/
+    // https://matrix.to/#/!jmuErVonajdNMbgdeY:mozilla.org/$jesupx87ZSzpVWWWp2iQYEBHnQeRadQilupRbngtW80?via=mozilla.org
+    // https://searchfox.org/mozilla-central/source/accessible/generic/TableAccessible.h
+    render(treeItem, children) {
+      let container = document.createElement("th");
+      container.append(...children);
+      return [container];
+    },
+  },
+  rowheader: {
+    render(treeItem, children) {
+      let container = document.createElement("th");
+      container.append(...children);
+      return [container];
+    },
+  },
+  column: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  row: {
+    render(treeItem, children) {
+      let container = document.createElement("tr");
+      container.append(...children);
+      return [container];
+    },
+  },
+  cell: {
+    render(treeItem, children) {
+      let container = document.createElement("td");
+      container.append(...children);
+      return [container];
+    },
+  },
+  link: {
+    render(treeItem, children) {
+      let container = document.createElement("a");
+
+      if (!treeItem.value) {
+        return [...children];
+      }
+
+      if (treeItem.value.toLowerCase().startsWith("javascript:")) {
+        container.href = "#";
+      } else {
+        container.href = treeItem.value;
+      }
+
+      if (children.length) {
+        // XXX: In some cases (i.e. logo on https://developer.mozilla.org/en-US/)
+        // where the child is just an svg image) we also want to include treeItem.name.
+        // In other cases it ends up with duplicated content.
+        container.append(...children);
+      } else {
+        container.append(treeItem.name);
+      }
+
+      container.dataset.accId = treeItem.id;
+      return [container];
+    },
+  },
+  AXLink: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  helpballoon: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHelpTag: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  character: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  list: {
+    render(treeItem, children) {
+      let tag = treeItem.attributes.tag == "ol" ? "ol" : "ul";
+      let container = document.createElement(tag);
+      container.append(...children);
+      return [container];
+    },
+  },
+  listitem: {
+    render(treeItem, children) {
+      let container = document.createElement("li");
+      container.append(...children);
+      return [container];
+    },
+  },
+  outline: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  outlineitem: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  pagetab: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  propertypage: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  indicator: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  graphic: {
+    render(treeItem, children) {
+      if (treeItem.attributes.tag == "svg") {
+        return ["<svg image>"];
+      }
+      if (treeItem.attributes.tag == "_moz_generated_content_image") {
+        // This is for ::before / ::after content.
+        // XXX: Why does this come through the tree?
+        return [];
+      }
+
+      let img = document.createElement("img");
+      img.setAttribute("alt", treeItem.attributes.src);
+      img.setAttribute("src", treeItem.attributes.src);
+      // img.setAttribute("width", treeItem.attributes.width);
+      // img.setAttribute("height", treeItem.attributes.height);
+      return [img];
+    },
+  },
+  statictext: {
+    render(treeItem, children) {
+      if (!treeItem.name) {
+        return [];
+      }
+      return [treeItem.name];
+    },
+  },
+  "text leaf": {
+    render(treeItem, children) {
+      return [treeItem.name];
+      // Leafs will be rendered by parents via name. XXX is that always true?
+      // return [];
+    },
+  },
+  pushbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+
+      if (children.length) {
+        container.append(...children);
+      } else {
+        container.append(treeItem.name || "");
+      }
+      return [container];
+    },
+  },
+  checkbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  radiobutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "1": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  combobox: {
+    render(treeItem, children) {
+      let container = document.createElement("select");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  droplist: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  progressbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  dial: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  hotkeyfield: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  slider: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  spinbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  diagram: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  animation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  equation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttondropdown: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttonmenu: {
+    render(treeItem, children) {
+      // XXX copy over
+
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttondropdowngrid: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  whitespace: {
+    render(treeItem, children) {
+      return [treeItem.name];
+    },
+  },
+  pagetablist: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  clock: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  splitbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  ipaddress: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "accel label": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  arrow: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  canvas: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "check menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "color chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "date editor": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "desktop icon": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "desktop frame": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "directory pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "file chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "font chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "chrome window": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "glass pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "html container": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  icon: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  label: {
+    render(treeItem, children) {
+      let container = document.createElement("label");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "layered pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "option pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "password text": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "popup menu": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "radio menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "root pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "scroll pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "split pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "table column header": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "table row header": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "tear off menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  terminal: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "text container": {
+    render(treeItem, children) {
+      if (treeItem.attributes.tag == "pre") {
+        let container = document.createElement("pre");
+        container.append(...children);
+        return [container];
+      }
+
+      return [...children];
+    },
+  },
+  "toggle button": {
+    render(treeItem, children) {
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "tree table": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  viewport: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  header: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  footer: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  paragraph: {
+    render(treeItem, children) {
+      if (!children.length) {
+        return [];
+      }
+      let container = document.createElement("p");
+      container.append(...children);
+      return [container];
+    },
+  },
+  ruler: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXRuler: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  autocomplete: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  editbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  entry: {
+    render(treeItem, children) {
+      // XXX: [relations] is missing from JSON export but would be needed to set up
+      // proper labeling on i.e. amazon.com.
+      let input = document.createElement("input");
+      input.dataset.accId = treeItem.id;
+
+      input.value = treeItem.value;
+      // container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      // container.append(...children);
+      return [input];
+    },
+  },
+  caption: {
+    render(treeItem, children) {
+      let container = document.createElement("caption");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "non-native document": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  heading: {
+    render(treeItem, children) {
+      let tag = treeItem.attributes.tag;
+      let container = document.createElement(tag); // XXX: make sure it's an h tag
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHeading: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  page: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  section: {
+    render(treeItem, children) {
+      // Section holds 0 or 1 children.. just skip it.
+      // XXX: Do we need to include a section for certain single-children (display inline?)
+      // if (!children.length || children.length === 1) {
+      //   return [...children];
+      // }
+      // Use display: contents from CSS so the section is maintained but doesn't
+      // do anything visually. XXX: We may want to do something more specific here
+      // like allow certain ones to be block
+      let container = document.createElement("section");
+      container.append(...children);
+      return [container];
+
+      // let container = document.createElement("div");
+      // container.append(...children);
+      // return [container];
+    },
+  },
+  "redundant object": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  form: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  ime: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "app root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "parent menuitem": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  calendar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "combobox list": {
+    render(treeItem, children) {
+      return [...children];
+    },
+  },
+  "combobox option": {
+    render(treeItem /*, children*/) {
+      let container = document.createElement("option");
+      container.textContent = `${treeItem.name}`;
+      container.dataset.accId = treeItem.id;
+      return [container];
+    },
+  },
+  "image map": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "listbox option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "listbox rich option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  listbox: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "flat equation": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  gridcell: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "embedded object": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  note: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.setAttribute("role", "note");
+      container.append(...children);
+      return [container];
+    },
+  },
+  figure: {
+    render(treeItem, children) {
+      let container = document.createElement("figure");
+      // container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "check rich option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  definitionlist: {
+    render(treeItem, children) {
+      let container = document.createElement("dl");
+      container.append(...children);
+      return [container];
+    },
+  },
+  term: {
+    render(treeItem, children) {
+      let container = document.createElement("dt");
+      container.append(...children);
+      return [container];
+    },
+  },
+  definition: {
+    render(treeItem, children) {
+      let container = document.createElement("dd");
+      container.append(...children);
+      return [container];
+    },
+  },
+  key: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  switch: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  math: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml identifier": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml number": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml operator": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml text": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml string literal": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml glyph": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml fraction": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml square root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml fenced": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml enclosed": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml style": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sub": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sup": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sub sup": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml under": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml over": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml under over": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml multiscripts": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml table": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml labeled row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml table row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml cell": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml action": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml error": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml long division": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack group": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack carries": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack carry": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack line": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grouping: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  text: {
+    render(treeItem, children) {
+      if (!treeItem.name) {
+        return [];
+      }
+      return [treeItem.name];
+    },
+  },
+  details: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  summary: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  landmark: {
+    render(treeItem, children) {
+      let roles = treeItem.attributes["xml-roles"].split(" ");
+
+      /*
+    <article>
+    <aside>
+    <details>
+    <figcaption>
+    <figure>
+    <footer>
+    <header>
+    <main>
+    <mark>
+    <nav>
+    <section>
+    <summary>
+    <time>
+      */
+
+      let container;
+      if (roles.includes("banner")) {
+        container = document.createElement("header");
+      }
+      if (roles.includes("navigation")) {
+        // (e.g., a menu)
+        container = document.createElement("nav");
+      }
+      if (roles.includes("main")) {
+        // (the main content of the page)
+        container = document.createElement("main");
+      }
+      if (roles.includes("complementary")) {
+        // (e.g., a sidebar)
+        container = document.createElement("aside");
+      }
+      if (roles.includes("contentinfo")) {
+        // (meta data about the page, e.g., a copyright statement)
+        container = document.createElement("div");
+        container.setAttribute("role", "contentinfo");
+      }
+      if (roles.includes("search")) {
+        container = document.createElement("form");
+        container.setAttribute("role", "search");
+      }
+      if (roles.includes("form")) {
+        container = document.createElement("form");
+      }
+      if (roles.includes("application")) {
+        // (a web application with its own keyboard interface)
+        container = document.createElement("div");
+        container.setAttribute("role", "application");
+      }
+
+      // container.textContent = `${treeItem.role}: ${roles.join(" ")}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  navigation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  footnote: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  article: {
+    render(treeItem, children) {
+      let container = document.createElement("article");
+      container.append(...children);
+      return [container];
+    },
+  },
+  region: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  editcombobox: {
+    render(treeItem, children) {
+      let container = document.createElement("label");
+      container.textContent = `${treeItem.name}`;
+      let input = document.createElement("input");
+      input.dataset.accId = treeItem.id;
+      input.value = treeItem.value;
+      container.appendChild(input);
+      return [container];
+    },
+  },
+  blockquote: {
+    render(treeItem, children) {
+      let container = document.createElement("blockquote");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "content deletion": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "content insertion": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  // form: { this is FORM_LANDMARK https://searchfox.org/mozilla-central/rev/96f1457323cc598a36f5701f8e67aedaf97acfcf/accessible/base/RoleMap.h#1625-1632
+  //   render(treeItem, children) {
+  //     let container = document.createElement("div");
+  //     container.textContent = `${treeItem.role}: ${treeItem.name}`;
+  //     container.append(...children);
+  //     return [container];
+  //   }
+  // },
+  mark: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+};
diff --git a/browser/components/secondarybrowser/content/secondaryui.css b/browser/components/secondarybrowser/content/secondaryui.css
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.css
@@ -0,0 +1,509 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+/* Copied from aboutReader.css: */
+
+
+
+/*======= Article content =======*/
+
+/* Note that any class names from the original article that we want to match on
+ * must be added to CLASSES_TO_PRESERVE in ReaderMode.jsm, so that
+ * Readability.js doesn't strip them out */
+
+ .moz-reader-content {
+  font-size: 1em;
+  line-height: 1.6em;
+}
+
+.moz-reader-content.line-height1 {
+  line-height: 1em;
+}
+
+.moz-reader-content.line-height2 {
+  line-height: 1.2em;
+}
+
+.moz-reader-content.line-height3 {
+  line-height: 1.4em;
+}
+
+.moz-reader-content.line-height4 {
+  line-height: 1.6em;
+}
+
+.moz-reader-content.line-height5 {
+  line-height: 1.8em;
+}
+
+.moz-reader-content.line-height6 {
+  line-height: 2.0em;
+}
+
+.moz-reader-content.line-height7 {
+  line-height: 2.2em;
+}
+
+.moz-reader-content.line-height8 {
+  line-height: 2.4em;
+}
+
+.moz-reader-content.line-height9 {
+  line-height: 2.6em;
+}
+
+@media print {
+  .moz-reader-content p,
+  .moz-reader-content code,
+  .moz-reader-content pre,
+  .moz-reader-content blockquote,
+  .moz-reader-content ul,
+  .moz-reader-content ol,
+  .moz-reader-content li,
+  .moz-reader-content figure,
+  .moz-reader-content .wp-caption {
+    margin: 0 0 10px 0 !important;
+    padding: 0 !important;
+  }
+}
+
+.moz-reader-content h1,
+.moz-reader-content h2,
+.moz-reader-content h3 {
+  font-weight: bold;
+}
+
+.moz-reader-content h1 {
+  font-size: 1.6em;
+  line-height: 1.25em;
+}
+
+.moz-reader-content h2 {
+  font-size: 1.2em;
+  line-height: 1.51em;
+}
+
+.moz-reader-content h3 {
+  font-size: 1em;
+  line-height: 1.66em;
+}
+
+.moz-reader-content a:link {
+  text-decoration: underline;
+  font-weight: normal;
+}
+
+.moz-reader-content a:link,
+.moz-reader-content a:link:hover,
+.moz-reader-content a:link:active {
+  color: #0095dd;
+}
+
+.moz-reader-content a:visited {
+  color: #c2e;
+}
+
+.moz-reader-content * {
+  max-width: 100%;
+  height: auto;
+}
+
+.moz-reader-content p,
+.moz-reader-content p,
+.moz-reader-content code,
+.moz-reader-content pre,
+.moz-reader-content blockquote,
+.moz-reader-content ul,
+.moz-reader-content ol,
+.moz-reader-content li,
+.moz-reader-content figure,
+.moz-reader-content .wp-caption {
+  margin: -10px -10px 20px -10px;
+  padding: 10px;
+  border-radius: 5px;
+}
+
+.moz-reader-content li {
+  margin-bottom: 0;
+}
+
+.moz-reader-content li > ul,
+.moz-reader-content li > ol {
+  margin-bottom: -10px;
+}
+
+.moz-reader-content p > img:only-child,
+.moz-reader-content p > a:only-child > img:only-child,
+.moz-reader-content .wp-caption img,
+.moz-reader-content figure img {
+  display: block;
+}
+
+.moz-reader-content img[moz-reader-center] {
+  margin-left: auto;
+  margin-right: auto;
+}
+
+.moz-reader-content .caption,
+.moz-reader-content .wp-caption-text
+.moz-reader-content figcaption {
+  font-size: 0.9em;
+  line-height: 1.48em;
+  font-style: italic;
+}
+
+.moz-reader-content code,
+.moz-reader-content pre {
+  white-space: pre-wrap;
+}
+
+.moz-reader-content blockquote {
+  padding: 0;
+  padding-inline-start: 16px;
+}
+
+.moz-reader-content ul,
+.moz-reader-content ol {
+  padding: 0;
+}
+
+.moz-reader-content ul {
+  padding-inline-start: 30px;
+  list-style: disc;
+}
+
+.moz-reader-content ol {
+  padding-inline-start: 30px;
+  list-style: decimal;
+}
+
+table,
+th,
+td {
+  border: 1px solid currentColor;
+  border-collapse: collapse;
+  padding: 6px;
+  vertical-align: top;
+}
+
+table {
+  margin: 5px;
+}
+
+/* Visually hide (but don't display: none) screen reader elements */
+.moz-reader-content .visually-hidden,
+.moz-reader-content .visuallyhidden,
+.moz-reader-content .sr-only {
+  display: inline-block;
+  width: 1px;
+  height: 1px;
+  margin: -1px;
+  overflow: hidden;
+  padding: 0;
+  border-width: 0;
+}
+
+/* Hide elements with common "hidden" class names */
+.moz-reader-content .hidden,
+.moz-reader-content .invisible {
+  display: none;
+}
+
+/* Enforce wordpress and similar emoji/smileys aren't sized to be full-width,
+ * see bug 1399616 for context. */
+.moz-reader-content img.wp-smiley,
+.moz-reader-content img.emoji {
+  display: inline-block;
+  border-width: 0;
+  /* height: auto is implied from `.moz-reader-content *` rule. */
+  width: 1em;
+  margin: 0 .07em;
+  padding: 0;
+}
+
+.reader-show-element {
+  display: initial;
+}
+
+
+/* Overrides */
+
+
+
+body {
+  --toolbar-bgcolor: #fbfbfb;
+  --toolbar-border: #b5b5b5;
+  --toolbar-hover: #ebebeb;
+  --popup-bgcolor: #fbfbfb;
+  --popup-border: #b5b5b5;
+  --font-color: #4c4c4c;
+  --icon-fill: #808080;
+  --icon-disabled-fill: #8080807F;
+  /* light colours */
+}
+
+body.dark {
+  --toolbar-bgcolor: #2a2a2d;
+  --toolbar-border: #4B4A50;
+  --toolbar-hover: #737373;
+  --popup-bgcolor: #4b4a50;
+  --popup-border: #65646a;
+  --font-color: #fff;
+  --icon-fill: #fff;
+  --icon-disabled-fill: #ffffff66;
+  /* dark colours */
+}
+
+
+html, body {
+  margin: 0;
+  padding: 0;
+}
+html {
+  font-family: sans-serif, Arial;
+  font-size: 14px/1.5;
+}
+
+body {
+  color: #333333;
+  background-color: #ffffff;
+}
+
+body.dark {
+  color: #eeeeee;
+  background-color: #333333;
+}
+
+body.dark *::-moz-selection {
+  background-color: #FFFFFF;
+  color: #0095DD;
+}
+body.dark a::-moz-selection {
+  color: #DD4800;
+}
+body.sepia {
+  color: #5b4636;
+  background-color: #f4ecd8;
+}
+
+#controls {
+  padding: 3px;
+  border-bottom: 2px solid var(--toolbar-border);
+  background: var(--toolbar-bgcolor);
+  box-sizing: border-box;
+  /* position: fixed;
+  width: 100%;
+  top: 0;
+  */
+}
+
+#debug-label {
+  vertical-align: middle;
+  user-select: none;
+  font-size: 12px;
+  position: absolute;
+  right: 3px;
+  top: 0;
+}
+
+#content {
+  position: relative;
+  box-sizing: border-box;
+  margin: auto;
+  padding: 0 5px;
+  overflow: hidden;
+}
+
+#content > * { display: none; }
+#content[view=A11Y] #a11y-content,
+#content[view="Page Outline"] #outline-content {
+  display: block;
+}
+/*
+#content {
+  display: grid;
+}
+#content > * {
+  grid-area: 1 / 1;
+  z-index: 0;
+} */
+
+
+#a11y-content details {
+  padding-left: 5px;
+  margin: 1px 0;
+}
+
+#outline-content details {
+  background: var(--outline-bgcolor);
+  border: solid 1px var(--outline-bordercolor);
+}
+
+#outline-content details > div {
+  margin-inline-start: 20px;
+}
+#outline-content h2 {
+  cursor: pointer;
+  margin: 0;
+  padding: 2px;
+}
+
+
+#outline-content #headings {
+  --outline-bgcolor: rgba(255, 0, 0, .1);
+  --outline-bordercolor: solid 1px rgba(255, 0, 0, .2);
+}
+
+#outline-content #links {
+  --outline-bgcolor: rgba(0, 0, 255, .1);
+  --outline-bordercolor: solid 1px rgba(0, 0, 255, .2);
+}
+#outline-content #images {
+  --outline-bgcolor: rgba(0, 255, 0, .1);
+  --outline-bordercolor: solid 1px rgba(0, 255, 0, .2);
+}
+#outline-content #videos {
+  --outline-bgcolor: rgba(0, 255, 255, .1);
+  --outline-bordercolor: solid 1px rgba(0, 255, 255, .2);
+}
+
+/* XXX: Copied from arewexbl still.. clean this up */
+#outline-content summary {padding: 4px 0; position: relative; width: 100%; cursor: pointer; }
+/* #outline-content summary .metadata { margin-left: 6px; font-size: smaller;}
+#outline-content summary > span { font-family: monospace; }
+#outline-content details ul { margin-top: 2px; margin-bottom: 0; } */
+
+.moz-reader-content ul,
+.moz-reader-content li {
+  margin-inline-start: 10px;
+  padding: 0;
+}
+li h3 {
+  margin: 0;
+}
+
+/* XXX: the bullet seems to come across as text in the a11y tree */
+.moz-reader-content li {
+  list-style: none;
+}
+/* nav ul {
+  background-color: #444;
+  padding: 0;
+  margin: 0;
+  display: flex;
+}
+nav li {
+  font-family: 'Oswald', sans-serif;
+  font-size: 1.2em;
+  line-height: 40px;
+  height: 40px;
+  border-bottom: 1px solid #888;
+  flex: 1;
+  height: 50px;
+  line-height: 50px;
+} */
+
+
+.moz-reader-content nav ul li {
+  list-style: none;
+}
+
+.internal-frame {
+  border: solid 1px;
+}
+
+section {
+  /* display: contents; */
+}
+
+header {
+  background: var(--popup-bgcolor);
+  border: solid 1px var(--popup-border);
+}
+article {
+  background: var(--popup-bgcolor);
+  border: solid 1px var(--popup-border);
+  padding: 2px;
+}
+
+div[role="note"] {
+  font-style: italic;
+  font-size: .9em;
+  padding-inline-start: 5px;
+  margin-bottom: 0.5em;
+}
+
+caption {
+  font-weight: bold;
+  padding: 0.2em;
+  padding-bottom: 0.2em;
+  text-align: center;
+}
+form[role="search"] {
+  background: var(--popup-bgcolor);
+  border: solid 1px var(--popup-border);
+  padding: 2px;
+}
+
+form[role="search"] button,
+form[role="search"] input {
+  margin-inline-start: 3px;
+}
+
+[role="banner"] ul,
+nav ul {
+  list-style-type: none;
+  margin: 0;
+  padding: 0;
+  overflow: hidden;
+  border: 1px solid #e7e7e7;
+  background-color: #f3f3f3;
+}
+
+[role="banner"] ul li,
+nav ul li {
+  float: left;
+}
+
+[role="banner"] ul li a,
+nav ul li a {
+  display: inline-block;
+  color: #666;
+  text-align: center;
+  padding: 14px 16px;
+  text-decoration: none;
+}
+
+[role="banner"] ul li a:hover:not(.active),
+nav ul li a:hover:not(.active) {
+  background-color: #ddd;
+}
+
+[role="banner"] ul a.active,
+nav ul a.active {
+  color: white;
+  background-color: #4CAF50;
+}
+
+/* XXX: Override because this was messing up spacing for lis */
+.moz-reader-content ul,
+.moz-reader-content ol,
+.moz-reader-content li {
+  margin: 0;
+  padding: 0;
+  border-radius: 0;
+}
+
+.moz-reader-content p,
+.moz-reader-content code,
+.moz-reader-content pre,
+.moz-reader-content blockquote,
+.moz-reader-content figure,
+.moz-reader-content .wp-caption {
+  margin: 0;
+  padding: 0;
+  padding-bottom: 5px;
+  border-radius: 5px;
+}
diff --git a/browser/components/secondarybrowser/content/secondaryui.html b/browser/components/secondarybrowser/content/secondaryui.html
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.html
@@ -0,0 +1,106 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE html>
+
+<html>
+<head>
+  <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'" />
+  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
+  <meta name="viewport" content="width=device-width; user-scalable=0" />
+  <link rel="stylesheet" href="chrome://browser/content/secondarybrowser/secondaryui.css">
+</head>
+<body>
+  <div id="controls">
+    <button id="view-outline">Outline</button>
+    <button id="view-a11y">A11Y</button>
+    <div id="debug-label">
+      <div id="title"><span id="page-title"></span></div>
+      <span id="debug-title"></span>
+      <label><input id="split" type="checkbox" checked /> Split</label>
+      <label><input id="debug" type="checkbox" /> Debug View</label>
+    </div>
+
+<!-- 
+  <ul class="toolbar reader-toolbar">
+    <li><button class="button close-button"></button></li>
+    <ul class="dropdown style-dropdown">
+      <li><button class="dropdown-toggle button style-button"></button></li>
+      <li class="dropdown-popup">
+        <div class="font-type-buttons"></div>
+        <hr>
+        <div class="font-size-buttons">
+          <button class="minus-button"></button>
+          <button class="font-size-sample"></button>
+          <button class="plus-button"></button>
+        </div>
+        <hr>
+        <div class="content-width-buttons">
+          <button class="content-width-minus-button"></button>
+          <button class="content-width-plus-button"></button>
+        </div>
+        <hr>
+        <div class="line-height-buttons">
+          <button class="line-height-minus-button"></button>
+          <button class="line-height-plus-button"></button>
+        </div>
+        <hr>
+        <div class="color-scheme-buttons"></div>
+        <div class="dropdown-arrow"></div>
+      </li>
+      <script>
+
+  let dropdown = this._toolbarElement;
+
+let elemL10nMap = {
+  ".minus-button": "minus",
+  ".plus-button": "plus",
+  ".content-width-minus-button": "contentwidthminus",
+  ".content-width-plus-button": "contentwidthplus",
+  ".line-height-minus-button": "lineheightminus",
+  ".line-height-plus-button": "lineheightplus",
+  ".light-button": "colorschemelight",
+  ".dark-button": "colorschemedark",
+  ".sepia-button": "colorschemesepia",
+};
+
+for (let [selector, stringID] of Object.entries(elemL10nMap)) {
+  dropdown
+    .querySelector(selector)
+    .setAttribute(
+      "title",
+      gStrings.GetStringFromName("aboutReader.toolbar." + stringID)
+    );
+}
+
+      </script>
+    </ul> -->
+  </div>
+  <div id="content">
+    <div id="a11y-content" class="moz-reader-content"></div>
+    <div id="outline-content" class="moz-reader-content">
+      <details id="headings">
+          <summary>Headings<span class="count"></span></summary>
+          <div></div>
+      </details>
+      <details id="links">
+          <summary>Links<span class="count"></span></summary>
+          <div></div>
+      </details>
+      <details id="images">
+          <summary>Images<span class="count"></span></summary>
+          <div>This is unimplemented :)</div>
+      </details>
+      <details id="videos">
+          <summary>Videos<span class="count"></span></summary>
+          <div>This is unimplemented :)</div>
+      </details>
+
+    </div>
+    <div id="media-content" class="moz-reader-content"></div>
+  </div>
+  <script src="chrome://browser/content/secondarybrowser/secondaryui.js"></script>
+  <script src="chrome://browser/content/secondarybrowser/roles.js"></script>
+</body>
+</html>
diff --git a/browser/components/secondarybrowser/content/secondaryui.js b/browser/components/secondarybrowser/content/secondaryui.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.js
@@ -0,0 +1,382 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const VIEW_A11Y = "A11Y";
+const VIEW_OUTLINE = "Page Outline";
+const STATE = {
+  ACC_TREE: {},
+  LAST_RENDERED_TREE: undefined,
+  LAST_RENDERED_DEBUG: undefined,
+  NODE_FOR_ACC: new Map(),
+  TITLE: "",
+  ACTIVE_VIEW: VIEW_OUTLINE,
+};
+
+document.querySelector("#view-outline").addEventListener("click", e => {
+  STATE.ACTIVE_VIEW = VIEW_OUTLINE;
+  renderFull();
+});
+
+document.querySelector("#view-a11y").addEventListener("click", e => {
+  STATE.ACTIVE_VIEW = VIEW_A11Y;
+  renderFull();
+});
+
+document.querySelector("#a11y-content").addEventListener("input", e => {
+  const { accId } = e.target.dataset;
+  console.log(e.target);
+  if (accId) {
+    document.dispatchEvent(
+      new CustomEvent("SecondaryBrowserContentEvent", {
+        bubbles: true,
+        detail: { type: e.type, accId, event: e },
+      })
+    );
+  }
+  // e.preventDefault();
+});
+
+function sendEventToActor(name, e) {
+  if (isDebug()) {
+    return;
+  }
+
+  let closestTarget = e.target;
+  while (
+    closestTarget &&
+    (!closestTarget.dataset || !closestTarget.dataset.accId)
+  ) {
+    closestTarget = closestTarget.parentNode;
+  }
+
+  if (!closestTarget) {
+    return;
+  }
+
+  // XXX: Send this up with accessible id to do command
+  // (see [id] field passed into the snapshot)
+  const { accId } = closestTarget.dataset;
+  console.log(e, closestTarget, accId, name);
+  if (accId) {
+    document.dispatchEvent(
+      new CustomEvent(name, {
+        bubbles: true,
+        detail: { accId },
+      })
+    );
+  }
+  e.preventDefault();
+}
+document.querySelector("#a11y-content").addEventListener(
+  "click",
+  e => {
+    sendEventToActor("SecondaryBrowserContentClicked", e);
+  },
+  { capture: true }
+);
+
+// document
+//   .querySelector("#a11y-content")
+//   .addEventListener("change", sendEventToActor, { capture: true });
+
+let ACC_TREE;
+
+function isDebug() {
+  return !!debugCheckbox.checked;
+}
+
+// const throttledRender = throttle(renderFull, 1000);
+// function throttle(callback, limit) {
+//   var wait = false;
+//   return function() {
+//     if (!wait) {
+//       callback.apply(null, arguments);
+//       wait = true;
+//       setTimeout(function() {
+//         wait = false;
+//       }, limit);
+//     }
+//   };
+// }
+// function idleRender() {
+//   requestIdleCallback(
+//     () => {
+//       renderFull();
+//     },
+//     { timeout: 100 }
+//   );
+// }
+
+function dispatchSplitState() {
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserContentView", {
+      bubbles: true,
+      detail: {
+        split: STATE.ACTIVE_VIEW == "Page Outline" || splitCheckbox.checked,
+      },
+    })
+  );
+}
+
+let splitCheckbox = document.querySelector("#split");
+splitCheckbox.onchange = dispatchSplitState;
+
+let debugCheckbox = document.querySelector("#debug");
+debugCheckbox.onchange = renderFull;
+
+function renderDebugContainer(treeItem, children) {
+  let details = document.createElement("details");
+  details.toggleAttribute("open");
+  details.setAttribute(
+    "title",
+    JSON.stringify(
+      Object.assign({}, treeItem, { children: undefined }),
+      null,
+      2
+    )
+  );
+  let summary = document.createElement("summary");
+  summary.textContent = `${treeItem.role}: ${treeItem.name ||
+    treeItem.attributes.src ||
+    treeItem.attributes["xml-roles"] ||
+    treeItem.attributes.tag ||
+    ""} (${treeItem.id})`;
+  details.append(summary, ...children);
+  return [details];
+}
+
+function findElements(accTree, role, els = []) {
+  if (accTree.role == role) {
+    els.push(accTree);
+  }
+
+  for (let child of accTree.children) {
+    findElements(child, role, els);
+  }
+
+  return els;
+}
+
+function buildHeadingOutline(accTree) {
+  let content = document.querySelector("#outline-content #headings > div");
+
+  content.innerHTML = "";
+  if (!accTree.children) {
+    // empty tree
+    return;
+  }
+
+  let count = document.querySelector("#outline-content #headings .count");
+  let headings = findElements(accTree, "heading");
+  count.textContent = ` (${headings.length})`;
+  if (!headings.length) {
+    content.innerHTML = "No headings found";
+  } else {
+    for (let heading of headings) {
+      let el = document.createElement("h2");
+      el.dataset.accId = heading.id;
+
+      el.addEventListener("click", e => {
+        sendEventToActor("SecondaryBrowserContentScroll", e);
+
+        // This would scroll the a11y view directly instead of signalling
+        // to the main page
+        // if (STATE.NODE_FOR_ACC.has(heading)) {
+        //   STATE.ACTIVE_VIEW = VIEW_A11Y;
+        //   renderFull();
+        //   STATE.NODE_FOR_ACC.get(heading).scrollIntoView();
+        // } else {
+        //   console.log("no heading for", heading);
+        // }
+      });
+      el.textContent = heading.name;
+      content.append(el);
+    }
+  }
+}
+
+function buildLinkOutline(accTree) {
+  let content = document.querySelector("#outline-content #links > div");
+
+  content.innerHTML = "";
+  if (!accTree.children) {
+    // empty tree
+    return;
+  }
+
+  let count = document.querySelector("#outline-content #links .count");
+  let links = findElements(accTree, "link");
+
+  count.textContent = ` (${links.length})`;
+  if (!links.length) {
+    content.innerHTML = "No headings found";
+  } else {
+    for (let link of links) {
+      let el = document.createElement("h2");
+      el.dataset.accId = link.id;
+
+      el.addEventListener("click", e => {
+        sendEventToActor("SecondaryBrowserContentClicked", e);
+        // This would scroll the a11y view directly instead of signalling
+        // to the main page
+        // if (STATE.NODE_FOR_ACC.has(link)) {
+        //   STATE.ACTIVE_VIEW = VIEW_A11Y;
+        //   renderFull();
+        //   STATE.NODE_FOR_ACC.get(link).scrollIntoView();
+        // } else {
+        //   console.log("no link for", heading);
+        // }
+      });
+      el.textContent = link.name;
+      content.append(el);
+    }
+  }
+}
+
+function buildOutlineView(accTree) {
+  document.querySelector("#debug-label").hidden = true;
+  // XXX: Can we nest things here like headings and links
+  buildHeadingOutline(accTree);
+  buildLinkOutline(accTree);
+}
+
+function buildA11YView(accTree) {
+  document.querySelector("#debug-label").hidden = false;
+  STATE.NODE_FOR_ACC.clear();
+  let content = document.querySelector("#a11y-content");
+  content.innerHTML = "";
+  let element = buildAccTreeElement(accTree);
+  content.append(...element);
+}
+
+function buildAccTreeElement(accTree) {
+  let children = accTree.children
+    .map(c => {
+      return buildAccTreeElement(c);
+    })
+    .flat();
+  let currentNode = accTree;
+  // console.log(currentNode.role, children);
+  let role = window.ROLE_MAP[currentNode.role];
+
+  if (!role) {
+    throw new Error(`Unknown role: ${currentNode.role}`);
+  }
+
+  if (isDebug()) {
+    return renderDebugContainer(currentNode, children);
+  }
+
+  let els = role.render(currentNode, children);
+  // XXX: It would be better to have a string key for acc objects
+  // that could persist across tree changes and map to the DOM. This
+  // would also allow us to do more differential updates to the tree
+  // in the actor. For now, just keep a map in memory and then when a
+  // heading is clicked, for instance, we can scroll to that node in the
+  // view.
+  if (els.length == 1 && els[0] && els[0].nodeType == 1) {
+    STATE.NODE_FOR_ACC.set(currentNode, els[0]);
+  }
+  // XXX: find a better way to map id to element
+  // if (els.length == 1 && els[0] && els[0].nodeType == 1) {
+  //   if (els[0].tagName == "A") {
+  //     console.log("Setting", els[0], currentNode.id);
+  //   }
+  //   els[0].dataset.accId = currentNode.id;
+  // }
+  return els;
+}
+
+async function renderFull() {
+  document.title = STATE.TITLE;
+  document.querySelector("#content").setAttribute("view", STATE.ACTIVE_VIEW);
+
+  /*
+  document.querySelector(
+    "#page-title"
+  ).textContent = `${STATE.TITLE} - ${STATE.ACTIVE_VIEW}`;
+  */
+
+  // if (
+  //   STATE.LAST_RENDERED_TREE == STATE.ACC_TREE &&
+  //   STATE.LAST_RENDERED_DEBUG == isDebug()
+  // ) {
+  //   return;
+  // }
+
+  // STATE.LAST_RENDERED_TREE = STATE.ACC_TREE;
+  // STATE.LAST_RENDERED_DEBUG = isDebug();
+
+  let start = performance.now();
+
+  if (
+    STATE.ACTIVE_VIEW == VIEW_A11Y &&
+    (STATE.LAST_RENDERED_TREE !== STATE.ACC_TREE ||
+      STATE.LAST_RENDERED_DEBUG !== isDebug())
+  ) {
+    buildA11YView(STATE.ACC_TREE);
+    STATE.LAST_RENDERED_TREE = STATE.ACC_TREE;
+    STATE.LAST_RENDERED_DEBUG = isDebug();
+  }
+  if (STATE.ACTIVE_VIEW == VIEW_OUTLINE) {
+    buildOutlineView(STATE.ACC_TREE);
+    STATE.LAST_RENDERED_TREE = null;
+  }
+
+  if (STATE.LAST_RENDERED_VIEW !== STATE.ACTIVE_VIEW) {
+    dispatchSplitState();
+  }
+  STATE.LAST_RENDERED_VIEW = STATE.ACTIVE_VIEW;
+  console.log(`renderFull time ${performance.now() - start}`);
+}
+
+window.addEventListener("DOMContentLoaded", function() {
+  // startListeningForAccessibilityEvents({
+  //   reorder: function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  //   "name-change": function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  //   "text-change": function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  //   "document-ready": function() {
+  //     // console.trace(arguments);
+  //     throttledRender();
+  //   },
+  // });
+  // console.log(window.ROLE_MAP);
+
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserContentLoaded", { bubbles: true })
+  );
+});
+
+window.addEventListener("SecondaryBrowserChromeToContent", event => {
+  console.log("SecondaryBrowserChromeToContent", event.detail);
+  switch (event.detail.messageType) {
+    case "TreeChanged": {
+      STATE.TITLE = event.detail.value.name;
+      STATE.ACC_TREE = event.detail.value;
+      renderFull();
+      break;
+    }
+    case "SetA11YView": {
+      STATE.ACTIVE_VIEW = VIEW_A11Y;
+      renderFull();
+      break;
+    }
+    case "SetOutlineView": {
+      STATE.ACTIVE_VIEW = VIEW_OUTLINE;
+      renderFull();
+      break;
+    }
+  }
+});
diff --git a/browser/components/secondarybrowser/moz.build b/browser/components/secondarybrowser/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/moz.build
@@ -0,0 +1,16 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ['content/jar.mn']
+
+EXTRA_JS_MODULES += [
+    'A11YMode.jsm',
+]
+
+FINAL_TARGET_FILES.actors += [
+    'SecondaryBrowserChild.jsm',
+    'SecondaryBrowserParent.jsm',
+]
diff --git a/browser/modules/ReaderParent.jsm b/browser/modules/ReaderParent.jsm
--- a/browser/modules/ReaderParent.jsm
+++ b/browser/modules/ReaderParent.jsm
@@ -70,37 +70,59 @@ var ReaderParent = {
   },
 
   updateReaderButton(browser) {
     let win = browser.ownerGlobal;
     if (browser != win.gBrowser.selectedBrowser) {
       return;
     }
 
+    let secondaryBrowserButton = win.document.getElementById(
+      "secondary-browser-button"
+    );
     let button = win.document.getElementById("reader-mode-button");
     let menuitem = win.document.getElementById("menu_readerModeItem");
     let key = win.document.getElementById("key_toggleReaderMode");
+
+    if (browser.secondaryBrowser) {
+      secondaryBrowserButton.setAttribute("readeractive", true);
+    } else {
+      secondaryBrowserButton.removeAttribute("readeractive");
+    }
+
     if (browser.currentURI.spec.startsWith("about:reader")) {
       let closeText = gStringBundle.GetStringFromName("readerView.close");
 
+      // if (browser.parentNode.querySelector(".secondarybrowser-reader")) {
+      //   browser.parentNode
+      //     .querySelector(".secondarybrowser-reader")
+      //     .setAttribute("active", "true");
+      // }
+
       button.setAttribute("readeractive", true);
       button.hidden = false;
       button.setAttribute("aria-label", closeText);
 
       menuitem.setAttribute("label", closeText);
       menuitem.setAttribute("hidden", false);
       menuitem.setAttribute(
         "accesskey",
         gStringBundle.GetStringFromName("readerView.close.accesskey")
       );
 
       key.setAttribute("disabled", false);
 
       Services.obs.notifyObservers(null, "reader-mode-available");
     } else {
+      // if (browser.parentNode.querySelector(".secondarybrowser-reader")) {
+      //   browser.parentNode
+      //     .querySelector(".secondarybrowser-reader")
+      //     .removeAttribute("active");
+      // }
+
       let enterText = gStringBundle.GetStringFromName("readerView.enter");
 
       button.removeAttribute("readeractive");
       button.hidden = !browser.isArticle;
       button.setAttribute("aria-label", enterText);
 
       menuitem.setAttribute("label", enterText);
       menuitem.setAttribute("hidden", !browser.isArticle);
@@ -117,16 +139,62 @@ var ReaderParent = {
     }
   },
 
   forceShowReaderIcon(browser) {
     browser.isArticle = true;
     this.updateReaderButton(browser);
   },
 
+  toggleSecondaryBrowser(event) {
+    let win = event.target.ownerGlobal;
+    let gBrowser = win.gBrowser;
+    let browser = gBrowser.selectedBrowser;
+
+    let stack = browser.parentNode;
+    let closeSecondaryBrowser = () => {
+      stack.removeAttribute("secondarybrowser");
+      if (browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.destroySecondaryBrowser();
+      }
+      for (let active of stack.querySelectorAll(
+        ".secondarybrowser-controls toolbarbutton[active]"
+      )) {
+        active.removeAttribute("active");
+      }
+    };
+    browser.closeSecondaryBrowser = closeSecondaryBrowser;
+
+    let openSecondaryBrowser = () => {
+      if (!browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.before(browser.createSecondaryBrowser());
+      }
+      if (!stack.hasAttribute("secondarybrowser")) {
+        stack.setAttribute("secondarybrowser", "on");
+      }
+    };
+    browser.openSecondaryBrowser = openSecondaryBrowser;
+    if (browser.secondaryBrowser) {
+      closeSecondaryBrowser();
+    } else {
+      openSecondaryBrowser();
+    }
+    this.updateReaderButton(browser);
+  },
+
+  secondaryBrowserButtonClick(event) {
+    if (event.button != 0) {
+      return;
+    }
+
+    this.toggleSecondaryBrowser(event);
+  },
+
   buttonClick(event) {
     if (event.button != 0) {
       return;
     }
     this.toggleReaderMode(event);
   },
 
   toggleReaderMode(event) {
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -782,16 +782,22 @@
   mask-image: linear-gradient(to right, transparent, black 3ch);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input {
   mask-position-x: calc(var(--cfr-label-width) * -1);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input:-moz-locale-dir(rtl) {
   mask-position-x: calc(var(--cfr-label-width));
 }
+#secondary-browser-button {
+  list-style-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+#secondary-browser-button[readeractive] {
+  background: var(--toolbarbutton-icon-fill-attention);
+}
 
 /* Reader mode icon */
 
 #reader-mode-button {
   list-style-image: url(chrome://browser/skin/readerMode.svg);
 }
 
 #reader-mode-button[readeractive] {
diff --git a/toolkit/actors/SelectParent.jsm b/toolkit/actors/SelectParent.jsm
--- a/toolkit/actors/SelectParent.jsm
+++ b/toolkit/actors/SelectParent.jsm
@@ -549,23 +549,26 @@ var SelectParentHelper = {
         }
       }
     }
 
     if (parentElement && ariaOwns) {
       parentElement.setAttribute("aria-owns", ariaOwns);
     }
 
+    // XXX: Pass in whether we are opening for a secondary browser. In the meantime
+    // we'll just enable search everywhere.add-a-comment
     // Check if search pref is enabled, if this is the first time iterating through
     // the dropdown, and if the list is long enough for a search element to be added.
-    if (
-      Services.prefs.getBoolPref("dom.forms.selectSearch") &&
-      addSearch &&
-      element.childElementCount > SEARCH_MINIMUM_ELEMENTS
-    ) {
+    if (true) {
+      // if (
+      //   Services.prefs.getBoolPref("dom.forms.selectSearch") &&
+      //   addSearch &&
+      //   element.childElementCount > SEARCH_MINIMUM_ELEMENTS
+      // ) {
       // Add a search text field as the first element of the dropdown
       let searchbox = element.ownerDocument.createXULElement("search-textbox");
       searchbox.className = "contentSelectDropdown-searchbox";
       searchbox.addEventListener("input", this.onSearchInput);
       searchbox.addEventListener("focus", this.onSearchFocus.bind(this));
       searchbox.addEventListener("blur", this.onSearchBlur);
       searchbox.addEventListener("command", this.onSearchInput);
 
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -449,18 +449,75 @@
         if (this.isRemoteBrowser) {
           this._documentContentType = aContentType;
         } else {
           this.contentDocument.documentContentType = aContentType;
         }
       }
     }
 
+    createSecondaryBrowser() {
+      if (!this.secondaryBrowser) {
+        this.secondaryBrowser = document.createXULElement("browser");
+        this.secondaryBrowser.classList.add("secondarybrowser");
+        this.secondaryBrowser.setAttribute("disablehistory", "true");
+        this.secondaryBrowser.setAttribute("nodefaultsrc", "true");
+        this.secondaryBrowser.setAttribute(
+          "remoteType",
+          this.getAttribute("remoteType")
+        );
+        this.secondaryBrowser.setAttribute(
+          "remote",
+          this.getAttribute("remote")
+        );
+        this.secondaryBrowser.setAttribute("type", "content");
+        this.secondaryBrowser.setAttribute(
+          "contextmenu",
+          this.getAttribute("contextmenu")
+        );
+        this.secondaryBrowser.setAttribute(
+          "datetimepicker",
+          this.getAttribute("datetimepicker")
+        );
+        this.secondaryBrowser.setAttribute(
+          "selectmenulist",
+          this.getAttribute("selectmenulist")
+        );
+        this.secondaryBrowser.setAttribute(
+          "tooltip",
+          this.getAttribute("tooltip")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autocompletepopup",
+          this.getAttribute("autocompletepopup")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autoscrollpopup",
+          this.getAttribute("autoscrollpopup")
+        );
+        this.secondaryBrowser.setAttribute("message", "true");
+        this.secondaryBrowser.setAttribute(
+          "messagemanagergroup",
+          "secondarybrowsers"
+        );
+
+        this.secondaryBrowser.sameProcessAsFrameLoader = this.frameLoader;
+        this.secondaryBrowser.hostBrowser = this;
+        this.secondaryBrowser.src = "about:secondarybrowser";
+      }
+      return this.secondaryBrowser;
+    }
+
     set sameProcessAsFrameLoader(val) {
       this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+      if (this.secondaryBrowser) {
+        this.secondaryBrowser.sameProcessAsFrameLoader = Cu.getWeakReference(
+          val
+        );
+      }
     }
 
     get sameProcessAsFrameLoader() {
       return (
         this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get()
       );
     }
 
@@ -1275,25 +1332,41 @@
         // our RemoteWebProgress or its associated manager, but we'll need to
         // add the progress listeners to the new non-remote WebProgress.
         this._remoteWebProgressManager = null;
         this._remoteWebProgress = null;
         this.restoreProgressListeners();
 
         this.addEventListener("pagehide", this.onPageHide, true);
       }
+
+      if (this.hadsecondaryBrowser) {
+        this.hadsecondaryBrowser = false;
+        this.before(this.createSecondaryBrowser());
+      }
     }
 
+    destroySecondaryBrowser() {
+      if (this.secondaryBrowser) {
+        this.hadsecondaryBrowser = true;
+        this.secondaryBrowser.remove();
+        this.secondaryBrowser = null;
+      }
+    }
     /**
      * This is necessary because the destructor doesn't always get called when
      * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
      */
     destroy() {
       elementsToDestroyOnUnload.delete(this);
 
+      // Just remove the secondarybrowser browser entirely and let it get recreated
+      // when we are re-added (i.e. with a remoteness change)
+      this.destroySecondaryBrowser();
+
       // Make sure that any open select is closed.
       if (this.hasAttribute("selectmenulist")) {
         let menulist = document.getElementById(
           this.getAttribute("selectmenulist")
         );
         if (menulist && menulist.open) {
           let resourcePath = "resource://gre/actors/SelectParent.jsm";
           let { SelectParentHelper } = ChromeUtils.import(resourcePath);
@@ -1979,17 +2052,23 @@
 
       function sendToChildren(browsingContext, childScope) {
         let windowGlobal = browsingContext.currentWindowGlobal;
         // If 'roots' is set, only send if windowGlobal.isProcessRoot is true.
         if (
           windowGlobal &&
           (childScope != "roots" || windowGlobal.isProcessRoot)
         ) {
-          windowGlobal.getActor(actorName).sendAsyncMessage(messageName, args);
+          try {
+            windowGlobal
+              .getActor(actorName)
+              .sendAsyncMessage(messageName, args);
+          } catch (e) {
+            console.log(actorName, messageName, e);
+          }
         }
 
         // Iterate as long as scope in assigned. Note that we use the original
         // passed in scope, not childScope here.
         if (scope) {
           for (let context of browsingContext.children) {
             sendToChildren(context, scope);
           }
diff --git a/toolkit/modules/ActorManagerParent.jsm b/toolkit/modules/ActorManagerParent.jsm
--- a/toolkit/modules/ActorManagerParent.jsm
+++ b/toolkit/modules/ActorManagerParent.jsm
@@ -178,17 +178,17 @@ let ACTORS = {
     child: {
       moduleURI: "resource://gre/actors/FindBarChild.jsm",
       events: {
         keypress: { mozSystemGroup: true },
       },
     },
 
     allFrames: true,
-    messageManagerGroups: ["browsers", "test"],
+    messageManagerGroups: ["browsers", "test", "secondarybrowsers"],
   },
 
   // This is the actor that responds to requests from the find toolbar and
   // searches for matches and highlights them.
   Finder: {
     child: {
       moduleURI: "resource://gre/actors/FinderChild.jsm",
     },
