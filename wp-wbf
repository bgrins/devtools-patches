# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  302cc6ec6d96b5ab4bf81933dd5249091e5d86c3

diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -493,22 +493,17 @@ checksum = "214238caa1bf3a496ec339296896
 dependencies = [
  "ppv-lite86",
 ]
 
 [[package]]
 name = "cascade_bloom_filter"
 version = "0.1.0"
 dependencies = [
- "nserror",
- "nsstring",
- "rental",
- "rust_cascade",
- "thin-vec",
- "xpcom",
+ "wasm-bindgen",
 ]
 
 [[package]]
 name = "cast"
 version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "926013f2860c46252efceabb19f4a6b308197505082c609025aa6706c011d427"
 
@@ -3713,19 +3708,19 @@ checksum = "ecd45702f76d6d3c75a80564378a
 dependencies = [
  "proc-macro2",
  "quote",
  "syn",
 ]
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "90cf5f418035b98e655e9cdb225047638296b862b42411c4e45bb88d700f7fc0"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "beae6331a816b1f65d04c45b078fd8e6c93e8071771f41b8163255bbd8d7c8fa"
 dependencies = [
  "unicode-xid",
 ]
 
 [[package]]
 name = "procedural-masquerade"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -4675,19 +4670,19 @@ dependencies = [
  "cc",
  "gleam",
  "glsl-to-cxx",
  "webrender_build",
 ]
 
 [[package]]
 name = "syn"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf"
+version = "1.0.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8d5d96e8cbb005d6959f119f773bfaebb5684296108fb32600c00cde305b2cd"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-xid",
 ]
 
 [[package]]
 name = "sync-guid"
@@ -5361,16 +5356,70 @@ dependencies = [
  "serde_json",
  "serde_urlencoded",
  "tokio 0.2.18",
  "tower-service",
  "urlencoding",
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c2dc4aa152834bc334f506c1a06b866416a8b6697d5c9f75b9a689c8486def0"
+dependencies = [
+ "cfg-if",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ded84f06e0ed21499f6184df0e0cb3494727b0c5da89534e0fcc55c51d812101"
+dependencies = [
+ "bumpalo",
+ "lazy_static",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "838e423688dac18d73e31edce74ddfac468e37b1506ad163ffaf0a46f703ffe3"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3156052d8ec77142051a533cdd686cba889537b213f948cd1d20869926e68e92"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c9ba19973a58daf4db6f352eda73dc0e289493cd29fb2632eb172085b6521acd"
+
+[[package]]
 name = "wasmparser"
 version = "0.48.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "073da89bf1c84db000dd68ce660c1b4a08e3a2d28fd1e3394ab9e7abdde4a0f8"
 
 [[package]]
 name = "wasmparser"
 version = "0.57.0"
diff --git a/js/xpconnect/loader/XPCOMUtils.jsm b/js/xpconnect/loader/XPCOMUtils.jsm
--- a/js/xpconnect/loader/XPCOMUtils.jsm
+++ b/js/xpconnect/loader/XPCOMUtils.jsm
@@ -47,18 +47,17 @@
  * 2. Create an array of component constructors (like the one
  * created in step 1):
  *  var components = [MyComponent];
  *
  * 3. Define the NSGetFactory entry point:
  *  this.NSGetFactory = XPCOMUtils.generateNSGetFactory(components);
  */
 
-
-var EXPORTED_SYMBOLS = [ "XPCOMUtils" ];
+var EXPORTED_SYMBOLS = ["XPCOMUtils"];
 
 let global = Cu.getGlobalForObject({});
 
 const nsIFactoryQI = ChromeUtils.generateQI([Ci.nsIFactory]);
 
 // Some global imports expose additional symbols; for example,
 // `Cu.importGlobalProperties(["MessageChannel"])` imports `MessageChannel`
 // and `MessagePort`. This table maps those extra symbols to the main
@@ -81,61 +80,71 @@ function redefine(object, prop, value) {
     enumerable: true,
     value,
     writable: true,
   });
   return value;
 }
 
 var XPCOMUtils = {
+  async loadWASM(jsmPath, wasmPath) {
+    const {wasm_bindgen} = ChromeUtils.import(jsmPath || "resource://gre/modules/cascade_bloom_filter.js", {});
+    await wasm_bindgen(wasmPath || "chrome://global/content/cascade_bloom_filter/cascade_bloom_filter_bg.wasm");
+// (async function() {
+  // let wb = await cbf.wasm_bindgen("chrome://global/content/cascade_bloom_filter/cascade_bloom_filter_bg.wasm");
+
+  return wasm_bindgen;
+  },
+
   /**
    * Generate a NSGetFactory function given an array of components.
    */
   generateNSGetFactory: function XPCU_generateNSGetFactory(componentsArray) {
     let classes = {};
     for (let i = 0; i < componentsArray.length; i++) {
-        let component = componentsArray[i];
-        if (!(component.prototype.classID instanceof Components.ID))
-          throw Error("In generateNSGetFactory, classID missing or incorrect for component " + component);
+      let component = componentsArray[i];
+      if (!(component.prototype.classID instanceof Components.ID))
+        throw Error(
+          "In generateNSGetFactory, classID missing or incorrect for component " +
+            component
+        );
 
-        classes[component.prototype.classID] = this._getFactory(component);
+      classes[component.prototype.classID] = this._getFactory(component);
     }
     return function NSGetFactory(cid) {
       let cidstring = cid.toString();
-      if (cidstring in classes)
-        return classes[cidstring];
+      if (cidstring in classes) return classes[cidstring];
       throw Cr.NS_ERROR_FACTORY_NOT_REGISTERED;
-    }
+    };
   },
 
   /**
    * Defines a getter on a specified object that will be created upon first use.
    *
    * @param aObject
    *        The object to define the lazy getter on.
    * @param aName
    *        The name of the getter to define on aObject.
    * @param aLambda
    *        A function that returns what the getter should return.  This will
    *        only ever be called once.
    */
-  defineLazyGetter: function XPCU_defineLazyGetter(aObject, aName, aLambda)
-  {
+  defineLazyGetter: function XPCU_defineLazyGetter(aObject, aName, aLambda) {
     let redefining = false;
     Object.defineProperty(aObject, aName, {
-      get: function () {
+      get: function() {
         if (!redefining) {
           // Make sure we don't get into an infinite recursion loop if
           // the getter lambda does something shady.
           redefining = true;
           return redefine(aObject, aName, aLambda.apply(aObject));
         }
       },
       configurable: true,
-      enumerable: true
+      enumerable: true,
     });
   },
 
   /**
    * Defines a getter on a specified object for a script.  The script will not
    * be loaded until first use.
    *
    * @param aObject
@@ -143,33 +152,35 @@ var XPCOMUtils = {
    * @param aNames
    *        The name of the getter to define on aObject for the script.
    *        This can be a string if the script exports only one symbol,
    *        or an array of strings if the script can be first accessed
    *        from several different symbols.
    * @param aResource
    *        The URL used to obtain the script.
    */
-  defineLazyScriptGetter: function XPCU_defineLazyScriptGetter(aObject, aNames,
-                                                               aResource)
-  {
+  defineLazyScriptGetter: function XPCU_defineLazyScriptGetter(
+    aObject,
+    aNames,
+    aResource
+  ) {
     if (!Array.isArray(aNames)) {
       aNames = [aNames];
     }
     for (let name of aNames) {
       Object.defineProperty(aObject, name, {
         get: function() {
           Services.scriptloader.loadSubScript(aResource, aObject);
           return aObject[name];
         },
         set(value) {
           redefine(aObject, name, value);
         },
         configurable: true,
-        enumerable: true
+        enumerable: true,
       });
     }
   },
 
   /**
    * Defines a getter property on the given object for each of the given
    * global names as accepted by Cu.importGlobalProperties. These
    * properties are imported into the shared JSM module global, and then
@@ -201,20 +212,22 @@ var XPCOMUtils = {
    *        The object to define the lazy getter on.
    * @param aName
    *        The name of the getter to define on aObject for the service.
    * @param aContract
    *        The contract used to obtain the service.
    * @param aInterfaceName
    *        The name of the interface to query the service to.
    */
-  defineLazyServiceGetter: function XPCU_defineLazyServiceGetter(aObject, aName,
-                                                                 aContract,
-                                                                 aInterfaceName)
-  {
+  defineLazyServiceGetter: function XPCU_defineLazyServiceGetter(
+    aObject,
+    aName,
+    aContract,
+    aInterfaceName
+  ) {
     this.defineLazyGetter(aObject, aName, function XPCU_serviceLambda() {
       if (aInterfaceName) {
         return Cc[aContract].getService(Ci[aInterfaceName]);
       }
       return Cc[aContract].getService().wrappedJSObject;
     });
   },
 
@@ -227,23 +240,29 @@ var XPCOMUtils = {
    * @param aServices
    *        An object with a property for each service to be
    *        imported, where the property name is the name of the
    *        symbol to define, and the value is a 1 or 2 element array
    *        containing the contract ID and, optionally, the interface
    *        name of the service, as passed to defineLazyServiceGetter.
    */
   defineLazyServiceGetters: function XPCU_defineLazyServiceGetters(
-                                   aObject, aServices)
-  {
+    aObject,
+    aServices
+  ) {
     for (let [name, service] of Object.entries(aServices)) {
       // Note: This is hot code, and cross-compartment array wrappers
       // are not JIT-friendly to destructuring or spread operators, so
       // we need to use indexed access instead.
-      this.defineLazyServiceGetter(aObject, name, service[0], service[1] || null);
+      this.defineLazyServiceGetter(
+        aObject,
+        name,
+        service[0],
+        service[1] || null
+      );
     }
   },
 
   /**
    * Defines a getter on a specified object for a module.  The module will not
    * be imported until first use. The getter allows to execute setup and
    * teardown code (e.g.  to register/unregister to services) and accepts
    * a proxy object which acts on behalf of the module until it is imported.
@@ -264,35 +283,40 @@ var XPCOMUtils = {
    *        A function that is executed when the module has been imported to
    *        run optional teardown procedures on the proxy object.
    *        This will only ever be called once.
    * @param aProxy
    *        An object which acts on behalf of the module to be imported until
    *        the module has been imported.
    */
   defineLazyModuleGetter: function XPCU_defineLazyModuleGetter(
-                                   aObject, aName, aResource, aSymbol,
-                                   aPreLambda, aPostLambda, aProxy)
-  {
+    aObject,
+    aName,
+    aResource,
+    aSymbol,
+    aPreLambda,
+    aPostLambda,
+    aProxy
+  ) {
     if (arguments.length == 3) {
       return ChromeUtils.defineModuleGetter(aObject, aName, aResource);
     }
 
     let proxy = aProxy || {};
 
-    if (typeof(aPreLambda) === "function") {
+    if (typeof aPreLambda === "function") {
       aPreLambda.apply(proxy);
     }
 
     this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
       var temp = {};
       try {
         ChromeUtils.import(aResource, temp);
 
-        if (typeof(aPostLambda) === "function") {
+        if (typeof aPostLambda === "function") {
           aPostLambda.apply(proxy);
         }
       } catch (ex) {
         Cu.reportError("Failed to load module " + aResource + ".");
         throw ex;
       }
       return temp[aSymbol || aName];
     });
@@ -305,18 +329,19 @@ var XPCOMUtils = {
    * @param aObject
    *        The object to define the lazy getter on.
    * @param aModules
    *        An object with a property for each module property to be
    *        imported, where the property name is the name of the
    *        imported symbol and the value is the module URI.
    */
   defineLazyModuleGetters: function XPCU_defineLazyModuleGetters(
-                                   aObject, aModules)
-  {
+    aObject,
+    aModules
+  ) {
     for (let [name, module] of Object.entries(aModules)) {
       ChromeUtils.defineModuleGetter(aObject, name, module);
     }
   },
 
   /**
    * Defines a getter on a specified object for preference value. The
    * preference is read the first time that the property is accessed,
@@ -334,21 +359,23 @@ var XPCOMUtils = {
    *        A function to call upon update. Receives as arguments
    *         `(aPreference, previousValue, newValue)`
    * @param aTransform
    *        An optional function to transform the value.  If provided,
    *        this function receives the new preference value as an argument
    *        and its return value is used by the getter.
    */
   defineLazyPreferenceGetter: function XPCU_defineLazyPreferenceGetter(
-                                   aObject, aName, aPreference,
-                                   aDefaultValue = null,
-                                   aOnUpdate = null,
-                                   aTransform = val => val)
-  {
+    aObject,
+    aName,
+    aPreference,
+    aDefaultValue = null,
+    aOnUpdate = null,
+    aTransform = val => val
+  ) {
     // Note: We need to keep a reference to this observer alive as long
     // as aObject is alive. This means that all of our getters need to
     // explicitly close over the variable that holds the object, and we
     // cannot define a value in place of a getter after we read the
     // preference.
     let observer = {
       QueryInterface: XPCU_lazyPreferenceObserverQI,
 
@@ -359,23 +386,22 @@ var XPCOMUtils = {
           if (aOnUpdate) {
             let previous = this.value;
 
             // Fetch and cache value.
             this.value = undefined;
             let latest = lazyGetter();
             aOnUpdate(data, previous, latest);
           } else {
-
             // Empty cache, next call to the getter will cause refetch.
             this.value = undefined;
           }
         }
       },
-    }
+    };
 
     let defineGetter = get => {
       Object.defineProperty(aObject, aName, {
         configurable: true,
         enumerable: true,
         get,
       });
     };
@@ -397,19 +423,21 @@ var XPCOMUtils = {
             break;
 
           case Ci.nsIPrefBranch.PREF_INVALID:
             prefValue = aDefaultValue;
             break;
 
           default:
             // This should never happen.
-            throw new Error(`Error getting pref ${aPreference}; its value's type is ` +
-                            `${Services.prefs.getPrefType(aPreference)}, which I don't ` +
-                            `know how to handle.`);
+            throw new Error(
+              `Error getting pref ${aPreference}; its value's type is ` +
+                `${Services.prefs.getPrefType(aPreference)}, which I don't ` +
+                `know how to handle.`
+            );
         }
 
         observer.value = aTransform(prefValue);
       }
       return observer.value;
     }
 
     defineGetter(() => {
@@ -423,57 +451,57 @@ var XPCOMUtils = {
   /**
    * Returns an nsIFactory for |component|.
    */
   _getFactory: function XPCOMUtils__getFactory(component) {
     var factory = component.prototype._xpcom_factory;
     if (!factory) {
       factory = {
         createInstance: function(outer, iid) {
-          if (outer)
-            throw Cr.NS_ERROR_NO_AGGREGATION;
-          return (new component()).QueryInterface(iid);
+          if (outer) throw Cr.NS_ERROR_NO_AGGREGATION;
+          return new component().QueryInterface(iid);
         },
-        QueryInterface: nsIFactoryQI
-      }
+        QueryInterface: nsIFactoryQI,
+      };
     }
     return factory;
   },
 
   /**
    * generates a singleton nsIFactory implementation that can be used as
    * the _xpcom_factory of the component.
    * @param aServiceConstructor
    *        Constructor function of the component.
    */
-  generateSingletonFactory:
-  function XPCOMUtils_generateSingletonFactory(aServiceConstructor) {
+  generateSingletonFactory: function XPCOMUtils_generateSingletonFactory(
+    aServiceConstructor
+  ) {
     return {
       _instance: null,
       createInstance: function XPCU_SF_createInstance(aOuter, aIID) {
         if (aOuter !== null) {
           throw Cr.NS_ERROR_NO_AGGREGATION;
         }
         if (this._instance === null) {
           this._instance = new aServiceConstructor();
         }
         return this._instance.QueryInterface(aIID);
       },
-      QueryInterface: nsIFactoryQI
+      QueryInterface: nsIFactoryQI,
     };
   },
 
   /**
    * Defines a non-writable property on an object.
    */
   defineConstant: function XPCOMUtils__defineConstant(aObj, aName, aValue) {
     Object.defineProperty(aObj, aName, {
       value: aValue,
       enumerable: true,
-      writable: false
+      writable: false,
     });
   },
 
   /**
    * Defines a proxy which acts as a lazy object getter that can be passed
    * around as a reference, and will only be evaluated when something in
    * that object gets accessed.
    *
@@ -523,30 +551,39 @@ var XPCOMUtils = {
    *        A function that gets called once when the object has just been evaluated.
    *        You can use this to do some work (e.g. setting properties) that you need
    *        to do on this object but that can wait until it gets evaluated.
    *
    *        Another use case for this is to use during code development to log when
    *        this object gets evaluated, to make sure you're not accidentally triggering
    *        it earlier than expected.
    */
-  defineLazyProxy: function XPCOMUtils__defineLazyProxy(aObject, aName, aInitFuncOrResource,
-                                                        aStubProperties, aUntrapCallback) {
+  defineLazyProxy: function XPCOMUtils__defineLazyProxy(
+    aObject,
+    aName,
+    aInitFuncOrResource,
+    aStubProperties,
+    aUntrapCallback
+  ) {
     let initFunc = aInitFuncOrResource;
 
-    if (typeof(aInitFuncOrResource) == "string") {
-      initFunc = function () {
+    if (typeof aInitFuncOrResource == "string") {
+      initFunc = function() {
         let tmp = {};
         ChromeUtils.import(aInitFuncOrResource, tmp);
         return tmp[aName];
       };
     }
 
-    let handler = new LazyProxyHandler(aName, initFunc,
-                                       aStubProperties, aUntrapCallback);
+    let handler = new LazyProxyHandler(
+      aName,
+      initFunc,
+      aStubProperties,
+      aUntrapCallback
+    );
 
     /*
      * We cannot simply create a lazy getter for the underlying
      * object and pass it as the target of the proxy, because
      * just passing it in `new Proxy` means it would get
      * evaluated. Becase of this, a full handler needs to be
      * implemented (the LazyProxyHandler).
      *
@@ -627,19 +664,21 @@ class LazyProxyHandler {
     return Reflect.defineProperty(this.getObject(), prop, descriptor);
   }
 
   has(target, prop) {
     return Reflect.has(this.getObject(), prop);
   }
 
   get(target, prop, receiver) {
-    if (this.pending &&
-        this.stubProperties &&
-        Object.prototype.hasOwnProperty.call(this.stubProperties, prop)) {
+    if (
+      this.pending &&
+      this.stubProperties &&
+      Object.prototype.hasOwnProperty.call(this.stubProperties, prop)
+    ) {
       return this.stubProperties[prop];
     }
     return Reflect.get(this.getObject(), prop, receiver);
   }
 
   set(target, prop, value, receiver) {
     return Reflect.set(this.getObject(), prop, value, receiver);
   }
@@ -648,12 +687,18 @@ class LazyProxyHandler {
     return Reflect.deleteProperty(this.getObject(), prop);
   }
 
   ownKeys(target) {
     return Reflect.ownKeys(this.getObject());
   }
 }
 
-var XPCU_lazyPreferenceObserverQI = ChromeUtils.generateQI([Ci.nsIObserver, Ci.nsISupportsWeakReference]);
+var XPCU_lazyPreferenceObserverQI = ChromeUtils.generateQI([
+  Ci.nsIObserver,
+  Ci.nsISupportsWeakReference,
+]);
 
-ChromeUtils.defineModuleGetter(this, "Services",
-                               "resource://gre/modules/Services.jsm");
+ChromeUtils.defineModuleGetter(
+  this,
+  "Services",
+  "resource://gre/modules/Services.jsm"
+);
diff --git a/toolkit/components/cascade_bloom_filter/Cargo.toml b/toolkit/components/cascade_bloom_filter/Cargo.toml
--- a/toolkit/components/cascade_bloom_filter/Cargo.toml
+++ b/toolkit/components/cascade_bloom_filter/Cargo.toml
@@ -1,12 +1,16 @@
 [package]
 name = "cascade_bloom_filter"
 version = "0.1.0"
 authors = ["Rob Wu <rob@robwu.nl>"]
 
+[lib]
+crate-type = ["cdylib"]
+
 [dependencies]
-nserror = { path = "../../../xpcom/rust/nserror" }
-nsstring = { path = "../../../xpcom/rust/nsstring" }
-rental = "0.5.5"
-rust_cascade = "0.6.0"
-thin-vec = { version = "0.1.0", features = ["gecko-ffi"] }
-xpcom = { path = "../../../xpcom/rust/xpcom" }
+wasm-bindgen = "0.2.63"
+#nserror = { path = "../../../xpcom/rust/nserror" }
+#nsstring = { path = "../../../xpcom/rust/nsstring" }
+#rental = "0.5.5"
+#rust_cascade = "0.6.0"
+#thin-vec = { version = "0.1.0", features = ["gecko-ffi"] }
+#xpcom = { path = "../../../xpcom/rust/xpcom" }
diff --git a/toolkit/components/cascade_bloom_filter/jar.mn b/toolkit/components/cascade_bloom_filter/jar.mn
new file mode 100644
--- /dev/null
+++ b/toolkit/components/cascade_bloom_filter/jar.mn
@@ -0,0 +1,7 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+toolkit.jar:
+  content/global/cascade_bloom_filter/cascade_bloom_filter.js                         (pkg/cascade_bloom_filter_bg.js)
+  content/global/cascade_bloom_filter/cascade_bloom_filter_bg.wasm                         (pkg/cascade_bloom_filter_bg.wasm)
diff --git a/toolkit/components/cascade_bloom_filter/moz.build b/toolkit/components/cascade_bloom_filter/moz.build
--- a/toolkit/components/cascade_bloom_filter/moz.build
+++ b/toolkit/components/cascade_bloom_filter/moz.build
@@ -2,16 +2,17 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 with Files('**'):
     BUG_COMPONENT = ('Toolkit', 'Blocklist Implementation')
 
+
 XPCSHELL_TESTS_MANIFESTS += ['test/xpcshell/xpcshell.ini']
 
 XPIDL_SOURCES += [
     'nsICascadeFilter.idl',
 ]
 
 XPIDL_MODULE = 'cascade_bindings'
 
@@ -22,9 +23,12 @@ EXPORTS.mozilla += [
 SOURCES += [
     "CascadeFilter.cpp"
 ]
 
 XPCOM_MANIFESTS += [
     'components.conf',
 ]
 
+DIRS += ['wasm']
+JAR_MANIFESTS += ['jar.mn']
+
 FINAL_LIBRARY = 'xul'
diff --git a/toolkit/components/cascade_bloom_filter/src/lib.rs b/toolkit/components/cascade_bloom_filter/src/lib.rs
--- a/toolkit/components/cascade_bloom_filter/src/lib.rs
+++ b/toolkit/components/cascade_bloom_filter/src/lib.rs
@@ -1,79 +1,14 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-extern crate nserror;
-extern crate nsstring;
-#[macro_use]
-extern crate rental;
-extern crate rust_cascade;
-extern crate thin_vec;
-#[macro_use]
-extern crate xpcom;
+// The wasm-pack uses wasm-bindgen to build and generate JavaScript binding file.
+// Import the wasm-bindgen crate.
+extern crate wasm_bindgen;
 
-use nserror::{nsresult, NS_ERROR_INVALID_ARG, NS_ERROR_NOT_INITIALIZED, NS_OK};
-use nsstring::nsACString;
-use rust_cascade::Cascade;
-use std::cell::RefCell;
-use thin_vec::ThinVec;
-use xpcom::interfaces::nsICascadeFilter;
-use xpcom::{xpcom_method, RefPtr};
-
-// Cascade does not take ownership of the data, so we must own the data in order to pass its
-// reference to Cascade.
-rental! {
-    mod rentals {
-        use super::Cascade;
-
-        #[rental]
-        pub struct CascadeWithOwnedData {
-            owndata: Box<[u8]>,
-            cascade: Box<Cascade<'owndata>>,
-        }
-    }
-}
+use wasm_bindgen::prelude::*;
 
-#[derive(xpcom)]
-#[xpimplements(nsICascadeFilter)]
-#[refcnt = "nonatomic"]
-pub struct InitCascadeFilter {
-    filter: RefCell<Option<rentals::CascadeWithOwnedData>>,
+// Our function to concatenate the string "Wasm by Example"
+// to the input string. We are using .into(), to convert
+// the rust types of str to a String.
+#[wasm_bindgen]
+pub fn add_wasm_by_example_to_string(input_string: String) -> String {
+  let result = format!("{} {}", input_string, "Hi From WASM");
+  return result.into();
 }
-
-impl CascadeFilter {
-    fn new() -> RefPtr<CascadeFilter> {
-        CascadeFilter::allocate(InitCascadeFilter {
-            filter: RefCell::new(None),
-        })
-    }
-    xpcom_method!(set_filter_data => SetFilterData(data: *const ThinVec<u8>));
-
-    fn set_filter_data(&self, data: &ThinVec<u8>) -> Result<(), nsresult> {
-        let filter = rentals::CascadeWithOwnedData::try_new_or_drop(
-            Vec::from(data.as_slice()).into_boxed_slice(),
-            |data| {
-                Cascade::from_bytes(data)
-                    .unwrap_or(None)
-                    .ok_or(NS_ERROR_INVALID_ARG)
-            },
-        )?;
-        self.filter.borrow_mut().replace(filter);
-        Ok(())
-    }
-
-    xpcom_method!(has => Has(key: *const nsACString) -> bool);
-
-    fn has(&self, key: &nsACString) -> Result<bool, nsresult> {
-        match self.filter.borrow().as_ref() {
-            None => Err(NS_ERROR_NOT_INITIALIZED),
-            Some(filter) => Ok(filter.rent(|cascade| cascade.has(&*key))),
-        }
-    }
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn cascade_filter_construct(result: &mut *const nsICascadeFilter) {
-    let inst: RefPtr<CascadeFilter> = CascadeFilter::new();
-    *result = inst.coerce::<nsICascadeFilter>();
-    std::mem::forget(inst);
-}
diff --git a/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js b/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js
--- a/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js
+++ b/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js
@@ -1,10 +1,12 @@
 "use strict";
 
+
+
 const CASCADE_CID = "@mozilla.org/cascade-filter;1";
 const CASCADE_IID = Ci.nsICascadeFilter;
 const CascadeFilter = Components.Constructor(CASCADE_CID, CASCADE_IID);
 
 add_task(function CascadeFilter_uninitialized() {
   let filter = new CascadeFilter();
   Assert.throws(
     () => filter.has(""),
diff --git a/toolkit/components/cascade_bloom_filter/wasm/.gitignore b/toolkit/components/cascade_bloom_filter/wasm/.gitignore
new file mode 100644
--- /dev/null
+++ b/toolkit/components/cascade_bloom_filter/wasm/.gitignore
@@ -0,0 +1,1 @@
+*
\ No newline at end of file
diff --git a/toolkit/components/cascade_bloom_filter/wasm/cascade_bloom_filter.js b/toolkit/components/cascade_bloom_filter/wasm/cascade_bloom_filter.js
new file mode 100644
--- /dev/null
+++ b/toolkit/components/cascade_bloom_filter/wasm/cascade_bloom_filter.js
@@ -0,0 +1,162 @@
+let wasm_bindgen;
+(function() {
+    const __exports = {};
+    let wasm;
+
+    let WASM_VECTOR_LEN = 0;
+
+    let cachegetUint8Memory0 = null;
+    function getUint8Memory0() {
+        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
+            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
+        }
+        return cachegetUint8Memory0;
+    }
+
+    let cachedTextEncoder = new TextEncoder('utf-8');
+
+    const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
+        ? function (arg, view) {
+        return cachedTextEncoder.encodeInto(arg, view);
+    }
+        : function (arg, view) {
+        const buf = cachedTextEncoder.encode(arg);
+        view.set(buf);
+        return {
+            read: arg.length,
+            written: buf.length
+        };
+    });
+
+    function passStringToWasm0(arg, malloc, realloc) {
+
+        if (realloc === undefined) {
+            const buf = cachedTextEncoder.encode(arg);
+            const ptr = malloc(buf.length);
+            getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
+            WASM_VECTOR_LEN = buf.length;
+            return ptr;
+        }
+
+        let len = arg.length;
+        let ptr = malloc(len);
+
+        const mem = getUint8Memory0();
+
+        let offset = 0;
+
+        for (; offset < len; offset++) {
+            const code = arg.charCodeAt(offset);
+            if (code > 0x7F) break;
+            mem[ptr + offset] = code;
+        }
+
+        if (offset !== len) {
+            if (offset !== 0) {
+                arg = arg.slice(offset);
+            }
+            ptr = realloc(ptr, len, len = offset + arg.length * 3);
+            const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
+            const ret = encodeString(arg, view);
+
+            offset += ret.written;
+        }
+
+        WASM_VECTOR_LEN = offset;
+        return ptr;
+    }
+
+    let cachegetInt32Memory0 = null;
+    function getInt32Memory0() {
+        if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
+            cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
+        }
+        return cachegetInt32Memory0;
+    }
+
+    let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });
+
+    cachedTextDecoder.decode();
+
+    function getStringFromWasm0(ptr, len) {
+        return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
+    }
+    /**
+    * @param {string} input_string
+    * @returns {string}
+    */
+    __exports.add_wasm_by_example_to_string = function(input_string) {
+        try {
+            var ptr0 = passStringToWasm0(input_string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
+            var len0 = WASM_VECTOR_LEN;
+            wasm.add_wasm_by_example_to_string(8, ptr0, len0);
+            var r0 = getInt32Memory0()[8 / 4 + 0];
+            var r1 = getInt32Memory0()[8 / 4 + 1];
+            return getStringFromWasm0(r0, r1);
+        } finally {
+            wasm.__wbindgen_free(r0, r1);
+        }
+    };
+
+    async function load(module, imports) {
+        if (typeof Response === 'function' && module instanceof Response) {
+
+            if (typeof WebAssembly.instantiateStreaming === 'function') {
+                try {
+                    return await WebAssembly.instantiateStreaming(module, imports);
+
+                } catch (e) {
+                    if (module.headers.get('Content-Type') != 'application/wasm') {
+                        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
+
+                    } else {
+                        throw e;
+                    }
+                }
+            }
+
+            const bytes = await module.arrayBuffer();
+            return await WebAssembly.instantiate(bytes, imports);
+
+        } else {
+
+            const instance = await WebAssembly.instantiate(module, imports);
+
+            if (instance instanceof WebAssembly.Instance) {
+                return { instance, module };
+
+            } else {
+                return instance;
+            }
+        }
+    }
+
+    async function init(input) {
+        if (typeof input === 'undefined') {
+            let src;
+            if (typeof document === 'undefined') {
+                src = location.href;
+            } else {
+                src = document.currentScript.src;
+            }
+            input = src.replace(/\.js$/, '_bg.wasm');
+        }
+        const imports = {};
+
+
+        if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
+            input = fetch(input);
+        }
+
+        const { instance, module } = await load(await input, imports);
+
+        wasm = instance.exports;
+        init.__wbindgen_wasm_module = module;
+
+        return wasm;
+    }
+
+    wasm_bindgen = Object.assign(init, __exports);
+
+})();
+var EXPORTED_SYMBOLS = ["wasm_bindgen"];
diff --git a/toolkit/components/cascade_bloom_filter/wasm/cascade_bloom_filter_bg.wasm b/toolkit/components/cascade_bloom_filter/wasm/cascade_bloom_filter_bg.wasm
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..ce2f64a1830c71b453a37188e02ed6e3b6455885
GIT binary patch
literal 21729
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

diff --git a/toolkit/components/cascade_bloom_filter/wasm/moz.build b/toolkit/components/cascade_bloom_filter/wasm/moz.build
new file mode 100644
--- /dev/null
+++ b/toolkit/components/cascade_bloom_filter/wasm/moz.build
@@ -0,0 +1,5 @@
+
+EXTRA_JS_MODULES += [
+    cascade_bloom_filter.js,
+]
+
diff --git a/toolkit/components/cascade_bloom_filter/wasm/package.json b/toolkit/components/cascade_bloom_filter/wasm/package.json
new file mode 100644
--- /dev/null
+++ b/toolkit/components/cascade_bloom_filter/wasm/package.json
@@ -0,0 +1,12 @@
+{
+  "name": "cascade_bloom_filter",
+  "collaborators": [
+    "Rob Wu <rob@robwu.nl>"
+  ],
+  "version": "0.1.0",
+  "files": [
+    "cascade_bloom_filter_bg.wasm",
+    "cascade_bloom_filter.js"
+  ],
+  "browser": "cascade_bloom_filter.js"
+}
\ No newline at end of file
