# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  302cc6ec6d96b5ab4bf81933dd5249091e5d86c3

diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -493,22 +493,17 @@ checksum = "214238caa1bf3a496ec339296896
 dependencies = [
  "ppv-lite86",
 ]
 
 [[package]]
 name = "cascade_bloom_filter"
 version = "0.1.0"
 dependencies = [
- "nserror",
- "nsstring",
- "rental",
- "rust_cascade",
- "thin-vec",
- "xpcom",
+ "wasm-bindgen",
 ]
 
 [[package]]
 name = "cast"
 version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "926013f2860c46252efceabb19f4a6b308197505082c609025aa6706c011d427"
 
@@ -3713,19 +3708,19 @@ checksum = "ecd45702f76d6d3c75a80564378a
 dependencies = [
  "proc-macro2",
  "quote",
  "syn",
 ]
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "90cf5f418035b98e655e9cdb225047638296b862b42411c4e45bb88d700f7fc0"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "beae6331a816b1f65d04c45b078fd8e6c93e8071771f41b8163255bbd8d7c8fa"
 dependencies = [
  "unicode-xid",
 ]
 
 [[package]]
 name = "procedural-masquerade"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -4675,19 +4670,19 @@ dependencies = [
  "cc",
  "gleam",
  "glsl-to-cxx",
  "webrender_build",
 ]
 
 [[package]]
 name = "syn"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf"
+version = "1.0.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8d5d96e8cbb005d6959f119f773bfaebb5684296108fb32600c00cde305b2cd"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-xid",
 ]
 
 [[package]]
 name = "sync-guid"
@@ -5361,16 +5356,70 @@ dependencies = [
  "serde_json",
  "serde_urlencoded",
  "tokio 0.2.18",
  "tower-service",
  "urlencoding",
 ]
 
 [[package]]
+name = "wasm-bindgen"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c2dc4aa152834bc334f506c1a06b866416a8b6697d5c9f75b9a689c8486def0"
+dependencies = [
+ "cfg-if",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ded84f06e0ed21499f6184df0e0cb3494727b0c5da89534e0fcc55c51d812101"
+dependencies = [
+ "bumpalo",
+ "lazy_static",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "838e423688dac18d73e31edce74ddfac468e37b1506ad163ffaf0a46f703ffe3"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3156052d8ec77142051a533cdd686cba889537b213f948cd1d20869926e68e92"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c9ba19973a58daf4db6f352eda73dc0e289493cd29fb2632eb172085b6521acd"
+
+[[package]]
 name = "wasmparser"
 version = "0.48.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "073da89bf1c84db000dd68ce660c1b4a08e3a2d28fd1e3394ab9e7abdde4a0f8"
 
 [[package]]
 name = "wasmparser"
 version = "0.57.0"
diff --git a/js/xpconnect/loader/XPCOMUtils.jsm b/js/xpconnect/loader/XPCOMUtils.jsm
--- a/js/xpconnect/loader/XPCOMUtils.jsm
+++ b/js/xpconnect/loader/XPCOMUtils.jsm
@@ -47,18 +47,17 @@
  * 2. Create an array of component constructors (like the one
  * created in step 1):
  *  var components = [MyComponent];
  *
  * 3. Define the NSGetFactory entry point:
  *  this.NSGetFactory = XPCOMUtils.generateNSGetFactory(components);
  */
 
-
-var EXPORTED_SYMBOLS = [ "XPCOMUtils" ];
+var EXPORTED_SYMBOLS = ["XPCOMUtils"];
 
 let global = Cu.getGlobalForObject({});
 
 const nsIFactoryQI = ChromeUtils.generateQI([Ci.nsIFactory]);
 
 // Some global imports expose additional symbols; for example,
 // `Cu.importGlobalProperties(["MessageChannel"])` imports `MessageChannel`
 // and `MessagePort`. This table maps those extra symbols to the main
@@ -81,61 +80,71 @@ function redefine(object, prop, value) {
     enumerable: true,
     value,
     writable: true,
   });
   return value;
 }
 
 var XPCOMUtils = {
+  async loadWASM(jsmPath, wasmPath) {
+    const {wasm_bindgen} = ChromeUtils.import(jsmPath || "resource://gre/modules/cascade_bloom_filter.js", {});
+    await wasm_bindgen(wasmPath || "chrome://global/content/cascade_bloom_filter/cascade_bloom_filter_bg.wasm");
+// (async function() {
+  // let wb = await cbf.wasm_bindgen("chrome://global/content/cascade_bloom_filter/cascade_bloom_filter_bg.wasm");
+
+  return wasm_bindgen;
+  },
+
   /**
    * Generate a NSGetFactory function given an array of components.
    */
   generateNSGetFactory: function XPCU_generateNSGetFactory(componentsArray) {
     let classes = {};
     for (let i = 0; i < componentsArray.length; i++) {
-        let component = componentsArray[i];
-        if (!(component.prototype.classID instanceof Components.ID))
-          throw Error("In generateNSGetFactory, classID missing or incorrect for component " + component);
+      let component = componentsArray[i];
+      if (!(component.prototype.classID instanceof Components.ID))
+        throw Error(
+          "In generateNSGetFactory, classID missing or incorrect for component " +
+            component
+        );
 
-        classes[component.prototype.classID] = this._getFactory(component);
+      classes[component.prototype.classID] = this._getFactory(component);
     }
     return function NSGetFactory(cid) {
       let cidstring = cid.toString();
-      if (cidstring in classes)
-        return classes[cidstring];
+      if (cidstring in classes) return classes[cidstring];
       throw Cr.NS_ERROR_FACTORY_NOT_REGISTERED;
-    }
+    };
   },
 
   /**
    * Defines a getter on a specified object that will be created upon first use.
    *
    * @param aObject
    *        The object to define the lazy getter on.
    * @param aName
    *        The name of the getter to define on aObject.
    * @param aLambda
    *        A function that returns what the getter should return.  This will
    *        only ever be called once.
    */
-  defineLazyGetter: function XPCU_defineLazyGetter(aObject, aName, aLambda)
-  {
+  defineLazyGetter: function XPCU_defineLazyGetter(aObject, aName, aLambda) {
     let redefining = false;
     Object.defineProperty(aObject, aName, {
-      get: function () {
+      get: function() {
         if (!redefining) {
           // Make sure we don't get into an infinite recursion loop if
           // the getter lambda does something shady.
           redefining = true;
           return redefine(aObject, aName, aLambda.apply(aObject));
         }
       },
       configurable: true,
-      enumerable: true
+      enumerable: true,
     });
   },
 
   /**
    * Defines a getter on a specified object for a script.  The script will not
    * be loaded until first use.
    *
    * @param aObject
@@ -143,33 +152,35 @@ var XPCOMUtils = {
    * @param aNames
    *        The name of the getter to define on aObject for the script.
    *        This can be a string if the script exports only one symbol,
    *        or an array of strings if the script can be first accessed
    *        from several different symbols.
    * @param aResource
    *        The URL used to obtain the script.
    */
-  defineLazyScriptGetter: function XPCU_defineLazyScriptGetter(aObject, aNames,
-                                                               aResource)
-  {
+  defineLazyScriptGetter: function XPCU_defineLazyScriptGetter(
+    aObject,
+    aNames,
+    aResource
+  ) {
     if (!Array.isArray(aNames)) {
       aNames = [aNames];
     }
     for (let name of aNames) {
       Object.defineProperty(aObject, name, {
         get: function() {
           Services.scriptloader.loadSubScript(aResource, aObject);
           return aObject[name];
         },
         set(value) {
           redefine(aObject, name, value);
         },
         configurable: true,
-        enumerable: true
+        enumerable: true,
       });
     }
   },
 
   /**
    * Defines a getter property on the given object for each of the given
    * global names as accepted by Cu.importGlobalProperties. These
    * properties are imported into the shared JSM module global, and then
@@ -201,20 +212,22 @@ var XPCOMUtils = {
    *        The object to define the lazy getter on.
    * @param aName
    *        The name of the getter to define on aObject for the service.
    * @param aContract
    *        The contract used to obtain the service.
    * @param aInterfaceName
    *        The name of the interface to query the service to.
    */
-  defineLazyServiceGetter: function XPCU_defineLazyServiceGetter(aObject, aName,
-                                                                 aContract,
-                                                                 aInterfaceName)
-  {
+  defineLazyServiceGetter: function XPCU_defineLazyServiceGetter(
+    aObject,
+    aName,
+    aContract,
+    aInterfaceName
+  ) {
     this.defineLazyGetter(aObject, aName, function XPCU_serviceLambda() {
       if (aInterfaceName) {
         return Cc[aContract].getService(Ci[aInterfaceName]);
       }
       return Cc[aContract].getService().wrappedJSObject;
     });
   },
 
@@ -227,23 +240,29 @@ var XPCOMUtils = {
    * @param aServices
    *        An object with a property for each service to be
    *        imported, where the property name is the name of the
    *        symbol to define, and the value is a 1 or 2 element array
    *        containing the contract ID and, optionally, the interface
    *        name of the service, as passed to defineLazyServiceGetter.
    */
   defineLazyServiceGetters: function XPCU_defineLazyServiceGetters(
-                                   aObject, aServices)
-  {
+    aObject,
+    aServices
+  ) {
     for (let [name, service] of Object.entries(aServices)) {
       // Note: This is hot code, and cross-compartment array wrappers
       // are not JIT-friendly to destructuring or spread operators, so
       // we need to use indexed access instead.
-      this.defineLazyServiceGetter(aObject, name, service[0], service[1] || null);
+      this.defineLazyServiceGetter(
+        aObject,
+        name,
+        service[0],
+        service[1] || null
+      );
     }
   },
 
   /**
    * Defines a getter on a specified object for a module.  The module will not
    * be imported until first use. The getter allows to execute setup and
    * teardown code (e.g.  to register/unregister to services) and accepts
    * a proxy object which acts on behalf of the module until it is imported.
@@ -264,35 +283,40 @@ var XPCOMUtils = {
    *        A function that is executed when the module has been imported to
    *        run optional teardown procedures on the proxy object.
    *        This will only ever be called once.
    * @param aProxy
    *        An object which acts on behalf of the module to be imported until
    *        the module has been imported.
    */
   defineLazyModuleGetter: function XPCU_defineLazyModuleGetter(
-                                   aObject, aName, aResource, aSymbol,
-                                   aPreLambda, aPostLambda, aProxy)
-  {
+    aObject,
+    aName,
+    aResource,
+    aSymbol,
+    aPreLambda,
+    aPostLambda,
+    aProxy
+  ) {
     if (arguments.length == 3) {
       return ChromeUtils.defineModuleGetter(aObject, aName, aResource);
     }
 
     let proxy = aProxy || {};
 
-    if (typeof(aPreLambda) === "function") {
+    if (typeof aPreLambda === "function") {
       aPreLambda.apply(proxy);
     }
 
     this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
       var temp = {};
       try {
         ChromeUtils.import(aResource, temp);
 
-        if (typeof(aPostLambda) === "function") {
+        if (typeof aPostLambda === "function") {
           aPostLambda.apply(proxy);
         }
       } catch (ex) {
         Cu.reportError("Failed to load module " + aResource + ".");
         throw ex;
       }
       return temp[aSymbol || aName];
     });
@@ -305,18 +329,19 @@ var XPCOMUtils = {
    * @param aObject
    *        The object to define the lazy getter on.
    * @param aModules
    *        An object with a property for each module property to be
    *        imported, where the property name is the name of the
    *        imported symbol and the value is the module URI.
    */
   defineLazyModuleGetters: function XPCU_defineLazyModuleGetters(
-                                   aObject, aModules)
-  {
+    aObject,
+    aModules
+  ) {
     for (let [name, module] of Object.entries(aModules)) {
       ChromeUtils.defineModuleGetter(aObject, name, module);
     }
   },
 
   /**
    * Defines a getter on a specified object for preference value. The
    * preference is read the first time that the property is accessed,
@@ -334,21 +359,23 @@ var XPCOMUtils = {
    *        A function to call upon update. Receives as arguments
    *         `(aPreference, previousValue, newValue)`
    * @param aTransform
    *        An optional function to transform the value.  If provided,
    *        this function receives the new preference value as an argument
    *        and its return value is used by the getter.
    */
   defineLazyPreferenceGetter: function XPCU_defineLazyPreferenceGetter(
-                                   aObject, aName, aPreference,
-                                   aDefaultValue = null,
-                                   aOnUpdate = null,
-                                   aTransform = val => val)
-  {
+    aObject,
+    aName,
+    aPreference,
+    aDefaultValue = null,
+    aOnUpdate = null,
+    aTransform = val => val
+  ) {
     // Note: We need to keep a reference to this observer alive as long
     // as aObject is alive. This means that all of our getters need to
     // explicitly close over the variable that holds the object, and we
     // cannot define a value in place of a getter after we read the
     // preference.
     let observer = {
       QueryInterface: XPCU_lazyPreferenceObserverQI,
 
@@ -359,23 +386,22 @@ var XPCOMUtils = {
           if (aOnUpdate) {
             let previous = this.value;
 
             // Fetch and cache value.
             this.value = undefined;
             let latest = lazyGetter();
             aOnUpdate(data, previous, latest);
           } else {
-
             // Empty cache, next call to the getter will cause refetch.
             this.value = undefined;
           }
         }
       },
-    }
+    };
 
     let defineGetter = get => {
       Object.defineProperty(aObject, aName, {
         configurable: true,
         enumerable: true,
         get,
       });
     };
@@ -397,19 +423,21 @@ var XPCOMUtils = {
             break;
 
           case Ci.nsIPrefBranch.PREF_INVALID:
             prefValue = aDefaultValue;
             break;
 
           default:
             // This should never happen.
-            throw new Error(`Error getting pref ${aPreference}; its value's type is ` +
-                            `${Services.prefs.getPrefType(aPreference)}, which I don't ` +
-                            `know how to handle.`);
+            throw new Error(
+              `Error getting pref ${aPreference}; its value's type is ` +
+                `${Services.prefs.getPrefType(aPreference)}, which I don't ` +
+                `know how to handle.`
+            );
         }
 
         observer.value = aTransform(prefValue);
       }
       return observer.value;
     }
 
     defineGetter(() => {
@@ -423,57 +451,57 @@ var XPCOMUtils = {
   /**
    * Returns an nsIFactory for |component|.
    */
   _getFactory: function XPCOMUtils__getFactory(component) {
     var factory = component.prototype._xpcom_factory;
     if (!factory) {
       factory = {
         createInstance: function(outer, iid) {
-          if (outer)
-            throw Cr.NS_ERROR_NO_AGGREGATION;
-          return (new component()).QueryInterface(iid);
+          if (outer) throw Cr.NS_ERROR_NO_AGGREGATION;
+          return new component().QueryInterface(iid);
         },
-        QueryInterface: nsIFactoryQI
-      }
+        QueryInterface: nsIFactoryQI,
+      };
     }
     return factory;
   },
 
   /**
    * generates a singleton nsIFactory implementation that can be used as
    * the _xpcom_factory of the component.
    * @param aServiceConstructor
    *        Constructor function of the component.
    */
-  generateSingletonFactory:
-  function XPCOMUtils_generateSingletonFactory(aServiceConstructor) {
+  generateSingletonFactory: function XPCOMUtils_generateSingletonFactory(
+    aServiceConstructor
+  ) {
     return {
       _instance: null,
       createInstance: function XPCU_SF_createInstance(aOuter, aIID) {
         if (aOuter !== null) {
           throw Cr.NS_ERROR_NO_AGGREGATION;
         }
         if (this._instance === null) {
           this._instance = new aServiceConstructor();
         }
         return this._instance.QueryInterface(aIID);
       },
-      QueryInterface: nsIFactoryQI
+      QueryInterface: nsIFactoryQI,
     };
   },
 
   /**
    * Defines a non-writable property on an object.
    */
   defineConstant: function XPCOMUtils__defineConstant(aObj, aName, aValue) {
     Object.defineProperty(aObj, aName, {
       value: aValue,
       enumerable: true,
-      writable: false
+      writable: false,
     });
   },
 
   /**
    * Defines a proxy which acts as a lazy object getter that can be passed
    * around as a reference, and will only be evaluated when something in
    * that object gets accessed.
    *
@@ -523,30 +551,39 @@ var XPCOMUtils = {
    *        A function that gets called once when the object has just been evaluated.
    *        You can use this to do some work (e.g. setting properties) that you need
    *        to do on this object but that can wait until it gets evaluated.
    *
    *        Another use case for this is to use during code development to log when
    *        this object gets evaluated, to make sure you're not accidentally triggering
    *        it earlier than expected.
    */
-  defineLazyProxy: function XPCOMUtils__defineLazyProxy(aObject, aName, aInitFuncOrResource,
-                                                        aStubProperties, aUntrapCallback) {
+  defineLazyProxy: function XPCOMUtils__defineLazyProxy(
+    aObject,
+    aName,
+    aInitFuncOrResource,
+    aStubProperties,
+    aUntrapCallback
+  ) {
     let initFunc = aInitFuncOrResource;
 
-    if (typeof(aInitFuncOrResource) == "string") {
-      initFunc = function () {
+    if (typeof aInitFuncOrResource == "string") {
+      initFunc = function() {
         let tmp = {};
         ChromeUtils.import(aInitFuncOrResource, tmp);
         return tmp[aName];
       };
     }
 
-    let handler = new LazyProxyHandler(aName, initFunc,
-                                       aStubProperties, aUntrapCallback);
+    let handler = new LazyProxyHandler(
+      aName,
+      initFunc,
+      aStubProperties,
+      aUntrapCallback
+    );
 
     /*
      * We cannot simply create a lazy getter for the underlying
      * object and pass it as the target of the proxy, because
      * just passing it in `new Proxy` means it would get
      * evaluated. Becase of this, a full handler needs to be
      * implemented (the LazyProxyHandler).
      *
@@ -627,19 +664,21 @@ class LazyProxyHandler {
     return Reflect.defineProperty(this.getObject(), prop, descriptor);
   }
 
   has(target, prop) {
     return Reflect.has(this.getObject(), prop);
   }
 
   get(target, prop, receiver) {
-    if (this.pending &&
-        this.stubProperties &&
-        Object.prototype.hasOwnProperty.call(this.stubProperties, prop)) {
+    if (
+      this.pending &&
+      this.stubProperties &&
+      Object.prototype.hasOwnProperty.call(this.stubProperties, prop)
+    ) {
       return this.stubProperties[prop];
     }
     return Reflect.get(this.getObject(), prop, receiver);
   }
 
   set(target, prop, value, receiver) {
     return Reflect.set(this.getObject(), prop, value, receiver);
   }
@@ -648,12 +687,18 @@ class LazyProxyHandler {
     return Reflect.deleteProperty(this.getObject(), prop);
   }
 
   ownKeys(target) {
     return Reflect.ownKeys(this.getObject());
   }
 }
 
-var XPCU_lazyPreferenceObserverQI = ChromeUtils.generateQI([Ci.nsIObserver, Ci.nsISupportsWeakReference]);
+var XPCU_lazyPreferenceObserverQI = ChromeUtils.generateQI([
+  Ci.nsIObserver,
+  Ci.nsISupportsWeakReference,
+]);
 
-ChromeUtils.defineModuleGetter(this, "Services",
-                               "resource://gre/modules/Services.jsm");
+ChromeUtils.defineModuleGetter(
+  this,
+  "Services",
+  "resource://gre/modules/Services.jsm"
+);
diff --git a/toolkit/components/cascade_bloom_filter/Cargo.toml b/toolkit/components/cascade_bloom_filter/Cargo.toml
--- a/toolkit/components/cascade_bloom_filter/Cargo.toml
+++ b/toolkit/components/cascade_bloom_filter/Cargo.toml
@@ -1,12 +1,16 @@
 [package]
 name = "cascade_bloom_filter"
 version = "0.1.0"
 authors = ["Rob Wu <rob@robwu.nl>"]
 
+[lib]
+crate-type = ["cdylib"]
+
 [dependencies]
-nserror = { path = "../../../xpcom/rust/nserror" }
-nsstring = { path = "../../../xpcom/rust/nsstring" }
-rental = "0.5.5"
-rust_cascade = "0.6.0"
-thin-vec = { version = "0.1.0", features = ["gecko-ffi"] }
-xpcom = { path = "../../../xpcom/rust/xpcom" }
+wasm-bindgen = "0.2.63"
+#nserror = { path = "../../../xpcom/rust/nserror" }
+#nsstring = { path = "../../../xpcom/rust/nsstring" }
+#rental = "0.5.5"
+#rust_cascade = "0.6.0"
+#thin-vec = { version = "0.1.0", features = ["gecko-ffi"] }
+#xpcom = { path = "../../../xpcom/rust/xpcom" }
diff --git a/toolkit/components/cascade_bloom_filter/moz.build b/toolkit/components/cascade_bloom_filter/moz.build
--- a/toolkit/components/cascade_bloom_filter/moz.build
+++ b/toolkit/components/cascade_bloom_filter/moz.build
@@ -2,16 +2,18 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 with Files('**'):
     BUG_COMPONENT = ('Toolkit', 'Blocklist Implementation')
 
+DIRS += ['pkg']
+
 XPCSHELL_TESTS_MANIFESTS += ['test/xpcshell/xpcshell.ini']
 
 XPIDL_SOURCES += [
     'nsICascadeFilter.idl',
 ]
 
 XPIDL_MODULE = 'cascade_bindings'
 
@@ -22,9 +24,13 @@ EXPORTS.mozilla += [
 SOURCES += [
     "CascadeFilter.cpp"
 ]
 
 XPCOM_MANIFESTS += [
     'components.conf',
 ]
 
+
+JAR_MANIFESTS += ['jar.mn']
+
+
 FINAL_LIBRARY = 'xul'
diff --git a/toolkit/components/cascade_bloom_filter/src/lib.rs b/toolkit/components/cascade_bloom_filter/src/lib.rs
--- a/toolkit/components/cascade_bloom_filter/src/lib.rs
+++ b/toolkit/components/cascade_bloom_filter/src/lib.rs
@@ -1,79 +1,14 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-extern crate nserror;
-extern crate nsstring;
-#[macro_use]
-extern crate rental;
-extern crate rust_cascade;
-extern crate thin_vec;
-#[macro_use]
-extern crate xpcom;
+// The wasm-pack uses wasm-bindgen to build and generate JavaScript binding file.
+// Import the wasm-bindgen crate.
+extern crate wasm_bindgen;
 
-use nserror::{nsresult, NS_ERROR_INVALID_ARG, NS_ERROR_NOT_INITIALIZED, NS_OK};
-use nsstring::nsACString;
-use rust_cascade::Cascade;
-use std::cell::RefCell;
-use thin_vec::ThinVec;
-use xpcom::interfaces::nsICascadeFilter;
-use xpcom::{xpcom_method, RefPtr};
-
-// Cascade does not take ownership of the data, so we must own the data in order to pass its
-// reference to Cascade.
-rental! {
-    mod rentals {
-        use super::Cascade;
-
-        #[rental]
-        pub struct CascadeWithOwnedData {
-            owndata: Box<[u8]>,
-            cascade: Box<Cascade<'owndata>>,
-        }
-    }
-}
+use wasm_bindgen::prelude::*;
 
-#[derive(xpcom)]
-#[xpimplements(nsICascadeFilter)]
-#[refcnt = "nonatomic"]
-pub struct InitCascadeFilter {
-    filter: RefCell<Option<rentals::CascadeWithOwnedData>>,
+// Our function to concatenate the string "Wasm by Example"
+// to the input string. We are using .into(), to convert
+// the rust types of str to a String.
+#[wasm_bindgen]
+pub fn add_wasm_by_example_to_string(input_string: String) -> String {
+  let result = format!("{} {}", input_string, "Wasm by Example");
+  return result.into();
 }
-
-impl CascadeFilter {
-    fn new() -> RefPtr<CascadeFilter> {
-        CascadeFilter::allocate(InitCascadeFilter {
-            filter: RefCell::new(None),
-        })
-    }
-    xpcom_method!(set_filter_data => SetFilterData(data: *const ThinVec<u8>));
-
-    fn set_filter_data(&self, data: &ThinVec<u8>) -> Result<(), nsresult> {
-        let filter = rentals::CascadeWithOwnedData::try_new_or_drop(
-            Vec::from(data.as_slice()).into_boxed_slice(),
-            |data| {
-                Cascade::from_bytes(data)
-                    .unwrap_or(None)
-                    .ok_or(NS_ERROR_INVALID_ARG)
-            },
-        )?;
-        self.filter.borrow_mut().replace(filter);
-        Ok(())
-    }
-
-    xpcom_method!(has => Has(key: *const nsACString) -> bool);
-
-    fn has(&self, key: &nsACString) -> Result<bool, nsresult> {
-        match self.filter.borrow().as_ref() {
-            None => Err(NS_ERROR_NOT_INITIALIZED),
-            Some(filter) => Ok(filter.rent(|cascade| cascade.has(&*key))),
-        }
-    }
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn cascade_filter_construct(result: &mut *const nsICascadeFilter) {
-    let inst: RefPtr<CascadeFilter> = CascadeFilter::new();
-    *result = inst.coerce::<nsICascadeFilter>();
-    std::mem::forget(inst);
-}
diff --git a/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js b/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js
--- a/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js
+++ b/toolkit/components/cascade_bloom_filter/test/xpcshell/test_cascade_bindings.js
@@ -1,10 +1,12 @@
 "use strict";
 
+
+
 const CASCADE_CID = "@mozilla.org/cascade-filter;1";
 const CASCADE_IID = Ci.nsICascadeFilter;
 const CascadeFilter = Components.Constructor(CASCADE_CID, CASCADE_IID);
 
 add_task(function CascadeFilter_uninitialized() {
   let filter = new CascadeFilter();
   Assert.throws(
     () => filter.has(""),
