# HG changeset patch
# User Steve Melia <steve.j.melia@gmail.com>
# Date 1460927456 -3600
#      Sun Apr 17 22:10:56 2016 +0100
# Node ID 01f2fb6a08f883331c851e50f6c2231c58d05ca1
# Parent  5ffdd1bafd496a5e9ca0d32f9729333d1b467eb4
Bug 1259812: Replace XUL elements with XHTML in inspector breadcrumbs;r=bgrins

diff --git a/devtools/client/inspector/breadcrumbs.js b/devtools/client/inspector/breadcrumbs.js
--- a/devtools/client/inspector/breadcrumbs.js
+++ b/devtools/client/inspector/breadcrumbs.js
@@ -7,37 +7,235 @@
 "use strict";
 
 const {Cu, Ci} = require("chrome");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 const Services = require("Services");
 const promise = require("promise");
 const FocusManager = Services.focus;
 
-const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 const MAX_LABEL_LENGTH = 40;
 const LOW_PRIORITY_ELEMENTS = {
   "HEAD": true,
   "BASE": true,
   "BASEFONT": true,
   "ISINDEX": true,
   "LINK": true,
   "META": true,
   "SCRIPT": true,
   "STYLE": true,
   "TITLE": true
 };
 
+const NS_XHTML = "http://www.w3.org/1999/xhtml";
+const SCROLL_REPEAT_MS = 100;
+
+/**
+ * Component to replicate functionality of XUL arrowscrollbox
+ * for breadcrumbs
+ */
+function ArrowScrollBox(chromeWin, chromeDoc, container) {
+  this.chromeWin = chromeWin;
+  this.chromeDoc = chromeDoc;
+  this.container = container;
+  this._init();
+}
+
+ArrowScrollBox.prototype = {
+
+  /**
+   * Build the HTML, add to the DOM and start listening to
+   * events
+   */
+  _init: function() {
+    this.constructHtml();
+
+    this.onunderflow();
+
+    this.inner.addEventListener("scroll", this.onscroll.bind(this), false);
+    this.inner.addEventListener("underflow", this.onunderflow.bind(this), false);
+    this.inner.addEventListener("overflow", this.onoverflow.bind(this), false);
+    this.leftBtn.addEventListener("mousedown", this.leftBtnClick.bind(this), false);
+    this.rightBtn.addEventListener("mousedown", this.rightBtnClick.bind(this), false);
+  },
+
+  /**
+   * Call the given function once; then continuously
+   * while the mouse button is held
+   */
+  clickOrHold: function(repeatFn) {
+    repeatFn = repeatFn.bind(this);
+
+    let timer;
+    let container = this.container;
+
+    function handleClick() {
+      cancelHold();
+      repeatFn();
+    }
+
+    let window = this.chromeWin;
+    function cancelHold() {
+      window.clearTimeout(timer)
+      container.removeEventListener("mouseout", cancelHold, false);
+      container.removeEventListener("mouseup", handleClick, false);
+    };
+
+    function repeated() {
+      repeatFn();
+      timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
+    };
+
+    container.addEventListener("mouseout", cancelHold, false);
+    container.addEventListener("mouseup", handleClick, false);
+    timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
+  },
+
+  /**
+   * When left arrow button is clicked scroll left
+   */
+  leftBtnClick: function() {
+    let scrollLeft = function() {
+      let element = this.getFirstInvisibleElement();
+      if (element === null) {
+        return;
+      }
+
+      element.scrollIntoView({ block: "start", behavior: "smooth" });
+    };
+
+    this.clickOrHold(scrollLeft);
+  },
+
+  /**
+   * When right arrow button is clicked scroll right
+   */
+  rightBtnClick: function() {
+    let scrollRight = function() {
+      let element = this.getLastInvisibleElement();
+      if (element == null) {
+        return;
+      }
+
+      element.scrollIntoView({ block: "end", behavior: "smooth" });
+    };
+
+    this.clickOrHold(scrollRight);
+  },
+
+  /**
+   * Event handler for scrolling, update the
+   * enabled/disabled status of the arrow buttons
+   */
+  onscroll: function() {
+    let first = this.getFirstInvisibleElement();
+    if (first === null) {
+      this.leftBtn.setAttribute("disabled", "true");
+    } else {
+      this.leftBtn.removeAttribute("disabled");
+    }
+ 
+    let last = this.getLastInvisibleElement();
+    if (last === null) {
+      this.rightBtn.setAttribute("disabled", "true");
+    } else {
+      this.rightBtn.removeAttribute("disabled");
+    }
+  },
+
+  /**
+   * On underflow, make the arrow buttons invisible
+   */
+  onunderflow: function() {
+    this.leftBtn.style.visibility = "collapse";
+    this.rightBtn.style.visibility = "collapse";
+  },
+
+  /**
+   * On overflow, show the arrow buttons
+   */
+  onoverflow: function() {
+    this.leftBtn.style.visibility = "visible";
+    this.rightBtn.style.visibility = "visible";
+  },
+
+  /**
+   * Get the first (i.e. furthest left)
+   * non visible element in the scroll box
+   */
+  getFirstInvisibleElement: function() {
+    let left = this.inner.scrollLeft;
+    for (let element of this.inner.childNodes) {
+      if (element.offsetLeft > left) {
+        return element.previousSibling;
+      }
+    }
+
+    return null;
+  },
+
+  /**
+   * Get the last (i.e. furthest right) 
+   * non-visible element in the scroll box
+   */
+  getLastInvisibleElement: function() {
+    let right = this.inner.scrollLeft + this.inner.clientWidth;
+    let elementLeft = 0;
+    for (let element of this.inner.childNodes) {
+      let elementRight = elementLeft + element.offsetWidth;
+      elementLeft = elementRight;
+      if (elementRight > right) {
+        return element;
+      }
+    }
+
+    return null;
+  },
+
+  /**
+   * Build the HTML for the scroll box and insert it into the DOM
+   */
+  constructHtml: function() {
+    this.leftBtn = this.createElement("div", "scrollbutton-up");
+    let leftBtnIcon = this.createElement("div", "toolbarbutton-icon");
+    this.leftBtn.appendChild(leftBtnIcon);
+    this.container.appendChild(this.leftBtn);
+
+    let startIndicator = this.createElement("div", "arrowscrollbox-overflow-start-indicator");
+    this.container.appendChild(startIndicator);
+
+    this.inner = this.createElement("div", "html-arrowscrollbox-inner");
+    this.container.appendChild(this.inner);
+
+    let endIndicator = this.createElement("div", "arrowscrollbox-overflow-end-indicator");
+    this.container.appendChild(endIndicator);
+
+    this.rightBtn = this.createElement("div", "scrollbutton-down");
+    let rightBtnIcon = this.createElement("div", "toolbarbutton-icon");
+    this.rightBtn.appendChild(rightBtnIcon);
+    this.container.appendChild(this.rightBtn);
+  },
+
+  /**
+   * Create an XHTML element with the given class name
+   * @param {tagName} name of the tag to create
+   * @param {className} class of the element
+   */
+  createElement : function(tagName, className) {
+    let div = this.chromeDoc.createElementNS(NS_XHTML, tagName);
+    div.className = className;
+    return div;
+  },
+};
+
 /**
  * Display the ancestors of the current node and its children.
  * Only one "branch" of children are displayed (only one line).
  *
- * FIXME: Bug 822388 - Use the BreadcrumbsWidget in the Inspector.
- *
  * Mechanism:
  * - If no nodes displayed yet:
  *   then display the ancestor of the selected node and the selected node;
  *   else select the node;
  * - If the selected node is the last node displayed, append its first (if any).
  *
  * @param {InspectorPanel} inspector The inspector hosting this widget.
  */
@@ -52,57 +250,43 @@ function HTMLBreadcrumbs(inspector) {
 exports.HTMLBreadcrumbs = HTMLBreadcrumbs;
 
 HTMLBreadcrumbs.prototype = {
   get walker() {
     return this.inspector.walker;
   },
 
   _init: function() {
-    this.container = this.chromeDoc.getElementById("inspector-breadcrumbs");
+    let outer = this.chromeDoc.getElementById("inspector-breadcrumbs");
+    this.arrowScrollBox = new ArrowScrollBox(this.chromeWin, this.chromeDoc, outer);
 
+    this.container = this.arrowScrollBox.inner;
+ 
     // These separators are used for CSS purposes only, and are positioned
     // off screen, but displayed with -moz-element.
-    this.separators = this.chromeDoc.createElement("box");
+    this.separators = this.chromeDoc.createElementNS(NS_XHTML, "div");
     this.separators.className = "breadcrumb-separator-container";
     this.separators.innerHTML =
-                      "<box id='breadcrumb-separator-before'></box>" +
-                      "<box id='breadcrumb-separator-after'></box>" +
-                      "<box id='breadcrumb-separator-normal'></box>";
+                      "<div id='breadcrumb-separator-before'></div>" +
+                      "<div id='breadcrumb-separator-after'></div>" +
+                      "<div id='breadcrumb-separator-normal'></div>";
     this.container.parentNode.appendChild(this.separators);
 
-    this.container.addEventListener("mousedown", this, true);
+    this.container.addEventListener("click", this, true);
     this.container.addEventListener("keypress", this, true);
     this.container.addEventListener("mouseover", this, true);
     this.container.addEventListener("mouseleave", this, true);
     this.container.addEventListener("focus", this, true);
 
     // We will save a list of already displayed nodes in this array.
     this.nodeHierarchy = [];
 
     // Last selected node in nodeHierarchy.
     this.currentIndex = -1;
 
-    // By default, hide the arrows. We let the <scrollbox> show them
-    // in case of overflow.
-    this.container.removeAttribute("overflows");
-    this.container._scrollButtonUp.collapsed = true;
-    this.container._scrollButtonDown.collapsed = true;
-
-    this.onscrollboxreflow = () => {
-      if (this.container._scrollButtonDown.collapsed) {
-        this.container.removeAttribute("overflows");
-      } else {
-        this.container.setAttribute("overflows", true);
-      }
-    };
-
-    this.container.addEventListener("underflow", this.onscrollboxreflow, false);
-    this.container.addEventListener("overflow", this.onscrollboxreflow, false);
-
     this.update = this.update.bind(this);
     this.updateSelectors = this.updateSelectors.bind(this);
     this.selection.on("new-node-front", this.update);
     this.selection.on("pseudoclass", this.updateSelectors);
     this.selection.on("attribute-changed", this.updateSelectors);
     this.inspector.on("markupmutation", this.update);
     this.update();
   },
@@ -168,28 +352,29 @@ HTMLBreadcrumbs.prototype = {
    * Build <label>s that represent the node:
    *   <label class="breadcrumbs-widget-item-tag">tagName</label>
    *   <label class="breadcrumbs-widget-item-id">#id</label>
    *   <label class="breadcrumbs-widget-item-classes">.class1.class2</label>
    * @param {NodeFront} node The node to pretty-print
    * @returns {DocumentFragment}
    */
   prettyPrintNodeAsXUL: function(node) {
-    let fragment = this.chromeDoc.createDocumentFragment();
-
-    let tagLabel = this.chromeDoc.createElement("label");
+    let tagLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     tagLabel.className = "breadcrumbs-widget-item-tag plain";
 
-    let idLabel = this.chromeDoc.createElement("label");
+    // @todo these will end up with moz-devtools-highlighted
+    // when focussed.
+    // which does not happen with a XUL element
+    let idLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     idLabel.className = "breadcrumbs-widget-item-id plain";
 
-    let classesLabel = this.chromeDoc.createElement("label");
+    let classesLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     classesLabel.className = "breadcrumbs-widget-item-classes plain";
 
-    let pseudosLabel = this.chromeDoc.createElement("label");
+    let pseudosLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";
 
     let tagText = node.tagName.toLowerCase();
     if (node.isPseudoElement) {
       tagText = node.isBeforePseudoElement ? "::before" : "::after";
     }
     let idText = node.id ? ("#" + node.id) : "";
     let classesText = "";
@@ -218,80 +403,32 @@ HTMLBreadcrumbs.prototype = {
       classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
     }
 
     tagLabel.textContent = tagText;
     idLabel.textContent = idText;
     classesLabel.textContent = classesText;
     pseudosLabel.textContent = node.pseudoClassLocks.join("");
 
+    let fragment = this.chromeDoc.createDocumentFragment();
     fragment.appendChild(tagLabel);
     fragment.appendChild(idLabel);
     fragment.appendChild(classesLabel);
     fragment.appendChild(pseudosLabel);
 
     return fragment;
   },
 
   /**
-   * Open the sibling menu.
-   * @param {DOMNode} button the button representing the node.
-   * @param {NodeFront} node the node we want the siblings from.
-   */
-  openSiblingMenu: function(button, node) {
-    // We make sure that the targeted node is selected
-    // because we want to use the nodemenu that only works
-    // for inspector.selection
-    this.navigateTo(node);
-
-    // Build a list of extra menu items that will be appended at the end of the
-    // inspector node context menu.
-    let items = [this.chromeDoc.createElement("menuseparator")];
-
-    this.walker.siblings(node, {
-      whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-    }).then(siblings => {
-      let nodes = siblings.nodes;
-      for (let i = 0; i < nodes.length; i++) {
-        // Skip siblings of the documentElement node.
-        if (nodes[i].nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
-          continue;
-        }
-
-        let item = this.chromeDoc.createElement("menuitem");
-        if (nodes[i] === node) {
-          item.setAttribute("disabled", "true");
-          item.setAttribute("checked", "true");
-        }
-
-        item.setAttribute("type", "radio");
-        item.setAttribute("label", this.prettyPrintNodeAsText(nodes[i]));
-
-        let self = this;
-        item.onmouseup = (function(node) {
-          return function() {
-            self.navigateTo(node);
-          };
-        })(nodes[i]);
-
-        items.push(item);
-      }
-
-      // Append the items to the inspector node context menu and show the menu.
-      this.inspector.showNodeMenu(button, "before_start", items);
-    });
-  },
-
-  /**
    * Generic event handler.
    * @param {DOMEvent} event.
    */
   handleEvent: function(event) {
-    if (event.type == "mousedown" && event.button == 0) {
-      this.handleMouseDown(event);
+    if (event.type == "click" && event.button == 0) {
+      this.handleClick(event);
     } else if (event.type == "keypress" && this.selection.isElementNode()) {
       this.handleKeyPress(event);
     } else if (event.type == "mouseover") {
       this.handleMouseOver(event);
     } else if (event.type == "mouseleave") {
       this.handleMouseLeave(event);
     } else if (event.type == "focus") {
       this.handleFocus(event);
@@ -310,49 +447,24 @@ HTMLBreadcrumbs.prototype = {
       // If we already have a selected breadcrumb and focus target is not it,
       // move focus to selected breadcrumb.
       event.preventDefault();
       control.focus();
     }
   },
 
   /**
-   * On click and hold, open the siblings menu.
+   * On click navigate to the correct node.
    * @param {DOMEvent} event.
    */
-  handleMouseDown: function(event) {
-    let timer;
-    let container = this.container;
-
-    function openMenu(event) {
-      cancelHold();
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsHold();
-      }
+  handleClick: function(event) {
+    let target = event.originalTarget;
+    if (target.tagName == "button") {
+      target.onBreadcrumbsClick();
     }
-
-    function handleClick(event) {
-      cancelHold();
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsClick();
-      }
-    }
-
-    let window = this.chromeWin;
-    function cancelHold(event) {
-      window.clearTimeout(timer);
-      container.removeEventListener("mouseout", cancelHold, false);
-      container.removeEventListener("mouseup", handleClick, false);
-    }
-
-    container.addEventListener("mouseout", cancelHold, false);
-    container.addEventListener("mouseup", handleClick, false);
-    timer = window.setTimeout(openMenu, 500, event);
   },
 
   /**
    * On mouse over, highlight the corresponding content DOM Node.
    * @param {DOMEvent} event.
    */
   handleMouseOver: function(event) {
     let target = event.originalTarget;
@@ -433,28 +545,25 @@ HTMLBreadcrumbs.prototype = {
    * Remove nodes and clean up.
    */
   destroy: function() {
     this.selection.off("new-node-front", this.update);
     this.selection.off("pseudoclass", this.updateSelectors);
     this.selection.off("attribute-changed", this.updateSelectors);
     this.inspector.off("markupmutation", this.update);
 
-    this.container.removeEventListener("underflow", this.onscrollboxreflow, false);
-    this.container.removeEventListener("overflow", this.onscrollboxreflow, false);
-    this.container.removeEventListener("mousedown", this, true);
+    this.container.removeEventListener("click", this, true);
     this.container.removeEventListener("keypress", this, true);
     this.container.removeEventListener("mouseover", this, true);
     this.container.removeEventListener("mouseleave", this, true);
     this.container.removeEventListener("focus", this, true);
 
     this.empty();
     this.separators.remove();
 
-    this.onscrollboxreflow = null;
     this.container = null;
     this.separators = null;
     this.nodeHierarchy = null;
 
     this.isDestroyed = true;
   },
 
   /**
@@ -519,17 +628,17 @@ HTMLBreadcrumbs.prototype = {
   },
 
   /**
    * Build a button representing the node.
    * @param {NodeFront} node The node from the page.
    * @return {DOMNode} The <button> for this node.
    */
   buildButton: function(node) {
-    let button = this.chromeDoc.createElement("button");
+    let button = this.chromeDoc.createElementNS(NS_XHTML, "button");
     button.appendChild(this.prettyPrintNodeAsXUL(node));
     button.className = "breadcrumbs-widget-item";
 
     button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(node));
 
     button.onkeypress = function onBreadcrumbsKeypress(e) {
       if (e.charCode == Ci.nsIDOMKeyEvent.DOM_VK_SPACE ||
           e.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
@@ -540,26 +649,16 @@ HTMLBreadcrumbs.prototype = {
     button.onBreadcrumbsClick = () => {
       this.navigateTo(node);
     };
 
     button.onBreadcrumbsHover = () => {
       this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
     };
 
-    button.onclick = (function _onBreadcrumbsRightClick(event) {
-      button.focus();
-      if (event.button == 2) {
-        this.openSiblingMenu(button, node);
-      }
-    }).bind(this);
-
-    button.onBreadcrumbsHold = (function _onBreadcrumbsHold() {
-      this.openSiblingMenu(button, node);
-    }).bind(this);
     return button;
   },
 
   /**
    * Connecting the end of the breadcrumbs to a node.
    * @param {NodeFront} node The node to reach.
    */
   expand: function(node) {
@@ -663,26 +762,18 @@ HTMLBreadcrumbs.prototype = {
     return resolveNextTick(true);
   },
 
   /**
    * Ensure the selected node is visible.
    */
   scroll: function() {
     // FIXME bug 684352: make sure its immediate neighbors are visible too.
-
-    let scrollbox = this.container;
     let element = this.nodeHierarchy[this.currentIndex].button;
-
-    // Repeated calls to ensureElementIsVisible would interfere with each other
-    // and may sometimes result in incorrect scroll positions.
-    this.chromeWin.clearTimeout(this._ensureVisibleTimeout);
-    this._ensureVisibleTimeout = this.chromeWin.setTimeout(function() {
-      scrollbox.ensureElementIsVisible(element);
-    }, ENSURE_SELECTION_VISIBLE_DELAY);
+    element.scrollIntoView({ block: "end", behavior: "smooth" });
   },
 
   /**
    * Update all button outputs.
    */
   updateSelectors: function() {
     if (this.isDestroyed) {
       return;
diff --git a/devtools/client/inspector/inspector.xul b/devtools/client/inspector/inspector.xul
--- a/devtools/client/inspector/inspector.xul
+++ b/devtools/client/inspector/inspector.xul
@@ -173,24 +173,19 @@
           class="devtools-searchinput"
           placeholder="&inspectorSearchHTML.label3;"/>
         <toolbarbutton id="inspector-pane-toggle"
           class="devtools-toolbarbutton"
           tabindex="0" />
       </toolbar>
       <vbox flex="1" id="markup-box">
       </vbox>
-      <toolbar id="inspector-breadcrumbs-toolbar"
-        class="devtools-toolbar"
-        nowindowdrag="true">
-        <arrowscrollbox id="inspector-breadcrumbs"
-          class="breadcrumbs-widget-container"
-          flex="1" orient="horizontal"
-          clicktoscroll="true"/>
-      </toolbar>
+      <html:div id="inspector-breadcrumbs-toolbar" class="devtools-toolbar">
+        <html:div id="inspector-breadcrumbs" class="breadcrumbs-widget-container"/>
+      </html:div>
     </vbox>
     <splitter class="devtools-side-splitter"/>
     <tabbox id="inspector-sidebar" handleCtrlTab="false" class="devtools-sidebar-tabs" hidden="true">
       <tabs>
         <tab id="sidebar-tab-ruleview"
              label="&ruleViewTitle;"
              crop="end"/>
         <tab id="sidebar-tab-computedview"
diff --git a/devtools/client/themes/inspector.css b/devtools/client/themes/inspector.css
--- a/devtools/client/themes/inspector.css
+++ b/devtools/client/themes/inspector.css
@@ -6,16 +6,57 @@
 #inspector-searchlabel {
   overflow: hidden;
 }
 
 #inspector-breadcrumbs-toolbar {
   padding: 0px;
   border-bottom-width: 0px;
   border-top-width: 1px;
+  display: block;
+  position: relative;
+}
+
+#inspector-breadcrumbs-toolbar,
+#inspector-breadcrumbs-toolbar * {
+  /* From minimal-xul.css */
+  -moz-user-focus: ignore;
+  -moz-user-select: none;
+  box-sizing: border-box;
+}
+
+#inspector-breadcrumbs {
+  display: flex;
+
+  /* Break out of the XUL flexbox, so the splitter can still shrink the
+     markup view even if the contents of the breadcrumbs are wider than
+     the new width. */
+  position: absolute;
+  top: 0;
+  left: 0;
+  bottom: 0;
+  right: 0;
+}
+
+
+#inspector-breadcrumbs .scrollbutton-up,
+#inspector-breadcrumbs .scrollbutton-down {
+  flex: 0;
+  display: flex;
+  align-items: center;
+}
+
+#inspector-breadcrumbs .html-arrowscrollbox-inner {
+  flex: 1;
+  display: flex;
+  overflow: hidden;
+}
+
+#inspector-breadcrumbs .breadcrumbs-widget-item {
+  flex-shrink: 0;
 }
 
 /* Expand/collapse panel toolbar button */
 
 #inspector-pane-toggle {
   list-style-image: var(--theme-pane-collapse-image);
 }
 
