# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b698f91ac29b5e876c643b0de9ba29516b6b7390
Bug 1128747 - debugging info

diff --git a/browser/devtools/shared/SplitView.jsm b/browser/devtools/shared/SplitView.jsm
--- a/browser/devtools/shared/SplitView.jsm
+++ b/browser/devtools/shared/SplitView.jsm
@@ -200,19 +200,19 @@ SplitView.prototype = {
       aEvent.stopPropagation();
       this.activeSummary = aSummary;
     }, false);
 
     this._side.appendChild(aDetails);
 
     if (binding.onCreate) {
       // queue onCreate handler
-      this._root.ownerDocument.defaultView.setTimeout(function () {
+      // this._root.ownerDocument.defaultView.setTimeout(function () {
         binding.onCreate(aSummary, aDetails, binding.data);
-      }, 0);
+      // }, 10);
     }
   },
 
   /**
    * Append an item to the split view according to two template elements
    * (one for the item's summary and the other for the item's details).
    *
    * @param string aName
diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -232,31 +232,32 @@ Editor.prototype = {
    * Appends the current Editor instance to the element specified by
    * 'el'. You can also provide your won iframe to host the editor as
    * an optional second parameter. This method actually creates and
    * loads CodeMirror and all its dependencies.
    *
    * This method is asynchronous and returns a promise.
    */
   appendTo: function (el, env) {
+    console.log("APPEND TO CALLED", el);
     let def = promise.defer();
     let cm  = editors.get(this);
 
     if (!env)
       env = el.ownerDocument.createElementNS(XUL_NS, "iframe");
 
     env.flex = 1;
 
     if (cm)
       throw new Error("You can append an editor only once.");
 
     let onLoad = () => {
       // Once the iframe is loaded, we can inject CodeMirror
       // and its dependencies into its DOM.
-
+console.log(env, env.ownerDocument.defaultView);
       env.removeEventListener("load", onLoad, true);
       let win = env.contentWindow.wrappedJSObject;
 
       if (!this.config.themeSwitching)
         win.document.documentElement.setAttribute("force-theme", "light");
 
       CM_SCRIPTS.forEach((url) =>
         Services.scriptloader.loadSubScript(url, win, "utf8"));
@@ -337,17 +338,21 @@ Editor.prototype = {
       this.reloadPreferences();
       def.resolve();
     };
 
     env.addEventListener("load", onLoad, true);
     env.setAttribute("src", CM_IFRAME);
     el.appendChild(env);
 
-    this.once("destroy", () => el.removeChild(env));
+    this.once("destroy", () => {
+      console.log("DESTROY RECEIVED!");
+      env.addEventListener("load", onLoad, true);
+      el.removeChild(env)
+    });
     return def.promise;
   },
 
   /**
    * Returns a boolean indicating whether the editor is ready to
    * use.  Use appendTo(el).then(() => {}) for most cases
    */
   isAppended: function() {
diff --git a/browser/devtools/styleeditor/StyleEditorUI.jsm b/browser/devtools/styleeditor/StyleEditorUI.jsm
--- a/browser/devtools/styleeditor/StyleEditorUI.jsm
+++ b/browser/devtools/styleeditor/StyleEditorUI.jsm
@@ -228,16 +228,17 @@ StyleEditorUI.prototype = {
 
     this.emit("stylesheets-reset");
   },
 
   /**
    * Remove all editors and add loading indicator.
    */
   _clear: function() {
+    console.log('clear');
     // remember selected sheet and line number for next load
     if (this.selectedEditor && this.selectedEditor.sourceEditor) {
       let href = this.selectedEditor.styleSheet.href;
       let {line, ch} = this.selectedEditor.sourceEditor.getCursor();
 
       this._styleSheetToSelect = {
         stylesheet: href,
         line: line,
@@ -273,26 +274,28 @@ StyleEditorUI.prototype = {
 
     if (!Services.prefs.getBoolPref(PREF_ORIG_SOURCES)) {
       return;
     }
 
     styleSheet.getOriginalSources().then((sources) => {
       if (sources && sources.length) {
       // Wait to make sure the editor is fully loaded before removing it.
-      editor.getSourceEditor().then(() => {
+      console.log("Waiting for a source editor before removing");
+      // editor.getSourceEditor().then(() => {
+      console.log("Got a source Editor, removing");
         this._removeStyleSheetEditor(editor);
         sources.forEach((source) => {
           // set so the first sheet will be selected, even if it's a source
           source.styleSheetIndex = styleSheet.styleSheetIndex;
           source.relatedStyleSheet = styleSheet;
 
           this._addStyleSheetEditor(source);
         });
-      });
+      // });
       }
     }, Cu.reportError);
   },
 
   /**
    * Add a new editor to the UI for a source.
    *
    * @param {StyleSheet}  styleSheet
@@ -522,24 +525,35 @@ StyleEditorUI.prototype = {
             && editor.styleSheet.styleSheetIndex == 0) {
           this._selectEditor(editor);
         }
         this.emit("editor-added", editor);
       }.bind(this),
 
       onShow: function(summary, details, data) {
         let editor = data.editor;
+        // If the editor has already been removed, don't try to load it.
+        if (this.editors.indexOf(editor) === -1) {
+          return;
+        }
         this.selectedEditor = editor;
+        console.log("onShow", editor.friendlyName, editor, this.editors.indexOf(editor));
+
+        let loaded = promise.defer();
+        if (!editor.sourceEditor) {
+          // only initialize source editor when we switch to this view
+          let inputElement = details.querySelector(".stylesheet-editor-input");
+          console.log("Appending to ", inputElement.ownerDocument.defaultView);
+          loaded = editor.load(inputElement);
+        } else {
+          loaded.resolve();
+        }
 
         Task.spawn(function* () {
-          if (!editor.sourceEditor) {
-            // only initialize source editor when we switch to this view
-            let inputElement = details.querySelector(".stylesheet-editor-input");
-            yield editor.load(inputElement);
-          }
+          yield loaded.promise;
 
           editor.onShow();
 
           this.emit("editor-selected", editor);
 
           // Is there any CSS coverage markup to include?
           csscoverage.getUsage(this._target).then(usage => {
             if (usage == null) {
diff --git a/browser/devtools/styleeditor/StyleSheetEditor.jsm b/browser/devtools/styleeditor/StyleSheetEditor.jsm
--- a/browser/devtools/styleeditor/StyleSheetEditor.jsm
+++ b/browser/devtools/styleeditor/StyleSheetEditor.jsm
@@ -10,16 +10,17 @@ this.EXPORTED_SYMBOLS = ["StyleSheetEdit
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 const require = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools.require;
 const Editor  = require("devtools/sourceeditor/editor");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const {CssLogic} = require("devtools/styleinspector/css-logic");
+const {console} = require("resource://gre/modules/devtools/Console.jsm", {});
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/FileUtils.jsm");
 Cu.import("resource://gre/modules/NetUtil.jsm");
 Cu.import("resource://gre/modules/osfile.jsm");
 Cu.import("resource://gre/modules/Task.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
 Cu.import("resource:///modules/devtools/StyleEditorUtil.jsm");
@@ -351,17 +352,17 @@ StyleSheetEditor.prototype = {
    * @param  {DOMElement} inputElement
    *         Element to load source editor in
    *
    * @return {Promise}
    *         Promise that will resolve when the style editor is loaded.
    */
   load: function(inputElement) {
     this._inputElement = inputElement;
-
+console.log("Called load", this._state.text.substring(0, 100));
     let config = {
       value: this._state.text,
       lineNumbers: true,
       mode: Editor.modes.css,
       readOnly: false,
       autoCloseBrackets: "{}()[]",
       extraKeys: this._getKeyBindings(),
       contextMenu: "sourceEditorContextMenu",
@@ -694,16 +695,17 @@ StyleSheetEditor.prototype = {
 
     return bindings;
   },
 
   /**
    * Clean up for this editor.
    */
   destroy: function() {
+    console.log("DESTROYING SOURCE HAS A SOURCE EDITOR", this._sourceEditor);
     if (this._sourceEditor) {
       this._sourceEditor.off("dirty-change", this._onPropertyChange);
       this._sourceEditor.off("save", this.saveToFile);
       this._sourceEditor.off("change", this.updateStyleSheet);
       if (this.highlighter && this.walker && this._sourceEditor.container) {
         this._sourceEditor.container.removeEventListener("mousemove",
           this._onMouseMove);
       }
