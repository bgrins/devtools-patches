# HG changeset patch
# User Daniel Holbert <dholbert@cs.stanford.edu>
# Date 1536793540 25200
#      Wed Sep 12 16:05:40 2018 -0700
# Node ID d19d769f87d80b8c5b05f184b6c7a29d04566af4
# Parent  5ecae696c54f6240e520e9a1517e7a5fc24069ed
Cache flex item final size, and avoid reflowing it if its subtree isn't dirty and its flex-determined size hasn't changed.

diff --git a/layout/generic/nsFlexContainerFrame.cpp b/layout/generic/nsFlexContainerFrame.cpp
--- a/layout/generic/nsFlexContainerFrame.cpp
+++ b/layout/generic/nsFlexContainerFrame.cpp
@@ -1804,16 +1804,18 @@ public:
   nscoord BSize() const { return mBSize; }
 
   nscoord Ascent() const { return mAscent; }
 };
 
 NS_DECLARE_FRAME_PROPERTY_DELETABLE(CachedFlexMeasuringReflow,
                                     CachedMeasuringReflowResult);
 
+NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE(CachedFlexItemSize, nsSize)
+
 const CachedMeasuringReflowResult&
 nsFlexContainerFrame::MeasureAscentAndBSizeForFlexItem(
   FlexItem& aItem,
   nsPresContext* aPresContext,
   ReflowInput& aChildReflowInput)
 {
   if (const auto* cachedResult =
         aItem.Frame()->GetProperty(CachedFlexMeasuringReflow())) {
@@ -1915,17 +1917,17 @@ FlexItem::FlexItem(ReflowInput& aFlexIte
     mMargin(aFlexItemReflowInput.ComputedPhysicalMargin()),
     mMainMinSize(aMainMinSize),
     mMainMaxSize(aMainMaxSize),
     mCrossMinSize(aCrossMinSize),
     mCrossMaxSize(aCrossMaxSize),
     mMainPosn(0),
     mCrossSize(aTentativeCrossSize),
     mCrossPosn(0),
-    mAscent(0),
+    mAscent(ReflowOutput::ASK_FOR_BASELINE),
     mShareOfWeightSoFar(0.0f),
     mWM(aFlexItemReflowInput.GetWritingMode()),
     mIsFrozen(false),
     mHadMinViolation(false),
     mHadMaxViolation(false),
     mHadMeasuringReflow(false),
     mIsStretched(false),
     mIsStrut(false),
@@ -4982,17 +4984,18 @@ nsFlexContainerFrame::DoFlexLayout(nsPre
       framePos += containerContentBoxOrigin;
 
       // (Intentionally snapshotting this before ApplyRelativePositioning, to
       // maybe use for setting the flex container's baseline.)
       const nscoord itemNormalBPos = framePos.B(flexWM);
 
       // Check if we actually need to reflow the item -- if we already reflowed
       // it with the right size, we can just reposition it as-needed.
-      bool itemNeedsReflow = true; // (Start out assuming the worst.)
+      // XXXdholbert maybe make this a 3-state enum
+      Maybe<bool> itemNeedsReflow; // (Start out assuming the worst.)
       if (item->HadMeasuringReflow()) {
         LogicalSize finalFlexItemCBSize =
           aAxisTracker.LogicalSizeFromFlexRelativeSizes(item->GetMainSize(),
                                                         item->GetCrossSize());
         // We've already reflowed the child once. Was the size we gave it in
         // that reflow the same as its final (post-flexing/stretching) size?
         if (finalFlexItemCBSize ==
             LogicalSize(flexWM,
@@ -5001,25 +5004,53 @@ nsFlexContainerFrame::DoFlexLayout(nsPre
           // care that our bsize is now considered "definite" (whereas it
           // wasn't in our previous "measuring" reflow), if they have a
           // relative bsize.
           if (!(item->Frame()->GetStateBits() &
                 NS_FRAME_CONTAINS_RELATIVE_BSIZE)) {
             // Item has the correct size (and its children don't care that
             // it's now "definite"). Let's just make sure it's at the right
             // position.
-            itemNeedsReflow = false;
-            MoveFlexItemToFinalPosition(aReflowInput, *item, framePos,
-                                        containerSize);
+            itemNeedsReflow.emplace(false);
           }
         }
+        if (!itemNeedsReflow) {
+          itemNeedsReflow.emplace(true);
+        }
       }
-      if (itemNeedsReflow) {
+      bool found;
+      // abusing nsSize here; putting main-size in .width, cross-size in .height
+      nsSize sizeToCache = nsSize(item->GetMainSize(),
+                                  item->GetCrossSize());
+      nsSize sizeFromCache =
+        item->Frame()->GetProperty(CachedFlexItemSize(), &found);
+      bool isCachedSizeStale = !found || sizeFromCache != sizeToCache;
+      if (isCachedSizeStale) {
+        item->Frame()->SetProperty(CachedFlexItemSize(), sizeToCache);
+      }
+
+      if (!itemNeedsReflow) { // (if we don't yet know...)
+        // If the child's subtree isn't dirty, and its resolved main size is
+        // the same as the last time we reflowed it, then we don't need to
+        // bother reflowing.
+        if (!NS_SUBTREE_DIRTY(item->Frame()) && !isCachedSizeStale) {
+          NS_WARNING("********dholbert skipping reflow due to "
+                     "cached size being up-to-date");
+          itemNeedsReflow.emplace(false);
+        }
+      }
+      if (!itemNeedsReflow || *itemNeedsReflow) { // If we don't know, or if we
+                                                  // do know it does need a reflow:
         ReflowFlexItem(aPresContext, aAxisTracker, aReflowInput,
                        *item, framePos, containerSize);
+      } else {
+        // We know flex item doesn't need reflow; but let's be sure it's at the
+        // right position.
+        MoveFlexItemToFinalPosition(aReflowInput, *item, framePos,
+                                    containerSize);
       }
 
       // If the item has auto margins, and we were tracking the UsedMargin
       // property, set the property to the computed margin values.
       if (item->HasAnyAutoMargin()) {
         nsMargin* propValue =
           item->Frame()->GetProperty(nsIFrame::UsedMarginProperty());
         if (propValue) {
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -5240,16 +5240,17 @@ nsFrame::MarkIntrinsicISizesDirty()
     CoordNeedsRecalc(metrics->mAscent);
   }
 
   // If we're a flex item, clear our flex-item-specific cached measurements
   // (which likely depended on our now-stale intrinsic isize).
   auto* parentFrame = GetParent();
   if (parentFrame && parentFrame->IsFlexContainerFrame()) {
     DeleteProperty(CachedFlexMeasuringReflow());
+    DeleteProperty(CachedFlexItemSize());
   }
 
   if (GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
     nsFontInflationData::MarkFontInflationDataTextDirty(this);
   }
 }
 
 /* virtual */ nscoord
