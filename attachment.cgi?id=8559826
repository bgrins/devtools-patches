# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  5433e632fb596652a2ab4d481348a13b4a4b1d5c
Bug 1121528 - Avoid the inspector going blank when quickly navigating

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -218,57 +218,58 @@ InspectorPanel.prototype = {
 
   /**
    * Return a promise that will resolve to the default node for selection.
    */
   _getDefaultNodeForSelection: function() {
     if (this._defaultNode) {
       return this._defaultNode;
     }
-    let walker = this.walker;
     let rootNode = null;
     let pendingSelection = this._pendingSelection;
 
     // A helper to tell if the target has or is about to navigate.
     // this._pendingSelection changes on "will-navigate" and "new-root" events.
     let hasNavigated = () => pendingSelection !== this._pendingSelection;
 
     // If available, set either the previously selected node or the body
     // as default selected, else set documentElement
-    return walker.getRootNode().then(aRootNode => {
+    return this.walker.getRootNode().then(aRootNode => {
       if (hasNavigated()) {
         return promise.reject("navigated; resolution of _defaultNode aborted");
       }
 
       rootNode = aRootNode;
       if (this.selectionCssSelector) {
-        return walker.querySelector(rootNode, this.selectionCssSelector);
+        return this.walker.querySelector(rootNode, this.selectionCssSelector);
       }
     }).then(front => {
       if (hasNavigated()) {
         return promise.reject("navigated; resolution of _defaultNode aborted");
       }
 
       if (front) {
         return front;
       }
-      return walker.querySelector(rootNode, "body");
+      return this.walker.querySelector(rootNode, "body");
     }).then(front => {
       if (hasNavigated()) {
         return promise.reject("navigated; resolution of _defaultNode aborted");
       }
 
       if (front) {
         return front;
       }
-      return this.walker.documentElement(this.walker.rootNode);
+
+      return this.walker.documentElement();
     }).then(node => {
-      if (walker !== this.walker) {
-        promise.reject(null);
+      if (hasNavigated()) {
+        return promise.reject("navigated; resolution of _defaultNode aborted");
       }
+
       this._defaultNode = node;
       return node;
     });
   },
 
   /**
    * Target getter.
    */
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -841,18 +841,19 @@ MarkupView.prototype = {
     }
 
     return this._waitForChildren().then(() => {
       if (this._destroyer) {
         return promise.reject("markupview destroyed");
       }
       return this._ensureVisible(aNode);
     }).then(() => {
-      // Why is this not working?
-      this.layoutHelpers.scrollIntoViewIfNeeded(this.getContainer(aNode).editor.elt, centered);
+      if (!this._destroyer) {
+        this.layoutHelpers.scrollIntoViewIfNeeded(this.getContainer(aNode).editor.elt, centered);
+      }
     }, e => {
       // Only report this rejection as an error if the panel hasn't been
       // destroyed in the meantime.
       if (!this._destroyer) {
         console.error(e);
       } else {
         console.warn("Could not show the node, the markup-view was destroyed " +
           "while waiting for children");
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -320,17 +320,18 @@ var NodeActor = exports.NodeActor = prot
     return CssLogic.getComputedStyle(this.rawNode);
   },
 
   /**
    * Is the node's display computed style value other than "none"
    */
   get isDisplayed() {
     // Consider all non-element nodes as displayed.
-    if (this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE ||
+    if (isNodeDead(this) ||
+        this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE ||
         this.isAfterPseudoElement ||
         this.isBeforePseudoElement) {
       return true;
     }
 
     let style = this.computedStyle;
     if (!style) {
       return true;
@@ -1358,32 +1359,33 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Return the document node that contains the given node,
    * or the root node if no node is specified.
    * @param NodeActor node
    *        The node whose document is needed, or null to
    *        return the root.
    */
   document: method(function(node) {
-    let doc = node ? nodeDocument(node.rawNode) : this.rootDoc;
+    let doc = isNodeDead(node) ? this.rootDoc : nodeDocument(node.rawNode);
     return this._ref(doc);
   }, {
     request: { node: Arg(0, "nullable:domnode") },
     response: { node: RetVal("domnode") },
   }),
 
   /**
    * Return the documentElement for the document containing the
    * given node.
    * @param NodeActor node
    *        The node whose documentElement is requested, or null
    *        to use the root document.
    */
   documentElement: method(function(node) {
-    let elt = node ? nodeDocument(node.rawNode).documentElement : this.rootDoc.documentElement;
+    let elt = isNodeDead(node) ? this.rootDoc.documentElement :
+                                 nodeDocument(node.rawNode).documentElement;
     return this._ref(elt);
   }, {
     request: { node: Arg(0, "nullable:domnode") },
     response: { node: RetVal("domnode") },
   }),
 
   /**
    * Return all parents of the given node, ordered from immediate parent
@@ -1391,16 +1393,20 @@ var WalkerActor = protocol.ActorClass({
    * @param NodeActor node
    *    The node whose parents are requested.
    * @param object options
    *    Named options, including:
    *    `sameDocument`: If true, parents will be restricted to the same
    *      document as the node.
    */
   parents: method(function(node, options={}) {
+    if (isNodeDead(node)) {
+      return [];
+    }
+
     let walker = this.getDocumentWalker(node.rawNode);
     let parents = [];
     let cur;
     while((cur = walker.parentNode())) {
       if (options.sameDocument && cur.ownerDocument != node.rawNode.ownerDocument) {
         break;
       }
       parents.push(this._ref(cur));
@@ -1463,16 +1469,20 @@ var WalkerActor = protocol.ActorClass({
     request: { node: Arg(0, "domnode") },
     response: {},
   }),
 
   /**
    * Release actors for a node and all child nodes.
    */
   releaseNode: method(function(node, options={}) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     if (node.retained && !options.force) {
       this._retainedOrphans.add(node);
       return;
     }
 
     if (node.retained) {
       // Forcing a retained node to go away.
       this._retainedOrphans.delete(node);
@@ -1540,16 +1550,20 @@ var WalkerActor = protocol.ActorClass({
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    *
    * @returns an object with three items:
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   children: method(function(node, options={}) {
+    if (isNodeDead(node)) {
+      return { hasFirst: true, hasLast: true, nodes: [] };
+    }
+
     if (options.center && options.start) {
       throw Error("Can't specify both 'center' and 'start' options.");
     }
     let maxNodes = options.maxNodes || -1;
     if (maxNodes == -1) {
       maxNodes = Number.MAX_VALUE;
     }
 
@@ -1634,16 +1648,20 @@ var WalkerActor = protocol.ActorClass({
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    *
    * @returns an object with three items:
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   siblings: method(function(node, options={}) {
+    if (isNodeDead(node)) {
+      return { hasFirst: true, hasLast: true, nodes: [] };
+    }
+
     let parentNode = this.getDocumentWalker(node.rawNode, options.whatToShow).parentNode();
     if (!parentNode) {
       return {
         hasFirst: true,
         hasLast: true,
         nodes: [node]
       };
     }
@@ -1660,31 +1678,39 @@ var WalkerActor = protocol.ActorClass({
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   nextSibling: method(function(node, options={}) {
+    if (isNodeDead(node)) {
+      return null;
+    }
+
     let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.nextSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
   /**
    * Get the previous sibling of a given node.  Getting nodes one at a time
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   previousSibling: method(function(node, options={}) {
+    if (isNodeDead(node)) {
+      return null;
+    }
+
     let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.previousSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
   /**
    * Helper function for the `children` method: Read forward in the sibling
    * list into an array with `count` items, including the current node.
@@ -1736,21 +1762,21 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Return the first node in the document that matches the given selector.
    * See https://developer.mozilla.org/en-US/docs/Web/API/Element.querySelector
    *
    * @param NodeActor baseNode
    * @param string selector
    */
   querySelector: method(function(baseNode, selector) {
-    if (!baseNode) {
-      return {}
-    };
+    if (isNodeDead(baseNode)) {
+      return {};
+    }
+
     let node = baseNode.rawNode.querySelector(selector);
-
     if (!node) {
       return {}
     };
 
     return this.attachElement(node);
   }, {
     request: {
       node: Arg(0, "domnode"),
@@ -1926,16 +1952,20 @@ var WalkerActor = protocol.ActorClass({
    *    Options object:
    *    `parents`: True if the pseudo-class should be added
    *      to parent nodes.
    *
    * @returns An empty packet.  A "pseudoClassLock" mutation will
    *    be queued for any changed nodes.
    */
   addPseudoClassLock: method(function(node, pseudo, options={}) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     this._addPseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
 
     let walker = this.getDocumentWalker(node.rawNode);
     let cur;
@@ -1980,23 +2010,31 @@ var WalkerActor = protocol.ActorClass({
       let { attach } = require("sdk/content/mod");
       let style = Style({source: HELPER_SHEET, type: "agent" });
       attach(style, win);
       this.installedHelpers.set(win, style);
     }
   },
 
   hideNode: method(function(node) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     this._installHelperSheet(node);
     node.rawNode.classList.add(HIDDEN_CLASS);
   }, {
     request: { node: Arg(0, "domnode") }
   }),
 
   unhideNode: method(function(node) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     node.rawNode.classList.remove(HIDDEN_CLASS);
   }, {
     request: { node: Arg(0, "domnode") }
   }),
 
   /**
    * Remove a pseudo-class lock from a node.
    *
@@ -2007,16 +2045,20 @@ var WalkerActor = protocol.ActorClass({
    *    Options object:
    *    `parents`: True if the pseudo-class should be removed
    *      from parent nodes.
    *
    * @returns An empty response.  "pseudoClassLock" mutations
    *    will be emitted for any changed nodes.
    */
   removePseudoClassLock: method(function(node, pseudo, options={}) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     this._removePseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
 
     let walker = this.getDocumentWalker(node.rawNode);
     let cur;
@@ -2046,16 +2088,20 @@ var WalkerActor = protocol.ActorClass({
     return true;
   },
 
   /**
    * Clear all the pseudo-classes on a given node or all nodes.
    * @param {NodeActor} node Optional node to clear pseudo-classes on
    */
   clearPseudoClassLocks: method(function(node) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     if (node) {
       DOMUtils.clearPseudoClassLocks(node.rawNode);
       this._activePseudoClassLocks.delete(node);
       this._queuePseudoClassMutation(node);
     } else {
       for (let locked of this._activePseudoClassLocks) {
         DOMUtils.clearPseudoClassLocks(locked.rawNode);
         this._activePseudoClassLocks.delete(locked);
@@ -2068,16 +2114,20 @@ var WalkerActor = protocol.ActorClass({
     },
     response: {}
   }),
 
   /**
    * Get a node's innerHTML property.
    */
   innerHTML: method(function(node) {
+    if (isNodeDead(node)) {
+      return "";
+    }
+
     return LongStringActor(this.conn, node.rawNode.innerHTML);
   }, {
     request: {
       node: Arg(0, "domnode")
     },
     response: {
       value: RetVal("longstring")
     }
@@ -2085,16 +2135,20 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Set a node's innerHTML property.
    *
    * @param {NodeActor} node The node.
    * @param {string} value The piece of HTML content.
    */
   setInnerHTML: method(function(node, value) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     let rawNode = node.rawNode;
     if (rawNode.nodeType !== rawNode.ownerDocument.ELEMENT_NODE)
       throw new Error("Can only change innerHTML to element nodes");
     rawNode.innerHTML = value;
   }, {
     request: {
       node: Arg(0, "domnode"),
       value: Arg(1, "string"),
@@ -2103,16 +2157,20 @@ var WalkerActor = protocol.ActorClass({
   }),
 
   /**
    * Get a node's outerHTML property.
    *
    * @param {NodeActor} node The node.
    */
   outerHTML: method(function(node) {
+    if (isNodeDead(node)) {
+      return "";
+    }
+
     return LongStringActor(this.conn, node.rawNode.outerHTML);
   }, {
     request: {
       node: Arg(0, "domnode")
     },
     response: {
       value: RetVal("longstring")
     }
@@ -2120,16 +2178,20 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Set a node's outerHTML property.
    *
    * @param {NodeActor} node The node.
    * @param {string} value The piece of HTML content.
    */
   setOuterHTML: method(function(node, value) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     let parsedDOM = DOMParser.parseFromString(value, "text/html");
     let rawNode = node.rawNode;
     let parentNode = rawNode.parentNode;
 
     // Special case for head and body.  Setting document.body.outerHTML
     // creates an extra <head> tag, and document.head.outerHTML creates
     // an extra <body>.  So instead we will call replaceChild with the
     // parsed DOM, assuming that they aren't trying to set both tags at once.
@@ -2180,16 +2242,20 @@ var WalkerActor = protocol.ActorClass({
    * Insert adjacent HTML to a node.
    *
    * @param {Node} node
    * @param {string} position One of "beforeBegin", "afterBegin", "beforeEnd",
    *                          "afterEnd" (see Element.insertAdjacentHTML).
    * @param {string} value The HTML content.
    */
   insertAdjacentHTML: method(function(node, position, value) {
+    if (isNodeDead(node)) {
+      return {node: [], newParents: []}
+    }
+
     let rawNode = node.rawNode;
     // Don't insert anything adjacent to the document element,
     // the head or the body.
     if (node.isDocumentElement()) {
       throw new Error("Can't insert adjacent element to the root.");
     }
 
     let isInsertAsSibling = position === "beforeBegin" ||
@@ -2259,18 +2325,24 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Removes a node from its parent node.
    *
    * @param {NodeActor} node The node to remove.
    * @returns The node's nextSibling before it was removed.
    */
   removeNode: method(function(node) {
-    if (this.isDocumentOrDocumentElementNode(node))
+    if (isNodeDead(node)) {
+      return null;
+    }
+
+    if (this.isDocumentOrDocumentElementNode(node)) {
       throw Error("Cannot remove document or document elements.");
+    }
+
     let nextSibling = this.nextSibling(node);
     node.rawNode.remove();
     // Mutation events will take care of the rest.
     return nextSibling;
   }, {
     request: {
       node: Arg(0, "domnode")
     },
@@ -2282,18 +2354,19 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Removes an array of nodes from their parent node.
    *
    * @param {NodeActor[]} nodes The nodes to remove.
    */
   removeNodes: method(function(nodes) {
     // Check that all nodes are valid before processing the removals.
     for (let node of nodes) {
-      if (this.isDocumentOrDocumentElementNode(node))
-        throw Error("Cannot remove document or document elements.");
+      if (isNodeDead(node) || this.isDocumentOrDocumentElementNode(node)) {
+        throw Error("Cannot remove document, document elements or dead nodes");
+      }
     }
 
     for (let node of nodes) {
       node.rawNode.remove();
       // Mutation events will take care of the rest.
     }
   }, {
     request: {
@@ -2301,16 +2374,20 @@ var WalkerActor = protocol.ActorClass({
     },
     response: {}
   }),
 
   /**
    * Insert a node into the DOM.
    */
   insertBefore: method(function(node, parent, sibling) {
+    if (isNodeDead(node) || isNodeDead(parent) || isNodeDead(sibling)) {
+      return null;
+    }
+
     parent.rawNode.insertBefore(node.rawNode, sibling ? sibling.rawNode : null);
   }, {
     request: {
       node: Arg(0, "domnode"),
       parent: Arg(1, "domnode"),
       sibling: Arg(2, "nullable:domnode")
     },
     response: {}
@@ -2318,16 +2395,20 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Editing a node's tagname actually means creating a new node with the same
    * attributes, removing the node and inserting the new one instead.
    * This method does not return anything as mutation events are taking care of
    * informing the consumers about changes.
    */
   editTagName: method(function(node, tagName) {
+    if (isNodeDead(node)) {
+      return;
+    }
+
     let oldNode = node.rawNode;
 
     // Create a new element with the same attributes as the current element and
     // prepare to replace the current node with it.
     let newNode;
     try {
       newNode = nodeDocument(oldNode).createElement(tagName);
     } catch(x) {
@@ -2654,17 +2735,20 @@ var WalkerActor = protocol.ActorClass({
     // Otherwise the top of the tree is rootDoc, hence rawNode is in rootDoc
     return true;
   },
 
   /**
    * @see _isInDomTree
    */
   isInDOMTree: method(function(node) {
-    return node ? this._isInDOMTree(node.rawNode) : false;
+    if (isNodeDead(node)) {
+      return false;
+    }
+    return this._isInDOMTree(node.rawNode);
   }, {
     request: { node: Arg(0, "domnode") },
     response: { attached: RetVal("boolean") }
   }),
 
   /**
    * Given an ObjectActor (identified by its ID), commonly used in the debugger,
    * webconsole and variablesView, return the corresponding inspector's NodeActor
@@ -3331,19 +3415,26 @@ var InspectorFront = exports.InspectorFr
     impl: "_getPageStyle"
   })
 });
 
 // Exported for test purposes.
 exports._documentWalker = DocumentWalker;
 
 function nodeDocument(node) {
+  if (Cu.isDeadWrapper(node)) {
+    return null;
+  }
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
+function isNodeDead(node) {
+  return !node || !node.rawNode || Cu.isDeadWrapper(node.rawNode);
+}
+
 /**
  * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
  * See inDeepTreeWalker for more information about the methods.
  *
  * @param {DOMNode} node
  * @param {Window} rootWin
  * @param {Int} whatToShow See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
  * @param {Function} filter A custom filter function Taking in a DOMNode
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -1011,17 +1011,18 @@ var StyleRuleActor = protocol.ActorClass
       case Ci.nsIDOMCSSRule.STYLE_RULE:
         form.selectors = CssLogic.getSelectors(this.rawRule);
         form.cssText = this.rawStyle.cssText || "";
         break;
       case ELEMENT_STYLE:
         // Elements don't have a parent stylesheet, and therefore
         // don't have an associated URI.  Provide a URI for
         // those.
-        form.href = this.rawNode.ownerDocument.location.href;
+        let location = this.rawNode.ownerDocument.location;
+        form.href = location ? location.href : null;
         form.cssText = this.rawStyle.cssText || "";
         break;
       case Ci.nsIDOMCSSRule.CHARSET_RULE:
         form.encoding = this.rawRule.encoding;
         break;
       case Ci.nsIDOMCSSRule.IMPORT_RULE:
         form.href = this.rawRule.href;
         break;
