# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  5433e632fb596652a2ab4d481348a13b4a4b1d5c
Bug 1121528 - Avoid the inspector going blank when quickly navigating

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -256,18 +256,18 @@ InspectorPanel.prototype = {
         return promise.reject("navigated; resolution of _defaultNode aborted");
       }
 
       if (front) {
         return front;
       }
       return this.walker.documentElement(this.walker.rootNode);
     }).then(node => {
-      if (walker !== this.walker) {
-        promise.reject(null);
+      if (!node || walker !== this.walker) {
+        return promise.reject("navigated; resolution of _defaultNode aborted");
       }
       this._defaultNode = node;
       return node;
     });
   },
 
   /**
    * Target getter.
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -269,16 +269,20 @@ var NodeActor = exports.NodeActor = prot
       } else {
         form.shortValue = this.rawNode.nodeValue;
       }
     }
 
     return form;
   },
 
+  isDead: function() {
+    return !this.rawNode || Cu.isDeadWrapper(this.rawNode);
+  },
+
   get isBeforePseudoElement() {
     return this.rawNode.nodeName === "_moz_generated_content_before"
   },
 
   get isAfterPseudoElement() {
     return this.rawNode.nodeName === "_moz_generated_content_after"
   },
 
@@ -1358,49 +1362,61 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Return the document node that contains the given node,
    * or the root node if no node is specified.
    * @param NodeActor node
    *        The node whose document is needed, or null to
    *        return the root.
    */
   document: method(function(node) {
+    if (node && node.isDead()) {
+      return null;
+    }
+
     let doc = node ? nodeDocument(node.rawNode) : this.rootDoc;
     return this._ref(doc);
   }, {
     request: { node: Arg(0, "nullable:domnode") },
-    response: { node: RetVal("domnode") },
+    response: { node: RetVal("nullable:domnode") },
   }),
 
   /**
    * Return the documentElement for the document containing the
    * given node.
    * @param NodeActor node
    *        The node whose documentElement is requested, or null
    *        to use the root document.
    */
   documentElement: method(function(node) {
+    if (node.isDead()) {
+      return null;
+    }
+
     let elt = node ? nodeDocument(node.rawNode).documentElement : this.rootDoc.documentElement;
     return this._ref(elt);
   }, {
     request: { node: Arg(0, "nullable:domnode") },
-    response: { node: RetVal("domnode") },
+    response: { node: RetVal("nullable:domnode") },
   }),
 
   /**
    * Return all parents of the given node, ordered from immediate parent
    * to root.
    * @param NodeActor node
    *    The node whose parents are requested.
    * @param object options
    *    Named options, including:
    *    `sameDocument`: If true, parents will be restricted to the same
    *      document as the node.
    */
   parents: method(function(node, options={}) {
+    if (node.isDead()) {
+      return [];
+    }
+
     let walker = this.getDocumentWalker(node.rawNode);
     let parents = [];
     let cur;
     while((cur = walker.parentNode())) {
       if (options.sameDocument && cur.ownerDocument != node.rawNode.ownerDocument) {
         break;
       }
       parents.push(this._ref(cur));
@@ -1463,16 +1479,20 @@ var WalkerActor = protocol.ActorClass({
     request: { node: Arg(0, "domnode") },
     response: {},
   }),
 
   /**
    * Release actors for a node and all child nodes.
    */
   releaseNode: method(function(node, options={}) {
+    if (node.isDead()) {
+      return;
+    }
+
     if (node.retained && !options.force) {
       this._retainedOrphans.add(node);
       return;
     }
 
     if (node.retained) {
       // Forcing a retained node to go away.
       this._retainedOrphans.delete(node);
@@ -1540,16 +1560,20 @@ var WalkerActor = protocol.ActorClass({
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    *
    * @returns an object with three items:
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   children: method(function(node, options={}) {
+    if (!node || node.isDead()) {
+      return { hasFirst: true, hasLast: true, nodes: [] };
+    }
+
     if (options.center && options.start) {
       throw Error("Can't specify both 'center' and 'start' options.");
     }
     let maxNodes = options.maxNodes || -1;
     if (maxNodes == -1) {
       maxNodes = Number.MAX_VALUE;
     }
 
@@ -1634,16 +1658,20 @@ var WalkerActor = protocol.ActorClass({
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    *
    * @returns an object with three items:
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   siblings: method(function(node, options={}) {
+    if (node.isDead()) {
+      return { hasFirst: true, hasLast: true, nodes: [] };
+    }
+
     let parentNode = this.getDocumentWalker(node.rawNode, options.whatToShow).parentNode();
     if (!parentNode) {
       return {
         hasFirst: true,
         hasLast: true,
         nodes: [node]
       };
     }
@@ -1660,31 +1688,39 @@ var WalkerActor = protocol.ActorClass({
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   nextSibling: method(function(node, options={}) {
+    if (node.isDead()) {
+      return null;
+    }
+
     let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.nextSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
   /**
    * Get the previous sibling of a given node.  Getting nodes one at a time
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   previousSibling: method(function(node, options={}) {
+    if (node.isDead()) {
+      return null;
+    }
+
     let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.previousSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
   /**
    * Helper function for the `children` method: Read forward in the sibling
    * list into an array with `count` items, including the current node.
@@ -1736,21 +1772,21 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Return the first node in the document that matches the given selector.
    * See https://developer.mozilla.org/en-US/docs/Web/API/Element.querySelector
    *
    * @param NodeActor baseNode
    * @param string selector
    */
   querySelector: method(function(baseNode, selector) {
-    if (!baseNode) {
-      return {}
-    };
+    if (!baseNode || baseNode.isDead()) {
+      return {};
+    }
+
     let node = baseNode.rawNode.querySelector(selector);
-
     if (!node) {
       return {}
     };
 
     return this.attachElement(node);
   }, {
     request: {
       node: Arg(0, "domnode"),
@@ -1926,16 +1962,20 @@ var WalkerActor = protocol.ActorClass({
    *    Options object:
    *    `parents`: True if the pseudo-class should be added
    *      to parent nodes.
    *
    * @returns An empty packet.  A "pseudoClassLock" mutation will
    *    be queued for any changed nodes.
    */
   addPseudoClassLock: method(function(node, pseudo, options={}) {
+    if (node.isDead()) {
+      return;
+    }
+
     this._addPseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
 
     let walker = this.getDocumentWalker(node.rawNode);
     let cur;
@@ -1980,23 +2020,31 @@ var WalkerActor = protocol.ActorClass({
       let { attach } = require("sdk/content/mod");
       let style = Style({source: HELPER_SHEET, type: "agent" });
       attach(style, win);
       this.installedHelpers.set(win, style);
     }
   },
 
   hideNode: method(function(node) {
+    if (node.isDead()) {
+      return;
+    }
+
     this._installHelperSheet(node);
     node.rawNode.classList.add(HIDDEN_CLASS);
   }, {
     request: { node: Arg(0, "domnode") }
   }),
 
   unhideNode: method(function(node) {
+    if (node.isDead()) {
+      return;
+    }
+
     node.rawNode.classList.remove(HIDDEN_CLASS);
   }, {
     request: { node: Arg(0, "domnode") }
   }),
 
   /**
    * Remove a pseudo-class lock from a node.
    *
@@ -2007,16 +2055,20 @@ var WalkerActor = protocol.ActorClass({
    *    Options object:
    *    `parents`: True if the pseudo-class should be removed
    *      from parent nodes.
    *
    * @returns An empty response.  "pseudoClassLock" mutations
    *    will be emitted for any changed nodes.
    */
   removePseudoClassLock: method(function(node, pseudo, options={}) {
+    if (node.isDead()) {
+      return;
+    }
+
     this._removePseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
 
     let walker = this.getDocumentWalker(node.rawNode);
     let cur;
@@ -2046,16 +2098,20 @@ var WalkerActor = protocol.ActorClass({
     return true;
   },
 
   /**
    * Clear all the pseudo-classes on a given node or all nodes.
    * @param {NodeActor} node Optional node to clear pseudo-classes on
    */
   clearPseudoClassLocks: method(function(node) {
+    if (node && node.isDead()) {
+      return;
+    }
+
     if (node) {
       DOMUtils.clearPseudoClassLocks(node.rawNode);
       this._activePseudoClassLocks.delete(node);
       this._queuePseudoClassMutation(node);
     } else {
       for (let locked of this._activePseudoClassLocks) {
         DOMUtils.clearPseudoClassLocks(locked.rawNode);
         this._activePseudoClassLocks.delete(locked);
@@ -2068,16 +2124,20 @@ var WalkerActor = protocol.ActorClass({
     },
     response: {}
   }),
 
   /**
    * Get a node's innerHTML property.
    */
   innerHTML: method(function(node) {
+    if (node.isDead()) {
+      return "";
+    }
+
     return LongStringActor(this.conn, node.rawNode.innerHTML);
   }, {
     request: {
       node: Arg(0, "domnode")
     },
     response: {
       value: RetVal("longstring")
     }
@@ -2085,16 +2145,20 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Set a node's innerHTML property.
    *
    * @param {NodeActor} node The node.
    * @param {string} value The piece of HTML content.
    */
   setInnerHTML: method(function(node, value) {
+    if (node.isDead()) {
+      return;
+    }
+
     let rawNode = node.rawNode;
     if (rawNode.nodeType !== rawNode.ownerDocument.ELEMENT_NODE)
       throw new Error("Can only change innerHTML to element nodes");
     rawNode.innerHTML = value;
   }, {
     request: {
       node: Arg(0, "domnode"),
       value: Arg(1, "string"),
@@ -2103,16 +2167,20 @@ var WalkerActor = protocol.ActorClass({
   }),
 
   /**
    * Get a node's outerHTML property.
    *
    * @param {NodeActor} node The node.
    */
   outerHTML: method(function(node) {
+    if (node.isDead()) {
+      return "";
+    }
+
     return LongStringActor(this.conn, node.rawNode.outerHTML);
   }, {
     request: {
       node: Arg(0, "domnode")
     },
     response: {
       value: RetVal("longstring")
     }
@@ -2120,16 +2188,20 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Set a node's outerHTML property.
    *
    * @param {NodeActor} node The node.
    * @param {string} value The piece of HTML content.
    */
   setOuterHTML: method(function(node, value) {
+    if (node.isDead()) {
+      return;
+    }
+
     let parsedDOM = DOMParser.parseFromString(value, "text/html");
     let rawNode = node.rawNode;
     let parentNode = rawNode.parentNode;
 
     // Special case for head and body.  Setting document.body.outerHTML
     // creates an extra <head> tag, and document.head.outerHTML creates
     // an extra <body>.  So instead we will call replaceChild with the
     // parsed DOM, assuming that they aren't trying to set both tags at once.
@@ -2180,16 +2252,20 @@ var WalkerActor = protocol.ActorClass({
    * Insert adjacent HTML to a node.
    *
    * @param {Node} node
    * @param {string} position One of "beforeBegin", "afterBegin", "beforeEnd",
    *                          "afterEnd" (see Element.insertAdjacentHTML).
    * @param {string} value The HTML content.
    */
   insertAdjacentHTML: method(function(node, position, value) {
+    if (node.isDead()) {
+      return {node: [], newParents: []}
+    }
+
     let rawNode = node.rawNode;
     // Don't insert anything adjacent to the document element,
     // the head or the body.
     if (node.isDocumentElement()) {
       throw new Error("Can't insert adjacent element to the root.");
     }
 
     let isInsertAsSibling = position === "beforeBegin" ||
@@ -2259,18 +2335,24 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Removes a node from its parent node.
    *
    * @param {NodeActor} node The node to remove.
    * @returns The node's nextSibling before it was removed.
    */
   removeNode: method(function(node) {
-    if (this.isDocumentOrDocumentElementNode(node))
+    if (node.isDead()) {
+      return null;
+    }
+
+    if (this.isDocumentOrDocumentElementNode(node)) {
       throw Error("Cannot remove document or document elements.");
+    }
+
     let nextSibling = this.nextSibling(node);
     node.rawNode.remove();
     // Mutation events will take care of the rest.
     return nextSibling;
   }, {
     request: {
       node: Arg(0, "domnode")
     },
@@ -2282,18 +2364,19 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Removes an array of nodes from their parent node.
    *
    * @param {NodeActor[]} nodes The nodes to remove.
    */
   removeNodes: method(function(nodes) {
     // Check that all nodes are valid before processing the removals.
     for (let node of nodes) {
-      if (this.isDocumentOrDocumentElementNode(node))
-        throw Error("Cannot remove document or document elements.");
+      if (node.isDead() || this.isDocumentOrDocumentElementNode(node)) {
+        throw Error("Cannot remove document, document elements or dead nodes");
+      }
     }
 
     for (let node of nodes) {
       node.rawNode.remove();
       // Mutation events will take care of the rest.
     }
   }, {
     request: {
@@ -2301,16 +2384,20 @@ var WalkerActor = protocol.ActorClass({
     },
     response: {}
   }),
 
   /**
    * Insert a node into the DOM.
    */
   insertBefore: method(function(node, parent, sibling) {
+    if (node.isDead() || parent.isDead() || (sibling && sibling.isDead())) {
+      return null;
+    }
+
     parent.rawNode.insertBefore(node.rawNode, sibling ? sibling.rawNode : null);
   }, {
     request: {
       node: Arg(0, "domnode"),
       parent: Arg(1, "domnode"),
       sibling: Arg(2, "nullable:domnode")
     },
     response: {}
@@ -2318,16 +2405,20 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Editing a node's tagname actually means creating a new node with the same
    * attributes, removing the node and inserting the new one instead.
    * This method does not return anything as mutation events are taking care of
    * informing the consumers about changes.
    */
   editTagName: method(function(node, tagName) {
+    if (node.isDead()) {
+      return;
+    }
+
     let oldNode = node.rawNode;
 
     // Create a new element with the same attributes as the current element and
     // prepare to replace the current node with it.
     let newNode;
     try {
       newNode = nodeDocument(oldNode).createElement(tagName);
     } catch(x) {
@@ -2654,17 +2745,20 @@ var WalkerActor = protocol.ActorClass({
     // Otherwise the top of the tree is rootDoc, hence rawNode is in rootDoc
     return true;
   },
 
   /**
    * @see _isInDomTree
    */
   isInDOMTree: method(function(node) {
-    return node ? this._isInDOMTree(node.rawNode) : false;
+    if (!node || node.isDead()) {
+      return false;
+    }
+    return this._isInDOMTree(node.rawNode);
   }, {
     request: { node: Arg(0, "domnode") },
     response: { attached: RetVal("boolean") }
   }),
 
   /**
    * Given an ObjectActor (identified by its ID), commonly used in the debugger,
    * webconsole and variablesView, return the corresponding inspector's NodeActor
@@ -3331,16 +3425,19 @@ var InspectorFront = exports.InspectorFr
     impl: "_getPageStyle"
   })
 });
 
 // Exported for test purposes.
 exports._documentWalker = DocumentWalker;
 
 function nodeDocument(node) {
+  if (Cu.isDeadWrapper(node)) {
+    return null;
+  }
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
  * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
  * See inDeepTreeWalker for more information about the methods.
  *
  * @param {DOMNode} node
