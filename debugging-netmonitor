# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f996215427273ee9a9a7c7c36230a4c6b2777e87
Bug 1143224 - Firefox loads slow with liveload and grunt when netmonitor is opened

diff --git a/browser/devtools/netmonitor/netmonitor-controller.js b/browser/devtools/netmonitor/netmonitor-controller.js
--- a/browser/devtools/netmonitor/netmonitor-controller.js
+++ b/browser/devtools/netmonitor/netmonitor-controller.js
@@ -512,16 +512,18 @@ function NetworkEventsHandler() {
   this._onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
   this._onRequestHeaders = this._onRequestHeaders.bind(this);
   this._onRequestCookies = this._onRequestCookies.bind(this);
   this._onRequestPostData = this._onRequestPostData.bind(this);
   this._onResponseHeaders = this._onResponseHeaders.bind(this);
   this._onResponseCookies = this._onResponseCookies.bind(this);
   this._onResponseContent = this._onResponseContent.bind(this);
   this._onEventTimings = this._onEventTimings.bind(this);
+  this._queuedEvents = [];
+  this._sendQueuedEventsThrottled = throttle(this._sendQueuedEvents.bind(this), 1000);
 }
 
 NetworkEventsHandler.prototype = {
   get client() NetMonitorController._target.client,
   get webConsoleClient() NetMonitorController.webConsoleClient,
 
   /**
    * Connect to the current target client.
@@ -534,21 +536,31 @@ NetworkEventsHandler.prototype = {
 
   /**
    * Disconnect from the client.
    */
   disconnect: function() {
     if (!this.client) {
       return;
     }
+    // this._sendQueuedEvents();
     dumpn("NetworkEventsHandler is disconnecting...");
     this.client.removeListener("networkEvent", this._onNetworkEvent);
     this.client.removeListener("networkEventUpdate", this._onNetworkEventUpdate);
   },
 
+  _sendQueuedEvents: function() {
+    for (let { actor, startedDateTime, method, url, isXHR } of this._queuedEvents) {
+      NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
+      window.emit(EVENTS.NETWORK_EVENT, actor);
+    }
+
+    this._queuedEvents = [];
+  },
+
   /**
    * The "networkEvent" message type handler.
    *
    * @param string aType
    *        Message type.
    * @param object aPacket
    *        The message received from the server.
    */
@@ -556,16 +568,18 @@ NetworkEventsHandler.prototype = {
     if (aPacket.from != this.webConsoleClient.actor) {
       // Skip events from different console actors.
       return;
     }
 
     let { actor, startedDateTime, method, url, isXHR } = aPacket.eventActor;
     NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
     window.emit(EVENTS.NETWORK_EVENT, actor);
+    // this._queuedEvents.push(aPacket.eventActor);
+    // this._sendQueuedEventsThrottled();
   },
 
   /**
    * The "networkEventUpdate" message type handler.
    *
    * @param string aType
    *        Message type.
    * @param object aPacket
@@ -853,16 +867,35 @@ function whenDataAvailable(aDataStore, a
 
   return deferred.promise;
 };
 
 const WDA_DEFAULT_VERIFY_INTERVAL = 50; // ms
 const WDA_DEFAULT_GIVE_UP_TIMEOUT = 2000; // ms
 
 /**
+ * Helper method to make sure a function gets called only once
+ * per N milliseconds.
+ * @param function
+ * @param int
+ */
+function throttle (callback, limit = 1) {
+  let wait = false;
+  return () => {
+    if (!wait) {
+      callback.call();
+      wait = true;
+      window.setTimeout(() => {
+        wait = false;
+      }, limit);
+    }
+  }
+}
+
+/**
  * Helper method for debugging.
  * @param string
  */
 function dumpn(str) {
   if (wantLogging) {
     dump("NET-FRONTEND: " + str + "\n");
   }
 }
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,17 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
-
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
@@ -47,16 +47,26 @@ this.SideMenuWidget = function SideMenuW
   this._list.setAttribute("with-item-checkboxes", this._showItemCheckboxes);
   this._list.setAttribute("with-group-checkboxes", this._showGroupCheckboxes);
   this._list.setAttribute("tabindex", "0");
   this._list.addEventListener("contextmenu", e => this._showContextMenu(e), false);
   this._list.addEventListener("keypress", e => this.emit("keyPress", e), false);
   this._list.addEventListener("mousedown", e => this.emit("mousePress", e), false);
   this._parent.appendChild(this._list);
 
+  this._list.addEventListener("scroll", e => {
+    // If this scroll was initiated by a change then don't keep track of pinned state.
+    if (!this._scrollingToBottom) {
+      this._pinnedToBottom = this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight;
+    }
+    this._scrollingToBottom = false;
+  });
+
+  this._pinnedToBottom = true;
+
   // Menu items can optionally be grouped.
   this._groupsByName = new Map(); // Can't use a WeakMap because keys are strings.
   this._orderedGroupElementsArray = [];
   this._orderedMenuElementsArray = [];
   this._itemsByElement = new Map();
 
   // This widget emits events that can be handled in a MenuContainer.
   EventEmitter.decorate(this);
@@ -98,38 +108,46 @@ SideMenuWidget.prototype = {
    *        Some attached primitive/object. Custom options supported:
    *          - group: a string specifying the group to place this item into
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
+    let group = this._getMenuGroupForName(aAttachment.group);
+    let item = this._getMenuItemForGroup(group, aContents, aAttachment);
+    let element = item.insertSelfAt(aIndex);
+
+    if (this._shouldMaintainScrollAtBottom(aIndex)) {
+      this.window.requestAnimationFrame(() => {
+        if (this._shouldMaintainScrollAtBottom(aIndex)) {
+          this._scrollingToBottom = true;
+          this._list.scrollTop = this._list.scrollHeight;
+        }
+      });
+    }
+
+    return element;
+  },
+
+  _shouldMaintainScrollAtBottom: function(aIndex) {
     // Maintaining scroll position at the bottom when a new item is inserted
-    // depends on several factors (the order of testing is important to avoid
-    // needlessly expensive operations that may cause reflows):
+    // depends on several factors:
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
-      (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
+      (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length - 1) &&
       // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+      this._pinnedToBottom;
 
-    let group = this._getMenuGroupForName(aAttachment.group);
-    let item = this._getMenuItemForGroup(group, aContents, aAttachment);
-    let element = item.insertSelfAt(aIndex);
-
-    if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
-    }
-
-    return element;
+    return maintainScrollAtBottom;
   },
 
   /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
