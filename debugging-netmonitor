# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f996215427273ee9a9a7c7c36230a4c6b2777e87
Bug 1143224 - Try to scroll less often in netmonitor

diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,17 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
-
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
@@ -47,16 +47,26 @@ this.SideMenuWidget = function SideMenuW
   this._list.setAttribute("with-item-checkboxes", this._showItemCheckboxes);
   this._list.setAttribute("with-group-checkboxes", this._showGroupCheckboxes);
   this._list.setAttribute("tabindex", "0");
   this._list.addEventListener("contextmenu", e => this._showContextMenu(e), false);
   this._list.addEventListener("keypress", e => this.emit("keyPress", e), false);
   this._list.addEventListener("mousedown", e => this.emit("mousePress", e), false);
   this._parent.appendChild(this._list);
 
+  this._list.addEventListener("scroll", e => {
+    // If this scroll was initiated by a change then don't keep track of pinned state.
+    if (!this._scrollingToBottom) {
+      this._pinnedToBottom = this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight;
+    }
+    this._scrollingToBottom = false;
+  });
+
+  this._pinnedToBottom = true;
+
   // Menu items can optionally be grouped.
   this._groupsByName = new Map(); // Can't use a WeakMap because keys are strings.
   this._orderedGroupElementsArray = [];
   this._orderedMenuElementsArray = [];
   this._itemsByElement = new Map();
 
   // This widget emits events that can be handled in a MenuContainer.
   EventEmitter.decorate(this);
@@ -98,38 +108,46 @@ SideMenuWidget.prototype = {
    *        Some attached primitive/object. Custom options supported:
    *          - group: a string specifying the group to place this item into
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
+    let group = this._getMenuGroupForName(aAttachment.group);
+    let item = this._getMenuItemForGroup(group, aContents, aAttachment);
+    let element = item.insertSelfAt(aIndex);
+
+    if (this._shouldMaintainScrollAtBottom(aIndex)) {
+      this.window.requestAnimationFrame(() => {
+        if (this._shouldMaintainScrollAtBottom(aIndex)) {
+          this._scrollingToBottom = true;
+          this._list.scrollTop = this._list.scrollHeight;
+        }
+      });
+    }
+
+    return element;
+  },
+
+  _shouldMaintainScrollAtBottom: function(aIndex) {
     // Maintaining scroll position at the bottom when a new item is inserted
-    // depends on several factors (the order of testing is important to avoid
-    // needlessly expensive operations that may cause reflows):
+    // depends on several factors:
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
-      (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
+      (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length - 1) &&
       // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+      this._pinnedToBottom;
 
-    let group = this._getMenuGroupForName(aAttachment.group);
-    let item = this._getMenuItemForGroup(group, aContents, aAttachment);
-    let element = item.insertSelfAt(aIndex);
-
-    if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
-    }
-
-    return element;
+    return maintainScrollAtBottom;
   },
 
   /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
