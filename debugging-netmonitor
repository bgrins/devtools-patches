# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c0262092fed258760ba2c55975c0cac6020fa408
dsfafdsa

diff --git a/browser/devtools/netmonitor/netmonitor-controller.js b/browser/devtools/netmonitor/netmonitor-controller.js
--- a/browser/devtools/netmonitor/netmonitor-controller.js
+++ b/browser/devtools/netmonitor/netmonitor-controller.js
@@ -512,16 +512,18 @@ function NetworkEventsHandler() {
   this._onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
   this._onRequestHeaders = this._onRequestHeaders.bind(this);
   this._onRequestCookies = this._onRequestCookies.bind(this);
   this._onRequestPostData = this._onRequestPostData.bind(this);
   this._onResponseHeaders = this._onResponseHeaders.bind(this);
   this._onResponseCookies = this._onResponseCookies.bind(this);
   this._onResponseContent = this._onResponseContent.bind(this);
   this._onEventTimings = this._onEventTimings.bind(this);
+  this._queuedEvents = [];
+  this._sendQueuedEventsThrottled = throttle(this._sendQueuedEvents.bind(this), 1000);
 }
 
 NetworkEventsHandler.prototype = {
   get client() NetMonitorController._target.client,
   get webConsoleClient() NetMonitorController.webConsoleClient,
 
   /**
    * Connect to the current target client.
@@ -534,38 +536,47 @@ NetworkEventsHandler.prototype = {
 
   /**
    * Disconnect from the client.
    */
   disconnect: function() {
     if (!this.client) {
       return;
     }
+    this._sendQueuedEvents();
     dumpn("NetworkEventsHandler is disconnecting...");
     this.client.removeListener("networkEvent", this._onNetworkEvent);
     this.client.removeListener("networkEventUpdate", this._onNetworkEventUpdate);
   },
 
+  _sendQueuedEvents: function() {
+    for (let { actor, startedDateTime, method, url, isXHR } of this._queuedEvents) {
+      NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
+      window.emit(EVENTS.NETWORK_EVENT, actor);
+    }
+
+    this._queuedEvents = [];
+  },
+
   /**
    * The "networkEvent" message type handler.
    *
    * @param string aType
    *        Message type.
    * @param object aPacket
    *        The message received from the server.
    */
   _onNetworkEvent: function(aType, aPacket) {
     if (aPacket.from != this.webConsoleClient.actor) {
       // Skip events from different console actors.
       return;
     }
 
-    let { actor, startedDateTime, method, url, isXHR } = aPacket.eventActor;
-    NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
-    window.emit(EVENTS.NETWORK_EVENT, actor);
+    this._queuedEvents.push(aPacket.eventActor);
+    this._sendQueuedEventsThrottled();
   },
 
   /**
    * The "networkEventUpdate" message type handler.
    *
    * @param string aType
    *        Message type.
    * @param object aPacket
@@ -853,16 +864,35 @@ function whenDataAvailable(aDataStore, a
 
   return deferred.promise;
 };
 
 const WDA_DEFAULT_VERIFY_INTERVAL = 50; // ms
 const WDA_DEFAULT_GIVE_UP_TIMEOUT = 2000; // ms
 
 /**
+ * Helper method to make sure a function gets called only once
+ * per N milliseconds.
+ * @param function
+ * @param int
+ */
+function throttle (callback, limit = 1) {
+  let wait = false;
+  return () => {
+    if (!wait) {
+      callback.call();
+      wait = true;
+      window.setTimeout(() => {
+        wait = false;
+      }, limit);
+    }
+  }
+}
+
+/**
  * Helper method for debugging.
  * @param string
  */
 function dumpn(str) {
   if (wantLogging) {
     dump("NET-FRONTEND: " + str + "\n");
   }
 }
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,17 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
-
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
@@ -95,16 +95,17 @@ SideMenuWidget.prototype = {
    *        Some attached primitive/object. Custom options supported:
    *          - group: a string specifying the group to place this item into
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
+    // console.trace();
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
     // needlessly expensive operations that may cause reflows):
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
@@ -468,17 +469,16 @@ SideMenuGroup.prototype = {
    * Inserts this group in the parent container at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this group.
    */
   insertSelfAt: function(aIndex) {
     let ownerList = this.ownerView._list;
     let groupsArray = this._orderedGroupElementsArray;
-
     if (aIndex >= 0) {
       ownerList.insertBefore(this._target, groupsArray[aIndex]);
       groupsArray.splice(aIndex, 0, this._target);
     } else {
       ownerList.appendChild(this._target);
       groupsArray.push(this._target);
     }
   },
@@ -577,26 +577,24 @@ SideMenuItem.prototype = {
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertSelfAt: function(aIndex) {
     let ownerList = this.ownerView._list;
     let menuArray = this._orderedMenuElementsArray;
-
     if (aIndex >= 0) {
       ownerList.insertBefore(this._container, ownerList.childNodes[aIndex]);
       menuArray.splice(aIndex, 0, this._target);
     } else {
       ownerList.appendChild(this._container);
       menuArray.push(this._target);
     }
     this._itemsByElement.set(this._target, this);
-
     return this._target;
   },
 
   /**
    * Check or uncheck the checkbox associated with this item.
    *
    * @param boolean aCheckState
    *        True to check, false to uncheck.
