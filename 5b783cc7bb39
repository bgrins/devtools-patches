
# HG changeset patch
# User Nicolas Chevobbe <nchevobbe@mozilla.com>
# Date 1500555406 -7200
# Node ID 5b783cc7bb39561a0d5b5d68bc70b8a6e723f4c0
# Parent  056aa9b5ece3b2758406f5855e3e547cdb72a973
Bug 1382690 - Adapt extensions inspect() calls to the new frontend. r=bgrins

The inspect command in extension was directly calling jsterm.inspectObject and doing so bypassed
the code we implemented for the command on the new frontend (i.e. no more variable view).
This patch modifies the jsterm inspectObject function so it can do the expected behavior,
and also reverts some changes made in the original inspect command bug, so we only deal with
the new frontend code in jsterm.inspectObject.
This implied changing an extension test that was waiting for the variable view to boot-up.
The test was modified to match the tests we already have for the inspect command on the new
console frontend.

MozReview-Commit-ID: 8fZV20Mck8r

diff --git a/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js b/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
--- a/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
+++ b/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
@@ -118,25 +118,29 @@ add_task(async function test_devtools_in
   info("Toolbox has been switched to the inspector as expected");
 
   info("Test inspectedWindow.eval inspect() binding called for a JS object");
 
   const splitPanelOpenedPromise = (async () => {
     await toolbox.once("split-console");
     let jsterm = toolbox.getPanel("webconsole").hud.jsterm;
 
-    const options = await new Promise(resolve => {
-      jsterm.once("variablesview-open", (evt, view, options) => resolve(options));
+    // Wait for the message to appear on the console.
+    const messageNode = await new Promise(resolve => {
+      jsterm.hud.on("new-messages", function onThisMessage(e, messages) {
+        for (let m of messages) {
+          resolve(m.node);
+          jsterm.hud.off("new-messages", onThisMessage);
+          return;
+        }
+      });
     });
 
-    const objectType = options.objectActor.type;
-    const objectPreviewProperties = options.objectActor.preview.ownProperties;
-    is(objectType, "object", "The inspected object has the expected type");
-    Assert.deepEqual(Object.keys(objectPreviewProperties), ["testkey"],
-                     "The inspected object has the expected preview properties");
+    let objectInspectors = [...messageNode.querySelectorAll(".tree")];
+    is(objectInspectors.length, 1, "There is the expected number of object inspectors");
   })();
 
   const inspectJSObjectPromise = extension.awaitMessage(`inspectedWindow-eval-result`);
   extension.sendMessage(`inspectedWindow-eval-request`, "inspect({testkey: 'testvalue'})");
   await inspectJSObjectPromise;
 
   info("Wait for the split console to be opened and the JS object inspected");
   await splitPanelOpenedPromise;
diff --git a/devtools/client/webconsole/jsterm.js b/devtools/client/webconsole/jsterm.js
--- a/devtools/client/webconsole/jsterm.js
+++ b/devtools/client/webconsole/jsterm.js
@@ -337,19 +337,17 @@ JSTerm.prototype = {
       switch (helperResult.type) {
         case "clearOutput":
           this.clearOutput();
           break;
         case "clearHistory":
           this.clearHistory();
           break;
         case "inspectObject":
-          if (!this.hud.NEW_CONSOLE_OUTPUT_ENABLED) {
-            this.inspectObjectActor(helperResult.object);
-          }
+          this.inspectObjectActor(helperResult.object);
           break;
         case "error":
           try {
             errorMessage = l10n.getStr(helperResult.message);
           } catch (ex) {
             errorMessage = helperResult.message;
           }
           break;
@@ -358,24 +356,19 @@ JSTerm.prototype = {
           break;
         case "copyValueToClipboard":
           clipboardHelper.copyString(helperResult.value);
           break;
       }
     }
 
     // Hide undefined results coming from JSTerm helper functions.
-    if (!errorMessage
-        && result
-        && typeof result == "object"
-        && result.type == "undefined"
-        && helperResult
-        && !helperHasRawOutput
-        && !(this.hud.NEW_CONSOLE_OUTPUT_ENABLED && helperResult.type === "inspectObject")
-    ) {
+    if (!errorMessage && result && typeof result == "object" &&
+      result.type == "undefined" &&
+      helperResult && !helperHasRawOutput) {
       callback && callback();
       return;
     }
 
     if (this.hud.NEW_CONSOLE_OUTPUT_ENABLED) {
       this.hud.newConsoleOutput.dispatchMessageAdd(response, true).then(callback);
       return;
     }
@@ -404,16 +397,26 @@ JSTerm.prototype = {
     }
 
     if (WebConsoleUtils.isActorGrip(result)) {
       msg._objectActors.add(result.actor);
     }
   },
 
   inspectObjectActor: function (objectActor) {
+    if (this.hud.NEW_CONSOLE_OUTPUT_ENABLED) {
+      this.hud.newConsoleOutput.dispatchMessageAdd({
+        helperResult: {
+          type: "inspectObject",
+          object: objectActor
+        }
+      }, true);
+      return this.hud.newConsoleOutput;
+    }
+
     return this.openVariablesView({
       objectActor,
       label: VariablesView.getString(objectActor, {concise: true}),
     });
   },
 
   /**
    * Execute a string. Execution happens asynchronously in the content process.

