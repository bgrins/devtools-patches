# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  00adb0c984e9a32ab61c665b692cc642acebbabf

diff --git a/browser/base/content/tabbrowser-tabs.js b/browser/base/content/tabbrowser-tabs.js
--- a/browser/base/content/tabbrowser-tabs.js
+++ b/browser/base/content/tabbrowser-tabs.js
@@ -513,22 +513,23 @@
 
       var arrowScrollbox = this.arrowScrollbox;
 
       // autoscroll the tab strip if we drag over the scroll
       // buttons, even if we aren't dragging a tab, but then
       // return to avoid drawing the drop indicator
       var pixelsToScroll = 0;
       if (this.getAttribute("overflow") == "true") {
-        var targetAnonid = event.originalTarget.getAttribute("anonid");
-        switch (targetAnonid) {
-          case "scrollbutton-up":
+
+        var target = event.originalTarget;
+        switch (target) {
+          case arrowScrollbox._scrollButtonUp:
             pixelsToScroll = arrowScrollbox.scrollIncrement * -1;
             break;
-          case "scrollbutton-down":
+          case arrowScrollbox._scrollButtonDown:
             pixelsToScroll = arrowScrollbox.scrollIncrement;
             break;
         }
         if (pixelsToScroll) {
           arrowScrollbox.scrollByPixels(
             (RTL_UI ? -1 : 1) * pixelsToScroll,
             true
           );
diff --git a/toolkit/content/widgets/arrowscrollbox.js b/toolkit/content/widgets/arrowscrollbox.js
--- a/toolkit/content/widgets/arrowscrollbox.js
+++ b/toolkit/content/widgets/arrowscrollbox.js
@@ -7,16 +7,37 @@
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
   const { Services } = ChromeUtils.import(
     "resource://gre/modules/Services.jsm"
   );
 
   class MozArrowScrollbox extends MozElements.BaseControl {
+    static get inheritedAttributes() {
+      return {
+        ".scrollbutton-up": "orient,disabled=scrolledtostart",
+        "[part=scrollbox]": "orient,align,pack,dir,smoothscroll",
+        ".scrollbutton-down": "orient,disabled=scrolledtoend",
+      };
+    }
+
+    get markup() {
+      return `
+      <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
+      <toolbarbutton class="scrollbutton-up" part="scrollbutton-up"/>
+      <spacer part="arrowscrollbox-overflow-start-indicator"></spacer>
+      <scrollbox part="scrollbox" flex="1">
+        <html:slot></html:slot>
+      </scrollbox>
+      <spacer part="arrowscrollbox-overflow-end-indicator"></spacer>
+      <toolbarbutton class="scrollbutton-down" part="scrollbutton-down"/>
+    `;
+    }
+
     constructor() {
       super();
       this.attachShadow({ mode: "open" });
       this.shadowRoot.appendChild(this.fragment);
 
       this.scrollbox = this.shadowRoot.querySelector("[part=scrollbox]");
       this._scrollButtonUp = this.shadowRoot.querySelector(".scrollbutton-up");
       this._scrollButtonDown = this.shadowRoot.querySelector(
@@ -98,57 +119,27 @@
         "mousedown",
         this.on_mousedown.bind(this)
       );
       this.shadowRoot.addEventListener(
         "mouseover",
         this.on_mouseover.bind(this)
       );
       this.shadowRoot.addEventListener("mouseout", this.on_mouseout.bind(this));
-
-      // Ultimately Bug 1514926 will convert arrowscrollbox binding to a custom element.
-      // For the needs of Bug 1497189, where we apply a custom CSP to about:addons, we had
-      // to remove inline handlers and hence added event listeners for mouse events here.
-      this.shadowRoot.addEventListener("click", e => {});
-      this.shadowRoot.addEventListener("mousedown", e => {});
-      this.shadowRoot.addEventListener("mouseup", e => {});
-      this.shadowRoot.addEventListener("mouseover", e => {});
-      this.shadowRoot.addEventListener("mouseout", e => {});
-    }
-
-    static get inheritedAttributes() {
-      return {
-        ".scrollbutton-up": "orient,disabled=scrolledtostart",
-        "[part=scrollbox]": "orient,align,pack,dir,smoothscroll",
-        ".scrollbutton-down": "orient,disabled=scrolledtoend",
-      };
     }
 
     get fragment() {
       if (!this.constructor.hasOwnProperty("_fragment")) {
         this.constructor._fragment = MozXULElement.parseXULToFragment(
           this.markup
         );
       }
       return document.importNode(this.constructor._fragment, true);
     }
 
-    get markup() {
-      return `
-      <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
-      <toolbarbutton class="scrollbutton-up" part="scrollbutton-up"/>
-      <spacer part="arrowscrollbox-overflow-start-indicator"></spacer>
-      <scrollbox part="scrollbox" flex="1">
-        <html:slot></html:slot>
-      </scrollbox>
-      <spacer part="arrowscrollbox-overflow-end-indicator"></spacer>
-      <toolbarbutton class="scrollbutton-down" part="scrollbutton-down"/>
-    `;
-    }
-
     connectedCallback() {
       if (!this.hasConnected) {
         this.setAttribute("notoverflowing", "true");
       }
       this.hasConnected = true;
 
       this._updateScrollButtonsDisabledState();
     }
@@ -358,21 +349,16 @@
       this.ensureElementIsVisible(targetElement, aInstant);
     }
 
     _getScrollableElements() {
       let nodes = this.children;
       if (nodes.length == 1) {
         let node = nodes[0];
         if (
-          node.localName == "children" &&
-          node.namespaceURI == "http://www.mozilla.org/xbl"
-        ) {
-          nodes = document.getBindingParent(this).children;
-        } else if (
           node.localName == "slot" &&
           node.namespaceURI == "http://www.w3.org/1999/xhtml"
         ) {
           nodes = node.getRootNode().host.children;
         }
       }
       return Array.prototype.filter.call(nodes, this._canScrollToElement, this);
     }
@@ -605,26 +591,16 @@
             ];
             if (this.isRTLScrollbox) {
               [leftOrTopElement, rightOrBottomElement] = [
                 rightOrBottomElement,
                 leftOrTopElement,
               ];
             }
 
-            // XXX: For some reason the scrolled to start/end detection isn't working with Shadow DOM impl. May
-            // have something do with calls to getBoundsWithoutFlushing, or maybe some missing styles:
-            // console.trace(
-            //   rightOrBottomElement,
-            //   rightOrBottomEdge(rightOrBottomElement),
-            //   rightOrBottomEdge(this.scrollbox),
-            //   rightOrBottomEdge(rightOrBottomElement) <=
-            //     rightOrBottomEdge(this.scrollbox)
-            // );
-
             if (
               leftOrTopElement &&
               leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)
             ) {
               scrolledToStart = !this.isRTLScrollbox;
               scrolledToEnd = this.isRTLScrollbox;
             } else if (
               rightOrBottomElement &&
