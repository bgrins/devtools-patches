# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c843008bfe6f226b35ce831dccd0d06b6ec95cca
972404 Shift right click on an element to open the Browser Toolbox;r=jryans

diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -499,25 +499,25 @@ nsContextMenu.prototype = {
     this.showItem("context-ctp-hide", this.onCTPPlugin);
     this.showItem("context-sep-ctp", this.onCTPPlugin);
   },
 
   inspectNode: function CM_inspectNode() {
     let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
     let gBrowser = this.browser.ownerDocument.defaultView.gBrowser;
     let tt = devtools.TargetFactory.forTab(gBrowser.selectedTab);
+
     return gDevTools.showToolbox(tt, "inspector").then(function(toolbox) {
-      let inspector = toolbox.getCurrentPanel();
       if (this.isRemote) {
+        // This needs to happen after the toolbox has opened so that the child framescript
+        // has been added.
         this.browser.messageManager.sendAsyncMessage("debug:inspect", {}, {node: this.target});
-        inspector.walker.findInspectingNode().then(nodeFront => {
-          inspector.selection.setNodeFront(nodeFront, "browser-context-menu");
-        });
       } else {
-        inspector.selection.setNode(this.target, "browser-context-menu");
+        let {InspectorActor} = devtools.require("devtools/server/actors/inspector", {});
+        InspectorActor.setInspectingNode(this.target);
       }
     }.bind(this));
   },
 
   // Set various context menu attributes based on the state of the world.
   setTarget: function (aNode, aRangeParent, aRangeOffset) {
     // gContextMenuContentData.isRemote tells us if the event came from a remote
     // process. gContextMenuContentData can be null if something (like tests)
diff --git a/browser/devtools/framework/ToolboxProcess.jsm b/browser/devtools/framework/ToolboxProcess.jsm
--- a/browser/devtools/framework/ToolboxProcess.jsm
+++ b/browser/devtools/framework/ToolboxProcess.jsm
@@ -84,16 +84,22 @@ this.BrowserToolboxProcess = function Br
 
 EventEmitter.decorate(BrowserToolboxProcess);
 
 /**
  * Initializes and starts a chrome toolbox process.
  * @return object
  */
 BrowserToolboxProcess.init = function(aOnClose, aOnRun, aOptions) {
+  // If there is already an active process, then just return it instead of
+  // creating a new one.
+  if (processes.size) {
+    let process = [...processes.values()][0];
+    return process;
+  }
   return new BrowserToolboxProcess(aOnClose, aOnRun, aOptions);
 };
 
 /**
  * Passes a set of options to the BrowserAddonActors for the given ID.
  *
  * @param aId string
  *        The ID of the add-on to pass the options to
diff --git a/browser/devtools/framework/gDevTools.jsm b/browser/devtools/framework/gDevTools.jsm
--- a/browser/devtools/framework/gDevTools.jsm
+++ b/browser/devtools/framework/gDevTools.jsm
@@ -630,48 +630,75 @@ let gDevToolsBrowser = {
       gDevToolsBrowser.uninstallWebIDEWidget();
     }
 
     // Enable App Manager?
     let appMgrEnabled = Services.prefs.getBoolPref("devtools.appmanager.enabled");
     toggleCmd("Tools:DevAppMgr", !webIDEEnabled && appMgrEnabled);
 
     // Enable Browser Toolbox?
-    let chromeEnabled = Services.prefs.getBoolPref("devtools.chrome.enabled");
-    let devtoolsRemoteEnabled = Services.prefs.getBoolPref("devtools.debugger.remote-enabled");
-    let remoteEnabled = chromeEnabled && devtoolsRemoteEnabled;
-    toggleCmd("Tools:BrowserToolbox", remoteEnabled);
-    toggleCmd("Tools:BrowserContentToolbox", remoteEnabled && win.gMultiProcessBrowser);
+    let remoteDebuggingEnabled = this.chromeEnabled && this.devtoolsRemoteEnabled;
+    toggleCmd("Tools:BrowserToolbox", remoteDebuggingEnabled);
+    toggleCmd("Tools:BrowserContentToolbox", remoteDebuggingEnabled && win.gMultiProcessBrowser);
 
     // Enable Error Console?
     let consoleEnabled = Services.prefs.getBoolPref("devtools.errorconsole.enabled");
     toggleCmd("Tools:ErrorConsole", consoleEnabled);
 
     // Enable DevTools connection screen, if the preference allows this.
-    toggleCmd("Tools:DevToolsConnect", devtoolsRemoteEnabled);
+    toggleCmd("Tools:DevToolsConnect", this.devtoolsRemoteEnabled);
+  },
+
+
+  /**
+   * Add or remove the 'shift-right-click' event listners used to open the
+   * Browser Toolbox, depending on the pref availablility.
+   */
+  updateRemoteDebuggingAvailability: function() {
+    this.devtoolsRemoteEnabled = Services.prefs.getBoolPref("devtools.debugger.remote-enabled");
+    this.chromeEnabled = Services.prefs.getBoolPref("devtools.chrome.enabled");
+    this.shiftRightClickEnabled =
+      this.chromeEnabled && this.devtoolsRemoteEnabled &&
+      Services.prefs.getBoolPref("devtools.debugger.shift-right-click");
+
+    for (let win of this._trackedBrowserWindows) {
+      if (this.shiftRightClickEnabled) {
+        win.addEventListener("mousedown", this._onMousedown, true);
+        win.addEventListener("contextmenu", this._onContextMenu, true);
+      } else {
+        win.removeEventListener("mousedown", this._onMousedown, true);
+        win.removeEventListener("contextmenu", this._onContextMenu, true);
+      }
+    }
   },
 
   observe: function(subject, topic, prefName) {
+    if (prefName === "devtools.debugger.remote-enabled" ||
+        prefName === "devtools.chrome.enabled" ||
+        prefName === "devtools.debugger.shift-right-click") {
+      this.updateRemoteDebuggingAvailability();
+    }
+
     if (prefName.endsWith("enabled")) {
       for (let win of this._trackedBrowserWindows) {
         this.updateCommandAvailability(win);
       }
     }
   },
 
   _prefObserverRegistered: false,
 
   ensurePrefObserver: function() {
     if (!this._prefObserverRegistered) {
       this._prefObserverRegistered = true;
       Services.prefs.addObserver("devtools.", this, false);
+      this.updateRemoteDebuggingAvailability();
     }
   },
 
-
   /**
    * This function is for the benefit of Tools:{toolId} commands,
    * triggered from the WebDeveloper menu and keyboard shortcuts.
    *
    * selectToolCommand's behavior:
    * - if the toolbox is closed,
    *   we open the toolbox and select the tool
    * - if the toolbox is open, and the targeted tool is not selected,
@@ -842,25 +869,58 @@ let gDevToolsBrowser = {
   /**
    * Move WebIDE widget to the navbar
    */
   moveWebIDEWidgetInNavbar: function() {
     CustomizableUI.addWidgetToArea("webide-button", CustomizableUI.AREA_NAVBAR);
   },
 
   /**
+   * A mousedown event that is fired when remote debugging is enabled.
+   * Open the Browser Toolbox and select the node.
+   */
+  _onMousedown: function(e) {
+    if (e.shiftKey && e.which === 3 && gDevToolsBrowser.shiftRightClickEnabled) {
+      let {BrowserToolboxProcess} =
+        Cu.import("resource:///modules/devtools/ToolboxProcess.jsm", {});
+      let proc = BrowserToolboxProcess.init();
+
+      let {InspectorActor} =
+        proc.loader.require("devtools/server/actors/inspector", {});
+      InspectorActor.setInspectingNode(e.originalTarget);
+
+      e.preventDefault();
+      e.stopPropagation();
+      return false;
+    }
+  },
+
+  /**
+   * A contextmenu event that is fired when remote debugging is enabled.
+   * Don't show the context menu if it was handled by the browser toolbox.
+   */
+  _onContextMenu: function(e) {
+    if (e.shiftKey && gDevToolsBrowser.shiftRightClickEnabled) {
+      e.preventDefault();
+      e.stopPropagation();
+      return false;
+    }
+  },
+
+  /**
    * Add this DevTools's presence to a browser window's document
    *
    * @param {XULDocument} doc
    *        The document to which menuitems and handlers are to be added
    */
   registerBrowserWindow: function DT_registerBrowserWindow(win) {
+    gDevToolsBrowser._trackedBrowserWindows.add(win);
+    this.updateRemoteDebuggingAvailability();
     this.updateCommandAvailability(win);
     this.ensurePrefObserver();
-    gDevToolsBrowser._trackedBrowserWindows.add(win);
     gDevToolsBrowser._addAllToolsToMenu(win.document);
 
     if (this._isFirebugInstalled()) {
       let broadcaster = win.document.getElementById("devtoolsMenuBroadcaster_DevToolbox");
       broadcaster.removeAttribute("key");
     }
 
     let tabContainer = win.document.getElementById("tabbrowser-tabs");
@@ -1291,16 +1351,19 @@ let gDevToolsBrowser = {
     }
 
     let tabContainer = win.document.getElementById("tabbrowser-tabs");
     tabContainer.removeEventListener("TabSelect", this, false);
     tabContainer.removeEventListener("TabOpen", this, false);
     tabContainer.removeEventListener("TabClose", this, false);
     tabContainer.removeEventListener("TabPinned", this, false);
     tabContainer.removeEventListener("TabUnpinned", this, false);
+
+    win.removeEventListener("mousedown", this._onMousedown, true);
+    win.removeEventListener("contextmenu", this._onContextMenu, true);
   },
 
   handleEvent: function(event) {
     switch (event.type) {
       case "TabOpen":
       case "TabClose":
       case "TabPinned":
       case "TabUnpinned":
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -120,16 +120,17 @@ function Toolbox(target, selectedTool, h
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
+  this._nodePickedWithContextMenu = this._nodePickedWithContextMenu.bind(this);
   this._highlighterReady = this._highlighterReady.bind(this);
   this._highlighterHidden = this._highlighterHidden.bind(this);
   this._prefChanged = this._prefChanged.bind(this);
   this._saveSplitConsoleHeight = this._saveSplitConsoleHeight.bind(this);
   this._onFocus = this._onFocus.bind(this);
   this._showDevEditionPromo = this._showDevEditionPromo.bind(this);
   this._updateTextboxMenuItems = this._updateTextboxMenuItems.bind(this);
   this._onBottomHostMinimized = this._onBottomHostMinimized.bind(this);
@@ -334,16 +335,17 @@ Toolbox.prototype = {
    */
   open: function() {
     return Task.spawn(function*() {
       let iframe = yield this._host.create();
       let domReady = promise.defer();
 
       // Load the toolbox-level actor fronts and utilities now
       yield this._target.makeRemote();
+
       iframe.setAttribute("src", this._URL);
       iframe.setAttribute("aria-label", toolboxStrings("toolbox.label"));
       let domHelper = new DOMHelpers(iframe.contentWindow);
       domHelper.onceDOMReady(() => domReady.resolve());
 
       yield domReady.promise;
 
       this.isReady = true;
@@ -389,16 +391,22 @@ Toolbox.prototype = {
       // The isTargetSupported check needs to happen after the target is
       // remoted, otherwise we could have done it in the toolbox constructor
       // (bug 1072764).
       let toolDef = gDevTools.getToolDefinition(this._defaultToolId);
       if (!toolDef || !toolDef.isTargetSupported(this._target)) {
         this._defaultToolId = "webconsole";
       }
 
+      // Some targets (like browser content toolbox), don't have an inspector.
+      if (this._target.hasActor("inspector")) {
+        this._inspector = InspectorFront(this._target.client,
+                                         this._target.form);
+      }
+
       yield this.selectTool(this._defaultToolId);
 
       // Wait until the original tool is selected so that the split
       // console input will receive focus.
       let splitConsolePromise = promise.resolve();
       if (Services.prefs.getBoolPref(SPLITCONSOLE_ENABLED_PREF)) {
         splitConsolePromise = this.openSplitConsole();
       }
@@ -417,16 +425,24 @@ Toolbox.prototype = {
       // finish, as most tests shut down without waiting for a toolbox
       // destruction event, resulting in the shared profiler connection being
       // opened and closed outside of the test that originally opened the
       // toolbox.
       if (gDevTools.testing) {
         yield profilerReady;
       }
 
+      if (this._inspector) {
+        this._inspector.on("inspect-context-menu", this._nodePickedWithContextMenu);
+        let hasInspectingNode = yield this._inspector.hasInspectingNode();
+        if (hasInspectingNode) {
+          this._nodePickedWithContextMenu();
+        }
+      }
+
       this.emit("ready");
     }.bind(this)).then(null, console.error.bind(console));
   },
 
   _pingTelemetry: function() {
     this._telemetry.toolOpened("toolbox");
 
     this._telemetry.logOncePerBrowserVersion(OS_HISTOGRAM, system.getOSCPU());
@@ -1092,17 +1108,17 @@ Toolbox.prototype = {
 
   /**
    * Ensure the tool with the given id is loaded.
    *
    * @param {string} id
    *        The id of the tool to load.
    */
   loadTool: function(id) {
-    if (id === "inspector" && !this._inspector) {
+    if (id === "inspector" && !this._initInspector) {
       return this.initInspector().then(() => {
         return this.loadTool(id);
       });
     }
 
     let deferred = promise.defer();
     let iframe = this.doc.getElementById("toolbox-panel-iframe-" + id);
 
@@ -1708,23 +1724,24 @@ Toolbox.prototype = {
       let key = doc.getElementById("key_" + toolId);
       if (key) {
         key.parentNode.removeChild(key);
       }
     }
   },
 
   /**
-   * Initialize the inspector/walker/selection/highlighter fronts.
-   * Returns a promise that resolves when the fronts are initialized
+   * Initialize the walker/selection/highlighter fronts.
+   * Returns a promise that resolves when the fronts are initialized.
+   * The inspector front is initialized on toolbox startup, but most of its
+   * functionality relies on this function being called.
    */
   initInspector: function() {
     if (!this._initInspector) {
       this._initInspector = Task.spawn(function*() {
-        this._inspector = InspectorFront(this._target.client, this._target.form);
         this._walker = yield this._inspector.getWalker(
           {showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent")}
         );
         this._selection = new Selection(this._walker);
 
         if (this.highlighterUtils.isRemoteHighlightable()) {
           this.walker.on("highlighter-ready", this._highlighterReady);
           this.walker.on("highlighter-hide", this._highlighterHidden);
@@ -1745,16 +1762,18 @@ Toolbox.prototype = {
     if (this._destroying) {
       return this._destroying;
     }
 
     if (!this._inspector) {
       return promise.resolve();
     }
 
+    this._inspector.off("inspect-context-menu", this._nodePickedWithContextMenu);
+
     let outstanding = () => {
       return Task.spawn(function*() {
         yield this.highlighterUtils.stopPicker();
         yield this._inspector.destroy();
         if (this._highlighter) {
           yield this._highlighter.destroy();
         }
         if (this._selection) {
@@ -1931,16 +1950,24 @@ Toolbox.prototype = {
     Services.obs.addObserver(leakCheckObserver, topic, false);
     this._destroyer.then(() => {
       Services.obs.removeObserver(leakCheckObserver, topic);
     });
 
     return this._destroyer;
   },
 
+  _nodePickedWithContextMenu: Task.async(function*() {
+    let inspector = yield this.selectTool("inspector");
+    let nodeFront = yield this.walker.findInspectingNode();
+    if (nodeFront) {
+      inspector.selection.setNodeFront(nodeFront, "browser-context-menu");
+    }
+  }),
+
   _highlighterReady: function() {
     this.emit("highlighter-ready");
   },
 
   _highlighterHidden: function() {
     this.emit("highlighter-hide");
   },
 
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -823,16 +823,18 @@ pref("devtools.debugger.remote-port", 60
 // Force debugger server binding on the loopback interface
 pref("devtools.debugger.force-local", true);
 // Display a prompt when a new connection starts to accept/reject it
 pref("devtools.debugger.prompt-connection", true);
 // Block tools from seeing / interacting with certified apps
 pref("devtools.debugger.forbid-certified-apps", true);
 // List of permissions that a sideloaded app can't ask for
 pref("devtools.apps.forbidden-permissions", "embed-apps,engineering-mode,embed-widgets");
+// Add a shortcut for shift + right click to open up the Browser Toolbox
+pref("devtools.debugger.shift-right-click", false);
 
 // DevTools default color unit
 pref("devtools.defaultColorUnit", "hex");
 
 // Used for devtools debugging
 pref("devtools.dump.emit", false);
 
 // Disable device discovery logging
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -169,30 +169,16 @@ var gValueSummaryLength = exports.DEFAUL
 exports.getValueSummaryLength = function() {
   return gValueSummaryLength;
 };
 
 exports.setValueSummaryLength = function(val) {
   gValueSummaryLength = val;
 };
 
-// When the user selects a node to inspect in e10s, the parent process
-// has a CPOW that wraps the node being inspected.  It uses the
-// message manager to send this node to the child, which stores the
-// node in gInspectingNode. Then a findInspectingNode request is sent
-// over the remote debugging protocol, and gInspectingNode is returned
-// to the parent as a NodeFront.
-var gInspectingNode = null;
-
-// We expect this function to be called from the child.js frame script
-// when it receives the node to be inspected over the message manager.
-exports.setInspectingNode = function(val) {
-  gInspectingNode = val;
-};
-
 /**
  * Server side of the node actor.
  */
 var NodeActor = exports.NodeActor = protocol.ActorClass({
   typeName: "domnode",
 
   initialize: function(walker, node) {
     protocol.Actor.prototype.initialize.call(this, null);
@@ -1891,27 +1877,29 @@ var WalkerActor = protocol.ActorClass({
       node = walker.previousSibling();
     } while(node && --count);
     ret.reverse();
     return ret;
   },
 
   /**
    * Return the node that the parent process has asked to
-   * inspect. This node is expected to be stored in gInspectingNode
+   * inspect. This node is expected to be stored in InspectorActor.inspectingNode
    * (which is set by a message manager message to the child.js frame
    * script). The node is returned over the remote debugging protocol
    * as a NodeFront.
    */
   findInspectingNode: method(function() {
-    let node = gInspectingNode;
+    let node = InspectorActor.inspectingNode;
     if (!node) {
       return {}
     };
 
+    InspectorActor.inspectingNode = null;
+
     return this.attachElement(node);
   }, {
     request: {},
     response: RetVal("disconnectedNode")
   }),
 
   /**
    * Return the first node in the document that matches the given selector.
@@ -3504,23 +3492,45 @@ var AttributeModificationList = Class({
 })
 
 /**
  * Server side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorActor = exports.InspectorActor = protocol.ActorClass({
   typeName: "inspector",
+  events: {
+    "inspect-context-menu": {
+      type: "inspect-context-menu"
+    },
+  },
+
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
+    this.emitNodePicked = () => {
+      events.emit(this, "inspect-context-menu");
+    };
+    events.on(InspectorActor, "setInspectingNode", this.emitNodePicked);
   },
 
+  hasInspectingNode: method(function() {
+    return {
+      hasInspectingNode: !!InspectorActor.inspectingNode
+    }
+  }, {
+    request: {},
+    response: {
+      hasInspectingNode: RetVal("boolean")
+    }
+  }),
+
   destroy: function () {
     protocol.Actor.prototype.destroy.call(this);
+    events.off(InspectorActor, "setInspectingNode", this.emitNodePicked);
   },
 
   // Forces destruction of the actor and all its children
   // like highlighter, walker and style actors.
   disconnect: function() {
     this.destroy();
   },
 
@@ -3710,16 +3720,37 @@ var InspectorActor = exports.InspectorAc
     }
   }, {
     request: {url: Arg(0, "string"), node: Arg(1, "nullable:domnode")},
     response: {value: RetVal("string")}
   })
 });
 
 /**
+ * When the user selects a node to inspect with the context menu, the node
+ * is stored globally on InspectorActor.inspectingNode within the server
+ * process.
+ *
+ * In e10s: the parent process has a CPOW that wraps the node being inspected.
+ * It uses the message manager to send this node to the child.
+ * In non-e10s: this function is imported through the devtools loader and
+ * called directly.
+ * In the Browser Toolbox: this function is imported through the
+ * BrowserToolboxProcess loader object and called directly.
+ *
+ * When this happens, the instance of the actor is notified, and it emits
+ * an event that notifies the client to fetch the node from it's Walker
+ * via the `findInspectingNode` call.
+ */
+InspectorActor.setInspectingNode = function(node) {
+  InspectorActor.inspectingNode = node;
+  events.emit(InspectorActor, "setInspectingNode");
+};
+
+/**
  * Client side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorFront = exports.InspectorFront = protocol.FrontClass(InspectorActor, {
   initialize: function(client, tabForm) {
     protocol.Front.prototype.initialize.call(this, client);
     this.actorID = tabForm.inspectorActor;
 
@@ -3728,16 +3759,32 @@ var InspectorFront = exports.InspectorFr
     this.manage(this);
   },
 
   destroy: function() {
     delete this.walker;
     protocol.Front.prototype.destroy.call(this);
   },
 
+  hasInspectingNode: protocol.custom(function() {
+    if (InspectorActor.inspectingNode) {
+      return true;
+    }
+
+    // In the case of the Browser Toolbox, InspectorActor.inspectingNode is
+    // set in the server process so we need to consult with the actor.
+    // XXX: For performance in the normal toolbox, we should detect this situation
+    // by checking the type of the root actor or something
+    return this._hasInspectingNode().then(response => {
+      return response.hasInspectingNode;
+    });
+  }, {
+    impl: "_hasInspectingNode"
+  }),
+
   getWalker: protocol.custom(function(options = {}) {
     return this._getWalker(options).then(walker => {
       this.walker = walker;
       return walker;
     });
   }, {
     impl: "_getWalker"
   }),
diff --git a/toolkit/devtools/server/child.js b/toolkit/devtools/server/child.js
--- a/toolkit/devtools/server/child.js
+++ b/toolkit/devtools/server/child.js
@@ -95,21 +95,20 @@ let chromeGlobal = this;
     if (conn) {
       conn.close();
       connections.delete(prefix);
     }
   });
   addMessageListener("debug:disconnect", onDisconnect);
 
   let onInspect = DevToolsUtils.makeInfallible(function(msg) {
-    // Store the node to be inspected in a global variable
-    // (gInspectingNode). Later we'll fetch this variable again using
-    // the findInspectingNode request over the remote debugging
-    // protocol.
-    let inspector = devtools.require("devtools/server/actors/inspector");
-    inspector.setInspectingNode(msg.objects.node);
+    // Store the node to be inspected in a variable.
+    // Later we'll fetch this variable again using the
+    // findInspectingNode request over the remote debugging protocol.
+    let {InspectorActor} = devtools.require("devtools/server/actors/inspector", {});
+    InspectorActor.setInspectingNode(msg.objects.node);
   });
   addMessageListener("debug:inspect", onInspect);
 })();
 
 } catch(e) {
   dump("Exception in app child process: " + e + "\n");
 }
