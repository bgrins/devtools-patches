# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f5dfe5774099507d635a4fa619ac1a7bbe025501
972404 Shift right click element alternate plan

diff --git a/browser/devtools/framework/ToolboxProcess.jsm b/browser/devtools/framework/ToolboxProcess.jsm
--- a/browser/devtools/framework/ToolboxProcess.jsm
+++ b/browser/devtools/framework/ToolboxProcess.jsm
@@ -84,16 +84,23 @@ this.BrowserToolboxProcess = function Br
 
 EventEmitter.decorate(BrowserToolboxProcess);
 
 /**
  * Initializes and starts a chrome toolbox process.
  * @return object
  */
 BrowserToolboxProcess.init = function(aOnClose, aOnRun, aOptions) {
+  // If there is already an active process, then just return it instead of
+  // creating a new one.
+  if (processes.size) {
+    let process = [...processes.values()][0];
+    // XXX: Send a message over the protocol to focus the window
+    return process;
+  }
   return new BrowserToolboxProcess(aOnClose, aOnRun, aOptions);
 };
 
 /**
  * Passes a set of options to the BrowserAddonActors for the given ID.
  *
  * @param aId string
  *        The ID of the add-on to pass the options to
diff --git a/browser/devtools/framework/gDevTools.jsm b/browser/devtools/framework/gDevTools.jsm
--- a/browser/devtools/framework/gDevTools.jsm
+++ b/browser/devtools/framework/gDevTools.jsm
@@ -848,16 +848,57 @@ let gDevToolsBrowser = {
 
   /**
    * Add this DevTools's presence to a browser window's document
    *
    * @param {XULDocument} doc
    *        The document to which menuitems and handlers are to be added
    */
   registerBrowserWindow: function DT_registerBrowserWindow(win) {
+    const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+    console.log("registerBrowserWindow", win);
+
+    // XX: Only add these handlers when BT is possible to open
+    win.addEventListener("mousedown", event => {
+      console.log("MOUSEDOWN", event.shiftKey && event.which === 3)
+      if (event.shiftKey && event.which === 3) {
+        event.preventDefault();
+        event.stopPropagation();
+        return false;
+      }
+    }, true);
+    win.addEventListener("contextmenu", event => {
+      if (event.shiftKey) {
+
+        // See https://dxr.mozilla.org/mozilla-central/source/browser/base/content/nsContextMenu.js#522
+        Cu.import("resource:///modules/devtools/ToolboxProcess.jsm");
+        let p = BrowserToolboxProcess.init();
+        console.log("Context menu event receieved",  p, event.originalTarget, p.loader);
+
+        let inspector = p.loader.require("devtools/server/actors/inspector");
+        inspector.setInspectingNode(event.originalTarget);
+
+        // p.debuggerServer.emit("Hi");
+        // debugger;
+        // this._inspector = InspectorFront(this._target.client, this._target.form);
+        // this._walker = yield this._inspector.getWalker(
+        //   {showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent")}
+        // );
+
+
+        //
+        // Can we get a tabForm.inspectorActor somehow from here?
+        console.log(inspector.getInspectingNode());
+
+        event.preventDefault();
+        event.stopPropagation();
+        return false;
+      }
+    }, true);
+
     this.updateCommandAvailability(win);
     this.ensurePrefObserver();
     gDevToolsBrowser._trackedBrowserWindows.add(win);
     gDevToolsBrowser._addAllToolsToMenu(win.document);
 
     if (this._isFirebugInstalled()) {
       let broadcaster = win.document.getElementById("devtoolsMenuBroadcaster_DevToolbox");
       broadcaster.removeAttribute("key");
diff --git a/browser/devtools/framework/toolbox-process-window.js b/browser/devtools/framework/toolbox-process-window.js
--- a/browser/devtools/framework/toolbox-process-window.js
+++ b/browser/devtools/framework/toolbox-process-window.js
@@ -89,17 +89,17 @@ function openToolbox({ form, chrome, isT
       selectedTool = Services.prefs.getCharPref("devtools.toolbox.selectedTool");
     } catch(e) {}
 
     try {
       // But if we are testing, then it should always open the debugger panel.
       selectedTool = Services.prefs.getCharPref("devtools.browsertoolbox.panel");
     } catch(e) {}
 
-    let options = { customIframe: frame };
+    let options = { customIframe: frame, pickOnLoad: true };
     gDevTools.showToolbox(target,
                           selectedTool,
                           devtools.Toolbox.HostType.CUSTOM,
                           options)
              .then(onNewToolbox);
   });
 }
 
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -100,32 +100,33 @@ const ToolboxButtons = exports.ToolboxBu
  *        The object the toolbox is debugging.
  * @param {string} selectedTool
  *        Tool to select initially
  * @param {Toolbox.HostType} hostType
  *        Type of host that will host the toolbox (e.g. sidebar, window)
  * @param {object} hostOptions
  *        Options for host specifically
  */
-function Toolbox(target, selectedTool, hostType, hostOptions) {
+function Toolbox(target, selectedTool, hostType, hostOptions={}) {
   this._target = target;
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
 
   this._initInspector = null;
   this._inspector = null;
 
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
+  this._browserToolboxNodePicked = this._browserToolboxNodePicked.bind(this);
   this._highlighterReady = this._highlighterReady.bind(this);
   this._highlighterHidden = this._highlighterHidden.bind(this);
   this._prefChanged = this._prefChanged.bind(this);
   this._saveSplitConsoleHeight = this._saveSplitConsoleHeight.bind(this);
   this._onFocus = this._onFocus.bind(this);
   this._showDevEditionPromo = this._showDevEditionPromo.bind(this);
   this._updateTextboxMenuItems = this._updateTextboxMenuItems.bind(this);
 
@@ -397,16 +398,24 @@ Toolbox.prototype = {
       // However, while testing, we must wait for the performance connection to finish,
       // as most tests shut down without waiting for a toolbox destruction event,
       // resulting in the shared profiler connection being opened and closed
       // outside of the test that originally opened the toolbox.
       if (gDevTools.testing) {
         yield profilerReady;
       }
 
+      if (this._hostOptions.pickOnLoad) {
+        let inspectorPanel = yield this.selectTool("inspector");
+        let nodeFront = yield this.inspector.walker.findInspectingNode();
+        if (nodeFront) {
+          inspectorPanel.selection.setNodeFront(nodeFront, "browser-context-menu");
+        }
+      }
+
       this.emit("ready");
     }.bind(this)).then(null, console.error.bind(console));
   },
 
   _pingTelemetry: function() {
     this._telemetry.toolOpened("toolbox");
 
     this._telemetry.logOncePerBrowserVersion(OS_HISTOGRAM,
@@ -1592,16 +1601,18 @@ Toolbox.prototype = {
     if (!this._initInspector) {
       this._initInspector = Task.spawn(function*() {
         this._inspector = InspectorFront(this._target.client, this._target.form);
         this._walker = yield this._inspector.getWalker(
           {showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent")}
         );
         this._selection = new Selection(this._walker);
 
+        this.walker.on("browser-toolbox-node-picked", this._browserToolboxNodePicked);
+
         if (this.highlighterUtils.isRemoteHighlightable()) {
           this.walker.on("highlighter-ready", this._highlighterReady);
           this.walker.on("highlighter-hide", this._highlighterHidden);
 
           let autohide = !gDevTools.testing;
           this._highlighter = yield this._inspector.getHighlighter(autohide);
         }
       }.bind(this));
@@ -1629,16 +1640,17 @@ Toolbox.prototype = {
         if (this._highlighter) {
           yield this._highlighter.destroy();
         }
         if (this._selection) {
           this._selection.destroy();
         }
 
         if (this.walker) {
+          this.walker.off("browser-toolbox-node-picked", this._browserToolboxNodePicked);
           this.walker.off("highlighter-ready", this._highlighterReady);
           this.walker.off("highlighter-hide", this._highlighterHidden);
         }
 
         this._inspector = null;
         this._highlighter = null;
         this._selection = null;
         this._walker = null;
@@ -1838,16 +1850,27 @@ Toolbox.prototype = {
     Services.obs.addObserver(leakCheckObserver, topic, false);
     this._destroyer.then(() => {
       Services.obs.removeObserver(leakCheckObserver, topic);
     });
 
     return this._destroyer;
   },
 
+  _browserToolboxNodePicked: Task.async(function*(nodeFront) {
+    if (nodeFront) {
+      let inspectorPanel = yield this.selectTool("inspector");
+      inspectorPanel.walker.findInspectingNode().then(nodeFront => {
+        console.log("HERE", nodeFront);
+        inspectorPanel.selection.setNodeFront(nodeFront, "browser-context-menu");
+      });
+      // inspectorPanel.selection.setNodeFront(nodeFront, "browser-context-menu");
+    }
+  }),
+
   _highlighterReady: function() {
     this.emit("highlighter-ready");
   },
 
   _highlighterHidden: function() {
     this.emit("highlighter-hide");
   },
 
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -175,22 +175,31 @@ exports.setValueSummaryLength = function
 };
 
 // When the user selects a node to inspect in e10s, the parent process
 // has a CPOW that wraps the node being inspected.  It uses the
 // message manager to send this node to the child, which stores the
 // node in gInspectingNode. Then a findInspectingNode request is sent
 // over the remote debugging protocol, and gInspectingNode is returned
 // to the parent as a NodeFront.
-var gInspectingNode = null;
+let gInspectingNode = null;
+let gOnInpectingNode = null;
 
 // We expect this function to be called from the child.js frame script
 // when it receives the node to be inspected over the message manager.
 exports.setInspectingNode = function(val) {
   gInspectingNode = val;
+  if (gOnInpectingNode) {
+    gOnInpectingNode();
+  }
+};
+
+/// XXX: remove this.. just for debugging
+exports.getInspectingNode = function() {
+  return gInspectingNode;
 };
 
 /**
  * Server side of the node actor.
  */
 var NodeActor = exports.NodeActor = protocol.ActorClass({
   typeName: "domnode",
 
@@ -1176,16 +1185,20 @@ var WalkerActor = protocol.ActorClass({
     },
     "picker-node-hovered" : {
       type: "pickerNodeHovered",
       node: Arg(0, "disconnectedNode")
     },
     "picker-node-canceled" : {
       type: "pickerNodeCanceled"
     },
+    "browser-toolbox-node-picked" : {
+      type: "browser-toolbox-node-picked",
+      nodes: Arg(0, "domnode")
+    },
     "highlighter-ready" : {
       type: "highlighter-ready"
     },
     "highlighter-hide" : {
       type: "highlighter-hide"
     },
     "display-change" : {
       type: "display-change",
@@ -1229,16 +1242,23 @@ var WalkerActor = protocol.ActorClass({
 
     // Ensure that the root document node actor is ready and
     // managed.
     this.rootNode = this.document();
 
     this.reflowObserver = getLayoutChangesObserver(this.tabActor);
     this._onReflows = this._onReflows.bind(this);
     this.reflowObserver.on("reflows", this._onReflows);
+
+    console.log("WALKER ACTOR HERE", conn, tabActor);
+
+    gOnInpectingNode = () => {
+      console.log("Node selected - emitting event", gInspectingNode);
+      events.emit(this, "browser-toolbox-node-picked", this._ref(gInspectingNode));
+    }
   },
 
   // Returns the JSON representation of this object over the wire.
   form: function() {
     return {
       actor: this.actorID,
       root: this.rootNode.form()
     }
