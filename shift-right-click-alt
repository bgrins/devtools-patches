# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f5dfe5774099507d635a4fa619ac1a7bbe025501
972404 Shift right click element alternate plan

diff --git a/browser/devtools/framework/ToolboxProcess.jsm b/browser/devtools/framework/ToolboxProcess.jsm
--- a/browser/devtools/framework/ToolboxProcess.jsm
+++ b/browser/devtools/framework/ToolboxProcess.jsm
@@ -84,16 +84,23 @@ this.BrowserToolboxProcess = function Br
 
 EventEmitter.decorate(BrowserToolboxProcess);
 
 /**
  * Initializes and starts a chrome toolbox process.
  * @return object
  */
 BrowserToolboxProcess.init = function(aOnClose, aOnRun, aOptions) {
+  // If there is already an active process, then just return it instead of
+  // creating a new one.
+  if (processes.size) {
+    let process = [...processes.values()][0];
+    // XXX: Send a message over the protocol to focus the window maybe?
+    return process;
+  }
   return new BrowserToolboxProcess(aOnClose, aOnRun, aOptions);
 };
 
 /**
  * Passes a set of options to the BrowserAddonActors for the given ID.
  *
  * @param aId string
  *        The ID of the add-on to pass the options to
diff --git a/browser/devtools/framework/gDevTools.jsm b/browser/devtools/framework/gDevTools.jsm
--- a/browser/devtools/framework/gDevTools.jsm
+++ b/browser/devtools/framework/gDevTools.jsm
@@ -558,16 +558,26 @@ let gDevToolsBrowser = {
 
   _tabStats: {
     peakOpen: 0,
     peakPinned: 0,
     histOpen: [],
     histPinned: []
   },
 
+  get devtoolsRemoteEnabled() {
+    let devtoolsRemoteEnabled = Services.prefs.getBoolPref("devtools.debugger.remote-enabled");
+    return devtoolsRemoteEnabled;
+  },
+
+  get remoteDebuggingEnabled() {
+    let chromeEnabled = Services.prefs.getBoolPref("devtools.chrome.enabled");
+    return chromeEnabled && this.devtoolsRemoteEnabled;
+  },
+
   /**
    * This function is for the benefit of Tools:DevToolbox in
    * browser/base/content/browser-sets.inc and should not be used outside
    * of there
    */
   toggleToolboxCommand: function(gBrowser) {
     let target = devtools.TargetFactory.forTab(gBrowser.selectedTab);
     let toolbox = gDevTools.getToolbox(target);
@@ -630,28 +640,26 @@ let gDevToolsBrowser = {
       gDevToolsBrowser.uninstallWebIDEWidget();
     }
 
     // Enable App Manager?
     let appMgrEnabled = Services.prefs.getBoolPref("devtools.appmanager.enabled");
     toggleCmd("Tools:DevAppMgr", !webIDEEnabled && appMgrEnabled);
 
     // Enable Browser Toolbox?
-    let chromeEnabled = Services.prefs.getBoolPref("devtools.chrome.enabled");
-    let devtoolsRemoteEnabled = Services.prefs.getBoolPref("devtools.debugger.remote-enabled");
-    let remoteEnabled = chromeEnabled && devtoolsRemoteEnabled;
-    toggleCmd("Tools:BrowserToolbox", remoteEnabled);
-    toggleCmd("Tools:BrowserContentToolbox", remoteEnabled && win.gMultiProcessBrowser);
+    let remoteDebuggingEnabled = this.remoteDebuggingEnabled;
+    toggleCmd("Tools:BrowserToolbox", remoteDebuggingEnabled);
+    toggleCmd("Tools:BrowserContentToolbox", remoteDebuggingEnabled && win.gMultiProcessBrowser);
 
     // Enable Error Console?
     let consoleEnabled = Services.prefs.getBoolPref("devtools.errorconsole.enabled");
     toggleCmd("Tools:ErrorConsole", consoleEnabled);
 
     // Enable DevTools connection screen, if the preference allows this.
-    toggleCmd("Tools:DevToolsConnect", devtoolsRemoteEnabled);
+    toggleCmd("Tools:DevToolsConnect", this.devtoolsRemoteEnabled);
   },
 
   observe: function(subject, topic, prefName) {
     if (prefName.endsWith("enabled")) {
       for (let win of this._trackedBrowserWindows) {
         this.updateCommandAvailability(win);
       }
     }
@@ -841,23 +849,60 @@ let gDevToolsBrowser = {
 
   /**
    * Move WebIDE widget to the navbar
    */
   moveWebIDEWidgetInNavbar: function() {
     CustomizableUI.addWidgetToArea("webide-button", CustomizableUI.AREA_NAVBAR);
   },
 
+  _onRemoteDebuggingMousedown: function(event) {
+    console.log("MOUSEDOWN", event.shiftKey && event.which === 3, this);
+    console.log("_onRemoteDebuggingMousedown", gDevToolsBrowser.remoteDebuggingEnabled);
+    if (event.shiftKey && event.which === 3 && gDevToolsBrowser.remoteDebuggingEnabled) {
+      event.preventDefault();
+      event.stopPropagation();
+      return false;
+    }
+  },
+
+  _onRemoteDebuggingContextMenu: function(event) {
+    console.log("_onRemoteDebuggingContextMenu", gDevToolsBrowser.remoteDebuggingEnabled);
+    if (event.shiftKey && gDevToolsBrowser.remoteDebuggingEnabled) {
+      Cu.import("resource:///modules/devtools/ToolboxProcess.jsm");
+      let p = BrowserToolboxProcess.init();
+      console.log("Context menu event receieved",  p, event.originalTarget, p.loader);
+
+      let inspector = p.loader.require("devtools/server/actors/inspector");
+      inspector.setInspectingNodeBrowserToolbox(event.originalTarget);
+
+      event.preventDefault();
+      event.stopPropagation();
+      return false;
+    }
+
+  },
+
   /**
    * Add this DevTools's presence to a browser window's document
    *
    * @param {XULDocument} doc
    *        The document to which menuitems and handlers are to be added
    */
   registerBrowserWindow: function DT_registerBrowserWindow(win) {
+    const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+    console.log("registerBrowserWindow", win, this.remoteDebuggingEnabled);
+
+    if (this.remoteDebuggingEnabled) {
+
+    }
+
+    win.addEventListener("mousedown", this._onRemoteDebuggingMousedown, true);
+    win.addEventListener("contextmenu", this._onRemoteDebuggingContextMenu, true);
+
     this.updateCommandAvailability(win);
     this.ensurePrefObserver();
     gDevToolsBrowser._trackedBrowserWindows.add(win);
     gDevToolsBrowser._addAllToolsToMenu(win.document);
 
     if (this._isFirebugInstalled()) {
       let broadcaster = win.document.getElementById("devtoolsMenuBroadcaster_DevToolbox");
       broadcaster.removeAttribute("key");
@@ -1285,16 +1330,19 @@ let gDevToolsBrowser = {
 
     // Destroy toolboxes for closed window
     for (let [target, toolbox] of gDevTools._toolboxes) {
       if (toolbox.frame && toolbox.frame.ownerDocument.defaultView == win) {
         toolbox.destroy();
       }
     }
 
+    win.removeEventListener("mousedown", this._onRemoteDebuggingMousedown, true);
+    win.removeEventListener("contextmenu", this._onRemoteDebuggingContextMenu, true);
+
     let tabContainer = win.document.getElementById("tabbrowser-tabs");
     tabContainer.removeEventListener("TabSelect", this, false);
     tabContainer.removeEventListener("TabOpen", this, false);
     tabContainer.removeEventListener("TabClose", this, false);
     tabContainer.removeEventListener("TabPinned", this, false);
     tabContainer.removeEventListener("TabUnpinned", this, false);
   },
 
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -100,32 +100,34 @@ const ToolboxButtons = exports.ToolboxBu
  *        The object the toolbox is debugging.
  * @param {string} selectedTool
  *        Tool to select initially
  * @param {Toolbox.HostType} hostType
  *        Type of host that will host the toolbox (e.g. sidebar, window)
  * @param {object} hostOptions
  *        Options for host specifically
  */
-function Toolbox(target, selectedTool, hostType, hostOptions) {
+function Toolbox(target, selectedTool, hostType, hostOptions={}) {
+  console.log("Toolbox", target);
   this._target = target;
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
 
   this._initInspector = null;
   this._inspector = null;
 
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
+  this._browserToolboxNodePicked = this._browserToolboxNodePicked.bind(this);
   this._highlighterReady = this._highlighterReady.bind(this);
   this._highlighterHidden = this._highlighterHidden.bind(this);
   this._prefChanged = this._prefChanged.bind(this);
   this._saveSplitConsoleHeight = this._saveSplitConsoleHeight.bind(this);
   this._onFocus = this._onFocus.bind(this);
   this._showDevEditionPromo = this._showDevEditionPromo.bind(this);
   this._updateTextboxMenuItems = this._updateTextboxMenuItems.bind(this);
 
@@ -316,16 +318,19 @@ Toolbox.prototype = {
    */
   open: function () {
     return Task.spawn(function*() {
       let iframe = yield this._host.create();
       let domReady = promise.defer();
 
       // Load the toolbox-level actor fronts and utilities now
       yield this._target.makeRemote();
+
+      this._inspector = InspectorFront(this._target.client, this._target.form);
+
       iframe.setAttribute("src", this._URL);
       iframe.setAttribute("aria-label", toolboxStrings("toolbox.label"));
       let domHelper = new DOMHelpers(iframe.contentWindow);
       domHelper.onceDOMReady(() => domReady.resolve());
 
       yield domReady.promise;
 
       this.isReady = true;
@@ -371,16 +376,17 @@ Toolbox.prototype = {
       // remoted, otherwise we could have done it in the toolbox constructor
       // (bug 1072764).
       let toolDef = gDevTools.getToolDefinition(this._defaultToolId);
       if (!toolDef || !toolDef.isTargetSupported(this._target)) {
         this._defaultToolId = "webconsole";
       }
 
       yield this.selectTool(this._defaultToolId);
+      this._inspector.on("browser-toolbox-node-picked", this._browserToolboxNodePicked);
 
       // Wait until the original tool is selected so that the split
       // console input will receive focus.
       let splitConsolePromise = promise.resolve();
       if (Services.prefs.getBoolPref(SPLITCONSOLE_ENABLED_PREF)) {
         splitConsolePromise = this.openSplitConsole();
       }
 
@@ -990,17 +996,17 @@ Toolbox.prototype = {
 
   /**
    * Ensure the tool with the given id is loaded.
    *
    * @param {string} id
    *        The id of the tool to load.
    */
   loadTool: function(id) {
-    if (id === "inspector" && !this._inspector) {
+    if (id === "inspector" && !this._initInspector) {
       return this.initInspector().then(() => {
         return this.loadTool(id);
       });
     }
 
     let deferred = promise.defer();
     let iframe = this.doc.getElementById("toolbox-panel-iframe-" + id);
 
@@ -1197,17 +1203,19 @@ Toolbox.prototype = {
 
   /**
    * Focus a tool's panel by id
    * @param  {string} id
    *         The id of tool to focus
    */
   focusTool: function(id) {
     let iframe = this.doc.getElementById("toolbox-panel-iframe-" + id);
-    iframe.focus();
+    if (iframe) {
+      iframe.focus();
+    }
   },
 
   /**
    * Focus split console's input line
    */
   focusConsoleInput: function() {
     let consolePanel = this.getPanel("webconsole");
     if (consolePanel) {
@@ -1586,17 +1594,16 @@ Toolbox.prototype = {
 
   /**
    * Initialize the inspector/walker/selection/highlighter fronts.
    * Returns a promise that resolves when the fronts are initialized
    */
   initInspector: function() {
     if (!this._initInspector) {
       this._initInspector = Task.spawn(function*() {
-        this._inspector = InspectorFront(this._target.client, this._target.form);
         this._walker = yield this._inspector.getWalker(
           {showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent")}
         );
         this._selection = new Selection(this._walker);
 
         if (this.highlighterUtils.isRemoteHighlightable()) {
           this.walker.on("highlighter-ready", this._highlighterReady);
           this.walker.on("highlighter-hide", this._highlighterHidden);
@@ -1617,16 +1624,18 @@ Toolbox.prototype = {
     if (this._destroying) {
       return this._destroying;
     }
 
     if (!this._inspector) {
       return promise.resolve();
     }
 
+    this._inspector.off("browser-toolbox-node-picked", this._browserToolboxNodePicked);
+
     let outstanding = () => {
       return Task.spawn(function*() {
         yield this.highlighterUtils.stopPicker();
         yield this._inspector.destroy();
         if (this._highlighter) {
           yield this._highlighter.destroy();
         }
         if (this._selection) {
@@ -1838,16 +1847,24 @@ Toolbox.prototype = {
     Services.obs.addObserver(leakCheckObserver, topic, false);
     this._destroyer.then(() => {
       Services.obs.removeObserver(leakCheckObserver, topic);
     });
 
     return this._destroyer;
   },
 
+  _browserToolboxNodePicked: Task.async(function*() {
+    let inspector = yield this.selectTool("inspector");
+    let nodeFront = yield this.walker.findInspectingNode();
+    if (nodeFront) {
+      inspector.selection.setNodeFront(nodeFront, "browser-context-menu");
+    }
+  }),
+
   _highlighterReady: function() {
     this.emit("highlighter-ready");
   },
 
   _highlighterHidden: function() {
     this.emit("highlighter-hide");
   },
 
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -175,24 +175,29 @@ exports.setValueSummaryLength = function
 };
 
 // When the user selects a node to inspect in e10s, the parent process
 // has a CPOW that wraps the node being inspected.  It uses the
 // message manager to send this node to the child, which stores the
 // node in gInspectingNode. Then a findInspectingNode request is sent
 // over the remote debugging protocol, and gInspectingNode is returned
 // to the parent as a NodeFront.
-var gInspectingNode = null;
+let gInspectingNode = null;
 
 // We expect this function to be called from the child.js frame script
 // when it receives the node to be inspected over the message manager.
 exports.setInspectingNode = function(val) {
   gInspectingNode = val;
 };
 
+exports.setInspectingNodeBrowserToolbox = function(val) {
+  gInspectingNode = val;
+  events.emit(exports.setInspectingNodeBrowserToolbox, "called");
+};
+
 /**
  * Server side of the node actor.
  */
 var NodeActor = exports.NodeActor = protocol.ActorClass({
   typeName: "domnode",
 
   initialize: function(walker, node) {
     protocol.Actor.prototype.initialize.call(this, null);
@@ -3439,19 +3444,29 @@ var AttributeModificationList = Class({
 })
 
 /**
  * Server side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorActor = exports.InspectorActor = protocol.ActorClass({
   typeName: "inspector",
+  events: {
+    "browser-toolbox-node-picked" : {
+      type: "browser-toolbox-node-picked",
+    },
+  },
+
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
+
+    events.on(exports.setInspectingNodeBrowserToolbox, "called", () => {
+      events.emit(this, "browser-toolbox-node-picked");
+    });
   },
 
   destroy: function () {
     protocol.Actor.prototype.destroy.call(this);
   },
 
   // Forces destruction of the actor and all its children
   // like highlighter, walker and style actors.
@@ -3650,17 +3665,16 @@ var InspectorActor = exports.InspectorAc
 /**
  * Client side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorFront = exports.InspectorFront = protocol.FrontClass(InspectorActor, {
   initialize: function(client, tabForm) {
     protocol.Front.prototype.initialize.call(this, client);
     this.actorID = tabForm.inspectorActor;
-
     // XXX: This is the first actor type in its hierarchy to use the protocol
     // library, so we're going to self-own on the client side for now.
     this.manage(this);
   },
 
   destroy: function() {
     delete this.walker;
     protocol.Front.prototype.destroy.call(this);
