# HG changeset patch
# Parent  3c23c168f2af7fe650122e74b68207bdcc188589
Backed out changeset dc33bb49347d (bug 1175702)

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -6853,34 +6853,24 @@ var gIdentityHandler = {
    * be called by onSecurityChange
    *
    * @param PRUint32 state
    * @param nsIURI uri The address for which the UI should be updated.
    */
   checkIdentity : function(state, uri) {
     let nsIWebProgressListener = Ci.nsIWebProgressListener;
 
-    // For some URIs like data: we can't get a host. URIs without a host will
-    // usually be treated as a non-secure connection if they're not on the
-    // whitelist below and don't resolve to file:// URIs internally.
-    let unknown = false;
-    try {
-      uri.host;
-    } catch (e) { unknown = true; }
-
     // Chrome URIs however get special treatment. Some chrome URIs are
     // whitelisted to provide a positive security signal to the user.
     let whitelist = /^about:(accounts|addons|app-manager|config|crashes|customizing|downloads|healthreport|home|license|newaddon|permissions|preferences|privatebrowsing|rights|sessionrestore|support|welcomeback)/i;
     let isChromeUI = uri.schemeIs("about") && whitelist.test(uri.spec);
     let mode = this.IDENTITY_MODE_UNKNOWN;
 
     if (isChromeUI) {
       mode = this.IDENTITY_MODE_CHROMEUI;
-    } else if (unknown) {
-      // Use default mode.
     } else if (state & nsIWebProgressListener.STATE_IDENTITY_EV_TOPLEVEL) {
       if (state & nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT) {
         mode = this.IDENTITY_MODE_MIXED_ACTIVE_BLOCKED_IDENTIFIED;
       } else {
         mode = this.IDENTITY_MODE_IDENTIFIED;
       }
     } else if (state & nsIWebProgressListener.STATE_IS_SECURE) {
       if (state & nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT) {
diff --git a/browser/base/content/test/general/browser_identity_UI.js b/browser/base/content/test/general/browser_identity_UI.js
--- a/browser/base/content/test/general/browser_identity_UI.js
+++ b/browser/base/content/test/general/browser_identity_UI.js
@@ -38,16 +38,17 @@ var tests = [
   {
     name: "subdomain with port",
     location: "http://sub1.test1.example.org:8000/",
     effectiveHost: "example.org"
   },
   {
     name: "subdomain HTTPS",
     location: "https://test1.example.com/",
+
     effectiveHost: "example.com",
     isHTTPS: true
   },
   {
     name: "view-source HTTPS",
     location: "view-source:https://example.com/",
     effectiveHost: null,
     isHTTPS: true
@@ -98,19 +99,17 @@ function nextTest() {
     if (!gForward)
       gTestDesc += " (second time)";
     content.location.reload(true);
   }
 }
 
 function checkResult() {
   // Sanity check other values, and the value of gIdentityHandler.getEffectiveHost()
-  is(gIdentityHandler._uri.spec, gCurrentTest.location, "location matches for test " + gTestDesc);
+  is(gIdentityHandler._lastUri.spec, gCurrentTest.location, "location matches for test " + gTestDesc);
   // getEffectiveHost can't be called for all modes
-  if (gCurrentTest.effectiveHost === null) {
-    let identityBox = document.getElementById("identity-box");
-    is(identityBox.className == gIdentityHandler.IDENTITY_MODE_UNKNOWN || identityBox.className == gIdentityHandler.IDENTITY_MODE_CHROMEUI, true, "mode matched");
-  } else {
+  if (gCurrentTest.effectiveHost === null)
+    is(gIdentityHandler._mode == gIdentityHandler.IDENTITY_MODE_UNKNOWN || gIdentityHandler._mode == gIdentityHandler.IDENTITY_MODE_CHROMEUI, true, "mode matched");
+  else
     is(gIdentityHandler.getEffectiveHost(), gCurrentTest.effectiveHost, "effectiveHost matches for test " + gTestDesc);
-  }
 
   executeSoon(nextTest);
 }
