# HG changeset patch
# Parent d50f590056fdca521a53af8562e3aee754b6c863
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 918884 - Implement a method to get the DOM element that owns a docshell

diff --git a/browser/devtools/inspector/test/Makefile.in b/browser/devtools/inspector/test/Makefile.in
--- a/browser/devtools/inspector/test/Makefile.in
+++ b/browser/devtools/inspector/test/Makefile.in
@@ -38,10 +38,12 @@ MOCHITEST_BROWSER_FILES := \
 		browser_inspector_bug_835722_infobar_reappears.js \
 		browser_inspector_bug_840156_destroy_after_navigation.js \
 		browser_inspector_reload.js \
 		browser_inspector_navigation.js \
 		browser_inspector_select_last_selected.js \
 		browser_inspector_select_last_selected.html \
 		browser_inspector_select_last_selected2.html \
 		browser_inspector_basic_highlighter.js \
+		browser_inspector_frames.html \
+		browser_inspector_frames.js \
 		head.js \
 		$(NULL)
diff --git a/browser/devtools/inspector/test/browser_inspector_frames.html b/browser/devtools/inspector/test/browser_inspector_frames.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_frames.html
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+<head>
+  <title>Inspector Frames Test</title>
+</head>
+<body>
+  <h1>Inspector Frames Test</h1>
+
+  <iframe id="iframe-blank"  src="about:blank"></iframe>
+
+  <iframe id="iframe-data-url" src="data:text/html;charset=utf-8,%3Chtml%3E%3Cbody%3Eiframe%3C/body%3E%3C/html%3E"></iframe>
+
+  <object id="object-data-url" type="text/html" data="data:text/html;charset=utf-8,%3Chtml%3E%3Cbody%3Eobject%3C/body%3E%3C/html%3E"></object>
+
+</body>
diff --git a/browser/devtools/inspector/test/browser_inspector_frames.js b/browser/devtools/inspector/test/browser_inspector_frames.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_frames.js
@@ -0,0 +1,68 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+function test() {
+  let inspector, toolbox;
+
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function onload() {
+    gBrowser.selectedBrowser.removeEventListener("load", onload, true);
+    waitForFocus(function() {
+      let target = TargetFactory.forTab(gBrowser.selectedTab);
+      gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
+        startInspectorTests(toolbox);
+      }).then(null, console.error);
+    }, content);
+  }, true);
+
+  content.location = "http://mochi.test:8888/browser/browser/devtools/" +
+                     "inspector/test/browser_inspector_frames.html";
+
+  function getWindowUtils(window)
+  {
+    return window.
+      QueryInterface(Components.interfaces.nsIInterfaceRequestor).
+      getInterface(Components.interfaces.nsIDOMWindowUtils);
+  }
+
+  function startInspectorTests(aToolbox)
+  {
+    toolbox = aToolbox;
+    inspector = toolbox.getCurrentPanel();
+    info("Inspector started");
+
+    let windowUtils = getWindowUtils(content);
+    is (content, gBrowser, "Container element for main window is xul:browser");
+
+    let iframeBlank = content.document.querySelector("#iframe-blank");
+    ok (iframeBlank, "Iframe exists on page");
+    let iframeBlankUtils = getWindowUtils(iframeBlank.contentWindow);
+    is (iframeBlankUtils.getContainerElement(), iframeBlank, "Container element for iframe window is iframe");
+
+    let iframeDataUrl = content.document.querySelector("#iframe-data-url");
+    ok (iframeDataUrl, "Iframe exists on page");
+    let iframeDataUrlUtils = getWindowUtils(iframeDataUrl.contentWindow);
+    is (iframeDataUrlUtils.getContainerElement(), iframeDataUrl, "Container element for iframe window is iframe");
+
+    let objectDataUrl = content.document.querySelector("#object-data-url");
+    ok (objectDataUrl, "Object exists on page");
+    let objectDataUrlUtils = getWindowUtils(objectDataUrl.contentWindow);
+    is (objectDataUrlUtils.getContainerElement(), objectDataUrl, "Container element for object window is the object");
+
+    finishUp();
+  }
+  function finishUp()
+  {
+    toolbox.destroy();
+    gBrowser.removeCurrentTab();
+    finish();
+  }
+}
+
+
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -2530,16 +2530,29 @@ nsDOMWindowUtils::GetOuterWindowWithId(u
                                   "GetWindowWithOuterIdWarning");
 
   *aWindow = nsGlobalWindow::GetOuterWindowWithId(aWindowID);
   NS_IF_ADDREF(*aWindow);
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsDOMWindowUtils::GetContainerElement(nsIDOMElement** aResult)
+{
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  nsCOMPtr<nsIDOMElement> element =
+    do_QueryInterface(window->GetFrameElementInternal());
+
+  CallQueryInterface(element, aResult);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsDOMWindowUtils::WrapDOMFile(nsIFile *aFile,
                               nsIDOMFile **aDOMFile)
 {
   if (!nsContentUtils::IsCallerChrome()) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   if (!aFile) {
diff --git a/dom/interfaces/base/nsIDOMWindowUtils.idl b/dom/interfaces/base/nsIDOMWindowUtils.idl
--- a/dom/interfaces/base/nsIDOMWindowUtils.idl
+++ b/dom/interfaces/base/nsIDOMWindowUtils.idl
@@ -38,17 +38,17 @@ interface nsIDOMFile;
 interface nsIFile;
 interface nsIDOMTouch;
 interface nsIDOMClientRect;
 interface nsIURI;
 interface nsIDOMEventTarget;
 interface nsIRunnable;
 interface nsICompositionStringSynthesizer;
 
-[scriptable, uuid(a1383ae5-e828-4c9a-929d-5293e61beb64)]
+[scriptable, uuid(750a47b6-8bdb-4cad-ba2c-b7d3e66d8021)]
 interface nsIDOMWindowUtils : nsISupports {
 
   /**
    * Image animation mode of the window. When this attribute's value
    * is changed, the implementation should set all images in the window
    * to the given value. That is, when set to kDontAnimMode, all images
    * will stop animating. The attribute's value must be one of the
    * animationMode values from imgIContainer.
@@ -1082,16 +1082,22 @@ interface nsIDOMWindowUtils : nsISupport
   readonly attribute float displayDPI;
 
   /**
    * Return the outer window with the given ID, if any.  Can return null.
    * @deprecated Use nsIWindowMediator.getOuterWindowWithId.  See bug 865664.
    */
   nsIDOMWindow getOuterWindowWithId(in unsigned long long aOuterWindowID);
 
+  /**
+   * Return the DOM Element that owns this docshell.  If this is the top level
+   * content docshell, returns the <xul:browser>.
+   */
+  nsIDOMElement getContainerElement();
+
   [noscript] void RenderDocument(in nsConstRect aRect,
                                  in uint32_t aFlags,
                                  in nscolor aBackgroundColor,
                                  in gfxContext aThebesContext);
 
   /**
    * advanceTimeAndRefresh allows the caller to take over the refresh
    * driver timing for a window.  A call to advanceTimeAndRefresh does
