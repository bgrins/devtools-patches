# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4c4abe35d80851590954b52eabf828c763104696
Bug XXX - Migrate browser.xul to xhtml

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -1,15 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 @namespace html url("http://www.w3.org/1999/xhtml");
 
+#main-window {
+  -moz-box-orient: vertical;
+}
+
 :root {
   --panelui-subview-transition-duration: 150ms;
   --lwt-additional-images: none;
   --lwt-background-alignment: right top;
   --lwt-background-tiling: no-repeat;
 }
 
 :root:-moz-lwtheme {
diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xhtml
rename from browser/base/content/browser.xul
rename to browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xhtml
@@ -22,26 +22,26 @@
 <?xml-stylesheet href="chrome://browser/skin/downloads/downloads.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/searchbar.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/places/places.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/places/editBookmark.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/compacttheme.css" type="text/css" alternate="yes" title="Light/Dark"?>
 
 # All DTD information is stored in a separate file so that it can be shared by
 # hiddenWindow.xul.
-<!DOCTYPE window [
+<!DOCTYPE html [
 #include browser-doctype.inc
 ]>
 
-<window id="main-window"
+<html id="main-window"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         onload="gBrowserInit.onLoad()" onunload="gBrowserInit.onUnload()" onclose="return WindowIsClosing();"
         title="&mainWindow.title;"
         title_normal="&mainWindow.title;"
 #ifdef XP_MACOSX
         title_privatebrowsing="&mainWindow.title;&mainWindow.titlemodifiermenuseparator;&mainWindow.titlePrivateBrowsingSuffix;"
         titledefault="&mainWindow.title;"
         titlemodifier=""
         titlemodifier_normal=""
@@ -67,17 +67,17 @@
         retargetdocumentfocus="urlbar"
         persist="screenX screenY width height sizemode">
 
 # All JS files which are needed by browser.xul and other top level windows to
 # support MacOS specific features *must* go into the global-scripts.inc file so
 # that they can be shared with macWindow.inc.xul.
 #include global-scripts.inc
 
-<script type="application/javascript">
+<script type="text/javascript" xmlns="http://www.w3.org/1999/xhtml">
   Services.scriptloader.loadSubScript("chrome://global/content/contentAreaUtils.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/tabbrowser.js", this);
 </script>
 
 # All sets except for popupsets (commands, keys, stringbundles and broadcasters)
 # *must* go into the browser-sets.inc file so that they can be shared with other
 # top level windows in macWindow.inc.xul.
 #include browser-sets.inc
@@ -1309,9 +1309,9 @@
       &pointerlockWarning.generic.label;
     </html:div>
   </html:div>
 
   <vbox id="browser-bottombox" layer="true">
     <notificationbox id="global-notificationbox" notificationside="bottom"/>
   </vbox>
 
-</window>
+</html>
diff --git a/browser/base/content/global-scripts.inc b/browser/base/content/global-scripts.inc
--- a/browser/base/content/global-scripts.inc
+++ b/browser/base/content/global-scripts.inc
@@ -2,17 +2,17 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 # If you update this list, you may need to add a mapping within the following
 # file so that ESLint works correctly:
 # tools/lint/eslint/eslint-plugin-mozilla/lib/environments/browser-window.js
 
-<script type="application/javascript">
+<script type="text/javascript" xmlns="http://www.w3.org/1999/xhtml">
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 for (let script of [
   "chrome://browser/content/browser.js",
 
   "chrome://browser/content/browser-captivePortal.js",
   "chrome://browser/content/browser-compacttheme.js",
   "chrome://browser/content/browser-feeds.js",
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -192,17 +192,17 @@ window._gBrowser = {
 
   get tabContainer() {
     delete this.tabContainer;
     return this.tabContainer = document.getElementById("tabbrowser-tabs");
   },
 
   get tabs() {
     delete this.tabs;
-    return this.tabs = this.tabContainer.childNodes;
+    return this.tabs = this.tabContainer.children;
   },
 
   get tabbox() {
     delete this.tabbox;
     return this.tabbox = document.getElementById("tabbrowser-tabbox");
   },
 
   get tabpanels() {
@@ -300,17 +300,17 @@ window._gBrowser = {
     for (let attribute in this._defaultBrowserAttributes) {
       this._defaultBrowserAttributes[attribute] = browser.getAttribute(attribute);
     }
 
     let tab = this.tabs[0];
     this._selectedTab = tab;
 
     let uniqueId = this._generateUniquePanelID();
-    this.tabpanels.childNodes[0].id = uniqueId;
+    this.tabpanels.children[0].id = uniqueId;
     tab.linkedPanel = uniqueId;
     tab.permanentKey = browser.permanentKey;
     tab._tPos = 0;
     tab._fullyOpen = true;
     tab.linkedBrowser = browser;
     this._tabForBrowser.set(browser, tab);
 
     // Hook the browser up with a progress listener.
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -10,17 +10,17 @@
           xmlns:xbl="http://www.mozilla.org/xbl">
 
   <binding id="tabbrowser-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
     <implementation>
       <!-- Override scrollbox.xml method, since our scrollbox's children are
            inherited from the binding parent -->
       <method name="_getScrollableElements">
         <body><![CDATA[
-          return Array.filter(document.getBindingParent(this).childNodes,
+          return Array.filter(document.getBindingParent(this).children,
                               this._canScrollToElement, this);
         ]]></body>
       </method>
       <method name="_canScrollToElement">
         <parameter name="tab"/>
         <body><![CDATA[
           return !tab._pinnedUnscrollable && !tab.hidden;
         ]]></body>
@@ -104,17 +104,17 @@
         <![CDATA[
           this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
           this._hiddenSoundPlayingTabs = new Set();
 
           let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
               "emptyPrivateTabTitle" : "emptyTabTitle";
           this.emptyTabTitle = gTabBrowserBundle.GetStringFromName("tabs." + strId);
 
-          var tab = this.firstChild;
+          var tab = this.firstElementChild;
           tab.label = this.emptyTabTitle;
 
           window.addEventListener("resize", this);
 
           Services.prefs.addObserver("privacy.userContext", this);
           this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
 
           XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
@@ -246,17 +246,17 @@
           return document.documentElement.getAttribute("customizing") == "true";
         ]]></getter>
       </property>
 
       <method name="_getVisibleTabs">
         <body><![CDATA[
           // Cannot access gBrowser before it's initialized.
           if (!gBrowser) {
-            return [ this.firstChild ];
+            return [ this.firstElementChild ];
           }
 
           return gBrowser.visibleTabs;
         ]]></body>
       </method>
 
       <method name="_setPositionalAttributes">
         <body><![CDATA[
@@ -512,34 +512,34 @@
 
             let layoutData = this._pinnedTabsLayoutCache;
             let uiDensity = document.documentElement.getAttribute("uidensity");
             if (!layoutData ||
                 layoutData.uiDensity != uiDensity) {
               let arrowScrollbox = this.arrowScrollbox;
               layoutData = this._pinnedTabsLayoutCache = {
                 uiDensity,
-                pinnedTabWidth: this.childNodes[0].getBoundingClientRect().width,
+                pinnedTabWidth: this.children[0].getBoundingClientRect().width,
                 scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width
               };
             }
 
             let width = 0;
             for (let i = numPinned - 1; i >= 0; i--) {
-              let tab = this.childNodes[i];
+              let tab = this.children[i];
               width += layoutData.pinnedTabWidth;
               tab.style.marginInlineStart = -(width + layoutData.scrollButtonWidth) + "px";
               tab._pinnedUnscrollable = true;
             }
             this.style.paddingInlineStart = width + "px";
           } else {
             this.removeAttribute("positionpinnedtabs");
 
             for (let i = 0; i < numPinned; i++) {
-              let tab = this.childNodes[i];
+              let tab = this.children[i];
               tab.style.marginInlineStart = "";
               tab._pinnedUnscrollable = false;
             }
 
             this.style.paddingInlineStart = "";
           }
 
           if (this._lastNumPinned != numPinned) {
@@ -755,17 +755,17 @@
           return tab;
         ]]></body>
       </method>
 
       <method name="_getDropIndex">
         <parameter name="event"/>
         <parameter name="isLink"/>
         <body><![CDATA[
-          var tabs = this.childNodes;
+          var tabs = this.children;
           var tab = this._getDragTargetTab(event, isLink);
           if (window.getComputedStyle(this).direction == "ltr") {
             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
               if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                 return i;
           } else {
             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
               if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
@@ -854,17 +854,17 @@
         <body>
         <![CDATA[
           if (!aTab) {
             return null;
           }
 
           // Cannot access gBrowser before it's initialized.
           if (!gBrowser) {
-            return this.tabbox.tabpanels.firstChild;
+            return this.tabbox.tabpanels.firstElementChild;
           }
 
           // If the tab's browser is lazy, we need to `_insertBrowser` in order
           // to have a linkedPanel.  This will also serve to bind the browser
           // and make it ready to use when the tab is selected.
           gBrowser._insertBrowser(aTab);
           return document.getElementById(aTab.linkedPanel);
         ]]>
@@ -1307,24 +1307,24 @@
           let maxMargin = Math.min(minMargin + scrollRect.width,
                                    scrollRect.right);
           if (!ltr)
             [minMargin, maxMargin] = [this.clientWidth - maxMargin,
                                       this.clientWidth - minMargin];
           newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
         } else {
           let newIndex = this._getDropIndex(event, effects == "link");
-          if (newIndex == this.childNodes.length) {
-            let tabRect = this.childNodes[newIndex - 1].getBoundingClientRect();
+          if (newIndex == this.children.length) {
+            let tabRect = this.children[newIndex - 1].getBoundingClientRect();
             if (ltr)
               newMargin = tabRect.right - rect.left;
             else
               newMargin = rect.right - tabRect.left;
           } else {
-            let tabRect = this.childNodes[newIndex].getBoundingClientRect();
+            let tabRect = this.children[newIndex].getBoundingClientRect();
             if (ltr)
               newMargin = tabRect.left - rect.left;
             else
               newMargin = rect.right - tabRect.right;
           }
         }
 
         ind.collapsed = false;
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -23,17 +23,17 @@ browser.jar:
         content/browser/aboutNetError-new.xhtml        (content/aboutNetError-new.xhtml)
         content/browser/aboutRobots-icon.png          (content/aboutRobots-icon.png)
         content/browser/aboutRobots-widget-left.png   (content/aboutRobots-widget-left.png)
         content/browser/aboutTabCrashed.css           (content/aboutTabCrashed.css)
         content/browser/aboutTabCrashed.js            (content/aboutTabCrashed.js)
         content/browser/aboutTabCrashed.xhtml         (content/aboutTabCrashed.xhtml)
 *       content/browser/browser.css                   (content/browser.css)
         content/browser/browser.js                    (content/browser.js)
-*       content/browser/browser.xul                   (content/browser.xul)
+*       content/browser/browser.xhtml                 (content/browser.xhtml)
         content/browser/browser-addons.js             (content/browser-addons.js)
         content/browser/browser-allTabsMenu.js        (content/browser-allTabsMenu.js)
         content/browser/browser-captivePortal.js      (content/browser-captivePortal.js)
         content/browser/browser-ctrlTab.js            (content/browser-ctrlTab.js)
         content/browser/browser-customization.js      (content/browser-customization.js)
         content/browser/browser-data-submission-info-bar.js (content/browser-data-submission-info-bar.js)
         content/browser/browser-compacttheme.js       (content/browser-compacttheme.js)
 #ifndef MOZILLA_OFFICIAL
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -786,17 +786,17 @@ var CustomizableUIInternal = {
     // through a migration path (bug 938980) or an add-on.
     if (aArea == CustomizableUI.AREA_NAVBAR) {
       aAreaNode.collapsed = false;
     }
 
     this.beginBatchUpdate();
 
     try {
-      let currentNode = container.firstChild;
+      let currentNode = container.firstElementChild;
       let placementsToRemove = new Set();
       for (let id of aPlacements) {
         while (currentNode && currentNode.getAttribute("skipintoolbarset") == "true") {
           currentNode = currentNode.nextSibling;
         }
 
         // Fix ids for specials and continue, for correctly placed specials.
         if (currentNode && (!currentNode.id || CustomizableUI.isSpecialWidget(currentNode)) &&
@@ -4460,17 +4460,17 @@ OverflowableToolbar.prototype = {
 
       if (child.getAttribute("overflows") != "false") {
         this._collapsed.set(child.id, this._target.clientWidth);
         child.setAttribute("overflowedItem", true);
         child.setAttribute("cui-anchorid", this._chevron.id);
         CustomizableUIInternal.ensureButtonContextMenu(child, this._toolbar, true);
         CustomizableUIInternal.notifyListeners("onWidgetOverflow", child, this._target);
 
-        this._list.insertBefore(child, this._list.firstChild);
+        this._list.insertBefore(child, this._list.firstElementChild);
         if (!this._addedListener) {
           CustomizableUI.addListener(this);
         }
         if (!CustomizableUI.isSpecialWidget(child.id)) {
           this._toolbar.setAttribute("overflowing", "true");
         }
       }
       child = prevChild;
@@ -4511,18 +4511,18 @@ OverflowableToolbar.prototype = {
    *        While there are items in the list, this width won't change, and so
    *        we can avoid flushing layout by providing it and/or caching it.
    *        Note that if `shouldMoveAllItems` is true, we never need the width
    *        anyway.
    */
   _moveItemsBackToTheirOrigin(shouldMoveAllItems, targetWidth) {
     let placements = gPlacements.get(this._toolbar.id);
     let win = this._target.ownerGlobal;
-    while (this._list.firstChild) {
-      let child = this._list.firstChild;
+    while (this._list.firstElementChild) {
+      let child = this._list.firstElementChild;
       let minSize = this._collapsed.get(child.id);
 
       if (!shouldMoveAllItems && minSize) {
         if (!targetWidth) {
           let dwu = win.windowUtils;
           targetWidth = Math.floor(dwu.getBoundsWithoutFlushing(this._target).width);
         }
         if (targetWidth <= minSize) {
@@ -4743,17 +4743,17 @@ OverflowableToolbar.prototype = {
   _hideTimeoutId: null,
   _showWithTimeout() {
     this.show().then(() => {
       let window = this._toolbar.ownerGlobal;
       if (this._hideTimeoutId) {
         window.clearTimeout(this._hideTimeoutId);
       }
       this._hideTimeoutId = window.setTimeout(() => {
-        if (!this._panel.firstChild.matches(":hover")) {
+        if (!this._panel.firstElementChild.matches(":hover")) {
           PanelMultiView.hidePopup(this._panel);
         }
       }, OVERFLOW_PANEL_HIDE_DELAY_MS);
     });
   },
 };
 
 CustomizableUIInternal.initialize();
diff --git a/browser/components/customizableui/PanelMultiView.jsm b/browser/components/customizableui/PanelMultiView.jsm
--- a/browser/components/customizableui/PanelMultiView.jsm
+++ b/browser/components/customizableui/PanelMultiView.jsm
@@ -1198,17 +1198,18 @@ var PanelView = class extends Associated
     }
   }
 
   /**
    * Adds a header with the given title, or removes it if the title is empty.
    */
   set headerText(value) {
     // If the header already exists, update or remove it as requested.
-    let header = this.node.firstChild;
+    let header = this.node.firstElementChild;
+    console.log(header, this.node);
     if (header && header.classList.contains("panel-header")) {
       if (value) {
         header.querySelector("label").setAttribute("value", value);
       } else {
         header.remove();
       }
       return;
     }
diff --git a/browser/components/customizableui/content/toolbar.xml b/browser/components/customizableui/content/toolbar.xml
--- a/browser/components/customizableui/content/toolbar.xml
+++ b/browser/components/customizableui/content/toolbar.xml
@@ -25,17 +25,17 @@
                 toolbox.palette = node;
                 toolbox.removeChild(node);
                 break;
               }
             }
           }
 
           // pass the current set of children for comparison with placements:
-          let children = Array.from(this.childNodes)
+          let children = Array.from(this.children)
                               .filter(node => node.getAttribute("skipintoolbarset") != "true" && node.id)
                               .map(node => node.id);
           CustomizableUI.registerToolbarNode(this, children);
       ]]></constructor>
 
       <method name="insertItem">
         <parameter name="aId"/>
         <parameter name="aBeforeElt"/>
diff --git a/browser/modules/AsyncTabSwitcher.jsm b/browser/modules/AsyncTabSwitcher.jsm
--- a/browser/modules/AsyncTabSwitcher.jsm
+++ b/browser/modules/AsyncTabSwitcher.jsm
@@ -409,17 +409,17 @@ class AsyncTabSwitcher {
     if (this.visibleTab !== showTab) {
       this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
       this.visibleTab = showTab;
 
       this.maybeVisibleTabs.add(showTab);
 
       let tabpanels = this.tabbrowser.tabpanels;
       let showPanel = this.tabbrowser.tabContainer.getRelatedElement(showTab);
-      let index = Array.indexOf(tabpanels.childNodes, showPanel);
+      let index = Array.indexOf(tabpanels.children, showPanel);
       if (index != -1) {
         this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
         tabpanels.setAttribute("selectedIndex", index);
         if (showTab === this.requestedTab) {
           if (this._requestingTab) {
             /*
              * If _requestingTab is set, that means that we're switching the
              * visibility of the tab synchronously, and we need to wait for
diff --git a/devtools/startup/devtools-startup.js b/devtools/startup/devtools-startup.js
--- a/devtools/startup/devtools-startup.js
+++ b/devtools/startup/devtools-startup.js
@@ -25,16 +25,18 @@ const kDebuggerPrefs = [
   "devtools.debugger.remote-enabled",
   "devtools.chrome.enabled"
 ];
 
 const DEVTOOLS_ENABLED_PREF = "devtools.enabled";
 
 const DEVTOOLS_POLICY_DISABLED_PREF = "devtools.policy.disabled";
 
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
 const { XPCOMUtils } = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm", {});
 
 ChromeUtils.defineModuleGetter(this, "Services",
                                "resource://gre/modules/Services.jsm");
 ChromeUtils.defineModuleGetter(this, "AppConstants",
                                "resource://gre/modules/AppConstants.jsm");
 ChromeUtils.defineModuleGetter(this, "CustomizableUI",
                                "resource:///modules/CustomizableUI.jsm");
@@ -564,17 +566,17 @@ DevToolsStartup.prototype = {
     const doc = window.document;
 
     // hookKeyShortcuts can be called both from hookWindow and from the developer toggle
     // onBeforeCreated. Make sure shortcuts are only added once per window.
     if (doc.getElementById("devtoolsKeyset")) {
       return;
     }
 
-    const keyset = doc.createElement("keyset");
+    const keyset = doc.createElementNS(XUL_NS, "keyset");
     keyset.setAttribute("id", "devtoolsKeyset");
 
     for (const key of KeyShortcuts) {
       const xulKey = this.createKey(doc, key, () => this.onKey(window, key));
       keyset.appendChild(xulKey);
     }
 
     // Appending a <key> element is not always enough. The <keyset> needs
@@ -596,17 +598,17 @@ DevToolsStartup.prototype = {
       const require = this.initDevTools("KeyShortcut", key);
       const { gDevToolsBrowser } = require("devtools/client/framework/devtools-browser");
       gDevToolsBrowser.onKeyShortcut(window, key, startTime);
     }
   },
 
   // Create a <xul:key> DOM Element
   createKey(doc, { id, toolId, shortcut, modifiers: mod }, oncommand) {
-    const k = doc.createElement("key");
+    const k = doc.createElementNS(XUL_NS, "key");
     k.id = "key_" + (id || toolId);
 
     if (shortcut.startsWith("VK_")) {
       k.setAttribute("keycode", shortcut);
     } else {
       k.setAttribute("key", shortcut);
     }
 
diff --git a/toolkit/components/processsingleton/MainProcessSingleton.js b/toolkit/components/processsingleton/MainProcessSingleton.js
--- a/toolkit/components/processsingleton/MainProcessSingleton.js
+++ b/toolkit/components/processsingleton/MainProcessSingleton.js
@@ -73,16 +73,39 @@ MainProcessSingleton.prototype = {
     }
 
     case "document-element-inserted":
       // Set up Custom Elements for XUL windows before anything else happens
       // in the document. Anything loaded here should be considered part of
       // core XUL functionality. Any window-specific elements can be registered
       // via <script> tags at the top of individual documents.
       const doc = subject;
+
+      // XXX: Shim some XUL document stuff onto HTML:
+      if (doc.nodePrincipal.isSystemPrincipal &&
+          doc.contentType == "application/xhtml+xml") {
+        doc.commandDispatcher = {
+          get focusedElement() {
+
+          },
+          get focusedWindow() {
+
+          },
+          addCommandUpdater: () => {},
+          removeCommandUpdater: () => {},
+          updateCommands: () => {},
+          getControllerForCommand: () => {},
+          getControllers: () => {},
+          advanceFocus: () => {},
+          rewindFocus: () => {},
+          advanceFocusIntoSubtree: () => {},
+          lock: () => {},
+          unlock: () => {},
+        };
+      }
       if (doc.nodePrincipal.isSystemPrincipal &&
           doc.contentType == "application/vnd.mozilla.xul+xml") {
         Services.scriptloader.loadSubScript(
           "chrome://global/content/customElements.js", doc.ownerGlobal);
       }
       break;
 
     case "xpcom-shutdown":
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -65,17 +65,17 @@
             if (this.currentIndex > -1)
               this._currentIndex = this.currentIndex + 1;
 
             var event = document.createEvent("Events");
             event.initEvent("select", true, true);
             this.dispatchEvent(event);
 
             // always call this (allows a commandupdater without controller)
-            document.commandDispatcher.updateCommands("richlistbox-select");
+            document.commandDispatcher && document.commandDispatcher.updateCommands("richlistbox-select");
           ]]>
         </body>
       </method>
 
       <!-- We override base-listbox here because those methods don't take dir
            into account on listbox (which doesn't support dir yet) -->
       <method name="getNextItem">
         <parameter name="aStartItem"/>
diff --git a/toolkit/content/widgets/tabbox.xml b/toolkit/content/widgets/tabbox.xml
--- a/toolkit/content/widgets/tabbox.xml
+++ b/toolkit/content/widgets/tabbox.xml
@@ -238,17 +238,17 @@
           this.setAttribute("orient", "horizontal");
 
         if (this.tabbox && this.tabbox.hasAttribute("selectedIndex")) {
           let selectedIndex = parseInt(this.tabbox.getAttribute("selectedIndex"));
           this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;
           return;
         }
 
-        var children = this.childNodes;
+        var children = this.children;
         var length = children.length;
         for (var i = 0; i < length; i++) {
           if (children[i].getAttribute("selected") == "true") {
             this.selectedIndex = i;
             return;
           }
         }
 
@@ -296,30 +296,30 @@
                                                              linkedPanelId);
 
             return ownerDoc.getElementById(linkedPanelId);
           }
 
           // otherwise linked tabpanel element has the same index as the given
           // tab element.
           let tabElmIdx = this.getIndexOfItem(aTabElm);
-          return tabpanelsElm.childNodes[tabElmIdx];
+          return tabpanelsElm.children[tabElmIdx];
         ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULSelectControlElement -->
       <property name="itemCount" readonly="true"
-                onget="return this.childNodes.length"/>
+                onget="return this.children.length"/>
 
       <property name="value" onget="return this.getAttribute('value');">
         <setter>
           <![CDATA[
             this.setAttribute("value", val);
-            var children = this.childNodes;
+            var children = this.children;
             for (var c = children.length - 1; c >= 0; c--) {
               if (children[c].value == val) {
                 this.selectedIndex = c;
                 break;
               }
             }
             return val;
           ]]>
@@ -350,30 +350,30 @@
       <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->
       <field name="_tabbox" readonly="true"><![CDATA[
         this.tabbox;
       ]]></field>
 
       <property name="selectedIndex">
         <getter>
         <![CDATA[
-          const tabs = this.childNodes;
+          const tabs = this.children;
           for (var i = 0; i < tabs.length; i++) {
             if (tabs[i].selected)
               return i;
           }
           return -1;
         ]]>
         </getter>
 
         <setter>
         <![CDATA[
           var tab = this.getItemAtIndex(val);
           if (tab) {
-            Array.forEach(this.childNodes, function(aTab) {
+            Array.forEach(this.children, function(aTab) {
               if (aTab.selected && aTab != tab)
                 aTab._selected = false;
             });
             tab._selected = true;
 
             this.setAttribute("value", tab.value);
 
             let linkedPanel = this.getRelatedElement(tab);
@@ -388,17 +388,17 @@
           return val;
         ]]>
         </setter>
       </property>
 
       <property name="selectedItem">
         <getter>
         <![CDATA[
-          const tabs = this.childNodes;
+          const tabs = this.children;
           for (var i = 0; i < tabs.length; i++) {
             if (tabs[i].selected)
               return tabs[i];
           }
           return null;
         ]]>
         </getter>
 
@@ -412,42 +412,42 @@
         ]]>
         </setter>
       </property>
 
       <method name="getIndexOfItem">
         <parameter name="item"/>
         <body>
         <![CDATA[
-          return Array.indexOf(this.childNodes, item);
+          return Array.indexOf(this.children, item);
         ]]>
         </body>
       </method>
 
       <method name="getItemAtIndex">
         <parameter name="index"/>
         <body>
         <![CDATA[
-          return this.childNodes.item(index);
+          return this.children.item(index);
         ]]>
         </body>
       </method>
 
       <method name="_selectNewTab">
         <parameter name="aNewTab"/>
         <parameter name="aFallbackDir"/>
         <parameter name="aWrap"/>
         <body>
         <![CDATA[
           var requestedTab = aNewTab;
           while (aNewTab.hidden || aNewTab.disabled || !this._canAdvanceToTab(aNewTab)) {
             aNewTab = aFallbackDir == -1 ? aNewTab.previousSibling : aNewTab.nextSibling;
             if (!aNewTab && aWrap)
-              aNewTab = aFallbackDir == -1 ? this.childNodes[this.childNodes.length - 1] :
-                                             this.childNodes[0];
+              aNewTab = aFallbackDir == -1 ? this.children[this.children.length - 1] :
+                                             this.children[0];
             if (!aNewTab || aNewTab == requestedTab)
               return;
           }
 
           var isTabFocused = false;
           try {
             isTabFocused =
               (document.commandDispatcher.focusedElement == this.selectedItem);
@@ -489,18 +489,18 @@
       <method name="advanceSelectedTab">
         <parameter name="aDir"/>
         <parameter name="aWrap"/>
         <body>
         <![CDATA[
           var startTab = this.selectedItem;
           var next = startTab[aDir == -1 ? "previousSibling" : "nextSibling"];
           if (!next && aWrap) {
-            next = aDir == -1 ? this.childNodes[this.childNodes.length - 1] :
-                                this.childNodes[0];
+            next = aDir == -1 ? this.children[this.children.length - 1] :
+                                this.children[0];
           }
           if (next && next != startTab) {
             this._selectNewTab(next, aDir, aWrap);
           }
         ]]>
         </body>
       </method>
 
@@ -552,21 +552,21 @@
             return null;
 
           let tabsElm = tabboxElm.tabs;
           if (!tabsElm)
             return null;
 
           // Return tab element having 'linkedpanel' attribute equal to the id
           // of the tab panel or the same index as the tab panel element.
-          let tabpanelIdx = Array.indexOf(this.childNodes, aTabPanelElm);
+          let tabpanelIdx = Array.indexOf(this.children, aTabPanelElm);
           if (tabpanelIdx == -1)
             return null;
 
-          let tabElms = tabsElm.childNodes;
+          let tabElms = tabsElm.children;
           let tabElmFromIndex = tabElms[tabpanelIdx];
 
           let tabpanelId = aTabPanelElm.id;
           if (tabpanelId) {
             for (let idx = 0; idx < tabElms.length; idx++) {
               var tabElm = tabElms[idx];
               if (tabElm.linkedPanel == tabpanelId)
                 return tabElm;
@@ -595,38 +595,38 @@
             }
             parent = parent.parentNode;
           }
 
           return this._tabbox = parent;
         ]]></getter>
       </property>
 
-      <field name="_selectedPanel">this.childNodes.item(this.selectedIndex)</field>
+      <field name="_selectedPanel">this.children.item(this.selectedIndex)</field>
 
       <property name="selectedIndex">
         <getter>
         <![CDATA[
           var indexStr = this.getAttribute("selectedIndex");
           return indexStr ? parseInt(indexStr) : -1;
         ]]>
         </getter>
 
         <setter>
         <![CDATA[
-          if (val < 0 || val >= this.childNodes.length)
+          if (val < 0 || val >= this.children.length)
             return val;
 
           // Give the tabbrowser a chance to run logic regardless of
           // whether the panel is going to change:
           this.dispatchEvent(new CustomEvent("preselect",
-            { detail: this.getRelatedElement(this.childNodes[val]) }));
+            { detail: this.getRelatedElement(this.children[val]) }));
 
           var panel = this._selectedPanel;
-          this._selectedPanel = this.childNodes[val];
+          this._selectedPanel = this.children[val];
           this.setAttribute("selectedIndex", val);
           if (this._selectedPanel != panel) {
             var event = document.createEvent("Events");
             event.initEvent("select", true, true);
             this.dispatchEvent(event);
           }
           return val;
         ]]>
@@ -786,22 +786,22 @@
       <handler event="keydown" keycode="VK_DOWN" group="system" preventdefault="true">
       <![CDATA[
         this.parentNode.advanceSelectedTab(1, this.arrowKeysShouldWrap);
       ]]>
       </handler>
 
       <handler event="keydown" keycode="VK_HOME" group="system" preventdefault="true">
       <![CDATA[
-        this.parentNode._selectNewTab(this.parentNode.childNodes[0]);
+        this.parentNode._selectNewTab(this.parentNode.children[0]);
       ]]>
       </handler>
 
       <handler event="keydown" keycode="VK_END" group="system" preventdefault="true">
       <![CDATA[
-        var tabs = this.parentNode.childNodes;
+        var tabs = this.parentNode.children;
         this.parentNode._selectNewTab(tabs[tabs.length - 1], -1);
       ]]>
       </handler>
     </handlers>
   </binding>
 
 </bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -85,16 +85,17 @@ iframe {
 }
 
 menulist[editable="true"] {
   -moz-user-focus: ignore;
 }
 
 /******** window & page ******/
 
+html,
 window,
 page {
   overflow: -moz-hidden-unscrollable;
   -moz-box-orient: vertical;
 }
 
 /******** box *******/
 
diff --git a/toolkit/modules/AppConstants.jsm b/toolkit/modules/AppConstants.jsm
--- a/toolkit/modules/AppConstants.jsm
+++ b/toolkit/modules/AppConstants.jsm
@@ -293,17 +293,17 @@ this.AppConstants = Object.freeze({
 
   DEBUG_JS_MODULES: "@DEBUG_JS_MODULES@",
 
   MOZ_BING_API_CLIENTID: "@MOZ_BING_API_CLIENTID@",
   MOZ_BING_API_KEY: "@MOZ_BING_API_KEY@",
   MOZ_GOOGLE_API_KEY: "@MOZ_GOOGLE_API_KEY@",
   MOZ_MOZILLA_API_KEY: "@MOZ_MOZILLA_API_KEY@",
 
-  BROWSER_CHROME_URL: "@BROWSER_CHROME_URL@",
+  BROWSER_CHROME_URL: "chrome://browser/content/browser.xhtml",
 
   // URL to the hg revision this was built from (e.g.
   // "https://hg.mozilla.org/mozilla-central/rev/6256ec9113c1")
   // On unofficial builds, this is an empty string.
 #ifndef MOZ_SOURCE_URL
 #define MOZ_SOURCE_URL
 #endif
   SOURCE_REVISION_URL: "@MOZ_SOURCE_URL@",
diff --git a/toolkit/themes/linux/global/global.css b/toolkit/themes/linux/global/global.css
--- a/toolkit/themes/linux/global/global.css
+++ b/toolkit/themes/linux/global/global.css
@@ -37,16 +37,17 @@ progressmeter[mode="undetermined"] {
   --arrowpanel-color: var(--default-arrowpanel-color);
   --arrowpanel-border-color: var(--default-arrowpanel-border-color);
   --arrowpanel-padding: 10px;
   --panel-disabled-color: GrayText;
 }
 
 /* ::::: root elements ::::: */
 
+html,
 window,
 page,
 dialog,
 wizard {
   -moz-appearance: dialog;
   background-color: -moz-Dialog;
   color: -moz-DialogText;
   font: message-box;
diff --git a/toolkit/themes/osx/global/global.css b/toolkit/themes/osx/global/global.css
--- a/toolkit/themes/osx/global/global.css
+++ b/toolkit/themes/osx/global/global.css
@@ -27,16 +27,17 @@ menulist > menupopup {
   --arrowpanel-border-radius: 3.5px;
   --panel-disabled-color: GrayText;
 
   --focus-ring-box-shadow: @focusRingShadow@;
 }
 
 /* ::::: root elements ::::: */
 
+html,
 window,
 page,
 dialog,
 wizard {
   -moz-appearance: dialog;
   background-color: #FFFFFF;
   color: -moz-DialogText;
   font: message-box;
diff --git a/toolkit/themes/windows/global/global.css b/toolkit/themes/windows/global/global.css
--- a/toolkit/themes/windows/global/global.css
+++ b/toolkit/themes/windows/global/global.css
@@ -33,16 +33,17 @@ menulist > menupopup {
 @media (-moz-windows-default-theme) {
   :root {
     --arrowpanel-border-color: hsla(210,4%,10%,.2);
   }
 }
 
 /* ::::: root elements ::::: */
 
+html,
 window,
 page,
 dialog,
 wizard {
   background-color: -moz-Dialog;
   color: -moz-DialogText;
   font: message-box;
 }
