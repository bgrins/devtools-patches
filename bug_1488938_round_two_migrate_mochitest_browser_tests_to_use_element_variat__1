# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1536256944 25200
#      Thu Sep 06 11:02:24 2018 -0700
# Node ID b160b5f8110bee28dd670c952336e41104702362
# Parent  0c947d96e8f3c9f04979975c69aa7d0bcb8a4266
Bug 1488938 - Round two: migrate mochitest-browser tests to use element variations of firstChild, etc;r=Gijs

This is a follow up to Bug 1482667. The list of callers was gathered by instrumenting
the webidl calls to these methods and dumping JS stack when they are called in browser.xul.

diff --git a/browser/base/content/test/forms/head.js b/browser/base/content/test/forms/head.js
--- a/browser/base/content/test/forms/head.js
+++ b/browser/base/content/test/forms/head.js
@@ -6,13 +6,13 @@ function hideSelectPopup(selectPopup, mo
     return ContentTaskUtils.waitForCondition(() => !SelectContentHelper.open);
   });
 
   if (mode == "escape") {
     EventUtils.synthesizeKey("KEY_Escape", {}, win);
   } else if (mode == "enter") {
     EventUtils.synthesizeKey("KEY_Enter", {}, win);
   } else if (mode == "click") {
-    EventUtils.synthesizeMouseAtCenter(selectPopup.lastChild, { }, win);
+    EventUtils.synthesizeMouseAtCenter(selectPopup.lastElementChild, { }, win);
   }
 
   return selectClosedPromise;
 }
diff --git a/browser/base/content/test/permissions/browser_autoplay_blocked.js b/browser/base/content/test/permissions/browser_autoplay_blocked.js
--- a/browser/base/content/test/permissions/browser_autoplay_blocked.js
+++ b/browser/base/content/test/permissions/browser_autoplay_blocked.js
@@ -22,30 +22,30 @@ function autoplayBlockedIcon() {
 }
 
 add_task(async function testMainViewVisible() {
 
   Services.prefs.setIntPref("media.autoplay.default", Ci.nsIAutoplay.ALLOWED);
 
   await BrowserTestUtils.withNewTab(AUTOPLAY_PAGE, async function() {
     let permissionsList = document.getElementById("identity-popup-permission-list");
-    let emptyLabel = permissionsList.nextSibling.nextSibling;
+    let emptyLabel = permissionsList.nextElementSibling.nextElementSibling;
 
     ok(BrowserTestUtils.is_hidden(autoplayBlockedIcon()), "Blocked icon not shown");
 
     await openIdentityPopup();
     ok(!BrowserTestUtils.is_hidden(emptyLabel), "List of permissions is empty");
     await closeIdentityPopup();
   });
 
   Services.prefs.setIntPref("media.autoplay.default", Ci.nsIAutoplay.BLOCKED);
 
   await BrowserTestUtils.withNewTab(AUTOPLAY_PAGE, async function() {
     let permissionsList = document.getElementById("identity-popup-permission-list");
-    let emptyLabel = permissionsList.nextSibling.nextSibling;
+    let emptyLabel = permissionsList.nextElementSibling.nextElementSibling;
 
     ok(!BrowserTestUtils.is_hidden(autoplayBlockedIcon()), "Blocked icon is shown");
 
     await openIdentityPopup();
     ok(BrowserTestUtils.is_hidden(emptyLabel), "List of permissions is not empty");
     let labelText = SitePermissions.getPermissionLabel("autoplay-media");
     let labels = permissionsList.querySelectorAll(".identity-popup-permission-label");
     is(labels.length, 1, "One permission visible in main view");
diff --git a/browser/base/content/test/popupNotifications/head.js b/browser/base/content/test/popupNotifications/head.js
--- a/browser/base/content/test/popupNotifications/head.js
+++ b/browser/base/content/test/popupNotifications/head.js
@@ -284,17 +284,17 @@ function triggerSecondaryCommand(popup, 
   info("Triggering secondary command for notification " + notification.id);
 
   if (index == 0) {
     EventUtils.synthesizeMouseAtCenter(notification.secondaryButton, {});
     return;
   }
 
   // Extra secondary actions appear in a menu.
-  notification.secondaryButton.nextSibling.nextSibling.focus();
+  notification.secondaryButton.nextElementSibling.nextElementSibling.focus();
 
   popup.addEventListener("popupshown", function() {
     info("Command popup open for notification " + notification.id);
     // Press down until the desired command is selected. Decrease index by one
     // since the secondary action was handled above.
     for (let i = 0; i <= index - 1; i++) {
       EventUtils.synthesizeKey("KEY_ArrowDown");
     }
diff --git a/browser/base/content/test/urlbar/head.js b/browser/base/content/test/urlbar/head.js
--- a/browser/base/content/test/urlbar/head.js
+++ b/browser/base/content/test/urlbar/head.js
@@ -273,17 +273,17 @@ function promisePageActionViewShown() {
   return BrowserTestUtils.waitForEvent(BrowserPageActions.panelNode, "ViewShown").then(async event => {
     let panelViewNode = event.originalTarget;
     await promisePageActionViewChildrenVisible(panelViewNode);
     return panelViewNode;
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
-  return promiseNodeVisible(panelViewNode.firstChild.firstChild);
+  return promiseNodeVisible(panelViewNode.firstElementChild.firstElementChild);
 }
 
 function promiseNodeVisible(node) {
   info(`promiseNodeVisible waiting, node.id=${node.id} node.localeName=${node.localName}\n`);
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
     let bounds = dwu.getBoundsWithoutFlushing(node);
     if (bounds.width > 0 && bounds.height > 0) {
diff --git a/browser/base/content/test/webextensions/head.js b/browser/base/content/test/webextensions/head.js
--- a/browser/base/content/test/webextensions/head.js
+++ b/browser/base/content/test/webextensions/head.js
@@ -26,17 +26,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 /**
  * Wait for a specific install event to fire for a given addon
diff --git a/browser/base/content/test/webrtc/head.js b/browser/base/content/test/webrtc/head.js
--- a/browser/base/content/test/webrtc/head.js
+++ b/browser/base/content/test/webrtc/head.js
@@ -293,17 +293,17 @@ function promiseMessage(aMessage, aActio
 }
 
 function promisePopupNotificationShown(aName, aAction) {
   return new Promise(resolve => {
 
     PopupNotifications.panel.addEventListener("popupshown", function() {
       ok(!!PopupNotifications.getNotification(aName), aName + " notification shown");
       ok(PopupNotifications.isPanelOpen, "notification panel open");
-      ok(!!PopupNotifications.panel.firstChild, "notification panel populated");
+      ok(!!PopupNotifications.panel.firstElementChild, "notification panel populated");
 
       executeSoon(resolve);
     }, {once: true});
 
     if (aAction)
       aAction();
 
   });
@@ -336,17 +336,17 @@ function promiseNoPopupNotification(aNam
   });
 }
 
 const kActionAlways = 1;
 const kActionDeny = 2;
 const kActionNever = 3;
 
 function activateSecondaryAction(aAction) {
-  let notification = PopupNotifications.panel.firstChild;
+  let notification = PopupNotifications.panel.firstElementChild;
   switch (aAction) {
     case kActionNever:
       notification.checkbox.setAttribute("checked", true); // fallthrough
     case kActionDeny:
       notification.secondaryButton.click();
       break;
     case kActionAlways:
       notification.checkbox.setAttribute("checked", true);
diff --git a/browser/components/extensions/test/browser/head.js b/browser/components/extensions/test/browser/head.js
--- a/browser/components/extensions/test/browser/head.js
+++ b/browser/components/extensions/test/browser/head.js
@@ -393,17 +393,17 @@ async function openChromeContextMenu(men
   const menu = win.document.getElementById(menuId);
   const shown = BrowserTestUtils.waitForEvent(menu, "popupshown");
   EventUtils.synthesizeMouseAtCenter(node, {type: "contextmenu"}, win);
   await shown;
   return menu;
 }
 
 async function openSubmenu(submenuItem, win = window) {
-  const submenu = submenuItem.firstChild;
+  const submenu = submenuItem.firstElementChild;
   const shown = BrowserTestUtils.waitForEvent(submenu, "popupshown");
   EventUtils.synthesizeMouseAtCenter(submenuItem, {}, win);
   await shown;
   return submenu;
 }
 
 function closeChromeContextMenu(menuId, itemToSelect, win = window) {
   const menu = win.document.getElementById(menuId);
diff --git a/browser/extensions/webcompat-reporter/test/browser/head.js b/browser/extensions/webcompat-reporter/test/browser/head.js
--- a/browser/extensions/webcompat-reporter/test/browser/head.js
+++ b/browser/extensions/webcompat-reporter/test/browser/head.js
@@ -51,18 +51,18 @@ function promisePageActionPanelShown() {
     }, { once: true });
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    let bodyNode = panelViewNode.firstChild;
-    for (let childNode of bodyNode.childNodes) {
+    let bodyNode = panelViewNode.firstElementChild;
+    for (let childNode of bodyNode.children) {
       let bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
diff --git a/dom/html/test/browser_content_contextmenu_userinput.js b/dom/html/test/browser_content_contextmenu_userinput.js
--- a/dom/html/test/browser_content_contextmenu_userinput.js
+++ b/dom/html/test/browser_content_contextmenu_userinput.js
@@ -19,21 +19,21 @@ add_task(async function() {
                                {type: "contextmenu", button: 2}, window);
     await popupShownPromise;
     is(contextMenu.state, "open", "Should have opened context menu");
 
     let pageMenuSep = document.getElementById("page-menu-separator");
     ok(pageMenuSep && !pageMenuSep.hidden,
        "Page menu separator should be shown");
 
-    let testMenuSep = pageMenuSep.previousSibling;
+    let testMenuSep = pageMenuSep.previousElementSibling;
     ok(testMenuSep && !testMenuSep.hidden,
        "User-added menu separator should be shown");
 
-    let testMenuItem = testMenuSep.previousSibling;
+    let testMenuItem = testMenuSep.previousElementSibling;
     is(testMenuItem.label, "Test Context Menu Click", "Got context menu item");
 
     let promiseCtxMenuClick = ContentTask.spawn(aBrowser, null, async function() {
       await new Promise(resolve => {
         let windowUtils = content.windowUtils;
         let menuitem = content.document.getElementById("menuitem");
         menuitem.addEventListener("click", function() {
           Assert.ok(windowUtils.isHandlingUserInput,
diff --git a/dom/webauthn/tests/browser/browser_webauthn_prompts.js b/dom/webauthn/tests/browser/browser_webauthn_prompts.js
--- a/dom/webauthn/tests/browser/browser_webauthn_prompts.js
+++ b/dom/webauthn/tests/browser/browser_webauthn_prompts.js
@@ -113,17 +113,17 @@ add_task(async function test_register() 
   let request = promiseWebAuthnRegister(tab)
     .then(arrivingHereIsBad)
     .catch(expectAbortError)
     .then(() => active = false);
   await promiseNotification("webauthn-prompt-register");
 
   // Cancel the request.
   ok(active, "request should still be active");
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
   await request;
 
   // Close tab.
   await BrowserTestUtils.removeTab(tab);
 });
 
 add_task(async function test_sign() {
   // Open a new tab.
@@ -134,17 +134,17 @@ add_task(async function test_sign() {
   let request = promiseWebAuthnSign(tab)
     .then(arrivingHereIsBad)
     .catch(expectAbortError)
     .then(() => active = false);
   await promiseNotification("webauthn-prompt-sign");
 
   // Cancel the request.
   ok(active, "request should still be active");
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
   await request;
 
   // Close tab.
   await BrowserTestUtils.removeTab(tab);
 });
 
 add_task(async function test_register_direct_cancel() {
   // Open a new tab.
@@ -154,17 +154,17 @@ add_task(async function test_register_di
   let active = true;
   let promise = promiseWebAuthnRegister(tab, "direct")
     .then(arrivingHereIsBad).catch(expectAbortError)
     .then(() => active = false);
   await promiseNotification("webauthn-prompt-register-direct");
 
   // Cancel the request.
   ok(active, "request should still be active");
-  PopupNotifications.panel.firstChild.secondaryButton.click();
+  PopupNotifications.panel.firstElementChild.secondaryButton.click();
   await promise;
 
   // Close tab.
   await BrowserTestUtils.removeTab(tab);
 });
 
 add_task(async function test_setup_softtoken() {
   await SpecialPowers.pushPrefEnv({
@@ -181,17 +181,17 @@ add_task(async function test_register_di
   // Open a new tab.
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, TEST_URL);
 
   // Request a new credential with direct attestation and wait for the prompt.
   let request = promiseWebAuthnRegister(tab, "direct");
   await promiseNotification("webauthn-prompt-register-direct");
 
   // Proceed.
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   // Ensure we got "direct" attestation.
   await request.then(verifyDirectCertificate);
 
   // Close tab.
   await BrowserTestUtils.removeTab(tab);
 });
 
@@ -199,17 +199,17 @@ add_task(async function test_register_di
   // Open a new tab.
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, TEST_URL);
 
   // Request a new credential with direct attestation and wait for the prompt.
   let request = promiseWebAuthnRegister(tab, "direct");
   await promiseNotification("webauthn-prompt-register-direct");
 
   // Check "anonymize anyway" and proceed.
-  PopupNotifications.panel.firstChild.checkbox.checked = true;
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.checkbox.checked = true;
+  PopupNotifications.panel.firstElementChild.button.click();
 
   // Ensure we got "none" attestation.
   await request.then(verifyAnonymizedCertificate);
 
   // Close tab.
   await BrowserTestUtils.removeTab(tab);
 });
diff --git a/testing/mochitest/browser-test.js b/testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js
+++ b/testing/mochitest/browser-test.js
@@ -553,17 +553,17 @@ Tester.prototype = {
     // eslint-disable-next-line no-nested-ternary
     let baseMsg = timedOut ? "Found a {elt} after previous test timed out"
                            : this.currentTest ? "Found an unexpected {elt} at the end of test run"
                                               : "Found an unexpected {elt}";
 
     // Remove stale tabs
     if (this.currentTest && window.gBrowser && gBrowser.tabs.length > 1) {
       while (gBrowser.tabs.length > 1) {
-        let lastTab = gBrowser.tabContainer.lastChild;
+        let lastTab = gBrowser.tabContainer.lastElementChild;
         if (!lastTab.closing) {
           // Report the stale tab as an error only when they're not closing.
           // Tests can finish without waiting for the closing tabs.
           this.currentTest.addResult(new testResult({
             name: baseMsg.replace("{elt}", "tab") + ": " +
               lastTab.linkedBrowser.currentURI.spec,
             allowFailure: this.currentTest.allowFailure,
           }));
diff --git a/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js b/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js
--- a/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js
@@ -61,17 +61,17 @@ add_task(async function test_backButton_
     await BrowserTestUtils.browserLoaded(aBrowser, false,
                                          "https://example.com" + DIRECTORY_PATH +
                                          "formless_basic.html?second");
     await fillTestPage(aBrowser);
 
     let forwardButton = document.getElementById("forward-button");
 
     let forwardTransitionPromise;
-    if (forwardButton.nextSibling == gURLBar) {
+    if (forwardButton.nextElementSibling == gURLBar) {
       // We need to wait for the forward button transition to complete before we
       // can click it, so we hook up a listener to wait for it to be ready.
       forwardTransitionPromise = BrowserTestUtils.waitForEvent(forwardButton, "transitionend");
     }
 
     let backPromise = BrowserTestUtils.browserStopped(aBrowser);
     EventUtils.synthesizeMouseAtCenter(document.getElementById("back-button"), {});
     await backPromise;
diff --git a/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js b/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
--- a/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
+++ b/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
@@ -154,17 +154,17 @@ async function testAutoplayUnknownPermis
     ok(promptShowing(), "Should now be showing permission prompt");
 
     // Click the appropriate doorhanger button.
     if (args.button == "allow") {
       info("Clicking allow button");
       PopupNotifications.panel.firstElementChild.button.click();
     } else if (args.button == "block") {
       info("Clicking block button");
-      PopupNotifications.panel.firstChild.secondaryButton.click();
+      PopupNotifications.panel.firstElementChild.secondaryButton.click();
     } else {
       ok(false, "Invalid button field");
     }
     // Check that the video started playing.
     await checkVideoDidPlay(browser, args);
 
     // Reset permission.
     SitePermissions.remove(browser.currentURI, "autoplay-media");
diff --git a/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js b/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js
--- a/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js
@@ -28,17 +28,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 async function checkInstallConfirmation(...names) {
   let notificationCount = 0;
diff --git a/toolkit/mozapps/extensions/test/browser/head.js b/toolkit/mozapps/extensions/test/browser/head.js
--- a/toolkit/mozapps/extensions/test/browser/head.js
+++ b/toolkit/mozapps/extensions/test/browser/head.js
@@ -1381,15 +1381,15 @@ function promiseNotification(id = "addon
     return Promise.resolve();
   }
 
   return new Promise(resolve => {
     function popupshown() {
       let notification = PopupNotifications.getNotification(id);
       if (notification) {
         PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-        PopupNotifications.panel.firstChild.button.click();
+        PopupNotifications.panel.firstElementChild.button.click();
         resolve();
       }
     }
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
diff --git a/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js b/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
--- a/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
+++ b/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
@@ -473,19 +473,19 @@ async function test_allUnverified() {
   await progressPromise;
   let installDialog = await dialogPromise;
 
   let notification = document.getElementById("addon-install-confirmation-notification");
   let message = notification.getAttribute("label");
   is(message, "Caution: This site would like to install an unverified add-on in " + gApp + ". Proceed at your own risk.");
 
   let container = document.getElementById("addon-install-confirmation-content");
-  is(container.childNodes.length, 1, "Should be one item listed");
-  is(container.childNodes[0].firstChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
-  is(container.childNodes[0].childNodes.length, 1, "Shouldn't have the unverified marker");
+  is(container.children.length, 1, "Should be one item listed");
+  is(container.children[0].firstElementChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
+  is(container.children[0].children.length, 1, "Shouldn't have the unverified marker");
 
   let notificationPromise = waitForNotification("addon-installed");
   acceptInstallDialog(installDialog);
   await notificationPromise;
 
   let addon = await AddonManager.getAddonByID("restartless-xpi@tests.mozilla.org");
   addon.uninstall();
 
diff --git a/toolkit/mozapps/extensions/test/xpinstall/head.js b/toolkit/mozapps/extensions/test/xpinstall/head.js
--- a/toolkit/mozapps/extensions/test/xpinstall/head.js
+++ b/toolkit/mozapps/extensions/test/xpinstall/head.js
@@ -260,22 +260,22 @@ var Harness = {
       panel.secondaryButton.click();
     } else {
       panel.button.click();
     }
   },
 
   handleEvent(event) {
     if (event.type === "popupshown") {
-      if (event.target.firstChild) {
+      if (event.target.firstElementChild) {
         let popupId = event.target.getAttribute("popupid");
         if (popupId === "addon-webext-permissions") {
-          this.popupReady(event.target.firstChild);
+          this.popupReady(event.target.firstElementChild);
         } else if (popupId === "addon-installed" || popupId === "addon-install-failed") {
-          event.target.firstChild.button.click();
+          event.target.firstElementChild.button.click();
         }
       }
     }
   },
 
   // Install blocked handling
 
   installDisabled(installInfo) {
