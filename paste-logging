# HG changeset patch
# Parent b86b845cdcf925d5f6072dc237ff96519f2d12da
# User Brian Grinstead <bgrinstead@mozilla.com>
additional logging for paste patch

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -563,25 +563,29 @@ Rule.prototype = {
    *
    * @param {string} [aName]
    *        A text property name (such as "background" or "border-top") used
    *        when calling from setPropertyValue & setPropertyName to signify
    *        that the property should be saved in store.userProperties.
    */
   applyProperties: function Rule_applyProperties(aModifications, aName)
   {
+    console.log("Applying properties", aModifications, aName);
     this.elementStyle.markOverriddenAll();
 
     if (!aModifications) {
       aModifications = this.style.startModifyingProperties();
     }
     let disabledProps = [];
     let store = this.elementStyle.store;
 
     for (let prop of this.textProps) {
+
+      console.log("Looping text props ", prop.name, prop.value);
+
       if (!prop.enabled) {
         disabledProps.push({
           name: prop.name,
           value: prop.value,
           priority: prop.priority
         });
         continue;
       }
@@ -591,43 +595,49 @@ Rule.prototype = {
 
       aModifications.setProperty(prop.name, prop.value, prop.priority);
 
       prop.updateComputed();
     }
 
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
+    console.log("Checking disabled ", disabledProps.length);
+
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
     let promise = aModifications.apply().then(() => {
+      console.log("Finished applying modifications", this.style.cssText);
       let cssProps = {};
       for (let cssProp of parseCSSText(this.style.cssText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
         if (!textProp.enabled) {
           continue;
         }
         let cssProp = cssProps[textProp.name];
+        console.log("Does CSS Prop exist?", cssProp);
 
         if (!cssProp) {
           cssProp = {
             name: textProp.name,
             value: "",
             priority: ""
           };
         }
 
+        console.log("Does name match ", aName, textProp.name);
         if (aName && textProp.name == aName) {
+          console.log(new Array(100).join("*"), "Setting user property", this.style, textProp.name, textProp.value);
           store.userProperties.setProperty(
             this.style,
             textProp.name,
             textProp.value);
         }
         textProp.priority = cssProp.priority;
       }
 
@@ -2175,35 +2185,37 @@ TextPropertyEditor.prototype = {
     // the value.
     let val = this.prop.value;
     if (this.prop.priority) {
       val += " !" + this.prop.priority;
     }
 
     let store = this.prop.rule.elementStyle.store;
     let propDirty = store.userProperties.contains(this.prop.rule.style, name);
-
+    console.log("Is property dirty? ", propDirty, this.prop.rule.style, name);
     if (propDirty) {
       this.element.setAttribute("dirty", "");
     } else {
       this.element.removeAttribute("dirty");
     }
 
+    console.log("Inside update, about to touch output parser", val);
     let swatchClass = "ruleview-colorswatch";
     let outputParser = this.ruleEditor.ruleView._outputParser;
     let frag = outputParser.parseCssProperty(name, val, {
       colorSwatchClass: swatchClass,
       colorClass: "ruleview-color",
       defaultColorType: !propDirty,
       urlClass: "theme-link",
       baseURI: this.sheetURI
     });
     this.valueSpan.innerHTML = "";
     this.valueSpan.appendChild(frag);
 
+    console.log("Inside update, after touch output parser", this.valueSpan.innerHTML);
     // Attach the color picker tooltip to the color swatches
     this._swatchSpans = this.valueSpan.querySelectorAll("." + swatchClass);
     if (this._swatchSpans.length) {
       for (let span of this._swatchSpans) {
         // Capture the original declaration value to be able to revert later
         let originalValue = this.valueSpan.textContent;
         // Adding this swatch to the list of swatches our colorpicker knows
         // about.
@@ -2388,16 +2400,17 @@ TextPropertyEditor.prototype = {
    *
    * @param {string} aValue
    *        The value contained in the editor.
    * @param {bool} aCommit
    *        True if the change should be applied.
    */
    _onValueDone: function PropertyEditor_onValueDone(aValue, aCommit)
   {
+    // console.log("On value done has been called ", aValue, aCommit, this.committed.value);
     if (!aCommit) {
        // A new property should be removed when escape is pressed.
        if (this.removeOnRevert) {
          this.remove();
        } else {
          this.prop.setValue(this.committed.value, this.committed.priority);
        }
        return;
@@ -2421,25 +2434,30 @@ TextPropertyEditor.prototype = {
       let firstProp = properties[0];
       propertiesToAdd = properties.slice(1);
 
       if (enteredValueFirst) {
         firstProp = propertiesNoName[0];
         propertiesToAdd = propertiesNoName.slice(1);
       }
 
+      // console.log("On value done first prop: ", firstProp, firstProp.value, firstProp.name);
+
+
       // If "red; width: 1px", then set value to "red"
       // If "color: red; width: 1px;", then set value to "color: red;"
       firstValue = enteredValueFirst ?
         firstProp.value + "!" + firstProp.priority :
         firstProp.name + ": " + firstProp.value + "!" + firstProp.priority;
     }
 
     let val = this._parseValue(firstValue);
 
+    // console.log("On value done val: ", val.value, val.priority);
+
     this.prop.setValue(val.value, val.priority);
     this.removeOnRevert = false;
     this.committed.value = this.prop.value;
     this.committed.priority = this.prop.priority;
     this.ruleEditor.addProperties(propertiesToAdd, this.prop);
 
     // If the name or value is not actively being edited, and the value is
     // empty, then remove the whole property.
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js b/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_bug_902966_revert_value_on_ESC.js
@@ -4,29 +4,29 @@
 
 // Test original value is correctly displayed when ESCaping out of the
 // inplace editor in the style inspector.
 
 let doc;
 let ruleWindow;
 let ruleView;
 let inspector;
-let originalValue = "#00F";
+let originalValue = "#0F0";
 
 // Test data format
 // {
 //  value: what char sequence to type,
 //  commitKey: what key to type to "commit" the change,
 //  modifiers: commitKey modifiers,
 //  expected: what value is expected as a result
 // }
 let testData = [
   {value: "red", commitKey: "VK_ESCAPE", modifiers: {}, expected: originalValue},
   {value: "red", commitKey: "VK_RETURN", modifiers: {}, expected: "#F00"},
-  {value: "blue", commitKey: "VK_TAB", modifiers: {shiftKey: true}, expected: "blue"}
+  {value: "orange", commitKey: "VK_TAB", modifiers: {}, expected: "orange"}
 ];
 
 function startTests()
 {
   let style = '' +
     '#testid {' +
     '  color: ' + originalValue + ';' +
     '}';
@@ -42,17 +42,17 @@ function startTests()
     inspector.selection.setNode(testElement);
     inspector.once("inspector-updated", () => runTestData(0));
   });
 }
 
 function runTestData(index)
 {
   if (index === testData.length) {
-    finishTest();
+    // finishTest();
     return;
   }
 
   let idRuleEditor = ruleView.element.children[1]._ruleEditor;
   let propEditor = idRuleEditor.rule.textProps[0].editor;
   waitForEditorFocus(propEditor.element, function(aEditor) {
     is(inplaceEditor(propEditor.valueSpan), aEditor, "Focused editor should be the value span.");
 
diff --git a/toolkit/devtools/output-parser.js b/toolkit/devtools/output-parser.js
--- a/toolkit/devtools/output-parser.js
+++ b/toolkit/devtools/output-parser.js
@@ -288,17 +288,17 @@ OutputParser.prototype = {
    *         Options object. For valid options and default values see
    *         _mergeOptions().
    * @returns {Boolean}
    *          true if the color passed in was valid, false otherwise. Special
    *          values such as transparent also return false.
    */
   _appendColor: function(color, options={}) {
     let colorObj = new colorUtils.CssColor(color);
-
+    console.log("Appending color");
     if (colorObj.valid && !colorObj.specialValue) {
       if (options.colorSwatchClass) {
         this._appendNode("span", {
           class: options.colorSwatchClass,
           style: "background-color:" + color
         });
       }
       if (options.defaultColorType) {
