# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8aa6fa3e6fc24fd3b12cb629aadbe70524a4754a
Bug zzz - flash attributes

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -773,25 +773,30 @@ MarkupView.prototype = {
   },
 
   /**
    * Given a list of mutations returned by the mutation observer, flash the
    * corresponding containers to attract attention.
    */
   _flashMutatedNodes: function(aMutations) {
     let addedOrEditedContainers = new Set();
+    let addedOrEditedAttributes = new Map();
     let removedContainers = new Set();
 
-    for (let {type, target, added, removed}  of aMutations) {
+    for (let {type, target, added, removed, attributeName}  of aMutations) {
       let container = this.getContainer(target);
 
       if (container) {
-        if (type === "attributes" || type === "characterData") {
+        if (type === "attributes") {
+          let arr = addedOrEditedAttributes.get(container) || new Set();
+          arr.add(attributeName);
+          addedOrEditedAttributes.set(container, arr);
+        }  else if (type === "characterData") {
           addedOrEditedContainers.add(container);
-        } else if (type === "childList") {
+        }else if (type === "childList") {
           // If there has been removals, flash the parent
           if (removed.length) {
             removedContainers.add(container);
           }
 
           // If there has been additions, flash the nodes if their associated
           // container exist (so if their parent is expanded in the inspector).
           added.forEach(added => {
@@ -811,16 +816,19 @@ MarkupView.prototype = {
     }
 
     for (let container of removedContainers) {
       container.flashMutation();
     }
     for (let container of addedOrEditedContainers) {
       container.flashMutation();
     }
+    for (let [container, attributes] of addedOrEditedAttributes) {
+      container.flashMutation(attributes);
+    }
   },
 
   /**
    * Make sure the given node's parents are expanded and the
    * node is scrolled on to screen.
    */
   showNode: function(aNode, centered) {
     let parent = aNode;
@@ -2357,16 +2365,18 @@ function ElementEditor(aContainer, aNode
   this.closeTag = null;
   this.attrList = null;
   this.newAttr = null;
   this.closeElt = null;
 
   // Create the main editor
   this.template("element", this);
 
+  this.animationTimers = new WeakMap();
+
   // Make the tag name editable (unless this is a remote node or
   // a document element)
   if (!aNode.isDocumentElement) {
     this.tag.setAttribute("tabindex", "0");
     editableField({
       element: this.tag,
       trigger: "dblclick",
       stopOnReturn: true,
@@ -2405,16 +2415,38 @@ function ElementEditor(aContainer, aNode
   this.tag.textContent = tagName;
   this.closeTag.textContent = tagName;
   this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";
 
   this.update();
 }
 
 ElementEditor.prototype = {
+
+  flashElement: function(el) {
+    // Make sure the animation class is not here
+    el.classList.remove("flash-out");
+    
+    // Change the background
+    el.classList.add("theme-bg-contrast");
+
+    let timer = this.animationTimers.get(el);
+    if (timer) {
+      this.markup.win.clearTimeout(timer);
+    }
+
+    this.animationTimers.set(el, this.markup.win.setTimeout(() => {
+      // Add the animation class to smoothly remove the background
+      el.classList.add("flash-out");
+      
+      // Remove the background
+      el.classList.remove("theme-bg-contrast");
+    }, this.markup.CONTAINER_FLASHING_DURATION));
+  },
+
   /**
    * Update the state of the editor from the node.
    */
   update: function() {
     let attrs = this.node.attributes || [];
     let attrsToRemove = new Set(this.attrList.querySelectorAll(".attreditor"));
 
     // Don't do work for attributes that haven't changed
@@ -2428,16 +2460,20 @@ ElementEditor.prototype = {
         // Element already exists and doesn't need any more work, except
         // to make it visible.
         el.style.removeProperty("display");
         attrsToRemove.delete(el);
       } else {
         // Create a new editor if we aren't currently editing the attribute.
         let attribute = this._createAttribute(attr);
         attribute.style.removeProperty("display");
+        if (valueChanged) {
+          let val = attribute.querySelector(".attr-value");
+          this.flashElement(val);
+        }
       }
     }
 
     for (let el of attrsToRemove) {
       el.remove();
     }
 
   },
