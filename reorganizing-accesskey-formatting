# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  9b8bdf52d5a14d3aeae10f71bc6f91825e7ab086

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -6,33 +6,31 @@
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
   static get observedAttributes() {
-    return ["accesskey", "highlightable"];
+    return ["accesskey", "highlightable", "text"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue == newValue) {
       return;
     }
     this.formatAccessKey();
   }
 
-  get isHiddenHighlightable() {
-    return false;
-    // return !this.hasAttribute("highlightable") && (
-    //   this.classList.contains("button-highlightable-text") ||
-    //   this.classList.contains("menulist-highlightable-label") ||
-    //   this.classList.contains("menu-iconic-highlightable-text")
-    // );
+  get needsFormatting() {
+    return this.hasAttribute("control") ||
+           this.classList.contains("radio-label") ||
+           this.classList.contains("checkbox-label") ||
+           this.classList.contains("toolbarbutton-multiline-text");
   }
 
   _onClick(event) {
     if (this.isTextLink) {
       if (event.button == 0 || event.button == 1) {
         this.openLink(event);
       }
       return;
@@ -121,38 +119,37 @@ class MozTextLabel extends MozElementMix
     return this.getAttribute("href");
   }
 
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey() {
     // Skip doing any DOM manipulation whenever possible:
     let accessKey = this.accessKey;
-    if (!gUnderlineAccesskey || this._lastFormattedAccessKey == accessKey || !this.textContent || this.isHiddenHighlightable) {
+    if (!gUnderlineAccesskey ||
+        this._lastFormattedAccessKey == accessKey ||
+        !this.textContent ||
+        !this.needsFormatting) {
       return;
     }
     this._lastFormattedAccessKey = accessKey;
 
-    if (!this.accessKeyParens) {
-      this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
-      this.appendChild(this.accessKeyParens);
+    if (this.accessKeySpan) { // Clear old accesskey
+      mergeElement(this.accessKeySpan, this);
+      this.accessKeySpan = null;
     }
 
-    var afterLabel = this.accessKeyParens;
-    afterLabel.textContent = "";
-
-    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
-    if (oldAccessKey) { // Clear old accesskey
-      mergeElement(oldAccessKey);
+    if (this.hiddenColon) {
+      mergeElement(this.hiddenColon, this);
+      this.hiddenColon = null;
     }
 
-    var oldHiddenSpan =
-      this.getElementsByAttribute("class", "hiddenColon").item(0);
-    if (oldHiddenSpan) {
-      mergeElement(oldHiddenSpan);
+    if (this.accessKeyParens) {
+      this.accessKeyParens.remove();
+      this.accessKeyParens = null;
     }
 
     // If we used to have an accessKey but not anymore, we're done here
     if (!accessKey) {
       return;
     }
 
     var labelText = this.textContent;
@@ -163,56 +160,62 @@ class MozTextLabel extends MozElementMix
         accessKeyIndex =
           labelText.toUpperCase().indexOf(accessKey.toUpperCase());
       }
     } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
       accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
     }
 
     const HTML_NS = "http://www.w3.org/1999/xhtml";
-    var span = document.createElementNS(HTML_NS, "span");
-    span.className = "accesskey";
+    this.accessKeySpan = document.createElementNS(HTML_NS, "span");
+    this.accessKeySpan.className = "accesskey";
 
     // Note that if you change the following code, see the comment of
     // nsTextBoxFrame::UpdateAccessTitle.
 
-    // If accesskey is not in string, append in parentheses
-    if (accessKeyIndex < 0) {
-      // If end is colon, we should insert before colon.
-      // i.e., "label:" -> "label(X):"
-      var colonHidden = false;
-      if (/:$/.test(labelText)) {
-        labelText = labelText.slice(0, -1);
-        var hiddenSpan = document.createElementNS(HTML_NS, "span");
-        hiddenSpan.className = "hiddenColon";
-        hiddenSpan.style.display = "none";
-        // Hide the last colon by using span element.
-        // I.e., label<span style="display:none;">:</span>
-        wrapChar(this, hiddenSpan, labelText.length);
-        colonHidden = true;
-      }
-      // If end is space(U+20),
-      // we should not add space before parentheses.
-      var endIsSpace = false;
-      if (/ $/.test(labelText)) {
-        endIsSpace = true;
-      }
-      if (gInsertSeparator && !endIsSpace)
-        afterLabel.textContent = " (";
-      else
-        afterLabel.textContent = "(";
-      span.textContent = accessKey.toUpperCase();
-      afterLabel.appendChild(span);
-      if (!colonHidden)
-        afterLabel.appendChild(document.createTextNode(")"));
-      else
-        afterLabel.appendChild(document.createTextNode("):"));
+    // If accesskey is in the string, underline it:
+    if (accessKeyIndex >= 0) {
+      wrapChar(this, this.accessKeySpan, accessKeyIndex);
       return;
     }
-    wrapChar(this, span, accessKeyIndex);
+
+    // If accesskey is not in string, append in parentheses
+    // If end is colon, we should insert before colon.
+    // i.e., "label:" -> "label(X):"
+    var colonHidden = false;
+    if (/:$/.test(labelText)) {
+      labelText = labelText.slice(0, -1);
+      this.hiddenColon = document.createElementNS(HTML_NS, "span");
+      this.hiddenColon.className = "hiddenColon";
+      this.hiddenColon.style.display = "none";
+      // Hide the last colon by using span element.
+      // I.e., label<span style="display:none;">:</span>
+      wrapChar(this, this.hiddenColon, labelText.length);
+      colonHidden = true;
+    }
+    // If end is space(U+20),
+    // we should not add space before parentheses.
+    var endIsSpace = false;
+    if (/ $/.test(labelText)) {
+      endIsSpace = true;
+    }
+
+    this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+    this.appendChild(this.accessKeyParens);
+    if (gInsertSeparator && !endIsSpace)
+      this.accessKeyParens.textContent = " (";
+    else
+      this.accessKeyParens.textContent = "(";
+    this.accessKeySpan.textContent = accessKey.toUpperCase();
+    this.accessKeyParens.appendChild(this.accessKeySpan);
+    if (!colonHidden) {
+      this.accessKeyParens.appendChild(document.createTextNode(")"));
+    } else {
+      this.accessKeyParens.appendChild(document.createTextNode("):"));
+    }
   }
 
   openLink(aEvent) {
     if (!this.isTextLink) {
       return;
     }
 
     var href = this.href;
@@ -282,17 +285,21 @@ class MozTextLabel extends MozElementMix
         win = win.opener;
     }
     win.open(href);
   }
 }
 
 customElements.define("label", MozTextLabel);
 
-function mergeElement(element) {
+function mergeElement(element, d) {
+  // If the element has been removed already, return:
+  if (!element.isConnected) {
+    return;
+  }
   if (element.previousSibling instanceof Text) {
     element.previousSibling.appendData(element.textContent);
   } else {
     element.parentNode.insertBefore(element.firstChild, element);
   }
   element.remove();
 }
 
@@ -303,16 +310,17 @@ function wrapChar(parent, element, index
   var node = treeWalker.nextNode();
   while (index >= node.length) {
     index -= node.length;
     node = treeWalker.nextNode();
   }
   if (index) {
     node = node.splitText(index);
   }
+
   node.parentNode.insertBefore(element, node);
   if (node.length > 1) {
     node.splitText(1);
   }
   element.appendChild(node);
 }
 
 let gInsertSeparator;
