# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  94906c37940c6b1c371dc7c22ed2098face96d8b
Updates for console perf test

diff --git a/devtools/client/webconsole/new-console-output/test/chrome/test_render_perf.html b/devtools/client/webconsole/new-console-output/test/chrome/test_render_perf.html
--- a/devtools/client/webconsole/new-console-output/test/chrome/test_render_perf.html
+++ b/devtools/client/webconsole/new-console-output/test/chrome/test_render_perf.html
@@ -34,55 +34,61 @@ const testPackets = Array.from({length: 
     "private": false,
     "styles": [],
     "timeStamp": 1455064271115 + id,
     "timer": null,
     "workerType": "none",
     "category": "webdev"
   }
 }));
+const lastPacket = testPackets.pop();
 
 async function timeit(cb) {
   // Return a Promise that resolves the number of seconds cb takes.
   let start = performance.now();
   await cb();
   let elapsed = performance.now() - start;
   return elapsed;
 }
 
+async function addAllMessages(wrapper) {
+  let time = await timeit(async () => {
+    testPackets.forEach((packet) => wrapper.dispatchMessageAdd(packet));
+    // Only wait for the last packet to minimize work.
+    await wrapper.dispatchMessageAdd(lastPacket, true);
+    await new Promise(resolve => requestAnimationFrame(resolve));
+  });
+  return time;
+}
+
 window.onload = async function () {
   // This test does costly work multiple times to have better performance data.
   SimpleTest.requestLongerTimeout(3);
 
   try {
     const Services = browserRequire("Services");
     Services.prefs.setIntPref("devtools.hud.loglimit", numMessages);
     const NewConsoleOutputWrapper = browserRequire(
       "devtools/client/webconsole/new-console-output/new-console-output-wrapper");
+    const actions = browserRequire("devtools/client/webconsole/new-console-output/actions/index");
     const EventEmitter = browserRequire("devtools/shared/event-emitter");
 
     const wrapper = new NewConsoleOutputWrapper(
       document.getElementById("output"),
       {hud: EventEmitter.decorate({proxy: {}})},
       {},
       null,
       document,
     );
     wrapper.init();
 
     let times = [];
-    const iterations = 25;
-    const lastPacket = testPackets.pop();
+    const iterations = 10;
     for (let i = 0; i < iterations; i++) {
-      let time = await timeit(async () => {
-        testPackets.forEach((packet) => wrapper.dispatchMessageAdd(packet));
-        // Only wait for the last packet to minimize work.
-        await wrapper.dispatchMessageAdd(lastPacket, true);
-        await new Promise(resolve => requestAnimationFrame(resolve));
-      });
+      let time = await addAllMessages(wrapper);
       info(`took ${time} ms to render messages`);
       times.push(time);
 
       // Clear the console
       wrapper.dispatchMessagesClear();
       await new Promise(resolve => requestAnimationFrame(resolve));
     }
 
@@ -90,16 +96,29 @@ window.onload = async function () {
     let totalTime = times.reduce((sum, t) => sum + t);
     let avg = totalTime / times.length;
     let median = times.length % 2 !== 0
       ? times[Math.floor(times.length / 2)]
       : (times[(times.length / 2) - 1] + times[times.length / 2]) / 2;
     info(`On average, it took ${avg} ms (median ${median} ms) ` +
          `to render ${numMessages} messages`);
 
+    await addAllMessages(wrapper);
+    let filterToggleTimeOff = await timeit(() => {
+      wrapper.getStore().dispatch(actions.filterToggle("log"));
+    });
+    info(`Filter toggle time (off): ${filterToggleTimeOff}`);
+
+    let filterToggleTimeOn = await timeit(() => {
+      wrapper.getStore().dispatch(actions.filterToggle("log"));
+    });
+    info(`Filter toggle time (on): ${filterToggleTimeOn}`);
+
+    await new Promise(r=>r);
+
     ok(true, "Yay, it didn't time out!");
   } catch (e) {
     ok(false, `Error :  ${e.message}
       ${e.stack}
     `);
   }
 
   SimpleTest.finish();
