# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  224715760a637bc37c14794839468a954f1f2695

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -29,163 +29,169 @@ window.addEventListener("DOMContentLoade
     } catch (ex) { console.error(ex); }
   }
   gElementsPendingConnection.clear();
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
-class MozXULElement extends XULElement {
-  /**
-   * Sometimes an element may not want to run connectedCallback logic during
-   * parse. This could be because we don't want to initialize the element before
-   * the element's contents have been fully parsed, or for performance reasons.
-   * If you'd like to opt-in to this, then add this to the beginning of your
-   * `connectedCallback` and `disconnectedCallback`:
-   *
-   *    if (this.delayConnectedCallback()) { return }
-   *
-   * And this at the beginning of your `attributeChangedCallback`
-   *
-   *    if (!this.isConnectedAndReady) { return; }
-   */
-  delayConnectedCallback() {
-    if (gIsDOMContentLoaded) {
-      return false;
-    }
-    gElementsPendingConnection.add(this);
-    return true;
-  }
-
-  get isConnectedAndReady() {
-    return gIsDOMContentLoaded && this.isConnected;
-  }
 
-  /**
-   * Allows eager deterministic construction of XUL elements with XBL attached, by
-   * parsing an element tree and returning a DOM fragment to be inserted in the
-   * document before any of the inner elements is referenced by JavaScript.
-   *
-   * This process is required instead of calling the createElement method directly
-   * because bindings get attached when:
-   *
-   * 1. the node gets a layout frame constructed, or
-   * 2. the node gets its JavaScript reflector created, if it's in the document,
-   *
-   * whichever happens first. The createElement method would return a JavaScript
-   * reflector, but the element wouldn't be in the document, so the node wouldn't
-   * get XBL attached. After that point, even if the node is inserted into a
-   * document, it won't get XBL attached until either the frame is constructed or
-   * the reflector is garbage collected and the element is touched again.
-   *
-   * @param {string} str
-   *        String with the XML representation of XUL elements.
-   * @param {string[]} [entities]
-   *        An array of DTD URLs containing entity definitions.
-   *
-   * @return {DocumentFragment} `DocumentFragment` instance containing
-   *         the corresponding element tree, including element nodes
-   *         but excluding any text node.
-   */
-  static parseXULToFragment(str, entities = []) {
-    let doc = gXULDOMParser.parseFromString(`
-      ${entities.length ? `<!DOCTYPE bindings [
-        ${entities.reduce((preamble, url, index) => {
-          return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}">
-            %_dtd-${index};
-            `;
-        }, "")}
-      ]>` : ""}
-      <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-        ${str}
-      </box>
-    `, "application/xml");
-    // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
-    // does not do this. Most XUL code assumes that the whitespace has been
-    // stripped out, so we simply remove all text nodes after using the parser.
-    let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
-    let currentNode = nodeIterator.nextNode();
-    while (currentNode) {
-      currentNode.remove();
-      currentNode = nodeIterator.nextNode();
+function MozElementMixin(base) {
+  return class MozElement extends base {
+    /**
+     * Sometimes an element may not want to run connectedCallback logic during
+     * parse. This could be because we don't want to initialize the element before
+     * the element's contents have been fully parsed, or for performance reasons.
+     * If you'd like to opt-in to this, then add this to the beginning of your
+     * `connectedCallback` and `disconnectedCallback`:
+     *
+     *    if (this.delayConnectedCallback()) { return }
+     *
+     * And this at the beginning of your `attributeChangedCallback`
+     *
+     *    if (!this.isConnectedAndReady) { return; }
+     */
+    delayConnectedCallback() {
+      if (gIsDOMContentLoaded) {
+        return false;
+      }
+      gElementsPendingConnection.add(this);
+      return true;
     }
-    // We use a range here so that we don't access the inner DOM elements from
-    // JavaScript before they are imported and inserted into a document.
-    let range = doc.createRange();
-    range.selectNodeContents(doc.querySelector("box"));
-    return range.extractContents();
-  }
 
-  /**
-   * Insert a localization link to an FTL file. This is used so that
-   * a Custom Element can wait to inject the link until it's connected,
-   * and so that consuming documents don't require the correct <link>
-   * present in the markup.
-   *
-   * @param path
-   *        The path to the FTL file
-   */
-  static insertFTLIfNeeded(path) {
-    let container = document.head || document.querySelector("linkset");
-    if (!container) {
-      if (document.contentType == "application/vnd.mozilla.xul+xml") {
-        container = document.createXULElement("linkset");
-        document.documentElement.appendChild(container);
-      } else if (document.documentURI == AppConstants.BROWSER_CHROME_URL) {
-        // Special case for browser.xhtml. Here `document.head` is null, so
-        // just insert the link at the end of the window.
-        container = document.documentElement;
-      } else {
-        throw new Error("Attempt to inject localization link before document.head is available");
-      }
+    get isConnectedAndReady() {
+      return gIsDOMContentLoaded && this.isConnected;
     }
 
-    for (let link of container.querySelectorAll("link")) {
-      if (link.getAttribute("href") == path) {
-        return;
+    /**
+     * Allows eager deterministic construction of XUL elements with XBL attached, by
+     * parsing an element tree and returning a DOM fragment to be inserted in the
+     * document before any of the inner elements is referenced by JavaScript.
+     *
+     * This process is required instead of calling the createElement method directly
+     * because bindings get attached when:
+     *
+     * 1. the node gets a layout frame constructed, or
+     * 2. the node gets its JavaScript reflector created, if it's in the document,
+     *
+     * whichever happens first. The createElement method would return a JavaScript
+     * reflector, but the element wouldn't be in the document, so the node wouldn't
+     * get XBL attached. After that point, even if the node is inserted into a
+     * document, it won't get XBL attached until either the frame is constructed or
+     * the reflector is garbage collected and the element is touched again.
+     *
+     * @param {string} str
+     *        String with the XML representation of XUL elements.
+     * @param {string[]} [entities]
+     *        An array of DTD URLs containing entity definitions.
+     *
+     * @return {DocumentFragment} `DocumentFragment` instance containing
+     *         the corresponding element tree, including element nodes
+     *         but excluding any text node.
+     */
+    static parseXULToFragment(str, entities = []) {
+      let doc = gXULDOMParser.parseFromString(`
+        ${entities.length ? `<!DOCTYPE bindings [
+          ${entities.reduce((preamble, url, index) => {
+            return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}">
+              %_dtd-${index};
+              `;
+          }, "")}
+        ]>` : ""}
+        <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+          ${str}
+        </box>
+      `, "application/xml");
+      // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
+      // does not do this. Most XUL code assumes that the whitespace has been
+      // stripped out, so we simply remove all text nodes after using the parser.
+      let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
+      let currentNode = nodeIterator.nextNode();
+      while (currentNode) {
+        currentNode.remove();
+        currentNode = nodeIterator.nextNode();
       }
+      // We use a range here so that we don't access the inner DOM elements from
+      // JavaScript before they are imported and inserted into a document.
+      let range = doc.createRange();
+      range.selectNodeContents(doc.querySelector("box"));
+      return range.extractContents();
     }
 
-    let link = document.createElement("link");
-    link.setAttribute("rel", "localization");
-    link.setAttribute("href", path);
-
-    container.appendChild(link);
-  }
+    /**
+     * Insert a localization link to an FTL file. This is used so that
+     * a Custom Element can wait to inject the link until it's connected,
+     * and so that consuming documents don't require the correct <link>
+     * present in the markup.
+     *
+     * @param path
+     *        The path to the FTL file
+     */
+    static insertFTLIfNeeded(path) {
+      let container = document.head || document.querySelector("linkset");
+      if (!container) {
+        if (document.contentType == "application/vnd.mozilla.xul+xml") {
+          container = document.createXULElement("linkset");
+          document.documentElement.appendChild(container);
+        } else if (document.documentURI == AppConstants.BROWSER_CHROME_URL) {
+          // Special case for browser.xhtml. Here `document.head` is null, so
+          // just insert the link at the end of the window.
+          container = document.documentElement;
+        } else {
+          throw new Error("Attempt to inject localization link before document.head is available");
+        }
+      }
 
-  /**
-   * Indicate that a class defining a XUL element implements one or more
-   * XPCOM interfaces by adding a getCustomInterface implementation to it.
-   *
-   * The supplied class should implement the properties and methods of
-   * all of the interfaces that are specified.
-   *
-   * @param cls
-   *        The class that implements the interface.
-   * @param names
-   *        Array of interface names.
-   */
-  static implementCustomInterface(cls, ifaces) {
-    const numbers = new Set(ifaces.map(i => i.number));
-    if (cls.prototype.customInterfaceNumbers) {
-      // Base class already implemented some interfaces. Inherit:
-      cls.prototype.customInterfaceNumbers.forEach(number => numbers.add(number));
+      for (let link of container.querySelectorAll("link")) {
+        if (link.getAttribute("href") == path) {
+          return;
+        }
+      }
+
+      let link = document.createElement("link");
+      link.setAttribute("rel", "localization");
+      link.setAttribute("href", path);
+
+      container.appendChild(link);
     }
 
-    cls.prototype.customInterfaceNumbers = numbers;
-    cls.prototype.getCustomInterfaceCallback = function getCustomInterfaceCallback(iface) {
-      if (numbers.has(iface.number)) {
-        return getInterfaceProxy(this);
+    /**
+     * Indicate that a class defining a XUL element implements one or more
+     * XPCOM interfaces by adding a getCustomInterface implementation to it.
+     *
+     * The supplied class should implement the properties and methods of
+     * all of the interfaces that are specified.
+     *
+     * @param cls
+     *        The class that implements the interface.
+     * @param names
+     *        Array of interface names.
+     */
+    static implementCustomInterface(cls, ifaces) {
+      const numbers = new Set(ifaces.map(i => i.number));
+      if (cls.prototype.customInterfaceNumbers) {
+        // Base class already implemented some interfaces. Inherit:
+        cls.prototype.customInterfaceNumbers.forEach(number => numbers.add(number));
       }
-      return null;
-    };
-  }
+
+      cls.prototype.customInterfaceNumbers = numbers;
+      cls.prototype.getCustomInterfaceCallback = function getCustomInterfaceCallback(iface) {
+        if (numbers.has(iface.number)) {
+          return getInterfaceProxy(this);
+        }
+        return null;
+      };
+    }
+  };
 }
 
+const MozXULElement = MozElementMixin(XULElement);
+const MozHTMLElement = MozElementMixin(HTMLElement);
+
 /**
  * Given an object, add a proxy that reflects interface implementations
  * onto the object itself.
  */
 function getInterfaceProxy(obj) {
   if (!obj._customInterfaceProxy) {
     obj._customInterfaceProxy = new Proxy(obj, {
       get(target, prop, receiver) {
@@ -257,10 +263,61 @@ if (!isDummyDocument) {
     ["stringbundle", "chrome://global/content/elements/stringbundle.js"],
     ["printpreview-toolbar", "chrome://global/content/printPreviewToolbar.js"],
     ["editor", "chrome://global/content/elements/editor.js"],
   ]) {
     customElements.setElementCreationCallback(tag, () => {
       Services.scriptloader.loadSubScript(script, window);
     });
   }
+
+
+  console.log("Definingscroollbox");
+  customElements.define("scrollbox", class extends MozElementMixin(XULScrollElement) {
+    static get observedAttributes() {
+      return ["orient", "align", "pack", "dir"];
+    }
+
+    onAttributeChanged() {
+      console.log(arguments);
+      this.copyAttributes();
+    }
+
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      if (!this.connectedOnce) {
+        this.connectedOnce = true;
+
+      }
+      this.copyAttributes();
+    }
+
+    copyAttribute(child, name) {
+      if (this.hasAttribute(name)) {
+        child.setAttribute(name, this.getAttribute(name));
+      } else {
+        child.removeAttribute(name);
+      }
+    }
+
+    copyAttributes() {
+      this.copyAttribute(this.box, "orient");
+      this.copyAttribute(this.box, "align");
+      this.copyAttribute(this.box, "pack");
+      this.copyAttribute(this.box, "dir");
+    }
+
+    constructor() {
+      super();
+
+      this.root = this.attachShadow({ mode: "open" });
+      this.box = document.createElement("box");
+      this.box.className = "box-inherit scrollbox-innerbox";
+      this.box.setAttribute("flex", "1");
+      this.box.appendChild(document.createElement("slot"));
+      this.root.appendChild(this.box);
+    }
+  });
 }
 }
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -717,17 +717,17 @@ slider {
   /* This is a hint to layerization that the scrollbar thumb can never leave
      the scrollbar track. */
   overflow: hidden;
 }
 
 /******** scrollbox ********/
 
 scrollbox {
-  -moz-binding: url("chrome://global/content/bindings/scrollbox.xml#scrollbox");
+  /* -moz-binding: url("chrome://global/content/bindings/scrollbox.xml#scrollbox"); */
   /* This makes it scrollable! */
   overflow: hidden;
 }
 
 scrollbox[smoothscroll=true] {
   scroll-behavior: smooth;
 }
 
