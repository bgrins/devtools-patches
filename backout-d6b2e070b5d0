# HG changeset patch
# Parent  d6b2e070b5d0eb986c12e35d7fde2baa48c3170c
Backed out changeset d6b2e070b5d0 (bug 1208544)

diff --git a/devtools/client/markupview/markup-view.js b/devtools/client/markupview/markup-view.js
--- a/devtools/client/markupview/markup-view.js
+++ b/devtools/client/markupview/markup-view.js
@@ -8,16 +8,17 @@ const {Cc, Cu, Ci} = require("chrome");
 
 // Page size for pageup/pagedown
 const PAGE_SIZE = 10;
 const DEFAULT_MAX_CHILDREN = 100;
 const COLLAPSE_ATTRIBUTE_LENGTH = 120;
 const COLLAPSE_DATA_URL_REGEX = /^data.+base64/;
 const COLLAPSE_DATA_URL_LENGTH = 60;
 const NEW_SELECTION_HIGHLIGHTER_TIMER = 1000;
+const GRAB_DELAY = 400;
 const DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE = 50;
 const DRAG_DROP_MIN_AUTOSCROLL_SPEED = 5;
 const DRAG_DROP_MAX_AUTOSCROLL_SPEED = 15;
 const AUTOCOMPLETE_POPUP_PANEL_ID = "markupview_autoCompletePopup";
 
 const {UndoStack} = require("devtools/client/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/client/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/client/framework/gDevTools.jsm", {});
@@ -128,21 +129,16 @@ function MarkupView(aInspector, aFrame, 
 
 exports.MarkupView = MarkupView;
 
 MarkupView.prototype = {
   /**
    * How long does a node flash when it mutates (in ms).
    */
   CONTAINER_FLASHING_DURATION: 500,
-  /**
-   * How long do you have to hold the mouse down before a drag
-   * starts (in ms).
-   */
-  GRAB_DELAY: 400,
 
   _selectedContainer: null,
 
   _initTooltips: function() {
     this.tooltip = new Tooltip(this._inspector.panelDoc);
     this._makeTooltipPersistent(false);
 
     this._elt.addEventListener("click", this._onMouseClick, false);
@@ -829,17 +825,17 @@ MarkupView.prototype = {
       }
       if (type === "attributes" || type === "characterData") {
         container.update();
 
         // Auto refresh style properties on selected node when they change.
         if (type === "attributes" && container.selected) {
           requiresLayoutChange = true;
         }
-      } else if (type === "childList" || type === "nativeAnonymousChildList") {
+      } else if (type === "childList") {
         container.childrenDirty = true;
         // Update the children to take care of changes in the markup view DOM.
         this._updateChildren(container, {flash: true});
       } else if (type === "pseudoClassLock") {
         container.update();
       }
     }
 
@@ -1924,17 +1920,17 @@ MarkupContainer.prototype = {
       this.isDragging = true;
 
       this._dragStartY = event.pageY;
       this.markup.indicateDropTarget(this.elt);
 
       // If this is the last child, use the closing <div.tag-line> of parent as indicator
       this.markup.indicateDragTarget(this.elt.nextElementSibling ||
                                      this.markup.getContainer(this.node.parentNode()).closeTagLine);
-    }, this.GRAB_DELAY);
+    }, GRAB_DELAY);
   },
 
   /**
    * On mouse up, stop dragging.
    */
   _onMouseUp: Task.async(function*() {
     this._isMouseDown = false;
 
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js b/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
@@ -2,21 +2,20 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test different kinds of drag and drop node re-ordering
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 5;
+const GRAB_DELAY = 400;
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  inspector.markup.GRAB_DELAY = GRAB_DELAY;
 
   info("Expanding #test");
   let parentFront = yield getNodeFront("#test", inspector);
   let parent = yield getNode("#test");
   let parentContainer = yield getContainerForNodeFront(parentFront, inspector);
 
   yield inspector.markup.expandNode(parentFront);
   yield waitForMultipleChildrenUpdates(inspector);
diff --git a/devtools/client/markupview/test/browser_markupview_mutation_01.js b/devtools/client/markupview/test/browser_markupview_mutation_01.js
--- a/devtools/client/markupview/test/browser_markupview_mutation_01.js
+++ b/devtools/client/markupview/test/browser_markupview_mutation_01.js
@@ -5,18 +5,16 @@
 "use strict";
 
 // Tests that various mutations to the dom update the markup view correctly.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_mutation.html";
 
 // Mutation tests. Each entry in the array has the following properties:
 // - desc: for logging only
-// - numMutations: how many mutations are expected to come happen due to the
-//   test case.  Defaults to 1 if not set.
 // - test: a function supposed to mutate the DOM
 // - check: a function supposed to test that the mutation was handled
 const TEST_DATA = [
   {
     desc: "Adding an attribute",
     test: () => {
       let node1 = getNode("#node1");
       node1.setAttribute("newattr", "newattrval");
@@ -63,41 +61,16 @@ const TEST_DATA = [
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrchanged\"";
       }), "newattr attribute found");
     }
   },
   {
-    desc: "Adding ::after element",
-    numMutations: 2,
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.classList.add("pseudo");
-    },
-    check: function*(inspector) {
-      let {children} = yield getContainerForSelector("#node1", inspector);
-      is(children.childNodes.length, 2,
-        "Node1 now has 2 children (text child and ::after");
-    }
-  },
-  {
-    desc: "Removing ::after element",
-    numMutations: 2,
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.classList.remove("pseudo");
-    },
-    check: function*(inspector) {
-      let container = yield getContainerForSelector("#node1", inspector);
-      ok(container.singleTextChild, "Has single text child.");
-    }
-  },
-  {
     desc: "Updating the text-content",
     test: () => {
       let node1 = getNode("#node1");
       node1.textContent = "newtext";
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
@@ -263,38 +236,23 @@ const TEST_DATA = [
 ];
 
 add_task(function*() {
   let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Expanding all markup-view nodes");
   yield inspector.markup.expandAll();
 
-  for (let {desc, test, check, numMutations} of TEST_DATA) {
+  for (let {desc, test, check} of TEST_DATA) {
     info("Starting test: " + desc);
 
-    numMutations = numMutations || 1;
-
     info("Executing the test markup mutation");
-    yield new Promise((resolve) => {
-      // If a test expects more than one mutation it may come through in a
-      // single event or possibly in multiples.
-      let seenMutations = 0;
-      inspector.on("markupmutation", function onmutation(e, mutations) {
-        seenMutations += mutations.length;
-        info("Receieved " + seenMutations +
-             " mutations, expecting at least " + numMutations);
-        if (seenMutations >= numMutations) {
-          inspector.off("markupmutation", onmutation);
-          resolve();
-        }
-      });
-
-      test();
-    })
+    let onMutation = inspector.once("markupmutation");
+    test();
+    yield onMutation;
 
     info("Expanding all markup-view nodes to make sure new nodes are imported");
     yield inspector.markup.expandAll();
 
     info("Checking the markup-view content");
     yield check(inspector);
   }
 });
diff --git a/devtools/client/markupview/test/doc_markup_mutation.html b/devtools/client/markupview/test/doc_markup_mutation.html
--- a/devtools/client/markupview/test/doc_markup_mutation.html
+++ b/devtools/client/markupview/test/doc_markup_mutation.html
@@ -1,16 +1,11 @@
 <!DOCTYPE html>
 
 <html class="html">
-  <style type="text/css">
-    #node1.pseudo::after {
-      content: "after";
-    }
-  </style>
 
   <body class="body">
     <div class="node0">
       <div id="node1" class="node1">line1</div>
       <div id="node2" class="node2">line2</div>
       <p class="node3">line3</p>
       <!-- A comment -->
       <p id="node4" class="node4">line4
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -320,17 +320,16 @@ var NodeActor = exports.NodeActor = prot
    */
   watchDocument: function(callback) {
     let node = this.rawNode;
     // Create the observer on the node's actor.  The node will make sure
     // the observer is cleaned up when the actor is released.
     let observer = new node.defaultView.MutationObserver(callback);
     observer.mergeAttributeRecords = true;
     observer.observe(node, {
-      nativeAnonymousChildList: true,
       attributes: true,
       characterData: true,
       childList: true,
       subtree: true
     });
     this.mutationObserver = observer;
   },
 
@@ -2808,36 +2807,35 @@ var WalkerActor = protocol.ActorClass({
    */
   onMutations: function(mutations) {
     for (let change of mutations) {
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
-      let type = change.type;
       let mutation = {
-        type: type,
+        type: change.type,
         target: targetActor.actorID,
       };
 
-      if (type === "attributes") {
+      if (mutation.type === "attributes") {
         mutation.attributeName = change.attributeName;
         mutation.attributeNamespace = change.attributeNamespace || undefined;
         mutation.newValue = targetNode.hasAttribute(mutation.attributeName) ?
                             targetNode.getAttribute(mutation.attributeName)
                             : null;
-      } else if (type === "characterData") {
+      } else if (mutation.type === "characterData") {
         if (targetNode.nodeValue.length > gValueSummaryLength) {
           mutation.newValue = targetNode.nodeValue.substring(0, gValueSummaryLength);
           mutation.incompleteValue = true;
         } else {
           mutation.newValue = targetNode.nodeValue;
         }
-      } else if (type === "childList" || type === "nativeAnonymousChildList") {
+      } else if (mutation.type === "childList") {
         // Get the list of removed and added actors that the client has seen
         // so that it can keep its ownership tree up to date.
         let removedActors = [];
         let addedActors = [];
         for (let removed of change.removedNodes) {
           let removedActor = this._refMap.get(removed);
           if (!removedActor) {
             // If the client never encountered this actor we don't need to
@@ -3329,17 +3327,17 @@ var WalkerFront = exports.WalkerFront = 
 
         if (!targetFront) {
           console.trace("Got a mutation for an unexpected actor: " + targetID + ", please file a bug on bugzilla.mozilla.org!");
           continue;
         }
 
         let emittedMutation = object.merge(change, { target: targetFront });
 
-        if (change.type === "childList" || change.type === "nativeAnonymousChildList") {
+        if (change.type === "childList") {
           // Update the ownership tree according to the mutation record.
           let addedFronts = [];
           let removedFronts = [];
           for (let removed of change.removed) {
             let removedFront = this.get(removed);
             if (!removedFront) {
               console.error("Got a removal of an actor we didn't know about: " + removed);
               continue;
