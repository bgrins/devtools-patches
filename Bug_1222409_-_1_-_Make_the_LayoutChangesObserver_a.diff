# vim: se ft=diff :
# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Date 1447942940 -3600
Bug 1222409 - 1 - Make the LayoutChangesObserver also send "resize" events

The LayoutChangesObserver was originally made to observe all kinds of
layout-related events. So far, it was only observing reflows though.
This adds the capability to also observe resize events on the content
window.

diff --git a/devtools/server/actors/layout.js b/devtools/server/actors/layout.js
--- a/devtools/server/actors/layout.js
+++ b/devtools/server/actors/layout.js
@@ -6,33 +6,33 @@
 
 /**
  * About the types of objects in this file:
  *
  * - ReflowActor: the actor class used for protocol purposes.
  *   Mostly empty, just gets an instance of LayoutChangesObserver and forwards
  *   its "reflows" events to clients.
  *
- * - Observable: A utility parent class, meant at being extended by classes that
- *   need a start/stop behavior.
- *
  * - LayoutChangesObserver: extends Observable and uses the ReflowObserver, to
  *   track reflows on the page.
  *   Used by the LayoutActor, but is also exported on the module, so can be used
  *   by any other actor that needs it.
  *
+ * - Observable: A utility parent class, meant at being extended by classes that
+ *   need a to observe something on the tabActor's windows.
+ *
  * - Dedicated observers: There's only one of them for now: ReflowObserver which
  *   listens to reflow events via the docshell,
  *   These dedicated classes are used by the LayoutChangesObserver.
  */
 
 const {Ci, Cu} = require("chrome");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 const protocol = require("devtools/server/protocol");
-const {method, Arg, RetVal, types} = protocol;
+const {method, Arg} = protocol;
 const events = require("sdk/event/core");
 const Heritage = require("sdk/core/heritage");
 const {setTimeout, clearTimeout} = require("sdk/timers");
 const EventEmitter = require("devtools/shared/event-emitter");
 
 /**
  * The reflow actor tracks reflows and emits events about them.
  */
@@ -43,35 +43,35 @@ var ReflowActor = exports.ReflowActor = 
     /**
      * The reflows event is emitted when reflows have been detected. The event
      * is sent with an array of reflows that occured. Each item has the
      * following properties:
      * - start {Number}
      * - end {Number}
      * - isInterruptible {Boolean}
      */
-    "reflows" : {
+    "reflows": {
       type: "reflows",
       reflows: Arg(0, "array:json")
     }
   },
 
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
 
     this.tabActor = tabActor;
     this._onReflow = this._onReflow.bind(this);
     this.observer = getLayoutChangesObserver(tabActor);
     this._isStarted = false;
   },
 
   /**
-   * The reflow actor is the first (and last) in its hierarchy to use protocol.js
-   * so it doesn't have a parent protocol actor that takes care of its lifetime.
-   * So it needs a disconnect method to cleanup.
+   * The reflow actor is the first (and last) in its hierarchy to use
+   * protocol.js so it doesn't have a parent protocol actor that takes care of
+   * its lifetime. So it needs a disconnect method to cleanup.
    */
   disconnect: function() {
     this.destroy();
   },
 
   destroy: function() {
     this.stop();
     releaseLayoutChangesObserver(this.tabActor);
@@ -127,73 +127,108 @@ exports.ReflowFront = protocol.FrontClas
   },
 
   destroy: function() {
     protocol.Front.prototype.destroy.call(this);
   },
 });
 
 /**
- * Base class for all sorts of observers we need to create for a given window.
+ * Base class for all sorts of observers that need to listen to events on the
+ * tabActor's windows.
  * @param {TabActor} tabActor
  * @param {Function} callback Executed everytime the observer observes something
  */
 function Observable(tabActor, callback) {
   this.tabActor = tabActor;
   this.callback = callback;
+
+  this._onWindowReady = this._onWindowReady.bind(this);
+  this._onWindowDestroyed = this._onWindowDestroyed.bind(this);
+
+  events.on(this.tabActor, "window-ready", this._onWindowReady);
+  events.on(this.tabActor, "window-destroyed", this._onWindowDestroyed);
 }
 
 Observable.prototype = {
   /**
    * Is the observer currently observing
    */
-  observing: false,
+  isObserving: false,
+
+  /**
+   * Stop observing and detroy this observer instance
+   */
+  destroy: function() {
+    if (this.isDestroyed) {
+      return;
+    }
+    this.isDestroyed = true;
+
+    this.stop();
+
+    events.off(this.tabActor, "window-ready", this._onWindowReady);
+    events.off(this.tabActor, "window-destroyed", this._onWindowDestroyed);
+
+    this.callback = null;
+    this.tabActor = null;
+  },
 
   /**
    * Start observing whatever it is this observer is supposed to observe
    */
   start: function() {
-    if (!this.observing) {
-      this._start();
-      this.observing = true;
+    if (this.isObserving) {
+      return;
     }
-  },
+    this.isObserving = true;
 
-  _start: function() {
-    /* To be implemented by sub-classes */
+    this._startListeners(this.tabActor.windows);
   },
 
   /**
    * Stop observing
    */
   stop: function() {
-    if (this.observing) {
-      this._stop();
-      this.observing = false;
+    if (!this.isObserving) {
+      return;
+    }
+    this.isObserving = false;
+
+    if (this.tabActor.attached && this.tabActor.docShell) {
+      // It's only worth stopping if the tabActor is still attached
+      this._stopListeners(this.tabActor.windows);
     }
   },
 
-  _stop: function() {
-    /* To be implemented by sub-classes */
+  _onWindowReady: function({window}) {
+    if (this.isObserving) {
+      this._startListeners([window]);
+    }
+  },
+
+  _onWindowDestroyed: function({window}) {
+    if (this.isObserving) {
+      this._stopListeners([window]);
+    }
+  },
+
+  _startListeners: function(windows) {
+    // To be implemented by sub-classes.
+  },
+
+  _stopListeners: function(windows) {
+    // To be implemented by sub-classes.
   },
 
   /**
    * To be called by sub-classes when something has been observed
    */
   notifyCallback: function(...args) {
-    this.observing && this.callback && this.callback.apply(null, args);
-  },
-
-  /**
-   * Stop observing and detroy this observer instance
-   */
-  destroy: function() {
-    this.stop();
-    this.callback = null;
-    this.tabActor = null;
+    this.isObserving && this.callback && this.callback.apply(null, args);
   }
 };
 
 /**
  * The LayouChangesObserver will observe reflows as soon as it is started.
  * Some devtools actors may cause reflows and it may be wanted to "hide" these
  * reflows from the LayouChangesObserver consumers.
  * If this is the case, such actors should require this module and use this
@@ -207,17 +242,17 @@ Observable.prototype = {
  * @param {DOMNode} syncReflowNode The node to use to force a sync reflow
  */
 var gIgnoreLayoutChanges = false;
 exports.setIgnoreLayoutChanges = function(ignore, syncReflowNode) {
   if (syncReflowNode) {
     let forceSyncReflow = syncReflowNode.offsetWidth;
   }
   gIgnoreLayoutChanges = ignore;
-}
+};
 
 /**
  * The LayoutChangesObserver class is instantiated only once per given tab
  * and is used to track reflows and dom and style changes in that tab.
  * The LayoutActor uses this class to send reflow events to its clients.
  *
  * This class isn't exported on the module because it shouldn't be instantiated
  * to avoid creating several instances per tabs.
@@ -225,66 +260,92 @@ exports.setIgnoreLayoutChanges = functio
  * and `releaseLayoutChangesObserver(tabActor)`
  * which are exported to get and release instances.
  *
  * The observer loops every EVENT_BATCHING_DELAY ms and checks if layout changes
  * have happened since the last loop iteration. If there are, it sends the
  * corresponding events:
  *
  * - "reflows", with an array of all the reflows that occured,
+ * - "resizes", with an array of all the resizes that occured,
  *
  * @param {TabActor} tabActor
  */
 function LayoutChangesObserver(tabActor) {
-  Observable.call(this, tabActor);
+  this.tabActor = tabActor;
 
   this._startEventLoop = this._startEventLoop.bind(this);
+  this._onReflow = this._onReflow.bind(this);
+  this._onResize = this._onResize.bind(this);
 
   // Creating the various observers we're going to need
   // For now, just the reflow observer, but later we can add markupMutation,
   // styleSheetChanges and styleRuleChanges
-  this._onReflow = this._onReflow.bind(this);
   this.reflowObserver = new ReflowObserver(this.tabActor, this._onReflow);
+  this.resizeObserver = new WindowResizeObserver(this.tabActor, this._onResize);
 
   EventEmitter.decorate(this);
 }
 
 exports.LayoutChangesObserver = LayoutChangesObserver;
 
-LayoutChangesObserver.prototype = Heritage.extend(Observable.prototype, {
+LayoutChangesObserver.prototype = {
   /**
-   * How long does this observer waits before emitting a batched reflows event.
+   * How long does this observer waits before emitting batched events.
    * The lower the value, the more event packets will be sent to clients,
    * potentially impacting performance.
    * The higher the value, the more time we'll wait, this is better for
    * performance but has an effect on how soon changes are shown in the toolbox.
    */
   EVENT_BATCHING_DELAY: 300,
 
   /**
    * Destroying this instance of LayoutChangesObserver will stop the batched
    * events from being sent.
    */
   destroy: function() {
+    this.isObserving = false;
+
     this.reflowObserver.destroy();
     this.reflows = null;
 
-    Observable.prototype.destroy.call(this);
+    this.resizeObserver.destroy();
+    this.hasResized = false;
+
+    this.tabActor = null;
   },
 
-  _start: function() {
+  start: function() {
+    if (this.isObserving) {
+      return;
+    }
+    this.isObserving = true;
+
     this.reflows = [];
+    this.hasResized = false;
+
     this._startEventLoop();
+
     this.reflowObserver.start();
+    this.resizeObserver.start();
   },
 
-  _stop: function() {
+  stop: function() {
+    if (!this.isObserving) {
+      return;
+    }
+    this.isObserving = false;
+
     this._stopEventLoop();
+
     this.reflows = [];
+    this.hasResized = false;
+
     this.reflowObserver.stop();
+    this.resizeObserver.stop();
   },
 
   /**
    * Start the event loop, which regularly checks if there are any observer
    * events to be sent as batched events
    * Calls itself in a loop.
    */
   _startEventLoop: function() {
@@ -294,16 +355,23 @@ LayoutChangesObserver.prototype = Herita
       return;
     }
 
     // Send any reflows we have
     if (this.reflows && this.reflows.length) {
       this.emit("reflows", this.reflows);
       this.reflows = [];
     }
+
+    // Send any resizes we have
+    if (this.hasResized) {
+      this.emit("resize");
+      this.hasResized = false;
+    }
+
     this.eventLoopTimer = this._setTimeout(this._startEventLoop,
       this.EVENT_BATCHING_DELAY);
   },
 
   _stopEventLoop: function() {
     this._clearTimeout(this.eventLoopTimer);
   },
 
@@ -330,18 +398,31 @@ LayoutChangesObserver.prototype = Herita
 
     // XXX: when/if bug 997092 gets fixed, we will be able to know which
     // elements have been reflowed, which would be a nice thing to add here.
     this.reflows.push({
       start: start,
       end: end,
       isInterruptible: isInterruptible
     });
+  },
+
+  /**
+   * Executed whenever a resize is observed. Only store a flag saying that a
+   * resize occured.
+   * The EVENT_BATCHING_DELAY loop will take care of it later.
+   */
+  _onResize: function() {
+    if (gIgnoreLayoutChanges) {
+      return;
+    }
+
+    this.hasResized = true;
   }
-});
+};
 
 /**
  * Get a LayoutChangesObserver instance for a given window. This function makes
  * sure there is only one instance per window.
  * @param {TabActor} tabActor
  * @return {LayoutChangesObserver}
  */
 var observedWindows = new Map();
@@ -350,22 +431,23 @@ function getLayoutChangesObserver(tabAct
   if (observerData) {
     observerData.refCounting ++;
     return observerData.observer;
   }
 
   let obs = new LayoutChangesObserver(tabActor);
   observedWindows.set(tabActor, {
     observer: obs,
-    refCounting: 1 // counting references allows to stop the observer when no
-                   // tabActor owns an instance
+    // counting references allows to stop the observer when no tabActor owns an
+    // instance.
+    refCounting: 1
   });
   obs.start();
   return obs;
-};
+}
 exports.getLayoutChangesObserver = getLayoutChangesObserver;
 
 /**
  * Release a LayoutChangesObserver instance that was retrieved by
  * getLayoutChangesObserver. This is required to ensure the tabActor reference
  * is removed and the observer is eventually stopped and destroyed.
  * @param {TabActor} tabActor
  */
@@ -375,95 +457,94 @@ function releaseLayoutChangesObserver(ta
     return;
   }
 
   observerData.refCounting --;
   if (!observerData.refCounting) {
     observerData.observer.destroy();
     observedWindows.delete(tabActor);
   }
-};
+}
 exports.releaseLayoutChangesObserver = releaseLayoutChangesObserver;
 
 /**
- * Instantiate and start a reflow observer on a given window's document element.
- * Will report any reflow that occurs in this window's docshell.
+ * Reports any reflow that occurs in the tabActor's docshells.
  * @extends Observable
  * @param {TabActor} tabActor
  * @param {Function} callback Executed everytime a reflow occurs
  */
 function ReflowObserver(tabActor, callback) {
   Observable.call(this, tabActor, callback);
-
-  this._onWindowReady = this._onWindowReady.bind(this);
-  events.on(this.tabActor, "window-ready", this._onWindowReady);
-  this._onWindowDestroyed = this._onWindowDestroyed.bind(this);
-  events.on(this.tabActor, "window-destroyed", this._onWindowDestroyed);
 }
 
 ReflowObserver.prototype = Heritage.extend(Observable.prototype, {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIReflowObserver,
     Ci.nsISupportsWeakReference]),
 
-  _onWindowReady: function({window}) {
-    if (this.observing) {
-      this._startListeners([window]);
-    }
-  },
-
-  _onWindowDestroyed: function({window}) {
-    if (this.observing) {
-      this._stopListeners([window]);
-    }
-  },
-
-  _start: function() {
-    this._startListeners(this.tabActor.windows);
-  },
-
-  _stop: function() {
-    if (this.tabActor.attached && this.tabActor.docShell) {
-      // It's only worth stopping if the tabActor is still attached
-      this._stopListeners(this.tabActor.windows);
-    }
-  },
-
   _startListeners: function(windows) {
     for (let window of windows) {
       let docshell = window.QueryInterface(Ci.nsIInterfaceRequestor)
                      .getInterface(Ci.nsIWebNavigation)
                      .QueryInterface(Ci.nsIDocShell);
       docshell.addWeakReflowObserver(this);
     }
   },
 
   _stopListeners: function(windows) {
     for (let window of windows) {
-      // Corner cases where a global has already been freed may happen, in which
-      // case, no need to remove the observer
       try {
         let docshell = window.QueryInterface(Ci.nsIInterfaceRequestor)
                        .getInterface(Ci.nsIWebNavigation)
                        .QueryInterface(Ci.nsIDocShell);
         docshell.removeWeakReflowObserver(this);
-      } catch (e) {}
+      } catch (e) {
+        // Corner cases where a global has already been freed may happen, in
+        // which case, no need to remove the observer.
+      }
     }
   },
 
   reflow: function(start, end) {
     this.notifyCallback(start, end, false);
   },
 
   reflowInterruptible: function(start, end) {
     this.notifyCallback(start, end, true);
+  }
+});
+
+/**
+ * Reports window resize events on the tabActor's windows.
+ * @extends Observable
+ * @param {TabActor} tabActor
+ * @param {Function} callback Executed everytime a resize occurs
+ */
+function WindowResizeObserver(tabActor, callback) {
+  Observable.call(this, tabActor, callback);
+  this.onResize = this.onResize.bind(this);
+}
+
+WindowResizeObserver.prototype = Heritage.extend(Observable.prototype, {
+  _startListeners: function() {
+    this.listenerTarget.addEventListener("resize", this.onResize);
   },
 
-  destroy: function() {
-    if (this._isDestroyed) {
-      return;
+  _stopListeners: function() {
+    this.listenerTarget.removeEventListener("resize", this.onResize);
+  },
+
+  onResize: function() {
+    this.notifyCallback();
+  },
+
+  get listenerTarget() {
+    // For the rootActor, return its window.
+    if (this.tabActor.isRootActor) {
+      return this.tabActor.window;
     }
-    this._isDestroyed = true;
 
-    events.off(this.tabActor, "window-ready", this._onWindowReady);
-    events.off(this.tabActor, "window-destroyed", this._onWindowDestroyed);
-    Observable.prototype.destroy.call(this);
+    // Otherwise, get the tabActor's chromeEventHandler.
+    return this.tabActor.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                               .getInterface(Ci.nsIWebNavigation)
+                               .QueryInterface(Ci.nsIDocShell)
+                               .chromeEventHandler;
   }
 });
diff --git a/devtools/server/tests/unit/test_layout-reflows-observer.js b/devtools/server/tests/unit/test_layout-reflows-observer.js
--- a/devtools/server/tests/unit/test_layout-reflows-observer.js
+++ b/devtools/server/tests/unit/test_layout-reflows-observer.js
@@ -51,17 +51,36 @@ MockWindow.prototype = {
 
 function MockDocShell() {
   this.observer = null;
 }
 MockDocShell.prototype = {
   addWeakReflowObserver: function(observer) {
     this.observer = observer;
   },
-  removeWeakReflowObserver: function(observer) {}
+  removeWeakReflowObserver: function() {},
+  get chromeEventHandler() {
+    return {
+      addEventListener: (type, cb) => {
+        if (type === "resize") {
+          this.resizeCb = cb;
+        }
+      },
+      removeEventListener: (type, cb) => {
+        if (type === "resize" && cb === this.resizeCb) {
+          this.resizeCb = null;
+        }
+      }
+    };
+  },
+  mockResize: function() {
+    if (this.resizeCb) {
+      this.resizeCb();
+    }
+  }
 };
 
 function run_test() {
   instancesOfObserversAreSharedBetweenWindows();
   eventsAreBatched();
   noEventsAreSentWhenThereAreNoReflowsAndLoopTimeouts();
   observerIsAlreadyStarted();
   destroyStopsObserving();
@@ -105,32 +124,45 @@ function eventsAreBatched() {
   // manually
   let tabActor = new MockTabActor();
   let observer = getLayoutChangesObserver(tabActor);
 
   let reflowsEvents = [];
   let onReflows = (event, reflows) => reflowsEvents.push(reflows);
   observer.on("reflows", onReflows);
 
+  let resizeEvents = [];
+  let onResize = () => resizeEvents.push("resize");
+  observer.on("resize", onResize);
+
   do_print("Fake one reflow event");
   tabActor.window.docShell.observer.reflow();
   do_print("Checking that no batched reflow event has been emitted");
   do_check_eq(reflowsEvents.length, 0);
 
   do_print("Fake another reflow event");
   tabActor.window.docShell.observer.reflow();
   do_print("Checking that still no batched reflow event has been emitted");
   do_check_eq(reflowsEvents.length, 0);
 
-  do_print("Faking timeout expiration and checking that reflow events are sent");
+  do_print("Fake a few of resize events too");
+  tabActor.window.docShell.mockResize();
+  tabActor.window.docShell.mockResize();
+  tabActor.window.docShell.mockResize();
+  do_print("Checking that still no batched resize event has been emitted");
+  do_check_eq(resizeEvents.length, 0);
+
+  do_print("Faking timeout expiration and checking that events are sent");
   observer.eventLoopTimer();
   do_check_eq(reflowsEvents.length, 1);
   do_check_eq(reflowsEvents[0].length, 2);
+  do_check_eq(resizeEvents.length, 1);
 
   observer.off("reflows", onReflows);
+  observer.off("resize", onResize);
   releaseLayoutChangesObserver(tabActor);
 }
 
 function noEventsAreSentWhenThereAreNoReflowsAndLoopTimeouts() {
  do_print("Checking that if no reflows were detected and the event batching " +
   "loop expires, then no reflows event is sent");
 
   let tabActor = new MockTabActor();
@@ -148,59 +180,59 @@ function noEventsAreSentWhenThereAreNoRe
   releaseLayoutChangesObserver(tabActor);
 }
 
 function observerIsAlreadyStarted() {
   do_print("Checking that the observer is already started when getting it");
 
   let tabActor = new MockTabActor();
   let observer = getLayoutChangesObserver(tabActor);
-  do_check_true(observer.observing);
+  do_check_true(observer.isObserving);
 
   observer.stop();
-  do_check_false(observer.observing);
+  do_check_false(observer.isObserving);
 
   observer.start();
-  do_check_true(observer.observing);
+  do_check_true(observer.isObserving);
 
   releaseLayoutChangesObserver(tabActor);
 }
 
 function destroyStopsObserving() {
   do_print("Checking that the destroying the observer stops it");
 
   let tabActor = new MockTabActor();
   let observer = getLayoutChangesObserver(tabActor);
-  do_check_true(observer.observing);
+  do_check_true(observer.isObserving);
 
   observer.destroy();
-  do_check_false(observer.observing);
+  do_check_false(observer.isObserving);
 
   releaseLayoutChangesObserver(tabActor);
 }
 
 function stoppingAndStartingSeveralTimesWorksCorrectly() {
   do_print("Checking that the stopping and starting several times the observer" +
     " works correctly");
 
   let tabActor = new MockTabActor();
   let observer = getLayoutChangesObserver(tabActor);
 
-  do_check_true(observer.observing);
+  do_check_true(observer.isObserving);
   observer.start();
   observer.start();
   observer.start();
-  do_check_true(observer.observing);
+  do_check_true(observer.isObserving);
 
   observer.stop();
-  do_check_false(observer.observing);
+  do_check_false(observer.isObserving);
 
   observer.stop();
   observer.stop();
-  do_check_false(observer.observing);
+  do_check_false(observer.isObserving);
 
   releaseLayoutChangesObserver(tabActor);
 }
 
 function reflowsArentStackedWhenStopped() {
   do_print("Checking that when stopped, reflows aren't stacked in the observer");
 
   let tabActor = new MockTabActor();
