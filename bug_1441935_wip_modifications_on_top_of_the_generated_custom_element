# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1545172000 28800
#      Tue Dec 18 14:26:40 2018 -0800
# Node ID 394d642ff956a9eae1f3fbaf30e3e48ab71f5b9b
# Parent  6652167af1189e4233a587c94e5ce4026e72158f
Bug 1441935 - WIP - Modifications on top of the generated Custom Element

Steps to build:

this.observer instead of this
./mach eslint toolkit/content/widgets/browser.js --fix

Differential Revision: https://phabricator.services.mozilla.com/D14911

diff --git a/devtools/client/responsive.html/browser/tunnel.js b/devtools/client/responsive.html/browser/tunnel.js
--- a/devtools/client/responsive.html/browser/tunnel.js
+++ b/devtools/client/responsive.html/browser/tunnel.js
@@ -59,17 +59,17 @@ const PROPERTIES_FROM_BROWSER_WINDOW = [
 
 /**
  * This module takes an "outer" <xul:browser> from a browser tab as described by
  * Firefox's tabbrowser.xml and wires it up to an "inner" <iframe mozbrowser>
  * browser element containing arbitrary page content of interest.
  *
  * The inner <iframe mozbrowser> element is _just_ the page content.  It is not
  * enough to to replace <xul:browser> on its own.  <xul:browser> comes along
- * with lots of associated functionality via XBL binding defined for such
+ * with lots of associated functionality via a Custom Element defined for such
  * elements in browser.xml, and the Firefox UI depends on these various things
  * to make the UI function.
  *
  * By mapping various methods, properties, and messages from the outer browser
  * to the inner browser, we can control the content inside the inner browser
  * using the standard Firefox UI elements for navigation, reloading, and more.
  *
  * The approaches used in this module were chosen to avoid needing changes to
@@ -148,22 +148,22 @@ function tunnelToInnerBrowser(outer, inn
       // copy the content's `permanentKey` up to the outer browser.
       debug("Copy inner permanentKey to outer browser");
       outer.permanentKey = inner.permanentKey;
 
       // Replace the outer browser's native messageManager with a message manager tunnel
       // which we can use to route messages of interest to the inner browser instead.
       // Note: The _actual_ messageManager accessible from
       // `browser.frameLoader.messageManager` is not overridable and is left unchanged.
-      // Only the XBL getter `browser.messageManager` is overridden.  Browser UI code
+      // Only the Custom Element getter `browser.messageManager` is overridden.  Browser UI code
       // always uses this getter instead of `browser.frameLoader.messageManager` directly,
       // so this has the effect of overriding the message manager for browser UI code.
       mmTunnel = new MessageManagerTunnel(outer, inner);
 
-      // Clear out any cached state that references the XBL binding's non-remote state,
+      // Clear out any cached state that references the Custom Element's non-remote state,
       // such as form fill controllers.  Otherwise they will remain in place and leak the
       // outer docshell.
       outer.destroy();
 
       // We are tunneling to an inner browser with a specific remoteness, so it is simpler
       // for the logic of the browser UI to assume this tab has taken on that remoteness,
       // even though it's not true.  Since the actions the browser UI performs are sent
       // down to the inner browser by this tunnel, the tab's remoteness effectively is the
@@ -188,19 +188,19 @@ function tunnelToInnerBrowser(outer, inn
       // remote browser binding creates.  We do not care about it's original value
       // because stop() will remove the browser binding and these will no longer bee
       // used.
       const webNavigation = new BrowserElementWebNavigation(inner);
       webNavigation.copyStateFrom(inner._remoteWebNavigationImpl);
       outer._remoteWebNavigation = webNavigation;
       outer._remoteWebNavigationImpl = webNavigation;
 
-      // Now that we've flipped to the remote browser XBL binding, add `progressListener`
+      // Now that we've flipped to the remote browser mode, add `progressListener`
       // onto the remote version of `webProgress`.  Normally tabbrowser.xml does this step
-      // when it creates a new browser, etc.  Since we manually changed the XBL binding
+      // when it creates a new browser, etc.  Since we manually changed the mode
       // above, it caused a fresh webProgress object to be created which does not have any
       // listeners added.  So, we get the listener that gBrowser is using for the tab and
       // reattach it here.
       const tab = gBrowser.getTabForBrowser(outer);
       const filteredProgressListener = gBrowser._tabFilters.get(tab);
       outer.webProgress.addProgressListener(filteredProgressListener);
 
       // Add the inner browser to tabbrowser's WeakMap from browser to tab.  This assists
@@ -300,17 +300,17 @@ function tunnelToInnerBrowser(outer, inn
       }
 
       // Remove the inner browser from the WeakMap from browser to tab.
       gBrowser._tabForBrowser.delete(inner);
 
       // Remove the progress listener we added manually.
       outer.webProgress.removeProgressListener(filteredProgressListener);
 
-      // Reset the XBL binding back to the original state.
+      // Reset the Custom Element back to the original state.
       outer.destroy();
 
       // Reset @remote since this is now back to a regular, non-remote browser
       outer.setAttribute("remote", "false");
       outer.removeAttribute("remoteType");
       outer.construct();
 
       // Delete browser window properties exposed on content's owner global
diff --git a/toolkit/components/processsingleton/CustomElementsListener.jsm b/toolkit/components/processsingleton/CustomElementsListener.jsm
--- a/toolkit/components/processsingleton/CustomElementsListener.jsm
+++ b/toolkit/components/processsingleton/CustomElementsListener.jsm
@@ -8,15 +8,16 @@ ChromeUtils.import("resource://gre/modul
 // Set up Custom Elements for XUL and XHTML documents before anything else
 // happens. Anything loaded here should be considered part of core XUL functionality.
 // Any window-specific elements can be registered via <script> tags at the
 // top of individual documents.
 Services.obs.addObserver({
   observe(doc) {
     if (doc.nodePrincipal.isSystemPrincipal && (
       doc.contentType == "application/vnd.mozilla.xul+xml" ||
-      doc.contentType == "application/xhtml+xml"
+      doc.contentType == "application/xhtml+xml" ||
+      doc.contentType == "text/html"
     )) {
       Services.scriptloader.loadSubScript(
         "chrome://global/content/customElements.js", doc.ownerGlobal);
     }
   },
 }, "document-element-inserted");
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -284,16 +284,18 @@ MozElements.BaseControl = class BaseCont
 MozXULElement.implementCustomInterface(MozElements.BaseControl,
                                        [Ci.nsIDOMXULControlElement]);
 
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozElements = MozElements;
 
+Services.scriptloader.loadSubScript("chrome://global/content/elements/browser.js", window);
+
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/radio.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -57,17 +57,16 @@ toolkit.jar:
    content/global/TopLevelVideoDocument.js
    content/global/timepicker.xhtml
    content/global/treeUtils.js
 #ifndef MOZ_FENNEC
    content/global/viewZoomOverlay.js
 #endif
    content/global/widgets.css
    content/global/bindings/autocomplete.xml    (widgets/autocomplete.xml)
-   content/global/bindings/browser.xml         (widgets/browser.xml)
    content/global/bindings/button.xml          (widgets/button.xml)
    content/global/bindings/calendar.js         (widgets/calendar.js)
    content/global/bindings/checkbox.xml        (widgets/checkbox.xml)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimepopup.xml   (widgets/datetimepopup.xml)
    content/global/bindings/datetimebox.xml     (widgets/datetimebox.xml)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
@@ -87,16 +86,17 @@ toolkit.jar:
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
+   content/global/elements/browser.js          (widgets/browser.js)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js          (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
diff --git a/toolkit/content/widgets/browser.js b/toolkit/content/widgets/browser.js
--- a/toolkit/content/widgets/browser.js
+++ b/toolkit/content/widgets/browser.js
@@ -3,20 +3,30 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
-class MozBrowser extends MozXULElement {
+class MozBrowser extends MozElementMixin(XULFrameElement) {
   constructor() {
     super();
 
+    this.observer = {
+      observe(aSubject, aTopic, aData) {
+        console.log("Observed", aSubject, aTopic, aData);
+      },
+      QueryInterface: ChromeUtils.generateQI([
+        Ci.nsIObserver,
+        Ci.nsISupportsWeakReference,
+      ]),
+    };
+
     this.addEventListener("keypress", (event) => {
       if (event.keyCode != KeyEvent.DOM_VK_F7) { return; }
       if (event.defaultPrevented || !event.isTrusted)
         return;
 
       const kPrefShortcutEnabled = "accessibility.browsewithcaret_shortcut.enabled";
       const kPrefWarnOnEnable = "accessibility.warn_on_browsewithcaret";
       const kPrefCaretBrowsingOn = "accessibility.browsewithcaret";
@@ -302,21 +312,21 @@ class MozBrowser extends MozXULElement {
     let { frameLoader } = this;
     if (!frameLoader)
       return null;
     this._loadContext = frameLoader.loadContext;
     return this._loadContext;
   }
 
   get autoCompletePopup() {
-    return document.getElementById(this.getAttribute('autocompletepopup'))
+    return document.getElementById(this.getAttribute("autocompletepopup"));
   }
 
   get dateTimePicker() {
-    return document.getElementById(this.getAttribute('datetimepicker'))
+    return document.getElementById(this.getAttribute("datetimepicker"));
   }
 
   set docShellIsActive(val) {
     if (this.isRemoteBrowser) {
       this.frameLoader.tabParent.docShellIsActive = val;
       return val;
     }
     if (this.docShell)
@@ -375,17 +385,17 @@ class MozBrowser extends MozXULElement {
 
     try {
       return { width: document.imageRequest.image.width, height: document.imageRequest.image.height };
     } catch (e) {}
     return null;
   }
 
   get isRemoteBrowser() {
-    return (this.getAttribute('remote') == 'true');
+    return (this.getAttribute("remote") == "true");
   }
 
   get remoteType() {
     if (!this.isRemoteBrowser) {
       return null;
     }
 
     let remoteType = this.getAttribute("remoteType");
@@ -480,21 +490,21 @@ class MozBrowser extends MozXULElement {
     }
 
     return ChromeUtils.getBrowsingContext(this._browsingContextId);
   }
   /**
    * Note that this overrides webNavigation on XULFrameElement, and duplicates the return value for the non-remote case
    */
   get webNavigation() {
-    return this.isRemoteBrowser ? this._remoteWebNavigation : this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);
+    return this.isRemoteBrowser ? this._remoteWebNavigation : this.docShell.QueryInterface(Ci.nsIWebNavigation);
   }
 
   get webProgress() {
-    return this.isRemoteBrowser ? this._remoteWebProgress : this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);
+    return this.isRemoteBrowser ? this._remoteWebProgress : this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebProgress);
   }
 
   get sessionHistory() {
     return this.webNavigation.sessionHistory;
   }
 
   get markupDocumentViewer() {
     return this.docShell.contentViewer;
@@ -534,23 +544,23 @@ class MozBrowser extends MozXULElement {
       return this.contentDocument.documentLoadGroup
         .requestContextID;
     } catch (e) {
       return null;
     }
   }
 
   set showWindowResizer(val) {
-    if (val) this.setAttribute('showresizer', 'true');
-    else this.removeAttribute('showresizer');
+    if (val) this.setAttribute("showresizer", "true");
+    else this.removeAttribute("showresizer");
     return val;
   }
 
   get showWindowResizer() {
-    return this.getAttribute('showresizer') == 'true';
+    return this.getAttribute("showresizer") == "true";
   }
 
   set fullZoom(val) {
     if (this.isRemoteBrowser) {
       let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
 
       if (changed) {
         this._fullZoom = val;
@@ -986,17 +996,17 @@ class MozBrowser extends MozXULElement {
       this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
 
       if (this.hasAttribute("selectmenulist")) {
         this.messageManager.addMessageListener("Forms:ShowDropDown", this);
         this.messageManager.addMessageListener("Forms:HideDropDown", this);
       }
 
       if (!this.hasAttribute("disablehistory")) {
-        Services.obs.addObserver(this, "browser:purge-session-history", true);
+        Services.obs.addObserver(this.observer, "browser:purge-session-history", true);
       }
 
       let rc_js = "resource://gre/modules/RemoteController.js";
       let scope = {};
       Services.scriptloader.loadSubScript(rc_js, scope);
       let RemoteController = scope.RemoteController;
       this._controller = new RemoteController(this);
       this.controllers.appendController(this._controller);
@@ -1004,17 +1014,17 @@ class MozBrowser extends MozXULElement {
 
     try {
       // |webNavigation.sessionHistory| will have been set by the frame
       // loader when creating the docShell as long as this xul:browser
       // doesn't have the 'disablehistory' attribute set.
       if (this.docShell && this.webNavigation.sessionHistory) {
         var os = Cc["@mozilla.org/observer-service;1"]
           .getService(Ci.nsIObserverService);
-        os.addObserver(this, "browser:purge-session-history", true);
+        os.addObserver(this.observer, "browser:purge-session-history", true);
 
         // enable global history if we weren't told otherwise
         if (!this.hasAttribute("disableglobalhistory") && !this.isRemoteBrowser) {
           try {
             this.docShell.useGlobalHistory = true;
           } catch (ex) {
             // This can occur if the Places database is locked
             Cu.reportError("Error enabling browser global history: " + ex);
@@ -1087,30 +1097,30 @@ class MozBrowser extends MozXULElement {
       } catch (ex) {
         // This can fail when this browser element is not attached to a
         // BrowserDOMWindow.
       }
 
       if (!this.hasAttribute("disablehistory")) {
         let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
         try {
-          Services.obs.removeObserver(this, "browser:purge-session-history");
+          Services.obs.removeObserver(this.observer, "browser:purge-session-history");
         } catch (ex) {
           // It's not clear why this sometimes throws an exception.
         }
       }
 
       return;
     }
 
     if (this.docShell && this.webNavigation.sessionHistory) {
       var os = Cc["@mozilla.org/observer-service;1"]
         .getService(Ci.nsIObserverService);
       try {
-        os.removeObserver(this, "browser:purge-session-history");
+        os.removeObserver(this.observer, "browser:purge-session-history");
       } catch (ex) {
         // It's not clear why this sometimes throws an exception.
       }
     }
 
     this._fastFind = null;
     this._webBrowserFind = null;
 
@@ -1154,17 +1164,17 @@ class MozBrowser extends MozXULElement {
             this.mPrefs.getBoolPref("apz.autoscroll.enabled", false)) {
             let { tabParent } = this.frameLoader;
             if (tabParent) {
               // If APZ is handling the autoscroll, it may decide to cancel
               // it of its own accord, so register an observer to allow it
               // to notify us of that.
               var os = Cc["@mozilla.org/observer-service;1"]
                 .getService(Ci.nsIObserverService);
-              os.addObserver(this, "apz:cancel-autoscroll", true);
+              os.addObserver(this.observer, "apz:cancel-autoscroll", true);
 
               usingApz = tabParent.startApzAutoscroll(
                 data.screenX, data.screenY,
                 data.scrollId, data.presShellId);
             }
             // Save the IDs for later
             this._autoScrollScrollId = data.scrollId;
             this._autoScrollPresShellId = data.presShellId;
@@ -1365,17 +1375,17 @@ class MozBrowser extends MozXULElement {
       window.removeEventListener("keydown", this, true);
       window.removeEventListener("keypress", this, true);
       window.removeEventListener("keyup", this, true);
       this.messageManager.sendAsyncMessage("Autoscroll:Stop");
 
       var os = Cc["@mozilla.org/observer-service;1"]
         .getService(Ci.nsIObserverService);
       try {
-        os.removeObserver(this, "apz:cancel-autoscroll");
+        os.removeObserver(this.observer, "apz:cancel-autoscroll");
       } catch (ex) {
         // It's not clear why this sometimes throws an exception
       }
 
       if (this.isRemoteBrowser && this._autoScrollScrollId != null) {
         let { tabParent } = this.frameLoader;
         if (tabParent) {
           tabParent.stopApzAutoscroll(this._autoScrollScrollId,
@@ -1757,17 +1767,17 @@ class MozBrowser extends MozXULElement {
       return { permitUnload, timedOut };
     }
 
     if (!this.docShell || !this.docShell.contentViewer) {
       return { permitUnload: true, timedOut: false };
     }
     return {
       permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),
-      timedOut: false
+      timedOut: false,
     };
   }
 
   print(aOuterWindowID, aPrintSettings, aPrintProgressListener) {
     if (!this.frameLoader) {
       throw Components.Exception("No frame loader.",
         Cr.NS_ERROR_FAILURE);
     }
@@ -1808,12 +1818,12 @@ class MozBrowser extends MozXULElement {
       this.docShell.getContentBlockingLog() :
       Promise.reject("docshell isn't available");
   }
   disconnectedCallback() {
     this.destroy();
   }
 }
 
-MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIObserver, Ci.nsIBrowser]);
+MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIBrowser]);
 customElements.define("browser", MozBrowser);
 
 }
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -167,20 +167,16 @@ iframe {
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   browser,
   editor,
   iframe {
     display: block;
   }
 }
 
-browser {
-  -moz-binding: url("chrome://global/content/bindings/browser.xml#browser");
-}
-
 /*********** popup notification ************/
 popupnotification {
   -moz-binding: url("chrome://global/content/bindings/notification.xml#popup-notification");
 }
 
 .popup-notification-menubutton:not([label]) {
   display: none;
 }
