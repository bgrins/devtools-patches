exporting patch:
# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Date 1440429868 -7200
#      Mon Aug 24 17:24:28 2015 +0200
# Node ID 943254a981e62d89355039ab059277c65df299a3
# Parent  453640fcbf718c18033850b3d564c85c2982b48a
Bug 1180134 - 1 - Color code animations and transitions so they look different

diff --git a/browser/devtools/animationinspector/components.js b/browser/devtools/animationinspector/components.js
--- a/browser/devtools/animationinspector/components.js
+++ b/browser/devtools/animationinspector/components.js
@@ -921,31 +921,34 @@ AnimationsTimeline.prototype = {
     let delay = state.delay || 0;
 
     let x = TimeScale.startTimeToDistance(start + (delay / rate), width);
     let w = TimeScale.durationToDistance(duration / rate, width);
 
     let iterations = createNode({
       parent: el,
       attributes: {
-        "class": "iterations" + (count ? "" : " infinite"),
+        "class": state.type + " iterations" + (count ? "" : " infinite"),
         // Individual iterations are represented by setting the size of the
         // repeating linear-gradient.
         "style": `left:${x}px;
                   width:${w * (count || 1)}px;
                   background-size:${Math.max(w, 2)}px 100%;`
       }
     });
 
     // The animation name is displayed over the iterations.
     createNode({
       parent: iterations,
       attributes: {
         "class": "name",
-        "title": state.name
+        "title": state.type
+                 ? L10N.getFormatStr("timeline." + state.type + ".nameLabel",
+                                     state.name)
+                 : state.name
       },
       textContent: state.name
     });
 
     // Delay.
     if (delay) {
       let w = TimeScale.durationToDistance(delay / rate, width);
       createNode({
diff --git a/browser/locales/en-US/chrome/browser/devtools/animationinspector.properties b/browser/locales/en-US/chrome/browser/devtools/animationinspector.properties
--- a/browser/locales/en-US/chrome/browser/devtools/animationinspector.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/animationinspector.properties
@@ -58,8 +58,18 @@ player.playbackRateLabel=%Sx
 # animation is running on the compositor thread.
 player.runningOnCompositorTooltip=This animation is running on compositor thread
 
 # LOCALIZATION NOTE (timeline.timeGraduationLabel):
 # This string is displayed at the top of the animation panel, next to each time
 # graduation, to indicate what duration (in milliseconds) this graduation
 # corresponds to.
 timeline.timeGraduationLabel=%Sms
+
+# LOCALIZATION NOTE (timeline.CSSAnimation.nameLabel):
+# This string is displayed in a tooltip of the animation panel that is shown
+# when hovering over the name of a CSS Animation in the timeline UI.
+timeline.cssanimation.nameLabel=%S - CSS Animation
+
+# LOCALIZATION NOTE (timeline.CSSAnimation.nameLabel):
+# This string is displayed in a tooltip of the animation panel that is shown
+# when hovering over the name of a CSS Transition in the timeline UI.
+timeline.csstransition.nameLabel=%S - CSS Transition
\ No newline at end of file
diff --git a/browser/themes/shared/devtools/animationinspector.css b/browser/themes/shared/devtools/animationinspector.css
--- a/browser/themes/shared/devtools/animationinspector.css
+++ b/browser/themes/shared/devtools/animationinspector.css
@@ -157,17 +157,19 @@ body {
   border-right: 5px solid transparent;
 }
 
 .animation-timeline .time-header {
   margin-left: var(--timeline-sidebar-width);
   height: 20px;
   overflow: hidden;
   position: relative;
-  border-bottom: 1px solid var(--theme-splitter-color);
+  /* This is the same color as the time graduations in
+     browser/devtools/animationinspector/utils.js */
+  border-bottom: 1px solid rgba(128, 136, 144, .5);
   cursor: col-resize;
   -moz-user-select: none;
 }
 
 .animation-timeline .time-header .time-tick {
   position: absolute;
   top: 3px;
 }
@@ -211,29 +213,47 @@ body {
   height: 100%;
 }
 
 /* Animation iterations */
 
 .animation-timeline .animation .iterations {
   position: relative;
   height: 100%;
-  border: 1px solid var(--theme-highlight-lightorange);
   box-sizing: border-box;
-  background: var(--theme-contrast-background);
-  /* Iterations are displayed with a repeating linear-gradient which size is
-     dynamically changed from JS */
+
+  --timelime-border-color: var(--theme-body-color);
+  --timeline-background-color: var(--theme-splitter-color);
+
+  /* Iterations of the animation are displayed with a repeating linear-gradient
+     which size is dynamically changed from JS. The gradient only draws 1px
+     borders between each iteration. These borders must have the same color as
+     the border of this element */
   background-image:
     linear-gradient(to right,
-                    var(--theme-highlight-lightorange) 0,
-                    var(--theme-highlight-lightorange) 1px,
+                    var(--timelime-border-color) 0,
+                    var(--timelime-border-color) 1px,
                     transparent 1px,
                     transparent 2px);
   background-repeat: repeat-x;
   background-position: -1px 0;
+  border: 1px solid var(--timelime-border-color);
+
+  /* The background color is set independently */
+  background: var(--timeline-background-color);
+}
+
+.animation-timeline .animation .cssanimation {
+  --timelime-border-color: var(--theme-highlight-lightorange);
+  --timeline-background-color: var(--theme-contrast-background);
+}
+
+.animation-timeline .animation .csstransition {
+  --timelime-border-color: var(--theme-highlight-bluegrey);
+  --timeline-background-color: var(--theme-highlight-blue);
 }
 
 .animation-timeline .animation .iterations.infinite {
   border-right-width: 0;
 }
 
 .animation-timeline .animation .iterations.infinite::before,
 .animation-timeline .animation .iterations.infinite::after {
@@ -249,47 +269,48 @@ body {
 }
 
 .animation-timeline .animation .iterations.infinite::after {
   bottom: 0;
   top: unset;
 }
 
 .animation-timeline .animation .name {
+  color: white;
   height: 100%;
   width: 100%;
   overflow: hidden;
   text-overflow: ellipsis;
   white-space: nowrap;
   line-height: 150%;
   padding: 0 2px;
 }
 
 .animation-timeline .animation .delay {
   position: absolute;
   top: 0;
   height: 100%;
   background-image: linear-gradient(to bottom,
                                     transparent,
                                     transparent 9px,
-                                    var(--theme-highlight-lightorange) 9px,
-                                    var(--theme-highlight-lightorange) 11px,
+                                    var(--timelime-border-color) 9px,
+                                    var(--timelime-border-color) 11px,
                                     transparent 11px,
                                     transparent);
 }
 
 .animation-timeline .animation .delay::before {
   position: absolute;
   content: "";
   left: 0;
   width: 2px;
   height: 8px;
   top: 50%;
   margin-top: -4px;
-  background: var(--theme-highlight-lightorange);
+  background: var(--timelime-border-color);
 }
 
 /* Animation target node gutter, contains a preview of the dom node */
 
 .animation-target {
   background-color: var(--theme-toolbar-background);
   padding: 1px 4px;
   box-sizing: border-box;
diff --git a/toolkit/devtools/server/actors/animation.js b/toolkit/devtools/server/actors/animation.js
--- a/toolkit/devtools/server/actors/animation.js
+++ b/toolkit/devtools/server/actors/animation.js
@@ -35,16 +35,23 @@ const {ActorClass, Actor, FrontClass, Fr
 // Make sure the nodeActor type is know here.
 const {NodeActor} = require("devtools/server/actors/inspector");
 const events = require("sdk/event/core");
 
 // How long (in ms) should we wait before polling again the state of an
 // animationPlayer.
 const PLAYER_DEFAULT_AUTO_REFRESH_TIMEOUT = 500;
 
+// Types of animations.
+const TYPES = {
+  CSS_ANIMATION: "cssanimation",
+  CSS_TRANSITION: "csstransition",
+  UNKNOWN: "unknown"
+};
+
 /**
  * The AnimationPlayerActor provides information about a given animation: its
  * startTime, currentTime, current state, etc.
  *
  * Since the state of a player changes as the animation progresses it is often
  * useful to call getCurrentState at regular intervals to get the current state.
  *
  * This actor also allows playing, pausing and seeking the animation.
@@ -116,16 +123,26 @@ let AnimationPlayerActor = ActorClass({
   isAnimation: function(player=this.player) {
     return player instanceof this.tabActor.window.CSSAnimation;
   },
 
   isTransition: function(player=this.player) {
     return player instanceof this.tabActor.window.CSSTransition;
   },
 
+  getType: function() {
+    if (this.isAnimation()) {
+      return TYPES.CSS_ANIMATION;
+    } else if (this.isTransition()) {
+      return TYPES.CSS_TRANSITION;
+    }
+
+    return null;
+  },
+
   /**
    * Some of the player's properties are retrieved from the node's
    * computed-styles because the Web Animations API does not provide them yet.
    * But the computed-styles may contain multiple animations for a node and so
    * we need to know which is the index of the current animation in the style.
    * @return {Number}
    */
   getPlayerIndex: function() {
@@ -163,19 +180,19 @@ let AnimationPlayerActor = ActorClass({
    * transition-property property.
    * @return {String}
    */
   getName: function() {
     if (this.isAnimation()) {
       return this.player.animationName;
     } else if (this.isTransition()) {
       return this.player.transitionProperty;
-    } else {
-      return  "";
     }
+
+    return "";
   },
 
   /**
    * Get the animation duration from this player, in milliseconds.
    * Note that the Web Animations API doesn't yet offer a way to retrieve this
    * directly from the AnimationPlayer object, so for now, a duration is only
    * returned if found in the node's computed styles.
    * @return {Number}
@@ -249,16 +266,17 @@ let AnimationPlayerActor = ActorClass({
    * is initialized.
    * @return {Object}
    */
   getCurrentState: method(function() {
     // Note that if you add a new property to the state object, make sure you
     // add the corresponding property in the AnimationPlayerFront' initialState
     // getter.
     let newState = {
+      type: this.getType(),
       // startTime is null whenever the animation is paused or waiting to start.
       startTime: this.player.startTime,
       currentTime: this.player.currentTime,
       playState: this.player.playState,
       playbackRate: this.player.playbackRate,
       name: this.getName(),
       duration: this.getDuration(),
       delay: this.getDelay(),
@@ -411,16 +429,17 @@ let AnimationPlayerFront = FrontClass(An
   },
 
   /**
    * Getter for the initial state of the player. Up to date states can be
    * retrieved by calling the getCurrentState method.
    */
   get initialState() {
     return {
+      type: this._form.type,
       startTime: this._form.startTime,
       currentTime: this._form.currentTime,
       playState: this._form.playState,
       playbackRate: this._form.playbackRate,
       name: this._form.name,
       duration: this._form.duration,
       delay: this._form.delay,
       iterationCount: this._form.iterationCount,
diff --git a/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js b/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js
--- a/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js
+++ b/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js
@@ -35,38 +35,41 @@ function* playerHasAnInitialState(walker
   ok("currentTime" in player.initialState, "Player's state has currentTime");
   ok("playState" in player.initialState, "Player's state has playState");
   ok("playbackRate" in player.initialState, "Player's state has playbackRate");
   ok("name" in player.initialState, "Player's state has name");
   ok("duration" in player.initialState, "Player's state has duration");
   ok("delay" in player.initialState, "Player's state has delay");
   ok("iterationCount" in player.initialState, "Player's state has iterationCount");
   ok("isRunningOnCompositor" in player.initialState, "Player's state has isRunningOnCompositor");
+  ok("type" in player.initialState, "Player's state has type");
 }
 
 function* playerStateIsCorrect(walker, front) {
   info("Checking the state of the simple animation");
 
   let state = yield getAnimationStateForNode(walker, front, ".simple-animation", 0);
   is(state.name, "move", "Name is correct");
   is(state.duration, 2000, "Duration is correct");
   // null = infinite count
   is(state.iterationCount, null, "Iteration count is correct");
   is(state.playState, "running", "PlayState is correct");
   is(state.playbackRate, 1, "PlaybackRate is correct");
+  is(state.type, "css-animation", "Type is correct");
 
   info("Checking the state of the transition");
 
   state = yield getAnimationStateForNode(walker, front, ".transition", 0);
   is(state.name, "width", "Transition name matches transition property");
   is(state.duration, 5000, "Transition duration is correct");
   // transitions run only once
   is(state.iterationCount, 1, "Transition iteration count is correct");
   is(state.playState, "running", "Transition playState is correct");
   is(state.playbackRate, 1, "Transition playbackRate is correct");
+  is(state.type, "css-transition", "Transition type is correct");
 
   info("Checking the state of one of multiple animations on a node");
 
   // Checking the 2nd player
   state = yield getAnimationStateForNode(walker, front, ".multiple-animations", 1);
   is(state.name, "glow", "The 2nd animation's name is correct");
   is(state.duration, 1000, "The 2nd animation's duration is correct");
   is(state.iterationCount, 5, "The 2nd animation's iteration count is correct");
