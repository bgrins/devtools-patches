# vim: se ft=diff :
# HG changeset patch
# User Tom Tromey <tromey@mozilla.com>
# Date 2015-09-11 12:52
Bug 984880 - add "invisible" attribute to TextProp

diff --git a/browser/devtools/styleeditor/test/browser.ini b/browser/devtools/styleeditor/test/browser.ini
index 2558984..693f399 100644
--- a/browser/devtools/styleeditor/test/browser.ini
+++ b/browser/devtools/styleeditor/test/browser.ini
@@ -43,16 +43,17 @@ support-files =
   sourcemaps-large.html
   sourcemaps-watching.html
   test_private.css
   test_private.html
   doc_long.css
   doc_uncached.css
   doc_uncached.html
   doc_xulpage.xul
+  sync.html
 
 [browser_styleeditor_autocomplete.js]
 [browser_styleeditor_autocomplete-disabled.js]
 [browser_styleeditor_bug_740541_iframes.js]
 [browser_styleeditor_bug_851132_middle_click.js]
 [browser_styleeditor_bug_870339.js]
 [browser_styleeditor_cmd_edit.js]
 skip-if = e10s # Bug 1055333 - style editor tests disabled with e10s
@@ -78,10 +79,11 @@ skip-if = e10s # Bug 1055333 - style editor tests disabled with e10s
 [browser_styleeditor_scroll.js]
 [browser_styleeditor_sv_keynav.js]
 [browser_styleeditor_sv_resize.js]
 [browser_styleeditor_selectstylesheet.js]
 [browser_styleeditor_sourcemaps.js]
 [browser_styleeditor_sourcemap_large.js]
 [browser_styleeditor_sourcemap_watching.js]
 skip-if = e10s # Bug 1055333 - style editor tests disabled with e10s
+[browser_styleeditor_sync.js]
 [browser_styleeditor_transition_rule.js]
 [browser_styleeditor_xul.js]
diff --git a/browser/devtools/styleeditor/test/browser_styleeditor_sync.js b/browser/devtools/styleeditor/test/browser_styleeditor_sync.js
new file mode 100644
index 0000000..18f24b9
--- /dev/null
+++ b/browser/devtools/styleeditor/test/browser_styleeditor_sync.js
@@ -0,0 +1,49 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Test that changes in the style inspector are synchronized into the
+// style editor.
+
+Services.scriptloader.loadSubScript("chrome://mochitests/content/browser/browser/devtools/styleinspector/test/head.js", this);
+
+const TESTCASE_URI = TEST_BASE_HTTP + "sync.html";
+
+const expectedText = `
+  body {
+    border-width: 15px;
+    /* color: red; */
+  }
+
+  #testid {
+    /* font-size: 4em; */
+  }
+  `;
+
+add_task(function*() {
+  yield addTab(TESTCASE_URI);
+  let { inspector, view } = yield openRuleView();
+  yield selectNode("#testid", inspector);
+  let ruleEditor = getRuleViewRuleEditor(view, 1);
+
+  // Disable the "font-size" property.
+  let propEditor = ruleEditor.rule.textProps[0].editor;
+  propEditor.enable.click();
+  yield ruleEditor.rule._applyingModifications;
+
+  // Disable the "color" property.  Note that this property is in a
+  // rule that also contains a non-inherited property -- so this test
+  // is also testing that property editing works properly in this
+  // situation.
+  ruleEditor = getRuleViewRuleEditor(view, 3);
+  propEditor = ruleEditor.rule.textProps[1].editor;
+  propEditor.enable.click();
+  yield ruleEditor.rule._applyingModifications;
+
+  let { ui } = yield openStyleEditor();
+
+  let editor = yield ui.editors[0].getSourceEditor();
+  let text = editor.sourceEditor.getText();
+  is(text, expectedText, "style inspector changes are synced");
+});
diff --git a/browser/devtools/styleeditor/test/head.js b/browser/devtools/styleeditor/test/head.js
index ef0766d..6d29c7c 100644
--- a/browser/devtools/styleeditor/test/head.js
+++ b/browser/devtools/styleeditor/test/head.js
@@ -66,27 +66,36 @@ function* cleanup()
     let target = TargetFactory.forTab(gBrowser.selectedTab);
     yield gDevTools.closeToolbox(target);
 
     gBrowser.removeCurrentTab();
   }
 }
 
 /**
+ * Open the style editor for the current tab.
+ */
+let openStyleEditor = Task.async(function*() {
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  let toolbox = yield gDevTools.showToolbox(target, "styleeditor");
+  let panel = toolbox.getPanel("styleeditor");
+  let ui = panel.UI;
+
+  return { toolbox, panel, ui };
+});
+
+/**
  * Creates a new tab in specified window navigates it to the given URL and
  * opens style editor in it.
  */
 let openStyleEditorForURL = Task.async(function* (url, win) {
   let tab = yield addTab(url, win);
-  let target = TargetFactory.forTab(tab);
-  let toolbox = yield gDevTools.showToolbox(target, "styleeditor");
-  let panel = toolbox.getPanel("styleeditor");
-  let ui = panel.UI;
-
-  return { tab, toolbox, panel, ui };
+  let result = yield openStyleEditor();
+  result.tab = tab;
+  return result;
 });
 
 /**
  * Loads shared/frame-script-utils.js in the specified tab.
  *
  * @param tab
  *        Optional tab to load the frame script in. Defaults to the current tab.
  */
diff --git a/browser/devtools/styleeditor/test/sync.html b/browser/devtools/styleeditor/test/sync.html
new file mode 100644
index 0000000..83da8c5
--- /dev/null
+++ b/browser/devtools/styleeditor/test/sync.html
@@ -0,0 +1,20 @@
+<!doctype html>
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>simple testcase</title>
+  <style type="text/css">
+  body {
+    border-width: 15px;
+    color: red;
+  }
+
+  #testid {
+    font-size: 4em;
+  }
+  </style>
+</head>
+<body>
+	<div id="testid">simple testcase</div>
+</body>
+</html>
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
index 4729c75..b4d6d40 100644
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -302,17 +302,17 @@ ElementStyle.prototype = {
     }
 
     // If this is a new rule, create its Rule object.
     if (!rule) {
       rule = new Rule(this, options);
     }
 
     // Ignore inherited rules with no properties.
-    if (options.inherited && rule.textProps.length === 0) {
+    if (options.inherited && !rule.anyProperties()) {
       return false;
     }
 
     this.rules.push(rule);
     return true;
   },
 
   /**
@@ -634,16 +634,19 @@ Rule.prototype = {
    * in the element style's store.
    */
   _applyPropertiesNoAuthored: function(modifications) {
     this.elementStyle.markOverriddenAll();
 
     let disabledProps = [];
 
     for (let prop of this.textProps) {
+      if (prop.invisible) {
+        continue;
+      }
       if (!prop.enabled) {
         disabledProps.push({
           name: prop.name,
           value: prop.value,
           priority: prop.priority
         });
         continue;
       }
@@ -844,23 +847,22 @@ Rule.prototype = {
    * to parse the style's authoredText.
    */
   _getTextProperties: function() {
     let textProps = [];
     let store = this.elementStyle.store;
     let props = parseDeclarations(this.style.authoredText, true);
     for (let prop of props) {
       let name = prop.name;
-      if (this.inherited && !domUtils.isInheritedProperty(name)) {
-        continue;
-      }
+      let invisible = this.inherited && !domUtils.isInheritedProperty(name);
       let value = store.userProperties.getProperty(this.style, name,
                                                    prop.value);
       let textProp = new TextProperty(this, name, value, prop.priority,
-                                      !("commentOffsets" in prop));
+                                      !("commentOffsets" in prop),
+                                      invisible);
       textProps.push(textProp);
     }
 
     return textProps;
   },
 
   /**
    * Return the list of disabled properties from the store for this rule.
@@ -1016,68 +1018,99 @@ Rule.prototype = {
    *        The text property that will be left to focus on a sibling.
    * @param {Number} direction
    *        The move focus direction number.
    */
   editClosestTextProperty: function(textProperty, direction) {
     let index = this.textProps.indexOf(textProperty);
 
     if (direction === Ci.nsIFocusManager.MOVEFOCUS_FORWARD) {
-      if (index === this.textProps.length - 1) {
+      for (++index; index < this.textProps.length; ++index) {
+        if (!this.textProps[index].invisible) {
+          break;
+        }
+      }
+      if (index === this.textProps.length) {
         textProperty.rule.editor.closeBrace.click();
       } else {
-        let nextProp = this.textProps[index + 1];
-        nextProp.editor.nameSpan.click();
+        this.textProps[index].editor.nameSpan.click();
       }
     } else if (direction === Ci.nsIFocusManager.MOVEFOCUS_BACKWARD) {
-      if (index === 0) {
+      for (--index; index >= 0; --index) {
+        if (!this.textProps[index].invisible) {
+          break;
+        }
+      }
+      if (index < 0) {
         textProperty.editor.ruleEditor.selectorText.click();
       } else {
-        let prevProp = this.textProps[index - 1];
-        prevProp.editor.valueSpan.click();
+        this.textProps[index].editor.valueSpan.click();
       }
     }
   },
 
   /**
    * Return a string representation of the rule.
    */
   stringifyRule: function() {
     let selectorText = this.selectorText;
     let cssText = "";
     let terminator = osString === "WINNT" ? "\r\n" : "\n";
 
     for (let textProp of this.textProps) {
-      cssText += "\t" + textProp.stringifyProperty() + terminator;
+      if (!textProp.invisible) {
+        cssText += "\t" + textProp.stringifyProperty() + terminator;
+      }
     }
 
     return selectorText + " {" + terminator + cssText + "}";
+  },
+
+  /**
+   * See whether this rule has any non-invisible properties.
+   * @return {Boolean} true if there is any visible property, or false
+   *         if all properties are invisible
+   */
+  anyProperties: function() {
+    for (let prop of this.textProps) {
+      if (!prop.invisible) {
+        return true;
+      }
+    }
+    return false;
   }
 };
 
 /**
  * A single property in a rule's authoredText.
  *
  * @param {Rule} rule
  *        The rule this TextProperty came from.
  * @param {String} name
  *        The text property name (such as "background" or "border-top").
  * @param {String} value
  *        The property's value (not including priority).
  * @param {String} priority
  *        The property's priority (either "important" or an empty string).
  * @param {Boolean} enabled
  *        Whether the property is enabled.
+ * @param {Boolean} invisible
+ *        Whether the property is invisible.  An invisible property
+ *        does not show up in the UI; these are needed so that the
+ *        index of a property in textProps is the same as the index
+ *        coming from parseDeclarations.
  */
-function TextProperty(rule, name, value, priority, enabled = true) {
+function TextProperty(rule, name, value, priority, enabled = true,
+                      invisible = false) {
   this.rule = rule;
   this.name = name;
   this.value = value;
   this.priority = priority;
   this.enabled = !!enabled;
+  this.invisible = invisible;
   this.updateComputed();
 }
 
 TextProperty.prototype = {
   /**
    * Update the editor associated with this text property,
    * if any.
    */
@@ -2239,17 +2272,17 @@ CssRuleView.prototype = {
    */
   highlightRule: function(rule) {
     let isRuleSelectorHighlighted = this._highlightRuleSelector(rule);
     let isStyleSheetHighlighted = this._highlightStyleSheet(rule);
     let isHighlighted = isRuleSelectorHighlighted || isStyleSheetHighlighted;
 
     // Highlight search matches in the rule properties
     for (let textProp of rule.textProps) {
-      if (this._highlightProperty(textProp.editor)) {
+      if (!textProp.invisible && this._highlightProperty(textProp.editor)) {
         isHighlighted = true;
       }
     }
 
     return isHighlighted;
   },
 
   /**
@@ -2747,17 +2780,17 @@ RuleEditor.prototype = {
             textContent: selectorText.value,
             class: selectorClass
           });
         }
       });
     }
 
     for (let prop of this.rule.textProps) {
-      if (!prop.editor) {
+      if (!prop.editor && !prop.invisible) {
         let editor = new TextPropertyEditor(this, prop);
         this.propertyList.appendChild(editor.element);
       }
     }
   },
 
   /**
    * Programatically add a new property to the rule.
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js b/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js
index 9d49ac0..df06400 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js
@@ -33,13 +33,17 @@ function* simpleInherit(inspector, view) {
   let elementRule = elementStyle.rules[0];
   ok(!elementRule.inherited,
     "Element style attribute should not consider itself inherited.");
 
   let inheritRule = elementStyle.rules[1];
   is(inheritRule.selectorText, "#test2",
     "Inherited rule should be the one that includes inheritable properties.");
   ok(!!inheritRule.inherited, "Rule should consider itself inherited.");
-  is(inheritRule.textProps.length, 1,
-    "Should only display one inherited style");
-  let inheritProp = inheritRule.textProps[0];
+  is(inheritRule.textProps.length, 2,
+    "Rule should have two styles");
+  let bgcProp = inheritRule.textProps[0];
+  is(bgcProp.name, "background-color",
+     "background-color property should exist");
+  ok(bgcProp.invisible, "background-color property should be invisible");
+  let inheritProp = inheritRule.textProps[1];
   is(inheritProp.name, "color", "color should have been inherited.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js b/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js
index a6edd13..6ea1406 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js
@@ -35,19 +35,21 @@ function* userAgentStylesUneditable(inspector, view) {
 
   yield selectNode("a", inspector);
   let uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
 
   for (let rule of uaRules) {
     ok(rule.editor.element.hasAttribute("uneditable"),
       "UA rules have uneditable attribute");
 
-    ok(!rule.textProps[0].editor.nameSpan._editable,
+    let firstProp = rule.textProps.filter(p => !p.invisible)[0];
+
+    ok(!firstProp.editor.nameSpan._editable,
       "nameSpan is not editable");
-    ok(!rule.textProps[0].editor.valueSpan._editable,
+    ok(!firstProp.editor.valueSpan._editable,
       "valueSpan is not editable");
     ok(!rule.editor.closeBrace._editable, "closeBrace is not editable");
 
     let colorswatch = rule.editor.element
       .querySelector(".ruleview-colorswatch");
     if (colorswatch) {
       ok(!view.tooltips.colorPicker.swatches.has(colorswatch),
         "The swatch is not editable");
