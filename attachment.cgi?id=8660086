# HG changeset patch
# User Tom Tromey <tromey@mozilla.com>
# Parent  6dbfe6719621efde26304de20ebf9c6e2cf1f1b2

Bug 984880 - rolled-up patch v5

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1379,17 +1379,17 @@ pref("devtools.inspector.showUserAgentSt
 // Show all native anonymous content (like controls in <video> tags)
 pref("devtools.inspector.showAllAnonymousContent", false);
 // Enable the MDN docs tooltip
 pref("devtools.inspector.mdnDocsTooltip.enabled", true);
 // Show the new animation inspector UI
 pref("devtools.inspector.animationInspectorV3", false);
 
 // DevTools default color unit
-pref("devtools.defaultColorUnit", "hex");
+pref("devtools.defaultColorUnit", "authored");
 
 // Enable the Responsive UI tool
 pref("devtools.responsiveUI.no-reload-notification", false);
 
 // Enable the Debugger
 pref("devtools.debugger.enabled", true);
 pref("devtools.debugger.chrome-debugging-host", "localhost");
 pref("devtools.debugger.chrome-debugging-port", 6080);
diff --git a/browser/devtools/framework/toolbox-options.xul b/browser/devtools/framework/toolbox-options.xul
--- a/browser/devtools/framework/toolbox-options.xul
+++ b/browser/devtools/framework/toolbox-options.xul
@@ -50,16 +50,17 @@
           <description>
             <label control="defaultColorUnitMenuList"
                    accesskey="&options.defaultColorUnit.accesskey;"
             >&options.defaultColorUnit.label;</label>
             <hbox>
               <menulist id="defaultColorUnitMenuList"
                         data-pref="devtools.defaultColorUnit">
                 <menupopup>
+                  <menuitem label="&options.defaultColorUnit.authored;" value="authored"/>
                   <menuitem label="&options.defaultColorUnit.hex;" value="hex"/>
                   <menuitem label="&options.defaultColorUnit.hsl;" value="hsl"/>
                   <menuitem label="&options.defaultColorUnit.rgb;" value="rgb"/>
                   <menuitem label="&options.defaultColorUnit.name;" value="name"/>
                 </menupopup>
               </menulist>
             </hbox>
           </description>
diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -91,37 +91,37 @@ EditingSession.prototype = {
 
     for (let property of properties) {
       if (!this._modifications.has(property.name)) {
         this._modifications.set(property.name,
           this.getPropertyFromRule(this._rules[0], property.name));
       }
 
       if (property.value == "") {
-        modifications.removeProperty(property.name);
+        modifications.removeProperty(-1, property.name);
       } else {
-        modifications.setProperty(property.name, property.value, "");
+        modifications.setProperty(-1, property.name, property.value, "");
       }
     }
 
     return modifications.apply().then(null, console.error);
   },
 
   /**
    * Reverts all of the property changes made by this instance. Returns a
    * promise that will be resolved when complete.
    */
   revert: function() {
     let modifications = this._rules[0].startModifyingProperties();
 
     for (let [property, value] of this._modifications) {
       if (value != "") {
-        modifications.setProperty(property, value, "");
+        modifications.setProperty(-1, property, value, "");
       } else {
-        modifications.removeProperty(property);
+        modifications.removeProperty(-1, property);
       }
     }
 
     return modifications.apply().then(null, console.error);
   },
 
   destroy: function() {
     this._doc = null;
diff --git a/browser/devtools/shared/css-parsing-utils.js b/browser/devtools/shared/css-parsing-utils.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/css-parsing-utils.js
@@ -0,0 +1,1061 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This file holds various CSS parsing and rewriting utilities.
+// Some entry points of note are:
+// parseDeclarations - parse a CSS rule into declarations
+// RuleRewriter - rewrite CSS rule text
+// parsePseudoClassesAndAttributes - parse selector and extract
+//     pseudo-classes
+// parseSingleValue - parse a single CSS property value
+
+"use strict";
+
+const {Cc, Ci, Cu} = require("chrome");
+Cu.importGlobalProperties(["CSS"]);
+loader.lazyGetter(this, "DOMUtils", () => {
+  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
+});
+
+const SELECTOR_ATTRIBUTE = exports.SELECTOR_ATTRIBUTE = 1;
+const SELECTOR_ELEMENT = exports.SELECTOR_ELEMENT = 2;
+const SELECTOR_PSEUDO_CLASS = exports.SELECTOR_PSEUDO_CLASS = 3;
+
+// Used to test whether a newline appears anywhere in some text.
+const NEWLINE_RX = /[\r\n]/;
+// Used to test whether a bit of text starts an empty comment, either
+// an "ordinary" /* ... */ comment, or a "heuristic bypass" comment
+// like /*! ... */.
+const EMPTY_COMMENT_START_RX = /^\/\*!?[ \r\n\t\f]*$/;
+// Used to test whether a bit of text ends an empty comment.
+const EMPTY_COMMENT_END_RX = /^[ \r\n\t\f]*\*\//;
+// Used to test whether a string starts with a blank line.
+const BLANK_LINE_RX = /^[ \t]*(?:\r\n|\n|\r|\f|$)/;
+
+// When commenting out a declaration, we put this character into the
+// comment opener so that future parses of the commented text know to
+// bypass the property name validity heuristic.
+const COMMENT_PARSING_HEURISTIC_BYPASS_CHAR = "!";
+
+/**
+ * A generator function that lexes a CSS source string, yielding the
+ * CSS tokens.  Comment tokens are dropped.
+ *
+ * @param {String} CSS source string
+ * @yield {CSSToken} The next CSSToken that is lexed
+ * @see CSSToken for details about the returned tokens
+ */
+function* cssTokenizer(string) {
+  let lexer = DOMUtils.getCSSLexer(string);
+  while (true) {
+    let token = lexer.nextToken();
+    if (!token) {
+      break;
+    }
+    // None of the existing consumers want comments.
+    if (token.tokenType !== "comment") {
+      yield token;
+    }
+  }
+}
+
+/**
+ * Pass |string| to the CSS lexer and return an array of all the
+ * returned tokens.  Comment tokens are not included.  In addition to
+ * the usual information, each token will have starting and ending
+ * line and column information attached.  Specifically, each token
+ * has an additional "loc" attribute.  This attribute is an object
+ * of the form {line: L, column: C}.  Lines and columns are both zero
+ * based.
+ *
+ * It's best not to add new uses of this function.  In general it is
+ * simpler and better to use the CSSToken offsets, rather than line
+ * and column.  Also, this function lexes the entire input string at
+ * once, rather than lazily yielding a token stream.  Use
+ * |cssTokenizer| or |DOMUtils.getCSSLexer| instead.
+ *
+ * @param{String} string The input string.
+ * @return {Array} An array of tokens (@see CSSToken) that have
+ *        line and column information.
+ */
+function cssTokenizerWithLineColumn(string) {
+  let lexer = DOMUtils.getCSSLexer(string);
+  let result = [];
+  let prevToken = undefined;
+  while (true) {
+    let token = lexer.nextToken();
+    let lineNumber = lexer.lineNumber;
+    let columnNumber = lexer.columnNumber;
+
+    if (prevToken) {
+      prevToken.loc.end = {
+        line: lineNumber,
+        column: columnNumber
+      };
+    }
+
+    if (!token) {
+      break;
+    }
+
+    if (token.tokenType === "comment") {
+      // We've already dealt with the previous token's location.
+      prevToken = undefined;
+    } else {
+      let startLoc = {
+        line: lineNumber,
+        column: columnNumber
+      };
+      token.loc = {start: startLoc};
+
+      result.push(token);
+      prevToken = token;
+    }
+  }
+
+  return result;
+}
+
+/**
+ * Escape a comment body.  Find the comment start and end strings in a
+ * string and inserts backslashes so that the resulting text can
+ * itself be put inside a comment.
+ *
+ * @param {String} inputString
+ *                 input string
+ * @return {String} the escaped result
+ */
+function escapeCSSComment(inputString) {
+  let result = inputString.replace(/\/(\\*)\*/g, "/\\$1*");
+  return result.replace(/\*(\\*)\//g, "*\\$1/");
+}
+
+/**
+ * Un-escape a comment body.  This undoes any comment escaping that
+ * was done by escapeCSSComment.  That is, given input like "/\*
+ * comment *\/", it will strip the backslashes.
+ *
+ * @param {String} inputString
+ *                 input string
+ * @return {String} the un-escaped result
+ */
+function unescapeCSSComment(inputString) {
+  let result = inputString.replace(/\/\\(\\*)\*/g, "/$1*");
+  return result.replace(/\*\\(\\*)\//g, "*$1/");
+}
+
+/**
+ * A convenience function that returns the string needed to nicely
+ * terminate the string originally passed to the lexer.  This differs
+ * from @see CSSLexer.impliedEOFCharacters in that it also includes
+ * a trailing backslash in some cases.
+ *
+ * @param {CSSLexer} lexer The lexer
+ * @return {String} the termination string
+ */
+function getLexerEOFChars(lexer) {
+  return (lexer.droppedTrailingBackslash ? "\\" : "") +
+    lexer.impliedEOFCharacters;
+}
+
+/**
+ * A helper function for parseDeclarations that implements a heuristic
+ * to decide whether a given bit of comment text should be parsed as a
+ * declaration.
+ *
+ * @param {String} name the property name that has been parsed
+ * @return {Boolean} true if the property should be parsed, false if
+ *                        the remainder of the comment should be skipped
+ */
+function shouldParsePropertyInComment(name) {
+  try {
+    // If the property name is invalid, the cssPropertyIsShorthand
+    // will throw an exception.  But if it is valid, no exception will
+    // be thrown; so we just ignore the return value.
+    DOMUtils.cssPropertyIsShorthand(name);
+    return true;
+  } catch (e) {
+    return false;
+  }
+}
+
+/**
+ * A helper function for @see parseDeclarations that handles parsing
+ * of comment text.  This wraps a recursive call to parseDeclarations
+ * with the processing needed to ensure that offsets in the result
+ * refer back to the original, unescaped, input string.
+ *
+ * @param {String} commentText The text of the comment, without the
+ *                             delimiters.
+ * @param {Number} startOffset The offset of the comment opener
+ *                             in the original text.
+ * @param {Number} endOffset The offset of the comment closer
+ *                           in the original text.
+ * @return {array} Array of declarations of the same form as returned
+ *                 by parseDeclarations.
+ */
+function parseCommentDeclarations(commentText, startOffset, endOffset) {
+  let commentOverride = false;
+  if (commentText === "") {
+    return [];
+  } else if (commentText[0] === COMMENT_PARSING_HEURISTIC_BYPASS_CHAR) {
+    // This is the special sign that the comment was written by
+    // rewriteDeclarations and so we should bypass the usual
+    // heuristic.
+    commentOverride = true;
+    commentText = commentText.substring(1);
+  }
+
+  let rewrittenText = unescapeCSSComment(commentText);
+
+  // We might have rewritten an embedded comment.  For example
+  // /\* ... *\/ would turn into /* ... */.
+  // This rewriting is necessary for proper lexing, but it means
+  // that the offsets we get back can be off.  So now we compute
+  // a map so that we can rewrite offsets later.  The map is the same
+  // length as |rewrittenText| and tells us how to map an index
+  // into |rewrittenText| to an index into |commentText|.
+  //
+  // First, we find the location of each comment starter or closer in
+  // |rewrittenText|.  At these spots we put a 1 into |rewrites|.
+  // Then we walk the array again, using the elements to compute a
+  // delta, which we use to make the final mapping.
+  //
+  // Note we allocate one extra entry because we can see an ending
+  // offset that is equal to the length.
+  let rewrites = new Array(rewrittenText.length + 1).fill(0);
+
+  let commentRe = /\/\\*\*|\*\\*\//g;
+  while (true) {
+    let matchData = commentRe.exec(rewrittenText);
+    if (!matchData) {
+      break;
+    }
+    rewrites[matchData.index] = 1;
+  }
+
+  let delta = 0;
+  for (let i = 0; i <= rewrittenText.length; ++i) {
+    delta += rewrites[i];
+    // |startOffset| to add the offset from the comment starter, |+2|
+    // for the length of the "/*", then |i| and |delta| as described
+    // above.
+    rewrites[i] = startOffset + 2 + i + delta;
+    if (commentOverride) {
+      ++rewrites[i];
+    }
+  }
+
+  // Note that we pass "false" for parseComments here.  It doesn't
+  // seem worthwhile to support declarations in comments-in-comments
+  // here, as there's no way to generate those using the tools, and
+  // users would be crazy to write such things.
+  let newDecls = parseDeclarationsInternal(rewrittenText, false,
+                                           true, commentOverride);
+  for (let decl of newDecls) {
+    decl.offsets[0] = rewrites[decl.offsets[0]];
+    decl.offsets[1] = rewrites[decl.offsets[1]];
+    decl.colonOffsets[0] = rewrites[decl.colonOffsets[0]];
+    decl.colonOffsets[1] = rewrites[decl.colonOffsets[1]];
+    decl.commentOffsets = [startOffset, endOffset];
+  }
+  return newDecls;
+}
+
+/**
+ * A helper function for parseDeclarationsInternal that creates a new
+ * empty declaration.
+ *
+ * @return {object} an empty declaration of the form returned by
+ *                  parseDeclarations
+ */
+function getEmptyDeclaration() {
+  return {name: "", value: "", priority: "",
+          terminator: "",
+          offsets: [undefined, undefined],
+          colonOffsets: false};
+}
+
+/**
+ * A helper function that does all the parsing work for
+ * parseDeclarations.  This is separate because it has some arguments
+ * that don't make sense in isolation.
+ *
+ * The return value and arguments are like parseDeclarations, with
+ * these additional arguments.
+ *
+ * @param {Boolean} inComment
+ *        If true, assume that this call is parsing some text
+ *        which came from a comment in another declaration.
+ *        In this case some heuristics are used to avoid parsing
+ *        text which isn't obviously a series of declarations.
+ * @param {Boolean} commentOverride
+ *        This only makes sense when inComment=true.
+ *        When true, assume that the comment was generated by
+ *        rewriteDeclarations, and skip the usual name-checking
+ *        heuristic.
+ */
+function parseDeclarationsInternal(inputString, parseComments,
+                                   inComment, commentOverride) {
+  if (inputString === null || inputString === undefined) {
+    throw new Error("empty input string");
+  }
+
+  let lexer = DOMUtils.getCSSLexer(inputString);
+
+  let declarations = [getEmptyDeclaration()];
+  let lastProp = declarations[0];
+
+  let current = "", hasBang = false;
+  while (true) {
+    let token = lexer.nextToken();
+    if (!token) {
+      break;
+    }
+
+    // Ignore HTML comment tokens (but parse anything they might
+    // happen to surround).
+    if (token.tokenType === "htmlcomment") {
+      continue;
+    }
+
+    // Update the start and end offsets of the declaration, but only
+    // when we see a significant token.
+    if (token.tokenType !== "whitespace" && token.tokenType !== "comment") {
+      if (lastProp.offsets[0] === undefined) {
+        lastProp.offsets[0] = token.startOffset;
+      }
+      lastProp.offsets[1] = token.endOffset;
+    } else if (lastProp.name && !current && !hasBang &&
+               !lastProp.priority && lastProp.colonOffsets[1]) {
+      // Whitespace appearing after the ":" is attributed to it.
+      lastProp.colonOffsets[1] = token.endOffset;
+    }
+
+    if (token.tokenType === "symbol" && token.text === ":") {
+      if (!lastProp.name) {
+        // Set the current declaration name if there's no name yet
+        lastProp.name = current.trim();
+        lastProp.colonOffsets = [token.startOffset, token.endOffset];
+        current = "";
+        hasBang = false;
+
+        // When parsing a comment body, if the left-hand-side is not a
+        // valid property name, then drop it and stop parsing.
+        if (inComment && !commentOverride &&
+            !shouldParsePropertyInComment(lastProp.name)) {
+          lastProp.name = null;
+          break;
+        }
+      } else {
+        // Otherwise, just append ':' to the current value (declaration value
+        // with colons)
+        current += ":";
+      }
+    } else if (token.tokenType === "symbol" && token.text === ";") {
+      lastProp.terminator = "";
+      lastProp.value = current.trim();
+      current = "";
+      hasBang = false;
+      declarations.push(getEmptyDeclaration());
+      lastProp = declarations[declarations.length - 1];
+    } else if (token.tokenType === "ident") {
+      if (token.text === "important" && hasBang) {
+        lastProp.priority = "important";
+        hasBang = false;
+      } else {
+        if (hasBang) {
+          current += "!";
+        }
+        current += token.text;
+      }
+    } else if (token.tokenType === "symbol" && token.text === "!") {
+      hasBang = true;
+    } else if (token.tokenType === "whitespace") {
+      if (current !== "") {
+        current += " ";
+      }
+    } else if (token.tokenType === "comment") {
+      if (parseComments && !lastProp.name && !lastProp.value) {
+        let commentText = inputString.substring(token.startOffset + 2,
+                                                token.endOffset - 2);
+        let newDecls = parseCommentDeclarations(commentText, token.startOffset,
+                                                token.endOffset);
+
+        // Insert the new declarations just before the final element.
+        let lastDecl = declarations.pop();
+        declarations = [...declarations, ...newDecls, lastDecl];
+      }
+    } else {
+      current += inputString.substring(token.startOffset, token.endOffset);
+    }
+  }
+
+  // Handle whatever trailing properties or values might still be there
+  if (current) {
+    if (!lastProp.name) {
+      // Ignore this case in comments.
+      if (!inComment) {
+        // Trailing property found, e.g. p1:v1;p2:v2;p3
+        lastProp.name = current.trim();
+      }
+    } else {
+      // Trailing value found, i.e. value without an ending ;
+      lastProp.value = current.trim();
+      let terminator = getLexerEOFChars(lexer);
+      lastProp.terminator = terminator + ";";
+      // If the input was unterminated, attribute the remainder to
+      // this property.  This avoids some bad behavior when rewriting
+      // an unterminated comment.
+      if (terminator) {
+        lastProp.offsets[1] = inputString.length;
+      }
+    }
+  }
+
+  // Remove declarations that have neither a name nor a value
+  declarations = declarations.filter(prop => prop.name || prop.value);
+
+  return declarations;
+}
+
+/**
+ * Returns an array of CSS declarations given a string.
+ * For example, parseDeclarations("width: 1px; height: 1px") would return
+ * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
+ *
+ * The input string is assumed to only contain declarations so { and }
+ * characters will be treated as part of either the property or value,
+ * depending where it's found.
+ *
+ * @param {String} inputString
+ *        An input string of CSS
+ * @param {Boolean} parseComments
+ *        If true, try to parse the contents of comments as well.
+ *        A comment will only be parsed if it occurs outside of
+ *        the body of some other declaration.
+ * @return {Array} an array of objects with the following signature:
+ *         [{"name": string, "value": string, "priority": string,
+ *           "terminator": string,
+ *           "offsets": [start, end], "colonOffsets": [start, end]},
+ *          ...]
+ *         Here, "offsets" holds the offsets of the start and end
+ *         of the declaration text, in a form suitable for use with
+ *         String.substring.
+ *         "terminator" is a string to use to terminate the declaration,
+ *         usually "" to mean no additional termination is needed.
+ *         "colonOffsets" holds the start and end locations of the
+ *         ":" that separates the property name from the value.
+ *         If the declaration appears in a comment, then there will
+ *         be an additional {"commentOffsets": [start, end] property
+ *         on the object, which will hold the offsets of the start
+ *         and end of the enclosing comment.
+ */
+function parseDeclarations(inputString, parseComments = false) {
+  return parseDeclarationsInternal(inputString, parseComments, false, false);
+}
+
+/**
+ * Return an object that can be used to rewrite declarations in some
+ * source text.  The source text and parsing are handled in the same
+ * way as @see parseDeclarations, with |parseComments| being true.
+ * Rewriting is done by calling one of the modification functions like
+ * setPropertyEnabled.  The returned object has the same interface
+ * as @see RuleModificationList.
+ *
+ * An example showing how to disable the 3rd property in a rule:
+ *
+ *    let rewriter = new RuleRewriter(ruleActor, ruleActor.authoredText);
+ *    rewriter.setPropertyEnabled(3, "color", false);
+ *    rewriter.apply().then(() => { ... the change is made ... });
+ *
+ * The exported rewriting methods are |renameProperty|, |setPropertyEnabled|,
+ * |createProperty|, |setProperty|, and |removeProperty|.  The |apply|
+ * method can be used to send the edited text to the StyleRuleActor;
+ * |getDefaultIndentation| is useful for the methods requiring a
+ * default indentation value; and |getResult| is useful for testing.
+ *
+ * Additionally, editing will set the |changedDeclarations| property
+ * on this object.  This property has the same form as the |changed|
+ * property of the object returned by |getResult|.
+ *
+ * @param {StyleRuleFront} rule The style rule to use.  Note that this
+ *        is only needed by the |apply| and |getDefaultIndentation| methods;
+ *        and in particular for testing it can be |null|.
+ * @param {String} inputString The CSS source text to parse and modify.
+ * @return {Object} an object that can be used to rewrite the input text.
+ */
+function RuleRewriter(rule, inputString) {
+  this.rule = rule;
+  this.inputString = inputString;
+  // Whether there are any newlines in the input text.
+  this.hasNewLine = /[\r\n]/.test(this.inputString);
+  // Keep track of which any declarations we had to rewrite while
+  // performing the requested action.
+  this.changedDeclarations = {};
+  // The declarations.
+  this.declarations = parseDeclarations(this.inputString, true);
+
+  this.decl = null;
+  this.result = null;
+}
+
+RuleRewriter.prototype = {
+  /**
+   * An internal function to complete initialization and set some
+   * properties for further processing.
+   *
+   * @param {Number} index The index of the property to modify
+   */
+  completeInitialization: function(index) {
+    if (index < 0) {
+      throw new Error("Invalid index " + index + ". Expected positive integer");
+    }
+    // |decl| is the declaration to be rewritten, or null if there is no
+    // declaration corresponding to |index|.
+    // |result| is used to accumulate the result text.
+    if (index < this.declarations.length) {
+      this.decl = this.declarations[index];
+      this.result = this.inputString.substring(0, this.decl.offsets[0]);
+    } else {
+      this.decl = null;
+      this.result = this.inputString;
+    }
+  },
+
+  /**
+   * A helper function to compute the indentation of some text.  This
+   * examines the rule's existing text to guess the indentation to use;
+   * unlike |getDefaultIndentation|, which examines the entire style
+   * sheet.
+   *
+   * @param {String} string the input text
+   * @param {Number} offset the offset at which to compute the indentation
+   * @return {String} the indentation at the indicated position
+   */
+  getIndentation: function(string, offset) {
+    let originalOffset = offset;
+    for (--offset; offset >= 0; --offset) {
+      let c = string[offset];
+      if (c === "\r" || c === "\n" || c === "\f") {
+        return string.substring(offset + 1, originalOffset);
+      }
+      if (c !== " " && c !== "\t") {
+        // Found some non-whitespace character before we found a newline
+        // -- let's reset the starting point and keep going, as we saw
+        // something on the line before the declaration.
+        originalOffset = offset;
+      }
+    }
+    // Ran off the end.
+    return "";
+  },
+
+  /**
+   * Modify a property value to ensure it is "lexically safe" for
+   * insertion into a style sheet.  This function doesn't attempt to
+   * ensure that the resulting text is a valid value for the given
+   * property; but rather just that inserting the text into the style
+   * sheet will not cause unwanted changes to other rules or
+   * declarations.
+   *
+   * @param {String} text The input text.  This should include the trailing ";".
+   * @return {String} Text that has been rewritten to be "lexically safe".
+   */
+  sanitizePropertyValue: function(text) {
+    let lexer = DOMUtils.getCSSLexer(text);
+
+    let result = "";
+    let previousOffset = 0;
+    let braceDepth = 0;
+    while (true) {
+      let token = lexer.nextToken();
+      if (!token) {
+        break;
+      }
+
+      if (token.tokenType === "symbol") {
+        switch (token.text) {
+          case ";":
+            // We simply drop the ";" here.  This lets us cope with
+            // declarations that don't have a ";" and also other
+            // termination.  The caller handles adding the ";" again.
+            result += text.substring(previousOffset, token.startOffset);
+            previousOffset = token.endOffset;
+            break;
+
+          case "{":
+            ++braceDepth;
+            break;
+
+          case "}":
+            --braceDepth;
+            if (braceDepth < 0) {
+              // Found an unmatched close bracket.
+              braceDepth = 0;
+              // Copy out text from |previousOffset|.
+              result += text.substring(previousOffset, token.startOffset);
+              // Quote the offending symbol.
+              result += "\\" + token.text;
+              previousOffset = token.endOffset;
+            }
+            break;
+        }
+      }
+    }
+
+    // Copy out any remaining text, then any needed terminators.
+    result += text.substring(previousOffset, text.length) +
+      getLexerEOFChars(lexer);
+    return result;
+  },
+
+  /**
+   * Start at |index| and skip whitespace
+   * backward in |string|.  Return the index of the first
+   * non-whitespace character, or -1 if the entire string was
+   * whitespace.
+   * @param {String} string the input string
+   * @param {Number} index the index at which to start
+   * @return {Number} index of the first non-whitespace character, or -1
+   */
+  skipWhitespaceBackward: function(string, index) {
+    for (--index;
+         index >= 0 && (string[index] === " " || string[index] === "\t");
+         --index) {
+      // Nothing.
+    }
+    return index;
+  },
+
+  /**
+   * Terminate a given declaration, if needed.
+   *
+   * @param {Number} index The index of the rule to possibly
+   *                       terminate.  It might be invalid, so this
+   *                       function must check for that.
+   */
+  maybeTerminateDecl: function(index) {
+    if (index < 0 || index >= this.declarations.length
+        // No need to rewrite declarations in comments.
+        || ("commentOffsets" in this.declarations[index])) {
+      return;
+    }
+
+    let termDecl = this.declarations[index];
+    let endIndex = termDecl.offsets[1];
+    // Due to an oddity of the lexer, we might have gotten a bit of
+    // extra whitespace in a trailing bad_url token -- so be sure to
+    // skip that as well.
+    endIndex = this.skipWhitespaceBackward(this.result, endIndex) + 1;
+
+    let trailingText = this.result.substring(endIndex);
+    if (termDecl.terminator) {
+      // Insert the terminator just at the end of the declaration,
+      // before any trailing whitespace.
+      this.result = this.result.substring(0, endIndex) + termDecl.terminator +
+        trailingText;
+      // The terminator includes the ";", but we don't want it in
+      // the changed value.
+      this.changedDeclarations[index] =
+        termDecl.value + termDecl.terminator.slice(0, -1);
+    }
+    // If the rule generally has newlines, but this particular
+    // declaration doesn't have a trailing newline, insert one now.
+    // Maybe this style is too weird to bother with.
+    if (this.hasNewLine && !NEWLINE_RX.test(trailingText)) {
+      this.result += "\n";
+    }
+  },
+
+  /**
+   * Sanitize the given property value and return the sanitized form.
+   * If the property is rewritten during sanitization, make a note in
+   * |changedDeclarations|.
+   *
+   * @param {String} text The property text.
+   * @param {Number} index The index of the property.
+   * @return {String} The sanitized text.
+   */
+  sanitizeText: function(text, index) {
+    let sanitizedText = this.sanitizePropertyValue(text);
+    if (sanitizedText !== text) {
+      this.changedDeclarations[index] = sanitizedText;
+    }
+    return sanitizedText;
+  },
+
+  /**
+   * Rename a declaration.
+   *
+   * @param {Number} index index of the property in the rule.
+   * @param {String} name current name of the property
+   * @param {String} newName new name of the property
+   */
+  renameProperty: function(index, name, newName) {
+    this.completeInitialization(index);
+    this.result += CSS.escape(newName);
+    // We could conceivably compute the name offsets instead so we
+    // could preserve white space and comments on the LHS of the ":".
+    this.completeCopying(this.decl.colonOffsets[0]);
+  },
+
+  /**
+   * Enable or disable a declaration
+   *
+   * @param {Number} index index of the property in the rule.
+   * @param {String} name current name of the property
+   * @param {Boolean} isEnabled true if the property should be enabled;
+   *                        false if it should be disabled
+   */
+  setPropertyEnabled: function(index, name, isEnabled) {
+    this.completeInitialization(index);
+    const decl = this.decl;
+    let copyOffset = decl.offsets[1];
+    if (isEnabled) {
+      // Enable it.  First see if the comment start can be deleted.
+      let commentStart = decl.commentOffsets[0];
+      if (EMPTY_COMMENT_START_RX.test(this.result.substring(commentStart))) {
+        this.result = this.result.substring(0, commentStart);
+      } else {
+        this.result += "*/ ";
+      }
+
+      // Insert the name and value separately, so we can report
+      // sanitization changes properly.
+      let commentNamePart =
+          this.inputString.substring(decl.offsets[0],
+                                     decl.colonOffsets[1]);
+      this.result += unescapeCSSComment(commentNamePart);
+
+      // When uncommenting, we must be sure to sanitize the text, to
+      // avoid things like /* decl: }; */, which will be accepted as
+      // a property but which would break the entire style sheet.
+      let newText = this.inputString.substring(decl.colonOffsets[1],
+                                               decl.offsets[1]);
+      newText = unescapeCSSComment(newText).trimRight();
+      this.result += this.sanitizeText(newText, index) + ";";
+
+      // See if the comment end can be deleted.
+      let trailingText = this.inputString.substring(decl.offsets[1]);
+      if (EMPTY_COMMENT_END_RX.test(trailingText)) {
+        copyOffset = decl.commentOffsets[1];
+      } else {
+        this.result += " /*";
+      }
+    } else {
+      // Disable it.  Note that we use our special comment syntax
+      // here.
+      let declText = this.inputString.substring(decl.offsets[0],
+                                                decl.offsets[1]);
+      this.result += "/*" + COMMENT_PARSING_HEURISTIC_BYPASS_CHAR +
+        " " + escapeCSSComment(declText) + " */";
+    }
+    this.completeCopying(copyOffset);
+  },
+
+  /**
+   * Create a new declaration.
+   *
+   * @param {Number} index index of the property in the rule.
+   * @param {String} name name of the new property
+   * @param {String} value value of the new property
+   * @param {String} priority priority of the new property; either
+   *                          the empty string or "important"
+   */
+  createProperty: function(index, name, value, priority, defaultIndentation) {
+    this.completeInitialization(index);
+    let newIndentation = "";
+    if (this.hasNewLine) {
+      if (this.declarations.length > 0) {
+        newIndentation = this.getIndentation(this.inputString,
+                                             this.declarations[0].offsets[0]);
+      } else {
+        newIndentation = defaultIndentation;
+      }
+    }
+
+    this.maybeTerminateDecl(index - 1);
+
+    // If we generally have newlines, and if skipping whitespace
+    // backward stops at a newline, then insert our text before that
+    // whitespace.  This ensures the indentation we computed is what
+    // is actually used.
+    let savedWhitespace = "";
+    if (this.hasNewLine) {
+      let wsOffset = this.skipWhitespaceBackward(this.result,
+                                                 this.result.length);
+      if (this.result[wsOffset] === "\r" || this.result[wsOffset] === "\n") {
+        savedWhitespace = this.result.substring(wsOffset + 1);
+        this.result = this.result.substring(0, wsOffset + 1);
+      }
+    }
+
+    this.result += newIndentation + CSS.escape(name) + ": " +
+      this.sanitizeText(value, index);
+
+    if (priority === "important") {
+      this.result += " !important";
+    }
+    this.result += ";";
+    if (this.hasNewLine) {
+      this.result += "\n";
+    }
+    this.result += savedWhitespace;
+
+    if (this.decl) {
+      // Still want to copy in the declaration previously at this
+      // index.
+      this.completeCopying(this.decl.offsets[0]);
+    }
+    // A harmless value.
+    this.completeCopying(this.inputString.length);
+  },
+
+  /**
+   * Set a declaration's value.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name the property's name
+   * @param {String} value the property's value
+   * @param {String} priority the property's priority, either the empty
+   *                          string or "important"
+   */
+  setProperty: function(index, name, value, priority, defaultIndentation) {
+    this.completeInitialization(index);
+    // We might see a "set" on a previously non-existent property; in
+    // that case, act like "create".
+    if (!this.decl) {
+      return this.createProperty(index, name, value, priority,
+                                 defaultIndentation);
+    }
+
+    // Note that this assumes that "set" never operates on disabled
+    // properties.
+    this.result += this.inputString.substring(this.decl.offsets[0],
+                                              this.decl.colonOffsets[1]) +
+      this.sanitizeText(value, index);
+
+    if (priority === "important") {
+      this.result += " !important";
+    }
+    this.result += ";";
+    this.completeCopying(this.decl.offsets[1]);
+  },
+
+  /**
+   * Remove a declaration.
+   *
+   * @param {Number} index index of the property in the rule.
+   * @param {String} name the name of the property to remove
+   */
+  removeProperty: function(index, name) {
+    this.completeInitialization(index);
+    let copyOffset = this.decl.offsets[1];
+    // Maybe removing this rule left us with a completely blank
+    // line.  In this case, we'll delete the whole thing.  We only
+    // bother with this if we're looking at sources that already
+    // have a newline somewhere.
+    if (this.hasNewLine) {
+      let nlOffset = this.skipWhitespaceBackward(this.result,
+                                                 this.decl.offsets[0]);
+      if (nlOffset < 0 || this.result[nlOffset] === "\r" ||
+          this.result[nlOffset] === "\n") {
+        let trailingText = this.inputString.substring(copyOffset);
+        let match = BLANK_LINE_RX.exec(trailingText);
+        if (match) {
+          this.result = this.result.substring(0, nlOffset + 1);
+          copyOffset += match[0].length;
+        }
+      }
+    }
+    this.completeCopying(copyOffset);
+  },
+
+  /**
+   * An internal function to copy any trailing text to the output
+   * string.
+   *
+   * @param {Number} copyOffset Offset into |inputString| of the
+   *        final text to copy to the output string.
+   */
+  completeCopying: function(copyOffset) {
+    // Add the trailing text.
+    this.result += this.inputString.substring(copyOffset);
+  },
+
+  /**
+   * Apply the modifications in this object to the associated rule.
+   *
+   * @return {Promise} A promise which will be resolved when the modifications
+   *         are complete.
+   */
+  apply: function() {
+    return this.rule.setRuleText(this.result);
+  },
+
+  /**
+   * Get the result of the rewriting.  This is used for testing.
+   *
+   * @return {object} an object of the form {changed: object, text: string}
+   *                  |changed| is an object where each key is
+   *                  the index of a property whose value had to be
+   *                  rewritten during the sanitization process, and
+   *                  whose value is the new text of the property.
+   *                  |text| is the rewritten text of the rule.
+   */
+  getResult: function() {
+    return {changed: this.changedDeclarations, text: this.result};
+  },
+
+  /**
+   * Return a promise that will be resolved to the default indentation
+   * of the rule.
+   *
+   * @return {Promise} a promise that will be resolved to a string
+   *         that holds the default indentation that should be used
+   *         for edits to the rule.
+   */
+  getDefaultIndentation: function() {
+    return this.rule.parentStyleSheet.guessIndentation();
+  }
+};
+
+/**
+ * Returns an array of the parsed CSS selector value and type given a string.
+ *
+ * The components making up the CSS selector can be extracted into 3 different
+ * types: element, attribute and pseudoclass. The object that is appended to
+ * the returned array contains the value related to one of the 3 types described
+ * along with the actual type.
+ *
+ * The following are the 3 types that can be returned in the object signature:
+ * (1) SELECTOR_ATTRIBUTE
+ * (2) SELECTOR_ELEMENT
+ * (3) SELECTOR_PSEUDO_CLASS
+ *
+ * @param {String} value
+ *        The CSS selector text.
+ * @return {Array} an array of objects with the following signature:
+ *         [{ "value": string, "type": integer }, ...]
+ */
+function parsePseudoClassesAndAttributes(value) {
+  if (!value) {
+    throw new Error("empty input string");
+  }
+
+  let tokens = cssTokenizer(value);
+  let result = [];
+  let current = "";
+  let functionCount = 0;
+  let hasAttribute = false;
+  let hasColon = false;
+
+  for (let token of tokens) {
+    if (token.tokenType === "ident") {
+      current += value.substring(token.startOffset, token.endOffset);
+
+      if (hasColon && !functionCount) {
+        if (current) {
+          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
+        }
+
+        current = "";
+        hasColon = false;
+      }
+    } else if (token.tokenType === "symbol" && token.text === ":") {
+      if (!hasColon) {
+        if (current) {
+          result.push({ value: current, type: SELECTOR_ELEMENT });
+        }
+
+        current = "";
+        hasColon = true;
+      }
+
+      current += token.text;
+    } else if (token.tokenType === "function") {
+      current += value.substring(token.startOffset, token.endOffset);
+      functionCount++;
+    } else if (token.tokenType === "symbol" && token.text === ")") {
+      current += token.text;
+
+      if (hasColon && functionCount == 1) {
+        if (current) {
+          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
+        }
+
+        current = "";
+        functionCount--;
+        hasColon = false;
+      } else {
+        functionCount--;
+      }
+    } else if (token.tokenType === "symbol" && token.text === "[") {
+      if (!hasAttribute && !functionCount) {
+        if (current) {
+          result.push({ value: current, type: SELECTOR_ELEMENT });
+        }
+
+        current = "";
+        hasAttribute = true;
+      }
+
+      current += token.text;
+    } else if (token.tokenType === "symbol" && token.text === "]") {
+      current += token.text;
+
+      if (hasAttribute && !functionCount) {
+        if (current) {
+          result.push({ value: current, type: SELECTOR_ATTRIBUTE });
+        }
+
+        current = "";
+        hasAttribute = false;
+      }
+    } else {
+      current += value.substring(token.startOffset, token.endOffset);
+    }
+  }
+
+  if (current) {
+    result.push({ value: current, type: SELECTOR_ELEMENT });
+  }
+
+  return result;
+}
+
+/**
+ * Expects a single CSS value to be passed as the input and parses the value
+ * and priority.
+ *
+ * @param {String} value
+ *        The value from the text editor.
+ * @return {Object} an object with 'value' and 'priority' properties.
+ */
+function parseSingleValue(value) {
+  let declaration = parseDeclarations("a: " + value + ";")[0];
+  return {
+    value: declaration ? declaration.value : "",
+    priority: declaration ? declaration.priority : ""
+  };
+}
+
+exports.cssTokenizer = cssTokenizer;
+exports.cssTokenizerWithLineColumn = cssTokenizerWithLineColumn;
+exports.escapeCSSComment = escapeCSSComment;
+// unescapeCSSComment is exported for testing.
+exports._unescapeCSSComment = unescapeCSSComment;
+exports.parseDeclarations = parseDeclarations;
+// parseCommentDeclarations is exported for testing.
+exports._parseCommentDeclarations = parseCommentDeclarations;
+exports.RuleRewriter = RuleRewriter;
+exports.parsePseudoClassesAndAttributes = parsePseudoClassesAndAttributes;
+exports.parseSingleValue = parseSingleValue;
diff --git a/browser/devtools/shared/moz.build b/browser/devtools/shared/moz.build
--- a/browser/devtools/shared/moz.build
+++ b/browser/devtools/shared/moz.build
@@ -28,16 +28,17 @@ EXTRA_JS_MODULES.devtools += [
     'widgets/VariablesViewController.jsm',
     'widgets/ViewHelpers.jsm',
 ]
 
 EXTRA_JS_MODULES.devtools.shared += [
     'autocomplete-popup.js',
     'browser-loader.js',
     'create-dispatcher.js',
+    'css-parsing-utils.js',
     'devices.js',
     'doorhanger.js',
     'frame-script-utils.js',
     'getjson.js',
     'inplace-editor.js',
     'node-attribute-parser.js',
     'observable-object.js',
     'options-view.js',
diff --git a/browser/devtools/shared/test/browser_outputparser.js b/browser/devtools/shared/test/browser_outputparser.js
--- a/browser/devtools/shared/test/browser_outputparser.js
+++ b/browser/devtools/shared/test/browser_outputparser.js
@@ -16,94 +16,91 @@ add_task(function*() {
 
 function* performTest() {
   let [host, , doc] = yield createHost("bottom", "data:text/html," +
     "<h1>browser_outputParser.js</h1><div></div>");
 
   let parser = new OutputParser(doc);
   testParseCssProperty(doc, parser);
   testParseCssVar(doc, parser);
+  testParseURL(doc, parser);
 
   host.destroy();
 }
 
 // Class name used in color swatch.
 let COLOR_TEST_CLASS = "test-class";
 
 // Create a new CSS color-parsing test.  |name| is the name of the CSS
 // property.  |value| is the CSS text to use.  |segments| is an array
 // describing the expected result.  If an element of |segments| is a
 // string, it is simply appended to the expected string.  Otherwise,
-// it must be an object with a |value| property and a |name| property.
-// These describe the color and are both used in the generated
-// expected output -- |name| is the color name as it appears in the
-// input (e.g., "red"); and |value| is the hash-style numeric value
-// for the color, which parseCssProperty emits in some spots (e.g.,
-// "#F00").
+// it must be an object with a |value| property, which is the color
+// name as it appears in the input.
 //
 // This approach is taken to reduce boilerplate and to make it simpler
 // to modify the test when the parseCssProperty output changes.
 function makeColorTest(name, value, segments) {
   let result = {
     name,
     value,
     expected: ""
   };
 
   for (let segment of segments) {
     if (typeof (segment) === "string") {
       result.expected += segment;
     } else {
-      result.expected += "<span data-color=\"" + segment.value + "\">" +
+      result.expected += "<span data-color=\"" + segment.name + "\">" +
         "<span style=\"background-color:" + segment.name +
         "\" class=\"" + COLOR_TEST_CLASS + "\"></span><span>" +
-        segment.value + "</span></span>";
+        segment.name + "</span></span>";
     }
   }
 
   result.desc = "Testing " + name + ": " + value;
 
   return result;
 }
 
 function testParseCssProperty(doc, parser) {
   let tests = [
     makeColorTest("border", "1px solid red",
-                  ["1px solid ", {name: "red", value: "#F00"}]),
+                  ["1px solid ", {name: "red"}]),
 
     makeColorTest("background-image",
                   "linear-gradient(to right, #F60 10%, rgba(0,0,0,1))",
-                  ["linear-gradient(to right, ", {name: "#F60", value: "#F60"},
-                   " 10%, ", {name: "rgba(0,0,0,1)", value: "#000"},
+                  ["linear-gradient(to right, ", {name: "#F60"},
+                   " 10%, ", {name: "rgba(0,0,0,1)"},
                    ")"]),
 
     // In "arial black", "black" is a font, not a color.
     makeColorTest("font-family", "arial black", ["arial black"]),
 
     makeColorTest("box-shadow", "0 0 1em red",
-                  ["0 0 1em ", {name: "red", value: "#F00"}]),
+                  ["0 0 1em ", {name: "red"}]),
 
     makeColorTest("box-shadow",
                   "0 0 1em red, 2px 2px 0 0 rgba(0,0,0,.5)",
-                  ["0 0 1em ", {name: "red", value: "#F00"},
+                  ["0 0 1em ", {name: "red"},
                    ", 2px 2px 0 0 ",
-                   {name: "rgba(0,0,0,.5)", value: "rgba(0,0,0,.5)"}]),
+                   {name: "rgba(0,0,0,.5)"}]),
 
     makeColorTest("content", "\"red\"", ["\"red\""]),
 
     // Invalid property names should not cause exceptions.
     makeColorTest("hellothere", "'red'", ["'red'"]),
 
     makeColorTest("filter",
                   "blur(1px) drop-shadow(0 0 0 blue) url(red.svg#blue)",
                   ["<span data-filters=\"blur(1px) drop-shadow(0 0 0 blue) ",
                    "url(red.svg#blue)\"><span>",
                    "blur(1px) drop-shadow(0 0 0 ",
-                   {name: "blue", value: "#00F"},
-                   ") url(\"red.svg#blue\")</span></span>"]),
+                   {name: "blue"},
+                   ") url(red.svg#blue)</span></span>"]),
 
     makeColorTest("color", "currentColor", ["currentColor"]),
   ];
 
   let target = doc.querySelector("div");
   ok(target, "captain, we have the div");
 
   for (let test of tests) {
@@ -131,8 +128,79 @@ function testParseCssVar(doc, parser) {
   ok(target, "captain, we have the div");
   target.appendChild(frag);
 
   is(target.innerHTML, "var(--some-kind-of-green)",
      "CSS property correctly parsed");
 
   target.innerHTML = "";
 }
+
+function testParseURL(doc, parser) {
+  info("Test that URL parsing preserves quoting style");
+
+  const tests = [
+    {
+      desc: "simple test without quotes",
+      leader: "url(",
+      trailer: ")",
+    },
+    {
+      desc: "simple test with single quotes",
+      leader: "url('",
+      trailer: "')",
+    },
+    {
+      desc: "simple test with double quotes",
+      leader: "url(\"",
+      trailer: "\")",
+    },
+    {
+      desc: "test with single quotes and whitespace",
+      leader: "url( \t'",
+      trailer: "'\r\n\f)",
+    },
+    {
+      desc: "simple test with uppercase",
+      leader: "URL(",
+      trailer: ")",
+    },
+    {
+      desc: "bad url, missing paren",
+      leader: "url(",
+      trailer: "",
+      expectedTrailer: ")"
+    },
+    {
+      desc: "bad url, double quote, missing paren",
+      leader: "url(\"",
+      trailer: "\"",
+      expectedTrailer: "\")",
+    },
+    {
+      desc: "bad url, single quote, missing paren and quote",
+      leader: "url('",
+      trailer: "",
+      expectedTrailer: "')"
+    }
+  ];
+
+  for (let test of tests) {
+    let url = test.leader + "something.jpg" + test.trailer;
+    let frag = parser.parseCssProperty("background", url, {
+      urlClass: "test-urlclass"
+    });
+
+    let target = doc.querySelector("div");
+    target.appendChild(frag);
+
+    let expectedTrailer = test.expectedTrailer || test.trailer;
+
+    let expected = test.leader +
+        "<a href=\"something.jpg\" class=\"test-urlclass\" " +
+        "target=\"_blank\">something.jpg</a>" +
+        expectedTrailer;
+
+    is(target.innerHTML, expected, test.desc);
+
+    target.innerHTML = "";
+  }
+}
diff --git a/browser/devtools/shared/test/unit/test_escapeCSSComment.js b/browser/devtools/shared/test/unit/test_escapeCSSComment.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/test/unit/test_escapeCSSComment.js
@@ -0,0 +1,43 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const Cu = Components.utils;
+Cu.import("resource://gre/modules/devtools/Loader.jsm");
+const {escapeCSSComment, _unescapeCSSComment} =
+      devtools.require("devtools/shared/css-parsing-utils");
+
+const TEST_DATA = [
+  {
+    input: "simple",
+    expected: "simple"
+  },
+  {
+    input: "/* comment */",
+    expected: "/\\* comment *\\/"
+  },
+  {
+    input: "/* two *//* comments */",
+    expected: "/\\* two *\\//\\* comments *\\/"
+  },
+  {
+    input: "/* nested /\\* comment *\\/ */",
+    expected: "/\\* nested /\\\\* comment *\\\\/ *\\/",
+  }
+];
+
+function run_test() {
+  let i = 0;
+  for (let test of TEST_DATA) {
+    ++i;
+    do_print("Test #" + i);
+
+    let escaped = escapeCSSComment(test.input);
+    equal(escaped, test.expected);
+    let unescaped = _unescapeCSSComment(escaped);
+    equal(unescaped, test.input);
+  }
+}
diff --git a/browser/devtools/shared/test/unit/test_parseDeclarations.js b/browser/devtools/shared/test/unit/test_parseDeclarations.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/test/unit/test_parseDeclarations.js
@@ -0,0 +1,421 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const Cu = Components.utils;
+const {require} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+const {parseDeclarations, _parseCommentDeclarations} =
+  require("devtools/shared/css-parsing-utils");
+
+const TEST_DATA = [
+  // Simple test
+  {
+    input: "p:v;",
+    expected: [{name: "p", value: "v", priority: "", offsets: [0, 4]}]
+  },
+  // Simple test
+  {
+    input: "this:is;a:test;",
+    expected: [
+      {name: "this", value: "is", priority: "", offsets: [0, 8]},
+      {name: "a", value: "test", priority: "", offsets: [8, 15]}
+    ]
+  },
+  // Test a single declaration with semi-colon
+  {
+    input: "name:value;",
+    expected: [{name: "name", value: "value", priority: "", offsets: [0, 11]}]
+  },
+  // Test a single declaration without semi-colon
+  {
+    input: "name:value",
+    expected: [{name: "name", value: "value", priority: "", offsets: [0, 10]}]
+  },
+  // Test multiple declarations separated by whitespaces and carriage
+  // returns and tabs
+  {
+    input: "p1 : v1 ; \t\t  \n p2:v2;   \n\n\n\n\t  p3    :   v3;",
+    expected: [
+      {name: "p1", value: "v1", priority: "", offsets: [0, 9]},
+      {name: "p2", value: "v2", priority: "", offsets: [16, 22]},
+      {name: "p3", value: "v3", priority: "", offsets: [32, 45]},
+    ]
+  },
+  // Test simple priority
+  {
+    input: "p1: v1; p2: v2 !important;",
+    expected: [
+      {name: "p1", value: "v1", priority: "", offsets: [0, 7]},
+      {name: "p2", value: "v2", priority: "important", offsets: [8, 26]}
+    ]
+  },
+  // Test simple priority
+  {
+    input: "p1: v1 !important; p2: v2",
+    expected: [
+      {name: "p1", value: "v1", priority: "important", offsets: [0, 18]},
+      {name: "p2", value: "v2", priority: "", offsets: [19, 25]}
+    ]
+  },
+  // Test simple priority
+  {
+    input: "p1: v1 !  important; p2: v2 ! important;",
+    expected: [
+      {name: "p1", value: "v1", priority: "important", offsets: [0, 20]},
+      {name: "p2", value: "v2", priority: "important", offsets: [21, 40]}
+    ]
+  },
+  // Test invalid priority
+  {
+    input: "p1: v1 important;",
+    expected: [
+      {name: "p1", value: "v1 important", priority: "", offsets: [0, 17]}
+    ]
+  },
+  // Test various types of background-image urls
+  {
+    input: "background-image: url(../../relative/image.png)",
+    expected: [{
+      name: "background-image",
+      value: "url(../../relative/image.png)",
+      priority: "",
+      offsets: [0, 47]
+    }]
+  },
+  {
+    input: "background-image: url(http://site.com/test.png)",
+    expected: [{
+      name: "background-image",
+      value: "url(http://site.com/test.png)",
+      priority: "",
+      offsets: [0, 47]
+    }]
+  },
+  {
+    input: "background-image: url(wow.gif)",
+    expected: [{
+      name: "background-image",
+      value: "url(wow.gif)",
+      priority: "",
+      offsets: [0, 30]
+    }]
+  },
+  // Test that urls with :;{} characters in them are parsed correctly
+  {
+    input: "background: red url(\"http://site.com/image{}:;.png?id=4#wat\") "
+      + "repeat top right",
+    expected: [{
+      name: "background",
+      value: "red url(\"http://site.com/image{}:;.png?id=4#wat\") " +
+        "repeat top right",
+      priority: "",
+      offsets: [0, 78]
+    }]
+  },
+  // Test that an empty string results in an empty array
+  {input: "", expected: []},
+  // Test that a string comprised only of whitespaces results in an empty array
+  {input: "       \n \n   \n   \n \t  \t\t\t  ", expected: []},
+  // Test that a null input throws an exception
+  {input: null, throws: true},
+  // Test that a undefined input throws an exception
+  {input: undefined, throws: true},
+  // Test that :;{} characters in quoted content are not parsed as multiple
+  // declarations
+  {
+    input: "content: \";color:red;}selector{color:yellow;\"",
+    expected: [{
+      name: "content",
+      value: "\";color:red;}selector{color:yellow;\"",
+      priority: "",
+      offsets: [0, 45]
+    }]
+  },
+  // Test that rules aren't parsed, just declarations. So { and } found after a
+  // property name should be part of the property name, same for values.
+  {
+    input: "body {color:red;} p {color: blue;}",
+    expected: [
+      {name: "body {color", value: "red", priority: "", offsets: [0, 16]},
+      {name: "} p {color", value: "blue", priority: "", offsets: [16, 33]},
+      {name: "}", value: "", priority: "", offsets: [33, 34]}
+    ]
+  },
+  // Test unbalanced : and ;
+  {
+    input: "color :red : font : arial;",
+    expected: [
+      {name: "color", value: "red : font : arial", priority: "",
+       offsets: [0, 26]}
+    ]
+  },
+  {
+    input: "background: red;;;;;",
+    expected: [{name: "background", value: "red", priority: "",
+                offsets: [0, 16]}]
+  },
+  {
+    input: "background:;",
+    expected: [{name: "background", value: "", priority: "",
+                offsets: [0, 12]}]
+  },
+  {input: ";;;;;", expected: []},
+  {input: ":;:;", expected: []},
+  // Test name only
+  {input: "color", expected: [
+    {name: "color", value: "", priority: "", offsets: [0, 5]}
+  ]},
+  // Test trailing name without :
+  {input: "color:blue;font", expected: [
+    {name: "color", value: "blue", priority: "", offsets: [0, 11]},
+    {name: "font", value: "", priority: "", offsets: [11, 15]}
+  ]},
+  // Test trailing name with :
+  {input: "color:blue;font:", expected: [
+    {name: "color", value: "blue", priority: "", offsets: [0, 11]},
+    {name: "font", value: "", priority: "", offsets: [11, 16]}
+  ]},
+  // Test leading value
+  {input: "Arial;color:blue;", expected: [
+    {name: "", value: "Arial", priority: "", offsets: [0, 6]},
+    {name: "color", value: "blue", priority: "", offsets: [6, 17]}
+  ]},
+  // Test hex colors
+  {
+    input: "color: #333",
+    expected: [{name: "color", value: "#333", priority: "", offsets: [0, 11]}]
+  },
+  {
+    input: "color: #456789",
+    expected: [{name: "color", value: "#456789", priority: "",
+                offsets: [0, 14]}]
+  },
+  {
+    input: "wat: #XYZ",
+    expected: [{name: "wat", value: "#XYZ", priority: "", offsets: [0, 9]}]
+  },
+  // Test string/url quotes escaping
+  {
+    input: "content: \"this is a 'string'\"",
+    expected: [{name: "content", value: "\"this is a 'string'\"", priority: "",
+                offsets: [0, 29]}]
+  },
+  {
+    input: 'content: "this is a \\"string\\""',
+    expected: [{
+      name: "content",
+      value: '"this is a \\"string\\""',
+      priority: "",
+      offsets: [0, 31]}]
+  },
+  {
+    input: "content: 'this is a \"string\"'",
+    expected: [{
+      name: "content",
+      value: '\'this is a "string"\'',
+      priority: "",
+      offsets: [0, 29]
+    }]
+  },
+  {
+    input: "content: 'this is a \\'string\\''",
+    expected: [{
+      name: "content",
+      value: "'this is a \\'string\\''",
+      priority: "",
+      offsets: [0, 31],
+    }]
+  },
+  {
+    input: "content: 'this \\' is a \" really strange string'",
+    expected: [{
+      name: "content",
+      value: "'this \\' is a \" really strange string'",
+      priority: "",
+      offsets: [0, 47]
+    }]
+  },
+  {
+    input: "content: \"a not s\\\
+          o very long title\"",
+    expected: [
+      {name: "content", value: '"a not s\\\
+          o very long title"', priority: "", offsets: [0, 46]}
+    ]
+  },
+  // Test calc with nested parentheses
+  {
+    input: "width: calc((100% - 3em) / 2)",
+    expected: [{name: "width", value: "calc((100% - 3em) / 2)", priority: "",
+                offsets: [0, 29]}]
+  },
+
+  // Simple embedded comment test.
+  {
+    parseComments: true,
+    input: "width: 5; /* background: green; */ background: red;",
+    expected: [{name: "width", value: "5", priority: "", offsets: [0, 9]},
+               {name: "background", value: "green", priority: "",
+                offsets: [13, 31], commentOffsets: [10, 34]},
+               {name: "background", value: "red", priority: "",
+                offsets: [35, 51]}]
+  },
+
+  // Embedded comment where the parsing heuristic fails.
+  {
+    parseComments: true,
+    input: "width: 5; /* background something: green; */ background: red;",
+    expected: [{name: "width", value: "5", priority: "", offsets: [0, 9]},
+               {name: "background", value: "red", priority: "",
+                offsets: [45, 61]}]
+  },
+
+  // Embedded comment where the parsing heuristic is a bit funny.
+  {
+    parseComments: true,
+    input: "width: 5; /* background: */ background: red;",
+    expected: [{name: "width", value: "5", priority: "", offsets: [0, 9]},
+               {name: "background", value: "", priority: "",
+                offsets: [13, 24], commentOffsets: [10, 27]},
+               {name: "background", value: "red", priority: "",
+                offsets: [28, 44]}]
+  },
+
+  // Another case where the parsing heuristic says not to bother; note
+  // that there is no ";" in the comment.
+  {
+    parseComments: true,
+    input: "width: 5; /* background: yellow */ background: red;",
+    expected: [{name: "width", value: "5", priority: "", offsets: [0, 9]},
+               {name: "background", value: "yellow", priority: "",
+                offsets: [13, 31], commentOffsets: [10, 34]},
+               {name: "background", value: "red", priority: "",
+                offsets: [35, 51]}]
+  },
+
+  // Parsing a comment should yield text that has been unescaped, and
+  // the offsets should refer to the original text.
+  {
+    parseComments: true,
+    input: "/* content: '*\\/'; */",
+    expected: [{name: "content", value: "'*/'", priority: "",
+                offsets: [3, 18], commentOffsets: [0, 21]}]
+  },
+
+  // Parsing a comment should yield text that has been unescaped, and
+  // the offsets should refer to the original text.  This variant
+  // tests the no-semicolon path.
+  {
+    parseComments: true,
+    input: "/* content: '*\\/' */",
+    expected: [{name: "content", value: "'*/'", priority: "",
+                offsets: [3, 17], commentOffsets: [0, 20]}]
+  },
+
+  // A comment-in-a-comment should yield the correct offsets.
+  {
+    parseComments: true,
+    input: "/* color: /\\* comment *\\/ red; */",
+    expected: [{name: "color", value: "red", priority: "",
+                offsets: [3, 30], commentOffsets: [0, 33]}]
+  },
+
+  // HTML comments are ignored.
+  {
+    parseComments: true,
+    input: "<!-- color: red; --> color: blue;",
+    expected: [{name: "color", value: "red", priority: "",
+                offsets: [5, 16]},
+               {name: "color", value: "blue", priority: "",
+                offsets: [21, 33]}]
+  },
+
+  // Don't error on an empty comment.
+  {
+    parseComments: true,
+    input: "/**/",
+    expected: []
+  },
+
+  // Parsing our special comments skips the name-check heuristic.
+  {
+    parseComments: true,
+    input: "/*! walrus: zebra; */",
+    expected: [{name: "walrus", value: "zebra", priority: "",
+                offsets: [4, 18], commentOffsets: [0, 21]}]
+  }
+];
+
+function run_test() {
+  run_basic_tests();
+  run_comment_tests();
+}
+
+// Test parseDeclarations.
+function run_basic_tests() {
+  for (let test of TEST_DATA) {
+    do_print("Test input string " + test.input);
+    let output;
+    try {
+      output = parseDeclarations(test.input, test.parseComments);
+    } catch (e) {
+      do_print("parseDeclarations threw an exception with the given input " +
+        "string");
+      if (test.throws) {
+        do_print("Exception expected");
+        do_check_true(true);
+      } else {
+        do_print("Exception unexpected\n" + e);
+        do_check_true(false);
+      }
+    }
+    if (output) {
+      assertOutput(output, test.expected);
+    }
+  }
+}
+
+const COMMENT_DATA = [
+  {
+    input: "content: 'hi",
+    expected: [{name: "content", value: "'hi", priority: "", terminator: "';",
+                offsets: [2, 14], colonOffsets: [9, 11],
+                commentOffsets: [0, 16]}]
+  }
+];
+
+// Test parseCommentDeclarations.
+function run_comment_tests() {
+  for (let test of COMMENT_DATA) {
+    do_print("Test input string " + test.input);
+    let output = _parseCommentDeclarations(test.input, 0,
+                                           test.input.length + 4);
+    deepEqual(output, test.expected);
+  }
+}
+
+function assertOutput(actual, expected) {
+  if (actual.length === expected.length) {
+    for (let i = 0; i < expected.length; i++) {
+      do_check_true(!!actual[i]);
+      do_print("Check that the output item has the expected name, " +
+        "value and priority");
+      do_check_eq(expected[i].name, actual[i].name);
+      do_check_eq(expected[i].value, actual[i].value);
+      do_check_eq(expected[i].priority, actual[i].priority);
+      deepEqual(expected[i].offsets, actual[i].offsets);
+      if ("commentOffsets" in expected[i]) {
+        deepEqual(expected[i].commentOffsets, actual[i].commentOffsets);
+      }
+    }
+  } else {
+    for (let prop of actual) {
+      do_print("Actual output contained: {name: " + prop.name + ", value: " +
+        prop.value + ", priority: " + prop.priority + "}");
+    }
+    do_check_eq(actual.length, expected.length);
+  }
+}
diff --git a/browser/devtools/styleinspector/test/unit/test_parsePseudoClassesAndAttributes.js b/browser/devtools/shared/test/unit/test_parsePseudoClassesAndAttributes.js
rename from browser/devtools/styleinspector/test/unit/test_parsePseudoClassesAndAttributes.js
rename to browser/devtools/shared/test/unit/test_parsePseudoClassesAndAttributes.js
--- a/browser/devtools/styleinspector/test/unit/test_parsePseudoClassesAndAttributes.js
+++ b/browser/devtools/shared/test/unit/test_parsePseudoClassesAndAttributes.js
@@ -7,17 +7,17 @@
 
 const Cu = Components.utils;
 const {require} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 const {
   parsePseudoClassesAndAttributes,
   SELECTOR_ATTRIBUTE,
   SELECTOR_ELEMENT,
   SELECTOR_PSEUDO_CLASS
-} = require("devtools/styleinspector/css-parsing-utils");
+} = require("devtools/shared/css-parsing-utils");
 
 const TEST_DATA = [
   // Test that a null input throws an exception
   {
     input: null,
     throws: true
   },
   // Test that a undefined input throws an exception
diff --git a/browser/devtools/styleinspector/test/unit/test_parseSingleValue.js b/browser/devtools/shared/test/unit/test_parseSingleValue.js
rename from browser/devtools/styleinspector/test/unit/test_parseSingleValue.js
rename to browser/devtools/shared/test/unit/test_parseSingleValue.js
--- a/browser/devtools/styleinspector/test/unit/test_parseSingleValue.js
+++ b/browser/devtools/shared/test/unit/test_parseSingleValue.js
@@ -2,17 +2,17 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 const Cu = Components.utils;
 const {require} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
-const {parseSingleValue} = require("devtools/styleinspector/css-parsing-utils");
+const {parseSingleValue} = require("devtools/shared/css-parsing-utils");
 
 const TEST_DATA = [
   {input: null, throws: true},
   {input: undefined, throws: true},
   {input: "", expected: {value: "", priority: ""}},
   {input: "  \t \t \n\n  ", expected: {value: "", priority: ""}},
   {input: "blue", expected: {value: "blue", priority: ""}},
   {input: "blue !important", expected: {value: "blue", priority: "important"}},
diff --git a/browser/devtools/shared/test/unit/test_rewriteDeclarations.js b/browser/devtools/shared/test/unit/test_rewriteDeclarations.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/test/unit/test_rewriteDeclarations.js
@@ -0,0 +1,479 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const Cu = Components.utils;
+Cu.import("resource://gre/modules/devtools/Loader.jsm");
+const {parseDeclarations, RuleRewriter} =
+      devtools.require("devtools/shared/css-parsing-utils");
+
+const TEST_DATA = [
+  {
+    desc: "simple set",
+    input: "p:v;",
+    instruction: {type: "set", name: "p", value: "N", priority: "",
+                  index: 0},
+    expected: "p:N;"
+  },
+  {
+    desc: "simple set clearing !important",
+    input: "p:v !important;",
+    instruction: {type: "set", name: "p", value: "N", priority: "",
+                  index: 0},
+    expected: "p:N;"
+  },
+  {
+    desc: "simple set adding !important",
+    input: "p:v;",
+    instruction: {type: "set", name: "p", value: "N", priority: "important",
+                  index: 0},
+    expected: "p:N !important;"
+  },
+  {
+    desc: "simple set between comments",
+    input: "/*color:red;*/ p:v; /*color:green;*/",
+    instruction: {type: "set", name: "p", value: "N", priority: "",
+                  index: 1},
+    expected: "/*color:red;*/ p:N; /*color:green;*/"
+  },
+  // The rule view can generate a "set" with a previously unknown
+  // property index; which should work like "create".
+  {
+    desc: "set at unknown index",
+    input: "a:b; e: f;",
+    instruction: {type: "set", name: "c", value: "d", priority: "",
+                  index: 2},
+    expected: "a:b; e: f;c: d;"
+  },
+  {
+    desc: "simple rename",
+    input: "p:v;",
+    instruction: {type: "rename", name: "p", newName: "q", index: 0},
+    expected: "q:v;"
+  },
+  // "rename" is passed the name that the user entered, and must do
+  // any escaping necessary to ensure that this is an identifier.
+  {
+    desc: "rename requiring escape",
+    input: "p:v;",
+    instruction: {type: "rename", name: "p", newName: "a b", index: 0},
+    expected: "a\\ b:v;"
+  },
+  {
+    desc: "simple create",
+    input: "",
+    instruction: {type: "create", name: "p", value: "v", priority: "important",
+                  index: 0},
+    expected: "p: v !important;"
+  },
+  {
+    desc: "create between two properties",
+    input: "a:b; e: f;",
+    instruction: {type: "create", name: "c", value: "d", priority: "",
+                  index: 1},
+    expected: "a:b; c: d;e: f;"
+  },
+  // "create" is passed the name that the user entered, and must do
+  // any escaping necessary to ensure that this is an identifier.
+  {
+    desc: "create requiring escape",
+    input: "",
+    instruction: {type: "create", name: "a b", value: "d", priority: "",
+                  index: 1},
+    expected: "a\\ b: d;"
+  },
+  {
+    desc: "simple disable",
+    input: "p:v;",
+    instruction: {type: "enable", name: "p", value: false, index: 0},
+    expected: "/*! p:v; */"
+  },
+  {
+    desc: "simple enable",
+    input: "/* color:v; */",
+    instruction: {type: "enable", name: "color", value: true, index: 0},
+    expected: "color:v;"
+  },
+  {
+    desc: "enable with following property in comment",
+    input: "/* color:red; color: blue; */",
+    instruction: {type: "enable", name: "color", value: true, index: 0},
+    expected: "color:red; /* color: blue; */"
+  },
+  {
+    desc: "enable with preceding property in comment",
+    input: "/* color:red; color: blue; */",
+    instruction: {type: "enable", name: "color", value: true, index: 1},
+    expected: "/* color:red; */ color: blue;"
+  },
+  {
+    desc: "simple remove",
+    input: "a:b;c:d;e:f;",
+    instruction: {type: "remove", name: "c", index: 1},
+    expected: "a:b;e:f;"
+  },
+  {
+    desc: "disable with comment ender in string",
+    input: "content: '*/';",
+    instruction: {type: "enable", name: "content", value: false, index: 0},
+    expected: "/*! content: '*\\/'; */"
+  },
+  {
+    desc: "enable with comment ender in string",
+    input: "/* content: '*\\/'; */",
+    instruction: {type: "enable", name: "content", value: true, index: 0},
+    expected: "content: '*/';"
+  },
+  {
+    desc: "enable requiring semicolon insertion",
+    // Note the lack of a trailing semicolon in the comment.
+    input: "/* color:red */ color: blue;",
+    instruction: {type: "enable", name: "color", value: true, index: 0},
+    expected: "color:red; color: blue;"
+  },
+  {
+    desc: "create requiring semicolon insertion",
+    // Note the lack of a trailing semicolon.
+    input: "color: red",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "color: red;a: b;"
+  },
+
+  // Newline insertion.
+  {
+    desc: "simple newline insertion",
+    input: "\ncolor: red;\n",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\ncolor: red;\na: b;\n"
+  },
+  // Newline insertion.
+  {
+    desc: "semicolon insertion before newline",
+    // Note the lack of a trailing semicolon.
+    input: "\ncolor: red\n",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\ncolor: red;\na: b;\n"
+  },
+  // Newline insertion.
+  {
+    desc: "newline and semicolon insertion",
+    // Note the lack of a trailing semicolon and newline.
+    input: "\ncolor: red",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\ncolor: red;\na: b;\n"
+  },
+
+  // Newline insertion and indentation.
+  {
+    desc: "indentation with create",
+    input: "\n  color: red;\n",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\n  color: red;\n  a: b;\n"
+  },
+  // Newline insertion and indentation.
+  {
+    desc: "indentation plus semicolon insertion before newline",
+    // Note the lack of a trailing semicolon.
+    input: "\n  color: red\n",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\n  color: red;\n  a: b;\n"
+  },
+  {
+    desc: "indentation inserted before trailing whitespace",
+    // Note the trailing whitespace.  This could come from a rule
+    // like:
+    // @supports (mumble) {
+    //   body {
+    //     color: red;
+    //   }
+    // }
+    // Here if we create a rule we don't want it to follow
+    // the indentation of the "}".
+    input: "\n    color: red;\n  ",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\n    color: red;\n    a: b;\n  "
+  },
+  // Newline insertion and indentation.
+  {
+    desc: "indentation comes from preceding comment",
+    // Note how the comment comes before the declaration.
+    input: "\n  /* comment */ color: red\n",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 1},
+    expected: "\n  /* comment */ color: red;\n  a: b;\n"
+  },
+  // Default indentation.
+  {
+    desc: "use of default indentation",
+    input: "\n",
+    instruction: {type: "create", name: "a", value: "b", priority: "",
+                  index: 0},
+    expected: "\n\ta: b;\n"
+  },
+
+  // Deletion handles newlines properly.
+  {
+    desc: "deletion removes newline",
+    input: "a:b;\nc:d;\ne:f;",
+    instruction: {type: "remove", name: "c", index: 1},
+    expected: "a:b;\ne:f;"
+  },
+  // Deletion handles newlines properly.
+  {
+    desc: "deletion remove blank line",
+    input: "\n  a:b;\n  c:d;  \ne:f;",
+    instruction: {type: "remove", name: "c", index: 1},
+    expected: "\n  a:b;\ne:f;"
+  },
+  // Deletion handles newlines properly.
+  {
+    desc: "deletion leaves comment",
+    input: "\n  a:b;\n  /* something */ c:d;  \ne:f;",
+    instruction: {type: "remove", name: "c", index: 1},
+    expected: "\n  a:b;\n  /* something */   \ne:f;"
+  },
+  // Deletion handles newlines properly.
+  {
+    desc: "deletion leaves previous newline",
+    input: "\n  a:b;\n  c:d;  \ne:f;",
+    instruction: {type: "remove", name: "e", index: 2},
+    expected: "\n  a:b;\n  c:d;  \n"
+  },
+  // Deletion handles newlines properly.
+  {
+    desc: "deletion removes trailing whitespace",
+    input: "\n  a:b;\n  c:d;  \n    e:f;",
+    instruction: {type: "remove", name: "e", index: 2},
+    expected: "\n  a:b;\n  c:d;  \n"
+  },
+  // Deletion handles newlines properly.
+  {
+    desc: "deletion preserves indentation",
+    input: "  a:b;\n  c:d;  \n    e:f;",
+    instruction: {type: "remove", name: "a", index: 0},
+    expected: "  c:d;  \n    e:f;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "enable single quote termination",
+    input: "/* content: 'hi */ color: red;",
+    instruction: {type: "enable", name: "content", value: true, index: 0},
+    expected: "content: 'hi'; color: red;"
+  },
+  // Termination insertion corner case.
+  {
+    desc: "create single quote termination",
+    input: "content: 'hi",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "content: 'hi';color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "enable double quote termination",
+    input: "/* content: \"hi */ color: red;",
+    instruction: {type: "enable", name: "content", value: true, index: 0},
+    expected: "content: \"hi\"; color: red;"
+  },
+  // Termination insertion corner case.
+  {
+    desc: "create double quote termination",
+    input: "content: \"hi",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "content: \"hi\";color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "enable url termination",
+    input: "/* background-image: url(something.jpg */ color: red;",
+    instruction: {type: "enable", name: "background-image", value: true,
+                  index: 0},
+    expected: "background-image: url(something.jpg); color: red;"
+  },
+  // Termination insertion corner case.
+  {
+    desc: "create url termination",
+    input: "background-image: url(something.jpg",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "background-image: url(something.jpg);color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "enable url single quote termination",
+    input: "/* background-image: url('something.jpg */ color: red;",
+    instruction: {type: "enable", name: "background-image", value: true,
+                  index: 0},
+    expected: "background-image: url('something.jpg'); color: red;"
+  },
+  // Termination insertion corner case.
+  {
+    desc: "create url single quote termination",
+    input: "background-image: url('something.jpg",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "background-image: url('something.jpg');color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "create url double quote termination",
+    input: "/* background-image: url(\"something.jpg */ color: red;",
+    instruction: {type: "enable", name: "background-image", value: true,
+                  index: 0},
+    expected: "background-image: url(\"something.jpg\"); color: red;"
+  },
+  // Termination insertion corner case.
+  {
+    desc: "enable url double quote termination",
+    input: "background-image: url(\"something.jpg",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "background-image: url(\"something.jpg\");color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "create backslash termination",
+    input: "something: \\",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "something: \\\\;color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "enable backslash single quote termination",
+    input: "something: '\\",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "something: '\\\\';color: red;"
+  },
+  {
+    desc: "enable backslash double quote termination",
+    input: "something: \"\\",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "something: \"\\\\\";color: red;"
+  },
+
+  // Termination insertion corner case.
+  {
+    desc: "enable comment termination",
+    input: "something: blah /* comment ",
+    instruction: {type: "create", name: "color", value: "red", priority: "",
+                  index: 1},
+    expected: "something: blah /* comment*/; color: red;"
+  },
+
+  // Rewrite a "heuristic override" comment.
+  {
+    desc: "enable with heuristic override comment",
+    input: "/*! walrus: zebra; */",
+    instruction: {type: "enable", name: "walrus", value: true, index: 0},
+    expected: "walrus: zebra;"
+  },
+
+  // Sanitize a bad value.
+  {
+    desc: "create sanitize unpaired brace",
+    input: "",
+    instruction: {type: "create", name: "p", value: "}", priority: "",
+                  index: 0},
+    expected: "p: \\};",
+    changed: {0: "\\}"}
+  },
+  // Sanitize a bad value.
+  {
+    desc: "set sanitize unpaired brace",
+    input: "walrus: zebra;",
+    instruction: {type: "set", name: "walrus", value: "{{}}}", priority: "",
+                  index: 0},
+    expected: "walrus: {{}}\\};",
+    changed: {0: "{{}}\\}"}
+  },
+  // Sanitize a bad value.
+  {
+    desc: "enable sanitize unpaired brace",
+    input: "/*! walrus: }*/",
+    instruction: {type: "enable", name: "walrus", value: true, index: 0},
+    expected: "walrus: \\};",
+    changed: {0: "\\}"}
+  },
+
+  // Creating a new declaration does not require an attempt to
+  // terminate a previous commented declaration.
+  {
+    desc: "disabled declaration does not need semicolon insertion",
+    input: "/*! no: semicolon */\n",
+    instruction: {type: "create", name: "walrus", value: "zebra", priority: "",
+                  index: 1},
+    expected: "/*! no: semicolon */\nwalrus: zebra;\n",
+    changed: {}
+  },
+];
+
+function rewriteDeclarations(inputString, instruction, defaultIndentation) {
+  let rewriter = new RuleRewriter(null, inputString);
+
+  switch (instruction.type) {
+    case "rename":
+      rewriter.renameProperty(instruction.index, instruction.name,
+                              instruction.newName);
+      break;
+
+    case "enable":
+      rewriter.setPropertyEnabled(instruction.index, instruction.name,
+                                  instruction.value);
+      break;
+
+    case "create":
+      rewriter.createProperty(instruction.index, instruction.name,
+                              instruction.value, instruction.priority,
+                              defaultIndentation);
+      break;
+
+    case "set":
+      rewriter.setProperty(instruction.index, instruction.name,
+                           instruction.value, instruction.priority,
+                           defaultIndentation);
+      break;
+
+    case "remove":
+      rewriter.removeProperty(instruction.index, instruction.name);
+      break;
+
+    default:
+      throw new Error("unrecognized instruction");
+  }
+
+  return rewriter.getResult();
+}
+
+function run_test() {
+  let i = 0;
+  for (let test of TEST_DATA) {
+    ++i;
+    let {changed, text} = rewriteDeclarations(test.input, test.instruction,
+                                              "\t");
+    equal(text, test.expected, "output for " + test.desc);
+    if ("changed" in test) {
+      deepEqual(changed, test.changed, "changed result for " + test.desc);
+    }
+  }
+}
diff --git a/browser/devtools/shared/test/unit/xpcshell.ini b/browser/devtools/shared/test/unit/xpcshell.ini
--- a/browser/devtools/shared/test/unit/xpcshell.ini
+++ b/browser/devtools/shared/test/unit/xpcshell.ini
@@ -5,11 +5,16 @@ tail =
 firefox-appdir = browser
 skip-if = toolkit == 'android' || toolkit == 'gonk'
 
 [test_advanceValidate.js]
 [test_attribute-parsing-01.js]
 [test_attribute-parsing-02.js]
 [test_bezierCanvas.js]
 [test_cubicBezier.js]
+[test_escapeCSSComment.js]
+[test_parseDeclarations.js]
+[test_parsePseudoClassesAndAttributes.js]
+[test_parseSingleValue.js]
+[test_rewriteDeclarations.js]
 [test_undoStack.js]
 [test_VariablesView_filtering-without-controller.js]
 [test_VariablesView_getString_promise.js]
diff --git a/browser/devtools/shared/widgets/FilterWidget.js b/browser/devtools/shared/widgets/FilterWidget.js
--- a/browser/devtools/shared/widgets/FilterWidget.js
+++ b/browser/devtools/shared/widgets/FilterWidget.js
@@ -9,17 +9,17 @@
   * for Rule View's filter swatches
   */
 
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const { Cu } = require("chrome");
 const { ViewHelpers } = Cu.import("resource:///modules/devtools/ViewHelpers.jsm", {});
 const STRINGS_URI = "chrome://browser/locale/devtools/filterwidget.properties";
 const L10N = new ViewHelpers.L10N(STRINGS_URI);
-const {cssTokenizer} = require("devtools/sourceeditor/css-tokenizer");
+const {cssTokenizer} = require("devtools/shared/css-parsing-utils");
 
 loader.lazyGetter(this, "asyncStorage",
                   () => require("devtools/toolkit/shared/async-storage"));
 
 const DEFAULT_FILTER_TYPE = "length";
 const UNIT_MAPPING = {
   percentage: "%",
   length: "px",
diff --git a/browser/devtools/shared/widgets/Tooltip.js b/browser/devtools/shared/widgets/Tooltip.js
--- a/browser/devtools/shared/widgets/Tooltip.js
+++ b/browser/devtools/shared/widgets/Tooltip.js
@@ -1143,16 +1143,18 @@ SwatchColorPickerTooltip.prototype = Her
    * color.
    */
   show: function() {
     // Call then parent class' show function
     SwatchBasedEditorTooltip.prototype.show.call(this);
     // Then set spectrum's color and listen to color changes to preview them
     if (this.activeSwatch) {
       this.currentSwatchColor = this.activeSwatch.nextSibling;
+      this._colorUnit =
+        colorUtils.classifyColor(this.currentSwatchColor.textContent);
       let color = this.activeSwatch.style.backgroundColor;
       this.spectrum.then(spectrum => {
         spectrum.off("changed", this._onSpectrumColorChange);
         spectrum.rgb = this._colorToRgba(color);
         spectrum.on("changed", this._onSpectrumColorChange);
         spectrum.updateUI();
       });
     }
@@ -1220,16 +1222,17 @@ SwatchColorPickerTooltip.prototype = Her
   _colorToRgba: function(color) {
     color = new colorUtils.CssColor(color);
     let rgba = color._getRGBATuple();
     return [rgba.r, rgba.g, rgba.b, rgba.a];
   },
 
   _toDefaultType: function(color) {
     let colorObj = new colorUtils.CssColor(color);
+    colorObj.colorUnit = this._colorUnit;
     return colorObj.toString();
   },
 
   destroy: function() {
     SwatchBasedEditorTooltip.prototype.destroy.call(this);
     this.currentSwatchColor = null;
     this.spectrum.then(spectrum => {
       spectrum.off("changed", this._onSpectrumColorChange);
diff --git a/browser/devtools/sourceeditor/css-autocompleter.js b/browser/devtools/sourceeditor/css-autocompleter.js
--- a/browser/devtools/sourceeditor/css-autocompleter.js
+++ b/browser/devtools/sourceeditor/css-autocompleter.js
@@ -1,33 +1,33 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Cc, Ci, Cu } = require('chrome');
 const {cssTokenizer, cssTokenizerWithLineColumn}  =
-      require("devtools/sourceeditor/css-tokenizer");
+      require("devtools/shared/css-parsing-utils");
 
 /**
- * Here is what this file (+ ./css-tokenizer.js) do.
+ * Here is what this file (+ css-parsing-utils.js) do.
  *
  * The main objective here is to provide as much suggestions to the user editing
  * a stylesheet in Style Editor. The possible things that can be suggested are:
  *  - CSS property names
  *  - CSS property values
  *  - CSS Selectors
  *  - Some other known CSS keywords
  *
  * Gecko provides a list of both property names and their corresponding values.
  * We take out a list of matching selectors using the Inspector actor's
  * `getSuggestionsForQuery` method. Now the only thing is to parse the CSS being
  * edited by the user, figure out what token or word is being written and last
  * but the most difficult, what is being edited.
  *
- * The file 'css-tokenizer' helps in converting the CSS into meaningful tokens,
+ * The file 'css-parsing-utils' helps to convert the CSS into meaningful tokens,
  * each having a certain type associated with it. These tokens help us to figure
  * out the currently edited word and to write a CSS state machine to figure out
  * what the user is currently editing. By that, I mean, whether he is editing a
  * selector or a property or a value, or even fine grained information like an
  * id in the selector.
  *
  * The `resolveState` method iterated over the tokens spitted out by the
  * tokenizer, using switch cases, follows a state machine logic and finally
diff --git a/browser/devtools/sourceeditor/css-tokenizer.js b/browser/devtools/sourceeditor/css-tokenizer.js
deleted file mode 100644
--- a/browser/devtools/sourceeditor/css-tokenizer.js
+++ /dev/null
@@ -1,95 +0,0 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const {Cc, Ci} = require("chrome");
-loader.lazyGetter(this, "DOMUtils", () => {
-  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
-});
-
-/**
- * A generator function that lexes a CSS source string, yielding the
- * CSS tokens.  Comment tokens are dropped.
- *
- * @param {String} CSS source string
- * @yield {CSSToken} The next CSSToken that is lexed
- * @see CSSToken for details about the returned tokens
- */
-function* cssTokenizer(string) {
-  let lexer = DOMUtils.getCSSLexer(string);
-  while (true) {
-    let token = lexer.nextToken();
-    if (!token) {
-      break;
-    }
-    // None of the existing consumers want comments.
-    if (token.tokenType !== "comment") {
-      yield token;
-    }
-  }
-}
-
-exports.cssTokenizer = cssTokenizer;
-
-/**
- * Pass |string| to the CSS lexer and return an array of all the
- * returned tokens.  Comment tokens are not included.  In addition to
- * the usual information, each token will have starting and ending
- * line and column information attached.  Specifically, each token
- * has an additional "loc" attribute.  This attribute is an object
- * of the form {line: L, column: C}.  Lines and columns are both zero
- * based.
- *
- * It's best not to add new uses of this function.  In general it is
- * simpler and better to use the CSSToken offsets, rather than line
- * and column.  Also, this function lexes the entire input string at
- * once, rather than lazily yielding a token stream.  Use
- * |cssTokenizer| or |DOMUtils.getCSSLexer| instead.
- *
- * @param{String} string The input string.
- * @return {Array} An array of tokens (@see CSSToken) that have
- *        line and column information.
- */
-function cssTokenizerWithLineColumn(string) {
-  let lexer = DOMUtils.getCSSLexer(string);
-  let result = [];
-  let prevToken = undefined;
-  while (true) {
-    let token = lexer.nextToken();
-    let lineNumber = lexer.lineNumber;
-    let columnNumber = lexer.columnNumber;
-
-    if (prevToken) {
-      prevToken.loc.end = {
-        line: lineNumber,
-        column: columnNumber
-      };
-    }
-
-    if (!token) {
-      break;
-    }
-
-    if (token.tokenType === "comment") {
-      // We've already dealt with the previous token's location.
-      prevToken = undefined;
-    } else {
-      let startLoc = {
-        line: lineNumber,
-        column: columnNumber
-      };
-      token.loc = {start: startLoc};
-
-      result.push(token);
-      prevToken = token;
-    }
-  }
-
-  return result;
-}
-
-exports.cssTokenizerWithLineColumn = cssTokenizerWithLineColumn;
diff --git a/browser/devtools/sourceeditor/moz.build b/browser/devtools/sourceeditor/moz.build
--- a/browser/devtools/sourceeditor/moz.build
+++ b/browser/devtools/sourceeditor/moz.build
@@ -2,14 +2,13 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXTRA_JS_MODULES.devtools.sourceeditor += [
     'autocomplete.js',
     'css-autocompleter.js',
-    'css-tokenizer.js',
     'debugger.js',
     'editor.js'
 ]
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
diff --git a/browser/devtools/styleeditor/StyleSheetEditor.jsm b/browser/devtools/styleeditor/StyleSheetEditor.jsm
--- a/browser/devtools/styleeditor/StyleSheetEditor.jsm
+++ b/browser/devtools/styleeditor/StyleSheetEditor.jsm
@@ -81,16 +81,22 @@ function StyleSheetEditor(styleSheet, wi
   this.styleSheet = styleSheet;
   this._inputElement = null;
   this.sourceEditor = null;
   this._window = win;
   this._isNew = isNew;
   this.walker = walker;
   this.highlighter = highlighter;
 
+  // True when we've called update() on the style sheet.
+  this._isUpdating = false;
+  // True when we've just set the editor text based on a style-applied
+  // event from the StyleSheetActor.
+  this._justSetText = false;
+
   this._state = {   // state to use when inputElement attaches
     text: "",
     selection: {
       start: {line: 0, ch: 0},
       end: {line: 0, ch: 0}
     }
   };
 
@@ -98,31 +104,33 @@ function StyleSheetEditor(styleSheet, wi
   if (styleSheet.href &&
       Services.io.extractScheme(this.styleSheet.href) == "file") {
     this._styleSheetFilePath = this.styleSheet.href;
   }
 
   this._onPropertyChange = this._onPropertyChange.bind(this);
   this._onError = this._onError.bind(this);
   this._onMediaRuleMatchesChange = this._onMediaRuleMatchesChange.bind(this);
-  this._onMediaRulesChanged = this._onMediaRulesChanged.bind(this)
+  this._onMediaRulesChanged = this._onMediaRulesChanged.bind(this);
+  this._onStyleApplied = this._onStyleApplied.bind(this);
   this.checkLinkedFileForChanges = this.checkLinkedFileForChanges.bind(this);
   this.markLinkedFileBroken = this.markLinkedFileBroken.bind(this);
   this.saveToFile = this.saveToFile.bind(this);
   this.updateStyleSheet = this.updateStyleSheet.bind(this);
   this._onMouseMove = this._onMouseMove.bind(this);
 
   this._focusOnSourceEditorReady = false;
   this.cssSheet.on("property-change", this._onPropertyChange);
   this.styleSheet.on("error", this._onError);
   this.mediaRules = [];
   if (this.cssSheet.getMediaRules) {
     this.cssSheet.getMediaRules().then(this._onMediaRulesChanged, Cu.reportError);
   }
   this.cssSheet.on("media-rules-changed", this._onMediaRulesChanged);
+  this.cssSheet.on("style-applied", this._onStyleApplied);
   this.savedFile = file;
   this.linkCSSFile();
 }
 
 StyleSheetEditor.prototype = {
   /**
    * Whether there are unsaved changes in the editor
    */
@@ -309,16 +317,43 @@ StyleSheetEditor.prototype = {
    * @param  {string} property
    *         Property that has changed on sheet
    */
   _onPropertyChange: function(property, value) {
     this.emit("property-change", property, value);
   },
 
   /**
+   * Called when the stylesheet text changes.
+   */
+  _onStyleApplied: function() {
+    if (this._isUpdating) {
+      // We just applied an edit in the editor, so we can drop this
+      // notification.
+      this._isUpdating = false;
+    } else if (this.sourceEditor) {
+      Task.spawn(function*() {
+        let longStr = yield this.styleSheet.getText();
+        let newText = yield longStr.string();
+        if (!this.styleSheet.isOriginalSource) {
+          let ruleCount = this.styleSheet.ruleCount;
+          newText = CssLogic.prettifyCSS(newText, ruleCount);
+        }
+        this._state.text = newText;
+        this._justSetText = true;
+        let firstLine = this.sourceEditor.getFirstVisibleLine();
+        let pos = this.sourceEditor.getCursor();
+        this.sourceEditor.setText(newText);
+        this.sourceEditor.setFirstVisibleLine(firstLine);
+        this.sourceEditor.setCursor(pos);
+      }.bind(this));
+    }
+  },
+
+  /**
    * Handles changes to the list of @media rules in the stylesheet.
    * Emits 'media-rules-changed' if the list has changed.
    *
    * @param  {array} rules
    *         Array of MediaRuleFronts for new media rules of sheet.
    */
   _onMediaRulesChanged: function(rules) {
     if (!rules.length && !this.mediaRules.length) {
@@ -481,27 +516,33 @@ StyleSheetEditor.prototype = {
   /**
    * Update live style sheet according to modifications.
    */
   _updateStyleSheet: function() {
     if (this.styleSheet.disabled) {
       return;  // TODO: do we want to do this?
     }
 
+    if (this._justSetText) {
+      this._justSetText = false;
+      return;
+    }
+
     this._updateTask = null; // reset only if we actually perform an update
                              // (stylesheet is enabled) so that 'missed' updates
                              // while the stylesheet is disabled can be performed
                              // when it is enabled back. @see enableStylesheet
 
     if (this.sourceEditor) {
       this._state.text = this.sourceEditor.getText();
     }
 
     let transitionsEnabled = Services.prefs.getBoolPref(TRANSITION_PREF);
 
+    this._isUpdating = true;
     this.styleSheet.update(this._state.text, transitionsEnabled)
                    .then(null, Cu.reportError);
   },
 
   /**
    * Handle mousemove events, calling _highlightSelectorAt after a delay only
    * and reseting the delay everytime.
    */
@@ -720,20 +761,21 @@ StyleSheetEditor.prototype = {
       if (this.highlighter && this.walker && this._sourceEditor.container) {
         this._sourceEditor.container.removeEventListener("mousemove",
           this._onMouseMove);
       }
       this._sourceEditor.destroy();
     }
     this.cssSheet.off("property-change", this._onPropertyChange);
     this.cssSheet.off("media-rules-changed", this._onMediaRulesChanged);
+    this.cssSheet.off("style-applied", this._onStyleApplied);
     this.styleSheet.off("error", this._onError);
     this._isDestroyed = true;
   }
-}
+};
 
 /**
  * Find a path on disk for a file given it's hosted uri, the uri of the
  * original resource that generated it (e.g. Sass file), and the location of the
  * local file for that source.
  *
  * @param {nsIURI} uri
  *        The uri of the resource
diff --git a/browser/devtools/styleeditor/test/browser.ini b/browser/devtools/styleeditor/test/browser.ini
--- a/browser/devtools/styleeditor/test/browser.ini
+++ b/browser/devtools/styleeditor/test/browser.ini
@@ -43,16 +43,17 @@ support-files =
   sourcemaps-large.html
   sourcemaps-watching.html
   test_private.css
   test_private.html
   doc_long.css
   doc_uncached.css
   doc_uncached.html
   doc_xulpage.xul
+  sync.html
 
 [browser_styleeditor_autocomplete.js]
 [browser_styleeditor_autocomplete-disabled.js]
 [browser_styleeditor_bug_740541_iframes.js]
 [browser_styleeditor_bug_851132_middle_click.js]
 [browser_styleeditor_bug_870339.js]
 [browser_styleeditor_cmd_edit.js]
 skip-if = e10s # Bug 1055333 - style editor tests disabled with e10s
@@ -78,10 +79,12 @@ skip-if = e10s # Bug 1055333 - style edi
 [browser_styleeditor_scroll.js]
 [browser_styleeditor_sv_keynav.js]
 [browser_styleeditor_sv_resize.js]
 [browser_styleeditor_selectstylesheet.js]
 [browser_styleeditor_sourcemaps.js]
 [browser_styleeditor_sourcemap_large.js]
 [browser_styleeditor_sourcemap_watching.js]
 skip-if = e10s # Bug 1055333 - style editor tests disabled with e10s
+[browser_styleeditor_sync.js]
+[browser_styleeditor_syncEditSelector.js]
 [browser_styleeditor_transition_rule.js]
 [browser_styleeditor_xul.js]
diff --git a/browser/devtools/styleeditor/test/browser_styleeditor_sync.js b/browser/devtools/styleeditor/test/browser_styleeditor_sync.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleeditor/test/browser_styleeditor_sync.js
@@ -0,0 +1,59 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Test that changes in the style inspector are synchronized into the
+// style editor.
+
+Services.scriptloader.loadSubScript("chrome://mochitests/content/browser/browser/devtools/styleinspector/test/head.js", this);
+
+const TESTCASE_URI = TEST_BASE_HTTP + "sync.html";
+
+const expectedText = `
+  body {
+    border-width: 15px;
+    /* color: red; */
+  }
+
+  #testid {
+    /* font-size: 4em; */
+  }
+  `;
+
+add_task(function*() {
+  yield addTab(TESTCASE_URI);
+  let { inspector, view } = yield openRuleView();
+  yield selectNode("#testid", inspector);
+  let ruleEditor = getRuleViewRuleEditor(view, 1);
+
+  // Disable the "font-size" property.
+  let propEditor = ruleEditor.rule.textProps[0].editor;
+  propEditor.enable.click();
+  yield ruleEditor.rule._applyingModifications;
+
+  // Disable the "color" property.  Note that this property is in a
+  // rule that also contains a non-inherited property -- so this test
+  // is also testing that property editing works properly in this
+  // situation.
+  ruleEditor = getRuleViewRuleEditor(view, 3);
+  propEditor = ruleEditor.rule.textProps[1].editor;
+  propEditor.enable.click();
+  yield ruleEditor.rule._applyingModifications;
+
+  let { ui } = yield openStyleEditor();
+
+  let editor = yield ui.editors[0].getSourceEditor();
+  let text = editor.sourceEditor.getText();
+  is(text, expectedText, "style inspector changes are synced");
+
+  // Close and reopen the toolbox, to see that the edited text remains
+  // available.
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  yield gDevTools.closeToolbox(target);
+
+  let { ui: newui } = yield openStyleEditor();
+  editor = yield newui.editors[0].getSourceEditor();
+  text = editor.sourceEditor.getText();
+  is(text, expectedText, "changes remain after close and reopen");
+});
diff --git a/browser/devtools/styleeditor/test/browser_styleeditor_syncEditSelector.js b/browser/devtools/styleeditor/test/browser_styleeditor_syncEditSelector.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleeditor/test/browser_styleeditor_syncEditSelector.js
@@ -0,0 +1,41 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Test that changes in the style inspector are synchronized into the
+// style editor.
+
+Services.scriptloader.loadSubScript("chrome://mochitests/content/browser/browser/devtools/styleinspector/test/head.js", this);
+
+const TESTCASE_URI = TEST_BASE_HTTP + "sync.html";
+
+const expectedText = `
+  body {
+    border-width: 15px;
+    color: red;
+  }
+
+  #testid, span {
+    font-size: 4em;
+  }
+  `;
+
+add_task(function*() {
+  yield addTab(TESTCASE_URI);
+  let { inspector, view } = yield openRuleView();
+  yield selectNode("#testid", inspector);
+  let ruleEditor = getRuleViewRuleEditor(view, 1);
+
+  let editor = yield focusEditableField(view, ruleEditor.selectorText);
+  editor.input.value = "#testid, span";
+  let onRuleViewChanged = once(view, "ruleview-changed");
+  EventUtils.synthesizeKey("VK_RETURN", {});
+  yield onRuleViewChanged;
+
+  let { ui } = yield openStyleEditor();
+
+  editor = yield ui.editors[0].getSourceEditor();
+  let text = editor.sourceEditor.getText();
+  is(text, expectedText, "selector edits are synced");
+});
diff --git a/browser/devtools/styleeditor/test/head.js b/browser/devtools/styleeditor/test/head.js
--- a/browser/devtools/styleeditor/test/head.js
+++ b/browser/devtools/styleeditor/test/head.js
@@ -66,27 +66,36 @@ function* cleanup()
     let target = TargetFactory.forTab(gBrowser.selectedTab);
     yield gDevTools.closeToolbox(target);
 
     gBrowser.removeCurrentTab();
   }
 }
 
 /**
+ * Open the style editor for the current tab.
+ */
+let openStyleEditor = Task.async(function*() {
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  let toolbox = yield gDevTools.showToolbox(target, "styleeditor");
+  let panel = toolbox.getPanel("styleeditor");
+  let ui = panel.UI;
+
+  return { toolbox, panel, ui };
+});
+
+/**
  * Creates a new tab in specified window navigates it to the given URL and
  * opens style editor in it.
  */
 let openStyleEditorForURL = Task.async(function* (url, win) {
   let tab = yield addTab(url, win);
-  let target = TargetFactory.forTab(tab);
-  let toolbox = yield gDevTools.showToolbox(target, "styleeditor");
-  let panel = toolbox.getPanel("styleeditor");
-  let ui = panel.UI;
-
-  return { tab, toolbox, panel, ui };
+  let result = yield openStyleEditor();
+  result.tab = tab;
+  return result;
 });
 
 /**
  * Loads shared/frame-script-utils.js in the specified tab.
  *
  * @param tab
  *        Optional tab to load the frame script in. Defaults to the current tab.
  */
diff --git a/browser/devtools/styleeditor/test/sync.html b/browser/devtools/styleeditor/test/sync.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleeditor/test/sync.html
@@ -0,0 +1,20 @@
+<!doctype html>
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>simple testcase</title>
+  <style type="text/css">
+  body {
+    border-width: 15px;
+    color: red;
+  }
+
+  #testid {
+    font-size: 4em;
+  }
+  </style>
+</head>
+<body>
+	<div id="testid">simple testcase</div>
+</body>
+</html>
diff --git a/browser/devtools/styleinspector/css-parsing-utils.js b/browser/devtools/styleinspector/css-parsing-utils.js
deleted file mode 100644
--- a/browser/devtools/styleinspector/css-parsing-utils.js
+++ /dev/null
@@ -1,218 +0,0 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const {cssTokenizer} = require("devtools/sourceeditor/css-tokenizer");
-
-const SELECTOR_ATTRIBUTE = exports.SELECTOR_ATTRIBUTE = 1;
-const SELECTOR_ELEMENT = exports.SELECTOR_ELEMENT = 2;
-const SELECTOR_PSEUDO_CLASS = exports.SELECTOR_PSEUDO_CLASS = 3;
-
-/**
- * Returns an array of CSS declarations given an string.
- * For example, parseDeclarations("width: 1px; height: 1px") would return
- * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
- *
- * The input string is assumed to only contain declarations so { and }
- * characters will be treated as part of either the property or value,
- * depending where it's found.
- *
- * @param {String} inputString
- *        An input string of CSS
- * @return {Array} an array of objects with the following signature:
- *         [{"name": string, "value": string, "priority": string}, ...]
- */
-function parseDeclarations(inputString) {
-  if (inputString === null || inputString === undefined) {
-    throw new Error("empty input string");
-  }
-
-  let tokens = cssTokenizer(inputString);
-
-  let declarations = [{name: "", value: "", priority: ""}];
-
-  let current = "", hasBang = false, lastProp;
-  for (let token of tokens) {
-    lastProp = declarations[declarations.length - 1];
-
-    if (token.tokenType === "symbol" && token.text === ":") {
-      if (!lastProp.name) {
-        // Set the current declaration name if there's no name yet
-        lastProp.name = current.trim();
-        current = "";
-        hasBang = false;
-      } else {
-        // Otherwise, just append ':' to the current value (declaration value
-        // with colons)
-        current += ":";
-      }
-    } else if (token.tokenType === "symbol" && token.text === ";") {
-      lastProp.value = current.trim();
-      current = "";
-      hasBang = false;
-      declarations.push({name: "", value: "", priority: ""});
-    } else if (token.tokenType === "ident") {
-      if (token.text === "important" && hasBang) {
-        lastProp.priority = "important";
-        hasBang = false;
-      } else {
-        if (hasBang) {
-          current += "!";
-        }
-        current += token.text;
-      }
-    } else if (token.tokenType === "symbol" && token.text === "!") {
-      hasBang = true;
-    } else if (token.tokenType === "whitespace") {
-      current += " ";
-    } else if (token.tokenType === "comment") {
-      // For now, just ignore.
-    } else {
-      current += inputString.substring(token.startOffset, token.endOffset);
-    }
-  }
-
-  // Handle whatever trailing properties or values might still be there
-  if (current) {
-    if (!lastProp.name) {
-      // Trailing property found, e.g. p1:v1;p2:v2;p3
-      lastProp.name = current.trim();
-    } else {
-      // Trailing value found, i.e. value without an ending ;
-      lastProp.value += current.trim();
-    }
-  }
-
-  // Remove declarations that have neither a name nor a value
-  declarations = declarations.filter(prop => prop.name || prop.value);
-
-  return declarations;
-}
-
-/**
- * Returns an array of the parsed CSS selector value and type given a string.
- *
- * The components making up the CSS selector can be extracted into 3 different
- * types: element, attribute and pseudoclass. The object that is appended to
- * the returned array contains the value related to one of the 3 types described
- * along with the actual type.
- *
- * The following are the 3 types that can be returned in the object signature:
- * (1) SELECTOR_ATTRIBUTE
- * (2) SELECTOR_ELEMENT
- * (3) SELECTOR_PSEUDO_CLASS
- *
- * @param {String} value
- *        The CSS selector text.
- * @return {Array} an array of objects with the following signature:
- *         [{ "value": string, "type": integer }, ...]
- */
-function parsePseudoClassesAndAttributes(value) {
-  if (!value) {
-    throw new Error("empty input string");
-  }
-
-  let tokens = cssTokenizer(value);
-  let result = [];
-  let current = "";
-  let functionCount = 0;
-  let hasAttribute = false;
-  let hasColon = false;
-
-  for (let token of tokens) {
-    if (token.tokenType === "ident") {
-      current += value.substring(token.startOffset, token.endOffset);
-
-      if (hasColon && !functionCount) {
-        if (current) {
-          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
-        }
-
-        current = "";
-        hasColon = false;
-      }
-    } else if (token.tokenType === "symbol" && token.text === ":") {
-      if (!hasColon) {
-        if (current) {
-          result.push({ value: current, type: SELECTOR_ELEMENT });
-        }
-
-        current = "";
-        hasColon = true;
-      }
-
-      current += token.text;
-    } else if (token.tokenType === "function") {
-      current += value.substring(token.startOffset, token.endOffset);
-      functionCount++;
-    } else if (token.tokenType === "symbol" && token.text === ")") {
-      current += token.text;
-
-      if (hasColon && functionCount == 1) {
-        if (current) {
-          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
-        }
-
-        current = "";
-        functionCount--;
-        hasColon = false;
-      } else {
-        functionCount--;
-      }
-    } else if (token.tokenType === "symbol" && token.text === "[") {
-      if (!hasAttribute && !functionCount) {
-        if (current) {
-          result.push({ value: current, type: SELECTOR_ELEMENT });
-        }
-
-        current = "";
-        hasAttribute = true;
-      }
-
-      current += token.text;
-    } else if (token.tokenType === "symbol" && token.text === "]") {
-      current += token.text;
-
-      if (hasAttribute && !functionCount) {
-        if (current) {
-          result.push({ value: current, type: SELECTOR_ATTRIBUTE });
-        }
-
-        current = "";
-        hasAttribute = false;
-      }
-    } else {
-      current += value.substring(token.startOffset, token.endOffset);
-    }
-  }
-
-  if (current) {
-    result.push({ value: current, type: SELECTOR_ELEMENT });
-  }
-
-  return result;
-}
-
-/**
- * Expects a single CSS value to be passed as the input and parses the value
- * and priority.
- *
- * @param {String} value
- *        The value from the text editor.
- * @return {Object} an object with 'value' and 'priority' properties.
- */
-function parseSingleValue(value) {
-  let declaration = parseDeclarations("a: " + value + ";")[0];
-  return {
-    value: declaration ? declaration.value : "",
-    priority: declaration ? declaration.priority : ""
-  };
-}
-
-exports.parseDeclarations = parseDeclarations;
-exports.parsePseudoClassesAndAttributes = parsePseudoClassesAndAttributes;
-exports.parseSingleValue = parseSingleValue;
diff --git a/browser/devtools/styleinspector/moz.build b/browser/devtools/styleinspector/moz.build
--- a/browser/devtools/styleinspector/moz.build
+++ b/browser/devtools/styleinspector/moz.build
@@ -1,18 +1,16 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
-XPCSHELL_TESTS_MANIFESTS += ['test/unit/xpcshell.ini']
 
 EXTRA_JS_MODULES.devtools.styleinspector += [
     'computed-view.js',
-    'css-parsing-utils.js',
     'rule-view.js',
     'style-inspector-menu.js',
     'style-inspector-overlays.js',
     'style-inspector.js',
     'utils.js',
 ]
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -25,23 +25,24 @@ const {
   createChild,
   appendText,
   advanceValidate,
   blurOnMultipleProperties,
   promiseWarn,
   throttle
 } = require("devtools/styleinspector/utils");
 const {
+  escapeCSSComment,
   parseDeclarations,
   parseSingleValue,
   parsePseudoClassesAndAttributes,
   SELECTOR_ATTRIBUTE,
   SELECTOR_ELEMENT,
   SELECTOR_PSEUDO_CLASS
-} = require("devtools/styleinspector/css-parsing-utils");
+} = require("devtools/shared/css-parsing-utils");
 loader.lazyRequireGetter(this, "overlays",
   "devtools/styleinspector/style-inspector-overlays");
 loader.lazyRequireGetter(this, "EventEmitter",
   "devtools/toolkit/event-emitter");
 loader.lazyRequireGetter(this, "StyleInspectorMenu",
   "devtools/styleinspector/style-inspector-menu");
 loader.lazyImporter(this, "Services", "resource://gre/modules/Services.jsm");
 
@@ -107,17 +108,17 @@ function createDummyDocument() {
  * ElementStyle:
  *   Responsible for keeping track of which properties are overridden.
  *   Maintains a list of Rule objects that apply to the element.
  * Rule:
  *   Manages a single style declaration or rule.
  *   Responsible for applying changes to the properties in a rule.
  *   Maintains a list of TextProperty objects.
  * TextProperty:
- *   Manages a single property from the cssText attribute of the
+ *   Manages a single property from the authoredText attribute of the
  *     relevant declaration.
  *   Maintains a list of computed properties that come from this
  *     property declaration.
  *   Changes to the TextProperty are sent to its related Rule for
  *     application.
  */
 
 /**
@@ -181,16 +182,22 @@ ElementStyle.prototype = {
   },
 
   destroy: function() {
     if (this.destroyed) {
       return;
     }
     this.destroyed = true;
 
+    for (let rule of this.rules) {
+      if (rule.editor) {
+        rule.editor.destroy();
+      }
+    }
+
     this.dummyElement = null;
     this.dummyElementPromise.then(dummyElement => {
       dummyElement.remove();
       this.dummyElementPromise = null;
     }, console.error);
   },
 
   /**
@@ -238,16 +245,21 @@ ElementStyle.prototype = {
         }
 
         // Mark overridden computed styles.
         this.markOverriddenAll();
 
         this._sortRulesForPseudoElement();
 
         // We're done with the previous list of rules.
+        for (let r of this._refreshRules) {
+          if (r && r.editor) {
+            r.editor.destroy();
+          }
+        }
         delete this._refreshRules;
       });
     }).then(null, e => {
       // populate is often called after a setTimeout,
       // the connection may already be closed.
       if (this.destroyed) {
         return promise.resolve(undefined);
       }
@@ -301,17 +313,17 @@ ElementStyle.prototype = {
     }
 
     // If this is a new rule, create its Rule object.
     if (!rule) {
       rule = new Rule(this, options);
     }
 
     // Ignore inherited rules with no properties.
-    if (options.inherited && rule.textProps.length === 0) {
+    if (options.inherited && !rule.anyProperties()) {
       return false;
     }
 
     this.rules.push(rule);
     return true;
   },
 
   /**
@@ -370,16 +382,26 @@ ElementStyle.prototype = {
     //   If the new property is a lower or equal priority, mark it as
     //   overridden.
     //
     // _overriddenDirty will be set on each prop, indicating whether its
     // dirty status changed during this pass.
     let taken = {};
     for (let computedProp of computedProps) {
       let earlier = taken[computedProp.name];
+
+      // Prevent -webkit-gradient from being selected after unchecking
+      // linear-gradient in this case:
+      //  -moz-linear-gradient: ...;
+      //  -webkit-linear-gradient: ...;
+      //  linear-gradient: ...;
+      if (!computedProp.textProp.isKnownProperty()) {
+        computedProp.overridden = true;
+        continue;
+      }
       let overridden;
       if (earlier &&
           computedProp.priority === "important" &&
           earlier.priority !== "important") {
         // New property is higher priority.  Mark the earlier property
         // overridden (which will reverse its dirty state).
         earlier._overriddenDirty = !earlier._overriddenDirty;
         earlier.overridden = true;
@@ -459,37 +481,32 @@ function Rule(elementStyle, options) {
   this.inherited = options.inherited || null;
   this.keyframes = options.keyframes || null;
   this._modificationDepth = 0;
 
   if (this.domRule && this.domRule.mediaText) {
     this.mediaText = this.domRule.mediaText;
   }
 
-  // Populate the text properties with the style's current cssText
+  // Populate the text properties with the style's current authoredText
   // value, and add in any disabled properties from the store.
   this.textProps = this._getTextProperties();
   this.textProps = this.textProps.concat(this._getDisabledProperties());
 }
 
 Rule.prototype = {
   mediaText: "",
 
   get title() {
-    if (this._title) {
-      return this._title;
+    let title = CssLogic.shortSource(this.sheet);
+    if (this.domRule.type !== ELEMENT_STYLE && this.ruleLine > 0) {
+      title += ":" + this.ruleLine;
     }
-    this._title = CssLogic.shortSource(this.sheet);
-    if (this.domRule.type !== ELEMENT_STYLE && this.ruleLine > 0) {
-      this._title += ":" + this.ruleLine;
-    }
-
-    this._title = this._title +
-      (this.mediaText ? " @media " + this.mediaText : "");
-    return this._title;
+
+    return title + (this.mediaText ? " @media " + this.mediaText : "");
   },
 
   get inheritedSource() {
     if (this._inheritedSource) {
       return this._inheritedSource;
     }
     this._inheritedSource = "";
     if (this.inherited) {
@@ -591,69 +608,79 @@ Rule.prototype = {
    * @param {String} priority
    *        The property's priority (either "important" or an empty string).
    * @param {TextProperty} siblingProp
    *        Optional, property next to which the new property will be added.
    */
   createProperty: function(name, value, priority, siblingProp) {
     let prop = new TextProperty(this, name, value, priority);
 
+    let ind;
     if (siblingProp) {
-      let ind = this.textProps.indexOf(siblingProp);
-      this.textProps.splice(ind + 1, 0, prop);
+      ind = this.textProps.indexOf(siblingProp) + 1;
+      this.textProps.splice(ind, 0, prop);
     } else {
+      ind = this.textProps.length;
       this.textProps.push(prop);
     }
 
-    this.applyProperties();
+    let deferred = promise.defer();
+    let modifications = this.style.startModifyingProperties();
+    modifications.getDefaultIndentation().then((indent) => {
+      modifications.createProperty(ind, name, value, priority, indent);
+      this.internalApplyProperties(modifications).then(() => {
+        deferred.resolve(null);
+      });
+    });
+    this.updateAfterApplyingProperties(deferred.promise);
     return prop;
   },
 
   /**
-   * Reapply all the properties in this rule, and update their
-   * computed styles. Store disabled properties in the element
-   * style's store. Will re-mark overridden properties.
+   * Helper function for applyProperties that is called when the actor
+   * does not support as-authored styles.  Store disabled properties
+   * in the element style's store.
    */
-  applyProperties: function(modifications) {
+  _applyPropertiesNoAuthored: function(modifications) {
     this.elementStyle.markOverriddenAll();
 
-    if (!modifications) {
-      modifications = this.style.startModifyingProperties();
-    }
     let disabledProps = [];
 
     for (let prop of this.textProps) {
+      if (prop.invisible) {
+        continue;
+      }
       if (!prop.enabled) {
         disabledProps.push({
           name: prop.name,
           value: prop.value,
           priority: prop.priority
         });
         continue;
       }
       if (prop.value.trim() === "") {
         continue;
       }
 
-      modifications.setProperty(prop.name, prop.value, prop.priority);
+      modifications.setProperty(-1, prop.name, prop.value, prop.priority);
 
       prop.updateComputed();
     }
 
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
-    let modificationsPromise = modifications.apply().then(() => {
+    return modifications.apply().then(() => {
       let cssProps = {};
-      for (let cssProp of parseDeclarations(this.style.cssText)) {
+      for (let cssProp of parseDeclarations(this.style.authoredText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
         if (!textProp.enabled) {
           continue;
         }
         let cssProp = cssProps[textProp.name];
@@ -663,46 +690,78 @@ Rule.prototype = {
             name: textProp.name,
             value: "",
             priority: ""
           };
         }
 
         textProp.priority = cssProp.priority;
       }
-
+    });
+  },
+
+  internalApplyProperties: function(modifications) {
+    let modificationsPromise;
+    if (this.style.canSetRuleText) {
+      modificationsPromise = modifications.apply().then(() => {
+        // The rewriting may have required some other property values
+        // to change, e.g., to insert some needed terminators.  Update
+        // the relevant properties here.
+        for (let index in modifications.changedDeclarations) {
+          let newValue = modifications.changedDeclarations[index];
+          this.textProps[index].noticeNewValue(newValue);
+        }
+      });
+    } else {
+      modificationsPromise = this._applyPropertiesNoAuthored(modifications);
+    }
+    return modificationsPromise;
+  },
+
+  updateAfterApplyingProperties: function(modificationsPromise) {
+    let resultPromise = modificationsPromise.then(() => {
       this.elementStyle.markOverriddenAll();
 
-      if (modificationsPromise === this._applyingModifications) {
+      if (resultPromise === this._applyingModifications) {
         this._applyingModifications = null;
       }
 
       this.elementStyle._changed();
     }).then(null, promiseWarn);
 
-    this._applyingModifications = modificationsPromise;
-    return modificationsPromise;
+    this._applyingModifications = resultPromise;
+    return resultPromise;
+  },
+
+  /**
+   * Reapply all the properties in this rule, and update their
+   * computed styles.  Will re-mark overridden properties.
+   */
+  applyProperties: function(modifications) {
+    let modificationsPromise = this.internalApplyProperties(modifications);
+    this.updateAfterApplyingProperties(modificationsPromise);
   },
 
   /**
    * Renames a property.
    *
    * @param {TextProperty} property
    *        The property to rename.
    * @param {String} name
    *        The new property name (such as "background" or "border-top").
    */
   setPropertyName: function(property, name) {
     if (name === property.name) {
       return;
     }
     let modifications = this.style.startModifyingProperties();
-    modifications.removeProperty(property.name);
+    modifications.renameProperty(this.textProps.indexOf(property),
+                                 property.name, name);
     property.name = name;
-    this.applyProperties(modifications, name);
+    this.applyProperties(modifications);
   },
 
   /**
    * Sets the value and priority of a property, then reapply all properties.
    *
    * @param {TextProperty} property
    *        The property to manipulate.
    * @param {String} value
@@ -712,88 +771,104 @@ Rule.prototype = {
    */
   setPropertyValue: function(property, value, priority) {
     if (value === property.value && priority === property.priority) {
       return;
     }
 
     property.value = value;
     property.priority = priority;
-    this.applyProperties(null, property.name);
+
+    let index = this.textProps.indexOf(property);
+    let deferred = promise.defer();
+    let modifications = this.style.startModifyingProperties();
+    modifications.getDefaultIndentation().then((indent) => {
+      modifications.setProperty(index, property.name, value, priority, indent);
+      this.internalApplyProperties(modifications).then(() => {
+        deferred.resolve(null);
+      });
+    });
+    this.updateAfterApplyingProperties(deferred.promise);
   },
 
   /**
    * Just sets the value and priority of a property, in order to preview its
    * effect on the content document.
    *
    * @param {TextProperty} property
    *        The property which value will be previewed
    * @param {String} value
    *        The value to be used for the preview
    * @param {String} priority
    *        The property's priority (either "important" or an empty string).
    */
   previewPropertyValue: function(property, value, priority) {
     let modifications = this.style.startModifyingProperties();
-    modifications.setProperty(property.name, value, priority);
+    modifications.setProperty(this.textProps.indexOf(property),
+                              property.name, value, priority);
     modifications.apply().then(() => {
       // Ensure dispatching a ruleview-changed event
       // also for previews
       this.elementStyle._changed();
     });
   },
 
   /**
    * Disables or enables given TextProperty.
    *
    * @param {TextProperty} property
    *        The property to enable/disable
    * @param {Boolean} value
    */
   setPropertyEnabled: function(property, value) {
+    if (property.enabled === !!value) {
+      // Wow.
+      this.elementStyle._changed();
+      return;
+    }
     property.enabled = !!value;
     let modifications = this.style.startModifyingProperties();
-    if (!property.enabled) {
-      modifications.removeProperty(property.name);
-    }
+    modifications.setPropertyEnabled(this.textProps.indexOf(property),
+                                     property.name, property.enabled);
     this.applyProperties(modifications);
   },
 
   /**
    * Remove a given TextProperty from the rule and update the rule
    * accordingly.
    *
    * @param {TextProperty} property
    *        The property to be removed
    */
   removeProperty: function(property) {
-    this.textProps = this.textProps.filter(prop => prop !== property);
+    let index = this.textProps.indexOf(property);
+    this.textProps.splice(index, 1);
     let modifications = this.style.startModifyingProperties();
-    modifications.removeProperty(property.name);
+    modifications.removeProperty(index, property.name);
     // Need to re-apply properties in case removing this TextProperty
     // exposes another one.
     this.applyProperties(modifications);
   },
 
   /**
    * Get the list of TextProperties from the style. Needs
-   * to parse the style's cssText.
+   * to parse the style's authoredText.
    */
   _getTextProperties: function() {
     let textProps = [];
     let store = this.elementStyle.store;
-    let props = parseDeclarations(this.style.cssText);
+    let props = parseDeclarations(this.style.authoredText, true);
     for (let prop of props) {
       let name = prop.name;
-      if (this.inherited && !domUtils.isInheritedProperty(name)) {
-        continue;
-      }
+      let invisible = this.inherited && !domUtils.isInheritedProperty(name);
       let value = store.userProperties.getProperty(this.style, name,
                                                    prop.value);
-      let textProp = new TextProperty(this, name, value, prop.priority);
+      let textProp = new TextProperty(this, name, value, prop.priority,
+                                      !("commentOffsets" in prop),
+                                      invisible);
       textProps.push(textProp);
     }
 
     return textProps;
   },
 
   /**
    * Return the list of disabled properties from the store for this rule.
@@ -860,33 +935,33 @@ Rule.prototype = {
     // Refresh the editor if one already exists.
     if (this.editor) {
       this.editor.populate();
     }
   },
 
   /**
    * Update the current TextProperties that match a given property
-   * from the cssText.  Will choose one existing TextProperty to update
+   * from the authoredText.  Will choose one existing TextProperty to update
    * with the new property's value, and will disable all others.
    *
    * When choosing the best match to reuse, properties will be chosen
    * by assigning a rank and choosing the highest-ranked property:
    *   Name, value, and priority match, enabled. (6)
    *   Name, value, and priority match, disabled. (5)
    *   Name and value match, enabled. (4)
    *   Name and value match, disabled. (3)
    *   Name matches, enabled. (2)
    *   Name matches, disabled. (1)
    *
    * If no existing properties match the property, nothing happens.
    *
    * @param {TextProperty} newProp
    *        The current version of the property, as parsed from the
-   *        cssText in Rule._getTextProperties().
+   *        authoredText in Rule._getTextProperties().
    * @return {Boolean} true if a property was updated, false if no properties
    *         were updated.
    */
   _updateTextProperty: function(newProp) {
     let match = { rank: 0, prop: null };
 
     for (let prop of this.textProps) {
       if (prop.name !== newProp.name) {
@@ -949,66 +1024,99 @@ Rule.prototype = {
    *        The text property that will be left to focus on a sibling.
    * @param {Number} direction
    *        The move focus direction number.
    */
   editClosestTextProperty: function(textProperty, direction) {
     let index = this.textProps.indexOf(textProperty);
 
     if (direction === Ci.nsIFocusManager.MOVEFOCUS_FORWARD) {
-      if (index === this.textProps.length - 1) {
+      for (++index; index < this.textProps.length; ++index) {
+        if (!this.textProps[index].invisible) {
+          break;
+        }
+      }
+      if (index === this.textProps.length) {
         textProperty.rule.editor.closeBrace.click();
       } else {
-        let nextProp = this.textProps[index + 1];
-        nextProp.editor.nameSpan.click();
+        this.textProps[index].editor.nameSpan.click();
       }
     } else if (direction === Ci.nsIFocusManager.MOVEFOCUS_BACKWARD) {
-      if (index === 0) {
+      for (--index; index >= 0; --index) {
+        if (!this.textProps[index].invisible) {
+          break;
+        }
+      }
+      if (index < 0) {
         textProperty.editor.ruleEditor.selectorText.click();
       } else {
-        let prevProp = this.textProps[index - 1];
-        prevProp.editor.valueSpan.click();
+        this.textProps[index].editor.valueSpan.click();
       }
     }
   },
 
   /**
    * Return a string representation of the rule.
    */
   stringifyRule: function() {
     let selectorText = this.selectorText;
     let cssText = "";
     let terminator = osString === "WINNT" ? "\r\n" : "\n";
 
     for (let textProp of this.textProps) {
-      cssText += "\t" + textProp.stringifyProperty() + terminator;
+      if (!textProp.invisible) {
+        cssText += "\t" + textProp.stringifyProperty() + terminator;
+      }
     }
 
     return selectorText + " {" + terminator + cssText + "}";
+  },
+
+  /**
+   * See whether this rule has any non-invisible properties.
+   * @return {Boolean} true if there is any visible property, or false
+   *         if all properties are invisible
+   */
+  anyProperties: function() {
+    for (let prop of this.textProps) {
+      if (!prop.invisible) {
+        return true;
+      }
+    }
+    return false;
   }
 };
 
 /**
- * A single property in a rule's cssText.
+ * A single property in a rule's authoredText.
  *
  * @param {Rule} rule
  *        The rule this TextProperty came from.
  * @param {String} name
  *        The text property name (such as "background" or "border-top").
  * @param {String} value
  *        The property's value (not including priority).
  * @param {String} priority
  *        The property's priority (either "important" or an empty string).
+ * @param {Boolean} enabled
+ *        Whether the property is enabled.
+ * @param {Boolean} invisible
+ *        Whether the property is invisible.  An invisible property
+ *        does not show up in the UI; these are needed so that the
+ *        index of a property in textProps is the same as the index
+ *        coming from parseDeclarations.
  */
-function TextProperty(rule, name, value, priority) {
+function TextProperty(rule, name, value, priority, enabled = true,
+                      invisible = false) {
   this.rule = rule;
   this.name = name;
   this.value = value;
   this.priority = priority;
-  this.enabled = true;
+  this.enabled = !!enabled;
+  this.invisible = invisible;
   this.updateComputed();
 }
 
 TextProperty.prototype = {
   /**
    * Update the editor associated with this text property,
    * if any.
    */
@@ -1083,16 +1191,27 @@ TextProperty.prototype = {
     if (this.editor && value !== this.editor.committed.value || force) {
       store.userProperties.setProperty(this.rule.style, this.name, value);
     }
 
     this.rule.setPropertyValue(this, value, priority);
     this.updateEditor();
   },
 
+  /**
+   * Called when the property's value has been updated externally, and
+   * the property and editor should update.
+   */
+  noticeNewValue: function(value) {
+    if (value !== this.value) {
+      this.value = value;
+      this.updateEditor();
+    }
+  },
+
   setName: function(name) {
     let store = this.rule.elementStyle.store;
 
     if (name !== this.name) {
       store.userProperties.setProperty(this.rule.style, name,
                                        this.editor.committed.value);
     }
 
@@ -1114,20 +1233,37 @@ TextProperty.prototype = {
    */
   stringifyProperty: function() {
     // Get the displayed property value
     let declaration = this.name + ": " + this.editor.valueSpan.textContent +
       ";";
 
     // Comment out property declarations that are not enabled
     if (!this.enabled) {
-      declaration = "/* " + declaration + " */";
+      declaration = "/* " + escapeCSSComment(declaration) + " */";
     }
 
     return declaration;
+  },
+
+  /**
+   * See whether this property's name is known.
+   *
+   * @return {Boolean} true if the property name is valid, false otherwise.
+   */
+  isKnownProperty: function() {
+    try {
+      // If the property name is invalid, the cssPropertyIsShorthand
+      // will throw an exception.  But if it is valid, no exception will
+      // be thrown; so we just ignore the return value.
+      domUtils.cssPropertyIsShorthand(this.name);
+      return true;
+    } catch (e) {
+      return false;
+    }
   }
 };
 
 /**
  * View hierarchy mostly follows the model hierarchy.
  *
  * CssRuleView:
  *   Owns an ElementStyle and creates a list of RuleEditors for its
@@ -2142,17 +2278,17 @@ CssRuleView.prototype = {
    */
   highlightRule: function(rule) {
     let isRuleSelectorHighlighted = this._highlightRuleSelector(rule);
     let isStyleSheetHighlighted = this._highlightStyleSheet(rule);
     let isHighlighted = isRuleSelectorHighlighted || isStyleSheetHighlighted;
 
     // Highlight search matches in the rule properties
     for (let textProp of rule.textProps) {
-      if (this._highlightProperty(textProp.editor)) {
+      if (!textProp.invisible && this._highlightProperty(textProp.editor)) {
         isHighlighted = true;
       }
     }
 
     return isHighlighted;
   },
 
   /**
@@ -2431,21 +2567,28 @@ function RuleEditor(aRuleView, aRule) {
   this.isEditable = !aRule.isSystem;
   // Flag that blocks updates of the selector and properties when it is
   // being edited
   this.isEditing = false;
 
   this._onNewProperty = this._onNewProperty.bind(this);
   this._newPropertyDestroy = this._newPropertyDestroy.bind(this);
   this._onSelectorDone = this._onSelectorDone.bind(this);
+  this._propertyChanged = this._propertyChanged.bind(this);
+
+  this.rule.domRule.on("property-change", this._propertyChanged);
 
   this._create();
 }
 
 RuleEditor.prototype = {
+  destroy: function() {
+    this.rule.domRule.off("property-change");
+  },
+
   get isSelectorEditable() {
     let toolbox = this.ruleView.inspector.toolbox;
     let trait = this.isEditable &&
       toolbox.target.client.traits.selectorEditable &&
       this.rule.domRule.type !== ELEMENT_STYLE &&
       this.rule.domRule.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE;
 
     // Do not allow editing anonymousselectors until we can
@@ -2550,38 +2693,49 @@ RuleEditor.prototype = {
 
       // Create a property editor when the close brace is clicked.
       editableItem({ element: this.closeBrace }, () => {
         this.newProperty();
       });
     }
   },
 
+  /**
+   * Event handler called when a property changes on the
+   * StyleRuleActor.
+   */
+  _propertyChanged: function(name) {
+    if (name === "line") {
+      this.updateSourceLink();
+    }
+  },
+
   updateSourceLink: function() {
     let sourceLabel = this.element.querySelector(".ruleview-rule-source-label");
+    let title = this.rule.title;
     let sourceHref = (this.rule.sheet && this.rule.sheet.href) ?
-      this.rule.sheet.href : this.rule.title;
+      this.rule.sheet.href : title;
     let sourceLine = this.rule.ruleLine > 0 ? ":" + this.rule.ruleLine : "";
 
     sourceLabel.setAttribute("tooltiptext", sourceHref + sourceLine);
 
     if (this.rule.isSystem) {
       let uaLabel = _strings.GetStringFromName("rule.userAgentStyles");
-      sourceLabel.setAttribute("value", uaLabel + " " + this.rule.title);
+      sourceLabel.setAttribute("value", uaLabel + " " + title);
 
       // Special case about:PreferenceStyleSheet, as it is generated on the
       // fly and the URI is not registered with the about: handler.
       // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
       if (sourceHref === "about:PreferenceStyleSheet") {
         sourceLabel.parentNode.setAttribute("unselectable", "true");
         sourceLabel.setAttribute("value", uaLabel);
         sourceLabel.removeAttribute("tooltiptext");
       }
     } else {
-      sourceLabel.setAttribute("value", this.rule.title);
+      sourceLabel.setAttribute("value", title);
       if (this.rule.ruleLine === -1 && this.rule.domRule.parentStyleSheet) {
         sourceLabel.parentNode.setAttribute("unselectable", "true");
       }
     }
 
     let showOrig = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);
     if (showOrig && !this.rule.isSystem &&
         this.rule.domRule.type !== ELEMENT_STYLE) {
@@ -2650,17 +2804,17 @@ RuleEditor.prototype = {
             textContent: selectorText.value,
             class: selectorClass
           });
         }
       });
     }
 
     for (let prop of this.rule.textProps) {
-      if (!prop.editor) {
+      if (!prop.editor && !prop.invisible) {
         let editor = new TextPropertyEditor(this, prop);
         this.propertyList.appendChild(editor.element);
       }
     }
   },
 
   /**
    * Programatically add a new property to the rule.
@@ -3168,17 +3322,18 @@ TextPropertyEditor.prototype = {
       this.enable.removeAttribute("checked");
     }
 
     this.warning.hidden = this.editing || this.isValid();
     this.filterProperty.hidden = this.editing ||
                                  !this.isValid() ||
                                  !this.prop.overridden;
 
-    if (this.prop.overridden || !this.prop.enabled) {
+    if (this.prop.overridden || !this.prop.enabled ||
+        !this.prop.isKnownProperty()) {
       this.element.classList.add("ruleview-overridden");
     } else {
       this.element.classList.remove("ruleview-overridden");
     }
 
     let name = this.prop.name;
     this.nameSpan.textContent = name;
 
@@ -3551,17 +3706,17 @@ TextPropertyEditor.prototype = {
     this._previewValue(this.valueSpan.textContent);
   },
 
   /**
    * Called when the swatch editor closes from an ESC. Revert to the original
    * value of this property before editing.
    */
   _onSwatchRevert: function() {
-    this.rule.setPropertyEnabled(this.prop, this.prop.enabled);
+    this._previewValue(this.prop.value);
     this.update();
   },
 
   /**
    * Parse a value string and break it into pieces, starting with the
    * first value, and into an array of additional properties (if any).
    *
    * Example: Calling with "red; width: 100px" would return
diff --git a/browser/devtools/styleinspector/style-inspector.js b/browser/devtools/styleinspector/style-inspector.js
--- a/browser/devtools/styleinspector/style-inspector.js
+++ b/browser/devtools/styleinspector/style-inspector.js
@@ -45,16 +45,17 @@ function RuleViewTool(inspector, window)
   this.view.on("ruleview-linked-clicked", this.onLinkClicked);
 
   this.inspector.selection.on("detached", this.onSelected);
   this.inspector.selection.on("new-node-front", this.onSelected);
   this.inspector.on("layout-change", this.refresh);
   this.inspector.selection.on("pseudoclass", this.refresh);
   this.inspector.target.on("navigate", this.clearUserProperties);
   this.inspector.sidebar.on("ruleview-selected", this.onPanelSelected);
+  this.inspector.pageStyle.on("stylesheet-updated", this.refresh);
 
   this.onSelected();
 }
 
 RuleViewTool.prototype = {
   isSidebarActive: function() {
     if (!this.view) {
       return false;
@@ -149,16 +150,19 @@ RuleViewTool.prototype = {
   },
 
   destroy: function() {
     this.inspector.off("layout-change", this.refresh);
     this.inspector.selection.off("pseudoclass", this.refresh);
     this.inspector.selection.off("new-node-front", this.onSelected);
     this.inspector.target.off("navigate", this.clearUserProperties);
     this.inspector.sidebar.off("ruleview-selected", this.onPanelSelected);
+    if (this.inspector.pageStyle) {
+      this.inspector.pageStyle.off("stylesheet-updated", this.refresh);
+    }
 
     this.view.off("ruleview-linked-clicked", this.onLinkClicked);
     this.view.off("ruleview-changed", this.onPropertyChanged);
     this.view.off("ruleview-refreshed", this.onViewRefreshed);
 
     this.view.destroy();
 
     this.view = this.document = this.inspector = null;
@@ -176,16 +180,17 @@ function ComputedViewTool(inspector, win
   this.refresh = this.refresh.bind(this);
   this.onPanelSelected = this.onPanelSelected.bind(this);
 
   this.inspector.selection.on("detached", this.onSelected);
   this.inspector.selection.on("new-node-front", this.onSelected);
   this.inspector.on("layout-change", this.refresh);
   this.inspector.selection.on("pseudoclass", this.refresh);
   this.inspector.sidebar.on("computedview-selected", this.onPanelSelected);
+  this.inspector.pageStyle.on("stylesheet-updated", this.refresh);
 
   this.view.selectElement(null);
 
   this.onSelected();
 }
 
 ComputedViewTool.prototype = {
   isSidebarActive: function() {
@@ -241,16 +246,19 @@ ComputedViewTool.prototype = {
   },
 
   destroy: function() {
     this.inspector.off("layout-change", this.refresh);
     this.inspector.sidebar.off("computedview-selected", this.refresh);
     this.inspector.selection.off("pseudoclass", this.refresh);
     this.inspector.selection.off("new-node-front", this.onSelected);
     this.inspector.sidebar.off("computedview-selected", this.onPanelSelected);
+    if (this.inspector.pageStyle) {
+      this.inspector.pageStyle.off("stylesheet-updated", this.refresh);
+    }
 
     this.view.destroy();
 
     this.view = this.document = this.inspector = null;
   }
 };
 
 exports.RuleViewTool = RuleViewTool;
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -55,16 +55,17 @@ support-files =
 [browser_ruleview_add-property_01.js]
 [browser_ruleview_add-property_02.js]
 [browser_ruleview_add-property-svg.js]
 [browser_ruleview_add-rule_01.js]
 [browser_ruleview_add-rule_02.js]
 [browser_ruleview_add-rule_03.js]
 [browser_ruleview_add-rule_04.js]
 [browser_ruleview_add-rule_pseudo_class.js]
+[browser_ruleview_authored.js]
 [browser_ruleview_colorpicker-and-image-tooltip_01.js]
 [browser_ruleview_colorpicker-and-image-tooltip_02.js]
 [browser_ruleview_colorpicker-appears-on-swatch-click.js]
 [browser_ruleview_colorpicker-commit-on-ENTER.js]
 [browser_ruleview_colorpicker-edit-gradient.js]
 [browser_ruleview_colorpicker-hides-on-tooltip.js]
 [browser_ruleview_colorpicker-multiple-changes.js]
 [browser_ruleview_colorpicker-release-outside-frame.js]
diff --git a/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js b/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js
--- a/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js
@@ -29,17 +29,23 @@ add_task(function*() {
   checkColorCycling(container, inspector);
 });
 
 function checkColorCycling(container, inspector) {
   let swatch = container.querySelector(".computedview-colorswatch");
   let valueNode = container.querySelector(".computedview-color");
   let win = inspector.sidebar.getWindowForTab("computedview");
 
-  // Hex (default)
+  // "Authored" (default; currently the computed value)
+  is(valueNode.textContent, "rgb(255, 0, 0)",
+                            "Color displayed as an RGB value.");
+
+  // Hex
+  EventUtils.synthesizeMouseAtCenter(swatch,
+                                     {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "#F00", "Color displayed as a hex value.");
 
   // HSL
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "hsl(0, 100%, 50%)",
                             "Color displayed as an HSL value.");
 
@@ -50,20 +56,14 @@ function checkColorCycling(container, in
                             "Color displayed as an RGB value.");
 
   // Color name
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "red",
                             "Color displayed as a color name.");
 
-  // "Authored" (currently the computed value)
+  // Back to "Authored"
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "rgb(255, 0, 0)",
                             "Color displayed as an RGB value.");
-
-  // Back to hex
-  EventUtils.synthesizeMouseAtCenter(swatch,
-                                     {type: "mousedown", shiftKey: true}, win);
-  is(valueNode.textContent, "#F00",
-                            "Color displayed as hex again.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js b/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js
--- a/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js
@@ -70,30 +70,30 @@ const TEST_DATA = [
     getHoveredNode: function*(view) {
       return getComputedViewProperty(view, "color").nameSpan;
     },
     assertNodeInfo: function(nodeInfo) {
       is(nodeInfo.type, VIEW_NODE_PROPERTY_TYPE);
       ok("property" in nodeInfo.value);
       ok("value" in nodeInfo.value);
       is(nodeInfo.value.property, "color");
-      is(nodeInfo.value.value, "#F00");
+      is(nodeInfo.value.value, "rgb(255, 0, 0)");
     }
   },
   {
     desc: "Testing a property value",
     getHoveredNode: function*(view) {
       return getComputedViewProperty(view, "color").valueSpan;
     },
     assertNodeInfo: function(nodeInfo) {
       is(nodeInfo.type, VIEW_NODE_VALUE_TYPE);
       ok("property" in nodeInfo.value);
       ok("value" in nodeInfo.value);
       is(nodeInfo.value.property, "color");
-      is(nodeInfo.value.value, "#F00");
+      is(nodeInfo.value.value, "rgb(255, 0, 0)");
     }
   },
   {
     desc: "Testing an image url",
     getHoveredNode: function*(view) {
       let {valueSpan} = getComputedViewProperty(view, "background-image");
       return valueSpan.querySelector(".theme-link");
     },
@@ -144,17 +144,17 @@ const TEST_DATA = [
     desc: "Testing a matched rule value",
     getHoveredNode: function*(view) {
       let content = yield getComputedViewMatchedRules(view, "color");
       return content.querySelector(".other-property-value");
     },
     assertNodeInfo: function(nodeInfo) {
       is(nodeInfo.type, VIEW_NODE_VALUE_TYPE);
       is(nodeInfo.value.property, "color");
-      is(nodeInfo.value.value, "#F00");
+      is(nodeInfo.value.value, "red");
     }
   },
   {
     desc: "Testing a matched rule stylesheet link",
     getHoveredNode: function*(view) {
       let content = yield getComputedViewMatchedRules(view, "color");
       return content.querySelector(".rule-link .theme-link");
     },
diff --git a/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js b/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js
--- a/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js
@@ -20,10 +20,10 @@ add_task(function*() {
   info("Changing the node's style and waiting for the update");
   let onUpdated = inspector.once("computed-view-refreshed");
   getNode("#testdiv").style.cssText = "font-size: 15px; color: red;";
   yield onUpdated;
 
   fontSize = getComputedViewPropertyValue(view, "font-size");
   is(fontSize, "15px", "The computed view shows the updated font-size");
   let color = getComputedViewPropertyValue(view, "color");
-  is(color, "#F00", "The computed view also shows the color now");
+  is(color, "rgb(255, 0, 0)", "The computed view also shows the color now");
 });
diff --git a/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js b/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js
--- a/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js
@@ -76,17 +76,17 @@ function checkSelectAll(view) {
   info("Testing select-all copy");
 
   let contentDoc = view.styleDocument;
   let prop = contentDoc.querySelector(".property-view");
 
   info("Checking that _onSelectAll() then copy returns the correct " +
     "clipboard value");
   view._contextmenu._onSelectAll();
-  let expectedPattern = "color: #FF0;[\\r\\n]+" +
+  let expectedPattern = "color: rgb\\(255, 255, 0\\);[\\r\\n]+" +
                         "font-family: helvetica,sans-serif;[\\r\\n]+" +
                         "font-size: 16px;[\\r\\n]+" +
                         "font-variant-caps: small-caps;[\\r\\n]*";
 
   return waitForClipboard(() => {
     fireCopyEvent(prop);
   }, () => {
     return checkClipboardData(expectedPattern);
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_authored.js b/browser/devtools/styleinspector/test/browser_ruleview_authored.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_ruleview_authored.js
@@ -0,0 +1,143 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test for as-authored styles.
+
+add_task(function*() {
+  yield addTab("data:text/html;charset=utf-8,browser_ruleview_authored.js");
+  let {inspector, view} = yield openRuleView();
+
+  yield basicTest(inspector, view);
+  yield overrideTest(inspector, view);
+  yield colorEditingTest(inspector, view);
+});
+
+function* createTestContent(inspector, style) {
+  let onMutated = inspector.once("markupmutation");
+  let styleNode = addStyle(content.document, style);
+  content.document.body.innerHTML =
+    '<div id="testid" class="testclass">Styled Node</div>';
+  yield onMutated;
+  yield selectNode("#testid", inspector);
+  return styleNode;
+}
+
+function* removeTestContent(inspector, node) {
+  let onMutated = inspector.once("markupmutation");
+  node.remove();
+  yield onMutated;
+}
+
+function* basicTest(inspector, view) {
+  let styleNode = yield createTestContent(inspector, "" +
+                                          "#testid {" +
+                                          // Invalid property.
+                                          "  something: random;" +
+                                          // Invalid value.
+                                          "  color: orang;" +
+                                          // Override.
+                                          "  background-color: blue;" +
+                                          "  background-color: #f0c;" +
+                                          "} ");
+
+  let elementStyle = view._elementStyle;
+
+  let expected = [
+    {name: "something", overridden: true},
+    {name: "color", overridden: true},
+    {name: "background-color", overridden: true},
+    {name: "background-color", overridden: false}
+  ];
+
+  let rule = elementStyle.rules[1];
+
+  for (let i = 0; i < expected.length; ++i) {
+    let prop = rule.textProps[i];
+    is(prop.name, expected[i].name, "test name for prop " + i);
+    is(prop.overridden, expected[i].overridden,
+       "test overridden for prop " + i);
+  }
+
+  yield removeTestContent(inspector, styleNode);
+}
+
+function* overrideTest(inspector, view) {
+  let gradientText = "(45deg, rgba(255,255,255,0.2) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.2) 75%, transparent 75%, transparent);";
+
+  let styleNode =
+      yield createTestContent(inspector, "" +
+                              "#testid {" +
+                              "  background-image: -moz-linear-gradient" +
+                              gradientText +
+                              "  background-image: -webkit-linear-gradient" +
+                              gradientText +
+                              "  background-image: linear-gradient" +
+                              gradientText +
+                              "} ");
+
+  let elementStyle = view._elementStyle;
+  let rule = elementStyle.rules[1];
+
+  // Initially the last property should be active.
+  for (let i = 0; i < 3; ++i) {
+    let prop = rule.textProps[i];
+    is(prop.name, "background-image", "check the property name");
+    is(prop.overridden, i !== 2, "check overridden for " + i);
+  }
+
+  rule.textProps[2].setEnabled(false);
+  yield rule._applyingModifications;
+
+  // Now the first property should be active.
+  for (let i = 0; i < 3; ++i) {
+    let prop = rule.textProps[i];
+    is(prop.overridden || !prop.enabled, i !== 0,
+       "post-change check overridden for " + i);
+  }
+
+  yield removeTestContent(inspector, styleNode);
+}
+
+function* colorEditingTest(inspector, view) {
+  let colors = [
+    {name: "hex", text: "#f0c", result: "#0F0"},
+    {name: "rgb", text: "rgb(0,128,250)", result: "rgb(0, 255, 0)"}
+  ];
+
+  Services.prefs.setCharPref("devtools.defaultColorUnit", "authored");
+
+  for (let color of colors) {
+    let styleNode = yield createTestContent(inspector, "" +
+                                            "#testid {" +
+                                            "  color: " + color.text + ";" +
+                                            "} ");
+
+    let cPicker = view.tooltips.colorPicker;
+    let swatch = getRuleViewProperty(view, "#testid", "color").valueSpan
+        .querySelector(".ruleview-colorswatch");
+    let onShown = cPicker.tooltip.once("shown");
+    swatch.click();
+    yield onShown;
+
+    let testNode = yield getNode("#testid");
+
+    yield simulateColorPickerChange(view, cPicker, [0, 255, 0, 1], {
+      element: testNode,
+      name: "color",
+      value: "rgb(0, 255, 0)"
+    });
+
+    let spectrum = yield cPicker.spectrum;
+    let onHidden = cPicker.tooltip.once("hidden");
+    EventUtils.sendKey("RETURN", spectrum.element.ownerDocument.defaultView);
+    yield onHidden;
+
+    is(getRuleViewPropertyValue(view, "#testid", "color"), color.result,
+       "changing the color preserved the unit for " + color.name);
+
+    yield removeTestContent(inspector, styleNode);
+  }
+}
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js
@@ -16,17 +16,17 @@ const TEST_URI = `
   </style>
   Testing the color picker tooltip!
 `;
 
 add_task(function*() {
   yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
   let {view} = yield openRuleView();
   let value = getRuleViewProperty(view, "body", "background").valueSpan;
-  let swatch = value.querySelectorAll(".ruleview-colorswatch")[1];
+  let swatch = value.querySelectorAll(".ruleview-colorswatch")[0];
   let url = value.querySelector(".theme-link");
   yield testImageTooltipAfterColorChange(swatch, url, view);
 });
 
 function* testImageTooltipAfterColorChange(swatch, url, ruleView) {
   info("First, verify that the image preview tooltip works");
   let anchor = yield isHoverTooltipTarget(ruleView.tooltips.previewTooltip,
                                           url);
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js
@@ -56,12 +56,12 @@ function* testColorChangeIsntRevertedWhe
   onShown = ruleView.tooltips.previewTooltip.once("shown");
   let anchor = yield isHoverTooltipTarget(ruleView.tooltips.previewTooltip,
                                           url);
   ruleView.tooltips.previewTooltip.show(anchor);
   yield onShown;
 
   info("Image tooltip is shown, verify that the swatch is still correct");
   swatch = value.querySelector(".ruleview-colorswatch");
-  is(swatch.style.backgroundColor, "rgb(0, 0, 0)",
+  is(swatch.style.backgroundColor, "black",
     "The swatch's color is correct");
-  is(swatch.nextSibling.textContent, "#000", "The color name is correct");
+  is(swatch.nextSibling.textContent, "black", "The color name is correct");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js
@@ -34,17 +34,17 @@ function testColorParsing(view) {
   let swatchEls = ruleEl.valueSpan.querySelectorAll(".ruleview-colorswatch");
   ok(swatchEls, "The color swatch elements were found");
   is(swatchEls.length, 3, "There are 3 color swatches");
 
   let colorEls = ruleEl.valueSpan.querySelectorAll(".ruleview-color");
   ok(colorEls, "The color elements were found");
   is(colorEls.length, 3, "There are 3 color values");
 
-  let colors = ["#F06", "#333", "#000"];
+  let colors = ["#f06", "#333", "#000"];
   for (let i = 0; i < colors.length; i++) {
     is(colorEls[i].textContent, colors[i], "The right color value was found");
   }
 }
 
 function* testPickingNewColor(view) {
   // Grab the first color swatch and color in the gradient
   let ruleEl = getRuleViewProperty(view, "body", "background-image");
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_copy_styles.js b/browser/devtools/styleinspector/test/browser_ruleview_copy_styles.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_copy_styles.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_copy_styles.js
@@ -98,16 +98,17 @@ add_task(function*() {
       desc: "Test Copy Rule",
       node: ruleEditor.rule.textProps[2].editor.nameSpan,
       menuItem: contextmenu.menuitemCopyRule,
       expectedPattern: "#testid {[\\r\\n]+" +
                        "\tcolor: #F00;[\\r\\n]+" +
                        "\tbackground-color: #00F;[\\r\\n]+" +
                        "\tfont-size: 12px;[\\r\\n]+" +
                        "\tborder-color: #00F !important;[\\r\\n]+" +
+                       "\t--var: \"\\*/\";[\\r\\n]+" +
                        "}",
       hidden: {
         copyLocation: true,
         copyPropertyDeclaration: false,
         copyPropertyName: false,
         copyPropertyValue: true,
         copySelector: true,
         copyRule: false
@@ -139,26 +140,50 @@ add_task(function*() {
         copyPropertyName: true,
         copyPropertyValue: true,
         copySelector: true,
         copyRule: false
       }
     },
     {
       setup: function*() {
-        yield disableProperty(view);
+        yield disableProperty(view, 0);
       },
       desc: "Test Copy Rule with Disabled Property",
       node: ruleEditor.rule.textProps[2].editor.nameSpan,
       menuItem: contextmenu.menuitemCopyRule,
       expectedPattern: "#testid {[\\r\\n]+" +
                        "\t\/\\* color: #F00; \\*\/[\\r\\n]+" +
                        "\tbackground-color: #00F;[\\r\\n]+" +
                        "\tfont-size: 12px;[\\r\\n]+" +
                        "\tborder-color: #00F !important;[\\r\\n]+" +
+                       "\t--var: \"\\*/\";[\\r\\n]+" +
+                       "}",
+      hidden: {
+        copyLocation: true,
+        copyPropertyDeclaration: false,
+        copyPropertyName: false,
+        copyPropertyValue: true,
+        copySelector: true,
+        copyRule: false
+      }
+    },
+    {
+      setup: function*() {
+        yield disableProperty(view, 4);
+      },
+      desc: "Test Copy Rule with Disabled Property with Comment",
+      node: ruleEditor.rule.textProps[2].editor.nameSpan,
+      menuItem: contextmenu.menuitemCopyRule,
+      expectedPattern: "#testid {[\\r\\n]+" +
+                       "\t\/\\* color: #F00; \\*\/[\\r\\n]+" +
+                       "\tbackground-color: #00F;[\\r\\n]+" +
+                       "\tfont-size: 12px;[\\r\\n]+" +
+                       "\tborder-color: #00F !important;[\\r\\n]+" +
+                       "\t/\\* --var: \"\\*\\\\\/\"; \\*\/[\\r\\n]+" +
                        "}",
       hidden: {
         copyLocation: true,
         copyPropertyDeclaration: false,
         copyPropertyName: false,
         copyPropertyValue: true,
         copySelector: true,
         copyRule: false
@@ -236,19 +261,19 @@ function* checkCopyStyle(view, node, men
       () => checkClipboardData(expectedPattern));
   } catch(e) {
     failedClipboard(expectedPattern);
   }
 
   view._contextmenu._menupopup.hidePopup();
 }
 
-function* disableProperty(view) {
+function* disableProperty(view, index) {
   let ruleEditor = getRuleViewRuleEditor(view, 1);
-  let propEditor = ruleEditor.rule.textProps[0].editor;
+  let propEditor = ruleEditor.rule.textProps[index].editor;
 
   info("Disabling a property");
   propEditor.enable.click();
   yield ruleEditor.rule._applyingModifications;
 }
 
 function checkClipboardData(expectedPattern) {
   let actual = SpecialPowers.getClipboardData("text/unicode");
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js b/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js
@@ -22,17 +22,17 @@ add_task(function*() {
   checkColorCycling(container, inspector);
 });
 
 function checkColorCycling(container, inspector) {
   let swatch = container.querySelector(".ruleview-colorswatch");
   let valueNode = container.querySelector(".ruleview-color");
   let win = inspector.sidebar.getWindowForTab("ruleview");
 
-  // Hex (default)
+  // Hex
   is(valueNode.textContent, "#F00", "Color displayed as a hex value.");
 
   // HSL
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "hsl(0, 100%, 50%)",
                             "Color displayed as an HSL value.");
 
@@ -43,20 +43,14 @@ function checkColorCycling(container, in
                             "Color displayed as an RGB value.");
 
   // Color name
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "red",
                             "Color displayed as a color name.");
 
-  // "Authored" (currently the computed value)
-  EventUtils.synthesizeMouseAtCenter(swatch,
-                                     {type: "mousedown", shiftKey: true}, win);
-  is(valueNode.textContent, "rgb(255, 0, 0)",
-                            "Color displayed as an RGB value.");
-
-  // Back to hex
+  // "Authored"
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "#F00",
-                            "Color displayed as hex again.");
+                            "Color displayed as an authored value.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js b/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_inherited-properties_01.js
@@ -33,13 +33,17 @@ function* simpleInherit(inspector, view)
   let elementRule = elementStyle.rules[0];
   ok(!elementRule.inherited,
     "Element style attribute should not consider itself inherited.");
 
   let inheritRule = elementStyle.rules[1];
   is(inheritRule.selectorText, "#test2",
     "Inherited rule should be the one that includes inheritable properties.");
   ok(!!inheritRule.inherited, "Rule should consider itself inherited.");
-  is(inheritRule.textProps.length, 1,
-    "Should only display one inherited style");
-  let inheritProp = inheritRule.textProps[0];
+  is(inheritRule.textProps.length, 2,
+    "Rule should have two styles");
+  let bgcProp = inheritRule.textProps[0];
+  is(bgcProp.name, "background-color",
+     "background-color property should exist");
+  ok(bgcProp.invisible, "background-color property should be invisible");
+  let inheritProp = inheritRule.textProps[1];
   is(inheritProp.name, "color", "color should have been inherited.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js b/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
@@ -19,12 +19,11 @@ add_task(function*() {
   let _strings = Services.strings
     .createBundle("chrome://global/locale/devtools/styleinspector.properties");
 
   let inline = _strings.GetStringFromName("rule.sourceInline");
 
   is(elementStyle.rules.length, 3, "Should have 3 rules.");
   is(elementStyle.rules[0].title, inline, "check rule 0 title");
   is(elementStyle.rules[1].title, inline +
-    ":15 @media screen and (min-width: 1px)", "check rule 1 title");
-  is(elementStyle.rules[2].title, inline + ":8", "check rule 2 title");
+    ":9 @media screen and (min-width: 1px)", "check rule 1 title");
+  is(elementStyle.rules[2].title, inline + ":2", "check rule 2 title");
 });
-
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
@@ -161,27 +161,27 @@ function* testParagraph(inspector, view)
     firstLetterRulesNb: 1,
     selectionRulesNb: 1
   });
 
   assertGutters(view);
 
   let elementFirstLineRule = rules.firstLineRules[0];
   is(convertTextPropsToString(elementFirstLineRule.textProps),
-     "background: blue none repeat scroll 0% 0%",
+     "background: blue",
      "Paragraph first-line properties are correct");
 
   let elementFirstLetterRule = rules.firstLetterRules[0];
   is(convertTextPropsToString(elementFirstLetterRule.textProps),
      "color: red; font-size: 130%",
      "Paragraph first-letter properties are correct");
 
   let elementSelectionRule = rules.selectionRules[0];
   is(convertTextPropsToString(elementSelectionRule.textProps),
-     "color: white; background: black none repeat scroll 0% 0%",
+     "color: white; background: black",
      "Paragraph first-letter properties are correct");
 }
 
 function* testBody(inspector, view) {
   yield testNode("body", inspector, view);
 
   let gutters = getGutters(view);
   is(gutters.length, 0, "There are no gutter headings");
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js b/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js
@@ -126,30 +126,28 @@ function* testPropertyChange6(inspector,
     "url(\"chrome://branding/content/about-logo.png\") repeat scroll 0% 0%",
     inspector);
 
   let rule = ruleView._elementStyle.rules[0];
   is(rule.editor.element.querySelectorAll(".ruleview-property").length, 5,
     "Added a property");
   validateTextProp(rule.textProps[4], true, "background",
                    "red url(\"chrome://branding/content/about-logo.png\") repeat scroll 0% 0%",
-                   "shortcut property correctly set",
-                   "#F00 url(\"chrome://branding/content/about-logo.png\") repeat scroll 0% 0%");
+                   "shortcut property correctly set");
 }
 
 function* changeElementStyle(testElement, style, inspector) {
   let onRefreshed = inspector.once("rule-view-refreshed");
   testElement.setAttribute("style", style);
   yield onRefreshed;
 }
 
-function validateTextProp(aProp, aEnabled, aName, aValue, aDesc,
-    valueSpanText) {
+function validateTextProp(aProp, aEnabled, aName, aValue, aDesc) {
   is(aProp.enabled, aEnabled, aDesc + ": enabled.");
   is(aProp.name, aName, aDesc + ": name.");
   is(aProp.value, aValue, aDesc + ": value.");
 
   is(aProp.editor.enable.hasAttribute("checked"), aEnabled,
     aDesc + ": enabled checkbox.");
   is(aProp.editor.nameSpan.textContent, aName, aDesc + ": name span.");
   is(aProp.editor.valueSpan.textContent,
-    valueSpanText || aValue, aDesc + ": value span.");
+    aValue, aDesc + ": value span.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js b/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles-uneditable.js
@@ -35,19 +35,21 @@ function* userAgentStylesUneditable(insp
 
   yield selectNode("a", inspector);
   let uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
 
   for (let rule of uaRules) {
     ok(rule.editor.element.hasAttribute("uneditable"),
       "UA rules have uneditable attribute");
 
-    ok(!rule.textProps[0].editor.nameSpan._editable,
+    let firstProp = rule.textProps.filter(p => !p.invisible)[0];
+
+    ok(!firstProp.editor.nameSpan._editable,
       "nameSpan is not editable");
-    ok(!rule.textProps[0].editor.valueSpan._editable,
+    ok(!firstProp.editor.valueSpan._editable,
       "valueSpan is not editable");
     ok(!rule.editor.closeBrace._editable, "closeBrace is not editable");
 
     let colorswatch = rule.editor.element
       .querySelector(".ruleview-colorswatch");
     if (colorswatch) {
       ok(!view.tooltips.colorPicker.swatches.has(colorswatch),
         "The swatch is not editable");
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js b/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js
--- a/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js
@@ -80,17 +80,17 @@ function testIsColorPopupOnNode(view, no
   info("Testing node " + node);
   view.styleDocument.popupNode = node;
   view._contextmenu._colorToCopy = "";
 
   let result = view._contextmenu._isColorPopup();
   let correct = isColorValueNode(node);
 
   is(result, correct, "_isColorPopup returned the expected value " + correct);
-  is(view._contextmenu._colorToCopy, (correct) ? "#123ABC" : "",
+  is(view._contextmenu._colorToCopy, (correct) ? "rgb(18, 58, 188)" : "",
      "_colorToCopy was set to the expected value");
 }
 
 /**
  * Check if a node is part of color value i.e. it has parent with a 'data-color'
  * attribute.
  */
 function isColorValueNode(node) {
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js b/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js
--- a/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js
@@ -11,17 +11,17 @@ const TEST_URI = `
   <div id="two" style="color:blue;">two</div>
 `;
 
 add_task(function*() {
   yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
   let {inspector, view} = yield openRuleView();
   yield selectNode("#one", inspector);
 
-  is(getRuleViewPropertyValue(view, "element", "color"), "#F00",
+  is(getRuleViewPropertyValue(view, "element", "color"), "red",
     "The rule-view shows the properties for test node one");
 
   let cView = inspector.sidebar.getWindowForTab("computedview")
     .computedview.view;
   let prop = getComputedViewProperty(cView, "color");
   ok(!prop, "The computed-view doesn't show the properties for test node one");
 
   info("Switching to the computed-view");
@@ -33,11 +33,11 @@ add_task(function*() {
     "The computed-view shows the properties for test node one");
 
   info("Selecting test node two");
   yield selectNode("#two", inspector);
 
   ok(getComputedViewPropertyValue(cView, "color"), "#00F",
     "The computed-view shows the properties for test node two");
 
-  is(getRuleViewPropertyValue(view, "element", "color"), "#F00",
+  is(getRuleViewPropertyValue(view, "element", "color"), "red",
     "The rule-view doesn't the properties for test node two");
 });
diff --git a/browser/devtools/styleinspector/test/doc_copystyles.css b/browser/devtools/styleinspector/test/doc_copystyles.css
--- a/browser/devtools/styleinspector/test/doc_copystyles.css
+++ b/browser/devtools/styleinspector/test/doc_copystyles.css
@@ -2,9 +2,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 html, body, #testid {
   color: #F00;
   background-color: #00F;
   font-size: 12px;
   border-color: #00F !important;
+  --var: "*/";
 }
diff --git a/browser/devtools/styleinspector/test/unit/.eslintrc b/browser/devtools/styleinspector/test/unit/.eslintrc
deleted file mode 100644
--- a/browser/devtools/styleinspector/test/unit/.eslintrc
+++ /dev/null
@@ -1,4 +0,0 @@
-{
-  // Extend from the common devtools xpcshell eslintrc config.
-  "extends": "../../../.eslintrc.xpcshell"
-}
\ No newline at end of file
diff --git a/browser/devtools/styleinspector/test/unit/test_parseDeclarations.js b/browser/devtools/styleinspector/test/unit/test_parseDeclarations.js
deleted file mode 100644
--- a/browser/devtools/styleinspector/test/unit/test_parseDeclarations.js
+++ /dev/null
@@ -1,282 +0,0 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-const Cu = Components.utils;
-const {require} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
-const {parseDeclarations} =
-  require("devtools/styleinspector/css-parsing-utils");
-
-const TEST_DATA = [
-  // Simple test
-  {
-    input: "p:v;",
-    expected: [{name: "p", value: "v", priority: ""}]
-  },
-  // Simple test
-  {
-    input: "this:is;a:test;",
-    expected: [
-      {name: "this", value: "is", priority: ""},
-      {name: "a", value: "test", priority: ""}
-    ]
-  },
-  // Test a single declaration with semi-colon
-  {
-    input: "name:value;",
-    expected: [{name: "name", value: "value", priority: ""}]
-  },
-  // Test a single declaration without semi-colon
-  {
-    input: "name:value",
-    expected: [{name: "name", value: "value", priority: ""}]
-  },
-  // Test multiple declarations separated by whitespaces and carriage
-  // returns and tabs
-  {
-    input: "p1 : v1 ; \t\t  \n p2:v2;   \n\n\n\n\t  p3    :   v3;",
-    expected: [
-      {name: "p1", value: "v1", priority: ""},
-      {name: "p2", value: "v2", priority: ""},
-      {name: "p3", value: "v3", priority: ""},
-    ]
-  },
-  // Test simple priority
-  {
-    input: "p1: v1; p2: v2 !important;",
-    expected: [
-      {name: "p1", value: "v1", priority: ""},
-      {name: "p2", value: "v2", priority: "important"}
-    ]
-  },
-  // Test simple priority
-  {
-    input: "p1: v1 !important; p2: v2",
-    expected: [
-      {name: "p1", value: "v1", priority: "important"},
-      {name: "p2", value: "v2", priority: ""}
-    ]
-  },
-  // Test simple priority
-  {
-    input: "p1: v1 !  important; p2: v2 ! important;",
-    expected: [
-      {name: "p1", value: "v1", priority: "important"},
-      {name: "p2", value: "v2", priority: "important"}
-    ]
-  },
-  // Test invalid priority
-  {
-    input: "p1: v1 important;",
-    expected: [
-      {name: "p1", value: "v1 important", priority: ""}
-    ]
-  },
-  // Test various types of background-image urls
-  {
-    input: "background-image: url(../../relative/image.png)",
-    expected: [{
-      name: "background-image",
-      value: "url(../../relative/image.png)",
-      priority: ""
-    }]
-  },
-  {
-    input: "background-image: url(http://site.com/test.png)",
-    expected: [{
-      name: "background-image",
-      value: "url(http://site.com/test.png)",
-      priority: ""
-    }]
-  },
-  {
-    input: "background-image: url(wow.gif)",
-    expected: [{
-      name: "background-image",
-      value: "url(wow.gif)",
-      priority: ""
-    }]
-  },
-  // Test that urls with :;{} characters in them are parsed correctly
-  {
-    input: "background: red url(\"http://site.com/image{}:;.png?id=4#wat\") "
-      + "repeat top right",
-    expected: [{
-      name: "background",
-      value: "red url(\"http://site.com/image{}:;.png?id=4#wat\") " +
-        "repeat top right",
-      priority: ""
-    }]
-  },
-  // Test that an empty string results in an empty array
-  {input: "", expected: []},
-  // Test that a string comprised only of whitespaces results in an empty array
-  {input: "       \n \n   \n   \n \t  \t\t\t  ", expected: []},
-  // Test that a null input throws an exception
-  {input: null, throws: true},
-  // Test that a undefined input throws an exception
-  {input: undefined, throws: true},
-  // Test that :;{} characters in quoted content are not parsed as multiple
-  // declarations
-  {
-    input: "content: \";color:red;}selector{color:yellow;\"",
-    expected: [{
-      name: "content",
-      value: "\";color:red;}selector{color:yellow;\"",
-      priority: ""
-    }]
-  },
-  // Test that rules aren't parsed, just declarations. So { and } found after a
-  // property name should be part of the property name, same for values.
-  {
-    input: "body {color:red;} p {color: blue;}",
-    expected: [
-      {name: "body {color", value: "red", priority: ""},
-      {name: "} p {color", value: "blue", priority: ""},
-      {name: "}", value: "", priority: ""}
-    ]
-  },
-  // Test unbalanced : and ;
-  {
-    input: "color :red : font : arial;",
-    expected: [
-      {name: "color", value: "red : font : arial", priority: ""}
-    ]
-  },
-  {
-    input: "background: red;;;;;",
-    expected: [{name: "background", value: "red", priority: ""}]
-  },
-  {
-    input: "background:;",
-    expected: [{name: "background", value: "", priority: ""}]
-  },
-  {input: ";;;;;", expected: []},
-  {input: ":;:;", expected: []},
-  // Test name only
-  {input: "color", expected: [
-    {name: "color", value: "", priority: ""}
-  ]},
-  // Test trailing name without :
-  {input: "color:blue;font", expected: [
-    {name: "color", value: "blue", priority: ""},
-    {name: "font", value: "", priority: ""}
-  ]},
-  // Test trailing name with :
-  {input: "color:blue;font:", expected: [
-    {name: "color", value: "blue", priority: ""},
-    {name: "font", value: "", priority: ""}
-  ]},
-  // Test leading value
-  {input: "Arial;color:blue;", expected: [
-    {name: "", value: "Arial", priority: ""},
-    {name: "color", value: "blue", priority: ""}
-  ]},
-  // Test hex colors
-  {
-    input: "color: #333",
-    expected: [{name: "color", value: "#333", priority: ""}]
-  },
-  {
-    input: "color: #456789",
-    expected: [{name: "color", value: "#456789", priority: ""}]
-  },
-  {
-    input: "wat: #XYZ",
-    expected: [{name: "wat", value: "#XYZ", priority: ""}]
-  },
-  // Test string/url quotes escaping
-  {
-    input: "content: \"this is a 'string'\"",
-    expected: [{name: "content", value: "\"this is a 'string'\"", priority: ""}]
-  },
-  {
-    input: 'content: "this is a \\"string\\""',
-    expected: [{
-      name: "content",
-      value: '"this is a \\"string\\""',
-      priority: ""}]
-  },
-  {
-    input: "content: 'this is a \"string\"'",
-    expected: [{
-      name: "content",
-      value: '\'this is a "string"\'',
-      priority: ""
-    }]
-  },
-  {
-    input: "content: 'this is a \\'string\\''",
-    expected: [{
-      name: "content",
-      value: "'this is a \\'string\\''",
-      priority: ""
-    }]
-  },
-  {
-    input: "content: 'this \\' is a \" really strange string'",
-    expected: [{
-      name: "content",
-      value: "'this \\' is a \" really strange string'",
-      priority: ""
-    }]
-  },
-  {
-    input: "content: \"a not s\\\
-          o very long title\"",
-    expected: [
-      {name: "content", value: '"a not s\\\
-          o very long title"', priority: ""}
-    ]
-  },
-  // Test calc with nested parentheses
-  {
-    input: "width: calc((100% - 3em) / 2)",
-    expected: [{name: "width", value: "calc((100% - 3em) / 2)", priority: ""}]
-  },
-];
-
-function run_test() {
-  for (let test of TEST_DATA) {
-    do_print("Test input string " + test.input);
-    let output;
-    try {
-      output = parseDeclarations(test.input);
-    } catch (e) {
-      do_print("parseDeclarations threw an exception with the given input " +
-        "string");
-      if (test.throws) {
-        do_print("Exception expected");
-        do_check_true(true);
-      } else {
-        do_print("Exception unexpected\n" + e);
-        do_check_true(false);
-      }
-    }
-    if (output) {
-      assertOutput(output, test.expected);
-    }
-  }
-}
-
-function assertOutput(actual, expected) {
-  if (actual.length === expected.length) {
-    for (let i = 0; i < expected.length; i++) {
-      do_check_true(!!actual[i]);
-      do_print("Check that the output item has the expected name, " +
-        "value and priority");
-      do_check_eq(expected[i].name, actual[i].name);
-      do_check_eq(expected[i].value, actual[i].value);
-      do_check_eq(expected[i].priority, actual[i].priority);
-    }
-  } else {
-    for (let prop of actual) {
-      do_print("Actual output contained: {name: " + prop.name + ", value: " +
-        prop.value + ", priority: " + prop.priority + "}");
-    }
-    do_check_eq(actual.length, expected.length);
-  }
-}
diff --git a/browser/devtools/styleinspector/test/unit/xpcshell.ini b/browser/devtools/styleinspector/test/unit/xpcshell.ini
deleted file mode 100644
--- a/browser/devtools/styleinspector/test/unit/xpcshell.ini
+++ /dev/null
@@ -1,10 +0,0 @@
-[DEFAULT]
-tags = devtools
-head =
-tail =
-firefox-appdir = browser
-skip-if = toolkit == 'android' || toolkit == 'gonk'
-
-[test_parseDeclarations.js]
-[test_parsePseudoClassesAndAttributes.js]
-[test_parseSingleValue.js]
diff --git a/browser/devtools/styleinspector/utils.js b/browser/devtools/styleinspector/utils.js
--- a/browser/devtools/styleinspector/utils.js
+++ b/browser/devtools/styleinspector/utils.js
@@ -7,17 +7,17 @@
 /* global domUtils */
 
 "use strict";
 
 const {Cc, Ci, Cu} = require("chrome");
 const {setTimeout, clearTimeout} =
       Cu.import("resource://gre/modules/Timer.jsm", {});
 const {parseDeclarations} =
-      require("devtools/styleinspector/css-parsing-utils");
+      require("devtools/shared/css-parsing-utils");
 const promise = require("promise");
 
 loader.lazyServiceGetter(this, "domUtils",
   "@mozilla.org/inspector/dom-utils;1", "inIDOMUtils");
 
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 
 /**
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
@@ -64,16 +64,20 @@ values from browser.dtd.  -->
   -  This label is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.label "Default color unit">
 
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.accesskey): This is the access
   -  key for a dropdown list that controls the default color unit used in the
   -  inspector. This is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.accesskey "U">
 
+<!-- LOCALIZATION NOTE (options.defaultColorUnit.authored): This is used in the
+  -  'Default color unit' dropdown list and is visible in the options panel. -->
+<!ENTITY options.defaultColorUnit.authored "As Authored">
+
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.hex): This is used in the
   -  'Default color unit' dropdown list and is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.hex "Hex">
 
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.hsl): This is used in the
   -  'Default color unit' dropdown list and is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.hsl "HSL(A)">
 
diff --git a/dom/webidl/CSSLexer.webidl b/dom/webidl/CSSLexer.webidl
--- a/dom/webidl/CSSLexer.webidl
+++ b/dom/webidl/CSSLexer.webidl
@@ -121,12 +121,41 @@ interface CSSLexer
 
   /**
    * The column number of the most recently returned token.  Column
    * numbers are 0-based.
    */
   readonly attribute unsigned long columnNumber;
 
   /**
+   * When EOF is reached, this will be true if the final character was
+   * a stray backslash, and false otherwise.
+   *
+   * The "real" CSS lexer treats a trailing backslash differently
+   * depending on whether or not it is in a string context.  Inside of
+   * a string, a trailing backslash is dropped.  Outside of a string,
+   * a trailing backslash is replaced by U+FFFD.  A program wanting to
+   * emulate this can examine impliedEOFCharacters to see whether it
+   * contains either of the quote characters; the presence of quote
+   * characters indicates that the dropped backslash occurred in a
+   * string context.
+   */
+  readonly attribute boolean droppedTrailingBackslash;
+
+  /**
+   * When EOF is reached, the last token might be unterminated in some
+   * ways.  This attribute holds a string containing the relevant
+   * terminators.  In particular:
+   * 1. If EOF occurs mid-string, this will hold the correct quote.
+   * 2. If EOF occurs in a url token, this will hold the close paren.
+   * 3. If EOF occurs in a comment this will hold the comment closer.
+   *
+   * Note that a trailing backslash might also have been present in
+   * the input string, but is not accounted for here;
+   * @see droppedTrailingBackslash.
+   */
+  readonly attribute DOMString impliedEOFCharacters;
+
+  /**
    * Return the next token, or null at EOF.
    */
   CSSToken? nextToken();
 };
diff --git a/layout/inspector/inDOMUtils.cpp b/layout/inspector/inDOMUtils.cpp
--- a/layout/inspector/inDOMUtils.cpp
+++ b/layout/inspector/inDOMUtils.cpp
@@ -1254,17 +1254,17 @@ inDOMUtils::ClearPseudoClassLocks(nsIDOM
 
 NS_IMETHODIMP
 inDOMUtils::ParseStyleSheet(nsIDOMCSSStyleSheet *aSheet,
                             const nsAString& aInput)
 {
   nsRefPtr<CSSStyleSheet> sheet = do_QueryObject(aSheet);
   NS_ENSURE_ARG_POINTER(sheet);
 
-  return sheet->ParseSheet(aInput);
+  return sheet->ParseSheet(aInput, CSSStyleSheet::PRESERVE_IMPORTED_SHEETS);
 }
 
 NS_IMETHODIMP
 inDOMUtils::ScrollElementIntoView(nsIDOMElement *aElement)
 {
   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
   NS_ENSURE_ARG_POINTER(content);
 
diff --git a/layout/inspector/tests/bug1202095.css b/layout/inspector/tests/bug1202095.css
new file mode 100644
--- /dev/null
+++ b/layout/inspector/tests/bug1202095.css
@@ -0,0 +1,7 @@
+/*
+ * Bug 1202095 - parseStyleSheet should not re-load @imports
+ */
+
+body {
+  background-color: purple;
+}
diff --git a/layout/inspector/tests/mochitest.ini b/layout/inspector/tests/mochitest.ini
--- a/layout/inspector/tests/mochitest.ini
+++ b/layout/inspector/tests/mochitest.ini
@@ -1,10 +1,11 @@
 [DEFAULT]
 support-files = 
+  bug1202095.css
   bug856317.css
   file_bug522601.html
 
 [test_bug462787.html]
 [test_bug462789.html]
 [test_bug522601.xhtml]
 [test_bug536379.html]
 [test_bug536379-2.html]
@@ -17,9 +18,10 @@ support-files =
 [test_color_to_rgba.html]
 [test_css_property_is_shorthand.html]
 [test_css_property_is_valid.html]
 [test_getRelativeRuleLine.html]
 [test_get_all_style_sheets.html]
 [test_is_valid_css_color.html]
 [test_isinheritableproperty.html]
 [test_parseStyleSheet.html]
+[test_parseStyleSheetImport.html]
 [test_selectormatcheselement.html]
diff --git a/layout/inspector/tests/test_parseStyleSheetImport.html b/layout/inspector/tests/test_parseStyleSheetImport.html
new file mode 100644
--- /dev/null
+++ b/layout/inspector/tests/test_parseStyleSheetImport.html
@@ -0,0 +1,55 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+    https://bugzilla.mozilla.org/show_bug.cgi?id=1202095
+-->
+  <head>
+    <title>Test for Bug 1202095</title>
+    <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+    <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+    <style>
+      @import url('bug1202095.css');
+    </style>
+  </head>
+  <body>
+    <script type="application/javascript">
+var domUtils = SpecialPowers.Cc["@mozilla.org/inspector/dom-utils;1"]
+               .getService(SpecialPowers.Ci.inIDOMUtils);
+
+function do_test() {
+  var sheet = document.styleSheets[1];
+  var importRule = sheet.cssRules[0];
+  is(importRule.type, SpecialPowers.Ci.nsIDOMCSSRule.IMPORT_RULE,
+     "initial sheet has @import rule");
+
+  var importedSheet = importRule.styleSheet;
+  importedSheet.deleteRule(0);
+  is(importedSheet.cssRules.length, 0, "imported sheet now has no rules");
+
+  // Re-parse the style sheet, preserving the import.
+  domUtils.parseStyleSheet(sheet, "@import url('bug1202095.css');");
+  is(sheet.cssRules[0].type, SpecialPowers.Ci.nsIDOMCSSRule.IMPORT_RULE,
+     "re-parsed sheet has @import rule");
+  is(sheet.cssRules[0].styleSheet, importedSheet,
+     "imported sheet has not changed");
+
+  // Re-parse the style sheet, removing the import.
+  domUtils.parseStyleSheet(sheet, "");
+  is(sheet.cssRules.length, 0, "style sheet now has no rules");
+
+  // Re-parse the style sheet, adding the import back.  This should
+  // not allow reuse.
+  domUtils.parseStyleSheet(sheet, "@import url('bug1202095.css');");
+  is(sheet.cssRules[0].type, SpecialPowers.Ci.nsIDOMCSSRule.IMPORT_RULE,
+     "re-re-re-parsed sheet has @import rule");
+  isnot(sheet.cssRules[0].styleSheet, importedSheet,
+     "imported sheet has changed now");
+
+  SimpleTest.finish();
+}
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(do_test);
+    </script>
+  </body>
+</html>
diff --git a/layout/style/CSSLexer.cpp b/layout/style/CSSLexer.cpp
--- a/layout/style/CSSLexer.cpp
+++ b/layout/style/CSSLexer.cpp
@@ -68,16 +68,37 @@ CSSLexer::LineNumber()
 }
 
 uint32_t
 CSSLexer::ColumnNumber()
 {
   return mScanner.GetColumnNumber();
 }
 
+bool
+CSSLexer::DroppedTrailingBackslash()
+{
+  uint32_t eofChars = mScanner.GetEOFCharacters();
+  return (eofChars & (nsCSSScanner::eEOFCharacters_ReplacementChar
+                      | nsCSSScanner::eEOFCharacters_DropBackslash)) != 0;
+}
+
+void
+CSSLexer::GetImpliedEOFCharacters(nsString& aResult)
+{
+  uint32_t eofChars = mScanner.GetEOFCharacters();
+
+  // Don't include a replacement character here, as callers are
+  // expected to handle this using trailingBackslash.
+  eofChars &= ~nsCSSScanner::eEOFCharacters_ReplacementChar;
+
+  nsCSSScanner::AppendImpliedEOFCharacters(nsCSSScanner::EOFCharacters(eofChars),
+                                           aResult);
+}
+
 void
 CSSLexer::NextToken(Nullable<CSSToken>& aResult)
 {
   nsCSSToken token;
   if (!mScanner.Next(token, eCSSScannerExclude_None)) {
     return;
   }
 
diff --git a/layout/style/CSSLexer.h b/layout/style/CSSLexer.h
--- a/layout/style/CSSLexer.h
+++ b/layout/style/CSSLexer.h
@@ -19,16 +19,18 @@ public:
   explicit CSSLexer(const nsAString&);
   ~CSSLexer();
 
   bool WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto,
                   JS::MutableHandle<JSObject*> aReflector);
 
   uint32_t LineNumber();
   uint32_t ColumnNumber();
+  bool DroppedTrailingBackslash();
+  void GetImpliedEOFCharacters(nsString& aResult);
   void NextToken(Nullable<CSSToken>& aResult);
 
 private:
   nsString mInput;
   nsCSSScanner mScanner;
 };
 
 } // namespace dom
diff --git a/layout/style/CSSStyleSheet.cpp b/layout/style/CSSStyleSheet.cpp
--- a/layout/style/CSSStyleSheet.cpp
+++ b/layout/style/CSSStyleSheet.cpp
@@ -2263,17 +2263,18 @@ CSSStyleSheet::StyleSheetLoaded(CSSStyle
     // they do)!
     mDocument->StyleRuleAdded(this, aSheet->GetOwnerRule());
   }
 
   return NS_OK;
 }
 
 nsresult
-CSSStyleSheet::ParseSheet(const nsAString& aInput)
+CSSStyleSheet::ParseSheet(const nsAString& aInput,
+                          ImportParseHandling aImportHandling)
 {
   // Not doing this if the sheet is not complete!
   if (!mInner->mComplete) {
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   // Hold strong ref to the CSSLoader in case the document update
   // kills the document
@@ -2285,21 +2286,35 @@ CSSStyleSheet::ParseSheet(const nsAStrin
     loader = new css::Loader();
   }
 
   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, true);
 
   WillDirty();
 
   // detach existing rules (including child sheets via import rules)
+  css::LoaderReusableStyleSheets reusableSheets;
   int ruleCount;
   while ((ruleCount = mInner->mOrderedRules.Count()) != 0) {
     nsRefPtr<css::Rule> rule = mInner->mOrderedRules.ObjectAt(ruleCount - 1);
     mInner->mOrderedRules.RemoveObjectAt(ruleCount - 1);
     rule->SetStyleSheet(nullptr);
+    if (aImportHandling == PRESERVE_IMPORTED_SHEETS &&
+        rule->GetType() == css::Rule::IMPORT_RULE) {
+      nsCOMPtr<nsIDOMCSSImportRule> importRule(do_QueryInterface(rule));
+      NS_ASSERTION(importRule, "GetType lied");
+
+      nsCOMPtr<nsIDOMCSSStyleSheet> childSheet;
+      importRule->GetStyleSheet(getter_AddRefs(childSheet));
+
+      nsRefPtr<CSSStyleSheet> cssSheet = do_QueryObject(childSheet);
+      if (cssSheet) {
+        reusableSheets.AddReusableSheet(cssSheet);
+      }
+    }
     if (mDocument) {
       mDocument->StyleRuleRemoved(this, rule);
     }
   }
 
   // nuke child sheets list and current namespace map
   for (CSSStyleSheet* child = mInner->mFirstChild; child; child = child->mNext) {
     NS_ASSERTION(child->mParent == this, "Child sheet is not parented to this!");
@@ -2318,17 +2333,17 @@ CSSStyleSheet::ParseSheet(const nsAStrin
     if (link) {
       lineNumber = link->GetLineNumber();
     }
   }
 
   nsCSSParser parser(loader, this);
   nsresult rv = parser.ParseSheet(aInput, mInner->mSheetURI, mInner->mBaseURI,
                                   mInner->mPrincipal, lineNumber,
-                                  allowUnsafeRules);
+                                  allowUnsafeRules, &reusableSheets);
   DidDirty(); // we are always 'dirty' here since we always remove rules first
   NS_ENSURE_SUCCESS(rv, rv);
 
   // notify document of all new rules
   if (mDocument) {
     for (int32_t index = 0; index < mInner->mOrderedRules.Count(); ++index) {
       nsRefPtr<css::Rule> rule = mInner->mOrderedRules.ObjectAt(index);
       if (rule->GetType() == css::Rule::IMPORT_RULE &&
diff --git a/layout/style/CSSStyleSheet.h b/layout/style/CSSStyleSheet.h
--- a/layout/style/CSSStyleSheet.h
+++ b/layout/style/CSSStyleSheet.h
@@ -119,16 +119,26 @@ private:
 
 
 class CSSStyleSheet final : public nsIStyleSheet,
                             public nsIDOMCSSStyleSheet,
                             public nsICSSLoaderObserver,
                             public nsWrapperCache
 {
 public:
+  // This is used to specify how @import should be handled when
+  // re-parsing a style sheet.
+  enum ImportParseHandling {
+    // Discard any imported style sheets and re-load them.
+    READ_IMPORTED_SHEETS,
+    // Hold on to existing imported sheets and attempt to reuse them
+    // to satisfy @import requests.
+    PRESERVE_IMPORTED_SHEETS
+  };
+
   typedef net::ReferrerPolicy ReferrerPolicy;
   CSSStyleSheet(CORSMode aCORSMode, ReferrerPolicy aReferrerPolicy);
   CSSStyleSheet(CORSMode aCORSMode, ReferrerPolicy aReferrerPolicy,
                 const dom::SRIMetadata& aIntegrity);
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(CSSStyleSheet,
                                                          nsIStyleSheet)
@@ -237,17 +247,18 @@ public:
   void EnsureUniqueInner();
 
   // Append all of this sheet's child sheets to aArray.
   void AppendAllChildSheets(nsTArray<CSSStyleSheet*>& aArray);
 
   bool UseForPresentation(nsPresContext* aPresContext,
                             nsMediaQueryResultCacheKey& aKey) const;
 
-  nsresult ParseSheet(const nsAString& aInput);
+  nsresult ParseSheet(const nsAString& aInput,
+                      ImportParseHandling aImportHandling = READ_IMPORTED_SHEETS);
 
   void SetInRuleProcessorCache() { mInRuleProcessorCache = true; }
 
   // nsIDOMStyleSheet interface
   NS_DECL_NSIDOMSTYLESHEET
 
   // nsIDOMCSSStyleSheet interface
   NS_DECL_NSIDOMCSSSTYLESHEET
diff --git a/layout/style/Loader.cpp b/layout/style/Loader.cpp
--- a/layout/style/Loader.cpp
+++ b/layout/style/Loader.cpp
@@ -502,16 +502,36 @@ SheetLoadData::ScheduleLoadEventIfNeeded
   if (NS_SUCCEEDED(internalThread->AddObserver(this))) {
     // Make sure to block onload here
     if (mLoader->mDocument) {
       mLoader->mDocument->BlockOnload();
     }
   }
 }
 
+/*********************
+ * Style sheet reuse *
+ *********************/
+
+bool
+LoaderReusableStyleSheets::FindReusableStyleSheet(nsIURI* aURL,
+                                                  nsRefPtr<CSSStyleSheet>& aResult)
+{
+  for (size_t i = 0; i < mReusableSheets.Length(); ++i) {
+    bool sameURI;
+    nsresult rv = aURL->Equals(mReusableSheets[i]->GetOriginalURI(), &sameURI);
+    if (!NS_FAILED(rv) && sameURI) {
+      aResult = mReusableSheets[i];
+      mReusableSheets.RemoveElementAt(i);
+      return true;
+    }
+  }
+  return false;
+}
+
 /*************************
  * Loader Implementation *
  *************************/
 
 Loader::Loader(void)
   : mDocument(nullptr)
   , mDatasToNotifyOn(0)
   , mCompatMode(eCompatibility_FullStandards)
@@ -2136,17 +2156,18 @@ HaveAncestorDataWithURI(SheetLoadData *a
 
   return false;
 }
 
 nsresult
 Loader::LoadChildSheet(CSSStyleSheet* aParentSheet,
                        nsIURI* aURL,
                        nsMediaList* aMedia,
-                       ImportRule* aParentRule)
+                       ImportRule* aParentRule,
+                       LoaderReusableStyleSheets* aReusableSheets)
 {
   LOG(("css::Loader::LoadChildSheet"));
   NS_PRECONDITION(aURL, "Must have a URI to load");
   NS_PRECONDITION(aParentSheet, "Must have a parent sheet");
 
   if (!mEnabled) {
     LOG_WARN(("  Not enabled"));
     return NS_ERROR_NOT_AVAILABLE;
@@ -2205,28 +2226,33 @@ Loader::LoadChildSheet(CSSStyleSheet* aP
     // No parent load data, so the sheet will need to be notified when
     // we finish, if it can be, if we do the load asynchronously.
     observer = aParentSheet;
   }
 
   // Now that we know it's safe to load this (passes security check and not a
   // loop) do so.
   nsRefPtr<CSSStyleSheet> sheet;
-  bool isAlternate;
   StyleSheetState state;
-  const nsSubstring& empty = EmptyString();
-  // For now, use CORS_NONE for child sheets
-  rv = CreateSheet(aURL, nullptr, principal, CORS_NONE,
-                   aParentSheet->GetReferrerPolicy(),
-                   EmptyString(), // integrity is only checked on main sheet
-                   parentData ? parentData->mSyncLoad : false,
-                   false, empty, state, &isAlternate, getter_AddRefs(sheet));
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (aReusableSheets && aReusableSheets->FindReusableStyleSheet(aURL, sheet)) {
+    aParentRule->SetSheet(sheet);
+    state = eSheetComplete;
+  } else {
+    bool isAlternate;
+    const nsSubstring& empty = EmptyString();
+    // For now, use CORS_NONE for child sheets
+    rv = CreateSheet(aURL, nullptr, principal, CORS_NONE,
+                     aParentSheet->GetReferrerPolicy(),
+                     EmptyString(), // integrity is only checked on main sheet
+                     parentData ? parentData->mSyncLoad : false,
+                     false, empty, state, &isAlternate, getter_AddRefs(sheet));
+    NS_ENSURE_SUCCESS(rv, rv);
 
-  PrepareSheet(sheet, empty, empty, aMedia, nullptr, isAlternate);
+    PrepareSheet(sheet, empty, empty, aMedia, nullptr, isAlternate);
+  }
 
   rv = InsertChildSheet(sheet, aParentSheet, aParentRule);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (state == eSheetComplete) {
     LOG(("  Sheet already complete"));
     // We're completely done.  No need to notify, even, since the
     // @import rule addition/modification will trigger the right style
diff --git a/layout/style/Loader.h b/layout/style/Loader.h
--- a/layout/style/Loader.h
+++ b/layout/style/Loader.h
@@ -15,27 +15,27 @@
 #include "nsDataHashtable.h"
 #include "nsRefPtrHashtable.h"
 #include "nsStringFwd.h"
 #include "nsTArray.h"
 #include "nsTObserverArray.h"
 #include "nsURIHashKey.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/CORSMode.h"
+#include "mozilla/CSSStyleSheet.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/net/ReferrerPolicy.h"
 
 class nsICSSLoaderObserver;
 class nsIContent;
 class nsIDocument;
 class nsMediaList;
 class nsIStyleSheetLinkingElement;
 
 namespace mozilla {
-class CSSStyleSheet;
 namespace dom {
 class Element;
 } // namespace dom
 } // namespace mozilla
 
 namespace mozilla {
 
 class URIPrincipalReferrerPolicyAndCORSModeHashKey : public nsURIHashKey
@@ -126,16 +126,60 @@ protected:
 
 
 
 namespace css {
 
 class SheetLoadData;
 class ImportRule;
 
+/*********************
+ * Style sheet reuse *
+ *********************/
+
+class MOZ_STACK_CLASS LoaderReusableStyleSheets
+{
+public:
+  LoaderReusableStyleSheets()
+  {
+  }
+
+  ~LoaderReusableStyleSheets()
+  {
+  }
+
+  /**
+   * Look for a reusable sheet (see AddReusableSheet) matching the
+   * given URL.  If found, set aResult, remove the reused sheet from
+   * the internal list, and return true.  Otherwise, return false.
+   *
+   * @param aURL the url to match
+   * @param aResult [out] the style sheet which can be reused
+   */
+  bool FindReusableStyleSheet(nsIURI* aURL, nsRefPtr<CSSStyleSheet>& aResult);
+
+  /**
+   * Indicate that a certain style sheet is available for reuse if its
+   * URI matches the URI of an @import.  Sheets should be added in the
+   * opposite order in which they are intended to be reused.
+   *
+   * @param aSheet the sheet which can be reused
+   */
+  void AddReusableSheet(CSSStyleSheet* aSheet) {
+    mReusableSheets.InsertElementAt(0, aSheet);
+  }
+
+private:
+  LoaderReusableStyleSheets(const LoaderReusableStyleSheets&) = delete;
+  LoaderReusableStyleSheets& operator=(const LoaderReusableStyleSheets&) = delete;
+
+  // The sheets that can be reused.
+  nsTArray<nsRefPtr<CSSStyleSheet>> mReusableSheets;
+};
+
 /***********************************************************************
  * Enum that describes the state of the sheet returned by CreateSheet. *
  ***********************************************************************/
 enum StyleSheetState {
   eSheetStateUnknown = 0,
   eSheetNeedsParser,
   eSheetPending,
   eSheetLoading,
@@ -237,21 +281,24 @@ public:
    * child sheet is already complete when this method returns, no
    * nsICSSLoaderObserver notification will be sent.
    *
    * @param aParentSheet the parent of this child sheet
    * @param aURL the URL of the child sheet
    * @param aMedia the already-parsed media list for the child sheet
    * @param aRule the @import rule importing this child.  This is used to
    *              properly order the child sheet list of aParentSheet.
+   * @param aSavedSheets any saved style sheets which could be reused
+   *              for this load
    */
   nsresult LoadChildSheet(CSSStyleSheet* aParentSheet,
                           nsIURI* aURL,
                           nsMediaList* aMedia,
-                          ImportRule* aRule);
+                          ImportRule* aRule,
+                          LoaderReusableStyleSheets* aSavedSheets);
 
   /**
    * Synchronously load and return the stylesheet at aURL.  Any child sheets
    * will also be loaded synchronously.  Note that synchronous loads over some
    * protocols may involve spinning up a new event loop, so use of this method
    * does NOT guarantee not receiving any events before the sheet loads.  This
    * method can be used to load sheets not associated with a document.
    *
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -124,17 +124,18 @@ public:
   // Clears everything set by the above Set*() functions.
   void Reset();
 
   nsresult ParseSheet(const nsAString& aInput,
                       nsIURI*          aSheetURI,
                       nsIURI*          aBaseURI,
                       nsIPrincipal*    aSheetPrincipal,
                       uint32_t         aLineNumber,
-                      bool             aAllowUnsafeRules);
+                      bool             aAllowUnsafeRules,
+                      LoaderReusableStyleSheets* aReusableSheets);
 
   nsresult ParseStyleAttribute(const nsAString&  aAttributeValue,
                                nsIURI*           aDocURL,
                                nsIURI*           aBaseURL,
                                nsIPrincipal*     aNodePrincipal,
                                css::StyleRule**  aResult);
 
   nsresult ParseDeclarations(const nsAString&  aBuffer,
@@ -1169,16 +1170,19 @@ protected:
   nsCOMPtr<nsIPrincipal> mSheetPrincipal;
 
   // The sheet we're parsing into
   nsRefPtr<CSSStyleSheet> mSheet;
 
   // Used for @import rules
   mozilla::css::Loader* mChildLoader; // not ref counted, it owns us
 
+  // Any sheets we may reuse when parsing an @import.
+  LoaderReusableStyleSheets* mReusableSheets;
+
   // Sheet section we're in.  This is used to enforce correct ordering of the
   // various rule types (eg the fact that a @charset rule must come before
   // anything else).  Note that there are checks of similar things in various
   // places in CSSStyleSheet.cpp (e.g in insertRule, RebuildChildList).
   enum nsCSSSection {
     eCSSSection_Charset,
     eCSSSection_Import,
     eCSSSection_NameSpace,
@@ -1426,17 +1430,18 @@ CSSParserImpl::ReleaseScanner()
 }
 
 nsresult
 CSSParserImpl::ParseSheet(const nsAString& aInput,
                           nsIURI*          aSheetURI,
                           nsIURI*          aBaseURI,
                           nsIPrincipal*    aSheetPrincipal,
                           uint32_t         aLineNumber,
-                          bool             aAllowUnsafeRules)
+                          bool             aAllowUnsafeRules,
+                          LoaderReusableStyleSheets* aReusableSheets)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   NS_PRECONDITION(aBaseURI, "need base URI");
   NS_PRECONDITION(aSheetURI, "need sheet URI");
   NS_PRECONDITION(mSheet, "Must have sheet to parse into");
   NS_ENSURE_STATE(mSheet);
 
 #ifdef DEBUG
@@ -1472,16 +1477,17 @@ CSSParserImpl::ParseSheet(const nsAStrin
       }
     }
   }
   else {
     mSection = eCSSSection_Charset; // sheet is empty, any rules are fair
   }
 
   mUnsafeRulesEnabled = aAllowUnsafeRules;
+  mReusableSheets = aReusableSheets;
 
   nsCSSToken* tk = &mToken;
   for (;;) {
     // Get next non-whitespace token
     if (!GetToken(true)) {
       OUTPUT_ERROR();
       break;
     }
@@ -1495,16 +1501,17 @@ CSSParserImpl::ParseSheet(const nsAStrin
     UngetToken();
     if (ParseRuleSet(AppendRuleToSheet, this)) {
       mSection = eCSSSection_General;
     }
   }
   ReleaseScanner();
 
   mUnsafeRulesEnabled = false;
+  mReusableSheets = nullptr;
 
   // XXX check for low level errors
   return NS_OK;
 }
 
 /**
  * Determines whether the identifier contained in the given string is a
  * vendor-specific identifier, as described in CSS 2.1 section 4.1.2.1.
@@ -3435,17 +3442,17 @@ CSSParserImpl::ProcessImport(const nsStr
       // import url is bad
       REPORT_UNEXPECTED_P(PEImportBadURI, aURLSpec);
       OUTPUT_ERROR();
     }
     return;
   }
 
   if (mChildLoader) {
-    mChildLoader->LoadChildSheet(mSheet, url, aMedia, rule);
+    mChildLoader->LoadChildSheet(mSheet, url, aMedia, rule, mReusableSheets);
   }
 }
 
 // Parse the {} part of an @media or @-moz-document rule.
 bool
 CSSParserImpl::ParseGroupRule(css::GroupRule* aRule,
                               RuleAppendFunc aAppendFunc,
                               void* aData)
@@ -15780,21 +15787,22 @@ nsCSSParser::SetChildLoader(mozilla::css
 }
 
 nsresult
 nsCSSParser::ParseSheet(const nsAString& aInput,
                         nsIURI*          aSheetURI,
                         nsIURI*          aBaseURI,
                         nsIPrincipal*    aSheetPrincipal,
                         uint32_t         aLineNumber,
-                        bool             aAllowUnsafeRules)
+                        bool             aAllowUnsafeRules,
+                        LoaderReusableStyleSheets* aReusableSheets)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseSheet(aInput, aSheetURI, aBaseURI, aSheetPrincipal, aLineNumber,
-               aAllowUnsafeRules);
+               aAllowUnsafeRules, aReusableSheets);
 }
 
 nsresult
 nsCSSParser::ParseStyleAttribute(const nsAString&  aAttributeValue,
                                  nsIURI*           aDocURI,
                                  nsIURI*           aBaseURI,
                                  nsIPrincipal*     aNodePrincipal,
                                  css::StyleRule**  aResult)
diff --git a/layout/style/nsCSSParser.h b/layout/style/nsCSSParser.h
--- a/layout/style/nsCSSParser.h
+++ b/layout/style/nsCSSParser.h
@@ -28,16 +28,17 @@ struct nsRuleData;
 
 namespace mozilla {
 class CSSStyleSheet;
 class CSSVariableValues;
 namespace css {
 class Rule;
 class Declaration;
 class Loader;
+class LoaderReusableStyleSheets;
 class StyleRule;
 } // namespace css
 } // namespace mozilla
 
 // Interface to the css parser.
 
 class MOZ_STACK_CLASS nsCSSParser {
 public:
@@ -74,23 +75,26 @@ public:
    *                  This must match the URI of the sheet passed to
    *                  SetStyleSheet.
    * @param aBaseURI the URI to use for relative URI resolution
    * @param aSheetPrincipal the principal of the stylesheet.  This must match
    *                        the principal of the sheet passed to SetStyleSheet.
    * @param aLineNumber the line number of the first line of the sheet.
    * @param aAllowUnsafeRules see aEnableUnsafeRules in
    *                          mozilla::css::Loader::LoadSheetSync
+   * @param aReusableSheets style sheets that can be reused by an @import.
+   *                        This can be nullptr.
    */
   nsresult ParseSheet(const nsAString& aInput,
                       nsIURI*          aSheetURL,
                       nsIURI*          aBaseURI,
                       nsIPrincipal*    aSheetPrincipal,
                       uint32_t         aLineNumber,
-                      bool             aAllowUnsafeRules);
+                      bool             aAllowUnsafeRules,
+                      mozilla::css::LoaderReusableStyleSheets* aReusableSheets = nullptr);
 
   // Parse HTML style attribute or its equivalent in other markup
   // languages.  aBaseURL is the base url to use for relative links in
   // the declaration.
   nsresult ParseStyleAttribute(const nsAString&  aAttributeValue,
                                nsIURI*           aDocURL,
                                nsIURI*           aBaseURL,
                                nsIPrincipal*     aNodePrincipal,
diff --git a/layout/style/test/test_csslexer.js b/layout/style/test/test_csslexer.js
--- a/layout/style/test/test_csslexer.js
+++ b/layout/style/test/test_csslexer.js
@@ -97,29 +97,65 @@ function test_lexer_linecol(domutils, cs
     if (!token) {
       break;
     }
   }
   // Ensure that we saw the correct number of tokens.
   equal(i, locations.length);
 }
 
+function test_lexer_eofchar(domutils, cssText, expected) {
+  let lexer = domutils.getCSSLexer(cssText);
+  while (lexer.nextToken()) {
+    // Nothing.
+  }
+
+  let result = cssText;
+  if (lexer.droppedTrailingBackslash) {
+    result += "\\";
+  }
+  result += lexer.impliedEOFCharacters;
+
+  equal(result, expected);
+}
+
 let LINECOL_TESTS = [
   ["simple", ["ident:0:0", ":0:6"]],
   ["\n    stuff", ["whitespace:0:0", "ident:1:4", ":1:9"]],
   ['"string with \\\nnewline"    \r\n', ["string:0:0", "whitespace:1:8",
                                          ":2:0"]]
 ];
 
+let EOFCHAR_TESTS = [
+  ["hello", "hello"],
+  ["hello \\", "hello \\\\"],
+  ["'hello", "'hello'"],
+  ["\"hello", "\"hello\""],
+  ["'hello\\", "'hello\\\\'"],
+  ["\"hello\\", "\"hello\\\\\""],
+  ["/*hello", "/*hello*/"],
+  ["/*hello\\", "/*hello\\*/"],
+  ["url(hello", "url(hello)"],
+  ["url('hello", "url('hello')"],
+  ["url(\"hello", "url(\"hello\")"],
+  ["url(hello\\", "url(hello\\\\)"],
+  ["url('hello\\", "url('hello\\\\')"],
+  ["url(\"hello\\", "url(\"hello\\\\\")"],
+];
+
 function run_test()
 {
   let domutils = Components.classes["@mozilla.org/inspector/dom-utils;1"]
                            .getService(Components.interfaces.inIDOMUtils);
 
   let text, result;
   for ([text, result] of LEX_TESTS) {
     test_lexer(domutils, text, result);
   }
 
   for ([text, result] of LINECOL_TESTS) {
     test_lexer_linecol(domutils, text, result);
   }
+
+  for ([text, result] of EOFCHAR_TESTS) {
+    test_lexer_eofchar(domutils, text, result);
+  }
 }
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -850,17 +850,17 @@ pref("devtools.debugger.force-local", tr
 // Display a prompt when a new connection starts to accept/reject it
 pref("devtools.debugger.prompt-connection", true);
 // Block tools from seeing / interacting with certified apps
 pref("devtools.debugger.forbid-certified-apps", true);
 // List of permissions that a sideloaded app can't ask for
 pref("devtools.apps.forbidden-permissions", "embed-apps,engineering-mode,embed-widgets");
 
 // DevTools default color unit
-pref("devtools.defaultColorUnit", "hex");
+pref("devtools.defaultColorUnit", "authored");
 
 // Used for devtools debugging
 pref("devtools.dump.emit", false);
 
 // Disable device discovery logging
 pref("devtools.discovery.log", false);
 // Whether to scan for DevTools devices via WiFi
 pref("devtools.remote.wifi.scan", true);
diff --git a/toolkit/devtools/output-parser.js b/toolkit/devtools/output-parser.js
--- a/toolkit/devtools/output-parser.js
+++ b/toolkit/devtools/output-parser.js
@@ -393,45 +393,75 @@ OutputParser.prototype = {
 
     let swatch = event.target;
     let color = this.colorSwatches.get(swatch);
     let val = color.nextColorUnit();
 
     swatch.nextElementSibling.textContent = val;
   },
 
-   /**
-    * Append a URL to the output.
-    *
-    * @param  {String} match
-    *         Complete match that may include "url(xxx)"
-    * @param  {String} url
-    *         Actual URL
-    * @param  {Object} [options]
-    *         Options object. For valid options and default values see
-    *         _mergeOptions().
-    */
-  _appendURL: function(match, url, options={}) {
+  /**
+   * A helper function that sanitizes a possibly-unterminated URL.
+   */
+  _sanitizeURL: function(url) {
+    // Re-lex the URL and add any needed termination characters.
+    let urlTokenizer = DOMUtils.getCSSLexer(url);
+    // Just read until EOF; there will only be a single token.
+    while (urlTokenizer.nextToken()) {
+      // Nothing.
+    }
+
+    if (urlTokenizer.droppedTrailingBackslash) {
+      url += "\\";
+    }
+    return url + urlTokenizer.impliedEOFCharacters;
+  },
+
+  /**
+   * Append a URL to the output.
+   *
+   * @param  {String} match
+   *         Complete match that may include "url(xxx)"
+   * @param  {String} url
+   *         Actual URL
+   * @param  {Object} [options]
+   *         Options object. For valid options and default values see
+   *         _mergeOptions().
+   */
+  _appendURL: function(match, url, options) {
     if (options.urlClass) {
-      this._appendTextNode("url(\"");
+      // Sanitize the URL.  Note that if we modify the URL, we just
+      // leave the termination characters.  This isn't strictly
+      // "as-authored", but it makes a bit more sense.
+      match = this._sanitizeURL(match);
+      // This regexp matches a URL token.  It puts the "url(", any
+      // leading whitespace, and any opening quote into |leader|; the
+      // URL text itself into |body|, and any trailing quote, trailing
+      // whitespace, and the ")" into |trailer|.  We considered adding
+      // functionality for this to CSSLexer, in some way, but this
+      // seemed simpler on the whole.
+      let [, leader, , body, trailer] =
+        /^(url\([ \t\r\n\f]*(["']?))(.*?)(\2[ \t\r\n\f]*\))$/i.exec(match);
+
+      this._appendTextNode(leader);
 
       let href = url;
       if (options.baseURI) {
         href = options.baseURI.resolve(url);
       }
 
       this._appendNode("a", {
         target: "_blank",
         class: options.urlClass,
         href: href
-      }, url);
+      }, body);
 
-      this._appendTextNode("\")");
+      this._appendTextNode(trailer);
     } else {
-      this._appendTextNode("url(\"" + url + "\")");
+      this._appendTextNode(match);
     }
   },
 
   /**
    * Create a node.
    *
    * @param  {String} tagName
    *         Tag type e.g. "div"
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -9,26 +9,31 @@ const {Cc, Ci, Cu} = require("chrome");
 const promise = require("promise");
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method, RetVal, types} = protocol;
 const events = require("sdk/event/core");
 const {Class} = require("sdk/core/heritage");
 const {LongStringActor} = require("devtools/server/actors/string");
 const {PSEUDO_ELEMENT_SET} = require("devtools/styleinspector/css-logic");
 
-// This will add the "stylesheet" actor type for protocol.js to recognize
-require("devtools/server/actors/stylesheets");
+// This will also add the "stylesheet" actor type for protocol.js to recognize
+const {UPDATE_PRESERVING_RULES, UPDATE_GENERAL} =
+      require("devtools/server/actors/stylesheets");
 
 loader.lazyGetter(this, "CssLogic", () => {
   return require("devtools/styleinspector/css-logic").CssLogic;
 });
 loader.lazyGetter(this, "DOMUtils", () => {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
 });
 
+loader.lazyGetter(this, "RuleRewriter", () => {
+  return require("devtools/shared/css-parsing-utils").RuleRewriter;
+});
+
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
 // Not included since these are uneditable by the user.
 // See https://hg.mozilla.org/mozilla-central/file/696a4ad5d011/layout/style/nsCSSPseudoElementList.h#l74
@@ -123,16 +128,22 @@ types.addDictType("fontface", {
 
 /**
  * The PageStyle actor lets the client look at the styles on a page, as
  * they are applied to a given node.
  */
 let PageStyleActor = protocol.ActorClass({
   typeName: "pagestyle",
 
+  events: {
+    "stylesheet-updated": {
+      type: "styleSheetUpdated",
+    }
+  },
+
   /**
    * Create a PageStyleActor.
    *
    * @param inspector
    *    The InspectorActor that owns this PageStyleActor.
    *
    * @constructor
    */
@@ -146,16 +157,27 @@ let PageStyleActor = protocol.ActorClass
     this.walker = inspector.walker;
     this.cssLogic = new CssLogic();
 
     // Stores the association of DOM objects -> actors
     this.refMap = new Map();
 
     this.onFrameUnload = this.onFrameUnload.bind(this);
     events.on(this.inspector.tabActor, "will-navigate", this.onFrameUnload);
+
+    this._styleApplied = this._styleApplied.bind(this);
+    this._watchedSheets = new Set();
+  },
+
+  destroy: function() {
+    for (let sheet of this._watchedSheets) {
+      sheet.off("style-applied", this._styleApplied);
+    }
+
+    protocol.Actor.prototype.destroy.call(this);
   },
 
   get conn() {
     return this.inspector.conn;
   },
 
   form: function(detail) {
     if (detail === "actorid") {
@@ -164,22 +186,33 @@ let PageStyleActor = protocol.ActorClass
 
     return {
       actor: this.actorID,
       traits: {
         // Whether the actor has had bug 1103993 fixed, which means that the
         // getApplied method calls cssLogic.highlight(node) to recreate the
         // style cache. Clients requesting getApplied from actors that have not
         // been fixed must make sure cssLogic.highlight(node) was called before.
-        getAppliedCreatesStyleCache: true
+        getAppliedCreatesStyleCache: true,
+        // Whether addNewRule accepts the editAuthored argument.
+        authoredStyles: true
       }
     };
   },
 
   /**
+   * Called when a style sheet is updated.
+   */
+  _styleApplied: function(kind) {
+    if (kind === UPDATE_GENERAL) {
+      events.emit(this, "stylesheet-updated");
+    }
+  },
+
+  /**
    * Return or create a StyleRuleActor for the given item.
    * @param item Either a CSSStyleRule or a DOM element.
    */
   _styleRef: function(item) {
     if (this.refMap.has(item)) {
       return this.refMap.get(item);
     }
     let actor = StyleRuleActor(this, item);
@@ -194,16 +227,20 @@ let PageStyleActor = protocol.ActorClass
    * @param  {DOMStyleSheet} sheet
    *         The style sheet to create an actor for.
    * @return {StyleSheetActor}
    *         The actor for this style sheet
    */
   _sheetRef: function(sheet) {
     let tabActor = this.inspector.tabActor;
     let actor = tabActor.createStyleSheetActor(sheet);
+    if (!this._watchedSheets.has(actor)) {
+      this._watchedSheets.add(actor);
+      actor.on("style-applied", this._styleApplied);
+    }
     return actor;
   },
 
   /**
    * Get the computed style for a node.
    *
    * @param NodeActor node
    * @param object options
@@ -504,26 +541,31 @@ let PageStyleActor = protocol.ActorClass
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSelectors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
-  getApplied: method(function(node, options) {
+  getApplied: method(Task.async(function*(node, options) {
     if (!node) {
       return {entries: [], rules: [], sheets: []};
     }
 
     this.cssLogic.highlight(node.rawNode);
     let entries = [];
     entries = entries.concat(this._getAllElementRules(node, undefined, options));
-    return this.getAppliedProps(node, entries, options);
-  }, {
+
+    let result = this.getAppliedProps(node, entries, options);
+    for (let rule of result.rules) {
+      yield rule.getAuthoredCssText();
+    }
+    return result;
+  }), {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
     response: RetVal("appliedStylesReturn")
   }),
@@ -885,22 +927,26 @@ let PageStyleActor = protocol.ActorClass
   getNewAppliedProps: function(node, rule) {
     let ruleActor = this._styleRef(rule);
     return this.getAppliedProps(node, [{ rule: ruleActor }],
       { matchedSelectors: true });
   },
 
   /**
    * Adds a new rule, and returns the new StyleRuleActor.
-   * @param NodeActor node
-   * @param [string] pseudoClasses The list of pseudo classes to append to the
-   * new selector.
-   * @returns StyleRuleActor of the new rule
+   * @param {NodeActor} node
+   * @param {String} pseudoClasses The list of pseudo classes to append to the
+   *        new selector.
+   * @param {Boolean} editAuthored
+   *        True if the selector should be updated by editing the
+   *        authored text; false if the selector should be updated via
+   *        CSSOM.
+   * @returns {StyleRuleActor} the new rule
    */
-  addNewRule: method(function(node, pseudoClasses) {
+  addNewRule: method(Task.async(function*(node, pseudoClasses, editAuthored = false) {
     let style = this.styleElement;
     let sheet = style.sheet;
     let cssRules = sheet.cssRules;
     let rawNode = node.rawNode;
 
     let selector;
     if (rawNode.id) {
       selector = "#" + CSS.escape(rawNode.id);
@@ -910,21 +956,32 @@ let PageStyleActor = protocol.ActorClass
       selector = rawNode.tagName.toLowerCase();
     }
 
     if (pseudoClasses && pseudoClasses.length > 0) {
       selector += pseudoClasses.join("");
     }
 
     let index = sheet.insertRule(selector + " {}", cssRules.length);
-    return this.getNewAppliedProps(node, cssRules.item(index));
-  }, {
+
+    // If inserting the rule succeeded, go ahead and edit the source
+    // text if requested.
+    if (editAuthored) {
+      let sheetActor = this._sheetRef(sheet);
+      let {str: authoredText} = yield sheetActor.getText();
+      authoredText += "\n" + selector + " {\n" + "}";
+      yield sheetActor.update(authoredText, false);
+    }
+
+    return this.getNewAppliedProps(node, sheet.cssRules.item(index));
+  }), {
     request: {
       node: Arg(0, "domnode"),
-      pseudoClasses: Arg(1, "nullable:array:string")
+      pseudoClasses: Arg(1, "nullable:array:string"),
+      editAuthored: Arg(2, "boolean")
     },
     response: RetVal("appliedStylesReturn")
   }),
 });
 exports.PageStyleActor = PageStyleActor;
 
 /**
  * Front object for the PageStyleActor
@@ -969,17 +1026,23 @@ let PageStyleFront = protocol.FrontClass
     }
     let ret = yield this._getApplied(node, options);
     return ret.entries;
   }), {
     impl: "_getApplied"
   }),
 
   addNewRule: protocol.custom(function(node, pseudoClasses) {
-    return this._addNewRule(node, pseudoClasses).then(ret => {
+    let addPromise;
+    if (this._form.traits && this._form.traits.authoredStyles) {
+      addPromise = this._addNewRule(node, pseudoClasses, true);
+    } else {
+      addPromise = this._addNewRule(node, pseudoClasses);
+    }
+    return addPromise.then(ret => {
       return ret.entries[0];
     });
   }, {
     impl: "_addNewRule"
   })
 });
 
 /**
@@ -987,29 +1050,44 @@ let PageStyleFront = protocol.FrontClass
  *
  * We slightly flatten the CSSOM for this actor, it represents
  * both the CSSRule and CSSStyle objects in one actor.  For nodes
  * (which have a CSSStyle but no CSSRule) we create a StyleRuleActor
  * with a special rule type (100).
  */
 let StyleRuleActor = protocol.ActorClass({
   typeName: "domstylerule",
+
+  events: {
+    "property-change": {
+      type: "propertyChange",
+      property: Arg(0, "string"),
+      value: Arg(1, "json")
+    },
+  },
+
   initialize: function(pageStyle, item) {
     protocol.Actor.prototype.initialize.call(this, null);
     this.pageStyle = pageStyle;
     this.rawStyle = item.style;
+    this._parentSheet = null;
 
     if (item instanceof (Ci.nsIDOMCSSRule)) {
       this.type = item.type;
       this.rawRule = item;
       if ((this.rawRule instanceof Ci.nsIDOMCSSStyleRule ||
            this.rawRule instanceof Ci.nsIDOMMozCSSKeyframeRule) &&
-           this.rawRule.parentStyleSheet) {
-        this.line = DOMUtils.getRuleLine(this.rawRule);
+          this.rawRule.parentStyleSheet) {
+        this.line = DOMUtils.getRelativeRuleLine(this.rawRule);
         this.column = DOMUtils.getRuleColumn(this.rawRule);
+        this._parentSheet = this.rawRule.parentStyleSheet;
+        this._getRuleIndex();
+        let sheetActor = this.pageStyle._sheetRef(this._parentSheet);
+        this._styleApplied = this._styleApplied.bind(this);
+        sheetActor.on("style-applied", this._styleApplied);
       }
     } else {
       // Fake a rule
       this.type = ELEMENT_STYLE;
       this.rawNode = item;
       this.rawRule = {
         style: item.style,
         toString: function() {
@@ -1054,16 +1132,23 @@ let StyleRuleActor = protocol.ActorClass
       actor: this.actorID,
       type: this.type,
       line: this.line || undefined,
       column: this.column,
       traits: {
         // Whether the style rule actor implements the modifySelector2 method
         // that allows for unmatched rule to be added
         modifySelectorUnmatched: true,
+        // Whether the style rule actor implements the setRuleText
+        // method.  Special case about:PreferenceStyleSheet, as it is
+        // generated on the fly and the URI is not registered with the
+        // about: handler.
+        // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
+        canSetRuleText: !!(this._parentSheet &&
+                           this._parentSheet.href !== "about:PreferenceStyleSheet"),
       }
     };
 
     if (this.rawRule.parentRule) {
       form.parentRule = this.pageStyle._styleRef(this.rawRule.parentRule).actorID;
 
       // CSS rules that we call media rules are STYLE_RULES that are children
       // of MEDIA_RULEs. We need to check the parentRule to check if a rule is
@@ -1071,20 +1156,21 @@ let StyleRuleActor = protocol.ActorClass
       // below.
       if (this.rawRule.parentRule.type === Ci.nsIDOMCSSRule.MEDIA_RULE) {
         form.media = [];
         for (let i = 0, n = this.rawRule.parentRule.media.length; i < n; i++) {
           form.media.push(this.rawRule.parentRule.media.item(i));
         }
       }
     }
-    if (this.rawRule.parentStyleSheet) {
-      form.parentStyleSheet = this.pageStyle._sheetRef(this.rawRule.parentStyleSheet).actorID;
+    if (this._parentSheet) {
+      form.parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet).actorID;
     }
 
+    form.authoredText = this.authoredText;
     switch (this.type) {
       case Ci.nsIDOMCSSRule.STYLE_RULE:
         form.selectors = CssLogic.getSelectors(this.rawRule);
         form.cssText = this.rawStyle.cssText || "";
         break;
       case ELEMENT_STYLE:
         // Elements don't have a parent stylesheet, and therefore
         // don't have an associated URI.  Provide a URI for
@@ -1108,17 +1194,132 @@ let StyleRuleActor = protocol.ActorClass
         form.keyText = this.rawRule.keyText || "";
         break;
     }
 
     return form;
   },
 
   /**
-   * Modify a rule's properties.  Passed an array of modifications:
+   * Send an event notifying that a property of the stylesheet
+   * has changed.
+   *
+   * @param {String} property
+   *        Name of the changed property
+   * @param {any} value
+   *        The new value
+   */
+  _notifyPropertyChanged: function(property, value) {
+    events.emit(this, "property-change", property, value);
+  },
+
+  /**
+   * Compute the index of this actor's raw rule in its parent style
+   * sheet.
+   */
+  _getRuleIndex: function() {
+    let rule = this.rawRule;
+    let cssRules = this._parentSheet.cssRules;
+    this._ruleIndex = -1;
+    for (let i = 0; i < cssRules.length; i++) {
+      if (rule === cssRules.item(i)) {
+        this._ruleIndex = i;
+        break;
+      }
+    }
+  },
+
+  /**
+   * This is attached to the parent style sheet actor's
+   * "style-applied" event.
+   */
+  _styleApplied: function(kind) {
+    if (kind === UPDATE_GENERAL) {
+      // A general change means that the rule actors are invalidated,
+      // so stop listening to events now.
+      let sheetActor = this.pageStyle._sheetRef(this._parentSheet);
+      sheetActor.off("style-applied", this._styleApplied);
+    } else if (this._ruleIndex >= 0) {
+      // The sheet was updated by this actor, in a way that preserves
+      // the rules.  Now, recompute our new rule from the style sheet,
+      // so that we aren't left with a reference to a dangling rule.
+      this.rawRule = this._parentSheet.cssRules[this._ruleIndex];
+      let line = DOMUtils.getRelativeRuleLine(this.rawRule);
+      let column = DOMUtils.getRuleColumn(this.rawRule);
+      if (line !== this.line) {
+        this.line = line;
+        this._notifyPropertyChanged("line", line);
+      }
+      if (column !== this.column) {
+        this.column = column;
+        this._notifyPropertyChanged("column", column);
+      }
+    }
+  },
+
+  /**
+   * Return the authored form of a rule's text.  This will include
+   * invalid and otherwise ignored properties.
+   */
+  getAuthoredCssText: function*() {
+    // Special case about:PreferenceStyleSheet, as it is generated on the
+    // fly and the URI is not registered with the about: handler.
+    // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
+    if (!this._parentSheet ||
+        this._parentSheet.href === "about:PreferenceStyleSheet" ||
+        (this.type !== Ci.nsIDOMCSSRule.STYLE_RULE &&
+         this.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE)) {
+      return "";
+    }
+
+    if (typeof this.authoredText === "string") {
+      return this.authoredText;
+    }
+
+    let parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet);
+    let {str: cssText} = yield parentStyleSheet.getText();
+    let {text} = getRuleText(cssText, this.line, this.column);
+
+    // Cache the result on the rule actor to avoid parsing again next time
+    this.authoredText = text;
+    return this.authoredText;
+  },
+
+  /**
+   * Set the contents of the rule.  This rewrites the rule in the
+   * stylesheet and causes it to be re-evaluated.
+   *
+   * @param {String} newText the new text of the rule
+   * @returns the rule with updated properties
+   */
+  setRuleText: method(Task.async(function*(newText) {
+    if (!this._parentSheet ||
+        (this.type !== Ci.nsIDOMCSSRule.STYLE_RULE &&
+         this.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE)) {
+      throw new Error("invalid call to setRuleText");
+    }
+
+    let parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet);
+    let {str: cssText} = yield parentStyleSheet.getText();
+
+    let {offset, text} = getRuleText(cssText, this.line, this.column);
+    cssText = cssText.substring(0, offset) + newText +
+      cssText.substring(offset + text.length);
+
+    this.authoredText = newText;
+    yield parentStyleSheet.update(cssText, false, UPDATE_PRESERVING_RULES);
+
+    return this;
+  }), {
+    request: { modification: Arg(0, "string") },
+    response: { rule: RetVal("domstylerule") }
+  }),
+
+  /**
+   * Modify a rule's properties. Passed an array of modifications:
    * {
    *   type: "set",
    *   name: <string>,
    *   value: <string>,
    *   priority: <optional string>
    * }
    *  or
    * {
@@ -1132,17 +1333,17 @@ let StyleRuleActor = protocol.ActorClass
     // Use a fresh element for each call to this function to prevent side
     // effects that pop up based on property values that were already set on the
     // element.
 
     let document;
     if (this.rawNode) {
       document = this.rawNode.ownerDocument;
     } else {
-      let parentStyleSheet = this.rawRule.parentStyleSheet;
+      let parentStyleSheet = this._parentSheet;
       while (parentStyleSheet.ownerRule &&
           parentStyleSheet.ownerRule instanceof Ci.nsIDOMCSSImportRule) {
         parentStyleSheet = parentStyleSheet.ownerRule.parentStyleSheet;
       }
 
       document = this.getDocument(parentStyleSheet);
     }
 
@@ -1165,136 +1366,177 @@ let StyleRuleActor = protocol.ActorClass
   }),
 
   /**
    * Helper function for modifySelector and modifySelector2, inserts the new
    * rule with the new selector into the parent style sheet and removes the
    * current rule. Returns the newly inserted css rule or null if the rule is
    * unsuccessfully inserted to the parent style sheet.
    *
-   * @param string value
+   * @param {String} value
    *        The new selector value
+   * @param {Boolean} editAuthored
+   *        True if the selector should be updated by editing the
+   *        authored text; false if the selector should be updated via
+   *        CSSOM.
    *
-   * @returns CSSRule
+   * @returns {CSSRule}
    *        The new CSS rule added
    */
-  _addNewSelector: function(value) {
+  _addNewSelector: Task.async(function*(value, editAuthored) {
     let rule = this.rawRule;
-    let parentStyleSheet = rule.parentStyleSheet;
-    let cssRules = parentStyleSheet.cssRules;
-    let cssText = rule.cssText;
-    let selectorText = rule.selectorText;
+    let parentStyleSheet = this._parentSheet;
 
-    for (let i = 0; i < cssRules.length; i++) {
-      if (rule === cssRules.item(i)) {
-        try {
-          // Inserts the new style rule into the current style sheet and
-          // delete the current rule
-          let ruleText = cssText.slice(selectorText.length).trim();
-          parentStyleSheet.insertRule(value + " " + ruleText, i);
-          parentStyleSheet.deleteRule(i + 1);
-          return cssRules.item(i);
-        } catch(e) {
-          // The selector could be invalid, or the rule could fail to insert.
-          // If that happens, the method returns null.
+    // We know the selector modification is ok, so if the client asked
+    // for the authored text to be edited, do it now.
+    if (editAuthored) {
+      let document = this.getDocument(this._parentSheet);
+      try {
+        document.querySelector(value);
+      } catch (e) {
+        return null;
+      }
+
+      let sheetActor = this.pageStyle._sheetRef(parentStyleSheet);
+      let {str: authoredText} = yield sheetActor.getText();
+      let [startOffset, endOffset] = getSelectorOffsets(authoredText, this.line,
+                                                        this.column);
+      authoredText = authoredText.substring(0, startOffset) + value +
+        authoredText.substring(endOffset);
+      yield sheetActor.update(authoredText, false, UPDATE_PRESERVING_RULES);
+    } else {
+      let cssRules = parentStyleSheet.cssRules;
+      let cssText = rule.cssText;
+      let selectorText = rule.selectorText;
+
+      for (let i = 0; i < cssRules.length; i++) {
+        if (rule === cssRules.item(i)) {
+          try {
+            // Inserts the new style rule into the current style sheet and
+            // delete the current rule
+            let ruleText = cssText.slice(selectorText.length).trim();
+            parentStyleSheet.insertRule(value + " " + ruleText, i);
+            parentStyleSheet.deleteRule(i + 1);
+            break;
+          } catch(e) {
+            // The selector could be invalid, or the rule could fail to insert.
+            return null;
+          }
         }
-
-        break;
       }
     }
 
-    return null;
-  },
+    return parentStyleSheet.cssRules[this._ruleIndex];
+  }),
 
   /**
    * Modify the current rule's selector by inserting a new rule with the new
    * selector value and removing the current rule.
    *
    * Note this method was kept for backward compatibility, but unmatched rules
    * support was added in FF41.
    *
    * @param string value
    *        The new selector value
    * @returns boolean
    *        Returns a boolean if the selector in the stylesheet was modified,
    *        and false otherwise
    */
-  modifySelector: method(function(value) {
+  modifySelector: method(Task.async(function*(value) {
     if (this.type === ELEMENT_STYLE) {
       return false;
     }
 
-    let document = this.getDocument(this.rawRule.parentStyleSheet);
+    let document = this.getDocument(this._parentSheet);
     // Extract the selector, and pseudo elements and classes
     let [selector, pseudoProp] = value.split(/(:{1,2}.+$)/);
     let selectorElement;
 
     try {
       selectorElement = document.querySelector(selector);
     } catch (e) {
       return false;
     }
 
     // Check if the selector is valid and not the same as the original
     // selector
     if (selectorElement && this.rawRule.selectorText !== value) {
-      this._addNewSelector(value);
+      yield this._addNewSelector(value, false);
       return true;
     }
     return false;
-  }, {
+  }), {
     request: { selector: Arg(0, "string") },
     response: { isModified: RetVal("boolean") },
   }),
 
   /**
    * Modify the current rule's selector by inserting a new rule with the new
    * selector value and removing the current rule.
    *
    * In contrast with the modifySelector method which was used before FF41,
    * this method also returns information about the new rule and applied style
    * so that consumers can immediately display the new rule, whether or not the
    * selector matches the current element without having to refresh the whole
    * list.
    *
-   * @param DOMNode node
+   * @param {DOMNode} node
    *        The current selected element
-   * @param string value
+   * @param {String} value
    *        The new selector value
-   * @returns Object
+   * @param {Boolean} editAuthored
+   *        True if the selector should be updated by editing the
+   *        authored text; false if the selector should be updated via
+   *        CSSOM.
+   * @returns {Object}
    *        Returns an object that contains the applied style properties of the
    *        new rule and a boolean indicating whether or not the new selector
    *        matches the current selected element
    */
-  modifySelector2: method(function(node, value) {
+  modifySelector2: method(function(node, value, editAuthored = false) {
     let isMatching = false;
     let ruleProps = null;
 
     if (this.type === ELEMENT_STYLE ||
         this.rawRule.selectorText === value) {
       return { ruleProps, isMatching: true };
     }
 
-    let newCssRule = this._addNewSelector(value);
-    if (newCssRule) {
-      ruleProps = this.pageStyle.getNewAppliedProps(node, newCssRule);
+    let selectorPromise = this._addNewSelector(value, editAuthored);
+
+    if (editAuthored) {
+      selectorPromise = selectorPromise.then(Task.async(function*(newCssRule) {
+        if (newCssRule) {
+          let style = this.pageStyle._styleRef(newCssRule);
+          yield style.getAuthoredCssText();
+        }
+        return newCssRule;
+      }.bind(this)));
     }
 
-    // Determine if the new selector value matches the current selected element
-    try {
-      isMatching = node.rawNode.matches(value);
-    } catch(e) {
-      // This fails when value is an invalid selector.
-    }
+    return selectorPromise.then((newCssRule) => {
+      if (newCssRule) {
+        ruleProps = this.pageStyle.getNewAppliedProps(node, newCssRule);
+      }
 
-    return { ruleProps, isMatching };
+      // Determine if the new selector value matches the current
+      // selected element
+      try {
+        isMatching = node.rawNode.matches(value);
+      } catch(e) {
+        // This fails when value is an invalid selector.
+      }
+
+      return { ruleProps, isMatching };
+    });
   }, {
     request: {
       node: Arg(0, "domnode"),
-      value: Arg(1, "string")
+      value: Arg(1, "string"),
+      editAuthored: Arg(2, "boolean")
     },
     response: RetVal("modifiedStylesReturn")
   })
 });
 
 /**
  * Front for the StyleRule actor.
  */
@@ -1315,34 +1557,51 @@ let StyleRuleFront = protocol.FrontClass
     this.actorID = form.actor;
     this._form = form;
     if (this._mediaText) {
       this._mediaText = null;
     }
   },
 
   /**
-   * Return a new RuleModificationList for this node.
+   * Ensure _form is updated when property-change is emitted.
+   */
+  _propertyChangePre: protocol.preEvent("property-change", function(name,
+                                                                    value) {
+    this._form[name] = value;
+  }),
+
+  /**
+   * Return a new RuleModificationList or RuleRewriter for this node.
+   * A RuleRewriter will be returned when the rule's canSetRuleText
+   * trait is true; otherwise a RuleModificationList will be
+   * returned.
    */
   startModifyingProperties: function() {
+    if (this.canSetRuleText) {
+      return new RuleRewriter(this, this.authoredText);
+    }
     return new RuleModificationList(this);
   },
 
   get type() {
     return this._form.type;
   },
   get line() {
     return this._form.line || -1;
   },
   get column() {
     return this._form.column || -1;
   },
   get cssText() {
     return this._form.cssText;
   },
+  get authoredText() {
+    return this._form.authoredText || this._form.cssText;
+  },
   get keyText() {
     return this._form.keyText;
   },
   get name() {
     return this._form.name;
   },
   get selectors() {
     return this._form.selectors;
@@ -1385,16 +1644,20 @@ let StyleRuleFront = protocol.FrontClass
     let sheet = this.parentStyleSheet;
     return sheet ? sheet.nodeHref : "";
   },
 
   get supportsModifySelectorUnmatched() {
     return this._form.traits && this._form.traits.modifySelectorUnmatched;
   },
 
+  get canSetRuleText() {
+    return this._form.traits && this._form.traits.canSetRuleText;
+  },
+
   get location() {
     return {
       source: this.parentStyleSheet,
       href: this.href,
       line: this.line,
       column: this.column
     };
   },
@@ -1427,17 +1690,21 @@ let StyleRuleFront = protocol.FrontClass
         return location;
       });
   },
 
   modifySelector: protocol.custom(Task.async(function*(node, value) {
     let response;
     if (this.supportsModifySelectorUnmatched) {
       // If the debugee supports adding unmatched rules (post FF41)
-      response = yield this.modifySelector2(node, value);
+      if (this.canSetRuleText) {
+        response = yield this.modifySelector2(node, value, true);
+      } else {
+        response = yield this.modifySelector2(node, value);
+      }
     } else {
       response = yield this._modifySelector(value);
     }
 
     if (response.ruleProps) {
       response.ruleProps = response.ruleProps.entries[0];
     }
     return response;
@@ -1447,65 +1714,144 @@ let StyleRuleFront = protocol.FrontClass
 });
 
 /**
  * Convenience API for building a list of attribute modifications
  * for the `modifyProperties` request.  A RuleModificationList holds a
  * list of modifications that will be applied to a StyleRuleActor.
  * The modifications are processed in the order in which they are
  * added to the RuleModificationList.
+ *
+ * Objects of this type expose the same API as @see RuleRewriter.
+ * This lets the inspector use (mostly) the same code, regardless of
+ * whether the server implements setRuleText.
  */
 let RuleModificationList = Class({
   /**
    * Initialize a RuleModificationList.
    * @param {StyleRuleFront} rule the associated rule
    */
   initialize: function(rule) {
     this.rule = rule;
     this.modifications = [];
   },
 
   /**
+   * Return a promise that resolves to the default indentation for
+   * this rule's style sheet.  This implementation always resolves to
+   * null, because |setRuleText| is not available.
+   *
+   * @return {Promise} A promise resolving to null.
+   */
+  getDefaultIndentation: function() {
+    return promise.resolve(null);
+  },
+
+  /**
    * Apply the modifications in this object to the associated rule.
    *
    * @return {Promise} A promise which will be resolved when the modifications
    *         are complete; @see StyleRuleActor.modifyProperties.
    */
   apply: function() {
     return this.rule.modifyProperties(this.modifications);
   },
 
   /**
    * Add a "set" entry to the modification list.
    *
-   * @param {string} name the property's name
-   * @param {string} value the property's value
-   * @param {string} priority the property's priority, either the empty
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name the property's name
+   * @param {String} value the property's value
+   * @param {String} priority the property's priority, either the empty
    *                          string or "important"
    */
-  setProperty: function(name, value, priority) {
+  setProperty: function(index, name, value, priority) {
     this.modifications.push({
       type: "set",
       name: name,
       value: value,
       priority: priority
     });
   },
 
   /**
    * Add a "remove" entry to the modification list.
    *
-   * @param {string} name the name of the property to remove
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name the name of the property to remove
    */
-  removeProperty: function(name) {
+  removeProperty: function(index, name) {
     this.modifications.push({
       type: "remove",
       name: name
     });
-  }
+  },
+
+  /**
+   * Rename a property.  This implementation acts like
+   * |removeProperty|, because |setRuleText| is not available.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name current name of the property
+   * @param {String} newName new name of the property
+   */
+  renameProperty: function(index, name, newName) {
+    this.removeProperty(index, name);
+  },
+
+  /**
+   * Enable or disable a property.  This implementation acts like
+   * |removeProperty| when disabling, or a no-op when enabling,
+   * because |setRuleText| is not available.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name current name of the property
+   * @param {Boolean} isEnabled true if the property should be enabled;
+   *                        false if it should be disabled
+   */
+  setPropertyEnabled: function(index, name, isEnabled) {
+    if (!isEnabled) {
+      this.removeProperty(index, name);
+    }
+  },
+
+  /**
+   * Create a new property.  This implementation does nothing, because
+   * |setRuleText| is not available.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name name of the new property
+   * @param {String} value value of the new property
+   * @param {String} priority priority of the new property; either
+   *                          the empty string or "important"
+   */
+  createProperty: function(index, name, value, priority) {
+    // Nothing.
+  },
 });
 
 /**
  * Helper function for getting an image preview of the given font.
  *
  * @param font {string}
  *        Name of font to preview
  * @param doc {Document}
@@ -1629,16 +1975,57 @@ function getRuleText(initialText, line, 
   // that cssTokenizer skips them.
   return {offset: textOffset + startOffset,
           text: text.substring(startOffset, endOffset)};
 }
 
 exports.getRuleText = getRuleText;
 
 /**
+ * Compute the start and end offsets of a rule's selector text, given
+ * the CSS text and the line and column at which the rule begins.
+ * @param {String} initialText
+ * @param {Number} line (1-indexed)
+ * @param {Number} column (1-indexed)
+ * @return {array} An array with two elements: [startOffset, endOffset].
+ *                 The elements mark the bounds in |initialText| of
+ *                 the CSS rule's selector.
+ */
+function getSelectorOffsets(initialText, line, column) {
+  if (typeof line === "undefined" || typeof column === "undefined") {
+    throw new Error("Location information is missing");
+  }
+
+  let {offset: textOffset, text} =
+      getTextAtLineColumn(initialText, line, column);
+  let lexer = DOMUtils.getCSSLexer(text);
+
+  // Search forward for the opening brace.
+  let endOffset;
+  while (true) {
+    let token = lexer.nextToken();
+    if (!token) {
+      break;
+    }
+    if (token.tokenType === "symbol" && token.text === "{") {
+      if (endOffset === undefined) {
+        break;
+      }
+      return [textOffset, textOffset + endOffset];
+    }
+    // Preserve comments and whitespace just before the "{".
+    if (token.tokenType !== "comment" && token.tokenType !== "whitespace") {
+      endOffset = token.endOffset;
+    }
+  }
+
+  throw new Error("could not find bounds of rule");
+}
+
+/**
  * Return the offset and substring of |text| that starts at the given
  * line and column.
  * @param {String} text
  * @param {Number} line (1-indexed)
  * @param {Number} column (1-indexed)
  * @return {object} An object of the form {offset: number, text: string},
  *                  where the offset is the offset into the input string
  *                  where the text starts, and where text is the text.
diff --git a/toolkit/devtools/server/actors/stylesheets.js b/toolkit/devtools/server/actors/stylesheets.js
--- a/toolkit/devtools/server/actors/stylesheets.js
+++ b/toolkit/devtools/server/actors/stylesheets.js
@@ -18,16 +18,21 @@ const protocol = require("devtools/serve
 const {Arg, Option, method, RetVal, types} = protocol;
 const {LongStringActor, ShortLongString} = require("devtools/server/actors/string");
 const {fetch} = require("devtools/toolkit/DevToolsUtils");
 const {listenOnce} = require("devtools/async-utils");
 const {SourceMapConsumer} = require("source-map");
 
 loader.lazyGetter(this, "CssLogic", () => require("devtools/styleinspector/css-logic").CssLogic);
 
+const {
+  getIndentationFromPrefs,
+  getIndentationFromString
+} = require("devtools/toolkit/shared/indentation");
+
 let TRANSITION_CLASS = "moz-styleeditor-transitioning";
 let TRANSITION_DURATION_MS = 500;
 let TRANSITION_BUFFER_MS = 1000;
 let TRANSITION_RULE_SELECTOR =
 ".moz-styleeditor-transitioning:root, .moz-styleeditor-transitioning:root *";
 let TRANSITION_RULE = TRANSITION_RULE_SELECTOR + " {\
 transition-duration: " + TRANSITION_DURATION_MS + "ms !important; \
 transition-delay: 0ms !important;\
@@ -35,16 +40,32 @@ transition-timing-function: ease-out !im
 transition-property: all !important;\
 }";
 
 let LOAD_ERROR = "error-load";
 
 types.addActorType("stylesheet");
 types.addActorType("originalsource");
 
+// The possible kinds of style-applied events.
+// UPDATE_PRESERVING_RULES means that the update is guaranteed to
+// preserve the number and order of rules on the style sheet.
+// UPDATE_GENERAL covers any other kind of change to the style sheet.
+let UPDATE_PRESERVING_RULES = 0;
+exports.UPDATE_PRESERVING_RULES = UPDATE_PRESERVING_RULES;
+let UPDATE_GENERAL = 1;
+exports.UPDATE_GENERAL = UPDATE_GENERAL;
+
+// If the user edits a style sheet, we stash a copy of the edited text
+// here, keyed by the document.  This way, if the tools are closed and
+// then reopened, the edited text will be available.  A weak map is
+// used so that navigation by the user will eventually cause the
+// edited text to be collected.
+let modifiedStyleSheets = new WeakMap();
+
 /**
  * Creates a StyleSheetsActor. StyleSheetsActor provides remote access to the
  * stylesheets of a document.
  */
 let StyleSheetsActor = exports.StyleSheetsActor = protocol.ActorClass({
   typeName: "stylesheets",
 
   /**
@@ -380,17 +401,18 @@ let StyleSheetActor = protocol.ActorClas
 
   events: {
     "property-change" : {
       type: "propertyChange",
       property: Arg(0, "string"),
       value: Arg(1, "json")
     },
     "style-applied" : {
-      type: "styleApplied"
+      type: "styleApplied",
+      kind: Arg(0, "number")
     },
     "media-rules-changed" : {
       type: "mediaRulesChanged",
       rules: Arg(0, "array:mediarule")
     }
   },
 
   /* List of original sources that generated this stylesheet */
@@ -588,20 +610,30 @@ let StyleSheetActor = protocol.ActorClas
   /**
    * Fetch the text for this stylesheet from the cache or network. Return
    * cached text if it's already been fetched.
    *
    * @return {Promise}
    *         Promise that resolves with a string text of the stylesheet.
    */
   _getText: function() {
-    if (this.text) {
+    if (typeof (this.text) === "string") {
       return promise.resolve(this.text);
     }
 
+    let styleMap = modifiedStyleSheets.get(this.document);
+    if (styleMap) {
+      let key = this.href ? this.href : this.ownerNode;
+      let cssText = styleMap.get(key);
+      if (cssText) {
+        this.text = cssText;
+        return promise.resolve(cssText);
+      }
+    }
+
     if (!this.href) {
       // this is an inline <style> sheet
       let content = this.ownerNode.textContent;
       this.text = content;
       return promise.resolve(content);
     }
 
     let options = {
@@ -867,85 +899,96 @@ let StyleSheetActor = protocol.ActorClas
   },
 
   /**
    * Update the style sheet in place with new text.
    *
    * @param  {object} request
    *         'text' - new text
    *         'transition' - whether to do CSS transition for change.
+   *         'kind' - either UPDATE_PRESERVING_RULES or UPDATE_GENERAL
    */
-  update: method(function(text, transition) {
+  update: method(function(text, transition, kind = UPDATE_GENERAL) {
     DOMUtils.parseStyleSheet(this.rawSheet, text);
 
+    let styleMap = modifiedStyleSheets.get(this.document);
+    if (!styleMap) {
+      styleMap = new Map();
+      modifiedStyleSheets.set(this.document, styleMap);
+    }
+    let key = this.href ? this.href : this.ownerNode;
+    styleMap.set(key, text);
+
     this.text = text;
 
     this._notifyPropertyChanged("ruleCount");
 
     if (transition) {
-      this._insertTransistionRule();
+      this._insertTransistionRule(kind);
     }
     else {
-      events.emit(this, "style-applied");
+      events.emit(this, "style-applied", kind);
     }
 
     this._getMediaRules().then((rules) => {
       events.emit(this, "media-rules-changed", rules);
     });
   }, {
     request: {
       text: Arg(0, "string"),
       transition: Arg(1, "boolean")
     }
   }),
 
   /**
    * Insert a catch-all transition rule into the document. Set a timeout
    * to remove the rule after a certain time.
    */
-  _insertTransistionRule: function() {
+  _insertTransistionRule: function(kind) {
     this.document.documentElement.classList.add(TRANSITION_CLASS);
 
     // We always add the rule since we've just reset all the rules
     this.rawSheet.insertRule(TRANSITION_RULE, this.rawSheet.cssRules.length);
 
     // Set up clean up and commit after transition duration (+buffer)
     // @see _onTransitionEnd
     this.window.clearTimeout(this._transitionTimeout);
-    this._transitionTimeout = this.window.setTimeout(this._onTransitionEnd.bind(this),
+    this._transitionTimeout = this.window.setTimeout(this._onTransitionEnd.bind(this, kind),
                               TRANSITION_DURATION_MS + TRANSITION_BUFFER_MS);
   },
 
   /**
    * This cleans up class and rule added for transition effect and then
    * notifies that the style has been applied.
    */
-  _onTransitionEnd: function()
+  _onTransitionEnd: function(kind)
   {
     this.document.documentElement.classList.remove(TRANSITION_CLASS);
 
     let index = this.rawSheet.cssRules.length - 1;
     let rule = this.rawSheet.cssRules[index];
     if (rule.selectorText == TRANSITION_RULE_SELECTOR) {
       this.rawSheet.deleteRule(index);
     }
 
-    events.emit(this, "style-applied");
+    events.emit(this, "style-applied", kind);
   }
 })
 
 /**
  * StyleSheetFront is the client-side counterpart to a StyleSheetActor.
  */
 var StyleSheetFront = protocol.FrontClass(StyleSheetActor, {
   initialize: function(conn, form) {
     protocol.Front.prototype.initialize.call(this, conn, form);
 
     this._onPropertyChange = this._onPropertyChange.bind(this);
     events.on(this, "property-change", this._onPropertyChange);
+
+    this._guessedIndentation = null;
   },
 
   destroy: function() {
     events.off(this, "property-change", this._onPropertyChange);
     protocol.Front.prototype.destroy.call(this);
   },
 
   _onPropertyChange: function(property, value) {
@@ -976,16 +1019,44 @@ var StyleSheetFront = protocol.FrontClas
   get isSystem() {
     return this._form.system;
   },
   get styleSheetIndex() {
     return this._form.styleSheetIndex;
   },
   get ruleCount() {
     return this._form.ruleCount;
+  },
+
+  /**
+   * Get the indentation to use for edits to this style sheet.
+   *
+   * @return {Promise} A promise that will resolve to a string that
+   * should be used to indent a block in this style sheet.
+   */
+  guessIndentation: function() {
+    let prefIndent = getIndentationFromPrefs();
+    if (prefIndent) {
+      let {indentUnit, indentWithTabs} = prefIndent;
+      return promise.resolve(indentWithTabs ? "\t" : " ".repeat(indentUnit));
+    }
+
+    if (this._guessedIndentation) {
+      return promise.resolve(this._guessedIndentation);
+    }
+
+    return Task.spawn(function*() {
+      let longStr = yield this.getText();
+      let source = yield longStr.string();
+
+      let {indentUnit, indentWithTabs} = getIndentationFromString(source);
+
+      this._guessedIndentation = indentWithTabs ? "\t" : " ".repeat(indentUnit);
+      return this._guessedIndentation;
+    }.bind(this));
   }
 });
 
 /**
  * Actor representing an original source of a style sheet that was specified
  * in a source map.
  */
 let OriginalSourceActor = protocol.ActorClass({
