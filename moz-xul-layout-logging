# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e00942169a4739244cd7a54e49558e972ed70250

diff --git a/browser/base/content/urlbarBindings.xml b/browser/base/content/urlbarBindings.xml
--- a/browser/base/content/urlbarBindings.xml
+++ b/browser/base/content/urlbarBindings.xml
@@ -94,16 +94,18 @@ file, You can obtain one at http://mozil
     </content>
 
     <implementation implements="nsIObserver">
       <field name="ExtensionSearchHandler" readonly="true">
         (ChromeUtils.import("resource://gre/modules/ExtensionSearchHandler.jsm", {})).ExtensionSearchHandler;
       </field>
 
       <constructor><![CDATA[
+      console.log("Construcotr running");
+      console.trace();
         // UrlbarInput compatibility shims
         this.document = document;
         this.window = window;
         this.textbox = this;
 
         this._prefs = Cc["@mozilla.org/preferences-service;1"]
                         .getService(Ci.nsIPrefService)
                         .getBranch("browser.urlbar.");
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -14,18 +14,25 @@ ChromeUtils.import("resource://gre/modul
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 
 // The listener of DOMContentLoaded must be set on window, rather than
 // document, because the window can go away before the event is fired.
 // In that case, we don't want to initialize anything, otherwise we
 // may be leaking things because they will never be destroyed after.
 let gIsDOMContentLoaded = false;
 const gElementsPendingConnection = new Set();
-window.addEventListener("DOMContentLoaded", () => {
+window.addEventListener("MozBeforeInitialXULLayout", () => {
+  console.log("Running MozBeforeInitialXULLayout", document.documentURI);
+}, { once: true, capture: true });
+window.addEventListener("readystatechange", () => {
+  console.log("Running readystatechange", document.documentURI);
+}, { capture: true });
+window.addEventListener("MozBeforeInitialXULLayout", () => {
   gIsDOMContentLoaded = true;
+  console.log("Running DOMContentLoaded", document.documentURI);
   for (let element of gElementsPendingConnection) {
     try {
       if (element.isConnected) {
         element.connectedCallback();
       }
     } catch (ex) { console.error(ex); }
   }
   gElementsPendingConnection.clear();
diff --git a/toolkit/content/widgets/progressmeter.js b/toolkit/content/widgets/progressmeter.js
--- a/toolkit/content/widgets/progressmeter.js
+++ b/toolkit/content/widgets/progressmeter.js
@@ -64,16 +64,19 @@ class MozProgressmeter extends MozXULEle
     return val;
   }
 
   isUndetermined() {
     return this.getAttribute("mode") == "undetermined";
   }
 
   connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
     this._initUI();
   }
 
   disconnectedCallback() {
     this.runAnimation = false;
   }
 
   static get observedAttributes() {
diff --git a/toolkit/content/widgets/textbox.js b/toolkit/content/widgets/textbox.js
--- a/toolkit/content/widgets/textbox.js
+++ b/toolkit/content/widgets/textbox.js
@@ -66,16 +66,21 @@ class MozInputBox extends MozXULElement 
     }
 
     if (name === "spellcheck" && oldValue != newValue) {
       this._initUI();
     }
   }
 
   connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      console.log("DELAYING!!");
+      return;
+    }
+    console.log("Not delaying", this);
     this._initUI();
   }
 
   _initUI() {
     this.spellcheck = this.hasAttribute("spellcheck");
     if (this.menupopup) {
       this.menupopup.remove();
     }
