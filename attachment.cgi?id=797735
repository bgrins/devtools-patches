# HG changeset patch
# Parent 2514aac648b2f58ffa8bcf535b9fd252872f9162
# User Michael Ratcliffe <mratcliffe@mozilla.com>
# Date 1377850019 -7200

Bug 910155 - Rule view does not keep changed rules marked after inspecting other nodes r=dcamp

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -62,17 +62,17 @@ function createDummyDocument() {
     allowPlugins: false,
     allowAuth: false
   });
   let docShell = getDocShell(frame);
   let eventTarget = docShell.chromeEventHandler;
   docShell.createAboutBlankContentViewer(Cc["@mozilla.org/nullprincipal;1"].createInstance(Ci.nsIPrincipal));
   let window = docShell.contentViewer.DOMDocument.defaultView;
   window.location = "data:text/html,<html></html>";
-  let deferred = promise.defer()
+  let deferred = promise.defer();
   eventTarget.addEventListener("DOMContentLoaded", function handler(event) {
     eventTarget.removeEventListener("DOMContentLoaded", handler, false);
     deferred.resolve(window.document);
   }, false);
   gDummyPromise = deferred.promise;
   return gDummyPromise;
 }
 
@@ -121,18 +121,16 @@ function ElementStyle(aElement, aStore, 
   if (!("userProperties" in this.store)) {
     this.store.userProperties = new UserProperties();
   }
 
   if (!("disabled" in this.store)) {
     this.store.disabled = new WeakMap();
   }
 
-  let doc = aElement.ownerDocument;
-
   // To figure out how shorthand properties are interpreted by the
   // engine, we will set properties on a dummy element and observe
   // how their .style attribute reflects them as computed values.
   this.dummyElementPromise = createDummyDocument().then(document => {
     this.dummyElement = document.createElementNS(this.element.namespaceURI,
                                                  this.element.tagName);
     document.documentElement.appendChild(this.dummyElement);
     return this.dummyElement;
@@ -300,19 +298,19 @@ ElementStyle.prototype = {
     //   overridden.
     //
     // _overriddenDirty will be set on each prop, indicating whether its
     // dirty status changed during this pass.
     let taken = {};
     for each (let computedProp in computedProps) {
       let earlier = taken[computedProp.name];
       let overridden;
-      if (earlier
-          && computedProp.priority === "important"
-          && earlier.priority !== "important") {
+      if (earlier &&
+          computedProp.priority === "important" &&
+          earlier.priority !== "important") {
         // New property is higher priority.  Mark the earlier property
         // overridden (which will reverse its dirty state).
         earlier._overriddenDirty = !earlier._overriddenDirty;
         earlier.overridden = true;
         overridden = false;
       } else {
         overridden = !!earlier;
       }
@@ -511,17 +509,16 @@ Rule.prototype = {
           value: prop.value,
           priority: prop.priority
         });
         continue;
       }
 
       aModifications.setProperty(prop.name, prop.value, prop.priority);
 
-
       prop.updateComputed();
     }
 
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
@@ -540,25 +537,24 @@ Rule.prototype = {
         }
         let cssProp = cssProps[textProp.name];
 
         if (!cssProp) {
           cssProp = {
             name: textProp.name,
             value: "",
             priority: ""
-          }
+          };
         }
 
         if (aName && textProp.name == aName) {
           store.userProperties.setProperty(
-            this.style, textProp.name,
-            null,
-            cssProp.value,
-            textProp.value);
+            this.style,
+            textProp.name,
+            cssProp.value);
         }
         textProp.priority = cssProp.priority;
       }
 
       this.elementStyle.markOverridden();
 
       if (promise === this._applyingModifications) {
         this._applyingModifications = null;
@@ -637,17 +633,16 @@ Rule.prototype = {
   },
 
   _parseCSSText: function Rule_parseProperties(aCssText)
   {
     let lines = aCssText.match(CSS_LINE_RE);
     let props = [];
 
     for (let line of lines) {
-      dump("line: " + line + "\n");
       let [, name, value, priority] = CSS_PROP_RE.exec(line) || []
       if (!name || !value) {
         continue;
       }
 
       props.push({
         name: name,
         value: value,
@@ -965,17 +960,17 @@ TextProperty.prototype = {
  *        set of disabled properties.
  * @param {PageStyleFront} aPageStyle
  *        The PageStyleFront for communicating with the remote server.
  * @constructor
  */
 function CssRuleView(aDoc, aStore, aPageStyle)
 {
   this.doc = aDoc;
-  this.store = aStore;
+  this.store = aStore || {};
   this.pageStyle = aPageStyle;
   this.element = this.doc.createElementNS(HTML_NS, "div");
   this.element.className = "ruleview devtools-monospace";
   this.element.flex = 1;
 
   this._boundCopy = this._onCopy.bind(this);
   this.element.addEventListener("copy", this._boundCopy);
 
@@ -1870,87 +1865,88 @@ TextPropertyEditor.prototype = {
 };
 
 /**
  * Store of CSSStyleDeclarations mapped to properties that have been changed by
  * the user.
  */
 function UserProperties()
 {
-  this.weakMap = new WeakMap();
+  this.map = new Map();
 }
 
 UserProperties.prototype = {
   /**
    * Get a named property for a given CSSStyleDeclaration.
    *
    * @param {CSSStyleDeclaration} aStyle
    *        The CSSStyleDeclaration against which the property is mapped.
    * @param {string} aName
    *        The name of the property to get.
-   * @param {string} aComputedValue
-   *        The computed value of the property.  The user value will only be
-   *        returned if the computed value hasn't changed since, and this will
-   *        be returned as the default if no user value is available.
+   * @param {string} aDefault
+   *        The value to return if the property is has been changed outside of
+   *        the rule view.
    * @return {string}
    *          The property value if it has previously been set by the user, null
    *          otherwise.
    */
-  getProperty: function UP_getProperty(aStyle, aName, aComputedValue) {
-    let entry = this.weakMap.get(aStyle, null);
+  getProperty: function(aStyle, aName, aDefault) {
+    let key = this.getKey(aStyle);
+    let entry = this.map.get(key, null);
 
     if (entry && aName in entry) {
       let item = entry[aName];
-      if (item.computed != aComputedValue) {
+      if (item != aDefault) {
         delete entry[aName];
-        return aComputedValue;
+        return aDefault;
       }
-
-      return item.user;
+      return item;
     }
-    return aComputedValue;
-
+    return aDefault;
   },
 
   /**
    * Set a named property for a given CSSStyleDeclaration.
    *
    * @param {CSSStyleDeclaration} aStyle
    *        The CSSStyleDeclaration against which the property is to be mapped.
    * @param {String} aName
    *        The name of the property to set.
-   * @param {String} aComputedValue
-   *        The computed property value.  The user value will not be used if the
-   *        computed value changes.
    * @param {String} aUserValue
    *        The value of the property to set.
    */
-  setProperty: function UP_setProperty(aStyle, aName, aComputedValue, aUserValue) {
-    let entry = this.weakMap.get(aStyle, null);
+  setProperty: function(aStyle, aName, aUserValue) {
+    let key = this.getKey(aStyle);
+    let entry = this.map.get(key, null);
     if (entry) {
-      entry[aName] = { computed: aComputedValue, user: aUserValue };
+      entry[aName] = aUserValue;
     } else {
       let props = {};
-      props[aName] = { computed: aComputedValue, user: aUserValue };
-      this.weakMap.set(aStyle, props);
+      props[aName] = aUserValue;
+      this.map.set(key, props);
     }
   },
 
   /**
    * Check whether a named property for a given CSSStyleDeclaration is stored.
    *
    * @param {CSSStyleDeclaration} aStyle
    *        The CSSStyleDeclaration against which the property would be mapped.
    * @param {String} aName
    *        The name of the property to check.
    */
-  contains: function UP_contains(aStyle, aName) {
-    let entry = this.weakMap.get(aStyle, null);
+  contains: function(aStyle, aName) {
+    let key = this.getKey(aStyle);
+    let entry = this.map.get(key, null);
     return !!entry && aName in entry;
   },
+
+  getKey: function(aStyle) {
+    return aStyle.href + ":" + aStyle.line;
+  },
 };
 
 /**
  * Helper functions
  */
 
 /**
  * Create a child element with a set of attributes.
diff --git a/browser/devtools/styleinspector/style-inspector.js b/browser/devtools/styleinspector/style-inspector.js
--- a/browser/devtools/styleinspector/style-inspector.js
+++ b/browser/devtools/styleinspector/style-inspector.js
@@ -20,17 +20,17 @@ loader.lazyGetter(this, "_strings", () =
 // registers inspector tools.
 
 function RuleViewTool(aInspector, aWindow, aIFrame)
 {
   this.inspector = aInspector;
   this.doc = aWindow.document;
   this.outerIFrame = aIFrame;
 
-  this.view = new RuleView.CssRuleView(this.doc, null);
+  this.view = new RuleView.CssRuleView(this.doc);
   this.doc.documentElement.appendChild(this.view.element);
 
   this._changeHandler = () => {
     this.inspector.markDirty();
   };
 
   this.view.element.addEventListener("CssRuleViewChanged", this._changeHandler);
 
@@ -259,9 +259,9 @@ ComputedViewTool.prototype = {
 
     delete this.outerIFrame;
     delete this.cssLogic;
     delete this.cssHtmlTree;
     delete this.window;
     delete this.document;
     delete this.inspector;
   }
-}
+};
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_ui.js b/browser/devtools/styleinspector/test/browser_ruleview_ui.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_ui.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_ui.js
@@ -7,35 +7,36 @@ let inspector;
 let ruleWindow;
 let ruleView;
 
 function startTest(aInspector, aRuleView)
 {
   inspector = aInspector;
   ruleWindow = aRuleView.doc.defaultView;
   ruleView = aRuleView;
-  let style = '' +
-    '#testid {' +
-    '  background-color: blue;' +
-    '} ' +
-    '.testclass, .unmatched {' +
-    '  background-color: green;' +
-    '}';
+  let style = "" +
+    "#testid {" +
+    "  background-color: blue;" +
+    "}" +
+    ".testclass, .unmatched {" +
+    "  background-color: green;" +
+    "}";
 
   let styleNode = addStyle(doc, style);
-  doc.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
+  doc.body.innerHTML = "<div id='testid' class='testclass'>Styled Node</div>" +
+                       "<div id='testid2'>Styled Node</div>";
 
   let testElement = doc.getElementById("testid");
   inspector.selection.setNode(testElement);
   inspector.once("inspector-updated", () => {
     is(ruleView.element.querySelectorAll("#noResults").length, 0, "After a highlight, no longer has a no-results element.");
     inspector.selection.setNode(null);
     inspector.once("inspector-updated", () => {
       is(ruleView.element.querySelectorAll("#noResults").length, 1, "After highlighting null, has a no-results element again.");
-      inspector.selection.setNode(testElement)
+      inspector.selection.setNode(testElement);
       inspector.once("inspector-updated", () => {
         let classEditor = ruleView.element.children[2]._ruleEditor;
         is(classEditor.selectorText.querySelector(".ruleview-selector-matched").textContent, ".testclass", ".textclass should be matched.");
         is(classEditor.selectorText.querySelector(".ruleview-selector-unmatched").textContent, ".unmatched", ".unmatched should not be matched.");
 
         testCancelNew();
       });
     });
@@ -45,17 +46,16 @@ function startTest(aInspector, aRuleView
 function testCancelNew()
 {
   // Start at the beginning: start to add a rule to the element's style
   // declaration, but leave it empty.
 
   let elementRuleEditor = ruleView.element.children[0]._ruleEditor;
   waitForEditorFocus(elementRuleEditor.element, function onNewElement(aEditor) {
     is(inplaceEditor(elementRuleEditor.newPropSpan), aEditor, "Next focused editor should be the new property editor.");
-    let input = aEditor.input;
     waitForEditorBlur(aEditor, function () {
       ok(!elementRuleEditor.rule._applyingModifications, "Shouldn't have an outstanding modification request after a cancel.");
       is(elementRuleEditor.rule.textProps.length,  0, "Should have canceled creating a new text property.");
       ok(!elementRuleEditor.propertyList.hasChildNodes(), "Should not have any properties.");
       testCreateNew();
     });
     aEditor.input.blur();
   });
@@ -132,17 +132,17 @@ function testEditProperty()
 
         ok(input.selectionStart === 0 && input.selectionEnd === input.value.length, "Editor contents are selected.");
 
         // Try clicking on the editor's input again, shouldn't cause trouble (see bug 761665).
         EventUtils.synthesizeMouse(input, 1, 1, { }, ruleWindow);
         input.select();
 
         waitForEditorBlur(aEditor, function() {
-          promiseDone(expectRuleChange(idRuleEditor.rule).then(() => {;
+          promiseDone(expectRuleChange(idRuleEditor.rule).then(() => {
             is(idRuleEditor.rule.style._rawStyle().getPropertyValue("border-color"), "red",
                "border-color should have been set.");
 
             let props = ruleView.element.querySelectorAll(".ruleview-property");
             for (let i = 0; i < props.length; i++) {
               is(props[i].hasAttribute("dirty"), i <= 1,
                 "props[" + i + "] marked dirty as appropriate");
             }
@@ -177,20 +177,39 @@ function testDisableProperty()
     is(idRuleEditor.rule.style._rawStyle().getPropertyValue("border-color"), "", "Border-color should have been unset.");
 
     propEditor.enable.click();
     return expectRuleChange(idRuleEditor.rule);
   }).then(() => {
     is(idRuleEditor.rule.style._rawStyle().getPropertyValue("border-color"), "red",
       "Border-color should have been reset.");
 
-    finishTest();
+    testPropertyStillMarkedDirty();
   }));
 }
 
+function testPropertyStillMarkedDirty() {
+  // Select an unstyled node.
+  let testElement = doc.getElementById("testid2");
+  inspector.selection.setNode(testElement);
+  inspector.once("inspector-updated", () => {
+    // Select the original node again.
+    testElement = doc.getElementById("testid");
+    inspector.selection.setNode(testElement);
+    inspector.once("inspector-updated", () => {
+      let props = ruleView.element.querySelectorAll(".ruleview-property");
+      for (let i = 0; i < props.length; i++) {
+        is(props[i].hasAttribute("dirty"), i <= 1,
+          "props[" + i + "] marked dirty as appropriate");
+      }
+      finishTest();
+    });
+  });
+}
+
 function finishTest()
 {
   inspector = ruleWindow = ruleView = null;
   doc = null;
   gBrowser.removeCurrentTab();
   finish();
 }
 
