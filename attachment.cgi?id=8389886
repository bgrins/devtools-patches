# HG changeset patch
# User Alexandre Poirot <poirot.alex@gmail.com>

Bug 977043 - Tweak TabActor to support changing its targeted context to an iframe r=bgrins

diff --git a/toolkit/devtools/client/dbg-client.jsm b/toolkit/devtools/client/dbg-client.jsm
index 6a12ecb..f74315a 100644
--- a/toolkit/devtools/client/dbg-client.jsm
+++ b/toolkit/devtools/client/dbg-client.jsm
@@ -197,16 +197,17 @@ const UnsolicitedNotifications = {
   "newGlobal": "newGlobal",
   "newScript": "newScript",
   "newSource": "newSource",
   "tabDetached": "tabDetached",
   "tabListChanged": "tabListChanged",
   "reflowActivity": "reflowActivity",
   "addonListChanged": "addonListChanged",
   "tabNavigated": "tabNavigated",
+  "tabDocShellUpdate": "tabDocShellUpdate",
   "pageError": "pageError",
   "documentLoad": "documentLoad",
   "enteredFrame": "enteredFrame",
   "exitedFrame": "exitedFrame",
   "appOpen": "appOpen",
   "appClose": "appClose",
   "appInstall": "appInstall",
   "appUninstall": "appUninstall"
diff --git a/toolkit/devtools/server/actors/childtab.js b/toolkit/devtools/server/actors/childtab.js
index ae7c651..b7db6c8 100644
--- a/toolkit/devtools/server/actors/childtab.js
+++ b/toolkit/devtools/server/actors/childtab.js
@@ -31,17 +31,17 @@ ContentActor.prototype = Object.create(TabActor.prototype);
 
 ContentActor.prototype.constructor = ContentActor;
 
 Object.defineProperty(ContentActor.prototype, "docShell", {
   get: function() {
     return this._chromeGlobal.docShell;
   },
   enumerable: true,
-  configurable: false
+  configurable: true
 });
 
 ContentActor.prototype.exit = function() {
   TabActor.prototype.exit.call(this);
   this._chromeGlobal = null;
 };
 
 // Override grip just to rename this._tabActorPool to this._tabActorPool2
diff --git a/toolkit/devtools/server/actors/webbrowser.js b/toolkit/devtools/server/actors/webbrowser.js
index c6560cd..00d40e6 100644
--- a/toolkit/devtools/server/actors/webbrowser.js
+++ b/toolkit/devtools/server/actors/webbrowser.js
@@ -666,19 +666,141 @@ TabActor.prototype = {
     // ... and a pool for context-lifetime actors.
     this._pushContext();
 
     // Watch for globals being created in this tab.
     this.chromeEventHandler.addEventListener("DOMWindowCreated", this._onWindowCreated, true);
     this.chromeEventHandler.addEventListener("pageshow", this._onWindowCreated, true);
     this._progressListener = new DebuggerProgressListener(this);
 
+    this._originalDocshell = this.webProgress;
+    this._originalWindow = this.window;
+
+    // Ensure replying to attach() request first
+    // before notifying about new docshells.
+    Services.tm.currentThread.dispatch(() => {
+      this._watchDocshells();
+    }, 0);
+
     this._attached = true;
   },
 
+  _watchDocshells: function BTA_watchDocshells() {
+    // In child processes, we watch all docshells living in the process.
+    if (Services.appinfo.processType == Services.appinfo.PROCESS_TYPE_CONTENT) {
+      Services.obs.addObserver(this, "webnavigation-create", false);
+    }
+    Services.obs.addObserver(this, "webnavigation-destroy", false);
+
+    // We watch for all child docshells under the current document,
+    this._progressListener.watch(this.webProgress);
+
+    // And list all already existing ones.
+    var containedDocShells = this.webProgress.getDocShellEnumerator(
+                               Ci.nsIDocShellTreeItem.typeAll,
+                               Ci.nsIDocShell.ENUMERATE_FORWARDS);
+    while (containedDocShells.hasMoreElements()) {
+      var childDocShell = containedDocShells.getNext();
+      childDocShell = childDocShell.QueryInterface(Ci.nsIInterfaceRequestor)
+                                   .getInterface(Ci.nsIWebProgress);
+
+      this._notifyDocShellUpdate(childDocShell);
+    }
+  },
+
+  onSwitchToDocShell: function BTA_onSwitchToDocShell(aRequest) {
+    let windowId = aRequest.windowId;
+    let win;
+    try {
+      win = Services.wm.getOuterWindowWithId(windowId);
+    } catch(e) {}
+    if (!win) {
+      return { error: "The related docshell is destroyed" };
+    }
+
+    // Wait a tick before starting switching the document
+    Services.tm.currentThread.dispatch(() => {
+      // Fake a "current document unload"
+      this._onLocationChangeStart(win.location.href);
+
+      // Wait a tick before faking a "current document changed"
+      Services.tm.currentThread.dispatch(() => {
+        this._onLocationChangeStop(win);
+      }, 0);
+    }, 0);
+
+    return {};
+  },
+
+  observe: function (aSubject, aTopic, aData) {
+    if (aTopic == "webnavigation-create") {
+      aSubject.QueryInterface(Ci.nsIDocShell);
+      // In child processes, we have new root docshells with no parent,
+      // let's watch them and all their child docshells.
+      if (!aSubject.parent) {
+        let webProgress = aSubject.QueryInterface(Ci.nsIInterfaceRequestor)
+                                  .getInterface(Ci.nsIWebProgress);
+        this._progressListener.watch(webProgress);
+      }
+      this._notifyDocShellUpdate(aSubject);
+    } else if (aTopic == "webnavigation-destroy") {
+      let webProgress = aSubject.QueryInterface(Ci.nsIInterfaceRequestor)
+                                .getInterface(Ci.nsIWebProgress);
+      let id = webProgress.DOMWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                          .getInterface(Ci.nsIDOMWindowUtils)
+                          .outerWindowID;
+      this._notifyDocShellDestroy(webProgress);
+    }
+  },
+
+  _notifyDocShellUpdate: function (webProgress) {
+    let window = webProgress.DOMWindow;
+    let id = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                   .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+    this.conn.send({ from: this.actorID,
+                     type: "tabDocShellUpdate",
+                     windowId: id,
+                     url: window.location.href,
+                     title: window.title
+                   });
+  },
+
+  _notifyDocShellDestroy: function (webProgress) {
+    let id = webProgress.DOMWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                        .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+    this.conn.send({ from: this.actorID,
+                     type: "tabDocShellUpdate",
+                     windowId: id,
+                     destroy: true
+                   });
+
+    // If the currently targeted context is destroyed,
+    // and we aren't on the top-level document,
+    // we have to switch to the top-level one.
+    if (webProgress.DOMWindow == this.window &&
+        this.window != this._originalWindow) {
+      this._onLocationChangeStart("");
+      this._onLocationChangeStop(this._originalWindow);
+    }
+
+    // Stop watching this docshell if that's a root one.
+    // (mostly for child processes)
+    webProgress.QueryInterface(Ci.nsIDocShell);
+    if (!webProgress.parent) {
+      this._progressListener.unwatch(webProgress);
+    }
+  },
+
+  _notifyDocShellDestroyAll: function () {
+    this.conn.send({ from: this.actorID,
+                     type: "tabDocShellUpdate",
+                     destroyAll: true
+                   });
+  },
+
   /**
    * Creates a thread actor and a pool for context-lifetime actors. It then sets
    * up the content window for debugging.
    */
   _pushContext: function BTA_pushContext() {
     dbg_assert(!this._contextPool, "Can't push multiple contexts");
 
     this._contextPool = new ActorPool(this.conn);
@@ -706,18 +828,25 @@ TabActor.prototype = {
    *
    * @returns false if the tab wasn't attached or true of detahing succeeds.
    */
   _detach: function BTA_detach() {
     if (!this.attached) {
       return false;
     }
 
+    this._progressListener.unwatch(this.webProgress);
     this._progressListener.destroy();
 
+    // Removes the observers being set in _watchDocShells
+    if (Services.appinfo.processType == Services.appinfo.PROCESS_TYPE_CONTENT) {
+      Services.obs.removeObserver(this, "webnavigation-create", false);
+    }
+    Services.obs.removeObserver(this, "webnavigation-destroy", false);
+
     this.chromeEventHandler.removeEventListener("DOMWindowCreated", this._onWindowCreated, true);
     this.chromeEventHandler.removeEventListener("pageshow", this._onWindowCreated, true);
 
     this._popContext();
 
     // Shut down actors that belong to this tab's pool.
     this.conn.removeActorPool(this._tabPool);
     this._tabPool = null;
@@ -924,20 +1053,30 @@ TabActor.prototype = {
     // Refresh the debuggee list when a new window object appears (top window or
     // iframe).
     if (this.threadActor.attached) {
       this.threadActor.findGlobals();
     }
   }, "TabActor.prototype.onWindowCreated"),
 
   /**
-   * Start notifying server codebase and client about a new document
+   * Start notifying server and client about a new document
    * being loaded in the currently targeted context.
    */
   _onLocationChangeStart: function (newURI) {
+    // We prevent dispatching multiple location changes at once
+    // especially when we are targeting an iframe and we are
+    // changing the top-level document.
+    // (the iframe docshell is destroyed during the top-level
+    // location change)
+    if (this._changingLocation) {
+      return;
+    }
+    this._changingLocation = true;
+
     this.threadActor.clearDebuggees();
     this.threadActor.disableAllBreakpoints();
 
     events.emit(this, "windowchange-start", this.window, true);
     this.conn.send({
       from: this.actorID,
       type: "tabNavigated",
       url: newURI,
@@ -945,18 +1084,28 @@ TabActor.prototype = {
       state: "start"
     });
   },
 
   /**
    * Notify server and client about a new document done loading in the current
    * targeted context.
    */
-  _onLocationChangeStop: function () {
+  _onLocationChangeStop: function (newWindow) {
+    this._changingLocation = false;
     let threadActor = this.threadActor;
+
+    let docShell = newWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                            .getInterface(Ci.nsIWebNavigation)
+                            .QueryInterface(Ci.nsIDocShell);
+    // Here is the very important call where we switch the currently
+    // targeted context.
+    Object.defineProperty(this, "docShell", { value: docShell, enumerable: true, configurable: true });
+    this._chromeEventHandler = docShell.chromeEventHandler;
+
     threadActor.global = this.window.wrappedJSObject ? this.window.wrappedJSObject : this.window;
     if (threadActor.attached) {
       threadActor.findGlobals();
     }
 
     if (threadActor.state == "running") {
       threadActor.dbg.enabled = true;
     }
@@ -991,17 +1140,18 @@ TabActor.prototype = {
 /**
  * The request types this actor can handle.
  */
 TabActor.prototype.requestTypes = {
   "attach": TabActor.prototype.onAttach,
   "detach": TabActor.prototype.onDetach,
   "reload": TabActor.prototype.onReload,
   "navigateTo": TabActor.prototype.onNavigateTo,
-  "reconfigure": TabActor.prototype.onReconfigure
+  "reconfigure": TabActor.prototype.onReconfigure,
+  "switchToDocShell": TabActor.prototype.onSwitchToDocShell
 };
 
 /**
  * Creates a tab actor for handling requests to a single in-process
  * <browser> tab. Most of the implementation comes from TabActor.
  *
  * @param aConnection DebuggerServerConnection
  *        The conection to the client.
@@ -1021,17 +1171,17 @@ BrowserTabActor.prototype = Object.create(TabActor.prototype);
 
 BrowserTabActor.prototype.constructor = BrowserTabActor;
 
 Object.defineProperty(BrowserTabActor.prototype, "docShell", {
   get: function() {
     return this._browser.docShell;
   },
   enumerable: true,
-  configurable: false
+  configurable: true
 });
 
 Object.defineProperty(BrowserTabActor.prototype, "title", {
   get: function() {
     let title = this.contentDocument.contentTitle;
     // If contentTitle is empty (e.g. on a not-yet-restored tab), but there is a
     // tabbrowser (i.e. desktop Firefox, but not Fennec), we can use the label
     // as the title.
@@ -1252,17 +1402,16 @@ BrowserAddonActor.prototype.requestTypes = {
  * navigate away from a paused page, the listener makes sure that the debuggee
  * is resumed before the navigation begins.
  *
  * @param TabActor aTabActor
  *        The tab actor associated with this listener.
  */
 function DebuggerProgressListener(aTabActor) {
   this._tabActor = aTabActor;
-  this.watch(this._tabActor.webProgress);
 }
 
 DebuggerProgressListener.prototype = {
   QueryInterface: XPCOMUtils.generateQI([
     Ci.nsIWebProgressListener,
     Ci.nsISupportsWeakReference,
     Ci.nsISupports,
   ]),
@@ -1290,19 +1439,29 @@ DebuggerProgressListener.prototype = {
     let isRequest = aFlag & Ci.nsIWebProgressListener.STATE_IS_REQUEST;
     let isWindow = aFlag & Ci.nsIWebProgressListener.STATE_IS_WINDOW;
 
     // Skip non-interesting states.
     if (!isWindow || !isNetwork) {
       return;
     }
 
+    // Catch any iframe location change
+    if (isStop) {
+      aProgress.QueryInterface(Ci.nsIDocShell);
+      this._tabActor._notifyDocShellUpdate(aProgress);
+    }
+
+    // Is it a request from the tab actor top level document?
+    // (i.e. the original document we attached to)
+    let isTopLevel = aProgress.DOMWindow == this._tabActor._originalWindow;
+
     // If the request isn't for the current actor document,
-    // we only dispatch 'windowchange' events.
-    if (aProgress.DOMWindow != this._tabActor.window) {
+    // nor the top level document, we only dispatch 'windowchange' events.
+    if (!isTopLevel && aProgress.DOMWindow != this._tabActor.window) {
       if (isStart) {
         events.emit(this._tabActor, "windowchange-start", aProgress.DOMWindow, false);
       }
       if (isStop) {
         events.emit(this._tabActor, "windowchange-stop", aProgress.DOMWindow, false);
       }
       return;
     }
@@ -1312,22 +1471,47 @@ DebuggerProgressListener.prototype = {
       if (this._tabActor.threadActor.state == "paused") {
         aRequest.suspend();
         this._tabActor.threadActor.onResume();
         this._tabActor.threadActor.dbg.enabled = false;
         this._tabActor._pendingNavigation = aRequest;
       }
 
       this._tabActor._onLocationChangeStart(aRequest.URI.spec);
+
+      // Clear the iframe list if the top-level document changes.
+      if (isTopLevel) {
+        this._tabActor._notifyDocShellDestroyAll();
+      }
     } else if (isStop) {
-      this._tabActor._onLocationChangeStop();
+      // If the top level document changes and we are targeting
+      // an iframe, we need to reset to the new top level document.
+      let resetToTopLevel =
+        isTopLevel && this._tabActor.window != this._tabActor._originalWindow;
+
+      this._tabActor._onLocationChangeStop(resetToTopLevel ?
+                                           this._tabActor._originalWindow :
+                                           this._tabActor.window);
+
+      // If we change the top level document, we just reseted the docshell list
+      // so we need to refresh it now
+      if (isTopLevel) {
+        var containedDocShells = aProgress.getDocShellEnumerator(
+                                   Ci.nsIDocShellTreeItem.typeAll,
+                                   Ci.nsIDocShell.ENUMERATE_FORWARDS);
+        while (containedDocShells.hasMoreElements()) {
+          var childDocShell = containedDocShells.getNext();
+          childDocShell = childDocShell.QueryInterface(Ci.nsIInterfaceRequestor)
+                                       .getInterface(Ci.nsIWebProgress);
+          this._tabActor._notifyDocShellUpdate(childDocShell);
+        }
+      }
     }
   }, "DebuggerProgressListener.prototype.onStateChange"),
 
   /**
    * Destroy the progress listener instance.
    */
   destroy: function DPL_destroy() {
-    this.unwatch(this._tabActor.webProgress);
     this._tabActor._progressListener = null;
     this._tabActor = null;
   }
 };
