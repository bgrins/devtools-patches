# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e6acf1da5ffad312a63b3e61a829e24526d84aee
Bug 1143224 - Test and optimizations for async added requests;r=jsantell

diff --git a/browser/devtools/netmonitor/netmonitor-controller.js b/browser/devtools/netmonitor/netmonitor-controller.js
--- a/browser/devtools/netmonitor/netmonitor-controller.js
+++ b/browser/devtools/netmonitor/netmonitor-controller.js
@@ -18,16 +18,19 @@ const EVENTS = {
   TARGET_WILL_NAVIGATE: "NetMonitor:TargetWillNavigate",
   TARGET_DID_NAVIGATE: "NetMonitor:TargetNavigate",
 
   // When a network event is received.
   // See https://developer.mozilla.org/docs/Tools/Web_Console/remoting for
   // more information about what each packet is supposed to deliver.
   NETWORK_EVENT: "NetMonitor:NetworkEvent",
 
+  // When a network event is added to the view
+  REQUEST_ADDED: "NetMonitor:RequestAdded",
+
   // When request headers begin and finish receiving.
   UPDATING_REQUEST_HEADERS: "NetMonitor:NetworkEventUpdating:RequestHeaders",
   RECEIVED_REQUEST_HEADERS: "NetMonitor:NetworkEventUpdated:RequestHeaders",
 
   // When request cookies begin and finish receiving.
   UPDATING_REQUEST_COOKIES: "NetMonitor:NetworkEventUpdating:RequestCookies",
   RECEIVED_REQUEST_COOKIES: "NetMonitor:NetworkEventUpdated:RequestCookies",
 
@@ -516,178 +519,184 @@ NetworkEventsHandler.prototype = {
    *        Message type.
    * @param object packet
    *        The message received from the server.
    * @param object networkInfo
    *        The network request information.
    */
   _onNetworkEventUpdate: function(type, { packet, networkInfo }) {
     let { actor, request: { url } } = networkInfo;
-
     switch (packet.updateType) {
       case "requestHeaders":
         this.webConsoleClient.getRequestHeaders(actor, this._onRequestHeaders);
-        window.emit(EVENTS.UPDATING_REQUEST_HEADERS, [actor, url]);
+        window.emit(EVENTS.UPDATING_REQUEST_HEADERS, actor);
         break;
       case "requestCookies":
         this.webConsoleClient.getRequestCookies(actor, this._onRequestCookies);
-        window.emit(EVENTS.UPDATING_REQUEST_COOKIES, [actor, url]);
+        window.emit(EVENTS.UPDATING_REQUEST_COOKIES, actor);
         break;
       case "requestPostData":
         this.webConsoleClient.getRequestPostData(actor, this._onRequestPostData);
-        window.emit(EVENTS.UPDATING_REQUEST_POST_DATA, [actor, url]);
+        window.emit(EVENTS.UPDATING_REQUEST_POST_DATA, actor);
         break;
       case "securityInfo":
         NetMonitorView.RequestsMenu.updateRequest(actor, {
           securityState: networkInfo.securityInfo,
         });
         this.webConsoleClient.getSecurityInfo(actor, this._onSecurityInfo);
-        window.emit(EVENTS.UPDATING_SECURITY_INFO, [actor, url]);
+        window.emit(EVENTS.UPDATING_SECURITY_INFO, actor);
         break;
       case "responseHeaders":
         this.webConsoleClient.getResponseHeaders(actor, this._onResponseHeaders);
-        window.emit(EVENTS.UPDATING_RESPONSE_HEADERS, [actor, url]);
+        window.emit(EVENTS.UPDATING_RESPONSE_HEADERS, actor);
         break;
       case "responseCookies":
         this.webConsoleClient.getResponseCookies(actor, this._onResponseCookies);
-        window.emit(EVENTS.UPDATING_RESPONSE_COOKIES, [actor, url]);
+        window.emit(EVENTS.UPDATING_RESPONSE_COOKIES, actor);
         break;
       case "responseStart":
         NetMonitorView.RequestsMenu.updateRequest(actor, {
           httpVersion: networkInfo.response.httpVersion,
           remoteAddress: networkInfo.response.remoteAddress,
           remotePort: networkInfo.response.remotePort,
           status: networkInfo.response.status,
           statusText: networkInfo.response.statusText,
           headersSize: networkInfo.response.headersSize
         });
-        window.emit(EVENTS.STARTED_RECEIVING_RESPONSE, [actor, url]);
+        window.emit(EVENTS.STARTED_RECEIVING_RESPONSE, actor);
         break;
       case "responseContent":
         NetMonitorView.RequestsMenu.updateRequest(actor, {
           contentSize: networkInfo.response.bodySize,
           transferredSize: networkInfo.response.transferredSize,
           mimeType: networkInfo.response.content.mimeType
         });
         this.webConsoleClient.getResponseContent(actor, this._onResponseContent);
-        window.emit(EVENTS.UPDATING_RESPONSE_CONTENT, [actor, url]);
+        window.emit(EVENTS.UPDATING_RESPONSE_CONTENT, actor);
         break;
       case "eventTimings":
         NetMonitorView.RequestsMenu.updateRequest(actor, {
           totalTime: networkInfo.totalTime
         });
         this.webConsoleClient.getEventTimings(actor, this._onEventTimings);
-        window.emit(EVENTS.UPDATING_EVENT_TIMINGS, [actor, url]);
+        window.emit(EVENTS.UPDATING_EVENT_TIMINGS, actor);
         break;
     }
   },
 
   /**
    * Handles additional information received for a "requestHeaders" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestHeaders: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       requestHeaders: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_REQUEST_HEADERS, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_REQUEST_HEADERS, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "requestCookies" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestCookies: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       requestCookies: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_REQUEST_COOKIES, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_REQUEST_COOKIES, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "requestPostData" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestPostData: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       requestPostData: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_REQUEST_POST_DATA, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_REQUEST_POST_DATA, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "securityInfo" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
    _onSecurityInfo: function(aResponse) {
      NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
        securityInfo: aResponse.securityInfo
+     }, () => {
+       window.emit(EVENTS.RECEIVED_SECURITY_INFO, aResponse.from);
      });
-
-     window.emit(EVENTS.RECEIVED_SECURITY_INFO, aResponse.from);
    },
 
   /**
    * Handles additional information received for a "responseHeaders" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onResponseHeaders: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       responseHeaders: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_RESPONSE_HEADERS, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_RESPONSE_HEADERS, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "responseCookies" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onResponseCookies: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       responseCookies: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_RESPONSE_COOKIES, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_RESPONSE_COOKIES, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "responseContent" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onResponseContent: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       responseContent: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_RESPONSE_CONTENT, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_RESPONSE_CONTENT, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "eventTimings" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onEventTimings: function(aResponse) {
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       eventTimings: aResponse
+    }, () => {
+      window.emit(EVENTS.RECEIVED_EVENT_TIMINGS, aResponse.from);
     });
-    window.emit(EVENTS.RECEIVED_EVENT_TIMINGS, aResponse.from);
   },
 
   /**
    * Fetches the full text of a LongString.
    *
    * @param object | string aStringGrip
    *        The long string grip containing the corresponding actor.
    *        If you pass in a plain string (by accident or because you're lazy),
diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -480,16 +480,18 @@ RequestsMenuView.prototype = Heritage.ex
     $("#toggle-raw-headers").removeEventListener("click", this.toggleRawHeadersEvent, false);
   },
 
   /**
    * Resets this container (removes all the networking information).
    */
   reset: function() {
     this.empty();
+    this._addQueue = [];
+    this._updateQueue = [];
     this._firstRequestStartedMillis = -1;
     this._lastRequestEndedMillis = -1;
   },
 
   /**
    * Specifies if this view may be updated lazily.
    */
   lazyUpdate: true,
@@ -1148,83 +1150,80 @@ RequestsMenuView.prototype = Heritage.ex
    * Schedules adding additional information to a network request.
    *
    * @param string aId
    *        An identifier coming from the network monitor controller.
    * @param object aData
    *        An object containing several { key: value } tuples of network info.
    *        Supported keys are "httpVersion", "status", "statusText" etc.
    */
-  updateRequest: function(aId, aData) {
+  updateRequest: function(aId, aData, aCallback) {
     // Prevent interference from zombie updates received after target closed.
     if (NetMonitorView._isDestroyed) {
       return;
     }
-    this._updateQueue.push([aId, aData]);
+    this._updateQueue.push([aId, aData, aCallback]);
 
     // Lazy updating is disabled in some tests.
     if (!this.lazyUpdate) {
       return void this._flushRequests();
     }
 
     this._flushRequestsTask.arm();
   },
 
   /**
    * Starts adding all queued additional information about network requests.
    */
   _flushRequests: function() {
-    for (let [aId, aStartedDateTime, aMethod, aUrl, aIsXHR, aFromCache] of this._addQueue) {
+    for (let [id, startedDateTime, method, url, isXHR, fromCache] of this._addQueue) {
       // Convert the received date/time string to a unix timestamp.
-      let unixTime = Date.parse(aStartedDateTime);
+      let unixTime = Date.parse(startedDateTime);
 
       // Create the element node for the network request item.
-      let menuView = this._createMenuView(aMethod, aUrl);
+      let menuView = this._createMenuView(method, url);
 
       // Remember the first and last event boundaries.
       this._registerFirstRequestStart(unixTime);
       this._registerLastRequestEnd(unixTime);
 
       // Append a network request item to this container.
-      let requestItem = this.push([menuView, aId], {
+      let requestItem = this.push([menuView, id], {
         attachment: {
           startedDeltaMillis: unixTime - this._firstRequestStartedMillis,
           startedMillis: unixTime,
-          method: aMethod,
-          url: aUrl,
-          isXHR: aIsXHR,
-          fromCache: aFromCache
+          method: method,
+          url: url,
+          isXHR: isXHR,
+          fromCache: fromCache
         }
       });
 
       // Create a tooltip for the newly appended network request item.
       let requestTooltip = requestItem.attachment.tooltip = new Tooltip(document, {
         closeOnEvents: [{
           emitter: $("#requests-menu-contents"),
           event: "scroll",
           useCapture: true
         }]
       });
 
-      $("#details-pane-toggle").disabled = false;
-      $("#requests-menu-empty-notice").hidden = true;
-
-      this.refreshSummary();
-      this.refreshZebra();
       this.refreshTooltip(requestItem);
 
-      if (aId == this._preferredItemId) {
+      if (id == this._preferredItemId) {
         this.selectedItem = requestItem;
       }
+
+      window.emit(EVENTS.REQUEST_ADDED, id);
     }
 
 
     // For each queued additional information packet, get the corresponding
     // request item in the view and update it based on the specified data.
-    for (let [id, data] of this._updateQueue) {
+    for (let [id, data, callback] of this._updateQueue) {
       let requestItem = this.getItemByValue(id);
       if (!requestItem) {
         // Packet corresponds to a dead request item, target navigated.
         continue;
       }
 
       // Each information packet may contain several { key: value } tuples of
       // network info, so update the view based on each one.
@@ -1347,16 +1346,20 @@ RequestsMenuView.prototype = Heritage.ex
             requestItem.attachment.eventTimings = value;
             this._createWaterfallView(
               requestItem, value.timings, requestItem.attachment.fromCache
             );
             break;
         }
       }
       refreshNetworkDetailsPaneIfNecessary(requestItem);
+
+      if (callback) {
+        callback();
+      }
     }
 
     /**
      * Refreshes the information displayed in the sidebar, in case this update
      * may have additional information about a request which isn't shown yet
      * in the network details pane.
      *
      * @param object aRequestItem
@@ -1369,16 +1372,19 @@ RequestsMenuView.prototype = Heritage.ex
         NetMonitorView.NetworkDetails.populate(selectedItem.attachment);
       }
     }
 
     // We're done flushing all the requests, clear the update queue.
     this._updateQueue = [];
     this._addQueue = [];
 
+    $("#details-pane-toggle").disabled = false;
+    $("#requests-menu-empty-notice").hidden = true;
+
     // Make sure all the requests are sorted and filtered.
     // Freshly added requests may not yet contain all the information required
     // for sorting and filtering predicates, so this is done each time the
     // network requests table is flushed (don't worry, events are drained first
     // so this doesn't happen once per network event update).
     this.sortContents();
     this.filterContents();
     this.refreshSummary();
@@ -1515,19 +1521,19 @@ RequestsMenuView.prototype = Heritage.ex
         let node = $(".requests-menu-type", target);
         let text = CONTENT_MIME_TYPE_ABBREVIATIONS[type] || type;
         node.setAttribute("value", text);
         node.setAttribute("tooltiptext", aValue);
         break;
       }
       case "responseContent": {
         let { mimeType } = aItem.attachment;
-        let { text, encoding } = aValue.content;
 
         if (mimeType.includes("image/")) {
+          let { text, encoding } = aValue.content;
           let responseBody = yield gNetwork.getString(text);
           let node = $(".requests-menu-icon", aItem.target);
           node.src = "data:" + mimeType + ";" + encoding + "," + responseBody;
           node.setAttribute("type", "thumbnail");
           node.removeAttribute("hidden");
 
           window.emit(EVENTS.RESPONSE_IMAGE_THUMBNAIL_DISPLAYED);
         }
diff --git a/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js b/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js
--- a/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js
+++ b/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js
@@ -90,16 +90,21 @@ let test = Task.async(function* () {
       waitForNetworkEvents(monitor, 0, 1) : waitForNetworkEvents(monitor, 1);
 
     info("Performing a request");
     debuggee.performRequests(1, uri);
 
     info("Waiting for NETWORK_EVENT");
     yield onNetworkEvent;
 
+    if (!RequestsMenu.getItemAtIndex(0)) {
+      info ("Waiting for the request to be added to the view")
+      yield monitor.panelWin.once(monitor.panelWin.EVENTS.REQUEST_ADDED);
+    }
+
     ok(true, "Received NETWORK_EVENT. Selecting the item.");
     let item = RequestsMenu.getItemAtIndex(0);
     RequestsMenu.selectedItem = item;
 
     info("Item selected. Waiting for NETWORKDETAILSVIEW_POPULATED");
     yield onDetailsPopulated;
 
     info("Received populated event. Selecting tab at index " + tabIndex);
diff --git a/browser/devtools/netmonitor/test/head.js b/browser/devtools/netmonitor/test/head.js
--- a/browser/devtools/netmonitor/test/head.js
+++ b/browser/devtools/netmonitor/test/head.js
@@ -192,16 +192,17 @@ function waitForNetworkEvents(aMonitor, 
   let deferred = promise.defer();
 
   let panel = aMonitor.panelWin;
   let events = panel.EVENTS;
 
   let progress = {};
   let genericEvents = 0;
   let postEvents = 0;
+  let addedToViews = new Set();
 
   let awaitedEventsToListeners = [
     ["UPDATING_REQUEST_HEADERS", onGenericEvent],
     ["RECEIVED_REQUEST_HEADERS", onGenericEvent],
     ["UPDATING_REQUEST_COOKIES", onGenericEvent],
     ["RECEIVED_REQUEST_COOKIES", onGenericEvent],
     ["UPDATING_REQUEST_POST_DATA", onPostEvent],
     ["RECEIVED_REQUEST_POST_DATA", onPostEvent],
@@ -232,36 +233,52 @@ function waitForNetworkEvents(aMonitor, 
     maybeResolve(event, actor);
   }
 
   function onPostEvent(event, actor) {
     postEvents++;
     maybeResolve(event, actor);
   }
 
-  function maybeResolve(event, [actor, url]) {
+  function onRequestAdded(event, actor) {
+    addedToViews.add(actor);
+  }
+
+  function maybeResolve(event, actor) {
+    if (panel.NetMonitorView.RequestsMenu.getItemByValue(actor)) {
+      addedToViews.add(actor);
+    }
+
     info("> Network events progress: " +
       genericEvents + "/" + ((aGetRequests + aPostRequests) * 13) + ", " +
       postEvents + "/" + (aPostRequests * 2) + ", " +
+      addedToViews.size + "/" + (aGetRequests + aPostRequests) + ", " +
       "got " + event + " for " + actor);
 
+    let networkInfo =
+      panel.NetMonitorController.webConsoleClient.getNetworkRequest(actor)
+    let url = networkInfo.request.url;
     updateProgressForURL(url, event);
+
     info("> Current state: " + JSON.stringify(progress, null, 2));
 
     // There are 15 updates which need to be fired for a request to be
     // considered finished. The "requestPostData" packet isn't fired for
     // non-POST requests.
-    if (genericEvents == (aGetRequests + aPostRequests) * 13 &&
-        postEvents == aPostRequests * 2) {
+    if (genericEvents >= (aGetRequests + aPostRequests) * 13 &&
+        postEvents >= aPostRequests * 2 &&
+        addedToViews.size >= aGetRequests + aPostRequests) {
 
       awaitedEventsToListeners.forEach(([e, l]) => panel.off(events[e], l));
+      panel.off(events.REQUEST_ADDED, onRequestAdded);
       executeSoon(deferred.resolve);
     }
   }
 
+  panel.on(events.REQUEST_ADDED, onRequestAdded);
   awaitedEventsToListeners.forEach(([e, l]) => panel.on(events[e], l));
   return deferred.promise;
 }
 
 function verifyRequestItemTarget(aRequestItem, aMethod, aUrl, aData = {}) {
   info("> Verifying: " + aMethod + " " + aUrl + " " + aData.toSource());
   // This bloats log sizes significantly in automation (bug 992485)
   //info("> Request: " + aRequestItem.attachment.toSource());
diff --git a/browser/devtools/webconsole/test/browser_netmonitor_shows_reqs_in_webconsole.js b/browser/devtools/webconsole/test/browser_netmonitor_shows_reqs_in_webconsole.js
--- a/browser/devtools/webconsole/test/browser_netmonitor_shows_reqs_in_webconsole.js
+++ b/browser/devtools/webconsole/test/browser_netmonitor_shows_reqs_in_webconsole.js
@@ -39,33 +39,35 @@ add_task(function* () {
     ]
   });
 
   // Test that the request appears in the network panel.
   let target = TargetFactory.forTab(tab);
   let toolbox = yield gDevTools.showToolbox(target, "netmonitor");
   info("Network panel is open.");
 
-  testNetmonitor(toolbox);
+  yield testNetmonitor(toolbox);
 });
 
 
 function loadDocument(browser) {
   let deferred = promise.defer();
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     deferred.resolve();
   }, true);
   content.location = TEST_PATH;
 
   return deferred.promise;
 }
 
-function testNetmonitor(toolbox) {
+function* testNetmonitor(toolbox) {
   let monitor = toolbox.getCurrentPanel();
   let { RequestsMenu } = monitor.panelWin.NetMonitorView;
+
+  yield monitor.panelWin.once(monitor.panelWin.EVENTS.REQUEST_ADDED);
   is(RequestsMenu.itemCount, 1, "Network request appears in the network panel");
 
   let item = RequestsMenu.getItemAtIndex(0);
   is(item.attachment.method, "GET", "The attached method is correct.");
   is(item.attachment.url, TEST_PATH, "The attached url is correct.");
 }
