# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  239b0664d4d98b3190eb7aa567ebd158dcab0690
Bug 1259603 - Use ConsoleEvents for cached messages and observing messages when webconsole actor is running

diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -556,21 +556,16 @@ WebConsoleActor.prototype =
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response object which holds the startedListeners array.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
   {
-    // XXXworkers: Not handling the Console API yet for workers (Bug 1209353).
-    if (isWorker) {
-       aRequest.listeners = [];
-    }
-
     let startedListeners = [];
     let window = !this.parentActor.isRootActor ? this.window : null;
     let appId = null;
     let messageManager = null;
 
     if (this._parentIsContentActor) {
       appId = this.parentActor.docShell.appId;
       messageManager = this.parentActor.messageManager;
@@ -591,16 +586,20 @@ WebConsoleActor.prototype =
           if (!this.consoleAPIListener) {
             this.consoleAPIListener =
               new ConsoleAPIListener(window, this);
             this.consoleAPIListener.init();
           }
           startedListeners.push(listener);
           break;
         case "NetworkActivity":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (!this.networkMonitor) {
             if (appId || messageManager) {
               // Start a network monitor in the parent process to listen to
               // most requests than happen in parent
               this.networkMonitor =
                 new NetworkMonitorChild(appId, messageManager,
                                         this.parentActor.actorID, this);
               this.networkMonitor.init();
@@ -612,34 +611,46 @@ WebConsoleActor.prototype =
             else {
               this.networkMonitor = new NetworkMonitor({ window: window }, this);
               this.networkMonitor.init();
             }
           }
           startedListeners.push(listener);
           break;
         case "FileActivity":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (this.window instanceof Ci.nsIDOMWindow) {
             if (!this.consoleProgressListener) {
               this.consoleProgressListener =
                 new ConsoleProgressListener(this.window, this);
             }
             this.consoleProgressListener.startMonitor(this.consoleProgressListener.
                                                       MONITOR_FILE_ACTIVITY);
             startedListeners.push(listener);
           }
           break;
         case "ReflowActivity":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (!this.consoleReflowListener) {
             this.consoleReflowListener =
               new ConsoleReflowListener(this.window, this);
           }
           startedListeners.push(listener);
           break;
         case "ServerLogging":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (!this.serverLoggingListener) {
             this.serverLoggingListener =
               new ServerLoggingListener(this.window, this);
           }
           startedListeners.push(listener);
           break;
       }
     }
@@ -1414,16 +1425,17 @@ WebConsoleActor.prototype =
    * This method sends the object to the remote Web Console client.
    *
    * @see ConsoleAPIListener
    * @param object aMessage
    *        The console API call we need to send to the remote client.
    */
   onConsoleAPICall: function WCA_onConsoleAPICall(aMessage)
   {
+    dump("doing a console API call: " + this.actorID + "\n\n")
     let packet = {
       from: this.actorID,
       type: "consoleAPICall",
       message: this.prepareConsoleMessageForRemote(aMessage),
     };
     this.conn.send(packet);
   },
 
diff --git a/devtools/shared/client/main.js b/devtools/shared/client/main.js
--- a/devtools/shared/client/main.js
+++ b/devtools/shared/client/main.js
@@ -939,24 +939,27 @@ DebuggerClient.prototype = {
 
   /**
    * Called by DebuggerTransport to dispatch incoming packets as appropriate.
    *
    * @param aPacket object
    *        The incoming packet.
    */
   onPacket: function (aPacket) {
+    dump("Message received: " + JSON.stringify(aPacket) + "\n\n");
+
     if (!aPacket.from) {
       DevToolsUtils.reportException(
         "onPacket",
         new Error("Server did not specify an actor, dropping packet: " +
                   JSON.stringify(aPacket)));
       return;
     }
 
+
     // If we have a registered Front for this actor, let it handle the packet
     // and skip all the rest of this unpleasantness.
     let front = this.getActor(aPacket.from);
     if (front) {
       front.onPacket(aPacket);
       return;
     }
 
diff --git a/devtools/shared/webconsole/test/chrome.ini b/devtools/shared/webconsole/test/chrome.ini
--- a/devtools/shared/webconsole/test/chrome.ini
+++ b/devtools/shared/webconsole/test/chrome.ini
@@ -15,16 +15,17 @@ support-files =
 [test_cached_messages.html]
 [test_commands_other.html]
 [test_commands_registration.html]
 [test_consoleapi.html]
 [test_consoleapi_innerID.html]
 [test_console_serviceworker.html]
 [test_console_serviceworker_cached.html]
 [test_console_styling.html]
+[test_console_worker.html]
 [test_file_uri.html]
 [test_reflow.html]
 [test_jsterm.html]
 [test_jsterm_autocomplete.html]
 [test_jsterm_cd_iframe.html]
 [test_jsterm_last_result.html]
 [test_jsterm_queryselector.html]
 [test_network_get.html]
diff --git a/devtools/shared/webconsole/test/console-test-worker.js b/devtools/shared/webconsole/test/console-test-worker.js
--- a/devtools/shared/webconsole/test/console-test-worker.js
+++ b/devtools/shared/webconsole/test/console-test-worker.js
@@ -1,10 +1,11 @@
 "use strict";
 
+console.log("Log from worker init")
 function f() {
   var a = 1;
   var b = 2;
   var c = 3;
 }
 
 self.onmessage = function (event) {
   if (event.data == "ping") {
diff --git a/devtools/shared/webconsole/test/test_console_worker.html b/devtools/shared/webconsole/test/test_console_worker.html
new file mode 100644
--- /dev/null
+++ b/devtools/shared/webconsole/test/test_console_worker.html
@@ -0,0 +1,74 @@
+<!DOCTYPE HTML>
+<html lang="en">
+<head>
+  <meta charset="utf8">
+  <title>Test for the Console API and Workers</title>
+  <script type="text/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript;version=1.8" src="common.js"></script>
+  <!-- Any copyright is dedicated to the Public Domain.
+     - http://creativecommons.org/publicdomain/zero/1.0/ -->
+</head>
+<body>
+<p>Test for the Console API and Workers</p>
+
+<script class="testbody" type="text/javascript;version=1.8">
+SimpleTest.waitForExplicitFinish();
+
+let expectedCachedConsoleCalls = [
+    {
+      level: "log",
+      filename: /console-test-worker/,
+      arguments: ['Log from worker init'],
+    },
+];
+let consoleCalls = [];
+
+let startTest = Task.async(function*() {
+  removeEventListener("load", startTest);
+  attachConsoleToWorker(["ConsoleAPI"], onAttach);
+});
+addEventListener("load", startTest);
+
+let onAttach = Task.async(function*(state, response) {
+  onCachedConsoleAPI = onCachedConsoleAPI.bind(null, state)
+  aState.client.getCachedMessages(["ConsoleAPI"], onCachedConsoleAPI);
+
+  // onConsoleAPICall = onConsoleAPICall.bind(null, state);
+  // state.dbgClient.addListener("consoleAPICall", onConsoleAPICall);
+});
+
+function onCachedConsoleAPI(state, type, packet) {
+  info("received message level: " + packet.message.level);
+  is(packet.from, state.actor, "console API call actor");
+  consoleCalls.push(packet.message);
+  if (consoleCalls.length != expectedCachedConsoleCalls.length) {
+    return;
+  }
+
+  info('Checking console calls.');
+  checkConsoleAPICalls(consoleCalls, expectedCachedConsoleCalls);
+  consoleCalls = [];
+  closeDebugger(state, function() {
+    SimpleTest.finish();
+  });
+}
+
+function onConsoleAPICall(state, type, packet) {
+  info("received message level: " + packet.message.level);
+  is(packet.from, state.actor, "console API call actor");
+  consoleCalls.push(packet.message);
+  if (consoleCalls.length != expectedConsoleCalls.length) {
+    return;
+  }
+
+  info('Checking console calls.');
+  state.dbgClient.removeListener("consoleAPICall", onConsoleAPICall);
+  checkConsoleAPICalls(consoleCalls, expectedConsoleCalls);
+  consoleCalls = [];
+  closeDebugger(state, function() {
+    SimpleTest.finish();
+  });
+}
+</script>
+</body>
+</html>
diff --git a/devtools/shared/webconsole/worker-utils.js b/devtools/shared/webconsole/worker-utils.js
--- a/devtools/shared/webconsole/worker-utils.js
+++ b/devtools/shared/webconsole/worker-utils.js
@@ -7,14 +7,104 @@
 "use strict";
 
 // XXXworkers This file is loaded on the server side for worker debugging.
 // Since the server is running in the worker thread, it doesn't
 // have access to Services / Components.  This functionality
 // is stubbed out to prevent errors, and will need to implemented
 // for Bug 1209353.
 
-exports.Utils = { L10n: function() {} };
-exports.ConsoleServiceListener = function() {};
-exports.ConsoleAPIListener = function() {};
+const CONSOLE_WORKER_IDS = exports.CONSOLE_WORKER_IDS = [];
+
+// XXX: Share utils in a single file between worker and non and have custom
+// files for listeners
+exports.Utils = {
+  L10n: function() {},
+  cloneObject: function(object, recursive, filter) {
+    if (typeof object != "object") {
+      return object;
+    }
+
+    let temp;
+
+    if (Array.isArray(object)) {
+      temp = [];
+      Array.forEach(object, function(value, index) {
+        if (!filter || filter(index, value, object)) {
+          temp.push(recursive ? WebConsoleUtils.cloneObject(value) : value);
+        }
+      });
+    } else {
+      temp = {};
+      for (let key in object) {
+        let value = object[key];
+        if (object.hasOwnProperty(key) &&
+            (!filter || filter(key, value, object))) {
+          temp[key] = recursive ? WebConsoleUtils.cloneObject(value) : value;
+        }
+      }
+    }
+
+    return temp;
+  },
+  getWorkerType: function(message) {
+    let id = message ? message.innerID : null;
+    return CONSOLE_WORKER_IDS[CONSOLE_WORKER_IDS.indexOf(id)] || null;
+  },
+ };
+
+function ConsoleServiceListener(window, listener) {
+  this.window = window;
+  this.listener = listener;
+}
+ConsoleServiceListener.prototype =
+{
+  init: function() {
+    dump("\n\n\nConsoleServiceListener.init\n\n\n");
+  },
+  destroy: function() {
+    dump("\n\n\nConsoleServiceListener.destroy\n\n\n");
+  },
+  observe: function(message) {
+    dump("\n\n\nConsoleServiceListener.observe\n\n\n");
+  },
+  getCachedMessages: function() {
+    dump("\n\n\nConsoleServiceListener.getCachedMessages\n\n\n");
+    return [];
+  }
+};
+
+function ConsoleAPIListener(window, owner, consoleID) {
+  this.window = window;
+  this.owner = owner;
+  this.consoleID = consoleID;
+}
+
+ConsoleAPIListener.prototype =
+{
+  init: function() {
+    dump("\n\n\nConsoleAPIListener.init\n\n\n");
+    this.observe = this.observe.bind(this);
+    setConsoleEventHandler(this.observe);
+  },
+  destroy: function() {
+    dump("\n\n\nConsoleAPIListener.destroy\n\n\n");
+    // XXX: How do we clear out the console event handler?
+    setConsoleEventHandler(() => {})
+    // setConsoleEventHandler(null);
+  },
+  observe: function(message) {
+    dump("\n\n\nConsoleAPIListener.observe\n\n\n");
+    dump("\n\n\n message: "+JSON.stringify(Object.keys(message))+"\n\n\n");
+    dump("\n\n\n args: "+JSON.stringify(message.arguments)+"\n\n\n");
+    this.owner.onConsoleAPICall(message.wrappedJSObject);
+  },
+  getCachedMessages: function() {
+    dump("\n\n\nConsoleAPIListener.getCachedMessages\n\n\n");
+    return retrieveConsoleEvents();
+  }
+};
+
+exports.ConsoleAPIListener = ConsoleAPIListener;
+exports.ConsoleServiceListener = ConsoleServiceListener;
+
 exports.addWebConsoleCommands = function() {};
 exports.ConsoleReflowListener = function() {};
-exports.CONSOLE_WORKER_IDS = [];
diff --git a/devtools/shared/worker/loader.js b/devtools/shared/worker/loader.js
--- a/devtools/shared/worker/loader.js
+++ b/devtools/shared/worker/loader.js
@@ -368,17 +368,17 @@ var {
   Debugger,
   URL,
   createSandbox,
   dump,
   rpc,
   loadSubScript,
   reportError,
   setImmediate,
-  xpcInspector
+  xpcInspector,
 } = (function () {
   if (typeof Components === "object") { // Main thread
     let {
       Constructor: CC,
       classes: Cc,
       manager: Cm,
       interfaces: Ci,
       results: Cr,
@@ -485,17 +485,19 @@ var {
 this.worker = new WorkerDebuggerLoader({
   createSandbox: createSandbox,
   globals: {
     "isWorker": true,
     "dump": dump,
     "loader": loader,
     "reportError": reportError,
     "rpc": rpc,
-    "setImmediate": setImmediate
+    "setImmediate": setImmediate,
+    "retrieveConsoleEvents": this.retrieveConsoleEvents,
+    "setConsoleEventHandler": this.setConsoleEventHandler,
   },
   loadSubScript: loadSubScript,
   modules: {
     "Debugger": Debugger,
     "PromiseDebugging": PromiseDebugging,
     "Services": Object.create(null),
     "URL": URL,
     "chrome": chrome,
