# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5e287404e4f8fd81330cd704e42fba5e3baa5f49
Bug 1259603 - Use ConsoleEvents for cached messages and observing messages when webconsole actor is running

diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -556,21 +556,16 @@ WebConsoleActor.prototype =
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response object which holds the startedListeners array.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
   {
-    // XXXworkers: Not handling the Console API yet for workers (Bug 1209353).
-    if (isWorker) {
-       aRequest.listeners = [];
-    }
-
     let startedListeners = [];
     let window = !this.parentActor.isRootActor ? this.window : null;
     let appId = null;
     let messageManager = null;
 
     if (this._parentIsContentActor) {
       appId = this.parentActor.docShell.appId;
       messageManager = this.parentActor.messageManager;
@@ -591,16 +586,20 @@ WebConsoleActor.prototype =
           if (!this.consoleAPIListener) {
             this.consoleAPIListener =
               new ConsoleAPIListener(window, this);
             this.consoleAPIListener.init();
           }
           startedListeners.push(listener);
           break;
         case "NetworkActivity":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (!this.networkMonitor) {
             if (appId || messageManager) {
               // Start a network monitor in the parent process to listen to
               // most requests than happen in parent
               this.networkMonitor =
                 new NetworkMonitorChild(appId, messageManager,
                                         this.parentActor.actorID, this);
               this.networkMonitor.init();
@@ -612,34 +611,46 @@ WebConsoleActor.prototype =
             else {
               this.networkMonitor = new NetworkMonitor({ window: window }, this);
               this.networkMonitor.init();
             }
           }
           startedListeners.push(listener);
           break;
         case "FileActivity":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (this.window instanceof Ci.nsIDOMWindow) {
             if (!this.consoleProgressListener) {
               this.consoleProgressListener =
                 new ConsoleProgressListener(this.window, this);
             }
             this.consoleProgressListener.startMonitor(this.consoleProgressListener.
                                                       MONITOR_FILE_ACTIVITY);
             startedListeners.push(listener);
           }
           break;
         case "ReflowActivity":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (!this.consoleReflowListener) {
             this.consoleReflowListener =
               new ConsoleReflowListener(this.window, this);
           }
           startedListeners.push(listener);
           break;
         case "ServerLogging":
+          // XXXworkers not supporting this message type for now
+          if (isWorker) {
+            break;
+          }
           if (!this.serverLoggingListener) {
             this.serverLoggingListener =
               new ServerLoggingListener(this.window, this);
           }
           startedListeners.push(listener);
           break;
       }
     }
@@ -1413,16 +1424,17 @@ WebConsoleActor.prototype =
    * This method sends the object to the remote Web Console client.
    *
    * @see ConsoleAPIListener
    * @param object aMessage
    *        The console API call we need to send to the remote client.
    */
   onConsoleAPICall: function WCA_onConsoleAPICall(aMessage)
   {
+    dump("doing a console API call: " + this.actorID + "\n\n")
     let packet = {
       from: this.actorID,
       type: "consoleAPICall",
       message: this.prepareConsoleMessageForRemote(aMessage),
     };
     this.conn.send(packet);
   },
 
diff --git a/devtools/shared/client/main.js b/devtools/shared/client/main.js
--- a/devtools/shared/client/main.js
+++ b/devtools/shared/client/main.js
@@ -939,24 +939,27 @@ DebuggerClient.prototype = {
 
   /**
    * Called by DebuggerTransport to dispatch incoming packets as appropriate.
    *
    * @param aPacket object
    *        The incoming packet.
    */
   onPacket: function (aPacket) {
+    dump("Message received: " + JSON.stringify(aPacket) + "\n\n");
+
     if (!aPacket.from) {
       DevToolsUtils.reportException(
         "onPacket",
         new Error("Server did not specify an actor, dropping packet: " +
                   JSON.stringify(aPacket)));
       return;
     }
 
+
     // If we have a registered Front for this actor, let it handle the packet
     // and skip all the rest of this unpleasantness.
     let front = this.getActor(aPacket.from);
     if (front) {
       front.onPacket(aPacket);
       return;
     }
 
diff --git a/devtools/shared/webconsole/worker-utils.js b/devtools/shared/webconsole/worker-utils.js
--- a/devtools/shared/webconsole/worker-utils.js
+++ b/devtools/shared/webconsole/worker-utils.js
@@ -7,14 +7,104 @@
 "use strict";
 
 // XXXworkers This file is loaded on the server side for worker debugging.
 // Since the server is running in the worker thread, it doesn't
 // have access to Services / Components.  This functionality
 // is stubbed out to prevent errors, and will need to implemented
 // for Bug 1209353.
 
-exports.Utils = { L10n: function() {} };
-exports.ConsoleServiceListener = function() {};
-exports.ConsoleAPIListener = function() {};
+const CONSOLE_WORKER_IDS = exports.CONSOLE_WORKER_IDS = [];
+
+// XXX: Share utils in a single file between worker and non and have custom
+// files for listeners
+exports.Utils = {
+  L10n: function() {},
+  cloneObject: function(object, recursive, filter) {
+    if (typeof object != "object") {
+      return object;
+    }
+
+    let temp;
+
+    if (Array.isArray(object)) {
+      temp = [];
+      Array.forEach(object, function(value, index) {
+        if (!filter || filter(index, value, object)) {
+          temp.push(recursive ? WebConsoleUtils.cloneObject(value) : value);
+        }
+      });
+    } else {
+      temp = {};
+      for (let key in object) {
+        let value = object[key];
+        if (object.hasOwnProperty(key) &&
+            (!filter || filter(key, value, object))) {
+          temp[key] = recursive ? WebConsoleUtils.cloneObject(value) : value;
+        }
+      }
+    }
+
+    return temp;
+  },
+  getWorkerType: function(message) {
+    let id = message ? message.innerID : null;
+    return CONSOLE_WORKER_IDS[CONSOLE_WORKER_IDS.indexOf(id)] || null;
+  },
+ };
+
+function ConsoleServiceListener(window, listener) {
+  this.window = window;
+  this.listener = listener;
+}
+ConsoleServiceListener.prototype =
+{
+  init: function() {
+    dump("\n\n\nConsoleServiceListener.init\n\n\n");
+  },
+  destroy: function() {
+    dump("\n\n\nConsoleServiceListener.destroy\n\n\n");
+  },
+  observe: function(message) {
+    dump("\n\n\nConsoleServiceListener.observe\n\n\n");
+  },
+  getCachedMessages: function() {
+    dump("\n\n\nConsoleServiceListener.getCachedMessages\n\n\n");
+    return [];
+  }
+};
+
+function ConsoleAPIListener(window, owner, consoleID) {
+  this.window = window;
+  this.owner = owner;
+  this.consoleID = consoleID;
+}
+
+ConsoleAPIListener.prototype =
+{
+  init: function() {
+    dump("\n\n\nConsoleAPIListener.init\n\n\n");
+    this.observe = this.observe.bind(this);
+    setConsoleEventHandler(this.observe);
+  },
+  destroy: function() {
+    dump("\n\n\nConsoleAPIListener.destroy\n\n\n");
+    // XXX: How do we clear out the console event handler?
+    setConsoleEventHandler(() => {})
+    // setConsoleEventHandler(null);
+  },
+  observe: function(message) {
+    dump("\n\n\nConsoleAPIListener.observe\n\n\n");
+    dump("\n\n\n message: "+JSON.stringify(Object.keys(message))+"\n\n\n");
+    dump("\n\n\n args: "+JSON.stringify(message.arguments)+"\n\n\n");
+    this.owner.onConsoleAPICall(message.wrappedJSObject);
+  },
+  getCachedMessages: function() {
+    dump("\n\n\nConsoleAPIListener.getCachedMessages\n\n\n");
+    return retrieveConsoleEvents();
+  }
+};
+
+exports.ConsoleAPIListener = ConsoleAPIListener;
+exports.ConsoleServiceListener = ConsoleServiceListener;
+
 exports.addWebConsoleCommands = function() {};
 exports.ConsoleReflowListener = function() {};
-exports.CONSOLE_WORKER_IDS = [];
diff --git a/devtools/shared/worker/loader.js b/devtools/shared/worker/loader.js
--- a/devtools/shared/worker/loader.js
+++ b/devtools/shared/worker/loader.js
@@ -368,17 +368,17 @@ var {
   Debugger,
   URL,
   createSandbox,
   dump,
   rpc,
   loadSubScript,
   reportError,
   setImmediate,
-  xpcInspector
+  xpcInspector,
 } = (function () {
   if (typeof Components === "object") { // Main thread
     let {
       Constructor: CC,
       classes: Cc,
       manager: Cm,
       interfaces: Ci,
       results: Cr,
@@ -485,17 +485,19 @@ var {
 this.worker = new WorkerDebuggerLoader({
   createSandbox: createSandbox,
   globals: {
     "isWorker": true,
     "dump": dump,
     "loader": loader,
     "reportError": reportError,
     "rpc": rpc,
-    "setImmediate": setImmediate
+    "setImmediate": setImmediate,
+    "retrieveConsoleEvents": this.retrieveConsoleEvents,
+    "setConsoleEventHandler": this.setConsoleEventHandler,
   },
   loadSubScript: loadSubScript,
   modules: {
     "Debugger": Debugger,
     "PromiseDebugging": PromiseDebugging,
     "Services": Object.create(null),
     "URL": URL,
     "chrome": chrome,
