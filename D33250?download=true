diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -526,7 +526,7 @@
 }
 
 #urlbar,
-.searchbar-textbox {
+#searchbar {
   /* Setting a width and min-width to let the location & search bars maintain
      a constant width in case they haven't be resized manually. (bug 965772) */
   width: 1px;
diff --git a/browser/components/places/content/bookmarkProperties.xul b/browser/components/places/content/bookmarkProperties.xul
--- a/browser/components/places/content/bookmarkProperties.xul
+++ b/browser/components/places/content/bookmarkProperties.xul
@@ -18,6 +18,7 @@
         buttons="accept, cancel"
         buttoniconaccept="save"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml"
         onload="BookmarkPropertiesPanel.onDialogLoad();"
         onunload="BookmarkPropertiesPanel.onDialogUnload();"
         style="min-width: 30em;"
diff --git a/browser/components/places/content/editBookmarkPanel.inc.xul b/browser/components/places/content/editBookmarkPanel.inc.xul
--- a/browser/components/places/content/editBookmarkPanel.inc.xul
+++ b/browser/components/places/content/editBookmarkPanel.inc.xul
@@ -73,9 +73,9 @@
              accesskey="&editBookmarkOverlay.tags.accesskey;"
              control="editBMPanel_tagsField"/>
       <hbox flex="1" align="center">
-        <textbox id="editBMPanel_tagsField"
-                 type="autocomplete"
-                 flex="1"
+        <html:input id="editBMPanel_tagsField"
+                 is="autocomplete-input"
+                 style="-moz-box-flex: 1;"
                  autocompletesearch="places-tag-autocomplete"
                  autocompletepopup="PopupAutoComplete"
                  completedefaultindex="true"
diff --git a/browser/components/preferences/in-content/home.xul b/browser/components/preferences/in-content/home.xul
--- a/browser/components/preferences/in-content/home.xul
+++ b/browser/components/preferences/in-content/home.xul
@@ -44,11 +44,13 @@
       </menulist>
 
       <vbox id="customSettings" hidden="true">
-        <textbox id="homePageUrl"
+        <html:input id="homePageUrl"
+                type="text"
                 class="uri-element check-home-page-controlled"
                 data-preference-related="browser.startup.homepage"
-                type="autocomplete"
+                is="autocomplete-input"
                 data-l10n-id="home-homepage-custom-url"
+                autocompletepopup="PopupAutoComplete"
                 autocompletesearch="unifiedcomplete" />
         <hbox class="homepage-buttons">
           <button id="useCurrentBtn"
diff --git a/browser/components/search/content/autocomplete-popup.js b/browser/components/search/content/autocomplete-popup.js
--- a/browser/components/search/content/autocomplete-popup.js
+++ b/browser/components/search/content/autocomplete-popup.js
@@ -19,7 +19,7 @@
       // the width of the textfield.
       let DOMUtils = window.windowUtils;
       let textboxRect = DOMUtils.getBoundsWithoutFlushing(this.mInput);
-      let inputRect = DOMUtils.getBoundsWithoutFlushing(this.mInput.inputField);
+      let inputRect = DOMUtils.getBoundsWithoutFlushing(this.mInput);
 
       // Ensure the panel is wide enough to fit at least 3 engines.
       let minWidth = Math.max(textboxRect.width,
diff --git a/browser/components/search/content/searchbar.js b/browser/components/search/content/searchbar.js
--- a/browser/components/search/content/searchbar.js
+++ b/browser/components/search/content/searchbar.js
@@ -47,7 +47,7 @@
         <image class="searchbar-search-icon"></image>
         <image class="searchbar-search-icon-overlay"></image>
       </hbox>
-      <textbox class="searchbar-textbox" type="autocomplete" inputtype="search" placeholder="&searchInput.placeholder;" flex="1" autocompletepopup="PopupSearchAutoComplete" autocompletesearch="search-autocomplete" autocompletesearchparam="searchbar-history" maxrows="10" completeselectedindex="true" minresultsforpopup="0"/>
+      <html:input class="searchbar-textbox" is="autocomplete-input" type="search" placeholder="&searchInput.placeholder;" autocompletepopup="PopupSearchAutoComplete" autocompletesearch="search-autocomplete" autocompletesearchparam="searchbar-history" maxrows="10" completeselectedindex="true" minresultsforpopup="0"/>
       <hbox class="search-go-container">
         <image class="search-go-button urlbar-icon" hidden="true" onclick="handleSearchCommand(event);" tooltiptext="&contentSearchSubmit.tooltip;"></image>
       </hbox>
@@ -161,7 +161,7 @@
     // Also make sure the textbox has ever been constructed, otherwise the
     // _textbox getter will cause the textbox constructor to run, add an
     // observer, and leak the world too.
-    if (this._textbox.mController && this._textbox.mController.input == this) {
+    if (this._textbox.mController && this._textbox.mController.input == this.nsIAutocompleteInput) {
       this._textbox.mController.input = null;
     }
 
@@ -553,18 +553,18 @@
       return;
     }
 
+    // XXX(ntim): port this too
     if (Services.prefs.getBoolPref("browser.urlbar.clickSelectsAll")) {
       this.textbox.setAttribute("clickSelectsAll", true);
     }
 
-    let inputBox = document.getAnonymousElementByAttribute(this.textbox,
-      "anonid", "moz-input-box");
+    // let inputBox = document.getAnonymousElementByAttribute(this.textbox,
+    //   "anonid", "moz-input-box");
 
-    // Force the Custom Element to upgrade until Bug 1470242 handles this:
-    window.customElements.upgrade(inputBox);
-    let cxmenu = inputBox.menupopup;
-    cxmenu.addEventListener("popupshowing",
-      () => { this._initContextMenu(cxmenu); }, { capture: true, once: true });
+    // XXX(ntim): Fix this
+    // let cxmenu = inputBox.menupopup;
+    // cxmenu.addEventListener("popupshowing",
+    //   () => { this._initContextMenu(cxmenu); }, { capture: true, once: true });
 
     this.textbox.setAttribute("aria-owns", this.textbox.popup.id);
 
diff --git a/browser/themes/osx/browser.css b/browser/themes/osx/browser.css
--- a/browser/themes/osx/browser.css
+++ b/browser/themes/osx/browser.css
@@ -383,7 +383,7 @@
 %include ../shared/places/editBookmarkPanel.inc.css
 
 #editBookmarkPanelRows > vbox > textbox,
-#editBookmarkPanelRows > vbox > hbox > textbox {
+#editBookmarkPanelRows > vbox > hbox > html|input {
   -moz-appearance: none;
   background-color: var(--arrowpanel-field-background);
   color: inherit;
@@ -394,7 +394,7 @@
 }
 
 #editBookmarkPanelRows > vbox > textbox[focused="true"],
-#editBookmarkPanelRows > vbox > hbox > textbox[focused="true"] {
+#editBookmarkPanelRows > vbox > hbox > html|input:focus {
   border-color: -moz-mac-focusring !important;
   box-shadow: var(--focus-ring-box-shadow);
 }
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -42,8 +42,11 @@
 
 .searchbar-textbox {
   -moz-appearance: none;
+  -moz-box-flex: 1;
   background: none;
   color: inherit;
+  border: none;
+  font: inherit;
   margin: 0;
 }
 
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -518,6 +518,7 @@
 };
 
 const MozXULElement = MozElements.MozElementMixin(XULElement);
+const MozHTMLElement = MozElements.MozElementMixin(HTMLElement);
 
 /**
  * Given an object, add a proxy that reflects interface implementations
@@ -635,6 +636,7 @@
 
 // Attach the base class to the window so other scripts can use it:
 window.MozXULElement = MozXULElement;
+window.MozHTMLElement = MozHTMLElement;
 
 customElements.setElementCreationCallback("browser", () => {
   Services.scriptloader.loadSubScript("chrome://global/content/elements/browser-custom-element.js", window);
@@ -671,6 +673,7 @@
     ["findbar", "chrome://global/content/elements/findbar.js"],
     ["menulist", "chrome://global/content/elements/menulist.js"],
     ["search-textbox", "chrome://global/content/elements/search-textbox.js"],
+    ["autocomplete-input", "chrome://global/content/elements/autocomplete-input.js"],
     ["stringbundle", "chrome://global/content/elements/stringbundle.js"],
     ["printpreview-toolbar", "chrome://global/content/printPreviewToolbar.js"],
     ["editor", "chrome://global/content/elements/editor.js"],
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -61,7 +61,6 @@
    content/global/viewZoomOverlay.js
 #endif
    content/global/widgets.css
-   content/global/bindings/autocomplete.xml    (widgets/autocomplete.xml)
    content/global/bindings/calendar.js         (widgets/calendar.js)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
@@ -76,6 +75,7 @@
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/wizard.xml          (widgets/wizard.xml)
+   content/global/elements/autocomplete-input.js              (widgets/autocomplete-input.js)
    content/global/elements/autocomplete-popup.js              (widgets/autocomplete-popup.js)
    content/global/elements/autocomplete-richlistitem.js       (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete-input.js
rename from toolkit/content/widgets/autocomplete.xml
rename to toolkit/content/widgets/autocomplete-input.js
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete-input.js
@@ -1,1225 +1,651 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<bindings id="autocompleteBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:html="http://www.w3.org/1999/xhtml"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:xbl="http://www.mozilla.org/xbl">
-
-  <binding id="autocomplete"
-           extends="chrome://global/content/bindings/textbox.xml#textbox">
-    <content sizetopopup="pref">
-      <xul:moz-input-box anonid="moz-input-box" flex="1">
-        <html:input anonid="input" class="textbox-input"
-                    allowevents="true"
-                    autocomplete="off"
-                    xbl:inherits="value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint"/>
-      </xul:moz-input-box>
-      <xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
-    </content>
-
-    <implementation implements="nsIAutoCompleteInput, nsIDOMXULMenuListElement">
-      <field name="mController">null</field>
-      <field name="mSearchNames">null</field>
-      <field name="mIgnoreInput">false</field>
-      <field name="noRollupOnEmptySearch">false</field>
-
-      <field name="_searchBeginHandler">null</field>
-      <field name="_searchCompleteHandler">null</field>
-      <field name="_textEnteredHandler">null</field>
-      <field name="_textRevertedHandler">null</field>
-
-      <constructor><![CDATA[
-        this.mController = Cc["@mozilla.org/autocomplete/controller;1"].
-          getService(Ci.nsIAutoCompleteController);
-
-        this._searchBeginHandler = this.initEventHandler("searchbegin");
-        this._searchCompleteHandler = this.initEventHandler("searchcomplete");
-        this._textEnteredHandler = this.initEventHandler("textentered");
-        this._textRevertedHandler = this.initEventHandler("textreverted");
-      ]]></constructor>
-
-      <!-- =================== nsIAutoCompleteInput =================== -->
-
-      <field name="_popup">null</field>
-      <property name="popup" readonly="true">
-        <getter><![CDATA[
-          // Memoize the result in a field rather than replacing this property,
-          // so that it can be reset along with the binding.
-          if (this._popup) {
-            return this._popup;
-          }
-
-          let popup = null;
-          let popupId = this.getAttribute("autocompletepopup");
-          if (popupId) {
-            popup = document.getElementById(popupId);
-          }
-          if (!popup) {
-            popup = document.createXULElement("panel", { is: "autocomplete-richlistbox-popup" });
-            popup.setAttribute("type", "autocomplete-richlistbox");
-            popup.setAttribute("noautofocus", "true");
-
-            let popupset = document.getAnonymousElementByAttribute(this, "anonid", "popupset");
-            popupset.appendChild(popup);
-          }
-          popup.mInput = this;
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-          return this._popup = popup;
-        ]]></getter>
-      </property>
-      <property name="popupElement" readonly="true"
-                onget="return this.popup;"/>
-
-      <property name="controller" onget="return this.mController;" readonly="true"/>
-
-      <property name="popupOpen"
-                onget="return this.popup.popupOpen;"
-                onset="if (val) this.openPopup(); else this.closePopup();"/>
-
-      <property name="disableAutoComplete"
-                onset="this.setAttribute('disableautocomplete', val); return val;"
-                onget="return this.getAttribute('disableautocomplete') == 'true';"/>
-
-      <property name="completeDefaultIndex"
-                onset="this.setAttribute('completedefaultindex', val); return val;"
-                onget="return this.getAttribute('completedefaultindex') == 'true';"/>
-
-      <property name="completeSelectedIndex"
-                onset="this.setAttribute('completeselectedindex', val); return val;"
-                onget="return this.getAttribute('completeselectedindex') == 'true';"/>
-
-      <property name="forceComplete"
-                onset="this.setAttribute('forcecomplete', val); return val;"
-                onget="return this.getAttribute('forcecomplete') == 'true';"/>
-
-      <property name="minResultsForPopup"
-                onset="this.setAttribute('minresultsforpopup', val); return val;"
-                onget="var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;"/>
-
-      <property name="timeout"
-                onset="this.setAttribute('timeout', val); return val;"
-                onget="var t = parseInt(this.getAttribute('timeout')); return isNaN(t) ? 50 : t;"/>
+"use strict";
 
-      <property name="searchParam"
-                onget="return this.getAttribute('autocompletesearchparam') || '';"
-                onset="this.setAttribute('autocompletesearchparam', val); return val;"/>
-
-      <property name="searchCount" readonly="true"
-                onget="this.initSearchNames(); return this.mSearchNames.length;"/>
-
-      <property name="PrivateBrowsingUtils" readonly="true">
-        <getter><![CDATA[
-          let module = {};
-          ChromeUtils.import("resource://gre/modules/PrivateBrowsingUtils.jsm", module);
-          Object.defineProperty(this, "PrivateBrowsingUtils", {
-            configurable: true,
-            enumerable: true,
-            writable: true,
-            value: module.PrivateBrowsingUtils,
-          });
-          return module.PrivateBrowsingUtils;
-        ]]></getter>
-      </property>
-
-      <property name="inPrivateContext" readonly="true"
-                onget="return this.PrivateBrowsingUtils.isWindowPrivate(window);"/>
-
-      <property name="noRollupOnCaretMove" readonly="true"
-                onget="return this.popup.getAttribute('norolluponanchor') == 'true'"/>
-
-      <!-- This is the maximum number of drop-down rows we get when we
-            hit the drop marker beside fields that have it (like the URLbar).-->
-      <field name="maxDropMarkerRows" readonly="true">14</field>
-
-      <method name="getSearchAt">
-        <parameter name="aIndex"/>
-        <body><![CDATA[
-          this.initSearchNames();
-          return this.mSearchNames[aIndex];
-        ]]></body>
-      </method>
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
 
-      <method name="setTextValueWithReason">
-        <parameter name="aValue"/>
-        <parameter name="aReason"/>
-        <body><![CDATA[
-          if (aReason == Ci.nsIAutoCompleteInput
-                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {
-            this._textValueSetByCompleteDefault = true;
-          }
-          this.textValue = aValue;
-          this._textValueSetByCompleteDefault = false;
-        ]]></body>
-      </method>
-
-      <property name="textValue">
-        <getter><![CDATA[
-          if (typeof this.onBeforeTextValueGet == "function") {
-            let result = this.onBeforeTextValueGet();
-            if (result) {
-              return result.value;
-            }
-          }
-          return this.value;
-        ]]></getter>
-        <setter><![CDATA[
-          if (typeof this.onBeforeTextValueSet == "function" &&
-              !this._textValueSetByCompleteDefault) {
-            val = this.onBeforeTextValueSet(val);
-          }
-
-          // "input" event is automatically dispatched by the editor if
-          // necessary.
-          this._setValueInternal(val, true);
-
-          return this.value;
-        ]]></setter>
-      </property>
-
-      <method name="selectTextRange">
-        <parameter name="aStartIndex"/>
-        <parameter name="aEndIndex"/>
-        <body><![CDATA[
-          this.inputField.setSelectionRange(aStartIndex, aEndIndex);
-        ]]></body>
-      </method>
-
-      <method name="onSearchBegin">
-        <body><![CDATA[
-          if (this.popup && typeof this.popup.onSearchBegin == "function")
-            this.popup.onSearchBegin();
-          if (this._searchBeginHandler)
-            this._searchBeginHandler();
-        ]]></body>
-      </method>
-
-      <method name="onSearchComplete">
-        <body><![CDATA[
-          if (this.mController.matchCount == 0)
-            this.setAttribute("nomatch", "true");
-          else
-            this.removeAttribute("nomatch");
-
-          if (this.ignoreBlurWhileSearching && !this.focused) {
-            this.handleEnter();
-            this.detachController();
-          }
-
-          if (this._searchCompleteHandler)
-            this._searchCompleteHandler();
-        ]]></body>
-      </method>
+class AutocompleteInput extends HTMLInputElement {
+  constructor() {
+    super();
 
-      <method name="onTextEntered">
-        <parameter name="event"/>
-        <body><![CDATA[
-          let rv = false;
-          if (this._textEnteredHandler) {
-            rv = this._textEnteredHandler(event);
-          }
-          return rv;
-        ]]></body>
-      </method>
-
-      <method name="onTextReverted">
-        <body><![CDATA[
-          if (this._textRevertedHandler)
-            return this._textRevertedHandler();
-          return false;
-        ]]></body>
-      </method>
-
-      <!-- =================== nsIDOMXULMenuListElement =================== -->
-
-      <property name="editable" readonly="true"
-                onget="return true;" />
-
-      <property name="crop"
-                onset="this.setAttribute('crop',val); return val;"
-                onget="return this.getAttribute('crop');"/>
-
-      <property name="open"
-                onget="return this.getAttribute('open') == 'true';">
-        <setter><![CDATA[
-          if (val)
-            this.showHistoryPopup();
-          else
-            this.closePopup();
-        ]]></setter>
-      </property>
-
-      <!-- =================== PUBLIC MEMBERS =================== -->
+    this.addEventListener("input", (event) => {
+      this.onInput(event);
+    });
 
-      <field name="valueIsTyped">false</field>
-      <field name="_textValueSetByCompleteDefault">false</field>
-      <property name="value"
-                onset="return this._setValueInternal(val, false);">
-        <getter><![CDATA[
-          if (typeof this.onBeforeValueGet == "function") {
-            var result = this.onBeforeValueGet();
-            if (result)
-              return result.value;
-          }
-          return this.inputField.value;
-        ]]></getter>
-      </property>
-
-      <property name="focused" readonly="true"
-                onget="return this.getAttribute('focused') == 'true';"/>
-
-      <!-- maximum number of rows to display at a time -->
-      <property name="maxRows"
-                onset="this.setAttribute('maxrows', val); return val;"
-                onget="return parseInt(this.getAttribute('maxrows')) || 0;"/>
-
-      <!-- option to allow scrolling through the list via the tab key, rather than
-           tab moving focus out of the textbox -->
-      <property name="tabScrolling"
-                onset="this.setAttribute('tabscrolling', val); return val;"
-                onget="return this.getAttribute('tabscrolling') == 'true';"/>
-
-      <!-- option to completely ignore any blur events while searches are
-           still going on. -->
-      <property name="ignoreBlurWhileSearching"
-                onset="this.setAttribute('ignoreblurwhilesearching', val); return val;"
-                onget="return this.getAttribute('ignoreblurwhilesearching') == 'true';"/>
-
-      <!-- option to highlight entries that don't have any matches -->
-      <property name="highlightNonMatches"
-                onset="this.setAttribute('highlightnonmatches', val); return val;"
-                onget="return this.getAttribute('highlightnonmatches') == 'true';"/>
-
-      <!-- =================== PRIVATE MEMBERS =================== -->
-
-      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->
-
-      <method name="attachController">
-        <body><![CDATA[
-          this.mController.input = this;
-        ]]></body>
-      </method>
+    this.addEventListener("keypress", (event) => {
+      return this.onKeyPress(event);
+    }, { capture: true, mozSystemGroup: true });
 
-      <method name="detachController">
-        <body><![CDATA[
-          if (this.mController.input == this)
-            this.mController.input = null;
-        ]]></body>
-      </method>
-
-      <!-- ::::::::::::: popup opening ::::::::::::: -->
-
-      <method name="openPopup">
-        <body><![CDATA[
-          if (this.focused)
-            this.popup.openAutocompletePopup(this, this);
-        ]]></body>
-      </method>
-
-      <method name="closePopup">
-        <body><![CDATA[
-          this.popup.closePopup();
-        ]]></body>
-      </method>
-
-      <method name="showHistoryPopup">
-        <body><![CDATA[
-          // Store our "normal" maxRows on the popup, so that it can reset the
-          // value when the popup is hidden.
-          this.popup._normalMaxRows = this.maxRows;
-
-          // Increase our maxRows temporarily, since we want the dropdown to
-          // be bigger in this case. The popup's popupshowing/popuphiding
-          // handlers will take care of resetting this.
-          this.maxRows = this.maxDropMarkerRows;
-
-          // Ensure that we have focus.
-          if (!this.focused)
-            this.focus();
-          this.attachController();
-          this.mController.startSearch("");
-        ]]></body>
-      </method>
-
-      <method name="toggleHistoryPopup">
-        <body><![CDATA[
-          if (!this.popup.popupOpen)
-            this.showHistoryPopup();
-          else
-            this.closePopup();
-        ]]></body>
-      </method>
-
-      <!-- ::::::::::::: event dispatching ::::::::::::: -->
-
-      <method name="initEventHandler">
-        <parameter name="aEventType"/>
-        <body><![CDATA[
-          let handlerString = this.getAttribute("on" + aEventType);
-          if (handlerString) {
-            return (new Function("eventType", "param", handlerString)).bind(this, aEventType);
-          }
-          return null;
-        ]]></body>
-      </method>
-
-      <!-- ::::::::::::: key handling ::::::::::::: -->
+    this.addEventListener("compositionstart", (event) => {
+      if (this.mController.input == this.nsIAutocompleteInput) {
+        this.mController.handleStartComposition();
+      }
+    }, true);
 
-      <field name="_selectionDetails">null</field>
-      <method name="onKeyPress">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          return this.handleKeyPress(aEvent);
-        ]]></body>
-      </method>
-
-      <method name="handleKeyPress">
-        <parameter name="aEvent"/>
-        <parameter name="aOptions"/>
-        <body><![CDATA[
-          if (aEvent.target.localName != "textbox")
-            return true; // Let child buttons of autocomplete take input
-
-          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.
-          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {
-            return false;
-          }
-
-          const isMac = /Mac/.test(navigator.platform);
-          var cancel = false;
-
-          // Catch any keys that could potentially move the caret. Ctrl can be
-          // used in combination with these keys on Windows and Linux; and Alt
-          // can be used on OS X, so make sure the unused one isn't used.
-          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;
-          if (!metaKey) {
-            switch (aEvent.keyCode) {
-              case KeyEvent.DOM_VK_LEFT:
-              case KeyEvent.DOM_VK_RIGHT:
-              case KeyEvent.DOM_VK_HOME:
-                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);
-                break;
-            }
-          }
-
-          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)
-          if (!aEvent.ctrlKey && !aEvent.altKey) {
-            switch (aEvent.keyCode) {
-              case KeyEvent.DOM_VK_TAB:
-                if (this.tabScrolling && this.popup.popupOpen)
-                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?
-                                                                KeyEvent.DOM_VK_UP :
-                                                                KeyEvent.DOM_VK_DOWN);
-                else if (this.forceComplete && this.mController.matchCount >= 1)
-                  this.mController.handleTab();
-                break;
-              case KeyEvent.DOM_VK_UP:
-              case KeyEvent.DOM_VK_DOWN:
-              case KeyEvent.DOM_VK_PAGE_UP:
-              case KeyEvent.DOM_VK_PAGE_DOWN:
-                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);
-                break;
-            }
-          }
-
-          // Handle readline/emacs-style navigation bindings on Mac.
-          if (isMac &&
-              this.popup.popupOpen &&
-              aEvent.ctrlKey &&
-              (aEvent.key === "n" || aEvent.key === "p")) {
-            const effectiveKey = (aEvent.key === "p") ?
-                                 KeyEvent.DOM_VK_UP :
-                                 KeyEvent.DOM_VK_DOWN;
-            cancel = this.mController.handleKeyNavigation(effectiveKey);
-          }
+    this.addEventListener("compositionend", (event) => {
+      if (this.mController.input == this.nsIAutocompleteInput) {
+        this.mController.handleEndComposition();
+      }
+    }, true);
 
-          // Handle keys we know aren't part of a shortcut, even with Alt or
-          // Ctrl.
-          switch (aEvent.keyCode) {
-            case KeyEvent.DOM_VK_ESCAPE:
-              cancel = this.mController.handleEscape();
-              break;
-            case KeyEvent.DOM_VK_RETURN:
-              if (isMac) {
-                // Prevent the default action, since it will beep on Mac
-                if (aEvent.metaKey)
-                  aEvent.preventDefault();
-              }
-              if (this.popup.selectedIndex >= 0) {
-                this._selectionDetails = {
-                  index: this.popup.selectedIndex,
-                  kind: "key",
-                };
-              }
-              cancel = this.handleEnter(aEvent, aOptions);
-              break;
-            case KeyEvent.DOM_VK_DELETE:
-              if (isMac && !aEvent.shiftKey) {
-                break;
-              }
-              cancel = this.handleDelete();
-              break;
-            case KeyEvent.DOM_VK_BACK_SPACE:
-              if (isMac && aEvent.shiftKey) {
-                cancel = this.handleDelete();
-              }
-              break;
-            case KeyEvent.DOM_VK_DOWN:
-            case KeyEvent.DOM_VK_UP:
-              if (aEvent.altKey)
-                this.toggleHistoryPopup();
-              break;
-            case KeyEvent.DOM_VK_F4:
-              if (!isMac) {
-                this.toggleHistoryPopup();
-              }
-              break;
-          }
-
-          if (cancel) {
-            aEvent.stopPropagation();
-            aEvent.preventDefault();
-          }
-
-          return true;
-        ]]></body>
-      </method>
-
-      <method name="handleEnter">
-        <parameter name="event"/>
-        <body><![CDATA[
-          return this.mController.handleEnter(false, event || null);
-        ]]></body>
-      </method>
-
-      <method name="handleDelete">
-        <body><![CDATA[
-          return this.mController.handleDelete();
-        ]]></body>
-      </method>
-
-      <!-- ::::::::::::: miscellaneous ::::::::::::: -->
-
-      <method name="initSearchNames">
-        <body><![CDATA[
-          if (!this.mSearchNames) {
-            var names = this.getAttribute("autocompletesearch");
-            if (!names)
-              this.mSearchNames = [];
-            else
-              this.mSearchNames = names.split(" ");
-          }
-        ]]></body>
-      </method>
+    this.addEventListener("focus", (event) => {
+      this.attachController();
+      if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute("usercontextid")) {
+        this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute("usercontextid"));
+      } else {
+        this.userContextId = 0;
+      }
+    }, true);
 
-      <method name="_focus">
-        <!-- doesn't reset this.mController -->
-        <body><![CDATA[
-          this._dontBlur = true;
-          this.focus();
-          this._dontBlur = false;
-        ]]></body>
-      </method>
-
-      <method name="resetActionType">
-        <body><![CDATA[
-          if (this.mIgnoreInput)
-            return;
-          this.removeAttribute("actiontype");
-        ]]></body>
-      </method>
-
-      <method name="_setValueInternal">
-        <parameter name="aValue"/>
-        <parameter name="aIsUserInput"/>
-        <body><![CDATA[
-          this.mIgnoreInput = true;
-
-          if (typeof this.onBeforeValueSet == "function")
-            aValue = this.onBeforeValueSet(aValue);
-
-          if (typeof this.trimValue == "function" &&
-              !this._textValueSetByCompleteDefault)
-            aValue = this.trimValue(aValue);
-
-          this.valueIsTyped = false;
-          if (aIsUserInput) {
-            this.inputField.setUserInput(aValue);
-          } else {
-            this.inputField.value = aValue;
-          }
-
-          if (typeof this.formatValue == "function")
-            this.formatValue();
-
-          this.mIgnoreInput = false;
-          var event = document.createEvent("Events");
-          event.initEvent("ValueChange", true, true);
-          this.inputField.dispatchEvent(event);
-          return aValue;
-        ]]></body>
-      </method>
-
-      <method name="onInput">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          if (!this.mIgnoreInput && this.mController.input == this) {
-            this.valueIsTyped = true;
-            this.mController.handleText();
-          }
-          this.resetActionType();
-        ]]></body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <handler event="input"><![CDATA[
-        this.onInput(event);
-      ]]></handler>
-
-      <handler event="keypress" phase="capturing" group="system"
-               action="return this.onKeyPress(event);"/>
-
-      <handler event="compositionstart" phase="capturing"
-               action="if (this.mController.input == this) this.mController.handleStartComposition();"/>
-
-      <handler event="compositionend" phase="capturing"
-               action="if (this.mController.input == this) this.mController.handleEndComposition();"/>
-
-      <handler event="focus" phase="capturing"><![CDATA[
-        this.attachController();
-        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute("usercontextid")) {
-          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute("usercontextid"));
-        } else {
-          this.userContextId = 0;
-        }
-      ]]></handler>
-
-      <handler event="blur" phase="capturing"><![CDATA[
-        if (!this._dontBlur) {
-          if (this.forceComplete && this.mController.matchCount >= 1) {
-            // If forceComplete is requested, we need to call the enter processing
-            // on blur so the input will be forced to the closest match.
-            // Thunderbird is the only consumer of forceComplete and this is used
-            // to force an recipient's email to the exact address book entry.
-            this.mController.handleEnter(true);
-          }
-          if (!this.ignoreBlurWhileSearching)
-            this.detachController();
+    this.addEventListener("blur", (event) => {
+      if (!this._dontBlur) {
+        if (this.forceComplete && this.mController.matchCount >= 1) {
+          // If forceComplete is requested, we need to call the enter processing
+          // on blur so the input will be forced to the closest match.
+          // Thunderbird is the only consumer of forceComplete and this is used
+          // to force an recipient's email to the exact address book entry.
+          this.mController.handleEnter(true);
         }
-      ]]></handler>
-    </handlers>
-  </binding>
+        if (!this.ignoreBlurWhileSearching)
+          this.detachController();
+      }
+    }, true);
+  }
 
-  <binding id="autocomplete-rich-result-popup">
-    <content ignorekeys="true" level="top" consumeoutsideclicks="never">
-      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox" flex="1"/>
-      <xul:hbox>
-        <children/>
-      </xul:hbox>
-    </content>
+  connectedCallback() {
+    this.setAttribute("autocomplete", "off");
+    this.setAttribute("allowevents", "true");
 
-    <implementation implements="nsIAutoCompletePopup">
-      <field name="mInput">null</field>
-      <field name="mPopupOpen">false</field>
-      <field name="_currentIndex">0</field>
+    this.mController = Cc["@mozilla.org/autocomplete/controller;1"]
+      .getService(Ci.nsIAutoCompleteController);
+    this.mSearchNames = null;
+    this.mIgnoreInput = false;
+    this.noRollupOnEmptySearch = false;
+    this._searchBeginHandler = null;
+    this._searchCompleteHandler = null;
+    this._textEnteredHandler = null;
+    this._textRevertedHandler = null;
 
-      <constructor><![CDATA[
-        if (!this.listEvents) {
-          this.listEvents = {
-            handleEvent: event => {
-              if (!this.parentNode) {
-                return;
-              }
+    /**
+     * =================== nsIAutoCompleteInput ===================
+     */
+    this._popup = null;
+
+    /**
+     * This is the maximum number of drop-down rows we get when we
+     * hit the drop marker beside fields that have it (like the URLbar).
+     */
+    this.maxDropMarkerRows = 14;
+
+    this.nsIAutocompleteInput = this.getCustomInterfaceCallback(Ci.nsIAutoCompleteInput);
 
-              switch (event.type) {
-                case "mouseup":
-                  // Don't call onPopupClick for the scrollbar buttons, thumb,
-                  // slider, etc. If we hit the richlistbox and not a
-                  // richlistitem, we ignore the event.
-                  if (event.target.closest("richlistbox,richlistitem")
-                                  .localName == "richlistitem") {
-                    this.onPopupClick(event);
-                  }
-                  break;
-                case "mousemove":
-                  if (Date.now() - this.mLastMoveTime <= 30) {
-                    return;
-                  }
+    /**
+     * =================== PUBLIC MEMBERS ===================
+     */
+    this.valueIsTyped = false;
+    this._textValueSetByCompleteDefault = false;
 
-                  let item = event.target.closest("richlistbox,richlistitem");
+    /**
+     * ::::::::::::: key handling :::::::::::::
+     */
+    this._selectionDetails = null;
+
+    this._searchBeginHandler = this.initEventHandler("searchbegin");
+    this._searchCompleteHandler = this.initEventHandler("searchcomplete");
+    this._textEnteredHandler = this.initEventHandler("textentered");
+    this._textRevertedHandler = this.initEventHandler("textreverted");
+  }
 
-                  // If we hit the richlistbox and not a richlistitem, we ignore
-                  // the event.
-                  if (item.localName == "richlistbox") {
-                    return;
-                  }
-
-                  let index = this.richlistbox.getIndexOfItem(item);
-
-                  this.mousedOverIndex = index;
+  get popup() {
+    // Memoize the result in a field rather than replacing this property,
+    // so that it can be reset along with the binding.
+    if (this._popup) {
+      return this._popup;
+    }
 
-                  if (item.selectedByMouseOver) {
-                    this.richlistbox.selectedIndex = index;
-                  }
+    let popup = null;
+    let popupId = this.getAttribute("autocompletepopup");
+    if (popupId) {
+      popup = document.getElementById(popupId);
+    }
+    if (!popup) {
+      popup = document.createXULElement("panel", { is: "autocomplete-richlistbox-popup" });
+      popup.setAttribute("type", "autocomplete-richlistbox");
+      popup.setAttribute("noautofocus", "true");
 
-                  this.mLastMoveTime = Date.now();
-                  break;
-              }
-            },
-          };
-          this.richlistbox.addEventListener("mouseup", this.listEvents);
-          this.richlistbox.addEventListener("mousemove", this.listEvents);
-        }
-      ]]></constructor>
+      if (!this._popupset) {
+        this._popupset = document.createXULElement("popupset");
+        document.documentElement.appendChild(this._popupset);
+      }
 
-      <destructor><![CDATA[
-        if (this.listEvents) {
-          this.richlistbox.removeEventListener("mouseup", this.listEvents);
-          this.richlistbox.removeEventListener("mousemove", this.listEvents);
-          delete this.listEvents;
-        }
-      ]]></destructor>
+      this._popupset.appendChild(popup);
+    }
+    popup.mInput = this;
+
+    return this._popup = popup;
+  }
 
-      <!-- =================== nsIAutoCompletePopup =================== -->
+  get popupElement() {
+    return this.popup;
+  }
 
-      <property name="input" readonly="true"
-                onget="return this.mInput"/>
-
-      <property name="overrideValue" readonly="true"
-                onget="return null;"/>
+  get controller() {
+    return this.mController;
+  }
 
-      <property name="popupOpen" readonly="true"
-                onget="return this.mPopupOpen;"/>
+  set popupOpen(val) {
+    if (val) this.openPopup();
+    else this.closePopup();
+  }
+
+  get popupOpen() {
+    return this.popup.popupOpen;
+  }
 
-      <method name="closePopup">
-        <body>
-          <![CDATA[
-          if (this.mPopupOpen) {
-            this.hidePopup();
-            this.removeAttribute("width");
-          }
-        ]]>
-        </body>
-      </method>
+  set disableAutoComplete(val) {
+    this.setAttribute("disableautocomplete", val);
+    return val;
+  }
 
-      <!-- This is the default number of rows that we give the autocomplete
-           popup when the textbox doesn't have a "maxrows" attribute
-           for us to use. -->
-      <field name="defaultMaxRows" readonly="true">6</field>
+  get disableAutoComplete() {
+    return this.getAttribute("disableautocomplete") == "true";
+  }
 
-      <!-- In some cases (e.g. when the input's dropmarker button is clicked),
-           the input wants to display a popup with more rows. In that case, it
-           should increase its maxRows property and store the "normal" maxRows
-           in this field. When the popup is hidden, we restore the input's
-           maxRows to the value stored in this field.
+  set completeDefaultIndex(val) {
+    this.setAttribute("completedefaultindex", val);
+    return val;
+  }
+
+  get completeDefaultIndex() {
+    return this.getAttribute("completedefaultindex") == "true";
+  }
 
-           This field is set to -1 between uses so that we can tell when it's
-           been set by the input and when we need to set it in the popupshowing
-           handler. -->
-      <field name="_normalMaxRows">-1</field>
+  set completeSelectedIndex(val) {
+    this.setAttribute("completeselectedindex", val);
+    return val;
+  }
 
-      <property name="maxRows" readonly="true">
-        <getter>
-          <![CDATA[
-          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;
-        ]]>
-        </getter>
-      </property>
+  get completeSelectedIndex() {
+    return this.getAttribute("completeselectedindex") == "true";
+  }
 
-      <method name="getNextIndex">
-        <parameter name="aReverse"/>
-        <parameter name="aAmount"/>
-        <parameter name="aIndex"/>
-        <parameter name="aMaxRow"/>
-        <body><![CDATA[
-          if (aMaxRow < 0)
-            return -1;
+  set forceComplete(val) {
+    this.setAttribute("forcecomplete", val);
+    return val;
+  }
+
+  get forceComplete() {
+    return this.getAttribute("forcecomplete") == "true";
+  }
 
-          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;
-          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)
-            newIdx = aMaxRow;
-          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)
-            newIdx = 0;
+  set minResultsForPopup(val) {
+    this.setAttribute("minresultsforpopup", val);
+    return val;
+  }
 
-          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)
-            aIndex = -1;
-          else
-            aIndex = newIdx;
+  get minResultsForPopup() {
+    var m = parseInt(this.getAttribute("minresultsforpopup"));
+    return isNaN(m) ? 1 : m;
+  }
 
-          return aIndex;
-        ]]></body>
-      </method>
+  set timeout(val) {
+    this.setAttribute("timeout", val);
+    return val;
+  }
 
-      <method name="onPopupClick">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          this.input.controller.handleEnter(true, aEvent);
-        ]]></body>
-      </method>
+  get timeout() {
+    var t = parseInt(this.getAttribute("timeout"));
+    return isNaN(t) ? 50 : t;
+  }
+
+  set searchParam(val) {
+    this.setAttribute("autocompletesearchparam", val);
+    return val;
+  }
+
+  get searchParam() {
+    return this.getAttribute("autocompletesearchparam") || "";
+  }
 
-      <property name="selectedIndex"
-                onget="return this.richlistbox.selectedIndex;">
-        <setter>
-          <![CDATA[
-          if (val != this.richlistbox.selectedIndex) {
-            this._previousSelectedIndex = this.richlistbox.selectedIndex;
-          }
-          this.richlistbox.selectedIndex = val;
-          // Since ensureElementIsVisible may cause an expensive Layout flush,
-          // invoke it only if there may be a scrollbar, so if we could fetch
-          // more results than we can show at once.
-          // maxResults is the maximum number of fetched results, maxRows is the
-          // maximum number of rows we show at once, without a scrollbar.
-          if (this.mPopupOpen && this.maxResults > this.maxRows) {
-            // when clearing the selection (val == -1, so selectedItem will be
-            // null), we want to scroll back to the top.  see bug #406194
-            this.richlistbox.ensureElementIsVisible(
-              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);
-          }
-          return val;
-        ]]>
-        </setter>
-      </property>
+  get searchCount() {
+    this.initSearchNames();
+    return this.mSearchNames.length;
+  }
 
-      <field name="_previousSelectedIndex">-1</field>
-      <field name="mLastMoveTime">Date.now()</field>
-      <field name="mousedOverIndex">-1</field>
+  get PrivateBrowsingUtils() {
+    let module = {};
+    ChromeUtils.import("resource://gre/modules/PrivateBrowsingUtils.jsm", module);
+    Object.defineProperty(this, "PrivateBrowsingUtils", {
+      configurable: true,
+      enumerable: true,
+      writable: true,
+      value: module.PrivateBrowsingUtils,
+    });
+    return module.PrivateBrowsingUtils;
+  }
+
+  get inPrivateContext() {
+    return this.PrivateBrowsingUtils.isWindowPrivate(window);
+  }
 
-      <method name="onSearchBegin">
-        <body><![CDATA[
-          this.mousedOverIndex = -1;
+  get noRollupOnCaretMove() {
+    return this.popup.getAttribute("norolluponanchor") == "true"
+  }
 
-          if (typeof this._onSearchBegin == "function") {
-            this._onSearchBegin();
-          }
-        ]]></body>
-      </method>
+  set textValue(val) {
+    if (typeof this.onBeforeTextValueSet == "function" &&
+      !this._textValueSetByCompleteDefault) {
+      val = this.onBeforeTextValueSet(val);
+    }
+
+    // "input" event is automatically dispatched by the editor if
+    // necessary.
+    this._setValueInternal(val, true);
+
+    return this.value;
+  }
 
-      <method name="openAutocompletePopup">
-        <parameter name="aInput"/>
-        <parameter name="aElement"/>
-        <body>
-          <![CDATA[
-          // until we have "baseBinding", (see bug #373652) this allows
-          // us to override openAutocompletePopup(), but still call
-          // the method on the base class
-          this._openAutocompletePopup(aInput, aElement);
-        ]]>
-        </body>
-      </method>
+  get textValue() {
+    if (typeof this.onBeforeTextValueGet == "function") {
+      let result = this.onBeforeTextValueGet();
+      if (result) {
+        return result.value;
+      }
+    }
+    return this.value;
+  }
+  /**
+   * =================== nsIDOMXULMenuListElement ===================
+   */
+  get editable() {
+    return true;
+  }
 
-      <method name="_openAutocompletePopup">
-        <parameter name="aInput"/>
-        <parameter name="aElement"/>
-        <body>
-          <![CDATA[
-          if (!this.mPopupOpen) {
-            // It's possible that the panel is hidden initially
-            // to avoid impacting startup / new window performance
-            aInput.popup.hidden = false;
-
-            this.mInput = aInput;
-            // clear any previous selection, see bugs 400671 and 488357
-            this.selectedIndex = -1;
-
-            var width = aElement.getBoundingClientRect().width;
-            this.setAttribute("width", width > 100 ? width : 100);
-            // invalidate() depends on the width attribute
-            this._invalidate();
+  set crop(val) {
+    return false;
+  }
 
-            this.openPopup(aElement, "after_start", 0, 0, false, false);
-          }
-        ]]>
-        </body>
-      </method>
+  get crop() {
+    return false;
+  }
 
-      <method name="invalidate">
-        <parameter name="reason"/>
-        <body>
-          <![CDATA[
-          // Don't bother doing work if we're not even showing
-          if (!this.mPopupOpen)
-            return;
+  set open(val) {
+    if (val)
+      this.showHistoryPopup();
+    else
+      this.closePopup();
+  }
 
-          this._invalidate(reason);
-          ]]>
-        </body>
-      </method>
+  get open() {
+    return this.getAttribute("open") == "true";
+  }
+
+  set value(val) {
+    return this._setValueInternal(val, false);
+  }
 
-      <method name="_invalidate">
-        <parameter name="reason"/>
-        <body>
-          <![CDATA[
-          // collapsed if no matches
-          this.richlistbox.collapsed = (this.matchCount == 0);
+  get value() {
+    if (typeof this.onBeforeValueGet == "function") {
+      var result = this.onBeforeValueGet();
+      if (result)
+        return result.value;
+    }
+    return super.value;
+  }
 
-          // Update the richlistbox height.
-          if (this._adjustHeightRAFToken) {
-            cancelAnimationFrame(this._adjustHeightRAFToken);
-            this._adjustHeightRAFToken = null;
-          }
-
-          if (this.mPopupOpen) {
-            delete this._adjustHeightOnPopupShown;
-            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());
-          } else {
-            this._adjustHeightOnPopupShown = true;
-          }
+  get focused() {
+    return this === document.activeElement;
+  }
+  /**
+   * maximum number of rows to display at a time
+   */
+  set maxRows(val) {
+    this.setAttribute("maxrows", val);
+    return val;
+  }
 
-          this._currentIndex = 0;
-          if (this._appendResultTimeout) {
-            clearTimeout(this._appendResultTimeout);
-          }
-          this._appendCurrentResult(reason);
-        ]]>
-        </body>
-      </method>
-
-      <property name="maxResults" readonly="true">
-        <getter>
-          <![CDATA[
-            // This is how many richlistitems will be kept around.
-            // Note, this getter may be overridden, or instances
-            // can have the nomaxresults attribute set to have no
-            // limit.
-            if (this.getAttribute("nomaxresults") == "true") {
-              return Infinity;
-            }
+  get maxRows() {
+    return parseInt(this.getAttribute("maxrows")) || 0;
+  }
+  /**
+   * option to allow scrolling through the list via the tab key, rather than
+   * tab moving focus out of the textbox
+   */
+  set tabScrolling(val) {
+    this.setAttribute("tabscrolling", val);
+    return val;
+  }
 
-            return 20;
-          ]]>
-        </getter>
-      </property>
+  get tabScrolling() {
+    return this.getAttribute("tabscrolling") == "true";
+  }
+  /**
+   * option to completely ignore any blur events while searches are
+   * still going on.
+   */
+  set ignoreBlurWhileSearching(val) {
+    this.setAttribute("ignoreblurwhilesearching", val);
+    return val;
+  }
 
-      <property name="matchCount" readonly="true">
-        <getter>
-          <![CDATA[
-          return Math.min(this.mInput.controller.matchCount, this.maxResults);
-          ]]>
-        </getter>
-      </property>
+  get ignoreBlurWhileSearching() {
+    return this.getAttribute("ignoreblurwhilesearching") == "true";
+  }
+  /**
+   * option to highlight entries that don't have any matches
+   */
+  set highlightNonMatches(val) {
+    this.setAttribute("highlightnonmatches", val);
+    return val;
+  }
 
-      <method name="_collapseUnusedItems">
-        <body>
-          <![CDATA[
-            let existingItemsCount = this.richlistbox.children.length;
-            for (let i = this.matchCount; i < existingItemsCount; ++i) {
-              let item = this.richlistbox.children[i];
+  get highlightNonMatches() {
+    return this.getAttribute("highlightnonmatches") == "true";
+  }
 
-              item.collapsed = true;
-              if (typeof item._onCollapse == "function") {
-                item._onCollapse();
-              }
-            }
-          ]]>
-        </body>
-      </method>
+  getSearchAt(aIndex) {
+    this.initSearchNames();
+    return this.mSearchNames[aIndex];
+  }
 
-      <method name="adjustHeight">
-        <body>
-          <![CDATA[
-          // Figure out how many rows to show
-          let rows = this.richlistbox.children;
-          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);
+  setTextValueWithReason(aValue, aReason) {
+    if (aReason == Ci.nsIAutoCompleteInput.TEXTVALUE_REASON_COMPLETEDEFAULT) {
+      this._textValueSetByCompleteDefault = true;
+    }
+    this.textValue = aValue;
+    this._textValueSetByCompleteDefault = false;
+  }
+
+  selectTextRange(aStartIndex, aEndIndex) {
+    super.setSelectionRange(aStartIndex, aEndIndex);
+  }
 
-          // Default the height to 0 if we have no rows to show
-          let height = 0;
-          if (numRows) {
-            let firstRowRect = rows[0].getBoundingClientRect();
-            if (this._rlbPadding == undefined) {
-              let style = window.getComputedStyle(this.richlistbox);
-              let paddingTop = parseInt(style.paddingTop) || 0;
-              let paddingBottom = parseInt(style.paddingBottom) || 0;
-              this._rlbPadding = paddingTop + paddingBottom;
-            }
+  onSearchBegin() {
+    if (this.popup && typeof this.popup.onSearchBegin == "function")
+      this.popup.onSearchBegin();
+    if (this._searchBeginHandler)
+      this._searchBeginHandler();
+  }
 
-            // The class `forceHandleUnderflow` is for the item might need to
-            // handle OverUnderflow or Overflow when the height of an item will
-            // be changed dynamically.
-            for (let i = 0; i < numRows; i++) {
-              if (rows[i].classList.contains("forceHandleUnderflow")) {
-                rows[i].handleOverUnderflow();
-              }
-            }
+  onSearchComplete() {
+    if (this.mController.matchCount == 0)
+      this.setAttribute("nomatch", "true");
+    else
+      this.removeAttribute("nomatch");
+
+    if (this.ignoreBlurWhileSearching && !this.focused) {
+      this.handleEnter();
+      this.detachController();
+    }
 
-            let lastRowRect = rows[numRows - 1].getBoundingClientRect();
-            // Calculate the height to have the first row to last row shown
-            height = lastRowRect.bottom - firstRowRect.top +
-                     this._rlbPadding;
-          }
+    if (this._searchCompleteHandler)
+      this._searchCompleteHandler();
+  }
+
+  onTextEntered(event) {
+    let rv = false;
+    if (this._textEnteredHandler) {
+      rv = this._textEnteredHandler(event);
+    }
+    return rv;
+  }
+
+  onTextReverted() {
+    if (this._textRevertedHandler)
+      return this._textRevertedHandler();
+    return false;
+  }
 
-          let currentHeight = this.richlistbox.getBoundingClientRect().height;
-          if (height <= currentHeight) {
-            this._collapseUnusedItems();
-          }
-          this.richlistbox.style.removeProperty("height");
-          // We need to get the ceiling of the calculated value to ensure that the box fully contains
-          // all of its contents and doesn't cause a scrollbar since nsIBoxObject only expects a
-          // `long`. e.g. if `height` is 99.5 the richlistbox would render at height 99px with a
-          // scrollbar for the extra 0.5px.
-          this.richlistbox.height = Math.ceil(height);
-          ]]>
-        </body>
-      </method>
+  /**
+   * =================== PRIVATE MEMBERS ===================  ::::::::::::: autocomplete controller :::::::::::::
+   */
+
+  attachController() {
+    this.mController.input = this.nsIAutocompleteInput;
 
-      <method name="_appendCurrentResult">
-        <parameter name="invalidateReason"/>
-        <body>
-          <![CDATA[
-          var controller = this.mInput.controller;
-          var matchCount = this.matchCount;
-          var existingItemsCount = this.richlistbox.children.length;
+    // XXX(ntim): this.nsIController.input returns a XPCWrappedNative_NoHelper, while
+    // this.nsIAutocompleteInput is a Proxy. Transform the Proxy into a
+    // XPCWrappedNative_NoHelper so equality checks work later on.
+    // this.nsIAutocompleteInput = this.mController.input;
+  }
 
-          // Process maxRows per chunk to improve performance and user experience
-          for (let i = 0; i < this.maxRows; i++) {
-            if (this._currentIndex >= matchCount) {
-              break;
-            }
-            let item;
-            let itemExists = this._currentIndex < existingItemsCount;
+  detachController() {
+    if (this.mController.input == this.nsIAutocompleteInput)
+      this.mController.input = null;
+  }
 
-            let originalValue, originalText, originalType;
-            let style = controller.getStyleAt(this._currentIndex);
-            let value =
-              style && style.includes("autofill") ?
-              controller.getFinalCompleteValueAt(this._currentIndex) :
-              controller.getValueAt(this._currentIndex);
-            let label = controller.getLabelAt(this._currentIndex);
-            let comment = controller.getCommentAt(this._currentIndex);
-            let image = controller.getImageAt(this._currentIndex);
-            // trim the leading/trailing whitespace
-            let trimmedSearchString = controller.searchString.replace(/^\s+/, "").replace(/\s+$/, "");
+  /**
+   * ::::::::::::: popup opening :::::::::::::
+   */
+  openPopup() {
+    if (this.focused)
+      this.popup.openAutocompletePopup(this.nsIAutocompleteInput, this);
+  }
 
-            let reusable = false;
-            if (itemExists) {
-              item = this.richlistbox.children[this._currentIndex];
+  closePopup() {
+    this.popup.closePopup();
+  }
+
+  showHistoryPopup() {
+    // Store our "normal" maxRows on the popup, so that it can reset the
+    // value when the popup is hidden.
+    this.popup._normalMaxRows = this.maxRows;
 
-              // Url may be a modified version of value, see _adjustAcItem().
-              originalValue = item.getAttribute("url") || item.getAttribute("ac-value");
-              originalText = item.getAttribute("ac-text");
-              originalType = item.getAttribute("originaltype");
+    // Increase our maxRows temporarily, since we want the dropdown to
+    // be bigger in this case. The popup's popupshowing/popuphiding
+    // handlers will take care of resetting this.
+    this.maxRows = this.maxDropMarkerRows;
 
-              // The styles on the list which have different <content> structure and overrided
-              // _adjustAcItem() are unreusable.
-              const UNREUSEABLE_STYLES = [
-                "autofill-profile",
-                "autofill-footer",
-                "autofill-clear-button",
-                "autofill-insecureWarning",
-                "generatedPassword",
-                "insecureWarning",
-                "loginsFooter",
-                "loginWithOrigin",
-              ];
-              // Reuse the item when its style is exactly equal to the previous style or
-              // neither of their style are in the UNREUSEABLE_STYLES.
-              reusable = originalType === style ||
-                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
-            }
+    // Ensure that we have focus.
+    if (!this.focused)
+      this.focus();
+    this.attachController();
+    this.mController.startSearch("");
+  }
+
+  toggleHistoryPopup() {
+    if (!this.popup.popupOpen)
+      this.showHistoryPopup();
+    else
+      this.closePopup();
+  }
 
-            // If no reusable item available, then create a new item.
-            if (!reusable) {
-              let options = null;
-              switch (style) {
-                case "autofill-profile":
-                  options = { is: "autocomplete-profile-listitem" };
-                  break;
-                case "autofill-footer":
-                  options = { is: "autocomplete-profile-listitem-footer" };
-                  break;
-                case "autofill-clear-button":
-                  options = { is: "autocomplete-profile-listitem-clear-button" };
-                  break;
-                case "autofill-insecureWarning":
-                  options = { is: "autocomplete-creditcard-insecure-field" };
-                  break;
-                case "generatedPassword":
-                  options = { is: "autocomplete-two-line-richlistitem" };
-                  break;
-                case "insecureWarning":
-                  options = { is: "autocomplete-richlistitem-insecure-warning" };
-                  break;
-                case "loginsFooter":
-                  options = { is: "autocomplete-richlistitem-logins-footer" };
-                  break;
-                case "loginWithOrigin":
-                  options = { is: "autocomplete-login-richlistitem" };
-                  break;
-                default:
-                  options = { is: "autocomplete-richlistitem" };
-              }
-              item = document.createXULElement("richlistitem", options);
-              item.className = "autocomplete-richlistitem";
-            }
+  /**
+   * ::::::::::::: event dispatching :::::::::::::
+   */
+  initEventHandler(aEventType) {
+    let handlerString = this.getAttribute("on" + aEventType);
+    if (handlerString) {
+      return (new Function("eventType", "param", handlerString)).bind(this, aEventType);
+    }
+    return null;
+  }
+
+  onKeyPress(aEvent) {
+    return this.handleKeyPress(aEvent);
+  }
 
-            item.setAttribute("dir", this.style.direction);
-            item.setAttribute("ac-image", image);
-            item.setAttribute("ac-value", value);
-            item.setAttribute("ac-label", label);
-            item.setAttribute("ac-comment", comment);
-            item.setAttribute("ac-text", trimmedSearchString);
+  handleKeyPress(aEvent, aOptions) {
+    // Re: urlbarDeferred, see the comment in urlbarBindings.xml.
+    if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {
+      return false;
+    }
+
+    const isMac = /Mac/.test(navigator.platform);
+    var cancel = false;
+
+    // Catch any keys that could potentially move the caret. Ctrl can be
+    // used in combination with these keys on Windows and Linux; and Alt
+    // can be used on OS X, so make sure the unused one isn't used.
+    let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;
+    if (!metaKey) {
+      switch (aEvent.keyCode) {
+        case KeyEvent.DOM_VK_LEFT:
+        case KeyEvent.DOM_VK_RIGHT:
+        case KeyEvent.DOM_VK_HOME:
+          cancel = this.mController.handleKeyNavigation(aEvent.keyCode);
+          break;
+      }
+    }
 
-            // Completely reuse the existing richlistitem for invalidation
-            // due to new results, but only when: the item is the same, *OR*
-            // we are about to replace the currently moused-over item, to
-            // avoid surprising the user.
-            let iface = Ci.nsIAutoCompletePopup;
-            if (reusable &&
-                originalText == trimmedSearchString &&
-                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&
-                (originalValue == value ||
-                 this.mousedOverIndex === this._currentIndex)) {
-              // try to re-use the existing item
-              let reused = item._reuseAcItem();
-              if (reused) {
-                this._currentIndex++;
-                continue;
-              }
-            } else {
-              if (typeof item._cleanup == "function") {
-                item._cleanup();
-              }
-              item.setAttribute("originaltype", style);
-            }
+    // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)
+    if (!aEvent.ctrlKey && !aEvent.altKey) {
+      switch (aEvent.keyCode) {
+        case KeyEvent.DOM_VK_TAB:
+          if (this.tabScrolling && this.popup.popupOpen)
+            cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?
+              KeyEvent.DOM_VK_UP :
+              KeyEvent.DOM_VK_DOWN);
+          else if (this.forceComplete && this.mController.matchCount >= 1)
+            this.mController.handleTab();
+          break;
+        case KeyEvent.DOM_VK_UP:
+        case KeyEvent.DOM_VK_DOWN:
+        case KeyEvent.DOM_VK_PAGE_UP:
+        case KeyEvent.DOM_VK_PAGE_DOWN:
+          cancel = this.mController.handleKeyNavigation(aEvent.keyCode);
+          break;
+      }
+    }
+
+    // Handle readline/emacs-style navigation bindings on Mac.
+    if (isMac &&
+      this.popup.popupOpen &&
+      aEvent.ctrlKey &&
+      (aEvent.key === "n" || aEvent.key === "p")) {
+      const effectiveKey = (aEvent.key === "p") ?
+        KeyEvent.DOM_VK_UP :
+        KeyEvent.DOM_VK_DOWN;
+      cancel = this.mController.handleKeyNavigation(effectiveKey);
+    }
 
-            if (reusable) {
-              // Adjust only when the result's type is reusable for existing
-              // item's. Otherwise, we might insensibly call old _adjustAcItem()
-              // as new binding has not been attached yet.
-              // We don't need to worry about switching to new binding, since
-              // _adjustAcItem() will fired by its own constructor accordingly.
-              item._adjustAcItem();
-              item.collapsed = false;
-            } else if (itemExists) {
-              let oldItem = this.richlistbox.children[this._currentIndex];
-              this.richlistbox.replaceChild(item, oldItem);
-            } else {
-              this.richlistbox.appendChild(item);
-            }
-
-            this._currentIndex++;
-          }
+    // Handle keys we know aren't part of a shortcut, even with Alt or
+    // Ctrl.
+    switch (aEvent.keyCode) {
+      case KeyEvent.DOM_VK_ESCAPE:
+        cancel = this.mController.handleEscape();
+        break;
+      case KeyEvent.DOM_VK_RETURN:
+        if (isMac) {
+          // Prevent the default action, since it will beep on Mac
+          if (aEvent.metaKey)
+            aEvent.preventDefault();
+        }
+        if (this.popup.selectedIndex >= 0) {
+          this._selectionDetails = {
+            index: this.popup.selectedIndex,
+            kind: "key",
+          };
+        }
+        cancel = this.handleEnter(aEvent, aOptions);
+        break;
+      case KeyEvent.DOM_VK_DELETE:
+        if (isMac && !aEvent.shiftKey) {
+          break;
+        }
+        cancel = this.handleDelete();
+        break;
+      case KeyEvent.DOM_VK_BACK_SPACE:
+        if (isMac && aEvent.shiftKey) {
+          cancel = this.handleDelete();
+        }
+        break;
+      case KeyEvent.DOM_VK_DOWN:
+      case KeyEvent.DOM_VK_UP:
+        if (aEvent.altKey)
+          this.toggleHistoryPopup();
+        break;
+      case KeyEvent.DOM_VK_F4:
+        if (!isMac) {
+          this.toggleHistoryPopup();
+        }
+        break;
+    }
 
-          if (typeof this.onResultsAdded == "function") {
-            // The items bindings may not be attached yet, so we must delay this
-            // before we can properly handle items properly without breaking
-            // the richlistbox.
-            Services.tm.dispatchToMainThread(() => this.onResultsAdded());
-          }
-
-          if (this._currentIndex < matchCount) {
-            // yield after each batch of items so that typing the url bar is
-            // responsive
-            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);
-          }
-        ]]>
-        </body>
-      </method>
-
-      <property name="overflowPadding"
-                onget="return Number(this.getAttribute('overflowpadding'))"
-                readonly="true" />
-
-      <method name="selectBy">
-        <parameter name="aReverse"/>
-        <parameter name="aPage"/>
-        <body>
-          <![CDATA[
-          try {
-            var amount = aPage ? 5 : 1;
+    if (cancel) {
+      aEvent.stopPropagation();
+      aEvent.preventDefault();
+    }
 
-            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount
-            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);
-            if (this.selectedIndex == -1) {
-              this.input._focus();
-            }
-          } catch (ex) {
-            // do nothing - occasionally timer-related js errors happen here
-            // e.g. "this.selectedIndex has no properties", when you type fast and hit a
-            // navigation key before this popup has opened
-          }
-            ]]>
-        </body>
-      </method>
+    return true;
+  }
+
+  handleEnter(event) {
+    return this.mController.handleEnter(false, event || null);
+  }
+
+  handleDelete() {
+    return this.mController.handleDelete();
+  }
 
-      <field name="richlistbox">
-        document.getAnonymousElementByAttribute(this, "anonid", "richlistbox");
-      </field>
-
-      <property name="view"
-                onget="return this.mInput.controller;"
-                onset="return val;"/>
+  /**
+   * ::::::::::::: miscellaneous :::::::::::::
+   */
+  initSearchNames() {
+    if (!this.mSearchNames) {
+      var names = this.getAttribute("autocompletesearch");
+      if (!names)
+        this.mSearchNames = [];
+      else
+        this.mSearchNames = names.split(" ");
+    }
+  }
 
-    </implementation>
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // If normalMaxRows wasn't already set by the input, then set it here
-        // so that we restore the correct number when the popup is hidden.
+  _focus() {
+    this._dontBlur = true;
+    this.focus();
+    this._dontBlur = false;
+  }
 
-        // Null-check this.mInput; see bug 1017914
-        if (this._normalMaxRows < 0 && this.mInput) {
-          this._normalMaxRows = this.mInput.maxRows;
-        }
+  resetActionType() {
+    if (this.mIgnoreInput)
+      return;
+    this.removeAttribute("actiontype");
+  }
+
+  _setValueInternal(value, isUserInput) {
+    this.mIgnoreInput = true;
 
-        // Set an attribute for styling the popup based on the input.
-        let inputID = "";
-        if (this.mInput && this.mInput.ownerDocument &&
-            this.mInput.ownerDocument.documentURIObject.schemeIs("chrome")) {
-          inputID = this.mInput.id;
-          // Take care of elements with no id that are inside xbl bindings
-          if (!inputID) {
-            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);
-            if (bindingParent) {
-              inputID = bindingParent.id;
-            }
-          }
-        }
-        this.setAttribute("autocompleteinput", inputID);
+    if (typeof this.onBeforeValueSet == "function") {
+      value = this.onBeforeValueSet(value);
+    }
+
+    if (typeof this.trimValue == "function" &&
+        !this._textValueSetByCompleteDefault) {
+      value = this.trimValue(value);
+    }
 
-        this.mPopupOpen = true;
-      ]]></handler>
+    this.valueIsTyped = false;
+    if (isUserInput) {
+      super.setUserInput(value);
+    } else {
+      super.value = value;
+    }
 
-      <handler event="popupshown">
-        <![CDATA[
-          if (this._adjustHeightOnPopupShown) {
-            delete this._adjustHeightOnPopupShown;
-            this.adjustHeight();
-          }
-      ]]>
-      </handler>
+    if (typeof this.formatValue == "function")
+      this.formatValue();
 
-      <handler event="popuphiding"><![CDATA[
-        var isListActive = true;
-        if (this.selectedIndex == -1)
-          isListActive = false;
-        this.input.controller.stopSearch();
-
-        this.removeAttribute("autocompleteinput");
-        this.mPopupOpen = false;
-
-        // Reset the maxRows property to the cached "normal" value (if there's
-        // any), and reset normalMaxRows so that we can detect whether it was set
-        // by the input when the popupshowing handler runs.
+    this.mIgnoreInput = false;
+    var event = document.createEvent("Events");
+    event.initEvent("ValueChange", true, true);
+    super.dispatchEvent(event);
+    return value;
+  }
 
-        // Null-check this.mInput; see bug 1017914
-        if (this.mInput && this._normalMaxRows > 0) {
-          this.mInput.maxRows = this._normalMaxRows;
-        }
-        this._normalMaxRows = -1;
-        // If the list was being navigated and then closed, make sure
-        // we fire accessible focus event back to textbox
+  onInput(aEvent) {
+    if (!this.mIgnoreInput && this.mController.input == this.nsIAutocompleteInput) {
+      this.valueIsTyped = true;
+      this.mController.handleText();
+    }
+    this.resetActionType();
+  }
+}
 
-        // Null-check this.mInput; see bug 1017914
-        if (isListActive && this.mInput) {
-          this.mInput.mIgnoreFocus = true;
-          this.mInput._focus();
-          this.mInput.mIgnoreFocus = false;
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
-</bindings>
+MozHTMLElement.implementCustomInterface(AutocompleteInput, [Ci.nsIAutoCompleteInput, Ci.nsIDOMXULMenuListElement]);
+customElements.define("autocomplete-input", AutocompleteInput, { extends: "input" });
+
+}

