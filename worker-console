# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2ebf10394882ffc825ab01d6ff54497d773808ae
Bug 1209353 - Try to create a console actor in worker

diff --git a/devtools/client/framework/target.js b/devtools/client/framework/target.js
--- a/devtools/client/framework/target.js
+++ b/devtools/client/framework/target.js
@@ -823,16 +823,18 @@ WindowTarget.prototype = {
   toString: function() {
     return 'WindowTarget:' + this.window;
   },
 };
 
 function WorkerTarget(workerClient) {
   EventEmitter.decorate(this);
   this._workerClient = workerClient;
+  console.trace();
+  console.log("WorkerTarget created in target.js", this._workerClient);
 }
 
 /**
  * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
  * either a local or remote tab, WorkerTarget always represents a remote worker.
  * Moreover, unlike TabTarget, which is constructed with a placeholder object
  * for remote tabs (from which a TabClient can then be lazily obtained),
  * WorkerTarget is constructed with a WorkerClient directly.
@@ -855,19 +857,25 @@ WorkerTarget.prototype = {
   get isTabActor() {
     return true;
   },
 
   get url() {
     return this._workerClient.url;
   },
 
+  get isWorkerTarget() {
+    return true;
+  },
+
   get form() {
+    console.log("get form()", this._workerClient);
     return {
       from: this._workerClient.actor,
+      consoleActor: this._workerClient.webConsoleActor,
       type: "attached",
       isFrozen: this._workerClient.isFrozen,
       url: this._workerClient.url
     };
   },
 
   get activeTab() {
     return this._workerClient;
@@ -882,10 +890,12 @@ WorkerTarget.prototype = {
   hasActor: function (name) {
     return false;
   },
 
   getTrait: function (name) {
     return undefined;
   },
 
-  makeRemote: function () {}
+  makeRemote: function () {
+    console.log("makeRemote()", this);
+  }
 };
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -5017,23 +5017,27 @@ WebConsoleConnectionProxy.prototype = {
       this._connectTimer.cancel();
       this._connectTimer = null;
     }, () => {
       this._connectTimer = null;
     });
 
     let client = this.client = this.target.client;
 
-    client.addListener("logMessage", this._onLogMessage);
-    client.addListener("pageError", this._onPageError);
-    client.addListener("consoleAPICall", this._onConsoleAPICall);
-    client.addListener("fileActivity", this._onFileActivity);
-    client.addListener("reflowActivity", this._onReflowActivity);
-    client.addListener("serverLogCall", this._onServerLogCall);
-    client.addListener("lastPrivateContextExited", this._onLastPrivateContextExited);
+    if (this.target.isWorkerTarget) {
+
+    } else {
+      client.addListener("logMessage", this._onLogMessage);
+      client.addListener("pageError", this._onPageError);
+      client.addListener("consoleAPICall", this._onConsoleAPICall);
+      client.addListener("fileActivity", this._onFileActivity);
+      client.addListener("reflowActivity", this._onReflowActivity);
+      client.addListener("serverLogCall", this._onServerLogCall);
+      client.addListener("lastPrivateContextExited", this._onLastPrivateContextExited);
+    }
     this.target.on("will-navigate", this._onTabNavigated);
     this.target.on("navigate", this._onTabNavigated);
 
     this._consoleActor = this.target.form.consoleActor;
     if (this.target.isTabActor) {
       let tab = this.target.form;
       this.owner.onLocationChange(tab.url, tab.title);
     }
@@ -5057,16 +5061,17 @@ WebConsoleConnectionProxy.prototype = {
   },
 
   /**
    * Attach to the Web Console actor.
    * @private
    */
   _attachConsole: function WCCP__attachConsole()
   {
+    console.log("Attaching client now " + this._consoleActor);
     let listeners = ["PageError", "ConsoleAPI", "NetworkActivity",
                      "FileActivity"];
     this.client.attachConsole(this._consoleActor, listeners,
                               this._onAttachConsole);
   },
 
   /**
    * The "attachConsole" response handler.
@@ -5083,16 +5088,17 @@ WebConsoleConnectionProxy.prototype = {
     if (aResponse.error) {
       Cu.reportError("attachConsole failed: " + aResponse.error + " " +
                      aResponse.message);
       this._connectDefer.reject(aResponse);
       return;
     }
 
     this.webConsoleClient = aWebConsoleClient;
+    console.log("frontend _onAttachConsole", aWebConsoleClient)
 
     this._hasNativeConsoleAPI = aResponse.nativeConsoleAPI;
     this.webConsoleClient.on("networkEvent", this._onNetworkEvent);
     this.webConsoleClient.on("networkEventUpdate", this._onNetworkEventUpdate);
 
     let msgs = ["PageError", "ConsoleAPI"];
     this.webConsoleClient.getCachedMessages(msgs, this._onCachedMessages);
 
diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -642,16 +642,23 @@ ThreadActor.prototype = {
     try {
       // Put ourselves in the paused state.
       let packet = this._paused();
       if (!packet) {
         return { error: "notAttached" };
       }
       packet.why = { type: "attached" };
 
+      // XXX: this is a hacky way to attach the webconsole and send the actor id.
+      // Seems like this should happen in server/worker.js maybe
+      if (this._webConsoleActor) {
+        var webConsoleActor = this._webConsoleActor;
+        packet.webConsoleActor = webConsoleActor.actorID;
+      }
+
       this._restoreBreakpoints();
 
       // Send the response to the attach request now (rather than
       // returning it), because we're going to start a nested event loop
       // here.
       this.conn.send(packet);
 
       // Start a nested event loop.
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -1,55 +1,42 @@
 /* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
 /* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+const Services = require("Services");
 const { Cc, Ci, Cu } = require("chrome");
 const { DebuggerServer, ActorPool } = require("devtools/server/main");
 const { EnvironmentActor, ThreadActor } = require("devtools/server/actors/script");
 const { ObjectActor, LongStringActor, createValueGrip, stringIsLong } = require("devtools/server/actors/object");
 const DevToolsUtils = require("devtools/shared/DevToolsUtils");
 
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "Services",
-                                  "resource://gre/modules/Services.jsm");
-XPCOMUtils.defineLazyGetter(this, "NetworkMonitor", () => {
-  return require("devtools/shared/webconsole/network-monitor")
-         .NetworkMonitor;
-});
-XPCOMUtils.defineLazyGetter(this, "NetworkMonitorChild", () => {
-  return require("devtools/shared/webconsole/network-monitor")
-         .NetworkMonitorChild;
-});
-XPCOMUtils.defineLazyGetter(this, "ConsoleProgressListener", () => {
-  return require("devtools/shared/webconsole/network-monitor")
-         .ConsoleProgressListener;
-});
-XPCOMUtils.defineLazyGetter(this, "events", () => {
-  return require("sdk/event/core");
-});
-XPCOMUtils.defineLazyGetter(this, "ServerLoggingListener", () => {
-  return require("devtools/shared/webconsole/server-logger")
-         .ServerLoggingListener;
-});
+loader.lazyRequireGetter(this, "NetworkMonitor", "devtools/shared/webconsole/network-monitor", true);
+loader.lazyRequireGetter(this, "NetworkMonitorChild", "devtools/shared/webconsole/network-monitor", true);
+loader.lazyRequireGetter(this, "ConsoleProgressListener", "devtools/shared/webconsole/network-monitor", true);
+loader.lazyRequireGetter(this, "events", "sdk/event/core");
+loader.lazyRequireGetter(this, "ServerLoggingListener", "devtools/shared/webconsole/server-logger");
 
 for (let name of ["WebConsoleUtils", "ConsoleServiceListener",
     "ConsoleAPIListener", "addWebConsoleCommands", "JSPropertyProvider",
     "ConsoleReflowListener", "CONSOLE_WORKER_IDS"]) {
   Object.defineProperty(this, name, {
     get: function(prop) {
       if (prop == "WebConsoleUtils") {
         prop = "Utils";
       }
-      return require("devtools/shared/webconsole/utils")[prop];
+      if (isWorker) {
+        return require("devtools/shared/webconsole/worker-utils")[prop];
+      } else {
+        return require("devtools/shared/webconsole/utils")[prop];
+      }
     }.bind(null, name),
     configurable: true,
     enumerable: true
   });
 }
 
 /**
  * The WebConsoleActor implements capabilities needed for the Web Console
@@ -168,16 +155,17 @@ WebConsoleActor.prototype =
             this.parentActor instanceof DebuggerServer.ContentActor;
   },
 
   /**
    * The window we work with.
    * @type nsIDOMWindow
    */
   get window() {
+    // dump("Fetching parent for console actor " + this.parentActor.window + " " + this.parentActor.actorID + "\n\n");
     if (this.parentActor.isRootActor) {
       return this._getWindowForBrowserConsole();
     }
     return this.parentActor.window;
   },
 
   /**
    * Get a window to use for the browser console.
@@ -550,16 +538,21 @@ WebConsoleActor.prototype =
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response object which holds the startedListeners array.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
   {
+    // XXX
+    if (isWorker) {
+      dump("XXX: Bailing out when adding listeners " + aRequest.listeners.join(",") + "\n");
+       aRequest.listeners = [];
+     }
     let startedListeners = [];
     let window = !this.parentActor.isRootActor ? this.window : null;
     let appId = null;
     let messageManager = null;
 
     if (this._parentIsContentActor) {
       appId = this.parentActor.docShell.appId;
       messageManager = this.parentActor.messageManager;
@@ -791,17 +784,17 @@ WebConsoleActor.prototype =
    * @return object
    *         The response packet to send to with the unique id in the
    *         `resultID` field.
    */
   onEvaluateJSAsync: function WCA_onEvaluateJSAsync(aRequest)
   {
     // We want to be able to run console commands without waiting
     // for the first to return (see Bug 1088861).
-
+    dump("onEvaluateJSAsync" + this.actorID + " " + aRequest.text + "\n\n");
     // First, send a response packet with the id only.
     let resultID = Date.now();
     this.conn.send({
       from: this.actorID,
       resultID: resultID
     });
 
     // Then, execute the script that may pause.
@@ -828,47 +821,55 @@ WebConsoleActor.prototype =
     let timestamp = Date.now();
 
     let evalOptions = {
       bindObjectActor: aRequest.bindObjectActor,
       frameActor: aRequest.frameActor,
       url: aRequest.url,
       selectedNodeActor: aRequest.selectedNodeActor,
     };
+    dump("Eval 0\n");
 
     let evalInfo = this.evalWithDebugger(input, evalOptions);
     let evalResult = evalInfo.result;
     let helperResult = evalInfo.helperResult;
 
+    dump("Eval 1 " + isWorker + "\n");
     let result, errorMessage, errorGrip = null;
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
         let error = evalResult.throw;
         errorGrip = this.createValueGrip(error);
-        errorMessage = error && (typeof error === "object")
-          ? error.unsafeDereference().toString()
+        // XXX: This error seems like an empty object in a worker.
+        // Can test by running '1_1' in a normal console and worker console
+        let unsafeDereference = error && (typeof error === "object") &&
+                                error.unsafeDereference();
+        errorMessage = unsafeDereference && unsafeDereference.toString
+          ? unsafeDereference.toString()
           : "" + error;
       }
     }
+    dump("Eval 2\n");
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
     let resultGrip;
     try {
       resultGrip = this.createValueGrip(result);
     } catch (e) {
       errorMessage = e;
     }
 
     this._lastConsoleInputEvaluation = result;
 
+    dump("Eval 3\n");
     return {
       from: this.actorID,
       input: input,
       result: resultGrip,
       timestamp: timestamp,
       exception: errorGrip,
       exceptionMessage: this._createStringGrip(errorMessage),
       helperResult: helperResult,
@@ -892,18 +893,18 @@ WebConsoleActor.prototype =
     // This is the case of the paused debugger
     if (frameActorId) {
       let frameActor = this.conn.getActor(frameActorId);
       if (frameActor) {
         let frame = frameActor.frame;
         environment = frame.environment;
       }
       else {
-        Cu.reportError("Web Console Actor: the frame actor was not found: " +
-                       frameActorId);
+        DevToolsUtils.reportException("onAutocomplete",
+          Error("The frame actor was not found: " + frameActorId));
       }
     }
     // This is the general case (non-paused debugger)
     else {
       dbgObject = this.dbg.makeGlobalObjectReference(this.evalWindow);
     }
 
     let result = JSPropertyProvider(dbgObject, environment, aRequest.text,
@@ -1021,17 +1022,19 @@ WebConsoleActor.prototype =
       sandbox: Object.create(null),
       helperResult: null,
       consoleActor: this,
     };
     addWebConsoleCommands(helpers);
 
     let evalWindow = this.evalWindow;
     function maybeExport(obj, name) {
-      if (typeof obj[name] != "function") {
+      // XXX: Don't ever export in worker b/c of Cu.exportFunction
+      if (typeof obj[name] != "function" || isWorker) {
+        dump("Skipping export " + name + "\n\n")
         return;
       }
 
       // By default, chrome-implemented functions that are exposed to content
       // refuse to accept arguments that are cross-origin for the caller. This
       // is generally the safe thing, but causes problems for certain console
       // helpers like cd(), where we users sometimes want to pass a cross-origin
       // window. To circumvent this restriction, we use exportFunction along
@@ -1121,84 +1124,92 @@ WebConsoleActor.prototype =
       aString = "help()";
     }
 
     // Add easter egg for console.mihai().
     if (trimmedString == "console.mihai()" || trimmedString == "console.mihai();") {
       aString = "\"http://incompleteness.me/blog/2015/02/09/console-dot-mihai/\"";
     }
 
+    dump("evalWithDebugger 0\n\n");
+
     // Find the Debugger.Frame of the given FrameActor.
     let frame = null, frameActor = null;
     if (aOptions.frameActor) {
       frameActor = this.conn.getActor(aOptions.frameActor);
       if (frameActor) {
         frame = frameActor.frame;
       }
       else {
-        Cu.reportError("Web Console Actor: the frame actor was not found: " +
-                       aOptions.frameActor);
+        DevToolsUtils.reportException("evalWithDebugger",
+          Error("The frame actor was not found: " + aOptions.frameActor));
       }
     }
 
+    dump("evalWithDebugger 1" + frameActor + "\n\n");
     // If we've been given a frame actor in whose scope we should evaluate the
     // expression, be sure to use that frame's Debugger (that is, the JavaScript
     // debugger's Debugger) for the whole operation, not the console's Debugger.
     // (One Debugger will treat a different Debugger's Debugger.Object instances
     // as ordinary objects, not as references to be followed, so mixing
     // debuggers causes strange behaviors.)
     let dbg = frame ? frameActor.threadActor.dbg : this.dbg;
     let dbgWindow = dbg.makeGlobalObjectReference(this.evalWindow);
 
+    dump("evalWithDebugger 2\n\n");
     // If we have an object to bind to |_self|, create a Debugger.Object
     // referring to that object, belonging to dbg.
     let bindSelf = null;
     if (aOptions.bindObjectActor) {
       let objActor = this.getActorByID(aOptions.bindObjectActor);
       if (objActor) {
         let jsObj = objActor.obj.unsafeDereference();
         // If we use the makeDebuggeeValue method of jsObj's own global, then
         // we'll get a D.O that sees jsObj as viewed from its own compartment -
         // that is, without wrappers. The evalWithBindings call will then wrap
         // jsObj appropriately for the evaluation compartment.
         let global = Cu.getGlobalForObject(jsObj);
         dbgWindow = dbg.makeGlobalObjectReference(global);
         bindSelf = dbgWindow.makeDebuggeeValue(jsObj);
       }
     }
+    dump("evalWithDebugger 4" + aOptions.selectedNodeActor  + "\n\n");
 
     // Get the Web Console commands for the given debugger window.
     let helpers = this._getWebConsoleCommands(dbgWindow);
     let bindings = helpers.sandbox;
     if (bindSelf) {
       bindings._self = bindSelf;
     }
 
+    dump("evalWithDebugger 4.1\n\n");
     if (aOptions.selectedNodeActor) {
       let actor = this.conn.getActor(aOptions.selectedNodeActor);
       if (actor) {
         helpers.selectedNode = actor.rawNode;
       }
     }
+    dump("evalWithDebugger 5\n\n");
 
     // Check if the Debugger.Frame or Debugger.Object for the global include
     // $ or $$. We will not overwrite these functions with the Web Console
     // commands.
     let found$ = false, found$$ = false;
     if (frame) {
       let env = frame.environment;
       if (env) {
         found$ = !!env.find("$");
         found$$ = !!env.find("$$");
       }
     }
     else {
       found$ = !!dbgWindow.getOwnPropertyDescriptor("$");
       found$$ = !!dbgWindow.getOwnPropertyDescriptor("$$");
     }
+    dump("evalWithDebugger 6\n\n");
 
     let $ = null, $$ = null;
     if (found$) {
       $ = bindings.$;
       delete bindings.$;
     }
     if (found$$) {
       $$ = bindings.$$;
@@ -1208,23 +1219,25 @@ WebConsoleActor.prototype =
     // Ready to evaluate the string.
     helpers.evalInput = aString;
 
     let evalOptions;
     if (typeof aOptions.url == "string") {
       evalOptions = { url: aOptions.url };
     }
 
+    dump("evalWithDebugger 7" + JSON.stringify(evalOptions) + " \n\n");
     let result;
     if (frame) {
       result = frame.evalWithBindings(aString, bindings, evalOptions);
     }
     else {
       result = dbgWindow.executeInGlobalWithBindings(aString, bindings, evalOptions);
     }
+    dump("evalWithDebugger 8\n\n");
 
     let helperResult = helpers.helperResult;
     delete helpers.evalInput;
     delete helpers.helperResult;
     delete helpers.selectedNode;
 
     if ($) {
       bindings.$ = $;
diff --git a/devtools/server/actors/worker.js b/devtools/server/actors/worker.js
--- a/devtools/server/actors/worker.js
+++ b/devtools/server/actors/worker.js
@@ -34,34 +34,41 @@ function WorkerActor(dbg) {
   this._isAttached = false;
   this._threadActor = null;
   this._transport = null;
 }
 
 WorkerActor.prototype = {
   actorPrefix: "worker",
 
+  get window() {
+    dump("Fetching window \n\n" + this._dbg.window);
+    return this._dbg.window;
+  },
+
   form: function () {
     return {
       actor: this.actorID,
+      webConsoleActor: this._webConsoleActor,
       url: this._dbg.url,
       type: this._dbg.type
     };
   },
 
   onAttach: function () {
     if (this._dbg.isClosed) {
       return { error: "closed" };
     }
 
     if (!this._isAttached) {
       this._dbg.addListener(this);
       this._isAttached = true;
     }
 
+
     return {
       type: "attached",
       isFrozen: this._dbg.isFrozen,
       url: this._dbg.url
     };
   },
 
   onDetach: function () {
@@ -83,23 +90,27 @@ WorkerActor.prototype = {
       return {
         type: "connected",
         threadActor: this._threadActor
       };
     }
 
     return DebuggerServer.connectToWorker(
       this.conn, this._dbg, this.actorID, request.options
-    ).then(({ threadActor, transport }) => {
+    ).then(({ threadActor, transport, webConsoleActor }) => {
       this._threadActor = threadActor;
       this._transport = transport;
+      this._webConsoleActor = webConsoleActor;
+
+      console.log("connectToWorker finished", this, this._webConsoleActor);
 
       return {
         type: "connected",
-        threadActor: this._threadActor
+        threadActor: this._threadActor,
+        webConsoleActor: this._webConsoleActor
       };
     }, (error) => {
       return { error: error.toString() };
     });
   },
 
   onClose: function () {
     if (this._isAttached) {
diff --git a/devtools/server/main.js b/devtools/server/main.js
--- a/devtools/server/main.js
+++ b/devtools/server/main.js
@@ -25,16 +25,18 @@ var Promise = require("promise");
 DevToolsUtils.defineLazyGetter(this, "DebuggerSocket", () => {
   let { DebuggerSocket } = require("devtools/shared/security/socket");
   return DebuggerSocket;
 });
 DevToolsUtils.defineLazyGetter(this, "Authentication", () => {
   return require("devtools/shared/security/auth");
 });
 
+dump("main.js loaded - worker? " + isWorker + "\n");
+
 // On B2G, `this` != Global scope, so `Ci` won't be binded on `this`
 // (i.e. this.Ci is undefined) Then later, when using loadSubScript,
 // Ci,... won't be defined for sub scripts.
 this.Ci = Ci;
 this.Cc = Cc;
 this.CC = CC;
 this.Cu = Cu;
 this.Cr = Cr;
@@ -792,16 +794,21 @@ var DebuggerServer = {
             let packet = JSON.parse(message);
             if (packet.type !== "rpc") {
               return;
             }
 
             Promise.resolve().then(() => {
               let method = {
                 "fetch": DevToolsUtils.fetch,
+                "foo": () => {
+                  return {
+                    bar: 1,
+                  }
+                }
               }[packet.method];
               if (!method) {
                 throw Error("Unknown method: " + packet.method);
               }
 
               return method.apply(undefined, packet.params);
             }).then((value) => {
               aDbg.postMessage(JSON.stringify({
@@ -847,16 +854,17 @@ var DebuggerServer = {
             return;
           }
 
           message = packet.message;
           if (message.error) {
             reject(error);
           }
 
+          console.log(message, message.type);
           if (message.type !== "paused") {
             return;
           }
 
           aDbg.removeListener(listener);
 
           // Step 7: Create a transport for the connection to the worker.
           let transport = new WorkerDebuggerTransport(aDbg, aId);
@@ -883,16 +891,17 @@ var DebuggerServer = {
 
           // Ensure that any packets received from the client on the main thread
           // to actors on the worker thread are forwarded to the server on the
           // worker thread.
           aConnection.setForwarding(aId, transport);
 
           resolve({
             threadActor: message.from,
+            webConsoleActor: message.webConsoleActor,
             transport: transport
           });
         }
       };
       aDbg.addListener(listener);
     });
   },
 
diff --git a/devtools/server/worker.js b/devtools/server/worker.js
--- a/devtools/server/worker.js
+++ b/devtools/server/worker.js
@@ -19,16 +19,17 @@ this.rpc = function (method, ...params) 
   return deferred.promise;
 };
 
 loadSubScript("resource://gre/modules/devtools/shared/worker-loader.js");
 
 var Promise = worker.require("promise");
 var { ActorPool } = worker.require("devtools/server/actors/common");
 var { ThreadActor } = worker.require("devtools/server/actors/script");
+var { WebConsoleActor } = worker.require("devtools/server/actors/webconsole");
 var { TabSources } = worker.require("devtools/server/actors/utils/TabSources");
 var makeDebugger = worker.require("devtools/server/actors/utils/make-debugger");
 var { DebuggerServer } = worker.require("devtools/server/main");
 
 DebuggerServer.init();
 DebuggerServer.createRootActor = function () {
   throw new Error("Should never get here!");
 };
@@ -49,44 +50,83 @@ this.addEventListener("message",  functi
     };
 
     // Step 4: Create a thread actor for the connection to the parent.
     let pool = new ActorPool(connection);
     connection.addActorPool(pool);
 
     let sources = null;
 
-    let actor = new ThreadActor({
+    let parent = {
       makeDebugger: makeDebugger.bind(null, {
         findDebuggees: () => {
           return [this.global];
         },
 
         shouldAddNewGlobalAsDebuggee: () => {
           return true;
         },
       }),
 
       get sources() {
         if (sources === null) {
           sources = new TabSources(actor);
         }
         return sources;
       }
-    }, global);
+    };
+    let actor = new ThreadActor(parent, global);
 
     pool.addActor(actor);
 
+    // let seen = [];
+    // let str = JSON.stringify(actor, function(key, val) {
+    //    if (val != null && typeof val == "object") {
+    //         if (seen.indexOf(val) >= 0) {
+    //             return;
+    //         }
+    //         seen.push(val);
+    //     }
+    //     return val;
+    // });
+
+    // dump("Connecting " + str + "\n");
+
+    let wc = new WebConsoleActor(actor.conn, {
+      makeDebugger: makeDebugger.bind(null, {
+        findDebuggees: () => {
+          return [this.global];
+        },
+
+        shouldAddNewGlobalAsDebuggee: () => {
+          return true;
+        },
+      }),
+      window: global
+    });
+
+    pool.addActor(wc);
+
+    dump("\nwc " + wc.actorID + "\n");
+    dump("\nac " + actor.actorID + "\n");
+
+    actor._webConsoleActor = wc;
+
+    // dump("Doing rpc " + wc + " " + wc.onAttach);
+    rpc("foo").then((a) => {
+      dump("Receieved rpc" + JSON.stringify(a));
+    });
+
     // Step 5: Attach to the thread actor.
     //
     // This will cause a packet to be sent over the connection to the parent.
     // Because this connection uses WorkerDebuggerTransport internally, this
     // packet will be sent using WorkerDebuggerGlobalScope.postMessage, causing
     // an onMessage event to be fired on the WorkerDebugger in the main thread.
-    actor.onAttach({});
+    actor.onAttach({ });
     break;
 
   case "disconnect":
     connections[packet.id].connection.close();
     break;
 
   case "rpc":
     let deferred = rpcDeferreds[packet.id];
diff --git a/devtools/shared/client/main.js b/devtools/shared/client/main.js
--- a/devtools/shared/client/main.js
+++ b/devtools/shared/client/main.js
@@ -499,27 +499,27 @@ DebuggerClient.prototype = {
    */
   attachConsole:
   function (aConsoleActor, aListeners, aOnResponse = noop) {
     let packet = {
       to: aConsoleActor,
       type: "startListeners",
       listeners: aListeners,
     };
-
     this.request(packet, (aResponse) => {
       let consoleClient;
       if (!aResponse.error) {
         if (this._clients.has(aConsoleActor)) {
           consoleClient = this._clients.get(aConsoleActor);
         } else {
           consoleClient = new WebConsoleClient(this, aResponse);
           this.registerClient(consoleClient);
         }
       }
+console.log("Attached", consoleClient);
       aOnResponse(aResponse, consoleClient);
     });
   },
 
   /**
    * Attach to a global-scoped thread actor for chrome debugging.
    *
    * @param string aThreadActor
@@ -1346,33 +1346,38 @@ WorkerClient.prototype = {
       this.client.unregisterClient(this);
       return aResponse;
     },
 
     telemetry: "WORKERDETACH"
   }),
 
   attachThread: function(aOptions = {}, aOnResponse = noop) {
+    console.trace();
     if (this.thread) {
       DevToolsUtils.executeSoon(() => aOnResponse({
         type: "connected",
         threadActor: this.thread._actor,
+        webConsoleActor: this.webConsoleActor,
       }, this.thread));
       return;
     }
 
     this.request({
       to: this._actor,
       type: "connect",
       options: aOptions,
     }, (aResponse) => {
+      console.log("attachThread", aResponse)
       if (!aResponse.error) {
         this.thread = new ThreadClient(this, aResponse.threadActor);
+        this.webConsoleActor = aResponse.webConsoleActor;
         this.client.registerClient(this.thread);
       }
+
       aOnResponse(aResponse, this.thread);
     });
   },
 
   _onClose: function () {
     this.removeListener("close", this._onClose);
     this.removeListener("freeze", this._onFreeze);
     this.removeListener("thaw", this._onThaw);
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -276,37 +276,47 @@ WebConsoleClient.prototype = {
       type: "evaluateJSAsync",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
     };
 
+    dump("this._client.request " + JSON.stringify(packet) + "\n\n");
+
     this._client.request(packet, response => {
       // Null check this in case the client has been detached while waiting
       // for a response.
       if (this.pendingEvaluationResults) {
         this.pendingEvaluationResults.set(response.resultID, aOnResponse);
       }
     });
   },
 
   /**
    * Handler for the actors's unsolicited evaluationResult packet.
    */
   onEvaluationResult: function(aNotification, aPacket) {
+    // The evaluation request came from a worker, the main thread's client
+    // receives this callback.
+    // XXX: Eddy, is this expected?
+    if (aPacket.from !== this._actor) {
+      return;
+    }
+
     // Find the associated callback based on this ID, and fire it.
     // In a sync evaluation, this would have already been called in
     // direct response to the client.request function.
     let onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
     if (onResponse) {
       onResponse(aPacket);
       this.pendingEvaluationResults.delete(aPacket.resultID);
-    } else {
+    } else if (!isWorker) {
+      debugger;
       DevToolsUtils.reportException("onEvaluationResult",
         "No response handler for an evaluateJSAsync result (resultID: " + aPacket.resultID + ")");
     }
   },
 
   /**
    * Autocomplete a JavaScript expression.
    *
diff --git a/devtools/shared/webconsole/moz.build b/devtools/shared/webconsole/moz.build
--- a/devtools/shared/webconsole/moz.build
+++ b/devtools/shared/webconsole/moz.build
@@ -10,9 +10,10 @@ if CONFIG['OS_TARGET'] != 'Android':
 
 DevToolsModules(
     'client.js',
     'network-helper.js',
     'network-monitor.js',
     'server-logger-monitor.js',
     'server-logger.js',
     'utils.js',
+    'worker-utils.js',
 )
diff --git a/devtools/shared/webconsole/worker-utils.js b/devtools/shared/webconsole/worker-utils.js
new file mode 100644
--- /dev/null
+++ b/devtools/shared/webconsole/worker-utils.js
@@ -0,0 +1,28 @@
+// This file is loaded on the server side for worker debugging.
+// Since the server is running in the worker thread, it doesn't
+// have access to things
+
+exports.Utils = {
+
+  l10n: function() {
+
+  },
+};
+let ConsoleServiceListener = function(window, aListener) {
+
+};
+exports.ConsoleServiceListener = ConsoleServiceListener;
+
+exports.ConsoleAPIListener = function() {
+
+};
+exports.addWebConsoleCommands = function() {
+
+};
+exports.JSPropertyProvider = function() {
+
+};
+exports.ConsoleReflowListener = function() {
+
+};
+exports.CONSOLE_WORKER_IDS = [];
\ No newline at end of file
