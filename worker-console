# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  d91e585c5a373d27d6338b0106a1b5b98beefe33
Bug 1209353 - Try to create a console actor in worker

diff --git a/devtools/client/debugger/test/mochitest/browser.ini b/devtools/client/debugger/test/mochitest/browser.ini
--- a/devtools/client/debugger/test/mochitest/browser.ini
+++ b/devtools/client/debugger/test/mochitest/browser.ini
@@ -567,16 +567,18 @@ skip-if = e10s && debug
 [browser_dbg_variables-view-reexpand-03.js]
 skip-if = e10s && debug
 [browser_dbg_variables-view-webidl.js]
 skip-if = e10s && debug
 [browser_dbg_watch-expressions-01.js]
 skip-if = e10s && debug
 [browser_dbg_watch-expressions-02.js]
 skip-if = e10s && debug
+[browser_dbg_worker-console.js]
+skip-if = e10s && debug
 [browser_dbg_worker-window.js]
 skip-if = e10s && debug
 [browser_dbg_WorkerActor.attach.js]
 skip-if = e10s && debug
 [browser_dbg_WorkerActor.attachThread.js]
 skip-if = e10s && debug
 [browser_dbg_split-console-keypress.js]
 skip-if = e10s && debug
diff --git a/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js b/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js
@@ -0,0 +1,135 @@
+// Check to make sure that a worker can be attached to a toolbox
+// and that the console works.
+// XXX: The test is in debugger/ since it's easier.. should move this
+// to an appropriate place before landing
+
+var TAB_URL = EXAMPLE_URL + "doc_WorkerActor.attachThread-tab.html";
+var WORKER_URL = "code_WorkerActor.attachThread-worker.js";
+
+DebuggerServer.init();
+DebuggerServer.addBrowserActors();
+
+function* initDebuggerForTab(TAB_URL, WORKER_URL) {
+
+  let client = new DebuggerClient(DebuggerServer.connectPipe());
+  yield connect(client);
+
+  let tab = yield addTab(TAB_URL);
+  let { tabs } = yield listTabs(client);
+  let [, tabClient] = yield attachTab(client, findTab(tabs, TAB_URL));
+
+  yield listWorkers(tabClient);
+  yield createWorkerInTab(tab, WORKER_URL);
+
+  let { workers } = yield listWorkers(tabClient);
+  let [, workerClient] = yield attachWorker(tabClient,
+                                             findWorker(workers, WORKER_URL));
+
+  let toolbox = yield gDevTools.showToolbox(TargetFactory.forWorker(workerClient),
+                                            "jsdebugger",
+                                            Toolbox.HostType.WINDOW);
+
+  let debuggerPanel = toolbox.getCurrentPanel();
+  let gDebugger = debuggerPanel.panelWin;
+
+  return {client,tab,tabClient,workerClient,toolbox,gDebugger};
+}
+
+add_task(function* testPaused() {
+  let {client,tab,tabClient,workerClient,toolbox,gDebugger} = yield initDebuggerForTab(TAB_URL, WORKER_URL);
+
+  let gTarget = gDebugger.gTarget;
+  let gResumeButton = gDebugger.document.getElementById("resume");
+  let gResumeKey = gDebugger.document.getElementById("resumeKey");
+
+  // Execute some basic math to make sure evaluations are working.
+  let jsterm = yield getSplitConsole(toolbox);
+  let executed = yield jsterm.execute("10000+1");
+  ok(executed.textContent.includes("10001"), "Text for message appeared correct");
+
+  // Pause the worker by waiting for next execution and then sending a message to
+  // it from the main thread.
+  let oncePaused = gTarget.once("thread-paused");
+  EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+  yield evalInTab(tab, `
+    worker.postMessage('ping');
+  `);
+  yield oncePaused;
+
+  // EDDY: here is the bug I was discussing.
+  // Try a couple more commands.  There is a bug here where the command doesn't
+  // finish executing until after we resume the debugger.
+  // In the main thread we could usually yield on this line but for some reason
+  // the result doesn't actually return until *after* the thread resumes
+  let command1 = jsterm.execute("10000+2");
+  let command2 = jsterm.execute("10000+3");
+  let command3 = jsterm.execute("foobar"); // throw an error
+
+  info ("Trying to get the result of command1");
+  executed = yield command1;
+  ok(executed.textContent.includes("10002"),
+      "command1 executed successfully");
+
+  info ("Trying to get the result of command2");
+  executed = yield command2;
+  ok(executed.textContent.includes("10003"),
+      "command2 executed successfully");
+
+  info ("Trying to get the result of command3")
+  executed = yield command3;
+  ok(executed.textContent.includes("ReferenceError: foobar is not defined"),
+      "command3 executed successfully");
+
+  // We shouldn't have to do this..
+  EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+
+  // yield new Promise(() => {});
+
+  yield gDevTools.closeToolbox(TargetFactory.forWorker(workerClient));
+  terminateWorkerInTab(tab, WORKER_URL);
+  yield waitForWorkerClose(workerClient);
+  yield close(client);
+});
+
+// Test to see if creating the pause from the console works.
+// add_task(function* testPauseByConsole() {
+//   let {client,tab,tabClient,workerClient,toolbox,gDebugger} = yield initDebuggerForTab(TAB_URL, WORKER_URL);
+
+//   let gTarget = gDebugger.gTarget;
+//   let gResumeButton = gDebugger.document.getElementById("resume");
+//   let gResumeKey = gDebugger.document.getElementById("resumeKey");
+
+//   let jsterm = yield getSplitConsole(toolbox);
+//   let executed = yield jsterm.execute("10000+1");
+
+//   ok(executed.textContent.includes("10001"),
+//       "Text for message appeared correct");
+
+//   let oncePaused = gTarget.once("thread-paused");
+//   EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+//   executed = yield jsterm.execute("10000+2");
+//   yield oncePaused;
+
+//   ok(executed.textContent.includes("10002"),
+//       "Text for message appeared correct");
+
+//   yield gDevTools.closeToolbox(TargetFactory.forWorker(workerClient));
+//   terminateWorkerInTab(tab, WORKER_URL);
+//   yield waitForWorkerClose(workerClient);
+//   yield close(client);
+// });
+
+function getSplitConsole(toolbox) {
+  return new Promise(resolve => {
+    toolbox.once("webconsole-ready", () => {
+      ok(toolbox.splitConsole, "Split console is shown.");
+      let jsterm = toolbox.getPanel("webconsole").hud.jsterm;
+      resolve(jsterm);
+    });
+    EventUtils.synthesizeKey("VK_ESCAPE", {}, toolbox.doc.defaultView);
+  });
+}
+
+registerCleanupFunction(() => {
+  Services.prefs.clearUserPref("devtools.toolbox.splitconsoleEnabled");
+});
diff --git a/devtools/client/debugger/test/mochitest/code_frame-script.js b/devtools/client/debugger/test/mochitest/code_frame-script.js
--- a/devtools/client/debugger/test/mochitest/code_frame-script.js
+++ b/devtools/client/debugger/test/mochitest/code_frame-script.js
@@ -32,16 +32,17 @@ this.generateMouseClick = function (path
                                      target.ownerDocument.defaultView);
 };
 
 this.createWorker = function (url) {
   dump("Creating worker with url '" + url + "'.\n");
 
   return new Promise(function (resolve, reject) {
     let worker = new content.Worker(url);
+    XPCNativeWrapper.unwrap(content).worker = worker;
     worker.addEventListener("message", function listener() {
       worker.removeEventListener("message", listener);
       workers[url] = worker;
       resolve();
     });
   });
 };
 
diff --git a/devtools/client/framework/target.js b/devtools/client/framework/target.js
--- a/devtools/client/framework/target.js
+++ b/devtools/client/framework/target.js
@@ -699,16 +699,18 @@ TabWebProgressListener.prototype = {
     this.target._navWindow = null;
     this.target = null;
   }
 };
 
 function WorkerTarget(workerClient) {
   EventEmitter.decorate(this);
   this._workerClient = workerClient;
+  console.trace();
+  console.log("WorkerTarget created in target.js", this._workerClient);
 }
 
 /**
  * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
  * either a local or remote tab, WorkerTarget always represents a remote worker.
  * Moreover, unlike TabTarget, which is constructed with a placeholder object
  * for remote tabs (from which a TabClient can then be lazily obtained),
  * WorkerTarget is constructed with a WorkerClient directly.
@@ -731,19 +733,25 @@ WorkerTarget.prototype = {
   get isTabActor() {
     return true;
   },
 
   get url() {
     return this._workerClient.url;
   },
 
+  get isWorkerTarget() {
+    return true;
+  },
+
   get form() {
+    console.log("get form()", this._workerClient);
     return {
       from: this._workerClient.actor,
+      consoleActor: this._workerClient.webConsoleActor,
       type: "attached",
       isFrozen: this._workerClient.isFrozen,
       url: this._workerClient.url
     };
   },
 
   get activeTab() {
     return this._workerClient;
@@ -758,10 +766,12 @@ WorkerTarget.prototype = {
   hasActor: function() {
     return false;
   },
 
   getTrait: function() {
     return undefined;
   },
 
-  makeRemote: function() {}
+  makeRemote: function() {
+    console.log("makeRemote()", this);
+  }
 };
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -5017,23 +5017,27 @@ WebConsoleConnectionProxy.prototype = {
       this._connectTimer.cancel();
       this._connectTimer = null;
     }, () => {
       this._connectTimer = null;
     });
 
     let client = this.client = this.target.client;
 
-    client.addListener("logMessage", this._onLogMessage);
-    client.addListener("pageError", this._onPageError);
-    client.addListener("consoleAPICall", this._onConsoleAPICall);
-    client.addListener("fileActivity", this._onFileActivity);
-    client.addListener("reflowActivity", this._onReflowActivity);
-    client.addListener("serverLogCall", this._onServerLogCall);
-    client.addListener("lastPrivateContextExited", this._onLastPrivateContextExited);
+    if (this.target.isWorkerTarget) {
+      // XXX: Not handling the Console API yet inside of workers (Bug 1209353).
+    } else {
+      client.addListener("logMessage", this._onLogMessage);
+      client.addListener("pageError", this._onPageError);
+      client.addListener("consoleAPICall", this._onConsoleAPICall);
+      client.addListener("fileActivity", this._onFileActivity);
+      client.addListener("reflowActivity", this._onReflowActivity);
+      client.addListener("serverLogCall", this._onServerLogCall);
+      client.addListener("lastPrivateContextExited", this._onLastPrivateContextExited);
+    }
     this.target.on("will-navigate", this._onTabNavigated);
     this.target.on("navigate", this._onTabNavigated);
 
     this._consoleActor = this.target.form.consoleActor;
     if (this.target.isTabActor) {
       let tab = this.target.form;
       this.owner.onLocationChange(tab.url, tab.title);
     }
@@ -5057,16 +5061,17 @@ WebConsoleConnectionProxy.prototype = {
   },
 
   /**
    * Attach to the Web Console actor.
    * @private
    */
   _attachConsole: function WCCP__attachConsole()
   {
+    console.log("Attaching client now " + this._consoleActor);
     let listeners = ["PageError", "ConsoleAPI", "NetworkActivity",
                      "FileActivity"];
     this.client.attachConsole(this._consoleActor, listeners,
                               this._onAttachConsole);
   },
 
   /**
    * The "attachConsole" response handler.
@@ -5083,16 +5088,17 @@ WebConsoleConnectionProxy.prototype = {
     if (aResponse.error) {
       Cu.reportError("attachConsole failed: " + aResponse.error + " " +
                      aResponse.message);
       this._connectDefer.reject(aResponse);
       return;
     }
 
     this.webConsoleClient = aWebConsoleClient;
+    console.log("frontend _onAttachConsole", aWebConsoleClient)
 
     this._hasNativeConsoleAPI = aResponse.nativeConsoleAPI;
     this.webConsoleClient.on("networkEvent", this._onNetworkEvent);
     this.webConsoleClient.on("networkEventUpdate", this._onNetworkEventUpdate);
 
     let msgs = ["PageError", "ConsoleAPI"];
     this.webConsoleClient.getCachedMessages(msgs, this._onCachedMessages);
 
diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -642,16 +642,23 @@ ThreadActor.prototype = {
     try {
       // Put ourselves in the paused state.
       let packet = this._paused();
       if (!packet) {
         return { error: "notAttached" };
       }
       packet.why = { type: "attached" };
 
+      // XXX: this is a hacky way to attach the webconsole and send the actor id
+      // in a packet
+      if (this._webConsoleActor) {
+        var webConsoleActor = this._webConsoleActor;
+        packet.webConsoleActor = webConsoleActor.actorID;
+      }
+
       this._restoreBreakpoints();
 
       // Send the response to the attach request now (rather than
       // returning it), because we're going to start a nested event loop
       // here.
       this.conn.send(packet);
 
       // Start a nested event loop.
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -1,55 +1,42 @@
 /* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
 /* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+const Services = require("Services");
 const { Cc, Ci, Cu } = require("chrome");
 const { DebuggerServer, ActorPool } = require("devtools/server/main");
 const { EnvironmentActor, ThreadActor } = require("devtools/server/actors/script");
 const { ObjectActor, LongStringActor, createValueGrip, stringIsLong } = require("devtools/server/actors/object");
 const DevToolsUtils = require("devtools/shared/DevToolsUtils");
 
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "Services",
-                                  "resource://gre/modules/Services.jsm");
-XPCOMUtils.defineLazyGetter(this, "NetworkMonitor", () => {
-  return require("devtools/shared/webconsole/network-monitor")
-         .NetworkMonitor;
-});
-XPCOMUtils.defineLazyGetter(this, "NetworkMonitorChild", () => {
-  return require("devtools/shared/webconsole/network-monitor")
-         .NetworkMonitorChild;
-});
-XPCOMUtils.defineLazyGetter(this, "ConsoleProgressListener", () => {
-  return require("devtools/shared/webconsole/network-monitor")
-         .ConsoleProgressListener;
-});
-XPCOMUtils.defineLazyGetter(this, "events", () => {
-  return require("sdk/event/core");
-});
-XPCOMUtils.defineLazyGetter(this, "ServerLoggingListener", () => {
-  return require("devtools/shared/webconsole/server-logger")
-         .ServerLoggingListener;
-});
+loader.lazyRequireGetter(this, "NetworkMonitor", "devtools/shared/webconsole/network-monitor", true);
+loader.lazyRequireGetter(this, "NetworkMonitorChild", "devtools/shared/webconsole/network-monitor", true);
+loader.lazyRequireGetter(this, "ConsoleProgressListener", "devtools/shared/webconsole/network-monitor", true);
+loader.lazyRequireGetter(this, "events", "sdk/event/core");
+loader.lazyRequireGetter(this, "ServerLoggingListener", "devtools/shared/webconsole/server-logger");
 
 for (let name of ["WebConsoleUtils", "ConsoleServiceListener",
     "ConsoleAPIListener", "addWebConsoleCommands", "JSPropertyProvider",
     "ConsoleReflowListener", "CONSOLE_WORKER_IDS"]) {
   Object.defineProperty(this, name, {
     get: function(prop) {
       if (prop == "WebConsoleUtils") {
         prop = "Utils";
       }
-      return require("devtools/shared/webconsole/utils")[prop];
+      if (isWorker) {
+        return require("devtools/shared/webconsole/worker-utils")[prop];
+      } else {
+        return require("devtools/shared/webconsole/utils")[prop];
+      }
     }.bind(null, name),
     configurable: true,
     enumerable: true
   });
 }
 
 /**
  * The WebConsoleActor implements capabilities needed for the Web Console
@@ -550,16 +537,21 @@ WebConsoleActor.prototype =
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response object which holds the startedListeners array.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
   {
+    // XXX: Not handling the Console API yet inside of workers (Bug 1209353).
+    if (isWorker) {
+       aRequest.listeners = [];
+    }
+
     let startedListeners = [];
     let window = !this.parentActor.isRootActor ? this.window : null;
     let appId = null;
     let messageManager = null;
 
     if (this._parentIsContentActor) {
       appId = this.parentActor.docShell.appId;
       messageManager = this.parentActor.messageManager;
@@ -791,17 +783,16 @@ WebConsoleActor.prototype =
    * @return object
    *         The response packet to send to with the unique id in the
    *         `resultID` field.
    */
   onEvaluateJSAsync: function WCA_onEvaluateJSAsync(aRequest)
   {
     // We want to be able to run console commands without waiting
     // for the first to return (see Bug 1088861).
-
     // First, send a response packet with the id only.
     let resultID = Date.now();
     this.conn.send({
       from: this.actorID,
       resultID: resultID
     });
 
     // Then, execute the script that may pause.
@@ -842,18 +833,22 @@ WebConsoleActor.prototype =
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
         let error = evalResult.throw;
         errorGrip = this.createValueGrip(error);
-        errorMessage = error && (typeof error === "object")
-          ? error.unsafeDereference().toString()
+        // XXX: This error seems like an empty object in a worker.
+        // Can test by running '1_1' in a normal console and worker console
+        let unsafeDereference = error && (typeof error === "object") &&
+                                error.unsafeDereference();
+        errorMessage = unsafeDereference && unsafeDereference.toString
+          ? unsafeDereference.toString()
           : "" + error;
       }
     }
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
     let resultGrip;
     try {
@@ -892,18 +887,18 @@ WebConsoleActor.prototype =
     // This is the case of the paused debugger
     if (frameActorId) {
       let frameActor = this.conn.getActor(frameActorId);
       if (frameActor) {
         let frame = frameActor.frame;
         environment = frame.environment;
       }
       else {
-        Cu.reportError("Web Console Actor: the frame actor was not found: " +
-                       frameActorId);
+        DevToolsUtils.reportException("onAutocomplete",
+          Error("The frame actor was not found: " + frameActorId));
       }
     }
     // This is the general case (non-paused debugger)
     else {
       dbgObject = this.dbg.makeGlobalObjectReference(this.evalWindow);
     }
 
     let result = JSPropertyProvider(dbgObject, environment, aRequest.text,
@@ -1025,16 +1020,21 @@ WebConsoleActor.prototype =
     addWebConsoleCommands(helpers);
 
     let evalWindow = this.evalWindow;
     function maybeExport(obj, name) {
       if (typeof obj[name] != "function") {
         return;
       }
 
+      // Workers don't have access to Cu
+      if (isWorker) {
+        return;
+      }
+
       // By default, chrome-implemented functions that are exposed to content
       // refuse to accept arguments that are cross-origin for the caller. This
       // is generally the safe thing, but causes problems for certain console
       // helpers like cd(), where we users sometimes want to pass a cross-origin
       // window. To circumvent this restriction, we use exportFunction along
       // with a special option designed for this purpose. See bug 1051224.
       obj[name] =
         Cu.exportFunction(obj[name], evalWindow, { allowCrossOriginArguments: true });
@@ -1129,18 +1129,18 @@ WebConsoleActor.prototype =
     // Find the Debugger.Frame of the given FrameActor.
     let frame = null, frameActor = null;
     if (aOptions.frameActor) {
       frameActor = this.conn.getActor(aOptions.frameActor);
       if (frameActor) {
         frame = frameActor.frame;
       }
       else {
-        Cu.reportError("Web Console Actor: the frame actor was not found: " +
-                       aOptions.frameActor);
+        DevToolsUtils.reportException("evalWithDebugger",
+          Error("The frame actor was not found: " + aOptions.frameActor));
       }
     }
 
     // If we've been given a frame actor in whose scope we should evaluate the
     // expression, be sure to use that frame's Debugger (that is, the JavaScript
     // debugger's Debugger) for the whole operation, not the console's Debugger.
     // (One Debugger will treat a different Debugger's Debugger.Object instances
     // as ordinary objects, not as references to be followed, so mixing
@@ -1210,21 +1210,29 @@ WebConsoleActor.prototype =
 
     let evalOptions;
     if (typeof aOptions.url == "string") {
       evalOptions = { url: aOptions.url };
     }
 
     let result;
     if (frame) {
+      dump("WebConsoleActor.evalWithDebugger - about to call frame.evalWithBindings " +
+           aString + "\n");
+      // XXX: This causes errors and a hang when evaluating a script on an already paused
+      // environment, in which the first call will never return anymore and no subsequent
+      // calls will ever work.
       result = frame.evalWithBindings(aString, bindings, evalOptions);
     }
     else {
+      dump("WebConsoleActor.evalWithDebugger - about to call dbgWindow.executeInGlobalWithBindings " +
+           aString + "\n");
       result = dbgWindow.executeInGlobalWithBindings(aString, bindings, evalOptions);
     }
+    dump("evalWithDebugger finished with result: " + JSON.stringify(result) + "\n");
 
     let helperResult = helpers.helperResult;
     delete helpers.evalInput;
     delete helpers.helperResult;
     delete helpers.selectedNode;
 
     if ($) {
       bindings.$ = $;
diff --git a/devtools/server/actors/worker.js b/devtools/server/actors/worker.js
--- a/devtools/server/actors/worker.js
+++ b/devtools/server/actors/worker.js
@@ -37,16 +37,17 @@ function WorkerActor(dbg) {
 }
 
 WorkerActor.prototype = {
   actorPrefix: "worker",
 
   form: function () {
     return {
       actor: this.actorID,
+      webConsoleActor: this._webConsoleActor,
       url: this._dbg.url,
       type: this._dbg.type
     };
   },
 
   onAttach: function () {
     if (this._dbg.isClosed) {
       return { error: "closed" };
@@ -83,23 +84,25 @@ WorkerActor.prototype = {
       return {
         type: "connected",
         threadActor: this._threadActor
       };
     }
 
     return DebuggerServer.connectToWorker(
       this.conn, this._dbg, this.actorID, request.options
-    ).then(({ threadActor, transport }) => {
+    ).then(({ threadActor, transport, webConsoleActor }) => {
       this._threadActor = threadActor;
       this._transport = transport;
+      this._webConsoleActor = webConsoleActor;
 
       return {
         type: "connected",
-        threadActor: this._threadActor
+        threadActor: this._threadActor,
+        webConsoleActor: this._webConsoleActor
       };
     }, (error) => {
       return { error: error.toString() };
     });
   },
 
   onClose: function () {
     if (this._isAttached) {
diff --git a/devtools/server/main.js b/devtools/server/main.js
--- a/devtools/server/main.js
+++ b/devtools/server/main.js
@@ -883,16 +883,17 @@ var DebuggerServer = {
 
           // Ensure that any packets received from the client on the main thread
           // to actors on the worker thread are forwarded to the server on the
           // worker thread.
           aConnection.setForwarding(aId, transport);
 
           resolve({
             threadActor: message.from,
+            webConsoleActor: message.webConsoleActor,
             transport: transport
           });
         }
       };
       aDbg.addListener(listener);
     });
   },
 
diff --git a/devtools/server/worker.js b/devtools/server/worker.js
--- a/devtools/server/worker.js
+++ b/devtools/server/worker.js
@@ -19,16 +19,17 @@ this.rpc = function (method, ...params) 
   return deferred.promise;
 };
 
 loadSubScript("resource://gre/modules/devtools/shared/worker/loader.js");
 
 var Promise = worker.require("promise");
 var { ActorPool } = worker.require("devtools/server/actors/common");
 var { ThreadActor } = worker.require("devtools/server/actors/script");
+var { WebConsoleActor } = worker.require("devtools/server/actors/webconsole");
 var { TabSources } = worker.require("devtools/server/actors/utils/TabSources");
 var makeDebugger = worker.require("devtools/server/actors/utils/make-debugger");
 var { DebuggerServer } = worker.require("devtools/server/main");
 
 DebuggerServer.init();
 DebuggerServer.createRootActor = function () {
   throw new Error("Should never get here!");
 };
@@ -49,37 +50,55 @@ this.addEventListener("message",  functi
     };
 
     // Step 4: Create a thread actor for the connection to the parent.
     let pool = new ActorPool(connection);
     connection.addActorPool(pool);
 
     let sources = null;
 
-    let actor = new ThreadActor({
+    let parent = {
       makeDebugger: makeDebugger.bind(null, {
         findDebuggees: () => {
           return [this.global];
         },
 
         shouldAddNewGlobalAsDebuggee: () => {
           return true;
         },
       }),
 
       get sources() {
         if (sources === null) {
           sources = new TabSources(actor);
         }
         return sources;
-      }
-    }, global);
+      },
+
+      window: global
+    };
+    let actor = new ThreadActor(parent, global);
 
     pool.addActor(actor);
 
+    let wc = new WebConsoleActor(actor.conn, parent);
+
+    pool.addActor(wc);
+
+    dump("server/worker.js - created thread actor: " + actor.actorID + "\n");
+    dump("server/worker.js - created webconsole actor: " + wc.actorID + "\n");
+
+    // XXX: this is a hacky way to attach the webconsole and send the actor id.
+    actor._webConsoleActor = wc;
+
+    // dump("Doing rpc " + wc + " " + wc.onAttach);
+    // rpc("foo").then((a) => {
+    //   dump("Receieved rpc" + JSON.stringify(a));
+    // });
+
     // Step 5: Attach to the thread actor.
     //
     // This will cause a packet to be sent over the connection to the parent.
     // Because this connection uses WorkerDebuggerTransport internally, this
     // packet will be sent using WorkerDebuggerGlobalScope.postMessage, causing
     // an onMessage event to be fired on the WorkerDebugger in the main thread.
     actor.onAttach({});
     break;
diff --git a/devtools/shared/client/main.js b/devtools/shared/client/main.js
--- a/devtools/shared/client/main.js
+++ b/devtools/shared/client/main.js
@@ -1350,27 +1350,29 @@ WorkerClient.prototype = {
     telemetry: "WORKERDETACH"
   }),
 
   attachThread: function(aOptions = {}, aOnResponse = noop) {
     if (this.thread) {
       DevToolsUtils.executeSoon(() => aOnResponse({
         type: "connected",
         threadActor: this.thread._actor,
+        webConsoleActor: this.webConsoleActor,
       }, this.thread));
       return;
     }
 
     this.request({
       to: this._actor,
       type: "connect",
       options: aOptions,
     }, (aResponse) => {
       if (!aResponse.error) {
         this.thread = new ThreadClient(this, aResponse.threadActor);
+        this.webConsoleActor = aResponse.webConsoleActor;
         this.client.registerClient(this.thread);
       }
       aOnResponse(aResponse, this.thread);
     });
   },
 
   _onClose: function () {
     this.removeListener("close", this._onClose);
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -289,16 +289,23 @@ WebConsoleClient.prototype = {
       }
     });
   },
 
   /**
    * Handler for the actors's unsolicited evaluationResult packet.
    */
   onEvaluationResult: function(aNotification, aPacket) {
+    // The evaluation request came from a worker, the main thread's client
+    // receives this callback.
+    // XXX: Eddy, is this expected?
+    if (aPacket.from !== this._actor) {
+      return;
+    }
+
     // Find the associated callback based on this ID, and fire it.
     // In a sync evaluation, this would have already been called in
     // direct response to the client.request function.
     let onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
     if (onResponse) {
       onResponse(aPacket);
       this.pendingEvaluationResults.delete(aPacket.resultID);
     } else {
diff --git a/devtools/shared/webconsole/moz.build b/devtools/shared/webconsole/moz.build
--- a/devtools/shared/webconsole/moz.build
+++ b/devtools/shared/webconsole/moz.build
@@ -10,9 +10,10 @@ if CONFIG['OS_TARGET'] != 'Android':
 
 DevToolsModules(
     'client.js',
     'network-helper.js',
     'network-monitor.js',
     'server-logger-monitor.js',
     'server-logger.js',
     'utils.js',
+    'worker-utils.js',
 )
diff --git a/devtools/shared/webconsole/worker-utils.js b/devtools/shared/webconsole/worker-utils.js
new file mode 100644
--- /dev/null
+++ b/devtools/shared/webconsole/worker-utils.js
@@ -0,0 +1,30 @@
+// This file is loaded on the server side for worker debugging.
+// Since the server is running in the worker thread, it doesn't
+// have access to Services / Components.  This functionality
+// is stubbed out to prevent errors, and will need to implemented
+// for Bug 1209353.
+
+exports.Utils = {
+
+  l10n: function() {
+
+  },
+};
+let ConsoleServiceListener = function(window, aListener) {
+
+};
+exports.ConsoleServiceListener = ConsoleServiceListener;
+
+exports.ConsoleAPIListener = function() {
+
+};
+exports.addWebConsoleCommands = function() {
+
+};
+exports.JSPropertyProvider = function() {
+
+};
+exports.ConsoleReflowListener = function() {
+
+};
+exports.CONSOLE_WORKER_IDS = [];
diff --git a/devtools/shared/worker/loader.js b/devtools/shared/worker/loader.js
--- a/devtools/shared/worker/loader.js
+++ b/devtools/shared/worker/loader.js
@@ -437,18 +437,22 @@ var {
       xpcInspector
     };
   } else { // Worker thread
     let requestors = [];
 
     let scope = this;
 
     let xpcInspector = {
+      get eventLoopNestLevel() {
+        return requestors.length;
+      },
+
       get lastNestRequestor() {
-        return requestors.length === 0 ? null : requestors[0];
+        return requestors.length === 0 ? null : requestors[requestors.length - 1];
       },
 
       enterNestedEventLoop: function (requestor) {
         requestors.push(requestor);
         scope.enterEventLoop();
         return requestors.length;
       },
 
