# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  84a280a8e16af2624a8cf9dd438dad9179f51dbc
Bug 123

diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -536,17 +536,17 @@ RequestsMenuView.prototype = Heritage.ex
         useCapture: true
       }]
     });
 
     $("#details-pane-toggle").disabled = false;
     $("#requests-menu-empty-notice").hidden = true;
 
     this.refreshSummary();
-    this.refreshZebra();
+    this.refreshZebra(true);
     this.refreshTooltip(requestItem);
 
     if (aId == this._preferredItemId) {
       this.selectedItem = requestItem;
     }
   },
 
   /**
@@ -1115,19 +1115,32 @@ RequestsMenuView.prototype = Heritage.ex
       .replace("#2", L10N.numberWithDecimals((totalBytes || 0) / 1024, CONTENT_SIZE_DECIMALS))
       .replace("#3", L10N.numberWithDecimals((totalMillis || 0) / 1000, REQUEST_TIME_DECIMALS))
     );
   },
 
   /**
    * Adds odd/even attributes to all the visible items in this container.
    */
-  refreshZebra: function() {
+  refreshZebra: function(lastElementOnly) {
     let visibleItems = this.visibleItems;
 
+    // Optimization used when only pushing an element onto the end of the list.
+    // In this case we only care to stripe the most recent item.
+    if (lastElementOnly && visibleItems.length) {
+      let i = visibleItems.length - 1;
+      let requestTarget = visibleItems[i].target
+      if (i % 2 == 0) {
+        requestTarget.setAttribute("even", "");
+      } else {
+        requestTarget.setAttribute("odd", "");
+      }
+      return;
+    }
+
     for (let i = 0, len = visibleItems.length; i < len; i++) {
       let requestItem = visibleItems[i];
       let requestTarget = requestItem.target;
 
       if (i % 2 == 0) {
         requestTarget.setAttribute("even", "");
         requestTarget.removeAttribute("odd");
       } else {
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,17 +5,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
+const {DeferredTask} = Cu.import("resource://gre/modules/DeferredTask.jsm", {});
 
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
@@ -53,16 +55,27 @@ this.SideMenuWidget = function SideMenuW
   this._parent.appendChild(this._list);
 
   // Menu items can optionally be grouped.
   this._groupsByName = new Map(); // Can't use a WeakMap because keys are strings.
   this._orderedGroupElementsArray = [];
   this._orderedMenuElementsArray = [];
   this._itemsByElement = new Map();
 
+  // this._list.addEventListener("scroll", () => {
+  //   if (this._list.lastElementChild) {
+  //   let cwu = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+  //                   .getInterface(Ci.nsIDOMWindowUtils);
+  //   let rect = cwu.getBoundsWithoutFlushing(this._list.lastElementChild);
+  //   let rect2 = cwu.getBoundsWithoutFlushing(this._list);
+
+  //   console.log("AT bottom?", (rect.height + rect.top) < rect2.bottom, rect.height + rect.top, rect2.bottom);
+  //   // console.log(rect, rect2, this._list.scrollTop, this._list.scrollHeight);
+  //   }
+  // });
   // This widget emits events that can be handled in a MenuContainer.
   EventEmitter.decorate(this);
 
   // Delegate some of the associated node's methods to satisfy the interface
   // required by MenuContainer instances.
   ViewHelpers.delegateWidgetAttributeMethods(this, aNode);
   ViewHelpers.delegateWidgetEventMethods(this, aNode);
 };
@@ -98,40 +111,83 @@ SideMenuWidget.prototype = {
    *        Some attached primitive/object. Custom options supported:
    *          - group: a string specifying the group to place this item into
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
+
+    // if (this._list.lastElementChild) {
+    // let rect = cwu.getBoundsWithoutFlushing(this._list.lastElementChild);
+    // let rect2 = cwu.getBoundsWithoutFlushing(this._list);
+    // // console.log(rect, rect2, this._list.scrollTop, this._list.scrollHeight);
+
+    // // console.log("AT bottom?", (rect.height + rect.top) < rect2.bottom, rect.height + rect.top, rect2.bottom);
+    // }
+
+
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
     // needlessly expensive operations that may cause reflows):
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
       // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+      this.isScrolledToBottom();
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
     if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
+      this.scrollToBottom();
     }
 
     return element;
   },
 
+  scrollToBottom: function() {
+    let window = this.window;
+    function onscroll() {
+        // console.log("QUEUE DISARMING");
+      this._queuedRequestHandler.disarm();
+      window.removeEventListener("scroll", onscroll);
+    }
+
+    if (!this._queuedRequestHandler) {
+      this._queuedRequestHandler = new DeferredTask(() => {
+        // console.log("QUEUE FIRING", this._numberOfCalls);
+        this._numberOfCalls = 0;
+        this._list.scrollTop = this._list.scrollHeight;
+        window.removeEventListener("scroll", onscroll);
+      }, 10);
+    }
+
+    this._numberOfCalls = (this._numberOfCalls || 0) + 1;
+    window.addEventListener("scroll", onscroll);
+    this._queuedRequestHandler.arm();
+  },
+
+  isScrolledToBottom: function() {
+    if (this._list.lastElementChild) {
+      let domUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                .getInterface(Ci.nsIDOMWindowUtils);
+      let groupRect = domUtils.getBoundsWithoutFlushing(this._list.lastElementChild);
+      let listRect = domUtils.getBoundsWithoutFlushing(this._list);
+      return (groupRect.height + groupRect.top) < listRect.bottom;
+    }
+    return false;
+  },
+
   /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
