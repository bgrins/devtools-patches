# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a1547d926bac41b756756ef1a735a53f3a8a98cc
Bug 1143224 - Use getBoundsWithoutFlushing and scroll less often in the SideMenuWidget to speed up the netmonitor UI;r=vporof

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -8,16 +8,17 @@
 //
 thisTestLeaksUncaughtRejectionsAndShouldBeFixed("TypeError: aValue.content is undefined");
 
 /**
  * Bug 863102 - Automatically scroll down upon new network requests.
  */
 
 function test() {
+
   requestLongerTimeout(2);
   let monitor, debuggee, requestsContainer, scrollTop;
 
   initNetMonitor(INFINITE_GET_URL).then(([aTab, aDebuggee, aMonitor]) => {
     monitor = aMonitor;
     debuggee = aDebuggee;
     let win = monitor.panelWin;
     let topNode = win.document.getElementById("requests-menu-contents");
@@ -76,17 +77,22 @@ function test() {
 
   // Handle exceptions in the chain of promises.
   .then(null, (err) => {
     ok(false, err);
     finish();
   });
 
   function waitForRequestsToOverflowContainer (aMonitor, aContainer) {
-    return waitForNetworkEvents(aMonitor, 1).then(() => {
+    aMonitor.panelWin.addEventListener("scroll", function onscroll() {
+      ok(false, "scrolled");
+    }, win);
+    return waitForNetworkEvents(aMonitor, 100).then(() => {
+
+      return promise.defer().promise;
       if (aContainer.scrollHeight > aContainer.clientHeight) {
         // Wait for some more just for good measure.
         return waitForNetworkEvents(aMonitor, 8);
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
       }
     });
   }
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,19 +5,22 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
+const {DeferredTask} = Cu.import("resource://gre/modules/DeferredTask.jsm", {});
 
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
+const SCROLL_FREQUENCY = 16;
+
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
  * @param nsIDOMNode aNode
  *        The element associated with the widget.
@@ -100,39 +103,93 @@ SideMenuWidget.prototype = {
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
-    // needlessly expensive operations that may cause reflows):
+    // needlessly expensive operations):
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
       // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+      this.isScrolledToBottom();
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
     if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
+      this.scrollToBottom();
     }
 
     return element;
   },
 
   /**
+   * Checks to see if the list is scrolled all the way to the bottom.
+   * Uses getBoundsWithoutFlushing to limit the performance impact
+   * of this function.
+   *
+   * @return bool
+   */
+  isScrolledToBottom: function() {
+    if (this._list.lastElementChild) {
+      let domUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                .getInterface(Ci.nsIDOMWindowUtils);
+      let groupRect = domUtils.getBoundsWithoutFlushing(this._list.lastElementChild);
+      let listRect = domUtils.getBoundsWithoutFlushing(this._list);
+
+      // Cheap way to check if it's scrolled all the way to the bottom.
+      // const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+      // console.log(groupRect.height, groupRect.top, groupRect.bottom, listRect.bottom);
+      return (groupRect.height + groupRect.top) < listRect.bottom;
+    }
+
+    return false;
+  },
+
+  /**
+   * Scroll the list to the bottom after a timeout.
+   * If the user scrolls in the meantime, cancel this operation.
+   */
+  scrollToBottom: function() {
+    // Lazily attach this functionality to the object, so it won't get
+    // created unless if this scrollToBottom behavior is needed.
+    if (!this._scrollToBottomTask) {
+      // The scroll event fires asynchronously, so we need to keep a bit to
+      // distinguish between user-initiated events and scrollTop assignment.
+      let ignoreNextScroll = false;
+
+      // This will fire at most once every SCROLL_FREQUENCY milliseconds.
+      this._scrollToBottomTask = new DeferredTask(() => {
+        ignoreNextScroll = true;
+        this._list.scrollTop = this._list.scrollHeight;
+      }, SCROLL_FREQUENCY);
+
+      // On a scroll, cancel any pending calls to _queuedRequestHandler.
+      this._list.addEventListener("scroll", () => {
+        if (ignoreNextScroll) {
+          ignoreNextScroll = false;
+        } else {
+          this._scrollToBottomTask.disarm();
+        }
+      }, true);
+    }
+
+    this._scrollToBottomTask.arm();
+  },
+
+  /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   getItemAtIndex: function(aIndex) {
