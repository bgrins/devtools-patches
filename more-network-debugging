# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8319693198eb345275ca933f0997b283a90369ef
Bug 1143224 -

diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -536,17 +536,17 @@ RequestsMenuView.prototype = Heritage.ex
         useCapture: true
       }]
     });
 
     $("#details-pane-toggle").disabled = false;
     $("#requests-menu-empty-notice").hidden = true;
 
     this.refreshSummary();
-    this.refreshZebra();
+    this.refreshZebra(true);
     this.refreshTooltip(requestItem);
 
     if (aId == this._preferredItemId) {
       this.selectedItem = requestItem;
     }
   },
 
   /**
@@ -659,16 +659,18 @@ RequestsMenuView.prototype = Heritage.ex
 
     // Append a network request item to this container.
     let newItem = this.push([menuView], {
       attachment: Object.create(selected, {
         isCustom: { value: true }
       })
     });
 
+    this.refreshZebra();
+
     // Immediately switch to new request pane.
     this.selectedItem = newItem;
   },
 
   /**
    * Send a new HTTP request using the data in the custom request form.
    */
   sendCustomRequest: function() {
@@ -1114,31 +1116,45 @@ RequestsMenuView.prototype = Heritage.ex
       .replace("#1", visibleRequestsCount)
       .replace("#2", L10N.numberWithDecimals((totalBytes || 0) / 1024, CONTENT_SIZE_DECIMALS))
       .replace("#3", L10N.numberWithDecimals((totalMillis || 0) / 1000, REQUEST_TIME_DECIMALS))
     );
   },
 
   /**
    * Adds odd/even attributes to all the visible items in this container.
+   *
+   * @param boolean lastElementOnly
+   *        Passing true will cause only the last visible element to be striped.
+   *        Use only if you know the element was pushed onto the end.
    */
-  refreshZebra: function() {
+  refreshZebra: function(lastElementOnly) {
     let visibleItems = this.visibleItems;
 
-    for (let i = 0, len = visibleItems.length; i < len; i++) {
+    // lastElementOnly is an optimization used when only pushing an element
+    // onto the end of the list.  In this case we only want to stripe the
+    // most recent item.  Don't try it if there is a sort applied.
+    lastElementOnly = lastElementOnly &&
+                      document.querySelectorAll(".requests-menu-header-button[sorted]").length == 0;
+
+    for (let i = visibleItems.length - 1; i >= 0; i--) {
       let requestItem = visibleItems[i];
       let requestTarget = requestItem.target;
 
       if (i % 2 == 0) {
         requestTarget.setAttribute("even", "");
         requestTarget.removeAttribute("odd");
       } else {
         requestTarget.setAttribute("odd", "");
         requestTarget.removeAttribute("even");
       }
+
+      if (lastElementOnly) {
+        break;
+      }
     }
   },
 
   /**
    * Refreshes the toggling anchor for the specified item's tooltip.
    *
    * @param object aItem
    *        The network request item in this container.
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,19 +5,22 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
+const {DeferredTask} = Cu.import("resource://gre/modules/DeferredTask.jsm", {});
 
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
+const SCROLL_FREQUENCY = 16;
+
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
  * @param nsIDOMNode aNode
  *        The element associated with the widget.
@@ -100,39 +103,105 @@ SideMenuWidget.prototype = {
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
-    // needlessly expensive operations that may cause reflows):
+    // needlessly expensive operations):
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
       // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+      this.isScrolledToBottom();
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
     if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
+      this.scrollToBottom();
     }
 
     return element;
   },
 
   /**
+   * Checks to see if the list is scrolled all the way to the bottom.
+   * Uses getBoundsWithoutFlushing to limit the performance impact
+   * of this function.
+   *
+   * @return bool
+   */
+  isScrolledToBottom: function() {
+    if (this._list.lastElementChild) {
+      let domUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                .getInterface(Ci.nsIDOMWindowUtils);
+      let groupRect = domUtils.getBoundsWithoutFlushing(this._list.lastElementChild);
+      let listRect = domUtils.getBoundsWithoutFlushing(this._list);
+
+      // Cheap way to check if it's scrolled all the way to the bottom.
+      // const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+      // console.log(groupRect.height, groupRect.top, groupRect.bottom, listRect.bottom);
+      return (groupRect.height + groupRect.top) < listRect.bottom;
+    }
+    return false;
+  },
+
+  /**
+   * Scroll the list to the bottom after a timeout.
+   * If the user scrolls in the meantime, cancel this operation.
+   */
+  scrollToBottom: function() {
+      const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+    if (!this._queuedRequestHandler) {
+
+      let setScrollManually = false;
+
+      this._disarm = () => {
+        if (setScrollManually) {
+          setScrollManually = false;
+          return;
+        }
+        // Cancel the task and null out the handler so it will get recreated
+        // on the next scrollToBottom call.
+        this._queuedRequestHandler.disarm();
+        this._list.removeEventListener("scroll", this._disarm);
+        console.log("SCROLLL HAPPENED - REMOVED LISTENER");
+      };
+
+      // let scroll = disarm.bind(this);
+
+      this._queuedRequestHandler = new DeferredTask(() => {
+        console.log("ARM HAPPENED - SCROLLING");
+        this._disarm();
+
+        // setScrollManually = true;
+        this._list.scrollTop = this._list.scrollHeight;
+        console.log("ARM HAPPENED - LISTENER REMOVED");
+      }, SCROLL_FREQUENCY);
+
+    }
+
+    if (!this._queuedRequestHandler.isArmed) {
+      // If a user scroll happens while waiting for the task to execute,
+      // then cancel it.
+    console.log("ARMING");
+      this._list.addEventListener("scroll", this._disarm);
+      this._queuedRequestHandler.arm();
+    }
+  },
+
+  /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   getItemAtIndex: function(aIndex) {
