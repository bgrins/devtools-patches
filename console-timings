# HG changeset patch
# Parent 76a272052164c6fce9b8f37f1750525bd72938ab
# User Brian Grinstead <bgrinstead@mozilla.com>
timing _flushMessageQueue

diff --git a/browser/devtools/webconsole/console-output.js b/browser/devtools/webconsole/console-output.js
--- a/browser/devtools/webconsole/console-output.js
+++ b/browser/devtools/webconsole/console-output.js
@@ -809,16 +809,20 @@ Messages.Simple.prototype = Heritage.ext
   },
 
   render: function()
   {
     if (this.element) {
       return this;
     }
 
+    Messages.BaseMessage.prototype.render.call(this);
+    this.element.textContent = 'hi';
+    return this;
+
     let timestamp = new Widgets.MessageTimestamp(this, this.timestamp).render();
 
     let icon = this.document.createElementNS(XHTML_NS, "span");
     icon.className = "icon";
 
     // Apply the current group by indenting appropriately.
     // TODO: remove this once bug 778766 is fixed.
     let indent = this._groupDepthCompat * COMPAT.GROUP_INDENT;
@@ -832,16 +836,18 @@ Messages.Simple.prototype = Heritage.ext
     let repeatNode = this._renderRepeatNode();
     let location = this._renderLocation();
 
     Messages.BaseMessage.prototype.render.call(this);
     if (this._className) {
       this.element.className += " " + this._className;
     }
 
+    this.element.textContent = 'hi';
+    return this;
     this.element.appendChild(timestamp.element);
     this.element.appendChild(indentNode);
     this.element.appendChild(icon);
     this.element.appendChild(body);
     if (repeatNode) {
       this.element.appendChild(repeatNode);
     }
     if (location) {
@@ -1696,16 +1702,18 @@ Widgets.BaseWidget.prototype = {
    * @param string [textContent]
    *        If this argument is provided the value is used as the textContent of
    *        the new DOM element.
    * @return DOMElement
    *         The new DOM element.
    */
   el: function(tagNameIdAndClasses)
   {
+    let elem = this.document.createElementNS(XHTML_NS, tagName);
+    return elem;
     let attrs, text;
     if (typeof arguments[1] == "object") {
       attrs = arguments[1];
       text = arguments[2];
     } else {
       text = arguments[1];
     }
 
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -2070,34 +2070,36 @@ WebConsoleFrame.prototype = {
     // Determine how many messages we can display now.
     let toDisplay = Math.min(this._outputQueue.length, MESSAGES_IN_INTERVAL);
     if (toDisplay < 1) {
       this._outputTimerInitialized = false;
       return;
     }
 
     // Try to prune the message queue.
+    console.time("Prune output queue");
     let shouldPrune = false;
     if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
       toDisplay = Math.min(this._outputQueue.length, toDisplay);
       shouldPrune = true;
     }
-
+    console.timeEnd("Prune output queue");
     let batch = this._outputQueue.splice(0, toDisplay);
     if (!batch.length) {
       this._outputTimerInitialized = false;
       return;
     }
-
+    // console.time("Flush message queue outer");
     let outputNode = this.outputNode;
     let lastVisibleNode = null;
     let scrollNode = outputNode.parentNode;
+    let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
     let scrolledToBottom = Utils.isOutputScrolledToBottom(outputNode);
-    let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
-
+
+    console.time("Output the current batch of messages.");
     // Output the current batch of messages.
     let newMessages = new Set();
     let updatedMessages = new Set();
     for (let item of batch) {
       let result = this._outputMessageFromQueue(hudIdSupportsString, item);
       if (result) {
         if (result.isRepeated) {
           updatedMessages.add(result.isRepeated);
@@ -2105,49 +2107,55 @@ WebConsoleFrame.prototype = {
         else {
           newMessages.add(result.node);
         }
         if (result.visible && result.node == this.outputNode.lastChild) {
           lastVisibleNode = result.node;
         }
       }
     }
+    console.timeEnd("Output the current batch of messages.");
 
     let oldScrollHeight = 0;
 
     // Prune messages if needed. We do not do this for every flush call to
     // improve performance.
     let removedNodes = 0;
+    console.time("Prune DOM if needed");
     if (shouldPrune || !this._outputQueue.length) {
       oldScrollHeight = scrollNode.scrollHeight;
 
       let categories = Object.keys(this._pruneCategoriesQueue);
       categories.forEach(function _pruneOutput(aCategory) {
         removedNodes += this.pruneOutputIfNecessary(aCategory);
       }, this);
       this._pruneCategoriesQueue = {};
     }
+    console.timeEnd("Prune DOM if needed");
 
     let isInputOutput = lastVisibleNode &&
                         (lastVisibleNode.category == CATEGORY_INPUT ||
                          lastVisibleNode.category == CATEGORY_OUTPUT);
 
     // Scroll to the new node if it is not filtered, and if the output node is
     // scrolled at the bottom or if the new node is a jsterm input/output
     // message.
+    console.time("scrollToVisible");
     if (lastVisibleNode && (scrolledToBottom || isInputOutput)) {
       Utils.scrollToVisible(lastVisibleNode);
     }
     else if (!scrolledToBottom && removedNodes > 0 &&
              oldScrollHeight != scrollNode.scrollHeight) {
       // If there were pruned messages and if scroll is not at the bottom, then
       // we need to adjust the scroll location.
       scrollNode.scrollTop -= oldScrollHeight - scrollNode.scrollHeight;
     }
-
+    console.timeEnd("scrollToVisible");
+
+    console.time("finishing up");
     if (newMessages.size) {
       this.emit("messages-added", newMessages);
     }
     if (updatedMessages.size) {
       this.emit("messages-updated", updatedMessages);
     }
 
     // If the queue is not empty, schedule another flush.
@@ -2157,16 +2165,18 @@ WebConsoleFrame.prototype = {
     else {
       this._outputTimerInitialized = false;
       if (this._flushCallback && this._flushCallback() === false) {
         this._flushCallback = null;
       }
     }
 
     this._lastOutputFlush = Date.now();
+    console.timeEnd("finishing up");
+    // console.timeEnd("Flush message queue outer");
   },
 
   /**
    * Initialize the output timer.
    * @private
    */
   _initOutputTimer: function WCF__initOutputTimer()
   {
@@ -2255,30 +2265,32 @@ WebConsoleFrame.prototype = {
       if (!(category in nodes)) {
         nodes[category] = [];
       }
       nodes[category].push(aIndex);
     }, this);
 
     let pruned = 0;
 
+    console.time("This should be slow");
     // Loop through the categories we found and prune if needed.
     for (let category in nodes) {
       let limit = Utils.logLimitForCategory(category);
       let indexes = nodes[category];
       if (indexes.length > limit) {
-        let n = Math.max(0, indexes.length - limit);
+        let n = Math.min(300, Math.max(0, indexes.length - limit));
         pruned += n;
+        console.log("Pruning ", n, " items");
         for (let i = n - 1; i >= 0; i--) {
           this._pruneItemFromQueue(this._outputQueue[indexes[i]]);
           this._outputQueue.splice(indexes[i], 1);
         }
       }
     }
-
+    console.timeEnd("This should be slow");
     return pruned;
   },
 
   /**
    * Prune an item from the output queue.
    *
    * @private
    * @param array aItem
diff --git a/browser/themes/shared/devtools/webconsole.inc.css b/browser/themes/shared/devtools/webconsole.inc.css
--- a/browser/themes/shared/devtools/webconsole.inc.css
+++ b/browser/themes/shared/devtools/webconsole.inc.css
@@ -136,16 +136,17 @@ a {
 #output-wrapper {
   direction: ltr;
   overflow: auto;
 }
 
 #output-container {
   -moz-user-select: text;
   -moz-box-flex: 1;
+  -moz-box-flex: 1;
   display: flex;
   flex-direction: column;
   align-items: flex-start;
 }
 
 #output-container.hideTimestamps > .message {
   -moz-padding-start: 0;
   -moz-margin-start: 7px;
