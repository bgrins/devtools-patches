# HG changeset patch
# User Oriol <oriol-bugzilla@hotmail.com>
# Parent  4c5fbf49376351679dcc49f4cff26c3c2e055ccc
Prevent the console from searching safe getters in proxy objects.

diff --git a/devtools/server/actors/object.js b/devtools/server/actors/object.js
--- a/devtools/server/actors/object.js
+++ b/devtools/server/actors/object.js
@@ -314,27 +314,33 @@ ObjectActor.prototype = {
    *         An object that maps property names to safe getter descriptors as
    *         defined by the remote debugging protocol.
    */
   _findSafeGetterValues: function (ownProperties, limit = 0) {
     let safeGetterValues = Object.create(null);
     let obj = this.obj;
     let level = 0, i = 0;
 
+    // Do not search safe getters in proxy objects.
+    if (obj.isProxy) {
+      return safeGetterValues;
+    }
+
     // Most objects don't have any safe getters but inherit some from their
     // prototype. Avoid calling getOwnPropertyNames on objects that may have
     // many properties like Array, strings or js objects. That to avoid
     // freezing firefox when doing so.
     if (TYPED_ARRAY_CLASSES.includes(this.obj.class) ||
         ["Array", "Object", "String"].includes(this.obj.class)) {
       obj = obj.proto;
       level++;
     }
 
-    while (obj) {
+    // Stop iterating when the prototype chain ends or a proxy is found.
+    while (obj && !obj.isProxy) {
       let getters = this._findSafeGetters(obj);
       for (let name of getters) {
         // Avoid overwriting properties from prototypes closer to this.obj. Also
         // avoid providing safeGetterValues from prototypes if property |name|
         // is already defined as an own property.
         if (name in safeGetterValues ||
             (obj != this.obj && ownProperties.indexOf(name) !== -1)) {
           continue;
diff --git a/devtools/server/tests/unit/test_objectgrips-17.js b/devtools/server/tests/unit/test_objectgrips-17.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/unit/test_objectgrips-17.js
@@ -0,0 +1,95 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+/* eslint-disable no-shadow, max-nested-callbacks */
+
+"use strict";
+
+var gDebuggee;
+var gClient;
+var gThreadClient;
+var gCallback;
+
+function run_test() {
+  run_test_with_server(DebuggerServer, function () {
+    run_test_with_server(WorkerDebuggerServer, do_test_finished);
+  });
+  do_test_pending();
+}
+
+function addTestNullPrincipalGlobal(name, server = DebuggerServer) {
+  // System principal objects are considered safe even when not wrapped in Xray,
+  // and therefore proxy traps may run. So the test needs to use a null principal.
+  let global = Cu.Sandbox(null);
+  global.__name = name;
+  server.addTestGlobal(global);
+  return global;
+}
+
+async function run_test_with_server(server, callback) {
+  gCallback = callback;
+  initTestDebuggerServer(server);
+  gDebuggee = addTestNullPrincipalGlobal("test-grips", server);
+  gDebuggee.eval(function stopMe(arg1, arg2) {
+    debugger;
+  }.toString());
+
+  gClient = new DebuggerClient(server.connectPipe());
+  await gClient.connect();
+  const [,, threadClient] = await attachTestTabAndResume(gClient, "test-grips");
+  gThreadClient = threadClient;
+  test_proxy_grip();
+}
+
+async function test_proxy_grip() {
+  gThreadClient.addOneTimeListener("paused", async function (event, packet) {
+    let [proxyGrip, inheritsProxyGrip] = packet.frame.arguments;
+
+    // Check the grip of the proxy object.
+    check_proxy_grip(proxyGrip);
+
+    // Retrieve the properties of the object which inherits from a proxy,
+    // and check the grip of its prototype.
+    let objClient = gThreadClient.pauseGrip(inheritsProxyGrip);
+    let response = await objClient.getPrototypeAndProperties();
+    check_prototype_and_properties(response);
+
+    // Check that none of the above ran proxy traps.
+    let trapDidRun = gDebuggee.eval("trapDidRun");
+    strictEqual(trapDidRun, false, "No proxy trap did run.");
+
+    await gThreadClient.resume();
+    await gClient.close();
+    gCallback();
+  });
+
+  gDebuggee.eval(`{
+    var trapDidRun = false;
+    var proxy = new Proxy({}, new Proxy({}, {get: (_, trap) => {
+      trapDidRun = true;
+      throw new Error("proxy " + trap + " trap was called.");
+    }}));
+    var inheritsProxy = Object.create(proxy, {x:{value:1}});
+    stopMe(proxy, inheritsProxy);
+  }`);
+}
+
+function check_proxy_grip(grip) {
+  strictEqual(grip.class, "Proxy", "The grip has a Proxy class.");
+  ok(grip.proxyTarget, "There is a [[ProxyTarget]] grip.");
+  ok(grip.proxyHandler, "There is a [[ProxyHandler]] grip.");
+
+  const {preview} = grip;
+  strictEqual(preview.ownPropertiesLength, 2, "The preview has 2 properties.");
+  let target = preview.ownProperties["<target>"].value;
+  strictEqual(target, grip.proxyTarget, "<target> contains the [[ProxyTarget]].");
+  let handler = preview.ownProperties["<handler>"].value;
+  strictEqual(handler, grip.proxyHandler, "<handler> contains the [[ProxyHandler]].");
+}
+
+function check_prototype_and_properties(response) {
+  let ownPropertiesLength = Reflect.ownKeys(response.ownProperties).length;
+  strictEqual(ownPropertiesLength, 1, "1 own property was retrieved.");
+  strictEqual(response.ownProperties.x.value, 1, "The property has the right value.");
+  check_proxy_grip(response.prototype);
+}
+
diff --git a/devtools/server/tests/unit/xpcshell.ini b/devtools/server/tests/unit/xpcshell.ini
--- a/devtools/server/tests/unit/xpcshell.ini
+++ b/devtools/server/tests/unit/xpcshell.ini
@@ -167,16 +167,17 @@ reason = only ran on B2G
 [test_objectgrips-09.js]
 [test_objectgrips-10.js]
 [test_objectgrips-11.js]
 [test_objectgrips-12.js]
 [test_objectgrips-13.js]
 [test_objectgrips-14.js]
 [test_objectgrips-15.js]
 [test_objectgrips-16.js]
+[test_objectgrips-17.js]
 [test_promise_state-01.js]
 [test_promise_state-02.js]
 [test_promise_state-03.js]
 [test_interrupt.js]
 [test_stepping-01.js]
 [test_stepping-02.js]
 [test_stepping-03.js]
 [test_stepping-04.js]
