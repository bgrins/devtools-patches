# HG changeset patch
# User Alexandre Poirot <poirot.alex@gmail.com>

Bug 1161072 - Destroy the walker actor on disconnect. r=bgrins

diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
index 3509717..646e80b 100644
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -1738,18 +1738,18 @@ Toolbox.prototype = {
     return this._initInspector;
   },
 
   /**
    * Destroy the inspector/walker/selection fronts
    * Returns a promise that resolves when the fronts are destroyed
    */
   destroyInspector: function() {
-    if (this._destroying) {
-      return this._destroying;
+    if (this._destroyingInspector) {
+      return this._destroyingInspector;
     }
 
     if (!this._inspector) {
       return promise.resolve();
     }
 
     let outstanding = () => {
       return Task.spawn(function*() {
@@ -1780,20 +1780,21 @@ Toolbox.prototype = {
         this._selection = null;
         this._walker = null;
       }.bind(this));
     };
 
     // Releasing the walker (if it has been created)
     // This can fail, but in any case, we want to continue destroying the
     // inspector/highlighter/selection
-    let walker = (this._destroying = this._walker) ?
+    // FF41+: Inspector actor starts managing Walker actor and auto destroy it.
+    let walker = this._walker && !this.walker.traits.autoReleased ?
                  this._walker.release() :
                  promise.resolve();
-    return walker.then(outstanding, outstanding);
+    return this._destroyingInspector = walker.then(outstanding, outstanding);
   },
 
   /**
    * Get the toolbox's notification box
    *
    * @return The notification box element.
    */
   getNotificationBox: function() {
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
index 1ef0736..bb08b8e 100644
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1299,17 +1299,23 @@ var WalkerActor = protocol.ActorClass({
     this._onReflows = this._onReflows.bind(this);
     this.reflowObserver.on("reflows", this._onReflows);
   },
 
   // Returns the JSON representation of this object over the wire.
   form: function() {
     return {
       actor: this.actorID,
-      root: this.rootNode.form()
+      root: this.rootNode.form(),
+      traits: {
+        // FF41+ Inspector starts managing the Walker, while the inspector also
+        // starts cleaning itself up automatically on client disconnection.
+        // So that there is no need to manually release the walker anymore.
+        autoReleased: true
+      }
     }
   },
 
   toString: function() {
     return "[WalkerActor " + this.actorID + "]";
   },
 
   getDocumentWalker: function(node, whatToShow) {
@@ -3130,16 +3136,18 @@ var WalkerFront = exports.WalkerFront = protocol.FrontClass(WalkerActor, {
     protocol.Front.prototype.destroy.call(this);
   },
 
   // Update the object given a form representation off the wire.
   form: function(json) {
     this.actorID = json.actor;
     this.rootNode = types.getType("domnode").read(json.root, this);
     this._rootNodeDeferred.resolve(this.rootNode);
+    // FF41+ the actor starts exposing traits
+    this.traits = json.traits || {};
   },
 
   /**
    * Clients can use walker.rootNode to get the current root node of the
    * walker, but during a reload the root node might be null.  This
    * method returns a promise that will resolve to the root node when it is
    * set.
    */
@@ -3544,16 +3552,17 @@ var InspectorActor = exports.InspectorActor = protocol.ActorClass({
     let deferred = promise.defer();
     this._walkerPromise = deferred.promise;
 
     let window = this.window;
     var domReady = () => {
       let tabActor = this.tabActor;
       window.removeEventListener("DOMContentLoaded", domReady, true);
       this.walker = WalkerActor(this.conn, tabActor, options);
+      this.manage(this.walker);
       events.once(this.walker, "destroyed", () => {
         this._walkerPromise = null;
         this._pageStylePromise = null;
       });
       deferred.resolve(this.walker);
     };
 
     if (window.document.readyState === "loading") {
