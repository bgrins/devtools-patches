# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b4d375fe1b499a2b3b827df6535473b3d506e08f
Bug 1304178 - Consistently emit the last rendered message in dom for jsterm.execute and with new-messages event;r=linclark

diff --git a/devtools/client/webconsole/jsterm.js b/devtools/client/webconsole/jsterm.js
--- a/devtools/client/webconsole/jsterm.js
+++ b/devtools/client/webconsole/jsterm.js
@@ -372,18 +372,17 @@ JSTerm.prototype = {
         result.type == "undefined" &&
         helperResult && !helperHasRawOutput) {
       callback && callback();
       return;
     }
 
     if (this.hud.NEW_CONSOLE_OUTPUT_ENABLED) {
       this.hud.newConsoleOutput.dispatchMessageAdd(response);
-      // @TODO figure out what to do about the callback.
-      callback && callback();
+      callback && callback(this.hud.newConsoleOutput.getLastMessage());
       return;
     }
     let msg = new Messages.JavaScriptEvalOutput(response,
                                                 errorMessage, errorDocLink);
     this.hud.output.addMessage(msg);
 
     if (callback) {
       let oldFlushCallback = this.hud._flushCallback;
@@ -421,17 +420,17 @@ JSTerm.prototype = {
    *        This is deprecated - please use the promise return value instead.
    * @returns Promise
    *          Resolves with the message once the result is displayed.
    */
   execute: function (executeString, callback) {
     let deferred = promise.defer();
     let resultCallback;
     if (this.hud.NEW_CONSOLE_OUTPUT_ENABLED) {
-      resultCallback = () => deferred.resolve();
+      resultCallback = (msg) => deferred.resolve(msg);
     } else {
       resultCallback = (msg) => {
         deferred.resolve(msg);
         if (callback) {
           callback(msg);
         }
       };
     }
diff --git a/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js b/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js
--- a/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js
+++ b/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js
@@ -12,16 +12,17 @@ const actions = require("devtools/client
 const { configureStore } = require("devtools/client/webconsole/new-console-output/store");
 
 const ConsoleOutput = React.createFactory(require("devtools/client/webconsole/new-console-output/components/console-output"));
 const FilterBar = React.createFactory(require("devtools/client/webconsole/new-console-output/components/filter-bar"));
 
 const store = configureStore();
 
 function NewConsoleOutputWrapper(parentNode, jsterm, toolbox, owner) {
+  this.parentNode = parentNode;
   const sourceMapService = toolbox ? toolbox._sourceMapService : null;
   let childComponent = ConsoleOutput({
     jsterm,
     sourceMapService,
     onViewSourceInDebugger: frame => toolbox.viewSourceInDebugger.call(
       toolbox,
       frame.url,
       frame.line
@@ -49,12 +50,18 @@ function NewConsoleOutputWrapper(parentN
 
 NewConsoleOutputWrapper.prototype = {
   dispatchMessageAdd: (message) => {
     store.dispatch(actions.messageAdd(message));
   },
   dispatchMessagesClear: () => {
     store.dispatch(actions.messagesClear());
   },
+  getLastMessage: function() {
+    // Return the last message in the DOM as the message that was just dispatched. This may not
+    // always be correct in the case of filtered messages, but it's close enough for our tests.
+    let messageNodes = this.parentNode.querySelectorAll(".message");
+    return messageNodes[messageNodes.length - 1]
+  },
 };
 
 // Exports from this module
 module.exports = NewConsoleOutputWrapper;
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -3257,23 +3257,19 @@ WebConsoleConnectionProxy.prototype = {
     this.webConsoleFrame._onUpdateListeners();
   },
 
   /**
    * Dispatch a message add on the new frontend and emit an event for tests.
    */
   dispatchMessageAdd: function(packet) {
     this.webConsoleFrame.newConsoleOutput.dispatchMessageAdd(packet);
-
-    // Return the last message in the DOM as the message that was just dispatched. This may not
-    // always be true in the case of filtered messages, but it's close enough for our tests.
-    let messageNodes = this.webConsoleFrame.experimentalOutputNode.querySelectorAll(".message");
     this.webConsoleFrame.emit("new-messages", new Set([{
       response: packet,
-      node: messageNodes[messageNodes.length - 1],
+      node: this.webConsoleFrame.newConsoleOutput.getLastMessage(),
     }]));
   },
 
   /**
    * The "cachedMessages" response handler.
    *
    * @private
    * @param object response
