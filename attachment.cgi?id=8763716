# HG changeset patch
# User Steve Melia <steve.j.melia@gmail.com>
# Date 1464131188 -3600
#      Wed May 25 00:06:28 2016 +0100
# Node ID 0f8035b7608195f4275a46b3180609eddae8c520
# Parent  3c5025f98e561a20e24d97c91a9e4e0ec28015ea
Bug 1269226: Explicitly handle node deletion in inspector breadcrumbs;r=pbro

diff --git a/devtools/client/inspector/breadcrumbs.js b/devtools/client/inspector/breadcrumbs.js
--- a/devtools/client/inspector/breadcrumbs.js
+++ b/devtools/client/inspector/breadcrumbs.js
@@ -825,16 +825,32 @@ HTMLBreadcrumbs.prototype = {
                      cmdDispatcher.focusedElement.parentNode == this.container);
 
     if (!this.selection.isConnected()) {
       // remove all the crumbs
       this.cutAfter(-1);
       return;
     }
 
+    // If this was an interesting deletion; then trim the breadcrumb trail
+    if (reason === "markupmutation") {
+      for (let {type, removed} of mutations) {
+        if (type !== "childList") {
+          continue;
+        }
+
+        for (let node of removed) {
+          let removedIndex = this.indexOf(node);
+          if (removedIndex > -1) {
+            this.cutAfter(removedIndex - 1);
+          }
+        }
+      }
+    }
+
     if (!this.selection.isElementNode()) {
       // no selection
       this.setCursor(-1);
       return;
     }
 
     let idx = this.indexOf(this.selection.nodeFront);
 
diff --git a/devtools/client/inspector/markup/markup.js b/devtools/client/inspector/markup/markup.js
--- a/devtools/client/inspector/markup/markup.js
+++ b/devtools/client/inspector/markup/markup.js
@@ -850,22 +850,36 @@ MarkupView.prototype = {
 
     // Retain the node so we can undo this...
     this.walker.retainNode(node).then(() => {
       let parent = node.parentNode();
       let nextSibling = null;
       this.undo.do(() => {
         this.walker.removeNode(node).then(siblings => {
           nextSibling = siblings.nextSibling;
-          let focusNode = moveBackward ? siblings.previousSibling : nextSibling;
+          let prevSibling = siblings.previousSibling;
+          let focusNode = moveBackward ? prevSibling : nextSibling;
 
           // If we can't move as the user wants, we move to the other direction.
           // If there is no sibling elements anymore, move to the parent node.
           if (!focusNode) {
-            focusNode = nextSibling || siblings.previousSibling || parent;
+            focusNode = nextSibling || prevSibling || parent;
+          }
+
+          let isNextSiblingText = nextSibling ?
+            nextSibling.nodeType === Ci.nsIDOMNode.TEXT_NODE : false;
+          let isPrevSiblingText = prevSibling ?
+            prevSibling.nodeType === Ci.nsIDOMNode.TEXT_NODE : false;
+
+          // If the parent had two children and the next or previous sibling
+          // is a text node, then it now has only a single text node, is about
+          // to be in-lined; and focus should move to the parent.
+          if (parent.numChildren === 2
+              && (isNextSiblingText || isPrevSiblingText)) {
+            focusNode = parent;
           }
 
           if (container.selected) {
             this.navigate(this.getContainer(focusNode));
           }
         });
       }, () => {
         let isValidSibling = nextSibling && !nextSibling.isPseudoElement;
diff --git a/devtools/client/inspector/test/browser_inspector_delete-selected-node-02.js b/devtools/client/inspector/test/browser_inspector_delete-selected-node-02.js
--- a/devtools/client/inspector/test/browser_inspector_delete-selected-node-02.js
+++ b/devtools/client/inspector/test/browser_inspector_delete-selected-node-02.js
@@ -13,39 +13,25 @@ const TEST_PAGE = URL_ROOT +
   "doc_inspector_delete-selected-node-02.html";
 
 add_task(function* () {
   let { inspector } = yield openInspectorForURL(TEST_PAGE);
 
   yield testManuallyDeleteSelectedNode();
   yield testAutomaticallyDeleteSelectedNode();
   yield testDeleteSelectedNodeContainerFrame();
+  yield testDeleteWithNonElementNode();
 
   function* testManuallyDeleteSelectedNode() {
     info("Selecting a node, deleting it via context menu and checking that " +
           "its parent node is selected and breadcrumbs are updated.");
 
-    yield selectNode("#deleteManually", inspector);
-
-    info("Getting the node container in the markup view.");
-    let container = yield getContainerForSelector("#deleteManually", inspector);
+    yield deleteNodeWithContextMenu("#deleteManually");
 
-    let allMenuItems = openContextMenuAndGetAllItems(inspector, {
-      target: container.tagLine,
-    });
-    let menuItem = allMenuItems.find(item => item.id === "node-menu-delete");
-
-    info("Clicking 'Delete Node' in the context menu.");
-    is(menuItem.disabled, false, "delete menu item is enabled");
-    menuItem.click();
-
-    info("Waiting for inspector to update.");
-    yield inspector.once("inspector-updated");
-
-    info("Inspector updated, performing checks.");
+    info("Performing checks.");
     yield assertNodeSelectedAndPanelsUpdated("#selectedAfterDelete",
                                              "li#selectedAfterDelete");
   }
 
   function* testAutomaticallyDeleteSelectedNode() {
     info("Selecting a node, deleting it via javascript and checking that " +
          "its parent node is selected and breadcrumbs are updated.");
 
@@ -78,19 +64,80 @@ add_task(function* () {
 
     info("Waiting for inspector to update.");
     yield inspector.once("inspector-updated");
 
     info("Inspector updated, performing checks.");
     yield assertNodeSelectedAndPanelsUpdated("body", "body");
   }
 
+  function* testDeleteWithNonElementNode() {
+    info("Selecting a node, deleting it via context menu and checking that " +
+         "its parent node is selected and breadcrumbs are updated " +
+         "when the node is followed by a non-element node");
+
+    yield deleteNodeWithContextMenu("#deleteWithNonElement");
+
+    let expectedCrumbs = ["html", "body", "div#deleteToMakeSingleTextNode"];
+    yield assertNodeSelectedAndCrumbsUpdated(expectedCrumbs,
+                                             Node.TEXT_NODE);
+
+    // Delete node with key, as cannot delete text node with
+    // context menu at this time.
+    inspector.markup._frame.focus();
+    EventUtils.synthesizeKey("VK_DELETE", {});
+    yield inspector.once("inspector-updated");
+
+    expectedCrumbs = ["html", "body", "div#deleteToMakeSingleTextNode"];
+    yield assertNodeSelectedAndCrumbsUpdated(expectedCrumbs,
+                                             Node.ELEMENT_NODE);
+  }
+
+  function* deleteNodeWithContextMenu(selector) {
+    yield selectNode(selector, inspector);
+
+    info("Getting the node container in the markup view.");
+    let container = yield getContainerForSelector(selector, inspector);
+
+    let allMenuItems = openContextMenuAndGetAllItems(inspector, {
+      target: container.tagLine,
+    });
+    let menuItem = allMenuItems.find(item => item.id === "node-menu-delete");
+
+    info("Clicking 'Delete Node' in the context menu.");
+    is(menuItem.disabled, false, "delete menu item is enabled");
+    menuItem.click();
+
+    // close the open context menu
+    EventUtils.synthesizeKey("VK_ESCAPE", {});
+
+    info("Waiting for inspector to update.");
+    yield inspector.once("inspector-updated");
+    return menuItem;
+  }
+
+  function* assertNodeSelectedAndCrumbsUpdated(expectedCrumbs,
+                                               expectedNodeType) {
+    info("Performing checks");
+    let actualNodeType = inspector.selection.nodeFront.nodeType;
+    is(actualNodeType, expectedNodeType, "The node has the right type");
+
+    let breadcrumbs = inspector.panelDoc.querySelectorAll(
+      "#inspector-breadcrumbs .html-arrowscrollbox-inner > *");
+    is(breadcrumbs.length, expectedCrumbs.length,
+       "Have the correct number of breadcrumbs");
+    for (let i = 0; i < breadcrumbs.length; i++) {
+      is(breadcrumbs[i].textContent, expectedCrumbs[i],
+         "Text content for button " + i + " is correct");
+    }
+  }
+
   function* assertNodeSelectedAndPanelsUpdated(selector, crumbLabel) {
     let nodeFront = yield getNodeFront(selector, inspector);
     is(inspector.selection.nodeFront, nodeFront, "The right node is selected");
 
-    let breadcrumbs = inspector.panelDoc.getElementById(
-      "inspector-breadcrumbs");
+    let breadcrumbs = inspector.panelDoc.querySelector(
+      "#inspector-breadcrumbs .html-arrowscrollbox-inner");
     is(breadcrumbs.querySelector("button[checked=true]").textContent,
        crumbLabel,
        "The right breadcrumb is selected");
   }
 });
diff --git a/devtools/client/inspector/test/doc_inspector_delete-selected-node-02.html b/devtools/client/inspector/test/doc_inspector_delete-selected-node-02.html
--- a/devtools/client/inspector/test/doc_inspector_delete-selected-node-02.html
+++ b/devtools/client/inspector/test/doc_inspector_delete-selected-node-02.html
@@ -6,10 +6,15 @@
 </head>
 <body>
   <ul id="deleteChildren">
     <li id="deleteManually">Delete me via the inspector</li>
     <li id="selectedAfterDelete">This node is selected after manual delete</li>
     <li id="deleteAutomatically">Delete me via javascript</li>
   </ul>
   <iframe id="deleteIframe" src="data:text/html,%3C!DOCTYPE%20html%3E%3Chtml%20lang%3D%22en%22%3E%3Cbody%3E%3Cp%20id%3D%22deleteInIframe%22%3EDelete my container iframe%3C%2Fp%3E%3C%2Fbody%3E%3C%2Fhtml%3E"></iframe>
+  <div id="deleteToMakeSingleTextNode">
+    1
+    <b id="deleteWithNonElement">Delete me and select the non-element node</b>
+    2
+  </div>
 </body>
 </html>
