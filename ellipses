# HG changeset patch
# Parent 0ed3e26cbc2be9ccc96c32ee83d67e229a731e8e
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 892935 - [markup view] if the content of a node is only text, we should expand the ellipsis;r=pbrosset

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -1072,17 +1072,17 @@ MarkupView.prototype = {
       }
       aContainer.childrenDirty = false;
       return promise.resolve(aContainer);
     }
 
     // If we're not expanded (or asked to update anyway), we're done for
     // now.  Note that this will leave the childrenDirty flag set, so when
     // expanded we'll refresh the child list.
-    if (!(aContainer.expanded || expand)) {
+    if (!aContainer.expanded && !expand && aContainer.node.hasExpandableChildren) {
       return promise.resolve(aContainer);
     }
 
     // We're going to issue a children request, make sure it includes the
     // centered node.
     let centered = this._checkSelectionVisible(aContainer);
 
     // Children aren't updated yet, but clear the childrenDirty flag anyway.
@@ -1131,16 +1131,20 @@ MarkupView.prototype = {
         }
         if (!children.hasLast) {
           let span = this.template("more-nodes", data);
           fragment.appendChild(span);
         }
       }
 
       aContainer.children.appendChild(fragment);
+
+      if (!aContainer.node.hasExpandableChildren) {
+        aContainer.expanded = true;
+      }
       return aContainer;
     }).then(null, console.error);
     this._queuedChildUpdates.set(aContainer, updatePromise);
     return updatePromise;
   },
 
   _waitForChildren: function() {
     if (!this._queuedChildUpdates) {
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -222,24 +222,31 @@ var NodeActor = exports.NodeActor = prot
   // Returns the JSON representation of this object over the wire.
   form: function(detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
 
+    let hasExpandableChildren = [...this.rawNode.childNodes].some((n) => {
+      // Could also ignore nodes like BR if we wanted (n.nodeName != "BR")
+      return n.nodeType != 3;
+    });
+
+
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
       numChildren: this.numChildren,
+      hasExpandableChildren: hasExpandableChildren,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
       isBeforePseudoElement: this.isBeforePseudoElement,
@@ -806,16 +813,26 @@ let NodeFront = protocol.FrontClass(Node
   get nodeName() this._form.nodeName,
 
   get baseURI() this._form.baseURI,
 
   get className() {
     return this.getAttribute("class") || '';
   },
 
+  get hasExpandableChildren() {
+    // Old version of server should always return true.
+    // May want to use a falsy name / prop, like noExpandableChildren
+    // to make this compat easier (since old versions will always be false)
+    if ('hasExpandableChildren' in this._form) {
+      return this._form.hasExpandableChildren;
+    }
+    return true;
+  },
+
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
   get hasEventListeners() this._form.hasEventListeners,
 
   get isBeforePseudoElement() this._form.isBeforePseudoElement,
   get isAfterPseudoElement() this._form.isAfterPseudoElement,
   get isPseudoElement() this.isBeforePseudoElement || this.isAfterPseudoElement,
   get isAnonymous() this._form.isAnonymous,
