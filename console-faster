# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f71701b82ab0a99a61aad048ff3e60ecdce509c4
Bug 1237368 - CSS tricks to make webconsole output scroll faster

diff --git a/devtools/client/themes/webconsole.css b/devtools/client/themes/webconsole.css
--- a/devtools/client/themes/webconsole.css
+++ b/devtools/client/themes/webconsole.css
@@ -132,21 +132,19 @@ a {
 }
 
 #output-wrapper {
   direction: ltr;
   overflow: auto;
 }
 
 #output-container {
+  /* This width is set to a hardcoded px in webconsole.js since it's way
+     faster than doing 100% (see Bug 1237368) */
   -moz-user-select: text;
-  -moz-box-flex: 1;
-  display: flex;
-  flex-direction: column;
-  align-items: flex-start;
 }
 
 #output-container.hideTimestamps > .message {
   -moz-padding-start: 0;
   -moz-margin-start: 7px;
   width: calc(100% - 7px);
 }
 
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -207,16 +207,17 @@ function WebConsoleFrame(webConsoleOwner
   this._outputQueue = [];
   this._itemDestroyQueue = [];
   this._pruneCategoriesQueue = {};
   this.filterPrefs = {};
 
   this.output = new ConsoleOutput(this);
 
   this._toggleFilter = this._toggleFilter.bind(this);
+  this.resize = this.resize.bind(this);
   this._onPanelSelected = this._onPanelSelected.bind(this);
   this._flushMessageQueue = this._flushMessageQueue.bind(this);
   this._onToolboxPrefChanged = this._onToolboxPrefChanged.bind(this);
   this._onUpdateListeners = this._onUpdateListeners.bind(this);
 
   this._outputTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
   this._outputTimerInitialized = false;
 
@@ -498,16 +499,18 @@ WebConsoleFrame.prototype = {
     if (system.constants.platform === "macosx") {
       doc.querySelector("#key_clearOSX").removeAttribute("disabled");
     } else {
       doc.querySelector("#key_clear").removeAttribute("disabled");
     }
 
     this.filterBox = doc.querySelector(".hud-filter-box");
     this.outputNode = doc.getElementById("output-container");
+    this.outputWrapper = doc.getElementById("output-wrapper");
+
     this.completeNode = doc.querySelector(".jsterm-complete-node");
     this.inputNode = doc.querySelector(".jsterm-input-node");
 
     this._setFilterTextBoxEvents();
     this._initFilterButtons();
 
     let fontSize = this.owner._browserConsole ?
                    Services.prefs.getIntPref("devtools.webconsole.fontSize") : 0;
@@ -535,16 +538,21 @@ WebConsoleFrame.prototype = {
     clearButton.addEventListener("command", () => {
       this.owner._onClearButton();
       this.jsterm.clearOutput(true);
     });
 
     this.jsterm = new JSTerm(this);
     this.jsterm.init();
 
+    this.resize();
+    this.window.addEventListener("resize", this.resize, true);
+    this.jsterm.on("sidebar-opened", this.resize);
+    this.jsterm.on("sidebar-closed", this.resize);
+
     let toolbox = gDevTools.getToolbox(this.owner.target);
     if (toolbox) {
       toolbox.on("webconsole-selected", this._onPanelSelected);
     }
 
     /*
      * Focus input line whenever the output area is clicked.
      * Reusing _addMEssageLinkCallback since it correctly filters
@@ -564,16 +572,25 @@ WebConsoleFrame.prototype = {
       newValue: Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP),
     });
 
     // focus input node
     this.jsterm.inputNode.focus();
   },
 
   /**
+   * Resizes the output node to fit the output wrapped.
+   * We need this because it makes the layout a lot faster than
+   * using -moz-box-flex and 100% width.  See Bug 1237368.
+   */
+  resize: function(e) {
+    this.outputNode.style.width = this.outputWrapper.clientWidth + "px";
+  },
+
+  /**
    * Sets the focus to JavaScript input field when the web console tab is
    * selected or when there is a split console present.
    * @private
    */
   _onPanelSelected: function WCF__onPanelSelected(evt, id)
   {
     this.jsterm.inputNode.focus();
   },
@@ -2025,24 +2042,24 @@ WebConsoleFrame.prototype = {
     if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
       toDisplay = Math.min(this._outputQueue.length, toDisplay);
       shouldPrune = true;
     }
 
     let batch = this._outputQueue.splice(0, toDisplay);
     let outputNode = this.outputNode;
     let lastVisibleNode = null;
-    let scrollNode = outputNode.parentNode;
+    let scrollNode = this.outputWrapper;
     let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
 
     // We won't bother to try to restore scroll position if this is showing
     // a lot of messages at once (and there are still items in the queue).
     // It is going to purge whatever you were looking at anyway.
     let scrolledToBottom = shouldPrune ||
-                           Utils.isOutputScrolledToBottom(outputNode);
+                           Utils.isOutputScrolledToBottom(outputNode, scrollNode);
 
     // Output the current batch of messages.
     let messages = new Set();
     for (let i = 0; i < batch.length; i++) {
       let item = batch[i];
       let result = this._outputMessageFromQueue(hudIdSupportsString, item);
       if (result) {
         messages.add({
@@ -2828,31 +2845,34 @@ WebConsoleFrame.prototype = {
     this._destroyer = promise.defer();
 
     let toolbox = gDevTools.getToolbox(this.owner.target);
     if (toolbox) {
       toolbox.off("webconsole-selected", this._onPanelSelected);
     }
 
     gDevTools.off("pref-changed", this._onToolboxPrefChanged);
+    this.window.removeEventListener("resize", this.resize, true);
 
     this._repeatNodes = {};
     this._outputQueue.forEach(this._destroyItem, this);
     this._outputQueue = [];
     this._itemDestroyQueue.forEach(this._destroyItem, this);
     this._itemDestroyQueue = [];
     this._pruneCategoriesQueue = {};
     this.webConsoleClient.clearNetworkRequests();
 
     if (this._outputTimerInitialized) {
       this._outputTimerInitialized = false;
       this._outputTimer.cancel();
     }
     this._outputTimer = null;
     if (this.jsterm) {
+      this.jsterm.off("sidebar-opened", this.resize);
+      this.jsterm.off("sidebar-closed", this.resize);
       this.jsterm.destroy();
       this.jsterm = null;
     }
     this.output.destroy();
     this.output = null;
 
     if (this._contextMenuHandler) {
       this._contextMenuHandler.destroy();
@@ -3473,16 +3493,17 @@ JSTerm.prototype = {
    * @see devtools/framework/sidebar.js
    * @private
    */
   _createSidebar: function JST__createSidebar()
   {
     let tabbox = this.hud.document.querySelector("#webconsole-sidebar");
     this.sidebar = new ToolSidebar(tabbox, this, "webconsole");
     this.sidebar.show();
+    this.emit("sidebar-opened");
   },
 
   /**
    * Add the variables view tab to the sidebar.
    *
    * @private
    * @return object
    *         A promise object for the adding of the new tab.
@@ -4025,58 +4046,58 @@ JSTerm.prototype = {
       case Ci.nsIDOMKeyEvent.DOM_VK_PAGE_UP:
         if (this.autocompletePopup.isOpen) {
           inputUpdated = this.complete(this.COMPLETE_PAGEUP);
           if (inputUpdated) {
             this._autocompletePopupNavigated = true;
           }
         }
         else {
-          this.hud.outputNode.parentNode.scrollTop =
+          this.hud.outputWrapper.scrollTop =
             Math.max(0,
-              this.hud.outputNode.parentNode.scrollTop -
-              this.hud.outputNode.parentNode.clientHeight
+              this.hud.outputWrapper.scrollTop -
+              this.hud.outputWrapper.clientHeight
             );
         }
         event.preventDefault();
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_PAGE_DOWN:
         if (this.autocompletePopup.isOpen) {
           inputUpdated = this.complete(this.COMPLETE_PAGEDOWN);
           if (inputUpdated) {
             this._autocompletePopupNavigated = true;
           }
         }
         else {
-          this.hud.outputNode.parentNode.scrollTop =
-            Math.min(this.hud.outputNode.parentNode.scrollHeight,
-              this.hud.outputNode.parentNode.scrollTop +
-              this.hud.outputNode.parentNode.clientHeight
+          this.hud.outputWrapper.scrollTop =
+            Math.min(this.hud.outputWrapper.scrollHeight,
+              this.hud.outputWrapper.scrollTop +
+              this.hud.outputWrapper.clientHeight
             );
         }
         event.preventDefault();
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_HOME:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectedIndex = 0;
           event.preventDefault();
         } else if (this.inputNode.value.length <= 0) {
-          this.hud.outputNode.parentNode.scrollTop = 0;
+          this.hud.outputWrapper.scrollTop = 0;
           event.preventDefault();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_END:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectedIndex = this.autocompletePopup.itemCount - 1;
           event.preventDefault();
         } else if (this.inputNode.value.length <= 0) {
-          this.hud.outputNode.parentNode.scrollTop = this.hud.outputNode.parentNode.scrollHeight;
+          this.hud.outputWrapper.scrollTop = this.hud.outputWrapper.scrollHeight;
           event.preventDefault();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
         if (this.autocompletePopup.isOpen || this.lastCompletion.value) {
           this.clearCompletion();
         }
@@ -4617,25 +4638,25 @@ var Utils = {
   {
     node.scrollIntoView(false);
   },
 
   /**
    * Check if the given output node is scrolled to the bottom.
    *
    * @param nsIDOMNode outputNode
+   * @param nsIDOMNode scrollNode
    * @return boolean
    *         True if the output node is scrolled to the bottom, or false
    *         otherwise.
    */
-  isOutputScrolledToBottom: function Utils_isOutputScrolledToBottom(outputNode)
+  isOutputScrolledToBottom: function (outputNode, scrollNode)
   {
     let lastNodeHeight = outputNode.lastChild ?
                          outputNode.lastChild.clientHeight : 0;
-    let scrollNode = outputNode.parentNode;
     return scrollNode.scrollTop + scrollNode.clientHeight >=
            scrollNode.scrollHeight - lastNodeHeight / 2;
   },
 
   /**
    * Determine the category of a given nsIScriptError.
    *
    * @param nsIScriptError scriptError
diff --git a/devtools/client/webconsole/webconsole.xul b/devtools/client/webconsole/webconsole.xul
--- a/devtools/client/webconsole/webconsole.xul
+++ b/devtools/client/webconsole/webconsole.xul
@@ -197,18 +197,23 @@ function goUpdateConsoleCommands() {
 
         <spacer flex="1"/>
 
         <textbox class="compact hud-filter-box devtools-searchinput" type="search"
                  placeholder="&filterOutput.placeholder;" tabindex="2"/>
       </toolbar>
 
       <hbox id="output-wrapper" flex="1" context="output-contextmenu" tooltip="aHTMLTooltip">
-        <div xmlns="http://www.w3.org/1999/xhtml" id="output-container"
-             tabindex="0" role="document" aria-live="polite" />
+        <!-- Hack to make scrolling in output-container much faster.
+             Don't fully understand, but getting rid of this block parent
+             makes scrolling 10x slower. -->
+        <div xmlns="http://www.w3.org/1999/xhtml">
+          <div xmlns="http://www.w3.org/1999/xhtml" id="output-container"
+               tabindex="0" role="document" aria-live="polite" />
+        </div>
       </hbox>
       <notificationbox id="webconsole-notificationbox">
         <hbox class="jsterm-input-container" style="direction:ltr">
           <stack class="jsterm-stack-node" flex="1">
             <textbox class="jsterm-complete-node devtools-monospace"
                      multiline="true" rows="1" tabindex="-1"/>
             <textbox class="jsterm-input-node devtools-monospace"
                      multiline="true" rows="1" tabindex="0"
