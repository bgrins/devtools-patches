# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b7f409bd51c8ae7260c1675785c698a9cb061244
Bug 1491484 - Don't updateBrowserWithState in findbar focus handler

This

diff --git a/toolkit/content/tests/browser/browser_findbar.js b/toolkit/content/tests/browser/browser_findbar.js
--- a/toolkit/content/tests/browser/browser_findbar.js
+++ b/toolkit/content/tests/browser/browser_findbar.js
@@ -1,16 +1,18 @@
 /* eslint-disable mozilla/no-arbitrary-setTimeout */
 ChromeUtils.import("resource://gre/modules/Timer.jsm", this);
 
 const TEST_PAGE_URI = "data:text/html;charset=utf-8,The letter s.";
 // Using 'javascript' schema to bypass E10SUtils.canLoadURIInProcess, because
 // it does not allow 'data:' URI to be loaded in the parent process.
 const E10S_PARENT_TEST_PAGE_URI = "javascript:document.write('The letter s.');";
 
+SimpleTest.requestCompleteLog();
+
 /**
  * Makes sure that the findbar hotkeys (' and /) event listeners
  * are added to the system event group and do not get blocked
  * by calling stopPropagation on a keypress event on a page.
  */
 add_task(async function test_hotkey_event_propagation() {
   info("Ensure hotkeys are not affected by stopPropagation.");
 
diff --git a/toolkit/content/widgets/findbar.js b/toolkit/content/widgets/findbar.js
--- a/toolkit/content/widgets/findbar.js
+++ b/toolkit/content/widgets/findbar.js
@@ -251,16 +251,17 @@ class MozFindbar extends XULElement {
       // if it matched an editable.
       this.browser.finder.enableSelection();
     });
 
     this._findField.addEventListener("focus", (event) => {
       if (/Mac/.test(navigator.platform)) {
         this._onFindFieldFocus();
       }
+      console.log("FOCUS HANDLER");
       this._updateBrowserWithState();
     });
 
     this._findField.addEventListener("compositionstart", (event) => {
       // Don't close the find toolbar while IME is composing.
       let findbar = this;
       findbar._isIMEComposing = true;
       if (findbar._quickFindTimeout) {
@@ -334,19 +335,19 @@ class MozFindbar extends XULElement {
       let finder = this._browser.finder;
       if (finder)
         finder.removeResultListener(this);
     }
 
     this._browser = val;
     if (this._browser) {
       // Need to do this to ensure the correct initial state.
-      this._updateBrowserWithState();
       this._browser.messageManager.addMessageListener("Findbar:Keypress", this);
       this._browser.messageManager.addMessageListener("Findbar:Mouseup", this);
+      this._updateBrowserWithState();
       this._browser.finder.addResultListener(this);
 
       this._findField.value = this._browser._lastSearchString;
     }
     return val;
   }
 
   get browser() {
@@ -797,21 +798,23 @@ class MozFindbar extends XULElement {
         this._onBrowserKeypress(aMessage.data);
         break;
     }
     return undefined;
   }
 
   _updateBrowserWithState() {
     if (this._browser && this._browser.messageManager) {
-      this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", {
+      var obj = {
         findMode: this._findMode,
         isOpenAndFocused: !this.hidden && document.activeElement == this._findField.inputField,
         hasQuickFindTimeout: !!this._quickFindTimeout,
-      });
+      };
+      console.log("Sending Findbar:UpdateState from parent", obj);
+      this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", obj);
     }
   }
 
   _enableFindButtons(aEnable) {
     this.getElement("find-next").disabled =
       this.getElement("find-previous").disabled = !aEnable;
   }
 
diff --git a/toolkit/modules/FindBarContent.jsm b/toolkit/modules/FindBarContent.jsm
--- a/toolkit/modules/FindBarContent.jsm
+++ b/toolkit/modules/FindBarContent.jsm
@@ -21,16 +21,17 @@ class FindBarContent {
     this.mm = mm;
 
     this.findMode = 0;
     this.inQuickFind = false;
 
     this.mm.addMessageListener("Findbar:UpdateState", this);
 
     Services.els.addSystemEventListener(this.mm, "mouseup", this, false);
+    Services.els.addSystemEventListener(this.mm, "keydown", this, false);
   }
 
   start(event) {
     this.inPassThrough = true;
   }
 
   startQuickFind(event, autostart = false) {
     let mode = FIND_TYPEAHEAD;
@@ -43,48 +44,53 @@ class FindBarContent {
     // to ensure we pass any further keypresses, too.
     this.findMode = mode;
     this.passKeyToParent(event);
   }
 
   receiveMessage(msg) {
     switch (msg.name) {
       case "Findbar:UpdateState":
+        console.log("Findbar:UpdateState received from child", "is open and focused?", msg.data.isOpenAndFocused, "in passthrough already?", this.inPassThrough)
         this.findMode = msg.data.findMode;
         this.inQuickFind = msg.data.hasQuickFindTimeout;
         if (msg.data.isOpenAndFocused) {
           this.inPassThrough = false;
         }
         break;
     }
   }
 
   handleEvent(event) {
     switch (event.type) {
       case "keypress":
         this.onKeypress(event);
         break;
+      case "keydown":
+        console.log("keydown received from child", this.inPassThrough, event.charCode);
+        break;
       case "mouseup":
         this.onMouseup(event);
         break;
     }
   }
 
   onKeypress(event) {
+    console.log("onKeypress received from child", this.inPassThrough, event.charCode);
     if (this.inPassThrough) {
       this.passKeyToParent(event);
     } else if (this.findMode != FIND_NORMAL && this.inQuickFind && event.charCode) {
       this.passKeyToParent(event);
     }
   }
 
   passKeyToParent(event) {
     event.preventDefault();
     // These are the properties required to dispatch another 'real' event
-    // to the findbar in the parent in _dispatchKeypressEvent in findbar.xml .
+    // to the findbar in the parent in _dispatchKeypressEvent in findbar.js.
     // If you make changes here, verify that that method can still do its job.
     const kRequiredProps = [
       "type", "bubbles", "cancelable", "ctrlKey", "altKey", "shiftKey",
       "metaKey", "keyCode", "charCode",
     ];
     let fakeEvent = {};
     for (let prop of kRequiredProps) {
       fakeEvent[prop] = event[prop];
