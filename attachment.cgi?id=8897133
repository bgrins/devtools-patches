# HG changeset patch
# User Gabriel Luong <gabriel.luong@gmail.com>
# Parent  95dd0949559d8548a846443a5d4001038ba6bf4e
Bug 1389732 - Add photon colors to variables.css. r=bgrins

diff --git a/browser/base/content/customelements/Basecontrol.js b/browser/base/content/customelements/Basecontrol.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/Basecontrol.js
@@ -0,0 +1,33 @@
+class XblBasecontrol extends BaseElement {
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    console.log(this, "connected");
+
+    let comment = document.createComment("Creating xbl-basecontrol");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  set disabled(val) {
+    if (val) this.setAttribute("disabled", "true");
+    else this.removeAttribute("disabled");
+    return val;
+  }
+
+  get disabled() {
+    return this.getAttribute("disabled") == "true";
+  }
+
+  set tabIndex(val) {
+    if (val) this.setAttribute("tabindex", val);
+    else this.removeAttribute("tabindex");
+    return val;
+  }
+
+  get tabIndex() {
+    return parseInt(this.getAttribute("tabindex")) || 0;
+  }
+}
+customElements.define("xbl-basecontrol", XblBasecontrol);
diff --git a/browser/base/content/customelements/Basetext.js b/browser/base/content/customelements/Basetext.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/Basetext.js
@@ -0,0 +1,67 @@
+class XblBasetext extends XblBasecontrol {
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    console.log(this, "connected");
+
+    let comment = document.createComment("Creating xbl-basetext");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set crop(val) {
+    this.setAttribute("crop", val);
+    return val;
+  }
+
+  get crop() {
+    return this.getAttribute("crop");
+  }
+
+  set image(val) {
+    this.setAttribute("image", val);
+    return val;
+  }
+
+  get image() {
+    return this.getAttribute("image");
+  }
+
+  set command(val) {
+    this.setAttribute("command", val);
+    return val;
+  }
+
+  get command() {
+    return this.getAttribute("command");
+  }
+
+  set accessKey(val) {
+    // Always store on the control
+    this.setAttribute("accesskey", val);
+    // If there is a label, change the accesskey on the labelElement
+    // if it's also set there
+    if (this.labelElement) {
+      this.labelElement.accessKey = val;
+    }
+    return val;
+  }
+
+  get accessKey() {
+    return this.labelElement
+      ? this.labelElement.accessKey
+      : this.getAttribute("accesskey");
+  }
+}
+customElements.define("xbl-basetext", XblBasetext);
diff --git a/browser/base/content/customelements/ListboxBase.js b/browser/base/content/customelements/ListboxBase.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/ListboxBase.js
@@ -0,0 +1,315 @@
+class XblListboxBase extends XblBasecontrol {
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    console.log(this, "connected");
+
+    let comment = document.createComment("Creating xbl-listbox-base");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  set selectedItem(val) {
+    this.selectItem(val);
+  }
+
+  get selectedItem() {
+    return this.selectedItems.length > 0 ? this.selectedItems[0] : null;
+  }
+
+  set selectedIndex(val) {
+    if (val >= 0) {
+      // This is a micro-optimization so that a call to getIndexOfItem or
+      // getItemAtIndex caused by _fireOnSelect (especially for derived
+      // widgets) won't loop the children.
+      this._selecting = {
+        item: this.getItemAtIndex(val),
+        index: val
+      };
+      this.selectItem(this._selecting.item);
+      delete this._selecting;
+    } else {
+      this.clearSelection();
+      this.currentItem = null;
+    }
+  }
+
+  get selectedIndex() {
+    if (this.selectedItems.length > 0)
+      return this.getIndexOfItem(this.selectedItems[0]);
+    return -1;
+  }
+
+  set value(val) {
+    var kids = this.getElementsByAttribute("value", val);
+    if (kids && kids.item(0)) this.selectItem(kids[0]);
+    return val;
+  }
+
+  get value() {
+    if (this.selectedItems.length > 0) return this.selectedItem.value;
+    return null;
+  }
+
+  set selType(val) {
+    this.setAttribute("seltype", val);
+    return val;
+  }
+
+  get selType() {
+    return this.getAttribute("seltype");
+  }
+
+  set currentItem(val) {
+    undefined;
+  }
+
+  get currentItem() {
+    return this._currentItem;
+  }
+
+  set currentIndex(val) {
+    if (val >= 0) this.currentItem = this.getItemAtIndex(val);
+    else this.currentItem = null;
+  }
+
+  get currentIndex() {
+    undefined;
+  }
+
+  get selectedCount() {
+    return this.selectedItems.length;
+  }
+
+  set disableKeyNavigation(val) {
+    undefined;
+  }
+
+  get disableKeyNavigation() {
+    return this.hasAttribute("disableKeyNavigation");
+  }
+
+  set suppressOnSelect(val) {
+    this.setAttribute("suppressonselect", val);
+  }
+
+  get suppressOnSelect() {
+    return this.getAttribute("suppressonselect") == "true";
+  }
+
+  set _selectDelay(val) {
+    this.setAttribute("_selectDelay", val);
+  }
+
+  get _selectDelay() {
+    return this.getAttribute("_selectDelay") || 50;
+  }
+  removeItemAt(index) {
+    var remove = this.getItemAtIndex(index);
+    if (remove) this.removeChild(remove);
+    return remove;
+  }
+  addItemToSelection(aItem) {
+    if (this.selType != "multiple" && this.selectedCount) return;
+
+    if (aItem.selected) return;
+
+    this.selectedItems.append(aItem);
+    aItem.selected = true;
+
+    this._fireOnSelect();
+  }
+  removeItemFromSelection(aItem) {
+    if (!aItem.selected) return;
+
+    this.selectedItems.remove(aItem);
+    aItem.selected = false;
+    this._fireOnSelect();
+  }
+  toggleItemSelection(aItem) {
+    if (aItem.selected) this.removeItemFromSelection(aItem);
+    else this.addItemToSelection(aItem);
+  }
+  selectItem(aItem) {
+    if (!aItem) return;
+
+    if (this.selectedItems.length == 1 && this.selectedItems[0] == aItem)
+      return;
+
+    this._selectionStart = null;
+
+    var suppress = this._suppressOnSelect;
+    this._suppressOnSelect = true;
+
+    this.clearSelection();
+    this.addItemToSelection(aItem);
+    this.currentItem = aItem;
+
+    this._suppressOnSelect = suppress;
+    this._fireOnSelect();
+  }
+  selectItemRange(aStartItem, aEndItem) {
+    if (this.selType != "multiple") return;
+
+    if (!aStartItem)
+      aStartItem = this._selectionStart
+        ? this._selectionStart
+        : this.currentItem;
+
+    if (!aStartItem) aStartItem = aEndItem;
+
+    var suppressSelect = this._suppressOnSelect;
+    this._suppressOnSelect = true;
+
+    this._selectionStart = aStartItem;
+
+    var currentItem;
+    var startIndex = this.getIndexOfItem(aStartItem);
+    var endIndex = this.getIndexOfItem(aEndItem);
+    if (endIndex < startIndex) {
+      currentItem = aEndItem;
+      aEndItem = aStartItem;
+      aStartItem = currentItem;
+    } else {
+      currentItem = aStartItem;
+    }
+
+    while (currentItem) {
+      this.addItemToSelection(currentItem);
+      if (currentItem == aEndItem) {
+        currentItem = this.getNextItem(currentItem, 1);
+        break;
+      }
+      currentItem = this.getNextItem(currentItem, 1);
+    }
+
+    // Clear around new selection
+    // Don't use clearSelection() because it causes a lot of noise
+    // with respect to selection removed notifications used by the
+    // accessibility API support.
+    var userSelecting = this._userSelecting;
+    this._userSelecting = false; // that's US automatically unselecting
+    for (; currentItem; currentItem = this.getNextItem(currentItem, 1))
+      this.removeItemFromSelection(currentItem);
+
+    for (
+      currentItem = this.getItemAtIndex(0);
+      currentItem != aStartItem;
+      currentItem = this.getNextItem(currentItem, 1)
+    )
+      this.removeItemFromSelection(currentItem);
+    this._userSelecting = userSelecting;
+
+    this._suppressOnSelect = suppressSelect;
+
+    this._fireOnSelect();
+  }
+  selectAll() {}
+  invertSelection() {}
+  clearSelection() {
+    if (this.selectedItems) {
+      while (this.selectedItems.length > 0) {
+        let item = this.selectedItems[0];
+        item.selected = false;
+        this.selectedItems.remove(item);
+      }
+    }
+
+    this._selectionStart = null;
+    this._fireOnSelect();
+  }
+  getSelectedItem(aIndex) {
+    return aIndex < this.selectedItems.length
+      ? this.selectedItems[aIndex]
+      : null;
+  }
+  timedSelect(aItem, aTimeout) {
+    var suppress = this._suppressOnSelect;
+    if (aTimeout != -1) this._suppressOnSelect = true;
+
+    this.selectItem(aItem);
+
+    this._suppressOnSelect = suppress;
+
+    if (aTimeout != -1) {
+      if (this._selectTimeout) window.clearTimeout(this._selectTimeout);
+      this._selectTimeout = window.setTimeout(
+        this._selectTimeoutHandler,
+        aTimeout,
+        this
+      );
+    }
+  }
+  moveByOffset(aOffset, aIsSelecting, aIsSelectingRange) {
+    if ((aIsSelectingRange || !aIsSelecting) && this.selType != "multiple")
+      return;
+
+    var newIndex = this.currentIndex + aOffset;
+    if (newIndex < 0) newIndex = 0;
+
+    var numItems = this.getRowCount();
+    if (newIndex > numItems - 1) newIndex = numItems - 1;
+
+    var newItem = this.getItemAtIndex(newIndex);
+    // make sure that the item is actually visible/selectable
+    if (this._userSelecting && newItem && !this._canUserSelect(newItem))
+      newItem = aOffset > 0
+        ? this.getNextItem(newItem, 1) || this.getPreviousItem(newItem, 1)
+        : this.getPreviousItem(newItem, 1) || this.getNextItem(newItem, 1);
+    if (newItem) {
+      this.ensureIndexIsVisible(this.getIndexOfItem(newItem));
+      if (aIsSelectingRange) this.selectItemRange(null, newItem);
+      else if (aIsSelecting) this.selectItem(newItem);
+
+      this.currentItem = newItem;
+    }
+  }
+  getNextItem(aStartItem, aDelta) {
+    while (aStartItem) {
+      aStartItem = aStartItem.nextSibling;
+      if (
+        aStartItem &&
+        aStartItem instanceof
+          Components.interfaces.nsIDOMXULSelectControlItemElement &&
+        (!this._userSelecting || this._canUserSelect(aStartItem))
+      ) {
+        --aDelta;
+        if (aDelta == 0) return aStartItem;
+      }
+    }
+    return null;
+  }
+  getPreviousItem(aStartItem, aDelta) {
+    while (aStartItem) {
+      aStartItem = aStartItem.previousSibling;
+      if (
+        aStartItem &&
+        aStartItem instanceof
+          Components.interfaces.nsIDOMXULSelectControlItemElement &&
+        (!this._userSelecting || this._canUserSelect(aStartItem))
+      ) {
+        --aDelta;
+        if (aDelta == 0) return aStartItem;
+      }
+    }
+    return null;
+  }
+  _moveByOffsetFromUserEvent(aOffset, aEvent) {
+    if (!aEvent.defaultPrevented) {
+      this._userSelecting = true;
+      this._mayReverse = true;
+      this.moveByOffset(aOffset, !aEvent.ctrlKey, aEvent.shiftKey);
+      this._userSelecting = false;
+      this._mayReverse = false;
+      aEvent.preventDefault();
+    }
+  }
+  _canUserSelect(aItem) {
+    var style = document.defaultView.getComputedStyle(aItem);
+    return style.display != "none" && style.visibility == "visible";
+  }
+  _selectTimeoutHandler(aMe) {}
+}
+customElements.define("xbl-listbox-base", XblListboxBase);
diff --git a/browser/base/content/customelements/Listitem.js b/browser/base/content/customelements/Listitem.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/Listitem.js
@@ -0,0 +1,78 @@
+class XblListitem extends XblBasetext {
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    console.log(this, "connected");
+
+    this.innerHTML = `<children>
+<listcell inherits="label,crop,disabled,flexlabel">
+</listcell>
+</children>`;
+    let comment = document.createComment("Creating xbl-listitem");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  set current(val) {
+    if (val) this.setAttribute("current", "true");
+    else this.removeAttribute("current");
+
+    let control = this.control;
+    if (!control || !control.suppressMenuItemEvent) {
+      this._fireEvent(val ? "DOMMenuItemActive" : "DOMMenuItemInactive");
+    }
+
+    return val;
+  }
+
+  get current() {
+    return this.getAttribute("current") == "true";
+  }
+
+  set value(val) {
+    this.setAttribute("value", val);
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set selected(val) {
+    if (val) this.setAttribute("selected", "true");
+    else this.removeAttribute("selected");
+
+    return val;
+  }
+
+  get selected() {
+    return this.getAttribute("selected") == "true";
+  }
+
+  get control() {
+    var parent = this.parentNode;
+    while (parent) {
+      if (parent instanceof Components.interfaces.nsIDOMXULSelectControlElement)
+        return parent;
+      parent = parent.parentNode;
+    }
+    return null;
+  }
+  _fireEvent(name) {
+    var event = document.createEvent("Events");
+    event.initEvent(name, true, true);
+    this.dispatchEvent(event);
+  }
+}
+customElements.define("xbl-listitem", XblListitem);
diff --git a/browser/base/content/customelements/Richlistbox.js b/browser/base/content/customelements/Richlistbox.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/Richlistbox.js
@@ -0,0 +1,312 @@
+class XblRichlistbox extends XblListboxBase {
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    console.log(this, "connected");
+
+    this.innerHTML = `<children includes="listheader">
+</children>
+<scrollbox allowevents="true" orient="vertical" anonid="main-box" flex="1" style="overflow: auto;" inherits="dir,pack">
+<children>
+</children>
+</scrollbox>`;
+    let comment = document.createComment("Creating xbl-richlistbox");
+    this.prepend(comment);
+
+    try {
+      // add a template build listener
+      if (this.builder) this.builder.addListener(this._builderListener);
+      else this._refreshSelection();
+    } catch (e) {}
+  }
+  disconnectedCallback() {}
+
+  get itemCount() {
+    return this.children.length;
+  }
+
+  get children() {
+    let iface = Components.interfaces.nsIDOMXULSelectControlItemElement;
+    let children = Array.from(this.childNodes).filter(
+      node => node instanceof iface
+    );
+    if (this.dir == "reverse" && this._mayReverse) {
+      children.reverse();
+    }
+    return children;
+  }
+  _fireOnSelect() {
+    // make sure not to modify last-selected when suppressing select events
+    // (otherwise we'll lose the selection when a template gets rebuilt)
+    if (this._suppressOnSelect || this.suppressOnSelect) return;
+
+    // remember the current item and all selected items with IDs
+    var state = this.currentItem ? this.currentItem.id : "";
+    if (this.selType == "multiple" && this.selectedCount) {
+      let getId = function getId(aItem) {
+        return aItem.id;
+      };
+      state += " " + [...this.selectedItems].filter(getId).map(getId).join(" ");
+    }
+    if (state) this.setAttribute("last-selected", state);
+    else this.removeAttribute("last-selected");
+
+    // preserve the index just in case no IDs are available
+    if (this.currentIndex > -1) this._currentIndex = this.currentIndex + 1;
+
+    var event = document.createEvent("Events");
+    event.initEvent("select", true, true);
+    this.dispatchEvent(event);
+
+    // always call this (allows a commandupdater without controller)
+    document.commandDispatcher.updateCommands("richlistbox-select");
+  }
+  getNextItem(aStartItem, aDelta) {
+    var prop = this.dir == "reverse" && this._mayReverse
+      ? "previousSibling"
+      : "nextSibling";
+    while (aStartItem) {
+      aStartItem = aStartItem[prop];
+      if (
+        aStartItem &&
+        aStartItem instanceof
+          Components.interfaces.nsIDOMXULSelectControlItemElement &&
+        (!this._userSelecting || this._canUserSelect(aStartItem))
+      ) {
+        --aDelta;
+        if (aDelta == 0) return aStartItem;
+      }
+    }
+    return null;
+  }
+  getPreviousItem(aStartItem, aDelta) {
+    var prop = this.dir == "reverse" && this._mayReverse
+      ? "nextSibling"
+      : "previousSibling";
+    while (aStartItem) {
+      aStartItem = aStartItem[prop];
+      if (
+        aStartItem &&
+        aStartItem instanceof
+          Components.interfaces.nsIDOMXULSelectControlItemElement &&
+        (!this._userSelecting || this._canUserSelect(aStartItem))
+      ) {
+        --aDelta;
+        if (aDelta == 0) return aStartItem;
+      }
+    }
+    return null;
+  }
+  appendItem(aLabel, aValue) {}
+  insertItemAt(aIndex, aLabel, aValue) {}
+  getIndexOfItem(aItem) {
+    // don't search the children, if we're looking for none of them
+    if (aItem == null) return -1;
+    if (this._selecting && this._selecting.item == aItem)
+      return this._selecting.index;
+    return this.children.indexOf(aItem);
+  }
+  getItemAtIndex(aIndex) {
+    if (this._selecting && this._selecting.index == aIndex)
+      return this._selecting.item;
+    return this.children[aIndex] || null;
+  }
+  ensureIndexIsVisible(aIndex) {
+    // work around missing implementation in scrollBoxObject
+    return this.ensureElementIsVisible(this.getItemAtIndex(aIndex));
+  }
+  ensureElementIsVisible(aElement) {
+    if (!aElement) return;
+    var targetRect = aElement.getBoundingClientRect();
+    var scrollRect = this._scrollbox.getBoundingClientRect();
+    var offset = targetRect.top - scrollRect.top;
+    if (offset >= 0) {
+      // scrollRect.bottom wouldn't take a horizontal scroll bar into account
+      let scrollRectBottom = scrollRect.top + this._scrollbox.clientHeight;
+      offset = targetRect.bottom - scrollRectBottom;
+      if (offset <= 0) return;
+    }
+    this._scrollbox.scrollTop += offset;
+  }
+  scrollToIndex(aIndex) {
+    var item = this.getItemAtIndex(aIndex);
+    if (item) this.scrollBoxObject.scrollToElement(item);
+  }
+  getNumberOfVisibleRows() {
+    var children = this.children;
+
+    for (
+      var top = 0;
+      top < children.length && !this._isItemVisible(children[top]);
+      top++
+    );
+    for (
+      var ix = top;
+      ix < children.length && this._isItemVisible(children[ix]);
+      ix++
+    );
+
+    return ix - top;
+  }
+  getIndexOfFirstVisibleRow() {
+    var children = this.children;
+
+    for (var ix = 0; ix < children.length; ix++)
+      if (this._isItemVisible(children[ix])) return ix;
+
+    return -1;
+  }
+  getRowCount() {
+    return this.children.length;
+  }
+  scrollOnePage(aDirection) {
+    var children = this.children;
+
+    if (children.length == 0) return 0;
+
+    // If nothing is selected, we just select the first element
+    // at the extreme we're moving away from
+    if (!this.currentItem) return aDirection == -1 ? children.length : 0;
+
+    // If the current item is visible, scroll by one page so that
+    // the new current item is at approximately the same position as
+    // the existing current item.
+    if (this._isItemVisible(this.currentItem))
+      this.scrollBoxObject.scrollBy(
+        0,
+        this.scrollBoxObject.height * aDirection
+      );
+
+    // Figure out, how many items fully fit into the view port
+    // (including the currently selected one), and determine
+    // the index of the first one lying (partially) outside
+    var height = this.scrollBoxObject.height;
+    var startBorder = this.currentItem.boxObject.y;
+    if (aDirection == -1) startBorder += this.currentItem.boxObject.height;
+
+    var index = this.currentIndex;
+    for (var ix = index; 0 <= ix && ix < children.length; ix += aDirection) {
+      var boxObject = children[ix].boxObject;
+      if (boxObject.height == 0) continue; // hidden children have a y of 0
+      var endBorder = boxObject.y + (aDirection == -1 ? boxObject.height : 0);
+      if ((endBorder - startBorder) * aDirection > height) break; // we've reached the desired distance
+      index = ix;
+    }
+
+    return index != this.currentIndex ? index - this.currentIndex : aDirection;
+  }
+  _refreshSelection() {
+    // when this method is called, we know that either the currentItem
+    // and selectedItems we have are null (ctor) or a reference to an
+    // element no longer in the DOM (template).
+
+    // first look for the last-selected attribute
+    var state = this.getAttribute("last-selected");
+    if (state) {
+      var ids = state.split(" ");
+
+      var suppressSelect = this._suppressOnSelect;
+      this._suppressOnSelect = true;
+      this.clearSelection();
+      for (let i = 1; i < ids.length; i++) {
+        var selectedItem = document.getElementById(ids[i]);
+        if (selectedItem) this.addItemToSelection(selectedItem);
+      }
+
+      var currentItem = document.getElementById(ids[0]);
+      if (!currentItem && this._currentIndex)
+        currentItem = this.getItemAtIndex(
+          Math.min(this._currentIndex - 1, this.getRowCount())
+        );
+      if (currentItem) {
+        this.currentItem = currentItem;
+        if (this.selType != "multiple" && this.selectedCount == 0)
+          this.selectedItem = currentItem;
+
+        if (this.scrollBoxObject.height) {
+          this.ensureElementIsVisible(currentItem);
+        } else {
+          // XXX hack around a bug in ensureElementIsVisible as it will
+          // scroll beyond the last element, bug 493645.
+          var previousElement = this.dir == "reverse"
+            ? currentItem.nextSibling
+            : currentItem.previousSibling;
+          this.ensureElementIsVisible(previousElement);
+        }
+      }
+      this._suppressOnSelect = suppressSelect;
+      // XXX actually it's just a refresh, but at least
+      // the Extensions manager expects this:
+      this._fireOnSelect();
+      return;
+    }
+
+    // try to restore the selected items according to their IDs
+    // (applies after a template rebuild, if last-selected was not set)
+    if (this.selectedItems) {
+      let itemIds = [];
+      for (let i = this.selectedCount - 1; i >= 0; i--) {
+        let selectedItem = this.selectedItems[i];
+        itemIds.push(selectedItem.id);
+        this.selectedItems.remove(selectedItem);
+      }
+      for (let i = 0; i < itemIds.length; i++) {
+        let selectedItem = document.getElementById(itemIds[i]);
+        if (selectedItem) {
+          this.selectedItems.append(selectedItem);
+        }
+      }
+    }
+    if (this.currentItem && this.currentItem.id)
+      this.currentItem = document.getElementById(this.currentItem.id);
+    else this.currentItem = null;
+
+    // if we have no previously current item or if the above check fails to
+    // find the previous nodes (which causes it to clear selection)
+    if (!this.currentItem && this.selectedCount == 0) {
+      this.currentIndex = this._currentIndex ? this._currentIndex - 1 : 0;
+
+      // cf. listbox constructor:
+      // select items according to their attributes
+      var children = this.children;
+      for (let i = 0; i < children.length; ++i) {
+        if (children[i].getAttribute("selected") == "true")
+          this.selectedItems.append(children[i]);
+      }
+    }
+
+    if (this.selType != "multiple" && this.selectedCount == 0)
+      this.selectedItem = this.currentItem;
+  }
+  _isItemVisible(aItem) {
+    if (!aItem) return false;
+
+    var y = this.scrollBoxObject.positionY + this.scrollBoxObject.y;
+
+    // Partially visible items are also considered visible
+    return (
+      aItem.boxObject.y + aItem.boxObject.height > y &&
+      aItem.boxObject.y < y + this.scrollBoxObject.height
+    );
+  }
+  getIndexOf(aElement) {
+    return this.getIndexOfItem(aElement);
+  }
+  ensureSelectedElementIsVisible() {
+    return this.ensureElementIsVisible(this.selectedItem);
+  }
+  goUp() {
+    var index = this.currentIndex;
+    this.moveByOffset(-1, true, false);
+    return index != this.currentIndex;
+  }
+  goDown() {
+    var index = this.currentIndex;
+    this.moveByOffset(1, true, false);
+    return index != this.currentIndex;
+  }
+  fireActiveItemEvent() {}
+}
+customElements.define("xbl-richlistbox", XblRichlistbox);
diff --git a/browser/base/content/customelements/Richlistitem.js b/browser/base/content/customelements/Richlistitem.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/Richlistitem.js
@@ -0,0 +1,39 @@
+class XblRichlistitem extends XblListitem {
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    console.log(this, "connected");
+
+    this.innerHTML = `<children>
+</children>`;
+    let comment = document.createComment("Creating xbl-richlistitem");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  get label() {
+    const XULNS =
+      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    return Array.map(
+      this.getElementsByTagNameNS(XULNS, "label"),
+      label => label.value
+    ).join(" ");
+  }
+
+  set searchLabel(val) {
+    if (val !== null) this.setAttribute("searchlabel", val);
+    else
+      // fall back to the label property (default value)
+      this.removeAttribute("searchlabel");
+    return val;
+  }
+
+  get searchLabel() {
+    return this.hasAttribute("searchlabel")
+      ? this.getAttribute("searchlabel")
+      : this.label;
+  }
+}
+customElements.define("xbl-richlistitem", XblRichlistitem);
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -89,16 +89,22 @@ browser.jar:
         content/browser/browser-tabsintitlebar.js       (content/browser-tabsintitlebar.js)
 #else
         content/browser/browser-tabsintitlebar.js       (content/browser-tabsintitlebar-stub.js)
 #endif
         content/browser/browser-thumbnails.js         (content/browser-thumbnails.js)
         content/browser/browser-trackingprotection.js (content/browser-trackingprotection.js)
         content/browser/tab-content.js                (content/tab-content.js)
         content/browser/content.js                    (content/content.js)
+        content/browser/customelements/Basecontrol.js   (content/customelements/Basecontrol.js)
+        content/browser/customelements/Basetext.js   (content/customelements/Basetext.js)
+        content/browser/customelements/ListboxBase.js   (content/customelements/ListboxBase.js)
+        content/browser/customelements/ListItem.js   (content/customelements/ListItem.js)
+        content/browser/customelements/Richlistbox.js   (content/customelements/Richlistbox.js)
+        content/browser/customelements/Richlistitem.js   (content/customelements/Richlistitem.js)
         content/browser/customelements/firefox-label.js   (content/customelements/firefox-label.js)
         content/browser/customelements/base-element.js    (content/customelements/base-element.js)
         content/browser/customelements/custom-elements.js (content/customelements/custom-elements.js)
         content/browser/social-content.js             (content/social-content.js)
         content/browser/default-theme-icon.svg        (content/default-theme-icon.svg)
         content/browser/defaultthemes/1.header.jpg    (content/defaultthemes/1.header.jpg)
         content/browser/defaultthemes/1.icon.jpg      (content/defaultthemes/1.icon.jpg)
         content/browser/defaultthemes/1.preview.jpg   (content/defaultthemes/1.preview.jpg)
diff --git a/browser/components/preferences/in-content-new/preferences.xul b/browser/components/preferences/in-content-new/preferences.xul
--- a/browser/components/preferences/in-content-new/preferences.xul
+++ b/browser/components/preferences/in-content-new/preferences.xul
@@ -218,16 +218,28 @@
   </stack>
   <html:firefox-label id="brian-test" value="baz" />
   <script type="application/javascript"
           src="chrome://browser/content/customelements/custom-elements.js"/>
   <script type="application/javascript"
           src="chrome://browser/content/customelements/base-element.js"/>
   <script type="application/javascript"
           src="chrome://browser/content/customelements/firefox-label.js"/>
+  <script type="application/javascript"
+          src="chrome://browser/content/customelements/Basecontrol.js"/>
+  <script type="application/javascript"
+          src="chrome://browser/content/customelements/Basetext.js"/>
+  <script type="application/javascript"
+          src="chrome://browser/content/customelements/ListboxBase.js"/>
+  <script type="application/javascript"
+          src="chrome://browser/content/customelements/Listitem.js"/>
+  <script type="application/javascript"
+          src="chrome://browser/content/customelements/Richlistbox.js"/>
+  <script type="application/javascript"
+          src="chrome://browser/content/customelements/Richlistitem.js"/>
 
   <script type="application/javascript">
     setTimeout(() => {
       var HTML_NS = "http://www.w3.org/1999/xhtml";
       var el = document.createElementNS(HTML_NS, "firefox-label");
       console.log("HER", el, document.documentElement);
       el.setAttribute("value", "bar");
       document.documentElement.appendChild(el);
diff --git a/devtools/client/themes/variables.css b/devtools/client/themes/variables.css
--- a/devtools/client/themes/variables.css
+++ b/devtools/client/themes/variables.css
@@ -237,9 +237,74 @@
 
   --toolbarbutton-background: rgba(110,120,130,0.1);
   --toolbarbutton-border-color: transparent;
   --toolbarbutton-hover-background: rgba(110,120,130,0.2);
   --toolbarbutton-hover-border-color: var(--toolbarbutton-border-color);
   --toolbarbutton-checked-background: var(--theme-selection-background);
   --toolbarbutton-checked-color: var(--theme-selection-color);
   --toolbarbutton-checked-border-color: var(--toolbarbutton-border-color);
+
+  /* Firefox Colors CSS Variables v1.0.3
+   * Colors are taken from: https://github.com/FirefoxUX/design-tokens */
+  --magenta-50: #ff1ad9;
+  --magenta-60: #ed00b5;
+  --magenta-70: #b5007f;
+  --magenta-80: #7d004f;
+  --magenta-90: #440027;
+
+  --purple-50: #9400ff;
+  --purple-60: #8000d7;
+  --purple-70: #6200a4;
+  --purple-80: #440071;
+  --purple-90: #25003e;
+
+  --blue-40: #45a1ff;
+  --blue-50: #0a84ff;
+  --blue-60: #0060df;
+  --blue-70: #003eaa;
+  --blue-80: #002275;
+  --blue-90: #000f40;
+
+  --teal-50: #00feff;
+  --teal-60: #00c8d7;
+  --teal-70: #008ea4;
+  --teal-80: #005a71;
+  --teal-90: #002d3e;
+
+  --green-50: #30e60b;
+  --green-60: #12bc00;
+  --green-70: #058b00;
+  --green-80: #006504;
+  --green-90: #003706;
+
+  --yellow-50: #ffe900;
+  --yellow-60: #d7b600;
+  --yellow-70: #a47f00;
+  --yellow-80: #715100;
+  --yellow-90: #3e2800;
+
+  --red-50: #ff0039;
+  --red-60: #d70022;
+  --red-70: #a4000f;
+  --red-80: #5a0002;
+  --red-90: #3e0200;
+
+  --orange-50: #ff9400;
+  --orange-60: #d76e00;
+  --orange-70: #a44900;
+  --orange-80: #712b00;
+  --orange-90: #3e1300;
+
+  --grey-10: #f9f9fa;
+  --grey-20: #ededf0;
+  --grey-30: #d7d7db;
+  --grey-40: #b1b1b3;
+  --grey-50: #737373;
+  --grey-60: #4a4a4f;
+  --grey-70: #38383d;
+  --grey-80: #2a2a2e;
+  --grey-90: #0c0c0d;
+
+  --ink-70: #363959;
+  --ink-80: #202340;
+  --ink-90: #0f1126;
 }
