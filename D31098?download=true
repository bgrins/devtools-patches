diff --git a/accessible/generic/Accessible.cpp b/accessible/generic/Accessible.cpp
--- a/accessible/generic/Accessible.cpp
+++ b/accessible/generic/Accessible.cpp
@@ -421,6 +421,7 @@
 
     // XXX we should look at layout for non XUL box frames, but need to decide
     // how that interacts with ARIA.
+    // XXXndeakin emulated-flexbox do something here?
     if (HasOwnContent() && mContent->IsXULElement() && frame->IsXULBoxFrame()) {
       const nsStyleXUL* xulStyle = frame->StyleXUL();
       if (xulStyle && frame->IsXULBoxFrame()) {
diff --git a/layout/generic/ReflowInput.cpp b/layout/generic/ReflowInput.cpp
--- a/layout/generic/ReflowInput.cpp
+++ b/layout/generic/ReflowInput.cpp
@@ -1116,7 +1116,7 @@
 // Returns true if aFrame is non-null, a XUL frame, and "XUL-collapsed" (which
 // only becomes a valid question to ask if we know it's a XUL frame).
 static bool IsXULCollapsedXULFrame(nsIFrame* aFrame) {
-  return aFrame && aFrame->IsXULBoxFrame() && aFrame->IsXULCollapsed();
+  return aFrame && aFrame->IsXULBoxOrEmulatedFrame() && aFrame->IsXULCollapsed();
 }
 
 nsIFrame* ReflowInput::GetHypotheticalBoxContainer(nsIFrame* aFrame,
diff --git a/layout/generic/nsFlexContainerFrame.h b/layout/generic/nsFlexContainerFrame.h
--- a/layout/generic/nsFlexContainerFrame.h
+++ b/layout/generic/nsFlexContainerFrame.h
@@ -163,6 +163,14 @@
                             nsAtom* aAttribute,
                             int32_t aModType) override;
 
+  virtual bool IsFrameOfType(uint32_t aFlags) const override {
+    if (mozilla::StaticPrefs::layout_css_emulate_moz_box_with_flex()) {
+      aFlags &= ~eEmulatedFlexBox;
+    }
+
+    return nsContainerFrame::IsFrameOfType(aFlags);
+  }
+
   // nsContainerFrame overrides
   uint16_t CSSAlignmentForAbsPosChild(
       const ReflowInput& aChildRI,
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -235,6 +235,11 @@
          !aFrame->IsXULBoxFrame();
 }
 
+static bool IsXULBoxOrEmulatedWrapped(const nsIFrame* aFrame) {
+  return aFrame->GetParent() && aFrame->GetParent()->IsXULBoxOrEmulatedFrame() &&
+         !aFrame->IsXULBoxFrame();
+}
+
 void nsReflowStatus::UpdateTruncated(const ReflowInput& aReflowInput,
                                      const ReflowOutput& aMetrics) {
   const WritingMode containerWM = aMetrics.GetWritingMode();
@@ -731,7 +736,7 @@
 
   DidSetComputedStyle(nullptr);
 
-  if (::IsXULBoxWrapped(this)) ::InitBoxMetrics(this, false);
+  if (::IsXULBoxOrEmulatedWrapped(this)) ::InitBoxMetrics(this, false);
 
   // For a newly created frame, we need to update this frame's visibility state.
   // Usually we update the state when the frame is restyled and has a
@@ -10503,7 +10508,7 @@
   // Note that the current mParent may already be destroyed at this point.
   mParent = aParent;
   MOZ_DIAGNOSTIC_ASSERT(!mParent || PresShell() == mParent->PresShell());
-  if (::IsXULBoxWrapped(this)) {
+  if (::IsXULBoxOrEmulatedWrapped(this)) {
     ::InitBoxMetrics(this, true);
   } else {
     // We could call Properties().Delete(BoxMetricsProperty()); here but
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -6074,7 +6074,7 @@
 
   // place the scrollcorner
   if (mScrollCornerBox || mResizerBox) {
-    MOZ_ASSERT(!mScrollCornerBox || mScrollCornerBox->IsXULBoxFrame(),
+    MOZ_ASSERT(!mScrollCornerBox || mScrollCornerBox->IsXULBoxOrEmulatedFrame(),
                "Must be a box frame!");
 
     nsRect r(0, 0, 0, 0);
@@ -6136,7 +6136,7 @@
   nsPresContext* presContext = mScrolledFrame->PresContext();
   nsRect vRect;
   if (mVScrollbarBox) {
-    MOZ_ASSERT(mVScrollbarBox->IsXULBoxFrame(), "Must be a box frame!");
+    MOZ_ASSERT(mVScrollbarBox->IsXULBoxOrEmulatedFrame(), "Must be a box frame!");
     vRect = mScrollPort;
     if (overlayScrollBarsWithZoom) {
       vRect.height = NSToCoordRound(res * scrollPortClampingSize.height);
@@ -6157,7 +6157,7 @@
 
   nsRect hRect;
   if (mHScrollbarBox) {
-    MOZ_ASSERT(mHScrollbarBox->IsXULBoxFrame(), "Must be a box frame!");
+    MOZ_ASSERT(mHScrollbarBox->IsXULBoxOrEmulatedFrame(), "Must be a box frame!");
     hRect = mScrollPort;
     if (overlayScrollBarsWithZoom) {
       hRect.width = NSToCoordRound(res * scrollPortClampingSize.width);
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2865,6 +2865,9 @@
     // other).
     eSupportsContainLayoutAndPaint = 1 << 16,
 
+     // This is a flex container that is emulating a XUL box.
+     eEmulatedFlexBox = 1 << 17,
+
     // These are to allow nsFrame::Init to assert that IsFrameOfType
     // implementations all call the base class method.  They are only
     // meaningful in DEBUG builds.
@@ -3665,6 +3668,8 @@
   // These methods have been migrated from nsIBox and are in the process of
   // being refactored. DO NOT USE OUTSIDE OF XUL.
   bool IsXULBoxFrame() const { return IsFrameOfType(nsIFrame::eXULBox); }
+  bool IsXULBoxOrEmulatedFrame() const { return IsFrameOfType(nsIFrame::eXULBox) ||
+                                                IsFrameOfType(nsIFrame::eEmulatedFlexBox); }
 
   enum Halignment { hAlign_Left, hAlign_Right, hAlign_Center };
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -686,20 +686,20 @@
 nsIFrame* nsBox::GetChildXULBox(const nsIFrame* aFrame) {
   // box layout ends at box-wrapped frames, so don't allow these frames
   // to report child boxes.
-  return aFrame->IsXULBoxFrame() ? aFrame->PrincipalChildList().FirstChild()
+  return aFrame->IsXULBoxOrEmulatedFrame() ? aFrame->PrincipalChildList().FirstChild()
                                  : nullptr;
 }
 
 /*static*/
 nsIFrame* nsBox::GetNextXULBox(const nsIFrame* aFrame) {
-  return aFrame->GetParent() && aFrame->GetParent()->IsXULBoxFrame()
+  return aFrame->GetParent() && aFrame->GetParent()->IsXULBoxOrEmulatedFrame()
              ? aFrame->GetNextSibling()
              : nullptr;
 }
 
 /*static*/
 nsIFrame* nsBox::GetParentXULBox(const nsIFrame* aFrame) {
-  return aFrame->GetParent() && aFrame->GetParent()->IsXULBoxFrame()
+  return aFrame->GetParent() && aFrame->GetParent()->IsXULBoxOrEmulatedFrame()
              ? aFrame->GetParent()
              : nullptr;
 }
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -677,7 +677,7 @@
 
   if (scrollbar == nullptr) return this;
 
-  return scrollbar->IsXULBoxFrame() ? scrollbar : this;
+  return scrollbar->IsXULBoxOrEmulatedFrame() ? scrollbar : this;
 }
 
 void nsSliderFrame::PageUpDown(nscoord change) {
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -243,7 +243,7 @@
   // on splitter content, then re-resolve style
   // XXXbz this is pretty messed up, since this can change whether we should
   // have a frame at all.  This really needs a better solution.
-  if (aParent && aParent->IsXULBoxFrame()) {
+  if (aParent && aParent->IsXULBoxOrEmulatedFrame()) {
     if (!aParent->IsXULHorizontal()) {
       if (!nsContentUtils::HasNonEmptyAttr(aContent, kNameSpaceID_None,
                                            nsGkAtoms::orient)) {
@@ -748,7 +748,7 @@
   }
 
   if ((SupportsCollapseDirection(Before) || SupportsCollapseDirection(After)) &&
-      mOuter->GetParent()->IsXULBoxFrame()) {
+      mOuter->GetParent()->IsXULBoxOrEmulatedFrame()) {
     // Find the splitter's immediate sibling.
     nsIFrame* splitterSibling;
     if (newState == CollapsedBefore || mState == CollapsedBefore) {
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -178,7 +178,7 @@
 
   // As an optimization, we cache the fact that we are not positioned to avoid
   // wasting time fetching attributes.
-  if (aChild->IsXULBoxFrame() &&
+  if (aChild->IsXULBoxOrEmulatedFrame() &&
       (aChild->GetStateBits() & NS_STATE_STACK_NOT_POSITIONED))
     return 0;
 
@@ -249,7 +249,7 @@
     }
   }
 
-  if (!offsetSpecified && aChild->IsXULBoxFrame()) {
+  if (!offsetSpecified && aChild->IsXULBoxOrEmulatedFrame()) {
     // If no offset was specified at all, then we cache this fact to avoid
     // requerying CSS or the content model.
     aChild->AddStateBits(NS_STATE_STACK_NOT_POSITIONED);

