# HG changeset patch
# Parent 56b736e32ae613dcbbe06968751d47e9f19d40e8
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e65a7ddaa9e0714fd1d0fb03f0384f10e6128ca1
Bug 1034110 - Provide a way to observe mutations for ::before/::after pseudo elements
* * *
ssd:

diff --git a/accessible/generic/DocAccessible.cpp b/accessible/generic/DocAccessible.cpp
--- a/accessible/generic/DocAccessible.cpp
+++ b/accessible/generic/DocAccessible.cpp
@@ -726,16 +726,23 @@ DocAccessible::AttributeWillChange(nsIDo
   }
 
   if (aAttribute == nsGkAtoms::aria_disabled ||
       aAttribute == nsGkAtoms::disabled)
     mStateBitWasOn = accessible->Unavailable();
 }
 
 void
+DocAccessible::NativeAnonymousNodeChanged(nsIDocument* aDocument,
+                                          mozilla::dom::Element* aElement,
+                                          bool isRemove)
+{
+}
+
+void
 DocAccessible::AttributeChanged(nsIDocument* aDocument,
                                 dom::Element* aElement,
                                 int32_t aNameSpaceID, nsIAtom* aAttribute,
                                 int32_t aModType,
                                 const nsAttrValue* aOldValue)
 {
   NS_ASSERTION(!IsDefunct(),
                "Attribute changed called on defunct document accessible!");
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -824,17 +824,17 @@ MarkupView.prototype = {
       }
       if (type === "attributes" || type === "characterData") {
         container.update();
 
         // Auto refresh style properties on selected node when they change.
         if (type === "attributes" && container.selected) {
           requiresLayoutChange = true;
         }
-      } else if (type === "childList") {
+      } else if (type === "childList" || "nativeAnonymousNodeBound") {
         container.childrenDirty = true;
         // Update the children to take care of changes in the markup view DOM.
         this._updateChildren(container, {flash: true});
       } else if (type === "pseudoClassLock") {
         container.update();
       }
     }
 
diff --git a/docshell/shistory/nsSHEntryShared.cpp b/docshell/shistory/nsSHEntryShared.cpp
--- a/docshell/shistory/nsSHEntryShared.cpp
+++ b/docshell/shistory/nsSHEntryShared.cpp
@@ -328,16 +328,23 @@ nsSHEntryShared::AttributeWillChange(nsI
                                      int32_t aNameSpaceID,
                                      nsIAtom* aAttribute,
                                      int32_t aModType,
                                      const nsAttrValue* aNewValue)
 {
 }
 
 void
+nsSHEntryShared::NativeAnonymousNodeChanged(nsIDocument* aDocument,
+                                            mozilla::dom::Element* aElement,
+                                            bool isRemove)
+{
+}
+
+void
 nsSHEntryShared::AttributeChanged(nsIDocument* aDocument,
                                   dom::Element* aElement,
                                   int32_t aNameSpaceID,
                                   nsIAtom* aAttribute,
                                   int32_t aModType,
                                   const nsAttrValue* aOldValue)
 {
   RemoveFromBFCacheAsync();
diff --git a/dom/animation/test/chrome.ini b/dom/animation/test/chrome.ini
--- a/dom/animation/test/chrome.ini
+++ b/dom/animation/test/chrome.ini
@@ -1,3 +1,4 @@
 [chrome/test_animation_observers.html]
+[chrome/test_anonymous_observers.html]
 [chrome/test_running_on_compositor.html]
 skip-if = buildapp == 'b2g'
\ No newline at end of file
diff --git a/dom/animation/test/chrome/test_anonymous_observers.html b/dom/animation/test/chrome/test_anonymous_observers.html
new file mode 100644
--- /dev/null
+++ b/dom/animation/test/chrome/test_anonymous_observers.html
@@ -0,0 +1,815 @@
+<!DOCTYPE html>
+<meta charset=utf-8>
+<title>Test chrome-only MutationObserver animation notifications</title>
+<script src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+<script src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>
+<link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+<style>
+@keyframes anim {
+  to { transform: translate(100px); }
+}
+#target {
+  width: 100px;
+  height: 100px;
+  background-color: yellow;
+  line-height: 16px;
+}
+</style>
+<div id=container><div id=target></div></div>
+<script>
+var div = document.getElementById("target");
+var gRecords = [];
+var gRecordPromiseResolvers = [];
+var gObserver = new MutationObserver(function(newRecords) {
+  gRecords.push(...newRecords);
+
+  var resolvers = gRecordPromiseResolvers;
+  gRecordPromiseResolvers = [];
+  resolvers.forEach(fn => fn());
+});
+
+// Asynchronous testing framework based on layout/style/test/animation_utils.js.
+
+var gTests = [];
+var gCurrentTestName;
+
+function addAsyncAnimTest(aName, aOptions, aTestGenerator) {
+  aTestGenerator.testName = aName;
+  aTestGenerator.options = aOptions || {};
+  gTests.push(aTestGenerator);
+}
+
+function runAsyncTest(aTestGenerator) {
+  return await_frame().then(function() {
+    var generator;
+
+    function step(arg) {
+      var next;
+      try {
+        next = generator.next(arg);
+      } catch (e) {
+        return Promise.reject(e);
+      }
+      if (next.done) {
+        return Promise.resolve(next.value);
+      } else {
+        return Promise.resolve(next.value).then(step);
+      }
+    }
+
+    var subtree = aTestGenerator.options.subtree;
+
+    gCurrentTestName = aTestGenerator.testName;
+    if (subtree) {
+      gCurrentTestName += ":subtree";
+    }
+
+    gRecords = [];
+    gObserver.disconnect();
+    gObserver.observe(aTestGenerator.options.observe,
+                      { animations: true, subtree: subtree});
+
+    generator = aTestGenerator();
+    return step();
+  });
+};
+
+function runAllAsyncTests() {
+  return gTests.reduce(function(sequence, test) {
+    return sequence.then(() => runAsyncTest(test));
+  }, Promise.resolve());
+}
+
+// Wrap is and ok with versions that prepend the current sub-test name
+// to the assertion description.
+var old_is = is, old_ok = ok;
+is = function(a, b, message) {
+  if (gCurrentTestName && message) {
+    message = `[${gCurrentTestName}] ${message}`;
+  }
+  old_is(a, b, message);
+}
+ok = function(a, message) {
+  if (gCurrentTestName && message) {
+    message = `[${gCurrentTestName}] ${message}`;
+  }
+  old_ok(a, message);
+}
+
+// Returns a Promise that is resolved by a requestAnimationFrame callback.
+function await_frame() {
+  return new Promise(function(aResolve) {
+    requestAnimationFrame(function() {
+      aResolve();
+    });
+  });
+}
+
+// Adds an event listener and returns a Promise that is resolved when the
+// event listener is called.
+function await_event(aElement, aEventName) {
+  return new Promise(function(aResolve) {
+    function listener(aEvent) {
+      aElement.removeEventListener(aEventName, listener);
+      aResolve();
+    }
+    aElement.addEventListener(aEventName, listener, false);
+  });
+}
+
+// Returns a Promise that is resolved after a given timeout duration.
+function await_timeout(aTimeout) {
+  return new Promise(function(aResolve) {
+    setTimeout(function() {
+      aResolve();
+    }, aTimeout);
+  });
+}
+
+// Returns a Promise that is resolved when the MutationObserver is next
+// invoked.
+function await_records() {
+  return new Promise(function(aResolve) {
+    gRecordPromiseResolvers.push(aResolve);
+  });
+}
+
+function assert_record_list(actual, expected, desc, index, listName) {
+  is(actual.length, expected.length, `${desc} - record[${index}].${listName} length`);
+  if (actual.length != expected.length) {
+    return;
+  }
+  for (var i = 0; i < actual.length; i++) {
+    ok(actual.indexOf(expected[i]) != -1,
+       `${desc} - record[${index}].${listName} contains expected Animation`);
+  }
+}
+
+function assert_records(expected, desc) {
+  var records = gRecords;
+  gRecords = [];
+  is(records.length, expected.length, `${desc} - number of records`);
+  if (records.length != expected.length) {
+    return;
+  }
+  for (var i = 0; i < records.length; i++) {
+    assert_record_list(records[i].addedAnimations, expected[i].added, desc, i, "addedAnimations");
+    assert_record_list(records[i].changedAnimations, expected[i].changed, desc, i, "changedAnimations");
+    assert_record_list(records[i].removedAnimations, expected[i].removed, desc, i, "removedAnimations");
+  }
+}
+
+// -- Tests ------------------------------------------------------------------
+
+// We run all tests first targetting the div and observing the div, then again
+// targetting the div and observing its parent while using the subtree:true
+// MutationObserver option.
+
+[
+  { observe: div,            target: div, subtree: false },
+  { observe: div.parentNode, target: div, subtree: true  },
+].forEach(function(aOptions) {
+
+  var e = aOptions.target;
+
+  // Test that starting a single transition that completes normally
+  // dispatches an added notification and then a removed notification.
+  addAsyncAnimTest("single_transition", aOptions, function*() {
+    // Start a transition.
+    e.style = "transition: background-color 100s; background-color: lime;";
+
+    // Register for the end of the transition.
+    var transitionEnd = await_event(e, "transitionend");
+
+    // The transition should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after transition start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after transition start");
+
+    // Advance until near the end of the transition, then wait for it to finish.
+    animations[0].currentTime = 99900;
+    yield transitionEnd;
+
+    // After the transition has finished, the Animation should disappear.
+    is(e.getAnimations().length, 0, "getAnimations().length after transition end");
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after transition end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single transition that is cancelled by resetting
+  // the transition-property property dispatches an added notification and
+  // then a removed notification.
+  addAsyncAnimTest("single_transition_cancelled_property", aOptions, function*() {
+    // Start a long transition.
+    e.style = "transition: background-color 100s; background-color: lime;";
+
+    // The transition should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after transition start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after transition start");
+
+    // Cancel the transition by setting transition-property.
+    e.style.transitionProperty = "none";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after transition end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single transition that is cancelled by setting
+  // style to the currently animated value dispatches an added
+  // notification and then a removed notification.
+  addAsyncAnimTest("single_transition_cancelled_value", aOptions, function*() {
+    // Start a long transition with a predictable value.
+    e.style = "transition: background-color 100s steps(2, end) -51s; background-color: lime;";
+
+    // The transition should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after transition start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after transition start");
+
+    // Cancel the transition by setting the current animation value.
+    var value = "rgb(128, 255, 0)";
+    is(getComputedStyle(e).backgroundColor, value, "half-way transition value");
+    e.style.backgroundColor = value;
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after transition end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single transition that is cancelled by setting
+  // style to a non-interpolable value dispatches an added notification
+  // and then a removed notification.
+  addAsyncAnimTest("single_transition_cancelled_noninterpolable", aOptions, function*() {
+    // Start a long transition.
+    e.style = "transition: line-height 100s; line-height: 100px;";
+
+    // The transition should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after transition start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after transition start");
+
+    // Cancel the transition by setting line-height to a non-interpolable value.
+    e.style.lineHeight = "normal";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after transition end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single transition and then reversing it
+  // dispatches an added notification, then a simultaneous removed and
+  // added notification, then a removed notification once finished.
+  addAsyncAnimTest("single_transition_reversed", aOptions, function*() {
+    // Start a long transition.
+    e.style = "transition: background-color 100s step-start; background-color: lime;";
+
+    // The transition should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after transition start");
+
+    var firstAnimation = animations[0];
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [firstAnimation], changed: [], removed: [] }],
+                   "records after transition start");
+
+    // Wait for the Animation to be playing, then seek well into
+    // the transition.
+    yield firstAnimation.ready;
+    firstAnimation.currentTime = 50000;
+
+    // Reverse the transition by setting the background-color back to its
+    // original value.
+    e.style.backgroundColor = "yellow";
+
+    // The reversal should cause the creation of a new Animation.
+    animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after transition reversal");
+
+    var secondAnimation = animations[0];
+
+    ok(firstAnimation != secondAnimation,
+       "second Animation should be different from the first");
+
+    // Wait for the single MutationRecord for the removal of the original
+    // Animation and the addition of the new Animation to be delivered.
+    yield await_frame();
+    assert_records([{ added: [secondAnimation], changed: [],
+                      removed: [firstAnimation] }],
+                   "records after transition reversal");
+
+    // Cancel the transition.
+    e.style.transitionProperty = "none";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: [secondAnimation] }],
+                   "records after transition end");
+
+    e.style = "";
+  });
+
+  // Test that multiple transitions starting and ending on an element
+  // at the same time get batched up into a single MutationRecord.
+  addAsyncAnimTest("multiple_transitions", aOptions, function*() {
+    // Start three long transitions.
+    e.style = "transition-duration: 100s; " +
+              "transition-property: color, background-color, line-height; " +
+              "color: blue; background-color: lime; line-height: 24px;";
+
+    // The transitions should cause the creation of three Animations.
+    var animations = e.getAnimations();
+    is(animations.length, 3, "getAnimations().length after transition starts");
+
+    // Wait for the single MutationRecord for the Animation additions to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after transition starts");
+
+    // Wait for the Animations to get going, then seek well into
+    // the transitions.
+    yield animations[0].ready;
+
+    animations.forEach(p => p.currentTime = 50000);
+
+    is(animations.filter(p => p.playState == "running").length, 3, "number of running Animations");
+
+    // Cancel one of the transitions by setting transition-property.
+    e.style.transitionProperty = "background-color, line-height";
+
+    var colorAnimation  = animations.filter(p => p.playState != "running");
+    var otherAnimations = animations.filter(p => p.playState == "running");
+
+    is(colorAnimation.length, 1, "number of non-running Animations after cancelling one");
+    is(otherAnimations.length, 2, "number of running Animations after cancelling one");
+
+    // Wait for a MutationRecord for one of the Animation
+    // removals to be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: colorAnimation }],
+                   "records after color transition end");
+
+    // Cancel the remaining transitions.
+    e.style.transitionProperty = "none";
+
+    // Wait for the MutationRecord for the other two Animation
+    // removals to be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: otherAnimations }],
+                   "records after other transition ends");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that completes normally
+  // dispatches an added notification and then a removed notification.
+  addAsyncAnimTest("single_animation", aOptions, function*() {
+    // Start an animation.
+    e.style = "animation: anim 100s;";
+
+    // Register for the end of the animation.
+    var animationEnd = await_event(e, "animationend");
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Advance until near the end of the animation, then wait for it to finish.
+    animations[0].currentTime = 99900;
+    yield animationEnd;
+
+    // After the animation has finished, the Animation should disappear.
+    is(e.getAnimations().length, 0, "getAnimations().length after animation end");
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that is cancelled by resetting
+  // the animation-name property dispatches an added notification and
+  // then a removed notification.
+  addAsyncAnimTest("single_animation_cancelled_name", aOptions, function*() {
+    // Start a long animation.
+    e.style = "animation: anim 100s;";
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Cancel the animation by setting animation-name.
+    e.style.animationName = "none";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that is cancelled by updating
+  // the animation-duration property dispatches an added notification and
+  // then a removed notification.
+  addAsyncAnimTest("single_animation_cancelled_duration", aOptions, function*() {
+    // Start a long animation.
+    e.style = "animation: anim 100s;";
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Advance the animation by a second.
+    animations[0].currentTime += 1000;
+
+    // Cancel the animation by setting animation-duration to a value less
+    // than a second.
+    e.style.animationDuration = "0.1s";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that is cancelled by updating
+  // the animation-delay property dispatches an added notification and
+  // then a removed notification.
+  addAsyncAnimTest("single_animation_cancelled_delay", aOptions, function*() {
+    // Start a long animation.
+    e.style = "animation: anim 100s;";
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Cancel the animation by setting animation-delay.
+    e.style.animationDelay = "-200s";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that is cancelled by updating
+  // the animation-fill-mode property dispatches an added notification and
+  // then a removed notification.
+  addAsyncAnimTest("single_animation_cancelled_fill", aOptions, function*() {
+    // Start a short, filled animation.
+    e.style = "animation: anim 100s forwards;";
+
+    // Register for the end of the animation.
+    var animationEnd = await_event(e, "animationend");
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Advance until near the end of the animation, then wait for it to finish.
+    animations[0].currentTime = 99900;
+    yield animationEnd;
+
+    // No changes to the list of animations at this point.
+    assert_records([], "records after animation starts filling");
+
+    // Cancel the animation by setting animation-fill-mode.
+    e.style.animationFillMode = "none";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that is cancelled by updating
+  // the animation-iteration-count property dispatches an added notification
+  // and then a removed notification.
+  addAsyncAnimTest("single_animation_cancelled_iteration_count",
+                   aOptions, function*() {
+    // Start a short, repeated animation.
+    e.style = "animation: anim 0.5s infinite;";
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Advance the animation until we are past the first iteration.
+    animations[0].currentTime += 1000;
+
+    // No changes to the list of animations at this point.
+    assert_records([], "records after animation starts repeating");
+
+    // Cancel the animation by setting animation-iteration-count.
+    e.style.animationIterationCount = "1";
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that starting a single animation that is cancelled by calling
+  // cancel() dispatches an added notification and then a removed
+  // notification.
+  addAsyncAnimTest("single_animation_cancelled_api", aOptions, function*() {
+    // Start a short, filled animation.
+    e.style = "animation: anim 100s forwards;";
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Cancel the animation
+    animations[0].cancel();
+
+    // Wait for the single MutationRecord for the Animation removal to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    // Re-trigger the animation
+    animations[0].play();
+    yield await_frame();
+
+    // Wait for the single MutationRecord for the Animation (re-)addition to
+    // be delivered.
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    e.style = "";
+  });
+
+  // Test that updating an animation property dispatches a changed notification.
+  [
+    { name: "duration",  prop: "animationDuration",       val: "200s"    },
+    { name: "timing",    prop: "animationTimingFunction", val: "linear"  },
+    { name: "iteration", prop: "animationIterationCount", val: "2"       },
+    { name: "direction", prop: "animationDirection",      val: "reverse" },
+    { name: "state",     prop: "animationPlayState",      val: "paused"  },
+    { name: "delay",     prop: "animationDelay",          val: "-1s"     },
+    { name: "fill",      prop: "animationFillMode",       val: "both"    },
+  ].forEach(function(aChangeTest) {
+    addAsyncAnimTest(`single_animation_change_${aChangeTest.name}`, aOptions, function*() {
+      // Start a long animation.
+      e.style = "animation: anim 100s;";
+
+      // The animation should cause the creation of a single Animation.
+      var animations = e.getAnimations();
+      is(animations.length, 1, "getAnimations().length after animation start");
+
+      // Wait for the single MutationRecord for the Animation addition to
+      // be delivered.
+      yield await_frame();
+      assert_records([{ added: animations, changed: [], removed: [] }],
+                     "records after animation start");
+
+      // Change a property of the animation such that it keeps running.
+      e.style[aChangeTest.prop] = aChangeTest.val;
+
+      // Wait for the single MutationRecord for the Animation change to
+      // be delivered.
+      yield await_frame();
+      assert_records([{ added: [], changed: animations, removed: [] }],
+                     "records after animation change");
+
+      // Cancel the animation.
+      e.style.animationName = "none";
+
+      // Wait for the addition, change and removal MutationRecords to be delivered.
+      yield await_frame();
+      assert_records([{ added: [], changed: [], removed: animations }],
+                      "records after animation end");
+
+      e.style = "";
+    });
+  });
+
+  // Test that a non-cancelling change to an animation followed immediately by a
+  // cancelling change will only send an animation removal notification.
+  addAsyncAnimTest("coalesce_change_cancel", aOptions, function*() {
+    // Start a long animation.
+    e.style = "animation: anim 100s;";
+
+    // The animation should cause the creation of a single Animation.
+    var animations = e.getAnimations();
+    is(animations.length, 1, "getAnimations().length after animation start");
+
+    // Wait for the single MutationRecord for the Animation addition to
+    // be delivered.
+    yield await_frame();
+    assert_records([{ added: animations, changed: [], removed: [] }],
+                   "records after animation start");
+
+    // Update the animation's delay such that it is still running.
+    e.style.animationDelay = "-1s";
+
+    // Then cancel the animation by updating its duration.
+    e.style.animationDuration = "0.5s";
+
+    // We should get a single removal notification.
+    yield await_frame();
+    assert_records([{ added: [], changed: [], removed: animations }],
+                   "records after animation end");
+
+    e.style = "";
+  });
+
+  // Test that attempting to start an animation that should already be finished
+  // does not send any notifications.
+  addAsyncAnimTest("already_finished", aOptions, function*() {
+    // Start an animation that should already be finished.
+    e.style = "animation: anim 1s -2s;";
+
+    // The animation should cause no Animations to be created.
+    var animations = e.getAnimations();
+    is(animations.length, 0, "getAnimations().length after animation start");
+
+    // And we should get no notifications.
+    yield await_frame();
+    assert_records([], "records after attempted animation start");
+
+    e.style = "";
+  });
+});
+
+addAsyncAnimTest("tree_ordering", { observe: div, subtree: true }, function*() {
+
+  // Create a tree with two children:
+  //
+  //         div
+  //        /  \
+  //   childA  childB
+  var childA = document.createElement("div");
+  var childB = document.createElement("div");
+
+  div.appendChild(childA);
+  div.appendChild(childB);
+
+  // Start an animation on each (using order: childB, div, childA)
+  //
+  // We include multiple animations on some nodes so that we can test batching
+  // works as expected later in this test.
+  childB.style = "animation: anim 100s";
+  div.style    = "animation: anim 100s, anim 100s, anim 100s";
+  childA.style = "animation: anim 100s, anim 100s";
+
+  var divAnimations = div.getAnimations();
+  var childAAnimations = childA.getAnimations();
+  var childBAnimations = childB.getAnimations();
+
+  // The order in which we get the corresponding records is currently
+  // based on the order we visit these nodes when updating styles.
+  //
+  // That is because we don't do any document-level batching of animation
+  // mutation records when we flush styles. We may introduce that in the
+  // future but for now all we are interested in testing here is that the order
+  // these records are dispatched is consistent between runs.
+  //
+  // We currently expect to get records in order childA, childB, div
+  yield await_frame();
+  assert_records([{ added: childAAnimations, changed: [], removed: [] },
+                  { added: childBAnimations, changed: [], removed: [] },
+                  { added: divAnimations, changed: [], removed: [] }],
+                 "records after simultaneous animation start");
+
+  // The one case where we *do* currently perform document-level (or actually
+  // timeline-level) batching is when animations are updated from a refresh
+  // driver tick. In particular, this means that when animations finish
+  // naturally the removed records should be dispatched according to the
+  // position of the elements in the tree.
+  //
+  // Fast-forward to *just* before the end of the animation.
+  var fastForward = animation => animation.currentTime = 99999;
+  divAnimations.forEach(fastForward);
+  childAAnimations.forEach(fastForward);
+  childBAnimations.forEach(fastForward);
+
+  yield await_event(div, "animationend");
+
+  // We should get records in order div, childA, childB
+  assert_records([{ added: [], changed: [], removed: divAnimations },
+                  { added: [], changed: [], removed: childAAnimations },
+                  { added: [], changed: [], removed: childBAnimations }],
+                 "records after finishing");
+
+  // Clean up
+  div.style = "";
+  childA.remove();
+  childB.remove();
+});
+
+// Run the tests.
+
+SimpleTest.waitForExplicitFinish();
+
+runAllAsyncTests().then(function() {
+  SimpleTest.finish();
+}, function(aError) {
+  ok(false, "Something failed: " + aError);
+});
+</script>
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -1624,16 +1624,19 @@ Element::BindToTree(nsIDocument* aDocume
           parent->ChangeEditableDescendantCount(editableDescendantChange);
           parent = parent->GetParent();
         }
       }
     }
   }
 
   nsNodeUtils::ParentChainChanged(this);
+  if (this->IsRootOfNativeAnonymousSubtree()) {
+	  nsNodeUtils::NativeAnonymousNodeChanged(this, false);
+  }
 
   if (HasID()) {
     AddToIdTable(DoGetID());
   }
 
   if (MayHaveStyle() && !IsXULElement()) {
     // XXXbz if we already have a style attr parsed, this won't do
     // anything... need to fix that.
@@ -1739,16 +1742,19 @@ Element::UnbindFromTree(bool aDeep, bool
         while (parent) {
           parent->ChangeEditableDescendantCount(editableDescendantChange);
           parent = parent->GetParent();
         }
       }
     }
 
     if (GetParent()) {
+      if (this->IsRootOfNativeAnonymousSubtree()) {
+        nsNodeUtils::NativeAnonymousNodeChanged(this, true);
+      }
       nsINode* p = mParent;
       mParent = nullptr;
       NS_RELEASE(p);
     } else {
       mParent = nullptr;
     }
     SetParentIsContent(false);
   }
diff --git a/dom/base/nsDOMMutationObserver.cpp b/dom/base/nsDOMMutationObserver.cpp
--- a/dom/base/nsDOMMutationObserver.cpp
+++ b/dom/base/nsDOMMutationObserver.cpp
@@ -109,16 +109,72 @@ nsMutationReceiver::Disconnect(bool aRem
     if (aRemoveFromObserver) {
       static_cast<nsDOMMutationObserver*>(observer)->RemoveReceiver(this);
     }
     // UnbindObject may delete 'this'!
     target->UnbindObject(observer);
   }
 }
 
+/**
+ * Notification that the root of a native anonymous subtree
+ * (such as ::before or ::after) has been added or removed.
+ * This fires for chrome observers only.
+ *
+ * @param aDocument    The owner-document of aContent.
+ * @param aElement     The anonymous element that's been added
+ *                     or removed.
+ * @param isRemove     True if it's a removal, false for addition.
+ */
+void
+nsMutationReceiver::NativeAnonymousNodeChanged(nsIDocument* aDocument,
+                                               mozilla::dom::Element* aElement,
+                                               bool isRemove) {
+
+  if (!NativeAnonymousNodeBound() ||
+      !Observer()->IsChrome()) {
+    return;
+  }
+  nsAutoString innerHTML;
+  aElement->GetParent()->AsElement()->GetInnerHTML(innerHTML);
+
+  // nsCOMPtr<nsLocation> location = aElement->OwnerDoc()->GetLocation();
+  // nsAutoString oldHref;
+  // location->GetHref(oldHref);
+
+  // aElement->OwnerDoc()->GetLocation().GetHref(oldHref);
+
+  // nsDocument* regDoc = static_cast<nsDocument*>(RegisterTarget());
+  // nsCOMPtr<nsIDOMLocation> location2 = regDoc->GetLocation();
+  // nsAutoString oldHref;
+  // location2.GetHref(oldHref);
+  // nsAutoString regHref;
+  // regDoc->GetLocation().GetHref(regHref);
+
+  nsINode* parent = NODE_FROM(aElement, aDocument);
+  // nsINode* parent2 = NODE_FROM(aElement, RegisterTarget()->AsElement()->OwnerDoc());
+	// if (Subtree() && parent->SubtreeRoot() != RegisterTarget()->SubtreeRoot()) {
+	// 	return;
+	// }
+
+  // XXX: Can there already be a currentrecord for this?
+  // Figure out how to handle that case.
+	nsDOMMutationRecord* m =
+		Observer()->CurrentRecord(nsGkAtoms::nativeAnonymousNodeBound);
+	m->mTarget = aElement->GetParent();
+
+  if (isRemove) {
+    m->mRemovedNodes = new nsSimpleContentList(aElement->GetParent());
+    m->mRemovedNodes->AppendElement(aElement);
+  } else {
+    m->mAddedNodes = new nsSimpleContentList(aElement->GetParent());
+    m->mAddedNodes->AppendElement(aElement);
+  }
+}
+
 void
 nsMutationReceiver::AttributeWillChange(nsIDocument* aDocument,
                                         mozilla::dom::Element* aElement,
                                         int32_t aNameSpaceID,
                                         nsIAtom* aAttribute,
                                         int32_t aModType,
                                         const nsAttrValue* aNewValue)
 {
@@ -580,34 +636,35 @@ nsDOMMutationObserver::Observe(nsINode& 
     aOptions.mAttributes.WasPassed() &&
     aOptions.mAttributes.Value();
   bool characterData =
     aOptions.mCharacterData.WasPassed() &&
     aOptions.mCharacterData.Value();
   bool subtree = aOptions.mSubtree;
   bool attributeOldValue =
     aOptions.mAttributeOldValue.WasPassed() &&
-    aOptions.mAttributeOldValue.Value();
+	aOptions.mAttributeOldValue.Value();
+  bool nativeAnonymousNodeBound = aOptions.mNativeAnonymousNodeBound;
   bool characterDataOldValue =
-    aOptions.mCharacterDataOldValue.WasPassed() &&
-    aOptions.mCharacterDataOldValue.Value();
+	  aOptions.mCharacterDataOldValue.WasPassed() &&
+	  aOptions.mCharacterDataOldValue.Value();
   bool animations =
     aOptions.mAnimations.WasPassed() &&
     aOptions.mAnimations.Value() &&
     nsContentUtils::ThreadsafeIsCallerChrome();
 
   if (!aOptions.mAttributes.WasPassed() &&
       (aOptions.mAttributeOldValue.WasPassed() ||
        aOptions.mAttributeFilter.WasPassed())) {
     attributes = true;
   }
 
   if (!aOptions.mCharacterData.WasPassed() &&
-      aOptions.mCharacterDataOldValue.WasPassed()) {
-    characterData = true;
+	  aOptions.mCharacterDataOldValue.WasPassed()) {
+	  characterData = true;
   }
 
   if (!(childList || attributes || characterData || animations)) {
     aRv.Throw(NS_ERROR_DOM_TYPE_ERR);
     return;
   }
 
   if (aOptions.mAttributeOldValue.WasPassed() &&
@@ -650,16 +707,17 @@ nsDOMMutationObserver::Observe(nsINode& 
 
   nsMutationReceiver* r = GetReceiverFor(&aTarget, true, animations);
   r->SetChildList(childList);
   r->SetAttributes(attributes);
   r->SetCharacterData(characterData);
   r->SetSubtree(subtree);
   r->SetAttributeOldValue(attributeOldValue);
   r->SetCharacterDataOldValue(characterDataOldValue);
+  r->SetNativeAnonymousNodeBound(nativeAnonymousNodeBound);
   r->SetAttributeFilter(filters);
   r->SetAllAttributes(allAttrs);
   r->SetAnimations(animations);
   r->RemoveClones();
 
 #ifdef DEBUG
   for (int32_t i = 0; i < mReceivers.Count(); ++i) {
     NS_WARN_IF_FALSE(mReceivers[i]->Target(),
@@ -708,18 +766,19 @@ nsDOMMutationObserver::GetObservingInfo(
   aResult.SetCapacity(mReceivers.Count());
   for (int32_t i = 0; i < mReceivers.Count(); ++i) {
     MutationObservingInfo& info = aResult.AppendElement()->SetValue();
     nsMutationReceiver* mr = mReceivers[i];
     info.mChildList = mr->ChildList();
     info.mAttributes.Construct(mr->Attributes());
     info.mCharacterData.Construct(mr->CharacterData());
     info.mSubtree = mr->Subtree();
-    info.mAttributeOldValue.Construct(mr->AttributeOldValue());
-    info.mCharacterDataOldValue.Construct(mr->CharacterDataOldValue());
+	  info.mAttributeOldValue.Construct(mr->AttributeOldValue());
+	  info.mCharacterDataOldValue.Construct(mr->CharacterDataOldValue());
+	  info.mNativeAnonymousNodeBound = mr->NativeAnonymousNodeBound();
     info.mAnimations.Construct(mr->Animations());
     nsCOMArray<nsIAtom>& filters = mr->AttributeFilter();
     if (filters.Count()) {
       info.mAttributeFilter.Construct();
       mozilla::dom::Sequence<nsString>& filtersAsStrings =
         info.mAttributeFilter.Value();
       for (int32_t j = 0; j < filters.Count(); ++j) {
         if (!filtersAsStrings.AppendElement(nsDependentAtomString(filters[j]),
diff --git a/dom/base/nsDOMMutationObserver.h b/dom/base/nsDOMMutationObserver.h
--- a/dom/base/nsDOMMutationObserver.h
+++ b/dom/base/nsDOMMutationObserver.h
@@ -167,16 +167,26 @@ public:
     return mParent ? mParent->CharacterDataOldValue() : mCharacterDataOldValue;
   }
   void SetCharacterDataOldValue(bool aOldValue)
   {
     NS_ASSERTION(!mParent, "Shouldn't have parent");
     mCharacterDataOldValue = aOldValue;
   }
 
+  bool NativeAnonymousNodeBound()
+  {
+    return mParent ? mParent->NativeAnonymousNodeBound() : mNativeAnonymousNodeBound;
+  }
+  void SetNativeAnonymousNodeBound(bool aOldValue)
+  {
+    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    mNativeAnonymousNodeBound = aOldValue;
+  }
+
   bool Attributes() { return mParent ? mParent->Attributes() : mAttributes; }
   void SetAttributes(bool aAttributes)
   {
     NS_ASSERTION(!mParent, "Shouldn't have parent");
     mAttributes = aAttributes;
   }
 
   bool AllAttributes()
@@ -293,16 +303,17 @@ protected:
   // alive so it doesn't go away and disconnect all its transient receivers.
   nsCOMPtr<nsINode>                  mKungFuDeathGrip;
   
 private:
   bool                               mSubtree;
   bool                               mChildList;
   bool                               mCharacterData;
   bool                               mCharacterDataOldValue;
+  bool                               mNativeAnonymousNodeBound;
   bool                               mAttributes;
   bool                               mAllAttributes;
   bool                               mAttributeOldValue;
   bool                               mAnimations;
   nsCOMArray<nsIAtom>                mAttributeFilter;
 };
 
 
@@ -357,16 +368,17 @@ public:
   }
 
   void Disconnect(bool aRemoveFromObserver);
 
   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
+  NS_DECL_NSIMUTATIONOBSERVER_NATIVEANONYMOUSNODEBOUND
   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATAWILLCHANGE
   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
   NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
 
   virtual void AttributeSetToCurrentValue(nsIDocument* aDocument,
                                           mozilla::dom::Element* aElement,
diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -628,16 +628,17 @@ GK_ATOM(msthemecompatible, "msthemecompa
 GK_ATOM(multicol, "multicol")
 GK_ATOM(multiple, "multiple")
 GK_ATOM(muted, "muted")
 GK_ATOM(name, "name")
 GK_ATOM(_namespace, "namespace")
 GK_ATOM(namespaceAlias, "namespace-alias")
 GK_ATOM(namespaceUri, "namespace-uri")
 GK_ATOM(NaN, "NaN")
+GK_ATOM(nativeAnonymousNodeBound, "nativeAnonymousNodeBound")
 GK_ATOM(nav, "nav")
 GK_ATOM(negate, "negate")
 GK_ATOM(never, "never")
 GK_ATOM(_new, "new")
 GK_ATOM(newline, "newline")
 GK_ATOM(nextBidi, "NextBidi")
 GK_ATOM(no, "no")
 GK_ATOM(noautofocus, "noautofocus")
diff --git a/dom/base/nsIMutationObserver.h b/dom/base/nsIMutationObserver.h
--- a/dom/base/nsIMutationObserver.h
+++ b/dom/base/nsIMutationObserver.h
@@ -196,16 +196,29 @@ public:
   virtual void AttributeChanged(nsIDocument* aDocument,
                                 mozilla::dom::Element* aElement,
                                 int32_t      aNameSpaceID,
                                 nsIAtom*     aAttribute,
                                 int32_t      aModType,
                                 const nsAttrValue* aOldValue) = 0;
 
   /**
+   * XXX: Notification that an attribute of an element has been
+   * set to the value it already had.
+   *
+   * @param aDocument    The owner-document of aContent.
+   * @param aElement     The element whose attribute changed
+   * @param aNameSpaceID The namespace id of the changed attribute
+   * @param aAttribute   The name of the changed attribute
+   */
+  virtual void NativeAnonymousNodeChanged(nsIDocument* aDocument,
+                                          mozilla::dom::Element* aElement,
+                                          bool isRemove) {}
+
+  /**
    * Notification that an attribute of an element has been
    * set to the value it already had.
    *
    * @param aDocument    The owner-document of aContent.
    * @param aElement     The element whose attribute changed
    * @param aNameSpaceID The namespace id of the changed attribute
    * @param aAttribute   The name of the changed attribute
    */
@@ -341,16 +354,21 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIMutatio
 #define NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE                      \
     virtual void AttributeWillChange(nsIDocument* aDocument,                 \
                                      mozilla::dom::Element* aElement,        \
                                      int32_t aNameSpaceID,                   \
                                      nsIAtom* aAttribute,                    \
                                      int32_t aModType,                       \
                                      const nsAttrValue* aNewValue) override;
 
+#define NS_DECL_NSIMUTATIONOBSERVER_NATIVEANONYMOUSNODEBOUND                 \
+    virtual void NativeAnonymousNodeChanged(nsIDocument* aDocument,          \
+                                            mozilla::dom::Element* aElement, \
+                                            bool isRemove) override;
+
 #define NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED                         \
     virtual void AttributeChanged(nsIDocument* aDocument,                    \
                                   mozilla::dom::Element* aElement,           \
                                   int32_t aNameSpaceID,                      \
                                   nsIAtom* aAttribute,                       \
                                   int32_t aModType,                          \
                                   const nsAttrValue* aOldValue) override;
 
@@ -378,16 +396,17 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIMutatio
 
 #define NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED                       \
     virtual void ParentChainChanged(nsIContent *aContent) override;
 
 #define NS_DECL_NSIMUTATIONOBSERVER                                          \
     NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATAWILLCHANGE                      \
     NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED                         \
     NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE                          \
+    NS_DECL_NSIMUTATIONOBSERVER_NATIVEANONYMOUSNODEBOUND                     \
     NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED                             \
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED                              \
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED                              \
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED                               \
     NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED                          \
     NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
 
 #define NS_IMPL_NSIMUTATIONOBSERVER_CORE_STUB(_class)                     \
@@ -414,16 +433,22 @@ void                                    
                             mozilla::dom::Element* aElement,              \
                             int32_t aNameSpaceID,                         \
                             nsIAtom* aAttribute,                          \
                             int32_t aModType,                             \
                             const nsAttrValue* aNewValue)                 \
 {                                                                         \
 }                                                                         \
 void                                                                      \
+_class::NativeAnonymousNodeChanged(nsIDocument* aDocument,                \
+                                   mozilla::dom::Element* aElement,       \
+                                   bool isRemove)                         \
+{                                                                         \
+}                                                                         \
+void                                                                      \
 _class::AttributeChanged(nsIDocument* aDocument,                          \
                          mozilla::dom::Element* aElement,                 \
                          int32_t aNameSpaceID,                            \
                          nsIAtom* aAttribute,                             \
                          int32_t aModType,                                \
                          const nsAttrValue* aOldValue)                    \
 {                                                                         \
 }                                                                         \
diff --git a/dom/base/nsNodeUtils.cpp b/dom/base/nsNodeUtils.cpp
--- a/dom/base/nsNodeUtils.cpp
+++ b/dom/base/nsNodeUtils.cpp
@@ -156,23 +156,31 @@ nsNodeUtils::AttributeSetToCurrentValue(
 }
 
 void
 nsNodeUtils::ContentAppended(nsIContent* aContainer,
                              nsIContent* aFirstNewContent,
                              int32_t aNewIndexInContainer)
 {
   nsIDocument* doc = aContainer->OwnerDoc();
-
   IMPL_MUTATION_NOTIFICATION(ContentAppended, aContainer,
                              (doc, aContainer, aFirstNewContent,
                               aNewIndexInContainer));
 }
 
 void
+nsNodeUtils::NativeAnonymousNodeChanged(mozilla::dom::Element* aElement,
+                                        bool isRemove)
+{
+  nsIDocument* doc = aElement->OwnerDoc();
+  IMPL_MUTATION_NOTIFICATION(NativeAnonymousNodeChanged, aElement,
+                            (doc, aElement, isRemove));
+}
+
+void
 nsNodeUtils::ContentInserted(nsINode* aContainer,
                              nsIContent* aChild,
                              int32_t aIndexInContainer)
 {
   NS_PRECONDITION(aContainer->IsNodeOfType(nsINode::eCONTENT) ||
                   aContainer->IsNodeOfType(nsINode::eDOCUMENT),
                   "container must be an nsIContent or an nsIDocument");
   nsIContent* container;
diff --git a/dom/base/nsNodeUtils.h b/dom/base/nsNodeUtils.h
--- a/dom/base/nsNodeUtils.h
+++ b/dom/base/nsNodeUtils.h
@@ -92,16 +92,26 @@ public:
    * @param aNewIndexInContainer Index of first new child
    * @see nsIMutationObserver::ContentAppended
    */
   static void ContentAppended(nsIContent* aContainer,
                               nsIContent* aFirstNewContent,
                               int32_t aNewIndexInContainer);
 
   /**
+   * XXXXX: Send ContentAppended notifications to nsIMutationObservers
+   * @param aContainer           Node into which new child/children were added
+   * @param aFirstNewContent     First new child
+   * @param aNewIndexInContainer Index of first new child
+   * @see nsIMutationObserver::ContentAppended
+   */
+  static void NativeAnonymousNodeChanged(mozilla::dom::Element* aElement,
+                                         bool isRemove);
+
+  /**
    * Send ContentInserted notifications to nsIMutationObservers
    * @param aContainer        Node into which new child was inserted
    * @param aChild            Newly inserted child
    * @param aIndexInContainer Index of new child
    * @see nsIMutationObserver::ContentInserted
    */
   static void ContentInserted(nsINode* aContainer,
                               nsIContent* aChild,
diff --git a/dom/webidl/MutationObserver.webidl b/dom/webidl/MutationObserver.webidl
--- a/dom/webidl/MutationObserver.webidl
+++ b/dom/webidl/MutationObserver.webidl
@@ -56,16 +56,18 @@ callback MutationCallback = void (sequen
 dictionary MutationObserverInit {
   boolean childList = false;
   boolean attributes;
   boolean characterData;
   boolean subtree = false;
   boolean attributeOldValue;
   boolean characterDataOldValue;
   // [ChromeOnly]
+  boolean nativeAnonymousNodeBound = false;
+  // [ChromeOnly]
   boolean animations;
   sequence<DOMString> attributeFilter;
 };
 
 dictionary MutationObservingInfo : MutationObserverInit
 {
   Node? observedNode = null;
 };
diff --git a/toolkit/components/satchel/nsFormFillController.cpp b/toolkit/components/satchel/nsFormFillController.cpp
--- a/toolkit/components/satchel/nsFormFillController.cpp
+++ b/toolkit/components/satchel/nsFormFillController.cpp
@@ -190,16 +190,23 @@ nsFormFillController::AttributeWillChang
                                           mozilla::dom::Element* aElement,
                                           int32_t aNameSpaceID,
                                           nsIAtom* aAttribute, int32_t aModType,
                                           const nsAttrValue* aNewValue)
 {
 }
 
 void
+nsFormFillController::NativeAnonymousNodeChanged(nsIDocument* aDocument,
+                                                 mozilla::dom::Element* aElement,
+                                                 bool isRemove)
+{
+}
+
+void
 nsFormFillController::ParentChainChanged(nsIContent* aContent)
 {
 }
 
 void
 nsFormFillController::NodeWillBeDestroyed(const nsINode* aNode)
 {
   mPwmgrInputs.Remove(aNode);
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -315,16 +315,17 @@ var NodeActor = exports.NodeActor = prot
    */
   watchDocument: function(callback) {
     let node = this.rawNode;
     // Create the observer on the node's actor.  The node will make sure
     // the observer is cleaned up when the actor is released.
     let observer = new node.defaultView.MutationObserver(callback);
     observer.mergeAttributeRecords = true;
     observer.observe(node, {
+      nativeAnonymousNodeBound: true,
       attributes: true,
       characterData: true,
       childList: true,
       subtree: true
     });
     this.mutationObserver = observer;
   },
 
@@ -2794,17 +2795,20 @@ var WalkerActor = protocol.ActorClass({
   },
 
   /**
    * Handles mutations from the DOM mutation observer API.
    *
    * @param array[MutationRecord] mutations
    *    See https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationRecord
    */
-  onMutations: function(mutations) {
+   onMutations: function(mutations) {
+    console.log("On mutations", mutations, mutations.map(t=>t.target),
+        mutations.map(t=>t.addedNodes),
+        mutations.map(t=>t.removedNodes));
     for (let change of mutations) {
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
       let mutation = {
         type: change.type,
@@ -2819,34 +2823,36 @@ var WalkerActor = protocol.ActorClass({
                             : null;
       } else if (mutation.type === "characterData") {
         if (targetNode.nodeValue.length > gValueSummaryLength) {
           mutation.newValue = targetNode.nodeValue.substring(0, gValueSummaryLength);
           mutation.incompleteValue = true;
         } else {
           mutation.newValue = targetNode.nodeValue;
         }
-      } else if (mutation.type === "childList") {
+      } else if (mutation.type === "childList" || mutation.type === "nativeAnonymousNodeBound") {
         // Get the list of removed and added actors that the client has seen
         // so that it can keep its ownership tree up to date.
         let removedActors = [];
         let addedActors = [];
         for (let removed of change.removedNodes) {
           let removedActor = this._refMap.get(removed);
+          console.log("Removed node", removed, removedActor);
           if (!removedActor) {
             // If the client never encountered this actor we don't need to
             // mention that it was removed.
             continue;
           }
           // While removed from the tree, nodes are saved as orphaned.
           this._orphaned.add(removedActor);
           removedActors.push(removedActor.actorID);
         }
         for (let added of change.addedNodes) {
           let addedActor = this._refMap.get(added);
+          console.log("Added node", added, addedActor);
           if (!addedActor) {
             // If the client never encounted this actor we don't need to tell
             // it about its addition for ownership tree purposes - if the
             // client wants to see the new nodes it can ask for children.
             continue;
           }
           // The actor is reconnected to the ownership tree, unorphan
           // it and let the client know so that its ownership tree is up
diff --git a/widget/cocoa/nsMenuGroupOwnerX.mm b/widget/cocoa/nsMenuGroupOwnerX.mm
--- a/widget/cocoa/nsMenuGroupOwnerX.mm
+++ b/widget/cocoa/nsMenuGroupOwnerX.mm
@@ -101,16 +101,21 @@ void nsMenuGroupOwnerX::AttributeWillCha
                                             dom::Element* aContent,
                                             int32_t aNameSpaceID,
                                             nsIAtom* aAttribute,
                                             int32_t aModType,
                                             const nsAttrValue* aNewValue)
 {
 }
 
+void nsMenuGroupOwnerX::NativeAnonymousNodeChanged(nsIDocument* aDocument,
+                                                   dom::Element* aElement,
+                                                   bool isRemove)
+{
+}
 
 void nsMenuGroupOwnerX::AttributeChanged(nsIDocument* aDocument,
                                          dom::Element* aElement,
                                          int32_t aNameSpaceID,
                                          nsIAtom* aAttribute,
                                          int32_t aModType,
                                          const nsAttrValue* aOldValue)
 {
