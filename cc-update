# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  bebc3593045d21d79739b846722c80498ae656b3
Bug 1207542 - The Control Center panel remains in focus after the user navigates to a previous page

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -6968,16 +6968,17 @@ var gIdentityHandler = {
    *
    * @param state
    *        Bitmask provided by nsIWebProgressListener.onSecurityChange.
    * @param uri
    *        nsIURI for which the identity UI should be displayed, already
    *        processed by nsIURIFixup.createExposableURI.
    */
   updateIdentity(state, uri) {
+    let uriChanged = false; //this._uri && (this._uri.spec != uri.spec);
     this._state = state;
     this._uri = uri;
 
     // Firstly, populate the state properties required to display the UI. See
     // the documentation of the individual properties for details.
 
     try {
       this._uri.host;
@@ -6994,16 +6995,21 @@ var gIdentityHandler = {
                               .SSLStatus;
     if (this._sslStatus) {
       this._sslStatus.QueryInterface(Ci.nsISSLStatus);
     }
 
     // Then, update the user interface with the available data.
     this.refreshIdentityBlock();
 
+    // If the location has changed, then hide the control center.
+    if (uriChanged) {
+      this._identityPopup.hidden = true;
+    }
+
     // NOTE: We do NOT update the identity popup (the control center) when
     // we receive a new security state. If the user opened the popup and looks
     // at the provided information we don't want to suddenly change the panel
     // contents.
   },
 
   /**
    * This is called asynchronously when requested by the Logins module, after
diff --git a/browser/base/content/test/general/browser.ini b/browser/base/content/test/general/browser.ini
--- a/browser/base/content/test/general/browser.ini
+++ b/browser/base/content/test/general/browser.ini
@@ -318,16 +318,17 @@ support-files = fxa_profile_handler.sjs
 [browser_fxa_web_channel.js]
 [browser_gestureSupport.js]
 skip-if = e10s # Bug 863514 - no gesture support.
 [browser_getshortcutoruri.js]
 [browser_hide_removing.js]
 [browser_homeDrop.js]
 skip-if = buildapp == 'mulet'
 [browser_identity_UI.js]
+[browser_identity_UI_visibility.js]
 [browser_insecureLoginForms.js]
 [browser_keywordBookmarklets.js]
 skip-if = e10s # Bug 1102025 - different principals for the bookmarklet only in e10s mode (unclear if test or 'real' issue)
 [browser_keywordSearch.js]
 [browser_keywordSearch_postData.js]
 [browser_lastAccessedTab.js]
 skip-if = toolkit == "windows" # Disabled on Windows due to frequent failures (bug 969405)
 [browser_locationBarCommand.js]
diff --git a/browser/base/content/test/general/browser_identity_UI.js b/browser/base/content/test/general/browser_identity_UI.js
--- a/browser/base/content/test/general/browser_identity_UI.js
+++ b/browser/base/content/test/general/browser_identity_UI.js
@@ -1,19 +1,20 @@
 /* Tests for correct behaviour of getEffectiveHost on identity handler */
 function test() {
   waitForExplicitFinish();
   requestLongerTimeout(2);
 
   ok(gIdentityHandler, "gIdentityHandler should exist");
 
-  gBrowser.selectedTab = gBrowser.addTab();
-  gBrowser.selectedBrowser.addEventListener("load", checkResult, true);
-
-  nextTest();
+  // gBrowser.selectedTab = gBrowser.addTab();
+  BrowserTestUtils.openNewForegroundTab(gBrowser, "http://example.com/").then(() => {
+    gBrowser.selectedBrowser.addEventListener("load", checkResult, true);
+    nextTest();
+  })
 }
 
 // Greek IDN for 'example.test'.
 var idnDomain = "\u03C0\u03B1\u03C1\u03AC\u03B4\u03B5\u03B9\u03B3\u03BC\u03B1.\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE";
 var tests = [
   {
     name: "normal domain",
     location: "http://test1.example.org/",
@@ -54,28 +55,29 @@ var tests = [
   },
   {
     name: "IP address",
     location: "http://127.0.0.1:8888/",
     effectiveHost: "127.0.0.1"
   },
 ]
 
-var gCurrentTest, gCurrentTestIndex = -1, gTestDesc;
+var gCurrentTest, gCurrentTestIndex = -1, gTestDesc, gPopupHidden;
 // Go through the tests in both directions, to add additional coverage for
 // transitions between different states.
 var gForward = true;
 var gCheckETLD = false;
 function nextTest() {
   if (!gCheckETLD) {
     if (gForward)
       gCurrentTestIndex++;
     else
       gCurrentTestIndex--;
 
+  console.log(gCheckETLD, gForward, gCurrentTestIndex, tests.length);
     if (gCurrentTestIndex == tests.length) {
       // Went too far, reverse
       gCurrentTestIndex--;
       gForward = false;
     }
 
     if (gCurrentTestIndex == -1) {
       gBrowser.selectedBrowser.removeEventListener("load", checkResult, true);
@@ -86,17 +88,25 @@ function nextTest() {
 
     gCurrentTest = tests[gCurrentTestIndex];
     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + ")";
     if (!gForward)
       gTestDesc += " (second time)";
     if (gCurrentTest.isHTTPS) {
       gCheckETLD = true;
     }
-    content.location = gCurrentTest.location;
+    // Show the identity popup
+    var popupShown = promisePopupShown(gIdentityHandler._identityPopup);
+    gPopupHidden = promisePopupHidden(gIdentityHandler._identityPopup);
+    gIdentityHandler._identityBox.click();
+    info("Waiting for popup shown")
+    popupShown.then(() => {
+      is_element_visible(gIdentityHandler._identityPopup, "control center is visible");
+      content.location = gCurrentTest.location;
+    });
   } else {
     gCheckETLD = false;
     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + " without eTLD in identity icon label)";
     if (!gForward)
       gTestDesc += " (second time)";
     content.location.reload(true);
   }
 }
@@ -108,10 +118,22 @@ function checkResult() {
   if (gCurrentTest.effectiveHost === null) {
     let identityBox = document.getElementById("identity-box");
     ok(identityBox.className == "unknownIdentity" ||
        identityBox.className == "chromeUI", "mode matched");
   } else {
     is(gIdentityHandler.getEffectiveHost(), gCurrentTest.effectiveHost, "effectiveHost matches for test " + gTestDesc);
   }
 
-  executeSoon(nextTest);
+  if (gPopupHidden) {
+    gPopupHidden.then(() => {
+      gPopupHidden = null;
+      is_element_hidden(gIdentityHandler._identityPopup, "control center is hidden");
+      executeSoon(nextTest);
+    });
+  } else {
+    executeSoon(nextTest);
+
+  }
+  // if (!is_hidden(gIdentityHandler._identityPopup)) {
+
+  // } else {
 }
diff --git a/browser/base/content/test/general/browser_identity_UI_visibility.js b/browser/base/content/test/general/browser_identity_UI_visibility.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser_identity_UI_visibility.js
@@ -0,0 +1,180 @@
+/* Tests for correct behaviour of getEffectiveHost on identity handler */
+
+add_task(function*() {
+  yield BrowserTestUtils.openNewForegroundTab(gBrowser, "http://example.com/");
+  yield BrowserTestUtils.loadURI(gBrowser.selectedBrowser, "http://test1.example.org/");
+
+  let popupShown = promisePopupShown(gIdentityHandler._identityPopup);
+  let popupHidden = promisePopupHidden(gIdentityHandler._identityPopup);
+  gIdentityHandler._identityBox.click();
+
+  info("Waiting for popup shown")
+  yield popupShown;
+  is_element_visible(gIdentityHandler._identityPopup, "control center is visible");
+
+  gIdentityHandler._identityPopup.focus();
+  setTimeout(() => {
+  gBrowser.goBack();
+
+  }, 1000)
+  // EventUtils.synthesizeKey("VK_BACK_SPACE", {});
+  yield popupHidden;
+
+  yield new Promise(() => {});
+});
+
+
+// function test() {
+//   waitForExplicitFinish();
+//   requestLongerTimeout(2);
+
+//   ok(gIdentityHandler, "gIdentityHandler should exist");
+
+//   // gBrowser.selectedTab = gBrowser.addTab();
+//   BrowserTestUtils.openNewForegroundTab(gBrowser, "http://example.com/").then(() => {
+
+
+//     var popupShown = promisePopupShown(gIdentityHandler._identityPopup);
+//     gPopupHidden = promisePopupHidden(gIdentityHandler._identityPopup);
+//     gIdentityHandler._identityBox.click();
+//     info("Waiting for popup shown")
+//     popupShown.then(() => {
+//       is_element_visible(gIdentityHandler._identityPopup, "control center is visible");
+//       content.location = gCurrentTest.location;
+
+//       gBrowser.goBack()
+
+//       yield BrowserTestUtils.loadURI(gBrowser.selectedBrowser)
+//     });
+
+
+//     gBrowser.selectedBrowser.addEventListener("load", checkResult, true);
+//     nextTest();
+//   })
+// }
+
+// // Greek IDN for 'example.test'.
+// var idnDomain = "\u03C0\u03B1\u03C1\u03AC\u03B4\u03B5\u03B9\u03B3\u03BC\u03B1.\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE";
+// var tests = [
+//   {
+//     name: "normal domain",
+//     location: "http://test1.example.org/",
+//     effectiveHost: "test1.example.org"
+//   },
+//   {
+//     name: "view-source",
+//     location: "view-source:http://example.com/",
+//     effectiveHost: null
+//   },
+//   {
+//     name: "normal HTTPS",
+//     location: "https://example.com/",
+//     effectiveHost: "example.com",
+//     isHTTPS: true
+//   },
+//   {
+//     name: "IDN subdomain",
+//     location: "http://sub1." + idnDomain + "/",
+//     effectiveHost: "sub1." + idnDomain
+//   },
+//   {
+//     name: "subdomain with port",
+//     location: "http://sub1.test1.example.org:8000/",
+//     effectiveHost: "sub1.test1.example.org"
+//   },
+//   {
+//     name: "subdomain HTTPS",
+//     location: "https://test1.example.com/",
+//     effectiveHost: "test1.example.com",
+//     isHTTPS: true
+//   },
+//   {
+//     name: "view-source HTTPS",
+//     location: "view-source:https://example.com/",
+//     effectiveHost: null,
+//     isHTTPS: true
+//   },
+//   {
+//     name: "IP address",
+//     location: "http://127.0.0.1:8888/",
+//     effectiveHost: "127.0.0.1"
+//   },
+// ]
+
+// var gCurrentTest, gCurrentTestIndex = -1, gTestDesc, gPopupHidden;
+// // Go through the tests in both directions, to add additional coverage for
+// // transitions between different states.
+// var gForward = true;
+// var gCheckETLD = false;
+// function nextTest() {
+//   if (!gCheckETLD) {
+//     if (gForward)
+//       gCurrentTestIndex++;
+//     else
+//       gCurrentTestIndex--;
+
+//   console.log(gCheckETLD, gForward, gCurrentTestIndex, tests.length);
+//     if (gCurrentTestIndex == tests.length) {
+//       // Went too far, reverse
+//       gCurrentTestIndex--;
+//       gForward = false;
+//     }
+
+//     if (gCurrentTestIndex == -1) {
+//       gBrowser.selectedBrowser.removeEventListener("load", checkResult, true);
+//       gBrowser.removeCurrentTab();
+//       finish();
+//       return;
+//     }
+
+//     gCurrentTest = tests[gCurrentTestIndex];
+//     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + ")";
+//     if (!gForward)
+//       gTestDesc += " (second time)";
+//     if (gCurrentTest.isHTTPS) {
+//       gCheckETLD = true;
+//     }
+//     // Show the identity popup
+//     var popupShown = promisePopupShown(gIdentityHandler._identityPopup);
+//     gPopupHidden = promisePopupHidden(gIdentityHandler._identityPopup);
+//     gIdentityHandler._identityBox.click();
+//     info("Waiting for popup shown")
+//     popupShown.then(() => {
+//       is_element_visible(gIdentityHandler._identityPopup, "control center is visible");
+//       content.location = gCurrentTest.location;
+//     });
+//   } else {
+//     gCheckETLD = false;
+//     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + " without eTLD in identity icon label)";
+//     if (!gForward)
+//       gTestDesc += " (second time)";
+//     content.location.reload(true);
+//   }
+// }
+
+// function checkResult() {
+//   // Sanity check other values, and the value of gIdentityHandler.getEffectiveHost()
+//   is(gIdentityHandler._uri.spec, gCurrentTest.location, "location matches for test " + gTestDesc);
+//   // getEffectiveHost can't be called for all modes
+//   if (gCurrentTest.effectiveHost === null) {
+//     let identityBox = document.getElementById("identity-box");
+//     ok(identityBox.className == "unknownIdentity" ||
+//        identityBox.className == "chromeUI", "mode matched");
+//   } else {
+//     is(gIdentityHandler.getEffectiveHost(), gCurrentTest.effectiveHost, "effectiveHost matches for test " + gTestDesc);
+//   }
+
+//   if (gPopupHidden) {
+//     gPopupHidden.then(() => {
+//       gPopupHidden = null;
+//       is_element_hidden(gIdentityHandler._identityPopup, "control center is hidden");
+//       executeSoon(nextTest);
+//     });
+//   } else {
+//     executeSoon(nextTest);
+    
+//   }
+//   // if (!is_hidden(gIdentityHandler._identityPopup)) {
+
+//   // } else {
+// }
