# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e0a91b61e9c27928f4fa277fb748b614152ffe96
Bug 1207542 - The Control Center panel remains in focus after the user navigates to a previous page

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -6968,16 +6968,17 @@ var gIdentityHandler = {
    *
    * @param state
    *        Bitmask provided by nsIWebProgressListener.onSecurityChange.
    * @param uri
    *        nsIURI for which the identity UI should be displayed, already
    *        processed by nsIURIFixup.createExposableURI.
    */
   updateIdentity(state, uri) {
+    let uriChanged = uri != this._uri;
     this._state = state;
     this._uri = uri;
 
     // Firstly, populate the state properties required to display the UI. See
     // the documentation of the individual properties for details.
 
     try {
       this._uri.host;
@@ -6994,16 +6995,21 @@ var gIdentityHandler = {
                               .SSLStatus;
     if (this._sslStatus) {
       this._sslStatus.QueryInterface(Ci.nsISSLStatus);
     }
 
     // Then, update the user interface with the available data.
     this.refreshIdentityBlock();
 
+    // If the location has changed, then hide the control center.
+    if (uriChanged) {
+      this._identityPopup.hidden = true;
+    }
+
     // NOTE: We do NOT update the identity popup (the control center) when
     // we receive a new security state. If the user opened the popup and looks
     // at the provided information we don't want to suddenly change the panel
     // contents.
   },
 
   /**
    * This is called asynchronously when requested by the Logins module, after
diff --git a/browser/base/content/test/general/browser_identity_UI.js b/browser/base/content/test/general/browser_identity_UI.js
--- a/browser/base/content/test/general/browser_identity_UI.js
+++ b/browser/base/content/test/general/browser_identity_UI.js
@@ -86,16 +86,19 @@ function nextTest() {
 
     gCurrentTest = tests[gCurrentTestIndex];
     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + ")";
     if (!gForward)
       gTestDesc += " (second time)";
     if (gCurrentTest.isHTTPS) {
       gCheckETLD = true;
     }
+    // Show the identity popup
+    gIdentityHandler._identityBox.click();
+    ok(!gIdentityHandler._identityPopup.hidden, "control center is visible");
     content.location = gCurrentTest.location;
   } else {
     gCheckETLD = false;
     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + " without eTLD in identity icon label)";
     if (!gForward)
       gTestDesc += " (second time)";
     content.location.reload(true);
   }
@@ -108,10 +111,11 @@ function checkResult() {
   if (gCurrentTest.effectiveHost === null) {
     let identityBox = document.getElementById("identity-box");
     ok(identityBox.className == "unknownIdentity" ||
        identityBox.className == "chromeUI", "mode matched");
   } else {
     is(gIdentityHandler.getEffectiveHost(), gCurrentTest.effectiveHost, "effectiveHost matches for test " + gTestDesc);
   }
 
+  ok(gIdentityHandler._identityPopup.hidden, "control center is hidden");
   executeSoon(nextTest);
 }
