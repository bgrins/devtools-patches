# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2a19b0f25a1350d8d8cf252d443a6ce3b661e0bb
Bug 1207542 - The Control Center panel remains in focus after the user navigates to a previous page

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -7006,16 +7006,17 @@ var gIdentityHandler = {
    *
    * @param state
    *        Bitmask provided by nsIWebProgressListener.onSecurityChange.
    * @param uri
    *        nsIURI for which the identity UI should be displayed, already
    *        processed by nsIURIFixup.createExposableURI.
    */
   updateIdentity(state, uri) {
+    let uriChanged = this._uri && (this._uri.spec != uri.spec);
     this._state = state;
     this._uri = uri;
 
     // Firstly, populate the state properties required to display the UI. See
     // the documentation of the individual properties for details.
 
     try {
       this._uri.host;
@@ -7030,20 +7031,23 @@ var gIdentityHandler = {
     this._sslStatus = gBrowser.securityUI
                               .QueryInterface(Ci.nsISSLStatusProvider)
                               .SSLStatus;
     if (this._sslStatus) {
       this._sslStatus.QueryInterface(Ci.nsISSLStatus);
     }
 
     // Then, update the user interface with the available data.
-
     if (this._identityBox) {
       this.refreshIdentityBlock();
     }
+    if (uriChanged) {
+      this._identityPopup.hidePopup();
+      this._identityPopup.hidden = true;
+    }
 
     // NOTE: We do NOT update the identity popup (the control center) when
     // we receive a new security state. If the user opened the popup and looks
     // at the provided information we don't want to suddenly change the panel
     // contents.
   },
 
   /**
diff --git a/browser/base/content/test/general/browser_identity_UI.js b/browser/base/content/test/general/browser_identity_UI.js
--- a/browser/base/content/test/general/browser_identity_UI.js
+++ b/browser/base/content/test/general/browser_identity_UI.js
@@ -1,19 +1,20 @@
 /* Tests for correct behaviour of getEffectiveHost on identity handler */
 function test() {
   waitForExplicitFinish();
   requestLongerTimeout(2);
 
   ok(gIdentityHandler, "gIdentityHandler should exist");
 
-  gBrowser.selectedTab = gBrowser.addTab();
-  gBrowser.selectedBrowser.addEventListener("load", checkResult, true);
-
-  nextTest();
+  // gBrowser.selectedTab = gBrowser.addTab();
+  BrowserTestUtils.openNewForegroundTab(gBrowser, "http://example.com/").then(() => {
+    gBrowser.selectedBrowser.addEventListener("load", checkResult, true);
+    nextTest();
+  })
 }
 
 // Greek IDN for 'example.test'.
 var idnDomain = "\u03C0\u03B1\u03C1\u03AC\u03B4\u03B5\u03B9\u03B3\u03BC\u03B1.\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE";
 var tests = [
   {
     name: "normal domain",
     location: "http://test1.example.org/",
@@ -54,29 +55,30 @@ var tests = [
   },
   {
     name: "IP address",
     location: "http://127.0.0.1:8888/",
     effectiveHost: "127.0.0.1"
   },
 ]
 
-var gCurrentTest, gCurrentTestIndex = -1, gTestDesc;
+var gCurrentTest, gCurrentTestIndex = -1, gTestDesc, gPopupHidden;
 // Go through the tests in both directions, to add additional coverage for
 // transitions between different states.
 var gForward = true;
 var gCheckETLD = false;
 function nextTest() {
   if (!gCheckETLD) {
     if (gForward)
       gCurrentTestIndex++;
     else
       gCurrentTestIndex--;
 
-    if (gCurrentTestIndex == tests.length) {
+    let atLastTest = gCurrentTestIndex == tests.length;
+    if (atLastTest) {
       // Went too far, reverse
       gCurrentTestIndex--;
       gForward = false;
     }
 
     if (gCurrentTestIndex == -1) {
       gBrowser.selectedBrowser.removeEventListener("load", checkResult, true);
       gBrowser.removeCurrentTab();
@@ -86,17 +88,33 @@ function nextTest() {
 
     gCurrentTest = tests[gCurrentTestIndex];
     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + ")";
     if (!gForward)
       gTestDesc += " (second time)";
     if (gCurrentTest.isHTTPS) {
       gCheckETLD = true;
     }
-    content.location = gCurrentTest.location;
+
+    // If this is the last test, then the URL won't change so don't bother opening
+    // the Control Center and making sure it closes.
+    if (atLastTest) {
+      BrowserTestUtils.loadURI(gBrowser.selectedBrowser, gCurrentTest.location);
+    } else {
+      var popupShown = promisePopupShown(gIdentityHandler._identityPopup);
+      gPopupHidden = promisePopupHidden(gIdentityHandler._identityPopup);
+      gIdentityHandler._identityBox.click();
+      info("Waiting for the Control Center to be shown");
+      popupShown.then(() => {
+        is_element_visible(gIdentityHandler._identityPopup, "Control Center is visible");
+        // Show the subview and make sure it closes when the URL changes (Bug 1207542).
+        gBrowser.ownerDocument.querySelector("#identity-popup-security-expander").click();
+        BrowserTestUtils.loadURI(gBrowser.selectedBrowser, gCurrentTest.location);
+      });
+    }
   } else {
     gCheckETLD = false;
     gTestDesc = "#" + gCurrentTestIndex + " (" + gCurrentTest.name + " without eTLD in identity icon label)";
     if (!gForward)
       gTestDesc += " (second time)";
     content.location.reload(true);
   }
 }
@@ -108,10 +126,19 @@ function checkResult() {
   if (gCurrentTest.effectiveHost === null) {
     let identityBox = document.getElementById("identity-box");
     ok(identityBox.className == "unknownIdentity" ||
        identityBox.className == "chromeUI", "mode matched");
   } else {
     is(gIdentityHandler.getEffectiveHost(), gCurrentTest.effectiveHost, "effectiveHost matches for test " + gTestDesc);
   }
 
-  executeSoon(nextTest);
+  if (gPopupHidden) {
+    info("Waiting for the Control Center to hide");
+    gPopupHidden.then(() => {
+      gPopupHidden = null;
+      is_element_hidden(gIdentityHandler._identityPopup, "control center is hidden");
+      executeSoon(nextTest);
+    });
+  } else {
+    executeSoon(nextTest);
+  }
 }
