# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1541186835 25200
#      Fri Nov 02 12:27:15 2018 -0700
# Node ID 0086b923098f4cdd8462413b56bcd9e7ac7c18ce
# Parent  a6493a0b53a3d8df5c23b1300591f1f7ebc573e4
Bug 1503342 - Rename richlistbox.children to richlistbox.itemChildren so .children will refer to the normal DOM API;r=paolo

In Bug 1479125 we put calls to .children that were intended to access child elements into the custom
method, which is a slower path. We may eventually want to remove itemChildren altogether and just assume
that all children are items, but that's out of scope for a perf fix like this.

Differential Revision: https://phabricator.services.mozilla.com/D10751

diff --git a/browser/base/content/test/urlbar/browser_urlbar_remove_match.js b/browser/base/content/test/urlbar/browser_urlbar_remove_match.js
--- a/browser/base/content/test/urlbar/browser_urlbar_remove_match.js
+++ b/browser/base/content/test/urlbar/browser_urlbar_remove_match.js
@@ -18,14 +18,14 @@ add_task(async function test_remove_hist
   Assert.equal(result.getAttribute("ac-value"), TEST_URL, "Found the expected result");
 
   EventUtils.synthesizeKey("KEY_ArrowDown");
   Assert.equal(gURLBar.popup.richlistbox.selectedIndex, 1);
   let options = AppConstants.platform == "macosx" ? { shiftKey: true } : {};
   EventUtils.synthesizeKey("KEY_Delete", options);
   await promiseVisitRemoved;
   await BrowserTestUtils.waitForCondition(
-    () => !gURLBar.popup.richlistbox.children.some(c => !c.collapsed && c.getAttribute("ac-value") == TEST_URL),
+    () => !gURLBar.popup.richlistbox.itemChildren.some(c => !c.collapsed && c.getAttribute("ac-value") == TEST_URL),
     "Waiting for the result to disappear");
 
   gURLBar.popup.hidePopup();
   await promisePopupHidden(gURLBar.popup);
 });
diff --git a/browser/base/content/test/webextensions/browser_extension_sideloading.js b/browser/base/content/test/webextensions/browser_extension_sideloading.js
--- a/browser/base/content/test/webextensions/browser_extension_sideloading.js
+++ b/browser/base/content/test/webextensions/browser_extension_sideloading.js
@@ -207,17 +207,17 @@ add_task(async function() {
 
   win = await BrowserOpenAddonsMgr(VIEW);
 
   let list = win.document.getElementById("addon-list");
 
   // Make sure XBL bindings are applied
   list.clientHeight;
 
-  let item = list.children.find(_item => _item.value == ID3);
+  let item = list.itemChildren.find(_item => _item.value == ID3);
   ok(item, "Found entry for sideloaded extension in about:addons");
   item.scrollIntoView({behavior: "instant"});
 
   ok(BrowserTestUtils.is_visible(item._enableBtn), "Enable button is visible for sideloaded extension");
   ok(BrowserTestUtils.is_hidden(item._disableBtn), "Disable button is not visible for sideloaded extension");
 
   // When clicking enable we should see the permissions notification
   popupPromise = promisePopupNotificationShown("addon-webext-permissions");
diff --git a/browser/base/content/test/webextensions/head.js b/browser/base/content/test/webextensions/head.js
--- a/browser/base/content/test/webextensions/head.js
+++ b/browser/base/content/test/webextensions/head.js
@@ -418,17 +418,17 @@ async function interactiveUpdateTest(aut
     if (manualUpdatePromise) {
       await manualUpdatePromise;
 
       let list = win.document.getElementById("addon-list");
 
       // Make sure we have XBL bindings
       list.clientHeight;
 
-      let item = list.children.find(_item => _item.value == ID);
+      let item = list.itemChildren.find(_item => _item.value == ID);
       EventUtils.synthesizeMouseAtCenter(item._updateBtn, {}, win);
     }
 
     return {promise};
   }
 
   // Navigate away from the starting page to force about:addons to load
   // in a new tab during the tests below.
diff --git a/browser/components/preferences/in-content/tests/browser_change_app_handler.js b/browser/components/preferences/in-content/tests/browser_change_app_handler.js
--- a/browser/components/preferences/in-content/tests/browser_change_app_handler.js
+++ b/browser/components/preferences/in-content/tests/browser_change_app_handler.js
@@ -65,20 +65,20 @@ add_task(async function() {
 
   dialog = await dialogLoadedPromise;
   info("Dialog loaded the second time");
 
   dialogDoc = dialog.document;
   dialogList = dialogDoc.getElementById("appList");
   let itemToRemove = dialogList.querySelector('richlistitem > label[value="' + selectedApp.name + '"]').parentNode;
   dialogList.selectItem(itemToRemove);
-  let itemsBefore = dialogList.children.length;
+  let itemsBefore = dialogList.itemChildren.length;
   dialogDoc.getElementById("remove").click();
   ok(!itemToRemove.parentNode, "Item got removed from DOM");
-  is(dialogList.children.length, itemsBefore - 1, "Item got removed");
+  is(dialogList.itemChildren.length, itemsBefore - 1, "Item got removed");
   dialogDoc.documentElement.acceptDialog();
 
   // Verify results are correct in mime service:
   mimeInfo = gMimeSvc.getFromTypeAndExtension("text/x-test-handler", null);
   ok(!mimeInfo.preferredApplicationHandler, "App should no longer be set as preferred.");
 
   // Check that we display this result:
   ok(list.selectedItem, "Should have a selected item");
diff --git a/browser/components/preferences/in-content/tests/browser_permissions_dialog.js b/browser/components/preferences/in-content/tests/browser_permissions_dialog.js
--- a/browser/components/preferences/in-content/tests/browser_permissions_dialog.js
+++ b/browser/components/preferences/in-content/tests/browser_permissions_dialog.js
@@ -358,17 +358,17 @@ add_task(async function testTabBehaviour
   let doc = sitePermissionsDialog.document;
 
   EventUtils.synthesizeKey("KEY_Tab", {}, sitePermissionsDialog);
   let richlistbox = doc.getElementById("permissionsBox");
   is(richlistbox, doc.activeElement.closest("#permissionsBox"), "The richlistbox is focused after pressing tab once.");
 
   EventUtils.synthesizeKey("KEY_ArrowDown", {}, sitePermissionsDialog);
   EventUtils.synthesizeKey("KEY_Tab", {}, sitePermissionsDialog);
-  let menulist = doc.getElementById("permissionsBox").children[1].getElementsByTagName("menulist")[0];
+  let menulist = doc.getElementById("permissionsBox").itemChildren[1].getElementsByTagName("menulist")[0];
   is(menulist, doc.activeElement, "The menulist inside the selected richlistitem is focused now");
 
   EventUtils.synthesizeKey("KEY_Tab", {}, sitePermissionsDialog);
   let removeButton = doc.getElementById("removePermission");
   is(removeButton, doc.activeElement, "The focus moves outside the richlistbox and onto the remove button");
 
   SitePermissions.remove(URI, "desktop-notification");
   SitePermissions.remove(u, "desktop-notification");
diff --git a/browser/components/preferences/sitePermissions.js b/browser/components/preferences/sitePermissions.js
--- a/browser/components/preferences/sitePermissions.js
+++ b/browser/components/preferences/sitePermissions.js
@@ -344,17 +344,17 @@ var gSitePermissionsManager = {
     this._setRemoveButtonState();
   },
 
   onPermissionSelect() {
     this._setRemoveButtonState();
 
     // If any item is selected, it should be the only item tabable
     // in the richlistbox for accessibility reasons.
-    this._list.children.forEach((item) => {
+    this._list.itemChildren.forEach((item) => {
       let menulist = item.getElementsByTagName("menulist")[0];
       if (!item.selected) {
         menulist.setAttribute("tabindex", -1);
       } else {
         menulist.removeAttribute("tabindex");
       }
     });
   },
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -188,41 +188,41 @@
             this.selectItem(kids[0]);
           return val;
         ]]>
         </setter>
       </property>
 
       <!-- nsIDOMXULSelectControlElement -->
       <property name="itemCount" readonly="true"
-                onget="return this.children.length"/>
+                onget="return this.itemChildren.length"/>
 
       <!-- nsIDOMXULSelectControlElement -->
       <method name="getIndexOfItem">
         <parameter name="aItem"/>
         <body>
           <![CDATA[
             // don't search the children, if we're looking for none of them
             if (aItem == null)
               return -1;
             if (this._selecting && this._selecting.item == aItem)
               return this._selecting.index;
-            return this.children.indexOf(aItem);
+            return this.itemChildren.indexOf(aItem);
           ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULSelectControlElement -->
       <method name="getItemAtIndex">
         <parameter name="aIndex"/>
         <body>
           <![CDATA[
             if (this._selecting && this._selecting.index == aIndex)
               return this._selecting.item;
-            return this.children[aIndex] || null;
+            return this.itemChildren[aIndex] || null;
           ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULMultiSelectControlElement -->
       <property name="selType"
                 onget="return this.getAttribute('seltype');"
                 onset="this.setAttribute('seltype', val); return val;"/>
@@ -510,40 +510,40 @@
               this._scrollbox.scrollToElement(item);
           ]]>
         </body>
       </method>
 
       <method name="getIndexOfFirstVisibleRow">
         <body>
           <![CDATA[
-            var children = this.children;
+            var children = this.itemChildren;
 
             for (var ix = 0; ix < children.length; ix++)
               if (this._isItemVisible(children[ix]))
                 return ix;
 
             return -1;
           ]]>
         </body>
       </method>
 
       <method name="getRowCount">
         <body>
           <![CDATA[
-            return this.children.length;
+            return this.itemChildren.length;
           ]]>
         </body>
       </method>
 
       <method name="scrollOnePage">
         <parameter name="aDirection"/> <!-- Must be -1 or 1 -->
         <body>
           <![CDATA[
-            var children = this.children;
+            var children = this.itemChildren;
 
             if (children.length == 0)
               return 0;
 
             // If nothing is selected, we just select the first element
             // at the extreme we're moving away from
             if (!this.currentItem)
               return aDirection == -1 ? children.length : 0;
@@ -573,22 +573,22 @@
               index = ix;
             }
 
             return index != this.currentIndex ? index - this.currentIndex : aDirection;
           ]]>
         </body>
       </method>
 
-      <property name="children" readonly="true">
+      <property name="itemChildren" readonly="true">
         <getter>
           <![CDATA[
             let iface = Ci.nsIDOMXULSelectControlItemElement;
-            let children = Array.from(this.childNodes)
-                                .filter(node => node.nodeType == 1 && node instanceof iface);
+            let children = Array.from(this.children)
+                                .filter(node => node instanceof iface);
             if (this.dir == "reverse" && this._mayReverse) {
               children.reverse();
             }
             return children;
           ]]>
         </getter>
       </property>
 
@@ -662,17 +662,17 @@
 
             // if we have no previously current item or if the above check fails to
             // find the previous nodes (which causes it to clear selection)
             if (!this.currentItem && this.selectedCount == 0) {
               this.currentIndex = this._currentIndex ? this._currentIndex - 1 : 0;
 
               // cf. listbox constructor:
               // select items according to their attributes
-              var children = this.children;
+              var children = this.itemChildren;
               for (let i = 0; i < children.length; ++i) {
                 if (children[i].getAttribute("selected") == "true")
                   this.selectedItems.append(children[i]);
               }
             }
 
             if (this.selType != "multiple" && this.selectedCount == 0)
               this.selectedItem = this.currentItem;
