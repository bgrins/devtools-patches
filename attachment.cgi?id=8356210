# HG changeset patch
# Parent f78ec00f29f5ff6d509f71942c6941bcf64e2706
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 922146 - Adds stylesheet added/removed events to actor and updates inspector panels, r=bgrins

diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -21,16 +21,18 @@ FontInspector.prototype = {
     this.update = this.update.bind(this);
     this.onNewNode = this.onNewNode.bind(this);
     this.onHighlighterLocked = this.onHighlighterLocked.bind(this);
     this.inspector.selection.on("new-node", this.onNewNode);
     this.inspector.sidebar.on("fontinspector-selected", this.onNewNode);
     if (this.inspector.highlighter) {
       this.inspector.highlighter.on("locked", this.onHighlighterLocked);
     }
+    this.inspector.pageStyle.on("stylesheet-added", this.update);
+    this.inspector.pageStyle.on("stylesheet-removed", this.update);
     this.update();
   },
 
   /**
    * Is the fontinspector visible in the sidebar?
    */
   isActive: function FI_isActive() {
     return this.inspector.sidebar &&
@@ -42,16 +44,20 @@ FontInspector.prototype = {
    */
   destroy: function FI_destroy() {
     this.chromeDoc = null;
     this.inspector.sidebar.off("layoutview-selected", this.onNewNode);
     this.inspector.selection.off("new-node", this.onNewNode);
     if (this.inspector.highlighter) {
       this.inspector.highlighter.off("locked", this.onHighlighterLocked);
     }
+    if (this.inspector.pageStyle) {
+      this.inspector.pageStyle.off("stylesheet-added", this.update);
+      this.inspector.pageStyle.off("stylesheet-removed", this.update);
+    }
   },
 
   /**
    * Selection 'new-node' event handler.
    */
   onNewNode: function FI_onNewNode() {
     if (this.isActive() &&
         this.inspector.selection.isLocal() &&
@@ -113,16 +119,18 @@ FontInspector.prototype = {
     }
     fontsArray = fontsArray.sort(function(a, b) {
       return a.srcIndex < b.srcIndex;
     });
     this.chromeDoc.querySelector("#all-fonts").innerHTML = "";
     for (let f of fontsArray) {
       this.render(f, contentDocument);
     }
+
+    this.inspector.emit("font-inspector-updated");
   },
 
   /**
    * Display the information of one font.
    */
   render: function FI_render(font, document) {
     let s = this.chromeDoc.querySelector("#template > section");
     s = s.cloneNode(true);
diff --git a/browser/devtools/fontinspector/test/browser.ini b/browser/devtools/fontinspector/test/browser.ini
--- a/browser/devtools/fontinspector/test/browser.ini
+++ b/browser/devtools/fontinspector/test/browser.ini
@@ -1,6 +1,8 @@
 [DEFAULT]
 support-files =
+  head.js
   browser_font.woff
   browser_fontinspector.html
 
 [browser_fontinspector.js]
+[browser_bug922146_refresh_on_stylesheet_change.js]
diff --git a/browser/devtools/fontinspector/test/browser_bug922146_refresh_on_stylesheet_change.js b/browser/devtools/fontinspector/test/browser_bug922146_refresh_on_stylesheet_change.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/fontinspector/test/browser_bug922146_refresh_on_stylesheet_change.js
@@ -0,0 +1,88 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+let doc;
+let inspector;
+
+const DOCUMENT_URL = "data:text/html," + encodeURIComponent([
+  '<!DOCTYPE html>',
+  '<html>',
+  '<head>',
+  '  <meta charset=utf-8 />',
+  '  <title>Current element\'s font inspector should be refreshed when stylesheets are added, removed or changed</title>',
+  '</head>',
+  '<body>',
+  '  <p>Some text</p>',
+  '</body>',
+  '</html>'
+].join("\n"));
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, arguments.callee,
+      true);
+    doc = content.document;
+    waitForFocus(testFontInspector, content);
+  }, true);
+
+  content.location = DOCUMENT_URL;
+}
+
+function endTests() {
+  doc = inspector = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function testFontInspector() {
+  info("Testing the font inspector");
+  openFontInspector(aInspector => {
+    inspector = aInspector;
+    inspector.selection.setNode(doc.querySelector("p"));
+    inspector.once("inspector-updated", () => {
+      changingStyleSheetsShouldUpdateFontView();
+    });
+  });
+}
+
+function changingStyleSheetsShouldUpdateFontView(index=0) {
+  if (index === styleSheetChanges.length) {
+    endTests();
+  } else {
+    styleSheetChanges[index]();
+    inspector.once("font-inspector-updated", () => {
+      ok(true, "The font inspector was refreshed after stylesheet change " + index);
+      // We must wait for the following event too, otherwise we'll be ending the
+      // test and closing the connection before ongoing requests end
+      inspector.once("computed-view-refreshed", () => {
+        changingStyleSheetsShouldUpdateFontView(index + 1);
+      });
+    });
+  }
+}
+
+var styleSheetChanges = [
+  function addStyleSheet() {
+    let sheet = doc.createElement("STYLE");
+    sheet.type = "text/css";
+    sheet.appendChild(doc.createTextNode("p {font:14px Arial;}"));
+    doc.getElementsByTagName("HEAD")[0].appendChild(sheet);
+  },
+  function modifyLastStyleSheet() {
+    let styles = doc.getElementsByTagName("STYLE");
+    if (styles.length) {
+      let sheet = styles[styles.length - 1];
+      sheet.appendChild(doc.createTextNode("p {font:12px Verdana;}"));
+    }
+  },
+  function removeLastStyleSheet() {
+    let styles = doc.getElementsByTagName("STYLE");
+    if (styles.length) {
+      styles[styles.length - 1].remove();
+    }
+  }
+];
diff --git a/browser/devtools/fontinspector/test/browser_fontinspector.js b/browser/devtools/fontinspector/test/browser_fontinspector.js
--- a/browser/devtools/fontinspector/test/browser_fontinspector.js
+++ b/browser/devtools/fontinspector/test/browser_fontinspector.js
@@ -30,33 +30,23 @@ function test() {
     rng.selectNode(doc.body);
     let fonts = DOMUtils.getUsedFontFaces(rng);
     if (fonts.length != 2) {
       // Fonts are not loaded yet.
       // Let try again in a couple of milliseconds (hacky, but
       // there's not better way to do it. See bug 835247).
       setTimeout(setupTest, 500);
     } else {
-      let target = TargetFactory.forTab(gBrowser.selectedTab);
-      gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
-        openFontInspector(toolbox.getCurrentPanel());
+      openFontInspector(aInspector => {
+        inspector = aInspector;
+        viewReady();
       });
     }
   }
 
-  function openFontInspector(aInspector) {
-    inspector = aInspector;
-
-    info("Inspector open");
-
-    inspector.selection.setNode(doc.body);
-    inspector.sidebar.select("fontinspector");
-    inspector.sidebar.once("fontinspector-ready", viewReady);
-  }
-
   function viewReady() {
     info("Font Inspector ready");
 
     view = inspector.sidebar.getWindowForTab("fontinspector");
 
     ok(!!view.fontInspector, "Font inspector document is alive.");
 
     let d = view.document;
diff --git a/browser/devtools/fontinspector/test/head.js b/browser/devtools/fontinspector/test/head.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/fontinspector/test/head.js
@@ -0,0 +1,13 @@
+let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+let TargetFactory = devtools.TargetFactory;
+
+function openFontInspector(cb) {
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
+    let inspector = toolbox.getCurrentPanel();
+    inspector.sidebar.select("fontinspector");
+    inspector.sidebar.once("fontinspector-ready", () => {
+      cb(inspector);
+    });
+  });
+}
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -49,16 +49,18 @@ const LAYOUT_CHANGE_TIMER = 250;
  * - computed-view-refreshed
  *      Fired when the computed rules view updates to a new node
  * - computed-view-property-expanded
  *      Fired when a property is expanded in the computed rules view
  * - computed-view-property-collapsed
  *      Fired when a property is collapsed in the computed rules view
  * - rule-view-refreshed
  *      Fired when the rule view updates to a new node
+ * - font-inspector-updated
+ *      Fired when the font inspector updates to a new node
  */
 function InspectorPanel(iframeWindow, toolbox) {
   this._toolbox = toolbox;
   this._target = toolbox._target;
   this.panelDoc = iframeWindow.document;
   this.panelWin = iframeWindow;
   this.panelWin.inspector = this;
   this._inspector = null;
@@ -409,23 +411,33 @@ InspectorPanel.prototype = {
     // of the selected node so it can be restored after reload of the same page
     if (reason !== "navigateaway" &&
         this.selection.node &&
         this.selection.isElementNode()) {
       this.selectionCssSelector = CssLogic.findCssSelector(this.selection.node);
     }
 
     let selfUpdate = this.updating("inspector-panel");
-    Services.tm.mainThread.dispatch(() => {
-      try {
-        selfUpdate(selection);
-      } catch(ex) {
-        console.error(ex);
-      }
-    }, Ci.nsIThread.DISPATCH_NORMAL);
+
+    // Start watching for stylesheet changes in the new node's document (if any)
+    // so that sidebar panels can update themselves when that happens
+    let styleSheetChangePromise = promise.resolve();
+    if (selection) {
+      styleSheetChangePromise = this.pageStyle.watchStyleSheetChanges(selection);
+    }
+
+    styleSheetChangePromise.then(() => {
+      Services.tm.mainThread.dispatch(() => {
+        try {
+          selfUpdate(selection);
+        } catch(ex) {
+          console.error(ex);
+        }
+      }, Ci.nsIThread.DISPATCH_NORMAL);
+    });
   },
 
   /**
    * Delay the "inspector-updated" notification while a tool
    * is updating itself.  Returns a function that must be
    * invoked when the tool is done updating with the node
    * that the tool is viewing.
    */
diff --git a/browser/devtools/layoutview/test/browser.ini b/browser/devtools/layoutview/test/browser.ini
--- a/browser/devtools/layoutview/test/browser.ini
+++ b/browser/devtools/layoutview/test/browser.ini
@@ -1,4 +1,7 @@
 [DEFAULT]
+support-files =
+  head.js
 
+[browser_bug922146_refresh_on_stylesheet_change.js]
 [browser_layoutview.js]
 skip-if = true
diff --git a/browser/devtools/layoutview/test/browser_bug922146_refresh_on_stylesheet_change.js b/browser/devtools/layoutview/test/browser_bug922146_refresh_on_stylesheet_change.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/layoutview/test/browser_bug922146_refresh_on_stylesheet_change.js
@@ -0,0 +1,84 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+let doc;
+let inspector;
+
+const DOCUMENT_URL = "data:text/html," + encodeURIComponent([
+  '<!DOCTYPE html>',
+  '<html>',
+  '<head>',
+  '  <meta charset=utf-8 />',
+  '  <title>Current element\'s layout should be refreshed when stylesheets are added, removed or changed</title>',
+  '</head>',
+  '<body>',
+  '  <p>Some text</p>',
+  '</body>',
+  '</html>'
+].join("\n"));
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, arguments.callee,
+      true);
+    doc = content.document;
+    waitForFocus(testLayoutView, content);
+  }, true);
+
+  content.location = DOCUMENT_URL;
+}
+
+function endTests() {
+  doc = inspector = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function testLayoutView() {
+  info("Testing the layout view");
+  openLayoutView(aInspector => {
+    inspector = aInspector;
+    inspector.selection.setNode(doc.querySelector("p"));
+    inspector.once("inspector-updated", () => {
+      changingStyleSheetsShouldUpdateLayoutView();
+    });
+  });
+}
+
+function changingStyleSheetsShouldUpdateLayoutView(index=0) {
+  if (index === styleSheetChanges.length) {
+    endTests();
+  } else {
+    styleSheetChanges[index]();
+    inspector.once("layoutview-updated", () => {
+      ok(true, "The layout view was refreshed after stylesheet change " + index);
+      changingStyleSheetsShouldUpdateLayoutView(index + 1);
+    });
+  }
+}
+
+var styleSheetChanges = [
+  function addStyleSheet() {
+    let sheet = doc.createElement("STYLE");
+    sheet.type = "text/css";
+    sheet.appendChild(doc.createTextNode("p {width: 300px;}"));
+    doc.getElementsByTagName("HEAD")[0].appendChild(sheet);
+  },
+  function modifyLastStyleSheet() {
+    let styles = doc.getElementsByTagName("STYLE");
+    if (styles.length) {
+      let sheet = styles[styles.length - 1];
+      sheet.appendChild(doc.createTextNode("p {width: 200px;}"));
+    }
+  },
+  function removeLastStyleSheet() {
+    let styles = doc.getElementsByTagName("STYLE");
+    if (styles.length) {
+      styles[styles.length - 1].remove();
+    }
+  }
+];
diff --git a/browser/devtools/layoutview/test/browser_layoutview.js b/browser/devtools/layoutview/test/browser_layoutview.js
--- a/browser/devtools/layoutview/test/browser_layoutview.js
+++ b/browser/devtools/layoutview/test/browser_layoutview.js
@@ -59,35 +59,27 @@ function test() {
   let style = "div { position: absolute; top: 42px; left: 42px; height: 100px; width: 100px; border: 10px solid black; padding: 20px; margin: 30px auto;}";
   let html = "<style>" + style + "</style><div></div>"
   content.location = "data:text/html," + encodeURIComponent(html);
 
   function setupTest() {
     node = doc.querySelector("div");
     ok(node, "node found");
 
-    let target = TargetFactory.forTab(gBrowser.selectedTab);
-    gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
-      openLayoutView(toolbox.getCurrentPanel());
-    });
+    openLayoutView(onLayoutViewOpen);
   }
 
-  function openLayoutView(aInspector) {
-    inspector = aInspector;
-
+  function onLayoutViewOpen(aInspector) {
     info("Inspector open");
 
-    inspector.sidebar.select("layoutview");
-    inspector.sidebar.once("layoutview-ready", () => {
-      inspector.selection.setNode(node);
-      inspector.once("inspector-updated", viewReady);
-    });
+    inspector = aInspector;
+    inspector.selection.setNode(node);
+    inspector.once("inspector-updated", viewReady);
   }
 
-
   function viewReady() {
     info("Layout view ready");
 
     view = inspector.sidebar.getWindowForTab("layoutview");
 
     ok(!!view.layoutview, "LayoutView document is alive.");
 
     test1();
diff --git a/browser/devtools/layoutview/test/head.js b/browser/devtools/layoutview/test/head.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/layoutview/test/head.js
@@ -0,0 +1,13 @@
+let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+let TargetFactory = devtools.TargetFactory;
+
+function openLayoutView(cb) {
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
+    let inspector = toolbox.getCurrentPanel();
+    inspector.sidebar.select("layoutview");
+    inspector.sidebar.once("layoutview-ready", () => {
+      cb(inspector);
+    });
+  });
+}
diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -35,16 +35,18 @@ LayoutView.prototype = {
     this.onNewNode = this.onNewNode.bind(this);
     this.onNewSelection = this.onNewSelection.bind(this);
     this.onHighlighterLocked = this.onHighlighterLocked.bind(this);
     this.inspector.selection.on("new-node-front", this.onNewSelection);
     this.inspector.sidebar.on("layoutview-selected", this.onNewNode);
     if (this.inspector.highlighter) {
       this.inspector.highlighter.on("locked", this.onHighlighterLocked);
     }
+    this.inspector.pageStyle.on("stylesheet-added", this.update);
+    this.inspector.pageStyle.on("stylesheet-removed", this.update);
 
     // Store for the different dimensions of the node.
     // 'selector' refers to the element that holds the value in view.xhtml;
     // 'property' is what we are measuring;
     // 'value' is the computed dimension, computed in update().
     this.map = {
       position: {selector: "#element-position",
                  property: "position",
@@ -104,16 +106,20 @@ LayoutView.prototype = {
     this.inspector.sidebar.off("layoutview-selected", this.onNewNode);
     this.inspector.selection.off("new-node-front", this.onNewSelection);
     if (this.browser) {
       this.browser.removeEventListener("MozAfterPaint", this.update, true);
     }
     if (this.inspector.highlighter) {
       this.inspector.highlighter.off("locked", this.onHighlighterLocked);
     }
+    if (this.inspector.pageStyle) {
+      this.inspector.pageStyle.off("stylesheet-added", this.update);
+      this.inspector.pageStyle.off("stylesheet-removed", this.update);
+    }
     this.sizeHeadingLabel = null;
     this.sizeLabel = null;
     this.inspector = null;
     this.doc = null;
   },
 
   /**
    * Selection 'new-node-front' event handler.
diff --git a/browser/devtools/styleinspector/computed-view.js b/browser/devtools/styleinspector/computed-view.js
--- a/browser/devtools/styleinspector/computed-view.js
+++ b/browser/devtools/styleinspector/computed-view.js
@@ -386,19 +386,16 @@ CssHtmlTree.prototype = {
       // Reset zebra striping.
       this._darkStripe = true;
 
       let deferred = promise.defer();
       this._refreshProcess = new UpdateProcess(this.styleWindow, this.propertyViews, {
         onItem: (aPropView) => {
           aPropView.refresh();
         },
-        onCancel: () => {
-          deferred.reject("refresh cancelled");
-        },
         onDone: () => {
           this._refreshProcess = null;
           this.noResults.hidden = this.numVisibleProperties > 0;
           this.styleInspector.inspector.emit("computed-view-refreshed");
           deferred.resolve(undefined);
         }
       });
       this._refreshProcess.schedule();
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -116,16 +116,17 @@ function createDummyDocument() {
  *
  * @constructor
  */
 function ElementStyle(aElement, aStore, aPageStyle)
 {
   this.element = aElement;
   this.store = aStore || {};
   this.pageStyle = aPageStyle;
+  this.rules = [];
 
   // We don't want to overwrite this.store.userProperties so we only create it
   // if it doesn't already exist.
   if (!("userProperties" in this.store)) {
     this.store.userProperties = new UserProperties();
   }
 
   if (!("disabled" in this.store)) {
@@ -187,18 +188,19 @@ ElementStyle.prototype = {
   {
     let populated = this.pageStyle.getApplied(this.element, {
       inherited: true,
       matchedSelectors: true
     }).then(entries => {
       // Make sure the dummy element has been created before continuing...
       return this.dummyElementPromise.then(() => {
         if (this.populated != populated) {
-          // Don't care anymore.
-          return promise.reject("unused");
+          // The currently selected element was changed before the dummy
+          // element promise completed, no need to go any further
+          return;
         }
 
         // Store the current list of rules (if any) during the population
         // process.  They will be reused if possible.
         this._refreshRules = this.rules;
 
         this.rules = [];
 
@@ -1353,19 +1355,21 @@ CssRuleView.prototype = {
     this._viewedElement = aElement;
     if (!this._viewedElement) {
       this._showEmpty();
       return promise.resolve(undefined);
     }
 
     this._elementStyle = new ElementStyle(aElement, this.store, this.pageStyle);
     return this._populate().then(() => {
-      this._elementStyle.onChanged = () => {
-        this._changed();
-      };
+      if (this._elementStyle) {
+        this._elementStyle.onChanged = () => {
+          this._changed();
+        };
+      }
     }).then(null, console.error);
   },
 
   /**
    * Update the rules for the currently highlighted element.
    */
   nodeChanged: function CssRuleView_nodeChanged()
   {
@@ -1379,25 +1383,25 @@ CssRuleView.prototype = {
     // Repopulate the element style.
     this._populate();
   },
 
   _populate: function() {
     let elementStyle = this._elementStyle;
     return this._elementStyle.populate().then(() => {
       if (this._elementStyle != elementStyle) {
-        return promise.reject("element changed");
+        return;
       }
       this._createEditors();
 
       // Notify anyone that cares that we refreshed.
       var evt = this.doc.createEvent("Events");
       evt.initEvent("CssRuleViewRefreshed", true, false);
       this.element.dispatchEvent(evt);
-      return undefined;
+      return;
     }).then(null, promiseWarn);
   },
 
   /**
    * Show the user that the rule view has no node selected.
    */
   _showEmpty: function CssRuleView_showEmpty()
   {
diff --git a/browser/devtools/styleinspector/style-inspector.js b/browser/devtools/styleinspector/style-inspector.js
--- a/browser/devtools/styleinspector/style-inspector.js
+++ b/browser/devtools/styleinspector/style-inspector.js
@@ -80,16 +80,18 @@ function RuleViewTool(aInspector, aWindo
   this.inspector.selection.on("new-node-front", this._onSelect);
   this.refresh = this.refresh.bind(this);
   this.inspector.on("layout-change", this.refresh);
 
   this.inspector.selection.on("pseudoclass", this.refresh);
   if (this.inspector.highlighter) {
     this.inspector.highlighter.on("locked", this._onSelect);
   }
+  this.inspector.pageStyle.on("stylesheet-added", this.refresh);
+  this.inspector.pageStyle.on("stylesheet-removed", this.refresh);
 
   this.onSelect();
 }
 
 exports.RuleViewTool = RuleViewTool;
 
 RuleViewTool.prototype = {
   onSelect: function RVT_onSelect(aEvent) {
@@ -122,16 +124,20 @@ RuleViewTool.prototype = {
 
   destroy: function RVT_destroy() {
     this.inspector.off("layout-change", this.refresh);
     this.inspector.selection.off("pseudoclass", this.refresh);
     this.inspector.selection.off("new-node-front", this._onSelect);
     if (this.inspector.highlighter) {
       this.inspector.highlighter.off("locked", this._onSelect);
     }
+    if (this.inspector.pageStyle) {
+      this.inspector.pageStyle.off("stylesheet-added", this.refresh);
+      this.inspector.pageStyle.off("stylesheet-removed", this.refresh);
+    }
 
     this.view.element.removeEventListener("CssRuleViewCSSLinkClicked",
       this._cssLinkHandler);
 
     this.view.element.removeEventListener("CssRuleViewChanged",
       this._changeHandler);
 
     this.view.element.removeEventListener("CssRuleViewRefreshed",
@@ -160,19 +166,20 @@ function ComputedViewTool(aInspector, aW
   this.inspector.selection.on("detached", this._onSelect);
   this.inspector.selection.on("new-node-front", this._onSelect);
   if (this.inspector.highlighter) {
     this.inspector.highlighter.on("locked", this._onSelect);
   }
   this.refresh = this.refresh.bind(this);
   this.inspector.on("layout-change", this.refresh);
   this.inspector.selection.on("pseudoclass", this.refresh);
+  this.inspector.pageStyle.on("stylesheet-added", this.refresh);
+  this.inspector.pageStyle.on("stylesheet-removed", this.refresh);
 
   this.view.highlight(null);
-
   this.onSelect();
 }
 
 exports.ComputedViewTool = ComputedViewTool;
 
 ComputedViewTool.prototype = {
   onSelect: function CVT_onSelect(aEvent)
   {
@@ -211,16 +218,20 @@ ComputedViewTool.prototype = {
   {
     this.inspector.off("layout-change", this.refresh);
     this.inspector.sidebar.off("computedview-selected", this.refresh);
     this.inspector.selection.off("pseudoclass", this.refresh);
     this.inspector.selection.off("new-node-front", this._onSelect);
     if (this.inspector.highlighter) {
       this.inspector.highlighter.off("locked", this._onSelect);
     }
+    if (this.inspector.pageStyle) {
+      this.inspector.pageStyle.off("stylesheet-added", this.refresh);
+      this.inspector.pageStyle.off("stylesheet-removed", this.refresh);
+    }
 
     this.view.destroy();
     delete this.view;
 
     delete this.outerIFrame;
     delete this.cssLogic;
     delete this.cssHtmlTree;
     delete this.window;
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -59,8 +59,10 @@ support-files = browser_ruleview_pseudoe
 [browser_ruleview_original_source_link.js]
 support-files =
   sourcemaps.html
   sourcemaps.css
   sourcemaps.css.map
   sourcemaps.scss
 [browser_computedview_original_source_link.js]
 [browser_bug946331_close_tooltip_on_new_selection.js]
+[browser_bug922146_stylesheet_changes_refresh.js]
+[browser_bug922146_stylesheet_changes_iframe_refresh.js]
diff --git a/browser/devtools/styleinspector/test/browser_bug705707_is_content_stylesheet.js b/browser/devtools/styleinspector/test/browser_bug705707_is_content_stylesheet.js
--- a/browser/devtools/styleinspector/test/browser_bug705707_is_content_stylesheet.js
+++ b/browser/devtools/styleinspector/test/browser_bug705707_is_content_stylesheet.js
@@ -62,27 +62,28 @@ function reselectElement(target, cb)
 function testModifyRules()
 {
   // Set a property on all rules, then refresh and make sure they are still
   // there (and there wasn't an error on the server side)
   for (let rule of ruleView._elementStyle.rules) {
     rule.editor.addProperty("font-weight", "bold", "");
   }
 
-  reselectElement(doc.querySelector("#target"), () => {
+  inspector.once("rule-view-refreshed", () => {
+    reselectElement(doc.querySelector("#target"), () => {
+      for (let rule of ruleView._elementStyle.rules) {
+        let lastRule = rule.textProps[rule.textProps.length - 1];
 
-    for (let rule of ruleView._elementStyle.rules) {
-      let lastRule = rule.textProps[rule.textProps.length - 1];
+        is (lastRule.name, "font-weight", "Last rule name is font-weight");
+        is (lastRule.value, "bold", "Last rule value is bold");
+      }
 
-      is (lastRule.name, "font-weight", "Last rule name is font-weight");
-      is (lastRule.value, "bold", "Last rule value is bold");
-    }
-
-    gBrowser.removeCurrentTab();
-    openXUL();
+      gBrowser.removeCurrentTab();
+      openXUL();
+    });
   });
 }
 
 
 function openXUL()
 {
   Cc["@mozilla.org/permissionmanager;1"].getService(Ci.nsIPermissionManager)
     .addFromPrincipal(XUL_PRINCIPAL, 'allowXULXBL', Ci.nsIPermissionManager.ALLOW_ACTION);
diff --git a/browser/devtools/styleinspector/test/browser_bug922146_stylesheet_changes_iframe_refresh.js b/browser/devtools/styleinspector/test/browser_bug922146_stylesheet_changes_iframe_refresh.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_bug922146_stylesheet_changes_iframe_refresh.js
@@ -0,0 +1,80 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+let doc;
+let iframeDoc;
+let inspector;
+
+const DOCUMENT_URL = "data:text/html," + encodeURIComponent([
+  '<!DOCTYPE html>',
+  '<html>',
+  '<head>',
+  '  <meta charset=utf-8 />',
+  '  <title>Current element\'s styles should be refreshed when stylesheets are added, removed or changed, even if that element is in an iframe</title>',
+  '</head>',
+  '<body>',
+  '  <p>Some content in the root doc</p>',
+  '  <iframe src="data:text/html,<p>Some content in the iframe doc</p>"></iframe>',
+  '</body>',
+  '</html>'
+].join("\n"));
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, arguments.callee,
+      true);
+    doc = content.document;
+    iframeDoc = doc.querySelector("iframe").contentDocument;
+    waitForFocus(testNestedIframeElement, content);
+  }, true);
+
+  content.location = DOCUMENT_URL;
+}
+
+function endTests() {
+  doc = iframeDoc = inspector = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function testNestedIframeElement() {
+  info("Testing the element nested in the iframe");
+
+  openRuleView(aInspector => {
+    inspector = aInspector;
+    inspector.selection.setNode(iframeDoc.querySelector("p"));
+    inspector.once("inspector-updated", () => {
+      // Add a stylesheet to the iframe doc and see if the event gets fired
+      addStyleSheet(iframeDoc);
+      inspector.once("rule-view-refreshed", () => {
+        ok(true, "The rule view was refreshed after stylesheet added in iframe");
+        testRootDocElement();
+      });
+    });
+  });
+}
+
+function testRootDocElement() {
+  info("Testing the element in the root doc");
+
+  inspector.selection.setNode(doc.querySelector("p"));
+  inspector.once("inspector-updated", () => {
+    // Add a stylesheet to the iframe doc and see if the event gets fired
+    addStyleSheet(doc);
+    inspector.once("rule-view-refreshed", () => {
+      ok(true, "The rule view was refreshed after stylesheet added in iframe");
+      endTests();
+    });
+  });
+}
+
+function addStyleSheet(doc) {
+  let sheet = doc.createElement("STYLE");
+  sheet.type = "text/css";
+  sheet.appendChild(doc.createTextNode("p {color:red; width:200px; font:14px Arial;}"));
+  doc.getElementsByTagName("HEAD")[0].appendChild(sheet);
+}
\ No newline at end of file
diff --git a/browser/devtools/styleinspector/test/browser_bug922146_stylesheet_changes_refresh.js b/browser/devtools/styleinspector/test/browser_bug922146_stylesheet_changes_refresh.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_bug922146_stylesheet_changes_refresh.js
@@ -0,0 +1,123 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+let doc;
+let inspector;
+
+const DOCUMENT_URL = "data:text/html," + encodeURIComponent([
+  '<!DOCTYPE html>',
+  '<html>',
+  '<head>',
+  '  <meta charset=utf-8 />',
+  '  <title>Current element\'s styles should be refreshed when stylesheets are added, removed or changed</title>',
+  '</head>',
+  '<body>',
+  '  <p>Some text</p>',
+  '</body>',
+  '</html>'
+].join("\n"));
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, arguments.callee,
+      true);
+    doc = content.document;
+    waitForFocus(testRuleView, content);
+  }, true);
+
+  content.location = DOCUMENT_URL;
+}
+
+function endTests() {
+  doc = inspector = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function testRuleView() {
+  info("Testing the rule view");
+
+  openRuleView(aInspector => {
+    inspector = aInspector;
+    inspector.selection.setNode(doc.querySelector("p"));
+    inspector.once("inspector-updated", () => {
+      changingStyleSheetsShouldUpdateRuleView();
+    });
+  });
+}
+
+function changingStyleSheetsShouldUpdateRuleView(index=0) {
+  if (index === styleSheetChanges.length) {
+    testComputedView();
+  } else {
+    styleSheetChanges[index]();
+    inspector.once("rule-view-refreshed", () => {
+      ok(true, "The rule view was refreshed after stylesheet change " + index);
+      changingStyleSheetsShouldUpdateRuleView(index + 1);
+    });
+  }
+}
+
+function testComputedView() {
+  info("Testing the computed view");
+
+  inspector.sidebar.select("computedview");
+  changingStyleSheetsShouldUpdateComputedView();
+}
+
+function changingStyleSheetsShouldUpdateComputedView(index=0) {
+  if (index === styleSheetChanges.length) {
+    styleSheetChangeEventsShouldWorkAfterPageReload();
+  } else {
+    styleSheetChanges[index]();
+    inspector.once("computed-view-refreshed", () => {
+      ok(true, "The computed view was refreshed after stylesheet change " + index);
+      changingStyleSheetsShouldUpdateComputedView(index + 1);
+    });
+  }
+}
+
+function styleSheetChangeEventsShouldWorkAfterPageReload() {
+  info("Reloading the page and testing again");
+
+  let el = doc.createElement("div");
+  doc.body.appendChild(el);
+
+  gBrowser.selectedBrowser.addEventListener("load", function(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, arguments.callee,
+      true);
+    doc = content.document;
+    is(doc.querySelectorAll("div").length, 0, "The page was reloaded");
+
+    inspector.once("computed-view-refreshed", endTests);
+    styleSheetChanges[0]();
+  }, true);
+
+  content.location = DOCUMENT_URL;
+}
+
+var styleSheetChanges = [
+  function addStyleSheet() {
+    let sheet = doc.createElement("STYLE");
+    sheet.type = "text/css";
+    sheet.appendChild(doc.createTextNode("p {color:red; width:200px; font:14px Arial;}"));
+    doc.getElementsByTagName("HEAD")[0].appendChild(sheet);
+  },
+  function modifyLastStyleSheet() {
+    let styles = doc.getElementsByTagName("STYLE");
+    if (styles.length) {
+      let sheet = styles[styles.length - 1];
+      sheet.appendChild(doc.createTextNode("p {color:blue; width:100px; font:12px Verdana;}"));
+    }
+  },
+  function removeLastStyleSheet() {
+    let styles = doc.getElementsByTagName("STYLE");
+    if (styles.length) {
+      styles[styles.length - 1].remove();
+    }
+  }
+];
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_inherit.js b/browser/devtools/styleinspector/test/browser_ruleview_inherit.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_inherit.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_inherit.js
@@ -18,61 +18,69 @@ function simpleInherit(aInspector, aRule
     '#test2 {' +
     '  background-color: green;' +
     '  color: purple;' +
     '}';
 
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="test2"><div id="test1">Styled Node</div></div>';
 
-  inspector.selection.setNode(doc.getElementById("test1"));
-  inspector.once("inspector-updated", () => {
-    let elementStyle = view._elementStyle;
+  inspector.once("rule-view-refreshed", () => {
+    inspector.selection.setNode(doc.getElementById("test1"));
+    inspector.once("inspector-updated", () => {
+      let elementStyle = view._elementStyle;
 
-    is(elementStyle.rules.length, 2, "Should have 2 rules.");
+      is(elementStyle.rules.length, 2, "Should have 2 rules.");
 
-    let elementRule = elementStyle.rules[0];
-    ok(!elementRule.inherited, "Element style attribute should not consider itself inherited.");
+      let elementRule = elementStyle.rules[0];
+      ok(!elementRule.inherited, "Element style attribute should not consider itself inherited.");
 
-    let inheritRule = elementStyle.rules[1];
-    is(inheritRule.selectorText, "#test2", "Inherited rule should be the one that includes inheritable properties.");
-    ok(!!inheritRule.inherited, "Rule should consider itself inherited.");
-    is(inheritRule.textProps.length, 1, "Should only display one inherited style");
-    let inheritProp = inheritRule.textProps[0];
-    is(inheritProp.name, "color", "color should have been inherited.");
+      let inheritRule = elementStyle.rules[1];
+      is(inheritRule.selectorText, "#test2", "Inherited rule should be the one that includes inheritable properties.");
+      ok(!!inheritRule.inherited, "Rule should consider itself inherited.");
+      is(inheritRule.textProps.length, 1, "Should only display one inherited style");
+      let inheritProp = inheritRule.textProps[0];
+      is(inheritProp.name, "color", "color should have been inherited.");
 
-    styleNode.parentNode.removeChild(styleNode);
-
-    emptyInherit();
+      styleNode.parentNode.removeChild(styleNode);
+      inspector.once("rule-view-refreshed", () => {
+        inspector.selection.setNode(null);
+        inspector.once("inspector-updated", emptyInherit);
+      });
+    });
   });
 }
 
 function emptyInherit()
 {
   // No inheritable styles, this rule shouldn't show up.
   let style = '' +
     '#test2 {' +
     '  background-color: green;' +
     '}';
 
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="test2"><div id="test1">Styled Node</div></div>';
 
-  inspector.selection.setNode(doc.getElementById("test1"));
-  inspector.once("inspector-updated", () => {
-    let elementStyle = view._elementStyle;
+  inspector.once("rule-view-refreshed", () => {
+    inspector.selection.setNode(doc.getElementById("test1"));
+    inspector.once("inspector-updated", () => {
+      let elementStyle = view._elementStyle;
 
-    is(elementStyle.rules.length, 1, "Should have 1 rule.");
+      is(elementStyle.rules.length, 1, "Should have 1 rule.");
 
-    let elementRule = elementStyle.rules[0];
-    ok(!elementRule.inherited, "Element style attribute should not consider itself inherited.");
+      let elementRule = elementStyle.rules[0];
+      ok(!elementRule.inherited, "Element style attribute should not consider itself inherited.");
 
-    styleNode.parentNode.removeChild(styleNode);
-
-    elementStyleInherit();
+      styleNode.parentNode.removeChild(styleNode);
+      inspector.once("rule-view-refreshed", () => {
+        inspector.selection.setNode(null);
+        inspector.once("inspector-updated", elementStyleInherit);
+      });
+    });
   });
 }
 
 function elementStyleInherit()
 {
   doc.body.innerHTML = '<div id="test2" style="color: red"><div id="test1">Styled Node</div></div>';
 
   inspector.selection.setNode(doc.getElementById("test1"));
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_override.js b/browser/devtools/styleinspector/test/browser_ruleview_override.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_override.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_override.js
@@ -16,43 +16,48 @@ function simpleOverride(aInspector, aRul
     '} ' +
     '.testclass {' +
     '  background-color: green;' +
     '}';
 
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
 
-  inspector.selection.setNode(doc.getElementById("testid"));
-  inspector.once("inspector-updated", () => {
-    let elementStyle = view._elementStyle;
+  inspector.once("rule-view-refreshed", () => {
+    inspector.selection.setNode(doc.getElementById("testid"));
+    inspector.once("inspector-updated", () => {
+      let elementStyle = view._elementStyle;
 
-    let idRule = elementStyle.rules[1];
-    let idProp = idRule.textProps[0];
-    is(idProp.name, "background-color", "First ID prop should be background-color");
-    ok(!idProp.overridden, "ID prop should not be overridden.");
+      let idRule = elementStyle.rules[1];
+      let idProp = idRule.textProps[0];
+      is(idProp.name, "background-color", "First ID prop should be background-color");
+      ok(!idProp.overridden, "ID prop should not be overridden.");
 
-    let classRule = elementStyle.rules[2];
-    let classProp = classRule.textProps[0];
-    is(classProp.name, "background-color", "First class prop should be background-color");
-    ok(classProp.overridden, "Class property should be overridden.");
+      let classRule = elementStyle.rules[2];
+      let classProp = classRule.textProps[0];
+      is(classProp.name, "background-color", "First class prop should be background-color");
+      ok(classProp.overridden, "Class property should be overridden.");
 
-    // Override background-color by changing the element style.
-    let elementRule = elementStyle.rules[0];
-    elementRule.createProperty("background-color", "purple", "");
-    promiseDone(elementRule._applyingModifications.then(() => {
-      let elementProp = elementRule.textProps[0];
-      is(classProp.name, "background-color", "First element prop should now be background-color");
-      ok(!elementProp.overridden, "Element style property should not be overridden");
-      ok(idProp.overridden, "ID property should be overridden");
-      ok(classProp.overridden, "Class property should be overridden");
+      // Override background-color by changing the element style.
+      let elementRule = elementStyle.rules[0];
+      elementRule.createProperty("background-color", "purple", "");
+      promiseDone(elementRule._applyingModifications.then(() => {
+        let elementProp = elementRule.textProps[0];
+        is(classProp.name, "background-color", "First element prop should now be background-color");
+        ok(!elementProp.overridden, "Element style property should not be overridden");
+        ok(idProp.overridden, "ID property should be overridden");
+        ok(classProp.overridden, "Class property should be overridden");
 
-      styleNode.parentNode.removeChild(styleNode);
-      partialOverride();
-    }));
+        styleNode.parentNode.removeChild(styleNode);
+        inspector.once("rule-view-refreshed", () => {
+          inspector.selection.setNode(null);
+          inspector.once("inspector-updated", partialOverride);
+        });
+      }));
+    });
   });
 }
 
 function partialOverride()
 {
   let style = '' +
     // Margin shorthand property...
     '.testclass {' +
@@ -61,34 +66,38 @@ function partialOverride()
     // ... will be partially overridden.
     '#testid {' +
     '  margin-left: 1px;' +
     '}';
 
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
 
-  inspector.selection.setNode(doc.getElementById("testid"));
-  inspector.once("inspector-updated", () => {
-    let elementStyle = view._elementStyle;
+  inspector.once("rule-view-refreshed", () => {
+    inspector.selection.setNode(doc.getElementById("testid"));
+    inspector.once("inspector-updated", () => {
+      let elementStyle = view._elementStyle;
 
-    let classRule = elementStyle.rules[2];
-    let classProp = classRule.textProps[0];
-    ok(!classProp.overridden, "Class prop shouldn't be overridden, some props are still being used.");
-    for (let computed of classProp.computed) {
-      if (computed.name.indexOf("margin-left") == 0) {
-        ok(computed.overridden, "margin-left props should be overridden.");
-      } else {
-        ok(!computed.overridden, "Non-margin-left props should not be overridden.");
+      let classRule = elementStyle.rules[2];
+      let classProp = classRule.textProps[0];
+      ok(!classProp.overridden, "Class prop shouldn't be overridden, some props are still being used.");
+      for (let computed of classProp.computed) {
+        if (computed.name.indexOf("margin-left") == 0) {
+          ok(computed.overridden, "margin-left props should be overridden.");
+        } else {
+          ok(!computed.overridden, "Non-margin-left props should not be overridden.");
+        }
       }
-    }
 
-    styleNode.parentNode.removeChild(styleNode);
-
-    importantOverride();
+      styleNode.parentNode.removeChild(styleNode);
+      inspector.once("rule-view-refreshed", () => {
+        inspector.selection.setNode(null);
+        inspector.once("inspector-updated", importantOverride);
+      });
+    });
   });
 }
 
 function importantOverride()
 {
   let style = '' +
     // Margin shorthand property...
     '.testclass {' +
@@ -96,69 +105,74 @@ function importantOverride()
     '}' +
     // ... will be partially overridden.
     '#testid {' +
     '  background-color: blue;' +
     '}';
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
 
-  inspector.selection.setNode(doc.getElementById("testid"));
-  inspector.once("inspector-updated", () => {
-    let elementStyle = view._elementStyle;
+  inspector.once("rule-view-refreshed", () => {
+    inspector.selection.setNode(doc.getElementById("testid"));
+    inspector.once("inspector-updated", () => {
+      let elementStyle = view._elementStyle;
 
-    let idRule = elementStyle.rules[1];
-    let idProp = idRule.textProps[0];
-    ok(idProp.overridden, "Not-important rule should be overridden.");
+      let idRule = elementStyle.rules[1];
+      let idProp = idRule.textProps[0];
+      ok(idProp.overridden, "Not-important rule should be overridden.");
 
-    let classRule = elementStyle.rules[2];
-    let classProp = classRule.textProps[0];
-    ok(!classProp.overridden, "Important rule should not be overridden.");
+      let classRule = elementStyle.rules[2];
+      let classProp = classRule.textProps[0];
+      ok(!classProp.overridden, "Important rule should not be overridden.");
 
-    styleNode.parentNode.removeChild(styleNode);
+      let elementRule = elementStyle.rules[0];
+      let elementProp = elementRule.createProperty("background-color", "purple", "important");
+      promiseDone(elementRule._applyingModifications.then(() => {
+        ok(classProp.overridden, "New important prop should override class property.");
+        ok(!elementProp.overridden, "New important prop should not be overriden.");
 
-    let elementRule = elementStyle.rules[0];
-    let elementProp = elementRule.createProperty("background-color", "purple", "important");
-    promiseDone(elementRule._applyingModifications.then(() => {
-      ok(classProp.overridden, "New important prop should override class property.");
-      ok(!elementProp.overridden, "New important prop should not be overriden.");
-
-      disableOverride();
-    }));
+        styleNode.parentNode.removeChild(styleNode);
+        inspector.once("rule-view-refreshed", () => {
+          inspector.selection.setNode(null);
+          inspector.once("inspector-updated", disableOverride);
+        });
+      }));
+    });
   });
 }
 
 function disableOverride()
 {
   let style = '' +
     '#testid {' +
     '  background-color: blue;' +
     '}' +
     '.testclass {' +
     '  background-color: green;' +
     '}';
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
 
-  inspector.selection.setNode(doc.getElementById("testid"));
-  inspector.once("inspector-updated", () => {
-    let elementStyle = view._elementStyle;
+  inspector.once("rule-view-refreshed", () => {
+    inspector.selection.setNode(doc.getElementById("testid"));
+    inspector.once("inspector-updated", () => {
+      let elementStyle = view._elementStyle;
 
-    let idRule = elementStyle.rules[1];
-    let idProp = idRule.textProps[0];
-    idProp.setEnabled(false);
-    promiseDone(idRule._applyingModifications.then(() => {
-      let classRule = elementStyle.rules[2];
-      let classProp = classRule.textProps[0];
-      ok(!classProp.overridden, "Class prop should not be overridden after id prop was disabled.");
+      let idRule = elementStyle.rules[1];
+      let idProp = idRule.textProps[0];
+      idProp.setEnabled(false);
+      promiseDone(idRule._applyingModifications.then(() => {
+        let classRule = elementStyle.rules[2];
+        let classProp = classRule.textProps[0];
+        ok(!classProp.overridden, "Class prop should not be overridden after id prop was disabled.");
 
-      styleNode.parentNode.removeChild(styleNode);
-
-      finishTest();
-    }));
+        styleNode.parentNode.removeChild(styleNode);
+        inspector.once("rule-view-refreshed", finishTest);
+      }));
+    });
   });
 }
 
 function finishTest()
 {
   doc = inspector = view = null;
   gBrowser.removeCurrentTab();
   finish();
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_ui.js b/browser/devtools/styleinspector/test/browser_ruleview_ui.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_ui.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_ui.js
@@ -19,30 +19,32 @@ function startTest(aInspector, aRuleView
     ".testclass, .unmatched {" +
     "  background-color: green;" +
     "}";
 
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = "<div id='testid' class='testclass'>Styled Node</div>" +
                        "<div id='testid2'>Styled Node</div>";
 
-  let testElement = doc.getElementById("testid");
-  inspector.selection.setNode(testElement);
-  inspector.once("inspector-updated", () => {
-    is(ruleView.element.querySelectorAll("#noResults").length, 0, "After a highlight, no longer has a no-results element.");
-    inspector.selection.setNode(null);
+  inspector.once("rule-view-refreshed", () => {
+    let testElement = doc.getElementById("testid");
+    inspector.selection.setNode(testElement);
     inspector.once("inspector-updated", () => {
-      is(ruleView.element.querySelectorAll("#noResults").length, 1, "After highlighting null, has a no-results element again.");
-      inspector.selection.setNode(testElement);
+      is(ruleView.element.querySelectorAll("#noResults").length, 0, "After a highlight, no longer has a no-results element.");
+      inspector.selection.setNode(null);
       inspector.once("inspector-updated", () => {
-        let classEditor = ruleView.element.children[2]._ruleEditor;
-        is(classEditor.selectorText.querySelector(".ruleview-selector-matched").textContent, ".testclass", ".textclass should be matched.");
-        is(classEditor.selectorText.querySelector(".ruleview-selector-unmatched").textContent, ".unmatched", ".unmatched should not be matched.");
+        is(ruleView.element.querySelectorAll("#noResults").length, 1, "After highlighting null, has a no-results element again.");
+        inspector.selection.setNode(testElement);
+        inspector.once("inspector-updated", () => {
+          let classEditor = ruleView.element.children[2]._ruleEditor;
+          is(classEditor.selectorText.querySelector(".ruleview-selector-matched").textContent, ".testclass", ".textclass should be matched.");
+          is(classEditor.selectorText.querySelector(".ruleview-selector-unmatched").textContent, ".unmatched", ".unmatched should not be matched.");
 
-        testCancelNew();
+          testCancelNew();
+        });
       });
     });
   });
 }
 
 function testCancelNew()
 {
   // Start at the beginning: start to add a rule to the element's style
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_update.js b/browser/devtools/styleinspector/test/browser_ruleview_update.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_update.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_update.js
@@ -18,24 +18,25 @@ function startTest(aInspector, aRuleView
     '  background-color: blue;' +
     '} ' +
     '.testclass {' +
     '  background-color: green;' +
     '}';
 
   let styleNode = addStyle(doc, style);
   doc.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
+  inspector.once("rule-view-refreshed", () => {
+    testElement = doc.getElementById("testid");
 
-  testElement = doc.getElementById("testid");
+    let elementStyle = 'margin-top: 1px; padding-top: 5px;'
+    testElement.setAttribute("style", elementStyle);
 
-  let elementStyle = 'margin-top: 1px; padding-top: 5px;'
-  testElement.setAttribute("style", elementStyle);
-
-  inspector.selection.setNode(testElement);
-  inspector.once("rule-view-refreshed", testRuleChanges);
+    inspector.selection.setNode(testElement);
+    inspector.once("rule-view-refreshed", testRuleChanges);
+  });
 }
 
 function testRuleChanges()
 {
   let selectors = ruleView.doc.querySelectorAll(".ruleview-selector");
   is(selectors.length, 3, "Three rules visible.");
   is(selectors[0].textContent.indexOf("element"), 0, "First item is inline style.");
   is(selectors[1].textContent.indexOf("#testid"), 0, "Second item is id rule.");
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1887,16 +1887,17 @@ var WalkerActor = protocol.ActorClass({
     let isTopLevel = this.layoutHelpers.isTopLevelWindow(window);
     if (!frame && !this.rootDoc && isTopLevel) {
       this.rootDoc = window.document;
       this.rootNode = this.document();
       this.queueMutation({
         type: "newRoot",
         target: this.rootNode.form()
       });
+      events.emit(this, "root-frame-load");
     }
     let frameActor = this._refMap.get(frame);
     if (!frameActor) {
       return;
     }
 
     this.queueMutation({
       type: "frameLoad",
@@ -1949,16 +1950,17 @@ var WalkerActor = protocol.ActorClass({
 
     let doc = window.document;
     let documentActor = this._refMap.get(doc);
     if (!documentActor) {
       return;
     }
 
     if (this.rootDoc === doc) {
+      events.emit(this, "root-frame-unload");
       this.rootDoc = null;
       this.rootNode = null;
     }
 
     this.queueMutation({
       type: "documentUnload",
       target: documentActor.actorID
     });
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -54,36 +54,70 @@ types.addDictType("matchedselector", {
 
 /**
  * The PageStyle actor lets the client look at the styles on a page, as
  * they are applied to a given node.
  */
 var PageStyleActor = protocol.ActorClass({
   typeName: "pagestyle",
 
+  events: {
+    /**
+     * Fired whenever a new style-sheet is added to the document
+     */
+    "stylesheet-added" : {
+      type: "styleSheetAdded"
+    },
+    /**
+     * Fired whenever a style-sheet is removed from the document.
+     * Note that when a style-sheet content is changed, this will result in
+     * both a "stylesheet-added" and "stylesheet-removed" events being sent
+     */
+    "stylesheet-removed" : {
+      type: "styleSheetRemoved"
+    }
+  },
+
   /**
    * Create a PageStyleActor.
    *
    * @param inspector
    *    The InspectorActor that owns this PageStyleActor.
    *
    * @constructor
    */
   initialize: function(inspector) {
     protocol.Actor.prototype.initialize.call(this, null);
+
+    // The PageStyleActor depends on the inspector and walker
     this.inspector = inspector;
     if (!this.inspector.walker) {
       throw Error("The inspector's WalkerActor must be created before " +
                    "creating a PageStyleActor.");
     }
-    this.walker = inspector.walker;
+    this.walker = this.inspector.walker;
+
     this.cssLogic = new CssLogic;
 
     // Stores the association of DOM objects -> actors
     this.refMap = new Map;
+
+    this._onStyleSheetAdded = () => events.emit(this, "stylesheet-added");
+    this._onStyleSheetRemoved = () => events.emit(this, "stylesheet-removed");
+    // Stores the documents for which stylesheets events are observed
+    this.styleSheetChangesDocs = new Set;
+  },
+
+  destroy: function() {
+    for (let doc of this.styleSheetChangesDocs) {
+      this._unwatchStyleSheetChanges(doc);
+    }
+    this.styleSheetChangesDocs.clear();
+
+    protocol.Actor.prototype.destroy.call(this);
   },
 
   get conn() this.inspector.conn,
 
   /**
    * Return or create a StyleRuleActor for the given item.
    * @param item Either a CSSStyleRule or a DOM element.
    */
@@ -109,16 +143,64 @@ var PageStyleActor = protocol.ActorClass
     let actor = new StyleSheetActor(sheet, this, this.walker.rootWin);
     this.manage(actor);
     this.refMap.set(sheet, actor);
 
     return actor;
   },
 
   /**
+   * Start watching for added/removed stylesheets in a given content document
+   * and fire events to the client when this happens.
+   * Note that when a stylesheet's content is changed, both a removed and added
+   * events will be fired.
+   */
+  watchStyleSheetChanges: method(function(node) {
+    let doc = node.rawNode.ownerDocument;
+
+    if (!this.styleSheetChangesDocs.has(doc)) {
+      // Flag required to get StyleSheet events going
+      doc.styleSheetChangeEventsEnabled = true;
+
+      let eventHandler = doc.defaultView.QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell)
+        .chromeEventHandler;
+
+      eventHandler.addEventListener("StyleSheetAdded",
+        this._onStyleSheetAdded, true);
+      eventHandler.addEventListener("StyleSheetRemoved",
+        this._onStyleSheetRemoved, true);
+
+      this.styleSheetChangesDocs.add(doc);
+    }
+  }, {
+    request: {
+      node: Arg(0, "domnode")
+    }
+  }),
+
+  _unwatchStyleSheetChanges: function(doc) {
+    // Accessing doc or its window may fail on tab close or navigation.
+    // When that occurs, we want to silently fail as it doesn't matter if this
+    // is not executed
+    try {
+      doc.styleSheetChangeEventsEnabled = true;
+
+      let eventHandler = doc.defaultView.QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell)
+        .chromeEventHandler;
+
+      eventHandler.removeEventListener("StyleSheetAdded",
+        this._onStyleSheetAdded, true);
+      eventHandler.removeEventListener("StyleSheetRemoved",
+        this._onStyleSheetRemoved, true);
+    } catch (e) {}
+  },
+
+  /**
    * Get the computed style for a node.
    *
    * @param NodeActor node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
@@ -350,18 +432,17 @@ var PageStyleActor = protocol.ActorClass
       return DOMUtils.isInheritedProperty(prop);
     });
   },
 
   /**
    * Helper function for getApplied, adds all the rules from a given
    * element.
    */
-  addElementRules: function(element, inherited, options, rules)
-  {
+  addElementRules: function(element, inherited, options, rules) {
     let elementStyle = this._styleRef(element);
 
     if (!inherited || this._hasInheritedProps(element.style)) {
       rules.push({
         rule: elementStyle,
         inherited: inherited,
       });
     }
