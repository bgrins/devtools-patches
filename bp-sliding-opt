# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  64fc74a36a1606092a3cf23b949773b0518908cb
Optimizations for breakpoint sliding

diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -2790,39 +2790,67 @@ SourceActor.prototype = {
           // build a map from line numbers to a list of entry points for each
           // line, implemented as a sparse array. An entry point is a (script,
           // offsets) pair, and represents all offsets in that script that are
           // entry points for the corresponding line.
           let lineToEntryPointsMap = [];
 
           // Iterate over all scripts that correspond to this source actor.
           let scripts = this.scripts.getScriptsBySourceActor(this);
+          console.log(scripts.length);
           for (let script of scripts) {
             // Get all offsets for each line in the current script. This returns
-            // a map from line numbers fo a list of offsets for each line,
+            // a map from line numbers to a list of offsets for each line,
             // implemented as a sparse array.
             let lineToOffsetsMap = script.getAllOffsets();
+            console.log("Offsets for script ", lineToOffsetsMap.length);
 
             // Iterate over each line, and add their list of offsets to the map
             // from line numbers to entry points by forming a (script, offsets)
             // pair, where script is the current script, and offsets is the list
             // of offsets for the current line.
-            for (let line = 0; line < lineToOffsetsMap.length; ++line) {
+            // console.time("lineToOffsetsMap");
+            let numTrue = 0;
+            let numFalse = 0;
+
+            let importantOffsets = lineToOffsetsMap[-1];
+            // console.log("Offsets map -1", lineToOffsetsMap[-1]);
+            for (let line of importantOffsets) {
+              // console.log("Has offset at line " + line);
               let offsets = lineToOffsetsMap[line];
-              if (offsets) {
-                let entryPoints = lineToEntryPointsMap[line];
-                if (!entryPoints) {
-                  // We dont have a list of entry points for the current line
-                  // number yet, so create it and add it to the map.
-                  entryPoints = [];
-                  lineToEntryPointsMap[line] = entryPoints;
-                }
-                entryPoints.push({ script, offsets });
+              let entryPoints = lineToEntryPointsMap[line];
+              if (!entryPoints) {
+                // We dont have a list of entry points for the current line
+                // number yet, so create it and add it to the map.
+                entryPoints = [];
+                lineToEntryPointsMap[line] = entryPoints;
               }
+              entryPoints.push({ script, offsets });
             }
+
+            // for (let line = 0; line < lineToOffsetsMap.length; ++line) {
+            //   let offsets = lineToOffsetsMap[line];
+            //   if (offsets) {
+            //     numTrue++;
+            //     console.log("Has offset at line " + line);
+            //     let entryPoints = lineToEntryPointsMap[line];
+            //     if (!entryPoints) {
+            //       // We dont have a list of entry points for the current line
+            //       // number yet, so create it and add it to the map.
+            //       entryPoints = [];
+            //       lineToEntryPointsMap[line] = entryPoints;
+            //     }
+            //     entryPoints.push({ script, offsets });
+            //   } else {
+            //     numFalse++;
+            //   }
+            // }
+            // console.timeEnd("lineToOffsetsMap");
+            // console.log("lineToOffsetsMap.length", lineToOffsetsMap.length,
+            //   "true: " + numTrue, "false: " + numFalse);
           }
 
           // Now that we have a map from line numbers to a list of entry points
           // for each line, we can use it to perform breakpoint sliding. Start
           // at the original line of the breakpoint actor, and keep incrementing
           // it by one, until either we find a line that has at least one entry
           // point, or we go past the last line in the map.
           //
diff --git a/js/src/vm/Debugger.cpp b/js/src/vm/Debugger.cpp
--- a/js/src/vm/Debugger.cpp
+++ b/js/src/vm/Debugger.cpp
@@ -5185,16 +5185,20 @@ DebuggerScript_getAllOffsets(JSContext* 
     FlowGraphSummary flowData(cx);
     if (!flowData.populate(cx, script))
         return false;
 
     /* Second pass: build the result array. */
     RootedObject result(cx, NewDenseEmptyArray(cx));
     if (!result)
         return false;
+
+    RootedObject filledOffsets(cx);
+    filledOffsets = NewDenseEmptyArray(cx);
+
     for (BytecodeRangeWithPosition r(cx, script); !r.empty(); r.popFront()) {
         if (!r.frontIsEntryPoint())
             continue;
 
         size_t offset = r.frontOffset();
         size_t lineno = r.frontLineNumber();
 
         /* Make a note, if the current instruction is an entry point for the current line. */
@@ -5232,18 +5236,35 @@ DebuggerScript_getAllOffsets(JSContext* 
                 RootedValue value(cx, ObjectValue(*offsets));
                 if (!DefineProperty(cx, result, id, value))
                     return false;
             }
 
             /* Append the current offset to the offsets array. */
             if (!NewbornArrayPush(cx, offsets, NumberValue(offset)))
                 return false;
-        }
-    }
+
+            /* Append the current offset index so the server doesn't need to
+               loop a bunch unnecessarily.  This is going to hackily being appended
+               into the -1 spot of the result array and surely there should be a better
+               way to send this back*/
+            if (!NewbornArrayPush(cx, filledOffsets, NumberValue(lineno)))
+                return false;
+        }
+    }
+
+    RootedId id(cx);
+    RootedValue v(cx, NumberValue(-1));
+    if (!ValueToId<CanGC>(cx, v, &id)) {
+        return false;
+    }
+
+    RootedValue value(cx, ObjectValue(*filledOffsets));
+    if (!DefineProperty(cx, result, id, value))
+        return false;
 
     args.rval().setObject(*result);
     return true;
 }
 
 static bool
 DebuggerScript_getAllColumnOffsets(JSContext* cx, unsigned argc, Value* vp)
 {
