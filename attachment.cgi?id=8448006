# HG changeset patch
# Parent b6408c32a17031bd9378bc2629d4135ff6144b92
inDeepTreeWalker

diff --git a/layout/inspector/inDeepTreeWalker.cpp b/layout/inspector/inDeepTreeWalker.cpp
--- a/layout/inspector/inDeepTreeWalker.cpp
+++ b/layout/inspector/inDeepTreeWalker.cpp
@@ -70,21 +70,21 @@ inDeepTreeWalker::SetShowSubDocuments(bo
   mShowSubDocuments = aShowSubDocuments;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::Init(nsIDOMNode* aRoot, uint32_t aWhatToShow)
 {
   mRoot = aRoot;
+  mCurrentNode = aRoot;
   mWhatToShow = aWhatToShow;
-  
-  PushNode(aRoot);
 
-  return NS_OK;
+  mDOMUtils = do_GetService("@mozilla.org/inspector/dom-utils;1");
+  return mDOMUtils ? NS_OK : NS_ERROR_UNEXPECTED;
 }
 
 ////////////////////////////////////////////////////
 // nsIDOMTreeWalker
 
 NS_IMETHODIMP
 inDeepTreeWalker::GetRoot(nsIDOMNode** aRoot)
 {
@@ -111,152 +111,205 @@ NS_IMETHODIMP
 inDeepTreeWalker::GetCurrentNode(nsIDOMNode** aCurrentNode)
 {
   *aCurrentNode = mCurrentNode;
   NS_IF_ADDREF(*aCurrentNode);
   
   return NS_OK;
 }
 
+already_AddRefed<nsIDOMNode>
+inDeepTreeWalker::GetParent()
+{
+  if (!mCurrentNode || mCurrentNode == mRoot) {
+    return nullptr;
+  }
+
+  nsCOMPtr<nsIDOMNode> parent;
+  MOZ_ASSERT(mDOMUtils, "mDOMUtils should have been initiated already in Init");
+  mDOMUtils->GetParentForNode(mCurrentNode, mShowAnonymousContent,
+                              getter_AddRefs(parent));
+
+  return parent.forget();
+}
+
 NS_IMETHODIMP
 inDeepTreeWalker::SetCurrentNode(nsIDOMNode* aCurrentNode)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return SetCurrentNode(aCurrentNode, nullptr);
+}
+
+
+NS_IMETHODIMP
+inDeepTreeWalker::SetCurrentNode(nsIDOMNode* aCurrentNode,
+                                 nsINodeList* aSiblings)
+{
+  if (!aCurrentNode) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mCurrentNode = aCurrentNode;
+  mSiblings = aSiblings;
+  if (!mSiblings) {
+    nsCOMPtr<nsIDOMNode> parent = GetParent();
+    if (parent) {
+      nsCOMPtr<nsIContent> parentContent = do_QueryInterface(parent);
+      nsCOMPtr<nsIDOMNodeList> list;
+      if (parentContent) {
+        list = parentContent->GetChildren(mShowAnonymousContent ?
+                                          nsIContent::eAllChildren :
+                                          nsIContent::eAllButXBL);
+      } else {
+        // If parent is a document...
+        parent->GetChildNodes(getter_AddRefs(list));
+      }
+      mSiblings = do_QueryInterface(list);
+    }
+  }
+
+  if (mSiblings) {
+    // We cached all the siblings (if there are any) of the current node, but we
+    // still have to set the index too, to be able to iterate over them.
+    if (mSiblings->Length() == 0) {
+      mSiblings = nullptr;
+    } else {
+      nsCOMPtr<nsIContent> currentAsContent = do_QueryInterface(mCurrentNode);
+      mCurrentIndex = mSiblings->IndexOf(currentAsContent);
+    }
+  }
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::ParentNode(nsIDOMNode** _retval)
 {
   *_retval = nullptr;
-  if (!mCurrentNode) return NS_OK;
-
-  if (mStack.Length() == 1) {
-    // No parent
+  if (!mCurrentNode || mCurrentNode == mRoot) {
     return NS_OK;
   }
 
-  // Pop off the current node, and push the new one
-  mStack.RemoveElementAt(mStack.Length()-1);
-  DeepTreeStackItem& top = mStack.ElementAt(mStack.Length() - 1);
-  mCurrentNode = top.node;
-  top.lastIndex = 0;
-  NS_ADDREF(*_retval = mCurrentNode);
+  nsCOMPtr<nsIDOMNode> parent = GetParent();
+
+  if (!parent) {
+    return NS_OK;
+  }
+
+  nsresult rv = SetCurrentNode(parent);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  parent.forget(_retval);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-inDeepTreeWalker::FirstChild(nsIDOMNode **_retval)
+inDeepTreeWalker::FirstChild(nsIDOMNode** _retval)
 {
   *_retval = nullptr;
   if (!mCurrentNode) {
     return NS_OK;
   }
 
-  DeepTreeStackItem& top = mStack.ElementAt(mStack.Length() - 1);
-  nsCOMPtr<nsIDOMNode> kid;
-  top.kids->Item(0, getter_AddRefs(kid));
-  if (!kid) {
-    return NS_OK;
+  nsCOMPtr<nsIDOMNode> fchild;
+  if (mShowSubDocuments) {
+    nsCOMPtr<nsIDOMDocument> domdoc = inLayoutUtils::GetSubDocumentFor(mCurrentNode);
+    fchild = do_QueryInterface(domdoc);
   }
-  top.lastIndex = 1;
-  PushNode(kid);
-  kid.forget(_retval);
+
+  nsCOMPtr<nsINodeList> children;
+  if (!fchild) {
+    nsCOMPtr<nsIContent> currentAsContent = do_QueryInterface(mCurrentNode);
+    if (currentAsContent) {
+      nsCOMPtr<nsIDOMNodeList> list = currentAsContent->GetChildren(mShowAnonymousContent ?
+                                                                    nsIContent::eAllChildren :
+                                                                    nsIContent::eAllButXBL);
+      children = do_QueryInterface(list);
+      if (children && children->Length() > 0) {
+        nsIContent* childAsContent = children->Item(0);
+        fchild = childAsContent->AsDOMNode();
+      }
+    } else {
+      // If it's not a content, then it's a document (or an attribute but we can ignore that
+      // case here). GetFirstChild should just work then.
+      mCurrentNode->GetFirstChild(getter_AddRefs(fchild));
+    }
+  }
+
+  if (fchild) {
+    nsresult rv = SetCurrentNode(fchild, children);
+    NS_ENSURE_SUCCESS(rv, rv);
+    NS_ADDREF(*_retval = mCurrentNode);
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::LastChild(nsIDOMNode **_retval)
 {
   *_retval = nullptr;
   if (!mCurrentNode) {
     return NS_OK;
   }
 
-  DeepTreeStackItem& top = mStack.ElementAt(mStack.Length() - 1);
-  nsCOMPtr<nsIDOMNode> kid;
-  uint32_t length;
-  top.kids->GetLength(&length);
-  top.kids->Item(length - 1, getter_AddRefs(kid));
-  if (!kid) {
-    return NS_OK;
+  nsCOMPtr<nsIContent> currentAsContent = do_QueryInterface(mCurrentNode);
+  nsCOMPtr<nsIDOMNode> lchild;
+  nsCOMPtr<nsINodeList> children;
+  if (currentAsContent) {
+    nsCOMPtr<nsIDOMNodeList> list = currentAsContent->GetChildren(mShowAnonymousContent ?
+                                                                  nsIContent::eAllChildren :
+                                                                  nsIContent::eAllButXBL);
+    children = do_QueryInterface(list);
+    if (children && children->Length() > 0) {
+      nsIContent* childAsContent = children->Item(children->Length()-1);
+      lchild = childAsContent->AsDOMNode();
+    }
+  } else {
+    mCurrentNode->GetLastChild(getter_AddRefs(lchild));
   }
-  top.lastIndex = length;
-  PushNode(kid);
-  kid.forget(_retval);
+
+  if (lchild) {
+    nsresult rv = SetCurrentNode(lchild, children);
+    NS_ENSURE_SUCCESS(rv, rv);
+    NS_ADDREF(*_retval = mCurrentNode);
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::PreviousSibling(nsIDOMNode **_retval)
 {
   *_retval = nullptr;
-  if (!mCurrentNode) {
+  if (!mCurrentNode || !mSiblings || mCurrentIndex < 1) {
     return NS_OK;
   }
 
-  NS_ASSERTION(mStack.Length() > 0, "Should have things in mStack");
-
-  if (mStack.Length() == 1) {
-    // No previous sibling
-    return NS_OK;
-  }
-
-  DeepTreeStackItem& parent = mStack.ElementAt(mStack.Length()-2);
-  nsCOMPtr<nsIDOMNode> previousSibling;
-  parent.kids->Item(parent.lastIndex-2, getter_AddRefs(previousSibling));
-  if (!previousSibling) {
-    return NS_OK;
-  }
-
-  // Our mStack's topmost element is our current node. Since we're trying to
-  // change that to the previous sibling, pop off the current node, and push
-  // the new one.
-  mStack.RemoveElementAt(mStack.Length() - 1);
-  parent.lastIndex--;
-  PushNode(previousSibling);
-  previousSibling.forget(_retval);
+  nsIContent* prev = mSiblings->Item(--mCurrentIndex);
+  mCurrentNode = prev->AsDOMNode();
+  NS_ADDREF(*_retval = mCurrentNode);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::NextSibling(nsIDOMNode **_retval)
 {
   *_retval = nullptr;
-  if (!mCurrentNode) {
+  if (!mCurrentNode || !mSiblings || mCurrentIndex + 2 > mSiblings->Length()) {
     return NS_OK;
   }
 
-  NS_ASSERTION(mStack.Length() > 0, "Should have things in mStack");
-
-  if (mStack.Length() == 1) {
-    // No next sibling
-    return NS_OK;
-  }
-
-  DeepTreeStackItem& parent = mStack.ElementAt(mStack.Length()-2);
-  nsCOMPtr<nsIDOMNode> nextSibling;
-  parent.kids->Item(parent.lastIndex, getter_AddRefs(nextSibling));
-  if (!nextSibling) {
-    return NS_OK;
-  }
-
-  // Our mStack's topmost element is our current node. Since we're trying to
-  // change that to the next sibling, pop off the current node, and push
-  // the new one.
-  mStack.RemoveElementAt(mStack.Length() - 1);
-  parent.lastIndex++;
-  PushNode(nextSibling);
-  nextSibling.forget(_retval);
+  nsIContent* next = mSiblings->Item(++mCurrentIndex);
+  mCurrentNode = next->AsDOMNode();
+  NS_ADDREF(*_retval = mCurrentNode);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::PreviousNode(nsIDOMNode **_retval)
 {
-  if (!mCurrentNode || mStack.Length() == 1) {
+  if (!mCurrentNode || mCurrentNode == mRoot) {
     // Nowhere to go from here
     *_retval = nullptr;
     return NS_OK;
   }
 
   nsCOMPtr<nsIDOMNode> node;
   PreviousSibling(getter_AddRefs(node));
 
@@ -314,92 +367,8 @@ inDeepTreeWalker::NextNode(nsIDOMNode **
       return NS_OK;
     }
     ++lastChildCallsToMake;
   }
 
   NS_NOTREACHED("how did we get here?");
   return NS_OK;
 }
-
-void
-inDeepTreeWalker::PushNode(nsIDOMNode* aNode)
-{
-  mCurrentNode = aNode;
-  if (!aNode) return;
-
-  DeepTreeStackItem item;
-  item.node = aNode;
-
-  nsCOMPtr<nsIDOMNodeList> kids;
-  if (mShowSubDocuments) {
-    nsCOMPtr<nsIDOMDocument> domdoc = inLayoutUtils::GetSubDocumentFor(aNode);
-    if (domdoc) {
-      domdoc->GetChildNodes(getter_AddRefs(kids));
-    }
-  }
-  
-  if (!kids) {
-    nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
-    if (content && mShowAnonymousContent) {
-      kids = content->GetChildren(nsIContent::eAllChildren);
-    }
-  }
-  if (!kids) {
-    aNode->GetChildNodes(getter_AddRefs(kids));
-  }
-  
-  item.kids = kids;
-  item.lastIndex = 0;
-  mStack.AppendElement(item);
-}
-
-/*
-// This NextNode implementation does not require the use of stacks, 
-// as does the one above. However, it does not handle anonymous 
-// content and sub-documents.
-NS_IMETHODIMP
-inDeepTreeWalker::NextNode(nsIDOMNode **_retval)
-{
-  if (!mCurrentNode) return NS_OK;
-  
-  // walk down the tree first
-  nsCOMPtr<nsIDOMNode> next;
-  mCurrentNode->GetFirstChild(getter_AddRefs(next));
-  if (!next) {
-    mCurrentNode->GetNextSibling(getter_AddRefs(next));
-    if (!next) { 
-      // we've hit the end, so walk back up the tree until another
-      // downward opening is found, or the top of the tree
-      nsCOMPtr<nsIDOMNode> subject = mCurrentNode;
-      nsCOMPtr<nsIDOMNode> parent;
-      while (1) {
-        subject->GetParentNode(getter_AddRefs(parent));
-        if (!parent) // hit the top of the tree
-          break;
-        parent->GetNextSibling(getter_AddRefs(subject));
-        if (subject) { // found a downward opening
-          next = subject;
-          break;
-        } else // walk up another level
-          subject = parent;
-      } 
-    }
-  }
-  
-  mCurrentNode = next;
-  
-  *_retval = next;
-  NS_IF_ADDREF(*_retval);
-  
-  return NS_OK;
-}
-
-
-char* getURL(nsIDOMDocument* aDoc)
-{
-  nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDoc);
-  nsIURI *uri = doc->GetDocumentURI();
-  char* s;
-  uri->GetSpec(&s);
-  return s;
-}
-*/
diff --git a/layout/inspector/inDeepTreeWalker.h b/layout/inspector/inDeepTreeWalker.h
--- a/layout/inspector/inDeepTreeWalker.h
+++ b/layout/inspector/inDeepTreeWalker.h
@@ -8,48 +8,38 @@
 #include "inIDeepTreeWalker.h"
 
 #include "nsCOMPtr.h"
 #include "nsIDOMNode.h"
 #include "nsTArray.h"
 
 class inIDOMUtils;
 
-////////////////////////////////////////////////////
-
-struct DeepTreeStackItem
-{
-  nsCOMPtr<nsIDOMNode> node;
-  nsCOMPtr<nsIDOMNodeList> kids;
-  uint32_t lastIndex; // Index one bigger than the index of whatever
-                      // kid we're currently at in |kids|.
-};
-
-////////////////////////////////////////////////////
-
 class inDeepTreeWalker : public inIDeepTreeWalker
 {
 public:
 	NS_DECL_ISUPPORTS
 	NS_DECL_INIDEEPTREEWALKER
 
   inDeepTreeWalker();
 
+  NS_IMETHODIMP SetCurrentNode(nsIDOMNode* aCurrentNode,
+                               nsINodeList* aSiblings);
 protected:
   virtual ~inDeepTreeWalker();
 
-  void PushNode(nsIDOMNode* aNode);
+  already_AddRefed<nsIDOMNode> GetParent();
 
   bool mShowAnonymousContent;
   bool mShowSubDocuments;
   nsCOMPtr<nsIDOMNode> mRoot;
   nsCOMPtr<nsIDOMNode> mCurrentNode;
+  nsCOMPtr<inIDOMUtils> mDOMUtils;
+  nsCOMPtr<nsINodeList> mSiblings;
+  uint32_t mCurrentIndex;
   uint32_t mWhatToShow;
-  
-  nsAutoTArray<DeepTreeStackItem, 8> mStack;
-  nsCOMPtr<inIDOMUtils> mDOMUtils;
 };
 
 // {BFCB82C2-5611-4318-90D6-BAF4A7864252}
 #define IN_DEEPTREEWALKER_CID \
 { 0xbfcb82c2, 0x5611, 0x4318, { 0x90, 0xd6, 0xba, 0xf4, 0xa7, 0x86, 0x42, 0x52 } }
 
 #endif // __inDeepTreeWalker_h___
diff --git a/layout/inspector/tests/file_bug522601.html b/layout/inspector/tests/file_bug522601.html
new file mode 100644
--- /dev/null
+++ b/layout/inspector/tests/file_bug522601.html
@@ -0,0 +1,17 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
+                      "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=522601
+-->
+<head>
+  <title>Test for Bug 522601</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<div id="some content">
+  <h1>Blah</h1>
+</div>
+</body>
+</html>
diff --git a/layout/inspector/tests/mochitest.ini b/layout/inspector/tests/mochitest.ini
--- a/layout/inspector/tests/mochitest.ini
+++ b/layout/inspector/tests/mochitest.ini
@@ -1,10 +1,12 @@
 [DEFAULT]
-support-files = bug856317.css
+support-files =
+  bug856317.css
+  file_bug522601.html
 
 [test_bug462787.html]
 [test_bug462789.html]
 [test_bug522601.xhtml]
 [test_bug536379-2.html]
 [test_bug536379.html]
 [test_bug557726.html]
 [test_bug609549.xhtml]
diff --git a/layout/inspector/tests/test_bug522601.xhtml b/layout/inspector/tests/test_bug522601.xhtml
--- a/layout/inspector/tests/test_bug522601.xhtml
+++ b/layout/inspector/tests/test_bug522601.xhtml
@@ -17,32 +17,51 @@ https://bugzilla.mozilla.org/show_bug.cg
 <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=522601">Mozilla Bug 522601</a>
 <p id="display" style="-moz-binding: url(#testBinding)">
   <span id="s">This is some text</span>
   More text
   <b id="b">Even more <i id="i1">Italic</i>text<i id="i2">And more italic</i></b></p>
 <div id="content" style="display: none">
   
 </div>
+<div id="subdoc">
+  <iframe id="frame1" src="file_bug522601.html"></iframe>
+</div>
 <pre id="test">
 <script type="application/javascript">
 <![CDATA[
 
 /** Test for Bug 522601 **/
 SimpleTest.waitForExplicitFinish();
 
 function testFunc(walker, func, expectedNode, str) {
   var oldCurrent = SpecialPowers.unwrap(walker.currentNode);
   var newNode = SpecialPowers.unwrap(walker[func]());
   is(newNode, expectedNode, "Unexpected node after " + str);
   is(SpecialPowers.unwrap(walker.currentNode), newNode ? newNode : oldCurrent,
      "Unexpected current node after " + str);
 }
 
 addLoadEvent(function() {
+  var walkerSubDocument =
+    SpecialPowers.Cc["@mozilla.org/inspector/deep-tree-walker;1"]
+              .createInstance(SpecialPowers.Ci.inIDeepTreeWalker);
+  walkerSubDocument.init($("frame1"), NodeFilter.SHOW_ALL);
+  walkerSubDocument.showAnonymousContent = false;
+  walkerSubDocument.showSubDocuments = true;
+  
+  is(SpecialPowers.unwrap(walkerSubDocument.currentNode), $("frame1"), "Unexpected sub-doc root");
+  testFunc(walkerSubDocument, "firstChild", $("frame1").contentDocument,
+           "step to sub document");
+  testFunc(walkerSubDocument, "firstChild", $("frame1").contentDocument.doctype,
+           "step to sub documents doctype");
+  testFunc(walkerSubDocument, "nextSibling", $("frame1").contentDocument.documentElement,
+           "step to sub documents documentElement");
+
+
   var walkerNonAnon =
     SpecialPowers.Cc["@mozilla.org/inspector/deep-tree-walker;1"]
               .createInstance(SpecialPowers.Ci.inIDeepTreeWalker);
   walkerNonAnon.init($("display"), NodeFilter.SHOW_ALL);
   walkerNonAnon.showAnonymousContent = false;
 
   is(SpecialPowers.unwrap(walkerNonAnon.currentNode), $("display"), "Unexpected non-anon root");
   testFunc(walkerNonAnon, "nextNode", $("s").previousSibling,
@@ -163,17 +182,17 @@ addLoadEvent(function() {
   testFunc(walkerAnon, "previousNode", $("b"), "step back to bold (anon)");
   testFunc(walkerAnon, "previousNode", $("s").nextSibling, "step back to more text (anon)");
   testFunc(walkerAnon, "previousNode", $("s").previousSibling,
            "step back to some text (anon)");
   testFunc(walkerAnon, "previousNode", anonDiv,
            "step back to anonymous div");
   testFunc(walkerAnon, "previousNode", $("display"), "step back to root (anon)");
   testFunc(walkerAnon, "previousNode", null, "step back past root (anon)");
-  
+
   SimpleTest.finish();
 });
 
 ]]>
 </script>
 </pre>
 </body>
 </html>
