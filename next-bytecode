# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7bbb08844061d72ad0ab32e6477f63796bad83b1
Bug 789430 - Pause on next bytecode instead of immediately;r=fitzgen

diff --git a/browser/devtools/debugger/debugger-controller.js b/browser/devtools/debugger/debugger-controller.js
--- a/browser/devtools/debugger/debugger-controller.js
+++ b/browser/devtools/debugger/debugger-controller.js
@@ -684,17 +684,20 @@ StackFrames.prototype = {
         } else if (aPacket.why.frameFinished.return) {
           this._currentReturnedValue = aPacket.why.frameFinished.return;
         }
         break;
       // If paused by an explicit interrupt, which are generated by the slow
       // script dialog and internal events such as setting breakpoints, ignore
       // the event to avoid UI flicker.
       case "interrupted":
-        return;
+        if (!aPacket.why.onNext) {
+          return;
+        }
+        break;
     }
 
     this.activeThread.fillFrames(CALL_STACK_PAGE_SIZE);
     DebuggerView.editor.focus();
   },
 
   /**
    * Handler for the thread client's resumed notification.
diff --git a/browser/devtools/debugger/views/toolbar-view.js b/browser/devtools/debugger/views/toolbar-view.js
--- a/browser/devtools/debugger/views/toolbar-view.js
+++ b/browser/devtools/debugger/views/toolbar-view.js
@@ -108,16 +108,18 @@ ToolbarView.prototype = {
 
   /**
    * Sets the resume button state based on the debugger active thread.
    *
    * @param string aState
    *        Either "paused" or "attached".
    */
   toggleResumeButtonState: function(aState) {
+    this._resumeButton.removeAttribute("break-on-next");
+
     // If we're paused, check and show a resume label on the button.
     if (aState == "paused") {
       this._resumeButton.setAttribute("checked", "true");
       this._resumeButton.setAttribute("tooltiptext", this._resumeTooltip);
     }
     // If we're attached, do the opposite.
     else if (aState == "attached") {
       this._resumeButton.removeAttribute("checked");
@@ -144,17 +146,19 @@ ToolbarView.prototype = {
       return;
     }
 
     if (this.activeThread.paused) {
       this.StackFrames.currentFrameDepth = -1;
       this.activeThread.resume(this.resumptionWarnFunc);
     } else {
       this.ThreadState.interruptedByResumeButton = true;
-      this.activeThread.interrupt();
+      this._resumeButton.setAttribute("break-on-next", "true");
+      this.activeThread.breakOnNext1(() => {
+      });
     }
   },
 
   /**
    * Listener handling the step over button click event.
    */
   _onStepOverPressed: function() {
     if (this.activeThread.paused) {
diff --git a/browser/themes/shared/devtools/debugger.css b/browser/themes/shared/devtools/debugger.css
--- a/browser/themes/shared/devtools/debugger.css
+++ b/browser/themes/shared/devtools/debugger.css
@@ -579,16 +579,20 @@
 #resume ~ toolbarbutton {
   transition: opacity 0.15s ease-in-out;
 }
 
 #resume:not([checked]) ~ toolbarbutton {
   opacity: 0.5;
 }
 
+#resume[break-on-next] {
+  background: var(--theme-highlight-green);
+}
+
 #step-over {
   list-style-image: url(debugger-step-over.png);
 }
 
 #step-in {
   list-style-image: url(debugger-step-in.png);
 }
 
diff --git a/toolkit/devtools/client/main.js b/toolkit/devtools/client/main.js
--- a/toolkit/devtools/client/main.js
+++ b/toolkit/devtools/client/main.js
@@ -1691,28 +1691,49 @@ ThreadClient.prototype = {
    * @param function aOnResponse
    *        Called with the response packet.
    */
   stepOut: function (aOnResponse) {
     this._doResume({ type: "finish" }, aOnResponse);
   },
 
   /**
+   * Immediately interrupt a running thread.
+   *
+   * @param function aOnResponse
+   *        Called with the response packet.
+   */
+  interrupt: function(aOnResponse) {
+    this._doInterrupt(null, aOnResponse);
+  },
+
+  /**
    * Interrupt a running thread.
    *
    * @param function aOnResponse
    *        Called with the response packet.
    */
-  interrupt: DebuggerClient.requester({
-    type: "interrupt"
+  _doInterrupt: DebuggerClient.requester({
+    type: "interrupt",
+    when: args(0)
   }, {
     telemetry: "INTERRUPT"
   }),
 
   /**
+   * Pause execution right before the next JavaScript bytecode is executed.
+   *
+   * @param function aOnResponse
+   *        Called with the response packet.
+   */
+  breakOnNext1: function(aOnResponse) {
+    this._doInterrupt("onNext", aOnResponse);
+  },
+
+  /**
    * Enable or disable pausing when an exception is thrown.
    *
    * @param boolean aFlag
    *        Enables pausing if true, disables otherwise.
    * @param function aOnResponse
    *        Called with the response packet.
    */
   pauseOnExceptions: function (aPauseOnExceptions,
@@ -1726,17 +1747,17 @@ ThreadClient.prototype = {
     if (this.paused) {
       this.reconfigure({
         pauseOnExceptions: aPauseOnExceptions,
         ignoreCaughtExceptions: aIgnoreCaughtExceptions
       }, aOnResponse);
       return;
     }
     // Otherwise send the flag using a standard resume request.
-    this.interrupt(aResponse => {
+    this._doInterrupt(null, aResponse => {
       if (aResponse.error) {
         // Can't continue if pausing failed.
         aOnResponse(aResponse);
         return;
       }
       this.resume(aOnResponse);
     });
   },
@@ -1757,17 +1778,17 @@ ThreadClient.prototype = {
     this._pauseOnDOMEvents = events;
     // If the debuggee is paused, the value of the array will be communicated in
     // the next resumption. Otherwise we have to force a pause in order to send
     // the array.
     if (this.paused) {
       DevToolsUtils.executeSoon(() => onResponse({}));
       return;
     }
-    this.interrupt(response => {
+    this._doInterrupt(null, response => {
       // Can't continue if pausing failed.
       if (response.error) {
         onResponse(response);
         return;
       }
       this.resume(onResponse);
     });
   },
@@ -2757,17 +2778,17 @@ SourceClient.prototype = {
     };
 
     // If the debuggee is paused, just set the breakpoint.
     if (this._activeThread.paused) {
       doSetBreakpoint();
       return;
     }
     // Otherwise, force a pause in order to set the breakpoint.
-    this._activeThread.interrupt(aResponse => {
+    this._activeThread._doInterrupt(null, aResponse => {
       if (aResponse.error) {
         // Can't set the breakpoint if pausing failed.
         aOnResponse(aResponse);
         return;
       }
 
       const { type, why } = aResponse;
       const cleanUp = type == "paused" && why.type == "interrupted"
diff --git a/toolkit/devtools/server/actors/script.js b/toolkit/devtools/server/actors/script.js
--- a/toolkit/devtools/server/actors/script.js
+++ b/toolkit/devtools/server/actors/script.js
@@ -1370,17 +1370,30 @@ ThreadActor.prototype = {
       return { type: "paused", why: { type: "alreadyPaused" } };
     } else if (this.state != "running") {
       return { error: "wrongState",
                message: "Received interrupt request in " + this.state +
                         " state." };
     }
 
     try {
-      // Put ourselves in the paused state.
+      // If execution should pause just before the next JavaScript bytecode is
+      // executed, just set an onEnterFrame handler.
+      if (aRequest.when == "onNext") {
+        let pauseAndRespond = this._pauseAndRespond.bind(this);
+        let onEnterFrame = function(aFrame) {
+          return pauseAndRespond(aFrame, { type: "interrupted", onNext: true });
+        };
+        this.dbg.onEnterFrame = onEnterFrame;
+
+        return { type: "willInterrupt" };
+      }
+
+      // If execution should pause immediately, just put ourselves in the paused
+      // state.
       let packet = this._paused();
       if (!packet) {
         return { error: "notInterrupted" };
       }
       packet.why = { type: "interrupted" };
 
       // Send the response to the interrupt request now (rather than
       // returning it), because we're going to start a nested event loop
