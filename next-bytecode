# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f0a2a2b0f06d71e71b1d082bd036009a3546a8de
Bug 789430 - Pause on next bytecode instead of immediately;r=fitzgen

diff --git a/browser/devtools/debugger/debugger-controller.js b/browser/devtools/debugger/debugger-controller.js
--- a/browser/devtools/debugger/debugger-controller.js
+++ b/browser/devtools/debugger/debugger-controller.js
@@ -690,17 +690,20 @@ StackFrames.prototype = {
         } else if (aPacket.why.frameFinished.return) {
           this._currentReturnedValue = aPacket.why.frameFinished.return;
         }
         break;
       // If paused by an explicit interrupt, which are generated by the slow
       // script dialog and internal events such as setting breakpoints, ignore
       // the event to avoid UI flicker.
       case "interrupted":
-        return;
+        if (!aPacket.why.onNext) {
+          return;
+        }
+        break;
     }
 
     this.activeThread.fillFrames(CALL_STACK_PAGE_SIZE);
     DebuggerView.editor.focus();
   },
 
   /**
    * Handler for the thread client's resumed notification.
diff --git a/browser/devtools/debugger/test/mochitest/browser.ini b/browser/devtools/debugger/test/mochitest/browser.ini
--- a/browser/devtools/debugger/test/mochitest/browser.ini
+++ b/browser/devtools/debugger/test/mochitest/browser.ini
@@ -137,16 +137,18 @@ skip-if = e10s || true # bug 1113935
 [browser_dbg_blackboxing-01.js]
 [browser_dbg_blackboxing-02.js]
 [browser_dbg_blackboxing-03.js]
 [browser_dbg_blackboxing-04.js]
 [browser_dbg_blackboxing-05.js]
 [browser_dbg_blackboxing-06.js]
 [browser_dbg_breadcrumbs-access.js]
 [browser_dbg_break-in-anon.js]
+[browser_dbg_break-on-next.js]
+[browser_dbg_break-on-next-console.js]
 [browser_dbg_break-on-dom-01.js]
 [browser_dbg_break-on-dom-02.js]
 [browser_dbg_break-on-dom-03.js]
 [browser_dbg_break-on-dom-04.js]
 [browser_dbg_break-on-dom-05.js]
 [browser_dbg_break-on-dom-06.js]
 [browser_dbg_break-on-dom-07.js]
 [browser_dbg_break-on-dom-08.js]
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_break-on-next-console.js b/browser/devtools/debugger/test/mochitest/browser_dbg_break-on-next-console.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_break-on-next-console.js
@@ -0,0 +1,60 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Test if 'break on next' functionality works from executions
+ * in content triggered by the console in the toolbox.
+ */
+
+const TAB_URL = EXAMPLE_URL + "doc_script-eval.html";
+
+function test() {
+  let gTab, gPanel, gDebugger;
+  let gSources, gBreakpoints, gTarget, gResumeButton, gResumeKey, gThreadClient;
+
+  initDebugger(TAB_URL).then(([aTab,, aPanel]) => {
+    gTab = aTab;
+    gPanel = aPanel;
+    gDebugger = gPanel.panelWin;
+    gSources = gDebugger.DebuggerView.Sources;
+    gBreakpoints = gDebugger.DebuggerController.Breakpoints;
+    gTarget = gDebugger.gTarget;
+    gThreadClient = gDebugger.gThreadClient;
+    gResumeButton = gDebugger.document.getElementById("resume");
+    gResumeKey = gDebugger.document.getElementById("resumeKey");
+
+    waitForSourceShown(gPanel, "-eval.js")
+      .then(testConsole)
+      .then(() => closeDebuggerAndFinish(gPanel));
+  });
+
+  let testConsole = Task.async(function*() {
+    info("Starting testConsole");
+
+    let oncePaused = gTarget.once("thread-paused");
+    EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    let jsterm = yield getSplitConsole();
+    let executed = jsterm.execute("1+1");
+    yield oncePaused;
+
+    // // XXX: Check call stack / scope variables
+
+    let onceResumed = gTarget.once("thread-resumed");
+    EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    yield onceResumed;
+
+    yield executed;
+  });
+
+  function getSplitConsole() {
+    return new Promise(resolve => {
+      let toolbox = gDevTools.getToolbox(gPanel.target);
+      toolbox.once("webconsole-ready", () => {
+        ok(toolbox.splitConsole, "Split console is shown.");
+        let jsterm = toolbox.getPanel("webconsole").hud.jsterm;
+        resolve(jsterm);
+      });
+      EventUtils.synthesizeKey("VK_ESCAPE", {}, gDebugger);
+    });
+  }
+}
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_break-on-next.js b/browser/devtools/debugger/test/mochitest/browser_dbg_break-on-next.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_break-on-next.js
@@ -0,0 +1,77 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Test if 'break on next' functionality works from executions
+ * in content that are triggered by the page and also by entry
+ * into the console in the toolbox.
+ */
+
+const TAB_URL = EXAMPLE_URL + "doc_script-eval.html";
+
+function test() {
+  let gTab, gPanel, gDebugger;
+  let gSources, gBreakpoints, gTarget, gResumeButton, gResumeKey, gThreadClient;
+
+  initDebugger(TAB_URL).then(([aTab,, aPanel]) => {
+    gTab = aTab;
+    gPanel = aPanel;
+    gDebugger = gPanel.panelWin;
+    gSources = gDebugger.DebuggerView.Sources;
+    gBreakpoints = gDebugger.DebuggerController.Breakpoints;
+    gTarget = gDebugger.gTarget;
+    gThreadClient = gDebugger.gThreadClient;
+    gResumeButton = gDebugger.document.getElementById("resume");
+    gResumeKey = gDebugger.document.getElementById("resumeKey");
+
+    waitForSourceShown(gPanel, "-eval.js")
+      .then(testInterval)
+      .then(testEvent)
+      .then(() => closeDebuggerAndFinish(gPanel));
+  });
+
+  // XX: capture an interval from the page (a non-anon source)
+
+
+  // Testing an interval instead of a timeout / rAF because
+  // it's less likely to fail due to timing issues.  If the
+  // first callback happens to fire before the break request
+  // happens then we'll just get it next time.
+  let testInterval = Task.async(function*() {
+    info("Starting testInterval");
+
+    yield evalInTab(gTab, `
+      var interval = setInterval(function() {
+        return 1+1;
+      }, 100);
+    `);
+
+    let oncePaused = gTarget.once("thread-paused");
+    EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    yield oncePaused;
+    yield evalInTab(gTab, "clearInterval(interval)");
+
+    // XXX: Check call stack / scope variables
+
+    let onceResumed = gTarget.once("thread-resumed");
+    EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    yield onceResumed;
+  });
+
+  let testEvent = Task.async(function*() {
+    info("Starting testEvent");
+
+    let oncePaused = gTarget.once("thread-paused");
+    EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    executeSoon(() => {
+      generateMouseClickInTab(gTab, "content.document.querySelector('button')");
+    });
+    yield oncePaused;
+
+    // XXX: Check call stack / scope variables
+
+    let onceResumed = gTarget.once("thread-resumed");
+    EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    yield onceResumed;
+  });
+}
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_interrupts.js b/browser/devtools/debugger/test/mochitest/browser_dbg_interrupts.js
--- a/browser/devtools/debugger/test/mochitest/browser_dbg_interrupts.js
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_interrupts.js
@@ -50,36 +50,60 @@ function test() {
     let onceResumed = gTarget.once("thread-resumed");
     gThreadClient.resume();
     return onceResumed;
   }
 
   function testResumeButton() {
     info ("Pressing the resume button, expecting a thread-paused");
 
+    ok (!gResumeButton.hasAttribute("disabled"), "Resume button is not disabled");
+    ok (!gResumeButton.hasAttribute("break-on-next"), "Resume button isn't waiting for next execution");
     ok (!gResumeButton.hasAttribute("checked"), "Resume button is not checked");
     let oncePaused = gTarget.once("thread-paused");
+
+    // Click the pause button to break on next execution
     EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    ok (gResumeButton.hasAttribute("disabled"), "Resume button is disabled");
+    ok (gResumeButton.hasAttribute("break-on-next"), "Resume button is waiting for next execution");
+    ok (!gResumeButton.hasAttribute("checked"), "Resume button is not checked");
+
+    // Evaluate a script to fully pause the debugger
+    evalInTab(gTab, "1+1;");
 
     return oncePaused
       .then(() => {
+        ok (!gResumeButton.hasAttribute("break-on-next"), "Resume button isn't waiting for next execution");
         is (gResumeButton.getAttribute("checked"), "true", "Resume button is checked");
+        ok (!gResumeButton.hasAttribute("disabled"), "Resume button is not disabled");
       })
       .then(() => gThreadClient.resume())
       .then(() => ensureThreadClientState(gPanel, "resumed"))
   }
 
   function testResumeKeyboard() {
     let key = gResumeKey.getAttribute("keycode");
     info ("Triggering a pause with keyboard (" + key +  "), expecting a thread-paused");
 
+    ok (!gResumeButton.hasAttribute("disabled"), "Resume button is not disabled");
+    ok (!gResumeButton.hasAttribute("break-on-next"), "Resume button isn't waiting for next execution");
     ok (!gResumeButton.hasAttribute("checked"), "Resume button is not checked");
     let oncePaused = gTarget.once("thread-paused");
+
+    // Press the key to break on next execution
     EventUtils.synthesizeKey(key, { }, gDebugger);
+    ok (gResumeButton.hasAttribute("disabled"), "Resume button is disabled");
+    ok (gResumeButton.hasAttribute("break-on-next"), "Resume button is waiting for next execution");
+    ok (!gResumeButton.hasAttribute("checked"), "Resume button is not checked");
+
+    // Evaluate a script to fully pause the debugger
+    evalInTab(gTab, "1+1;");
 
     return oncePaused
       .then(() => {
+        ok (!gResumeButton.hasAttribute("break-on-next"), "Resume button isn't waiting for next execution");
         is (gResumeButton.getAttribute("checked"), "true", "Resume button is checked");
+        ok (!gResumeButton.hasAttribute("disabled"), "Resume button is not disabled");
       })
       .then(() => gThreadClient.resume())
       .then(() => ensureThreadClientState(gPanel, "resumed"))
   }
 }
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-highlight.js b/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-highlight.js
--- a/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-highlight.js
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-highlight.js
@@ -43,16 +43,19 @@ function testPause() {
          gToolboxTab.getAttribute("selected") == "true",
         "...and the tab is selected, so the glow will not be present.");
     }).then(testResume);
   });
 
   EventUtils.sendMouseEvent({ type: "mousedown" },
     gDebugger.document.getElementById("resume"),
     gDebugger);
+
+  // Evaluate a script to fully pause the debugger
+  evalInTab(gTab, "1+1;");
 }
 
 function testResume() {
   gDebugger.gThreadClient.addOneTimeListener("resumed", () => {
     gToolbox.selectTool("webconsole").then(() => {
       ok(!gToolboxTab.classList.contains("highlighted"),
         "The highlighted class is not present now after the resume");
       ok(!gToolboxTab.hasAttribute("selected") ||
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-raise.js b/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-raise.js
--- a/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-raise.js
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_on-pause-raise.js
@@ -91,16 +91,19 @@ function testPause() {
          gToolboxTab.getAttribute("selected") == "true",
         "...and the tab is selected, so the glow will not be present.");
     }).then(testResume);
   });
 
   EventUtils.sendMouseEvent({ type: "mousedown" },
     gDebugger.document.getElementById("resume"),
     gDebugger);
+
+  // Evaluate a script to fully pause the debugger
+  evalInTab(gTab, "1+1;");
 }
 
 function testResume() {
   gDebugger.gThreadClient.addOneTimeListener("resumed", () => {
     gToolbox.selectTool("webconsole").then(() => {
       ok(!gToolboxTab.hasAttribute("highlighted") ||
           gToolboxTab.getAttribute("highlighted") != "true",
         "The highlighted class is not present now after the resume");
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_pause-no-step.js b/browser/devtools/debugger/test/mochitest/browser_dbg_pause-no-step.js
--- a/browser/devtools/debugger/test/mochitest/browser_dbg_pause-no-step.js
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_pause-no-step.js
@@ -1,23 +1,25 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 /**
- * Tests if stepping only is enabled when paused with a location
+ * Tests that pausing / stepping is only enabled when there is a
+ * location.
  */
 
 const TAB_URL = EXAMPLE_URL + "doc_pause-exceptions.html";
 
-let gPanel, gDebugger;
+let gTab, gPanel, gDebugger;
 let gResumeButton, gStepOverButton, gStepOutButton, gStepInButton;
 let gResumeKey, gFrames;
 
 function test() {
   initDebugger(TAB_URL).then(([aTab,, aPanel]) => {
+    gTab = aTab;
     gPanel = aPanel;
     gDebugger = gPanel.panelWin;
     gResumeButton = gDebugger.document.getElementById("resume");
     gStepOverButton = gDebugger.document.getElementById("step-over");
     gStepInButton = gDebugger.document.getElementById("step-in");
     gStepOutButton = gDebugger.document.getElementById("step-out");
     gResumeKey = gDebugger.document.getElementById("resumeKey");
     gFrames = gDebugger.DebuggerView.StackFrames;
@@ -28,34 +30,41 @@ function test() {
 
 function testPause() {
   ok(!gDebugger.gThreadClient.paused, "Should be running after starting the test.");
   ok(gStepOutButton.disabled, "Stepping out button should be disabled");
   ok(gStepInButton.disabled, "Stepping in button should be disabled");
   ok(gStepOverButton.disabled, "Stepping over button should be disabled");
 
   gDebugger.gThreadClient.addOneTimeListener("paused", () => {
-    // Nothing should happen here because the button is disabled. If
-    // this runs any code, there will be errors and the test will fail.
-    EventUtils.sendMouseEvent({ type: "mousedown" }, gStepOverButton, gDebugger);
-
     ok(gDebugger.gThreadClient.paused,
        "Should be paused after an interrupt request.");
 
-    ok(gStepOutButton.disabled, "Stepping out button should still be disabled");
-    ok(gStepInButton.disabled, "Stepping in button should still be disabled");
-    ok(gStepOverButton.disabled, "Stepping over button should still be disabled");
+    ok(!gStepOutButton.disabled, "Stepping out button should be enabled");
+    ok(!gStepInButton.disabled, "Stepping in button should be enabled");
+    ok(!gStepOverButton.disabled, "Stepping over button should be enabled");
 
-    is(gFrames.itemCount, 0,
-       "Should have no frames when paused in the main loop.");
+    waitForDebuggerEvents(gPanel, gDebugger.EVENTS.AFTER_FRAMES_REFILLED).then(() => {
+      is(gFrames.itemCount, 1,
+         "Should have 1 frame from the evalInTab call.");
+      gDebugger.gThreadClient.resume(testBreakAtLocation);
+    });
 
-    gDebugger.gThreadClient.resume(testBreakAtLocation);
   });
 
   EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+
+  ok(!gDebugger.gThreadClient.paused,
+    "Shouldn't be paused until the next script is executed.");
+  ok(gStepOutButton.disabled, "Stepping out button should be disabled");
+  ok(gStepInButton.disabled, "Stepping in button should be disabled");
+  ok(gStepOverButton.disabled, "Stepping over button should be disabled");
+
+  // Evaluate a script to fully pause the debugger
+  evalInTab(gTab, "1+1;");
 }
 
 function testBreakAtLocation() {
   gDebugger.gThreadClient.addOneTimeListener("paused", () => {
     ok(!gStepOutButton.disabled, "Stepping out button should be enabled");
     ok(!gStepInButton.disabled, "Stepping in button should be enabled");
     ok(!gStepOverButton.disabled, "Stepping over button should be enabled");
 
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_pause-resume.js b/browser/devtools/debugger/test/mochitest/browser_dbg_pause-resume.js
--- a/browser/devtools/debugger/test/mochitest/browser_dbg_pause-resume.js
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_pause-resume.js
@@ -43,16 +43,23 @@ function testPause() {
 
     is(gFrames.itemCount, 0,
       "Should have no frames when paused in the main loop.");
 
     testResume();
   });
 
   EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+
+  is(gResumeButton.getAttribute("tooltiptext"),
+     gDebugger.L10N.getFormatStr("pausePendingButtonTooltip"),
+    "Button tooltip should be 'waiting for execution' when breaking on nex.");
+
+  // Evaluate a script to fully pause the debugger
+  evalInTab(gTab, "1+1;");
 }
 
 function testResume() {
   gDebugger.gThreadClient.addOneTimeListener("resumed", () => {
     is(gDebugger.gThreadClient.paused, false,
       "Should be paused after an interrupt request.");
 
     is(gResumeButton.getAttribute("tooltiptext"),
diff --git a/browser/devtools/debugger/test/mochitest/browser_dbg_pause-warning.js b/browser/devtools/debugger/test/mochitest/browser_dbg_pause-warning.js
--- a/browser/devtools/debugger/test/mochitest/browser_dbg_pause-warning.js
+++ b/browser/devtools/debugger/test/mochitest/browser_dbg_pause-warning.js
@@ -31,16 +31,19 @@ function testPause() {
       inspector.once("inspector-updated").then(testNotificationIsUp1);
     });
     gToolbox.selectTool("inspector");
   });
 
   EventUtils.sendMouseEvent({ type: "mousedown" },
     gDebugger.document.getElementById("resume"),
     gDebugger);
+
+  // Evaluate a script to fully pause the debugger
+  evalInTab(gTab, "1+1;");
 }
 
 function testNotificationIsUp1() {
   let notificationBox = gToolbox.getNotificationBox();
   let notification = notificationBox.getNotificationWithValue("inspector-script-paused");
 
   ok(notification,
     "Inspector notification is present (1).");
diff --git a/browser/devtools/debugger/views/toolbar-view.js b/browser/devtools/debugger/views/toolbar-view.js
--- a/browser/devtools/debugger/views/toolbar-view.js
+++ b/browser/devtools/debugger/views/toolbar-view.js
@@ -46,16 +46,17 @@ ToolbarView.prototype = {
     this._resumeOrderTooltip.defaultPosition = TOOLBAR_ORDER_POPUP_POSITION;
 
     let resumeKey = ShortcutUtils.prettifyShortcut(document.getElementById("resumeKey"));
     let stepOverKey = ShortcutUtils.prettifyShortcut(document.getElementById("stepOverKey"));
     let stepInKey = ShortcutUtils.prettifyShortcut(document.getElementById("stepInKey"));
     let stepOutKey = ShortcutUtils.prettifyShortcut(document.getElementById("stepOutKey"));
     this._resumeTooltip = L10N.getFormatStr("resumeButtonTooltip", resumeKey);
     this._pauseTooltip = L10N.getFormatStr("pauseButtonTooltip", resumeKey);
+    this._pausePendingTooltip = L10N.getFormatStr("pausePendingButtonTooltip");
     this._stepOverTooltip = L10N.getFormatStr("stepOverTooltip", stepOverKey);
     this._stepInTooltip = L10N.getFormatStr("stepInTooltip", stepInKey);
     this._stepOutTooltip = L10N.getFormatStr("stepOutTooltip", stepOutKey);
 
     this._instrumentsPaneToggleButton.addEventListener("mousedown", this._onTogglePanesPressed, false);
     this._resumeButton.addEventListener("mousedown", this._onResumePressed, false);
     this._stepOverButton.addEventListener("mousedown", this._onStepOverPressed, false);
     this._stepInButton.addEventListener("mousedown", this._onStepInPressed, false);
@@ -107,21 +108,33 @@ ToolbarView.prototype = {
     this._resumeOrderTooltip.setTextContent({ messages: [label], isAlertTooltip: true });
     this._resumeOrderTooltip.show(this._resumeButton);
   },
 
   /**
    * Sets the resume button state based on the debugger active thread.
    *
    * @param string aState
-   *        Either "paused" or "attached".
+   *        Either "paused", "attached", or "breakOnNext".
    * @param boolean hasLocation
    *        True if we are paused at a specific JS location
    */
   toggleResumeButtonState: function(aState, hasLocation) {
+    // Intermidiate state after pressing the pause button and waiting
+    // for the next script execution to happen.
+    if (aState == "breakOnNext") {
+      this._resumeButton.setAttribute("break-on-next", "true");
+      this._resumeButton.disabled = true;
+      this._resumeButton.setAttribute("tooltiptext", this._pausePendingTooltip);
+      return;
+    }
+
+    this._resumeButton.removeAttribute("break-on-next");
+    this._resumeButton.disabled = false;
+
     // If we're paused, check and show a resume label on the button.
     if (aState == "paused") {
       this._resumeButton.setAttribute("checked", "true");
       this._resumeButton.setAttribute("tooltiptext", this._resumeTooltip);
 
       // Only enable the stepping buttons if we are paused at a
       // specific location. After bug 789430, we'll always be paused
       // at a location, but currently you can pause the entire engine
@@ -130,28 +143,28 @@ ToolbarView.prototype = {
         this._toggleButtonsState({ enabled: true });
       }
     }
     // If we're attached, do the opposite.
     else if (aState == "attached") {
       this._resumeButton.removeAttribute("checked");
       this._resumeButton.setAttribute("tooltiptext", this._pauseTooltip);
       this._toggleButtonsState({ enabled: false });
-   }
+    }
   },
 
   _toggleButtonsState: function({ enabled }) {
     const buttons = [
       this._stepOutButton,
       this._stepInButton,
       this._stepOverButton
     ];
     for (let button of buttons) {
       button.disabled = !enabled;
-    };
+    }
   },
 
   /**
    * Listener handling the toggle button click event.
    */
   _onTogglePanesPressed: function() {
     DebuggerView.toggleInstrumentsPane({
       visible: DebuggerView.instrumentsPaneHidden,
@@ -159,26 +172,28 @@ ToolbarView.prototype = {
       delayed: true
     });
   },
 
   /**
    * Listener handling the pause/resume button click event.
    */
   _onResumePressed: function() {
-    if (this.StackFrames._currentFrameDescription != FRAME_TYPE.NORMAL) {
+    if (this.StackFrames._currentFrameDescription != FRAME_TYPE.NORMAL ||
+        this._resumeButton.disabled) {
       return;
     }
 
     if (this.activeThread.paused) {
       this.StackFrames.currentFrameDepth = -1;
       this.activeThread.resume(this.resumptionWarnFunc);
     } else {
       this.ThreadState.interruptedByResumeButton = true;
-      this.activeThread.interrupt();
+      this.toggleResumeButtonState("breakOnNext");
+      this.activeThread.breakOnNext();
     }
   },
 
   /**
    * Listener handling the step over button click event.
    */
   _onStepOverPressed: function() {
     if (this.activeThread.paused && !this._stepOverButton.disabled) {
diff --git a/browser/devtools/framework/gDevTools.jsm b/browser/devtools/framework/gDevTools.jsm
--- a/browser/devtools/framework/gDevTools.jsm
+++ b/browser/devtools/framework/gDevTools.jsm
@@ -878,31 +878,31 @@ let gDevToolsBrowser = {
       gDevTools.showToolbox(target, "jsdebugger").then(toolbox => {
         let threadClient = toolbox.getCurrentPanel().panelWin.gThreadClient;
 
         // Break in place, which means resuming the debuggee thread and pausing
         // right before the next step happens.
         switch (threadClient.state) {
           case "paused":
             // When the debugger is already paused.
-            threadClient.breakOnNext();
+            threadClient.resumeThenPause();
             aCallback();
             break;
           case "attached":
             // When the debugger is already open.
             threadClient.interrupt(() => {
-              threadClient.breakOnNext();
+              threadClient.resumeThenPause();
               aCallback();
             });
             break;
           case "resuming":
             // The debugger is newly opened.
             threadClient.addOneTimeListener("resumed", () => {
               threadClient.interrupt(() => {
-                threadClient.breakOnNext();
+                threadClient.resumeThenPause();
                 aCallback();
               });
             });
             break;
           default:
             throw Error("invalid thread client state in slow script debug handler: " +
                         threadClient.state);
           }
diff --git a/browser/locales/en-US/chrome/browser/devtools/debugger.properties b/browser/locales/en-US/chrome/browser/devtools/debugger.properties
--- a/browser/locales/en-US/chrome/browser/devtools/debugger.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/debugger.properties
@@ -41,21 +41,25 @@ debuggerMenu.accesskey=D
 # LOCALIZATION NOTE (collapsePanes): This is the tooltip for the button
 # that collapses the left and right panes in the debugger UI.
 collapsePanes=Collapse panes
 
 # LOCALIZATION NOTE (expandPanes): This is the tooltip for the button
 # that expands the left and right panes in the debugger UI.
 expandPanes=Expand panes
 
-# LOCALIZATION NOTE (pauseLabel): The label that is displayed on the pause
+# LOCALIZATION NOTE (pauseButtonTooltip): The tooltip that is displayed for the pause
 # button when the debugger is in a running state.
 pauseButtonTooltip=Click to pause (%S)
 
-# LOCALIZATION NOTE (resumeLabel): The label that is displayed on the pause
+# LOCALIZATION NOTE (pausePendingButtonTooltip): The tooltip that is displayed for
+# the pause button after it's been clicked but before the next JavaScript to run.
+pausePendingButtonTooltip=Waiting for next execution
+
+# LOCALIZATION NOTE (resumeButtonTooltip): The label that is displayed on the pause
 # button when the debugger is in a paused state.
 resumeButtonTooltip=Click to resume (%S)
 
 # LOCALIZATION NOTE (startTracingTooltip): The label that is displayed on the trace
 # button when execution tracing is stopped.
 startTracingTooltip=Click to start tracing
 
 # LOCALIZATION NOTE (stopTracingTooltip): The label that is displayed on the trace
diff --git a/browser/themes/shared/devtools/debugger.css b/browser/themes/shared/devtools/debugger.css
--- a/browser/themes/shared/devtools/debugger.css
+++ b/browser/themes/shared/devtools/debugger.css
@@ -576,17 +576,22 @@
   }
 }
 
 #debugger-controls toolbarbutton {
   transition: opacity 0.15s ease-in-out;
 }
 
 #debugger-controls toolbarbutton[disabled] {
-    opacity: .5;
+  opacity: .5;
+  transition: none;
+}
+
+#resume[break-on-next] {
+  background: var(--theme-highlight-lightorange);
 }
 
 #step-over {
   list-style-image: url(debugger-step-over.png);
 }
 
 #step-in {
   list-style-image: url(debugger-step-in.png);
diff --git a/toolkit/devtools/client/main.js b/toolkit/devtools/client/main.js
--- a/toolkit/devtools/client/main.js
+++ b/toolkit/devtools/client/main.js
@@ -1656,17 +1656,17 @@ ThreadClient.prototype = {
   },
 
   /**
    * Resume then pause without stepping.
    *
    * @param function aOnResponse
    *        Called with the response packet.
    */
-  breakOnNext: function (aOnResponse) {
+  resumeThenPause: function (aOnResponse) {
     this._doResume({ type: "break" }, aOnResponse);
   },
 
   /**
    * Step over a function call.
    *
    * @param function aOnResponse
    *        Called with the response packet.
@@ -1691,23 +1691,44 @@ ThreadClient.prototype = {
    * @param function aOnResponse
    *        Called with the response packet.
    */
   stepOut: function (aOnResponse) {
     this._doResume({ type: "finish" }, aOnResponse);
   },
 
   /**
+   * Immediately interrupt a running thread.
+   *
+   * @param function aOnResponse
+   *        Called with the response packet.
+   */
+  interrupt: function(aOnResponse) {
+    this._doInterrupt(null, aOnResponse);
+  },
+
+  /**
+   * Pause execution right before the next JavaScript bytecode is executed.
+   *
+   * @param function aOnResponse
+   *        Called with the response packet.
+   */
+  breakOnNext: function(aOnResponse) {
+    this._doInterrupt("onNext", aOnResponse);
+  },
+
+  /**
    * Interrupt a running thread.
    *
    * @param function aOnResponse
    *        Called with the response packet.
    */
-  interrupt: DebuggerClient.requester({
-    type: "interrupt"
+  _doInterrupt: DebuggerClient.requester({
+    type: "interrupt",
+    when: args(0)
   }, {
     telemetry: "INTERRUPT"
   }),
 
   /**
    * Enable or disable pausing when an exception is thrown.
    *
    * @param boolean aFlag
diff --git a/toolkit/devtools/server/actors/script.js b/toolkit/devtools/server/actors/script.js
--- a/toolkit/devtools/server/actors/script.js
+++ b/toolkit/devtools/server/actors/script.js
@@ -1370,17 +1370,29 @@ ThreadActor.prototype = {
       return { type: "paused", why: { type: "alreadyPaused" } };
     } else if (this.state != "running") {
       return { error: "wrongState",
                message: "Received interrupt request in " + this.state +
                         " state." };
     }
 
     try {
-      // Put ourselves in the paused state.
+      // If execution should pause just before the next JavaScript bytecode is
+      // executed, just set an onEnterFrame handler.
+      if (aRequest.when == "onNext") {
+        let onEnterFrame = (aFrame) => {
+          return this._pauseAndRespond(aFrame, { type: "interrupted", onNext: true });
+        };
+        this.dbg.onEnterFrame = onEnterFrame;
+
+        return { type: "willInterrupt" };
+      }
+
+      // If execution should pause immediately, just put ourselves in the paused
+      // state.
       let packet = this._paused();
       if (!packet) {
         return { error: "notInterrupted" };
       }
       packet.why = { type: "interrupted" };
 
       // Send the response to the interrupt request now (rather than
       // returning it), because we're going to start a nested event loop
