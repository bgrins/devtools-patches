# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  698d20c94746543bcfece4766a440e0d78f90e85
Bug 789430 - Pause on next bytecode instead of immediately;r=fitzgen

diff --git a/browser/devtools/debugger/debugger-controller.js b/browser/devtools/debugger/debugger-controller.js
--- a/browser/devtools/debugger/debugger-controller.js
+++ b/browser/devtools/debugger/debugger-controller.js
@@ -687,17 +687,20 @@ StackFrames.prototype = {
         } else if (aPacket.why.frameFinished.return) {
           this._currentReturnedValue = aPacket.why.frameFinished.return;
         }
         break;
       // If paused by an explicit interrupt, which are generated by the slow
       // script dialog and internal events such as setting breakpoints, ignore
       // the event to avoid UI flicker.
       case "interrupted":
-        return;
+        if (!aPacket.why.onNext) {
+          return;
+        }
+        break;
     }
 
     this.activeThread.fillFrames(CALL_STACK_PAGE_SIZE);
     DebuggerView.editor.focus();
   },
 
   /**
    * Handler for the thread client's resumed notification.
diff --git a/browser/devtools/debugger/test/browser_dbg_interrupts.js b/browser/devtools/debugger/test/browser_dbg_interrupts.js
--- a/browser/devtools/debugger/test/browser_dbg_interrupts.js
+++ b/browser/devtools/debugger/test/browser_dbg_interrupts.js
@@ -50,26 +50,35 @@ function test() {
     let onceResumed = gTarget.once("thread-resumed");
     gThreadClient.resume();
     return onceResumed;
   }
 
   function testResumeButton() {
     info ("Pressing the resume button, expecting a thread-paused");
 
+    ok (!gResumeButton.hasAttribute("disabled"), "Resume button is not disabled");
     ok (!gResumeButton.hasAttribute("checked"), "Resume button is not checked");
     let oncePaused = gTarget.once("thread-paused");
+    setTimeout(() => {
     EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
+    }, 1000);
 
-    return oncePaused
-      .then(() => {
-        is (gResumeButton.getAttribute("checked"), "true", "Resume button is checked");
-      })
-      .then(() => gThreadClient.resume())
-      .then(() => ensureThreadClientState(gPanel, "resumed"))
+    // Run a function in content to force the thread to pause
+    // ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+    //   console.log(1+1);
+    // });
+
+    return new Promise(() => {});
+    // return oncePaused
+    //   .then(() => {
+    //     is (gResumeButton.getAttribute("checked"), "true", "Resume button is checked");
+    //   })
+    //   .then(() => gThreadClient.resume())
+    //   .then(() => ensureThreadClientState(gPanel, "resumed"))
   }
 
   function testResumeKeyboard() {
     let key = gResumeKey.getAttribute("keycode");
     info ("Triggering a pause with keyboard (" + key +  "), expecting a thread-paused");
 
     ok (!gResumeButton.hasAttribute("checked"), "Resume button is not checked");
     let oncePaused = gTarget.once("thread-paused");
diff --git a/browser/devtools/debugger/views/toolbar-view.js b/browser/devtools/debugger/views/toolbar-view.js
--- a/browser/devtools/debugger/views/toolbar-view.js
+++ b/browser/devtools/debugger/views/toolbar-view.js
@@ -107,21 +107,34 @@ ToolbarView.prototype = {
     this._resumeOrderTooltip.setTextContent({ messages: [label], isAlertTooltip: true });
     this._resumeOrderTooltip.show(this._resumeButton);
   },
 
   /**
    * Sets the resume button state based on the debugger active thread.
    *
    * @param string aState
-   *        Either "paused" or "attached".
+   *        Either "paused", "attached", or "breakOnNext".
    * @param boolean hasLocation
    *        True if we are paused at a specific JS location
    */
   toggleResumeButtonState: function(aState, hasLocation) {
+    // Intermidiate state after pressing the pause button and waiting
+    // for the next script execution to happen.
+    if (aState == "breakOnNext") {
+      this._resumeButton.setAttribute("break-on-next", "true");
+      this._resumeButton.disabled = true;
+      // XXX: Adjust tooltip text to indicate that it will break on next
+      // execution.
+      return;
+    }
+
+    this._resumeButton.removeAttribute("break-on-next");
+    this._resumeButton.disabled = false;
+
     // If we're paused, check and show a resume label on the button.
     if (aState == "paused") {
       this._resumeButton.setAttribute("checked", "true");
       this._resumeButton.setAttribute("tooltiptext", this._resumeTooltip);
 
       // Only enable the stepping buttons if we are paused at a
       // specific location. After bug 789430, we'll always be paused
       // at a location, but currently you can pause the entire engine
@@ -130,28 +143,28 @@ ToolbarView.prototype = {
         this._toggleButtonsState({ enabled: true });
       }
     }
     // If we're attached, do the opposite.
     else if (aState == "attached") {
       this._resumeButton.removeAttribute("checked");
       this._resumeButton.setAttribute("tooltiptext", this._pauseTooltip);
       this._toggleButtonsState({ enabled: false });
-   }
+    }
   },
 
   _toggleButtonsState: function({ enabled }) {
     const buttons = [
       this._stepOutButton,
       this._stepInButton,
       this._stepOverButton
     ];
     for (let button of buttons) {
       button.disabled = !enabled;
-    };
+    }
   },
 
   /**
    * Listener handling the toggle button click event.
    */
   _onTogglePanesPressed: function() {
     DebuggerView.toggleInstrumentsPane({
       visible: DebuggerView.instrumentsPaneHidden,
@@ -159,26 +172,28 @@ ToolbarView.prototype = {
       delayed: true
     });
   },
 
   /**
    * Listener handling the pause/resume button click event.
    */
   _onResumePressed: function() {
-    if (this.StackFrames._currentFrameDescription != FRAME_TYPE.NORMAL) {
+    if (this.StackFrames._currentFrameDescription != FRAME_TYPE.NORMAL ||
+        this._resumeButton.disabled) {
       return;
     }
 
     if (this.activeThread.paused) {
       this.StackFrames.currentFrameDepth = -1;
       this.activeThread.resume(this.resumptionWarnFunc);
     } else {
       this.ThreadState.interruptedByResumeButton = true;
-      this.activeThread.interrupt();
+      this.toggleResumeButtonState("breakOnNext");
+      this.activeThread.breakOnNext();
     }
   },
 
   /**
    * Listener handling the step over button click event.
    */
   _onStepOverPressed: function() {
     if (this.activeThread.paused && !this._stepOverButton.disabled) {
diff --git a/browser/devtools/framework/gDevTools.jsm b/browser/devtools/framework/gDevTools.jsm
--- a/browser/devtools/framework/gDevTools.jsm
+++ b/browser/devtools/framework/gDevTools.jsm
@@ -879,31 +879,31 @@ let gDevToolsBrowser = {
       gDevTools.showToolbox(target, "jsdebugger").then(toolbox => {
         let threadClient = toolbox.getCurrentPanel().panelWin.gThreadClient;
 
         // Break in place, which means resuming the debuggee thread and pausing
         // right before the next step happens.
         switch (threadClient.state) {
           case "paused":
             // When the debugger is already paused.
-            threadClient.breakOnNext();
+            threadClient.resumeThenPause();
             aCallback();
             break;
           case "attached":
             // When the debugger is already open.
             threadClient.interrupt(() => {
-              threadClient.breakOnNext();
+              threadClient.resumeThenPause();
               aCallback();
             });
             break;
           case "resuming":
             // The debugger is newly opened.
             threadClient.addOneTimeListener("resumed", () => {
               threadClient.interrupt(() => {
-                threadClient.breakOnNext();
+                threadClient.resumeThenPause();
                 aCallback();
               });
             });
             break;
           default:
             throw Error("invalid thread client state in slow script debug handler: " +
                         threadClient.state);
           }
diff --git a/browser/themes/shared/devtools/debugger.css b/browser/themes/shared/devtools/debugger.css
--- a/browser/themes/shared/devtools/debugger.css
+++ b/browser/themes/shared/devtools/debugger.css
@@ -576,17 +576,22 @@
   }
 }
 
 #debugger-controls toolbarbutton {
   transition: opacity 0.15s ease-in-out;
 }
 
 #debugger-controls toolbarbutton[disabled] {
-    opacity: .5;
+  opacity: .5;
+  transition: none;
+}
+
+#resume[break-on-next] {
+  background: var(--theme-highlight-green);
 }
 
 #step-over {
   list-style-image: url(debugger-step-over.png);
 }
 
 #step-in {
   list-style-image: url(debugger-step-in.png);
diff --git a/toolkit/devtools/client/main.js b/toolkit/devtools/client/main.js
--- a/toolkit/devtools/client/main.js
+++ b/toolkit/devtools/client/main.js
@@ -956,16 +956,19 @@ DebuggerClient.prototype = {
         let resumption = { from: thread._actor, type: "resumed" };
         thread._onThreadState(resumption);
       }
     }
 
     // Only try to notify listeners on events, not responses to requests
     // that lack a packet type.
     if (aPacket.type) {
+      if (aPacket.type != "consoleAPICall") {
+        console.log("Emitting packet of type", aPacket.type, aPacket);
+      }
       this.emit(aPacket.type, aPacket);
     }
 
     if (activeRequest) {
       let emitReply = () => activeRequest.emit("json-reply", aPacket);
       if (activeRequest.stack) {
         Cu.callFunctionWithAsyncStack(emitReply, activeRequest.stack,
                                       "DevTools RDP");
@@ -1656,17 +1659,17 @@ ThreadClient.prototype = {
   },
 
   /**
    * Resume then pause without stepping.
    *
    * @param function aOnResponse
    *        Called with the response packet.
    */
-  breakOnNext: function (aOnResponse) {
+  resumeThenPause: function (aOnResponse) {
     this._doResume({ type: "break" }, aOnResponse);
   },
 
   /**
    * Step over a function call.
    *
    * @param function aOnResponse
    *        Called with the response packet.
@@ -1691,23 +1694,44 @@ ThreadClient.prototype = {
    * @param function aOnResponse
    *        Called with the response packet.
    */
   stepOut: function (aOnResponse) {
     this._doResume({ type: "finish" }, aOnResponse);
   },
 
   /**
+   * Immediately interrupt a running thread.
+   *
+   * @param function aOnResponse
+   *        Called with the response packet.
+   */
+  interrupt: function(aOnResponse) {
+    this._doInterrupt(null, aOnResponse);
+  },
+
+  /**
+   * Pause execution right before the next JavaScript bytecode is executed.
+   *
+   * @param function aOnResponse
+   *        Called with the response packet.
+   */
+  breakOnNext: function(aOnResponse) {
+    this._doInterrupt("onNext", aOnResponse);
+  },
+
+  /**
    * Interrupt a running thread.
    *
    * @param function aOnResponse
    *        Called with the response packet.
    */
-  interrupt: DebuggerClient.requester({
-    type: "interrupt"
+  _doInterrupt: DebuggerClient.requester({
+    type: "interrupt",
+    when: args(0)
   }, {
     telemetry: "INTERRUPT"
   }),
 
   /**
    * Enable or disable pausing when an exception is thrown.
    *
    * @param boolean aFlag
@@ -1726,17 +1750,17 @@ ThreadClient.prototype = {
     if (this.paused) {
       this.reconfigure({
         pauseOnExceptions: aPauseOnExceptions,
         ignoreCaughtExceptions: aIgnoreCaughtExceptions
       }, aOnResponse);
       return;
     }
     // Otherwise send the flag using a standard resume request.
-    this.interrupt(aResponse => {
+    this._doInterrupt(null, aResponse => {
       if (aResponse.error) {
         // Can't continue if pausing failed.
         aOnResponse(aResponse);
         return;
       }
       this.resume(aOnResponse);
     });
   },
@@ -1757,17 +1781,17 @@ ThreadClient.prototype = {
     this._pauseOnDOMEvents = events;
     // If the debuggee is paused, the value of the array will be communicated in
     // the next resumption. Otherwise we have to force a pause in order to send
     // the array.
     if (this.paused) {
       DevToolsUtils.executeSoon(() => onResponse({}));
       return;
     }
-    this.interrupt(response => {
+    this._doInterrupt(null, response => {
       // Can't continue if pausing failed.
       if (response.error) {
         onResponse(response);
         return;
       }
       this.resume(onResponse);
     });
   },
@@ -2757,17 +2781,17 @@ SourceClient.prototype = {
     };
 
     // If the debuggee is paused, just set the breakpoint.
     if (this._activeThread.paused) {
       doSetBreakpoint();
       return;
     }
     // Otherwise, force a pause in order to set the breakpoint.
-    this._activeThread.interrupt(aResponse => {
+    this._activeThread._doInterrupt(null, aResponse => {
       if (aResponse.error) {
         // Can't set the breakpoint if pausing failed.
         aOnResponse(aResponse);
         return;
       }
 
       const { type, why } = aResponse;
       const cleanUp = type == "paused" && why.type == "interrupted"
diff --git a/toolkit/devtools/server/actors/script.js b/toolkit/devtools/server/actors/script.js
--- a/toolkit/devtools/server/actors/script.js
+++ b/toolkit/devtools/server/actors/script.js
@@ -1029,18 +1029,17 @@ ThreadActor.prototype = {
         this._options.pauseOnExceptions = aRequest.pauseOnExceptions;
         this._options.ignoreCaughtExceptions = aRequest.ignoreCaughtExceptions;
         this.maybePauseOnExceptions();
         this._maybeListenToEvents(aRequest);
       }
 
       let packet = this._resumed();
       this._popThreadPause();
-      // Tell anyone who cares of the resume (as of now, that's the xpcshell
-      // harness)
+      // Tell subscribers about the resume (used by tool frontends and tests)
       if (Services.obs) {
         Services.obs.notifyObservers(this, "devtools-thread-resumed", null);
       }
       return packet;
     }, error => {
       return error instanceof Error
         ? { error: "unknownError",
             message: DevToolsUtils.safeErrorString(error) }
@@ -1370,17 +1369,30 @@ ThreadActor.prototype = {
       return { type: "paused", why: { type: "alreadyPaused" } };
     } else if (this.state != "running") {
       return { error: "wrongState",
                message: "Received interrupt request in " + this.state +
                         " state." };
     }
 
     try {
-      // Put ourselves in the paused state.
+      // If execution should pause just before the next JavaScript bytecode is
+      // executed, just set an onEnterFrame handler.
+      if (aRequest.when == "onNext") {
+        let pauseAndRespond = this._pauseAndRespond.bind(this);
+        let onEnterFrame = function(aFrame) {
+          return pauseAndRespond(aFrame, { type: "interrupted", onNext: true });
+        };
+        this.dbg.onEnterFrame = onEnterFrame;
+
+        return { type: "willInterrupt" };
+      }
+
+      // If execution should pause immediately, just put ourselves in the paused
+      // state.
       let packet = this._paused();
       if (!packet) {
         return { error: "notInterrupted" };
       }
       packet.why = { type: "interrupted" };
 
       // Send the response to the interrupt request now (rather than
       // returning it), because we're going to start a nested event loop
