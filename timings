# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  08c0c41f4bda739b182259bb9077c14041f8e8f4
Breakpoint sliding timings

diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -2712,28 +2712,30 @@ SourceActor.prototype = {
    * @param BreakpointActor actor
    *        The BreakpointActor to be set as a breakpoint handler.
    *
    * @returns A Promise that resolves to the given BreakpointActor.
    */
   _setBreakpoint: function (actor) {
     let { originalLocation } = actor;
     let { originalSourceActor, originalLine, originalColumn } = originalLocation;
-
+console.time("Calling _setBreakpointAtOriginalLocation");
     return this._setBreakpointAtOriginalLocation(actor, originalLocation)
                .then((actualLocation) => {
+console.timeEnd("Calling _setBreakpointAtOriginalLocation");
       if (actualLocation) {
         return actualLocation;
       }
 
       // There were no scripts that matched the given location, so we need to
       // perform breakpoint sliding. We try to slide the breakpoint by column
       // first, and if that fails, by line instead.
       if (!this.isSourceMapped) {
         if (originalColumn !== undefined) {
+        console.time("Junk");
           // To perform breakpoint sliding for column breakpoints, we need to
           // build a map from column numbers to a list of entry points for each
           // column, implemented as a sparse array. An entry point is a (script,
           // offsets) pair, and represents all offsets in that script that are
           // entry points for the corresponding column.
           let columnToEntryPointsMap = [];
 
           // Iterate over all scripts that correspond to this source actor and
@@ -2756,30 +2758,34 @@ SourceActor.prototype = {
                 // number yet, so create it and add it to the map.
                 entryPoints = [];
                 columnToEntryPointsMap[column] = entryPoints;
               }
               entryPoints.push({ script, offsets: [offset] });
             }
           }
 
+        console.timeEnd("Junk");
           // Now that we have a map from column numbers to a list of entry points
           // for each column, we can use it to perform breakpoint sliding. Start
           // at the original column of the breakpoint actor, and keep
           // incrementing it by one, until either we find a line that has at
           // least one entry point, or we go past the last column in the map.
           //
           // Note that by computing the entire map up front, and implementing it
           // as a sparse array, we can easily tell when we went past the last
           // column in the map.
+          console.log("ENTRY POINTS", columnToEntryPointsMap.length, originalColumn);
+        console.time("Sliding");
           let actualColumn = originalColumn + 1;
           while (actualColumn < columnToEntryPointsMap.length) {
             let entryPoints = columnToEntryPointsMap[actualColumn];
             if (entryPoints) {
               setBreakpointAtEntryPoints(actor, entryPoints);
+        console.timeEnd("Sliding");
               return new OriginalLocation(
                 originalSourceActor,
                 originalLine,
                 actualColumn
               );
             }
             ++actualColumn;
           }
@@ -2787,25 +2793,35 @@ SourceActor.prototype = {
           return originalLocation;
         } else {
           // To perform breakpoint sliding for line breakpoints, we need to
           // build a map from line numbers to a list of entry points for each
           // line, implemented as a sparse array. An entry point is a (script,
           // offsets) pair, and represents all offsets in that script that are
           // entry points for the corresponding line.
           let lineToEntryPointsMap = [];
-
+          console.time("breakpoint sliding for line breakpoints");
+
+          console.time("Getting scripts");
           // Iterate over all scripts that correspond to this source actor.
           let scripts = this.scripts.getScriptsBySourceActor(this);
+          console.timeEnd("Getting scripts");
+          console.log("NUmber of scripts", scripts.length);
+          let i = 0;
           for (let script of scripts) {
+            i++;
+            console.time("getAllOffsets " + i);
             // Get all offsets for each line in the current script. This returns
             // a map from line numbers fo a list of offsets for each line,
             // implemented as a sparse array.
             let lineToOffsetsMap = script.getAllOffsets();
-
+            console.timeEnd("getAllOffsets " + i);
+
+
+            console.time("iterate " + i);
             // Iterate over each line, and add their list of offsets to the map
             // from line numbers to entry points by forming a (script, offsets)
             // pair, where script is the current script, and offsets is the list
             // of offsets for the current line.
             for (let line = 0; line < lineToOffsetsMap.length; ++line) {
               let offsets = lineToOffsetsMap[line];
               if (offsets) {
                 let entryPoints = lineToEntryPointsMap[line];
@@ -2813,18 +2829,20 @@ SourceActor.prototype = {
                   // We dont have a list of entry points for the current line
                   // number yet, so create it and add it to the map.
                   entryPoints = [];
                   lineToEntryPointsMap[line] = entryPoints;
                 }
                 entryPoints.push({ script, offsets });
               }
             }
+            console.timeEnd("iterate " + i);
           }
-
+          console.timeEnd("breakpoint sliding for line breakpoints");
+console.time("final");
           // Now that we have a map from line numbers to a list of entry points
           // for each line, we can use it to perform breakpoint sliding. Start
           // at the original line of the breakpoint actor, and keep incrementing
           // it by one, until either we find a line that has at least one entry
           // point, or we go past the last line in the map.
           //
           // Note that by computing the entire map up front, and implementing it
           // as a sparse array, we can easily tell when we went past the last
@@ -2833,16 +2851,17 @@ SourceActor.prototype = {
           while (actualLine < lineToEntryPointsMap.length) {
             let entryPoints = lineToEntryPointsMap[actualLine];
             if (entryPoints) {
               setBreakpointAtEntryPoints(actor, entryPoints);
               break;
             }
             ++actualLine;
           }
+console.timeEnd("final");
           if (actualLine >= lineToEntryPointsMap.length) {
             // We went past the last line in the map, so breakpoint sliding
             // failed. Keep the BreakpointActor in the BreakpointActorMap as a
             // pending breakpoint, so we can try again whenever a new script is
             // introduced.
             return originalLocation;
           }
 
@@ -2930,22 +2949,28 @@ SourceActor.prototype = {
       }
 
       return actor;
     });
   },
 
   _setBreakpointAtOriginalLocation: function (actor, originalLocation) {
     if (!this.isSourceMapped) {
+      console.time("fromOriginalLocation");
+      let oL = GeneratedLocation.fromOriginalLocation(originalLocation);
+      console.timeEnd("fromOriginalLocation");
+      console.time("_setBreakpointAtGeneratedLocation");
       if (!this._setBreakpointAtGeneratedLocation(
         actor,
-        GeneratedLocation.fromOriginalLocation(originalLocation)
+        oL
       )) {
+      console.timeEnd("_setBreakpointAtGeneratedLocation");
         return promise.resolve(null);
       }
+      console.timeEnd("_setBreakpointAtGeneratedLocation");
 
       return promise.resolve(originalLocation);
     } else {
       return this.sources.getAllGeneratedLocations(originalLocation)
                          .then((generatedLocations) => {
         if (!this._setBreakpointAtAllGeneratedLocations(
           actor,
           generatedLocations
@@ -2988,24 +3013,27 @@ SourceActor.prototype = {
   _setBreakpointAtGeneratedLocation: function (actor, generatedLocation) {
     let {
       generatedSourceActor,
       generatedLine,
       generatedColumn,
       generatedLastColumn
     } = generatedLocation;
 
+console.time("getScriptsBySourceActorAndLine");
     // Find all scripts that match the given source actor and line number.
     let scripts = this.scripts.getScriptsBySourceActorAndLine(
       generatedSourceActor,
       generatedLine
     );
+console.timeEnd("getScriptsBySourceActorAndLine");
 
     scripts = scripts.filter((script) => !actor.hasScript(script));
 
+console.time("entryPoints");
     // Find all entry points that correspond to the given location.
     let entryPoints = [];
     if (generatedColumn === undefined) {
       // This is a line breakpoint, so we are interested in all offsets
       // that correspond to the given line number.
       for (let script of scripts) {
         let offsets = script.getLineOffsets(generatedLine);
         if (offsets.length > 0) {
@@ -3023,20 +3051,23 @@ SourceActor.prototype = {
         for (let { columnNumber: column, offset } of columnToOffsetMap) {
           if (column >= generatedColumn && column <= generatedLastColumn) {
             entryPoints.push({ script, offsets: [offset] });
           }
         }
       }
     }
 
+console.timeEnd("entryPoints");
     if (entryPoints.length === 0) {
       return false;
     }
+console.time("setBreakpointAtEntryPoints");
     setBreakpointAtEntryPoints(actor, entryPoints);
+console.timeEnd("setBreakpointAtEntryPoints");
     return true;
   }
 };
 
 SourceActor.prototype.requestTypes = {
   "source": SourceActor.prototype.onSource,
   "blackbox": SourceActor.prototype.onBlackBox,
   "unblackbox": SourceActor.prototype.onUnblackBox,
