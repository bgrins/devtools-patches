# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8f0d3e4a9936bba854a73196d2b2c98ab55a629e

diff --git a/browser/base/content/TabBrowser.js b/browser/base/content/TabBrowser.js
--- a/browser/base/content/TabBrowser.js
+++ b/browser/base/content/TabBrowser.js
@@ -92,33 +92,54 @@ class TabBrowser {
         </stack>
       </vbox>
     </hbox>
     </notificationbox>
   </tabpanels>
 </tabbox>
 `;
 
+
+
+//     this.innerHTML = `<stringbundle anonid="tbstringbundle" src="chrome://browser/locale/tabbrowser.properties">
+// </stringbundle>
+// <tabbox anonid="tabbox" class="tabbrowser-tabbox" flex="1" eventnode="document" inherits="handleCtrlPageUpDown" onselect="if (event.target.localName == 'tabpanels') this.parentNode.updateCurrentBrowser();">
+// <tabpanels flex="1" class="plain" selectedIndex="0" anonid="panelcontainer">
+// <notificationbox flex="1" notificationside="top">
+// <hbox flex="1" class="browserSidebarContainer">
+// <vbox flex="1" class="browserContainer">
+// <stack flex="1" class="browserStack" anonid="browserStack">
+// <browser anonid="initialBrowser" type="content" message="true" messagemanagergroup="browsers" primary="true" inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup,selectmenulist,datetimepicker">
+// </browser>
+// </stack>
+// </vbox>
+// </hbox>
+// </notificationbox>
+// </tabpanels>
+// </tabbox>
+// <children>
+// </children>`;
+
     Object.defineProperty(this, "tabContainer", {
       configurable: true,
       enumerable: true,
       get() {
         delete this.tabContainer;
         return (this.tabContainer = document.getElementById(
           this.getAttribute("tabcontainer")
         ));
-      },
+      }
     });
     Object.defineProperty(this, "tabs", {
       configurable: true,
       enumerable: true,
       get() {
         delete this.tabs;
         return (this.tabs = this.tabContainer.childNodes);
-      },
+      }
     });
     Object.defineProperty(this, "closingTabsEnum", {
       configurable: true,
       enumerable: true,
       get() {
         delete this.closingTabsEnum;
         return (this.closingTabsEnum = { ALL: 0, OTHER: 1, TO_END: 2 });
       },
@@ -166,21 +187,23 @@ class TabBrowser {
         delete this["_unifiedComplete"];
         return (this["_unifiedComplete"] = val);
       }
     });
     Object.defineProperty(this, "mTabBox", {
       configurable: true,
       enumerable: true,
       get() {
-        // return this.getAnonymousElementByID("tabbox");
-        delete this.mTabBox;
-        return (this.mTabBox = this.getAnonymousElementByID(
+        return this.getAnonymousElementByID(
           "tabbox"
-        ));
+        );
+        // delete this.mTabBox;
+        // return (this.mTabBox = this.getAnonymousElementByID(
+        //   "tabbox"
+        // ));
       },
       set(val) {
         delete this["mTabBox"];
         return (this["mTabBox"] = val);
       }
     });
     Object.defineProperty(this, "mPanelContainer", {
       configurable: true,
@@ -233,17 +256,16 @@ class TabBrowser {
         delete this["_lastRelatedTabMap"];
         return (this["_lastRelatedTabMap"] = val);
       }
     });
     Object.defineProperty(this, "mCurrentBrowser", {
       configurable: true,
       enumerable: true,
       get() {
-        delete this.mCurrentBrowser;
         return (this.mCurrentBrowser = this.getAnonymousElementByID(
         "initialBrowser"
         ));
         // return (this.mCurrentBrowser = null);
       },
       set(val) {
         delete this["mCurrentBrowser"];
         return (this["mCurrentBrowser"] = val);
@@ -614,83 +636,25 @@ class TabBrowser {
         return (this._hoverTabTimer = null);
       },
       set(val) {
         delete this["_hoverTabTimer"];
         return (this["_hoverTabTimer"] = val);
       }
     });
 
-
-
-//     const NS_XUL =
-//       "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-//     this.mStringBundle = document.createElementNS(NS_XUL, "stringbundle");
-//     this.mStringBundle.setAttribute("src", "chrome://browser/locale/tabbrowser.properties");
-//     this.container.appendChild(this.mStringBundle);
-
-//     this.mTabBox = document.createElementNS(NS_XUL, "tabbox");
-//     this.mTabBox.setAttribute("class", "tabbrowser-tabbox");
-//     this.mTabBox.setAttribute("flex", "1");
-//     this.mTabBox.setAttribute("eventnode", "document");
-//     this.mTabBox.setAttribute("onselect", "if (event.target.localName == 'tabpanels') { gBrowser.updateCurrentBrowser(); }");
-//     this.container.appendChild(this.mTabBox);
-
-//     this.mPanelContainer = document.createElementNS(NS_XUL, "tabpanels");
-//     this.mPanelContainer.setAttribute("flex", "1");
-//     this.mPanelContainer.setAttribute("class", "plain");
-//     this.mPanelContainer.setAttribute("selectedIndex", "0");
-//     this.mTabBox.appendChild(this.mPanelContainer);
-
-//     this.mCurrentBrowser = document.createElementNS(NS_XUL, "browser");
-//     this.mCurrentBrowser.permanentKey = {};
-//     this.mCurrentBrowser.setAttribute("aid", "initialBrowser");
-//     this.mCurrentBrowser.setAttribute("type", "content");
-//     this.mCurrentBrowser.setAttribute("message", "true");
-//     this.mCurrentBrowser.setAttribute("messagemanagergroup", "browsers");
-//     this.mCurrentBrowser.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
-//     this.mCurrentBrowser.setAttribute("tooltip", this.getAttribute("contenttooltip"));
-// dump(this.mCurrentBrowser + "\n");
-//     // Create the browserStack container
-//     var stack = document.createElementNS(NS_XUL, "stack");
-//     stack.className = "browserStack";
-//     stack.appendChild(this.mCurrentBrowser);
-//     stack.setAttribute("flex", "1");
-
-//     // Create the browserContainer
-//     var browserContainer = document.createElementNS(NS_XUL, "vbox");
-//     browserContainer.className = "browserContainer";
-//     browserContainer.appendChild(stack);
-//     browserContainer.setAttribute("flex", "1");
-
-//     // Create the sidebar container
-//     var browserSidebarContainer = document.createElementNS(NS_XUL, "hbox");
-//     browserSidebarContainer.className = "browserSidebarContainer";
-//     browserSidebarContainer.appendChild(browserContainer);
-//     browserSidebarContainer.setAttribute("flex", "1");
-
-//     // Add the Message and the Browser to the box
-//     var notificationbox = document.createElementNS(NS_XUL, "notificationbox");
-//     notificationbox.setAttribute("flex", "1");
-//     notificationbox.setAttribute("notificationside", "top");
-//     notificationbox.appendChild(browserSidebarContainer);
-
-//     this.mPanelContainer.appendChild(notificationbox);
-
-
     try {
       this.mCurrentBrowser = this.getAnonymousElementByID(
         "initialBrowser"
       );
       this.mCurrentBrowser.permanentKey = {};
 
       Services.obs.addObserver(this, "contextual-identity-updated");
 
       this.mCurrentTab = this.tabContainer.firstChild;
-      // console.log(this.mCurrentTab);
       const nsIEventListenerService =
         Components.interfaces.nsIEventListenerService;
       let els = Components.classes[
         "@mozilla.org/eventlistenerservice;1"
       ].getService(nsIEventListenerService);
       els.addSystemEventListener(document, "keydown", this, false);
       if (AppConstants.platform == "macosx") {
         els.addSystemEventListener(document, "keypress", this, false);
@@ -778,30 +742,29 @@ class TabBrowser {
       messageManager.addMessageListener("Prerender:Swap", this);
 
       XPCOMUtils.defineLazyPreferenceGetter(
         this,
         "animationsEnabled",
         "toolkit.cosmeticAnimations.enabled",
         true
       );
-    } catch (e) { dump("Caught: " + e + "\n"); }
+    } catch (e) { dump("Caught " + e + "\n"); }
   }
 
   get tabContextMenu() {
     return this.tabContainer.contextMenu;
   }
 
   get visibleTabs() {
-    if (!this._visibleTabs) {
+    if (!this._visibleTabs)
       this._visibleTabs = Array.filter(
         this.tabs,
         tab => !tab.hidden && !tab.closing
       );
-    }
     return this._visibleTabs;
   }
 
   get _numPinnedTabs() {
     for (var i = 0; i < this.tabs.length; i++) {
       if (!this.tabs[i].pinned) break;
     }
     return i;
@@ -818,19 +781,16 @@ class TabBrowser {
     let popupAnchor = document.createElementNS(NS_XUL, "hbox");
     popupAnchor.className = "popup-anchor";
     popupAnchor.hidden = true;
     stack.appendChild(popupAnchor);
     return (this.mCurrentTab._popupAnchor = popupAnchor);
   }
 
   set selectedTab(val) {
-
-    console.log("Setting selected tab", (gNavToolbox.collapsed && !this._allowTabChange), val, this.mTabBox);
-    dump("Setting selected tab\n");
     if (gNavToolbox.collapsed && !this._allowTabChange) {
       return this.mTabBox.selectedTab;
     }
     // Update the tab
     this.mTabBox.selectedTab = val;
     return val;
   }
 
@@ -2398,18 +2358,17 @@ class TabBrowser {
       aTargetTab = params.targetTab;
       aNewIndex = typeof params.newIndex === "number"
         ? params.newIndex
         : aNewIndex;
       aPostDatas = params.postDatas || aPostDatas;
       aUserContextId = params.userContextId;
       aTriggeringPrincipal = params.triggeringPrincipal;
     }
-    console.log("LOADTABS", arguments);
-    console.trace();
+
     if (!aURIs.length) return;
 
     // The tab selected after this new tab is closed (i.e. the new tab's
     // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
     // when several urls are opened here (i.e. closing the first should select
     // the next of many URLs opened) or if the pref to have UI links opened in
     // the background is set (i.e. the link is not being opened modally)
     //
@@ -2479,17 +2438,16 @@ class TabBrowser {
       if (firstTabAdded) {
         // .selectedTab setter focuses the content area
         this.selectedTab = firstTabAdded;
       } else this.selectedBrowser.focus();
     }
   }
   updateBrowserRemoteness(aBrowser, aShouldBeRemote, aOptions) {
     aOptions = aOptions || {};
-    console.trace();
     let isRemote = aBrowser.getAttribute("remote") == "true";
 
     if (!gMultiProcessBrowser && aShouldBeRemote) {
       throw new Error(
         "Cannot switch to remote browser in a window " +
           "without the remote tabs load context."
       );
     }
@@ -4669,17 +4627,17 @@ class TabBrowser {
         this.tabbrowser.dispatchEvent(event);
       },
 
       // This function is called after all the main state changes to
       // make sure we display the right tab.
       updateDisplay() {
         let requestedTabState = this.getTabState(this.requestedTab);
         let requestedBrowser = this.requestedTab.linkedBrowser;
-        console.log("UpdateDisplay", requestedTabState, this.requestedTab, requestedBrowser)
+
         // It is often more desirable to show a blank tab when appropriate than
         // the tab switch spinner - especially since the spinner is usually
         // preceded by a perceived lag of TAB_SWITCH_TIMEOUT ms in the
         // tab switch. We can hide this lag, and hide the time being spent
         // constructing TabChild's, layer trees, etc, by showing a blank
         // tab instead and focusing it immediately.
         let shouldBeBlank = false;
         if (requestedBrowser.isRemoteBrowser) {
