# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  19480c5351171537652af013289a595fa4d66ede

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -8180,25 +8180,25 @@ nsIDocument::CanSavePresentation(nsIRequ
           nsCOMPtr<nsILoadInfo> li;
           channel->GetLoadInfo(getter_AddRefs(li));
           if (li) {
             if (li->InternalContentPolicyType() == nsIContentPolicy::TYPE_INTERNAL_IMAGE_FAVICON) {
               continue;
             }
           }
         }
-#ifdef DEBUG_PAGE_CACHE
+// #ifdef DEBUG_PAGE_CACHE
         nsAutoCString requestName, docSpec;
         request->GetName(requestName);
         if (mDocumentURI)
           mDocumentURI->GetSpec(docSpec);
 
-        printf("document %s has request %s\n",
+        printf(">>> document %s has request %s\n",
                docSpec.get(), requestName.get());
-#endif
+// #endif
         return false;
       }
     }
   }
 
   // Check if we have active GetUserMedia use
   if (MediaManager::Exists() && win &&
       MediaManager::Get()->IsWindowStillActive(win->WindowID())) {
@@ -8417,16 +8417,17 @@ nsDocument::UnblockOnload(bool aFireSync
       }
     } else if (mIsBeingUsedAsImage) {
       // To correctly unblock onload for a document that contains an SVG
       // image, we need to know when all of the SVG document's resources are
       // done loading, in a way comparable to |window.onload|. We fire this
       // event to indicate that the SVG should be considered fully loaded.
       // Because scripting is disabled on SVG-as-image documents, this event
       // is not accessible to content authors. (See bug 837315.)
+      printf(">>> MozSVGAsImageDocumentLoad %s\n", GetDocumentURI()->GetSpecOrDefault().get());
       RefPtr<AsyncEventDispatcher> asyncDispatcher =
         new AsyncEventDispatcher(this,
                                  NS_LITERAL_STRING("MozSVGAsImageDocumentLoad"),
                                  CanBubble::eNo,
                                  ChromeOnlyDispatch::eNo);
       asyncDispatcher->PostDOMEvent();
     }
   }
diff --git a/xpfe/appshell/nsXULWindow.cpp b/xpfe/appshell/nsXULWindow.cpp
--- a/xpfe/appshell/nsXULWindow.cpp
+++ b/xpfe/appshell/nsXULWindow.cpp
@@ -870,16 +870,17 @@ NS_IMETHODIMP nsXULWindow::SetVisibility
     return NS_OK;
   }
 
   if (mDebuting) {
     return NS_OK;
   }
   mDebuting = true;  // (Show / Focus is recursive)
 
+  printf(">>> nsXULWindow::SetVisibility %d\n", aVisibility);
   //XXXTAB Do we really need to show docshell and the window?  Isn't
   // the window good enough?
   nsCOMPtr<nsIBaseWindow> shellAsWin(do_QueryInterface(mDocShell));
   shellAsWin->SetVisibility(aVisibility);
   // Store locally so it doesn't die on us. 'Show' can result in the window
   // being closed with nsXULWindow::Destroy being called. That would set
   // mWindow to null and posibly destroy the nsIWidget while its Show method
   // is on the stack. We need to keep it alive until Show finishes.
