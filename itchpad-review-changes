# HG changeset patch
# Parent a3a3615372bdad1078f28404b87e14d2051f19c6
# User Brian Grinstead <bgrinstead@mozilla.com>
addressing review changes
* * *
review changes, 2
* * *
test

diff --git a/browser/devtools/itchpad/chrome/content/itchpad-loader.js b/browser/devtools/itchpad/chrome/content/itchpad-loader.js
--- a/browser/devtools/itchpad/chrome/content/itchpad-loader.js
+++ b/browser/devtools/itchpad/chrome/content/itchpad-loader.js
@@ -1,60 +1,150 @@
 const Cu = Components.utils;
 const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 const {FileUtils} = Cu.import("resource://gre/modules/FileUtils.jsm", {});
+const {NetUtil} = Cu.import("resource://gre/modules/NetUtil.jsm", {});
 const require = devtools.require;
+const promise = require("itchpad/helpers/promise");
 const Itchpad = require("itchpad/itchpad");
 
+const SAMPLE_PATH = buildTempDirectoryStructure();
+const SAMPLE_NAME = "DevTools Content";
+const SAMPLE_VERSION = "0.1";
+const SAMPLE_PROJECT_URL = "http://mozilla.org";
+const SAMPLE_ICON = "chrome://browser/skin/devtools/tool-options.svg";
+
+/**
+ * Create a workspace for working on itchpad, available at
+ * chrome://browser/content/devtools/itchpad-loader.xul.
+ * This emulates the integration points that the app manager uses.
+ */
+window.addEventListener("DOMContentLoaded", function onDOMReady() {
+  window.removeEventListener("DOMContentLoaded", onDOMReady, true);
+
+  let iframe = document.getElementById("itchpad-iframe");
+  window.itchpad = Itchpad.Itchpad();
+
+
+  itchpad.on("onEditorCreated", (editor) => {
+    console.log("editor created: " + editor);
+  });
+  itchpad.on("onEditorDestroyed", (editor) => {
+    console.log("editor destroyed: " + editor);
+  });
+  itchpad.on("onEditorSave", (editor, resource) => {
+    console.log("editor saved: " + editor, resource.path);
+  });
+  itchpad.on("onTreeSelected", (resource) => {
+    console.log("tree selected: " + resource.path);
+  });
+  itchpad.on("onEditorLoad", (editor) => {
+    console.log("editor loaded: " + editor);
+  });
+  itchpad.on("onEditorActivated", (editor) => {
+    console.log("editor focused: " + editor);
+  });
+  itchpad.on("onEditorDeactivated", (editor) => {
+    console.log("editor blur: " + editor);
+  });
+  itchpad.on("onEditorChange", (editor) => {
+    console.log("editor changed: " + editor);
+  });
+  itchpad.on("onEditorCursorActivity", (editor) => {
+    console.log("editor cursor activity: " + editor);
+  });
+  itchpad.on("onCommand", (cmd) => {
+    console.log("Command: " + cmd);
+  });
+
+  itchpad.load(iframe).then(() => {
+    itchpad.setProjectToSinglePath(SAMPLE_PATH, {
+      name: SAMPLE_NAME,
+      version: SAMPLE_VERSION,
+      iconUrl: SAMPLE_ICON,
+      projectOverviewURL: SAMPLE_PROJECT_URL
+    }).then(() => {
+      console.log("All resources have been loaded", [...itchpad.project.allResources()]);
+    });
+
+  });
+
+}, true);
+
+
+/**
+ * Build a temporary directory as a workspace for this loader
+ * https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O
+ */
 function buildTempDirectoryStructure() {
 
   // return FileUtils.getDir("CurProcD", ["chrome", "browser", "content", "browser", "devtools"]).path;
   // return FileUtils.getDir("CurProcD", ["modules", "devtools", "itchpad", "samples", "webapp"]).path;
 
   // First create (and remove) the temp dir to discard any changes
   let TEMP_DIR = FileUtils.getDir("TmpD", ["Itchpad"], true);
   TEMP_DIR.remove(true);
 
-  // Now rebuild our fake project
+  // Now rebuild our fake project.
   TEMP_DIR = FileUtils.getDir("TmpD", ["Itchpad"], true);
 
   FileUtils.getDir("TmpD", ["Itchpad", "css"], true);
   FileUtils.getDir("TmpD", ["Itchpad", "data"], true);
   FileUtils.getDir("TmpD", ["Itchpad", "img", "icons"], true);
   FileUtils.getDir("TmpD", ["Itchpad", "js"], true);
 
-  FileUtils.getFile("TmpD", ["Itchpad", "index.html"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  let htmlFile = FileUtils.getFile("TmpD", ["Itchpad", "index.html"]);
+  htmlFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  writeToFile(htmlFile, [
+    '<!DOCTYPE html>',
+    '<html lang="en">',
+    ' <head>',
+    '   <meta charset="utf-8" />',
+    '   <title>Itchpad Temp File</title>',
+    '   <link rel="stylesheet" href="style.css" />',
+    ' </head>',
+    ' <body id="home">',
+    '   <p>Itchpad Temp File</p>',
+    ' </body>',
+    '</html>'].join("\n")
+  );
+
   FileUtils.getFile("TmpD", ["Itchpad", "README.md"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
 
-  FileUtils.getFile("TmpD", ["Itchpad", "css", "styles.css"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  let cssFile = FileUtils.getFile("TmpD", ["Itchpad", "css", "styles.css"]);
+  cssFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  writeToFile(cssFile, [
+    'body {',
+    ' background: red;',
+    '}'
+    ].join("\n")
+  );
 
   FileUtils.getFile("TmpD", ["Itchpad", "js", "script.js"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
 
   FileUtils.getFile("TmpD", ["Itchpad", "img", "fake.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "16x16.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "32x32.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "128x128.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "vector.svg"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
 
   return TEMP_DIR.path;
 }
 
-const SAMPLE_PATH = buildTempDirectoryStructure();
-const SAMPLE_NAME = "DevTools Content";
-const SAMPLE_VERSION = "0.1";
-const SAMPLE_PROJECT_URL = "http://mozilla.org";
-const SAMPLE_ICON = "chrome://browser/skin/devtools/tool-options.svg";
+// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O#Writing_to_a_file
+function writeToFile(file, data) {
 
-window.addEventListener("DOMContentLoaded", function onDOMReady() {
-  window.removeEventListener("DOMContentLoaded", onDOMReady, true);
+  let defer = promise.defer();
+  var ostream = FileUtils.openSafeFileOutputStream(file)
 
-  let iframe = document.getElementById("itchpad-iframe");
-  window.itchpad = Itchpad.Itchpad();
+  var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].
+                  createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
+  converter.charset = "UTF-8";
+  var istream = converter.convertToInputStream(data);
 
-  itchpad.load(iframe).then(() => {
-    itchpad.setProjectToSinglePath(SAMPLE_PATH, {
-      name: SAMPLE_NAME,
-      version: SAMPLE_VERSION,
-      iconUrl: SAMPLE_ICON,
-      projectOverviewURL: SAMPLE_PROJECT_URL
-    });
+  // The last argument (the callback) is optional.
+  NetUtil.asyncCopy(istream, ostream, function(status) {
+    if (!Components.isSuccessCode(status)) {
+      // Handle error!
+      console.log("ERROR WRITING TEMP FILE", status);
+    }
   });
-}, true);
+}
diff --git a/browser/devtools/itchpad/chrome/content/itchpad-loader.xul b/browser/devtools/itchpad/chrome/content/itchpad-loader.xul
--- a/browser/devtools/itchpad/chrome/content/itchpad-loader.xul
+++ b/browser/devtools/itchpad/chrome/content/itchpad-loader.xul
@@ -2,24 +2,17 @@
 <!-- This Source Code Form is subject to the terms of the Mozilla Public
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 <!DOCTYPE window [
 <!ENTITY % toolboxDTD SYSTEM "chrome://browser/locale/devtools/toolbox.dtd" >
  %toolboxDTD;
 ]>
 
-<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-        id="devtools-itchpad-window"
-        macanimationtype="document"
-        fullscreenbutton="true"
-        windowtype="devtools:itchpad"
-        width="900" height="320"
-        persist="screenX screenY width height sizemode"
-        windowtitle="itchpad window">
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
 <script type="application/javascript;version=1.8" src="chrome://browser/content/devtools/itchpad-loader.js"></script>
 
   <commandset id="toolbox-commandset">
     <command id="itchpad-cmd-close" oncommand="window.close();"/>
   </commandset>
 
   <keyset id="itchpad-keyset">
diff --git a/browser/devtools/itchpad/chrome/content/itchpad.xul b/browser/devtools/itchpad/chrome/content/itchpad.xul
--- a/browser/devtools/itchpad/chrome/content/itchpad.xul
+++ b/browser/devtools/itchpad/chrome/content/itchpad.xul
@@ -1,12 +1,13 @@
 <?xml version="1.0"?>
 <!-- This Source Code Form is subject to the terms of the Mozilla Public
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<?xml-stylesheet href="chrome://browser/skin/devtools/light-theme.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/devtools/itchpad/itchpad.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/content/devtools/widgets.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/content/devtools/debugger.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/devtools/common.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/devtools/widgets.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/devtools/debugger.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/content/devtools/markup-view.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/devtools/markup-view.css" type="text/css"?>
@@ -17,32 +18,28 @@
 <!ENTITY % scratchpadDTD SYSTEM "chrome://browser/locale/devtools/scratchpad.dtd" >
  %scratchpadDTD;
 <!ENTITY % editMenuStrings SYSTEM "chrome://global/locale/editMenuOverlay.dtd">
 %editMenuStrings;
 <!ENTITY % sourceEditorStrings SYSTEM "chrome://browser/locale/devtools/sourceeditor.dtd">
 %sourceEditorStrings;
 ]>
 
-<window id="itchpad-window"
-        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" class="theme-body"
-        title="Itchpad"
-        windowtype="devtools:itchpad"
-        macanimcationtype="document"
-        fullscreenbutton="true"
-        screenX="4" screenY="4"
-        width="640" height="480"
-        persist="screenX screenY width height sizemode">
+<page xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" class="theme-body">
+
+  <script type="application/javascript" src="chrome://global/content/globalOverlay.js"/>
 
   <commandset id="itchpad-commandset" />
   <commandset id="editMenuCommands"/>
   <keyset id="itchpad-keyset" />
   <keyset id="editMenuKeys"/>
 
-  <!-- XXX: Let plugins declare their own menu items -->
+  <!-- Eventually we want to let plugins declare their own menu items.
+       Wait unti app manager lands to deal with this integration point.
+  -->
   <menubar id="itchpad-menubar">
     <menu id="file-menu" label="&fileMenu.label;" accesskey="&fileMenu.accesskey;">
       <menupopup id="file-menu-popup" />
     </menu>
 
     <menu id="edit-menu" label="&editMenu.label;"
           accesskey="&editMenu.accesskey;">
       <menupopup id="edit-menu-popup">
@@ -62,19 +59,16 @@
   </menubar>
 
 
   <popupset>
     <menupopup id="directory-menu-popup">
     </menupopup>
   </popupset>
 
-  <script type="application/javascript" src="chrome://global/content/globalOverlay.js"/>
-  <script type="application/javascript;version=1.8" src="chrome://browser/content/devtools/theme-switching.js"></script>
-
   <deck id="main-deck" flex="1">
     <vbox flex="1" id="source-deckitem">
       <hbox id="sources-body" flex="1">
         <vbox width="250">
           <vbox id="sources" flex="1">
           </vbox>
           <toolbar id="project-toolbar" class="devtools-toolbar" hidden="true"></toolbar>
         </vbox>
@@ -95,9 +89,9 @@
                   flex="1">
             <tabs hidden="true"/>
             <tabpanels flex="1"/>
           </tabbox>
         </vbox>
       </hbox>
     </vbox>
   </deck>
-</window>
+</page>
diff --git a/browser/devtools/itchpad/chrome/content/readdir.js b/browser/devtools/itchpad/chrome/content/readdir.js
deleted file mode 100644
--- a/browser/devtools/itchpad/chrome/content/readdir.js
+++ /dev/null
@@ -1,74 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-importScripts("resource://gre/modules/osfile.jsm");
-
-function readDir(path, ignore, maxDepth = Infinity) {
-  let ret = {};
-
-  let set = new Set();
-
-  let info = OS.File.stat(path);
-  set.add({
-    path: path,
-    name: info.name,
-    isDir: info.isDir,
-    isSymLink: info.isSymLink,
-    depth: 0
-  });
-
-  for (let info of set) {
-    let children = [];
-
-    if (info.isDir && !info.isSymLink) {
-      if (info.depth > maxDepth) {
-        continue;
-      }
-
-      let iterator = new OS.File.DirectoryIterator(info.path);
-      try {
-        for (let child in iterator) {
-          if (ignore && child.name.match(ignore)) {
-            continue;
-          }
-
-          children.push(child.path);
-          set.add({
-            path: child.path,
-            name: child.name,
-            isDir: child.isDir,
-            isSymLink: child.isSymLink,
-            depth: info.depth + 1
-          });
-        }
-      } finally {
-        iterator.close();
-      }
-    }
-
-    ret[info.path] = {
-      name: info.name,
-      isDir: info.isDir,
-      isSymLink: info.isSymLink,
-      depth: info.depth,
-      children: children,
-    };
-  }
-
-  return ret;
-};
-
-onmessage = function (event) {
-  try {
-    let {path, ignore, depth} = event.data;
-    let message = readDir(path, ignore, depth);
-    postMessage(message);
-  } catch(ex) {
-    console.log(ex);
-  }
-};
-
-
diff --git a/browser/devtools/itchpad/lib/editors.js b/browser/devtools/itchpad/lib/editors.js
--- a/browser/devtools/itchpad/lib/editors.js
+++ b/browser/devtools/itchpad/lib/editors.js
@@ -4,146 +4,260 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const { EventTarget } = require("sdk/event/target");
 const { emit } = require("sdk/event/core");
 const promise = require("itchpad/helpers/promise");
-
 const Editor  = require("devtools/sourceeditor/editor");
-
-
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
+/**
+ * ItchEditor is extended to implement an editor, which is the main view
+ * that shows up when a file is selected.  This object should not be used
+ * directly - use TextEditor for a basic code editor.
+ */
 var ItchEditor = Class({
   extends: EventTarget,
 
+  /**
+   * A boolean specifying if the toolbar above the editor should be hidden.
+   */
+  hidesToolbar: false,
+
   toString: function() {
     return this.label || "";
   },
 
+  emit: function(name, ...args) {
+    emit(this, name, ...args);
+  },
+
+  /**
+   * Initialize the editor with a single document.  This should be called
+   * by objects extending this object with:
+   * ItchEditor.prototype.initialize.apply(this, arguments)
+   */
   initialize: function(document) {
     this.doc = document;
     this.label = "";
     this.elt = this.doc.createElement("vbox");
     this.elt.setAttribute("flex", "1");
     this.elt.editor = this;
     this.toolbar = this.doc.querySelector("#itchpad-toolbar");
   },
 
+  /**
+   * Sets the visibility of the element that shows up above the editor
+   * based on the this.hidesToolbar property.
+   */
   setToolbarVisibility: function() {
     if (this.hidesToolbar) {
       this.toolbar.setAttribute("hidden", "true");
     } else {
       this.toolbar.removeAttribute("hidden");
     }
   },
 
+
+  /**
+   * Load a single resource into the editor.
+   *
+   * @param Resource resource
+   *        The single file / item that is being dealt with (see stores/base)
+   * @returns Promise
+   *          A promise that is resolved once the editor has loaded the contents
+   *          of the resource.
+   */
   load: function(resource) {
     return promise.resolve();
   },
 
+  /**
+   * Clean up the editor.  This can have different meanings
+   * depending on the type of editor.
+   */
+  destroy: function() {
+
+  },
+
+  /**
+   * Give focus to the editor.  This can have different meanings
+   * depending on the type of editor.
+   *
+   * @returns Promise
+   *          A promise that is resolved once the editor has been focused.
+   */
   focus: function() {
     return promise.resolve();
   }
 });
 exports.ItchEditor = ItchEditor;
 
-var MODE_CATEGORIES = {};
-
-MODE_CATEGORIES[Editor.modes.text.name] = "txt";
-MODE_CATEGORIES[Editor.modes.js.name] = "js";
-MODE_CATEGORIES[Editor.modes.html.name] = "html";
-MODE_CATEGORIES[Editor.modes.css.name] = "css";
-
+/**
+ * The main implementation of the ItchEditor class.  The TextEditor is used
+ * when editing any sort of plain text file, and can be created with different
+ * modes for syntax highlighting depending on the language.
+ */
 var TextEditor = Class({
   extends: ItchEditor,
 
+  /**
+   * Extra keyboard shortcuts to use with the editor.  Shortcuts defined
+   * within itchpad should be triggered when they happen in the editor, and
+   * they would usually be swallowed without registering them.
+   * See "devtools/sourceeditor/editor" for more information.
+   */
   get extraKeys() {
     let extraKeys = {};
 
-
     // Copy all of the registered keys into extraKeys object, to notify CodeMirror
     // that it should be ignoring these keys
     [...this.doc.querySelectorAll("#itchpad-keyset key")].forEach((key) => {
       let keyUpper = key.getAttribute("key").toUpperCase();
       let toolModifiers = key.getAttribute("modifiers");
       let modifiers = {
         alt: toolModifiers.contains("alt"),
-        shift: toolModifiers.contains("shift"),
+        shift: toolModifiers.contains("shift")
       };
+
+      // On the key press, we will dispatch the event within itchpad.
       extraKeys[Editor.accel(keyUpper, modifiers)] = () => {
         let event = this.doc.createEvent('Event');
         event.initEvent('command', true, true);
         let command = this.doc.querySelector("#" + key.getAttribute("command"));
         command.dispatchEvent(event);
       };
     });
+
     return extraKeys;
   },
 
-  get category() {
-    return MODE_CATEGORIES[this.editor.getMode().name];
-  },
-
   initialize: function(document, mode=Editor.modes.text) {
-    ItchEditor.prototype.initialize.call(this, document);
+    ItchEditor.prototype.initialize.apply(this, arguments);
     this.label = mode.name;
     this.editor = new Editor({
       mode: mode,
       lineNumbers: true,
-      extraKeys: this.extraKeys
+      extraKeys: this.extraKeys,
+      themeSwitching: false
+    });
+
+    // Trigger editor specific events on `this`
+    this.editor.on("change", (...args) => {
+      this.emit("change", ...args);
+    });
+    this.editor.on("cursorActivity", (...args) => {
+      this.emit("cursorActivity", ...args);
     });
 
     this.appended = this.editor.appendTo(this.elt);
   },
 
-  load: function(resource) {
-    return this.appended.then(() => {
-      return resource.load();
-    }).then(text => {
-      this.editor.setText(text);
-      this.editor.setClean();
-      emit(this, "load");
-    }).then(null, console.error);
+  /**
+   * Clean up the editor.  This can have different meanings
+   * depending on the type of editor.
+   */
+  destroy: function() {
+    this.editor.destroy();
+    this.editor = null;
   },
 
+  /**
+   * Load a single resource into the text editor.
+   *
+   * @param Resource resource
+   *        The single file / item that is being dealt with (see stores/base)
+   * @returns Promise
+   *          A promise that is resolved once the text editor has loaded the
+   *          contents of the resource.
+   */
+  load: function(resource) {
+    // Wait for the editor.appendTo and resource.load before proceeding.
+    // They can run  in parallel.
+    return promise.all([
+      resource.load(),
+      this.appended
+    ]).then(([resourceContents])=> {
+      this.editor.setText(resourceContents);
+      this.editor.setClean();
+      this.emit("load");
+    }, console.error);
+  },
+
+  /**
+   * Save the resource based on the current state of the editor
+   *
+   * @param Resource resource
+   *        The single file / item to be saved
+   * @returns Promise
+   *          A promise that is resolved once the resource has been
+   *          saved.
+   */
   save: function(resource) {
     return resource.save(this.editor.getText()).then(() => {
       this.editor.setClean();
-      emit(this, "save", resource);
+      this.emit("save", resource);
     });
   },
 
-  focus: function(resource) {
+  /**
+   * Give focus to the code editor.
+   *
+   * @returns Promise
+   *          A promise that is resolved once the editor has been focused.
+   */
+  focus: function() {
     return this.appended.then(() => {
       this.editor.focus();
     });
   }
 });
 
+/**
+ * Wrapper for TextEditor using JavaScript syntax highlighting.
+ */
+function JSEditor(document) {
+  return TextEditor(document, Editor.modes.js);
+}
 
-function textMode(mode) {
-  return function(document) { return TextEditor(document, mode); }
+/**
+ * Wrapper for TextEditor using CSS syntax highlighting.
+ */
+function CSSEditor(document) {
+  return TextEditor(document, Editor.modes.css);
+}
+
+/**
+ * Wrapper for TextEditor using HTML syntax highlighting.
+ */
+function HTMLEditor(document) {
+  return TextEditor(document, Editor.modes.html);
+}
+
+/**
+ * Get the type of editor that can handle a particular resource.
+ * @param Resource resource
+ *        The single file that is going to be opened.
+ * @returns Type:Editor
+ *          The type of editor that can handle this resource.  The
+ *          return value is a constructor function.
+ */
+function EditorTypeForResource(resource) {
+  const categoryMap = {
+    "txt": TextEditor,
+    "html": HTMLEditor,
+    "xml": HTMLEditor,
+    "css": CSSEditor,
+    "js": JSEditor,
+    "json": JSEditor
+  };
+  return categoryMap[resource.contentCategory] || TextEditor;
 }
 
 exports.TextEditor = TextEditor;
-exports.JSEditor = textMode(Editor.modes.js);
-exports.CSSEditor = textMode(Editor.modes.css);
-exports.HTMLEditor = textMode(Editor.modes.html);
-
-const categoryMap = {
-  "txt": exports.TextEditor,
-  "html": exports.HTMLEditor,
-  "xml": exports.HTMLEditor,
-  "css": exports.CSSEditor,
-  "js": exports.JSEditor,
-  "json": exports.JSEditor
-};
-
-function EditorTypeForResource(resource) {
-  return categoryMap[resource.contentCategory] || TextEditor;
-}
-
+exports.JSEditor = JSEditor;
+exports.CSSEditor = CSSEditor;
+exports.HTMLEditor = HTMLEditor;
 exports.EditorTypeForResource = EditorTypeForResource;
diff --git a/browser/devtools/itchpad/lib/event/scope.js b/browser/devtools/itchpad/lib/event/scope.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/event/scope.js
+++ /dev/null
@@ -1,82 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const { EventTarget } = require("sdk/event/target");
-
-var Scope = Class({
-  initialize: function(owner) {
-    this.owner = owner;
-  },
-
-  on: function(target, event, handler) {
-    this.listeners = this.listeners || [];
-    this.listeners.push({
-      target: target,
-      event: event,
-      handler: handler
-    });
-    target.on(event, handler);
-  },
-
-  off: function(t, e, h) {
-    if (!this.listeners) return;
-    this.listeners = this.listeners.filter(({ target, event, handler }) => {
-      return !(target === t && event === e && handler === h);
-    });
-    target.off(event, handler);
-  },
-
-  clear: function(clearTarget) {
-    if (!this.listeners) return;
-    this.listeners = this.listeners.filter(({ target, event, handler }) => {
-      if (target === clearTarget) {
-        target.off(event, handler);
-        return false;
-      }
-      return true;
-    });
-  },
-  destroy: function() {
-    this.owner = undefined;
-    if (!this.listeners) return;
-    this.listeners.forEach(({ target, event, handler }) => {
-      target.off(event, handler);
-    });
-    this.listeners = undefined;
-  }
-});
-
-var scopes = new WeakMap();
-function scope(owner) {
-  if (!scopes.has(owner)) {
-    let scope = new Scope(owner);
-    scopes.set(owner, scope);
-    return scope;
-  }
-  return scopes.get(owner);
-}
-exports.scope = scope;
-
-exports.on = function(owner, target, event, handler) {
-  if (!target) return;
-  scope(owner).on(target, event, handler);
-}
-
-exports.off = function(owner, target, event, handler) {
-  if (!target) return;
-  scope(owner).off(target, event, handler);
-}
-
-exports.forget = function(owner, target) {
-  scope(owner).clear(target);
-}
-
-exports.done = function(owner) {
-  scope(owner).destroy();
-  scopes.delete(owner);
-}
-
diff --git a/browser/devtools/itchpad/lib/helpers/event.js b/browser/devtools/itchpad/lib/helpers/event.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/event.js
@@ -0,0 +1,86 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * This file wraps EventEmitter objects to provide functions to forget
+ * all events bound on a certain object.
+ */
+
+const { Class } = require("sdk/core/heritage");
+
+/**
+ * The Scope object is used to keep track of listeners.
+ * This object is not exported.
+ */
+var Scope = Class({
+  on: function(target, event, handler) {
+    this.listeners = this.listeners || [];
+    this.listeners.push({
+      target: target,
+      event: event,
+      handler: handler
+    });
+    target.on(event, handler);
+  },
+
+  off: function(t, e, h) {
+    if (!this.listeners) return;
+    this.listeners = this.listeners.filter(({ target, event, handler }) => {
+      return !(target === t && event === e && handler === h);
+    });
+    target.off(event, handler);
+  },
+
+  clear: function(clearTarget) {
+    if (!this.listeners) return;
+    this.listeners = this.listeners.filter(({ target, event, handler }) => {
+      if (target === clearTarget) {
+        target.off(event, handler);
+        return false;
+      }
+      return true;
+    });
+  },
+
+  destroy: function() {
+    if (!this.listeners) return;
+    this.listeners.forEach(({ target, event, handler }) => {
+      target.off(event, handler);
+    });
+    this.listeners = undefined;
+  }
+});
+
+var scopes = new WeakMap();
+function scope(owner) {
+  if (!scopes.has(owner)) {
+    let scope = new Scope(owner);
+    scopes.set(owner, scope);
+    return scope;
+  }
+  return scopes.get(owner);
+}
+exports.scope = scope;
+
+exports.on = function on(owner, target, event, handler) {
+  if (!target) return;
+  scope(owner).on(target, event, handler);
+}
+
+exports.off = function off(owner, target, event, handler) {
+  if (!target) return;
+  scope(owner).off(target, event, handler);
+}
+
+exports.forget = function forget(owner, target) {
+  scope(owner).clear(target);
+}
+
+exports.done = function done(owner) {
+  scope(owner).destroy();
+  scopes.delete(owner);
+}
+
diff --git a/browser/devtools/itchpad/lib/helpers/file-picker.js b/browser/devtools/itchpad/lib/helpers/file-picker.js
--- a/browser/devtools/itchpad/lib/helpers/file-picker.js
+++ b/browser/devtools/itchpad/lib/helpers/file-picker.js
@@ -1,19 +1,44 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+/**
+ * This file contains helper functions for showing OS-specific
+ * file and folder pickers.
+ */
+
 const { Cu, Cc, Ci } = require("chrome");
 const { FileUtils } = Cu.import("resource://gre/modules/FileUtils.jsm", {});
 const promise = require("itchpad/helpers/promise");
 const { merge } = require("sdk/util/object");
+const { localizedStrings } = require("itchpad/helpers/l10n");
 
+/**
+ * Show a file / folder picker.
+ * https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIFilePicker
+ *
+ * @param object options
+ *        Additional options for setting the source. Supported options:
+ *          - directory: string, The path to default opening
+ *          - defaultName: string, The filename including extension that
+ *                         should be suggested to the user as a default
+ *          - window: DOMWindow, The filename including extension that
+ *                         should be suggested to the user as a default
+ *          - title: string, The filename including extension that
+ *                         should be suggested to the user as a default
+ *          - mode: int, The type of picker to open.
+ *
+ * @return promise
+ *         A promise that is resolved with the full path
+ *         after the file has been picked.
+ */
 function showPicker(options) {
   let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
   if (options.directory) {
     try {
       fp.displayDirectory = FileUtils.File(options.directory);
     } catch(ex) {
       console.warn(ex);
     }
@@ -33,31 +58,59 @@ function showPicker(options) {
         deferred.reject();
       }
     }
   });
   return deferred.promise;
 }
 exports.showPicker = showPicker;
 
+/**
+ * Show a save dialog
+ * https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIFilePicker
+ *
+ * @param object options
+ *        Additional options as specified in showPicker
+ *
+ * @return promise
+ *         A promise that is resolved when the save dialog has closed
+ */
 function showSave(options) {
   return showPicker(merge({
-    title: "Select a File",
+    title: localizedStrings.selectFileLabel,
     mode: Ci.nsIFilePicker.modeSave
   }, options));
 }
 exports.showSave = showSave;
 
+/**
+ * Show a file open dialog
+ *
+ * @param object options
+ *        Additional options as specified in showPicker
+ *
+ * @return promise
+ *         A promise that is resolved when the file has been opened
+ */
 function showOpen(options) {
   return showPicker(merge({
-    title: "Open a File",
+    title: localizedStrings.openFileLabel,
     mode: Ci.nsIFilePicker.modeOpen
   }, options));
 }
 exports.showOpen = showOpen;
 
+/**
+ * Show a folder open dialog
+ *
+ * @param object options
+ *        Additional options as specified in showPicker
+ *
+ * @return promise
+ *         A promise that is resolved when the folder has been opened
+ */
 function showOpenFolder(options) {
   return showPicker(merge({
-    title: "Select a Folder",
+    title: localizedStrings.openFolderLabel,
     mode: Ci.nsIFilePicker.modeGetFolder
   }, options));
 }
 exports.showOpenFolder = showOpenFolder;
diff --git a/browser/devtools/itchpad/lib/helpers/l10n.js b/browser/devtools/itchpad/lib/helpers/l10n.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/l10n.js
@@ -0,0 +1,32 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * This file contains helper functions for internationalizing itchpad strings
+ */
+
+const { Cu, Cc, Ci } = require("chrome");
+const { ViewHelpers } = Cu.import("resource:///modules/devtools/ViewHelpers.jsm", {});
+const ITCHPAD_STRINGS_URI = "chrome://browser/locale/devtools/itchpad.properties";
+const L10N = new ViewHelpers.L10N(ITCHPAD_STRINGS_URI).stringBundle;
+
+function getLocalizedString (name) {
+  try {
+    return L10N.GetStringFromName(name);
+  } catch (ex) {
+    console.log("Error reading '" + name + "'");
+    throw new Error("l10n error with " + name);
+  }
+}
+
+exports.getLocalizedString = getLocalizedString;
+exports.localizedStrings = {
+  get deleteLabel() { return getLocalizedString("itchpad.deleteLabel"); },
+  get newLabel() { return getLocalizedString("itchpad.newLabel"); },
+  get selectFileLabel() { return getLocalizedString("itchpad.selectFileLabel"); },
+  get openFileLabel() { return getLocalizedString("itchpad.openFileLabel"); },
+  get openFolderLabel() { return getLocalizedString("itchpad.selectFolderLabel"); },
+};
\ No newline at end of file
diff --git a/browser/devtools/itchpad/lib/helpers/osfile.js b/browser/devtools/itchpad/lib/helpers/osfile.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/helpers/osfile.js
+++ /dev/null
@@ -1,9 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Cu } = require("chrome");
-const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
-module.exports = OS;
diff --git a/browser/devtools/itchpad/lib/helpers/promise.js b/browser/devtools/itchpad/lib/helpers/promise.js
--- a/browser/devtools/itchpad/lib/helpers/promise.js
+++ b/browser/devtools/itchpad/lib/helpers/promise.js
@@ -1,10 +1,11 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-// ... until sdk/core/promise uses Promise.jsm...
-
+/**
+ * This helper is a quick way to require() the Promise object from Promise.jsm.
+ */
 const { Cu } = require("chrome");
 module.exports = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
diff --git a/browser/devtools/itchpad/lib/helpers/readdir.js b/browser/devtools/itchpad/lib/helpers/readdir.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/readdir.js
@@ -0,0 +1,89 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+importScripts("resource://gre/modules/osfile.jsm");
+
+/**
+ * This file is meant to be loaded in a worker using:
+ *   new ChromeWorker("chrome://browser/content/devtools/readdir.js");
+ *
+ * Read a local directory inside of a web woker
+ *
+ * @param {string} path
+ *        window to inspect
+ * @param {RegExp|string} ignore
+ *        A pattern to ignore certain files.  This is
+ *        called with file.name.match(ignore).
+ * @param {Number} maxDepth
+ *        How many directories to recurse before stopping.
+ *        Directories with depth > maxDepth will be ignored.
+ */
+function readDir(path, ignore, maxDepth = Infinity) {
+  let ret = {};
+
+  let set = new Set();
+
+  let info = OS.File.stat(path);
+  set.add({
+    path: path,
+    name: info.name,
+    isDir: info.isDir,
+    isSymLink: info.isSymLink,
+    depth: 0
+  });
+
+  for (let info of set) {
+    let children = [];
+
+    if (info.isDir && !info.isSymLink) {
+      if (info.depth > maxDepth) {
+        continue;
+      }
+
+      let iterator = new OS.File.DirectoryIterator(info.path);
+      try {
+        for (let child in iterator) {
+          if (ignore && child.name.match(ignore)) {
+            continue;
+          }
+
+          children.push(child.path);
+          set.add({
+            path: child.path,
+            name: child.name,
+            isDir: child.isDir,
+            isSymLink: child.isSymLink,
+            depth: info.depth + 1
+          });
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    ret[info.path] = {
+      name: info.name,
+      isDir: info.isDir,
+      isSymLink: info.isSymLink,
+      depth: info.depth,
+      children: children,
+    };
+  }
+
+  return ret;
+};
+
+onmessage = function (event) {
+  try {
+    let {path, ignore, depth} = event.data;
+    let message = readDir(path, ignore, depth);
+    postMessage(message);
+  } catch(ex) {
+    console.log(ex);
+  }
+};
+
+
diff --git a/browser/devtools/itchpad/lib/helpers/task.js b/browser/devtools/itchpad/lib/helpers/task.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/helpers/task.js
+++ /dev/null
@@ -1,11 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Cu } = require("chrome");
-
-const { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
-
-module.exports = Task;
diff --git a/browser/devtools/itchpad/lib/itchpad.js b/browser/devtools/itchpad/lib/itchpad.js
--- a/browser/devtools/itchpad/lib/itchpad.js
+++ b/browser/devtools/itchpad/lib/itchpad.js
@@ -1,83 +1,91 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+const { Cc, Ci, Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
-
 const { Project } = require("itchpad/project");
-const { PageCollection } = require("itchpad/page");
-const { TreeView } = require("itchpad/tree");
+const { ProjectTreeView } = require("itchpad/tree");
 const { ShellDeck } = require("itchpad/shells");
-const { Resource } = require("itchpad/stores/base");
-const { ResourceMap, Pair } = require("itchpad/resource-map");
+const { Resource } = require("itchpad/stores/resource");
 const { registeredPlugins } = require("itchpad/plugins/core");
 const { EventTarget } = require("sdk/event/target");
-const { on, forget } = require("itchpad/event/scope");
+const { on, forget } = require("itchpad/helpers/event");
 const { emit } = require("sdk/event/core");
 const { merge } = require("sdk/util/object");
 const promise = require("itchpad/helpers/promise");
 const { ToolSidebar } = require("devtools/framework/sidebar");
+const { ViewHelpers } = Cu.import("resource:///modules/devtools/ViewHelpers.jsm", {});
+const { DOMHelpers } = Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
+const { Services } = Cu.import("resource://gre/modules/Services.jsm", {});
+const ITCHPAD_URL = "chrome://browser/content/devtools/itchpad.xul";
 
-const { Cc, Ci, Cu } = require("chrome");
-const { ViewHelpers } = Cu.import("resource:///modules/devtools/ViewHelpers.jsm", {});
-Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
-
-const {Services} = Cu.import("resource://gre/modules/Services.jsm", {});
-const ITCHPAD_URL = "chrome://browser/content/devtools/itchpad.xul";
-const ITCHPAD_STRINGS_URI = "chrome://browser/locale/devtools/itchpad.properties";
-const L10N = new ViewHelpers.L10N(ITCHPAD_STRINGS_URI).stringBundle;
-
-// Uncomment to get logging of addon events.
-require("itchpad/plugins/logging/lib/logging");
-
-require("itchpad/plugins/apply/lib/apply");
+// Enabled Plugins
 require("itchpad/plugins/dirty/lib/dirty");
 require("itchpad/plugins/delete/lib/delete");
 require("itchpad/plugins/new/lib/new");
 require("itchpad/plugins/save/lib/save");
-require("itchpad/plugins/open/lib/open");
-require("itchpad/plugins/style/lib/style");
-require("itchpad/plugins/notify/lib/notify");
-require("itchpad/plugins/fuzzy-search/lib/plugin");
 require("itchpad/plugins/image-view/lib/plugin");
-require("itchpad/plugins/drag-drop-new/lib/drag-drop-new");
-require("itchpad/plugins/find-and-replace/lib/plugin");
 require("itchpad/plugins/app-manager/lib/plugin");
 require("itchpad/plugins/status-bar/lib/plugin");
 
+// Disabled Plugins.  These are not used right now, but will be
+// needed soon to enable important editing features.
+// require("itchpad/plugins/open/lib/open");
+// require("itchpad/plugins/drag-drop-new/lib/drag-drop-new");
+// require("itchpad/plugins/find-and-replace/lib/plugin");
+// require("itchpad/plugins/logging/lib/logging");
+
 /**
- * This is the main class tying together an instance of the pad.  It is
- * created in itchpad.xul.
+ * This is the main class tying together an instance of the Itchpad.
+ * The frontend is contained inside of this.iframe, which loads itchpad.xul.
  *
- * It mediates access to a few resources:
- * - The list of plugins for this instance.
- * - The tree view that views file trees.
- * - The ShellDeck that contains all editors for this instance.
- * - The Project that includes local resources for the instance.
- * - The list of Live Stores for the instance.
- * - The ResourceMap that ties Live resources to Project resources.
- * - The Target associated with this instance, if any.
- * - The toolbox associated with this instance, if any.
+ * Responsible for maintaining:
+ *   - The list of plugins for this instance.
+ *   - The ShellDeck that contains all editors for this instance.
+ *   - The Project that includes local resources for the instance.
+ *   - The tree view that lists Project files.
+ *
+ * This object emits the following events:
+ *   - "onEditorDestroyed": When editor is destroyed
+ *   - "onEditorSave": When editor is saved
+ *   - "onEditorLoad": When editor is loaded
+ *   - "onEditorActivated": When editor is activated
+ *   - "onEditorChange": When editor is changed
+ *   - "onEditorCursorActivity": When there is cursor activity in a text editor
+ *   - "onCommand": When a command happens
+ *   - "onEditorDestroyed": When editor is destroyed
+ *
+ * The events can be bound like so:
+ *   itchpad.on("onEditorCreated", (editor) => { });
  */
 var Itchpad = Class({
   extends: EventTarget,
 
   initialize: function(options = {}) {
-    this.project = options.project;
-    this.stores = new Set();
-    this._onNodeSelection = this._onNodeSelection.bind(this);
+    this._onTreeSelected = this._onTreeSelected.bind(this);
     this._onEditorCreated = this._onEditorCreated.bind(this);
     this._onEditorActivated = this._onEditorActivated.bind(this);
+    this._onEditorDeactivated = this._onEditorDeactivated.bind(this);
     this._updateEditorMenuItems = this._updateEditorMenuItems.bind(this);
   },
 
+  /**
+   * Load the instance inside of a specified iframe
+   *
+   * @param Iframe iframe
+   *        The iframe to inject the itchpad DOM into
+   * @returns Promise
+   *          A promise that is resolved once the iframe has been
+   *          loaded.
+   */
   load: function(iframe) {
     let deferred = promise.defer();
     this.iframe = iframe;
 
     let domReady = () => {
       this._onLoad();
       deferred.resolve();
     };
@@ -85,144 +93,216 @@ var Itchpad = Class({
     let domHelper = new DOMHelpers(this.iframe.contentWindow);
     domHelper.onceDOMReady(domReady);
 
     this.iframe.setAttribute("src", ITCHPAD_URL);
 
     return deferred.promise;
   },
 
+  /**
+   * Build the itchpad DOM inside of this.iframe.
+   */
   _onLoad: function() {
     this.document = this.iframe.contentDocument;
     this.window = this.iframe.contentWindow;
 
     this._buildSidebar();
 
     this.window.addEventListener("unload", this.destroy.bind(this));
 
     // Editor management
-    this.shells = new ShellDeck(this.document, this);
+    this.shells = new ShellDeck(this, this.document);
     this.shells.on("editor-created", this._onEditorCreated);
     this.shells.on("editor-activated", this._onEditorActivated);
+    this.shells.on("editor-deactivated", this._onEditorDeactivated);
 
     let shellContainer = this.document.querySelector("#shells-deck-container");
     shellContainer.appendChild(this.shells.elt);
 
     let popup = this.document.querySelector("#edit-menu-popup");
     popup.addEventListener("popupshowing", this.updateEditorMenuItems);
 
-    // Store/Resource management
-    this.resourceMap = new ResourceMap();
+    // We are not allowing preset projects for now - rebuild a fresh one
+    // each time.
+    this.setProject(new Project({
+      id: "",
+      name: "",
+      directories: [],
+      openFiles: []
+    }));
 
-    if (!this.project) {
-      this.project = new Project({
-        id: "Test",
-        name: "App",
-        directories: [],
-        openFiles: []
-      });
-    }
-    this.setProject(this.project);
-    this.setPage(new PageCollection());
-
+    this._initCommands();
     this._initPlugins();
   },
 
+
+  /**
+   * Create the project tree sidebar that lists files.
+   */
   _buildSidebar: function() {
-    // Create the sources sidebar
-    this.projectTree = new CollectionTree(this.document, {
-      nodeVisible: this.nodeVisible.bind(this),
-      nodeFormatter: this.formatNode.bind(this)
+    this.projectTree = new ProjectTreeView(this.document, {
+      resourceVisible: this.resourceVisible.bind(this),
+      resourceFormatter: this.resourceFormatter.bind(this)
     });
-    this.projectTree.on("selection", this._onNodeSelection);
+    this.projectTree.on("selection", this._onTreeSelected);
 
     let sourcesBox = this.document.querySelector("#sources");
     sourcesBox.appendChild(this.projectTree.elt);
 
     // Plugin/inspection sidebar
     let tabbox = this.document.querySelector("#sidebar");
     this.sidebar = new ToolSidebar(tabbox, this, "itchpad");
     ViewHelpers.togglePane({
       visible: false,
       delayed: false,
       animated: false
     }, this.document.querySelector("#sidebar-box"));
   },
 
-  _initPlugins: function() {
+  /**
+   * Set up listeners for commands to dispatch to all of the plugins
+   */
+  _initCommands: function() {
     this.commands = this.document.querySelector("#itchpad-commandset");
     this.commands.addEventListener("command", (evt) => {
       evt.stopPropagation();
       evt.preventDefault();
       this.pluginDispatch("onCommand", evt.target.id, evt.target);
     });
-    this.pluginMethods = {};
-    this.loadPlugins();
   },
 
+  /**
+   * Initialize each plugin in registeredPlugins
+   */
+  _initPlugins: function() {
+    this._plugins = [];
+
+    for (let plugin of registeredPlugins) {
+      try {
+        this._plugins.push(plugin(this));
+      } catch(ex) {
+        console.exception(ex);
+      }
+    }
+
+    this.pluginDispatch("lateInit");
+  },
+
+  /**
+   * Enable / disable necessary menu items using globalOverlay.js.
+   */
   _updateEditorMenuItems: function() {
     this.window.goUpdateGlobalEditMenuItems();
     this.window.goUpdateGlobalEditMenuItems();
     let commands = ['cmd_undo', 'cmd_redo', 'cmd_delete', 'cmd_findAgain'];
     commands.forEach(this.window.goUpdateCommand);
   },
 
+  /**
+   * Destroy all objects on the iframe unload event.
+   */
   destroy: function() {
     this._plugins.forEach(plugin => { plugin.destroy(); });
-    this.projectTree.forgetCollection();
+
+    [...this.project.allResources()].forEach((resource) => {
+      let editor = this.editorFor(resource);
+      if (editor) {
+        editor.destroy();
+      }
+    });
+
+    forget(this, this.project);
+    this.project.destroy();
+    this.project = null;
     this.projectTree.destroy();
     this.projectTree = null;
   },
 
-  // Set the current project viewed by the itchpad.
+  /**
+   * Set the current project viewed by the itchpad.
+   *
+   * @param Project project
+   *        The project to set.
+   */
   setProject: function(project) {
+    if (this.project) {
+      forget(this, this.project);
+    }
     this.project = project;
-    this.resourceMap.setProject(project);
-    this.projectTree.setCollection(project);
+    this.projectTree.setProject(project);
+
+    // Whenever a store gets removed, clean up any editors that
+    // exist for resources within it.
+    on(this, project, "store-removed", (store) => {
+      [...store.allResources()].forEach((resource) => {
+        let editor = this.editorFor(resource);
+        if (editor) {
+          editor.destroy();
+        }
+      });
+    });
   },
 
+  /**
+   * Set the current project viewed by the itchpad.
+   *
+   * @param string path
+   *               The file path to set
+   * @param Object opts
+   *               Custom options used by the project. See plugins/app-manager.
+   * @param Promise
+   *        Promise that is resolved once the project is ready to be used.
+   */
   setProjectToSinglePath: function(path, opts = {}) {
-    let existingPaths = [...this.projectTree.models].map(model=>model.path);
-    console.log(
-      "Setting project to single path: " + path,
-      "Existing paths: ", existingPaths.join(", ")
-    );
     this.project.customOpts = opts;
     this.project.projectType = "APP_MANAGER";
-    this.project.removePaths(existingPaths);
+    this.project.removeAllStores();
     this.project.addPath(path);
-    this.project.save();
+    return this.project.refresh();
   },
 
-  setPage: function(page) {
-    this.page = page;
-    this.resourceMap.setPage(page);
+  /**
+   * Open a resource in a particular shell.
+   *
+   * @param Resource resource
+   *                 The file to be opened.
+   */
+  openResource: function(resource) {
+    this.shells.open(resource);
+    this.projectTree.selectResource(resource);
   },
 
-  openResource: function(resource) {
-    let pair = this.resourceMap.pair(resource);
-    let shell = this.shells.open(pair, resource);
-
-    this.projectTree.select(resource);
-  },
-
-  // When a node is selected in the tree, open its associated editor.
-  _onNodeSelection: function(resource) {
-    // XXX: Should check to see if there is a suitable editor rather
-    // than blacklisting these types
+  /**
+   * When a node is selected in the tree, open its associated editor.
+   *
+   * @param Resource resource
+   *                 The file that has been selected
+   */
+  _onTreeSelected: function(resource) {
+    // Don't attempt to open a directory that is not the root element.
     if (resource.isDir && resource.parent) {
       return;
     }
+    this.pluginDispatch("onTreeSelected", resource);
     this.openResource(resource);
   },
 
   /**
-   * Plugin UI commands.  These aren't really great, we should rethink these.
+   * Create an xul element with options
+   *
+   * @param string type
+   *               The tag name of the element to create.
+   * @param Object options
+   *               "command": DOMNode or string ID of a command element.
+   *               "parent": DOMNode or selector of parent to append child to.
+   *               anything other keys are set as an attribute as the element.
+   * @returns DOMElement
+   *          The element that has been created.
    */
-
   createElement: function(type, options) {
     let elt = this.document.createElement(type);
 
     let parent;
 
     for (let opt in options) {
       if (opt === "command") {
         let command = typeof(options.command) === "string" ? options.command : options.command.id;
@@ -240,25 +320,39 @@ var Itchpad = Class({
         parent = this.document.querySelector(parent);
       }
       parent.appendChild(elt);
     }
 
     return elt;
   },
 
-  getLocalizedString: function(name) {
-    try {
-      return L10N.GetStringFromName(name);
-    } catch (ex) {
-      console.log("Error reading '" + name + "'");
-      throw new Error("l10n error with " + name);
-    }
+  /**
+   * Create a "menuitem" xul element with options
+   *
+   * @param Object options
+   *               See createElement for available options.
+   * @returns DOMElement
+   *          The menuitem that has been created.
+   */
+  createMenuItem: function(options) {
+    return this.createElement("menuitem", options);
   },
 
+  /**
+   * Add a command to the itchpad document.
+   * This method is meant to be used with plugins.
+   *
+   * @param Object definition
+   *               key: a key/keycode string. Example: "f".
+   *               id: Unique ID.  Example: "find".
+   *               modifiers: Key modifiers. Example: "accel".
+   * @returns DOMElement
+   *          The command element that has been created.
+   */
   addCommand: function(definition) {
     let command = this.document.createElement("command");
     command.setAttribute("id", definition.id);
     if (definition.key) {
       let key = this.document.createElement("key");
       key.id = "key_" + definition.id;
 
       let keyName = definition.key;
@@ -271,297 +365,215 @@ var Itchpad = Class({
       key.setAttribute("command", definition.id);
       this.document.getElementById("itchpad-keyset").appendChild(key);
     }
     command.setAttribute("oncommand", "void(0);"); // needed. See bug 371900
     this.document.getElementById("itchpad-commandset").appendChild(command);
     return command;
   },
 
-
-  createMenuItem: function(options) {
-    return this.createElement("menuitem", options);
-  },
-
-  createToolbarGroup: function(options) {
-    return this.createElement("hbox", merge({
-      class: "devtools-toolbarbutton-group"
-    }, options));
-  },
-
-  createToolbarButton: function(options) {
-    return this.createElement("toolbarbutton", merge({
-      class: "devtools-toolbarbutton"
-    }, options));
-  },
-
-  addSidebar: function(name, url) {
-    let deferred = promise.defer();
-
-    this.sidebar.once(name + "-ready", () => {
-      deferred.resolve(this.sidebar.getWindowForTab(name));
-    });
-    this.sidebar.addTab(name, url, false);
-
-    return deferred.promise;
-  },
-
-  showSidebar: function(name) {
-    this.sidebar.select(name);
-    let sidebar = this.document.getElementById("sidebar-box");
-    ViewHelpers.togglePane({ visible: true, animated: true, delayed: true }, sidebar);
-  },
-
-  hideSidebar: function() {
-    let sidebar = this.document.getElementById("sidebar-box");
-    ViewHelpers.togglePane({ visible: false, animated: true, delayed: true }, sidebar);
-  },
-
-  loadPlugins: function() {
-    this._plugins = [];
-
-    for (let plugin of registeredPlugins) {
-      try {
-        this._plugins.push(plugin(this));
-      } catch(ex) {
-        console.exception(ex);
-      }
-    }
-
-    this.pluginDispatch("lateInit");
-  },
-
+  /**
+   * Get the instance of a plugin registered with a certain type.
+   *
+   * @param Type pluginType
+   *             The type, such as SavePlugin
+   * @returns Plugin
+   *          The plugin instance matching the specified type.
+   */
   getPlugin: function(pluginType) {
     for (let plugin of this.plugins) {
       if (plugin.constructor === pluginType) {
         return plugin;
       }
     }
     return null;
   },
 
+  /**
+   * Get all plugin instances active for the current plugin
+   *
+   * @returns [Plugin]
+   */
   get plugins() {
     if (!this._plugins) {
       console.log("plugins requested before _plugins was set");
       return [];
     }
     return this._plugins.filter(plugin => {
       return !this.project.projectType ||
              !plugin.projectType ||
              this.project.projectType === plugin.projectType;
     });
   },
 
+  /**
+   * Dispatch an onEditorCreated event, and listen for other events specific
+   * to this editor instance.
+   *
+   * @param Editor editor
+   *               The new editor instance.
+   */
   _onEditorCreated: function(editor) {
-    this.plugins.forEach(plugin => plugin.onEditorCreated(editor));
-    this._editorListen(editor, "change", "onEditorChange");
-    this._editorListen(editor, "cursorActivity", "onEditorCursorActivity");
-    this._containerListen(editor, "load", "onEditorLoad");
-    this._containerListen(editor, "save", "onEditorSave");
+    this.pluginDispatch("onEditorCreated", editor);
+    this._editorListenAndDispatch(editor, "change", "onEditorChange");
+    this._editorListenAndDispatch(editor, "cursorActivity", "onEditorCursorActivity");
+    this._editorListenAndDispatch(editor, "load", "onEditorLoad");
+    this._editorListenAndDispatch(editor, "save", "onEditorSave");
   },
 
-  _onEditorActivated: function(editor) {
+  /**
+   * Dispatch an onEditorActivated event and finish setting up once the
+   * editor is ready to use.
+   *
+   * @param Editor editor
+   *               The editor instance, which is now appended in the document.
+   * @param Resource resource
+   *               The resource used by the editor
+   */
+  _onEditorActivated: function(editor, resource) {
     editor.setToolbarVisibility();
-    this.plugins.forEach(plugin => plugin.onEditorActivated(editor));
+    this.pluginDispatch("onEditorActivated", editor, resource);
+  },
+
+  /**
+   * Dispatch an onEditorDactivated event once an editor loses focus
+   *
+   * @param Editor editor
+   *               The editor instance, which is no longer active.
+   * @param Resource resource
+   *               The resource used by the editor
+   */
+  _onEditorDeactivated: function(editor, resource) {
+    this.pluginDispatch("onEditorDeactivated", editor, resource);
   },
 
   /**
    * Call a method on all plugins that implement the method.
+   * Also emits the same handler name on `this`.
+   *
+   * @param string handler
+   *               Which function name to call on plugins.
+   * @param ...args args
+   *                All remaining parameters are passed into the handler.
    */
   pluginDispatch: function(handler, ...args) {
-    // XXX: EMIT ON this as well and document the events
+    // XXX: Memory leak when console.log an Editor here
+    // console.log("DISPATCHING EVENT TO PLUGIN", handler, args);
+    emit(this, handler, ...args);
     this.plugins.forEach(plugin => {
       try {
         if (handler in plugin) plugin[handler](...args);
       } catch(ex) {
         console.error(ex);
       }
     })
   },
 
-  _containerListen: function(editor, event, handler) {
+  /**
+   * Listen to an event on the editor object and dispatch it
+   * to all plugins that implement the associated method
+   *
+   * @param Editor editor
+   *               Which editor to listen to
+   * @param string event
+   *               Which editor event to listen for
+   * @param string handler
+   *               Which plugin method to call
+   */
+  _editorListenAndDispatch: function(editor, event, handler) {
     editor.on(event, (...args) => {
-      this.pluginDispatch(handler, editor, ...args);
-    });
-  },
-
-  _editorListen: function(editor, event, handler) {
-    if (!editor.editor) {
-      return;
-    }
-    editor.editor.on(event, (...args) => {
-      this.pluginDispatch(handler, editor, ...args);
+      this.pluginDispatch(handler, editor, this.resourceFor(editor), ...args);
     });
   },
 
   /**
-   * Set the current devtools target for the pad.
-   */
-  setTarget: function(target, own=false) {
-    if (target === this.target) {
-      return promise.resolve();
-    }
-
-    if (this.ownsTarget && this.target) {
-      this.target.destroy();
-    }
-
-    this._webConsolePromise = null;
-    this.ownsTarget = own;
-    this.target = target;
-
-    let remote = target ? target.makeRemote() : promise.resolve();
-
-    return remote.then(() => {
-      this.page.setTarget(target);
-      emit(this, "target-changed");
-    }).then(null, console.error);
-  },
-
-  /**
-   * Get a WebConsoleClient for communicating with the current target.
-   */
-  getWebConsoleClient: function() {
-    if (this._webConsolePromise) {
-      return this._webConsolePromise;
-    }
-    let deferred = promise.defer();
-    this.target.client.attachConsole(this.target.form.consoleActor, [], (response, consoleClient) => {
-      try {
-        if (response.error) {
-          deferred.reject(response.error);
-          return;
-        }
-        deferred.resolve(consoleClient);
-      } catch(ex) {
-        console.error(ex);
-      }
-    });
-    this._webConsolePromise = deferred.promise;
-    return deferred.promise
-  },
-
-  /**
-   * Find a shell for an editor, pair, or resource.
+   * Find a shell for a resource.
+   *
+   * @param Resource resource
+   *                 The file to be opened.
+   * @returns Shell
    */
   shellFor: function(resource) {
-    let pair = this.pairFor(resource);
-    return this.shells.shellFor(pair);
+    return this.shells.shellFor(resource);
   },
 
   /**
    * Returns the Editor for a given resource.
+   *
+   * @param Resource resource
+   *                 The file to check.
+   * @returns Editor
+   *          Instance of the editor for this file.
    */
   editorFor: function(resource) {
     let shell = this.shellFor(resource);
     return shell ? shell.editor : shell;
   },
 
   /**
-   * Returns the Pair that matches a given editor, pair, or resource.
+   * Returns a resource for the given editor
+   *
+   * @param Editor editor
+   *               The editor to check
+   * @returns Resource
+   *          The resource associated with this editor
    */
-  pairFor: function(thing) {
-    if (thing instanceof Pair) {
-      return thing;
+  resourceFor: function(editor) {
+    if (editor && editor.shell && editor.shell.resource) {
+      return editor.shell.resource;
     }
-    if (thing instanceof Resource) {
-      return this.resourceMap.pair(thing);
-    }
-    if (thing.pair) {
-      return thing.pair;
-    }
-    throw new Error("Don't know how to get a pair associated with: " + thing);
+    return null;
   },
 
   /**
-   * Returns a live resource for the given editor, pair, or resource.
+   * Decide whether a given resource should be hidden in the tree.
+   *
+   * @param Resource resource
+   *                 The resource in the tree
+   * @returns Boolean
+   *          True if the node should be visible, false if hidden.
    */
-  liveFor: function(thing) {
-    let pair = this.pairFor(thing);
-    return pair ? pair.live : null;
-  },
-
-  /**
-   * Returns a project resource for the given editor, pair, or resource.
-   */
-  projectFor: function(thing) {
-    let pair = this.pairFor(thing);
-    return pair ? pair.project : null;
-  },
-
-  /**
-   * Decide whether a given node should be hidden in the tree.
-   */
-  nodeVisible: function(node) {
+  resourceVisible: function(resource) {
     return true;
   },
 
   /**
-   * Format the given node for display in the resource tree.
+   * Format the given node for display in the resource tree view.
+   *
+   * @param Resource resource
+   *                 The file to be opened.
+   * @param DOMNode elt
+   *                The element in the tree to render into.
    */
-  formatNode: function(node, elt) {
-    let editor = this.editorFor(node);
+  resourceFormatter: function(resource, elt) {
+    let editor = this.editorFor(resource);
     let renderedByPlugin = false;
 
-    if (this.plugins) {
-      this.plugins.forEach(plugin => {
-        if (!plugin.onAnnotate) {
-          return;
-        }
-        if (plugin.onAnnotate(node, editor, elt)) {
-          renderedByPlugin = true;
-        }
-      });
-    }
+    // Allow plugins to override default templating of resource in tree.
+    this.plugins.forEach(plugin => {
+      if (!plugin.onAnnotate) {
+        return;
+      }
+      if (plugin.onAnnotate(resource, editor, elt)) {
+        renderedByPlugin = true;
+      }
+    });
 
+    // If no plugin wants to handle it, just use a string from the resource.
     if (!renderedByPlugin) {
-      elt.textContent = node.displayName;
+      elt.textContent = resource.displayName;
     }
   },
 
   get sourcesVisible() {
     return this.sourceToggle.hasAttribute("pane-collapsed");
   },
 
   get currentShell() {
     return this.shells.currentShell;
   },
 
   get currentEditor() {
     return this.shells.currentEditor;
   },
 });
 
-var CollectionTree = Class({
-  extends: TreeView,
-
-  initialize: function(document, options) {
-    TreeView.prototype.initialize.call(this, document, options);
-  },
-
-  forgetCollection: function() {
-    if (this.coll) {
-      forget(this, this.coll);
-      for (let store of this.coll.allStores()) {
-        this.removeModel(store);
-      }
-    }
-  },
-
-  setCollection: function(coll) {
-    this.forgetCollection();
-    this.coll = coll;
-    if (this.coll) {
-      on(this, coll, "store-added", this.addModel.bind(this));
-      on(this, coll, "store-removed", this.removeModel.bind(this));
-      on(this, coll, "project-saved", this.refresh.bind(this));
-      this.refresh();
-    }
-  },
-
-  refresh: function() {
-    for (let store of this.coll.allStores()) {
-      this.addModel(store);
-    }
-  }
-});
-
 exports.Itchpad = Itchpad;
diff --git a/browser/devtools/itchpad/lib/menuitems.js b/browser/devtools/itchpad/lib/menuitems.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/menuitems.js
+++ /dev/null
@@ -1,222 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-
-'use strict';
-
-const windowUtils = require("sdk/deprecated/window-utils");
-const { Class } = require("sdk/core/heritage");
-const { validateOptions } = require("sdk/deprecated/api-utils");
-const { on, emit, once, off } = require("sdk/event/core");
-const { isBrowser } = require("sdk/window/utils");
-const { EventTarget } = require('sdk/event/target');
-const menuitemNS = require("sdk/core/namespace").ns();
-
-const { unload } = require('unloader');
-
-const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
-function MenuitemOptions(options) {
-  return validateOptions(options, {
-    id: { is: ['string'] },
-    menuid: { is: ['undefined', 'string'] },
-    insertbefore: { is: ['undefined', 'string', 'object', 'number'] },
-    label: { is: ["string"] },
-    include: { is: ['string', 'undefined'] },
-    disabled: { is: ["undefined", "boolean"], map: function(v) !!v},
-    accesskey: { is: ["undefined", "string"] },
-    key: { is: ["undefined", "string"] },
-    checked: { is: ['undefined', 'boolean'] },
-    className: { is: ["undefined", "string"] },
-    onCommand: { is: ['undefined', 'function'] },
-    useChrome: { map: function(v) !!v }
-  });
-}
-
-let Menuitem = Class({
-  extends: EventTarget,
-  initialize: function(options) {
-    options = menuitemNS(this).options = MenuitemOptions(options);
-    EventTarget.prototype.initialize.call(this, options);
-
-    menuitemNS(this).destroyed = false;
-    menuitemNS(this).unloaders = [];
-    menuitemNS(this).menuitems = addMenuitems(this, options).menuitems;
-  },
-  get id() menuitemNS(this).options.id,
-  get label() menuitemNS(this).options.label,
-  set label(val) updateProperty(this, 'label', val),
-  get checked() menuitemNS(this).options.checked,
-  set checked(val) updateProperty(this, 'checked', !!val),
-  get disabled() menuitemNS(this).options.disabled,
-  set disabled(val) updateProperty(this, 'disabled', !!val),
-  get key() menuitemNS(this).options.key,
-  set key(val) updateProperty(this, 'key', val),
-  clone: function (overwrites) {
-    let opts = Object.clone(menuitemNS(this).options);
-    for (let key in overwrites) {
-      opts[key] = ovrewrites[key];
-    }
-    return Menuitem(opts);
-  },
-  get menuid() menuitemNS(this).options.menuid,
-  set menuid(val) {
-    let options = menuitemNS(this).options;
-    options.menuid = val;
-
-    forEachMI(function(menuitem, i, $) {
-      updateMenuitemParent(menuitem, options, $);
-    });
-  },
-  destroy: function() {
-    if (!menuitemNS(this).destroyed) {
-      menuitemNS(this).destroyed = true;
-      menuitemNS(this).unloaders.forEach(function(u) u());
-      menuitemNS(this).unloaders = null;
-      menuitemNS(this).menuitems = null;
-    }
-    return true;
-  }
-});
-
-function addMenuitems(self, options) {
-  let menuitems = [];
-
-  // setup window tracker
-  windowUtils.WindowTracker({
-    onTrack: function (window) {
-      if (menuitemNS(self).destroyed) return;
-      if (options.include) {
-        if (options.include != window.location) return;
-      }
-      else if (!isBrowser(window)) {
-        return;
-      }
-
-      // add the new menuitem to a menu
-      var menuitem = updateMenuitemAttributes(
-          window.document.createElementNS(NS_XUL, "menuitem"), options);
-      var menuitems_i = menuitems.push(menuitem) - 1;
-
-      // add the menutiem to the ui
-      let added = updateMenuitemParent(menuitem, options, function(id) window.document.getElementById(id));
-
-      menuitem.addEventListener("command", function() {
-        if (!self.disabled)
-          emit(self, 'command', options.useChrome ? window : null);
-      }, true);
-
-      // add unloader
-      let unloader = function unloader() {
-        menuitem.parentNode && menuitem.parentNode.removeChild(menuitem);
-        menuitems[menuitems_i] = null;
-      };
-
-      menuitemNS(self).unloaders.push(function() {
-        remover();
-        unloader();
-      });
-
-      let remover = unload(unloader, window);
-    }
-
-  });
-
-  return { menuitems: menuitems };
-}
-
-function updateMenuitemParent(menuitem, options, $) {
-  // add the menutiem to the ui
-  if (Array.isArray(options.menuid)) {
-      let ids = options.menuid;
-      for (var len = ids.length, i = 0; i < len; i++) {
-        if (tryParent($(ids[i]), menuitem, options.insertbefore))
-          return true;
-      }
-  }
-  else {
-    return tryParent($(options.menuid), menuitem, options.insertbefore);
-  }
-
-  return false;
-}
-
-function updateMenuitemAttributes(menuitem, options) {
-  menuitem.setAttribute("id", options.id);
-  menuitem.setAttribute("label", options.label);
-
-  if (options.accesskey)
-    menuitem.setAttribute("accesskey", options.accesskey);
-
-  if (options.key)
-    menuitem.setAttribute("key", options.key);
-
-  menuitem.setAttribute("disabled", !!options.disabled);
-
-  if (options.image) {
-    menuitem.classList.add("menuitem-iconic");
-    menuitem.style.listStyleImage = "url('" + options.image + "')";
-  }
-
-  if (options.checked)
-    menuitem.setAttribute('checked', options.checked);
-
-  if (options.className)
-    options.className.split(/\s+/).forEach(function(name) menuitem.classList.add(name));
-
-  return menuitem;
-}
-
-function updateProperty(menuitem, key, val) {
-  menuitemNS(menuitem).options[key] = val;
-
-  forEachMI(function(menuitem) {
-    menuitem.setAttribute(key, val);
-  }, menuitem);
-  return val;
-}
-
-function forEachMI(callback, menuitem) {
-  menuitemNS(menuitem).menuitems.forEach(function(mi, i) {
-    if (!mi) return;
-    callback(mi, i, function(id) mi.ownerDocument.getElementById(id));
-  });
-}
-
-function tryParent(parent, menuitem, before) {
-  if (parent) {
-    if (!before) {
-      parent.appendChild(menuitem);
-      return true;
-    }
-
-    parent.insertBefore(menuitem, insertBefore(parent, before));
-    return true;
-  }
-
-  return false;
-}
-
-function insertBefore(parent, insertBefore) {
-  if (typeof insertBefore == "number") {
-    switch (insertBefore) {
-      case MenuitemExport.FIRST_CHILD:
-        return parent.firstChild;
-    }
-    return null;
-  }
-  else if (typeof insertBefore == "string") {
-    return parent.querySelector("#" + insertBefore);
-  }
-  return insertBefore;
-}
-
-function MenuitemExport(options) {
-  return Menuitem(options);
-}
-MenuitemExport.FIRST_CHILD = 1;
-
-exports.Menuitem = MenuitemExport;
diff --git a/browser/devtools/itchpad/lib/page.js b/browser/devtools/itchpad/lib/page.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/page.js
+++ /dev/null
@@ -1,31 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const { StoreCollection } = require("itchpad/store-collection");
-const { StylesStore } = require("itchpad/stores/styles");
-
-// This is a bad name for the collection of stores tied to the live target.
-// Target was already taken, Live didn't sound right.  A rename would be
-// welcome.
-var PageCollection = Class({
-  extends: StoreCollection,
-
-  initialize: function() {
-    StoreCollection.prototype.initialize.call(this);
-
-    this.styles = new StylesStore();
-    this.addStore(this.styles);
-  },
-
-  setTarget: function(target) {
-    for (let store of this.stores) {
-      store.setTarget(target);
-    }
-  }
-});
-
-exports.PageCollection = PageCollection;
diff --git a/browser/devtools/itchpad/lib/path-match.js b/browser/devtools/itchpad/lib/path-match.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/path-match.js
+++ /dev/null
@@ -1,121 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/**
- * A quick check that the characters in 'search' appear in 'path'.
- * Used for quick trimming of search space.
- */
-exports.quickMatch = function(search, path) {
-  let index = -1;
-  for (let i = 0; i < search.length; i++) {
-    index = path.indexOf(search[i], index + 1);
-    if (index === -1) {
-      break;
-    }
-  }
-  return (index !== -1);
-}
-
-/**
- * A slower check that makes sure search terms can be found on word
- * boundaries.
- */
-
-const BOUNDARY_RE = /\W/;
-
-function charTest(ch) {
-  if (BOUNDARY_RE.test(ch)) {
-    return "(?:(\\" + ch + ")|(.*)(\\" + ch + "))";
-  } else {
-    return "(?:(" + ch + ")|(.*)\\b(" + ch + "))";
-  }
-}
-
-exports.pathMatchExpression = function(search) {
-  let ch = search[0];
-  let ch = BOUNDARY_RE.test(ch) ? "\\" + ch : ch;
-  let expr = "(.*)(?:(^" + ch + ")|(.*)\\b(" + ch + "))";
-  for (let i = 1; i < search.length; i++) {
-    expr += charTest(search[i]);
-  }
-  expr += "(.*)";
-  return new RegExp(expr);
-}
-
-exports.annotate = function(re, path) {
-  // The regular expression is constructed such that each character in the
-  // search has three matches:
-  // First will match for an immediate match
-  // Second will match any interstitial path
-  // Third will match if second matches.
-
-  let matches = re.exec(path);
-  if (!matches) {
-    return null;
-  }
-
-  let open = null;
-  let fragments = [];
-
-  // 0 unused by exec, 3 matches expected per char, leading and trailing text
-  if (matches.length % 3 != 0) {
-    throw new Error("Unexpected match length!");
-  }
-
-  if (matches[1]) {
-    fragments.push({ fragment: matches[1], matched: false });
-  }
-
-  for (let i = 2; i < matches.length - 1; i += 3) {
-    let immediate = matches[i];
-    let interstitial = matches[i + 1];
-    let newWord = matches[i + 2];
-
-    if (immediate) {
-      if (!open) {
-        open = { fragment: immediate, matched: true };
-        fragments.push(open);
-      } else {
-        open.fragment += immediate;
-      }
-    } else {
-      if (interstitial) {
-        fragments.push({ fragment: interstitial, matched: false });
-      }
-
-      open = { fragment: newWord, matched: true };
-      fragments.push(open);
-    }
-  }
-
-  // ... and one trailing match for remaining stuff.
-  let last = matches[matches.length - 1];
-  if (last) {
-    fragments.push({ fragment: last, matched: false });
-  }
-
-  return fragments;
-}
-
-exports.score = function(re, path) {
-  let annotated = exports.annotate(re, path);
-  if (!annotated) {
-    return 0;
-  }
-
-  let score = 0;
-  for (let item of annotated) {
-    if (item.matched && item.fragment.length > score) {
-      score = item.fragment.length;
-    }
-  }
-
-  // Among items with the same score, prefer matches later
-  // in the string.
-  score = (score << 16) + (annotated[0].matched ? 0 : annotated[0].fragment.length & 0xffff);
-
-  return score;
-}
diff --git a/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js b/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js
--- a/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js
+++ b/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js
@@ -1,27 +1,40 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
 const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const promise = require("itchpad/helpers/promise");
 const { ItchEditor } = require("itchpad/editors");
 
 var AppProjectEditor = Class({
   extends: ItchEditor,
 
   hidesToolbar: true,
 
   initialize: function(document, host) {
-    ItchEditor.prototype.initialize.call(this, document);
+    ItchEditor.prototype.initialize.apply(this, arguments);
     this.appended = promise.resolve();
     this.host = host;
+    this.label = "app-manager";
+  },
+
+  destroy: function() {
+    this.elt.remove();
+    this.elt = null;
   },
 
   load: function(resource) {
     this.elt.textContent = "";
     let {customOpts} = this.host.project;
-    let iframe = this.elt.ownerDocument.createElement("iframe");
+    let iframe = this.iframe = this.elt.ownerDocument.createElement("iframe");
     iframe.setAttribute("flex", "1");
     iframe.setAttribute("src", customOpts.projectOverviewURL);
     this.elt.appendChild(iframe);
+    this.emit("load");
   }
 });
 
 exports.AppProjectEditor = AppProjectEditor;
diff --git a/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js
--- a/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js
+++ b/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js
@@ -10,37 +10,37 @@ const { AppProjectEditor } = require("./
 var AppManagerRenderer = Class({
   extends: Plugin,
 
   projectType: "APP_MANAGER",
 
   isAppManagerProject: function() {
     return this.host.project.projectType === "APP_MANAGER";
   },
-  editorForResource: function(node) {
-    if (!node.parent && this.isAppManagerProject()) {
+  editorForResource: function(resource) {
+    if (!resource.parent && this.isAppManagerProject()) {
       return AppProjectEditor;
     }
   },
-  onAnnotate: function(node, editor, elt) {
-    if (node.parent || !this.isAppManagerProject()) {
+  onAnnotate: function(resource, editor, elt) {
+    if (resource.parent || !this.isAppManagerProject()) {
       return;
     }
 
     let {customOpts} = this.host.project;
     let doc = elt.ownerDocument;
     let image = doc.createElement("image");
     let label = doc.createElement("label");
     let versionLabel = doc.createElement("label");
 
     label.className = "project-name-label";
     versionLabel.className = "project-version-label";
     image.className = "project-image";
 
-    let name = customOpts.name || node.basename;
+    let name = customOpts.name || resource.basename;
     let version = customOpts.version || "v0.0.1";
     let url = customOpts.iconUrl || "icon-sample.png";
 
     label.textContent = name;
     versionLabel.textContent = version;
     image.setAttribute("src", url);
 
     elt.innerHTML = "";
diff --git a/browser/devtools/itchpad/lib/plugins/apply/lib/apply.js b/browser/devtools/itchpad/lib/plugins/apply/lib/apply.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/plugins/apply/lib/apply.js
+++ /dev/null
@@ -1,72 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-var { Class } = require("sdk/core/heritage");
-var { registerPlugin, Plugin } = require("itchpad/plugins/core");
-const timers = require("sdk/timers");
-
-const DEFAULT_THROTTLE_DELAY = 500;
-
-var ApplyPlugin = Class({
-  extends: Plugin,
-
-  init: function(host) {
-    this.needsUpdate = new Set();
-  },
-
-  onEditorChange: function(editor) {
-    this.scheduleAutoUpdate(editor);
-  },
-
-  onCommand: function(cmd) {
-    // If we haven't been auto-applying, at least apply on save (not
-    // sure this is great behavior, but I'm gonna try it)
-    if (cmd === "cmd-save") {
-      let editor = this.host.currentEditor;
-      this.apply(editor);
-    }
-  },
-
-  scheduleAutoUpdate: function(editor) {
-    let live = this.host.liveFor(editor);
-    if (!live || !live.canAutoApply) {
-      return;
-    }
-
-    this.needsUpdate.add(editor);
-    if (this._updateTask) {
-      timers.clearTimeout(this._updateTask);
-    }
-
-    this._updateTask = timers.setTimeout(this.applyUpdates.bind(this), DEFAULT_THROTTLE_DELAY);
-  },
-
-  applyUpdates: function() {
-    if (this._updateTask) {
-      timers.clearTimeout(this._updateTask);
-      this._updateTask = null;
-    }
-
-    for (let editor of this.needsUpdate) {
-      console.log("applying auto update of " + editor);
-
-      this.apply(editor);
-    }
-    this.needsUpdate = new Set();
-  },
-
-  apply: function(editor) {
-    let live = this.host.liveFor(editor);
-    if (!live || !live.apply) {
-      return;
-    }
-
-    let text = editor.editor.getText();
-    live.apply(text);
-  }
-});
-exports.ApplyPlugin = ApplyPlugin;
-registerPlugin(ApplyPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/core.js b/browser/devtools/itchpad/lib/plugins/core.js
--- a/browser/devtools/itchpad/lib/plugins/core.js
+++ b/browser/devtools/itchpad/lib/plugins/core.js
@@ -36,16 +36,18 @@ var Plugin = Class({
     if (!this._privData) {
       this._privData = new WeakMap();
     }
     if (!this._privData.has(item)) {
        this._privData.set(item, {});
     }
     return this._privData.get(item);
   },
+  onTreeSelected: function(resource) {},
+
 
   // Editor state lifetime...
   onEditorCreated: function(editor) {},
   onEditorDestroyed: function(editor) {},
 
   onEditorActivated: function(editor) {
     if (this._showFor) {
       let category = editor.category;
diff --git a/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js b/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js
--- a/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js
+++ b/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js
@@ -1,35 +1,36 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Class } = require("sdk/core/heritage");
 const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { localizedStrings } = require("itchpad/helpers/l10n");
 
 var DeletePlugin = Class({
   extends: Plugin,
 
   init: function(host) {
     this.host.addCommand({
       id: "cmd-delete"
     });
     this.host.createMenuItem({
       parent: "#directory-menu-popup",
-      label: this.host.getLocalizedString("itchpad.deleteLabel"),
+      label: localizedStrings.deleteLabel,
       command: "cmd-delete"
     });
   },
 
   onCommand: function(cmd) {
     if (cmd === "cmd-delete") {
       let tree = this.host.projectTree;
-      let resource = tree.getSelected();
+      let resource = tree.getSelectedResource();
       let parent = resource.parent;
       tree.deleteNode(resource).then(() => {
         this.host.project.refresh();
       })
     }
   }
 });
 
diff --git a/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js b/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
--- a/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
+++ b/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
@@ -10,26 +10,27 @@ const { emit } = require("sdk/event/core
 
 var DirtyPlugin = Class({
   extends: Plugin,
 
   onEditorSave: function(editor) { this.onEditorChange(editor); },
   onEditorLoad: function(editor) { this.onEditorChange(editor); },
 
   onEditorChange: function(editor) {
+    // Only run on a TextEditor
     if (!editor || !editor.editor) {
       return;
     }
-    let tree = this.host.tree;
 
     // Dont' force a refresh unless the dirty state has changed...
     let priv = this.priv(editor);
     let clean = editor.editor.isClean();
     if (priv.isClean !== clean) {
-      let resource = editor.shell.project;
+
+      let resource = editor.shell.resource;
       emit(resource, "label-change", resource);
       priv.isClean = clean;
     }
   },
 
   onAnnotate: function(resource, editor, elt) {
     if (editor && editor.editor && !editor.editor.isClean()) {
       elt.textContent = '*' + resource.displayName;
diff --git a/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js b/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js
--- a/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js
+++ b/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js
@@ -7,17 +7,17 @@
 const { Class } = require("sdk/core/heritage");
 const { registerPlugin, Plugin } = require("itchpad/plugins/core");
 const promise = require("itchpad/helpers/promise");
 const Editor  = require("devtools/sourceeditor/editor");
 const { Cu } = require("chrome");
 const { VariablesView } = Cu.import("resource:///modules/devtools/VariablesView.jsm", {});
 const { ObjectClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
 const { EnvironmentClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
-const OS = require("itchpad/helpers/osfile");
+const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
 
 var DragDropNew = Class({
   extends: Plugin,
 
   init: function(host) {
     this.onDrop = this.onDrop.bind(this);
     this.onDragOver = this.onDragOver.bind(this);
     this.dropzone = host.document.querySelector("#main-deck");
@@ -36,18 +36,16 @@ var DragDropNew = Class({
     var allTheFiles = event.dataTransfer.files || [];
 
     [...allTheFiles].forEach((file) => {
       let path = file.mozFullPath;
       if (file.type === "") {
         this.host.project.addPath(path);
       }
     });
-
-    this.host.project.save();
   },
 
   destroy: function() {
     this.dropzone.removeEventListener("dragover", this.onDragOver, true);
     this.dropzone.removeEventListener("drop", this.onDrop, true);
   }
 
 });
diff --git a/browser/devtools/itchpad/lib/plugins/fuzzy-search/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/fuzzy-search/lib/plugin.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/plugins/fuzzy-search/lib/plugin.js
+++ /dev/null
@@ -1,219 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const { registerPlugin, Plugin } = require("itchpad/plugins/core");
-const match = require("itchpad/path-match");
-
-const VISIBLE_RESULTS = 10;
-
-var Search = Class({
-  extends: Plugin,
-
-  init: function(host) {
-    this.command = this.host.addCommand({
-      id: "search-files",
-      key: "p",
-      modifiers: "accel"
-    });
-
-    this.searchBox = this.host.createElement("textbox", {
-      parent: "#plugin-toolbar-right",
-      type: "search",
-      timeout: "50",
-      hidden: true,
-      class: "devtools-searchinput",
-    });
-
-    this.panel = this.host.createElement("panel", {
-      parent: "window",
-      class: "results-panel",
-      level: "top",
-      noautofocus: "true",
-      consumeoutsideclicks: "false",
-      hidden: "true"
-    });
-
-    this.onSearchFocus = this.onSearchFocus.bind(this);
-    this.onSearchInput = this.onSearchInput.bind(this);
-    this.onSearchKey = this.onSearchKey.bind(this);
-
-    this.searchBox.addEventListener("focus", this.onSearchFocus, true);
-    this.searchBox.addEventListener("input", this.onSearchInput, true);
-    this.searchBox.addEventListener("keypress", this.onSearchKey, true);
-  },
-
-  populateHistory: function() {
-    let history = this.host.shells.history || { items: [] };
-    let results = [];
-
-    for (let i = history.items.length - 2; i >= 0; i--) {
-      let shell = history.items[i];
-      let project = shell.pair.project;
-      if (project) {
-        results.push({ score: 1, resource: project });
-      }
-    }
-    this.populate(results);
-  },
-
-  populate: function(searchResults, search) {
-    this.results = searchResults;
-    this.cards = [];
-
-    while (this.panel.firstChild) {
-      this.panel.removeChild(this.panel.firstChild);
-    }
-
-    let searchExpression = search ? match.pathMatchExpression(search) : null;
-
-    for (let i = 0; i < VISIBLE_RESULTS && i < searchResults.length; i++) {
-      let result = searchResults[i];
-      let card = this.cardFor(result.resource, searchExpression);
-      this.panel.appendChild(card);
-      this.cards.push(card);
-      let selectIndex = i;
-      card.addEventListener("click", () => {
-        this.select(selectIndex);
-        this.finish();
-      }, true);
-    }
-  },
-
-  onSearchFocus: function() {
-    this.selectedIndex = undefined;
-  },
-
-  onSearchInput: function() {
-    let index = this.host.project.index;
-
-    let search = this.searchBox.value;
-    let results = index.fuzzyMatchPath(this.searchBox.value);
-
-    results = results.sort((a, b) => {
-      let diff = b.score - a.score;
-      if (diff !== 0) return diff;
-      // Prefer longer URI matches
-      diff = b.resource.path.length - a.resource.path.length;
-      if (diff !== 0) return diff;
-      return a.resource.path.localeCompare(b.resource.path);
-    });
-
-    this.populate(results, search);
-    this.showPanel();
-    this.select(0);
-  },
-
-  onSearchKey: function(e) {
-    switch (e.keyCode) {
-      case e.DOM_VK_RETURN:
-      case e.DOM_VK_ENTER: {
-        this.finish();
-        break;
-      }
-      case e.DOM_VK_DOWN: {
-        let index = this.selectedIndex === undefined ? 0 : this.selectedIndex + 1;
-        this.select(index);
-        break;
-      }
-      case e.DOM_VK_UP: {
-        let index = this.selectedIndex === undefined ? 0 : this.selectedIndex - 1;
-        this.select(index);
-        break;
-      }
-      case e.DOM_VK_ESCAPE: {
-        this.finish();
-        break;
-      }
-    }
-  },
-
-  select: function(index) {
-    if (this.results.length < 1) {
-      return;
-    }
-
-    if (index < 0) {
-      index = 0;
-    }
-    if (index >= this.results.length) {
-      index = this.results.length - 1;
-    }
-
-    if (this.selectedIndex !== undefined) {
-      this.cards[this.selectedIndex].classList.remove("selected");
-    }
-    this.selectedIndex = index;
-    this.cards[index].classList.add("selected");
-    this.host.openResource(this.results[index].resource);
-  },
-
-  finish: function() {
-    if (this.selectedIndex === undefined && this.results && this.results.length > 0) {
-      this.selectedIndex = 0;
-    }
-    if (this.results[this.selectedIndex]) {
-      this.host.openResource(this.results[this.selectedIndex].resource);
-    }
-    this.panel.hidePopup();
-    this.searchBox.value = "";
-    this.searchBox.setAttribute("hidden", "true");
-    this.host.currentEditor.editor.focus();
-  },
-
-  cardFor: function(resource, search) {
-    let card = this.host.createElement("vbox", {
-      class: "light results-panel-item list-widget-item"
-    });
-
-    let name = this.host.createElement("label", {
-      parent: card,
-      class: "plain results-panel-item-name",
-      value: resource.basename
-    });
-
-    let details = this.host.createElement("label", {
-      parent: card,
-      class: "plain results-panel-item-details",
-    });
-
-    let displayPath = resource.relativePath();
-    let annotated = search ? match.annotate(search, displayPath) : null;
-    if (annotated) {
-      for (let fragment of annotated) {
-        let span = this.host.createElement("span", {
-          parent: details,
-          class: fragment.matched ? "results-panel-item-match" : "",
-        });
-        span.textContent = fragment.fragment;
-      }
-    } else {
-      details.setAttribute("value", resource.relativePath());
-    }
-
-    return card;
-  },
-
-  showPanel: function() {
-    this.panel.hidden = false;
-    this.panel.openPopup(this.searchBox, "after_start", 0, 0);
-  },
-
-  onCommand: function(cmd, target) {
-    if (cmd === "search-files") {
-      this.searchBox.removeAttribute("hidden");
-      this.searchBox.focus();
-      this.searchBox.select();
-      this.populateHistory();
-      if (this.results.length > 0) {
-        this.showPanel();
-      }
-    }
-  }
-});
-
-exports.Search = Search;
-registerPlugin(Search);
diff --git a/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js b/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js
--- a/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js
+++ b/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js
@@ -8,17 +8,17 @@ const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const promise = require("itchpad/helpers/promise");
 const { ItchEditor } = require("itchpad/editors");
 
 var ImageEditor = Class({
   extends: ItchEditor,
 
   initialize: function(document) {
-    ItchEditor.prototype.initialize.call(this, document);
+    ItchEditor.prototype.initialize.apply(this, arguments);
     this.label = "image";
     this.appended = promise.resolve();
   },
 
   load: function(resource) {
     let image = this.doc.createElement("image");
     image.className = "editor-image";
     image.setAttribute("src", resource.uri);
@@ -26,12 +26,14 @@ var ImageEditor = Class({
     let box1 = this.doc.createElement("box");
     box1.appendChild(image);
 
     let box2 = this.doc.createElement("box");
     box2.setAttribute("flex", 1);
 
     this.elt.appendChild(box1);
     this.elt.appendChild(box2);
+
+    this.emit("load");
   }
 });
 
 exports.ImageEditor = ImageEditor;
diff --git a/browser/devtools/itchpad/lib/plugins/new/lib/new.js b/browser/devtools/itchpad/lib/plugins/new/lib/new.js
--- a/browser/devtools/itchpad/lib/plugins/new/lib/new.js
+++ b/browser/devtools/itchpad/lib/plugins/new/lib/new.js
@@ -1,70 +1,71 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Class } = require("sdk/core/heritage");
 const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { localizedStrings } = require("itchpad/helpers/l10n");
 
 // Handles the save command.
 var NewFile = Class({
   extends: Plugin,
 
   init: function(host) {
     this.host.createMenuItem({
       parent: "#file-menu-popup",
-      label: this.host.getLocalizedString("itchpad.newLabel"),
+      label: localizedStrings.newLabel,
       command: "cmd-new",
       key: "key-new"
     });
     this.host.createMenuItem({
       parent: "#directory-menu-popup",
-      label: this.host.getLocalizedString("itchpad.newLabel"),
+      label: localizedStrings.newLabel,
       command: "cmd-new"
     });
 
     this.command = this.host.addCommand({
       id: "cmd-new",
       key: "n",
       modifiers: "accel"
     });
   },
 
   onCommand: function(cmd) {
     if (cmd === "cmd-new") {
       let tree = this.host.projectTree;
-      let resource = tree.getSelected();
+      let resource = tree.getSelectedResource();
       parent = resource.isDir ? resource : resource.parent;
       sibling = resource.isDir ? null : resource;
 
       if (!("createChild" in parent)) {
         return;
       }
 
       let extension = sibling ? sibling.contentCategory : parent.store.defaultCategory;
       let template = "untitled{1}." + extension;
       let name = this.suggestName(parent, template);
 
       tree.promptNew(name, parent, sibling).then(name => {
 
-        // XXX: do something about bad names.
+        // XXX: sanitize bad file names.
 
         // If the name is already taken, just add/increment a number.
         if (this.hasChild(parent, name)) {
           let matches = name.match(/([^\d.]*)(\d*)([^.]*)(.*)/);
           template = matches[1] + "{1}" + matches[3] + matches[4];
           name = this.suggestName(parent, template, parseInt(matches[2]) || 2);
         }
 
         return parent.createChild(name);
       }).then(resource => {
-        tree.select(resource);
+        tree.selectResource(resource);
         this.host.currentEditor.focus();
       }).then(null, console.error);
     }
   },
 
   suggestName: function(parent, template, start=1) {
     let i = start;
     let name;
diff --git a/browser/devtools/itchpad/lib/plugins/notify/lib/notify.js b/browser/devtools/itchpad/lib/plugins/notify/lib/notify.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/plugins/notify/lib/notify.js
+++ /dev/null
@@ -1,179 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const { registerPlugin, Plugin } = require("itchpad/plugins/core");
-const promise = require("itchpad/helpers/promise");
-
-const Editor  = require("devtools/sourceeditor/editor");
-
-const { Cu } = require("chrome");
-const { VariablesView } = Cu.import("resource:///modules/devtools/VariablesView.jsm", {});
-const { ObjectClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
-const { EnvironmentClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
-
-var Notify = Class({
-  extends: Plugin,
-
-  init: function(host) {
-    this.host.addCommand({
-      id: "cmd-hide-sidebar",
-      key: "VK_ESCAPE"
-    });
-    this.host.pluginMethods.notify = this;
-    this.host.createElement("splitter", {
-      parent: "#shells",
-      class: "devtools-horizontal-splitter",
-    });
-    this.div = this.host.createElement("div", {
-      parent: "#shells",
-      class: "output-pane",
-      flex: 1,
-      hidden: "true",
-    });
-
-  },
-
-  get client() { return this.host.target.client },
-
-  showPane: function() {
-    this.div.removeAttribute("hidden");
-    if (!this.editor) {
-      this.editor = new Editor({
-        mode: Editor.modes.text,
-        lineWrapping: true,
-        readOnly: true
-      });
-      this.appended = this.editor.appendTo(this.div);
-    }
-    return this.appended;
-  },
-
-  hidePane: function() {
-    this.div.setAttribute("hidden", "true");
-  },
-
-  onCommand: function(cmd) {
-    if (cmd === "cmd-hide-sidebar") {
-      this.host.hideSidebar();
-      this.hidePane();
-    }
-  },
-
-  info: function(item) {
-    this.showPane();
-    return this._writePrimitive(item).then(this._append.bind(this));
-  },
-
-  error: function(item) {
-    this.showPane();
-    return this._writeError(item).then(this._append.bind(this));
-  },
-
-  _append: function(value) {
-    return this.appended.then(() => {
-      let editor = this.editor;
-      let line = editor.lineCount();
-      editor.replaceText(value + "\n", { line: line, col: 0 });
-      editor.setFirstVisibleLine(line);
-    });
-  },
-
-  _writePrimitive: function(value) {
-    let deferred = promise.defer();
-    if (value.type == "longString") {
-      this.host.getWebConsoleClient().then(client => {
-        client.longString(value).substring(0, value.length, response => {
-          if (response.error) {
-            console.error("Display failed: " + response.error + " " + response.message);
-            deferred.reject(response);
-          } else {
-            deferred.resolve(response.substring);
-          }
-        });
-      });
-    } else {
-      deferred.resolve(value.type || value);
-    }
-
-    return deferred.promise;
-  },
-
-
-  _writeError: function(error) {
-    let deferred = promise.defer();
-
-    if (VariablesView.isPrimitive({ value: error })) {
-      let type = error.type;
-      if (type == "undefined" ||
-          type == "null" ||
-          type == "Infinity" ||
-          type == "-Infinity" ||
-          type == "NaN" ||
-          type == "-0") {
-        deferred.resolve(type);
-      } else if (type == "longString") {
-        deferred.resolve(error.initial + "\u2026");
-      } else {
-        deferred.resolve(error);
-      }
-    } else {
-      let objectClient = new ObjectClient(this.client, error);
-      objectClient.getPrototypeAndProperties(response => {
-        if (response.error) {
-          deferred.reject(response);
-          return;
-        }
-
-        let { ownProperties, safeGetterValues } = response;
-        let error = Object.create(null);
-
-        // Combine all the property descriptor/getter values into one object.
-        for (let key of Object.keys(safeGetterValues)) {
-          error[key] = safeGetterValues[key].getterValue;
-        }
-
-        for (let key of Object.keys(ownProperties)) {
-          error[key] = ownProperties[key].value;
-        }
-
-        // Assemble the best possible stack we can given the properties we have.
-        let stack;
-        if (typeof error.stack == "string") {
-          stack = error.stack;
-        } else if (typeof error.fileName == "number") {
-          stack = "@" + error.fileName;
-          if (typeof error.lineNumber == "number") {
-            stack += ":" + error.lineNumber;
-          }
-        } else if (typeof error.lineNumber == "number") {
-          stack = "@" + error.lineNumber;
-        }
-
-        stack = stack ? "\n" + stack.replace(/\n$/, "") : "";
-
-        if (typeof error.message == "string") {
-          deferred.resolve(error.message + stack);
-        } else {
-          objectClient.getDisplayString(response => {
-            if (response.error) {
-              deferred.reject(response);
-            } else if (typeof response.displayString == "string") {
-              deferred.resolve(response.displayString + stack);
-            } else {
-              deferred.resolve(stack);
-            }
-          });
-        }
-      });
-    }
-
-    return deferred.promise.then(value => "Exception: " + value);
-  },
-});
-exports.Notify = Notify;
-
-registerPlugin(Notify);
diff --git a/browser/devtools/itchpad/lib/plugins/open/lib/open.js b/browser/devtools/itchpad/lib/plugins/open/lib/open.js
--- a/browser/devtools/itchpad/lib/plugins/open/lib/open.js
+++ b/browser/devtools/itchpad/lib/plugins/open/lib/open.js
@@ -7,53 +7,33 @@
 const { Class } = require("sdk/core/heritage");
 const { registerPlugin, Plugin } = require("itchpad/plugins/core");
 const picker = require("itchpad/helpers/file-picker");
 
 var OpenPlugin = Class({
   extends: Plugin,
 
   init: function(host) {
-
     this.command = this.host.addCommand({
       id: "cmd-open",
       key: "o",
       modifiers: "accel"
     });
-
-    this.fileLabel = this.host.createElement("label", {
-      parent: "#plugin-toolbar-left",
-      class: "itchpad-file-label"
-    });
-    this.onTreeSelection = this.onTreeSelection.bind(this);
-    this.host.projectTree.on("selection", this.onTreeSelection);
-  },
-
-  destroy: function() {
-    this.host.projectTree.off("selection", this.onTreeSelection);
   },
 
   onCommand: function(cmd) {
     if (cmd === "cmd-open") {
       picker.showOpen({
         window: this.host.window
       }).then(path => {
         this.open(path);
       });
     }
   },
 
-  onTreeSelection: function(node) {
-    if (!node.isDir) {
-      this.fileLabel.textContent = node.basename;
-    } else if (!node.parent) {
-      this.fileLabel.textContent = "";
-    }
-  },
-
   open: function(path) {
     this.host.project.resourceFor(path).then(resource => {
       this.host.openResource(resource);
     });
   }
 });
 
 exports.OpenPlugin = OpenPlugin;
diff --git a/browser/devtools/itchpad/lib/plugins/save/lib/save.js b/browser/devtools/itchpad/lib/plugins/save/lib/save.js
--- a/browser/devtools/itchpad/lib/plugins/save/lib/save.js
+++ b/browser/devtools/itchpad/lib/plugins/save/lib/save.js
@@ -43,17 +43,17 @@ var SavePlugin = Class({
       this.save();
     } else if (cmd === "cmd-saveas") {
       this.saveAs();
     }
   },
 
   saveAs: function() {
     let editor = this.host.currentEditor;
-    let project = this.host.projectFor(editor);
+    let project = this.host.resourceFor(editor);
 
     let resource;
     picker.showSave({
       window: this.host.window,
       directory: project && project.parent ? project.parent.path : null,
       defaultName: project ? project.basename : null,
     }).then(path => {
       return this.createResource(path);
@@ -62,38 +62,26 @@ var SavePlugin = Class({
       return this.saveResource(editor, resource);
     }).then(() => {
       this.host.openResource(resource);
     }).then(null, console.error);
   },
 
   save: function() {
     let editor = this.host.currentEditor;
-    let project = this.host.projectFor(editor);
-    if (!project) {
+    let resource = this.host.resourceFor(editor);
+    if (!resource) {
       return this.saveAs();
     }
 
-    return this.saveResource(editor, project);
+    return this.saveResource(editor, resource);
   },
 
   createResource: function(path) {
     return this.host.project.resourceFor(path, { create: true })
   },
 
   saveResource: function(editor, resource) {
-    // If this wasn't a project editor, update the project
-    // editor.
-    let shell = this.host.shellFor(resource);
-    let projectEditor = shell ? shell.editor.project : null;
-    let text = -1;
-    if (projectEditor && projectEditor !== editor) {
-      text = editor.editor.getText();
-    }
-    return editor.save(resource).then(() => {
-      if (text != -1) {
-        projectEditor.editor.setText(text);
-      }
-    });
+    return editor.save(resource);
   }
 })
 exports.SavePlugin = SavePlugin;
 registerPlugin(SavePlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js
--- a/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js
+++ b/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js
@@ -4,16 +4,20 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const promise = require("itchpad/helpers/promise");
 const { registerPlugin, Plugin } = require("itchpad/plugins/core");
 
+/**
+ * Print information about the currently opened file
+ * and the state of the current editor
+ */
 var StatusBarPlugin = Class({
   extends: Plugin,
 
   init: function() {
     this.box = this.host.createElement("hbox", {
       parent: "#itchpad-toolbar-bottom"
     });
 
@@ -21,42 +25,83 @@ var StatusBarPlugin = Class({
       parent: this.box,
       class: "itchpad-basic-display"
     });
 
     this.cursorPosition = this.host.createElement("label", {
       parent: this.box,
       class: "itchpad-basic-display"
     });
+
+    this.fileLabel = this.host.createElement("label", {
+      parent: "#plugin-toolbar-left",
+      class: "itchpad-file-label"
+    });
   },
 
-  render: function(editor) {
+  destroy: function() {
+  },
+
+  /**
+   * Print information about the current state of the editor
+   *
+   * @param Editor editor
+   */
+  render: function(editor, resource) {
+    if (!resource || resource.isDir) {
+      this.fileLabel.textContent = "";
+      this.cursorPosition.value = "";
+      return;
+    }
+
+    this.fileLabel.textContent = resource.basename;
     this.activeMode.value = editor.toString();
     if (editor.editor) {
       let cursorStart = editor.editor.getCursor("start");
       let cursorEnd = editor.editor.getCursor("end");
       if (cursorStart.line === cursorEnd.line && cursorStart.ch === cursorEnd.ch) {
         this.cursorPosition.value = cursorStart.line + " " + cursorStart.ch;
       } else {
         this.cursorPosition.value = cursorStart.line + " " + cursorStart.ch + " | " +
                                     cursorEnd.line + " " + cursorEnd.ch;
       }
     } else {
       this.cursorPosition.value = "";
     }
   },
 
-  onEditorChange: function(editor) {
-    this.render(editor);
+
+  /**
+   * Print the current file name
+   *
+   * @param Resource resource
+   */
+  onTreeSelected: function(resource) {
+    if (!resource || resource.isDir) {
+      this.fileLabel.textContent = "";
+      return;
+    }
+    console.log("ON TREE SELECTION");
+    this.fileLabel.textContent = resource.basename;
   },
 
-  onEditorCursorActivity: function(editor) {
-    this.render(editor);
+  onEditorDeactivated: function(editor) {
+    console.log("ON DEACTIVATE");
+    this.fileLabel.textContent = "";
+    this.cursorPosition.value = "";
   },
 
-  onEditorActivated: function(editor) {
-    this.render(editor);
+  onEditorChange: function(editor, resource) {
+    this.render(editor, resource);
+  },
+
+  onEditorCursorActivity: function(editor, resource) {
+    this.render(editor, resource);
+  },
+
+  onEditorActivated: function(editor, resource) {
+    this.render(editor, resource);
   },
 
 });
 
 exports.StatusBarPlugin = StatusBarPlugin;
 registerPlugin(StatusBarPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/style/lib/style.js b/browser/devtools/itchpad/lib/plugins/style/lib/style.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/plugins/style/lib/style.js
+++ /dev/null
@@ -1,22 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-var { Class } = require("sdk/core/heritage");
-var { registerPlugin, Plugin } = require("itchpad/plugins/core");
-
-var StyleAnnotation = Class({
-  extends: Plugin,
-  onAnnotate: function(resource, editor) {
-    if (!resource.sheet) {
-      return;
-    }
-
-    return " (" + resource.sheet.ruleCount + " rules)";
-  }
-});
-exports.StyleAnnotation = StyleAnnotation;
-
-registerPlugin(StyleAnnotation);
diff --git a/browser/devtools/itchpad/lib/project-index.js b/browser/devtools/itchpad/lib/project-index.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/project-index.js
+++ /dev/null
@@ -1,96 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const match = require("itchpad/path-match");
-
-var IndexMap = Class({
-  initialize: function() {
-    this.map = new Map();
-  },
-
-  add: function(key, item) {
-    let set = this.map.get(key)
-    if (!set) {
-      set = new Set();
-      this.map.set(key, set);
-    }
-    set.add(item);
-  },
-
-  remove: function(key, item) {
-    let set = this.map.get(key);
-    if (!set) {
-      return;
-    }
-    set.delete(item);
-  },
-
-  get: function(key) {
-    return this.map.get(key) || new Set();
-  },
-
-  keys: function() {
-    let keys = new Set();
-    for (let [key, value] of this.map) {
-      keys.add(key);
-    }
-    return keys;
-  }
-});
-
-var ProjectIndex = Class({
-  initialize: function() {
-    this.basenames = new IndexMap();
-    this.relativePaths = new IndexMap();
-  },
-
-  add: function(resource) {
-    this.basenames.add(resource.basename, resource);
-    let path = resource.relativePath();
-    this.relativePaths.add(path, resource);
-  },
-
-  remove: function(resource) {
-    this.basenames.remove(resource.basename, resource);
-  },
-
-  findBasename: function(basename) {
-    return this.basenames.get(basename);
-  },
-
-  fuzzyMatchPath: function(search) {
-    let start = Date.now();
-
-    let candidates = [];
-    for (let path of this.relativePaths.keys()) {
-      if (match.quickMatch(search, path)) {
-        candidates.push(path);
-      }
-    }
-
-    let matches = [];
-    let candidateMisses = [];
-    let re = match.pathMatchExpression(search);
-    for (let candidate of candidates) {
-      let score = match.score(re, candidate);
-      if (score > 0) {
-        for (let resource of this.relativePaths.get(candidate)) {
-          if (!resource.isDir) {
-            matches.push({ score: score, resource: resource });
-          }
-        }
-      }
-    }
-
-    console.log("Search took " + (Date.now() - start) + " and returned " + matches.length + " results.");
-
-    return matches;
-  }
-});
-exports.ProjectIndex = ProjectIndex;
-
-
diff --git a/browser/devtools/itchpad/lib/project.js b/browser/devtools/itchpad/lib/project.js
--- a/browser/devtools/itchpad/lib/project.js
+++ b/browser/devtools/itchpad/lib/project.js
@@ -1,367 +1,239 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const { EventTarget } = require("sdk/event/target");
 const { emit } = require("sdk/event/core");
-const { scope } = require("itchpad/event/scope");
+const { scope, on, forget } = require("itchpad/helpers/event");
 const prefs = require("sdk/preferences/service");
 const { LocalStore } = require("itchpad/stores/local");
-const OS = require("itchpad/helpers/osfile");
-const task = require("itchpad/helpers/task");
-const { ProjectIndex } = require("itchpad/project-index");
+const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
+const { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
 const promise = require("itchpad/helpers/promise");
 const { TextEncoder, TextDecoder } = require('sdk/io/buffer');
-const { indexedDB } = require('sdk/indexed-db');
 const url = require('sdk/url');
-const { StoreCollection } = require("itchpad/store-collection");
 
 const gDecoder = new TextDecoder();
 const gEncoder = new TextEncoder();
 
-// I'm fairly certain this could be merged with the app-manager project
-// store with a bit of work on the app-manager side.
-var IDBProjectStore = {
-  _db: null,
+/**
+ * A Project keeps track of the opened folders using LocalStore
+ * objects.  Resources are generally requested from the project,
+ * even though the Store is actually keeping track of them.
+ */
+var Project = Class({
+  extends: EventTarget,
 
-  _request: function(request) {
-    let deferred = promise.defer();
-    request.onerror = function(event) {
-      deferred.reject(event.target.errorCode);
-    };
-    request.onsuccess = function(event) {
-      deferred.resolve(event.target.result);
-    }
-    return deferred.promise;
+  /**
+   * Intialize the Project.
+   *
+   * @param Object options
+   *               Options to be passed into Project.load function
+   */
+  initialize: function(options) {
+    this.localStores = new Map();
+
+    this.load(options);
   },
 
-  _open: function() {
-    if (this._openPromise) {
-      return this._openPromise;
-    }
-
-    let deferred = promise.defer();
-    this._openPromise = deferred.promise;
-
-    let request = indexedDB.open("DevtoolsEditorProjects", 1);
-    request.onerror = (event) => {
-      deferred.reject("Unable to open DevtoolsEdtiorProjects indexedDB. " +
-                       "Error code: " + event.target.errorCode);
-    };
-    request.onupgradeneeded = (event) => {
-      let db = event.target.result;
-      db.createObjectStore("projects", { keyPath: "id" });
-    };
-    request.onsuccess = () => {
-      deferred.resolve(request.result);
-    };
-
-    return this._openPromise;
+  destroy: function() {
+    // We are removing the store because the project never gets persisted.
+    // There may need to be separate destroy functionality that doesn't remove
+    // from project if this is saved to DB.
+    this.removeAllStores();
   },
 
-  all: function() {
-    if (this._cachedProjects) {
-      return this._cachedProjects;
-    }
-
-    this._cachedProjects = this._open().then(db => {
-      let objectStore = db.transaction("projects").objectStore("projects");
-
-      let projects = [];
-      let deferred = promise.defer();
-      objectStore.openCursor().onsuccess = (event) => {
-        let cursor = event.target.result;
-        if (cursor) {
-          projects.push(cursor.value);
-          cursor.continue();
-        } else {
-          deferred.resolve(projects);
-        }
-      };
-      return deferred.promise;
-    });
-
-    return this._cachedProjects;
+  toString: function() {
+    return "[Project] " + this.name;
   },
 
-  get: function(id) {
-    return this.all().then(projects => {
-      for (let project of projects) {
-        if (project.id === id) {
-          return project;
-        }
-      }
-      return null;
-    });
-  },
+  /**
+   * Load a project given metadata about it.
+   *
+   * @param Object options
+   *               Information about the project, containing:
+   *                id: An ID (currently unused, but could be used for saving)
+   *                name: The display name of the project
+   *                directories: An array of path strings to load
+   */
+  load: function(options) {
+    this.id = options.id;
+    this.name = options.name || "Untitled";
 
-  add: function(project) {
-    return this._open().then(db => {
-      if (!project.id) {
-        return promise.reject("Project must have an id field");
-      }
-
-      return this._request(db.transaction(["projects"], "readwrite")
-        .objectStore("projects")
-        .add(project)).then(() => {
-          this._cachedProjects = null;
-          return project;
-        });
-    });
-  },
-
-  update: function(project) {
-    return this._open().then(db => {
-      return this._request(db.transaction(["projects"], "readwrite")
-        .objectStore("projects")
-        .put(project)).then(() => {
-          this._cachedProjects = null;
-          return project;
-        });
-    });
-  },
-
-  remove: function(id) {
-    return this._open().then(db => {
-      return this._request(this._db.transaction(["projects"], "readwrite")
-        .objectStore("projects")
-        .delete(id)).then(() => { this._cachedProjects = null; });
-    });
-  }
-};
-
-var Projects = Class({
-  initialize: function() {
-    this.store = IDBProjectStore;
-    this._projectsById = new Map();
-  },
-
-  projectForID: function(id, create=false) {
-    if (this._projectsById.has(id)) {
-      return promise.resolve(this._projectsById.get(id));
-    }
-
-    return this.store.get(id).then(obj => {
-      if (!obj && !create) {
-        throw new Error("Project doesn't exist with id: " + id);
-      }
-
-      if (obj) {
-        return obj;
-      }
-
-      obj = emptyProject();
-      obj.id = id;
-      return this.store.add(obj);
-    }).then(obj => {
-      let proj = new Project(obj);
-      this._projectsById.set(id, proj);
-      return proj;
-    });
-  },
-
-  // Return the default project.
-  defaultProject: function() {
-    return this.projectForID("default", true);
-  },
-
-  forManifest: function(path) {
-    let id = "app:" + OS.Path.normalize(path);
-    let dir = OS.Path.dirname(path);
-
-    return this.projectForID(id, true).then(project => {
-      project.setManifest(path);
-      project.addPath(dir);
-      return project;
-    });
-  },
-});
-exports.Projects = new Projects();
-
-function emptyProject() {
-  return {
-    directories: [],
-    openFiles: []
-  };
-}
-
-// A project holds a list of local folders and maintains LocalStore objects
-// representing them.
-var Project = Class({
-  extends: StoreCollection,
-
-  initialize: function(info) {
-    StoreCollection.prototype.initialize.call(this);
-
-    this.index = new ProjectIndex();
-    this.localStores = new Map();
-
-    this.on("resource-added", this.onResourceAdded.bind(this));
-    this.on("resource-removed", this.onResourceRemoved.bind(this));
-
-    this.load(info);
-  },
-
-  toString: function() { return "[Project] " + this.name; },
-
-  load: function(data) {
-    this.id = data.id;
-    this.name = data.name || "Untitled";
-    if (data.pattern) {
-      this.pattern = data.pattern;
-      this.manualPattern = true;
-    } else {
-      this.pattern = "*";
-    }
-
-    let paths = new Set(data.directories.map(name => OS.Path.normalize(name)));
+    let paths = new Set(options.directories.map(name => OS.Path.normalize(name)));
 
     for (let [path, store] of this.localStores) {
       if (!paths.has(path)) {
         this.removePath(path);
       }
     }
 
     for (let path of paths) {
       this.addPath(path);
     }
-
-    this.setManifest(data.manifestPath);
   },
 
-  save: function() {
-    let data = emptyProject();
-
-    data.id = this.id;
-    data.name = this.name;
-    if (this.manualPattern) {
-      data.pattern = this.pattern;
-    }
-    data.manifest = this.manifestPath;
-    data.directories = [store.path for ([id, store] of this.localStores)];
-    return IDBProjectStore.update(data).then(() => {
-      emit(this, "project-saved");
-    });
-  },
-
-  setManifest: function(path, json=null) {
-    this.manifestPath = path;
-
-    let promise = json ? promise.resolve(json) : (OS.File.read(path).then(bytes => {
-      return JSON.parse(gDecoder.decode(bytes));
-    }));
-
-    return promise.then(json => {
-      this.manifest = json;
-      this.name = this.manifest.name || this.name;
-      if (!this.manualPattern) {
-        let dir = url.fromFilename(OS.Path.dirname(this.manifestPath));
-        this.pattern = dir + "*";
-      }
-    });
-  },
-
-  setName: function(name) {
-    this.name = name;
-    return this.save().then(() => {
-      emit(this, "name-change");
-    });
-  },
-
-  setPattern: function(pattern) {
-    this.manualPattern = true;
-    this.pattern = pattern;
-    return this.save().then(() => {
-      emit(this, "pattern-change");
-    });
-  },
-
+  /**
+   * Refresh all project stores from disk
+   *
+   * @returns Promise
+   *          A promise that resolves when everything has been refreshed.
+   */
   refresh: function() {
-    return task.spawn(function*() {
+    return Task.spawn(function*() {
       for (let [path, store] of this.localStores) {
         yield store.refresh();
       }
     }.bind(this));
   },
 
+
+  /**
+   * Fetch a resource from the backing storage system for the store.
+   *
+   * @param string path
+   *               The path to fetch
+   * @param Object options
+   *               "create": bool indicating whether to create a file if it does not exist.
+   * @returns Promise
+   *          A promise that resolves with the Resource.
+   */
   resourceFor: function(path, options) {
     let store = this.storeContaining(path);
     return store.resourceFor(path, options);
   },
 
+  /**
+   * Get every resource used inside of the project.
+   *
+   * @returns generator-iterator<Resource>
+   *          A list of all Resources in all Stores.
+   */
+  allResources: function*() {
+    for (let store of this.allStores()) {
+      for (let [key, resource] of store.resources) {
+        yield resource;
+      }
+    }
+  },
+
+  /**
+   * Get every Path used inside of the project.
+   *
+   * @returns generator-iterator<Store>
+   *          A list of all Stores
+   */
   allStores: function*() {
     for (let [path, store] of this.localStores) {
       yield store;
     }
   },
 
+  /**
+   * Get every file path used inside of the project.
+   *
+   * @returns generator-iterator<string>
+   *          A list of all file paths
+   */
+  allPaths: function*() {
+    for (let [path, store] of this.localStores) {
+      yield path;
+    }
+  },
+
+  /**
+   * Get the store that contains a path.
+   *
+   * @returns Store
+   *          The store, if any.  Will return null if no store
+   *          contains the given path.
+   */
   storeContaining: function(path) {
-    let ret = null;
-    for (let [id, store] of this.localStores) {
+    let containingStore = null;
+    for (let store of this.allStores()) {
       if (store.contains(path)) {
-        if (ret) {
-          // XXX
-          console.warning("Nested projects are going to cause pain.");
-        }
-        ret = store;
+        // With nested projects, the final containing store will be returned.
+        containingStore = store;
       }
     }
-    return ret;
+    return containingStore;
   },
 
+  /**
+   * Add a store at the current path.  If a store already exists
+   * for this path, then return it.
+   *
+   * @param string path
+   * @returns LocalStore
+   */
   addPath: function(path) {
     if (!this.localStores.has(path)) {
       this.addLocalStore(new LocalStore(path));
     }
+    return this.localStores.get(path);
   },
 
-  removePaths: function(paths) {
-    for (let path of paths) {
-      this.removePath(path);
+  /**
+   * Remove a store for a given path.
+   *
+   * @param string path
+   */
+  removePath: function(path) {
+    this.removeLocalStore(this.localStores.get(path));
+  },
+
+
+  /**
+   * Add the given Store to the project.
+   * Fires a 'store-added' event on the project.
+   *
+   * @param Store store
+   */
+  addLocalStore: function(store) {
+    store.canPair = true;
+    this.localStores.set(store.path, store);
+
+    // Originally StoreCollection.addStore
+    on(this, store, "resource-added", (resource) => {
+      emit(this, "resource-added", resource);
+    });
+    on(this, store, "resource-removed", (resource) => {
+      emit(this, "resource-removed", resource);
+    })
+
+    emit(this, "store-added", store);
+  },
+
+
+  /**
+   * Remove all of the Stores belonging to the project.
+   */
+  removeAllStores: function() {
+    for (let store of this.allStores()) {
+      this.removeLocalStore(store);
     }
   },
 
-  removePath: function(path) {
-    this.removeLocalStore(this.localStores.get(path));
-    this.localStores.delete(path);
-  },
-
-  addLocalStore: function(store) {
-    store.canPair = true;
-    this.localStores.set(store.path, store);
-    this.addStore(store);
-  },
-
+  /**
+   * Remove the given Store from the project.
+   * Fires a 'store-removed' event on the project.
+   *
+   * @param Store store
+   */
   removeLocalStore: function(store) {
+    // XXX: tree selection should be reset if active element is affected by
+    // the store being removed
     if (store) {
       this.localStores.delete(store.path);
-      this.removeStore(store);
+      forget(this, store);
+      emit(this, "store-removed", store);
+      store.destroy();
     }
-  },
-
-  onResourceAdded: function(resource) {
-    // Automatically use a manifest for this project if we find
-    // one in the only store that exists in the project.
-    if (!this.manifest
-        && resource.basename === "manifest.webapp"
-        && resource.parent === resource.store.root
-        && this.localStores.size === 1) {
-      this.setManifest(resource.path);
-    }
-
-    try {
-      this.index.add(resource);
-    } catch(ex) {
-      console.error(ex);
-    }
-  },
-
-  onResourceRemoved: function(resource) {
-    this.index.remove(resource);
   }
 });
+
 exports.Project = Project;
-
diff --git a/browser/devtools/itchpad/lib/resource-map.js b/browser/devtools/itchpad/lib/resource-map.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/resource-map.js
+++ /dev/null
@@ -1,294 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const { emit } = require("sdk/event/core");
-const { EventTarget } = require("sdk/event/target");
-const timers = require("sdk/timers");
-const { on, off, forget } = require("itchpad/event/scope");
-
-var Pair = Class({
-  extends: EventTarget,
-
-  initialize: function(map, project=null, live=null) {
-    this.map = map;
-    this._updateSource("project", project, false);
-    this._updateSource("live", live, false);
-  },
-
-  toString: function() {
-    return "[Pair " + this._project + ":" + this._live + "]";
-  },
-
-  get project() { return this._project },
-  set project(resource) {
-    this._updateSource("project", resource, true);
-  },
-
-  get live() { return this._live },
-  set live(resource) {
-    this._updateSource("live", resource, true);
-  },
-
-  _updateSource: function(aspect, resource, notify) {
-    let val = "_" + aspect;
-    let map = this.map;
-
-    if (resource === this[val]) {
-      return;
-    }
-
-    if (resource) {
-      // No other pair can own this.
-      let other = map.pairs.get(resource);
-      if (other) {
-        other[aspect] = null;
-      }
-    }
-
-    if (this[val]) {
-      map.pairs.delete(this[val]);
-    }
-
-    this[val] = resource;
-
-    if (resource) {
-      map.pairs.set(resource, this);
-    }
-
-    if (notify) {
-      emit(this, "changed", aspect);
-    }
-  }
-});
-
-exports.Pair = Pair;
-
-// Maintains the list of pairs.
-var ResourceMap = Class({
-  initialize: function() {
-    this.liveStores = new Set();
-    this.pairs = new Map();
-    this.manualPairs = new Map();
-
-    this.scheduleRebuild = this.scheduleRebuild.bind(this);
-  },
-
-  setProject: function(project) {
-    this.unwatchCollection(this.project);
-    this.project = project;
-    this.watchCollection(this.project);
-    this.scheduleRebuild();
-  },
-
-  setPage: function(page) {
-    this.unwatchCollection(this.page);
-    this.page = page;
-    this.watchCollection(this.page);
-    this.scheduleRebuild();
-  },
-
-  watchCollection: function(collection) {
-    on(this, collection, "resource-added", this.scheduleRebuild);
-    on(this, collection, "resource-removed", this.scheduleRebuild);
-  },
-
-  unwatchCollection: function(collection) {
-    forget(this, collection);
-  },
-
-  scheduleRebuild: function() {
-    if (this._scheduledRebuild) {
-      timers.clearTimeout(this._scheduledRebuild);
-    }
-    this._scheduledRebuild = timers.setTimeout(this.rebuild.bind(this), 100);
-  },
-
-  manualPair: function(project, live) {
-    let pair;
-
-    let pair = this.pairs.get(project);
-    if (!pair) {
-      pair = this.pairs.get(live);
-    }
-    if (!pair) {
-      pair = new Pair(this, project, live);
-    }
-    pair.project = project;
-    pair.live = live;
-
-    // XXX: Manual pairs should probably be by path, otherwise
-    // they won't last through a refresh.  Will fix that later.
-    this.manualPairs.set(live, pair);
-    this.rebuild();
-  },
-
-  /**
-   * Rebuild the project pairings.
-   */
-  rebuild: function() {
-    if (this._scheduledRebuild) {
-      timers.clearTimeout(this._scheduledRebuild);
-      this._scheduledRebuild = null;
-    }
-    let start = Date.now();
-    // Rules:
-    // - Pairs stay with the local resource if they change.
-
-    let newPairs = new Map();
-
-    // Walk through all live resources...
-    for (let live of this.page.allResources()) {
-      if (live.isDir) {
-        continue;
-      }
-
-      // If there's a manual pair, just trust it.
-      if (this.manualPairs.has(live)) {
-        let manual = this.manualPairs.get(live);
-        newPairs.set(manual.project, manual);
-        newPairs.set(manual.live, manual);
-        continue;
-      }
-
-      // Find a project resource for this resource...
-      let project = this._findPair(live);
-
-      if (!project) {
-        // No paired resource, no need to save a pair, but do
-        // keep the one-sided pair around if there is one.
-        let oldPair = this.pairs.get(live);
-        if (oldPair) {
-          // Just in case.
-          oldPair.project = null;
-
-          newPairs.set(live, oldPair);
-        }
-        continue;
-      }
-
-      // We have a real pair.  Update it if it already exists.
-      // XXX: This could leave us with an empty pair, make
-      // sure editors close properly...
-      let pair = this.pairs.get(project);
-      if (pair) {
-        pair.live = live;
-      } else {
-        pair = new Pair(this, project, live);
-      }
-      newPairs.set(live, pair);
-      newPairs.set(project, pair);
-
-      // Remove the project link from the map so the next pass
-      // doesn't pick it up.
-      this.pairs.delete(project);
-    }
-
-    // Now newPairs has pairs for all live resources that
-    // need them (either because they already had a single-sided pair
-    // in the wild or because they found a real pair)
-    // Now make sure that any project resources with an outstanding pair
-    // are included.
-    for (let project of this.project.allResources()) {
-      let newPair = newPairs.get(project);
-      if (newPair) {
-        // Already taken care of.
-        continue;
-      }
-      let oldPair = this.pairs.get(project);
-      if (oldPair) {
-        oldPair.live = null;
-        newPairs.set(project, oldPair);
-      }
-    }
-
-    this.pairs = newPairs;
-    let end = Date.now();
-    console.log("Rebuilt project map in " + (end - start) + "ms");
-  },
-
-  pair: function(resource) {
-    if (this.pairs.has(resource)) {
-      return this.pairs.get(resource);
-    }
-
-    // Didn't find a pair in the project map, go ahead and create
-    // a one-sided pair.
-    let pair;
-    if (resource.isProject) {
-      pair = new Pair(this, resource, null);
-    } else {
-      pair = new Pair(this, null, resource);
-    }
-    this.pairs.set(resource, pair);
-    return pair;
-  },
-
-  /**
-   * Find the best project pair for a given live resource.
-   *
-   * Right now we only have one strategy, but new strategies
-   * can be added here.
-   */
-  _findPair: function(live) {
-    return this._fuzzyStrategy(live);
-  },
-
-  /**
-   * The default fuzzy match strategy for finding a live pairing.
-   * Finds a project resources with the same basename, and chooses
-   * the one with the most path component matches.
-   */
-  _fuzzyStrategy: function(resource) {
-    let matches = this._findBasenameMatches(resource.basename);
-    if (matches.length < 1) {
-      return null;
-    }
-
-    let searchPath = resource.uri.path.split('/').filter(item => !!item);
-    searchPath.reverse();
-
-    let bestMatch = null;
-    let bestMatchComponents = 0;
-    let bestMatchExtra = 1000;
-    for (let match of matches) {
-      let matchPath = match.uri.path.split('/').filter(item => !!item);
-      matchPath.reverse();
-      let i;
-      for (i = 0; i < matchPath.length && i < searchPath.length; i++) {
-        if (matchPath[i] != searchPath[i]) {
-          break;
-        }
-      }
-
-      // In case of a tie in matched components, arbitrarily assume that
-      // resources closer to the project root are correct.
-      let remaining = matchPath.length - i;
-      if (i > bestMatchComponents ||
-          (i === bestMatchComponents && remaining < bestMatchExtra)) {
-        bestMatch = match;
-        bestMatchComponents = i;
-        bestMatchExtra = remaining;
-      }
-    }
-
-    return bestMatch;
-  },
-
-  _findBasenameMatches: function(basename) {
-    let matches = [];
-    for (let resource of this.project.index.findBasename(basename)) {
-      if (!resource.store.canPair) {
-        continue;
-      }
-      matches.push(resource);
-    }
-    return matches;
-  }
-});
-exports.ResourceMap = ResourceMap;
-
-
diff --git a/browser/devtools/itchpad/lib/shells.js b/browser/devtools/itchpad/lib/shells.js
--- a/browser/devtools/itchpad/lib/shells.js
+++ b/browser/devtools/itchpad/lib/shells.js
@@ -6,134 +6,186 @@
 
 const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const { EventTarget } = require("sdk/event/target");
 const { emit } = require("sdk/event/core");
 const { EditorTypeForResource } = require("itchpad/editors");
 const NetworkHelper = require("devtools/toolkit/webconsole/network-helper");
 
+/**
+ * The Shell is the object that manages the editor for a single resource.
+ * It is in charge of selecting the proper Editor (text/image/plugin-defined)
+ * and instantiating / appending the editor.
+ * This object is not exported, it is just used internally by the ShellDeck.
+ *
+ * This object has a promise `editorReady`, that will resolve once the editor
+ * is ready to be used.
+ */
 var Shell = Class({
   extends: EventTarget,
 
-  initialize: function(host, pair, selectedResource) {
+  /**
+   * @param Itchpad host
+   * @param Resource resource
+   */
+  initialize: function(host, resource) {
     this.host = host;
     this.doc = host.document;
-    this.pair = pair;
-    this.project = pair.project;
-    this.live = pair.live;
+    this.resource = resource;
     this.elt = this.doc.createElement("vbox");
     this.elt.shell = this;
 
-    this.editor = null;
+    let constructor = this._editorTypeForResource();
 
-    this._ensureEditor();
+    this.editor = constructor(this.doc, this.host);
+    this.editor.shell = this;
+    this.editorReady = this.editor.appended;
+
+    this.elt.appendChild(this.editor.elt);
+    this.editor.load(resource);
   },
 
-  _ensureEditor: function() {
-    if (this.editor) {
-      let editor = this.editor;
-      editor.appended.then(() => {
-        emit(this, "editor-activated", editor);
-      });
-      return;
-    }
-
-    let project = this.project;
-    let constructor = EditorTypeForResource(project);
+  /**
+   * Make sure the correct editor is selected for the resource.
+   * @returns Type:Editor
+   */
+  _editorTypeForResource: function() {
+    let resource = this.resource;
+    let constructor = EditorTypeForResource(resource);
 
     if (this.host.plugins) {
       this.host.plugins.forEach(plugin => {
         if (plugin.editorForResource) {
-          let pluginEditor = plugin.editorForResource(project);
+          let pluginEditor = plugin.editorForResource(resource);
           if (pluginEditor) {
             constructor = pluginEditor;
           }
         }
       });
     }
 
-    let editor = constructor(this.doc, this.host);
-    editor.appended.then(() => {
-      emit(this, "editor-created", editor);
-    });
-
-    this.editor = editor;
-    editor.shell = this;
-    editor.pair = this.pair;
-
-    this.elt.appendChild(editor.elt);
-    editor.appended.then(() => {
-      emit(this, "editor-activated", editor);
-    });
-    editor.load(project);
+    return constructor;
   }
 });
 
+/**
+ * The ShellDeck is in charge of managing the list of active Shells for
+ * the current Itchpad instance (aka host).
+ *
+ * This object emits the following events:
+ *   - "editor-created": When an editor is initially created
+ *   - "editor-activated": When an editor is ready to use
+ *   - "editor-deactivated": When an editor is ready to use
+ */
 var ShellDeck = Class({
   extends: EventTarget,
 
-  initialize: function(document, host) {
+  /**
+   * @param Itchpad host
+   * @param Document document
+   */
+  initialize: function(host, document) {
     this.doc = document;
     this.host = host;
     this.deck = this.doc.createElement("deck");
     this.deck.setAttribute("flex", "1");
     this.elt = this.deck;
 
     this.shells = new Map();
 
-    this._deactivateEditor = null;
+    this._activeShell = null;
   },
 
-  open: function(pair, defaultResource) {
-    // XXX: This doesn't work if pairing changes...
-    let shell = this.shells.get(pair);
+  /**
+   * Open a resource in a Shell.  Will create the Shell
+   * if it doesn't exist yet.
+   *
+   * @param Resource resource
+   *                 The file to be opened
+   * @returns Shell
+   */
+  open: function(defaultResource) {
+    let shell = this.shellFor(defaultResource);
     if (!shell) {
-      shell = this.createShell(pair, defaultResource);
-      this.shells.set(pair, shell);
+      shell = this._createShell(defaultResource);
+      this.shells.set(defaultResource, shell);
     }
     this.selectShell(shell);
     return shell;
   },
 
+  /**
+   * Create a new Sehll for a resource.  Called by `open`.
+   *
+   * @returns Shell
+   */
+  _createShell: function(defaultResource) {
+    let shell = Shell(this.host, defaultResource);
+    shell.editorReady.then(() => {
+      this.shells.set(shell.resource, shell);
+      emit(this, "editor-created", shell.editor);
+      if (this.currentShell === shell) {
+        this.selectShell(shell);
+      }
+    });
+    this.deck.appendChild(shell.elt);
+    return shell;
+  },
+
+  /**
+   * Select a given shell and open its editor.
+   * Will fire editor-deactivated on the old selected Shell (if any),
+   * and editor-activated on the new one once it is ready
+   *
+   * @param Shell shell
+   */
+  selectShell: function(shell) {
+    // Don't fire another activate if this is already the active shell
+    if (this._activeShell != shell) {
+      if (this._activeShell) {
+        emit(this, "editor-deactivated", this._activeShell.editor, this._activeShell.resource);
+      }
+      this.deck.selectedPanel = shell.elt;
+      this._activeShell = shell;
+      shell.editorReady.then(() => {
+        // Handle case where another shell has been requested before this
+        // one is finished loading.
+        if (this._activeShell === shell) {
+          emit(this, "editor-activated", shell.editor, shell.resource);
+        }
+      });
+    }
+  },
+
+  /**
+   * Find a Shell for a Resource.
+   *
+   * @param Resource resource
+   * @returns Shell
+   */
   shellFor: function(resource) {
     return this.shells.get(resource);
   },
 
-  selectShell: function(shell) {
-    if (this.deck.selectedPanel.shell != shell) {
-      this.deck.selectedPanel = shell.elt;
-    }
-    if (this._deactivateEditor != shell.editor) {
-      emit(this, "editor-deactivated", this._deactivateEditor);
-      shell.editor.appended.then(() => {
-        emit(this, "editor-activated", shell.editor);
-      });
-      this._deactivateEditor = shell.editor;
-    }
+  /**
+   * The currently active Shell.  Note: the editor may not yet be available
+   * on the current shell.  Best to wait for the 'editor-activated' event
+   * instead.
+   *
+   * @returns Shell
+   */
+  get currentShell() {
+    return this._activeShell;
   },
 
-  get currentShell() {
-    return this.deck.selectedPanel ? this.deck.selectedPanel.shell : null;
+  /**
+   * The currently active Editor, or null if it is not ready.
+   *
+   * @returns Editor
+   */
+  get currentEditor() {
+    let shell = this.currentShell;
+    return shell ? shell.editor : null;
   },
 
-  get currentEditor() {
-    let shell = this.currentShell;
-    return shell ? shell.editor : shell;
-  },
-
-  createShell: function(pair, defaultResource) {
-    let shell = Shell(this.host, pair, defaultResource);
-    shell.on("editor-created", (editor) => {
-      this.shells.set(shell.project, editor);
-      emit(this, "editor-created", editor);
-    });
-    shell.on("editor-activated", (editor) => {
-      if (this.currentShell === shell) {
-        emit(this, "editor-activated", editor);
-      }
-    });
-
-    this.deck.appendChild(shell.elt);
-    return shell;
-  },
 });
 exports.ShellDeck = ShellDeck;
diff --git a/browser/devtools/itchpad/lib/store-collection.js b/browser/devtools/itchpad/lib/store-collection.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/store-collection.js
+++ /dev/null
@@ -1,59 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Class } = require("sdk/core/heritage");
-const { EventTarget } = require("sdk/event/target");
-const { emit } = require("sdk/event/core");
-const { on, forget } = require("itchpad/event/scope");
-
-var StoreCollection = Class({
-  extends: EventTarget,
-
-  initialize: function() {
-    this.stores = new Set();
-  },
-
-  allStores: function*() {
-    for (let store of this.stores) {
-      yield store;
-    }
-  },
-
-  allResources: function*() {
-    for (let store of this.stores) {
-      for (let [key, resource] of store.resources) {
-        yield resource;
-      }
-    }
-  },
-
-  addStore: function(store) {
-    this.stores.add(store);
-    for (let resource of store.allResources()) {
-      this.onResourceAdded(resource);
-    }
-    on(this, store, "resource-added", (resource) => {
-      emit(this, "resource-added", resource);
-    });
-    on(this, store, "resource-removed", (resource) => {
-      emit(this, "resource-removed", resource);
-    })
-
-    emit(this, "store-added", store);
-  },
-
-  removeStore: function(store) {
-    store.destroy();
-    this.stores.delete(store);
-    for (let resource of store.allResources()) {
-      this.onResourceRemoved(resource);
-    }
-    forget(this, store);
-    emit(this, "store-removed", store);
-  }
-});
-
-exports.StoreCollection = StoreCollection;
diff --git a/browser/devtools/itchpad/lib/stores/base.js b/browser/devtools/itchpad/lib/stores/base.js
--- a/browser/devtools/itchpad/lib/stores/base.js
+++ b/browser/devtools/itchpad/lib/stores/base.js
@@ -3,168 +3,48 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Cc, Ci, Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const { EventTarget } = require("sdk/event/target");
 const { emit } = require("sdk/event/core");
-const URL = require("sdk/url");
 const promise = require("itchpad/helpers/promise");
 
 /**
  * A Store object maintains a collection of Resource objects stored in a tree.
- * A given store is either a Project store or a Live store.
+ * The Store class should not be instantiated directly.  Instead, you should
+ * use a class extending it - right now this is only a LocalStore.
+ *
+ * Events:
+ * This object emits the 'resource-added' and 'resource-removed' events.
  */
 var Store = Class({
   extends: EventTarget,
 
-  // Should be called during initialize() of a subclass.
+  /**
+   * Should be called during initialize() of a subclass.
+   */
   initStore: function() {
     this.resources = new Map();
   },
 
-  // Set the root resource.
-  setRoot: function(resource) {
-    this.root = resource;
-    this.notifyAdd(resource);
-  },
-
   refresh: function() {
     return promise.resolve();
   },
 
   allResources: function*() {
     for (let [key, resource] of this.resources) {
       yield resource;
     }
   },
 
   notifyAdd: function(resource) {
     emit(this, "resource-added", resource);
   },
 
   notifyRemove: function(resource) {
     emit(this, "resource-removed", resource);
-  },
-
-  notifyMissing: function(oldChildren, newChildren) {
-    for (let item of oldChildren) {
-      if (!newChildren.has(item)) {
-        this.notifyRemove(item);
-      }
-    }
   }
 });
 
-ProjectStore = Class({
-  extends: Store,
-  isProject: true,
-  isLive: false,
-  aspect: "project"
-});
-exports.ProjectStore = ProjectStore;
-
-LiveStore = Class({
-  extends: Store,
-  isProject: false,
-  isLive: true,
-  aspect: "live"
-});
-exports.LiveStore = LiveStore;
-
-var Resource = Class({
-  extends: EventTarget,
-
-  get isProject() { return this.store.isProject },
-  get aspect() { return this.store.aspect },
-
-  refresh: function() { return promise.resolve(this) },
-
-  setURI: function(uri) {
-    if (typeof(uri) === "string") {
-      uri = URL.URL(uri);
-    }
-    this._uriBasename = uriBasename(uri);
-    this.uri = uri;
-  },
-
-  get basename() { return this._uriBasename },
-  get displayName() { return this.basename },
-
-  get isDir() { return this.children !== undefined; },
-  get hasChildren() { return this.children && this.children.size > 0; },
-
-  setChildren: function(newChildren) {
-    let oldChildren = this.children || new Set();
-    let change = false;
-
-    for (let child of oldChildren) {
-      if (!newChildren.has(child)) {
-        change = true;
-        child.parent = null;
-        this.store.notifyRemove(child);
-      }
-    }
-
-    for (let child of newChildren) {
-      if (!oldChildren.has(child)) {
-        change = true;
-        child.parent = this;
-        this.store.notifyAdd(child);
-      }
-    }
-
-    this.children = newChildren;
-    if (change) {
-      emit(this, "children-changed", this);
-    }
-  },
-
-  addChild: function(resource) {
-    this.children = this.children || new Set();
-
-    resource.parent = this;
-    this.children.add(resource);
-    this.store.notifyAdd(resource);
-    emit(this, "children-changed", this);
-    return resource;
-  },
-
-  removeChild: function(resource) {
-    resource.parent = null;
-    this.children.remove(resource);
-    this.store.notifyRemove(resource);
-    emit(this, "children-changed", this);
-    return resource;
-  },
-
-  get contentType() { return "text/plain" },
-  get contentCategory() {
-    const NetworkHelper = require("devtools/toolkit/webconsole/network-helper");
-    let category = NetworkHelper.mimeCategoryMap[this.contentType];
-    // Boo hard-coding.
-    if (!category && this.basename === "manifest.webapp") {
-      return "json";
-    }
-    return category || "txt";
-  }
-});
-
-exports.Resource = Resource;
-
-// Surely there's a better way to do this.
-function uriBasename(uri) {
-  var basename = uri.path;
-
-  let idx = uri.path.lastIndexOf("/", basename.length - 2);
-  if (idx > -1) {
-    basename = uri.path.substring(idx + 1);
-  }
-
-  if (basename[basename.length - 1] === "/") {
-    basename = basename.substring(0, basename.length - 1);
-  }
-
-  return basename;
-}
-
+exports.Store = Store;
diff --git a/browser/devtools/itchpad/lib/stores/local.js b/browser/devtools/itchpad/lib/stores/local.js
--- a/browser/devtools/itchpad/lib/stores/local.js
+++ b/browser/devtools/itchpad/lib/stores/local.js
@@ -1,72 +1,73 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-/**
- * Hastily-written local file backend for ItchPad
- */
-
 const { Cc, Ci, Cu, ChromeWorker } = require("chrome");
 const { Class } = require("sdk/core/heritage");
-const { TextEncoder, TextDecoder } = require('sdk/io/buffer')
+const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
 const { emit } = require("sdk/event/core");
-const { ProjectStore, Resource } = require("itchpad/stores/base");
-const task = require("itchpad/helpers/task");
-const data = require("sdk/self").data;
+const { Store } = require("itchpad/stores/base");
+const { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
 const promise = require("itchpad/helpers/promise");
-const Task = require("itchpad/helpers/task");
-const URL = require("sdk/url");
-const OS = require("itchpad/helpers/osfile");
-const { FileUtils } = Cu.import("resource://gre/modules/FileUtils.jsm", {});
-const mimeService = Cc["@mozilla.org/mime;1"].getService(Ci.nsIMIMEService);
-
+const { on, forget } = require("itchpad/helpers/event");
+const { FileResource } = require("itchpad/stores/resource");
 
 const CHECK_LINKED_DIRECTORY_DELAY = 5000;
 const SHOULD_LIVE_REFRESH = true;
-const spawn = Task.spawn;
-
-const gDecoder = new TextDecoder();
-const gEncoder = new TextEncoder();
-
-// XXX: Ignores should probably be handled differently.
+// XXX: Ignores should be customizable
 const IGNORE_REGEX = /(^\.)|(\~$)|(^node_modules$)/;
 
+/**
+ * A Store object maintains a collection of Resource objects stored in a tree.
+ * The Store class should not be instantiated directly.  Instead, you should
+ * use a class extending it - right now this is only a LocalStore.
+ *
+ * This object emits the following events:
+ *   - "resource-added": When a resource is added
+ *   - "resource-removed": When a resource is removed
+ */
 var LocalStore = Class({
-  extends: ProjectStore,
+  extends: Store,
 
   defaultCategory: "js",
 
   initialize: function(path) {
     this.initStore();
     this.window = Cc["@mozilla.org/appshell/appShellService;1"].getService(Ci.nsIAppShellService).hiddenDOMWindow;
     this.path = OS.Path.normalize(path);
     this.rootPath = this.path;
     this.displayName = this.path;
-    this.setRoot(this._forPath(this.path));
+    this.root = this._forPath(this.path);
+    this.notifyAdd(this.root);
     this.refreshLoop = this.refreshLoop.bind(this);
     this.refreshLoop();
   },
 
   destroy: function() {
-    this.window.clearTimeout(this._refreshTimeout);
+    if (this.window) {
+      this.window.clearTimeout(this._refreshTimeout);
+    }
     if (this._refreshDeferred) {
       this._refreshDeferred.reject("destroy");
     }
-    this.worker.terminate();
+    if (this.worker) {
+      this.worker.terminate();
+    }
 
     this._refreshTimeout = null;
     this._refreshDeferred = null;
     this.window = null;
     this.worker = null;
 
     if (this.root) {
+      forget(this, this.root);
       this.root.destroy();
     }
   },
 
   toString: function() { return "[LocalStore:" + this.path + "]" },
 
   /**
    * Return a FileResource object for the given path.  If a FileInfo
@@ -82,31 +83,32 @@ var LocalStore = Class({
     this.resources.set(path, resource);
     return resource;
   },
 
   /**
    * Return a promise that resolves to a fully-functional FileResource
    * within this project.  This will hit the disk for stat info.
    * options:
+   *
    *   create: If true, a resource will be created even if the underlying
    *     file doesn't exist.
    */
   resourceFor: function(path, options) {
     path = OS.Path.normalize(path);
 
     if (this.resources.has(path)) {
       return promise.resolve(this.resources.get(path));
     }
 
     if (!this.contains(path)) {
       return promise.reject(new Error(path + " does not belong to " + this.path));
     }
 
-    return spawn(function() {
+    return Task.spawn(function() {
       let parent = yield this.resourceFor(OS.Path.dirname(path));
 
       let info;
       try {
         info = yield OS.File.stat(path);
       } catch (ex if ex instanceof OS.File.Error && ex.becauseNoSuchFile) {
         if (!options.create) {
           throw ex;
@@ -203,136 +205,8 @@ var LocalStore = Class({
         return false;
       }
     }
     return true;
   }
 });
 exports.LocalStore = LocalStore;
 
-var FileResource = Class({
-  extends: Resource,
-
-  initialize: function(store, path, info) {
-    this.store = store;
-    this.path = path;
-
-    this.setURI(URL.URL(URL.fromFilename(path)));
-    this._lastReadModification = undefined;
-
-    this.info = info;
-    this.parent = null;
-  },
-
-  toString: function() {
-    return "[FileResource:" + this.path + "]";
-  },
-
-  destroy: function() {
-    if (this._refreshDeferred) {
-      this._refreshDeferred.reject();
-    }
-    this._refreshDeferred = null;
-  },
-
-  // Fetch and cache information about this particular file
-  // https://developer.mozilla.org/en-US/docs/JavaScript_OS.File/OS.File_for_the_main_thread#OS.File.stat
-  refresh: function() {
-    if (this._refreshDeferred) {
-      return this._refreshDeferred.promise;
-    }
-    this._refreshDeferred = promise.defer();
-    OS.File.stat(this.path).then(info => {
-      this.info = info;
-      if (this._refreshDeferred) {
-        this._refreshDeferred.resolve(this);
-        this._refreshDeferred = null;
-      }
-    });
-    return this._refreshDeferred.promise;
-  },
-
-  get displayName() { return this.basename + (this.isDir ? "/" : "") },
-
-  get isDir() {
-    if (!this.info) { return false; }
-    return this.info.isDir && !this.info.isSymLink;
-  },
-
-  /**
-   * Returns the path relative to the store.  This is used for
-   * project search, there might be a better approach.
-   */
-  relativePath: function() {
-    if (!this._relativePath) {
-      if (this.path.startsWith(this.store.path)) {
-        this._relativePath = OS.Path.basename(this.store.path) + this.path.substring(this.store.path.length);
-      } else {
-        this._relativePath = this.path;
-      }
-    }
-    return this._relativePath;
-  },
-
-  /**
-   * Returns the text of the file as a promise.
-   */
-  load: function() {
-    return OS.File.read(this.path).then(bytes => {
-      return gDecoder.decode(bytes);
-    });
-  },
-
-  createChild: function(name, initial="") {
-    console.log("CREATING " + name);
-    if (!this.isDir) {
-      return promise.reject(new Error("Cannot add child to a regular file"));
-    }
-
-    let newPath = OS.Path.join(this.path, name);
-
-    let buffer = initial ? gEncoder.encode(initial) : "";
-    return OS.File.writeAtomic(newPath, buffer, {
-      noOverwrite: true
-    }).then(() => {
-      return this.store.refresh();
-    }).then(() => {
-      let resource = this.store.resources.get(newPath);
-      if (!resource) {
-        throw new Error("Error creating " + newPath);
-      }
-      return resource;
-    });
-  },
-
-  /**
-   * Write a string to the file.
-   */
-  save: function(str) {
-    let buffer = gEncoder.encode(str);
-    let path = this.path;
-
-    // XXX: This was losing permissions on save
-    // return OS.File.writeAtomic(this.path, buffer, { tmpPath: this.path + ".tmp" });
-
-    return task.spawn(function*() {
-        let pfh = yield OS.File.open(path, {truncate: true});
-        yield pfh.write(buffer);
-        yield pfh.close();
-    });
-  },
-
-  get contentType() {
-    if (this._contentType) {
-      return this._contentType;
-    }
-    if (this.isDir) {
-      return "x-directory/normal";
-    }
-    try {
-      this._contentType = mimeService.getTypeFromFile(new FileUtils.File(this.path));
-    } catch(ex) {
-      console.error(ex);
-      this._contentType = null;
-    }
-    return this._contentType;
-  }
-});
diff --git a/browser/devtools/itchpad/lib/stores/resource.js b/browser/devtools/itchpad/lib/stores/resource.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/stores/resource.js
@@ -0,0 +1,250 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const { Cc, Ci, Cu } = require("chrome");
+const { TextEncoder, TextDecoder } = require('sdk/io/buffer');
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const URL = require("sdk/url");
+const promise = require("itchpad/helpers/promise");
+const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
+const { FileUtils } = Cu.import("resource://gre/modules/FileUtils.jsm", {});
+const mimeService = Cc["@mozilla.org/mime;1"].getService(Ci.nsIMIMEService);
+const { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
+
+const gDecoder = new TextDecoder();
+const gEncoder = new TextEncoder();
+
+var Resource = Class({
+  extends: EventTarget,
+
+  refresh: function() { return promise.resolve(this) },
+
+  setURI: function(uri) {
+    if (typeof(uri) === "string") {
+      uri = URL.URL(uri);
+    }
+    this._uriBasename = uriBasename(uri);
+    this.uri = uri;
+  },
+
+  get basename() { return this._uriBasename },
+  get displayName() { return this.basename },
+
+  get isDir() { return this.children !== undefined; },
+  get hasChildren() { return this.children && this.children.size > 0; },
+
+  setChildren: function(newChildren) {
+    let oldChildren = this.children || new Set();
+    let change = false;
+
+    for (let child of oldChildren) {
+      if (!newChildren.has(child)) {
+        change = true;
+        child.parent = null;
+        this.store.notifyRemove(child);
+      }
+    }
+
+    for (let child of newChildren) {
+      if (!oldChildren.has(child)) {
+        change = true;
+        child.parent = this;
+        this.store.notifyAdd(child);
+      }
+    }
+
+    this.children = newChildren;
+    if (change) {
+      emit(this, "children-changed", this);
+    }
+  },
+
+  addChild: function(resource) {
+    this.children = this.children || new Set();
+
+    resource.parent = this;
+    this.children.add(resource);
+    this.store.notifyAdd(resource);
+    emit(this, "children-changed", this);
+    return resource;
+  },
+
+  removeChild: function(resource) {
+    resource.parent = null;
+    this.children.remove(resource);
+    this.store.notifyRemove(resource);
+    emit(this, "children-changed", this);
+    return resource;
+  },
+
+  get contentType() { return "text/plain" },
+  get contentCategory() {
+    const NetworkHelper = require("devtools/toolkit/webconsole/network-helper");
+    let category = NetworkHelper.mimeCategoryMap[this.contentType];
+    // Boo hard-coding.
+    if (!category && this.basename === "manifest.webapp") {
+      return "json";
+    }
+    return category || "txt";
+  }
+});
+
+exports.Resource = Resource;
+
+// Surely there's a better way to do this.
+function uriBasename(uri) {
+  var basename = uri.path;
+
+  let idx = uri.path.lastIndexOf("/", basename.length - 2);
+  if (idx > -1) {
+    basename = uri.path.substring(idx + 1);
+  }
+
+  if (basename[basename.length - 1] === "/") {
+    basename = basename.substring(0, basename.length - 1);
+  }
+
+  return basename;
+}
+
+
+var FileResource = Class({
+  extends: Resource,
+
+  initialize: function(store, path, info) {
+    this.store = store;
+    this.path = path;
+
+    this.setURI(URL.URL(URL.fromFilename(path)));
+    this._lastReadModification = undefined;
+
+    this.info = info;
+    this.parent = null;
+  },
+
+  toString: function() {
+    return "[FileResource:" + this.path + "]";
+  },
+
+  destroy: function() {
+    if (this._refreshDeferred) {
+      this._refreshDeferred.reject();
+    }
+    this._refreshDeferred = null;
+  },
+
+  // Fetch and cache information about this particular file
+  // https://developer.mozilla.org/en-US/docs/JavaScript_OS.File/OS.File_for_the_main_thread#OS.File.stat
+  refresh: function() {
+    if (this._refreshDeferred) {
+      return this._refreshDeferred.promise;
+    }
+    this._refreshDeferred = promise.defer();
+    OS.File.stat(this.path).then(info => {
+      this.info = info;
+      if (this._refreshDeferred) {
+        this._refreshDeferred.resolve(this);
+        this._refreshDeferred = null;
+      }
+    });
+    return this._refreshDeferred.promise;
+  },
+
+  get displayName() { return this.basename + (this.isDir ? "/" : "") },
+
+  get isDir() {
+    if (!this.info) { return false; }
+    return this.info.isDir && !this.info.isSymLink;
+  },
+
+  /**
+   * Returns the path relative to the store.  This is used for
+   * project search, there might be a better approach.
+   */
+  relativePath: function() {
+    if (!this._relativePath) {
+      if (this.path.startsWith(this.store.path)) {
+        this._relativePath = OS.Path.basename(this.store.path) + this.path.substring(this.store.path.length);
+      } else {
+        this._relativePath = this.path;
+      }
+    }
+    return this._relativePath;
+  },
+
+  /**
+   * Returns the text of the file as a promise.
+   */
+  load: function() {
+    console.log("READING TEXT...");
+    return OS.File.read(this.path).then(bytes => {
+    console.log("GOT TEXT...", gDecoder.decode(bytes));
+      return gDecoder.decode(bytes);
+    });
+  },
+
+  createChild: function(name, initial="") {
+    if (!this.isDir) {
+      return promise.reject(new Error("Cannot add child to a regular file"));
+    }
+
+    let newPath = OS.Path.join(this.path, name);
+
+    let buffer = initial ? gEncoder.encode(initial) : "";
+    return OS.File.writeAtomic(newPath, buffer, {
+      noOverwrite: true
+    }).then(() => {
+      return this.store.refresh();
+    }).then(() => {
+      let resource = this.store.resources.get(newPath);
+      if (!resource) {
+        throw new Error("Error creating " + newPath);
+      }
+      return resource;
+    });
+  },
+
+  /**
+   * Write a string to the file.
+   */
+  save: function(str) {
+    let buffer = gEncoder.encode(str);
+    let path = this.path;
+
+    // XXX: writeAtomic was losing permissions after saving on OSX
+    // return OS.File.writeAtomic(this.path, buffer, { tmpPath: this.path + ".tmp" });
+
+    return Task.spawn(function*() {
+        let pfh = yield OS.File.open(path, {truncate: true});
+        yield pfh.write(buffer);
+        yield pfh.close();
+    });
+  },
+
+  get contentType() {
+    if (this._contentType) {
+      return this._contentType;
+    }
+    if (this.isDir) {
+      return "x-directory/normal";
+    }
+    try {
+      this._contentType = mimeService.getTypeFromFile(new FileUtils.File(this.path));
+    } catch(ex) {
+      if (ex.name !== "NS_ERROR_NOT_AVAILABLE") {
+        console.error(ex, this.path);
+      }
+      this._contentType = null;
+    }
+    return this._contentType;
+  }
+});
+
+exports.FileResource = FileResource;
diff --git a/browser/devtools/itchpad/lib/stores/styles.js b/browser/devtools/itchpad/lib/stores/styles.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/stores/styles.js
+++ /dev/null
@@ -1,188 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { Cu } = require("chrome");
-const { Class } = require("sdk/core/heritage");
-const { EventTarget } = require("sdk/event/target");
-const { emit } = require("sdk/event/core");
-const promise = require("itchpad/helpers/promise");
-const URL = require("sdk/url");
-
-const { StyleSheetsFront } = require("devtools/server/actors/stylesheets");
-const { StyleEditorFront } = require("devtools/server/actors/styleeditor");
-const {CssLogic} = require("devtools/styleinspector/css-logic");
-
-const { LiveStore, Resource } = require("itchpad/stores/base");
-
-
-var StylesStore = Class({
-  extends: LiveStore,
-
-  defaultCategory: "css",
-
-  initialize: function(target) {
-    this.initStore();
-
-    this._onStyleSheetsCleared = this._onStyleSheetsCleared.bind(this);
-    this._onNavigate = this._onNavigate.bind(this);
-
-    this.setRoot(FolderResource(this));
-
-    this.setTarget(target);
-  },
-
-  setTarget: function(target) {
-    if (this.debuggee) {
-      this.resources.clear();
-      this.debuggee.destroy();
-      this.target.off("will-navigate", this._onStyleSheetsCleared);
-      this.target.off("navigate", this._onNavigate);
-    }
-
-    this.target = target;
-
-    if (!target) {
-      return;
-    }
-
-    // XXX: Need to share style editor fronts with the style editor.
-    if (this.target.form.styleSheetsActor) {
-      this.debuggee = StyleSheetsFront(this.target.client, this.target.form);
-    } else {
-      // We're talking to a pre-firefox 29 server-side
-      this.debuggee = StyleEditorFront(this.target.client, this.target.form);
-    }
-
-    this.debuggee.getStyleSheets().then(styleSheets => {
-      if (this.target !== target) {
-        return;
-      }
-      this.root.setSheets(styleSheets);
-      this.target.on("will-navigate", this._onStyleSheetsCleared);
-      this.target.on("navigate", this._onNavigate);
-    }).then(null, console.error);
-  },
-
-  _onNavigate: function() {
-    this.debuggee.getStyleSheets().then(styleSheets => {
-      this.root.setSheets(styleSheets);
-    });
-  },
-
-  _onStyleSheetsCleared: function() {
-    this.resources.clear();
-    this.root.setSheets();
-  },
-
-  refresh: function() {
-    // This is a live source, no explicit refresh needed.
-    return promise.resolve();
-  },
-
-  forSheet: function(sheet) {
-    if (this.resources.has(sheet.actorID)) {
-      return this.resources.get(sheet.actorID);
-    }
-
-    let resource = SheetResource(this, sheet);
-    this.resources.set(sheet.actorID, resource);
-    this.notifyAdd(resource);
-    return resource;
-  }
-});
-exports.StylesStore = StylesStore;
-
-var FolderResource = Class({
-  extends: Resource,
-
-  initialize: function(store) {
-    this.store = store;
-    this.children = new Set();
-  },
-
-  get displayName() { return "Styles"; },
-  get isDir() { return true; },
-  get hasChildren() { return this.children.size > 0 },
-
-  setSheets: function(sheets=[]) {
-    let newChildren = new Set();
-    for (let sheet of sheets) {
-      newChildren.add(this.store.forSheet(sheet));
-    }
-    this.setChildren(newChildren);
-  },
-
-  createChild: function(name) {
-    if (!this.store.debuggee) {
-      console.error("Tried to create a child without a debuggee.");
-      deferred.reject(new Error("Can't create child without a target."));
-    }
-    return this.store.debuggee.addStyleSheet("").then(sheet => {
-      let resource = this.store.forSheet(sheet);
-      resource._title = name;
-      this.addChild(resource);
-      return resource;
-    }).then(null, console.error);
-  }
-});
-
-var SheetResource = Class({
-  extends: Resource,
-
-  initialize: function(store, sheet) {
-    this.store = store;
-    this.sheet = sheet;
-    this.children = new Set();
-    if (sheet.href) {
-      this.setURI(new URL.URL(sheet.href));
-    } else {
-      this.setURI(new URL.URL("#sheet-" + sheet.styleSheetIndex, sheet.nodeHref));
-    }
-  },
-
-  toString: function() {
-    return "[SheetResource:" + this.uri + "]";
-  },
-
-  get displayName() {
-    if (this._title) {
-      return this._title;
-    }
-
-    if (!this.sheet.href) {
-      this._title = "<inline style sheet " + this.sheet.styleSheetIndex + ">";
-      return this._title;
-    }
-
-    this._title = CssLogic.shortSource({ href: this.sheet.href });
-    try {
-      this._title = decodeURI(this._title);
-    } catch(ex) {
-    }
-
-    return this._title;
-  },
-
-  get isDir() { return false; },
-  get hasChildren() { return false; },
-
-  get contentType() {
-    // Good enough.
-    return "text/css";
-  },
-
-  canAutoApply: true,
-
-  load: function() {
-    return this.sheet.getText().then(longstr => {
-      return longstr.string();
-    });
-  },
-
-  apply: function(text) {
-    return this.sheet.update(text, true);
-  }
-});
diff --git a/browser/devtools/itchpad/lib/tree.js b/browser/devtools/itchpad/lib/tree.js
--- a/browser/devtools/itchpad/lib/tree.js
+++ b/browser/devtools/itchpad/lib/tree.js
@@ -1,30 +1,39 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+const { Cu } = require("chrome");
 const { Class } = require("sdk/core/heritage");
 const { emit } = require("sdk/event/core");
 const { EventTarget } = require("sdk/event/target");
 const { merge } = require("sdk/util/object");
 const promise = require("itchpad/helpers/promise");
 const { InplaceEditor } = require("devtools/shared/inplace-editor");
-const { on, forget } = require("itchpad/event/scope");
-const OS = require("itchpad/helpers/osfile");
+const { on, forget } = require("itchpad/helpers/event");
+const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
 
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
-var Container = Class({
-  initialize: function(tree, node) {
+/**
+ * ResourceContainer is used as the view of a single Resource in
+ * the tree.  It is not exported.
+ */
+var ResourceContainer = Class({
+  /**
+   * @param ProjectTreeView tree
+   * @param Resource resource
+   */
+  initialize: function(tree, resource) {
     this.tree = tree;
-    this.node = node;
+    this.resource = resource;
     this.elt = null;
     this.expander = null;
     this.children = null;
 
     let doc = tree.doc;
 
     this.elt = doc.createElementNS(HTML_NS, "li");
     this.elt.classList.add("child");
@@ -75,138 +84,189 @@ var Container = Class({
       this.select();
       evt.stopPropagation();
     }, true);
 
     this.update();
   },
 
   destroy: function() {
-
+    this.elt.remove();
+    this.expander.remove();
+    this.icon.remove();
+    this.highlighter.remove();
+    this.children.remove();
+    this.label.remove();
+    this.elt = this.expander = this.icon = this.highlighter = this.children = this.label = null;
   },
 
+  /**
+   * Open the context menu when right clicking on the view.
+   * XXX: We could pass this to plugins to allow themselves
+   * to be register/remove items from the context menu if needed.
+   *
+   * @param Event e
+   */
   openContextMenu: function(ev) {
     ev.preventDefault();
     let popup = this.tree.doc.getElementById("directory-menu-popup");
-    // XXX: Pass this method onto plugins to allow them to remove themselves
-    // from context menu in certain cases.
     popup.openPopupAtScreen(ev.screenX, ev.screenY, true);
   },
 
-  remove: function() {
-    if (this.elt.parentNode) {
-      this.elt.parentNode.removeChild(this.elt);
-    }
-  },
-
+  /**
+   * Update the view based on the current state of the Resource.
+   */
   update: function() {
-    let visible = this.tree.options.nodeVisible ?
-      this.tree.options.nodeVisible(this.node) :
+    let visible = this.tree.options.resourceVisible ?
+      this.tree.options.resourceVisible(this.resource) :
       true;
 
     this.elt.hidden = !visible;
 
-    this.tree.options.nodeFormatter(this.node, this.label);
+    this.tree.options.resourceFormatter(this.resource, this.label);
+
     this.icon.className = "file-icon";
 
-    let contentCategory = this.node.contentCategory;
-    let baseName = this.node.basename || "";
+    let contentCategory = this.resource.contentCategory;
+    let baseName = this.resource.basename || "";
 
-    if (!this.node.parent) {
+    if (!this.resource.parent) {
       this.icon.classList.add("icon-none");
-    } else if (this.node.isDir) {
+    } else if (this.resource.isDir) {
       this.icon.classList.add("icon-folder");
     } else if (baseName.endsWith(".manifest") || baseName.endsWith(".webapp")) {
       this.icon.classList.add("icon-manifest");
     } else if (contentCategory === "js") {
       this.icon.classList.add("icon-js");
     } else if (contentCategory === "css") {
       this.icon.classList.add("icon-css");
     } else if (contentCategory === "html") {
       this.icon.classList.add("icon-html");
     } else if (contentCategory === "image") {
       this.icon.classList.add("icon-img");
     } else {
       this.icon.classList.add("icon-file");
     }
 
-    this.expander.style.visibility = this.node.hasChildren ? "visible" : "hidden";
+    this.expander.style.visibility = this.resource.hasChildren ? "visible" : "hidden";
 
   },
 
+  /**
+   * Select this view in the ProjectTreeView.
+   */
   select: function() {
     this.tree.selectContainer(this);
   },
 
+  /**
+   * @returns Boolean
+   *          Is this view currently selected
+   */
   get selected() {
     return this.line.classList.contains("selected");
   },
+
+  /**
+   * Set the selected state in the UI.
+   */
   set selected(v) {
     if (v) {
       this.line.classList.add("selected");
     } else {
       this.line.classList.remove("selected");
     }
   },
 
+  /**
+   * @returns Boolean
+   *          Are any children visible.
+   */
   get expanded() {
     return !this.elt.classList.contains("tree-collapsed");
   },
 
+  /**
+   * Set the visiblity state of children.
+   */
   set expanded(v) {
     if (v) {
       this.elt.classList.remove("tree-collapsed");
       this.expander.setAttribute("open", "");
     } else {
       this.expander.removeAttribute("open");
       this.elt.classList.add("tree-collapsed");
     }
   }
 });
 
+/**
+ * TreeView is a view managing a list of children.
+ * It is not to be instantiated directly - only extended.
+ * Use ProjectTreeView instead.
+ */
 var TreeView = Class({
   extends: EventTarget,
 
+  /**
+   * @param Document document
+   * @param Object options
+   *               - resourceFormatter: a function(Resource, DOMNode)
+   *                 that renders the resource into the view
+   *               - resourceVisible: a function(Resource) -> Boolean
+   *                 that determines if the resource should show up.
+   */
   initialize: function(document, options) {
     this.doc = document;
     this.options = merge({
-      nodeFormatter: function(node, elt) {
-        elt.textContent = node.toString();
+      resourceFormatter: function(resource, elt) {
+        elt.textContent = resource.toString();
       }
     }, options);
     this.models = new Set();
     this.roots = new Set();
     this._containers = new Map();
     this.elt = document.createElement("vbox");
     this.elt.tree = this;
     this.elt.className = "side-menu-widget-container sources-tree";
     this.elt.setAttribute("with-arrows", "true");
     this.elt.setAttribute("theme", "dark");
     this.elt.setAttribute("flex", "1");
 
     this.children = document.createElementNS(HTML_NS, "ul");
     this.children.setAttribute("flex", "1");
     this.elt.appendChild(this.children);
 
-    this.nodeChildrenChanged = this.nodeChildrenChanged.bind(this);
-    this.updateNode = this.updateNode.bind(this);
+    this.resourceChildrenChanged = this.resourceChildrenChanged.bind(this);
+    this.updateResource = this.updateResource.bind(this);
   },
 
   destroy: function() {
     this._destroyed = true;
     this.elt.remove();
   },
 
+  /**
+   * Prompt the user to create a new file in the tree.
+   *
+   * @param string initial
+   *               The suggested starting file name
+   * @param Resource parent
+   * @param Resource sibling
+   *                 Which resource to put this next to.  If not set,
+   *                 it will be put in front of all other children.
+   *
+   * @returns Promise
+   *          Resolves once the prompt has been successful,
+   *          Rejected if it is cancelled
+   */
   promptNew: function(initial, parent, sibling=null) {
     let deferred = promise.defer();
 
     let parentContainer = this._containers.get(parent);
-    // Give child updates something to wait on...
-    parentContainer.prompting = deferred.promise;
-
     let item = this.doc.createElement("li");
     item.className = "child";
     let placeholder = this.doc.createElementNS(HTML_NS, "div");
     placeholder.className = "child";
     item.appendChild(placeholder);
 
     let children = parentContainer.children;
     sibling = sibling ? this._containers.get(sibling).elt : null;
@@ -229,166 +289,255 @@ var TreeView = Class({
       destroy: () => {
         item.parentNode.removeChild(item);
       },
     });
 
     return deferred.promise;
   },
 
+  /**
+   * Add a new Store into the TreeView
+   *
+   * @param Store model
+   */
   addModel: function(model) {
-
     if (this.models.has(model)) {
       // Requesting to add a model that already exists
       return;
     }
     this.models.add(model);
     let placeholder = this.doc.createElementNS(HTML_NS, "li");
     placeholder.style.display = "none";
     this.children.appendChild(placeholder);
     this.roots.add(model.root);
     model.root.refresh().then(root => {
       if (this._destroyed || !this.models.has(model)) {
         // model may have been removed during the initial refresh.
-        // In this case, do not import the node or add to DOM, just leave it be.
+        // In this case, do not import the resource or add to DOM, just leave it be.
         return;
       }
-      let container = this.importNode(root);
+      let container = this.importResource(root);
       container.line.classList.add("side-menu-widget-group-title");
       container.line.setAttribute("theme", "dark");
       this.selectContainer(container);
 
       this.children.insertBefore(container.elt, placeholder);
       this.children.removeChild(placeholder);
     });
   },
 
+  /**
+   * Remove a Store from the TreeView
+   *
+   * @param Store model
+   */
   removeModel: function(model) {
     this.models.delete(model);
-    this.removeNode(model.root);
-    model.destroy();
+    this.removeResource(model.root);
   },
 
-  select: function(node) {
-    this.selectContainer(this._containers.get(node));
+
+  /**
+   * Get the ResourceContainer.  Used for testing the view.
+   *
+   * @param Resource resource
+   * @returns ResourceContainer
+   */
+  getViewContainer: function(resource) {
+    return this._containers.get(resource);
   },
 
+  /**
+   * Select a ResourceContainer in the tree.
+   *
+   * @param ResourceContainer container
+   */
   selectContainer: function(container) {
     if (this.selectedContainer === container) {
       return;
     }
     if (this.selectedContainer) {
       this.selectedContainer.selected = false;
     }
     this.selectedContainer = container;
     container.selected = true;
-    emit(this, "selection", container.node);
+    emit(this, "selection", container.resource);
   },
 
-  getSelected: function() {
-    return this.selectedContainer.node;
+  /**
+   * Select a Resource in the tree.
+   *
+   * @param Resource resource
+   */
+  selectResource: function(resource) {
+    this.selectContainer(this._containers.get(resource));
   },
 
-  importNode: function(node) {
-    if (!node) {
+  /**
+   * Get the currently selected Resource
+   *
+   * @param Resource resource
+   */
+  getSelectedResource: function() {
+    return this.selectedContainer.resource;
+  },
+
+  /**
+   * Insert a Resource into the view.
+   * Makes a new ResourceContainer if needed
+   *
+   * @param Resource resource
+   */
+  importResource: function(resource) {
+    if (!resource) {
       return null;
     }
 
-    if (this._containers.has(node)) {
-      return this._containers.get(node);
+    if (this._containers.has(resource)) {
+      return this._containers.get(resource);
     }
-    var container = Container(this, node);
-    this._containers.set(node, container);
+    var container = ResourceContainer(this, resource);
+    this._containers.set(resource, container);
     this._updateChildren(container);
 
-    on(this, node, "children-changed", this.nodeChildrenChanged);
-    on(this, node, "label-change", this.updateNode);
+    on(this, resource, "children-changed", this.resourceChildrenChanged);
+    on(this, resource, "label-change", this.updateResource);
 
     return container;
   },
 
-  deleteNode: function(resource) {
+  deleteResource: function(resource) {
     if (resource.isDir) {
       return OS.File.removeDir(resource.path);
     } else {
       return OS.File.remove(resource.path);
     }
   },
 
-  removeNode: function(node) {
-    let container = this._containers.get(node);
-    // May be requesting a removal before the import happens.
-    // In this case, container will not be set.
-    if (container) {
-      container.remove();
-    }
-    forget(this, node);
-
-    let toRemove = this.descendants(node);
-    toRemove.add(node);
+  removeResource: function(resource) {
+    let toRemove = this.descendants(resource);
+    toRemove.add(resource);
     for (let remove of toRemove) {
-      this._removeNode(remove);
+      this._removeResource(remove);
     }
   },
 
-  _removeNode: function(node) {
-    node.off("children-changed", this.nodeChildrenChanged);
-    node.off("label-change", this.updateNode);
-    if (this._containers.get(node)) {
-      this._containers.get(node).destroy();
-      this._containers.delete(node);
+  _removeResource: function(resource) {
+    resource.off("children-changed", this.resourceChildrenChanged);
+    resource.off("label-change", this.updateResource);
+    if (this._containers.get(resource)) {
+      this._containers.get(resource).destroy();
+      this._containers.delete(resource);
     }
   },
 
-  nodeChildrenChanged: function(node) {
-    this.updateNode(node);
-    this._updateChildren(this._containers.get(node));
+  resourceChildrenChanged: function(resource) {
+    this.updateResource(resource);
+    this._updateChildren(this._containers.get(resource));
   },
 
-  updateNode: function(node) {
-    let container = this._containers.get(node);
+  updateResource: function(resource) {
+    let container = this._containers.get(resource);
     container.update();
   },
 
   _updateChildren: function(container) {
-    let node = container.node;
+    let resource = container.resource;
 
     let fragment = this.doc.createDocumentFragment();
 
 
-    if (node.children) {
-      for (let child of node.children) {
-        let childContainer = this.importNode(child);
+    if (resource.children) {
+      for (let child of resource.children) {
+        let childContainer = this.importResource(child);
         fragment.appendChild(childContainer.elt);
       }
     }
 
     while (container.children.firstChild) {
       container.children.removeChild(container.children.firstChild);
     }
 
     container.children.appendChild(fragment);
   },
 
-  // Return a set with all descendants of the node
-  descendants: function(node) {
+  // Return a set with all descendants of the resource
+  descendants: function(resource) {
     let set = new Set();
 
     function addChildren(item) {
       if (!item.children) {
         return;
       }
 
       for (let child of item.children) {
         set.add(child);
       }
     }
 
-    addChildren(node);
+    addChildren(resource);
     for (let item of set) {
       addChildren(item);
     }
 
     return set;
   }
 });
 
-exports.TreeView = TreeView;
+var ProjectTreeView = Class({
+  extends: TreeView,
+
+  /**
+   * See TreeView.initialize
+   *
+   * @param Document document
+   * @param Object options
+   */
+  initialize: function(document, options) {
+    TreeView.prototype.initialize.apply(this, arguments);
+  },
+
+  destroy: function() {
+    this.forgetProject();
+    TreeView.prototype.destroy.apply(this, arguments);
+  },
+
+  /**
+   * Remove current project and empty the tree
+   */
+  forgetProject: function() {
+    if (this.project) {
+      forget(this, this.project);
+      for (let store of this.project.allStores()) {
+        this.removeModel(store);
+      }
+    }
+  },
+
+  /**
+   * Show a project in the tree
+   *
+   * @param Project project
+   *        The project to render into a tree
+   */
+  setProject: function(project) {
+    this.forgetProject();
+    this.project = project;
+    if (this.project) {
+      on(this, project, "store-added", this.addModel.bind(this));
+      on(this, project, "store-removed", this.removeModel.bind(this));
+      on(this, project, "project-saved", this.refresh.bind(this));
+      this.refresh();
+    }
+  },
+
+  /**
+   * Refresh the tree with all of the current project stores
+   */
+  refresh: function() {
+    for (let store of this.project.allStores()) {
+      this.addModel(store);
+    }
+  }
+});
+
+exports.ProjectTreeView = ProjectTreeView;
diff --git a/browser/devtools/itchpad/lib/unloader.js b/browser/devtools/itchpad/lib/unloader.js
deleted file mode 100644
--- a/browser/devtools/itchpad/lib/unloader.js
+++ /dev/null
@@ -1,98 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-'use strict';
-
-const { Class } = require("sdk/core/heritage");
-const unloadNS = require("sdk/core/namespace").ns();
-const { when: unload } = require("sdk/system/unload");
-
-var Unloader = exports.Unloader = Class({
-  initialize: function Unloader() {
-    unloadNS(this).unloaders = [];
-    unloadNS(this).unloadersUnload = unloadersUnload.bind(null, unloadNS(this).unloaders);
-
-    // run the unloaders on unload
-    unload(unloadNS(this).unloadersUnload);
-  },
-  unload: function unload(callback, container) {
-    // Calling with no arguments runs all the unloader callbacks
-    if (callback == null) {
-      unloadNS(this).unloadersUnload();
-      return null;
-    }
-
-    let windowRemover = windowUnloader.bind(null, unloader, unloadNS(this).unloaders);
-
-    // The callback is bound to the lifetime of the container if we have one
-    if (container != null) {
-      // Remove the unloader when the container unloads
-      container.addEventListener("unload", windowRemover, false);
-
-      // Wrap the callback to additionally remove the unload listener
-      let origCallback = callback;
-      callback = function() {
-        container.removeEventListener("unload", windowRemover, false);
-        origCallback();
-      }
-    }
-
-    // Wrap the callback in a function that ignores failures
-    function unloader() {
-      try {
-        callback();
-      }
-      catch(e) {
-        console.error(e);
-      }
-    }
-    unloadNS(this).unloaders.push(unloader);
-
-    // Provide a way to remove the unloader
-    return removeUnloader.bind(null, unloader, unloadNS(this).unloaders);
-  }
-});
-
-function sliceUnloader(unloader, unloaders) {
-  let index = unloaders.indexOf(unloader);
-  if (index < 0)
-    return [];
-  return unloaders.splice(index, 1);
-}
-// wraps sliceUnloader and doesn't return anything
-function removeUnloader(unloader, unloaders) {
-  sliceUnloader.apply(null, arguments);
-}
-function windowUnloader(unloader, unloaders) {
-  sliceUnloader.apply(null, arguments).forEach(function(u) u());
-}
-function unloadersUnload(unloaders) {
-  // run all the pending unloaders
-  unloaders.slice().forEach(function(u) u());
-  // clear the unload array
-  unloaders.length = 0;
-}
-
-/**
- * Save callbacks to run when unloading. Optionally scope the callback to a
- * container, e.g., window. Provide a way to run all the callbacks.
- *
- * @usage unload(): Run all callbacks and release them.
- *
- * @usage unload(callback): Add a callback to run on unload.
- * @param [function] callback: 0-parameter function to call on unload.
- * @return [function]: A 0-parameter function that undoes adding the callback.
- *
- * @usage unload(callback, container) Add a scoped callback to run on unload.
- * @param [function] callback: 0-parameter function to call on unload.
- * @param [node] container: Remove the callback when this container unloads.
- * @return [function]: A 0-parameter function that undoes adding the callback.
- */
-const gUnload = Unloader();
-exports.unload = gUnload.unload.bind(gUnload);
diff --git a/browser/devtools/itchpad/test/browser.ini b/browser/devtools/itchpad/test/browser.ini
--- a/browser/devtools/itchpad/test/browser.ini
+++ b/browser/devtools/itchpad/test/browser.ini
@@ -1,9 +1,11 @@
 [DEFAULT]
 subsuite = devtools
 support-files =
   head.js
-  samples/*
+  helper_homepage.html
 
 [browser_itchpad_immediate_destroy.js]
 [browser_itchpad_init.js]
-[browser_itchpad_init_custom.js]
+[browser_itchpad_editing_01.js]
+[browser_itchpad_new_file.js]
+[browser_itchpad_tree_selection.js]
diff --git a/browser/devtools/itchpad/test/browser_itchpad_editing_01.js b/browser/devtools/itchpad/test/browser_itchpad_editing_01.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/browser_itchpad_editing_01.js
@@ -0,0 +1,112 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test Itchpad basic functionality
+let test = asyncTest(function*() {
+  let itchpad = yield addItchpadTabForTempDirectory();
+  let TEMP_PATH = [...itchpad.project.allPaths()][0];
+
+  var defer = promise.defer();
+
+  ok (itchpad.currentEditor, "There is an editor for itchpad");
+  let containers = [...itchpad.projectTree._containers].map(z=>z[0]);
+
+  yield selectFile(itchpad, containers[1]);
+  yield selectFile(itchpad, containers[2]);
+  yield selectFile(itchpad, containers[3]);
+  yield selectFile(itchpad, containers[4]);
+  yield testEditFile(itchpad, TEMP_PATH + "/index.html", "<h1>Changed Content</h1>");
+
+  yield selectFile(itchpad, containers[5]);
+  yield selectFile(itchpad, containers[6]);
+  yield testEditFile(itchpad, TEMP_PATH + "/README.md", "### Markdown\n*Editing*");
+
+  is ([...itchpad.project.allPaths()].length, 1, "1 path is set");
+  itchpad.project.removeAllStores();
+  is ([...itchpad.project.allPaths()].length, 0, "No paths are remaining");
+
+  // itchpad.window.setTimeout(() => {
+  defer.resolve();
+  // }, 5000);
+  return defer.promise;
+});
+
+
+function whenEditorCreated(itchpad) {
+  let def = promise.defer();
+  itchpad.once("onEditorCreated", (editor) => {
+    def.resolve(editor);
+  });
+  return def.promise;
+}
+
+function whenEditorLoad(itchpad) {
+  let def = promise.defer();
+  itchpad.once("onEditorLoad", (editor) => {
+    def.resolve(editor);
+  });
+  return def.promise;
+}
+
+function whenEditorSave(itchpad) {
+  let def = promise.defer();
+  itchpad.once("onEditorSave", (editor, resource) => {
+    def.resolve(resource);
+  });
+  return def.promise;
+}
+
+function* selectFile(itchpad, container) {
+  ok (container && container.path, "A valid container has been passed in for selection " + (container && container.path));
+  itchpad.projectTree.selectResource(container);
+
+  if (container.isDir) {
+    return;
+  }
+
+  let [editorCreated, editorLoaded] = yield promise.all([
+    whenEditorCreated(itchpad),
+    whenEditorLoad(itchpad)
+  ]);
+
+  is (editorCreated, itchpad.currentEditor,  "Editor has been created for " + container.path);
+  is (editorLoaded, itchpad.currentEditor,  "Editor has been loaded for " + container.path);
+}
+
+function* testEditFile(itchpad, filePath, newData) {
+  info ("Testing file editing for: " + filePath);
+
+  let initialData = yield getFileData(filePath);
+  let editor = itchpad.currentEditor;
+  let resource = itchpad.resourceFor(editor);
+  let viewContainer= itchpad.projectTree.getViewContainer(resource);
+  let originalTreeLabel = viewContainer.label.textContent;
+
+  is (resource.path, filePath, "Resource path is set correctly");
+  is (editor.editor.getText(), initialData, "Editor is loaded with correct file contents");
+
+  info ("Setting text in the editor and doing checks before saving");
+
+  editor.editor.setText(newData);
+  is (editor.editor.getText(), newData, "Editor has been filled with new data");
+  is (viewContainer.label.textContent, "*" + originalTreeLabel, "Label is marked as changed");
+
+  info ("Saving the editor and checking to make sure the file gets saved on disk");
+
+  editor.save(resource);
+
+  let savedResource = yield whenEditorSave(itchpad);
+
+  is (viewContainer.label.textContent, originalTreeLabel, "Label is unmarked as changed");
+  is (savedResource.path, filePath, "The saved resouce path matches the original file path");
+  is (savedResource, resource, "The saved resource is the same as the original resource");
+
+  let savedData = yield getFileData(filePath);
+  is (savedData, newData, "Data has been correctly saved to disk");
+
+  info ("Finished checking saving for " + filePath);
+
+}
diff --git a/browser/devtools/itchpad/test/browser_itchpad_immediate_destroy.js b/browser/devtools/itchpad/test/browser_itchpad_immediate_destroy.js
--- a/browser/devtools/itchpad/test/browser_itchpad_immediate_destroy.js
+++ b/browser/devtools/itchpad/test/browser_itchpad_immediate_destroy.js
@@ -1,31 +1,62 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test that itchpad can be initialized with a single path and custom options.
+// Test that itchpad can be destroyed in various states of loading
+// without causing any leaks or exceptions.
 
-function test() {
-  info ("Initializing itchpad with custom options");
+let test = asyncTest(function* () {
 
-  addItchpadTab().then(() => {
+  info ("Testing tab closure when itchpad is in various states");
+
+  yield addTab("chrome://browser/content/devtools/itchpad-test.html").then(() => {
     let iframe = content.document.getElementById("itchpad-iframe");
+    ok (iframe, "Tab has placeholder iframe for itchpad");
+
+    info ("Closing the tab without doing anything");
+    gBrowser.removeCurrentTab();
+  });
+
+  yield addTab("chrome://browser/content/devtools/itchpad-test.html").then(() => {
+    let iframe = content.document.getElementById("itchpad-iframe");
+    ok (iframe, "Tab has placeholder iframe for itchpad");
+
     let itchpad = Itchpad.Itchpad();
-
-    ok (iframe, "Tab has placeholder iframe for itchpad");
     ok (itchpad, "Itchpad has been initialized");
 
-    itchpad.load(iframe).then(() => {
-      ok (true, "Load callback has been called");
-      itchpad.setProjectToSinglePath(SAMPLE_WEBAPP_PATH, {
-        name: "Test",
-        version: "0.1",
-        iconUrl: "chrome://browser/skin/devtools/tool-options.svg",
-        projectOverviewURL: SAMPLE_WEBAPP_URL
-      });
-      finish();
+    info ("Closing the tab before attempting to load");
+    gBrowser.removeCurrentTab();
+  });
+
+  yield addTab("chrome://browser/content/devtools/itchpad-test.html").then(() => {
+    let iframe = content.document.getElementById("itchpad-iframe");
+    ok (iframe, "Tab has placeholder iframe for itchpad");
+
+    let itchpad = Itchpad.Itchpad();
+    ok (itchpad, "Itchpad has been initialized");
+
+    itchpad.load(iframe);
+
+    info ("Closing the tab after a load is requested, but before load is finished");
+    gBrowser.removeCurrentTab();
+  });
+
+  yield addTab("chrome://browser/content/devtools/itchpad-test.html").then(() => {
+    let iframe = content.document.getElementById("itchpad-iframe");
+    ok (iframe, "Tab has placeholder iframe for itchpad");
+
+    let itchpad = Itchpad.Itchpad();
+    ok (itchpad, "Itchpad has been initialized");
+
+    return itchpad.load(iframe).then(() => {
+      info ("Closing the tab after a load has been requested and finished");
+      gBrowser.removeCurrentTab();
     });
   });
-}
 
+  finish();
+});
+
+
diff --git a/browser/devtools/itchpad/test/browser_itchpad_init.js b/browser/devtools/itchpad/test/browser_itchpad_init.js
--- a/browser/devtools/itchpad/test/browser_itchpad_init.js
+++ b/browser/devtools/itchpad/test/browser_itchpad_init.js
@@ -4,22 +4,16 @@
 
 "use strict";
 
 // Test that itchpad can be initialized.
 
 function test() {
   info ("Initializing itchpad");
 
-  addItchpadTab().then(() => {
-    let iframe = content.document.getElementById("itchpad-iframe");
-    let itchpad = Itchpad.Itchpad();
-
-    ok (iframe, "Tab has placeholder iframe for itchpad");
-    ok (itchpad, "Itchpad has been initialized");
-
-    itchpad.load(iframe).then(() => {
-      ok (true, "Load callback has been called");
-      finish();
-    });
+  addItchpadTab().then((itchpad) => {
+    ok (itchpad, "Load callback has been called");
+    ok (itchpad.shells, "Itchpad has shells");
+    ok (itchpad.project, "Itchpad has a project");
+    finish();
   });
 }
 
diff --git a/browser/devtools/itchpad/test/browser_itchpad_init_custom.js b/browser/devtools/itchpad/test/browser_itchpad_init_custom.js
deleted file mode 100644
--- a/browser/devtools/itchpad/test/browser_itchpad_init_custom.js
+++ /dev/null
@@ -1,34 +0,0 @@
-/* vim: set ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
- http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-// Test that itchpad can be initialized with a single path and custom options.
-
-function test() {
-  info ("Initializing itchpad with custom options");
-
-  addItchpadTab().then(() => {
-    let iframe = content.document.getElementById("itchpad-iframe");
-    let itchpad = Itchpad.Itchpad();
-
-    ok (iframe, "Tab has placeholder iframe for itchpad");
-    ok (itchpad, "Itchpad has been initialized");
-
-    itchpad.load(iframe).then(() => {
-      ok (true, "Load callback has been called");
-      itchpad.setProjectToSinglePath(SAMPLE_WEBAPP_PATH, {
-        name: "Test",
-        version: "0.1",
-        iconUrl: "chrome://browser/skin/devtools/tool-options.svg",
-        projectOverviewURL: SAMPLE_WEBAPP_URL
-      });
-
-      // TODO: make setProjectToSinglePath return a promise
-      // .then(()=>{finish(); });
-      finish();
-    });
-  });
-}
-
diff --git a/browser/devtools/itchpad/test/browser_itchpad_new_file.js b/browser/devtools/itchpad/test/browser_itchpad_new_file.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/browser_itchpad_new_file.js
@@ -0,0 +1,13 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test tree selection functionality
+
+let test = asyncTest(function*() {
+  let itchpad = yield addItchpadTabForTempDirectory();
+  ok(itchpad, "Itchpad has loaded");
+
+});
\ No newline at end of file
diff --git a/browser/devtools/itchpad/test/browser_itchpad_tree_selection.js b/browser/devtools/itchpad/test/browser_itchpad_tree_selection.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/browser_itchpad_tree_selection.js
@@ -0,0 +1,17 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test tree selection functionality
+
+let test = asyncTest(function*() {
+  let itchpad = yield addItchpadTabForTempDirectory();
+  ok(itchpad, "Itchpad has loaded");
+
+  // containers.forEach(function(container) {
+  //   console.log("Container exists", container.displayName);
+  //   itchpad.projectTree.select(container);
+  // });
+});
\ No newline at end of file
diff --git a/browser/devtools/itchpad/test/head.js b/browser/devtools/itchpad/test/head.js
--- a/browser/devtools/itchpad/test/head.js
+++ b/browser/devtools/itchpad/test/head.js
@@ -3,22 +3,21 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const Cu = Components.utils;
 let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 let TargetFactory = devtools.TargetFactory;
 let {console} = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 let promise = devtools.require("sdk/core/promise");
 const {FileUtils} = Cu.import("resource://gre/modules/FileUtils.jsm", {});
+const {NetUtil} = Cu.import("resource://gre/modules/NetUtil.jsm", {});
 const Itchpad = devtools.require("itchpad/itchpad");
 
-const TEST_DIR_PATH = getTestFilePath(".");
-const SAMPLE_WEBAPP_PATH = TEST_DIR_PATH + "/samples/webapp";
 const TEST_URL_ROOT = "http://mochi.test:8888/browser/browser/devtools/itchpad/test/";
-const SAMPLE_WEBAPP_URL = TEST_URL_ROOT + "/samples/webapp/index.html";
+const SAMPLE_WEBAPP_URL = TEST_URL_ROOT + "/helper_homepage.html";
 
 // All test are asynchronous
 waitForExplicitFinish();
 
 //Services.prefs.setBoolPref("devtools.dump.emit", true);
 
 // Set the testing flag on gDevTools and reset it when the test ends
 gDevTools.testing = true;
@@ -66,13 +65,142 @@ function addTab(url) {
       def.resolve(tab);
     }, content);
   }, true);
   content.location = url;
 
   return def.promise;
 }
 
-function addItchpadTab() {
-  return addTab("chrome://browser/content/devtools/itchpad-test.html");
+function addItchpadTabForTempDirectory() {
+  let TEMP_PATH = buildTempDirectoryStructure();
+  let CUSTOM_OPTS = {
+    name: "Test",
+    version: "0.1",
+    iconUrl: "chrome://browser/skin/devtools/tool-options.svg",
+    projectOverviewURL: SAMPLE_WEBAPP_URL
+  };
+
+  return addItchpadTab().then((itchpad) => {
+    return itchpad.setProjectToSinglePath(TEMP_PATH, CUSTOM_OPTS).then(() => {
+      return itchpad;
+    });
+  });
 }
 
+function addItchpadTab() {
+  return addTab("chrome://browser/content/devtools/itchpad-test.html").then(() => {
+    let iframe = content.document.getElementById("itchpad-iframe");
+    let itchpad = Itchpad.Itchpad();
 
+    ok (iframe, "Tab has placeholder iframe for itchpad");
+    ok (itchpad, "Itchpad has been initialized");
+
+    return itchpad.load(iframe).then(() => {
+      return itchpad;
+    });
+  });
+}
+
+
+
+/**
+ * Build a temporary directory as a workspace for this loader
+ * https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O
+ */
+function buildTempDirectoryStructure() {
+
+  // return FileUtils.getDir("CurProcD", ["chrome", "browser", "content", "browser", "devtools"]).path;
+  // return FileUtils.getDir("CurProcD", ["modules", "devtools", "itchpad", "samples", "webapp"]).path;
+
+  // First create (and remove) the temp dir to discard any changes
+  let TEMP_DIR = FileUtils.getDir("TmpD", ["Itchpad"], true);
+  TEMP_DIR.remove(true);
+
+  // Now rebuild our fake project.
+  TEMP_DIR = FileUtils.getDir("TmpD", ["Itchpad"], true);
+
+  FileUtils.getDir("TmpD", ["Itchpad", "css"], true);
+  FileUtils.getDir("TmpD", ["Itchpad", "data"], true);
+  FileUtils.getDir("TmpD", ["Itchpad", "img", "icons"], true);
+  FileUtils.getDir("TmpD", ["Itchpad", "js"], true);
+
+  let htmlFile = FileUtils.getFile("TmpD", ["Itchpad", "index.html"]);
+  htmlFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  writeToFile(htmlFile, [
+    '<!DOCTYPE html>',
+    '<html lang="en">',
+    ' <head>',
+    '   <meta charset="utf-8" />',
+    '   <title>Itchpad Temp File</title>',
+    '   <link rel="stylesheet" href="style.css" />',
+    ' </head>',
+    ' <body id="home">',
+    '   <p>Itchpad Temp File</p>',
+    ' </body>',
+    '</html>'].join("\n")
+  );
+
+  let readmeFile = FileUtils.getFile("TmpD", ["Itchpad", "README.md"]);
+  readmeFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  writeToFile(readmeFile, [
+    '## Readme'
+    ].join("\n")
+  );
+
+  let cssFile = FileUtils.getFile("TmpD", ["Itchpad", "css", "styles.css"]);
+  cssFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  writeToFile(cssFile, [
+    'body {',
+    ' background: red;',
+    '}'
+    ].join("\n")
+  );
+
+  FileUtils.getFile("TmpD", ["Itchpad", "js", "script.js"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+
+  FileUtils.getFile("TmpD", ["Itchpad", "img", "fake.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "16x16.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "32x32.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "128x128.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  FileUtils.getFile("TmpD", ["Itchpad", "img", "icons", "vector.svg"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+
+  return TEMP_DIR.path;
+}
+
+// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O#Writing_to_a_file
+function writeToFile(file, data) {
+
+  let defer = promise.defer();
+  var ostream = FileUtils.openSafeFileOutputStream(file);
+
+  var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].
+                  createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
+  converter.charset = "UTF-8";
+  var istream = converter.convertToInputStream(data);
+
+  // The last argument (the callback) is optional.
+  NetUtil.asyncCopy(istream, ostream, function(status) {
+    if (!Components.isSuccessCode(status)) {
+      // Handle error!
+      info("ERROR WRITING TEMP FILE", status);
+    }
+  });
+}
+
+// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O#Writing_to_a_file
+function* getFileData(path) {
+  let file = new FileUtils.File(path);
+  let def = promise.defer();
+
+  NetUtil.asyncFetch(file, function(inputStream, status) {
+    if (!Components.isSuccessCode(status)) {
+      // Handle error!
+      info("ERROR READING TEMP FILE", status);
+    }
+    var data = NetUtil.readInputStreamToString(inputStream, inputStream.available());
+    def.resolve(data);
+  });
+
+  return def.promise;
+}
+
+
diff --git a/browser/devtools/itchpad/test/helper_homepage.html b/browser/devtools/itchpad/test/helper_homepage.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/helper_homepage.html
@@ -0,0 +1,1 @@
+<h1>Itchpad tests</h1>
\ No newline at end of file
diff --git a/browser/devtools/itchpad/test/samples/webapp/README.md b/browser/devtools/itchpad/test/samples/webapp/README.md
deleted file mode 100644
diff --git a/browser/devtools/itchpad/test/samples/webapp/css/main.css b/browser/devtools/itchpad/test/samples/webapp/css/main.css
deleted file mode 100644
diff --git a/browser/devtools/itchpad/test/samples/webapp/img/spacer.gif b/browser/devtools/itchpad/test/samples/webapp/img/spacer.gif
deleted file mode 100644
index 1d9a4f524c97fa9d148cc15d7e114acce53520a7..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/browser/devtools/itchpad/test/samples/webapp/index.html b/browser/devtools/itchpad/test/samples/webapp/index.html
deleted file mode 100644
diff --git a/browser/devtools/itchpad/test/samples/webapp/js/framework.js b/browser/devtools/itchpad/test/samples/webapp/js/framework.js
deleted file mode 100644
diff --git a/browser/devtools/itchpad/test/samples/webapp/js/page.js b/browser/devtools/itchpad/test/samples/webapp/js/page.js
deleted file mode 100644
diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -3,17 +3,17 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 browser.jar:
     content/browser/devtools/widgets.css                               (shared/widgets/widgets.css)
     content/browser/devtools/widgets/VariablesView.xul                 (shared/widgets/VariablesView.xul)
     content/browser/devtools/markup-view.xhtml                         (markupview/markup-view.xhtml)
     content/browser/devtools/markup-view.css                           (markupview/markup-view.css)
     content/browser/devtools/itchpad.xul                               (itchpad/chrome/content/itchpad.xul)
-    content/browser/devtools/readdir.js                                (itchpad/chrome/content/readdir.js)
+    content/browser/devtools/readdir.js                                (itchpad/lib/helpers/readdir.js)
     content/browser/devtools/itchpad-loader.xul                        (itchpad/chrome/content/itchpad-loader.xul)
     content/browser/devtools/itchpad-test.html                         (itchpad/chrome/content/itchpad-test.html)
     content/browser/devtools/itchpad-loader.js                         (itchpad/chrome/content/itchpad-loader.js)
     content/browser/devtools/netmonitor.xul                            (netmonitor/netmonitor.xul)
     content/browser/devtools/netmonitor.css                            (netmonitor/netmonitor.css)
     content/browser/devtools/netmonitor-controller.js                  (netmonitor/netmonitor-controller.js)
     content/browser/devtools/netmonitor-view.js                        (netmonitor/netmonitor-view.js)
     content/browser/devtools/NetworkPanel.xhtml                        (webconsole/NetworkPanel.xhtml)
diff --git a/browser/locales/en-US/chrome/browser/devtools/itchpad.properties b/browser/locales/en-US/chrome/browser/devtools/itchpad.properties
--- a/browser/locales/en-US/chrome/browser/devtools/itchpad.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/itchpad.properties
@@ -16,8 +16,20 @@
 # file / folder to be deleted
 itchpad.deleteLabel=Delete
 
 # LOCALIZATION NOTE (itchpad.newLabel):
 # This string is displayed as a context menu item for adding a new file to
 # the directory
 itchpad.newLabel=New...
 
+# LOCALIZATION NOTE (itchpad.selectFileLabel):
+# This string is displayed as the title on the file picker when saving a file
+itchpad.selectFileLabel=Select a File
+
+# LOCALIZATION NOTE (itchpad.openFolderLabel):
+# This string is displayed as the title on the file picker when opening a folder
+itchpad.openFolderLabel=Select a Folder
+
+# LOCALIZATION NOTE (itchpad.openFileLabel):
+# This string is displayed as the title on the file picker when opening a file
+itchpad.openFileLabel=Open a File
+
