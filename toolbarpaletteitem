# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  ca9df8b302950643ea723b66945eb224a7542fc8
Bug 1507875 - Remove the CUI toolbarpaletteitem binding

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -1255,20 +1255,16 @@ toolbarpaletteitem[dragover] {
   flex-shrink: 0;
   flex-wrap: wrap;
 }
 
 #customization-toolbar-visibility-button > .box-inherit > .button-menu-dropmarker {
   display: -moz-box;
 }
 
-toolbarpaletteitem {
-  -moz-binding: url("chrome://browser/content/customizableui/toolbar.xml#toolbarpaletteitem");
-}
-
 toolbarpaletteitem[place="palette"] {
   -moz-box-orient: vertical;
   width: 7em;
   /* icon (16) + margin (9 + 12) + 3 lines of text: */
   height: calc(39px + 3em);
   margin-bottom: 5px;
   margin-inline-end: 24px;
   overflow: visible;
diff --git a/browser/components/customizableui/CustomizeMode.jsm b/browser/components/customizableui/CustomizeMode.jsm
--- a/browser/components/customizableui/CustomizeMode.jsm
+++ b/browser/components/customizableui/CustomizeMode.jsm
@@ -726,17 +726,17 @@ CustomizeMode.prototype = {
       return null;
     }
     // Do not build a palette item for hidden widgets; there's not much to show.
     if (widgetNode.hidden) {
       return null;
     }
 
     let wrapper = this.createOrUpdateWrapper(widgetNode, aPlace);
-    wrapper.appendChild(widgetNode);
+    wrapper.querySelector("hbox").appendChild(widgetNode);
     return wrapper;
   },
 
   depopulatePalette() {
     return (async () => {
       this.visiblePalette.hidden = true;
       let paletteChild = this.visiblePalette.firstElementChild;
       let nextChild;
@@ -793,27 +793,34 @@ CustomizeMode.prototype = {
     // It's possible that this toolbar node is "mid-flight" and doesn't have
     // a parent, in which case we skip replacing it. This can happen if a
     // toolbar item has been dragged into the palette. In that case, we tell
     // CustomizableUI to remove the widget from its area before putting the
     // widget in the palette - so the node will have no parent.
     if (aNode.parentNode) {
       aNode = aNode.parentNode.replaceChild(wrapper, aNode);
     }
-    wrapper.appendChild(aNode);
+    wrapper.querySelector("hbox").appendChild(aNode);
     return wrapper;
   },
 
   createOrUpdateWrapper(aNode, aPlace, aIsUpdate) {
     let wrapper;
     if (aIsUpdate && aNode.parentNode && aNode.parentNode.localName == "toolbarpaletteitem") {
       wrapper = aNode.parentNode;
       aPlace = wrapper.getAttribute("place");
     } else {
+      console.log("CREATING", aNode);
       wrapper = this.document.createXULElement("toolbarpaletteitem");
+      let box = this.document.createXULElement("hbox");
+      box.classList.add("toolbarpaletteitem-box");
+      let label = this.document.createXULElement("label");
+      label.classList.add("toolbarpaletteitem-label");
+      wrapper.appendChild(box);
+      wrapper.appendChild(label);
       // "place" is used to show the label when it's sitting in the palette.
       wrapper.setAttribute("place", aPlace);
     }
 
 
     // Ensure the wrapped item doesn't look like it's in any special state, and
     // can't be interactved with when in the customization palette.
     // Note that some buttons opt out of this with the
