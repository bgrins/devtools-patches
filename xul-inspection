# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  6b8732084897332d3890dceca1be1a4364f63db9
Bug 1360072 - Protect against empty node list when inspecting anonymous content;r=pbro

diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -854,17 +854,16 @@ var WalkerActor = protocol.ActorClassWit
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
     this.showAllAnonymousContent = options.showAllAnonymousContent;
-
     this.walkerSearch = new WalkerSearch(this);
 
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
     this._orphaned = new Set();
 
     // The client can tell the walker that it is interested in a node
@@ -1386,17 +1385,17 @@ var WalkerActor = protocol.ActorClassWit
     let rawNode = node.rawNode;
     let firstChild = getFilteredWalker(rawNode).firstChild();
     let lastChild = getFilteredWalker(rawNode).lastChild();
 
     if (!firstChild) {
       // No children, we're done.
       return { hasFirst: true, hasLast: true, nodes: [] };
     }
-
+    console.log(firstChild, lastChild);
     let start;
     if (options.center) {
       start = options.center.rawNode;
     } else if (options.start) {
       start = options.start.rawNode;
     } else {
       start = firstChild;
     }
@@ -1411,20 +1410,20 @@ var WalkerActor = protocol.ActorClassWit
       let backwardNodes = this._readBackward(backwardWalker, backwardCount);
       nodes = backwardNodes;
     }
 
     // Then read forward by any slack left in the max children...
     let forwardWalker = getFilteredWalker(start);
     let forwardCount = maxNodes - nodes.length;
     nodes = nodes.concat(this._readForward(forwardWalker, forwardCount));
-
     // If there's any room left, it means we've run all the way to the end.
     // If we're centering, check if there are more items to read at the front.
     let remaining = maxNodes - nodes.length;
+console.log(forwardCount, remaining, nodes.length);
     if (options.center && remaining > 0 && nodes[0].rawNode != firstChild) {
       let firstNodes = this._readBackward(backwardWalker, remaining);
 
       // Then put it all back together.
       nodes = firstNodes.concat(nodes);
     }
 
     return {
