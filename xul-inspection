# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  1793a41066c3aea8b67f116be4546da225a0cd59
Bug 1360072 - Protect against empty node list when inspecting anonymous content;r=pbro

diff --git a/devtools/client/inspector/markup/markup.js b/devtools/client/inspector/markup/markup.js
--- a/devtools/client/inspector/markup/markup.js
+++ b/devtools/client/inspector/markup/markup.js
@@ -373,16 +373,17 @@ MarkupView.prototype = {
    * @param  {NodeFront} nodeFront
    *         The node to show as hovered
    */
   _showContainerAsHovered: function (nodeFront) {
     if (this._hoveredNode === nodeFront) {
       return;
     }
 
+    console.log("Hovered new node", nodeFront, this.getContainer(nodeFront));
     if (this._hoveredNode) {
       this.getContainer(this._hoveredNode).hovered = false;
     }
 
     this.getContainer(nodeFront).hovered = true;
     this._hoveredNode = nodeFront;
     // Emit an event that the container view is actually hovered now, as this function
     // can be called by an asynchronous caller.
@@ -961,16 +962,18 @@ MarkupView.prototype = {
       this._elt.appendChild(container.elt);
       this._rootNode = node;
     } else if (nodeType == nodeConstants.ELEMENT_NODE && !isPseudoElement) {
       container = new MarkupElementContainer(this, node, this.inspector);
     } else if (nodeType == nodeConstants.COMMENT_NODE ||
                nodeType == nodeConstants.TEXT_NODE) {
       container = new MarkupTextContainer(this, node, this.inspector);
     } else {
+      console.trace();
+      console.log("Creating a read only container", node)
       container = new MarkupReadOnlyContainer(this, node, this.inspector);
     }
 
     if (flashNode) {
       container.flashMutation();
     }
 
     this._containers.set(node, container);
@@ -1529,23 +1532,28 @@ MarkupView.prototype = {
    * and set the dirty flag if needed.
    *
    * @return The node that should be made visible, if any.
    */
   _checkSelectionVisible: function (container) {
     let centered = null;
     let node = this.inspector.selection.nodeFront;
     while (node) {
+      console.log("Looking at: ", node.parentNode(), container.node, node.parentNode() === container.node)
       if (node.parentNode() === container.node) {
         centered = node;
         break;
       }
       node = node.parentNode();
     }
 
+    if (!centered) {
+      console.error("Didn't receive a centered node")
+    }
+
     return centered;
   },
 
   /**
    * Make sure all children of the given container's node are
    * imported and attached to the container in the right order.
    *
    * Children need to be updated only in the following circumstances:
@@ -1627,17 +1635,17 @@ MarkupView.prototype = {
     // expanded we'll refresh the child list.
     if (!(container.expanded || expand)) {
       return promise.resolve(container);
     }
 
     // We're going to issue a children request, make sure it includes the
     // centered node.
     let centered = this._checkSelectionVisible(container);
-
+    console.log("Frontend requesting centered node: ", centered);
     // Children aren't updated yet, but clear the childrenDirty flag anyway.
     // If the dirty flag is re-set while we're fetching we'll need to fetch
     // again.
     container.childrenDirty = false;
     let updatePromise =
       this._getVisibleChildren(container, centered).then(children => {
         if (!this._containers) {
           return promise.reject("markup view destroyed");
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -408,16 +408,17 @@ var NodeActor = exports.NodeActor = prot
     return false;
   },
 
   writeAttrs: function () {
     if (!this.rawNode.attributes) {
       return undefined;
     }
 
+    return [{namespace: 'http://www.w3.org/1999/xhtml', name: 'foo', value: 'bar'}]
     return [...this.rawNode.attributes].map(attr => {
       return {namespace: attr.namespace, name: attr.name, value: attr.value };
     });
   },
 
   writePseudoClassLocks: function () {
     if (this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
       return undefined;
@@ -867,17 +868,16 @@ var WalkerActor = protocol.ActorClassWit
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
     this.showAllAnonymousContent = options.showAllAnonymousContent;
-
     this.walkerSearch = new WalkerSearch(this);
 
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
     this._orphaned = new Set();
 
     // The client can tell the walker that it is interested in a node
@@ -1399,57 +1399,75 @@ var WalkerActor = protocol.ActorClassWit
     let rawNode = node.rawNode;
     let firstChild = getFilteredWalker(rawNode).firstChild();
     let lastChild = getFilteredWalker(rawNode).lastChild();
 
     if (!firstChild) {
       // No children, we're done.
       return { hasFirst: true, hasLast: true, nodes: [] };
     }
-
+    console.log(firstChild, lastChild);
     let start;
     if (options.center) {
       start = options.center.rawNode;
     } else if (options.start) {
       start = options.start.rawNode;
     } else {
       start = firstChild;
     }
 
+    if (!start || getFilteredWalker(start).parentNode() !== rawNode) {
+      console.error("Unexpected state on children request: startNode is not a child of node", start, rawNode);
+      // // Passed in a bad options.center
+      // while (start && start.parentNode !== rawNode) {
+      //   start = start.parentNode;
+      // }
+      console.log(getFilteredWalker(rawNode));
+      console.log(getFilteredWalker(start));
+    } else {
+      console.error("It's OK: ", start, rawNode)
+    }
+
     let nodes = [];
 
     // Start by reading backward from the starting point if we're centering...
     let backwardWalker = getFilteredWalker(start);
     if (backwardWalker.currentNode != firstChild && options.center) {
       backwardWalker.previousSibling();
       let backwardCount = Math.floor(maxNodes / 2);
       let backwardNodes = this._readBackward(backwardWalker, backwardCount);
       nodes = backwardNodes;
     }
 
     // Then read forward by any slack left in the max children...
     let forwardWalker = getFilteredWalker(start);
     let forwardCount = maxNodes - nodes.length;
     nodes = nodes.concat(this._readForward(forwardWalker, forwardCount));
-
     // If there's any room left, it means we've run all the way to the end.
     // If we're centering, check if there are more items to read at the front.
     let remaining = maxNodes - nodes.length;
+console.log(forwardCount, remaining, nodes.length, nodes[0].rawNode, firstChild);
+
+    if (nodes.length === 0) {
+      debugger;
+    }
     if (options.center && remaining > 0 && nodes[0].rawNode != firstChild) {
       let firstNodes = this._readBackward(backwardWalker, remaining);
 
       // Then put it all back together.
       nodes = firstNodes.concat(nodes);
     }
 
-    return {
+    var ret = {
       hasFirst: nodes[0].rawNode == firstChild,
       hasLast: nodes[nodes.length - 1].rawNode == lastChild,
       nodes: nodes
     };
+    console.log(ret);
+    return ret;
   },
 
   /**
    * Return siblings of the given node.  By default this method will return
    * all siblings of the node, but there are options that can restrict this
    * to a more manageable subset.
    *
    * If `start` or `center` are not specified, this method will center on the
@@ -3104,16 +3122,19 @@ DocumentWalker.prototype = {
     if (skipTo === SKIP_TO_PARENT) {
       while (node && this.isSkippedNode(node)) {
         node = node.parentNode;
       }
     } else if (skipTo === SKIP_TO_SIBLING) {
       node = this.getClosestAcceptedSibling(node);
     }
 
+    if (startingNode !== node) {
+      console.log("Found a diff node", startingNode, node);;
+    }
     return node || startingNode;
   },
 
   /**
    * Loop on all of the provided node siblings until finding one that is compliant with
    * the filter function.
    */
   getClosestAcceptedSibling: function (node) {
@@ -3173,16 +3194,17 @@ function standardTreeWalkerFilter(node) 
     return nodeHasSize(node)
            ? nodeFilterConstants.FILTER_ACCEPT
            : nodeFilterConstants.FILTER_SKIP;
   }
 
   // Ignore all native and XBL anonymous content inside a non-XUL document
   if (!isInXULDocument(node) && (isXBLAnonymous(node) ||
                                   isNativeAnonymous(node))) {
+    console.log("Skipping anon in non xul doc", node);
     // Note: this will skip inspecting the contents of feedSubscribeLine since
     // that's XUL content injected in an HTML document, but we need to because
     // this also skips many other elements that need to be skipped - like form
     // controls, scrollbars, video controls, etc (see bug 1187482).
     return nodeFilterConstants.FILTER_SKIP;
   }
 
   return nodeFilterConstants.FILTER_ACCEPT;
diff --git a/devtools/shared/fronts/inspector.js b/devtools/shared/fronts/inspector.js
--- a/devtools/shared/fronts/inspector.js
+++ b/devtools/shared/fronts/inspector.js
@@ -123,16 +123,20 @@ const NodeFront = FrontClassWithSpec(nod
       form.nodeValue = form.incompleteValue ? null : form.shortValue;
     }
 
     // Shallow copy of the form.  We could just store a reference, but
     // eventually we'll want to update some of the data.
     this._form = object.merge(form);
     this._form.attrs = this._form.attrs ? this._form.attrs.slice() : [];
 
+    if (!this._form.nodeType) {
+      console.error("Bad form", form, this);
+      console.trace();
+    }
     if (form.parent) {
       // Get the owner actor for this actor (the walker), and find the
       // parent node of this actor from it, creating a standin node if
       // necessary.
       let parentNodeFront = ctx.marshallPool().ensureParentFront(form.parent);
       this.reparent(parentNodeFront);
     }
 
