# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a56d9d4c4b735f9c021b66f670ccf935f33be088
Bug 1164728 - Scroll to bottom in netmonitor synchronously after inserting a batch of requests;r=vporof

diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -373,17 +373,16 @@ RequestsMenuView.prototype = Heritage.ex
     this._summary.setAttribute("value", L10N.getStr("networkMenu.empty"));
     this.userInputTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
 
     Prefs.filters.forEach(type => this.filterOn(type));
     this.sortContents(this._byTiming);
 
     this.allowFocusOnRightClick = true;
     this.maintainSelectionVisible = true;
-    this.widget.autoscrollWithAppendedItems = true;
 
     this.widget.addEventListener("select", this._onSelect, false);
     this.widget.addEventListener("swap", this._onSwap, false);
     this._splitter.addEventListener("mousemove", this._onResize, false);
     window.addEventListener("resize", this._onResize, false);
 
     this.requestsMenuSortEvent = getKeyWithEvent(this.sortBy.bind(this));
     this.requestsMenuFilterEvent = getKeyWithEvent(this.filterOn.bind(this));
@@ -1331,16 +1330,19 @@ RequestsMenuView.prototype = Heritage.ex
    * Starts adding all queued additional information about network requests.
    */
   _flushRequests: function() {
     // Prevent displaying any updates received after the target closed.
     if (NetMonitorView._isDestroyed) {
       return;
     }
 
+    let widget = NetMonitorView.RequestsMenu.widget;
+    let isScrolledToBottom = widget.isScrolledToBottom();
+
     for (let [id, startedDateTime, method, url, isXHR, fromCache] of this._addQueue) {
       // Convert the received date/time string to a unix timestamp.
       let unixTime = Date.parse(startedDateTime);
 
       // Create the element node for the network request item.
       let menuView = this._createMenuView(method, url);
 
       // Remember the first and last event boundaries.
@@ -1372,16 +1374,19 @@ RequestsMenuView.prototype = Heritage.ex
 
       if (id == this._preferredItemId) {
         this.selectedItem = requestItem;
       }
 
       window.emit(EVENTS.REQUEST_ADDED, id);
     }
 
+    if (isScrolledToBottom && this._addQueue.length) {
+      widget.scrollToBottom();
+    }
 
     // For each queued additional information packet, get the corresponding
     // request item in the view and update it based on the specified data.
     for (let [id, data, callback] of this._updateQueue) {
       let requestItem = this.getItemByValue(id);
       if (!requestItem) {
         // Packet corresponds to a dead request item, target navigated.
         continue;
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,22 +5,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
-const {DeferredTask} = Cu.import("resource://gre/modules/DeferredTask.jsm", {});
 
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
-const SCROLL_FREQUENCY = 16;
-
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
  * @param nsIDOMNode aNode
  *        The element associated with the widget.
@@ -77,63 +74,36 @@ SideMenuWidget.prototype = {
   sortedGroups: true,
 
   /**
    * The comparator used to sort groups.
    */
   groupSortPredicate: function(a, b) a.localeCompare(b),
 
   /**
-   * Specifies that the container viewport should be "stuck" to the
-   * bottom. That is, the container is automatically scrolled down to
-   * keep appended items visible, but only when the scroll position is
-   * already at the bottom.
-   */
-  autoscrollWithAppendedItems: false,
-
-  /**
    * Inserts an item in this container at the specified index, optionally
    * grouping by name.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @param nsIDOMNode aContents
    *        The node displayed in the container.
    * @param object aAttachment [optional]
    *        Some attached primitive/object. Custom options supported:
    *          - group: a string specifying the group to place this item into
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
-    // Maintaining scroll position at the bottom when a new item is inserted
-    // depends on several factors (the order of testing is important to avoid
-    // needlessly expensive operations that may cause reflows):
-    let maintainScrollAtBottom =
-      // 1. The behavior should be enabled,
-      this.autoscrollWithAppendedItems &&
-      // 2. There shouldn't currently be any selected item in the list.
-      !this._selectedItem &&
-      // 3. The new item should be appended at the end of the list.
-      (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
-      // 4. We aren't waiting for a scroll to happen.
-      (!this._scrollToBottomTask || !this._scrollToBottomTask.isArmed) &&
-      // 5. The list should already be scrolled at the bottom.
-      this.isScrolledToBottom();
-
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
-    if (maintainScrollAtBottom) {
-      this.scrollToBottom();
-    }
-
     return element;
   },
 
   /**
    * Checks to see if the list is scrolled all the way to the bottom.
    * Uses getBoundsWithoutFlushing to limit the performance impact
    * of this function.
    *
@@ -153,40 +123,18 @@ SideMenuWidget.prototype = {
     return false;
   },
 
   /**
    * Scroll the list to the bottom after a timeout.
    * If the user scrolls in the meantime, cancel this operation.
    */
   scrollToBottom: function() {
-    // Lazily attach this functionality to the object, so it won't get
-    // created unless if this scrollToBottom behavior is needed.
-    if (!this._scrollToBottomTask) {
-      // The scroll event fires asynchronously, so we need to keep a bit to
-      // distinguish between user-initiated events and scrollTop assignment.
-      let ignoreNextScroll = false;
-
-      this._scrollToBottomTask = new DeferredTask(() => {
-        ignoreNextScroll = true;
-        this._list.scrollTop = this._list.scrollHeight;
-        this.emit("scroll-to-bottom");
-      }, SCROLL_FREQUENCY);
-
-      // On a user scroll, cancel any pending calls to the scroll function.
-      this._list.addEventListener("scroll", () => {
-        if (!ignoreNextScroll && this._scrollToBottomTask.isArmed &&
-            !this.isScrolledToBottom()) {
-          this._scrollToBottomTask.disarm();
-        }
-        ignoreNextScroll = false;
-      }, true);
-    }
-
-    this._scrollToBottomTask.arm();
+    this._list.scrollTop = this._list.scrollHeight;
+    this.emit("scroll-to-bottom");
   },
 
   /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
