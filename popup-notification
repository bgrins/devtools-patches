# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a559b84032a8d570a64f0bb67ce917c9d696d4fc
Bug 1487065 - Implement popup-notification as a Custom Element

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -974,20 +974,16 @@ html|*#fullscreen-exit-button {
 
 .popup-anchor {
   /* should occupy space but not be visible */
   opacity: 0;
   pointer-events: none;
   -moz-stack-sizing: ignore;
 }
 
-#addon-progress-notification {
-  -moz-binding: url("chrome://browser/content/urlbarBindings.xml#addon-progress-notification");
-}
-
 browser[tabmodalPromptShowing] {
   -moz-user-focus: none !important;
 }
 
 /* Status panel */
 
 #statuspanel {
   position: fixed;
diff --git a/browser/base/content/test/popupNotifications/browser_displayURI.js b/browser/base/content/test/popupNotifications/browser_displayURI.js
--- a/browser/base/content/test/popupNotifications/browser_displayURI.js
+++ b/browser/base/content/test/popupNotifications/browser_displayURI.js
@@ -3,36 +3,32 @@
  */
 
 async function check(contentTask, options = {}) {
   await BrowserTestUtils.withNewTab("https://test1.example.com/", async function(browser) {
     let popupShownPromise = waitForNotificationPanel();
     await ContentTask.spawn(browser, null, contentTask);
     let panel = await popupShownPromise;
     let notification = panel.children[0];
-    let body = document.getAnonymousElementByAttribute(notification,
-                                                       "class",
-                                                       "popup-notification-body");
+    let body = notification.querySelector(".popup-notification-body");
     ok(body.innerHTML.includes("example.com"), "Check that at least the eTLD+1 is present in the markup");
   });
 
   let channel = NetUtil.newChannel({
     uri: getRootDirectory(gTestPath),
     loadUsingSystemPrincipal: true,
   });
   channel = channel.QueryInterface(Ci.nsIFileChannel);
 
   await BrowserTestUtils.withNewTab(channel.file.path, async function(browser) {
     let popupShownPromise = waitForNotificationPanel();
     await ContentTask.spawn(browser, null, contentTask);
     let panel = await popupShownPromise;
     let notification = panel.children[0];
-    let body = document.getAnonymousElementByAttribute(notification,
-                                                       "class",
-                                                       "popup-notification-body");
+    let body = notification.querySelector(".popup-notification-body");
     if (notification.id == "geolocation-notification") {
       ok(body.innerHTML.includes("local file"), `file:// URIs should be displayed as local file.`);
     } else {
       ok(body.innerHTML.includes("Unknown origin"), "file:// URIs should be displayed as unknown origin.");
     }
   });
 
   if (!options.skipOnExtension) {
@@ -55,19 +51,17 @@ async function check(contentTask, option
     await extension.startup();
     let extensionURI = await extension.awaitMessage("extension-tab-url");
 
     await BrowserTestUtils.withNewTab(extensionURI, async function(browser) {
       let popupShownPromise = waitForNotificationPanel();
       await ContentTask.spawn(browser, null, contentTask);
       let panel = await popupShownPromise;
       let notification = panel.children[0];
-      let body = document.getAnonymousElementByAttribute(notification,
-                                                         "class",
-                                                         "popup-notification-body");
+      let body = notification.querySelector(".popup-notification-body");
       ok(body.innerHTML.includes("Test Extension Name"),
          "Check the the extension name is present in the markup");
     });
 
     await extension.unload();
   }
 }
 
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js b/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
@@ -14,17 +14,17 @@ function test() {
 function checkCheckbox(checkbox, label, checked = false, hidden = false) {
   is(checkbox.label, label, "Checkbox should have the correct label");
   is(checkbox.hidden, hidden, "Checkbox should be shown");
   is(checkbox.checked, checked, "Checkbox should be checked by default");
 }
 
 function checkMainAction(notification, disabled = false) {
   let mainAction = notification.button;
-  let warningLabel = document.getAnonymousElementByAttribute(notification, "class", "popup-notification-warning");
+  let warningLabel = notification.querySelector(".popup-notification-warning");
   is(warningLabel.hidden, !disabled, "Warning label should be shown");
   is(mainAction.disabled, disabled, "MainAction should be disabled");
 }
 
 function promiseElementVisible(element) {
   // HTMLElement.offsetParent is null when the element is not visisble
   // (or if the element has |position: fixed|). See:
   // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
diff --git a/browser/base/content/test/popupNotifications/head.js b/browser/base/content/test/popupNotifications/head.js
--- a/browser/base/content/test/popupNotifications/head.js
+++ b/browser/base/content/test/popupNotifications/head.js
@@ -178,18 +178,17 @@ function checkPopup(popup, notifyObj) {
   ok(notifyObj.showingCallbackTriggered, "showing callback was triggered");
   ok(notifyObj.shownCallbackTriggered, "shown callback was triggered");
 
   let notifications = popup.childNodes;
   is(notifications.length, 1, "one notification displayed");
   let notification = notifications[0];
   if (!notification)
     return;
-  let icon = document.getAnonymousElementByAttribute(notification, "class",
-                                                     "popup-notification-icon");
+  let icon = notification.querySelector(".popup-notification-icon");
   if (notifyObj.id == "geolocation") {
     isnot(icon.boxObject.width, 0, "icon for geo displayed");
     ok(popup.anchorNode.classList.contains("notification-anchor-icon"),
        "notification anchored to icon");
   }
 
   let description = notifyObj.message.split("<>");
   let text = {};
@@ -213,17 +212,17 @@ function checkPopup(popup, notifyObj) {
     let secondaryAction = notifyObj.secondaryActions[0];
     is(notification.getAttribute("secondarybuttonlabel"), secondaryAction.label,
        "secondary action label matches");
     is(notification.getAttribute("secondarybuttonaccesskey"),
        secondaryAction.accessKey, "secondary action accesskey matches");
   }
   // Additional secondary actions appear as menu items.
   let actualExtraSecondaryActions =
-    Array.filter(notification.childNodes, child => child.nodeName == "menuitem");
+    Array.filter(notification.menupopup.childNodes, child => child.nodeName == "menuitem");
   let extraSecondaryActions = notifyObj.secondaryActions ? notifyObj.secondaryActions.slice(1) : [];
   is(actualExtraSecondaryActions.length, extraSecondaryActions.length,
      "number of extra secondary actions matches");
   extraSecondaryActions.forEach(function(a, i) {
     is(actualExtraSecondaryActions[i].getAttribute("label"), a.label,
        "label for extra secondary action " + i + " matches");
     is(actualExtraSecondaryActions[i].getAttribute("accesskey"), a.accessKey,
        "accessKey for extra secondary action " + i + " matches");
diff --git a/browser/components/customizableui/content/panelUI.js b/browser/components/customizableui/content/panelUI.js
--- a/browser/components/customizableui/content/panelUI.js
+++ b/browser/components/customizableui/content/panelUI.js
@@ -828,16 +828,17 @@ const PanelUI = {
   _clearBannerItem() {
     if (this._panelBannerItem) {
       this._panelBannerItem.notification = null;
       this._panelBannerItem.hidden = true;
     }
   },
 
   _onNotificationButtonEvent(event, type) {
+    console.log("here", event.originalTarget);
     let notificationEl = getNotificationFromElement(event.originalTarget);
 
     if (!notificationEl)
       throw "PanelUI._onNotificationButtonEvent: couldn't find notification element";
 
     if (!notificationEl.notification)
       throw "PanelUI._onNotificationButtonEvent: couldn't find notification";
 
@@ -894,20 +895,14 @@ XPCOMUtils.defineConstant(this, "PanelUI
 /**
  * Gets the currently selected locale for display.
  * @return  the selected locale
  */
 function getLocale() {
   return Services.locale.appLocaleAsLangTag;
 }
 
+/**
+ * Given a DOM node inside a <popupnotification>, return the parent <popupnotification>.
+ */
 function getNotificationFromElement(aElement) {
-  // Need to find the associated notification object, which is a bit tricky
-  // since it isn't associated with the element directly - this is kind of
-  // gross and very dependent on the structure of the popupnotification
-  // binding's content.
-  let notificationEl;
-  let parent = aElement;
-  while (parent && (parent = aElement.ownerDocument.getBindingParent(parent))) {
-    notificationEl = parent;
-  }
-  return notificationEl;
+  return aElement.closest("popupnotification");
 }
diff --git a/browser/components/customizableui/test/browser_panelUINotifications.js b/browser/components/customizableui/test/browser_panelUINotifications.js
--- a/browser/components/customizableui/test/browser_panelUINotifications.js
+++ b/browser/components/customizableui/test/browser_panelUINotifications.js
@@ -8,32 +8,30 @@ ChromeUtils.import("resource://gre/modul
  */
 add_task(async function testMainActionCalled() {
   let options = {
     gBrowser: window.gBrowser,
     url: "about:blank",
   };
 
   await BrowserTestUtils.withNewTab(options, function(browser) {
-    let doc = browser.ownerDocument;
-
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
     let mainActionCalled = false;
     let mainAction = {
       callback: () => { mainActionCalled = true; },
     };
     AppMenuNotifications.showNotification("update-manual", mainAction);
 
     isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is showing.");
     let notifications = [...PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
     is(doorhanger.id, "appMenu-update-manual-notification", "PanelUI is displaying the update-manual notification.");
 
-    let button = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "button");
+    let button = doorhanger.button;
     button.click();
 
     ok(mainActionCalled, "Main action callback was called");
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
     is(PanelUI.menuButton.hasAttribute("badge-status"), false, "Should not have a badge status");
   });
 });
 
@@ -61,17 +59,17 @@ add_task(async function testSecondaryAct
     AppMenuNotifications.showNotification("update-manual", mainAction);
 
     isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is showing.");
     let notifications = [...PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
     is(doorhanger.id, "appMenu-update-manual-notification", "PanelUI is displaying the update-manual notification.");
 
-    let secondaryActionButton = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "secondarybutton");
+    let secondaryActionButton = doorhanger.secondarybutton;
     secondaryActionButton.click();
 
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
 
     is(PanelUI.menuButton.getAttribute("badge-status"), "update-manual", "Badge is displaying on PanelUI button.");
 
     await gCUITestUtils.openMainMenu();
     isnot(PanelUI.menuButton.getAttribute("badge-status"), "update-manual", "Badge is hidden on PanelUI button.");
@@ -112,17 +110,17 @@ add_task(async function testInteractionW
 
     isnot(PanelUI.menuButton.getAttribute("badge-status"), "fxa-needs-authentication", "Fxa badge is hidden on PanelUI button.");
     isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is showing.");
     let notifications = [...PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
     is(doorhanger.id, "appMenu-update-manual-notification", "PanelUI is displaying the update-manual notification.");
 
-    let secondaryActionButton = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "secondarybutton");
+    let secondaryActionButton = doorhanger.secondarybutton;
     secondaryActionButton.click();
 
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
 
     is(PanelUI.menuButton.getAttribute("badge-status"), "update-manual", "Badge is displaying on PanelUI button.");
 
     await gCUITestUtils.openMainMenu();
     isnot(PanelUI.menuButton.getAttribute("badge-status"), "update-manual", "Badge is hidden on PanelUI button.");
@@ -156,17 +154,17 @@ add_task(async function testAddingBadgeW
 
     isnot(PanelUI.menuButton.getAttribute("badge-status"), "fxa-needs-authentication", "Fxa badge is hidden on PanelUI button.");
     isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is showing.");
     let notifications = [...PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
     is(doorhanger.id, "appMenu-update-manual-notification", "PanelUI is displaying the update-manual notification.");
 
-    let mainActionButton = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "button");
+    let mainActionButton = doorhanger.button;
     mainActionButton.click();
 
     ok(mainActionCalled, "Main action callback was called");
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
     is(PanelUI.menuButton.getAttribute("badge-status"), "fxa-needs-authentication", "Fxa badge is shown on PanelUI button.");
     AppMenuNotifications.removeNotification(/.*/);
     is(PanelUI.menuButton.hasAttribute("badge-status"), false, "Should not have a badge status");
   });
@@ -241,17 +239,17 @@ add_task(async function testMultipleNonB
     AppMenuNotifications.showNotification("update-restart", updateRestartAction);
 
     isnot(PanelUI.notificationPanel.state, "closed", "Doorhanger is showing.");
     notifications = [...PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     doorhanger = notifications[0];
     is(doorhanger.id, "appMenu-update-restart-notification", "PanelUI is displaying the update-restart notification.");
 
-    let secondaryActionButton = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "secondarybutton");
+    let secondaryActionButton = doorhanger.secondarybutton;
     secondaryActionButton.click();
 
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
     is(PanelUI.menuButton.getAttribute("badge-status"), "update-restart", "update-restart badge is displaying on PanelUI button.");
 
     await gCUITestUtils.openMainMenu();
     isnot(PanelUI.menuButton.getAttribute("badge-status"), "update-restart", "update-restart badge is hidden on PanelUI button.");
     let menuItem = PanelUI.mainView.querySelector(".panel-banner-item");
diff --git a/browser/components/customizableui/test/browser_panelUINotifications_fullscreen.js b/browser/components/customizableui/test/browser_panelUINotifications_fullscreen.js
--- a/browser/components/customizableui/test/browser_panelUINotifications_fullscreen.js
+++ b/browser/components/customizableui/test/browser_panelUINotifications_fullscreen.js
@@ -30,14 +30,13 @@ add_task(async function testFullscreen()
 
   let popupshownPromise = BrowserTestUtils.waitForEvent(PanelUI.notificationPanel, "popupshown");
   EventUtils.synthesizeKey("KEY_F11");
   await popupshownPromise;
   await new Promise(executeSoon);
   isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is showing.");
   isnot(PanelUI.menuButton.getAttribute("badge-status"), "update-manual", "Badge is not displaying on PanelUI button.");
 
-  let mainActionButton = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "button");
-  mainActionButton.click();
+  doorhanger.button.click();
   ok(mainActionCalled, "Main action callback was called");
   is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
   is(PanelUI.menuButton.hasAttribute("badge-status"), false, "Should not have a badge status");
 });
diff --git a/browser/components/customizableui/test/browser_panelUINotifications_fullscreen_noAutoHideToolbar.js b/browser/components/customizableui/test/browser_panelUINotifications_fullscreen_noAutoHideToolbar.js
--- a/browser/components/customizableui/test/browser_panelUINotifications_fullscreen_noAutoHideToolbar.js
+++ b/browser/components/customizableui/test/browser_panelUINotifications_fullscreen_noAutoHideToolbar.js
@@ -72,18 +72,17 @@ add_task(async function testFullscreen()
   await ContentTask.spawn(gBrowser.selectedBrowser, {}, async () => {
     content.document.exitFullscreen();
   });
   await popupshownPromise;
   await new Promise(executeSoon);
   isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is shown after exiting DOM fullscreen.");
   isnot(PanelUI.menuButton.getAttribute("badge-status"), "update-manual", "Badge is not displaying on PanelUI button.");
 
-  let mainActionButton = document.getAnonymousElementByAttribute(doorhanger, "anonid", "button");
-  mainActionButton.click();
+  doorhanger.button.click();
   ok(mainActionCalled, "Main action callback was called");
   is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
   is(PanelUI.menuButton.hasAttribute("badge-status"), false, "Should not have a badge status");
 
   fullscreenPromise = BrowserTestUtils.waitForEvent(window, "fullscreen");
   EventUtils.synthesizeKey("KEY_F11");
   await fullscreenPromise;
 });
diff --git a/browser/components/customizableui/test/browser_panelUINotifications_multiWindow.js b/browser/components/customizableui/test/browser_panelUINotifications_multiWindow.js
--- a/browser/components/customizableui/test/browser_panelUINotifications_multiWindow.js
+++ b/browser/components/customizableui/test/browser_panelUINotifications_multiWindow.js
@@ -9,18 +9,16 @@ ChromeUtils.import("resource://gre/modul
  */
 add_task(async function testDoesNotShowDoorhangerForBackgroundWindow() {
   let options = {
     gBrowser: window.gBrowser,
     url: "about:blank",
   };
 
   await BrowserTestUtils.withNewTab(options, async function(browser) {
-    let doc = browser.ownerDocument;
-
     let win = await BrowserTestUtils.openNewBrowserWindow();
     await SimpleTest.promiseFocus(win);
     let mainActionCalled = false;
     let mainAction = {
       callback: () => { mainActionCalled = true; },
     };
     AppMenuNotifications.showNotification("update-manual", mainAction);
     is(PanelUI.notificationPanel.state, "closed", "The background window's doorhanger is closed.");
@@ -29,17 +27,17 @@ add_task(async function testDoesNotShowD
     await BrowserTestUtils.closeWindow(win);
     await SimpleTest.promiseFocus(window);
     isnot(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is showing.");
     let notifications = [...PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
     is(doorhanger.id, "appMenu-update-manual-notification", "PanelUI is displaying the update-manual notification.");
 
-    let button = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "button");
+    let button = doorhanger.button;
     button.click();
 
     ok(mainActionCalled, "Main action callback was called");
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
     is(PanelUI.menuButton.hasAttribute("badge-status"), false, "Should not have a badge status");
   });
 });
 
@@ -53,22 +51,20 @@ add_task(async function testBackgroundWi
     gBrowser: window.gBrowser,
     url: "about:blank",
   };
 
   await BrowserTestUtils.withNewTab(options, async function(browser) {
     let win = await BrowserTestUtils.openNewBrowserWindow();
     await SimpleTest.promiseFocus(win);
     AppMenuNotifications.showNotification("update-manual", {callback() {}});
-    let doc = win.gBrowser.ownerDocument;
     let notifications = [...win.PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
-    let button = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "button");
-    button.click();
+    doorhanger.button.click();
 
     await BrowserTestUtils.closeWindow(win);
     await SimpleTest.promiseFocus(window);
 
     is(PanelUI.notificationPanel.state, "closed", "update-manual doorhanger is closed.");
     is(PanelUI.menuButton.hasAttribute("badge-status"), false, "Should not have a badge status");
   });
 });
@@ -88,17 +84,17 @@ add_task(async function testBackgroundWi
   await BrowserTestUtils.withNewTab(options, async function(browser) {
     let win = await BrowserTestUtils.openNewBrowserWindow();
     await SimpleTest.promiseFocus(win);
     AppMenuNotifications.showNotification("update-manual", {callback() {}});
     let doc = win.gBrowser.ownerDocument;
     let notifications = [...win.PanelUI.notificationPanel.children].filter(n => !n.hidden);
     is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
     let doorhanger = notifications[0];
-    let button = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "secondarybutton");
+    let button = doorhanger.secondarybutton;
     button.click();
 
     await BrowserTestUtils.closeWindow(win);
     await SimpleTest.promiseFocus(window);
 
     is(PanelUI.notificationPanel.state, "closed", "The background window's doorhanger is closed.");
     is(PanelUI.menuButton.hasAttribute("badge-status"), true,
        "The dismissed notification should still have a badge status");
@@ -111,21 +107,20 @@ add_task(async function testBackgroundWi
  * Tests that when we open a new window while a notification is showing, the
  * notification also shows on the new window.
  */
 add_task(async function testOpenWindowAfterShowingNotification() {
   AppMenuNotifications.showNotification("update-manual", {callback() {}});
 
   let win = await BrowserTestUtils.openNewBrowserWindow();
   await SimpleTest.promiseFocus(win);
-  let doc = win.gBrowser.ownerDocument;
   let notifications = [...win.PanelUI.notificationPanel.children].filter(n => !n.hidden);
   is(notifications.length, 1, "PanelUI doorhanger is only displaying one notification.");
   let doorhanger = notifications[0];
-  let button = doc.getAnonymousElementByAttribute(doorhanger, "anonid", "secondarybutton");
+  let button = doorhanger.secondarybutton;
   button.click();
 
   await BrowserTestUtils.closeWindow(win);
   await SimpleTest.promiseFocus(window);
 
   is(PanelUI.notificationPanel.state, "closed", "The background window's doorhanger is closed.");
   is(PanelUI.menuButton.hasAttribute("badge-status"), true,
      "The dismissed notification should still have a badge status");
diff --git a/browser/components/extensions/ExtensionControlledPopup.jsm b/browser/components/extensions/ExtensionControlledPopup.jsm
--- a/browser/components/extensions/ExtensionControlledPopup.jsm
+++ b/browser/components/extensions/ExtensionControlledPopup.jsm
@@ -223,16 +223,17 @@ class ExtensionControlledPopup {
     }
 
     let addon = await AddonManager.getAddonByID(extensionId);
     this.populateDescription(doc, addon);
 
     // Setup the command handler.
     let handleCommand = async (event) => {
       panel.hidePopup();
+      // XXX: Check popupnotification.button instead?
       if (event.originalTarget.getAttribute("anonid") == "button") {
         // Main action is to keep changes.
         await this.setConfirmation(extensionId);
       } else {
         // Secondary action is to restore settings.
         if (this.beforeDisableAddon) {
           await this.beforeDisableAddon(this, win);
         }
diff --git a/browser/components/extensions/test/browser/browser_ExtensionControlledPopup.js b/browser/components/extensions/test/browser/browser_ExtensionControlledPopup.js
--- a/browser/components/extensions/test/browser/browser_ExtensionControlledPopup.js
+++ b/browser/components/extensions/test/browser/browser_ExtensionControlledPopup.js
@@ -99,26 +99,24 @@ add_task(async function testExtensionCon
     Services.obs.notifyObservers(null, observerTopic);
     return popupShown;
   }
 
   function closePopupWithAction(action, extensionId) {
     let done;
     if (action == "ignore") {
       panel.hidePopup();
-    } else {
-      if (action == "button") {
-        done = TestUtils.waitForCondition(() => {
-          return ExtensionSettingsStore.getSetting(confirmedType, id, id).value;
-        });
-      } else if (action == "secondarybutton") {
-        done = awaitEvent("shutdown", id);
-      }
-      doc.getAnonymousElementByAttribute(
-        popupnotification, "anonid", action).click();
+    } else if (action == "button") {
+      done = TestUtils.waitForCondition(() => {
+        return ExtensionSettingsStore.getSetting(confirmedType, id, id).value;
+      });
+      popupnotification.button.click();
+    } else if (action == "secondarybutton") {
+      done = awaitEvent("shutdown", id);
+      popupnotification.secondarybutton.click();
     }
     return done;
   }
 
   // No callbacks are initially called.
   ok(!onObserverAdded.called, "No observer has been added");
   ok(!onObserverRemoved.called, "No observer has been removed");
   ok(!beforeDisableAddon.called, "Settings have not been restored");
diff --git a/browser/components/extensions/test/browser/browser_ext_chrome_settings_overrides_home.js b/browser/components/extensions/test/browser/browser_ext_chrome_settings_overrides_home.js
--- a/browser/components/extensions/test/browser/browser_ext_chrome_settings_overrides_home.js
+++ b/browser/components/extensions/test/browser/browser_ext_chrome_settings_overrides_home.js
@@ -323,30 +323,29 @@ add_task(async function test_doorhanger_
   await BrowserTestUtils.browserLoaded(gBrowser.selectedBrowser);
   await popupShown;
 
   ok(gURLBar.value.endsWith("ext2.html"), "ext2 is in control");
 
   // Click Restore Settings.
   let popupHidden = promisePopupHidden(panel);
   let prefPromise = promisePrefChangeObserved(HOMEPAGE_URL_PREF);
-  document.getAnonymousElementByAttribute(
-    popupnotification, "anonid", "secondarybutton").click();
+  popupnotification.secondarybutton.click();
   await prefPromise;
   await popupHidden;
 
   // Expect a new doorhanger for the next extension.
   await promisePopupShown(panel);
 
   ok(gURLBar.value.endsWith("ext1.html"), "ext1 is in control");
 
   // Click Restore Settings again.
   popupHidden = promisePopupHidden(panel);
   prefPromise = promisePrefChangeObserved(HOMEPAGE_URL_PREF);
-  document.getAnonymousElementByAttribute(popupnotification, "anonid", "secondarybutton").click();
+  popupnotification.secondarybutton.click();
   await popupHidden;
   await prefPromise;
 
   is(getHomePageURL(), defaultHomePage, "The homepage is set back to default");
 
   await ext1.unload();
   await ext2.unload();
 });
@@ -396,30 +395,30 @@ add_task(async function test_doorhanger_
   is(description.textContent,
      "An extension,  Ext2, changed what you see when you open your homepage and new windows.Learn more",
      "The extension name is in the popup");
 
   // Click Restore Settings.
   let popupHidden = promisePopupHidden(panel);
   let prefPromise = promisePrefChangeObserved(HOMEPAGE_URL_PREF);
   let popupnotification = doc.getElementById("extension-homepage-notification");
-  doc.getAnonymousElementByAttribute(popupnotification, "anonid", "secondarybutton").click();
+  popupnotification.secondarybutton.click();
   await prefPromise;
   await popupHidden;
 
   // Expect a new doorhanger for the next extension.
   await promisePopupShown(panel);
 
   ok(win.gURLBar.value.endsWith("ext1.html"), "ext1 is in control");
   is(description.textContent,
      "An extension,  Ext1, changed what you see when you open your homepage and new windows.Learn more",
      "The extension name is in the popup");
 
   // Click Keep Changes.
-  doc.getAnonymousElementByAttribute(popupnotification, "anonid", "button").click();
+  popupnotification.button.click();
   await TestUtils.waitForCondition(() => isConfirmed(ext1Id));
 
   ok(getHomePageURL().endsWith("ext1.html"), "The homepage is still the set");
 
   await BrowserTestUtils.closeWindow(win);
   await ext1.unload();
   await ext2.unload();
 
diff --git a/browser/components/extensions/test/browser/browser_ext_tabs_hide.js b/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
--- a/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
+++ b/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
@@ -60,18 +60,17 @@ add_task(function test_doorhanger_keep()
 
     is(gBrowser.visibleTabs.length, 2, "There are 2 visible tabs now");
     is(panel.anchorNode.closest("toolbarbutton").id,
        "alltabs-button", "The doorhanger is anchored to the all tabs button");
 
     // Click the Keep Tabs Hidden button.
     let popupnotification = document.getElementById("extension-tab-hide-notification");
     let popupHidden = promisePopupHidden(panel);
-    document.getAnonymousElementByAttribute(
-      popupnotification, "anonid", "button").click();
+    popupnotification.button.click();
     await popupHidden;
 
     // Hide another tab and ensure the popup didn't open.
     extension.sendMessage("hide", {url: "*://*/?two"});
     await extension.awaitMessage("done");
     is(panel.state, "closed", "The popup is still closed");
     is(gBrowser.visibleTabs.length, 1, "There's one visible tab now");
 
@@ -105,18 +104,17 @@ add_task(function test_doorhanger_disabl
     is(images.length, 2, "There are two images");
     ok(images.some(img => img.src.includes("addon-icon.png")),
        "There's an icon for the extension");
     ok(images.some(img => getComputedStyle(img).backgroundImage.includes("arrow-dropdown-16.svg")),
        "There's an icon for the all tabs menu");
 
     // Click the Disable Extension button.
     let popupHidden = promisePopupHidden(panel);
-    document.getAnonymousElementByAttribute(
-      popupnotification, "anonid", "secondarybutton").click();
+    popupnotification.secondarybutton.click();
     await popupHidden;
     await new Promise(executeSoon);
 
     is(gBrowser.visibleTabs.length, 3, "There are 3 visible tabs again");
     is(addon.userDisabled, true, "The extension is now disabled");
   });
 });
 
diff --git a/browser/components/extensions/test/browser/browser_ext_url_overrides_newtab.js b/browser/components/extensions/test/browser/browser_ext_url_overrides_newtab.js
--- a/browser/components/extensions/test/browser/browser_ext_url_overrides_newtab.js
+++ b/browser/components/extensions/test/browser/browser_ext_url_overrides_newtab.js
@@ -12,25 +12,21 @@ function getNotificationSetting(extensio
   return ExtensionSettingsStore.getSetting("newTabNotification", extensionId);
 }
 
 function getNewTabDoorhanger() {
   return document.getElementById("extension-new-tab-notification");
 }
 
 function clickKeepChanges(notification) {
-  let button = document.getAnonymousElementByAttribute(
-    notification, "anonid", "button");
-  button.click();
+  notification.button.click();
 }
 
 function clickRestoreSettings(notification) {
-  let button = document.getAnonymousElementByAttribute(
-    notification, "anonid", "secondarybutton");
-  button.click();
+  notification.secondarybutton.click();
 }
 
 function waitForNewTab() {
   let eventName = "browser-open-newtab-start";
   return new Promise(resolve => {
     function observer() {
       Services.obs.removeObserver(observer, eventName);
       resolve();
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -72,17 +72,20 @@ const MozElementMixin = Base => class Mo
     }
 
     if (attrNewName === "text") {
       child.textContent =
         this.hasAttribute(attrName) ? this.getAttribute(attrName) : "";
     } else if (this.hasAttribute(attrName)) {
       child.setAttribute(attrNewName, this.getAttribute(attrName));
     } else {
-      child.removeAttribute(attrNewName);
+      // XXX: We don't want to empty out the existing 'class' if iconclass wasn't passed in.
+      // How does XBL handle this? Does it never empty it out, or only do it if it was originally
+      // set by the host, or what?
+      // child.removeAttribute(attrNewName);
     }
   }
 
   /**
    * Sometimes an element may not want to run connectedCallback logic during
    * parse. This could be because we don't want to initialize the element before
    * the element's contents have been fully parsed, or for performance reasons.
    * If you'd like to opt-in to this, then add this to the beginning of your
@@ -296,16 +299,17 @@ customElements.setElementCreationCallbac
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
+    "chrome://global/content/elements/popupnotification.js",
     "chrome://global/content/elements/radio.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
     "chrome://global/content/elements/tree.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -95,16 +95,17 @@ toolkit.jar:
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
    content/global/elements/marquee.js          (widgets/marquee.js)
+   content/global/elements/popupnotification.js  (widgets/popupnotification.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
diff --git a/toolkit/content/widgets/notification.xml b/toolkit/content/widgets/popupnotification.js
copy from toolkit/content/widgets/notification.xml
copy to toolkit/content/widgets/popupnotification.js
--- a/toolkit/content/widgets/notification.xml
+++ b/toolkit/content/widgets/popupnotification.js
@@ -1,103 +1,171 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
 
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+class MozPopupNotification extends MozXULElement {
 
-<!DOCTYPE bindings [
-<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
-%notificationDTD;
-]>
+  static get observedAttributes() {
+    return [
+      "buttonaccesskey",
+      "buttoncommand",
+      "buttonhighlight",
+      "buttonlabel",
+      "checkboxchecked",
+      "checkboxcommand",
+      "checkboxhidden",
+      "checkboxlabel",
+      "closebuttoncommand",
+      "closebuttonhidden",
+      "dropmarkerhidden",
+      "dropmarkerpopupshown",
+      "endlabel",
+      "icon",
+      "iconclass",
+      "label",
+      "learnmoreclick",
+      "learnmoreurl",
+      "mainactiondisabled",
+      "menucommand",
+      "name",
+      "origin",
+      "origin",
+      "popupid",
+      "secondarybuttonaccesskey",
+      "secondarybuttoncommand",
+      "secondarybuttonhidden",
+      "secondarybuttonlabel",
+      "secondendlabel",
+      "secondname",
+      "warninghidden",
+      "warninglabel",
+    ];
+  }
 
-<bindings id="notificationBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:xbl="http://www.mozilla.org/xbl"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:html = "http://www.w3.org/1999/xhtml">
+  attributeChangedCallback(o, v, n) {
+    if (!this._hasSlotted) {
+      return;
+    }
+
+    this.inheritAttributes();
+  }
+
+  inheritAttributes() {
+    for (let el of this.querySelectorAll("[inherits]")) {
+      for (let attr of el.getAttribute("inherits").split(",")) {
+        this.inheritAttribute(el, attr);
+      }
+    }
+  }
 
-  <binding id="popup-notification">
-    <content orient="vertical">
-      <xul:hbox class="popup-notification-header-container">
-        <children includes="popupnotificationheader"/>
-      </xul:hbox>
-      <xul:hbox align="start" class="popup-notification-body-container">
-        <xul:image class="popup-notification-icon"
-                   xbl:inherits="popupid,src=icon,class=iconclass"/>
-        <xul:vbox flex="1" pack="start"
-                  class="popup-notification-body" xbl:inherits="popupid">
-          <xul:hbox align="start">
-            <xul:vbox flex="1">
-              <xul:label class="popup-notification-origin header"
-                         xbl:inherits="value=origin,tooltiptext=origin"
-                         crop="center"/>
-              <!-- These need to be on the same line to avoid creating
-                   whitespace between them (whitespace is added in the
-                   localization file, if necessary). -->
-              <xul:description class="popup-notification-description" xbl:inherits="popupid"><html:span
-                xbl:inherits="xbl:text=label,popupid"/><html:b xbl:inherits="xbl:text=name,popupid"/><html:span
-              xbl:inherits="xbl:text=endlabel,popupid"/><html:b xbl:inherits="xbl:text=secondname,popupid"/><html:span
-              xbl:inherits="xbl:text=secondendlabel,popupid"/></xul:description>
-            </xul:vbox>
-            <xul:toolbarbutton anonid="closebutton"
-                               class="messageCloseButton close-icon popup-notification-closebutton tabbable"
-                               xbl:inherits="oncommand=closebuttoncommand,hidden=closebuttonhidden"
-                               tooltiptext="&closeNotification.tooltip;"/>
-          </xul:hbox>
-          <children includes="popupnotificationcontent"/>
-          <xul:label class="text-link popup-notification-learnmore-link"
-                     xbl:inherits="onclick=learnmoreclick,href=learnmoreurl">&learnMore;</xul:label>
-          <xul:checkbox anonid="checkbox"
-                        xbl:inherits="hidden=checkboxhidden,checked=checkboxchecked,label=checkboxlabel,oncommand=checkboxcommand" />
-          <xul:description class="popup-notification-warning" xbl:inherits="hidden=warninghidden,xbl:text=warninglabel"/>
-        </xul:vbox>
-      </xul:hbox>
-      <xul:hbox class="popup-notification-footer-container">
-        <children includes="popupnotificationfooter"/>
-      </xul:hbox>
-      <xul:hbox class="popup-notification-button-container panel-footer">
-        <children includes="button"/>
-        <xul:button anonid="secondarybutton"
-                    class="popup-notification-button popup-notification-secondary-button"
-                    xbl:inherits="oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden"/>
-        <xul:toolbarseparator xbl:inherits="hidden=dropmarkerhidden"/>
-        <xul:button anonid="menubutton"
-                    type="menu"
-                    class="popup-notification-button popup-notification-dropmarker"
-                    aria-label="&moreActionsButton.accessibleLabel;"
-                    xbl:inherits="onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden">
-          <xul:menupopup anonid="menupopup"
-                         position="after_end"
-                         aria-label="&moreActionsButton.accessibleLabel;"
-                         xbl:inherits="oncommand=menucommand">
-            <children/>
-          </xul:menupopup>
-        </xul:button>
-        <xul:button anonid="button"
-                    class="popup-notification-button popup-notification-primary-button"
-                    label="&defaultButton.label;"
-                    accesskey="&defaultButton.accesskey;"
-                    xbl:inherits="oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,default=buttonhighlight,disabled=mainactiondisabled"/>
-      </xul:hbox>
-    </content>
-    <implementation>
-      <field name="checkbox" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "checkbox");
-      </field>
-      <field name="closebutton" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "closebutton");
-      </field>
-      <field name="button" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "button");
-      </field>
-      <field name="secondaryButton" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "secondarybutton");
-      </field>
-      <field name="menubutton" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "menubutton");
-      </field>
-      <field name="menupopup" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "menupopup");
-      </field>
-    </implementation>
-  </binding>
-</bindings>
+  constructor() {
+    super();
+    XPCOMUtils.defineLazyGetter(this, "button", () => {
+      this.slotContents();
+      return this.querySelector("[anonid=button]");
+    });
+    XPCOMUtils.defineLazyGetter(this, "secondarybutton", () => {
+      this.slotContents();
+      return this.querySelector("[anonid=secondarybutton]");
+    });
+    XPCOMUtils.defineLazyGetter(this, "checkbox", () => {
+      this.slotContents();
+      return this.querySelector("[anonid=checkbox]");
+    });
+    XPCOMUtils.defineLazyGetter(this, "closebutton", () => {
+      this.slotContents();
+      return this.querySelector("[anonid=closebutton]");
+    });
+    XPCOMUtils.defineLazyGetter(this, "menubutton", () => {
+      this.slotContents();
+      return this.querySelector("[anonid=menubutton]");
+    });
+    XPCOMUtils.defineLazyGetter(this, "menupopup", () => {
+      this.slotContents();
+      return this.querySelector("[anonid=menupopup]");
+    });
+  }
+
+  slotContents() {
+    if (this._hasSlotted) {
+      return;
+    }
+    this._hasSlotted = true;
+    let popupnotificationheader = this.querySelector("popupnotificationheader");
+    let popupnotificationcontent = this.querySelector("popupnotificationcontent");
+    let popupnotificationfooter = this.querySelector("popupnotificationfooter");
+    let button = this.querySelector("button");
+    let menuitems = this.querySelectorAll("menuitem");
+    this.appendChild(MozXULElement.parseXULToFragment(`
+      <hbox class="popup-notification-header-container">
+        <children includes="popupnotificationheader"></children>
+      </hbox>
+      <hbox align="start" class="popup-notification-body-container">
+        <image class="popup-notification-icon"
+               inherits="popupid,src=icon,class=iconclass"/>
+        <vbox flex="1" pack="start" class="popup-notification-body">
+          <hbox align="start">
+            <vbox flex="1">
+              <label class="popup-notification-origin header" inherits="value=origin,tooltiptext=origin" crop="center"></label>
+              <description class="popup-notification-description" inherits="popupid">
+                <html:span inherits="text=label,popupid"></html:span>
+                <html:b inherits="text=name,popupid"></html:b>
+                <html:span inherits="text=endlabel,popupid"></html:span>
+                <html:b inherits="text=secondname,popupid"></html:b>
+                <html:span inherits="text=secondendlabel,popupid"></html:span>
+              </description>
+            </vbox>
+            <toolbarbutton anonid="closebutton" class="messageCloseButton close-icon popup-notification-closebutton tabbable" inherits="oncommand=closebuttoncommand,hidden=closebuttonhidden" tooltiptext="&closeNotification.tooltip;"></toolbarbutton>
+          </hbox>
+          <children includes="popupnotificationcontent"></children>
+          <label class="text-link popup-notification-learnmore-link" inherits="onclick=learnmoreclick,href=learnmoreurl"></label>
+          <checkbox anonid="checkbox" inherits="hidden=checkboxhidden,checked=checkboxchecked,label=checkboxlabel,oncommand=checkboxcommand"></checkbox>
+          <description class="popup-notification-warning" inherits="hidden=warninghidden,text=warninglabel"></description>
+        </vbox>
+      </hbox>
+      <hbox class="popup-notification-footer-container">
+        <children includes="popupnotificationfooter"></children>
+      </hbox>
+      <hbox class="popup-notification-button-container panel-footer">
+        <children includes="button"></children>
+        <button anonid="secondarybutton" class="popup-notification-button popup-notification-secondary-button" inherits="oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden"></button>
+        <toolbarseparator inherits="hidden=dropmarkerhidden"></toolbarseparator>
+        <button anonid="menubutton" type="menu" class="popup-notification-button popup-notification-dropmarker" aria-label="&moreActionsButton.accessibleLabel;" inherits="onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden">
+          <menupopup anonid="menupopup" position="after_end" aria-label="&moreActionsButton.accessibleLabel;" inherits="oncommand=menucommand">
+            <children includes="menuitem"></children>
+          </menupopup>
+        </button>
+        <button anonid="button" class="popup-notification-button popup-notification-primary-button" label="&defaultButton.label;" accesskey="&defaultButton.accesskey;" inherits="oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,default=buttonhighlight,disabled=mainactiondisabled"></button>
+      </hbox>
+    `, ["chrome://global/locale/notification.dtd"]));
+
+    if (popupnotificationheader) {
+      this.querySelector("children[includes='popupnotificationheader']").replaceWith(popupnotificationheader);
+    }
+    if (popupnotificationcontent) {
+      this.querySelector("children[includes='popupnotificationcontent']").replaceWith(popupnotificationcontent);
+    }
+    if (popupnotificationfooter) {
+      this.querySelector("children[includes='popupnotificationfooter']").replaceWith(popupnotificationfooter);
+    }
+    if (button) {
+      this.querySelector("children[includes='button']").replaceWith(button);
+    }
+    if (menuitems) {
+      this.querySelector("children[includes='menuitem']").replaceWith(...menuitems);
+    }
+
+    this.inheritAttributes();
+  }
+}
+
+customElements.define("popupnotification", MozPopupNotification);
+
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -169,17 +169,17 @@ iframe {
   editor,
   iframe {
     display: block;
   }
 }
 
 /*********** popup notification ************/
 popupnotification {
-  -moz-binding: url("chrome://global/content/bindings/notification.xml#popup-notification");
+  -moz-box-orient: vertical;
 }
 
 .popup-notification-menubutton:not([label]) {
   display: none;
 }
 
 /********** checkbox **********/
 
diff --git a/toolkit/modules/PopupNotifications.jsm b/toolkit/modules/PopupNotifications.jsm
--- a/toolkit/modules/PopupNotifications.jsm
+++ b/toolkit/modules/PopupNotifications.jsm
@@ -47,26 +47,21 @@ function getAnchorFromBrowser(aBrowser, 
     if (ChromeUtils.getClassName(anchor) == "XULElement") {
       return anchor;
     }
     return aBrowser.ownerDocument.getElementById(anchor);
   }
   return null;
 }
 
+/**
+ * Given a DOM node inside a <popupnotification>, return the parent <popupnotification>.
+ */
 function getNotificationFromElement(aElement) {
-  // Need to find the associated notification object, which is a bit tricky
-  // since it isn't associated with the element directly - this is kind of
-  // gross and very dependent on the structure of the popupnotification
-  // binding's content.
-  let notificationEl;
-  let parent = aElement;
-  while (parent && (parent = aElement.ownerDocument.getBindingParent(parent)))
-    notificationEl = parent;
-  return notificationEl;
+  return aElement.closest("popupnotification");
 }
 
 /**
  * Notification object describes a single popup notification.
  *
  * @see PopupNotifications.show()
  */
 function Notification(id, message, anchorID, mainAction, secondaryActions,
@@ -741,22 +736,22 @@ PopupNotifications.prototype = {
       // If this notification was provided by the chrome document rather than
       // created ad hoc, move it back to where we got it from.
       let originalParent = gNotificationParents.get(popupnotification);
       if (originalParent) {
         popupnotification.notification = null;
 
         // Remove nodes dynamically added to the notification's menu button
         // in _refreshPanel.
-        let contentNode = popupnotification.lastElementChild;
+        let contentNode = popupnotification.menupopup.lastElementChild;
         while (contentNode) {
           let previousSibling = contentNode.previousElementSibling;
           if (contentNode.nodeName == "menuitem" ||
               contentNode.nodeName == "menuseparator")
-            popupnotification.removeChild(contentNode);
+            popupnotification.menupopup.removeChild(contentNode);
           contentNode = previousSibling;
         }
 
         // Re-hide the notification such that it isn't rendered in the chrome
         // document. _refreshPanel will unhide it again when needed.
         popupnotification.hidden = true;
 
         originalParent.appendChild(popupnotification);
@@ -940,16 +935,17 @@ PopupNotifications.prototype = {
         } else {
           this._setNotificationUIState(popupnotification, checkbox.uncheckedState);
         }
       } else {
         popupnotification.setAttribute("checkboxhidden", "true");
         popupnotification.setAttribute("warninghidden", "true");
       }
 
+      popupnotification.slotContents();
       this.panel.appendChild(popupnotification);
 
       // The popupnotification may be hidden if we got it from the chrome
       // document rather than creating it ad hoc.
       popupnotification.hidden = false;
     }, this);
   },
 
@@ -1040,16 +1036,17 @@ PopupNotifications.prototype = {
         this.panel.setAttribute("noautohide", "true");
       } else {
         this.panel.removeAttribute("noautohide");
       }
 
       // On OS X and Linux we need a different panel arrow color for
       // click-to-play plugins, so copy the popupid and use css.
       this.panel.setAttribute("popupid", this.panel.firstElementChild.getAttribute("popupid"));
+
       notificationsToShow.forEach(function(n) {
         // Record that the notification was actually displayed on screen.
         // Notifications that were opened a second time or that were originally
         // shown with "options.dismissed" will be recorded in a separate bucket.
         n._recordTelemetryStat(TELEMETRY_STAT_OFFERED);
         // Remember the time the notification was shown for the security delay.
         n.timeShown = this.window.performance.now();
       }, this);
diff --git a/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindow.js b/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindow.js
--- a/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindow.js
+++ b/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindow.js
@@ -17,17 +17,17 @@ add_task(async function testUpdatesBackg
       is(PanelUI.menuButton.getAttribute("badge-status"), "update-available",
          "The badge is showing for the background window");
       let popupShownPromise = BrowserTestUtils.waitForEvent(PanelUI.notificationPanel, "popupshown");
       await BrowserTestUtils.closeWindow(extraWindow);
       await SimpleTest.promiseFocus(window);
       await popupShownPromise;
 
       checkWhatsNewLink(window, "update-available-whats-new");
-      let buttonEl = getNotificationButton(window, "update-available", "button");
+      let buttonEl = getNotificationButton(window, "update-available");
       buttonEl.click();
     },
     {
       notificationId: "update-restart",
       button: "secondarybutton",
       cleanup() {
         AppMenuNotifications.removeNotification(/.*/);
       },
diff --git a/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindowFailures.js b/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindowFailures.js
--- a/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindowFailures.js
+++ b/toolkit/mozapps/update/tests/browser/browser_updatesBackgroundWindowFailures.js
@@ -15,17 +15,17 @@ add_task(async function testBackgroundWi
                                               "Background window has a badge.");
 
       is(PanelUI.notificationPanel.state, "closed",
          "The doorhanger is not showing for the background window");
       is(PanelUI.menuButton.getAttribute("badge-status"), "update-available",
          "The badge is showing for the background window");
 
       checkWhatsNewLink(extraWindow, "update-available-whats-new");
-      let buttonEl = getNotificationButton(extraWindow, "update-available", "button");
+      let buttonEl = getNotificationButton(extraWindow, "update-available");
       buttonEl.click();
 
       if (destroyWindow) {
         await BrowserTestUtils.closeWindow(extraWindow);
         await SimpleTest.promiseFocus(window);
       }
     };
   }
diff --git a/toolkit/mozapps/update/tests/browser/head.js b/toolkit/mozapps/update/tests/browser/head.js
--- a/toolkit/mozapps/update/tests/browser/head.js
+++ b/toolkit/mozapps/update/tests/browser/head.js
@@ -289,17 +289,17 @@ function waitForEvent(topic, status = nu
  *         The ID of the notification to get the button for.
  * @param  button
  *         The anonid of the button to get.
  * @return The button element.
  */
 function getNotificationButton(win, notificationId, button) {
   let notification = win.document.getElementById(`appMenu-${notificationId}-notification`);
   is(notification.hidden, false, `${notificationId} notification is showing`);
-  return win.document.getAnonymousElementByAttribute(notification, "anonid", button);
+  return notification.button;
 }
 
 /**
  * Ensures that the "What's new" link with the provided ID is displayed and
  * matches the url parameter provided. If no URL is provided, it will instead
  * ensure that the link matches the default link URL.
  *
  * @param  win
