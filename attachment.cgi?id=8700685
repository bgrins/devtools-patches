# HG changeset patch
# User Lin Clark <lclark@mozilla.com>
# Parent  36aa441232b7e8cc82b0a83d1b343fd3ace134a7
Bug 1064458 - Remove 'Log request and response bodies' preference. r=bgrins

diff --git a/devtools/client/locales/en-US/webConsole.dtd b/devtools/client/locales/en-US/webConsole.dtd
--- a/devtools/client/locales/en-US/webConsole.dtd
+++ b/devtools/client/locales/en-US/webConsole.dtd
@@ -6,21 +6,16 @@
   - keep it in English, or another language commonly spoken among web developers.
   - You want to make that choice consistent across the developer tools.
   - A good criteria is the language in which you'd find the best
   - documentation on web development on the web. -->
 
 <!ENTITY window.title "Web Console">
 <!ENTITY browserConsole.title "Browser Console">
 
-<!-- LOCALIZATION NOTE (saveBodies.label): You can see this string in the Web
-   - Console context menu. -->
-<!ENTITY saveBodies.label     "Log Request and Response Bodies">
-<!ENTITY saveBodies.accesskey "L">
-
 <!-- LOCALIZATION NOTE (openURL.label): You can see this string in the Web
    - Console context menu. -->
 <!ENTITY openURL.label     "Open URL in New Tab">
 <!ENTITY openURL.accesskey "T">
 
 <!-- LOCALIZATION NOTE (btnPageNet.label): This string is used for the menu
   -  button that allows users to toggle the network logging output.
   -  This string and the following strings toggle various kinds of output
diff --git a/devtools/client/netmonitor/har/har-automation.js b/devtools/client/netmonitor/har/har-automation.js
--- a/devtools/client/netmonitor/har/har-automation.js
+++ b/devtools/client/netmonitor/har/har-automation.js
@@ -68,21 +68,18 @@ var HarAutomation = Class({
     if (!tabGrip) {
       return;
     }
 
     this.debuggerClient = client;
     this.tabClient = this.toolbox.target.activeTab;
     this.webConsoleClient = this.toolbox.target.activeConsole;
 
-    let netPrefs = { "NetworkMonitor.saveRequestAndResponseBodies": true };
-    this.webConsoleClient.setPreferences(netPrefs, () => {
-      this.tabWatcher = new TabWatcher(this.toolbox, this);
-      this.tabWatcher.connect();
-    });
+    this.tabWatcher = new TabWatcher(this.toolbox, this);
+    this.tabWatcher.connect();
   },
 
   pageLoadBegin: function(aResponse) {
     this.resetCollector();
   },
 
   resetCollector: function() {
     if (this.collector) {
diff --git a/devtools/client/netmonitor/netmonitor-controller.js b/devtools/client/netmonitor/netmonitor-controller.js
--- a/devtools/client/netmonitor/netmonitor-controller.js
+++ b/devtools/client/netmonitor/netmonitor-controller.js
@@ -5,17 +5,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 var { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 
 const NET_STRINGS_URI = "chrome://devtools/locale/netmonitor.properties";
 const PKI_STRINGS_URI = "chrome://pippki/locale/pippki.properties";
 const LISTENERS = [ "NetworkActivity" ];
-const NET_PREFS = { "NetworkMonitor.saveRequestAndResponseBodies": true };
 
 // The panel's window global is an EventEmitter firing the following events:
 const EVENTS = {
   // When the monitored target begins and finishes navigating.
   TARGET_WILL_NAVIGATE: "NetMonitor:TargetWillNavigate",
   TARGET_DID_NAVIGATE: "NetMonitor:TargetNavigate",
 
   // When a network or timeline event is received.
@@ -221,17 +220,17 @@ var NetMonitorController = {
     // aren't actual tabs.
     if (this._target.isTabActor) {
       this.tabClient = this._target.activeTab;
     }
 
     let connectWebConsole = () => {
       let deferred = promise.defer();
       this.webConsoleClient = this._target.activeConsole;
-      this.webConsoleClient.setPreferences(NET_PREFS, deferred.resolve);
+      deferred.resolve();
       return deferred.promise;
     };
 
     let connectTimeline = () => {
       // Don't start up waiting for timeline markers if the server isn't
       // recent enough to emit the markers we're interested in.
       if (this._target.getTrait("documentLoadingMarkers")) {
         this.timelineFront = new TimelineFront(this._target.client, this._target.form);
diff --git a/devtools/client/webconsole/test/browser.ini b/devtools/client/webconsole/test/browser.ini
--- a/devtools/client/webconsole/test/browser.ini
+++ b/devtools/client/webconsole/test/browser.ini
@@ -165,16 +165,17 @@ skip-if = e10s # Bug 1042253 - webconsol
 skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole e10s tests
 [browser_console_filters.js]
 [browser_console_iframe_messages.js]
 skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole e10s tests
 [browser_console_keyboard_accessibility.js]
 [browser_console_log_inspectable_object.js]
 [browser_console_native_getters.js]
 [browser_console_navigation_marker.js]
+[browser_console_netlogging.js]
 [browser_console_nsiconsolemessage.js]
 skip-if = buildapp == 'mulet'
 [browser_console_optimized_out_vars.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_private_browsing.js]
 skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole e10s tests
 [browser_console_server_logging.js]
 [browser_console_variables_view.js]
@@ -294,17 +295,16 @@ skip-if = e10s # Bug 1042253 - webconsol
 skip-if = e10s && os == 'win'
 [browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_804845_ctrl_key_nav.js]
 skip-if = os != "mac"
 [browser_webconsole_bug_817834_add_edited_input_to_history.js]
 [browser_webconsole_bug_837351_securityerrors.js]
 skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js]
 [browser_webconsole_filter_buttons_contextmenu.js]
 [browser_webconsole_bug_1006027_message_timestamps_incorrect.js]
 skip-if = e10s # Bug 1042253 - webconsole e10s tests (Linux debug intermittent)
 [browser_webconsole_bug_1010953_cspro.js]
 skip-if = e10s && os == 'win'
 [browser_webconsole_certificate_messages.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_show_subresource_security_errors.js]
diff --git a/devtools/client/webconsole/test/browser_console_netlogging.js b/devtools/client/webconsole/test/browser_console_netlogging.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/browser_console_netlogging.js
@@ -0,0 +1,73 @@
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Tests that network log messages bring up the network panel.
+
+"use strict";
+
+const TEST_URI = "data:text/html;charset=utf-8,Web Console network " +
+                 "logging tests";
+
+const TEST_NETWORK_REQUEST_URI =
+  "http://example.com/browser/devtools/client/webconsole/test/" +
+  "test-network-request.html";
+
+var lastRequest = null;
+var requestCallback = null;
+var browser, hud;
+
+function test() {
+  info("test this out")
+  loadTab(TEST_URI).then((tab) => {
+    browser = tab.browser;
+
+    HUDService.openBrowserConsoleOrFocus().then(aHud => {
+      hud = aHud;
+      HUDService.lastFinishedRequest.callback = requestCallbackWrapper;
+      executeSoon(testPageLoad);
+    });
+  });
+}
+
+function requestCallbackWrapper(request) {
+  info("test this out again")
+  lastRequest = request;
+
+  hud.ui.webConsoleClient.getResponseContent(lastRequest.actor,
+    function(aResponse) {
+      lastRequest.response.content = aResponse.content;
+      lastRequest.discardResponseBody = aResponse.contentDiscarded;
+
+      hud.ui.webConsoleClient.getRequestPostData(lastRequest.actor,
+        function(response) {
+          lastRequest.request.postData = response.postData;
+          lastRequest.discardRequestBody = response.postDataDiscarded;
+
+          if (requestCallback) {
+            requestCallback();
+          }
+        });
+    });
+}
+
+function testPageLoad() {
+  requestCallback = function() {
+    // Check if page load was logged correctly.
+    ok(lastRequest, "Page load was logged");
+
+    is(lastRequest.request.url, TEST_NETWORK_REQUEST_URI,
+      "Logged network entry is page load");
+    is(lastRequest.request.method, "GET", "Method is correct");
+    ok(!lastRequest.request.postData.text, "No request body was stored");
+    ok(lastRequest.discardRequestBody, "Request body was discarded");
+    ok(!lastRequest.response.content.text, "No response body was stored");
+    ok(lastRequest.discardResponseBody || lastRequest.fromCache,
+       "Response body was discarded or response came from the cache");
+
+    executeSoon(finishTest);
+  };
+
+  BrowserTestUtils.loadURI(gBrowser.selectedBrowser, TEST_NETWORK_REQUEST_URI);
+}
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_600183_charset.js b/devtools/client/webconsole/test/browser_webconsole_bug_600183_charset.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_600183_charset.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_600183_charset.js
@@ -49,21 +49,16 @@ function waitForRequest() {
   return deferred.promise;
 }
 
 var test = asyncTest(function* () {
   let { browser } = yield loadTab(INIT_URI);
 
   let hud = yield openConsole();
 
-  yield hud.ui.setSaveRequestAndResponseBodies(true);
-
-  ok(hud.ui._saveRequestAndResponseBodies,
-    "The saveRequestAndResponseBodies property was successfully set.");
-
   let gotLastRequest = waitForRequest();
 
   let loaded = loadBrowser(browser);
   content.location = TEST_URI;
   yield loaded;
 
   yield gotLastRequest;
 });
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js b/devtools/client/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
@@ -28,30 +28,25 @@ var test = asyncTest(function* () {
 
   performTest();
 });
 
 function consoleOpened(hud) {
   let deferred = promise.defer();
 
   webConsoleClient = hud.ui.webConsoleClient;
-  hud.ui.setSaveRequestAndResponseBodies(true).then(() => {
-    ok(hud.ui._saveRequestAndResponseBodies,
-      "The saveRequestAndResponseBodies property was successfully set.");
-
-    HUDService.lastFinishedRequest.callback = (aHttpRequest) => {
-      let status = aHttpRequest.response.status;
-      lastFinishedRequests[status] = aHttpRequest;
-      if ("301" in lastFinishedRequests &&
-          "404" in lastFinishedRequests) {
-        deferred.resolve();
-      }
-    };
-    content.location = TEST_URI2;
-  });
+  HUDService.lastFinishedRequest.callback = (aHttpRequest) => {
+    let status = aHttpRequest.response.status;
+    lastFinishedRequests[status] = aHttpRequest;
+    if ("301" in lastFinishedRequests &&
+        "404" in lastFinishedRequests) {
+      deferred.resolve();
+    }
+  };
+  content.location = TEST_URI2;
 
   return deferred.promise;
 }
 
 function getHeaders() {
   let deferred = promise.defer();
 
   HUDService.lastFinishedRequest.callback = null;
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js b/devtools/client/webconsole/test/browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js
deleted file mode 100644
--- a/devtools/client/webconsole/test/browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js
+++ /dev/null
@@ -1,124 +0,0 @@
-/* vim:set ts=2 sw=2 sts=2 et: */
-/*
- * Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-// Tests that the 'Log Request and Response Bodies' buttons can be toggled
-// with keyboard.
-
-"use strict";
-
-const TEST_URI = "data:text/html;charset=utf-8,Web Console test for " +
-                 "bug 915141: Toggle log response bodies with keyboard";
-var hud;
-
-function test() {
-  let saveBodiesMenuItem;
-  let saveBodiesContextMenuItem;
-
-  loadTab(TEST_URI).then(({tab: tab}) => {
-    return openConsole(tab);
-  })
-  .then((aHud) => {
-    hud = aHud;
-    saveBodiesMenuItem = hud.ui.rootElement.querySelector("#saveBodies");
-    saveBodiesContextMenuItem = hud.ui.rootElement.querySelector("#saveBodiesContextMenu");
-
-    // Test the context menu action.
-    info("Testing 'Log Request and Response Bodies' menuitem of right click " +
-         "context menu.");
-
-    return openPopup(saveBodiesContextMenuItem);
-  })
-  .then(() => {
-    is(saveBodiesContextMenuItem.getAttribute("checked"), "false",
-       "Context menu: 'log responses' is not checked before action.");
-    is(hud.ui._saveRequestAndResponseBodies, false,
-       "Context menu: Responses are not logged before action.");
-
-    EventUtils.synthesizeKey("VK_DOWN", {});
-    EventUtils.synthesizeKey("VK_RETURN", {});
-
-    return waitForUpdate(saveBodiesContextMenuItem);
-  })
-  .then(() => {
-    is(saveBodiesContextMenuItem.getAttribute("checked"), "true",
-       "Context menu: 'log responses' is checked after menuitem was selected " +
-       "with keyboard.");
-    is(hud.ui._saveRequestAndResponseBodies, true,
-       "Context menu: Responses are saved after menuitem was selected with " +
-       "keyboard.");
-
-    return openPopup(saveBodiesMenuItem);
-  })
-  .then(() => {
-    // Test the 'Net' menu item.
-    info("Testing 'Log Request and Response Bodies' menuitem of 'Net' menu " +
-         "in the console.");
-    // 'Log Request and Response Bodies' should be selected due to previous
-    // test.
-
-    is(saveBodiesMenuItem.getAttribute("checked"), "true",
-       "Console net menu: 'log responses' is checked before action.");
-    is(hud.ui._saveRequestAndResponseBodies, true,
-       "Console net menu: Responses are logged before action.");
-
-    // The correct item is the last one in the menu.
-    EventUtils.synthesizeKey("VK_UP", {});
-    EventUtils.synthesizeKey("VK_RETURN", {});
-
-    return waitForUpdate(saveBodiesMenuItem);
-  })
-  .then(() => {
-    is(saveBodiesMenuItem.getAttribute("checked"), "false",
-       "Console net menu: 'log responses' is NOT checked after menuitem was " +
-       "selected with keyboard.");
-    is(hud.ui._saveRequestAndResponseBodies, false,
-       "Responses are NOT saved after menuitem was selected with keyboard.");
-    hud = null;
-  })
-  .then(finishTest);
-}
-
-/**
- * Opens and waits for the menu containing menuItem to open.
- * @param menuItem MenuItem
- *        A MenuItem in a menu that should be opened.
- * @return A promise that's resolved once menu is open.
- */
-function openPopup(menuItem) {
-  let menu = menuItem.parentNode;
-
-  let menuOpened = promise.defer();
-  let uiUpdated = promise.defer();
-  // The checkbox menuitem is updated asynchronously on 'popupshowing' event so
-  // it's better to wait for both the update to happen and the menu to open
-  // before continuing or the test might fail due to a race between menu being
-  // shown and the item updated to have the correct state.
-  hud.ui.once("save-bodies-ui-toggled", uiUpdated.resolve);
-  menu.addEventListener("popupshown", function onPopup() {
-    menu.removeEventListener("popupshown", onPopup);
-    menuOpened.resolve();
-  });
-
-  menu.openPopup();
-  return Promise.all([menuOpened.promise, uiUpdated.promise]);
-}
-
-/**
- * Waits for the settings and menu containing menuItem to update.
- * @param menuItem MenuItem
- *        The menuitem that should be updated.
- * @return A promise that's resolved once the settings and menus are updated.
- */
-function waitForUpdate(menuItem) {
-  info("Waiting for settings update to complete.");
-  let deferred = promise.defer();
-  hud.ui.once("save-bodies-pref-reversed", function() {
-    hud.ui.once("save-bodies-ui-toggled", deferred.resolve);
-    // The checked state is only updated once the popup is shown.
-    menuItem.parentNode.openPopup();
-  });
-  return deferred.promise;
-}
diff --git a/devtools/client/webconsole/test/browser_webconsole_netlogging.js b/devtools/client/webconsole/test/browser_webconsole_netlogging.js
--- a/devtools/client/webconsole/test/browser_webconsole_netlogging.js
+++ b/devtools/client/webconsole/test/browser_webconsole_netlogging.js
@@ -69,68 +69,26 @@ function testPageLoad() {
   requestCallback = function() {
     // Check if page load was logged correctly.
     ok(lastRequest, "Page load was logged");
 
     is(lastRequest.request.url, TEST_NETWORK_REQUEST_URI,
       "Logged network entry is page load");
     is(lastRequest.request.method, "GET", "Method is correct");
     ok(!lastRequest.request.postData.text, "No request body was stored");
-    ok(lastRequest.discardRequestBody, "Request body was discarded");
-    ok(!lastRequest.response.content.text, "No response body was stored");
-    ok(lastRequest.discardResponseBody || lastRequest.fromCache,
-       "Response body was discarded or response came from the cache");
-
-    lastRequest = null;
-    requestCallback = null;
-    executeSoon(testPageLoadBody);
-  };
-
-  content.location = TEST_NETWORK_REQUEST_URI;
-}
-
-function testPageLoadBody() {
-  // Turn on logging of request bodies and check again.
-  hud.ui.setSaveRequestAndResponseBodies(true).then(() => {
-    ok(hud.ui._saveRequestAndResponseBodies,
-      "The saveRequestAndResponseBodies property was successfully set.");
-
-    testPageLoadBodyAfterSettingUpdate();
-  });
-}
-
-function testPageLoadBodyAfterSettingUpdate() {
-  let loaded = false;
-  let requestCallbackInvoked = false;
-
-  requestCallback = function() {
-    ok(lastRequest, "Page load was logged again");
-    ok(!lastRequest.discardResponseBody, "Response body was not discarded");
+    ok(!lastRequest.discardRequestBody, "Request body was not discarded");
     is(lastRequest.response.content.text.indexOf("<!DOCTYPE HTML>"), 0,
       "Response body's beginning is okay");
 
     lastRequest = null;
     requestCallback = null;
-    requestCallbackInvoked = true;
-
-    if (loaded) {
-      executeSoon(testXhrGet);
-    }
+    executeSoon(testXhrGet);
   };
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    loaded = true;
-
-    if (requestCallbackInvoked) {
-      executeSoon(testXhrGet);
-    }
-  }, true);
-
-  content.location.reload();
+  content.location = TEST_NETWORK_REQUEST_URI;
 }
 
 function testXhrGet() {
   requestCallback = function() {
     ok(lastRequest, "testXhrGet() was logged");
     is(lastRequest.request.method, "GET", "Method is correct");
     ok(!lastRequest.request.postData.text, "No request body was sent");
     ok(!lastRequest.discardRequestBody, "Request body was not discarded");
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -363,52 +363,24 @@ WebConsoleFrame.prototype = {
    */
   get webConsoleClient() {
     return this.proxy ? this.proxy.webConsoleClient : null;
   },
 
   _destroyer: null,
 
   // Used in tests.
-  _saveRequestAndResponseBodies: false,
+  _saveRequestAndResponseBodies: true,
 
   // Chevron width at the starting of Web Console's input box.
   _chevronWidth: 0,
   // Width of the monospace characters in Web Console's input box.
   _inputCharWidth: 0,
 
   /**
-   * Tells whether to save the bodies of network requests and responses.
-   * Disabled by default to save memory.
-   *
-   * @return boolean
-   *         The saveRequestAndResponseBodies pref value.
-   */
-  getSaveRequestAndResponseBodies:
-  function WCF_getSaveRequestAndResponseBodies() {
-    let deferred = promise.defer();
-    let toGet = [
-      "NetworkMonitor.saveRequestAndResponseBodies"
-    ];
-
-    // Make sure the web console client connection is established first.
-    this.webConsoleClient.getPreferences(toGet, response => {
-      if (!response.error) {
-        this._saveRequestAndResponseBodies = response.preferences[toGet[0]];
-        deferred.resolve(this._saveRequestAndResponseBodies);
-      }
-      else {
-        deferred.reject(response.error);
-      }
-    });
-
-    return deferred.promise;
-  },
-
-  /**
    * Setter for saving of network request and response bodies.
    *
    * @param boolean value
    *        The new value you want to set.
    */
   setSaveRequestAndResponseBodies:
   function WCF_setSaveRequestAndResponseBodies(value) {
     if (!this.webConsoleClient) {
@@ -555,57 +527,16 @@ WebConsoleFrame.prototype = {
                      .removeAttribute("disabled");
       }
     }
 
     // Update the character width and height needed for the popup offset
     // calculations.
     this._updateCharSize();
 
-    let updateSaveBodiesPrefUI = (element) => {
-      this.getSaveRequestAndResponseBodies().then(value => {
-        element.setAttribute("checked", value);
-        this.emit("save-bodies-ui-toggled");
-      });
-    }
-
-    let reverseSaveBodiesPref = ({ target: element }) => {
-      this.getSaveRequestAndResponseBodies().then(value => {
-        this.setSaveRequestAndResponseBodies(!value);
-        element.setAttribute("checked", value);
-        this.emit("save-bodies-pref-reversed");
-      });
-    }
-
-    let saveBodiesDisabled = !this.getFilterState("networkinfo") &&
-                             !this.getFilterState("netxhr") &&
-                             !this.getFilterState("network");
-
-    let saveBodies = doc.getElementById("saveBodies");
-    saveBodies.addEventListener("command", reverseSaveBodiesPref);
-    saveBodies.disabled = saveBodiesDisabled;
-
-    let saveBodiesContextMenu = doc.getElementById("saveBodiesContextMenu");
-    saveBodiesContextMenu.addEventListener("command", reverseSaveBodiesPref);
-    saveBodiesContextMenu.disabled = saveBodiesDisabled;
-
-    saveBodies.parentNode.addEventListener("popupshowing", () => {
-      updateSaveBodiesPrefUI(saveBodies);
-      saveBodies.disabled = !this.getFilterState("networkinfo") &&
-                            !this.getFilterState("netxhr") &&
-                            !this.getFilterState("network");
-    });
-
-    saveBodiesContextMenu.parentNode.addEventListener("popupshowing", () => {
-      updateSaveBodiesPrefUI(saveBodiesContextMenu);
-      saveBodiesContextMenu.disabled = !this.getFilterState("networkinfo") &&
-                                       !this.getFilterState("netxhr") &&
-                                       !this.getFilterState("network");
-    });
-
     let clearButton = doc.getElementsByClassName("webconsole-clear-console-button")[0];
     clearButton.addEventListener("command", () => {
       this.owner._onClearButton();
       this.jsterm.clearOutput(true);
     });
 
     this.jsterm = new JSTerm(this);
     this.jsterm.init();
@@ -951,18 +882,16 @@ WebConsoleFrame.prototype = {
         let prefKey = target.getAttribute("prefKey");
         this.setFilterState(prefKey, state);
 
         // Disable the log response and request body if network logging is off.
         if (prefKey == "networkinfo" || prefKey == "netxhr" || prefKey == "network") {
           let checkState = !this.getFilterState("networkinfo") &&
                            !this.getFilterState("netxhr") &&
                            !this.getFilterState("network");
-          this.document.getElementById("saveBodies").disabled = checkState;
-          this.document.getElementById("saveBodiesContextMenu").disabled = checkState;
         }
 
         // Adjust the state of the button appropriately.
         let menuPopup = target.parentNode;
 
         let someChecked = false;
         let menuItem = menuPopup.firstChild;
         while (menuItem) {
@@ -5100,25 +5029,30 @@ WebConsoleConnectionProxy.prototype = {
     if (response.error) {
       Cu.reportError("attachConsole failed: " + response.error + " " +
                      response.message);
       this._connectDefer.reject(response);
       return;
     }
 
     this.webConsoleClient = webConsoleClient;
-
     this._hasNativeConsoleAPI = response.nativeConsoleAPI;
-    this.webConsoleClient.on("networkEvent", this._onNetworkEvent);
-    this.webConsoleClient.on("networkEventUpdate", this._onNetworkEventUpdate);
-
-    let msgs = ["PageError", "ConsoleAPI"];
-    this.webConsoleClient.getCachedMessages(msgs, this._onCachedMessages);
-
-    this.webConsoleFrame._onUpdateListeners();
+
+    // There is no way to view response bodies from the Browser Console, so do
+    // not waste the memory.
+    let saveBodies = !this.webConsoleFrame.owner._browserConsole;
+    this.webConsoleFrame.setSaveRequestAndResponseBodies(saveBodies).then(() => {
+      this.webConsoleClient.on("networkEvent", this._onNetworkEvent);
+      this.webConsoleClient.on("networkEventUpdate", this._onNetworkEventUpdate);
+
+      let msgs = ["PageError", "ConsoleAPI"];
+      this.webConsoleClient.getCachedMessages(msgs, this._onCachedMessages);
+
+      this.webConsoleFrame._onUpdateListeners();
+    });
   },
 
   /**
    * The "cachedMessages" response handler.
    *
    * @private
    * @param object response
    *        The JSON response object received from the server.
diff --git a/devtools/client/webconsole/webconsole.xul b/devtools/client/webconsole/webconsole.xul
--- a/devtools/client/webconsole/webconsole.xul
+++ b/devtools/client/webconsole/webconsole.xul
@@ -67,18 +67,16 @@ function goUpdateConsoleCommands() {
          enabled in JS -->
     <key id="key_clear" disabled="true" key="&clearOutputCtrl.key;" command="consoleCmd_clearOutput" modifiers="control shift"/>
     <key id="key_clearOSX" disabled="true" key="&clearOutputCtrl.key;" command="consoleCmd_clearOutput" modifiers="control"/>
   </keyset>
   <keyset id="editMenuKeys"/>
 
   <popupset id="mainPopupSet">
     <menupopup id="output-contextmenu" onpopupshowing="goUpdateGlobalEditMenuItems()">
-      <menuitem id="saveBodiesContextMenu" type="checkbox" label="&saveBodies.label;"
-                accesskey="&saveBodies.accesskey;"/>
       <menuitem id="menu_openURL" label="&openURL.label;"
                 accesskey="&openURL.accesskey;" command="consoleCmd_openURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_copyURL" label="&copyURLCmd.label;"
                 accesskey="&copyURLCmd.accesskey;" command="consoleCmd_copyURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_openInVarView" label="&openInVarViewCmd.label;"
         accesskey="&openInVarViewCmd.accesskey;" disabled="true"/>
@@ -105,19 +103,16 @@ function goUpdateConsoleCommands() {
               <menuitem label="&btnConsoleErrors;" type="checkbox" autocheck="false"
                         prefKey="network"/>
               <menuitem label="&btnConsoleWarnings;" type="checkbox" autocheck="false"
                         prefKey="netwarn"/>
               <menuitem label="&btnConsoleXhr;" type="checkbox" autocheck="false"
                         prefKey="netxhr"/>
               <menuitem label="&btnConsoleLog;" type="checkbox" autocheck="false"
                         prefKey="networkinfo"/>
-              <menuseparator id="saveBodiesSeparator" />
-              <menuitem id="saveBodies" type="checkbox" label="&saveBodies.label;"
-                        accesskey="&saveBodies.accesskey;"/>
             </menupopup>
           </toolbarbutton>
           <toolbarbutton label="&btnPageCSS.label;" type="menu-button"
                          category="css" class="devtools-toolbarbutton webconsole-filter-button"
                          tooltiptext="&btnPageCSS.tooltip2;"
                          accesskey="&btnPageCSS.accesskey;"
                          tabindex="4">
             <menupopup id="css-contextmenu">
diff --git a/devtools/shared/webconsole/network-monitor.js b/devtools/shared/webconsole/network-monitor.js
--- a/devtools/shared/webconsole/network-monitor.js
+++ b/devtools/shared/webconsole/network-monitor.js
@@ -519,21 +519,20 @@ NetworkMonitor.prototype = {
 
   // Network response bodies are piped through a buffer of the given size (in
   // bytes).
   responsePipeSegmentSize: null,
 
   owner: null,
 
   /**
-   * Whether to save the bodies of network requests and responses. Disabled by
-   * default to save memory.
+   * Whether to save the bodies of network requests and responses.
    * @type boolean
    */
-  saveRequestAndResponseBodies: false,
+  saveRequestAndResponseBodies: true,
 
   /**
    * Object that holds the HTTP activity objects for ongoing requests.
    */
   openRequests: null,
 
   /**
    * Object that holds response headers coming from this._httpResponseExaminer.
@@ -1238,17 +1237,17 @@ function NetworkMonitorChild(appId, mess
   this._netEvents = new Map();
 }
 exports.NetworkMonitorChild = NetworkMonitorChild;
 
 NetworkMonitorChild.prototype = {
   appId: null,
   owner: null,
   _netEvents: null,
-  _saveRequestAndResponseBodies: false,
+  _saveRequestAndResponseBodies: true,
 
   get saveRequestAndResponseBodies() {
     return this._saveRequestAndResponseBodies;
   },
 
   set saveRequestAndResponseBodies(val) {
     this._saveRequestAndResponseBodies = val;
 
diff --git a/devtools/shared/webconsole/test/test_network_longstring.html b/devtools/shared/webconsole/test/test_network_longstring.html
--- a/devtools/shared/webconsole/test/test_network_longstring.html
+++ b/devtools/shared/webconsole/test/test_network_longstring.html
@@ -20,37 +20,25 @@ function startTest()
 {
   removeEventListener("load", startTest);
 
   attachConsoleToTab(["NetworkActivity"], onAttach);
 }
 
 function onAttach(aState, aResponse)
 {
-  info("enable network request and response body logging");
+  info("set long string length");
 
   window.ORIGINAL_LONG_STRING_LENGTH = DebuggerServer.LONG_STRING_LENGTH;
   window.ORIGINAL_LONG_STRING_INITIAL_LENGTH =
     DebuggerServer.LONG_STRING_INITIAL_LENGTH;
 
   DebuggerServer.LONG_STRING_LENGTH = 400;
   DebuggerServer.LONG_STRING_INITIAL_LENGTH = 400;
 
-  onSetPreferences = onSetPreferences.bind(null, aState);
-  aState.client.setPreferences({
-    "NetworkMonitor.saveRequestAndResponseBodies": true,
-  }, onSetPreferences);
-}
-
-function onSetPreferences(aState, aResponse)
-{
-  is(aResponse.updated.length, 1, "updated prefs length");
-  is(aResponse.updated[0], "NetworkMonitor.saveRequestAndResponseBodies",
-     "updated prefs length");
-
   info("test network POST request");
 
   onNetworkEvent = onNetworkEvent.bind(null, aState);
   aState.dbgClient.addListener("networkEvent", onNetworkEvent);
   onNetworkEventUpdate = onNetworkEventUpdate.bind(null, aState);
   aState.dbgClient.addListener("networkEventUpdate", onNetworkEventUpdate);
 
   let iframe = document.querySelector("iframe").contentWindow;
diff --git a/devtools/shared/webconsole/test/test_network_post.html b/devtools/shared/webconsole/test/test_network_post.html
--- a/devtools/shared/webconsole/test/test_network_post.html
+++ b/devtools/shared/webconsole/test/test_network_post.html
@@ -20,30 +20,16 @@ function startTest()
 {
   removeEventListener("load", startTest);
 
   attachConsoleToTab(["NetworkActivity"], onAttach);
 }
 
 function onAttach(aState, aResponse)
 {
-  info("enable network request and response body logging");
-
-  onSetPreferences = onSetPreferences.bind(null, aState);
-  aState.client.setPreferences({
-    "NetworkMonitor.saveRequestAndResponseBodies": true,
-  }, onSetPreferences);
-}
-
-function onSetPreferences(aState, aResponse)
-{
-  is(aResponse.updated.length, 1, "updated prefs length");
-  is(aResponse.updated[0], "NetworkMonitor.saveRequestAndResponseBodies",
-     "updated prefs length");
-
   info("test network POST request");
 
   onNetworkEvent = onNetworkEvent.bind(null, aState);
   aState.dbgClient.addListener("networkEvent", onNetworkEvent);
   onNetworkEventUpdate = onNetworkEventUpdate.bind(null, aState);
   aState.dbgClient.addListener("networkEventUpdate", onNetworkEventUpdate);
 
   let iframe = document.querySelector("iframe").contentWindow;
