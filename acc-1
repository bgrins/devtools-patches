# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b2919970d120b33932ab3a28eb63bac865c3956e

diff --git a/accessible/xul/XULComboboxAccessible.cpp b/accessible/xul/XULComboboxAccessible.cpp
--- a/accessible/xul/XULComboboxAccessible.cpp
+++ b/accessible/xul/XULComboboxAccessible.cpp
@@ -30,22 +30,22 @@ XULComboboxAccessible::
                                          nsGkAtoms::autocomplete, eIgnoreCase))
     mGenericTypes |= eAutoComplete;
   else
     mGenericTypes |= eCombobox;
 
   // Both the XUL <textbox type="autocomplete"> and <menulist editable="true">
   // widgets use XULComboboxAccessible. We need to walk the anonymous children
   // for these so that the entry field is a child. Otherwise no XBL children.
-  if (!mContent->NodeInfo()->Equals(nsGkAtoms::textbox, kNameSpaceID_XUL) &&
-      !mContent->AsElement()->AttrValueIs(kNameSpaceID_None,
-                                          nsGkAtoms::editable, nsGkAtoms::_true,
-                                          eIgnoreCase)) {
-    mStateFlags |= eNoXBLKids;
-  }
+  // if (!mContent->NodeInfo()->Equals(nsGkAtoms::textbox, kNameSpaceID_XUL) &&
+  //     !mContent->AsElement()->AttrValueIs(kNameSpaceID_None,
+  //                                         nsGkAtoms::editable, nsGkAtoms::_true,
+  //                                         eIgnoreCase)) {
+  //   mStateFlags |= eNoXBLKids;
+  // }
 }
 
 role
 XULComboboxAccessible::NativeRole() const
 {
   return IsAutoComplete() ? roles::AUTOCOMPLETE : roles::COMBOBOX;
 }
 
