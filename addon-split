# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  9f72d12f7e3489df69960e5d8ab9d610c7d08be4
Subclass addon custom element

diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -1,16 +1,158 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // This file is loaded into the browser window scope.
 /* eslint-env mozilla/browser-window */
 
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+ChromeUtils.import("resource://gre/modules/DownloadUtils.jsm");
+
+class MozAddonProgressNotification extends MozElements.PopupNotification {
+  slotContents() {
+    let firstTime = !this._hasSlotted;
+    console.log("HAS SLOTTED", this, firstTime, this.notification);
+    super.slotContents();
+      this.progressmeter = document.getElementById("addon-progress-notification-progressmeter");
+      this.progresstext = document.getElementById("addon-progress-notification-progresstext");
+      if (!this.notification)
+        return;
+
+      this.notification.options.installs.forEach(function(aInstall) {
+        aInstall.addListener(this);
+      }, this);
+
+      // Calling updateProgress can sometimes cause this notification to be
+      // removed in the middle of refreshing the notification panel which
+      // makes the panel get refreshed again. Just initialise to the
+      // undetermined state and then schedule a proper check at the next
+      // opportunity
+      this.setProgress(0, -1);
+      this._updateProgressTimeout = setTimeout(this.updateProgress.bind(this), 0);
+  }
+
+  destroy() {
+    if (!this.notification)
+      return;
+
+    this.notification.options.installs.forEach(function(aInstall) {
+      aInstall.removeListener(this);
+    }, this);
+    clearTimeout(this._updateProgressTimeout);
+  }
+
+  setProgress(aProgress, aMaxProgress) {
+    if (aMaxProgress == -1) {
+      this.progressmeter.removeAttribute("value");
+    } else {
+      this.progressmeter.setAttribute("value", (aProgress * 100) / aMaxProgress);
+    }
+
+    let now = Date.now();
+
+    if (!this.notification.lastUpdate) {
+      this.notification.lastUpdate = now;
+      this.notification.lastProgress = aProgress;
+      return;
+    }
+
+    let delta = now - this.notification.lastUpdate;
+    if ((delta < 400) && (aProgress < aMaxProgress))
+      return;
+
+    delta /= 1000;
+
+    // This algorithm is the same used by the downloads code.
+    let speed = (aProgress - this.notification.lastProgress) / delta;
+    if (this.notification.speed)
+      speed = speed * 0.9 + this.notification.speed * 0.1;
+
+    this.notification.lastUpdate = now;
+    this.notification.lastProgress = aProgress;
+    this.notification.speed = speed;
+
+    let status = null;
+    [status, this.notification.last] = DownloadUtils.getDownloadStatus(aProgress, aMaxProgress, speed, this.notification.last);
+    this.progresstext.setAttribute("value", status);
+    this.progresstext.setAttribute("tooltiptext", status);
+  }
+
+  cancel() {
+    console.log("CALLED CANCEL", this);
+    let installs = this.notification.options.installs;
+    installs.forEach(function(aInstall) {
+      try {
+        aInstall.cancel();
+      } catch (e) {
+        // Cancel will throw if the download has already failed
+      }
+    }, this);
+
+    PopupNotifications.remove(this.notification);
+  }
+
+  updateProgress() {
+    if (!this.notification)
+      return;
+
+    let downloadingCount = 0;
+    let progress = 0;
+    let maxProgress = 0;
+
+    this.notification.options.installs.forEach(function(aInstall) {
+      if (aInstall.maxProgress == -1)
+        maxProgress = -1;
+      progress += aInstall.progress;
+      if (maxProgress >= 0)
+        maxProgress += aInstall.maxProgress;
+      if (aInstall.state < AddonManager.STATE_DOWNLOADED)
+        downloadingCount++;
+    });
+
+    if (downloadingCount == 0) {
+      this.destroy();
+      this.progressmeter.removeAttribute("value");
+      let status = gNavigatorBundle.getString("addonDownloadVerifying");
+      this.progresstext.setAttribute("value", status);
+      this.progresstext.setAttribute("tooltiptext", status);
+    } else {
+      this.setProgress(progress, maxProgress);
+    }
+  }
+
+  onDownloadProgress() {
+    this.updateProgress();
+  }
+
+  onDownloadFailed() {
+    this.updateProgress();
+  }
+
+  onDownloadCancelled() {
+    this.updateProgress();
+  }
+
+  onDownloadEnded() {
+    this.updateProgress();
+  }
+  disconnectedCallback() {
+    this.destroy();
+  }
+}
+
+customElements.define("addon-progress-notification", MozAddonProgressNotification);
+
 // Removes a doorhanger notification if all of the installs it was notifying
 // about have ended in some way.
 function removeNotificationOnEnd(notification, installs) {
   let count = installs.length;
 
   function maybeRemove(install) {
     install.removeListener(this);
 
diff --git a/browser/base/content/popup-notifications.inc b/browser/base/content/popup-notifications.inc
--- a/browser/base/content/popup-notifications.inc
+++ b/browser/base/content/popup-notifications.inc
@@ -56,17 +56,17 @@
       <popupnotificationcontent orient="vertical">
         <textbox id="password-notification-username"/>
         <textbox id="password-notification-password" type="password" show-content=""/>
         <checkbox id="password-notification-visibilityToggle" hidden="true"/>
       </popupnotificationcontent>
     </popupnotification>
 
 
-    <popupnotification id="addon-progress-notification" hidden="true">
+    <popupnotification id="addon-progress-notification" is="addon-progress-notification" hidden="true">
       <popupnotificationcontent orient="vertical">
         <html:progress id="addon-progress-notification-progressmeter" max="100"/>
         <label id="addon-progress-notification-progresstext" crop="end"/>
       </popupnotificationcontent>
     </popupnotification>
 
     <popupnotification id="addon-install-confirmation-notification" hidden="true">
       <popupnotificationcontent id="addon-install-confirmation-content" orient="vertical"/>
diff --git a/toolkit/content/widgets/popupnotification.js b/toolkit/content/widgets/popupnotification.js
--- a/toolkit/content/widgets/popupnotification.js
+++ b/toolkit/content/widgets/popupnotification.js
@@ -1,22 +1,18 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-// This is loaded into all XUL windows. Wrap in a block to prevent
-// leaking to window scope.
-{
+// This is loaded into chrome windows with the subscript loader. If you need to
+// define globals, wrap in a block to prevent leaking onto `window`.
 
-ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
-
-class MozPopupNotification extends MozXULElement {
-
+MozElements.PopupNotification = class PopupNotification extends MozXULElement {
   static get observedAttributes() {
     return [
       "buttonaccesskey",
       "buttoncommand",
       "buttonhighlight",
       "buttonlabel",
       "checkboxchecked",
       "checkboxcommand",
@@ -62,16 +58,17 @@ class MozPopupNotification extends MozXU
       for (let attr of el.getAttribute("inherits").split(",")) {
         this.inheritAttribute(el, attr);
       }
     }
   }
 
   constructor() {
     super();
+    ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
     XPCOMUtils.defineLazyGetter(this, "button", () => {
       this.slotContents();
       return this.querySelector("[anonid=button]");
     });
     XPCOMUtils.defineLazyGetter(this, "secondarybutton", () => {
       this.slotContents();
       return this.querySelector("[anonid=secondarybutton]");
     });
@@ -159,13 +156,11 @@ class MozPopupNotification extends MozXU
       this.querySelector("children[includes='button']").replaceWith(button);
     }
     if (menuitems) {
       this.querySelector("children[includes='menuitem']").replaceWith(...menuitems);
     }
 
     this.inheritAttributes();
   }
-}
+};
 
-customElements.define("popupnotification", MozPopupNotification);
-
-}
+customElements.define("popupnotification", MozElements.PopupNotification);
diff --git a/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js b/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
--- a/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
+++ b/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
@@ -513,17 +513,17 @@ async function test_cancel() {
   anchor.click();
   // Reopen the notification
   anchor.click();
 
   ok(PopupNotifications.isPanelOpen, "Notification should still be open");
   is(PopupNotifications.panel.childNodes.length, 1, "Should be only one notification");
   notification = panel.childNodes[0];
   is(notification.id, "addon-progress-notification", "Should have seen the progress notification");
-
+await new Promise(r=>r);
   // Cancel the download
   let install = notification.notification.options.installs[0];
   let cancelledPromise = new Promise(resolve => {
     install.addListener({
       onDownloadCancelled() {
         install.removeListener(this);
         resolve();
       },
