# HG changeset patch
# Parent 2f64e0245f050ea3318dde54158cbd226f30f5fd
# User Brian Grinstead <bgrinstead@mozilla.com>
extra debugging

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -994,16 +994,17 @@ MarkupView.prototype = {
     let expand = options && options.expand;
     let flash = options && options.flash;
 
     aContainer.hasChildren = aContainer.node.hasChildren;
 
     if (!this._queuedChildUpdates) {
       this._queuedChildUpdates = new Map();
     }
+    console.log("Any _queuedChildUpdates?", this._queuedChildUpdates.has(aContainer))
 
     if (this._queuedChildUpdates.has(aContainer)) {
       return this._queuedChildUpdates.get(aContainer);
     }
 
     if (!aContainer.childrenDirty) {
       return promise.resolve(aContainer);
     }
@@ -1035,19 +1036,21 @@ MarkupView.prototype = {
       if (!this._containers) {
         return promise.reject("markup view destroyed");
       }
       this._queuedChildUpdates.delete(aContainer);
 
       // If children are dirty, we got a change notification for this node
       // while the request was in progress, we need to do it again.
       if (aContainer.childrenDirty) {
+        console.log("Found a weird case");
         return this._updateChildren(aContainer, {expand: centered});
       }
 
+        console.log("Proceeding and rebuilding", children.nodes);
       let fragment = this.doc.createDocumentFragment();
 
       for (let child of children.nodes) {
         let container = this.importNode(child, flash);
         fragment.appendChild(container.elt);
       }
 
       while (aContainer.children.firstChild) {
diff --git a/content/base/src/nsDOMMutationObserver.cpp b/content/base/src/nsDOMMutationObserver.cpp
--- a/content/base/src/nsDOMMutationObserver.cpp
+++ b/content/base/src/nsDOMMutationObserver.cpp
@@ -165,16 +165,17 @@ nsMutationReceiver::CharacterDataWillCha
 void
 nsMutationReceiver::ContentAppended(nsIDocument* aDocument,
                                     nsIContent* aContainer,
                                     nsIContent* aFirstNewContent,
                                     int32_t aNewIndexInContainer)
 {
   nsINode* parent = NODE_FROM(aContainer, aDocument);
   bool wantsChildList = ChildList() && (Subtree() || parent == Target());
+  printf("Hello there2 %d\n", wantsChildList);
   if (!wantsChildList || aFirstNewContent->ChromeOnlyAccess()) {
     return;
   }
 
   if (nsAutoMutationBatch::IsBatching()) {
     if (parent == nsAutoMutationBatch::GetBatchTarget()) {
       nsAutoMutationBatch::UpdateObserver(Observer(), wantsChildList);
     }
@@ -203,16 +204,19 @@ nsMutationReceiver::ContentAppended(nsID
 void
 nsMutationReceiver::ContentInserted(nsIDocument* aDocument,
                                     nsIContent* aContainer,
                                     nsIContent* aChild,
                                     int32_t aIndexInContainer)
 {
   nsINode* parent = NODE_FROM(aContainer, aDocument);
   bool wantsChildList = ChildList() && (Subtree() || parent == Target());
+  nsAutoString tag;
+  parent->Tag()->ToString(tag);
+  printf("Hello there3 %s\n", NS_LossyConvertUTF16toASCII(tag).get());
   if (!wantsChildList || aChild->ChromeOnlyAccess()) {
     return;
   }
 
   if (nsAutoMutationBatch::IsBatching()) {
     if (parent == nsAutoMutationBatch::GetBatchTarget()) {
       nsAutoMutationBatch::UpdateObserver(Observer(), wantsChildList);
     }
@@ -234,16 +238,17 @@ nsMutationReceiver::ContentInserted(nsID
 
 void
 nsMutationReceiver::ContentRemoved(nsIDocument* aDocument,
                                    nsIContent* aContainer,
                                    nsIContent* aChild,
                                    int32_t aIndexInContainer,
                                    nsIContent* aPreviousSibling)
 {
+  printf("Hello there1 %d", aChild->ChromeOnlyAccess());
   if (aChild->ChromeOnlyAccess()) {
     return;
   }
 
   nsINode* parent = NODE_FROM(aContainer, aDocument);
   if (nsAutoMutationBatch::IsBatching()) {
     if (nsAutoMutationBatch::IsRemovalDone()) {
       // This can happen for example if HTML parser parses to
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -928,22 +928,22 @@ var WalkerActor = protocol.ActorClass({
     // list contains orphaned nodes that were so retained.
     this._retainedOrphans = new Set();
 
     this.onMutations = this.onMutations.bind(this);
     this.onFrameLoad = this.onFrameLoad.bind(this);
     this.onFrameUnload = this.onFrameUnload.bind(this);
     this.onAnyStyleSheetChange = this.onAnyStyleSheetChange.bind(this);
 
-    this.tabActor.browser.addEventListener("StyleSheetRemoved", this.onAnyStyleSheetChange, false);
-    this.tabActor.browser.addEventListener("StyleSheetAdded", this.onAnyStyleSheetChange, false);
-    this.tabActor.browser.addEventListener("StyleRuleRemoved", this.onAnyStyleSheetChange, false);
-    this.tabActor.browser.addEventListener("StyleRuleAdded", this.onAnyStyleSheetChange, false);
-    this.tabActor.browser.addEventListener("StyleRuleChanged", this.onAnyStyleSheetChange, false);
-    this.tabActor.browser.addEventListener("StyleSheetApplicableStateChanged", this.onAnyStyleSheetChange, false);
+    this.tabActor.browser.addEventListener("StyleSheetRemoved", this.onAnyStyleSheetChange, true);
+    this.tabActor.browser.addEventListener("StyleSheetAdded", this.onAnyStyleSheetChange, true);
+    this.tabActor.browser.addEventListener("StyleRuleRemoved", this.onAnyStyleSheetChange, true);
+    this.tabActor.browser.addEventListener("StyleRuleAdded", this.onAnyStyleSheetChange, true);
+    this.tabActor.browser.addEventListener("StyleRuleChanged", this.onAnyStyleSheetChange, true);
+    this.tabActor.browser.addEventListener("StyleSheetApplicableStateChanged", this.onAnyStyleSheetChange, true);
 
     // StyleSheetApplicableStateChanged
 
     events.on(tabActor, "will-navigate", this.onFrameUnload);
     events.on(tabActor, "navigate", this.onFrameLoad);
 
     // Ensure that the root document node actor is ready and
     // managed.
@@ -953,17 +953,17 @@ var WalkerActor = protocol.ActorClass({
     this._onReflows = this._onReflows.bind(this);
     this.reflowObserver.on("reflows", this._onReflows);
   },
 
   // Handle any style change event to repopulate children that may
   // have matched pseudo elements
   onAnyStyleSheetChange: function(e) {
     let {rule, stylesheet, target} = e;
-    console.log("onAnyStyleSheetChange", e);
+    console.log("onAnyStyleSheetChange", e, stylesheet ? stylesheet.cssRules.length : null);
     if (rule) {
       this.notifyRuleChange(rule, target);
     } else {
       [...stylesheet.cssRules].forEach((rule) => {
         this.notifyRuleChange(rule, target);
       })
     }
   },
@@ -981,16 +981,17 @@ var WalkerActor = protocol.ActorClass({
                                             .replace(/::after/g, '')
                                             .replace(/:after/g, '');
       console.log("Searching for ", selectorText, "Found " + document.querySelectorAll(selectorText).length + " nodes.");
       // XXX: escape the selector.
       // XXX: Only need to qSA on the relevant portions of the selector
       // So for `h1::before, div { }` we don't care about the div
       [...document.querySelectorAll(selectorText)].forEach((node) => {
         if (this._refMap.has(node)) {
+          console.log(documentWalker(node, document.defaultView).firstChild());
           this.queueMutation({
             type: "childList",
             target: this._refMap.get(node).actorID,
             added: [],
             removed: [],
             numChildren: this._refMap.get(node).numChildren
           });
         }
