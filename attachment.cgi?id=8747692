# HG changeset patch
# Parent  6b8ff7012009f272e84281a1643415f0d6b146ff
Bug 1259812: Replace XUL elements with XHTML in inspector breadcrumbs;r=bgrins

diff --git a/devtools/client/inspector/breadcrumbs.js b/devtools/client/inspector/breadcrumbs.js
--- a/devtools/client/inspector/breadcrumbs.js
+++ b/devtools/client/inspector/breadcrumbs.js
@@ -8,37 +8,237 @@
 
 const {Cu, Ci} = require("chrome");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 const Services = require("Services");
 const promise = require("promise");
 const FocusManager = Services.focus;
 const {waitForTick} = require("devtools/shared/DevToolsUtils");
 
-const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 const MAX_LABEL_LENGTH = 40;
 const LOW_PRIORITY_ELEMENTS = {
   "HEAD": true,
   "BASE": true,
   "BASEFONT": true,
   "ISINDEX": true,
   "LINK": true,
   "META": true,
   "SCRIPT": true,
   "STYLE": true,
   "TITLE": true
 };
 
+const NS_XHTML = "http://www.w3.org/1999/xhtml";
+const SCROLL_REPEAT_MS = 100;
+
+/**
+ * Component to replicate functionality of XUL arrowscrollbox
+ * for breadcrumbs
+ */
+function ArrowScrollBox(chromeWin, chromeDoc, container) {
+  this.chromeWin = chromeWin;
+  this.chromeDoc = chromeDoc;
+  this.container = container;
+  this._init();
+}
+
+ArrowScrollBox.prototype = {
+
+  /**
+   * Build the HTML, add to the DOM and start listening to
+   * events
+   */
+  _init: function() {
+    this.constructHtml();
+
+    this.onunderflow();
+
+    this.inner.addEventListener("scroll", this.onscroll.bind(this), false);
+    this.inner.addEventListener("underflow", this.onunderflow.bind(this), false);
+    this.inner.addEventListener("overflow", this.onoverflow.bind(this), false);
+    this.leftBtn.addEventListener("mousedown", this.leftBtnClick.bind(this), false);
+    this.rightBtn.addEventListener("mousedown", this.rightBtnClick.bind(this), false);
+  },
+
+  /**
+   * Call the given function once; then continuously
+   * while the mouse button is held
+   * @param {repeatFn} the function to repeat while the button is held
+   */
+  clickOrHold: function(repeatFn) {
+    repeatFn = repeatFn.bind(this);
+
+    let timer;
+    let container = this.container;
+
+    function handleClick() {
+      cancelHold();
+      repeatFn();
+    }
+
+    let window = this.chromeWin;
+    function cancelHold() {
+      window.clearTimeout(timer)
+      container.removeEventListener("mouseout", cancelHold, false);
+      container.removeEventListener("mouseup", handleClick, false);
+    };
+
+    function repeated() {
+      repeatFn();
+      timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
+    };
+
+    container.addEventListener("mouseout", cancelHold, false);
+    container.addEventListener("mouseup", handleClick, false);
+    timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
+  },
+
+  /**
+   * When left arrow button is clicked scroll left
+   */
+  leftBtnClick: function() {
+    let scrollLeft = function() {
+      let element = this.getFirstInvisibleElement();
+      if (element === null) {
+        return;
+      }
+
+      element.scrollIntoView({ block: "start", behavior: "smooth" });
+    };
+
+    this.clickOrHold(scrollLeft);
+  },
+
+  /**
+   * When right arrow button is clicked scroll right
+   */
+  rightBtnClick: function() {
+    let scrollRight = function() {
+      let element = this.getLastInvisibleElement();
+      if (element == null) {
+        return;
+      }
+
+      element.scrollIntoView({ block: "end", behavior: "smooth" });
+    };
+
+    this.clickOrHold(scrollRight);
+  },
+
+  /**
+   * Event handler for scrolling, update the
+   * enabled/disabled status of the arrow buttons
+   */
+  onscroll: function() {
+    let first = this.getFirstInvisibleElement();
+    if (first === null) {
+      this.leftBtn.setAttribute("disabled", "true");
+    } else {
+      this.leftBtn.removeAttribute("disabled");
+    }
+ 
+    let last = this.getLastInvisibleElement();
+    if (last === null) {
+      this.rightBtn.setAttribute("disabled", "true");
+    } else {
+      this.rightBtn.removeAttribute("disabled");
+    }
+  },
+
+  /**
+   * On underflow, make the arrow buttons invisible
+   */
+  onunderflow: function() {
+    this.leftBtn.style.visibility = "collapse";
+    this.rightBtn.style.visibility = "collapse";
+  },
+
+  /**
+   * On overflow, show the arrow buttons
+   */
+  onoverflow: function() {
+    this.leftBtn.style.visibility = "visible";
+    this.rightBtn.style.visibility = "visible";
+  },
+
+  /**
+   * Get the first (i.e. furthest left)
+   * non visible element in the scroll box
+   */
+  getFirstInvisibleElement: function() {
+    let left = this.inner.scrollLeft;
+    for (let element of this.inner.childNodes) {
+      if (element.offsetLeft > left) {
+        return element.previousSibling;
+      }
+    }
+
+    return null;
+  },
+
+  /**
+   * Get the last (i.e. furthest right) 
+   * non-visible element in the scroll box
+   */
+  getLastInvisibleElement: function() {
+    let right = this.inner.scrollLeft + this.inner.clientWidth;
+    let elementLeft = 0;
+    for (let element of this.inner.childNodes) {
+      let elementRight = elementLeft + element.offsetWidth;
+      elementLeft = elementRight;
+      if (elementRight > right) {
+        return element;
+      }
+    }
+
+    return null;
+  },
+
+  /**
+   * Build the HTML for the scroll box and insert it into the DOM
+   */
+  constructHtml: function() {
+    this.leftBtn = this.createElement("div", "scrollbutton-up");
+    let leftBtnIcon = this.createElement("div", "toolbarbutton-icon");
+    this.leftBtn.appendChild(leftBtnIcon);
+    this.container.appendChild(this.leftBtn);
+
+    let startIndicator = this.createElement("div", "arrowscrollbox-overflow-start-indicator");
+    this.container.appendChild(startIndicator);
+
+    this.inner = this.createElement("div", "html-arrowscrollbox-inner");
+    this.container.appendChild(this.inner);
+
+    let endIndicator = this.createElement("div", "arrowscrollbox-overflow-end-indicator");
+    this.container.appendChild(endIndicator);
+
+    this.rightBtn = this.createElement("div", "scrollbutton-down");
+    let rightBtnIcon = this.createElement("div", "toolbarbutton-icon");
+    this.rightBtn.appendChild(rightBtnIcon);
+    this.container.appendChild(this.rightBtn);
+  },
+
+  /**
+   * Create an XHTML element with the given class name
+   * @param {tagName} name of the tag to create
+   * @param {className} class of the element
+   */
+  createElement : function(tagName, className) {
+    let div = this.chromeDoc.createElementNS(NS_XHTML, tagName);
+    div.className = className;
+    return div;
+  },
+};
+
+
 /**
  * Display the ancestors of the current node and its children.
  * Only one "branch" of children are displayed (only one line).
  *
- * FIXME: Bug 822388 - Use the BreadcrumbsWidget in the Inspector.
- *
  * Mechanism:
  * - If no nodes displayed yet:
  *   then display the ancestor of the selected node and the selected node;
  *   else select the node;
  * - If the selected node is the last node displayed, append its first (if any).
  *
  * @param {InspectorPanel} inspector The inspector hosting this widget.
  */
@@ -53,57 +253,43 @@ function HTMLBreadcrumbs(inspector) {
 exports.HTMLBreadcrumbs = HTMLBreadcrumbs;
 
 HTMLBreadcrumbs.prototype = {
   get walker() {
     return this.inspector.walker;
   },
 
   _init: function() {
-    this.container = this.chromeDoc.getElementById("inspector-breadcrumbs");
+    let outer = this.chromeDoc.getElementById("inspector-breadcrumbs");
+    this.arrowScrollBox = new ArrowScrollBox(this.chromeWin, this.chromeDoc, outer);
 
+    this.container = this.arrowScrollBox.inner;
+ 
     // These separators are used for CSS purposes only, and are positioned
     // off screen, but displayed with -moz-element.
-    this.separators = this.chromeDoc.createElement("box");
+    this.separators = this.chromeDoc.createElementNS(NS_XHTML, "div");
     this.separators.className = "breadcrumb-separator-container";
     this.separators.innerHTML =
-                      "<box id='breadcrumb-separator-before'></box>" +
-                      "<box id='breadcrumb-separator-after'></box>" +
-                      "<box id='breadcrumb-separator-normal'></box>";
+                      "<div id='breadcrumb-separator-before'></div>" +
+                      "<div id='breadcrumb-separator-after'></div>" +
+                      "<div id='breadcrumb-separator-normal'></div>";
     this.container.parentNode.appendChild(this.separators);
 
-    this.container.addEventListener("mousedown", this, true);
+    this.container.addEventListener("click", this, true);
     this.container.addEventListener("keypress", this, true);
     this.container.addEventListener("mouseover", this, true);
     this.container.addEventListener("mouseleave", this, true);
     this.container.addEventListener("focus", this, true);
 
     // We will save a list of already displayed nodes in this array.
     this.nodeHierarchy = [];
 
     // Last selected node in nodeHierarchy.
     this.currentIndex = -1;
 
-    // By default, hide the arrows. We let the <scrollbox> show them
-    // in case of overflow.
-    this.container.removeAttribute("overflows");
-    this.container._scrollButtonUp.collapsed = true;
-    this.container._scrollButtonDown.collapsed = true;
-
-    this.onscrollboxreflow = () => {
-      if (this.container._scrollButtonDown.collapsed) {
-        this.container.removeAttribute("overflows");
-      } else {
-        this.container.setAttribute("overflows", true);
-      }
-    };
-
-    this.container.addEventListener("underflow", this.onscrollboxreflow, false);
-    this.container.addEventListener("overflow", this.onscrollboxreflow, false);
-
     this.update = this.update.bind(this);
     this.updateSelectors = this.updateSelectors.bind(this);
     this.selection.on("new-node-front", this.update);
     this.selection.on("pseudoclass", this.updateSelectors);
     this.selection.on("attribute-changed", this.updateSelectors);
     this.inspector.on("markupmutation", this.update);
     this.update();
   },
@@ -168,29 +354,27 @@ HTMLBreadcrumbs.prototype = {
   /**
    * Build <label>s that represent the node:
    *   <label class="breadcrumbs-widget-item-tag">tagName</label>
    *   <label class="breadcrumbs-widget-item-id">#id</label>
    *   <label class="breadcrumbs-widget-item-classes">.class1.class2</label>
    * @param {NodeFront} node The node to pretty-print
    * @returns {DocumentFragment}
    */
-  prettyPrintNodeAsXUL: function(node) {
-    let fragment = this.chromeDoc.createDocumentFragment();
-
-    let tagLabel = this.chromeDoc.createElement("label");
+  prettyPrintNodeAsXHTML: function(node) {
+    let tagLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     tagLabel.className = "breadcrumbs-widget-item-tag plain";
 
-    let idLabel = this.chromeDoc.createElement("label");
+    let idLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     idLabel.className = "breadcrumbs-widget-item-id plain";
 
-    let classesLabel = this.chromeDoc.createElement("label");
+    let classesLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     classesLabel.className = "breadcrumbs-widget-item-classes plain";
 
-    let pseudosLabel = this.chromeDoc.createElement("label");
+    let pseudosLabel = this.chromeDoc.createElementNS(NS_XHTML, "label");
     pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";
 
     let tagText = node.tagName.toLowerCase();
     if (node.isPseudoElement) {
       tagText = node.isBeforePseudoElement ? "::before" : "::after";
     }
     let idText = node.id ? ("#" + node.id) : "";
     let classesText = "";
@@ -219,80 +403,32 @@ HTMLBreadcrumbs.prototype = {
       classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
     }
 
     tagLabel.textContent = tagText;
     idLabel.textContent = idText;
     classesLabel.textContent = classesText;
     pseudosLabel.textContent = node.pseudoClassLocks.join("");
 
+    let fragment = this.chromeDoc.createDocumentFragment();
     fragment.appendChild(tagLabel);
     fragment.appendChild(idLabel);
     fragment.appendChild(classesLabel);
     fragment.appendChild(pseudosLabel);
 
     return fragment;
   },
 
   /**
-   * Open the sibling menu.
-   * @param {DOMNode} button the button representing the node.
-   * @param {NodeFront} node the node we want the siblings from.
-   */
-  openSiblingMenu: function(button, node) {
-    // We make sure that the targeted node is selected
-    // because we want to use the nodemenu that only works
-    // for inspector.selection
-    this.navigateTo(node);
-
-    // Build a list of extra menu items that will be appended at the end of the
-    // inspector node context menu.
-    let items = [this.chromeDoc.createElement("menuseparator")];
-
-    this.walker.siblings(node, {
-      whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-    }).then(siblings => {
-      let nodes = siblings.nodes;
-      for (let i = 0; i < nodes.length; i++) {
-        // Skip siblings of the documentElement node.
-        if (nodes[i].nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
-          continue;
-        }
-
-        let item = this.chromeDoc.createElement("menuitem");
-        if (nodes[i] === node) {
-          item.setAttribute("disabled", "true");
-          item.setAttribute("checked", "true");
-        }
-
-        item.setAttribute("type", "radio");
-        item.setAttribute("label", this.prettyPrintNodeAsText(nodes[i]));
-
-        let self = this;
-        item.onmouseup = (function(node) {
-          return function() {
-            self.navigateTo(node);
-          };
-        })(nodes[i]);
-
-        items.push(item);
-      }
-
-      // Append the items to the inspector node context menu and show the menu.
-      this.inspector.showNodeMenu(button, "before_start", items);
-    });
-  },
-
-  /**
    * Generic event handler.
    * @param {DOMEvent} event.
    */
   handleEvent: function(event) {
-    if (event.type == "mousedown" && event.button == 0) {
-      this.handleMouseDown(event);
+    if (event.type == "click" && event.button == 0) {
+      this.handleClick(event);
     } else if (event.type == "keypress" && this.selection.isElementNode()) {
       this.handleKeyPress(event);
     } else if (event.type == "mouseover") {
       this.handleMouseOver(event);
     } else if (event.type == "mouseleave") {
       this.handleMouseLeave(event);
     } else if (event.type == "focus") {
       this.handleFocus(event);
@@ -302,58 +438,37 @@ HTMLBreadcrumbs.prototype = {
   /**
    * Focus event handler. When breadcrumbs container gets focus, if there is an
    * already selected breadcrumb, move focus to it.
    * @param {DOMEvent} event.
    */
   handleFocus: function(event) {
     let control = this.container.querySelector(
       ".breadcrumbs-widget-item[checked]");
-    if (control && control !== event.target) {
+    if (!this.suspendFocus && control && control !== event.target) {
       // If we already have a selected breadcrumb and focus target is not it,
       // move focus to selected breadcrumb.
       event.preventDefault();
       control.focus();
     }
+    this.suspendFocus = false;
   },
 
   /**
-   * On click and hold, open the siblings menu.
+   * On click navigate to the correct node.
    * @param {DOMEvent} event.
    */
-  handleMouseDown: function(event) {
-    let timer;
-    let container = this.container;
-
-    function openMenu(event) {
-      cancelHold();
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsHold();
-      }
+  handleClick: function(event) {
+    // When clicking a button, suspend refocusing
+    // the trail on the currently active breadcrumb.
+    this.suspendFocus = true;
+    let target = event.originalTarget;
+    if (target.tagName == "button") {
+      target.onBreadcrumbsClick();
     }
-
-    function handleClick(event) {
-      cancelHold();
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsClick();
-      }
-    }
-
-    let window = this.chromeWin;
-    function cancelHold(event) {
-      window.clearTimeout(timer);
-      container.removeEventListener("mouseout", cancelHold, false);
-      container.removeEventListener("mouseup", handleClick, false);
-    }
-
-    container.addEventListener("mouseout", cancelHold, false);
-    container.addEventListener("mouseup", handleClick, false);
-    timer = window.setTimeout(openMenu, 500, event);
   },
 
   /**
    * On mouse over, highlight the corresponding content DOM Node.
    * @param {DOMEvent} event.
    */
   handleMouseOver: function(event) {
     let target = event.originalTarget;
@@ -434,28 +549,25 @@ HTMLBreadcrumbs.prototype = {
    * Remove nodes and clean up.
    */
   destroy: function() {
     this.selection.off("new-node-front", this.update);
     this.selection.off("pseudoclass", this.updateSelectors);
     this.selection.off("attribute-changed", this.updateSelectors);
     this.inspector.off("markupmutation", this.update);
 
-    this.container.removeEventListener("underflow", this.onscrollboxreflow, false);
-    this.container.removeEventListener("overflow", this.onscrollboxreflow, false);
-    this.container.removeEventListener("mousedown", this, true);
+    this.container.removeEventListener("click", this, true);
     this.container.removeEventListener("keypress", this, true);
     this.container.removeEventListener("mouseover", this, true);
     this.container.removeEventListener("mouseleave", this, true);
     this.container.removeEventListener("focus", this, true);
 
     this.empty();
     this.separators.remove();
 
-    this.onscrollboxreflow = null;
     this.container = null;
     this.separators = null;
     this.nodeHierarchy = null;
 
     this.isDestroyed = true;
   },
 
   /**
@@ -520,18 +632,18 @@ HTMLBreadcrumbs.prototype = {
   },
 
   /**
    * Build a button representing the node.
    * @param {NodeFront} node The node from the page.
    * @return {DOMNode} The <button> for this node.
    */
   buildButton: function(node) {
-    let button = this.chromeDoc.createElement("button");
-    button.appendChild(this.prettyPrintNodeAsXUL(node));
+    let button = this.chromeDoc.createElementNS(NS_XHTML, "button");
+    button.appendChild(this.prettyPrintNodeAsXHTML(node));
     button.className = "breadcrumbs-widget-item";
 
     button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(node));
 
     button.onkeypress = function onBreadcrumbsKeypress(e) {
       if (e.charCode == Ci.nsIDOMKeyEvent.DOM_VK_SPACE ||
           e.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
         button.click();
@@ -540,27 +652,17 @@ HTMLBreadcrumbs.prototype = {
 
     button.onBreadcrumbsClick = () => {
       this.navigateTo(node);
     };
 
     button.onBreadcrumbsHover = () => {
       this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
     };
-
-    button.onclick = (function _onBreadcrumbsRightClick(event) {
-      button.focus();
-      if (event.button == 2) {
-        this.openSiblingMenu(button, node);
-      }
-    }).bind(this);
-
-    button.onBreadcrumbsHold = (function _onBreadcrumbsHold() {
-      this.openSiblingMenu(button, node);
-    }).bind(this);
+    
     return button;
   },
 
   /**
    * Connecting the end of the breadcrumbs to a node.
    * @param {NodeFront} node The node to reach.
    */
   expand: function(node) {
@@ -664,26 +766,18 @@ HTMLBreadcrumbs.prototype = {
     return waitForTick().then(() => true);
   },
 
   /**
    * Ensure the selected node is visible.
    */
   scroll: function() {
     // FIXME bug 684352: make sure its immediate neighbors are visible too.
-
-    let scrollbox = this.container;
     let element = this.nodeHierarchy[this.currentIndex].button;
-
-    // Repeated calls to ensureElementIsVisible would interfere with each other
-    // and may sometimes result in incorrect scroll positions.
-    this.chromeWin.clearTimeout(this._ensureVisibleTimeout);
-    this._ensureVisibleTimeout = this.chromeWin.setTimeout(function() {
-      scrollbox.ensureElementIsVisible(element);
-    }, ENSURE_SELECTION_VISIBLE_DELAY);
+    element.scrollIntoView({ block: "end", behavior: "smooth" });
   },
 
   /**
    * Update all button outputs.
    */
   updateSelectors: function() {
     if (this.isDestroyed) {
       return;
@@ -697,17 +791,17 @@ HTMLBreadcrumbs.prototype = {
       if (currentPrettyPrintText === textOutput) {
         continue;
       }
 
       // Otherwise, update the whole markup for the button.
       while (button.hasChildNodes()) {
         button.firstChild.remove();
       }
-      button.appendChild(this.prettyPrintNodeAsXUL(node));
+      button.appendChild(this.prettyPrintNodeAsXHTML(node));
       button.setAttribute("tooltiptext", textOutput);
 
       this.nodeHierarchy[i].currentPrettyPrintText = textOutput;
     }
   },
 
   /**
    * Given a list of mutation changes (passed by the markupmutation event),
diff --git a/devtools/client/inspector/inspector.xul b/devtools/client/inspector/inspector.xul
--- a/devtools/client/inspector/inspector.xul
+++ b/devtools/client/inspector/inspector.xul
@@ -176,24 +176,19 @@
           class="devtools-searchinput"
           placeholder="&inspectorSearchHTML.label3;"/>
         <toolbarbutton id="inspector-pane-toggle"
           class="devtools-toolbarbutton"
           tabindex="0" />
       </toolbar>
       <vbox flex="1" id="markup-box">
       </vbox>
-      <toolbar id="inspector-breadcrumbs-toolbar"
-        class="devtools-toolbar"
-        nowindowdrag="true">
-        <arrowscrollbox id="inspector-breadcrumbs"
-          class="breadcrumbs-widget-container"
-          flex="1" orient="horizontal"
-          clicktoscroll="true"/>
-      </toolbar>
+      <html:div id="inspector-breadcrumbs-toolbar" class="devtools-toolbar">
+        <html:div id="inspector-breadcrumbs" class="breadcrumbs-widget-container"/>
+      </html:div>
     </vbox>
     <splitter class="devtools-side-splitter"/>
     <tabbox id="inspector-sidebar" handleCtrlTab="false" class="devtools-sidebar-tabs" hidden="true">
       <tabs>
         <tab id="sidebar-tab-ruleview"
              label="&ruleViewTitle;"
              crop="end"/>
         <tab id="sidebar-tab-computedview"
diff --git a/devtools/client/inspector/test/browser.ini b/devtools/client/inspector/test/browser.ini
--- a/devtools/client/inspector/test/browser.ini
+++ b/devtools/client/inspector/test/browser.ini
@@ -40,17 +40,16 @@ support-files =
 [browser_inspector_addNode_01.js]
 [browser_inspector_addNode_02.js]
 [browser_inspector_addNode_03.js]
 [browser_inspector_breadcrumbs.js]
 [browser_inspector_breadcrumbs_highlight_hover.js]
 [browser_inspector_breadcrumbs_keybinding.js]
 [browser_inspector_breadcrumbs_keyboard_trap.js]
 skip-if = os == "mac" # Full keyboard navigation on OSX only works if Full Keyboard Access setting is set to All Control in System Keyboard Preferences
-[browser_inspector_breadcrumbs_menu.js]
 [browser_inspector_breadcrumbs_mutations.js]
 [browser_inspector_delete-selected-node-01.js]
 [browser_inspector_delete-selected-node-02.js]
 [browser_inspector_delete-selected-node-03.js]
 [browser_inspector_destroy-after-navigation.js]
 [browser_inspector_destroy-before-ready.js]
 [browser_inspector_expand-collapse.js]
 [browser_inspector_gcli-inspect-command.js]
diff --git a/devtools/client/inspector/test/browser_inspector_breadcrumbs.js b/devtools/client/inspector/test/browser_inspector_breadcrumbs.js
--- a/devtools/client/inspector/test/browser_inspector_breadcrumbs.js
+++ b/devtools/client/inspector/test/browser_inspector_breadcrumbs.js
@@ -13,17 +13,18 @@ const NODES = [
   {selector: "#i21", result: "i2 i21 i211 i2111"},
   {selector: "#i22211", result: "i2 i22 i222 i2221 i22211"},
   {selector: "#i22", result: "i2 i22 i222 i2221 i22211"},
   {selector: "#i3", result: "i3 i31"},
 ];
 
 add_task(function*() {
   let { inspector } = yield openInspectorForURL(TEST_URI);
-  let container = inspector.panelDoc.getElementById("inspector-breadcrumbs");
+  let breadcrumbs = inspector.panelDoc.getElementById("inspector-breadcrumbs");
+  let container = breadcrumbs.getElementsByClassName("html-arrowscrollbox-inner").item(0);
 
   for (let node of NODES) {
     info("Testing node " + node.selector);
 
     info("Selecting node and waiting for breadcrumbs to update");
     let breadcrumbsUpdated = inspector.once("breadcrumbs-updated");
     yield selectNode(node.selector, inspector);
     yield breadcrumbsUpdated;
diff --git a/devtools/client/inspector/test/browser_inspector_breadcrumbs_keybinding.js b/devtools/client/inspector/test/browser_inspector_breadcrumbs_keybinding.js
--- a/devtools/client/inspector/test/browser_inspector_breadcrumbs_keybinding.js
+++ b/devtools/client/inspector/test/browser_inspector_breadcrumbs_keybinding.js
@@ -77,17 +77,17 @@ add_task(function*() {
 
   info("Selecting the test node");
   yield selectNode("#i2", inspector);
 
   info("Clicking on the corresponding breadcrumbs node to focus it");
   let container = inspector.panelDoc.getElementById("inspector-breadcrumbs");
 
   let button = container.querySelector("button[checked]");
-  button.click();
+  button.focus();
 
   let currentSelection = "#id2";
   for (let {desc, key, newSelection} of TEST_DATA) {
     info(desc);
 
     let onUpdated;
     if (newSelection !== currentSelection) {
       info("Expecting a new node to be selected");
diff --git a/devtools/client/inspector/test/browser_inspector_breadcrumbs_keyboard_trap.js b/devtools/client/inspector/test/browser_inspector_breadcrumbs_keyboard_trap.js
--- a/devtools/client/inspector/test/browser_inspector_breadcrumbs_keyboard_trap.js
+++ b/devtools/client/inspector/test/browser_inspector_breadcrumbs_keyboard_trap.js
@@ -51,16 +51,17 @@ add_task(function*() {
   yield selectNode("#i2", inspector);
 
   info("Clicking on the corresponding breadcrumbs node to focus it");
   let container = doc.getElementById("inspector-breadcrumbs");
 
   let button = container.querySelector("button[checked]");
   let onHighlight = toolbox.once("node-highlight");
   button.click();
+  button.focus();
   yield onHighlight;
 
   // Ensure a breadcrumb is focused.
   is(doc.activeElement, button, "Focus is on selected breadcrumb");
 
   for (let { desc, focused, key, options } of TEST_DATA) {
     info(desc);
 
diff --git a/devtools/client/inspector/test/browser_inspector_breadcrumbs_menu.js b/devtools/client/inspector/test/browser_inspector_breadcrumbs_menu.js
deleted file mode 100644
--- a/devtools/client/inspector/test/browser_inspector_breadcrumbs_menu.js
+++ /dev/null
@@ -1,51 +0,0 @@
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-// Test that the inspector node context menu appears when right-clicking on the
-// breadcrumbs nodes.
-
-const TEST_URI = URL_ROOT + "doc_inspector_breadcrumbs.html";
-
-add_task(function*() {
-  let {inspector} = yield openInspectorForURL(TEST_URI);
-  let container = inspector.panelDoc.getElementById("inspector-breadcrumbs");
-
-  info("Select a test node and try to right-click on the selected breadcrumb");
-  yield selectNode("#i1", inspector);
-  let button = container.querySelector("button[checked]");
-
-  let onMenuShown = once(inspector.nodemenu, "popupshown");
-  button.onclick({button: 2});
-  yield onMenuShown;
-
-  ok(true, "The context menu appeared on right-click");
-
-  info("Right-click on a non selected crumb (the body node)");
-  button = button.previousSibling;
-  onMenuShown = once(inspector.nodemenu, "popupshown");
-  let onInspectorUpdated = inspector.once("inspector-updated");
-  button.onclick({button: 2});
-
-  yield onMenuShown;
-  ok(true, "The context menu appeared on right-click");
-
-  yield onInspectorUpdated;
-  is(inspector.selection.nodeFront.tagName.toLowerCase(), "body",
-     "The body node was selected when right-clicking in the breadcrumbs");
-
-  info("Right-click on the html node");
-  button = button.previousSibling;
-  onMenuShown = once(inspector.nodemenu, "popupshown");
-  onInspectorUpdated = inspector.once("inspector-updated");
-  button.onclick({button: 2});
-
-  yield onMenuShown;
-  ok(true, "The context menu appeared on right-click");
-
-  yield onInspectorUpdated;
-  is(inspector.selection.nodeFront.tagName.toLowerCase(), "html",
-     "The html node was selected when right-clicking in the breadcrumbs");
-});
diff --git a/devtools/client/inspector/test/browser_inspector_breadcrumbs_mutations.js b/devtools/client/inspector/test/browser_inspector_breadcrumbs_mutations.js
--- a/devtools/client/inspector/test/browser_inspector_breadcrumbs_mutations.js
+++ b/devtools/client/inspector/test/browser_inspector_breadcrumbs_mutations.js
@@ -136,17 +136,18 @@ const TEST_DATA = [{
     }]);
   },
   shouldRefresh: true,
   output: ["html", "body#new-id.test-class-changed", "article#i1-changed"]
 }];
 
 add_task(function*() {
   let {inspector} = yield openInspectorForURL(TEST_URI);
-  let container = inspector.panelDoc.getElementById("inspector-breadcrumbs");
+  let breadcrumbs = inspector.panelDoc.getElementById("inspector-breadcrumbs");
+  let container = breadcrumbs.getElementsByClassName("html-arrowscrollbox-inner").item(0);
   let win = container.ownerDocument.defaultView;
 
   for (let {desc, setup, run, shouldRefresh, output} of TEST_DATA) {
     info("Running test case: " + desc);
 
     info("Listen to markupmutation events from the inspector to know when a " +
          "test case has completed");
     let onContentMutation = inspector.once("markupmutation");
diff --git a/devtools/client/themes/inspector.css b/devtools/client/themes/inspector.css
--- a/devtools/client/themes/inspector.css
+++ b/devtools/client/themes/inspector.css
@@ -6,16 +6,62 @@
 #inspector-searchlabel {
   overflow: hidden;
 }
 
 #inspector-breadcrumbs-toolbar {
   padding: 0px;
   border-bottom-width: 0px;
   border-top-width: 1px;
+  display: block;
+  position: relative;
+}
+
+#inspector-breadcrumbs-toolbar,
+#inspector-breadcrumbs-toolbar * {
+  /* From minimal-xul.css */
+  -moz-user-focus: ignore;
+  -moz-user-select: none;
+  box-sizing: border-box;
+}
+
+#inspector-breadcrumbs {
+  display: flex;
+
+  /* Break out of the XUL flexbox, so the splitter can still shrink the
+     markup view even if the contents of the breadcrumbs are wider than
+     the new width. */
+  position: absolute;
+  top: 0;
+  left: 0;
+  bottom: 0;
+  right: 0;
+}
+
+
+#inspector-breadcrumbs .scrollbutton-up,
+#inspector-breadcrumbs .scrollbutton-down {
+  flex: 0;
+  display: flex;
+  align-items: center;
+}
+
+#inspector-breadcrumbs .html-arrowscrollbox-inner {
+  flex: 1;
+  display: flex;
+  overflow: hidden;
+}
+
+#inspector-breadcrumbs .breadcrumbs-widget-item {
+  flex-shrink: 0;
+  white-space: nowrap;
+}
+
+#inspector-breadcrumbs .breadcrumbs-widget-item::-moz-focus-inner {
+  border: none;
 }
 
 /* Expand/collapse panel toolbar button */
 
 #inspector-pane-toggle {
   list-style-image: var(--theme-pane-collapse-image);
 }
 
