# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e7108e4315cca3df662c41c8d00ef28a91d4a7ec

diff --git a/browser/base/.babelrc b/browser/base/.babelrc
new file mode 100644
--- /dev/null
+++ b/browser/base/.babelrc
@@ -0,0 +1,3 @@
+{
+  "presets": ["es2015"]
+}
\ No newline at end of file
diff --git a/browser/base/content/TabBrowser.js.orig b/browser/base/content/TabBrowser.js.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/TabBrowser.js.orig
@@ -0,0 +1,6397 @@
+// TODO:
+// * This is in a js file for now to make it easier to setup (so it can access window globals),
+//   but perf should be better if this was in a JSM instead.
+// * Web contents shrinks down to 25px x 25px after navigating from the start page. Can't see why
+//   that is happening as far as the XUL/CSS goes.
+
+// STEPS TO BUILD:
+// Generate the class with `npm run elements` from https://github.com/bgrins/xbl-analysis
+// Remove customElements.define(...);
+// Replace document.getAnonymousElementByAttribute(this, ..) with document.getAnonymousElementByAttribute(this.container)
+// Add: /* eslint-disable complexity */ before `  addTab(`
+// Replace `window.getComputedStyle(this` with `window.getComputedStyle(this.container`
+
+class TabBrowser {
+  constructor(container) {
+    var start = performance.now();
+    this.container = container;
+
+    // Pass along any used DOM methods to the container node
+    this.addEventListener = this.container.addEventListener.bind(this.container);
+    this.removeEventListener = this.container.removeEventListener.bind(this.container);
+    this.dispatchEvent = this.container.dispatchEvent.bind(this.container);
+    this.getAttribute = this.container.getAttribute.bind(this.container);
+    this.hasAttribute = this.container.hasAttribute.bind(this.container);
+    this.setAttribute = this.container.setAttribute.bind(this.container);
+    this.removeAttribute = this.container.removeAttribute.bind(this.container);
+    this.appendChild = this.container.appendChild.bind(this.container);
+    this.ownerGlobal = this.container.ownerGlobal;
+    this.ownerDocument = this.container.ownerDocument;
+    this.namespaceURI = this.container.namespaceURI;
+    this.style = this.container.style;
+
+    this.initialBrowser = document.getAnonymousElementByAttribute(
+      this.container,
+      "anonid",
+      "initialBrowser"
+    );
+
+    // XXX: Unsure if this is needed and/or will work with classes
+    // this.QueryInterface = XPCOMUtils.generateQI([
+    //   Ci.nsIDOMEventListener,
+    //   Ci.nsIMessageListener,
+    //   Ci.nsIObserver,
+    // ]);
+
+    // For upgrading, replace below here:
+    Object.defineProperty(this, "tabContainer", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.tabContainer;
+        return (this.tabContainer = document.getElementById(
+          this.getAttribute("tabcontainer")
+        ));
+      }
+    });
+    Object.defineProperty(this, "tabs", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.tabs;
+        return (this.tabs = this.tabContainer.childNodes);
+      }
+    });
+    Object.defineProperty(this, "closingTabsEnum", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.closingTabsEnum;
+        return (this.closingTabsEnum = { ALL: 0, OTHER: 1, TO_END: 2 });
+      }
+    });
+    Object.defineProperty(this, "_visibleTabs", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._visibleTabs;
+        return (this._visibleTabs = null);
+      },
+      set(val) {
+        delete this._visibleTabs;
+        return (this._visibleTabs = val);
+      }
+    });
+    Object.defineProperty(this, "mURIFixup", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mURIFixup;
+        return (this.mURIFixup = Components.classes[
+          "@mozilla.org/docshell/urifixup;1"
+        ].getService(Components.interfaces.nsIURIFixup));
+      }
+    });
+    Object.defineProperty(this, "_unifiedComplete", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._unifiedComplete;
+        return (this._unifiedComplete = Components.classes[
+          "@mozilla.org/autocomplete/search;1?name=unifiedcomplete"
+        ].getService(Components.interfaces.mozIPlacesAutoComplete));
+      }
+    });
+    Object.defineProperty(this, "mTabBox", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mTabBox;
+        return (this.mTabBox = document.getAnonymousElementByAttribute(
+          this.container,
+          "anonid",
+          "tabbox"
+        ));
+      }
+    });
+    Object.defineProperty(this, "mPanelContainer", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mPanelContainer;
+        return (this.mPanelContainer = document.getAnonymousElementByAttribute(
+          this.container,
+          "anonid",
+          "panelcontainer"
+        ));
+      }
+    });
+    Object.defineProperty(this, "mStringBundle", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mStringBundle;
+        return (this.mStringBundle = document.getAnonymousElementByAttribute(
+          this.container,
+          "anonid",
+          "tbstringbundle"
+        ));
+      },
+      set(val) {
+        delete this.mStringBundle;
+        return (this.mStringBundle = val);
+      }
+    });
+    Object.defineProperty(this, "mCurrentTab", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mCurrentTab;
+        return (this.mCurrentTab = null);
+      },
+      set(val) {
+        delete this.mCurrentTab;
+        return (this.mCurrentTab = val);
+      }
+    });
+    Object.defineProperty(this, "_lastRelatedTabMap", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._lastRelatedTabMap;
+        return (this._lastRelatedTabMap = new WeakMap());
+      },
+      set(val) {
+        delete this._lastRelatedTabMap;
+        return (this._lastRelatedTabMap = val);
+      }
+    });
+    Object.defineProperty(this, "mCurrentBrowser", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mCurrentBrowser;
+        return (this.mCurrentBrowser = null);
+      },
+      set(val) {
+        delete this.mCurrentBrowser;
+        return (this.mCurrentBrowser = val);
+      }
+    });
+    Object.defineProperty(this, "mProgressListeners", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mProgressListeners;
+        return (this.mProgressListeners = []);
+      },
+      set(val) {
+        delete this.mProgressListeners;
+        return (this.mProgressListeners = val);
+      }
+    });
+    Object.defineProperty(this, "mTabsProgressListeners", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mTabsProgressListeners;
+        return (this.mTabsProgressListeners = []);
+      },
+      set(val) {
+        delete this.mTabsProgressListeners;
+        return (this.mTabsProgressListeners = val);
+      }
+    });
+    Object.defineProperty(this, "_tabListeners", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._tabListeners;
+        return (this._tabListeners = new Map());
+      },
+      set(val) {
+        delete this._tabListeners;
+        return (this._tabListeners = val);
+      }
+    });
+    Object.defineProperty(this, "_tabFilters", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._tabFilters;
+        return (this._tabFilters = new Map());
+      },
+      set(val) {
+        delete this._tabFilters;
+        return (this._tabFilters = val);
+      }
+    });
+    Object.defineProperty(this, "mIsBusy", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mIsBusy;
+        return (this.mIsBusy = false);
+      },
+      set(val) {
+        delete this.mIsBusy;
+        return (this.mIsBusy = val);
+      }
+    });
+    Object.defineProperty(this, "_outerWindowIDBrowserMap", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._outerWindowIDBrowserMap;
+        return (this._outerWindowIDBrowserMap = new Map());
+      },
+      set(val) {
+        delete this._outerWindowIDBrowserMap;
+        return (this._outerWindowIDBrowserMap = val);
+      }
+    });
+    Object.defineProperty(this, "arrowKeysShouldWrap", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.arrowKeysShouldWrap;
+        return (this.arrowKeysShouldWrap = AppConstants == "macosx");
+      }
+    });
+    Object.defineProperty(this, "_autoScrollPopup", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._autoScrollPopup;
+        return (this._autoScrollPopup = null);
+      },
+      set(val) {
+        delete this._autoScrollPopup;
+        return (this._autoScrollPopup = val);
+      }
+    });
+    Object.defineProperty(this, "_previewMode", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._previewMode;
+        return (this._previewMode = false);
+      },
+      set(val) {
+        delete this._previewMode;
+        return (this._previewMode = val);
+      }
+    });
+    Object.defineProperty(this, "_lastFindValue", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._lastFindValue;
+        return (this._lastFindValue = "");
+      },
+      set(val) {
+        delete this._lastFindValue;
+        return (this._lastFindValue = val);
+      }
+    });
+    Object.defineProperty(this, "_contentWaitingCount", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._contentWaitingCount;
+        return (this._contentWaitingCount = 0);
+      },
+      set(val) {
+        delete this._contentWaitingCount;
+        return (this._contentWaitingCount = val);
+      }
+    });
+    Object.defineProperty(this, "tabAnimationsInProgress", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.tabAnimationsInProgress;
+        return (this.tabAnimationsInProgress = 0);
+      },
+      set(val) {
+        delete this.tabAnimationsInProgress;
+        return (this.tabAnimationsInProgress = val);
+      }
+    });
+    Object.defineProperty(this, "_tabForBrowser", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._tabForBrowser;
+        return (this._tabForBrowser = new WeakMap());
+      }
+    });
+    Object.defineProperty(this, "serializationHelper", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.serializationHelper;
+        return (this.serializationHelper = Cc[
+          "@mozilla.org/network/serialization-helper;1"
+        ].getService(Ci.nsISerializationHelper));
+      },
+      set(val) {
+        delete this.serializationHelper;
+        return (this.serializationHelper = val);
+      }
+    });
+    Object.defineProperty(this, "mIconLoadingPrincipal", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this.mIconLoadingPrincipal;
+        return (this.mIconLoadingPrincipal = null);
+      },
+      set(val) {
+        delete this.mIconLoadingPrincipal;
+        return (this.mIconLoadingPrincipal = val);
+      }
+    });
+    Object.defineProperty(this, "_tabSwitchID", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._tabSwitchID;
+        return (this._tabSwitchID = null);
+      },
+      set(val) {
+        delete this._tabSwitchID;
+        return (this._tabSwitchID = val);
+      }
+    });
+    Object.defineProperty(this, "_preloadedBrowser", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._preloadedBrowser;
+        return (this._preloadedBrowser = null);
+      },
+      set(val) {
+        delete this._preloadedBrowser;
+        return (this._preloadedBrowser = val);
+      }
+    });
+    Object.defineProperty(this, "_browserBindingProperties", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._browserBindingProperties;
+        return (this._browserBindingProperties = [
+          "canGoBack",
+          "canGoForward",
+          "goBack",
+          "goForward",
+          "permitUnload",
+          "reload",
+          "reloadWithFlags",
+          "stop",
+          "loadURI",
+          "loadURIWithFlags",
+          "goHome",
+          "homePage",
+          "gotoIndex",
+          "currentURI",
+          "documentURI",
+          "preferences",
+          "imageDocument",
+          "isRemoteBrowser",
+          "messageManager",
+          "getTabBrowser",
+          "finder",
+          "fastFind",
+          "sessionHistory",
+          "contentTitle",
+          "characterSet",
+          "fullZoom",
+          "textZoom",
+          "webProgress",
+          "addProgressListener",
+          "removeProgressListener",
+          "audioPlaybackStarted",
+          "audioPlaybackStopped",
+          "pauseMedia",
+          "stopMedia",
+          "resumeMedia",
+          "mute",
+          "unmute",
+          "blockedPopups",
+          "lastURI",
+          "purgeSessionHistory",
+          "stopScroll",
+          "startScroll",
+          "userTypedValue",
+          "userTypedClear",
+          "mediaBlocked",
+          "didStartLoadSinceLastUserTyping"
+        ]);
+      },
+      set(val) {
+        delete this._browserBindingProperties;
+        return (this._browserBindingProperties = val);
+      }
+    });
+    Object.defineProperty(this, "_removingTabs", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._removingTabs;
+        return (this._removingTabs = []);
+      },
+      set(val) {
+        delete this._removingTabs;
+        return (this._removingTabs = val);
+      }
+    });
+    Object.defineProperty(this, "_windowIsClosing", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._windowIsClosing;
+        return (this._windowIsClosing = false);
+      },
+      set(val) {
+        delete this._windowIsClosing;
+        return (this._windowIsClosing = val);
+      }
+    });
+    Object.defineProperty(this, "browsers", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        // This defines a proxy which allows us to access browsers by
+        // index without actually creating a full array of browsers.
+        delete this.browsers;
+        return (this.browsers = new Proxy([], {
+          has: (target, name) => {
+            if (typeof name == "string" && Number.isInteger(parseInt(name))) {
+              return name in this.tabs;
+            }
+            return false;
+          },
+          get: (target, name) => {
+            if (name == "length") {
+              return this.tabs.length;
+            }
+            if (typeof name == "string" && Number.isInteger(parseInt(name))) {
+              if (!(name in this.tabs)) {
+                return undefined;
+              }
+              return this.tabs[name].linkedBrowser;
+            }
+            return target[name];
+          }
+        }));
+      }
+    });
+    Object.defineProperty(this, "_printPreviewBrowsers", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._printPreviewBrowsers;
+        return (this._printPreviewBrowsers = new Set());
+      },
+      set(val) {
+        delete this._printPreviewBrowsers;
+        return (this._printPreviewBrowsers = val);
+      }
+    });
+    Object.defineProperty(this, "_switcher", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._switcher;
+        return (this._switcher = null);
+      },
+      set(val) {
+        delete this._switcher;
+        return (this._switcher = val);
+      }
+    });
+    Object.defineProperty(this, "_tabMinWidthLimit", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._tabMinWidthLimit;
+        return (this._tabMinWidthLimit = 50);
+      },
+      set(val) {
+        delete this._tabMinWidthLimit;
+        return (this._tabMinWidthLimit = val);
+      }
+    });
+    Object.defineProperty(this, "_soundPlayingAttrRemovalTimer", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._soundPlayingAttrRemovalTimer;
+        return (this._soundPlayingAttrRemovalTimer = 0);
+      },
+      set(val) {
+        delete this._soundPlayingAttrRemovalTimer;
+        return (this._soundPlayingAttrRemovalTimer = val);
+      }
+    });
+    Object.defineProperty(this, "_hoverTabTimer", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._hoverTabTimer;
+        return (this._hoverTabTimer = null);
+      },
+      set(val) {
+        delete this._hoverTabTimer;
+        return (this._hoverTabTimer = val);
+      }
+    });
+
+    this.mCurrentBrowser = document.getAnonymousElementByAttribute(
+      this.container,
+      "anonid",
+      "initialBrowser"
+    );
+    this.mCurrentBrowser.permanentKey = {};
+
+    CustomizableUI.addListener(this);
+    this._updateNewTabVisibility();
+
+    Services.obs.addObserver(this, "contextual-identity-updated");
+
+    this.mCurrentTab = this.tabContainer.firstChild;
+    const nsIEventListenerService =
+      Components.interfaces.nsIEventListenerService;
+    let els = Components.classes[
+      "@mozilla.org/eventlistenerservice;1"
+    ].getService(nsIEventListenerService);
+    els.addSystemEventListener(document, "keydown", this, false);
+    if (AppConstants.platform == "macosx") {
+      els.addSystemEventListener(document, "keypress", this, false);
+    }
+    window.addEventListener("sizemodechange", this);
+    window.addEventListener("occlusionstatechange", this);
+
+    var uniqueId = this._generateUniquePanelID();
+    this.mPanelContainer.childNodes[0].id = uniqueId;
+    this.mCurrentTab.linkedPanel = uniqueId;
+    this.mCurrentTab.permanentKey = this.mCurrentBrowser.permanentKey;
+    this.mCurrentTab._tPos = 0;
+    this.mCurrentTab._fullyOpen = true;
+    this.mCurrentTab.linkedBrowser = this.mCurrentBrowser;
+    this._tabForBrowser.set(this.mCurrentBrowser, this.mCurrentTab);
+
+    // set up the shared autoscroll popup
+    this._autoScrollPopup = this.mCurrentBrowser._createAutoScrollPopup();
+    this._autoScrollPopup.id = "autoscroller";
+    this.appendChild(this._autoScrollPopup);
+    this.mCurrentBrowser.setAttribute(
+      "autoscrollpopup",
+      this._autoScrollPopup.id
+    );
+    this.mCurrentBrowser.droppedLinkHandler = handleDroppedLink;
+
+    // Hook up the event listeners to the first browser
+    var tabListener = this.mTabProgressListener(
+      this.mCurrentTab,
+      this.mCurrentBrowser,
+      true,
+      false
+    );
+    const nsIWebProgress = Components.interfaces.nsIWebProgress;
+    const filter = Components.classes[
+      "@mozilla.org/appshell/component/browser-status-filter;1"
+    ].createInstance(nsIWebProgress);
+    filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);
+    this._tabListeners.set(this.mCurrentTab, tabListener);
+    this._tabFilters.set(this.mCurrentTab, filter);
+    this.webProgress.addProgressListener(filter, nsIWebProgress.NOTIFY_ALL);
+
+    if (Services.prefs.getBoolPref("browser.display.use_system_colors"))
+      this.style.backgroundColor = "-moz-default-background-color";
+
+    let messageManager = window.getGroupMessageManager("browsers");
+
+    let remote = window
+      .QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIWebNavigation)
+      .QueryInterface(Ci.nsILoadContext).useRemoteTabs;
+    if (remote) {
+      messageManager.addMessageListener("DOMTitleChanged", this);
+      messageManager.addMessageListener("DOMWindowClose", this);
+      window.messageManager.addMessageListener("contextmenu", this);
+      messageManager.addMessageListener("Browser:Init", this);
+
+      // If this window has remote tabs, switch to our tabpanels fork
+      // which does asynchronous tab switching.
+      this.mPanelContainer.classList.add("tabbrowser-tabpanels");
+    } else {
+      this._outerWindowIDBrowserMap.set(
+        this.mCurrentBrowser.outerWindowID,
+        this.mCurrentBrowser
+      );
+    }
+    messageManager.addMessageListener("DOMWindowFocus", this);
+    messageManager.addMessageListener("RefreshBlocker:Blocked", this);
+    messageManager.addMessageListener("Browser:WindowCreated", this);
+
+    // To correctly handle keypresses for potential FindAsYouType, while
+    // the tab's find bar is not yet initialized.
+    this._findAsYouType = Services.prefs.getBoolPref(
+      "accessibility.typeaheadfind"
+    );
+    Services.prefs.addObserver("accessibility.typeaheadfind", this);
+    messageManager.addMessageListener("Findbar:Keypress", this);
+
+    // Add listeners for prerender messages
+    messageManager.addMessageListener("Prerender:Request", this);
+    messageManager.addMessageListener("Prerender:Cancel", this);
+    messageManager.addMessageListener("Prerender:Swap", this);
+
+    XPCOMUtils.defineLazyPreferenceGetter(
+      this,
+      "animationsEnabled",
+      "toolkit.cosmeticAnimations.enabled",
+      true
+    );
+    XPCOMUtils.defineLazyPreferenceGetter(
+      this,
+      "tabWarmingEnabled",
+      "browser.tabs.remote.warmup.enabled",
+      false
+    );
+    XPCOMUtils.defineLazyPreferenceGetter(
+      this,
+      "tabWarmingMax",
+      "browser.tabs.remote.warmup.maxTabs",
+      3
+    );
+    XPCOMUtils.defineLazyPreferenceGetter(
+      this,
+      "tabWarmingUnloadDelay" /* ms */,
+      "browser.tabs.remote.warmup.unloadDelayMs",
+      2000
+    );
+    XPCOMUtils.defineLazyPreferenceGetter(
+      this,
+      "tabMinWidthPref",
+      "browser.tabs.tabMinWidth",
+      this._tabMinWidthLimit,
+      (pref, prevValue, newValue) => (this.tabMinWidth = newValue),
+      newValue => Math.max(newValue, this._tabMinWidthLimit)
+    );
+
+    this.tabMinWidth = this.tabMinWidthPref;
+
+    this.addEventListener(
+      "DOMWindowClose",
+      event => {
+        if (!event.isTrusted) return;
+
+        if (this.tabs.length == 1) {
+          // We already did PermitUnload in nsGlobalWindow::Close
+          // for this tab. There are no other tabs we need to do
+          // PermitUnload for.
+          window.skipNextCanClose = true;
+          return;
+        }
+
+        var tab = this._getTabForContentWindow(event.target);
+        if (tab) {
+          // Skip running PermitUnload since it already happened.
+          this.removeTab(tab, { skipPermitUnload: true });
+          event.preventDefault();
+        }
+      },
+      true
+    );
+
+    this.addEventListener(
+      "DOMWillOpenModalDialog",
+      event => {
+        if (!event.isTrusted) return;
+
+        let targetIsWindow = event.target instanceof Window;
+
+        // We're about to open a modal dialog, so figure out for which tab:
+        // If this is a same-process modal dialog, then we're given its DOM
+        // window as the event's target. For remote dialogs, we're given the
+        // browser, but that's in the originalTarget and not the target,
+        // because it's across the tabbrowser's XBL boundary.
+        let tabForEvent = targetIsWindow
+          ? this._getTabForContentWindow(event.target.top)
+          : this.getTabForBrowser(event.originalTarget);
+
+        // Focus window for beforeunload dialog so it is seen but don't
+        // steal focus from other applications.
+        if (
+          event.detail &&
+          event.detail.tabPrompt &&
+          event.detail.inPermitUnload &&
+          Services.focus.activeWindow
+        )
+          window.focus();
+
+        // Don't need to act if the tab is already selected or if there isn't
+        // a tab for the event (e.g. for the webextensions options_ui remote
+        // browsers embedded in the "about:addons" page):
+        if (!tabForEvent || tabForEvent.selected) return;
+
+        // We always switch tabs for beforeunload tab-modal prompts.
+        if (
+          event.detail &&
+          event.detail.tabPrompt &&
+          !event.detail.inPermitUnload
+        ) {
+          let docPrincipal = targetIsWindow
+            ? event.target.document.nodePrincipal
+            : null;
+          // At least one of these should/will be non-null:
+          let promptPrincipal =
+            event.detail.promptPrincipal ||
+            docPrincipal ||
+            tabForEvent.linkedBrowser.contentPrincipal;
+          // For null principals, we bail immediately and don't show the checkbox:
+          if (!promptPrincipal || promptPrincipal.isNullPrincipal) {
+            tabForEvent.setAttribute("attention", "true");
+            return;
+          }
+
+          // For non-system/expanded principals, we bail and show the checkbox
+          if (
+            promptPrincipal.URI &&
+            !Services.scriptSecurityManager.isSystemPrincipal(promptPrincipal)
+          ) {
+            let permission = Services.perms.testPermissionFromPrincipal(
+              promptPrincipal,
+              "focus-tab-by-prompt"
+            );
+            if (permission != Services.perms.ALLOW_ACTION) {
+              // Tell the prompt box we want to show the user a checkbox:
+              let tabPrompt = this.getTabModalPromptBox(
+                tabForEvent.linkedBrowser
+              );
+              tabPrompt.onNextPromptShowAllowFocusCheckboxFor(promptPrincipal);
+              tabForEvent.setAttribute("attention", "true");
+              return;
+            }
+          }
+          // ... so system and expanded principals, as well as permitted "normal"
+          // URI-based principals, always get to steal focus for the tab when prompting.
+        }
+
+        // If permissions/origins dictate so, bring tab to the front.
+        this.selectedTab = tabForEvent;
+      },
+      true
+    );
+
+    this.addEventListener("DOMTitleChanged", event => {
+      if (!event.isTrusted) return;
+
+      var contentWin = event.target.defaultView;
+      if (contentWin != contentWin.top) return;
+
+      var tab = this._getTabForContentWindow(contentWin);
+      if (!tab || tab.hasAttribute("pending")) return;
+
+      var titleChanged = this.setTabTitle(tab);
+      if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
+        tab.setAttribute("titlechanged", "true");
+    });
+
+    this.addEventListener("oop-browser-crashed", event => {
+      if (!event.isTrusted) return;
+
+      let browser = event.originalTarget;
+
+      // Preloaded browsers do not actually have any tabs. If one crashes,
+      // it should be released and removed.
+      if (browser === this._preloadedBrowser) {
+        this.removePreloadedBrowser();
+        return;
+      }
+
+      let icon = browser.mIconURL;
+      let tab = this.getTabForBrowser(browser);
+
+      if (this.selectedBrowser == browser) {
+        TabCrashHandler.onSelectedBrowserCrash(browser);
+      } else {
+        this.updateBrowserRemoteness(browser, false);
+        SessionStore.reviveCrashedTab(tab);
+      }
+
+      tab.removeAttribute("soundplaying");
+      this.setIcon(
+        tab,
+        icon,
+        browser.contentPrincipal,
+        browser.contentRequestContextID
+      );
+    });
+
+    this.addEventListener("DOMAudioPlaybackStarted", event => {
+      var tab = this.getTabFromAudioEvent(event);
+      if (!tab) {
+        return;
+      }
+
+      clearTimeout(tab._soundPlayingAttrRemovalTimer);
+      tab._soundPlayingAttrRemovalTimer = 0;
+
+      let modifiedAttrs = [];
+      if (tab.hasAttribute("soundplaying-scheduledremoval")) {
+        tab.removeAttribute("soundplaying-scheduledremoval");
+        modifiedAttrs.push("soundplaying-scheduledremoval");
+      }
+
+      if (!tab.hasAttribute("soundplaying")) {
+        tab.setAttribute("soundplaying", true);
+        modifiedAttrs.push("soundplaying");
+      }
+
+      if (modifiedAttrs.length) {
+        // Flush style so that the opacity takes effect immediately, in
+        // case the media is stopped before the style flushes naturally.
+        getComputedStyle(tab).opacity;
+      }
+
+      this._tabAttrModified(tab, modifiedAttrs);
+    });
+
+    this.addEventListener("DOMAudioPlaybackStopped", event => {
+      var tab = this.getTabFromAudioEvent(event);
+      if (!tab) {
+        return;
+      }
+
+      if (tab.hasAttribute("soundplaying")) {
+        let removalDelay = Services.prefs.getIntPref(
+          "browser.tabs.delayHidingAudioPlayingIconMS"
+        );
+
+        tab.style.setProperty(
+          "--soundplaying-removal-delay",
+          `${removalDelay - 300}ms`
+        );
+        tab.setAttribute("soundplaying-scheduledremoval", "true");
+        this._tabAttrModified(tab, ["soundplaying-scheduledremoval"]);
+
+        tab._soundPlayingAttrRemovalTimer = setTimeout(() => {
+          tab.removeAttribute("soundplaying-scheduledremoval");
+          tab.removeAttribute("soundplaying");
+          this._tabAttrModified(tab, [
+            "soundplaying",
+            "soundplaying-scheduledremoval"
+          ]);
+        }, removalDelay);
+      }
+    });
+
+    this.addEventListener("DOMAudioPlaybackBlockStarted", event => {
+      var tab = this.getTabFromAudioEvent(event);
+      if (!tab) {
+        return;
+      }
+
+      if (!tab.hasAttribute("activemedia-blocked")) {
+        tab.setAttribute("activemedia-blocked", true);
+        this._tabAttrModified(tab, ["activemedia-blocked"]);
+        tab.startMediaBlockTimer();
+      }
+    });
+
+    this.addEventListener("DOMAudioPlaybackBlockStopped", event => {
+      var tab = this.getTabFromAudioEvent(event);
+      if (!tab) {
+        return;
+      }
+
+      if (tab.hasAttribute("activemedia-blocked")) {
+        tab.removeAttribute("activemedia-blocked");
+        this._tabAttrModified(tab, ["activemedia-blocked"]);
+        let hist = Services.telemetry.getHistogramById(
+          "TAB_AUDIO_INDICATOR_USED"
+        );
+        hist.add(2 /* unblockByVisitingTab */);
+        tab.finishMediaBlockTimer();
+      }
+    });
+
+    dump("COnstructor: " + (performance.now() - start) + "\n");
+  }
+  disconnectedCallback() {
+    Services.obs.removeObserver(this, "contextual-identity-updated");
+
+    CustomizableUI.removeListener(this);
+
+    for (let tab of this.tabs) {
+      let browser = tab.linkedBrowser;
+      if (browser.registeredOpenURI) {
+        this._unifiedComplete.unregisterOpenPage(
+          browser.registeredOpenURI,
+          browser.getAttribute("usercontextid") || 0
+        );
+        delete browser.registeredOpenURI;
+      }
+
+      let filter = this._tabFilters.get(tab);
+      if (filter) {
+        browser.webProgress.removeProgressListener(filter);
+
+        let listener = this._tabListeners.get(tab);
+        if (listener) {
+          filter.removeProgressListener(listener);
+          listener.destroy();
+        }
+
+        this._tabFilters.delete(tab);
+        this._tabListeners.delete(tab);
+      }
+    }
+    const nsIEventListenerService =
+      Components.interfaces.nsIEventListenerService;
+    let els = Components.classes[
+      "@mozilla.org/eventlistenerservice;1"
+    ].getService(nsIEventListenerService);
+    els.removeSystemEventListener(document, "keydown", this, false);
+    if (AppConstants.platform == "macosx") {
+      els.removeSystemEventListener(document, "keypress", this, false);
+    }
+    window.removeEventListener("sizemodechange", this);
+    window.removeEventListener("occlusionstatechange", this);
+
+    if (gMultiProcessBrowser) {
+      let messageManager = window.getGroupMessageManager("browsers");
+      messageManager.removeMessageListener("DOMTitleChanged", this);
+      window.messageManager.removeMessageListener("contextmenu", this);
+
+      if (this._switcher) {
+        this._switcher.destroy();
+      }
+    }
+
+    Services.prefs.removeObserver("accessibility.typeaheadfind", this);
+  }
+
+  get tabContextMenu() {
+    return this.tabContainer.contextMenu;
+  }
+
+  get visibleTabs() {
+    if (!this._visibleTabs)
+      this._visibleTabs = Array.filter(
+        this.tabs,
+        tab => !tab.hidden && !tab.closing
+      );
+    return this._visibleTabs;
+  }
+
+  get _numPinnedTabs() {
+    for (var i = 0; i < this.tabs.length; i++) {
+      if (!this.tabs[i].pinned) break;
+    }
+    return i;
+  }
+
+  get popupAnchor() {
+    if (this.mCurrentTab._popupAnchor) {
+      return this.mCurrentTab._popupAnchor;
+    }
+    let stack = this.mCurrentBrowser.parentNode;
+    // Create an anchor for the popup
+    const NS_XUL =
+      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    let popupAnchor = document.createElementNS(NS_XUL, "hbox");
+    popupAnchor.className = "popup-anchor";
+    popupAnchor.hidden = true;
+    stack.appendChild(popupAnchor);
+    return (this.mCurrentTab._popupAnchor = popupAnchor);
+  }
+
+  set selectedTab(val) {
+    if (gNavToolbox.collapsed && !this._allowTabChange) {
+      return this.mTabBox.selectedTab;
+    }
+    // Update the tab
+    this.mTabBox.selectedTab = val;
+    return val;
+  }
+
+  get selectedTab() {
+    return this.mCurrentTab;
+  }
+
+  get selectedBrowser() {
+    return this.mCurrentBrowser;
+  }
+
+  get canGoBack() {
+    return this.mCurrentBrowser.canGoBack;
+  }
+
+  get canGoForward() {
+    return this.mCurrentBrowser.canGoForward;
+  }
+
+  set homePage(val) {
+    this.mCurrentBrowser.homePage = val;
+    return val;
+  }
+
+  get homePage() {
+    return this.mCurrentBrowser.homePage;
+  }
+
+  get currentURI() {
+    return this.mCurrentBrowser.currentURI;
+  }
+
+  get finder() {
+    return this.mCurrentBrowser.finder;
+  }
+
+  get docShell() {
+    return this.mCurrentBrowser.docShell;
+  }
+
+  get webNavigation() {
+    return this.mCurrentBrowser.webNavigation;
+  }
+
+  get webBrowserFind() {
+    return this.mCurrentBrowser.webBrowserFind;
+  }
+
+  get webProgress() {
+    return this.mCurrentBrowser.webProgress;
+  }
+
+  get contentWindow() {
+    return this.mCurrentBrowser.contentWindow;
+  }
+
+  get contentWindowAsCPOW() {
+    return this.mCurrentBrowser.contentWindowAsCPOW;
+  }
+
+  get sessionHistory() {
+    return this.mCurrentBrowser.sessionHistory;
+  }
+
+  get markupDocumentViewer() {
+    return this.mCurrentBrowser.markupDocumentViewer;
+  }
+
+  get contentViewerEdit() {
+    return this.mCurrentBrowser.contentViewerEdit;
+  }
+
+  get contentDocument() {
+    return this.mCurrentBrowser.contentDocument;
+  }
+
+  get contentDocumentAsCPOW() {
+    return this.mCurrentBrowser.contentDocumentAsCPOW;
+  }
+
+  get contentTitle() {
+    return this.mCurrentBrowser.contentTitle;
+  }
+
+  get contentPrincipal() {
+    return this.mCurrentBrowser.contentPrincipal;
+  }
+
+  get securityUI() {
+    return this.mCurrentBrowser.securityUI;
+  }
+
+  set fullZoom(val) {
+    this.mCurrentBrowser.fullZoom = val;
+  }
+
+  get fullZoom() {
+    return this.mCurrentBrowser.fullZoom;
+  }
+
+  set textZoom(val) {
+    this.mCurrentBrowser.textZoom = val;
+  }
+
+  get textZoom() {
+    return this.mCurrentBrowser.textZoom;
+  }
+
+  get isSyntheticDocument() {
+    return this.mCurrentBrowser.isSyntheticDocument;
+  }
+
+  set userTypedValue(val) {
+    return (this.mCurrentBrowser.userTypedValue = val);
+  }
+
+  get userTypedValue() {
+    return this.mCurrentBrowser.userTypedValue;
+  }
+
+  set tabMinWidth(val) {
+    let root = document.documentElement;
+    root.style.setProperty("--tab-min-width", val + "px");
+    return val;
+  }
+  isFindBarInitialized(aTab) {
+    return (aTab || this.selectedTab)._findBar != undefined;
+  }
+  getFindBar(aTab) {
+    if (!aTab) aTab = this.selectedTab;
+
+    if (aTab._findBar) return aTab._findBar;
+
+    let findBar = document.createElementNS(this.namespaceURI, "findbar");
+    let browser = this.getBrowserForTab(aTab);
+    let browserContainer = this.getBrowserContainer(browser);
+    browserContainer.appendChild(findBar);
+
+    // Force a style flush to ensure that our binding is attached.
+    findBar.clientTop;
+
+    findBar.browser = browser;
+    findBar._findField.value = this._lastFindValue;
+
+    aTab._findBar = findBar;
+
+    let event = document.createEvent("Events");
+    event.initEvent("TabFindInitialized", true, false);
+    aTab.dispatchEvent(event);
+
+    return findBar;
+  }
+  getStatusPanel() {
+    if (!this._statusPanel) {
+      this._statusPanel = document.createElementNS(
+        this.namespaceURI,
+        "statuspanel"
+      );
+      this._statusPanel.setAttribute("inactive", "true");
+      this._statusPanel.setAttribute("layer", "true");
+      this._appendStatusPanel();
+    }
+    return this._statusPanel;
+  }
+  _appendStatusPanel() {
+    if (this._statusPanel) {
+      let browser = this.selectedBrowser;
+      let browserContainer = this.getBrowserContainer(browser);
+      browserContainer.insertBefore(
+        this._statusPanel,
+        browser.parentNode.nextSibling
+      );
+    }
+  }
+  _setCloseKeyState(aEnabled) {
+    let keyClose = document.getElementById("key_close");
+    let closeKeyEnabled = keyClose.getAttribute("disabled") != "true";
+    if (closeKeyEnabled == aEnabled) return;
+
+    if (aEnabled) keyClose.removeAttribute("disabled");
+    else keyClose.setAttribute("disabled", "true");
+
+    // We also want to remove the keyboard shortcut from the file menu
+    // when the shortcut is disabled, and bring it back when it's
+    // renabled.
+    //
+    // Fixing bug 630826 could make that happen automatically.
+    // Fixing bug 630830 could avoid the ugly hack below.
+
+    let closeMenuItem = document.getElementById("menu_close");
+    let parentPopup = closeMenuItem.parentNode;
+    let nextItem = closeMenuItem.nextSibling;
+    let clonedItem = closeMenuItem.cloneNode(true);
+
+    parentPopup.removeChild(closeMenuItem);
+
+    if (aEnabled) clonedItem.setAttribute("key", "key_close");
+    else clonedItem.removeAttribute("key");
+
+    parentPopup.insertBefore(clonedItem, nextItem);
+  }
+  pinTab(aTab) {
+    if (aTab.pinned) return;
+
+    if (aTab.hidden) this.showTab(aTab);
+
+    this.moveTabTo(aTab, this._numPinnedTabs);
+    aTab.setAttribute("pinned", "true");
+    this.tabContainer._unlockTabSizing();
+    this.tabContainer._positionPinnedTabs();
+    this.tabContainer.adjustTabstrip();
+
+    this.getBrowserForTab(
+      aTab
+    ).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: true });
+
+    if (aTab.selected) this._setCloseKeyState(false);
+
+    let event = document.createEvent("Events");
+    event.initEvent("TabPinned", true, false);
+    aTab.dispatchEvent(event);
+  }
+  unpinTab(aTab) {
+    if (!aTab.pinned) return;
+
+    this.moveTabTo(aTab, this._numPinnedTabs - 1);
+    aTab.removeAttribute("pinned");
+    aTab.style.marginInlineStart = "";
+    this.tabContainer._unlockTabSizing();
+    this.tabContainer._positionPinnedTabs();
+    this.tabContainer.adjustTabstrip();
+
+    this.getBrowserForTab(
+      aTab
+    ).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: false });
+
+    if (aTab.selected) this._setCloseKeyState(true);
+
+    let event = document.createEvent("Events");
+    event.initEvent("TabUnpinned", true, false);
+    aTab.dispatchEvent(event);
+  }
+  previewTab(aTab, aCallback) {
+    let currentTab = this.selectedTab;
+    try {
+      // Suppress focus, ownership and selected tab changes
+      this._previewMode = true;
+      this.selectedTab = aTab;
+      aCallback();
+    } finally {
+      this.selectedTab = currentTab;
+      this._previewMode = false;
+    }
+  }
+  getBrowserAtIndex(aIndex) {
+    return this.browsers[aIndex];
+  }
+  getBrowserIndexForDocument(aDocument) {
+    var tab = this._getTabForContentWindow(aDocument.defaultView);
+    return tab ? tab._tPos : -1;
+  }
+  getBrowserForDocument(aDocument) {
+    var tab = this._getTabForContentWindow(aDocument.defaultView);
+    return tab ? tab.linkedBrowser : null;
+  }
+  getBrowserForContentWindow(aWindow) {
+    var tab = this._getTabForContentWindow(aWindow);
+    return tab ? tab.linkedBrowser : null;
+  }
+  getBrowserForOuterWindowID(aID) {
+    return this._outerWindowIDBrowserMap.get(aID);
+  }
+  _getTabForContentWindow(aWindow) {
+    // When not using remote browsers, we can take a fast path by getting
+    // directly from the content window to the browser without looping
+    // over all browsers.
+    if (!gMultiProcessBrowser) {
+      let browser = aWindow
+        .QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIWebNavigation)
+        .QueryInterface(Ci.nsIDocShell).chromeEventHandler;
+      return this.getTabForBrowser(browser);
+    }
+
+    for (let i = 0; i < this.browsers.length; i++) {
+      // NB: We use contentWindowAsCPOW so that this code works both
+      // for remote browsers as well. aWindow may be a CPOW.
+      if (this.browsers[i].contentWindowAsCPOW == aWindow) return this.tabs[i];
+    }
+    return null;
+  }
+  getTabForBrowser(aBrowser) {
+    return this._tabForBrowser.get(aBrowser);
+  }
+  getNotificationBox(aBrowser) {
+    return this.getSidebarContainer(aBrowser).parentNode;
+  }
+  getSidebarContainer(aBrowser) {
+    return this.getBrowserContainer(aBrowser).parentNode;
+  }
+  getBrowserContainer(aBrowser) {
+    return (aBrowser || this.mCurrentBrowser).parentNode.parentNode;
+  }
+  getTabModalPromptBox(aBrowser) {
+    let browser = aBrowser || this.mCurrentBrowser;
+    if (!browser.tabModalPromptBox) {
+      browser.tabModalPromptBox = new TabModalPromptBox(browser);
+    }
+    return browser.tabModalPromptBox;
+  }
+  getTabFromAudioEvent(aEvent) {
+    if (
+      !Services.prefs.getBoolPref("browser.tabs.showAudioPlayingIcon") ||
+      !aEvent.isTrusted
+    ) {
+      return null;
+    }
+
+    var browser = aEvent.originalTarget;
+    var tab = this.getTabForBrowser(browser);
+    return tab;
+  }
+  _callProgressListeners(
+    aBrowser,
+    aMethod,
+    aArguments,
+    aCallGlobalListeners,
+    aCallTabsListeners
+  ) {
+    var rv = true;
+
+    function callListeners(listeners, args) {
+      for (let p of listeners) {
+        if (aMethod in p) {
+          try {
+            if (!p[aMethod].apply(p, args)) rv = false;
+          } catch (e) {
+            // don't inhibit other listeners
+            Components.utils.reportError(e);
+          }
+        }
+      }
+    }
+
+    if (!aBrowser) aBrowser = this.mCurrentBrowser;
+
+    if (aCallGlobalListeners != false && aBrowser == this.mCurrentBrowser) {
+      callListeners(this.mProgressListeners, aArguments);
+    }
+
+    if (aCallTabsListeners != false) {
+      aArguments.unshift(aBrowser);
+
+      callListeners(this.mTabsProgressListeners, aArguments);
+    }
+
+    return rv;
+  }
+  _isLocalAboutURI(aURI, aResolvedURI) {
+    if (!aURI.schemeIs("about")) {
+      return false;
+    }
+
+    // Specially handle about:blank as local
+    if (aURI.pathQueryRef === "blank") {
+      return true;
+    }
+
+    try {
+      // Use the passed in resolvedURI if we have one
+      const resolvedURI =
+        aResolvedURI ||
+        Services.io.newChannelFromURI2(
+          aURI,
+          null, // loadingNode
+          Services.scriptSecurityManager.getSystemPrincipal(), // loadingPrincipal
+          null, // triggeringPrincipal
+          Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL, // securityFlags
+          Ci.nsIContentPolicy.TYPE_OTHER // contentPolicyType
+        ).URI;
+      return resolvedURI.schemeIs("jar") || resolvedURI.schemeIs("file");
+    } catch (ex) {
+      // aURI might be invalid.
+      return false;
+    }
+  }
+  mTabProgressListener(
+    aTab,
+    aBrowser,
+    aStartsBlank,
+    aWasPreloadedBrowser,
+    aOrigStateFlags
+  ) {
+    let stateFlags = aOrigStateFlags || 0;
+    // Initialize mStateFlags to non-zero e.g. when creating a progress
+    // listener for preloaded browsers as there was no progress listener
+    // around when the content started loading. If the content didn't
+    // quite finish loading yet, mStateFlags will very soon be overridden
+    // with the correct value and end up at STATE_STOP again.
+    if (aWasPreloadedBrowser) {
+      stateFlags =
+        Ci.nsIWebProgressListener.STATE_STOP |
+        Ci.nsIWebProgressListener.STATE_IS_REQUEST;
+    }
+
+    return {
+      mTabBrowser: this,
+      mTab: aTab,
+      mBrowser: aBrowser,
+      mBlank: aStartsBlank,
+
+      // cache flags for correct status UI update after tab switching
+      mStateFlags: stateFlags,
+      mStatus: 0,
+      mMessage: "",
+      mTotalProgress: 0,
+
+      // count of open requests (should always be 0 or 1)
+      mRequestCount: 0,
+
+      destroy() {
+        delete this.mTab;
+        delete this.mBrowser;
+        delete this.mTabBrowser;
+      },
+
+      _callProgressListeners() {
+        Array.unshift(arguments, this.mBrowser);
+        return this.mTabBrowser._callProgressListeners.apply(
+          this.mTabBrowser,
+          arguments
+        );
+      },
+
+      _shouldShowProgress(aRequest) {
+        if (this.mBlank) return false;
+
+        // Don't show progress indicators in tabs for about: URIs
+        // pointing to local resources.
+        if (
+          aRequest instanceof Ci.nsIChannel &&
+          this.mTabBrowser._isLocalAboutURI(aRequest.originalURI, aRequest.URI)
+        ) {
+          return false;
+        }
+
+        return true;
+      },
+
+      _isForInitialAboutBlank(aWebProgress, aStateFlags, aLocation) {
+        if (!this.mBlank || !aWebProgress.isTopLevel) {
+          return false;
+        }
+
+        // If the state has STATE_STOP, and no requests were in flight, then this
+        // must be the initial "stop" for the initial about:blank document.
+        const nsIWebProgressListener =
+          Components.interfaces.nsIWebProgressListener;
+        if (
+          aStateFlags & nsIWebProgressListener.STATE_STOP &&
+          this.mRequestCount == 0 &&
+          !aLocation
+        ) {
+          return true;
+        }
+
+        let location = aLocation ? aLocation.spec : "";
+        return location == "about:blank";
+      },
+
+      _syncThrobberAnimations() {
+        const originalTab = this.mTab;
+        BrowserUtils.promiseLayoutFlushed(
+          this.mTab.ownerDocument,
+          "style",
+          () => {
+            if (!originalTab.parentNode) {
+              return;
+            }
+
+            const animations = Array.from(
+              originalTab.parentNode.getElementsByTagName("tab")
+            )
+              .map(tab => {
+                const throbber = document.getAnonymousElementByAttribute(
+                  tab,
+                  "anonid",
+                  "tab-throbber"
+                );
+                return throbber
+                  ? throbber.getAnimations({ subtree: true })
+                  : [];
+              })
+              .reduce((a, b) => a.concat(b))
+              .filter(
+                anim =>
+                  anim instanceof CSSAnimation &&
+                  (anim.animationName === "tab-throbber-animation" ||
+                    anim.animationName === "tab-throbber-animation-rtl") &&
+                  (anim.playState === "running" || anim.playState === "pending")
+              );
+
+            // Synchronize with the oldest running animation, if any.
+            const firstStartTime = Math.min(
+              ...animations.map(
+                anim => (anim.startTime === null ? Infinity : anim.startTime)
+              )
+            );
+            if (firstStartTime === Infinity) {
+              return;
+            }
+            requestAnimationFrame(() => {
+              for (let animation of animations) {
+                // If |animation| has been cancelled since this rAF callback
+                // was scheduled we don't want to set its startTime since
+                // that would restart it. We check for a cancelled animation
+                // by looking for a null currentTime rather than checking
+                // the playState, since reading the playState of
+                // a CSSAnimation object will flush style.
+                if (animation.currentTime !== null) {
+                  animation.startTime = firstStartTime;
+                }
+              }
+            });
+          }
+        );
+      },
+
+      onProgressChange(
+        aWebProgress,
+        aRequest,
+        aCurSelfProgress,
+        aMaxSelfProgress,
+        aCurTotalProgress,
+        aMaxTotalProgress
+      ) {
+        this.mTotalProgress = aMaxTotalProgress
+          ? aCurTotalProgress / aMaxTotalProgress
+          : 0;
+
+        if (!this._shouldShowProgress(aRequest)) return;
+
+        if (this.mTotalProgress && this.mTab.hasAttribute("busy"))
+          this.mTab.setAttribute("progress", "true");
+
+        this._callProgressListeners("onProgressChange", [
+          aWebProgress,
+          aRequest,
+          aCurSelfProgress,
+          aMaxSelfProgress,
+          aCurTotalProgress,
+          aMaxTotalProgress
+        ]);
+      },
+
+      onProgressChange64(
+        aWebProgress,
+        aRequest,
+        aCurSelfProgress,
+        aMaxSelfProgress,
+        aCurTotalProgress,
+        aMaxTotalProgress
+      ) {
+        return this.onProgressChange(
+          aWebProgress,
+          aRequest,
+          aCurSelfProgress,
+          aMaxSelfProgress,
+          aCurTotalProgress,
+          aMaxTotalProgress
+        );
+      },
+
+      onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+        if (!aRequest) return;
+
+        const nsIWebProgressListener =
+          Components.interfaces.nsIWebProgressListener;
+        const nsIChannel = Components.interfaces.nsIChannel;
+        let location, originalLocation;
+        try {
+          aRequest.QueryInterface(nsIChannel);
+          location = aRequest.URI;
+          originalLocation = aRequest.originalURI;
+        } catch (ex) {}
+
+        let ignoreBlank = this._isForInitialAboutBlank(
+          aWebProgress,
+          aStateFlags,
+          location
+        );
+
+        // If we were ignoring some messages about the initial about:blank, and we
+        // got the STATE_STOP for it, we'll want to pay attention to those messages
+        // from here forward. Similarly, if we conclude that this state change
+        // is one that we shouldn't be ignoring, then stop ignoring.
+        if (
+          (ignoreBlank &&
+            aStateFlags & nsIWebProgressListener.STATE_STOP &&
+            aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) ||
+          (!ignoreBlank && this.mBlank)
+        ) {
+          this.mBlank = false;
+        }
+
+        if (aStateFlags & nsIWebProgressListener.STATE_START) {
+          this.mRequestCount++;
+        } else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
+          const NS_ERROR_UNKNOWN_HOST = 2152398878;
+          if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
+            // to prevent bug 235825: wait for the request handled
+            // by the automatic keyword resolver
+            return;
+          }
+          // since we (try to) only handle STATE_STOP of the last request,
+          // the count of open requests should now be 0
+          this.mRequestCount = 0;
+        }
+
+        if (
+          aStateFlags & nsIWebProgressListener.STATE_START &&
+          aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
+        ) {
+          if (aWebProgress.isTopLevel) {
+            // Need to use originalLocation rather than location because things
+            // like about:home and about:privatebrowsing arrive with nsIRequest
+            // pointing to their resolved jar: or file: URIs.
+            if (
+              !(
+                originalLocation &&
+                gInitialPages.includes(originalLocation.spec) &&
+                originalLocation != "about:blank" &&
+                this.mBrowser.initialPageLoadedFromURLBar !=
+                  originalLocation.spec &&
+                this.mBrowser.currentURI &&
+                this.mBrowser.currentURI.spec == "about:blank"
+              )
+            ) {
+              // Indicating that we started a load will allow the location
+              // bar to be cleared when the load finishes.
+              // In order to not overwrite user-typed content, we avoid it
+              // (see if condition above) in a very specific case:
+              // If the load is of an 'initial' page (e.g. about:privatebrowsing,
+              // about:newtab, etc.), was not explicitly typed in the location
+              // bar by the user, is not about:blank (because about:blank can be
+              // loaded by websites under their principal), and the current
+              // page in the browser is about:blank (indicating it is a newly
+              // created or re-created browser, e.g. because it just switched
+              // remoteness or is a new tab/window).
+              this.mBrowser.urlbarChangeTracker.startedLoad();
+            }
+            delete this.mBrowser.initialPageLoadedFromURLBar;
+            // If the browser is loading it must not be crashed anymore
+            this.mTab.removeAttribute("crashed");
+          }
+
+          if (this._shouldShowProgress(aRequest)) {
+            if (
+              !(aStateFlags & nsIWebProgressListener.STATE_RESTORING) &&
+              aWebProgress &&
+              aWebProgress.isTopLevel
+            ) {
+              this.mTab.setAttribute("busy", "true");
+              this.mTab._notselectedsinceload = !this.mTab.selected;
+              this._syncThrobberAnimations();
+            }
+
+            if (this.mTab.selected) {
+              this.mTabBrowser.mIsBusy = true;
+            }
+          }
+        } else if (
+          aStateFlags & nsIWebProgressListener.STATE_STOP &&
+          aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
+        ) {
+          if (this.mTab.hasAttribute("busy")) {
+            this.mTab.removeAttribute("busy");
+
+            // Only animate the "burst" indicating the page has loaded if
+            // the top-level page is the one that finished loading.
+            if (
+              aWebProgress.isTopLevel &&
+              !aWebProgress.isLoadingDocument &&
+              Components.isSuccessCode(aStatus) &&
+              !this.mTabBrowser.tabAnimationsInProgress &&
+              Services.prefs.getBoolPref("toolkit.cosmeticAnimations.enabled")
+            ) {
+              if (this.mTab._notselectedsinceload) {
+                this.mTab.setAttribute("notselectedsinceload", "true");
+              } else {
+                this.mTab.removeAttribute("notselectedsinceload");
+              }
+
+              this.mTab.setAttribute("bursting", "true");
+            }
+
+            this.mTabBrowser._tabAttrModified(this.mTab, ["busy"]);
+            if (!this.mTab.selected) this.mTab.setAttribute("unread", "true");
+          }
+          this.mTab.removeAttribute("progress");
+
+          if (aWebProgress.isTopLevel) {
+            let isSuccessful = Components.isSuccessCode(aStatus);
+            if (!isSuccessful && !isTabEmpty(this.mTab)) {
+              // Restore the current document's location in case the
+              // request was stopped (possibly from a content script)
+              // before the location changed.
+
+              this.mBrowser.userTypedValue = null;
+
+              let inLoadURI = this.mBrowser.inLoadURI;
+              if (this.mTab.selected && gURLBar && !inLoadURI) {
+                URLBarSetURI();
+              }
+            } else if (isSuccessful) {
+              this.mBrowser.urlbarChangeTracker.finishedLoad();
+            }
+
+            if (!this.mBrowser.mIconURL) {
+              this.mTabBrowser.useDefaultIcon(this.mTab);
+            }
+          }
+
+          // For keyword URIs clear the user typed value since they will be changed into real URIs
+          if (location.scheme == "keyword") this.mBrowser.userTypedValue = null;
+
+          if (this.mTab.selected) this.mTabBrowser.mIsBusy = false;
+        }
+
+        if (ignoreBlank) {
+          this._callProgressListeners(
+            "onUpdateCurrentBrowser",
+            [aStateFlags, aStatus, "", 0],
+            true,
+            false
+          );
+        } else {
+          this._callProgressListeners(
+            "onStateChange",
+            [aWebProgress, aRequest, aStateFlags, aStatus],
+            true,
+            false
+          );
+        }
+
+        this._callProgressListeners(
+          "onStateChange",
+          [aWebProgress, aRequest, aStateFlags, aStatus],
+          false
+        );
+
+        if (
+          aStateFlags &
+          (nsIWebProgressListener.STATE_START |
+            nsIWebProgressListener.STATE_STOP)
+        ) {
+          // reset cached temporary values at beginning and end
+          this.mMessage = "";
+          this.mTotalProgress = 0;
+        }
+        this.mStateFlags = aStateFlags;
+        this.mStatus = aStatus;
+      },
+
+      onLocationChange(aWebProgress, aRequest, aLocation, aFlags) {
+        // OnLocationChange is called for both the top-level content
+        // and the subframes.
+        let topLevel = aWebProgress.isTopLevel;
+
+        if (topLevel) {
+          let isSameDocument = !!(
+            aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT
+          );
+          // We need to clear the typed value
+          // if the document failed to load, to make sure the urlbar reflects the
+          // failed URI (particularly for SSL errors). However, don't clear the value
+          // if the error page's URI is about:blank, because that causes complete
+          // loss of urlbar contents for invalid URI errors (see bug 867957).
+          // Another reason to clear the userTypedValue is if this was an anchor
+          // navigation initiated by the user.
+          if (
+            this.mBrowser.didStartLoadSinceLastUserTyping() ||
+            (aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE &&
+              aLocation.spec != "about:blank") ||
+            (isSameDocument && this.mBrowser.inLoadURI)
+          ) {
+            this.mBrowser.userTypedValue = null;
+          }
+
+          // If the browser was playing audio, we should remove the playing state.
+          if (this.mTab.hasAttribute("soundplaying") && !isSameDocument) {
+            clearTimeout(this.mTab._soundPlayingAttrRemovalTimer);
+            this.mTab._soundPlayingAttrRemovalTimer = 0;
+            this.mTab.removeAttribute("soundplaying");
+            this.mTabBrowser._tabAttrModified(this.mTab, ["soundplaying"]);
+          }
+
+          // If the browser was previously muted, we should restore the muted state.
+          if (this.mTab.hasAttribute("muted")) {
+            this.mTab.linkedBrowser.mute();
+          }
+
+          if (this.mTabBrowser.isFindBarInitialized(this.mTab)) {
+            let findBar = this.mTabBrowser.getFindBar(this.mTab);
+
+            // Close the Find toolbar if we're in old-style TAF mode
+            if (findBar.findMode != findBar.FIND_NORMAL) {
+              findBar.close();
+            }
+          }
+
+          this.mTabBrowser.setTabTitle(this.mTab);
+
+          // Don't clear the favicon if this tab is in the pending
+          // state, as SessionStore will have set the icon for us even
+          // though we're pointed at an about:blank. Also don't clear it
+          // if onLocationChange was triggered by a pushState or a
+          // replaceState (bug 550565) or a hash change (bug 408415).
+          if (
+            !this.mTab.hasAttribute("pending") &&
+            aWebProgress.isLoadingDocument &&
+            !isSameDocument
+          ) {
+            this.mBrowser.mIconURL = null;
+          }
+
+          let userContextId = this.mBrowser.getAttribute("usercontextid") || 0;
+          if (this.mBrowser.registeredOpenURI) {
+            this.mTabBrowser._unifiedComplete.unregisterOpenPage(
+              this.mBrowser.registeredOpenURI,
+              userContextId
+            );
+            delete this.mBrowser.registeredOpenURI;
+          }
+          // Tabs in private windows aren't registered as "Open" so
+          // that they don't appear as switch-to-tab candidates.
+          if (
+            !isBlankPageURL(aLocation.spec) &&
+            (!PrivateBrowsingUtils.isWindowPrivate(window) ||
+              PrivateBrowsingUtils.permanentPrivateBrowsing)
+          ) {
+            this.mTabBrowser._unifiedComplete.registerOpenPage(
+              aLocation,
+              userContextId
+            );
+            this.mBrowser.registeredOpenURI = aLocation;
+          }
+        }
+
+        if (!this.mBlank) {
+          this._callProgressListeners("onLocationChange", [
+            aWebProgress,
+            aRequest,
+            aLocation,
+            aFlags
+          ]);
+        }
+
+        if (topLevel) {
+          this.mBrowser.lastURI = aLocation;
+          this.mBrowser.lastLocationChange = Date.now();
+        }
+      },
+
+      onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
+        if (this.mBlank) return;
+
+        this._callProgressListeners("onStatusChange", [
+          aWebProgress,
+          aRequest,
+          aStatus,
+          aMessage
+        ]);
+
+        this.mMessage = aMessage;
+      },
+
+      onSecurityChange(aWebProgress, aRequest, aState) {
+        this._callProgressListeners("onSecurityChange", [
+          aWebProgress,
+          aRequest,
+          aState
+        ]);
+      },
+
+      onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI) {
+        return this._callProgressListeners("onRefreshAttempted", [
+          aWebProgress,
+          aURI,
+          aDelay,
+          aSameURI
+        ]);
+      },
+
+      QueryInterface(aIID) {
+        if (
+          aIID.equals(Components.interfaces.nsIWebProgressListener) ||
+          aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
+          aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
+          aIID.equals(Components.interfaces.nsISupports)
+        )
+          return this;
+        throw Components.results.NS_NOINTERFACE;
+      }
+    };
+  }
+  storeIcon(aBrowser, aURI, aLoadingPrincipal, aRequestContextID) {
+    try {
+      if (!(aURI instanceof Ci.nsIURI)) {
+        aURI = makeURI(aURI);
+      }
+      PlacesUIUtils.loadFavicon(
+        aBrowser,
+        aLoadingPrincipal,
+        aURI,
+        aRequestContextID
+      );
+    } catch (ex) {
+      Components.utils.reportError(ex);
+    }
+  }
+  setIcon(aTab, aURI, aLoadingPrincipal, aRequestContextID) {
+    let browser = this.getBrowserForTab(aTab);
+    browser.mIconURL = aURI instanceof Ci.nsIURI ? aURI.spec : aURI;
+    let loadingPrincipal =
+      aLoadingPrincipal || Services.scriptSecurityManager.getSystemPrincipal();
+    let requestContextID = aRequestContextID || 0;
+    let sizedIconUrl = browser.mIconURL || "";
+    if (sizedIconUrl != aTab.getAttribute("image")) {
+      if (sizedIconUrl) {
+        if (
+          !browser.mIconLoadingPrincipal ||
+          !browser.mIconLoadingPrincipal.equals(loadingPrincipal)
+        ) {
+          aTab.setAttribute(
+            "iconLoadingPrincipal",
+            this.serializationHelper.serializeToString(loadingPrincipal)
+          );
+          aTab.setAttribute("requestcontextid", requestContextID);
+          browser.mIconLoadingPrincipal = loadingPrincipal;
+        }
+        aTab.setAttribute("image", sizedIconUrl);
+      } else {
+        aTab.removeAttribute("iconLoadingPrincipal");
+        delete browser.mIconLoadingPrincipal;
+        aTab.removeAttribute("image");
+      }
+      this._tabAttrModified(aTab, ["image"]);
+    }
+
+    this._callProgressListeners(browser, "onLinkIconAvailable", [
+      browser.mIconURL
+    ]);
+  }
+  getIcon(aTab) {
+    let browser = aTab ? this.getBrowserForTab(aTab) : this.selectedBrowser;
+    return browser.mIconURL;
+  }
+  setPageInfo(aURL, aDescription, aPreviewImage) {
+    if (aURL) {
+      let pageInfo = {
+        url: aURL,
+        description: aDescription,
+        previewImageURL: aPreviewImage
+      };
+      PlacesUtils.history.update(pageInfo).catch(Components.utils.reportError);
+    }
+  }
+  shouldLoadFavIcon(aURI) {
+    return (
+      aURI &&
+      Services.prefs.getBoolPref("browser.chrome.site_icons") &&
+      Services.prefs.getBoolPref("browser.chrome.favicons") &&
+      "schemeIs" in aURI &&
+      (aURI.schemeIs("http") || aURI.schemeIs("https"))
+    );
+  }
+  useDefaultIcon(aTab) {
+    let browser = this.getBrowserForTab(aTab);
+    let documentURI = browser.documentURI;
+    let requestContextID = browser.contentRequestContextID;
+    let loadingPrincipal = browser.contentPrincipal;
+    let icon = null;
+
+    if (browser.imageDocument) {
+      if (Services.prefs.getBoolPref("browser.chrome.site_icons")) {
+        let sz = Services.prefs.getIntPref(
+          "browser.chrome.image_icons.max_size"
+        );
+        if (
+          browser.imageDocument.width <= sz &&
+          browser.imageDocument.height <= sz
+        ) {
+          // Don't try to store the icon in Places, regardless it would
+          // be skipped (see Bug 403651).
+          icon = browser.currentURI;
+        }
+      }
+    }
+
+    // Use documentURIObject in the check for shouldLoadFavIcon so that we
+    // do the right thing with about:-style error pages.  Bug 453442
+    if (!icon && this.shouldLoadFavIcon(documentURI)) {
+      let url = documentURI.prePath + "/favicon.ico";
+      if (!this.isFailedIcon(url)) {
+        icon = url;
+        this.storeIcon(browser, icon, loadingPrincipal, requestContextID);
+      }
+    }
+
+    this.setIcon(aTab, icon, loadingPrincipal, requestContextID);
+  }
+  isFailedIcon(aURI) {
+    if (!(aURI instanceof Ci.nsIURI)) aURI = makeURI(aURI);
+    return PlacesUtils.favicons.isFailedFavicon(aURI);
+  }
+  getWindowTitleForBrowser(aBrowser) {
+    var newTitle = "";
+    var docElement = this.ownerDocument.documentElement;
+    var sep = docElement.getAttribute("titlemenuseparator");
+    let tab = this.getTabForBrowser(aBrowser);
+    let docTitle;
+
+    if (tab._labelIsContentTitle) {
+      // Strip out any null bytes in the content title, since the
+      // underlying widget implementations of nsWindow::SetTitle pass
+      // null-terminated strings to system APIs.
+      docTitle = tab.getAttribute("label").replace(/\0/g, "");
+    }
+
+    if (!docTitle) docTitle = docElement.getAttribute("titledefault");
+
+    var modifier = docElement.getAttribute("titlemodifier");
+    if (docTitle) {
+      newTitle += docElement.getAttribute("titlepreface");
+      newTitle += docTitle;
+      if (modifier) newTitle += sep;
+    }
+    newTitle += modifier;
+
+    // If location bar is hidden and the URL type supports a host,
+    // add the scheme and host to the title to prevent spoofing.
+    // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
+    try {
+      if (docElement.getAttribute("chromehidden").includes("location")) {
+        var uri = this.mURIFixup.createExposableURI(aBrowser.currentURI);
+        if (uri.scheme == "about") newTitle = uri.spec + sep + newTitle;
+        else newTitle = uri.prePath + sep + newTitle;
+      }
+    } catch (e) {}
+
+    return newTitle;
+  }
+  updateTitlebar() {
+    this.ownerDocument.title = this.getWindowTitleForBrowser(
+      this.mCurrentBrowser
+    );
+  }
+  updateCurrentBrowser(aForceUpdate) {
+    var newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);
+    if (this.mCurrentBrowser == newBrowser && !aForceUpdate) return;
+
+    if (!aForceUpdate) {
+      document.commandDispatcher.lock();
+
+      TelemetryStopwatch.start("FX_TAB_SWITCH_UPDATE_MS");
+      if (!gMultiProcessBrowser) {
+        // old way of measuring tab paint which is not valid with e10s.
+        // Waiting until the next MozAfterPaint ensures that we capture
+        // the time it takes to paint, upload the textures to the compositor,
+        // and then composite.
+        if (this._tabSwitchID) {
+          TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_MS");
+        }
+
+        let tabSwitchID = Symbol();
+
+        TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_MS");
+        this._tabSwitchID = tabSwitchID;
+
+        let onMozAfterPaint = () => {
+          if (this._tabSwitchID === tabSwitchID) {
+            TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_MS");
+            this._tabSwitchID = null;
+          }
+          window.removeEventListener("MozAfterPaint", onMozAfterPaint);
+        };
+        window.addEventListener("MozAfterPaint", onMozAfterPaint);
+      }
+    }
+
+    var oldTab = this.mCurrentTab;
+
+    // Preview mode should not reset the owner
+    if (!this._previewMode && !oldTab.selected) oldTab.owner = null;
+
+    let lastRelatedTab = this._lastRelatedTabMap.get(oldTab);
+    if (lastRelatedTab) {
+      if (!lastRelatedTab.selected) lastRelatedTab.owner = null;
+    }
+    this._lastRelatedTabMap = new WeakMap();
+
+    var oldBrowser = this.mCurrentBrowser;
+
+    if (!gMultiProcessBrowser) {
+      oldBrowser.removeAttribute("primary");
+      oldBrowser.docShellIsActive = false;
+      newBrowser.setAttribute("primary", "true");
+      newBrowser.docShellIsActive =
+        window.windowState != window.STATE_MINIMIZED && !window.isFullyOccluded;
+    }
+
+    var updateBlockedPopups = false;
+    if (
+      (oldBrowser.blockedPopups && !newBrowser.blockedPopups) ||
+      (!oldBrowser.blockedPopups && newBrowser.blockedPopups)
+    )
+      updateBlockedPopups = true;
+
+    this.mCurrentBrowser = newBrowser;
+    this.mCurrentTab = this.tabContainer.selectedItem;
+    this.showTab(this.mCurrentTab);
+
+    gURLBar.setAttribute("switchingtabs", "true");
+    window.addEventListener(
+      "MozAfterPaint",
+      function() {
+        gURLBar.removeAttribute("switchingtabs");
+      },
+      { once: true }
+    );
+
+    this._appendStatusPanel();
+
+    if (updateBlockedPopups) this.mCurrentBrowser.updateBlockedPopups();
+
+    // Update the URL bar.
+    var loc = this.mCurrentBrowser.currentURI;
+
+    var webProgress = this.mCurrentBrowser.webProgress;
+    var securityUI = this.mCurrentBrowser.securityUI;
+
+    this._callProgressListeners(
+      null,
+      "onLocationChange",
+      [webProgress, null, loc, 0],
+      true,
+      false
+    );
+
+    if (securityUI) {
+      // Include the true final argument to indicate that this event is
+      // simulated (instead of being observed by the webProgressListener).
+      this._callProgressListeners(
+        null,
+        "onSecurityChange",
+        [webProgress, null, securityUI.state, true],
+        true,
+        false
+      );
+    }
+
+    var listener = this._tabListeners.get(this.mCurrentTab);
+    if (listener && listener.mStateFlags) {
+      this._callProgressListeners(
+        null,
+        "onUpdateCurrentBrowser",
+        [
+          listener.mStateFlags,
+          listener.mStatus,
+          listener.mMessage,
+          listener.mTotalProgress
+        ],
+        true,
+        false
+      );
+    }
+
+    if (!this._previewMode) {
+      this.mCurrentTab.updateLastAccessed();
+      this.mCurrentTab.removeAttribute("unread");
+      oldTab.updateLastAccessed();
+
+      let oldFindBar = oldTab._findBar;
+      if (
+        oldFindBar &&
+        oldFindBar.findMode == oldFindBar.FIND_NORMAL &&
+        !oldFindBar.hidden
+      )
+        this._lastFindValue = oldFindBar._findField.value;
+
+      this.updateTitlebar();
+
+      this.mCurrentTab.removeAttribute("titlechanged");
+      this.mCurrentTab.removeAttribute("attention");
+
+      // The tab has been selected, it's not unselected anymore.
+      // (1) Call the current tab's finishUnselectedTabHoverTimer()
+      //     to save a telemetry record.
+      // (2) Call the current browser's unselectedTabHover() with false
+      //     to dispatch an event.
+      this.mCurrentTab.finishUnselectedTabHoverTimer();
+      this.mCurrentBrowser.unselectedTabHover(false);
+    }
+
+    // If the new tab is busy, and our current state is not busy, then
+    // we need to fire a start to all progress listeners.
+    const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
+    if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
+      this.mIsBusy = true;
+      this._callProgressListeners(
+        null,
+        "onStateChange",
+        [
+          webProgress,
+          null,
+          nsIWebProgressListener.STATE_START |
+            nsIWebProgressListener.STATE_IS_NETWORK,
+          0
+        ],
+        true,
+        false
+      );
+    }
+
+    // If the new tab is not busy, and our current state is busy, then
+    // we need to fire a stop to all progress listeners.
+    if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
+      this.mIsBusy = false;
+      this._callProgressListeners(
+        null,
+        "onStateChange",
+        [
+          webProgress,
+          null,
+          nsIWebProgressListener.STATE_STOP |
+            nsIWebProgressListener.STATE_IS_NETWORK,
+          0
+        ],
+        true,
+        false
+      );
+    }
+
+    this._setCloseKeyState(!this.mCurrentTab.pinned);
+
+    // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code
+    // that might rely upon the other changes suppressed.
+    // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window
+    if (!this._previewMode) {
+      // We've selected the new tab, so go ahead and notify listeners.
+      let event = new CustomEvent("TabSelect", {
+        bubbles: true,
+        cancelable: false,
+        detail: {
+          previousTab: oldTab
+        }
+      });
+      this.mCurrentTab.dispatchEvent(event);
+
+      this._tabAttrModified(oldTab, ["selected"]);
+      this._tabAttrModified(this.mCurrentTab, ["selected"]);
+
+      if (oldBrowser != newBrowser && oldBrowser.getInPermitUnload) {
+        oldBrowser.getInPermitUnload(inPermitUnload => {
+          if (!inPermitUnload) {
+            return;
+          }
+          // Since the user is switching away from a tab that has
+          // a beforeunload prompt active, we remove the prompt.
+          // This prevents confusing user flows like the following:
+          //   1. User attempts to close Firefox
+          //   2. User switches tabs (ingoring a beforeunload prompt)
+          //   3. User returns to tab, presses "Leave page"
+          let promptBox = this.getTabModalPromptBox(oldBrowser);
+          let prompts = promptBox.listPrompts();
+          // There might not be any prompts here if the tab was closed
+          // while in an onbeforeunload prompt, which will have
+          // destroyed aforementioned prompt already, so check there's
+          // something to remove, first:
+          if (prompts.length) {
+            // NB: This code assumes that the beforeunload prompt
+            //     is the top-most prompt on the tab.
+            prompts[prompts.length - 1].abortPrompt();
+          }
+        });
+      }
+
+      if (!gMultiProcessBrowser) {
+        this._adjustFocusBeforeTabSwitch(oldTab, this.mCurrentTab);
+        this._adjustFocusAfterTabSwitch(this.mCurrentTab);
+      }
+    }
+
+    updateUserContextUIIndicator();
+    gIdentityHandler.updateSharingIndicator();
+
+    this.tabContainer._setPositionalAttributes();
+
+    if (!gMultiProcessBrowser) {
+      document.commandDispatcher.unlock();
+
+      let event = new CustomEvent("TabSwitchDone", {
+        bubbles: true,
+        cancelable: true
+      });
+      this.dispatchEvent(event);
+    }
+
+    if (!aForceUpdate) TelemetryStopwatch.finish("FX_TAB_SWITCH_UPDATE_MS");
+  }
+  _adjustFocusBeforeTabSwitch(oldTab, newTab) {
+    if (this._previewMode) {
+      return;
+    }
+
+    let oldBrowser = oldTab.linkedBrowser;
+    let newBrowser = newTab.linkedBrowser;
+
+    oldBrowser._urlbarFocused = gURLBar && gURLBar.focused;
+
+    if (this.isFindBarInitialized(oldTab)) {
+      let findBar = this.getFindBar(oldTab);
+      oldTab._findBarFocused =
+        !findBar.hidden && findBar._findField.getAttribute("focused") == "true";
+    }
+
+    let activeEl = document.activeElement;
+    // If focus is on the old tab, move it to the new tab.
+    if (activeEl == oldTab) {
+      newTab.focus();
+    } else if (
+      gMultiProcessBrowser &&
+      activeEl != newBrowser &&
+      activeEl != newTab
+    ) {
+      // In e10s, if focus isn't already in the tabstrip or on the new browser,
+      // and the new browser's previous focus wasn't in the url bar but focus is
+      // there now, we need to adjust focus further.
+      let keepFocusOnUrlBar =
+        newBrowser && newBrowser._urlbarFocused && gURLBar && gURLBar.focused;
+      if (!keepFocusOnUrlBar) {
+        // Clear focus so that _adjustFocusAfterTabSwitch can detect if
+        // some element has been focused and respect that.
+        document.activeElement.blur();
+      }
+    }
+  }
+  _adjustFocusAfterTabSwitch(newTab) {
+    // Don't steal focus from the tab bar.
+    if (document.activeElement == newTab) return;
+
+    let newBrowser = this.getBrowserForTab(newTab);
+
+    // If there's a tabmodal prompt showing, focus it.
+    if (newBrowser.hasAttribute("tabmodalPromptShowing")) {
+      let XUL_NS =
+        "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+      let prompts = newBrowser.parentNode.getElementsByTagNameNS(
+        XUL_NS,
+        "tabmodalprompt"
+      );
+      let prompt = prompts[prompts.length - 1];
+      prompt.Dialog.setDefaultFocus();
+      return;
+    }
+
+    // Focus the location bar if it was previously focused for that tab.
+    // In full screen mode, only bother making the location bar visible
+    // if the tab is a blank one.
+    if (newBrowser._urlbarFocused && gURLBar) {
+      // Explicitly close the popup if the URL bar retains focus
+      gURLBar.closePopup();
+
+      // If the user happened to type into the URL bar for this browser
+      // by the time we got here, focusing will cause the text to be
+      // selected which could cause them to overwrite what they've
+      // already typed in.
+      if (gURLBar.focused && newBrowser.userTypedValue) {
+        return;
+      }
+
+      if (!window.fullScreen || isTabEmpty(newTab)) {
+        focusAndSelectUrlBar();
+        return;
+      }
+    }
+
+    // Focus the find bar if it was previously focused for that tab.
+    if (
+      gFindBarInitialized &&
+      !gFindBar.hidden &&
+      this.selectedTab._findBarFocused
+    ) {
+      gFindBar._findField.focus();
+      return;
+    }
+
+    // Don't focus the content area if something has been focused after the
+    // tab switch was initiated.
+    if (
+      gMultiProcessBrowser &&
+      document.activeElement != document.documentElement
+    )
+      return;
+
+    // We're now committed to focusing the content area.
+    let fm = Services.focus;
+    let focusFlags = fm.FLAG_NOSCROLL;
+
+    if (!gMultiProcessBrowser) {
+      let newFocusedElement = fm.getFocusedElementForWindow(
+        window.content,
+        true,
+        {}
+      );
+
+      // for anchors, use FLAG_SHOWRING so that it is clear what link was
+      // last clicked when switching back to that tab
+      if (
+        newFocusedElement &&
+        (newFocusedElement instanceof HTMLAnchorElement ||
+          newFocusedElement.getAttributeNS(
+            "http://www.w3.org/1999/xlink",
+            "type"
+          ) == "simple")
+      )
+        focusFlags |= fm.FLAG_SHOWRING;
+    }
+
+    fm.setFocus(newBrowser, focusFlags);
+  }
+  _tabAttrModified(aTab, aChanged) {
+    if (aTab.closing) return;
+
+    let event = new CustomEvent("TabAttrModified", {
+      bubbles: true,
+      cancelable: false,
+      detail: {
+        changed: aChanged
+      }
+    });
+    aTab.dispatchEvent(event);
+  }
+  setBrowserSharing(aBrowser, aState) {
+    let tab = this.getTabForBrowser(aBrowser);
+    if (!tab) return;
+
+    let sharing;
+    if (aState.screen) {
+      sharing = "screen";
+    } else if (aState.camera) {
+      sharing = "camera";
+    } else if (aState.microphone) {
+      sharing = "microphone";
+    }
+
+    if (sharing) {
+      tab.setAttribute("sharing", sharing);
+      tab._sharingState = aState;
+    } else {
+      tab.removeAttribute("sharing");
+      tab._sharingState = null;
+    }
+    this._tabAttrModified(tab, ["sharing"]);
+
+    if (aBrowser == this.mCurrentBrowser)
+      gIdentityHandler.updateSharingIndicator();
+  }
+  setTabTitleLoading(aTab) {}
+  setInitialTabTitle(aTab, aTitle, aOptions) {
+    if (aTitle) {
+      if (!aTab.getAttribute("label")) {
+        aTab._labelIsInitialTitle = true;
+      }
+
+      this._setTabLabel(aTab, aTitle, aOptions);
+    }
+  }
+  setTabTitle(aTab) {
+    var browser = this.getBrowserForTab(aTab);
+    var title = browser.contentTitle;
+
+    // Don't replace an initially set label with the URL while the tab
+    // is loading.
+    if (aTab._labelIsInitialTitle) {
+      if (!title) {
+        return false;
+      }
+      delete aTab._labelIsInitialTitle;
+    }
+
+    let isContentTitle = false;
+    if (title) {
+      isContentTitle = true;
+    } else if (aTab.hasAttribute("customizemode")) {
+      let brandBundle = document.getElementById("bundle_brand");
+      let brandShortName = brandBundle.getString("brandShortName");
+      title = gNavigatorBundle.getFormattedString("customizeMode.tabTitle", [
+        brandShortName
+      ]);
+      isContentTitle = true;
+    } else {
+      if (browser.currentURI.displaySpec) {
+        try {
+          title = this.mURIFixup.createExposableURI(browser.currentURI)
+            .displaySpec;
+        } catch (ex) {
+          title = browser.currentURI.displaySpec;
+        }
+      }
+
+      if (title && !isBlankPageURL(title)) {
+        // At this point, we now have a URI.
+        // Let's try to unescape it using a character set
+        // in case the URI is not ASCII.
+        try {
+          var characterSet = browser.characterSet;
+          const textToSubURI = Components.classes[
+            "@mozilla.org/intl/texttosuburi;1"
+          ].getService(Components.interfaces.nsITextToSubURI);
+          title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
+        } catch (ex) {
+          /* Do nothing. */
+        }
+      } else {
+        // Still no title? Fall back to our untitled string.
+        title = this.mStringBundle.getString("tabs.emptyTabTitle");
+      }
+    }
+
+    return this._setTabLabel(aTab, title, { isContentTitle });
+  }
+  _setTabLabel(aTab, aLabel, aOptions) {
+    if (!aLabel) {
+      return false;
+    }
+
+    aTab._fullLabel = aLabel;
+
+    aOptions = aOptions || {};
+    if (!aOptions.isContentTitle) {
+      // Remove protocol and "www."
+      if (!("_regex_shortenURLForTabLabel" in this)) {
+        this._regex_shortenURLForTabLabel = /^[^:]+:\/\/(?:www\.)?/;
+      }
+      aLabel = aLabel.replace(this._regex_shortenURLForTabLabel, "");
+    }
+
+    aTab._labelIsContentTitle = aOptions.isContentTitle;
+
+    if (aTab.getAttribute("label") == aLabel) {
+      return false;
+    }
+
+    let dwu = window
+      .QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIDOMWindowUtils);
+    let isRTL =
+      dwu.getDirectionFromText(aLabel) == Ci.nsIDOMWindowUtils.DIRECTION_RTL;
+
+    aTab.setAttribute("label", aLabel);
+    aTab.setAttribute("labeldirection", isRTL ? "rtl" : "ltr");
+
+    // Dispatch TabAttrModified event unless we're setting the label
+    // before the TabOpen event was dispatched.
+    if (!aOptions.beforeTabOpen) {
+      this._tabAttrModified(aTab, ["label"]);
+    }
+
+    if (aTab.selected) {
+      this.updateTitlebar();
+    }
+
+    return true;
+  }
+  loadOneTab(
+    aURI,
+    aReferrerURI,
+    aCharset,
+    aPostData,
+    aLoadInBackground,
+    aAllowThirdPartyFixup
+  ) {
+    var aTriggeringPrincipal;
+    var aReferrerPolicy;
+    var aFromExternal;
+    var aRelatedToCurrent;
+    var aAllowMixedContent;
+    var aSkipAnimation;
+    var aForceNotRemote;
+    var aPreferredRemoteType;
+    var aNoReferrer;
+    var aUserContextId;
+    var aSameProcessAsFrameLoader;
+    var aOriginPrincipal;
+    var aOpener;
+    var aOpenerBrowser;
+    var aIsPrerendered;
+    var aCreateLazyBrowser;
+    var aNextTabParentId;
+    var aFocusUrlBar;
+    var aName;
+    if (
+      arguments.length == 2 &&
+      typeof arguments[1] == "object" &&
+      !(arguments[1] instanceof Ci.nsIURI)
+    ) {
+      let params = arguments[1];
+      aTriggeringPrincipal = params.triggeringPrincipal;
+      aReferrerURI = params.referrerURI;
+      aReferrerPolicy = params.referrerPolicy;
+      aCharset = params.charset;
+      aPostData = params.postData;
+      aLoadInBackground = params.inBackground;
+      aAllowThirdPartyFixup = params.allowThirdPartyFixup;
+      aFromExternal = params.fromExternal;
+      aRelatedToCurrent = params.relatedToCurrent;
+      aAllowMixedContent = params.allowMixedContent;
+      aSkipAnimation = params.skipAnimation;
+      aForceNotRemote = params.forceNotRemote;
+      aPreferredRemoteType = params.preferredRemoteType;
+      aNoReferrer = params.noReferrer;
+      aUserContextId = params.userContextId;
+      aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;
+      aOriginPrincipal = params.originPrincipal;
+      aOpener = params.opener;
+      aOpenerBrowser = params.openerBrowser;
+      aIsPrerendered = params.isPrerendered;
+      aCreateLazyBrowser = params.createLazyBrowser;
+      aNextTabParentId = params.nextTabParentId;
+      aFocusUrlBar = params.focusUrlBar;
+      aName = params.name;
+    }
+
+    var bgLoad = aLoadInBackground != null
+      ? aLoadInBackground
+      : Services.prefs.getBoolPref("browser.tabs.loadInBackground");
+    var owner = bgLoad ? null : this.selectedTab;
+
+    var tab = this.addTab(aURI, {
+      triggeringPrincipal: aTriggeringPrincipal,
+      referrerURI: aReferrerURI,
+      referrerPolicy: aReferrerPolicy,
+      charset: aCharset,
+      postData: aPostData,
+      ownerTab: owner,
+      allowThirdPartyFixup: aAllowThirdPartyFixup,
+      fromExternal: aFromExternal,
+      relatedToCurrent: aRelatedToCurrent,
+      skipAnimation: aSkipAnimation,
+      allowMixedContent: aAllowMixedContent,
+      forceNotRemote: aForceNotRemote,
+      createLazyBrowser: aCreateLazyBrowser,
+      preferredRemoteType: aPreferredRemoteType,
+      noReferrer: aNoReferrer,
+      userContextId: aUserContextId,
+      originPrincipal: aOriginPrincipal,
+      sameProcessAsFrameLoader: aSameProcessAsFrameLoader,
+      opener: aOpener,
+      openerBrowser: aOpenerBrowser,
+      isPrerendered: aIsPrerendered,
+      nextTabParentId: aNextTabParentId,
+      focusUrlBar: aFocusUrlBar,
+      name: aName
+    });
+    if (!bgLoad) this.selectedTab = tab;
+
+    return tab;
+  }
+  loadTabs(aURIs, aLoadInBackground, aReplace) {
+    let aTriggeringPrincipal;
+    let aAllowThirdPartyFixup;
+    let aTargetTab;
+    let aNewIndex = -1;
+    let aPostDatas = [];
+    let aUserContextId;
+    if (arguments.length == 2 && typeof arguments[1] == "object") {
+      let params = arguments[1];
+      aLoadInBackground = params.inBackground;
+      aReplace = params.replace;
+      aAllowThirdPartyFixup = params.allowThirdPartyFixup;
+      aTargetTab = params.targetTab;
+      aNewIndex = typeof params.newIndex === "number"
+        ? params.newIndex
+        : aNewIndex;
+      aPostDatas = params.postDatas || aPostDatas;
+      aUserContextId = params.userContextId;
+      aTriggeringPrincipal = params.triggeringPrincipal;
+    }
+
+    if (!aURIs.length) return;
+
+    // The tab selected after this new tab is closed (i.e. the new tab's
+    // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
+    // when several urls are opened here (i.e. closing the first should select
+    // the next of many URLs opened) or if the pref to have UI links opened in
+    // the background is set (i.e. the link is not being opened modally)
+    //
+    // i.e.
+    //    Number of URLs    Load UI Links in BG       Focus Last Viewed?
+    //    == 1              false                     YES
+    //    == 1              true                      NO
+    //    > 1               false/true                NO
+    var multiple = aURIs.length > 1;
+    var owner = multiple || aLoadInBackground ? null : this.selectedTab;
+    var firstTabAdded = null;
+    var targetTabIndex = -1;
+
+    if (aReplace) {
+      let browser;
+      if (aTargetTab) {
+        browser = this.getBrowserForTab(aTargetTab);
+        targetTabIndex = aTargetTab._tPos;
+      } else {
+        browser = this.mCurrentBrowser;
+        targetTabIndex = this.tabContainer.selectedIndex;
+      }
+      let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+      if (aAllowThirdPartyFixup) {
+        flags |=
+          Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP |
+          Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
+      }
+      try {
+        browser.loadURIWithFlags(aURIs[0], {
+          flags,
+          postData: aPostDatas[0],
+          triggeringPrincipal: aTriggeringPrincipal
+        });
+      } catch (e) {
+        // Ignore failure in case a URI is wrong, so we can continue
+        // opening the next ones.
+      }
+    } else {
+      firstTabAdded = this.addTab(aURIs[0], {
+        ownerTab: owner,
+        skipAnimation: multiple,
+        allowThirdPartyFixup: aAllowThirdPartyFixup,
+        postData: aPostDatas[0],
+        userContextId: aUserContextId,
+        triggeringPrincipal: aTriggeringPrincipal
+      });
+      if (aNewIndex !== -1) {
+        this.moveTabTo(firstTabAdded, aNewIndex);
+        targetTabIndex = firstTabAdded._tPos;
+      }
+    }
+
+    let tabNum = targetTabIndex;
+    for (let i = 1; i < aURIs.length; ++i) {
+      let tab = this.addTab(aURIs[i], {
+        skipAnimation: true,
+        allowThirdPartyFixup: aAllowThirdPartyFixup,
+        postData: aPostDatas[i],
+        userContextId: aUserContextId,
+        triggeringPrincipal: aTriggeringPrincipal
+      });
+      if (targetTabIndex !== -1) this.moveTabTo(tab, ++tabNum);
+    }
+
+    if (firstTabAdded && !aLoadInBackground) {
+      this.selectedTab = firstTabAdded;
+    }
+  }
+  updateBrowserRemoteness(aBrowser, aShouldBeRemote, aOptions) {
+    aOptions = aOptions || {};
+    let isRemote = aBrowser.getAttribute("remote") == "true";
+
+    if (!gMultiProcessBrowser && aShouldBeRemote) {
+      throw new Error(
+        "Cannot switch to remote browser in a window " +
+          "without the remote tabs load context."
+      );
+    }
+
+    // Default values for remoteType
+    if (!aOptions.remoteType) {
+      aOptions.remoteType = aShouldBeRemote
+        ? E10SUtils.DEFAULT_REMOTE_TYPE
+        : E10SUtils.NOT_REMOTE;
+    }
+
+    // If we are passed an opener, we must be making the browser non-remote, and
+    // if the browser is _currently_ non-remote, we need the openers to match,
+    // because it is already too late to change it.
+    if (aOptions.opener) {
+      if (aShouldBeRemote) {
+        throw new Error(
+          "Cannot set an opener on a browser which should be remote!"
+        );
+      }
+      if (!isRemote && aBrowser.contentWindow.opener != aOptions.opener) {
+        throw new Error(
+          "Cannot change opener on an already non-remote browser!"
+        );
+      }
+    }
+
+    // Abort if we're not going to change anything
+    let currentRemoteType = aBrowser.getAttribute("remoteType");
+    if (
+      isRemote == aShouldBeRemote &&
+      !aOptions.newFrameloader &&
+      (!isRemote || currentRemoteType == aOptions.remoteType)
+    ) {
+      return false;
+    }
+
+    let tab = this.getTabForBrowser(aBrowser);
+    // aBrowser needs to be inserted now if it hasn't been already.
+    this._insertBrowser(tab);
+
+    let evt = document.createEvent("Events");
+    evt.initEvent("BeforeTabRemotenessChange", true, false);
+    tab.dispatchEvent(evt);
+
+    let wasActive = document.activeElement == aBrowser;
+
+    // Unmap the old outerWindowID.
+    this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);
+
+    // Unhook our progress listener.
+    let filter = this._tabFilters.get(tab);
+    let listener = this._tabListeners.get(tab);
+    aBrowser.webProgress.removeProgressListener(filter);
+    filter.removeProgressListener(listener);
+
+    // We'll be creating a new listener, so destroy the old one.
+    listener.destroy();
+
+    let oldUserTypedValue = aBrowser.userTypedValue;
+    let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
+
+    // Make sure the browser is destroyed so it unregisters from observer notifications
+    aBrowser.destroy();
+
+    // Make sure to restore the original droppedLinkHandler and
+    // sameProcessAsFrameLoader.
+    let droppedLinkHandler = aBrowser.droppedLinkHandler;
+    let sameProcessAsFrameLoader = aBrowser.sameProcessAsFrameLoader;
+
+    // Change the "remote" attribute.
+    let parent = aBrowser.parentNode;
+    parent.removeChild(aBrowser);
+    if (aShouldBeRemote) {
+      aBrowser.setAttribute("remote", "true");
+      aBrowser.setAttribute("remoteType", aOptions.remoteType);
+    } else {
+      aBrowser.setAttribute("remote", "false");
+      aBrowser.removeAttribute("remoteType");
+    }
+
+    // NB: This works with the hack in the browser constructor that
+    // turns this normal property into a field.
+    if (aOptions.sameProcessAsFrameLoader) {
+      // Always set sameProcessAsFrameLoader when passed in aOptions.
+      aBrowser.sameProcessAsFrameLoader = aOptions.sameProcessAsFrameLoader;
+    } else if (!aShouldBeRemote || currentRemoteType == aOptions.remoteType) {
+      // Only copy existing sameProcessAsFrameLoader when not switching
+      // remote type otherwise it would stop the switch.
+      aBrowser.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
+    }
+
+    if (aOptions.opener) {
+      // Set the opener window on the browser, such that when the frame
+      // loader is created the opener is set correctly.
+      aBrowser.presetOpenerWindow(aOptions.opener);
+    }
+
+    parent.appendChild(aBrowser);
+
+    aBrowser.userTypedValue = oldUserTypedValue;
+    if (hadStartedLoad) {
+      aBrowser.urlbarChangeTracker.startedLoad();
+    }
+
+    aBrowser.droppedLinkHandler = droppedLinkHandler;
+
+    // Switching a browser's remoteness will create a new frameLoader.
+    // As frameLoaders start out with an active docShell we have to
+    // deactivate it if this is not the selected tab's browser or the
+    // browser window is minimized.
+    aBrowser.docShellIsActive = this.shouldActivateDocShell(aBrowser);
+
+    // Create a new tab progress listener for the new browser we just injected,
+    // since tab progress listeners have logic for handling the initial about:blank
+    // load
+    listener = this.mTabProgressListener(tab, aBrowser, true, false);
+    this._tabListeners.set(tab, listener);
+    filter.addProgressListener(listener, Ci.nsIWebProgress.NOTIFY_ALL);
+
+    // Restore the progress listener.
+    aBrowser.webProgress.addProgressListener(
+      filter,
+      Ci.nsIWebProgress.NOTIFY_ALL
+    );
+
+    // Restore the securityUI state.
+    let securityUI = aBrowser.securityUI;
+    let state = securityUI
+      ? securityUI.state
+      : Ci.nsIWebProgressListener.STATE_IS_INSECURE;
+    // Include the true final argument to indicate that this event is
+    // simulated (instead of being observed by the webProgressListener).
+    this._callProgressListeners(
+      aBrowser,
+      "onSecurityChange",
+      [aBrowser.webProgress, null, state, true],
+      true,
+      false
+    );
+
+    if (aShouldBeRemote) {
+      // Switching the browser to be remote will connect to a new child
+      // process so the browser can no longer be considered to be
+      // crashed.
+      tab.removeAttribute("crashed");
+    } else {
+      aBrowser.messageManager.sendAsyncMessage("Browser:AppTab", {
+        isAppTab: tab.pinned
+      });
+
+      // Register the new outerWindowID.
+      this._outerWindowIDBrowserMap.set(aBrowser.outerWindowID, aBrowser);
+    }
+
+    if (wasActive) aBrowser.focus();
+
+    // If the findbar has been initialised, reset its browser reference.
+    if (this.isFindBarInitialized(tab)) {
+      this.getFindBar(tab).browser = aBrowser;
+    }
+
+    evt = document.createEvent("Events");
+    evt.initEvent("TabRemotenessChange", true, false);
+    tab.dispatchEvent(evt);
+
+    return true;
+  }
+  updateBrowserRemotenessByURL(aBrowser, aURL, aOptions) {
+    aOptions = aOptions || {};
+
+    if (!gMultiProcessBrowser)
+      return this.updateBrowserRemoteness(aBrowser, false);
+
+    let currentRemoteType = aBrowser.getAttribute("remoteType") || null;
+
+    aOptions.remoteType = E10SUtils.getRemoteTypeForURI(
+      aURL,
+      gMultiProcessBrowser,
+      currentRemoteType,
+      aBrowser.currentURI
+    );
+
+    // If this URL can't load in the current browser then flip it to the
+    // correct type.
+    if (currentRemoteType != aOptions.remoteType || aOptions.newFrameloader) {
+      let remote = aOptions.remoteType != E10SUtils.NOT_REMOTE;
+      return this.updateBrowserRemoteness(aBrowser, remote, aOptions);
+    }
+
+    return false;
+  }
+  removePreloadedBrowser() {
+    if (!this._isPreloadingEnabled()) {
+      return;
+    }
+
+    let browser = this._getPreloadedBrowser();
+
+    if (browser) {
+      browser.remove();
+    }
+  }
+  _getPreloadedBrowser() {
+    if (!this._isPreloadingEnabled()) {
+      return null;
+    }
+
+    // The preloaded browser might be null.
+    let browser = this._preloadedBrowser;
+
+    // Consume the browser.
+    this._preloadedBrowser = null;
+
+    // Attach the nsIFormFillController now that we know the browser
+    // will be used. If we do that before and the preloaded browser
+    // won't be consumed until shutdown then we leak a docShell.
+    // Also, we do not need to take care of attaching nsIFormFillControllers
+    // in the case that the browser is remote, as remote browsers take
+    // care of that themselves.
+    if (browser && this.hasAttribute("autocompletepopup")) {
+      browser.setAttribute(
+        "autocompletepopup",
+        this.getAttribute("autocompletepopup")
+      );
+    }
+
+    return browser;
+  }
+  _isPreloadingEnabled() {
+    // Preloading for the newtab page is enabled when the pref is true
+    // and the URL is "about:newtab". We do not support preloading for
+    // custom newtab URLs.
+    return (
+      Services.prefs.getBoolPref("browser.newtab.preload") &&
+      !aboutNewTabService.overridden
+    );
+  }
+  _createPreloadBrowser() {
+    // Do nothing if we have a preloaded browser already
+    // or preloading of newtab pages is disabled.
+    if (this._preloadedBrowser || !this._isPreloadingEnabled()) {
+      return;
+    }
+
+    let remoteType = E10SUtils.getRemoteTypeForURI(
+      BROWSER_NEW_TAB_URL,
+      gMultiProcessBrowser
+    );
+    let browser = this._createBrowser({ isPreloadBrowser: true, remoteType });
+    this._preloadedBrowser = browser;
+
+    let notificationbox = this.getNotificationBox(browser);
+    this.mPanelContainer.appendChild(notificationbox);
+
+    if (remoteType != E10SUtils.NOT_REMOTE) {
+      // For remote browsers, we need to make sure that the webProgress is
+      // instantiated, otherwise the parent won't get informed about the state
+      // of the preloaded browser until it gets attached to a tab.
+      browser.webProgress;
+    }
+
+    browser.loadURI(BROWSER_NEW_TAB_URL);
+    browser.docShellIsActive = false;
+
+    // Make sure the preloaded browser is loaded with desired zoom level
+    let tabURI = Services.io.newURI(BROWSER_NEW_TAB_URL);
+    FullZoom.onLocationChange(tabURI, false, browser);
+  }
+  _createBrowser(aParams) {
+    // Supported parameters:
+    // userContextId, remote, remoteType, isPreloadBrowser,
+    // uriIsAboutBlank, sameProcessAsFrameLoader, isPrerendered
+
+    const NS_XUL =
+      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+    let b = document.createElementNS(NS_XUL, "browser");
+    b.permanentKey = {};
+    b.setAttribute("type", "content");
+    b.setAttribute("message", "true");
+    b.setAttribute("messagemanagergroup", "browsers");
+    b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
+    b.setAttribute("tooltip", this.getAttribute("contenttooltip"));
+
+    if (aParams.isPrerendered) {
+      b.setAttribute("prerendered", "true");
+    }
+
+    if (aParams.userContextId) {
+      b.setAttribute("usercontextid", aParams.userContextId);
+    }
+
+    // remote parameter used by some addons, use default in this case.
+    if (aParams.remote && !aParams.remoteType) {
+      aParams.remoteType = E10SUtils.DEFAULT_REMOTE_TYPE;
+    }
+
+    if (aParams.remoteType) {
+      b.setAttribute("remoteType", aParams.remoteType);
+      b.setAttribute("remote", "true");
+    }
+
+    if (aParams.openerWindow) {
+      if (aParams.remoteType) {
+        throw new Error("Cannot set opener window on a remote browser!");
+      }
+      b.presetOpenerWindow(aParams.openerWindow);
+    }
+
+    if (!aParams.isPreloadBrowser && this.hasAttribute("autocompletepopup")) {
+      b.setAttribute(
+        "autocompletepopup",
+        this.getAttribute("autocompletepopup")
+      );
+    }
+
+    if (aParams.isPreloadBrowser) {
+      b.setAttribute("isPreloadBrowser", "true");
+    }
+
+    if (this.hasAttribute("selectmenulist"))
+      b.setAttribute("selectmenulist", this.getAttribute("selectmenulist"));
+
+    if (this.hasAttribute("datetimepicker")) {
+      b.setAttribute("datetimepicker", this.getAttribute("datetimepicker"));
+    }
+
+    b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
+
+    if (aParams.nextTabParentId) {
+      if (!aParams.remoteType) {
+        throw new Error("Cannot have nextTabParentId without a remoteType");
+      }
+      // Gecko is going to read this attribute and use it.
+      b.setAttribute("nextTabParentId", aParams.nextTabParentId.toString());
+    }
+
+    if (aParams.sameProcessAsFrameLoader) {
+      b.sameProcessAsFrameLoader = aParams.sameProcessAsFrameLoader;
+    }
+
+    // This will be used by gecko to control the name of the opened
+    // window.
+    if (aParams.name) {
+      // XXX: The `name` property is special in HTML and XUL. Should
+      // we use a different attribute name for this?
+      b.setAttribute("name", aParams.name);
+    }
+
+    // Create the browserStack container
+    var stack = document.createElementNS(NS_XUL, "stack");
+    stack.className = "browserStack";
+    stack.appendChild(b);
+    stack.setAttribute("flex", "1");
+
+    // Create the browserContainer
+    var browserContainer = document.createElementNS(NS_XUL, "vbox");
+    browserContainer.className = "browserContainer";
+    browserContainer.appendChild(stack);
+    browserContainer.setAttribute("flex", "1");
+
+    // Create the sidebar container
+    var browserSidebarContainer = document.createElementNS(NS_XUL, "hbox");
+    browserSidebarContainer.className = "browserSidebarContainer";
+    browserSidebarContainer.appendChild(browserContainer);
+    browserSidebarContainer.setAttribute("flex", "1");
+
+    // Add the Message and the Browser to the box
+    var notificationbox = document.createElementNS(NS_XUL, "notificationbox");
+    notificationbox.setAttribute("flex", "1");
+    notificationbox.setAttribute("notificationside", "top");
+    notificationbox.appendChild(browserSidebarContainer);
+
+    // Prevent the superfluous initial load of a blank document
+    // if we're going to load something other than about:blank.
+    if (!aParams.uriIsAboutBlank) {
+      b.setAttribute("nodefaultsrc", "true");
+    }
+
+    return b;
+  }
+  _createLazyBrowser(aTab) {
+    let browser = aTab.linkedBrowser;
+
+    let names = this._browserBindingProperties;
+
+    for (let i = 0; i < names.length; i++) {
+      let name = names[i];
+      let getter;
+      let setter;
+      switch (name) {
+        case "audioMuted":
+          getter = () => false;
+          break;
+        case "contentTitle":
+          getter = () => SessionStore.getLazyTabValue(aTab, "title");
+          break;
+        case "currentURI":
+          getter = () => {
+            let url = SessionStore.getLazyTabValue(aTab, "url");
+            return Services.io.newURI(url);
+          };
+          break;
+        case "didStartLoadSinceLastUserTyping":
+          getter = () => () => false;
+          break;
+        case "fullZoom":
+        case "textZoom":
+          getter = () => 1;
+          break;
+        case "getTabBrowser":
+          getter = () => () => this;
+          break;
+        case "isRemoteBrowser":
+          getter = () => browser.getAttribute("remote") == "true";
+          break;
+        case "permitUnload":
+          getter = () => () => ({ permitUnload: true, timedOut: false });
+          break;
+        case "reload":
+        case "reloadWithFlags":
+          getter = () => params => {
+            // Wait for load handler to be instantiated before
+            // initializing the reload.
+            aTab.addEventListener(
+              "SSTabRestoring",
+              () => {
+                browser[name](params);
+              },
+              { once: true }
+            );
+            gBrowser._insertBrowser(aTab);
+          };
+          break;
+        case "resumeMedia":
+          getter = () => () => {
+            // No need to insert a browser, so we just call the browser's
+            // method.
+            aTab.addEventListener(
+              "SSTabRestoring",
+              () => {
+                browser[name]();
+              },
+              { once: true }
+            );
+          };
+          break;
+        case "userTypedValue":
+        case "userTypedClear":
+        case "mediaBlocked":
+          getter = () => SessionStore.getLazyTabValue(aTab, name);
+          break;
+        default:
+          getter = () => {
+            if (AppConstants.NIGHTLY_BUILD) {
+              let message = `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\n`;
+              console.log(message + new Error().stack);
+            }
+            this._insertBrowser(aTab);
+            return browser[name];
+          };
+          setter = value => {
+            if (AppConstants.NIGHTLY_BUILD) {
+              let message = `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\n`;
+              console.log(message + new Error().stack);
+            }
+            this._insertBrowser(aTab);
+            return (browser[name] = value);
+          };
+      }
+      Object.defineProperty(browser, name, {
+        get: getter,
+        set: setter,
+        configurable: true,
+        enumerable: true
+      });
+    }
+  }
+  _insertBrowser(aTab, aInsertedOnTabCreation) {
+    "use strict";
+    // If browser is already inserted or window is closed don't do anything.
+    if (aTab.linkedPanel || window.closed) {
+      return;
+    }
+
+    let browser = aTab.linkedBrowser;
+
+    // If browser is a lazy browser, delete the substitute properties.
+    if (this._browserBindingProperties[0] in browser) {
+      for (let name of this._browserBindingProperties) {
+        delete browser[name];
+      }
+    }
+
+    let {
+      uriIsAboutBlank,
+      remoteType,
+      usingPreloadedContent
+    } = aTab._browserParams;
+    delete aTab._browserParams;
+
+    let notificationbox = this.getNotificationBox(browser);
+    let uniqueId = this._generateUniquePanelID();
+    notificationbox.id = uniqueId;
+    aTab.linkedPanel = uniqueId;
+
+    // Inject the <browser> into the DOM if necessary.
+    if (!notificationbox.parentNode) {
+      // NB: this appendChild call causes us to run constructors for the
+      // browser element, which fires off a bunch of notifications. Some
+      // of those notifications can cause code to run that inspects our
+      // state, so it is important that the tab element is fully
+      // initialized by this point.
+      this.mPanelContainer.appendChild(notificationbox);
+    }
+
+    // wire up a progress listener for the new browser object.
+    let tabListener = this.mTabProgressListener(
+      aTab,
+      browser,
+      uriIsAboutBlank,
+      usingPreloadedContent
+    );
+    const filter = Cc[
+      "@mozilla.org/appshell/component/browser-status-filter;1"
+    ].createInstance(Ci.nsIWebProgress);
+    filter.addProgressListener(tabListener, Ci.nsIWebProgress.NOTIFY_ALL);
+    browser.webProgress.addProgressListener(
+      filter,
+      Ci.nsIWebProgress.NOTIFY_ALL
+    );
+    this._tabListeners.set(aTab, tabListener);
+    this._tabFilters.set(aTab, filter);
+
+    browser.droppedLinkHandler = handleDroppedLink;
+
+    // We start our browsers out as inactive, and then maintain
+    // activeness in the tab switcher.
+    browser.docShellIsActive = false;
+
+    // When addTab() is called with an URL that is not "about:blank" we
+    // set the "nodefaultsrc" attribute that prevents a frameLoader
+    // from being created as soon as the linked <browser> is inserted
+    // into the DOM. We thus have to register the new outerWindowID
+    // for non-remote browsers after we have called browser.loadURI().
+    if (remoteType == E10SUtils.NOT_REMOTE) {
+      this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
+    }
+
+    var evt = new CustomEvent("TabBrowserInserted", {
+      bubbles: true,
+      detail: { insertedOnTabCreation: aInsertedOnTabCreation }
+    });
+    aTab.dispatchEvent(evt);
+  }
+  discardBrowser(aBrowser) {
+    "use strict";
+    let tab = this.getTabForBrowser(aBrowser);
+
+    if (
+      !tab ||
+      tab.selected ||
+      tab.closing ||
+      this._windowIsClosing ||
+      !aBrowser.isConnected ||
+      !aBrowser.isRemoteBrowser ||
+      aBrowser.frameLoader.tabParent.hasBeforeUnload
+    ) {
+      return;
+    }
+
+    // Set browser parameters for when browser is restored.  Also remove
+    // listeners and set up lazy restore data in SessionStore. This must
+    // be done before aBrowser is destroyed and removed from the document.
+    tab._browserParams = {
+      uriIsAboutBlank: aBrowser.currentURI.spec == "about:blank",
+      remoteType: aBrowser.remoteType,
+      usingPreloadedContent: false
+    };
+
+    SessionStore.resetBrowserToLazyState(tab);
+
+    this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);
+
+    // Remove the tab's filter and progress listener.
+    let filter = this._tabFilters.get(tab);
+    let listener = this._tabListeners.get(tab);
+    aBrowser.webProgress.removeProgressListener(filter);
+    filter.removeProgressListener(listener);
+    listener.destroy();
+
+    this._tabListeners.delete(tab);
+    this._tabFilters.delete(tab);
+
+    aBrowser.destroy();
+
+    let notificationbox = this.getNotificationBox(aBrowser);
+    this.mPanelContainer.removeChild(notificationbox);
+    tab.removeAttribute("linkedpanel");
+
+    this._createLazyBrowser(tab);
+  }
+  /* eslint-disable complexity */
+  addTab(
+    aURI,
+    aReferrerURI,
+    aCharset,
+    aPostData,
+    aOwner,
+    aAllowThirdPartyFixup
+  ) {
+    "use strict";
+    const NS_XUL =
+      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    var aTriggeringPrincipal;
+    var aReferrerPolicy;
+    var aFromExternal;
+    var aRelatedToCurrent;
+    var aSkipAnimation;
+    var aAllowMixedContent;
+    var aForceNotRemote;
+    var aPreferredRemoteType;
+    var aNoReferrer;
+    var aUserContextId;
+    var aEventDetail;
+    var aSameProcessAsFrameLoader;
+    var aOriginPrincipal;
+    var aDisallowInheritPrincipal;
+    var aOpener;
+    var aOpenerBrowser;
+    var aIsPrerendered;
+    var aCreateLazyBrowser;
+    var aSkipBackgroundNotify;
+    var aNextTabParentId;
+    var aNoInitialLabel;
+    var aFocusUrlBar;
+    var aName;
+    if (
+      arguments.length == 2 &&
+      typeof arguments[1] == "object" &&
+      !(arguments[1] instanceof Ci.nsIURI)
+    ) {
+      let params = arguments[1];
+      aTriggeringPrincipal = params.triggeringPrincipal;
+      aReferrerURI = params.referrerURI;
+      aReferrerPolicy = params.referrerPolicy;
+      aCharset = params.charset;
+      aPostData = params.postData;
+      aOwner = params.ownerTab;
+      aAllowThirdPartyFixup = params.allowThirdPartyFixup;
+      aFromExternal = params.fromExternal;
+      aRelatedToCurrent = params.relatedToCurrent;
+      aSkipAnimation = params.skipAnimation;
+      aAllowMixedContent = params.allowMixedContent;
+      aForceNotRemote = params.forceNotRemote;
+      aPreferredRemoteType = params.preferredRemoteType;
+      aNoReferrer = params.noReferrer;
+      aUserContextId = params.userContextId;
+      aEventDetail = params.eventDetail;
+      aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;
+      aOriginPrincipal = params.originPrincipal;
+      aDisallowInheritPrincipal = params.disallowInheritPrincipal;
+      aOpener = params.opener;
+      aOpenerBrowser = params.openerBrowser;
+      aIsPrerendered = params.isPrerendered;
+      aCreateLazyBrowser = params.createLazyBrowser;
+      aSkipBackgroundNotify = params.skipBackgroundNotify;
+      aNextTabParentId = params.nextTabParentId;
+      aNoInitialLabel = params.noInitialLabel;
+      aFocusUrlBar = params.focusUrlBar;
+      aName = params.name;
+    }
+
+    // if we're adding tabs, we're past interrupt mode, ditch the owner
+    if (this.mCurrentTab.owner) this.mCurrentTab.owner = null;
+
+    // Find the tab that opened this one, if any. This is used for
+    // determining positioning, and inherited attributes such as the
+    // user context ID.
+    //
+    // If we have a browser opener (which is usually the browser
+    // element from a remote window.open() call), use that.
+    //
+    // Otherwise, if the tab is related to the current tab (e.g.,
+    // because it was opened by a link click), use the selected tab as
+    // the owner. If aReferrerURI is set, and we don't have an
+    // explicit relatedToCurrent arg, we assume that the tab is
+    // related to the current tab, since aReferrerURI is null or
+    // undefined if the tab is opened from an external application or
+    // bookmark (i.e. somewhere other than an existing tab).
+    let relatedToCurrent = aRelatedToCurrent == null
+      ? !!aReferrerURI
+      : aRelatedToCurrent;
+    let openerTab =
+      (aOpenerBrowser && this.getTabForBrowser(aOpenerBrowser)) ||
+      (relatedToCurrent && this.selectedTab);
+
+    var t = document.createElementNS(NS_XUL, "tab");
+
+    t.openerTab = openerTab;
+
+    aURI = aURI || "about:blank";
+    let aURIObject = null;
+    try {
+      aURIObject = Services.io.newURI(aURI);
+    } catch (ex) {
+      /* we'll try to fix up this URL later */
+    }
+
+    let lazyBrowserURI;
+    if (aCreateLazyBrowser && aURI != "about:blank") {
+      lazyBrowserURI = aURIObject;
+      aURI = "about:blank";
+    }
+
+    var uriIsAboutBlank = aURI == "about:blank";
+
+    if (!aNoInitialLabel) {
+      if (isBlankPageURL(aURI)) {
+        t.setAttribute(
+          "label",
+          this.mStringBundle.getString("tabs.emptyTabTitle")
+        );
+      } else {
+        // Set URL as label so that the tab isn't empty initially.
+        this.setInitialTabTitle(t, aURI, { beforeTabOpen: true });
+      }
+    }
+
+    if (aIsPrerendered) {
+      t.setAttribute("hidden", "true");
+    }
+
+    // Related tab inherits current tab's user context unless a different
+    // usercontextid is specified
+    if (aUserContextId == null && openerTab) {
+      aUserContextId = openerTab.getAttribute("usercontextid") || 0;
+    }
+
+    if (aUserContextId) {
+      t.setAttribute("usercontextid", aUserContextId);
+      ContextualIdentityService.setTabStyle(t);
+    }
+
+    t.setAttribute("onerror", "this.removeAttribute('image');");
+
+    if (aSkipBackgroundNotify) {
+      t.setAttribute("skipbackgroundnotify", true);
+    }
+
+    t.className = "tabbrowser-tab";
+
+    this.tabContainer._unlockTabSizing();
+
+    // When overflowing, new tabs are scrolled into view smoothly, which
+    // doesn't go well together with the width transition. So we skip the
+    // transition in that case.
+    let animate =
+      !aSkipAnimation &&
+      this.tabContainer.getAttribute("overflow") != "true" &&
+      this.animationsEnabled;
+    if (!animate) {
+      t.setAttribute("fadein", "true");
+
+      // Call _handleNewTab asynchronously as it needs to know if the
+      // new tab is selected.
+      setTimeout(
+        function(tabContainer) {
+          tabContainer._handleNewTab(t);
+        },
+        0,
+        this.tabContainer
+      );
+    }
+
+    // invalidate cache
+    this._visibleTabs = null;
+
+    this.tabContainer.appendChild(t);
+
+    let usingPreloadedContent = false;
+    let b;
+
+    try {
+      // If this new tab is owned by another, assert that relationship
+      if (aOwner) t.owner = aOwner;
+
+      var position = this.tabs.length - 1;
+      t._tPos = position;
+      this.tabContainer._setPositionalAttributes();
+
+      this.tabContainer.updateVisibility();
+
+      // If we don't have a preferred remote type, and we have a remote
+      // opener, use the opener's remote type.
+      if (!aPreferredRemoteType && aOpenerBrowser) {
+        aPreferredRemoteType = aOpenerBrowser.remoteType;
+      }
+
+      // If URI is about:blank and we don't have a preferred remote type,
+      // then we need to use the referrer, if we have one, to get the
+      // correct remote type for the new tab.
+      if (uriIsAboutBlank && !aPreferredRemoteType && aReferrerURI) {
+        aPreferredRemoteType = E10SUtils.getRemoteTypeForURI(
+          aReferrerURI.spec,
+          gMultiProcessBrowser
+        );
+      }
+
+      let remoteType = aForceNotRemote
+        ? E10SUtils.NOT_REMOTE
+        : E10SUtils.getRemoteTypeForURI(
+            aURI,
+            gMultiProcessBrowser,
+            aPreferredRemoteType
+          );
+
+      // If we open a new tab with the newtab URL in the default
+      // userContext, check if there is a preloaded browser ready.
+      // Private windows are not included because both the label and the
+      // icon for the tab would be set incorrectly (see bug 1195981).
+      if (
+        aURI == BROWSER_NEW_TAB_URL &&
+        !aUserContextId &&
+        !PrivateBrowsingUtils.isWindowPrivate(window)
+      ) {
+        b = this._getPreloadedBrowser();
+        if (b) {
+          usingPreloadedContent = true;
+        }
+      }
+
+      if (!b) {
+        // No preloaded browser found, create one.
+        b = this._createBrowser({
+          remoteType,
+          uriIsAboutBlank,
+          userContextId: aUserContextId,
+          sameProcessAsFrameLoader: aSameProcessAsFrameLoader,
+          openerWindow: aOpener,
+          isPrerendered: aIsPrerendered,
+          nextTabParentId: aNextTabParentId,
+          name: aName
+        });
+      }
+
+      t.linkedBrowser = b;
+
+      if (aFocusUrlBar) {
+        b._urlbarFocused = true;
+      }
+
+      this._tabForBrowser.set(b, t);
+      t.permanentKey = b.permanentKey;
+      t._browserParams = {
+        uriIsAboutBlank,
+        remoteType,
+        usingPreloadedContent
+      };
+
+      // If the caller opts in, create a lazy browser.
+      if (aCreateLazyBrowser) {
+        this._createLazyBrowser(t);
+
+        if (lazyBrowserURI) {
+          // Lazy browser must be explicitly registered so tab will appear as
+          // a switch-to-tab candidate in autocomplete.
+          this._unifiedComplete.registerOpenPage(
+            lazyBrowserURI,
+            aUserContextId
+          );
+          b.registeredOpenURI = lazyBrowserURI;
+        }
+      } else {
+        this._insertBrowser(t, true);
+      }
+    } catch (e) {
+      Cu.reportError("Failed to create tab");
+      Cu.reportError(e);
+      t.remove();
+      if (t.linkedBrowser) {
+        this._tabFilters.delete(t);
+        this._tabListeners.delete(t);
+        let notificationbox = this.getNotificationBox(t.linkedBrowser);
+        notificationbox.remove();
+      }
+      throw e;
+    }
+
+    // Dispatch a new tab notification.  We do this once we're
+    // entirely done, so that things are in a consistent state
+    // even if the event listener opens or closes tabs.
+    var detail = aEventDetail || {};
+    var evt = new CustomEvent("TabOpen", { bubbles: true, detail });
+    t.dispatchEvent(evt);
+
+    if (!usingPreloadedContent && aOriginPrincipal && aURI) {
+      let { URI_INHERITS_SECURITY_CONTEXT } = Ci.nsIProtocolHandler;
+      // Unless we know for sure we're not inheriting principals,
+      // force the about:blank viewer to have the right principal:
+      if (
+        !aURIObject ||
+        doGetProtocolFlags(aURIObject) & URI_INHERITS_SECURITY_CONTEXT
+      ) {
+        b.createAboutBlankContentViewer(aOriginPrincipal);
+      }
+    }
+
+    // If we didn't swap docShells with a preloaded browser
+    // then let's just continue loading the page normally.
+    if (
+      !usingPreloadedContent &&
+      (!uriIsAboutBlank || aDisallowInheritPrincipal)
+    ) {
+      // pretend the user typed this so it'll be available till
+      // the document successfully loads
+      if (aURI && gInitialPages.indexOf(aURI) == -1) b.userTypedValue = aURI;
+
+      let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+      if (aAllowThirdPartyFixup) {
+        flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
+        flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
+      }
+      if (aFromExternal) flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
+      if (aAllowMixedContent)
+        flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_MIXED_CONTENT;
+      if (aDisallowInheritPrincipal)
+        flags |= Ci.nsIWebNavigation.LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL;
+      try {
+        b.loadURIWithFlags(aURI, {
+          flags,
+          triggeringPrincipal: aTriggeringPrincipal,
+          referrerURI: aNoReferrer ? null : aReferrerURI,
+          referrerPolicy: aReferrerPolicy,
+          charset: aCharset,
+          postData: aPostData
+        });
+      } catch (ex) {
+        Cu.reportError(ex);
+      }
+    }
+
+    // If we're opening a tab related to the an existing tab, move it
+    // to a position after that tab.
+    if (
+      openerTab &&
+      Services.prefs.getBoolPref("browser.tabs.insertRelatedAfterCurrent")
+    ) {
+      let lastRelatedTab = this._lastRelatedTabMap.get(openerTab);
+      let newTabPos = (lastRelatedTab || openerTab)._tPos + 1;
+      if (lastRelatedTab) lastRelatedTab.owner = null;
+      else t.owner = openerTab;
+      this.moveTabTo(t, newTabPos, true);
+      this._lastRelatedTabMap.set(openerTab, t);
+    }
+
+    // This field is updated regardless if we actually animate
+    // since it's important that we keep this count correct in all cases.
+    this.tabAnimationsInProgress++;
+
+    if (animate) {
+      requestAnimationFrame(function() {
+        // kick the animation off
+        t.setAttribute("fadein", "true");
+      });
+    }
+
+    return t;
+  }
+  warnAboutClosingTabs(aCloseTabs, aTab) {
+    var tabsToClose;
+    switch (aCloseTabs) {
+      case this.closingTabsEnum.ALL:
+        tabsToClose =
+          this.tabs.length -
+          this._removingTabs.length -
+          gBrowser._numPinnedTabs;
+        break;
+      case this.closingTabsEnum.OTHER:
+        tabsToClose = this.visibleTabs.length - 1 - gBrowser._numPinnedTabs;
+        break;
+      case this.closingTabsEnum.TO_END:
+        if (!aTab) throw new Error("Required argument missing: aTab");
+
+        tabsToClose = this.getTabsToTheEndFrom(aTab).length;
+        break;
+      default:
+        throw new Error("Invalid argument: " + aCloseTabs);
+    }
+
+    if (tabsToClose <= 1) return true;
+
+    const pref = aCloseTabs == this.closingTabsEnum.ALL
+      ? "browser.tabs.warnOnClose"
+      : "browser.tabs.warnOnCloseOtherTabs";
+    var shouldPrompt = Services.prefs.getBoolPref(pref);
+    if (!shouldPrompt) return true;
+
+    var ps = Services.prompt;
+
+    // default to true: if it were false, we wouldn't get this far
+    var warnOnClose = { value: true };
+    var bundle = this.mStringBundle;
+
+    // focus the window before prompting.
+    // this will raise any minimized window, which will
+    // make it obvious which window the prompt is for and will
+    // solve the problem of windows "obscuring" the prompt.
+    // see bug #350299 for more details
+    window.focus();
+    var warningMessage = PluralForm.get(
+      tabsToClose,
+      bundle.getString("tabs.closeWarningMultiple")
+    ).replace("#1", tabsToClose);
+    var buttonPressed = ps.confirmEx(
+      window,
+      bundle.getString("tabs.closeWarningTitle"),
+      warningMessage,
+      ps.BUTTON_TITLE_IS_STRING * ps.BUTTON_POS_0 +
+        ps.BUTTON_TITLE_CANCEL * ps.BUTTON_POS_1,
+      bundle.getString("tabs.closeButtonMultiple"),
+      null,
+      null,
+      aCloseTabs == this.closingTabsEnum.ALL
+        ? bundle.getString("tabs.closeWarningPromptMe")
+        : null,
+      warnOnClose
+    );
+    var reallyClose = buttonPressed == 0;
+
+    // don't set the pref unless they press OK and it's false
+    if (
+      aCloseTabs == this.closingTabsEnum.ALL &&
+      reallyClose &&
+      !warnOnClose.value
+    )
+      Services.prefs.setBoolPref(pref, false);
+
+    return reallyClose;
+  }
+  getTabsToTheEndFrom(aTab) {
+    var tabsToEnd = [];
+    let tabs = this.visibleTabs;
+    for (let i = tabs.length - 1; tabs[i] != aTab && i >= 0; --i) {
+      tabsToEnd.push(tabs[i]);
+    }
+    return tabsToEnd;
+  }
+  removeTabsToTheEndFrom(aTab, aParams) {
+    if (!this.warnAboutClosingTabs(this.closingTabsEnum.TO_END, aTab)) return;
+
+    let removeTab = tab => {
+      // Avoid changing the selected browser several times.
+      if (tab.selected) this.selectedTab = aTab;
+
+      this.removeTab(tab, aParams);
+    };
+
+    let tabs = this.getTabsToTheEndFrom(aTab);
+    let tabsWithBeforeUnload = [];
+    for (let i = tabs.length - 1; i >= 0; --i) {
+      let tab = tabs[i];
+      if (this._hasBeforeUnload(tab)) tabsWithBeforeUnload.push(tab);
+      else removeTab(tab);
+    }
+    tabsWithBeforeUnload.forEach(removeTab);
+  }
+  removeAllTabsBut(aTab) {
+    if (aTab.pinned || !this.warnAboutClosingTabs(this.closingTabsEnum.OTHER))
+      return;
+
+    let tabs = this.visibleTabs.reverse();
+    this.selectedTab = aTab;
+
+    let tabsWithBeforeUnload = [];
+    for (let i = tabs.length - 1; i >= 0; --i) {
+      let tab = tabs[i];
+      if (tab != aTab && !tab.pinned) {
+        if (this._hasBeforeUnload(tab)) tabsWithBeforeUnload.push(tab);
+        else this.removeTab(tab, { animate: true });
+      }
+    }
+    for (let tab of tabsWithBeforeUnload) {
+      this.removeTab(tab, { animate: true });
+    }
+  }
+  removeCurrentTab(aParams) {
+    this.removeTab(this.mCurrentTab, aParams);
+  }
+  removeTab(aTab, aParams) {
+    if (aParams) {
+      var animate = aParams.animate;
+      var byMouse = aParams.byMouse;
+      var skipPermitUnload = aParams.skipPermitUnload;
+    }
+
+    // Telemetry stopwatches may already be running if removeTab gets
+    // called again for an already closing tab.
+    if (
+      !TelemetryStopwatch.running("FX_TAB_CLOSE_TIME_ANIM_MS", aTab) &&
+      !TelemetryStopwatch.running("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab)
+    ) {
+      // Speculatevely start both stopwatches now. We'll cancel one of
+      // the two later depending on whether we're animating.
+      TelemetryStopwatch.start("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
+      TelemetryStopwatch.start("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
+    }
+    window.maybeRecordAbandonmentTelemetry(aTab, "tabClosed");
+
+    // Handle requests for synchronously removing an already
+    // asynchronously closing tab.
+    if (!animate && aTab.closing) {
+      this._endRemoveTab(aTab);
+      return;
+    }
+
+    var isLastTab = this.tabs.length - this._removingTabs.length == 1;
+
+    if (!this._beginRemoveTab(aTab, null, null, true, skipPermitUnload)) {
+      TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
+      TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
+      return;
+    }
+
+    if (!aTab.pinned && !aTab.hidden && aTab._fullyOpen && byMouse)
+      this.tabContainer._lockTabSizing(aTab);
+    else this.tabContainer._unlockTabSizing();
+
+    if (
+      !animate /* the caller didn't opt in */ ||
+      isLastTab ||
+      aTab.pinned ||
+      aTab.hidden ||
+      this._removingTabs.length >
+        3 /* don't want lots of concurrent animations */ ||
+      aTab.getAttribute("fadein") !=
+        "true" /* fade-in transition hasn't been triggered yet */ ||
+      window.getComputedStyle(aTab).maxWidth ==
+        "0.1px" /* fade-in transition hasn't moved yet */ ||
+      !this.animationsEnabled
+    ) {
+      // We're not animating, so we can cancel the animation stopwatch.
+      TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
+      this._endRemoveTab(aTab);
+      return;
+    }
+
+    // We're animating, so we can cancel the non-animation stopwatch.
+    TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
+
+    aTab.style.maxWidth = ""; // ensure that fade-out transition happens
+    aTab.removeAttribute("fadein");
+    aTab.removeAttribute("bursting");
+
+    setTimeout(
+      function(tab, tabbrowser) {
+        if (
+          tab.parentNode &&
+          window.getComputedStyle(tab).maxWidth == "0.1px"
+        ) {
+          NS_ASSERT(
+            false,
+            "Giving up waiting for the tab closing animation to finish (bug 608589)"
+          );
+          tabbrowser._endRemoveTab(tab);
+        }
+      },
+      3000,
+      aTab,
+      this
+    );
+  }
+  _hasBeforeUnload(aTab) {
+    let browser = aTab.linkedBrowser;
+    return (
+      browser.isRemoteBrowser &&
+      browser.frameLoader &&
+      browser.frameLoader.tabParent &&
+      browser.frameLoader.tabParent.hasBeforeUnload
+    );
+  }
+  _beginRemoveTab(
+    aTab,
+    aAdoptedByTab,
+    aCloseWindowWithLastTab,
+    aCloseWindowFastpath,
+    aSkipPermitUnload
+  ) {
+    if (aTab.closing || this._windowIsClosing) return false;
+
+    var browser = this.getBrowserForTab(aTab);
+    if (
+      !aSkipPermitUnload &&
+      !aAdoptedByTab &&
+      aTab.linkedPanel &&
+      !aTab._pendingPermitUnload &&
+      (!browser.isRemoteBrowser || this._hasBeforeUnload(aTab))
+    ) {
+      TelemetryStopwatch.start("FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS", aTab);
+
+      // We need to block while calling permitUnload() because it
+      // processes the event queue and may lead to another removeTab()
+      // call before permitUnload() returns.
+      aTab._pendingPermitUnload = true;
+      let { permitUnload, timedOut } = browser.permitUnload();
+      delete aTab._pendingPermitUnload;
+
+      TelemetryStopwatch.finish("FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS", aTab);
+
+      // If we were closed during onbeforeunload, we return false now
+      // so we don't (try to) close the same tab again. Of course, we
+      // also stop if the unload was cancelled by the user:
+      if (aTab.closing || (!timedOut && !permitUnload)) {
+        return false;
+      }
+    }
+
+    this._blurTab(aTab);
+
+    var closeWindow = false;
+    var newTab = false;
+    if (this.tabs.length - this._removingTabs.length == 1) {
+      closeWindow = aCloseWindowWithLastTab != null
+        ? aCloseWindowWithLastTab
+        : !window.toolbar.visible ||
+            Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab");
+
+      if (closeWindow) {
+        // We've already called beforeunload on all the relevant tabs if we get here,
+        // so avoid calling it again:
+        window.skipNextCanClose = true;
+      }
+
+      // Closing the tab and replacing it with a blank one is notably slower
+      // than closing the window right away. If the caller opts in, take
+      // the fast path.
+      if (
+        closeWindow &&
+        aCloseWindowFastpath &&
+        this._removingTabs.length == 0
+      ) {
+        // This call actually closes the window, unless the user
+        // cancels the operation.  We are finished here in both cases.
+        this._windowIsClosing = window.closeWindow(
+          true,
+          window.warnAboutClosingWindow
+        );
+        return false;
+      }
+
+      newTab = true;
+    }
+    aTab._endRemoveArgs = [closeWindow, newTab];
+
+    // swapBrowsersAndCloseOther will take care of closing the window without animation.
+    if (closeWindow && aAdoptedByTab) {
+      // Remove the tab's filter to avoid leaking.
+      if (aTab.linkedPanel) {
+        this._tabFilters.delete(aTab);
+      }
+      return true;
+    }
+
+    if (!aTab._fullyOpen) {
+      // If the opening tab animation hasn't finished before we start closing the
+      // tab, decrement the animation count since _handleNewTab will not get called.
+      this.tabAnimationsInProgress--;
+    }
+
+    this.tabAnimationsInProgress++;
+
+    // Mute audio immediately to improve perceived speed of tab closure.
+    if (!aAdoptedByTab && aTab.hasAttribute("soundplaying")) {
+      // Don't persist the muted state as this wasn't a user action.
+      // This lets undo-close-tab return it to an unmuted state.
+      aTab.linkedBrowser.mute(true);
+    }
+
+    aTab.closing = true;
+    this._removingTabs.push(aTab);
+    this._visibleTabs = null; // invalidate cache
+
+    // Invalidate hovered tab state tracking for this closing tab.
+    if (this.tabContainer._hoveredTab == aTab) aTab._mouseleave();
+
+    if (newTab) this.addTab(BROWSER_NEW_TAB_URL, { skipAnimation: true });
+    else this.tabContainer.updateVisibility();
+
+    // We're committed to closing the tab now.
+    // Dispatch a notification.
+    // We dispatch it before any teardown so that event listeners can
+    // inspect the tab that's about to close.
+    var evt = new CustomEvent("TabClose", {
+      bubbles: true,
+      detail: { adoptedBy: aAdoptedByTab }
+    });
+    aTab.dispatchEvent(evt);
+
+    if (aTab.linkedPanel) {
+      if (!aAdoptedByTab && !gMultiProcessBrowser) {
+        // Prevent this tab from showing further dialogs, since we're closing it
+        var windowUtils = browser.contentWindow
+          .QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIDOMWindowUtils);
+        windowUtils.disableDialogs();
+      }
+
+      // Remove the tab's filter and progress listener.
+      const filter = this._tabFilters.get(aTab);
+
+      browser.webProgress.removeProgressListener(filter);
+
+      const listener = this._tabListeners.get(aTab);
+      filter.removeProgressListener(listener);
+      listener.destroy();
+    }
+
+    if (browser.registeredOpenURI && !aAdoptedByTab) {
+      this._unifiedComplete.unregisterOpenPage(
+        browser.registeredOpenURI,
+        browser.getAttribute("usercontextid") || 0
+      );
+      delete browser.registeredOpenURI;
+    }
+
+    // We are no longer the primary content area.
+    browser.removeAttribute("primary");
+
+    // Remove this tab as the owner of any other tabs, since it's going away.
+    for (let tab of this.tabs) {
+      if ("owner" in tab && tab.owner == aTab)
+        // |tab| is a child of the tab we're removing, make it an orphan
+        tab.owner = null;
+    }
+
+    return true;
+  }
+  _endRemoveTab(aTab) {
+    if (!aTab || !aTab._endRemoveArgs) return;
+
+    var [aCloseWindow, aNewTab] = aTab._endRemoveArgs;
+    aTab._endRemoveArgs = null;
+
+    if (this._windowIsClosing) {
+      aCloseWindow = false;
+      aNewTab = false;
+    }
+
+    this.tabAnimationsInProgress--;
+
+    this._lastRelatedTabMap = new WeakMap();
+
+    // update the UI early for responsiveness
+    aTab.collapsed = true;
+    this._blurTab(aTab);
+
+    this._removingTabs.splice(this._removingTabs.indexOf(aTab), 1);
+
+    if (aCloseWindow) {
+      this._windowIsClosing = true;
+      while (this._removingTabs.length)
+        this._endRemoveTab(this._removingTabs[0]);
+    } else if (!this._windowIsClosing) {
+      if (aNewTab) focusAndSelectUrlBar();
+
+      // workaround for bug 345399
+      this.tabContainer.mTabstrip._updateScrollButtonsDisabledState();
+    }
+
+    // We're going to remove the tab and the browser now.
+    this._tabFilters.delete(aTab);
+    this._tabListeners.delete(aTab);
+
+    var browser = this.getBrowserForTab(aTab);
+
+    if (aTab.linkedPanel) {
+      this._outerWindowIDBrowserMap.delete(browser.outerWindowID);
+
+      // Because of the way XBL works (fields just set JS
+      // properties on the element) and the code we have in place
+      // to preserve the JS objects for any elements that have
+      // JS properties set on them, the browser element won't be
+      // destroyed until the document goes away.  So we force a
+      // cleanup ourselves.
+      // This has to happen before we remove the child so that the
+      // XBL implementation of nsIObserver still works.
+      browser.destroy();
+    }
+
+    var wasPinned = aTab.pinned;
+
+    // Remove the tab ...
+    this.tabContainer.removeChild(aTab);
+
+    // ... and fix up the _tPos properties immediately.
+    for (let i = aTab._tPos; i < this.tabs.length; i++) this.tabs[i]._tPos = i;
+
+    if (!this._windowIsClosing) {
+      if (wasPinned) this.tabContainer._positionPinnedTabs();
+
+      // update tab close buttons state
+      this.tabContainer.adjustTabstrip();
+
+      setTimeout(
+        function(tabs) {
+          tabs._lastTabClosedByMouse = false;
+        },
+        0,
+        this.tabContainer
+      );
+    }
+
+    // update tab positional properties and attributes
+    this.selectedTab._selected = true;
+    this.tabContainer._setPositionalAttributes();
+
+    // Removing the panel requires fixing up selectedPanel immediately
+    // (see below), which would be hindered by the potentially expensive
+    // browser removal. So we remove the browser and the panel in two
+    // steps.
+
+    var panel = this.getNotificationBox(browser);
+
+    // In the multi-process case, it's possible an asynchronous tab switch
+    // is still underway. If so, then it's possible that the last visible
+    // browser is the one we're in the process of removing. There's the
+    // risk of displaying preloaded browsers that are at the end of the
+    // deck if we remove the browser before the switch is complete, so
+    // we alert the switcher in order to show a spinner instead.
+    if (this._switcher) {
+      this._switcher.onTabRemoved(aTab);
+    }
+
+    // This will unload the document. An unload handler could remove
+    // dependant tabs, so it's important that the tabbrowser is now in
+    // a consistent state (tab removed, tab positions updated, etc.).
+    browser.remove();
+
+    // Release the browser in case something is erroneously holding a
+    // reference to the tab after its removal.
+    this._tabForBrowser.delete(aTab.linkedBrowser);
+    aTab.linkedBrowser = null;
+
+    panel.remove();
+
+    // closeWindow might wait an arbitrary length of time if we're supposed
+    // to warn about closing the window, so we'll just stop the tab close
+    // stopwatches here instead.
+    TelemetryStopwatch.finish(
+      "FX_TAB_CLOSE_TIME_ANIM_MS",
+      aTab,
+      true /* aCanceledOkay */
+    );
+    TelemetryStopwatch.finish(
+      "FX_TAB_CLOSE_TIME_NO_ANIM_MS",
+      aTab,
+      true /* aCanceledOkay */
+    );
+
+    if (aCloseWindow)
+      this._windowIsClosing = closeWindow(true, window.warnAboutClosingWindow);
+  }
+  _blurTab(aTab) {
+    if (!aTab.selected) return;
+
+    if (
+      aTab.owner &&
+      !aTab.owner.hidden &&
+      !aTab.owner.closing &&
+      Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")
+    ) {
+      this.selectedTab = aTab.owner;
+      return;
+    }
+
+    // Switch to a visible tab unless there aren't any others remaining
+    let remainingTabs = this.visibleTabs;
+    let numTabs = remainingTabs.length;
+    if (numTabs == 0 || (numTabs == 1 && remainingTabs[0] == aTab)) {
+      remainingTabs = Array.filter(
+        this.tabs,
+        function(tab) {
+          return !tab.closing;
+        },
+        this
+      );
+    }
+
+    // Try to find a remaining tab that comes after the given tab
+    var tab = aTab;
+    do {
+      tab = tab.nextSibling;
+    } while (tab && remainingTabs.indexOf(tab) == -1);
+
+    if (!tab) {
+      tab = aTab;
+
+      do {
+        tab = tab.previousSibling;
+      } while (tab && remainingTabs.indexOf(tab) == -1);
+    }
+
+    this.selectedTab = tab;
+  }
+  swapBrowsersAndCloseOther(aOurTab, aOtherTab) {
+    // Do not allow transfering a private tab to a non-private window
+    // and vice versa.
+    if (
+      PrivateBrowsingUtils.isWindowPrivate(window) !=
+      PrivateBrowsingUtils.isWindowPrivate(aOtherTab.ownerGlobal)
+    )
+      return;
+
+    let ourBrowser = this.getBrowserForTab(aOurTab);
+    let otherBrowser = aOtherTab.linkedBrowser;
+
+    // Can't swap between chrome and content processes.
+    if (ourBrowser.isRemoteBrowser != otherBrowser.isRemoteBrowser) return;
+
+    // Keep the userContextId if set on other browser
+    if (otherBrowser.hasAttribute("usercontextid")) {
+      ourBrowser.setAttribute(
+        "usercontextid",
+        otherBrowser.getAttribute("usercontextid")
+      );
+    }
+
+    // That's gBrowser for the other window, not the tab's browser!
+    var remoteBrowser = aOtherTab.ownerGlobal.gBrowser;
+    var isPending = aOtherTab.hasAttribute("pending");
+
+    let otherTabListener = remoteBrowser._tabListeners.get(aOtherTab);
+    let stateFlags = otherTabListener.mStateFlags;
+
+    // Expedite the removal of the icon if it was already scheduled.
+    if (aOtherTab._soundPlayingAttrRemovalTimer) {
+      clearTimeout(aOtherTab._soundPlayingAttrRemovalTimer);
+      aOtherTab._soundPlayingAttrRemovalTimer = 0;
+      aOtherTab.removeAttribute("soundplaying");
+      remoteBrowser._tabAttrModified(aOtherTab, ["soundplaying"]);
+    }
+
+    // First, start teardown of the other browser.  Make sure to not
+    // fire the beforeunload event in the process.  Close the other
+    // window if this was its last tab.
+    if (!remoteBrowser._beginRemoveTab(aOtherTab, aOurTab, true)) return;
+
+    // If this is the last tab of the window, hide the window
+    // immediately without animation before the docshell swap, to avoid
+    // about:blank being painted.
+    let [closeWindow] = aOtherTab._endRemoveArgs;
+    if (closeWindow) {
+      let win = aOtherTab.ownerGlobal;
+      let dwu = win
+        .QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIDOMWindowUtils);
+      dwu.suppressAnimation(true);
+      // Only suppressing window animations isn't enough to avoid
+      // an empty content area being painted.
+      let baseWin = win
+        .QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIDocShell)
+        .QueryInterface(Ci.nsIDocShellTreeItem)
+        .treeOwner.QueryInterface(Ci.nsIBaseWindow);
+      baseWin.visibility = false;
+    }
+
+    let modifiedAttrs = [];
+    if (aOtherTab.hasAttribute("muted")) {
+      aOurTab.setAttribute("muted", "true");
+      aOurTab.muteReason = aOtherTab.muteReason;
+      ourBrowser.mute();
+      modifiedAttrs.push("muted");
+    }
+    if (aOtherTab.hasAttribute("soundplaying")) {
+      aOurTab.setAttribute("soundplaying", "true");
+      modifiedAttrs.push("soundplaying");
+    }
+    if (aOtherTab.hasAttribute("usercontextid")) {
+      aOurTab.setUserContextId(aOtherTab.getAttribute("usercontextid"));
+      modifiedAttrs.push("usercontextid");
+    }
+    if (aOtherTab.hasAttribute("sharing")) {
+      aOurTab.setAttribute("sharing", aOtherTab.getAttribute("sharing"));
+      modifiedAttrs.push("sharing");
+      aOurTab._sharingState = aOtherTab._sharingState;
+      webrtcUI.swapBrowserForNotification(otherBrowser, ourBrowser);
+    }
+
+    SitePermissions.copyTemporaryPermissions(otherBrowser, ourBrowser);
+
+    // If the other tab is pending (i.e. has not been restored, yet)
+    // then do not switch docShells but retrieve the other tab's state
+    // and apply it to our tab.
+    if (isPending) {
+      SessionStore.setTabState(aOurTab, SessionStore.getTabState(aOtherTab));
+
+      // Make sure to unregister any open URIs.
+      this._swapRegisteredOpenURIs(ourBrowser, otherBrowser);
+    } else {
+      // Workarounds for bug 458697
+      // Icon might have been set on DOMLinkAdded, don't override that.
+      if (!ourBrowser.mIconURL && otherBrowser.mIconURL)
+        this.setIcon(
+          aOurTab,
+          otherBrowser.mIconURL,
+          otherBrowser.contentPrincipal,
+          otherBrowser.contentRequestContextID
+        );
+      var isBusy = aOtherTab.hasAttribute("busy");
+      if (isBusy) {
+        aOurTab.setAttribute("busy", "true");
+        modifiedAttrs.push("busy");
+        if (aOurTab.selected) this.mIsBusy = true;
+      }
+
+      this._swapBrowserDocShells(
+        aOurTab,
+        otherBrowser,
+        Ci.nsIBrowser.SWAP_DEFAULT,
+        stateFlags
+      );
+    }
+
+    // Unregister the previously opened URI
+    if (otherBrowser.registeredOpenURI) {
+      this._unifiedComplete.unregisterOpenPage(
+        otherBrowser.registeredOpenURI,
+        otherBrowser.getAttribute("usercontextid") || 0
+      );
+      delete otherBrowser.registeredOpenURI;
+    }
+
+    // Handle findbar data (if any)
+    let otherFindBar = aOtherTab._findBar;
+    if (otherFindBar && otherFindBar.findMode == otherFindBar.FIND_NORMAL) {
+      let ourFindBar = this.getFindBar(aOurTab);
+      ourFindBar._findField.value = otherFindBar._findField.value;
+      if (!otherFindBar.hidden) ourFindBar.onFindCommand();
+    }
+
+    // Finish tearing down the tab that's going away.
+    if (closeWindow) {
+      aOtherTab.ownerGlobal.close();
+    } else {
+      remoteBrowser._endRemoveTab(aOtherTab);
+    }
+
+    this.setTabTitle(aOurTab);
+
+    // If the tab was already selected (this happpens in the scenario
+    // of replaceTabWithWindow), notify onLocationChange, etc.
+    if (aOurTab.selected) this.updateCurrentBrowser(true);
+
+    if (modifiedAttrs.length) {
+      this._tabAttrModified(aOurTab, modifiedAttrs);
+    }
+  }
+  swapBrowsers(aOurTab, aOtherTab, aFlags) {
+    let otherBrowser = aOtherTab.linkedBrowser;
+    let otherTabBrowser = otherBrowser.getTabBrowser();
+
+    // We aren't closing the other tab so, we also need to swap its tablisteners.
+    let filter = otherTabBrowser._tabFilters.get(aOtherTab);
+    let tabListener = otherTabBrowser._tabListeners.get(aOtherTab);
+    otherBrowser.webProgress.removeProgressListener(filter);
+    filter.removeProgressListener(tabListener);
+
+    // Perform the docshell swap through the common mechanism.
+    this._swapBrowserDocShells(aOurTab, otherBrowser, aFlags);
+
+    // Restore the listeners for the swapped in tab.
+    tabListener = otherTabBrowser.mTabProgressListener(
+      aOtherTab,
+      otherBrowser,
+      false,
+      false
+    );
+    otherTabBrowser._tabListeners.set(aOtherTab, tabListener);
+
+    const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
+    filter.addProgressListener(tabListener, notifyAll);
+    otherBrowser.webProgress.addProgressListener(filter, notifyAll);
+  }
+  _swapBrowserDocShells(aOurTab, aOtherBrowser, aFlags, aStateFlags) {
+    // aOurTab's browser needs to be inserted now if it hasn't already.
+    this._insertBrowser(aOurTab);
+
+    // Unhook our progress listener
+    const filter = this._tabFilters.get(aOurTab);
+    let tabListener = this._tabListeners.get(aOurTab);
+    let ourBrowser = this.getBrowserForTab(aOurTab);
+    ourBrowser.webProgress.removeProgressListener(filter);
+    filter.removeProgressListener(tabListener);
+
+    // Make sure to unregister any open URIs.
+    this._swapRegisteredOpenURIs(ourBrowser, aOtherBrowser);
+
+    // Unmap old outerWindowIDs.
+    this._outerWindowIDBrowserMap.delete(ourBrowser.outerWindowID);
+    let remoteBrowser = aOtherBrowser.ownerGlobal.gBrowser;
+    if (remoteBrowser) {
+      remoteBrowser._outerWindowIDBrowserMap.delete(
+        aOtherBrowser.outerWindowID
+      );
+    }
+
+    // If switcher is active, it will intercept swap events and
+    // react as needed.
+    if (!this._switcher) {
+      aOtherBrowser.docShellIsActive = this.shouldActivateDocShell(ourBrowser);
+    }
+
+    // Swap the docshells
+    ourBrowser.swapDocShells(aOtherBrowser);
+
+    if (ourBrowser.isRemoteBrowser) {
+      // Switch outerWindowIDs for remote browsers.
+      let ourOuterWindowID = ourBrowser._outerWindowID;
+      ourBrowser._outerWindowID = aOtherBrowser._outerWindowID;
+      aOtherBrowser._outerWindowID = ourOuterWindowID;
+    }
+
+    // Register new outerWindowIDs.
+    this._outerWindowIDBrowserMap.set(ourBrowser.outerWindowID, ourBrowser);
+    if (remoteBrowser) {
+      remoteBrowser._outerWindowIDBrowserMap.set(
+        aOtherBrowser.outerWindowID,
+        aOtherBrowser
+      );
+    }
+
+    if (!(aFlags & Ci.nsIBrowser.SWAP_KEEP_PERMANENT_KEY)) {
+      // Swap permanentKey properties.
+      let ourPermanentKey = ourBrowser.permanentKey;
+      ourBrowser.permanentKey = aOtherBrowser.permanentKey;
+      aOtherBrowser.permanentKey = ourPermanentKey;
+      aOurTab.permanentKey = ourBrowser.permanentKey;
+      if (remoteBrowser) {
+        let otherTab = remoteBrowser.getTabForBrowser(aOtherBrowser);
+        if (otherTab) {
+          otherTab.permanentKey = aOtherBrowser.permanentKey;
+        }
+      }
+    }
+
+    // Restore the progress listener
+    tabListener = this.mTabProgressListener(
+      aOurTab,
+      ourBrowser,
+      false,
+      false,
+      aStateFlags
+    );
+    this._tabListeners.set(aOurTab, tabListener);
+
+    const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
+    filter.addProgressListener(tabListener, notifyAll);
+    ourBrowser.webProgress.addProgressListener(filter, notifyAll);
+  }
+  _swapRegisteredOpenURIs(aOurBrowser, aOtherBrowser) {
+    // Swap the registeredOpenURI properties of the two browsers
+    let tmp = aOurBrowser.registeredOpenURI;
+    delete aOurBrowser.registeredOpenURI;
+    if (aOtherBrowser.registeredOpenURI) {
+      aOurBrowser.registeredOpenURI = aOtherBrowser.registeredOpenURI;
+      delete aOtherBrowser.registeredOpenURI;
+    }
+    if (tmp) {
+      aOtherBrowser.registeredOpenURI = tmp;
+    }
+  }
+  reloadAllTabs() {
+    let tabs = this.visibleTabs;
+    let l = tabs.length;
+    for (var i = 0; i < l; i++) {
+      try {
+        this.getBrowserForTab(tabs[i]).reload();
+      } catch (e) {
+        // ignore failure to reload so others will be reloaded
+      }
+    }
+  }
+  reloadTab(aTab) {
+    let browser = this.getBrowserForTab(aTab);
+    // Reset temporary permissions on the current tab. This is done here
+    // because we only want to reset permissions on user reload.
+    SitePermissions.clearTemporaryPermissions(browser);
+    browser.reload();
+  }
+  addProgressListener(aListener) {
+    if (arguments.length != 1) {
+      Components.utils.reportError(
+        "gBrowser.addProgressListener was " +
+          "called with a second argument, " +
+          "which is not supported. See bug " +
+          "608628. Call stack: " +
+          new Error().stack
+      );
+    }
+
+    this.mProgressListeners.push(aListener);
+  }
+  removeProgressListener(aListener) {
+    this.mProgressListeners = this.mProgressListeners.filter(
+      l => l != aListener
+    );
+  }
+  addTabsProgressListener(aListener) {
+    this.mTabsProgressListeners.push(aListener);
+  }
+  removeTabsProgressListener(aListener) {
+    this.mTabsProgressListeners = this.mTabsProgressListeners.filter(
+      l => l != aListener
+    );
+  }
+  getBrowserForTab(aTab) {
+    return aTab.linkedBrowser;
+  }
+  showOnlyTheseTabs(aTabs) {
+    for (let tab of this.tabs) {
+      if (aTabs.indexOf(tab) == -1) this.hideTab(tab);
+      else this.showTab(tab);
+    }
+
+    this.tabContainer._handleTabSelect(true);
+  }
+  showTab(aTab) {
+    if (aTab.hidden) {
+      aTab.removeAttribute("hidden");
+      this._visibleTabs = null; // invalidate cache
+
+      this.tabContainer.adjustTabstrip();
+
+      this.tabContainer._setPositionalAttributes();
+
+      let event = document.createEvent("Events");
+      event.initEvent("TabShow", true, false);
+      aTab.dispatchEvent(event);
+    }
+  }
+  hideTab(aTab) {
+    if (!aTab.hidden && !aTab.pinned && !aTab.selected && !aTab.closing) {
+      aTab.setAttribute("hidden", "true");
+      this._visibleTabs = null; // invalidate cache
+
+      this.tabContainer.adjustTabstrip();
+
+      this.tabContainer._setPositionalAttributes();
+
+      let event = document.createEvent("Events");
+      event.initEvent("TabHide", true, false);
+      aTab.dispatchEvent(event);
+    }
+  }
+  selectTabAtIndex(aIndex, aEvent) {
+    let tabs = this.visibleTabs;
+
+    // count backwards for aIndex < 0
+    if (aIndex < 0) {
+      aIndex += tabs.length;
+      // clamp at index 0 if still negative.
+      if (aIndex < 0) aIndex = 0;
+    } else if (aIndex >= tabs.length) {
+      // clamp at right-most tab if out of range.
+      aIndex = tabs.length - 1;
+    }
+
+    this.selectedTab = tabs[aIndex];
+
+    if (aEvent) {
+      aEvent.preventDefault();
+      aEvent.stopPropagation();
+    }
+  }
+  replaceTabWithWindow(aTab, aOptions) {
+    if (this.tabs.length == 1) return null;
+
+    var options = "chrome,dialog=no,all";
+    for (var name in aOptions) options += "," + name + "=" + aOptions[name];
+
+    // Play the tab closing animation to give immediate feedback while
+    // waiting for the new window to appear.
+    // content area when the docshells are swapped.
+    if (this.animationsEnabled) {
+      aTab.style.maxWidth = ""; // ensure that fade-out transition happens
+      aTab.removeAttribute("fadein");
+    }
+
+    // tell a new window to take the "dropped" tab
+    return window.openDialog(getBrowserURL(), "_blank", options, aTab);
+  }
+  openNonRemoteWindow(aTab) {
+    if (!AppConstants.E10S_TESTING_ONLY) {
+      throw "This method is intended only for e10s testing!";
+    }
+    let url = aTab.linkedBrowser.currentURI.spec;
+    return window.openDialog(
+      "chrome://browser/content/",
+      "_blank",
+      "chrome,all,dialog=no,non-remote",
+      url
+    );
+  }
+  moveTabTo(aTab, aIndex, aKeepRelatedTabs) {
+    var oldPosition = aTab._tPos;
+    if (oldPosition == aIndex) return;
+
+    // Don't allow mixing pinned and unpinned tabs.
+    if (aTab.pinned) aIndex = Math.min(aIndex, this._numPinnedTabs - 1);
+    else aIndex = Math.max(aIndex, this._numPinnedTabs);
+    if (oldPosition == aIndex) return;
+
+    if (!aKeepRelatedTabs) {
+      this._lastRelatedTabMap = new WeakMap();
+    }
+
+    let wasFocused = document.activeElement == this.mCurrentTab;
+
+    aIndex = aIndex < aTab._tPos ? aIndex : aIndex + 1;
+
+    // invalidate cache
+    this._visibleTabs = null;
+
+    // use .item() instead of [] because dragging to the end of the strip goes out of
+    // bounds: .item() returns null (so it acts like appendChild), but [] throws
+    this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));
+
+    for (let i = 0; i < this.tabs.length; i++) {
+      this.tabs[i]._tPos = i;
+      this.tabs[i]._selected = false;
+    }
+
+    // If we're in the midst of an async tab switch while calling
+    // moveTabTo, we can get into a case where _visuallySelected
+    // is set to true on two different tabs.
+    //
+    // What we want to do in moveTabTo is to remove logical selection
+    // from all tabs, and then re-add logical selection to mCurrentTab
+    // (and visual selection as well if we're not running with e10s, which
+    // setting _selected will do automatically).
+    //
+    // If we're running with e10s, then the visual selection will not
+    // be changed, which is fine, since if we weren't in the midst of a
+    // tab switch, the previously visually selected tab should still be
+    // correct, and if we are in the midst of a tab switch, then the async
+    // tab switcher will set the visually selected tab once the tab switch
+    // has completed.
+    this.mCurrentTab._selected = true;
+
+    if (wasFocused) this.mCurrentTab.focus();
+
+    this.tabContainer._handleTabSelect(true);
+
+    if (aTab.pinned) this.tabContainer._positionPinnedTabs();
+
+    this.tabContainer._setPositionalAttributes();
+
+    var evt = document.createEvent("UIEvents");
+    evt.initUIEvent("TabMove", true, false, window, oldPosition);
+    aTab.dispatchEvent(evt);
+  }
+  moveTabForward() {
+    let nextTab = this.mCurrentTab.nextSibling;
+    while (nextTab && nextTab.hidden) nextTab = nextTab.nextSibling;
+
+    if (nextTab) this.moveTabTo(this.mCurrentTab, nextTab._tPos);
+    else if (this.arrowKeysShouldWrap) this.moveTabToStart();
+  }
+  adoptTab(aTab, aIndex, aSelectTab) {
+    // Swap the dropped tab with a new one we create and then close
+    // it in the other window (making it seem to have moved between
+    // windows). We also ensure that the tab we create to swap into has
+    // the same remote type and process as the one we're swapping in.
+    // This makes sure we don't get a short-lived process for the new tab.
+    let linkedBrowser = aTab.linkedBrowser;
+    let params = {
+      eventDetail: { adoptedTab: aTab },
+      preferredRemoteType: linkedBrowser.remoteType,
+      sameProcessAsFrameLoader: linkedBrowser.frameLoader,
+      skipAnimation: true
+    };
+    if (aTab.hasAttribute("usercontextid")) {
+      // new tab must have the same usercontextid as the old one
+      params.userContextId = aTab.getAttribute("usercontextid");
+    }
+    let newTab = this.addTab("about:blank", params);
+    let newBrowser = this.getBrowserForTab(newTab);
+
+    // Stop the about:blank load.
+    newBrowser.stop();
+    // Make sure it has a docshell.
+    newBrowser.docShell;
+
+    let numPinned = this._numPinnedTabs;
+    if (aIndex < numPinned || (aTab.pinned && aIndex == numPinned)) {
+      this.pinTab(newTab);
+    }
+
+    this.moveTabTo(newTab, aIndex);
+
+    // We need to select the tab before calling swapBrowsersAndCloseOther
+    // so that window.content in chrome windows points to the right tab
+    // when pagehide/show events are fired. This is no longer necessary
+    // for any exiting browser code, but it may be necessary for add-on
+    // compatibility.
+    if (aSelectTab) {
+      this.selectedTab = newTab;
+    }
+
+    aTab.parentNode._finishAnimateTabMove();
+    this.swapBrowsersAndCloseOther(newTab, aTab);
+
+    if (aSelectTab) {
+      // Call updateCurrentBrowser to make sure the URL bar is up to date
+      // for our new tab after we've done swapBrowsersAndCloseOther.
+      this.updateCurrentBrowser(true);
+    }
+
+    return newTab;
+  }
+  moveTabBackward() {
+    let previousTab = this.mCurrentTab.previousSibling;
+    while (previousTab && previousTab.hidden)
+      previousTab = previousTab.previousSibling;
+
+    if (previousTab) this.moveTabTo(this.mCurrentTab, previousTab._tPos);
+    else if (this.arrowKeysShouldWrap) this.moveTabToEnd();
+  }
+  moveTabToStart() {
+    var tabPos = this.mCurrentTab._tPos;
+    if (tabPos > 0) this.moveTabTo(this.mCurrentTab, 0);
+  }
+  moveTabToEnd() {
+    var tabPos = this.mCurrentTab._tPos;
+    if (tabPos < this.browsers.length - 1)
+      this.moveTabTo(this.mCurrentTab, this.browsers.length - 1);
+  }
+  moveTabOver(aEvent) {
+    var direction = window.getComputedStyle(this.container.parentNode).direction;
+    if (
+      (direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||
+      (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT)
+    )
+      this.moveTabForward();
+    else this.moveTabBackward();
+  }
+  duplicateTab(aTab, aRestoreTabImmediately) {
+    return SessionStore.duplicateTab(window, aTab, 0, aRestoreTabImmediately);
+  }
+  activateBrowserForPrintPreview(aBrowser) {
+    this._printPreviewBrowsers.add(aBrowser);
+    if (this._switcher) {
+      this._switcher.activateBrowserForPrintPreview(aBrowser);
+    }
+    aBrowser.docShellIsActive = true;
+  }
+  deactivatePrintPreviewBrowsers() {
+    let browsers = this._printPreviewBrowsers;
+    this._printPreviewBrowsers = new Set();
+    for (let browser of browsers) {
+      browser.docShellIsActive = this.shouldActivateDocShell(browser);
+    }
+  }
+  shouldActivateDocShell(aBrowser) {
+    if (this._switcher) {
+      return this._switcher.shouldActivateDocShell(aBrowser);
+    }
+    return (
+      (aBrowser == this.selectedBrowser &&
+        window.windowState != window.STATE_MINIMIZED &&
+        !window.isFullyOccluded) ||
+      this._printPreviewBrowsers.has(aBrowser)
+    );
+  }
+  _getSwitcher() {
+    if (this._switcher) {
+      return this._switcher;
+    }
+
+    let switcher = {
+      // How long to wait for a tab's layers to load. After this
+      // time elapses, we're free to put up the spinner and start
+      // trying to load a different tab.
+      TAB_SWITCH_TIMEOUT: 400 /* ms */,
+
+      // When the user hasn't switched tabs for this long, we unload
+      // layers for all tabs that aren't in use.
+      UNLOAD_DELAY: 300 /* ms */,
+
+      // The next three tabs form the principal state variables.
+      // See the assertions in postActions for their invariants.
+
+      // Tab the user requested most recently.
+      requestedTab: this.selectedTab,
+
+      // Tab we're currently trying to load.
+      loadingTab: null,
+
+      // We show this tab in case the requestedTab hasn't loaded yet.
+      lastVisibleTab: this.selectedTab,
+
+      // Auxilliary state variables:
+
+      visibleTab: this.selectedTab, // Tab that's on screen.
+      spinnerTab: null, // Tab showing a spinner.
+      blankTab: null, // Tab showing blank.
+      originalTab: this.selectedTab, // Tab that we started on.
+
+      tabbrowser: this, // Reference to gBrowser.
+      loadTimer: null, // TAB_SWITCH_TIMEOUT nsITimer instance.
+      unloadTimer: null, // UNLOAD_DELAY nsITimer instance.
+
+      // Map from tabs to STATE_* (below).
+      tabState: new Map(),
+
+      // True if we're in the midst of switching tabs.
+      switchInProgress: false,
+
+      // Keep an exact list of content processes (tabParent) in which
+      // we're actively suppressing the display port. This gives a robust
+      // way to make sure we don't forget to un-suppress.
+      activeSuppressDisplayport: new Set(),
+
+      // Set of tabs that might be visible right now. We maintain
+      // this set because we can't be sure when a tab is actually
+      // drawn. A tab is added to this set when we ask to make it
+      // visible. All tabs but the most recently shown tab are
+      // removed from the set upon MozAfterPaint.
+      maybeVisibleTabs: new Set([this.selectedTab]),
+
+      // This holds onto the set of tabs that we've been asked to warm up.
+      // This is used only for Telemetry and logging, and (in order to not
+      // over-complicate the async tab switcher any further) has nothing to do
+      // with how warmed tabs are loaded and unloaded.
+      warmingTabs: new WeakSet(),
+
+      STATE_UNLOADED: 0,
+      STATE_LOADING: 1,
+      STATE_LOADED: 2,
+      STATE_UNLOADING: 3,
+
+      // re-entrancy guard:
+      _processing: false,
+
+      // Wraps nsITimer. Must not use the vanilla setTimeout and
+      // clearTimeout, because they will be blocked by nsIPromptService
+      // dialogs.
+      setTimer(callback, timeout) {
+        let event = {
+          notify: callback
+        };
+
+        var timer = Cc["@mozilla.org/timer;1"].createInstance(
+          Components.interfaces.nsITimer
+        );
+        timer.initWithCallback(event, timeout, Ci.nsITimer.TYPE_ONE_SHOT);
+        return timer;
+      },
+
+      clearTimer(timer) {
+        timer.cancel();
+      },
+
+      getTabState(tab) {
+        let state = this.tabState.get(tab);
+        if (state === undefined) {
+          return this.STATE_UNLOADED;
+        }
+        return state;
+      },
+
+      setTabStateNoAction(tab, state) {
+        if (state == this.STATE_UNLOADED) {
+          this.tabState.delete(tab);
+        } else {
+          this.tabState.set(tab, state);
+        }
+      },
+
+      setTabState(tab, state) {
+        this.setTabStateNoAction(tab, state);
+
+        let browser = tab.linkedBrowser;
+        let { tabParent } = browser.frameLoader;
+        if (state == this.STATE_LOADING) {
+          this.assert(!this.minimizedOrFullyOccluded);
+          browser.docShellIsActive = true;
+          if (!tabParent) {
+            this.onLayersReady(browser);
+          }
+        } else if (state == this.STATE_UNLOADING) {
+          this.unwarmTab(tab);
+          browser.docShellIsActive = false;
+          if (!tabParent) {
+            this.onLayersCleared(browser);
+          }
+        }
+
+        if (!tab.linkedBrowser.isRemoteBrowser) {
+          // setTabState is potentially re-entrant in the non-remote case,
+          // so we must re-get the state for this assertion.
+          let nonRemoteState = this.getTabState(tab);
+          // Non-remote tabs can never stay in the STATE_LOADING
+          // or STATE_UNLOADING states. By the time this function
+          // exits, a non-remote tab must be in STATE_LOADED or
+          // STATE_UNLOADED, since the painting and the layer
+          // upload happen synchronously.
+          this.assert(
+            nonRemoteState == this.STATE_UNLOADED ||
+              nonRemoteState == this.STATE_LOADED
+          );
+        }
+      },
+
+      get minimizedOrFullyOccluded() {
+        return (
+          window.windowState == window.STATE_MINIMIZED || window.isFullyOccluded
+        );
+      },
+
+      init() {
+        this.log("START");
+
+        // If we minimized the window before the switcher was activated,
+        // we might have set  the preserveLayers flag for the current
+        // browser. Let's clear it.
+        this.tabbrowser.mCurrentBrowser.preserveLayers(false);
+
+        window.addEventListener("MozAfterPaint", this);
+        window.addEventListener("MozLayerTreeReady", this);
+        window.addEventListener("MozLayerTreeCleared", this);
+        window.addEventListener("TabRemotenessChange", this);
+        window.addEventListener("sizemodechange", this);
+        window.addEventListener("occlusionstatechange", this);
+        window.addEventListener("SwapDocShells", this, true);
+        window.addEventListener("EndSwapDocShells", this, true);
+
+        let tab = this.requestedTab;
+        let browser = tab.linkedBrowser;
+        let tabIsLoaded =
+          !browser.isRemoteBrowser ||
+          browser.frameLoader.tabParent.hasPresented;
+
+        if (!this.minimizedOrFullyOccluded) {
+          this.log("Initial tab is loaded?: " + tabIsLoaded);
+          this.setTabState(
+            tab,
+            tabIsLoaded ? this.STATE_LOADED : this.STATE_LOADING
+          );
+        }
+      },
+
+      destroy() {
+        if (this.unloadTimer) {
+          this.clearTimer(this.unloadTimer);
+          this.unloadTimer = null;
+        }
+        if (this.loadTimer) {
+          this.clearTimer(this.loadTimer);
+          this.loadTimer = null;
+        }
+
+        window.removeEventListener("MozAfterPaint", this);
+        window.removeEventListener("MozLayerTreeReady", this);
+        window.removeEventListener("MozLayerTreeCleared", this);
+        window.removeEventListener("TabRemotenessChange", this);
+        window.removeEventListener("sizemodechange", this);
+        window.removeEventListener("occlusionstatechange", this);
+        window.removeEventListener("SwapDocShells", this, true);
+        window.removeEventListener("EndSwapDocShells", this, true);
+
+        this.tabbrowser._switcher = null;
+
+        this.activeSuppressDisplayport.forEach(function(tabParent) {
+          tabParent.suppressDisplayport(false);
+        });
+        this.activeSuppressDisplayport.clear();
+      },
+
+      finish() {
+        this.log("FINISH");
+
+        this.assert(this.tabbrowser._switcher);
+        this.assert(this.tabbrowser._switcher === this);
+        this.assert(!this.spinnerTab);
+        this.assert(!this.blankTab);
+        this.assert(!this.loadTimer);
+        this.assert(!this.loadingTab);
+        this.assert(this.lastVisibleTab === this.requestedTab);
+        this.assert(
+          this.minimizedOrFullyOccluded ||
+            this.getTabState(this.requestedTab) == this.STATE_LOADED
+        );
+
+        this.destroy();
+
+        let toBrowser = this.requestedTab.linkedBrowser;
+        toBrowser.setAttribute("primary", "true");
+
+        let fromBrowser = this.originalTab.linkedBrowser;
+        // It's possible that the tab we're switching from closed
+        // before we were able to finalize, in which case, fromBrowser
+        // doesn't exist.
+        if (fromBrowser) {
+          fromBrowser.removeAttribute("primary");
+        }
+
+        document.commandDispatcher.unlock();
+
+        let event = new CustomEvent("TabSwitchDone", {
+          bubbles: true,
+          cancelable: true
+        });
+        this.tabbrowser.dispatchEvent(event);
+      },
+
+      // This function is called after all the main state changes to
+      // make sure we display the right tab.
+      updateDisplay() {
+        let requestedTabState = this.getTabState(this.requestedTab);
+        let requestedBrowser = this.requestedTab.linkedBrowser;
+
+        // It is often more desirable to show a blank tab when appropriate than
+        // the tab switch spinner - especially since the spinner is usually
+        // preceded by a perceived lag of TAB_SWITCH_TIMEOUT ms in the
+        // tab switch. We can hide this lag, and hide the time being spent
+        // constructing TabChild's, layer trees, etc, by showing a blank
+        // tab instead and focusing it immediately.
+        let shouldBeBlank = false;
+        if (requestedBrowser.isRemoteBrowser) {
+          // If a tab is remote and the window is not minimized, we can show a
+          // blank tab instead of a spinner in the following cases:
+          //
+          // 1. The tab has just crashed, and we haven't started showing the
+          //    tab crashed page yet (in this case, the TabParent is null)
+          // 2. The tab has never presented, and has not finished loading
+          //    a non-local-about: page.
+          //
+          // For (2), "finished loading a non-local-about: page" is
+          // determined by the busy state on the tab element and checking
+          // if the loaded URI is local.
+          let hasSufficientlyLoaded =
+            !this.requestedTab.hasAttribute("busy") &&
+            !this.tabbrowser._isLocalAboutURI(requestedBrowser.currentURI);
+
+          let fl = requestedBrowser.frameLoader;
+          shouldBeBlank =
+            !this.minimizedOrFullyOccluded &&
+            (!fl.tabParent ||
+              (!hasSufficientlyLoaded && !fl.tabParent.hasPresented));
+        }
+
+        this.log("Tab should be blank: " + shouldBeBlank);
+        this.log(
+          "Requested tab is remote?: " + requestedBrowser.isRemoteBrowser
+        );
+
+        // Figure out which tab we actually want visible right now.
+        let showTab = null;
+        if (
+          requestedTabState != this.STATE_LOADED &&
+          this.lastVisibleTab &&
+          this.loadTimer &&
+          !shouldBeBlank
+        ) {
+          // If we can't show the requestedTab, and lastVisibleTab is
+          // available, show it.
+          showTab = this.lastVisibleTab;
+        } else {
+          // Show the requested tab. If it's not available, we'll show the spinner or a blank tab.
+          showTab = this.requestedTab;
+        }
+
+        // First, let's deal with blank tabs, which we show instead
+        // of the spinner when the tab is not currently set up
+        // properly in the content process.
+        if (!shouldBeBlank && this.blankTab) {
+          this.blankTab.linkedBrowser.removeAttribute("blank");
+          this.blankTab = null;
+        } else if (shouldBeBlank && this.blankTab !== showTab) {
+          if (this.blankTab) {
+            this.blankTab.linkedBrowser.removeAttribute("blank");
+          }
+          this.blankTab = showTab;
+          this.blankTab.linkedBrowser.setAttribute("blank", "true");
+        }
+
+        // Show or hide the spinner as needed.
+        let needSpinner =
+          this.getTabState(showTab) != this.STATE_LOADED &&
+          !this.minimizedOrFullyOccluded &&
+          !shouldBeBlank;
+
+        if (!needSpinner && this.spinnerTab) {
+          this.spinnerHidden();
+          this.tabbrowser.removeAttribute("pendingpaint");
+          this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
+          this.spinnerTab = null;
+        } else if (needSpinner && this.spinnerTab !== showTab) {
+          if (this.spinnerTab) {
+            this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
+          } else {
+            this.spinnerDisplayed();
+          }
+          this.spinnerTab = showTab;
+          this.tabbrowser.setAttribute("pendingpaint", "true");
+          this.spinnerTab.linkedBrowser.setAttribute("pendingpaint", "true");
+        }
+
+        // Switch to the tab we've decided to make visible.
+        if (this.visibleTab !== showTab) {
+          this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
+          this.visibleTab = showTab;
+
+          this.maybeVisibleTabs.add(showTab);
+
+          let tabs = this.tabbrowser.mTabBox.tabs;
+          let tabPanel = this.tabbrowser.mPanelContainer;
+          let showPanel = tabs.getRelatedElement(showTab);
+          let index = Array.indexOf(tabPanel.childNodes, showPanel);
+          if (index != -1) {
+            this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
+            tabPanel.setAttribute("selectedIndex", index);
+            if (showTab === this.requestedTab) {
+              if (this._requestingTab) {
+                /*
+                       * If _requestingTab is set, that means that we're switching the
+                       * visibility of the tab synchronously, and we need to wait for
+                       * the "select" event before shifting focus so that
+                       * _adjustFocusAfterTabSwitch runs with the right information for
+                       * the tab switch.
+                       */
+                this.tabbrowser.addEventListener(
+                  "select",
+                  () => {
+                    this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
+                  },
+                  { once: true }
+                );
+              } else {
+                this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
+              }
+            }
+          }
+
+          // This doesn't necessarily exist if we're a new window and haven't switched tabs yet
+          if (this.lastVisibleTab)
+            this.lastVisibleTab._visuallySelected = false;
+
+          this.visibleTab._visuallySelected = true;
+        }
+
+        this.lastVisibleTab = this.visibleTab;
+      },
+
+      assert(cond) {
+        if (!cond) {
+          dump("Assertion failure\n" + Error().stack);
+
+          // Don't break a user's browser if an assertion fails.
+          if (AppConstants.DEBUG) {
+            throw new Error("Assertion failure");
+          }
+        }
+      },
+
+      // We've decided to try to load requestedTab.
+      loadRequestedTab() {
+        this.assert(!this.loadTimer);
+        this.assert(!this.minimizedOrFullyOccluded);
+
+        // loadingTab can be non-null here if we timed out loading the current tab.
+        // In that case we just overwrite it with a different tab; it's had its chance.
+        this.loadingTab = this.requestedTab;
+        this.log("Loading tab " + this.tinfo(this.loadingTab));
+
+        this.loadTimer = this.setTimer(
+          () => this.onLoadTimeout(),
+          this.TAB_SWITCH_TIMEOUT
+        );
+        this.setTabState(this.requestedTab, this.STATE_LOADING);
+      },
+
+      // This function runs before every event. It fixes up the state
+      // to account for closed tabs.
+      preActions() {
+        this.assert(this.tabbrowser._switcher);
+        this.assert(this.tabbrowser._switcher === this);
+
+        for (let [tab] of this.tabState) {
+          if (!tab.linkedBrowser) {
+            this.tabState.delete(tab);
+            this.unwarmTab(tab);
+          }
+        }
+
+        if (this.lastVisibleTab && !this.lastVisibleTab.linkedBrowser) {
+          this.lastVisibleTab = null;
+        }
+        if (this.blankTab && !this.blankTab.linkedBrowser) {
+          this.blankTab = null;
+        }
+        if (this.spinnerTab && !this.spinnerTab.linkedBrowser) {
+          this.spinnerHidden();
+          this.spinnerTab = null;
+        }
+        if (this.loadingTab && !this.loadingTab.linkedBrowser) {
+          this.loadingTab = null;
+          this.clearTimer(this.loadTimer);
+          this.loadTimer = null;
+        }
+      },
+
+      // This code runs after we've responded to an event or requested a new
+      // tab. It's expected that we've already updated all the principal
+      // state variables. This function takes care of updating any auxilliary
+      // state.
+      postActions() {
+        // Once we finish loading loadingTab, we null it out. So the state should
+        // always be LOADING.
+        this.assert(
+          !this.loadingTab ||
+            this.getTabState(this.loadingTab) == this.STATE_LOADING
+        );
+
+        // We guarantee that loadingTab is non-null iff loadTimer is non-null. So
+        // the timer is set only when we're loading something.
+        this.assert(!this.loadTimer || this.loadingTab);
+        this.assert(!this.loadingTab || this.loadTimer);
+
+        // If we're switching to a non-remote tab, there's no need to wait
+        // for it to send layers to the compositor, as this will happen
+        // synchronously. Clearing this here means that in the next step,
+        // we can load the non-remote browser immediately.
+        if (!this.requestedTab.linkedBrowser.isRemoteBrowser) {
+          this.loadingTab = null;
+          if (this.loadTimer) {
+            this.clearTimer(this.loadTimer);
+            this.loadTimer = null;
+          }
+        }
+
+        // If we're not loading anything, try loading the requested tab.
+        let requestedState = this.getTabState(this.requestedTab);
+        if (
+          !this.loadTimer &&
+          !this.minimizedOrFullyOccluded &&
+          (requestedState == this.STATE_UNLOADED ||
+            requestedState == this.STATE_UNLOADING)
+        ) {
+          this.loadRequestedTab();
+        }
+
+        // See how many tabs still have work to do.
+        let numPending = 0;
+        let numWarming = 0;
+        for (let [tab, state] of this.tabState) {
+          // Skip print preview browsers since they shouldn't affect tab switching.
+          if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
+            continue;
+          }
+
+          if (state == this.STATE_LOADED && tab !== this.requestedTab) {
+            numPending++;
+
+            if (tab !== this.visibleTab) {
+              numWarming++;
+            }
+          }
+          if (state == this.STATE_LOADING || state == this.STATE_UNLOADING) {
+            numPending++;
+          }
+        }
+
+        this.updateDisplay();
+
+        // It's possible for updateDisplay to trigger one of our own event
+        // handlers, which might cause finish() to already have been called.
+        // Check for that before calling finish() again.
+        if (!this.tabbrowser._switcher) {
+          return;
+        }
+
+        this.maybeFinishTabSwitch();
+
+        if (numWarming > this.tabbrowser.tabWarmingMax) {
+          this.logState("Hit tabWarmingMax");
+          if (this.unloadTimer) {
+            this.clearTimer(this.unloadTimer);
+          }
+          this.unloadNonRequiredTabs();
+        }
+
+        if (numPending == 0) {
+          this.finish();
+        }
+
+        this.logState("done");
+      },
+
+      // Fires when we're ready to unload unused tabs.
+      onUnloadTimeout() {
+        this.logState("onUnloadTimeout");
+        this.preActions();
+        this.unloadTimer = null;
+
+        this.unloadNonRequiredTabs();
+
+        this.postActions();
+      },
+
+      // If there are any non-visible and non-requested tabs in
+      // STATE_LOADED, sets them to STATE_UNLOADING. Also queues
+      // up the unloadTimer to run onUnloadTimeout if there are still
+      // tabs in the process of unloading.
+      unloadNonRequiredTabs() {
+        this.warmingTabs = new WeakSet();
+        let numPending = 0;
+
+        // Unload any tabs that can be unloaded.
+        for (let [tab, state] of this.tabState) {
+          if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
+            continue;
+          }
+
+          if (
+            state == this.STATE_LOADED &&
+            !this.maybeVisibleTabs.has(tab) &&
+            tab !== this.lastVisibleTab &&
+            tab !== this.loadingTab &&
+            tab !== this.requestedTab
+          ) {
+            this.setTabState(tab, this.STATE_UNLOADING);
+          }
+
+          if (state != this.STATE_UNLOADED && tab !== this.requestedTab) {
+            numPending++;
+          }
+        }
+
+        if (numPending) {
+          // Keep the timer going since there may be more tabs to unload.
+          this.unloadTimer = this.setTimer(
+            () => this.onUnloadTimeout(),
+            this.UNLOAD_DELAY
+          );
+        }
+      },
+
+      // Fires when an ongoing load has taken too long.
+      onLoadTimeout() {
+        this.logState("onLoadTimeout");
+        this.preActions();
+        this.loadTimer = null;
+        this.loadingTab = null;
+        this.postActions();
+      },
+
+      // Fires when the layers become available for a tab.
+      onLayersReady(browser) {
+        let tab = this.tabbrowser.getTabForBrowser(browser);
+        this.logState(
+          `onLayersReady(${tab._tPos}, ${browser.isRemoteBrowser})`
+        );
+
+        this.assert(
+          this.getTabState(tab) == this.STATE_LOADING ||
+            this.getTabState(tab) == this.STATE_LOADED
+        );
+        this.setTabState(tab, this.STATE_LOADED);
+
+        if (this.loadingTab === tab) {
+          this.clearTimer(this.loadTimer);
+          this.loadTimer = null;
+          this.loadingTab = null;
+        }
+      },
+
+      // Fires when we paint the screen. Any tab switches we initiated
+      // previously are done, so there's no need to keep the old layers
+      // around.
+      onPaint() {
+        this.maybeVisibleTabs.clear();
+      },
+
+      // Called when we're done clearing the layers for a tab.
+      onLayersCleared(browser) {
+        let tab = this.tabbrowser.getTabForBrowser(browser);
+        if (tab) {
+          this.logState(`onLayersCleared(${tab._tPos})`);
+          this.assert(
+            this.getTabState(tab) == this.STATE_UNLOADING ||
+              this.getTabState(tab) == this.STATE_UNLOADED
+          );
+          this.setTabState(tab, this.STATE_UNLOADED);
+        }
+      },
+
+      // Called when a tab switches from remote to non-remote. In this case
+      // a MozLayerTreeReady notification that we requested may never fire,
+      // so we need to simulate it.
+      onRemotenessChange(tab) {
+        this.logState(
+          `onRemotenessChange(${tab._tPos}, ${tab.linkedBrowser
+            .isRemoteBrowser})`
+        );
+        if (!tab.linkedBrowser.isRemoteBrowser) {
+          if (this.getTabState(tab) == this.STATE_LOADING) {
+            this.onLayersReady(tab.linkedBrowser);
+          } else if (this.getTabState(tab) == this.STATE_UNLOADING) {
+            this.onLayersCleared(tab.linkedBrowser);
+          }
+        } else if (this.getTabState(tab) == this.STATE_LOADED) {
+          // A tab just changed from non-remote to remote, which means
+          // that it's gone back into the STATE_LOADING state until
+          // it sends up a layer tree.
+          this.setTabState(tab, this.STATE_LOADING);
+        }
+      },
+
+      // Called when a tab has been removed, and the browser node is
+      // about to be removed from the DOM.
+      onTabRemoved(tab) {
+        if (this.lastVisibleTab == tab) {
+          // The browser that was being presented to the user is
+          // going to be removed during this tick of the event loop.
+          // This will cause us to show a tab spinner instead.
+          this.preActions();
+          this.lastVisibleTab = null;
+          this.postActions();
+        }
+      },
+
+      onSizeModeOrOcclusionStateChange() {
+        if (this.minimizedOrFullyOccluded) {
+          for (let [tab, state] of this.tabState) {
+            // Skip print preview browsers since they shouldn't affect tab switching.
+            if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
+              continue;
+            }
+
+            if (state == this.STATE_LOADING || state == this.STATE_LOADED) {
+              this.setTabState(tab, this.STATE_UNLOADING);
+            }
+          }
+          if (this.loadTimer) {
+            this.clearTimer(this.loadTimer);
+            this.loadTimer = null;
+          }
+          this.loadingTab = null;
+        } else {
+          // Do nothing. We'll automatically start loading the requested tab in
+          // postActions.
+        }
+      },
+
+      onSwapDocShells(ourBrowser, otherBrowser) {
+        // This event fires before the swap. ourBrowser is from
+        // our window. We save the state of otherBrowser since ourBrowser
+        // needs to take on that state at the end of the swap.
+
+        let otherTabbrowser = otherBrowser.ownerGlobal.gBrowser;
+        let otherState;
+        if (otherTabbrowser && otherTabbrowser._switcher) {
+          let otherTab = otherTabbrowser.getTabForBrowser(otherBrowser);
+          let otherSwitcher = otherTabbrowser._switcher;
+          otherState = otherSwitcher.getTabState(otherTab);
+        } else {
+          otherState = otherBrowser.docShellIsActive
+            ? this.STATE_LOADED
+            : this.STATE_UNLOADED;
+        }
+
+        if (!this.swapMap) {
+          this.swapMap = new WeakMap();
+        }
+        this.swapMap.set(otherBrowser, {
+          state: otherState
+        });
+      },
+
+      onEndSwapDocShells(ourBrowser, otherBrowser) {
+        // The swap has happened. We reset the loadingTab in
+        // case it has been swapped. We also set ourBrowser's state
+        // to whatever otherBrowser's state was before the swap.
+
+        if (this.loadTimer) {
+          // Clearing the load timer means that we will
+          // immediately display a spinner if ourBrowser isn't
+          // ready yet. Typically it will already be ready
+          // though. If it's not, we're probably in a new window,
+          // in which case we have no other tabs to display anyway.
+          this.clearTimer(this.loadTimer);
+          this.loadTimer = null;
+        }
+        this.loadingTab = null;
+
+        let { state: otherState } = this.swapMap.get(otherBrowser);
+
+        this.swapMap.delete(otherBrowser);
+
+        let ourTab = this.tabbrowser.getTabForBrowser(ourBrowser);
+        if (ourTab) {
+          this.setTabStateNoAction(ourTab, otherState);
+        }
+      },
+
+      shouldActivateDocShell(browser) {
+        let tab = this.tabbrowser.getTabForBrowser(browser);
+        let state = this.getTabState(tab);
+        return state == this.STATE_LOADING || state == this.STATE_LOADED;
+      },
+
+      activateBrowserForPrintPreview(browser) {
+        let tab = this.tabbrowser.getTabForBrowser(browser);
+        this.setTabState(tab, this.STATE_LOADING);
+      },
+
+      canWarmTab(tab) {
+        if (!this.tabbrowser.tabWarmingEnabled) {
+          return false;
+        }
+
+        // If the tab is not yet inserted, closing, not remote,
+        // crashed, already visible, or already requested, warming
+        // up the tab makes no sense.
+        if (
+          this.minimizedOrFullyOccluded ||
+          !tab.linkedPanel ||
+          tab.closing ||
+          !tab.linkedBrowser.isRemoteBrowser ||
+          !tab.linkedBrowser.frameLoader.tabParent
+        ) {
+          return false;
+        }
+
+        // Similarly, if the tab is already in STATE_LOADING or
+        // STATE_LOADED somehow, there's no point in trying to
+        // warm it up.
+        let state = this.getTabState(tab);
+        if (state === this.STATE_LOADING || state === this.STATE_LOADED) {
+          return false;
+        }
+
+        return true;
+      },
+
+      unwarmTab(tab) {
+        this.warmingTabs.delete(tab);
+      },
+
+      warmupTab(tab) {
+        if (!this.canWarmTab(tab)) {
+          return;
+        }
+
+        this.logState("warmupTab " + this.tinfo(tab));
+
+        this.warmingTabs.add(tab);
+        this.setTabState(tab, this.STATE_LOADING);
+        this.suppressDisplayPortAndQueueUnload(
+          tab,
+          this.tabbrowser.tabWarmingUnloadDelay
+        );
+      },
+
+      // Called when the user asks to switch to a given tab.
+      requestTab(tab) {
+        if (tab === this.requestedTab) {
+          return;
+        }
+
+        if (this.tabbrowser.tabWarmingEnabled) {
+          let warmingState = "disqualified";
+
+          if (this.warmingTabs.has(tab)) {
+            let tabState = this.getTabState(tab);
+            if (tabState == this.STATE_LOADING) {
+              warmingState = "stillLoading";
+            } else if (tabState == this.STATE_LOADED) {
+              warmingState = "loaded";
+            }
+          } else if (this.canWarmTab(tab)) {
+            warmingState = "notWarmed";
+          }
+
+          Services.telemetry
+            .getHistogramById("FX_TAB_SWITCH_REQUEST_TAB_WARMING_STATE")
+            .add(warmingState);
+
+          this.unwarmTab(tab);
+        }
+
+        this._requestingTab = true;
+        this.logState("requestTab " + this.tinfo(tab));
+        this.startTabSwitch();
+
+        this.requestedTab = tab;
+
+        this.suppressDisplayPortAndQueueUnload(
+          this.requestedTab,
+          this.UNLOAD_DELAY
+        );
+        this._requestingTab = false;
+      },
+
+      suppressDisplayPortAndQueueUnload(tab, unloadTimeout) {
+        let browser = tab.linkedBrowser;
+        let fl = browser.frameLoader;
+
+        if (
+          fl &&
+          fl.tabParent &&
+          !this.activeSuppressDisplayport.has(fl.tabParent)
+        ) {
+          fl.tabParent.suppressDisplayport(true);
+          this.activeSuppressDisplayport.add(fl.tabParent);
+        }
+
+        this.preActions();
+
+        if (this.unloadTimer) {
+          this.clearTimer(this.unloadTimer);
+        }
+        this.unloadTimer = this.setTimer(
+          () => this.onUnloadTimeout(),
+          unloadTimeout
+        );
+
+        this.postActions();
+      },
+
+      handleEvent(event, delayed = false) {
+        if (this._processing) {
+          this.setTimer(() => this.handleEvent(event, true), 0);
+          return;
+        }
+        if (delayed && this.tabbrowser._switcher != this) {
+          // if we delayed processing this event, we might be out of date, in which
+          // case we drop the delayed events
+          return;
+        }
+        this._processing = true;
+        this.preActions();
+
+        if (event.type == "MozLayerTreeReady") {
+          this.onLayersReady(event.originalTarget);
+        }
+        if (event.type == "MozAfterPaint") {
+          this.onPaint();
+        } else if (event.type == "MozLayerTreeCleared") {
+          this.onLayersCleared(event.originalTarget);
+        } else if (event.type == "TabRemotenessChange") {
+          this.onRemotenessChange(event.target);
+        } else if (
+          event.type == "sizemodechange" ||
+          event.type == "occlusionstatechange"
+        ) {
+          this.onSizeModeOrOcclusionStateChange();
+        } else if (event.type == "SwapDocShells") {
+          this.onSwapDocShells(event.originalTarget, event.detail);
+        } else if (event.type == "EndSwapDocShells") {
+          this.onEndSwapDocShells(event.originalTarget, event.detail);
+        }
+
+        this.postActions();
+        this._processing = false;
+      },
+
+      /*
+             * Telemetry and Profiler related helpers for recording tab switch
+             * timing.
+             */
+
+      startTabSwitch() {
+        TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+        TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+        this.addMarker("AsyncTabSwitch:Start");
+        this.switchInProgress = true;
+      },
+
+      /**
+             * Something has occurred that might mean that we've completed
+             * the tab switch (layers are ready, paints are done, spinners
+             * are hidden). This checks to make sure all conditions are
+             * satisfied, and then records the tab switch as finished.
+             */
+      maybeFinishTabSwitch() {
+        if (
+          this.switchInProgress &&
+          this.requestedTab &&
+          (this.getTabState(this.requestedTab) == this.STATE_LOADED ||
+            this.requestedTab === this.blankTab)
+        ) {
+          // After this point the tab has switched from the content thread's point of view.
+          // The changes will be visible after the next refresh driver tick + composite.
+          let time = TelemetryStopwatch.timeElapsed(
+            "FX_TAB_SWITCH_TOTAL_E10S_MS",
+            window
+          );
+          if (time != -1) {
+            TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+            this.log("DEBUG: tab switch time = " + time);
+            this.addMarker("AsyncTabSwitch:Finish");
+          }
+          this.switchInProgress = false;
+        }
+      },
+
+      spinnerDisplayed() {
+        this.assert(!this.spinnerTab);
+        let browser = this.requestedTab.linkedBrowser;
+        this.assert(browser.isRemoteBrowser);
+        TelemetryStopwatch.start("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
+        // We have a second, similar probe for capturing recordings of
+        // when the spinner is displayed for very long periods.
+        TelemetryStopwatch.start(
+          "FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS",
+          window
+        );
+        this.addMarker("AsyncTabSwitch:SpinnerShown");
+      },
+
+      spinnerHidden() {
+        this.assert(this.spinnerTab);
+        this.log(
+          "DEBUG: spinner time = " +
+            TelemetryStopwatch.timeElapsed(
+              "FX_TAB_SWITCH_SPINNER_VISIBLE_MS",
+              window
+            )
+        );
+        TelemetryStopwatch.finish("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
+        TelemetryStopwatch.finish(
+          "FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS",
+          window
+        );
+        this.addMarker("AsyncTabSwitch:SpinnerHidden");
+        // we do not get a onPaint after displaying the spinner
+      },
+
+      addMarker(marker) {
+        if (Services.profiler) {
+          Services.profiler.AddMarker(marker);
+        }
+      },
+
+      /*
+             * Debug related logging for switcher.
+             */
+
+      _useDumpForLogging: false,
+      _logInit: false,
+
+      logging() {
+        if (this._useDumpForLogging) return true;
+        if (this._logInit) return this._shouldLog;
+        let result = Services.prefs.getBoolPref(
+          "browser.tabs.remote.logSwitchTiming",
+          false
+        );
+        this._shouldLog = result;
+        this._logInit = true;
+        return this._shouldLog;
+      },
+
+      tinfo(tab) {
+        if (tab) {
+          return tab._tPos + "(" + tab.linkedBrowser.currentURI.spec + ")";
+        }
+        return "null";
+      },
+
+      log(s) {
+        if (!this.logging()) return;
+        if (this._useDumpForLogging) {
+          dump(s + "\n");
+        } else {
+          Services.console.logStringMessage(s);
+        }
+      },
+
+      logState(prefix) {
+        if (!this.logging()) return;
+
+        let accum = prefix + " ";
+        for (let i = 0; i < this.tabbrowser.tabs.length; i++) {
+          let tab = this.tabbrowser.tabs[i];
+          let state = this.getTabState(tab);
+          let isWarming = this.warmingTabs.has(tab);
+
+          accum += i + ":";
+          if (tab === this.lastVisibleTab) accum += "V";
+          if (tab === this.loadingTab) accum += "L";
+          if (tab === this.requestedTab) accum += "R";
+          if (tab === this.blankTab) accum += "B";
+          if (isWarming) accum += "(W)";
+          if (state == this.STATE_LOADED) accum += "(+)";
+          if (state == this.STATE_LOADING) accum += "(+?)";
+          if (state == this.STATE_UNLOADED) accum += "(-)";
+          if (state == this.STATE_UNLOADING) accum += "(-?)";
+          accum += " ";
+        }
+        if (this._useDumpForLogging) {
+          dump(accum + "\n");
+        } else {
+          Services.console.logStringMessage(accum);
+        }
+      }
+    };
+    this._switcher = switcher;
+    switcher.init();
+    return switcher;
+  }
+  warmupTab(aTab) {
+    if (gMultiProcessBrowser) {
+      this._getSwitcher().warmupTab(aTab);
+    }
+  }
+  goBack() {
+    return this.mCurrentBrowser.goBack();
+  }
+  goForward() {
+    return this.mCurrentBrowser.goForward();
+  }
+  reload() {
+    return this.mCurrentBrowser.reload();
+  }
+  reloadWithFlags(aFlags) {
+    return this.mCurrentBrowser.reloadWithFlags(aFlags);
+  }
+  stop() {
+    return this.mCurrentBrowser.stop();
+  }
+  loadURI(aURI, aReferrerURI, aCharset) {
+    return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
+  }
+  loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData) {
+    // Note - the callee understands both:
+    // (a) loadURIWithFlags(aURI, aFlags, ...)
+    // (b) loadURIWithFlags(aURI, { flags: aFlags, ... })
+    // Forwarding it as (a) here actually supports both (a) and (b),
+    // so you can call us either way too.
+    return this.mCurrentBrowser.loadURIWithFlags(
+      aURI,
+      aFlags,
+      aReferrerURI,
+      aCharset,
+      aPostData
+    );
+  }
+  goHome() {
+    return this.mCurrentBrowser.goHome();
+  }
+  gotoIndex(aIndex) {
+    return this.mCurrentBrowser.gotoIndex(aIndex);
+  }
+  _handleKeyDownEvent(aEvent) {
+    if (!aEvent.isTrusted) {
+      // Don't let untrusted events mess with tabs.
+      return;
+    }
+
+    if (aEvent.altKey) return;
+
+    // Don't check if the event was already consumed because tab
+    // navigation should always work for better user experience.
+
+    if (aEvent.ctrlKey && aEvent.shiftKey && !aEvent.metaKey) {
+      switch (aEvent.keyCode) {
+        case aEvent.DOM_VK_PAGE_UP:
+          this.moveTabBackward();
+          aEvent.preventDefault();
+          return;
+        case aEvent.DOM_VK_PAGE_DOWN:
+          this.moveTabForward();
+          aEvent.preventDefault();
+          return;
+      }
+    }
+
+    if (AppConstants.platform != "macosx") {
+      if (
+        aEvent.ctrlKey &&
+        !aEvent.shiftKey &&
+        !aEvent.metaKey &&
+        aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
+        !this.mCurrentTab.pinned
+      ) {
+        this.removeCurrentTab({ animate: true });
+        aEvent.preventDefault();
+      }
+    }
+  }
+  _handleKeyPressEventMac(aEvent) {
+    if (!aEvent.isTrusted) {
+      // Don't let untrusted events mess with tabs.
+      return;
+    }
+
+    if (aEvent.altKey) return;
+
+    if (AppConstants.platform == "macosx") {
+      if (!aEvent.metaKey) return;
+
+      var offset = 1;
+      switch (aEvent.charCode) {
+        case "}".charCodeAt(0):
+          offset = -1;
+        case "{".charCodeAt(0):
+          if (window.getComputedStyle(this.container).direction == "ltr") offset *= -1;
+          this.tabContainer.advanceSelectedTab(offset, true);
+          aEvent.preventDefault();
+      }
+    }
+  }
+  createTooltip(event) {
+    event.stopPropagation();
+    var tab = document.tooltipNode;
+    if (tab.localName != "tab") {
+      event.preventDefault();
+      return;
+    }
+
+    let stringWithShortcut = (stringId, keyElemId) => {
+      let keyElem = document.getElementById(keyElemId);
+      let shortcut = ShortcutUtils.prettifyShortcut(keyElem);
+      return this.mStringBundle.getFormattedString(stringId, [shortcut]);
+    };
+
+    var label;
+    if (tab.mOverCloseButton) {
+      label = tab.selected
+        ? stringWithShortcut("tabs.closeSelectedTab.tooltip", "key_close")
+        : this.mStringBundle.getString("tabs.closeTab.tooltip");
+    } else if (tab._overPlayingIcon) {
+      let stringID;
+      if (tab.selected) {
+        stringID = tab.linkedBrowser.audioMuted
+          ? "tabs.unmuteAudio.tooltip"
+          : "tabs.muteAudio.tooltip";
+        label = stringWithShortcut(stringID, "key_toggleMute");
+      } else {
+        if (tab.hasAttribute("activemedia-blocked")) {
+          stringID = "tabs.unblockAudio.tooltip";
+        } else {
+          stringID = tab.linkedBrowser.audioMuted
+            ? "tabs.unmuteAudio.background.tooltip"
+            : "tabs.muteAudio.background.tooltip";
+        }
+
+        label = this.mStringBundle.getString(stringID);
+      }
+    } else {
+      label = tab._fullLabel || tab.getAttribute("label");
+      if (
+        AppConstants.E10S_TESTING_ONLY &&
+        tab.linkedBrowser &&
+        tab.linkedBrowser.isRemoteBrowser
+      ) {
+        label += " - e10s";
+        if (
+          tab.linkedBrowser.frameLoader &&
+          Services.appinfo.maxWebProcessCount > 1
+        ) {
+          label += " (" + tab.linkedBrowser.frameLoader.tabParent.osPid + ")";
+        }
+      }
+      if (tab.userContextId) {
+        label = this.mStringBundle.getFormattedString(
+          "tabs.containers.tooltip",
+          [
+            label,
+            ContextualIdentityService.getUserContextLabel(tab.userContextId)
+          ]
+        );
+      }
+    }
+
+    event.target.setAttribute("label", label);
+  }
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "keydown":
+        this._handleKeyDownEvent(aEvent);
+        break;
+      case "keypress":
+        this._handleKeyPressEventMac(aEvent);
+        break;
+      case "sizemodechange":
+      case "occlusionstatechange":
+        if (aEvent.target == window && !this._switcher) {
+          this.mCurrentBrowser.preserveLayers(
+            window.windowState == window.STATE_MINIMIZED ||
+              window.isFullyOccluded
+          );
+          this.mCurrentBrowser.docShellIsActive = this.shouldActivateDocShell(
+            this.mCurrentBrowser
+          );
+        }
+        break;
+    }
+  }
+  receiveMessage(aMessage) {
+    let data = aMessage.data;
+    let browser = aMessage.target;
+
+    switch (aMessage.name) {
+      case "DOMTitleChanged": {
+        let tab = this.getTabForBrowser(browser);
+        if (!tab || tab.hasAttribute("pending")) return undefined;
+        let titleChanged = this.setTabTitle(tab);
+        if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
+          tab.setAttribute("titlechanged", "true");
+        break;
+      }
+      case "DOMWindowClose": {
+        if (this.tabs.length == 1) {
+          // We already did PermitUnload in the content process
+          // for this tab (the only one in the window). So we don't
+          // need to do it again for any tabs.
+          window.skipNextCanClose = true;
+          window.close();
+          return undefined;
+        }
+
+        let tab = this.getTabForBrowser(browser);
+        if (tab) {
+          // Skip running PermitUnload since it already happened in
+          // the content process.
+          this.removeTab(tab, { skipPermitUnload: true });
+        }
+        break;
+      }
+      case "contextmenu": {
+        openContextMenu(aMessage);
+        break;
+      }
+      case "DOMWindowFocus": {
+        let tab = this.getTabForBrowser(browser);
+        if (!tab) return undefined;
+        this.selectedTab = tab;
+        window.focus();
+        break;
+      }
+      case "Browser:Init": {
+        let tab = this.getTabForBrowser(browser);
+        if (!tab) return undefined;
+
+        this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
+        browser.messageManager.sendAsyncMessage("Browser:AppTab", {
+          isAppTab: tab.pinned
+        });
+        break;
+      }
+      case "Browser:WindowCreated": {
+        let tab = this.getTabForBrowser(browser);
+        if (tab && data.userContextId) {
+          ContextualIdentityService.telemetry(data.userContextId);
+          tab.setUserContextId(data.userContextId);
+        }
+
+        // We don't want to update the container icon and identifier if
+        // this is not the selected browser.
+        if (browser == gBrowser.selectedBrowser) {
+          updateUserContextUIIndicator();
+        }
+
+        break;
+      }
+      case "Findbar:Keypress": {
+        let tab = this.getTabForBrowser(browser);
+        // If the find bar for this tab is not yet alive, only initialize
+        // it if there's a possibility FindAsYouType will be used.
+        // There's no point in doing it for most random keypresses.
+        if (!this.isFindBarInitialized(tab) && data.shouldFastFind) {
+          let shouldFastFind = this._findAsYouType;
+          if (!shouldFastFind) {
+            // Please keep in sync with toolkit/content/widgets/findbar.xml
+            const FAYT_LINKS_KEY = "'";
+            const FAYT_TEXT_KEY = "/";
+            let charCode = data.fakeEvent.charCode;
+            let key = charCode ? String.fromCharCode(charCode) : null;
+            shouldFastFind = key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY;
+          }
+          if (shouldFastFind) {
+            // Make sure we return the result.
+            return this.getFindBar(tab).receiveMessage(aMessage);
+          }
+        }
+        break;
+      }
+      case "RefreshBlocker:Blocked": {
+        // The data object is expected to contain the following properties:
+        //  - URI (string)
+        //     The URI that a page is attempting to refresh or redirect to.
+        //  - delay (int)
+        //     The delay (in milliseconds) before the page was going to
+        //     reload or redirect.
+        //  - sameURI (bool)
+        //     true if we're refreshing the page. false if we're redirecting.
+        //  - outerWindowID (int)
+        //     The outerWindowID of the frame that requested the refresh or
+        //     redirect.
+
+        let brandBundle = document.getElementById("bundle_brand");
+        let brandShortName = brandBundle.getString("brandShortName");
+        let message = gNavigatorBundle.getFormattedString(
+          "refreshBlocked." + (data.sameURI ? "refreshLabel" : "redirectLabel"),
+          [brandShortName]
+        );
+
+        let notificationBox = this.getNotificationBox(browser);
+        let notification = notificationBox.getNotificationWithValue(
+          "refresh-blocked"
+        );
+
+        if (notification) {
+          notification.label = message;
+        } else {
+          let refreshButtonText = gNavigatorBundle.getString(
+            "refreshBlocked.goButton"
+          );
+          let refreshButtonAccesskey = gNavigatorBundle.getString(
+            "refreshBlocked.goButton.accesskey"
+          );
+
+          let buttons = [
+            {
+              label: refreshButtonText,
+              accessKey: refreshButtonAccesskey,
+              callback() {
+                if (browser.messageManager) {
+                  browser.messageManager.sendAsyncMessage(
+                    "RefreshBlocker:Refresh",
+                    data
+                  );
+                }
+              }
+            }
+          ];
+
+          notificationBox.appendNotification(
+            message,
+            "refresh-blocked",
+            "chrome://browser/skin/notification-icons/popup.svg",
+            notificationBox.PRIORITY_INFO_MEDIUM,
+            buttons
+          );
+        }
+        break;
+      }
+
+      case "Prerender:Request": {
+        let sendCancelPrerendering = () => {
+          browser.frameloader.messageManager.sendAsyncMessage(
+            "Prerender:Canceled",
+            { id: data.id }
+          );
+        };
+
+        let tab = this.getTabForBrowser(browser);
+        if (!tab) {
+          // No tab?
+          sendCancelPrerendering();
+          break;
+        }
+
+        if (tab.hidden) {
+          // Skip prerender on hidden tab.
+          sendCancelPrerendering();
+          break;
+        }
+
+        if (browser.canGoForward) {
+          // Skip prerender on history navigation as we don't support it
+          // yet. Remove this check once bug 1323650 is implemented.
+          sendCancelPrerendering();
+          break;
+        }
+
+        if (!data.href) {
+          // If we don't have data.href, loadOneTab will load about:blank
+          // which is meaningless for prerendering.
+          sendCancelPrerendering();
+          break;
+        }
+
+        let groupedSHistory = browser.frameLoader.ensureGroupedSHistory();
+
+        let newTab = this.loadOneTab(data.href, {
+          referrerURI: data.referrer ? makeURI(data.referrer) : null,
+          referrerPolicy: Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,
+          postData: null,
+          allowThirdPartyFixup: true,
+          relatedToCurrent: true,
+          isPrerendered: true,
+          triggeringPrincipal: Utils.deserializePrincipal(
+            data.triggeringPrincipal
+          )
+        });
+        let partialSHistory = newTab.linkedBrowser.frameLoader.partialSHistory;
+        groupedSHistory.addPrerenderingPartialSHistory(
+          partialSHistory,
+          data.id
+        );
+        break;
+      }
+
+      case "Prerender:Cancel": {
+        let groupedSHistory = browser.frameLoader.groupedSHistory;
+        if (groupedSHistory) {
+          groupedSHistory.cancelPrerendering(data.id);
+        }
+        break;
+      }
+
+      case "Prerender:Swap": {
+        let frameloader = browser.frameLoader;
+        let groupedSHistory = browser.frameLoader.groupedSHistory;
+        if (groupedSHistory) {
+          groupedSHistory
+            .activatePrerendering(data.id)
+            .then(
+              () =>
+                frameloader.messageManager.sendAsyncMessage(
+                  "Prerender:Swapped",
+                  data
+                ),
+              () =>
+                frameloader.messageManager.sendAsyncMessage(
+                  "Prerender:Canceled",
+                  data
+                )
+            );
+        }
+        break;
+      }
+    }
+    return undefined;
+  }
+  observe(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "contextual-identity-updated": {
+        for (let tab of this.tabs) {
+          if (tab.getAttribute("usercontextid") == aData) {
+            ContextualIdentityService.setTabStyle(tab);
+          }
+        }
+        break;
+      }
+      case "nsPref:changed": {
+        // This is the only pref observed.
+        this._findAsYouType = Services.prefs.getBoolPref(
+          "accessibility.typeaheadfind"
+        );
+        break;
+      }
+    }
+  }
+  _updateNewTabVisibility() {
+    let sib = this.tabContainer.nextElementSibling;
+    while (sib && sib.hidden) {
+      sib = sib.nextElementSibling;
+    }
+    const kAttr = "hasadjacentnewtabbutton";
+    if (sib && sib.id == "new-tab-button") {
+      this.tabContainer.setAttribute(kAttr, "true");
+    } else {
+      this.tabContainer.removeAttribute(kAttr);
+    }
+  }
+  onWidgetAfterDOMChange(aNode, aNextNode, aContainer) {
+    if (
+      aContainer.ownerDocument == document &&
+      aContainer.id == "TabsToolbar"
+    ) {
+      this._updateNewTabVisibility();
+    }
+  }
+  onAreaNodeRegistered(aArea, aContainer) {
+    if (aContainer.ownerDocument == document && aArea == "TabsToolbar") {
+      this._updateNewTabVisibility();
+    }
+  }
+  onAreaReset(aArea, aContainer) {
+    this.onAreaNodeRegistered(aArea, aContainer);
+  }
+  _generateUniquePanelID() {
+    if (!this._uniquePanelIDCounter) {
+      this._uniquePanelIDCounter = 0;
+    }
+
+    let outerID = window
+      .QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+
+    // We want panel IDs to be globally unique, that's why we include the
+    // window ID. We switched to a monotonic counter as Date.now() lead
+    // to random failures because of colliding IDs.
+    return "panel-" + outerID + "-" + ++this._uniquePanelIDCounter;
+  }
+}
diff --git a/browser/base/content/browser-bundle.js b/browser/base/content/browser-bundle.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser-bundle.js
@@ -0,0 +1,15353 @@
+/******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+/******/
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+/******/
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId]) {
+/******/ 			return installedModules[moduleId].exports;
+/******/ 		}
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			i: moduleId,
+/******/ 			l: false,
+/******/ 			exports: {}
+/******/ 		};
+/******/
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+/******/
+/******/ 		// Flag the module as loaded
+/******/ 		module.l = true;
+/******/
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+/******/
+/******/
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+/******/
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+/******/
+/******/ 	// define getter function for harmony exports
+/******/ 	__webpack_require__.d = function(exports, name, getter) {
+/******/ 		if(!__webpack_require__.o(exports, name)) {
+/******/ 			Object.defineProperty(exports, name, {
+/******/ 				configurable: false,
+/******/ 				enumerable: true,
+/******/ 				get: getter
+/******/ 			});
+/******/ 		}
+/******/ 	};
+/******/
+/******/ 	// getDefaultExport function for compatibility with non-harmony modules
+/******/ 	__webpack_require__.n = function(module) {
+/******/ 		var getter = module && module.__esModule ?
+/******/ 			function getDefault() { return module['default']; } :
+/******/ 			function getModuleExports() { return module; };
+/******/ 		__webpack_require__.d(getter, 'a', getter);
+/******/ 		return getter;
+/******/ 	};
+/******/
+/******/ 	// Object.prototype.hasOwnProperty.call
+/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
+/******/
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+/******/
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(__webpack_require__.s = 0);
+/******/ })
+/************************************************************************/
+/******/ ([
+/* 0 */
+/***/ (function(module, exports, __webpack_require__) {
+
+
+__webpack_require__(1);
+__webpack_require__(2);
+__webpack_require__(3);
+__webpack_require__(4);
+__webpack_require__(5);
+__webpack_require__(6);
+__webpack_require__(7);
+__webpack_require__(8);
+__webpack_require__(9);
+__webpack_require__(10);
+__webpack_require__(11);
+
+
+/***/ }),
+/* 1 */
+/***/ (function(module, exports) {
+
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* eslint-env mozilla/browser-window */
+
+var Ci = Components.interfaces;
+var Cu = Components.utils;
+var Cc = Components.classes;
+var Cr = Components.results;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/AppConstants.jsm");
+Cu.import("resource://gre/modules/NotificationDB.jsm");
+
+const {WebExtensionPolicy} = Cu.getGlobalForObject(Services);
+
+// lazy module getters
+
+XPCOMUtils.defineLazyModuleGetters(window, {
+  AboutHome: "resource:///modules/AboutHome.jsm",
+  BrowserUITelemetry: "resource:///modules/BrowserUITelemetry.jsm",
+  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
+  CharsetMenu: "resource://gre/modules/CharsetMenu.jsm",
+  Color: "resource://gre/modules/Color.jsm",
+  ContentSearch: "resource:///modules/ContentSearch.jsm",
+  ContextualIdentityService: "resource://gre/modules/ContextualIdentityService.jsm",
+  CustomizableUI: "resource:///modules/CustomizableUI.jsm",
+  Deprecated: "resource://gre/modules/Deprecated.jsm",
+  DownloadsCommon: "resource:///modules/DownloadsCommon.jsm",
+  E10SUtils: "resource://gre/modules/E10SUtils.jsm",
+  ExtensionsUI: "resource:///modules/ExtensionsUI.jsm",
+  FormValidationHandler: "resource:///modules/FormValidationHandler.jsm",
+  LanguagePrompt: "resource://gre/modules/LanguagePrompt.jsm",
+  LightweightThemeManager: "resource://gre/modules/LightweightThemeManager.jsm",
+  Log: "resource://gre/modules/Log.jsm",
+  LoginManagerParent: "resource://gre/modules/LoginManagerParent.jsm",
+  NewTabUtils: "resource://gre/modules/NewTabUtils.jsm",
+  PageActions: "resource:///modules/PageActions.jsm",
+  PageThumbs: "resource://gre/modules/PageThumbs.jsm",
+  PluralForm: "resource://gre/modules/PluralForm.jsm",
+  PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
+  ProcessHangMonitor: "resource:///modules/ProcessHangMonitor.jsm",
+  PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
+  ReaderMode: "resource://gre/modules/ReaderMode.jsm",
+  ReaderParent: "resource:///modules/ReaderParent.jsm",
+  RecentWindow: "resource:///modules/RecentWindow.jsm",
+  SafeBrowsing: "resource://gre/modules/SafeBrowsing.jsm",
+  SessionStore: "resource:///modules/sessionstore/SessionStore.jsm",
+  SchedulePressure: "resource:///modules/SchedulePressure.jsm",
+  ShortcutUtils: "resource://gre/modules/ShortcutUtils.jsm",
+  SimpleServiceDiscovery: "resource://gre/modules/SimpleServiceDiscovery.jsm",
+  SitePermissions: "resource:///modules/SitePermissions.jsm",
+  TabCrashHandler: "resource:///modules/ContentCrashHandlers.jsm",
+  TelemetryStopwatch: "resource://gre/modules/TelemetryStopwatch.jsm",
+  Translation: "resource:///modules/translation/Translation.jsm",
+  UITour: "resource:///modules/UITour.jsm",
+  UpdateUtils: "resource://gre/modules/UpdateUtils.jsm",
+  Utils: "resource://gre/modules/sessionstore/Utils.jsm",
+  Weave: "resource://services-sync/main.js",
+  WebNavigationFrames: "resource://gre/modules/WebNavigationFrames.jsm",
+  fxAccounts: "resource://gre/modules/FxAccounts.jsm",
+  webrtcUI: "resource:///modules/webrtcUI.jsm",
+  ZoomUI: "resource:///modules/ZoomUI.jsm",
+});
+
+if (AppConstants.MOZ_CRASHREPORTER) {
+  XPCOMUtils.defineLazyModuleGetter(this, "PluginCrashReporter",
+    "resource:///modules/ContentCrashHandlers.jsm");
+}
+
+XPCOMUtils.defineLazyScriptGetter(window, "PrintUtils",
+                                  "chrome://global/content/printUtils.js");
+XPCOMUtils.defineLazyScriptGetter(window, "ZoomManager",
+                                  "chrome://global/content/viewZoomOverlay.js");
+XPCOMUtils.defineLazyScriptGetter(window, "FullZoom",
+                                  "chrome://browser/content/browser-fullZoom.js");
+XPCOMUtils.defineLazyScriptGetter(window, "PanelUI",
+                                  "chrome://browser/content/customizableui/panelUI.js");
+XPCOMUtils.defineLazyScriptGetter(window, "gViewSourceUtils",
+                                  "chrome://global/content/viewSourceUtils.js");
+XPCOMUtils.defineLazyScriptGetter(window, ["LightWeightThemeWebInstaller",
+                                         "gExtensionsNotifications",
+                                         "gXPInstallObserver"],
+                                  "chrome://browser/content/browser-addons.js");
+XPCOMUtils.defineLazyScriptGetter(window, "ctrlTab",
+                                  "chrome://browser/content/browser-ctrlTab.js");
+XPCOMUtils.defineLazyScriptGetter(window, "CustomizationHandler",
+                                  "chrome://browser/content/browser-customization.js");
+XPCOMUtils.defineLazyScriptGetter(window, ["PointerLock", "FullScreen"],
+                                  "chrome://browser/content/browser-fullScreenAndPointerLock.js");
+XPCOMUtils.defineLazyScriptGetter(window, ["gGestureSupport", "gHistorySwipeAnimation"],
+                                  "chrome://browser/content/browser-gestureSupport.js");
+XPCOMUtils.defineLazyScriptGetter(window, "gSafeBrowsing",
+                                  "chrome://browser/content/browser-safebrowsing.js");
+XPCOMUtils.defineLazyScriptGetter(window, "gSync",
+                                  "chrome://browser/content/browser-sync.js");
+XPCOMUtils.defineLazyScriptGetter(window, "gBrowserThumbnails",
+                                  "chrome://browser/content/browser-thumbnails.js");
+XPCOMUtils.defineLazyScriptGetter(window, ["setContextMenuContentData",
+                                         "openContextMenu", "nsContextMenu"],
+                                  "chrome://browser/content/nsContextMenu.js");
+XPCOMUtils.defineLazyScriptGetter(window, ["DownloadsPanel",
+                                         "DownloadsOverlayLoader",
+                                         "DownloadsSubview",
+                                         "DownloadsView", "DownloadsViewUI",
+                                         "DownloadsViewController",
+                                         "DownloadsSummary", "DownloadsFooter",
+                                         "DownloadsBlockedSubview"],
+                                  "chrome://browser/content/downloads/downloads.js");
+XPCOMUtils.defineLazyScriptGetter(window, ["DownloadsButton",
+                                         "DownloadsIndicatorView"],
+                                  "chrome://browser/content/downloads/indicator.js");
+XPCOMUtils.defineLazyScriptGetter(window, "gEditItemOverlay",
+                                  "chrome://browser/content/places/editBookmarkOverlay.js");
+
+
+// lazy service getters
+
+XPCOMUtils.defineLazyServiceGetters(window, {
+  Favicons: ["@mozilla.org/browser/favicon-service;1", "mozIAsyncFavicons"],
+  gAboutNewTabService: ["@mozilla.org/browser/aboutnewtab-service;1", "nsIAboutNewTabService"],
+  gDNSService: ["@mozilla.org/network/dns-service;1", "nsIDNSService"],
+  gSerializationHelper: ["@mozilla.org/network/serialization-helper;1", "nsISerializationHelper"],
+  Marionette: ["@mozilla.org/remote/marionette;1", "nsIMarionette"],
+  SessionStartup: ["@mozilla.org/browser/sessionstartup;1", "nsISessionStartup"],
+  WindowsUIUtils: ["@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils"],
+});
+
+if (AppConstants.MOZ_CRASHREPORTER) {
+  XPCOMUtils.defineLazyServiceGetter(window, "gCrashReporter",
+                                     "@mozilla.org/xre/app-info;1",
+                                     "nsICrashReporter");
+}
+
+XPCOMUtils.defineLazyGetter(window, "gBrowserBundle", function() {
+  return Services.strings.createBundle("chrome://browser/locale/browser.properties");
+});
+XPCOMUtils.defineLazyGetter(window, "gTabBrowserBundle", function() {
+  return Services.strings.createBundle("chrome://browser/locale/tabbrowser.properties");
+});
+
+XPCOMUtils.defineLazyGetter(window, "gCustomizeMode", function() {
+  let scope = {};
+  Cu.import("resource:///modules/CustomizeMode.jsm", scope);
+  return new scope.CustomizeMode(window);
+});
+
+XPCOMUtils.defineLazyGetter(window, "InlineSpellCheckerUI", function() {
+  let tmp = {};
+  Cu.import("resource://gre/modules/InlineSpellChecker.jsm", tmp);
+  return new tmp.InlineSpellChecker();
+});
+
+XPCOMUtils.defineLazyGetter(window, "PageMenuParent", function() {
+  let tmp = {};
+  Cu.import("resource://gre/modules/PageMenu.jsm", tmp);
+  return new tmp.PageMenuParent();
+});
+
+XPCOMUtils.defineLazyGetter(window, "PopupNotifications", function() {
+  let tmp = {};
+  Cu.import("resource://gre/modules/PopupNotifications.jsm", tmp);
+  try {
+    // Hide all notifications while the URL is being edited and the address bar
+    // has focus, including the virtual focus in the results popup.
+    // We also have to hide notifications explicitly when the window is
+    // minimized because of the effects of the "noautohide" attribute on Linux.
+    // This can be removed once bug 545265 and bug 1320361 are fixed.
+    let shouldSuppress = () => {
+      return window.windowState == window.STATE_MINIMIZED ||
+             (gURLBar.getAttribute("pageproxystate") != "valid" &&
+             gURLBar.focused);
+    };
+    return new tmp.PopupNotifications(gBrowser,
+                                      document.getElementById("notification-popup"),
+                                      document.getElementById("notification-popup-box"),
+                                      { shouldSuppress });
+  } catch (ex) {
+    Cu.reportError(ex);
+    return null;
+  }
+});
+
+XPCOMUtils.defineLazyGetter(window, "Win7Features", function() {
+  if (AppConstants.platform != "win")
+    return null;
+
+  const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
+  if (WINTASKBAR_CONTRACTID in Cc &&
+      Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar).available) {
+    let AeroPeek = Cu.import("resource:///modules/WindowsPreviewPerTab.jsm", {}).AeroPeek;
+    return {
+      onOpenWindow() {
+        AeroPeek.onOpenWindow(window);
+      },
+      onCloseWindow() {
+        AeroPeek.onCloseWindow(window);
+      }
+    };
+  }
+  return null;
+});
+
+const nsIWebNavigation = Ci.nsIWebNavigation;
+
+var gLastValidURLStr = "";
+var gInPrintPreviewMode = false;
+var gContextMenu = null; // nsContextMenu instance
+var gMultiProcessBrowser =
+  window.QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIWebNavigation)
+        .QueryInterface(Ci.nsILoadContext)
+        .useRemoteTabs;
+
+if (AppConstants.platform != "macosx") {
+  var gEditUIVisible = true;
+}
+
+/* globals gBrowser, gNavToolbox, gURLBar:true, gNavigatorBundle*/
+[
+  ["gBrowser",            "content"],
+  ["gNavToolbox",         "navigator-toolbox"],
+  ["gURLBar",             "urlbar"],
+  ["gNavigatorBundle",    "bundle_browser"]
+].forEach(function(elementGlobal) {
+  var [name, id] = elementGlobal;
+  Object.defineProperty(window, name, {
+    configurable: true,
+    enumerable: true,
+    get() {
+      var element = document.getElementById(id);
+      if (!element)
+        return null;
+      delete window[name];
+      return window[name] = element;
+    },
+    set(val) {
+      delete window[name];
+      return window[name] = val;
+    },
+  });
+});
+
+// Smart getter for the findbar.  If you don't wish to force the creation of
+// the findbar, check gFindBarInitialized first.
+
+Object.defineProperty(this, "gFindBar", {
+  configurable: true,
+  enumerable: true,
+  get() {
+    return window.gBrowser.getFindBar();
+  },
+});
+
+Object.defineProperty(this, "gFindBarInitialized", {
+  configurable: true,
+  enumerable: true,
+  get() {
+    return window.gBrowser.isFindBarInitialized();
+  },
+});
+
+Object.defineProperty(this, "AddonManager", {
+  configurable: true,
+  enumerable: true,
+  get() {
+    let tmp = {};
+    Cu.import("resource://gre/modules/AddonManager.jsm", tmp);
+    return this.AddonManager = tmp.AddonManager;
+  },
+  set(val) {
+    delete this.AddonManager;
+    return this.AddonManager = val;
+  },
+});
+
+
+var gInitialPages = [
+  "about:blank",
+  "about:newtab",
+  "about:home",
+  "about:privatebrowsing",
+  "about:welcomeback",
+  "about:sessionrestore"
+];
+
+function isInitialPage(url) {
+  return gInitialPages.includes(url) || url == BROWSER_NEW_TAB_URL;
+}
+
+function* browserWindows() {
+  let windows = Services.wm.getEnumerator("navigator:browser");
+  while (windows.hasMoreElements())
+    yield windows.getNext();
+}
+
+/**
+* We can avoid adding multiple load event listeners and save some time by adding
+* one listener that calls all real handlers.
+*/
+function pageShowEventHandlers(persisted) {
+  XULBrowserWindow.asyncUpdateUI();
+}
+
+function UpdateBackForwardCommands(aWebNavigation) {
+  var backBroadcaster = document.getElementById("Browser:Back");
+  var forwardBroadcaster = document.getElementById("Browser:Forward");
+
+  // Avoid setting attributes on broadcasters if the value hasn't changed!
+  // Remember, guys, setting attributes on elements is expensive!  They
+  // get inherited into anonymous content, broadcast to other widgets, etc.!
+  // Don't do it if the value hasn't changed! - dwh
+
+  var backDisabled = backBroadcaster.hasAttribute("disabled");
+  var forwardDisabled = forwardBroadcaster.hasAttribute("disabled");
+  if (backDisabled == aWebNavigation.canGoBack) {
+    if (backDisabled)
+      backBroadcaster.removeAttribute("disabled");
+    else
+      backBroadcaster.setAttribute("disabled", true);
+  }
+
+  if (forwardDisabled == aWebNavigation.canGoForward) {
+    if (forwardDisabled)
+      forwardBroadcaster.removeAttribute("disabled");
+    else
+      forwardBroadcaster.setAttribute("disabled", true);
+  }
+}
+
+/**
+ * Click-and-Hold implementation for the Back and Forward buttons
+ * XXXmano: should this live in toolbarbutton.xml?
+ */
+function SetClickAndHoldHandlers() {
+  // Bug 414797: Clone the back/forward buttons' context menu into both buttons.
+  let popup = document.getElementById("backForwardMenu").cloneNode(true);
+  popup.removeAttribute("id");
+  // Prevent the back/forward buttons' context attributes from being inherited.
+  popup.setAttribute("context", "");
+
+  let backButton = document.getElementById("back-button");
+  backButton.setAttribute("type", "menu");
+  backButton.appendChild(popup);
+  gClickAndHoldListenersOnElement.add(backButton);
+
+  let forwardButton = document.getElementById("forward-button");
+  popup = popup.cloneNode(true);
+  forwardButton.setAttribute("type", "menu");
+  forwardButton.appendChild(popup);
+  gClickAndHoldListenersOnElement.add(forwardButton);
+}
+
+
+const gClickAndHoldListenersOnElement = {
+  _timers: new Map(),
+
+  _mousedownHandler(aEvent) {
+    if (aEvent.button != 0 ||
+        aEvent.currentTarget.open ||
+        aEvent.currentTarget.disabled)
+      return;
+
+    // Prevent the menupopup from opening immediately
+    aEvent.currentTarget.firstChild.hidden = true;
+
+    aEvent.currentTarget.addEventListener("mouseout", this);
+    aEvent.currentTarget.addEventListener("mouseup", this);
+    this._timers.set(aEvent.currentTarget, setTimeout((b) => this._openMenu(b), 500, aEvent.currentTarget));
+  },
+
+  _clickHandler(aEvent) {
+    if (aEvent.button == 0 &&
+        aEvent.target == aEvent.currentTarget &&
+        !aEvent.currentTarget.open &&
+        !aEvent.currentTarget.disabled) {
+      let cmdEvent = document.createEvent("xulcommandevent");
+      cmdEvent.initCommandEvent("command", true, true, window, 0,
+                                aEvent.ctrlKey, aEvent.altKey, aEvent.shiftKey,
+                                aEvent.metaKey, null, aEvent.mozInputSource);
+      aEvent.currentTarget.dispatchEvent(cmdEvent);
+
+      // This is here to cancel the XUL default event
+      // dom.click() triggers a command even if there is a click handler
+      // however this can now be prevented with preventDefault().
+      aEvent.preventDefault();
+    }
+  },
+
+  _openMenu(aButton) {
+    this._cancelHold(aButton);
+    aButton.firstChild.hidden = false;
+    aButton.open = true;
+  },
+
+  _mouseoutHandler(aEvent) {
+    let buttonRect = aEvent.currentTarget.getBoundingClientRect();
+    if (aEvent.clientX >= buttonRect.left &&
+        aEvent.clientX <= buttonRect.right &&
+        aEvent.clientY >= buttonRect.bottom)
+      this._openMenu(aEvent.currentTarget);
+    else
+      this._cancelHold(aEvent.currentTarget);
+  },
+
+  _mouseupHandler(aEvent) {
+    this._cancelHold(aEvent.currentTarget);
+  },
+
+  _cancelHold(aButton) {
+    clearTimeout(this._timers.get(aButton));
+    aButton.removeEventListener("mouseout", this);
+    aButton.removeEventListener("mouseup", this);
+  },
+
+  handleEvent(e) {
+    switch (e.type) {
+      case "mouseout":
+        this._mouseoutHandler(e);
+        break;
+      case "mousedown":
+        this._mousedownHandler(e);
+        break;
+      case "click":
+        this._clickHandler(e);
+        break;
+      case "mouseup":
+        this._mouseupHandler(e);
+        break;
+    }
+  },
+
+  remove(aButton) {
+    aButton.removeEventListener("mousedown", this, true);
+    aButton.removeEventListener("click", this, true);
+  },
+
+  add(aElm) {
+    this._timers.delete(aElm);
+
+    aElm.addEventListener("mousedown", this, true);
+    aElm.addEventListener("click", this, true);
+  }
+};
+
+const gSessionHistoryObserver = {
+  observe(subject, topic, data) {
+    if (topic != "browser:purge-session-history")
+      return;
+
+    var backCommand = document.getElementById("Browser:Back");
+    backCommand.setAttribute("disabled", "true");
+    var fwdCommand = document.getElementById("Browser:Forward");
+    fwdCommand.setAttribute("disabled", "true");
+
+    // Hide session restore button on about:home
+    window.messageManager.broadcastAsyncMessage("Browser:HideSessionRestoreButton");
+
+    // Clear undo history of the URL bar
+    gURLBar.editor.transactionManager.clear();
+  }
+};
+
+const gStoragePressureObserver = {
+  _lastNotificationTime: -1,
+
+  observe(subject, topic, data) {
+    if (topic != "QuotaManager::StoragePressure" ||
+        !Services.prefs.getBoolPref("browser.storageManager.enabled")) {
+      return;
+    }
+
+    const NOTIFICATION_VALUE = "storage-pressure-notification";
+    let notificationBox = document.getElementById("high-priority-global-notificationbox");
+    if (notificationBox.getNotificationWithValue(NOTIFICATION_VALUE)) {
+      // Do not display the 2nd notification when there is already one
+      return;
+    }
+
+    // Don't display notification twice within the given interval.
+    // This is because
+    //   - not to annoy user
+    //   - give user some time to clean space.
+    //     Even user sees notification and starts acting, it still takes some time.
+    const MIN_NOTIFICATION_INTERVAL_MS =
+      Services.prefs.getIntPref("browser.storageManager.pressureNotification.minIntervalMS");
+    let duration = Date.now() - this._lastNotificationTime;
+    if (duration <= MIN_NOTIFICATION_INTERVAL_MS) {
+      return;
+    }
+    this._lastNotificationTime = Date.now();
+
+    const BYTES_IN_GIGABYTE = 1073741824;
+    const USAGE_THRESHOLD_BYTES = BYTES_IN_GIGABYTE *
+      Services.prefs.getIntPref("browser.storageManager.pressureNotification.usageThresholdGB");
+    let msg = "";
+    let buttons = [];
+    let usage = subject.QueryInterface(Ci.nsISupportsPRUint64).data;
+    let prefStrBundle = document.getElementById("bundle_preferences");
+    let brandShortName = document.getElementById("bundle_brand").getString("brandShortName");
+    buttons.push({
+      label: prefStrBundle.getString("spaceAlert.learnMoreButton.label"),
+      accessKey: prefStrBundle.getString("spaceAlert.learnMoreButton.accesskey"),
+      callback(notificationBar, button) {
+        let learnMoreURL = Services.urlFormatter.formatURLPref("app.support.baseURL") + "storage-permissions";
+        gBrowser.selectedTab = gBrowser.addTab(learnMoreURL);
+      }
+    });
+    if (usage < USAGE_THRESHOLD_BYTES) {
+      // The firefox-used space < 5GB, then warn user to free some disk space.
+      // This is because this usage is small and not the main cause for space issue.
+      // In order to avoid the bad and wrong impression among users that
+      // firefox eats disk space a lot, indicate users to clean up other disk space.
+      msg = prefStrBundle.getFormattedString("spaceAlert.under5GB.message", [brandShortName]);
+      buttons.push({
+        label: prefStrBundle.getString("spaceAlert.under5GB.okButton.label"),
+        accessKey: prefStrBundle.getString("spaceAlert.under5GB.okButton.accesskey"),
+        callback() {}
+      });
+    } else {
+      // The firefox-used space >= 5GB, then guide users to about:preferences
+      // to clear some data stored on firefox by websites.
+      let descriptionStringID = "spaceAlert.over5GB.message";
+      let prefButtonLabelStringID = "spaceAlert.over5GB.prefButton.label";
+      let prefButtonAccesskeyStringID = "spaceAlert.over5GB.prefButton.accesskey";
+      if (AppConstants.platform == "win") {
+        descriptionStringID = "spaceAlert.over5GB.messageWin";
+        prefButtonLabelStringID = "spaceAlert.over5GB.prefButtonWin.label";
+        prefButtonAccesskeyStringID = "spaceAlert.over5GB.prefButtonWin.accesskey";
+      }
+      msg = prefStrBundle.getFormattedString(descriptionStringID, [brandShortName]);
+      buttons.push({
+        label: prefStrBundle.getString(prefButtonLabelStringID),
+        accessKey: prefStrBundle.getString(prefButtonAccesskeyStringID),
+        callback(notificationBar, button) {
+          // The advanced subpanes are only supported in the old organization, which will
+          // be removed by bug 1349689.
+          let win = gBrowser.ownerGlobal;
+          win.openPreferences("panePrivacy", { origin: "storagePressure" });
+        }
+      });
+    }
+
+    notificationBox.appendNotification(
+      msg, NOTIFICATION_VALUE, null, notificationBox.PRIORITY_WARNING_HIGH, buttons, null);
+  }
+};
+
+/**
+ * Given a starting docshell and a URI to look up, find the docshell the URI
+ * is loaded in.
+ * @param   aDocument
+ *          A document to find instead of using just a URI - this is more specific.
+ * @param   aDocShell
+ *          The doc shell to start at
+ * @param   aSoughtURI
+ *          The URI that we're looking for
+ * @returns The doc shell that the sought URI is loaded in. Can be in
+ *          subframes.
+ */
+function findChildShell(aDocument, aDocShell, aSoughtURI) {
+  aDocShell.QueryInterface(Components.interfaces.nsIWebNavigation);
+  aDocShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor);
+  var doc = aDocShell.getInterface(Components.interfaces.nsIDOMDocument);
+  if ((aDocument && doc == aDocument) ||
+      (aSoughtURI && aSoughtURI.spec == aDocShell.currentURI.spec))
+    return aDocShell;
+
+  var node = aDocShell.QueryInterface(Components.interfaces.nsIDocShellTreeItem);
+  for (var i = 0; i < node.childCount; ++i) {
+    var docShell = node.getChildAt(i);
+    docShell = findChildShell(aDocument, docShell, aSoughtURI);
+    if (docShell)
+      return docShell;
+  }
+  return null;
+}
+
+var gPopupBlockerObserver = {
+  handleEvent(aEvent) {
+    if (aEvent.originalTarget != gBrowser.selectedBrowser)
+      return;
+
+    gIdentityHandler.refreshIdentityBlock();
+
+    if (!gBrowser.selectedBrowser.blockedPopups ||
+        !gBrowser.selectedBrowser.blockedPopups.length) {
+      // Hide the notification box (if it's visible).
+      let notificationBox = gBrowser.getNotificationBox();
+      let notification = notificationBox.getNotificationWithValue("popup-blocked");
+      if (notification) {
+        notificationBox.removeNotification(notification, false);
+      }
+      return;
+    }
+
+    // Only show the notification again if we've not already shown it. Since
+    // notifications are per-browser, we don't need to worry about re-adding
+    // it.
+    if (!gBrowser.selectedBrowser.blockedPopups.reported) {
+      if (Services.prefs.getBoolPref("privacy.popups.showBrowserMessage")) {
+        var brandBundle = document.getElementById("bundle_brand");
+        var brandShortName = brandBundle.getString("brandShortName");
+        var popupCount = gBrowser.selectedBrowser.blockedPopups.length;
+
+        var stringKey = AppConstants.platform == "win"
+                        ? "popupWarningButton"
+                        : "popupWarningButtonUnix";
+
+        var popupButtonText = gNavigatorBundle.getString(stringKey);
+        var popupButtonAccesskey = gNavigatorBundle.getString(stringKey + ".accesskey");
+
+        var messageBase = gNavigatorBundle.getString("popupWarning.message");
+        var message = PluralForm.get(popupCount, messageBase)
+                                .replace("#1", brandShortName)
+                                .replace("#2", popupCount);
+
+        let notificationBox = gBrowser.getNotificationBox();
+        let notification = notificationBox.getNotificationWithValue("popup-blocked");
+        if (notification) {
+          notification.label = message;
+        } else {
+          var buttons = [{
+            label: popupButtonText,
+            accessKey: popupButtonAccesskey,
+            popup: "blockedPopupOptions",
+            callback: null
+          }];
+
+          const priority = notificationBox.PRIORITY_WARNING_MEDIUM;
+          notificationBox.appendNotification(message, "popup-blocked",
+                                             "chrome://browser/skin/notification-icons/popup.svg",
+                                             priority, buttons);
+        }
+      }
+
+      // Record the fact that we've reported this blocked popup, so we don't
+      // show it again.
+      gBrowser.selectedBrowser.blockedPopups.reported = true;
+    }
+  },
+
+  toggleAllowPopupsForSite(aEvent) {
+    var pm = Services.perms;
+    var shouldBlock = aEvent.target.getAttribute("block") == "true";
+    var perm = shouldBlock ? pm.DENY_ACTION : pm.ALLOW_ACTION;
+    pm.addFromPrincipal(gBrowser.contentPrincipal, "popup", perm);
+
+    if (!shouldBlock)
+      this.showAllBlockedPopups(gBrowser.selectedBrowser);
+
+    gBrowser.getNotificationBox().removeCurrentNotification();
+  },
+
+  fillPopupList(aEvent) {
+    // XXXben - rather than using |currentURI| here, which breaks down on multi-framed sites
+    //          we should really walk the blockedPopups and create a list of "allow for <host>"
+    //          menuitems for the common subset of hosts present in the report, this will
+    //          make us frame-safe.
+    //
+    // XXXjst - Note that when this is fixed to work with multi-framed sites,
+    //          also back out the fix for bug 343772 where
+    //          nsGlobalWindow::CheckOpenAllow() was changed to also
+    //          check if the top window's location is whitelisted.
+    let browser = gBrowser.selectedBrowser;
+    var uri = browser.contentPrincipal.URI || browser.currentURI;
+    var blockedPopupAllowSite = document.getElementById("blockedPopupAllowSite");
+    try {
+      blockedPopupAllowSite.removeAttribute("hidden");
+      let uriHost = uri.asciiHost ? uri.host : uri.spec;
+      var pm = Services.perms;
+      if (pm.testPermission(uri, "popup") == pm.ALLOW_ACTION) {
+        // Offer an item to block popups for this site, if a whitelist entry exists
+        // already for it.
+        let blockString = gNavigatorBundle.getFormattedString("popupBlock", [uriHost]);
+        blockedPopupAllowSite.setAttribute("label", blockString);
+        blockedPopupAllowSite.setAttribute("block", "true");
+      } else {
+        // Offer an item to allow popups for this site
+        let allowString = gNavigatorBundle.getFormattedString("popupAllow", [uriHost]);
+        blockedPopupAllowSite.setAttribute("label", allowString);
+        blockedPopupAllowSite.removeAttribute("block");
+      }
+    } catch (e) {
+      blockedPopupAllowSite.setAttribute("hidden", "true");
+    }
+
+    if (PrivateBrowsingUtils.isWindowPrivate(window))
+      blockedPopupAllowSite.setAttribute("disabled", "true");
+    else
+      blockedPopupAllowSite.removeAttribute("disabled");
+
+    let blockedPopupDontShowMessage = document.getElementById("blockedPopupDontShowMessage");
+    let showMessage = Services.prefs.getBoolPref("privacy.popups.showBrowserMessage");
+    blockedPopupDontShowMessage.setAttribute("checked", !showMessage);
+    blockedPopupDontShowMessage.setAttribute("label", gNavigatorBundle.getString("popupWarningDontShowFromMessage"));
+
+    let blockedPopupsSeparator =
+        document.getElementById("blockedPopupsSeparator");
+    blockedPopupsSeparator.setAttribute("hidden", true);
+
+    gBrowser.selectedBrowser.retrieveListOfBlockedPopups().then(blockedPopups => {
+      let foundUsablePopupURI = false;
+      if (blockedPopups) {
+        for (let i = 0; i < blockedPopups.length; i++) {
+          let blockedPopup = blockedPopups[i];
+
+          // popupWindowURI will be null if the file picker popup is blocked.
+          // xxxdz this should make the option say "Show file picker" and do it (Bug 590306)
+          if (!blockedPopup.popupWindowURIspec)
+            continue;
+
+          var popupURIspec = blockedPopup.popupWindowURIspec;
+
+          // Sometimes the popup URI that we get back from the blockedPopup
+          // isn't useful (for instance, netscape.com's popup URI ends up
+          // being "http://www.netscape.com", which isn't really the URI of
+          // the popup they're trying to show).  This isn't going to be
+          // useful to the user, so we won't create a menu item for it.
+          if (popupURIspec == "" || popupURIspec == "about:blank" ||
+              popupURIspec == "<self>" ||
+              popupURIspec == uri.spec)
+            continue;
+
+          // Because of the short-circuit above, we may end up in a situation
+          // in which we don't have any usable popup addresses to show in
+          // the menu, and therefore we shouldn't show the separator.  However,
+          // since we got past the short-circuit, we must've found at least
+          // one usable popup URI and thus we'll turn on the separator later.
+          foundUsablePopupURI = true;
+
+          var menuitem = document.createElement("menuitem");
+          var label = gNavigatorBundle.getFormattedString("popupShowPopupPrefix",
+                                                          [popupURIspec]);
+          menuitem.setAttribute("label", label);
+          menuitem.setAttribute("oncommand", "gPopupBlockerObserver.showBlockedPopup(event);");
+          menuitem.setAttribute("popupReportIndex", i);
+          menuitem.popupReportBrowser = browser;
+          aEvent.target.appendChild(menuitem);
+        }
+      }
+
+      // Show the separator if we added any
+      // showable popup addresses to the menu.
+      if (foundUsablePopupURI)
+        blockedPopupsSeparator.removeAttribute("hidden");
+    }, null);
+  },
+
+  onPopupHiding(aEvent) {
+    let item = aEvent.target.lastChild;
+    while (item && item.getAttribute("observes") != "blockedPopupsSeparator") {
+      let next = item.previousSibling;
+      item.remove();
+      item = next;
+    }
+  },
+
+  showBlockedPopup(aEvent) {
+    var target = aEvent.target;
+    var popupReportIndex = target.getAttribute("popupReportIndex");
+    let browser = target.popupReportBrowser;
+    browser.unblockPopup(popupReportIndex);
+  },
+
+  showAllBlockedPopups(aBrowser) {
+    aBrowser.retrieveListOfBlockedPopups().then(popups => {
+      for (let i = 0; i < popups.length; i++) {
+        if (popups[i].popupWindowURIspec)
+          aBrowser.unblockPopup(i);
+      }
+    }, null);
+  },
+
+  editPopupSettings() {
+    let prefillValue = "";
+    try {
+      // We use contentPrincipal rather than currentURI to get the right
+      // value in case this is a data: URI that's inherited off something else.
+      // Some principals don't have URIs, so fall back in case URI is not present.
+      let principalURI = gBrowser.contentPrincipal.URI || gBrowser.currentURI;
+      if (principalURI) {
+        // asciiHost conveniently doesn't throw.
+        if (principalURI.asciiHost) {
+          prefillValue = principalURI.prePath;
+        } else {
+          // For host-less URIs like file://, prePath would effectively allow
+          // popups everywhere on file://. Use the full spec:
+          prefillValue = principalURI.spec;
+        }
+      }
+    } catch (e) { }
+
+    var bundlePreferences = document.getElementById("bundle_preferences");
+    var params = { blockVisible: false,
+                   sessionVisible: false,
+                   allowVisible: true,
+                   prefilledHost: prefillValue,
+                   permissionType: "popup",
+                   windowTitle: bundlePreferences.getString("popuppermissionstitle2"),
+                   introText: bundlePreferences.getString("popuppermissionstext") };
+    var existingWindow = Services.wm.getMostRecentWindow("Browser:Permissions");
+    if (existingWindow) {
+      existingWindow.initWithParams(params);
+      existingWindow.focus();
+    } else
+      window.openDialog("chrome://browser/content/preferences/permissions.xul",
+                        "_blank", "resizable,dialog=no,centerscreen", params);
+  },
+
+  dontShowMessage() {
+    var showMessage = Services.prefs.getBoolPref("privacy.popups.showBrowserMessage");
+    Services.prefs.setBoolPref("privacy.popups.showBrowserMessage", !showMessage);
+    gBrowser.getNotificationBox().removeCurrentNotification();
+  }
+};
+
+function gKeywordURIFixup({ target: browser, data: fixupInfo }) {
+  let deserializeURI = (spec) => spec ? makeURI(spec) : null;
+
+  // We get called irrespective of whether we did a keyword search, or
+  // whether the original input would be vaguely interpretable as a URL,
+  // so figure that out first.
+  let alternativeURI = deserializeURI(fixupInfo.fixedURI);
+  if (!fixupInfo.keywordProviderName || !alternativeURI || !alternativeURI.host) {
+    return;
+  }
+
+  let contentPrincipal = browser.contentPrincipal;
+
+  // At this point we're still only just about to load this URI.
+  // When the async DNS lookup comes back, we may be in any of these states:
+  // 1) still on the previous URI, waiting for the preferredURI (keyword
+  //    search) to respond;
+  // 2) at the keyword search URI (preferredURI)
+  // 3) at some other page because the user stopped navigation.
+  // We keep track of the currentURI to detect case (1) in the DNS lookup
+  // callback.
+  let previousURI = browser.currentURI;
+  let preferredURI = deserializeURI(fixupInfo.preferredURI);
+
+  // now swap for a weak ref so we don't hang on to browser needlessly
+  // even if the DNS query takes forever
+  let weakBrowser = Cu.getWeakReference(browser);
+  browser = null;
+
+  // Additionally, we need the host of the parsed url
+  let hostName = alternativeURI.displayHost;
+  // and the ascii-only host for the pref:
+  let asciiHost = alternativeURI.asciiHost;
+  // Normalize out a single trailing dot - NB: not using endsWith/lastIndexOf
+  // because we need to be sure this last dot is the *only* dot, too.
+  // More generally, this is used for the pref and should stay in sync with
+  // the code in nsDefaultURIFixup::KeywordURIFixup .
+  if (asciiHost.indexOf(".") == asciiHost.length - 1) {
+    asciiHost = asciiHost.slice(0, -1);
+  }
+
+  let isIPv4Address = host => {
+    let parts = host.split(".");
+    if (parts.length != 4) {
+      return false;
+    }
+    return parts.every(part => {
+      let n = parseInt(part, 10);
+      return n >= 0 && n <= 255;
+    });
+  };
+  // Avoid showing fixup information if we're suggesting an IP. Note that
+  // decimal representations of IPs are normalized to a 'regular'
+  // dot-separated IP address by network code, but that only happens for
+  // numbers that don't overflow. Longer numbers do not get normalized,
+  // but still work to access IP addresses. So for instance,
+  // 1097347366913 (ff7f000001) gets resolved by using the final bytes,
+  // making it the same as 7f000001, which is 127.0.0.1 aka localhost.
+  // While 2130706433 would get normalized by network, 1097347366913
+  // does not, and we have to deal with both cases here:
+  if (isIPv4Address(asciiHost) || /^(?:\d+|0x[a-f0-9]+)$/i.test(asciiHost))
+    return;
+
+  let onLookupComplete = (request, record, status) => {
+    let browserRef = weakBrowser.get();
+    if (!Components.isSuccessCode(status) || !browserRef)
+      return;
+
+    let currentURI = browserRef.currentURI;
+    // If we're in case (3) (see above), don't show an info bar.
+    if (!currentURI.equals(previousURI) &&
+        !currentURI.equals(preferredURI)) {
+      return;
+    }
+
+    // show infobar offering to visit the host
+    let notificationBox = gBrowser.getNotificationBox(browserRef);
+    if (notificationBox.getNotificationWithValue("keyword-uri-fixup"))
+      return;
+
+    let message = gNavigatorBundle.getFormattedString(
+      "keywordURIFixup.message", [hostName]);
+    let yesMessage = gNavigatorBundle.getFormattedString(
+      "keywordURIFixup.goTo", [hostName]);
+
+    let buttons = [
+      {
+        label: yesMessage,
+        accessKey: gNavigatorBundle.getString("keywordURIFixup.goTo.accesskey"),
+        callback() {
+          // Do not set this preference while in private browsing.
+          if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+            let pref = "browser.fixup.domainwhitelist." + asciiHost;
+            Services.prefs.setBoolPref(pref, true);
+          }
+          openUILinkIn(alternativeURI.spec, "current");
+        }
+      },
+      {
+        label: gNavigatorBundle.getString("keywordURIFixup.dismiss"),
+        accessKey: gNavigatorBundle.getString("keywordURIFixup.dismiss.accesskey"),
+        callback() {
+          let notification = notificationBox.getNotificationWithValue("keyword-uri-fixup");
+          notificationBox.removeNotification(notification, true);
+        }
+      }
+    ];
+    let notification =
+      notificationBox.appendNotification(message, "keyword-uri-fixup", null,
+                                         notificationBox.PRIORITY_INFO_HIGH,
+                                         buttons);
+    notification.persistence = 1;
+  };
+
+  try {
+    gDNSService.asyncResolve(hostName, 0, onLookupComplete, Services.tm.mainThread,
+                             contentPrincipal.originAttributes);
+  } catch (ex) {
+    // Do nothing if the URL is invalid (we don't want to show a notification in that case).
+    if (ex.result != Cr.NS_ERROR_UNKNOWN_HOST) {
+      // ... otherwise, report:
+      Cu.reportError(ex);
+    }
+  }
+}
+
+function serializeInputStream(aStream) {
+  let data = {
+    content: NetUtil.readInputStreamToString(aStream, aStream.available()),
+  };
+
+  if (aStream instanceof Ci.nsIMIMEInputStream) {
+    data.headers = new Map();
+    aStream.visitHeaders((name, value) => {
+      data.headers.set(name, value);
+    });
+  }
+
+  return data;
+}
+
+/**
+ * Handles URIs when we want to deal with them in chrome code rather than pass
+ * them down to a content browser. This can avoid unnecessary process switching
+ * for the browser.
+ * @param aBrowser the browser that is attempting to load the URI
+ * @param aUri the nsIURI that is being loaded
+ * @returns true if the URI is handled, otherwise false
+ */
+function handleUriInChrome(aBrowser, aUri) {
+  if (aUri.scheme == "file") {
+    try {
+      let mimeType = Cc["@mozilla.org/mime;1"].getService(Ci.nsIMIMEService)
+                                              .getTypeFromURI(aUri);
+      if (mimeType == "application/x-xpinstall") {
+        let systemPrincipal = Services.scriptSecurityManager.getSystemPrincipal();
+        AddonManager.getInstallForURL(aUri.spec, install => {
+          AddonManager.installAddonFromWebpage(mimeType, aBrowser, systemPrincipal,
+                                               install);
+        }, mimeType);
+        return true;
+      }
+    } catch (e) {
+      return false;
+    }
+  }
+
+  return false;
+}
+
+// A shared function used by both remote and non-remote browser XBL bindings to
+// load a URI or redirect it to the correct process.
+function _loadURIWithFlags(browser, uri, params) {
+  let tab = gBrowser.getTabForBrowser(browser);
+  // Preloaded browsers don't have tabs, so we ignore those.
+  if (tab) {
+    maybeRecordAbandonmentTelemetry(tab, "newURI");
+  }
+
+  if (!uri) {
+    uri = "about:blank";
+  }
+  let triggeringPrincipal = params.triggeringPrincipal || null;
+  let flags = params.flags || 0;
+  let referrer = params.referrerURI;
+  let referrerPolicy = ("referrerPolicy" in params ? params.referrerPolicy :
+                        Ci.nsIHttpChannel.REFERRER_POLICY_UNSET);
+  let postData = params.postData;
+
+  let currentRemoteType = browser.remoteType;
+  let requiredRemoteType;
+  try {
+    let fixupFlags = Ci.nsIURIFixup.FIXUP_FLAG_NONE;
+    if (flags & Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) {
+      fixupFlags |= Ci.nsIURIFixup.FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;
+    }
+    if (flags & Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS) {
+      fixupFlags |= Ci.nsIURIFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS;
+    }
+    let uriObject = Services.uriFixup.createFixupURI(uri, fixupFlags);
+    if (handleUriInChrome(browser, uriObject)) {
+      // If we've handled the URI in Chrome then just return here.
+      return;
+    }
+
+    // Note that I had thought that we could set uri = uriObject.spec here, to
+    // save on fixup later on, but that changes behavior and breaks tests.
+    requiredRemoteType =
+      E10SUtils.getRemoteTypeForURIObject(uriObject, gMultiProcessBrowser,
+                                          currentRemoteType, browser.currentURI);
+  } catch (e) {
+    // createFixupURI throws if it can't create a URI. If that's the case then
+    // we still need to pass down the uri because docshell handles this case.
+    requiredRemoteType = gMultiProcessBrowser ? E10SUtils.DEFAULT_REMOTE_TYPE
+                                              : E10SUtils.NOT_REMOTE;
+  }
+
+  let mustChangeProcess = requiredRemoteType != currentRemoteType;
+  let newFrameloader = false;
+  if (browser.getAttribute("preloadedState") === "consumed" && uri != "about:newtab") {
+    // Leaving about:newtab from a used to be preloaded browser should run the process
+    // selecting algorithm again.
+    mustChangeProcess = true;
+    newFrameloader = true;
+    browser.removeAttribute("preloadedState");
+  }
+
+  // !requiredRemoteType means we're loading in the parent/this process.
+  if (!requiredRemoteType) {
+    browser.inLoadURI = true;
+  }
+  try {
+    if (!mustChangeProcess) {
+      if (params.userContextId) {
+        browser.webNavigation.setOriginAttributesBeforeLoading({ userContextId: params.userContextId });
+      }
+
+      browser.webNavigation.loadURIWithOptions(uri, flags,
+                                               referrer, referrerPolicy,
+                                               postData, null, null, triggeringPrincipal);
+    } else {
+      // Check if the current browser is allowed to unload.
+      let {permitUnload, timedOut} = browser.permitUnload();
+      if (!timedOut && !permitUnload) {
+        return;
+      }
+
+      if (postData) {
+        postData = serializeInputStream(postData);
+      }
+
+      let loadParams = {
+        uri,
+        triggeringPrincipal: triggeringPrincipal
+          ? gSerializationHelper.serializeToString(triggeringPrincipal)
+          : null,
+        flags,
+        referrer: referrer ? referrer.spec : null,
+        referrerPolicy,
+        remoteType: requiredRemoteType,
+        postData,
+        newFrameloader,
+      };
+
+      if (params.userContextId) {
+        loadParams.userContextId = params.userContextId;
+      }
+
+      LoadInOtherProcess(browser, loadParams);
+    }
+  } catch (e) {
+    // If anything goes wrong when switching remoteness, just switch remoteness
+    // manually and load the URI.
+    // We might lose history that way but at least the browser loaded a page.
+    // This might be necessary if SessionStore wasn't initialized yet i.e.
+    // when the homepage is a non-remote page.
+    if (mustChangeProcess) {
+      Cu.reportError(e);
+      gBrowser.updateBrowserRemotenessByURL(browser, uri);
+
+      if (params.userContextId) {
+        browser.webNavigation.setOriginAttributesBeforeLoading({ userContextId: params.userContextId });
+      }
+
+      browser.webNavigation.loadURIWithOptions(uri, flags, referrer, referrerPolicy,
+                                               postData, null, null, triggeringPrincipal);
+    } else {
+      throw e;
+    }
+  } finally {
+    if (!requiredRemoteType) {
+      browser.inLoadURI = false;
+    }
+  }
+}
+
+// Starts a new load in the browser first switching the browser to the correct
+// process
+function LoadInOtherProcess(browser, loadOptions, historyIndex = -1) {
+  let tab = gBrowser.getTabForBrowser(browser);
+  SessionStore.navigateAndRestore(tab, loadOptions, historyIndex);
+}
+
+// Called when a docshell has attempted to load a page in an incorrect process.
+// This function is responsible for loading the page in the correct process.
+function RedirectLoad({ target: browser, data }) {
+  if (browser.getAttribute("preloadedState") === "consumed") {
+    browser.removeAttribute("preloadedState");
+    data.loadOptions.newFrameloader = true;
+  }
+
+  if (data.loadOptions.reloadInFreshProcess) {
+    // Convert the fresh process load option into a large allocation remote type
+    // to use common processing from this point.
+    data.loadOptions.remoteType = E10SUtils.LARGE_ALLOCATION_REMOTE_TYPE;
+    data.loadOptions.newFrameloader = true;
+  } else if (browser.remoteType == E10SUtils.LARGE_ALLOCATION_REMOTE_TYPE) {
+    // If we're in a Large-Allocation process, we prefer switching back into a
+    // normal content process, as that way we can clean up the L-A process.
+    data.loadOptions.remoteType =
+      E10SUtils.getRemoteTypeForURI(data.loadOptions.uri, gMultiProcessBrowser);
+  }
+
+  // We should only start the redirection if the browser window has finished
+  // starting up. Otherwise, we should wait until the startup is done.
+  if (gBrowserInit.delayedStartupFinished) {
+    LoadInOtherProcess(browser, data.loadOptions, data.historyIndex);
+  } else {
+    let delayedStartupFinished = (subject, topic) => {
+      if (topic == "browser-delayed-startup-finished" &&
+          subject == window) {
+        Services.obs.removeObserver(delayedStartupFinished, topic);
+        LoadInOtherProcess(browser, data.loadOptions, data.historyIndex);
+      }
+    };
+    Services.obs.addObserver(delayedStartupFinished,
+                             "browser-delayed-startup-finished");
+  }
+}
+
+if (document.documentElement.getAttribute("windowtype") == "navigator:browser") {
+  addEventListener("DOMContentLoaded", function() {
+    gBrowserInit.onDOMContentLoaded();
+  }, { once: true });
+}
+
+let _resolveDelayedStartup;
+var delayedStartupPromise = new Promise(resolve => {
+  _resolveDelayedStartup = resolve;
+});
+
+var gBrowserInit = {
+  delayedStartupFinished: false,
+
+  onDOMContentLoaded() {
+    window.QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(nsIWebNavigation)
+          .QueryInterface(Ci.nsIDocShellTreeItem).treeOwner
+          .QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIXULWindow)
+          .XULBrowserWindow = window.XULBrowserWindow;
+    window.QueryInterface(Ci.nsIDOMChromeWindow).browserDOMWindow =
+      new nsBrowserAccess();
+
+    let initBrowser =
+      document.getAnonymousElementByAttribute(gBrowser, "anonid", "initialBrowser");
+
+    // remoteType and sameProcessAsFrameLoader are passed through to
+    // updateBrowserRemoteness as part of an options object, which itself defaults
+    // to an empty object. So defaulting them to undefined here will cause the
+    // default behavior in updateBrowserRemoteness if they don't get set.
+    let isRemote = gMultiProcessBrowser;
+    let remoteType;
+    let sameProcessAsFrameLoader;
+
+    let tabArgument = window.arguments && window.arguments[0];
+    if (tabArgument instanceof XULElement) {
+      // The window's first argument is a tab if and only if we are swapping tabs.
+      // We must set the browser's usercontextid before updateBrowserRemoteness(),
+      // so that the newly created remote tab child has the correct usercontextid.
+      if (tabArgument.hasAttribute("usercontextid")) {
+        initBrowser.setAttribute("usercontextid",
+                                 tabArgument.getAttribute("usercontextid"));
+      }
+
+      let linkedBrowser = tabArgument.linkedBrowser;
+      if (linkedBrowser) {
+        remoteType = linkedBrowser.remoteType;
+        isRemote = remoteType != E10SUtils.NOT_REMOTE;
+        sameProcessAsFrameLoader = linkedBrowser.frameLoader;
+      }
+      initBrowser.removeAttribute("blank");
+    }
+
+    // Set a sane starting width/height for all resolutions on new profiles.
+    if (Services.prefs.getBoolPref("privacy.resistFingerprinting")) {
+      // When the fingerprinting resistance is enabled, making sure that we don't
+      // have a maximum window to interfere with generating rounded window dimensions.
+      document.documentElement.setAttribute("sizemode", "normal");
+    } else if (!document.documentElement.hasAttribute("width")) {
+      const TARGET_WIDTH = 1280;
+      const TARGET_HEIGHT = 1040;
+      let width = Math.min(screen.availWidth * .9, TARGET_WIDTH);
+      let height = Math.min(screen.availHeight * .9, TARGET_HEIGHT);
+
+      document.documentElement.setAttribute("width", width);
+      document.documentElement.setAttribute("height", height);
+
+      if (width < TARGET_WIDTH && height < TARGET_HEIGHT) {
+        document.documentElement.setAttribute("sizemode", "maximized");
+      }
+    }
+
+    gBrowser.updateBrowserRemoteness(initBrowser, isRemote, {
+      remoteType, sameProcessAsFrameLoader
+    });
+  },
+
+  onLoad() {
+    gBrowser.addEventListener("DOMUpdatePageReport", gPopupBlockerObserver);
+
+    Services.obs.addObserver(gPluginHandler.NPAPIPluginCrashed, "plugin-crashed");
+
+    window.addEventListener("AppCommand", HandleAppCommandEvent, true);
+
+    // These routines add message listeners. They must run before
+    // loading the frame script to ensure that we don't miss any
+    // message sent between when the frame script is loaded and when
+    // the listener is registered.
+    DOMEventHandler.init();
+    gPageStyleMenu.init();
+    LanguageDetectionListener.init();
+    BrowserOnClick.init();
+    FeedHandler.init();
+    CompactTheme.init();
+    AboutPrivateBrowsingListener.init();
+    TrackingProtection.init();
+    CaptivePortalWatcher.init();
+    ZoomUI.init(window);
+
+    let mm = window.getGroupMessageManager("browsers");
+    mm.loadFrameScript("chrome://browser/content/tab-content.js", true);
+    mm.loadFrameScript("chrome://browser/content/content.js", true);
+    mm.loadFrameScript("chrome://browser/content/content-UITour.js", true);
+    mm.loadFrameScript("chrome://global/content/content-HybridContentTelemetry.js", true);
+    mm.loadFrameScript("chrome://global/content/manifestMessages.js", true);
+
+    window.messageManager.addMessageListener("Browser:LoadURI", RedirectLoad);
+
+    if (!gMultiProcessBrowser) {
+      // There is a Content:Click message manually sent from content.
+      Services.els.addSystemEventListener(gBrowser, "click", contentAreaClick, true);
+    }
+
+    // hook up UI through progress listener
+    gBrowser.addProgressListener(window.XULBrowserWindow);
+    gBrowser.addTabsProgressListener(window.TabsProgressListener);
+
+    SidebarUI.init();
+
+    // We do this in onload because we want to ensure the button's state
+    // doesn't flicker as the window is being shown.
+    DownloadsButton.init();
+
+    // Certain kinds of automigration rely on this notification to complete
+    // their tasks BEFORE the browser window is shown. SessionStore uses it to
+    // restore tabs into windows AFTER important parts like gMultiProcessBrowser
+    // have been initialized.
+    Services.obs.notifyObservers(window, "browser-window-before-show");
+
+    gUIDensity.init();
+
+    if (AppConstants.CAN_DRAW_IN_TITLEBAR) {
+      gDragSpaceObserver.init();
+    }
+
+    if (!window.toolbar.visible) {
+      // adjust browser UI for popups
+      gURLBar.setAttribute("readonly", "true");
+    }
+
+    // Misc. inits.
+    TabletModeUpdater.init();
+    CombinedStopReload.ensureInitialized();
+    gPrivateBrowsingUI.init();
+    BrowserPageActions.init();
+    gAccessibilityServiceIndicator.init();
+
+    if (window.matchMedia("(-moz-os-version: windows-win8)").matches &&
+        window.matchMedia("(-moz-windows-default-theme)").matches) {
+      let windowFrameColor = new Color(...Cu.import("resource:///modules/Windows8WindowFrameColor.jsm", {})
+                                            .Windows8WindowFrameColor.get());
+      // Default to black for foreground text.
+      if (!windowFrameColor.isContrastRatioAcceptable(new Color(0, 0, 0))) {
+        document.documentElement.setAttribute("darkwindowframe", "true");
+      }
+    }
+
+    ToolbarIconColor.init();
+
+    gRemoteControl.updateVisualCue(Marionette.running);
+
+    // If we are given a tab to swap in, take care of it before first paint to
+    // avoid an about:blank flash.
+    let tabToOpen = window.arguments && window.arguments[0];
+    if (tabToOpen instanceof XULElement) {
+      // Clear the reference to the tab from the arguments array.
+      window.arguments[0] = null;
+
+      // Stop the about:blank load
+      gBrowser.stop();
+      // make sure it has a docshell
+      gBrowser.docShell;
+
+      try {
+        gBrowser.swapBrowsersAndCloseOther(gBrowser.selectedTab, tabToOpen);
+      } catch (e) {
+        Cu.reportError(e);
+      }
+    }
+
+    this._setInitialFocus();
+
+    // Hack to ensure that the about:home favicon is loaded
+    // instantaneously, to avoid flickering and improve perceived performance.
+    this._uriToLoadPromise.then(uriToLoad => {
+      if (uriToLoad == "about:home") {
+        gBrowser.setIcon(gBrowser.selectedTab, "chrome://branding/content/icon32.png");
+      } else if (uriToLoad == "about:privatebrowsing") {
+        gBrowser.setIcon(gBrowser.selectedTab, "chrome://browser/skin/privatebrowsing/favicon.svg");
+      }
+    });
+
+    // Wait until chrome is painted before executing code not critical to making the window visible
+    this._boundDelayedStartup = this._delayedStartup.bind(this);
+    window.addEventListener("MozAfterPaint", this._boundDelayedStartup);
+
+    this._loadHandled = true;
+  },
+
+  _cancelDelayedStartup() {
+    window.removeEventListener("MozAfterPaint", this._boundDelayedStartup);
+    this._boundDelayedStartup = null;
+  },
+
+  _delayedStartup() {
+    let tmp = {};
+    Cu.import("resource://gre/modules/TelemetryTimestamps.jsm", tmp);
+    let TelemetryTimestamps = tmp.TelemetryTimestamps;
+    TelemetryTimestamps.add("delayedStartupStarted");
+
+    this._cancelDelayedStartup();
+
+    // We need to set the OfflineApps message listeners up before we
+    // load homepages, which might need them.
+    OfflineApps.init();
+
+    // This pageshow listener needs to be registered before we may call
+    // swapBrowsersAndCloseOther() to receive pageshow events fired by that.
+    window.messageManager.addMessageListener("PageVisibility:Show", function(message) {
+      if (message.target == gBrowser.selectedBrowser) {
+        setTimeout(pageShowEventHandlers, 0, message.data.persisted);
+      }
+    });
+
+    gBrowser.addEventListener("AboutTabCrashedLoad", function(event) {
+      let ownerDoc = event.originalTarget;
+
+      if (!ownerDoc.documentURI.startsWith("about:tabcrashed")) {
+        return;
+      }
+
+      let browser = gBrowser.getBrowserForDocument(event.target);
+      // Reset the zoom for the tabcrashed page.
+      ZoomManager.setZoomForBrowser(browser, 1);
+    }, false, true);
+
+    gBrowser.addEventListener("InsecureLoginFormsStateChange", function() {
+      gIdentityHandler.refreshForInsecureLoginForms();
+    });
+
+    gBrowser.addEventListener("PermissionStateChange", function() {
+      gIdentityHandler.refreshIdentityBlock();
+    });
+
+    // Get the service so that it initializes and registers listeners for new
+    // tab pages in order to be ready for any early-loading about:newtab pages,
+    // e.g., start/home page, command line / startup uris to load, sessionstore
+    gAboutNewTabService.QueryInterface(Ci.nsISupports);
+
+    this._handleURIToLoad();
+
+    Services.obs.addObserver(gIdentityHandler, "perm-changed");
+    Services.obs.addObserver(gRemoteControl, "remote-active");
+    Services.obs.addObserver(gSessionHistoryObserver, "browser:purge-session-history");
+    Services.obs.addObserver(gStoragePressureObserver, "QuotaManager::StoragePressure");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-disabled");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-started");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-blocked");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-origin-blocked");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-failed");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-confirmation");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-complete");
+    window.messageManager.addMessageListener("Browser:URIFixup", gKeywordURIFixup);
+
+    BrowserOffline.init();
+    IndexedDBPromptHelper.init();
+    CanvasPermissionPromptHelper.init();
+
+    // Initialize the full zoom setting.
+    // We do this before the session restore service gets initialized so we can
+    // apply full zoom settings to tabs restored by the session restore service.
+    FullZoom.init();
+    PanelUI.init();
+
+    UpdateUrlbarSearchSplitterState();
+
+    // Enable/Disable auto-hide tabbar
+    gBrowser.tabContainer.updateVisibility();
+
+    BookmarkingUI.init();
+    AutoShowBookmarksToolbar.init();
+
+    Services.prefs.addObserver(gHomeButton.prefDomain, gHomeButton);
+
+    var homeButton = document.getElementById("home-button");
+    gHomeButton.updateTooltip(homeButton);
+
+    let safeMode = document.getElementById("helpSafeMode");
+    if (Services.appinfo.inSafeMode) {
+      safeMode.label = safeMode.getAttribute("stoplabel");
+      safeMode.accesskey = safeMode.getAttribute("stopaccesskey");
+    }
+
+    // BiDi UI
+    gBidiUI = isBidiEnabled();
+    if (gBidiUI) {
+      document.getElementById("documentDirection-separator").hidden = false;
+      document.getElementById("documentDirection-swap").hidden = false;
+      document.getElementById("textfieldDirection-separator").hidden = false;
+      document.getElementById("textfieldDirection-swap").hidden = false;
+    }
+
+    // Setup click-and-hold gestures access to the session history
+    // menus if global click-and-hold isn't turned on
+    if (!getBoolPref("ui.click_hold_context_menus", false))
+      SetClickAndHoldHandlers();
+
+    Cu.import("resource:///modules/UpdateTopLevelContentWindowIDHelper.jsm", {})
+      .trackBrowserWindow(window);
+
+    PlacesToolbarHelper.init();
+
+    ctrlTab.readPref();
+    Services.prefs.addObserver(ctrlTab.prefName, ctrlTab);
+
+    // The object handling the downloads indicator is initialized here in the
+    // delayed startup function, but the actual indicator element is not loaded
+    // unless there are downloads to be displayed.
+    DownloadsButton.initializeIndicator();
+
+    if (AppConstants.platform != "macosx") {
+      updateEditUIVisibility();
+      let placesContext = document.getElementById("placesContext");
+      placesContext.addEventListener("popupshowing", updateEditUIVisibility);
+      placesContext.addEventListener("popuphiding", updateEditUIVisibility);
+    }
+
+    LightWeightThemeWebInstaller.init();
+
+    if (Win7Features)
+      Win7Features.onOpenWindow();
+
+    FullScreen.init();
+    PointerLock.init();
+
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+      MenuTouchModeObserver.init();
+    }
+
+    if (AppConstants.MOZ_DATA_REPORTING)
+      gDataNotificationInfoBar.init();
+
+    if (!AppConstants.MOZILLA_OFFICIAL)
+      DevelopmentHelpers.init();
+
+    gExtensionsNotifications.init();
+
+    let wasMinimized = window.windowState == window.STATE_MINIMIZED;
+    window.addEventListener("sizemodechange", () => {
+      let isMinimized = window.windowState == window.STATE_MINIMIZED;
+      if (wasMinimized != isMinimized) {
+        wasMinimized = isMinimized;
+        UpdatePopupNotificationsVisibility();
+      }
+    });
+
+    window.addEventListener("mousemove", MousePosTracker);
+    window.addEventListener("dragover", MousePosTracker);
+
+    gNavToolbox.addEventListener("customizationstarting", CustomizationHandler);
+    gNavToolbox.addEventListener("customizationending", CustomizationHandler);
+
+    SessionStore.promiseInitialized.then(() => {
+      // Bail out if the window has been closed in the meantime.
+      if (window.closed) {
+        return;
+      }
+
+      // Enable the Restore Last Session command if needed
+      RestoreLastSessionObserver.init();
+
+      SidebarUI.startDelayedLoad();
+
+      PanicButtonNotifier.init();
+    });
+
+    gBrowser.tabContainer.addEventListener("TabSelect", function() {
+      for (let panel of document.querySelectorAll("panel[tabspecific='true']")) {
+        if (panel.state == "open") {
+          panel.hidePopup();
+        }
+      }
+    });
+
+    this.delayedStartupFinished = true;
+
+    _resolveDelayedStartup();
+
+    SessionStore.promiseAllWindowsRestored.then(() => {
+      this._schedulePerWindowIdleTasks();
+      document.documentElement.setAttribute("sessionrestored", "true");
+    });
+
+    Services.obs.notifyObservers(window, "browser-delayed-startup-finished");
+    TelemetryTimestamps.add("delayedStartupFinished");
+  },
+
+  _setInitialFocus() {
+    let initiallyFocusedElement = document.commandDispatcher.focusedElement;
+
+    let firstBrowserPaintDeferred = {};
+    firstBrowserPaintDeferred.promise = new Promise(resolve => {
+      firstBrowserPaintDeferred.resolve = resolve;
+    });
+
+    let mm = window.messageManager;
+    mm.addMessageListener("Browser:FirstPaint", function onFirstPaint() {
+      mm.removeMessageListener("Browser:FirstPaint", onFirstPaint);
+      firstBrowserPaintDeferred.resolve();
+    });
+
+    let initialBrowser = gBrowser.selectedBrowser;
+    mm.addMessageListener("Browser:FirstNonBlankPaint",
+                          function onFirstNonBlankPaint() {
+      mm.removeMessageListener("Browser:FirstNonBlankPaint", onFirstNonBlankPaint);
+      initialBrowser.removeAttribute("blank");
+    });
+
+    this._uriToLoadPromise.then(uriToLoad => {
+      if ((isBlankPageURL(uriToLoad) || uriToLoad == "about:privatebrowsing") &&
+          focusAndSelectUrlBar()) {
+        return;
+      }
+
+      if (gBrowser.selectedBrowser.isRemoteBrowser) {
+        // If the initial browser is remote, in order to optimize for first paint,
+        // we'll defer switching focus to that browser until it has painted.
+        firstBrowserPaintDeferred.promise.then(() => {
+          // If focus didn't move while we were waiting for first paint, we're okay
+          // to move to the browser.
+          if (document.commandDispatcher.focusedElement == initiallyFocusedElement) {
+            gBrowser.selectedBrowser.focus();
+          }
+        });
+      } else {
+        // If the initial browser is not remote, we can focus the browser
+        // immediately with no paint performance impact.
+        gBrowser.selectedBrowser.focus();
+      }
+    });
+  },
+
+  _handleURIToLoad() {
+    this._uriToLoadPromise.then(uriToLoad => {
+      if (!uriToLoad || uriToLoad == "about:blank") {
+        return;
+      }
+
+      // We don't check if uriToLoad is a XULElement because this case has
+      // already been handled before first paint, and the argument cleared.
+      if (uriToLoad instanceof Ci.nsIArray) {
+        let count = uriToLoad.length;
+        let specs = [];
+        for (let i = 0; i < count; i++) {
+          let urisstring = uriToLoad.queryElementAt(i, Ci.nsISupportsString);
+          specs.push(urisstring.data);
+        }
+
+        // This function throws for certain malformed URIs, so use exception handling
+        // so that we don't disrupt startup
+        try {
+          gBrowser.loadTabs(specs, {
+            inBackground: false,
+            replace: true,
+            triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+          });
+        } catch (e) {}
+      } else if (window.arguments.length >= 3) {
+        // window.arguments[2]: referrer (nsIURI | string)
+        //                 [3]: postData (nsIInputStream)
+        //                 [4]: allowThirdPartyFixup (bool)
+        //                 [5]: referrerPolicy (int)
+        //                 [6]: userContextId (int)
+        //                 [7]: originPrincipal (nsIPrincipal)
+        //                 [8]: triggeringPrincipal (nsIPrincipal)
+        let referrerURI = window.arguments[2];
+        if (typeof(referrerURI) == "string") {
+          try {
+            referrerURI = makeURI(referrerURI);
+          } catch (e) {
+            referrerURI = null;
+          }
+        }
+        let referrerPolicy = (window.arguments[5] != undefined ?
+            window.arguments[5] : Ci.nsIHttpChannel.REFERRER_POLICY_UNSET);
+        let userContextId = (window.arguments[6] != undefined ?
+            window.arguments[6] : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID);
+        loadURI(uriToLoad, referrerURI, window.arguments[3] || null,
+                window.arguments[4] || false, referrerPolicy, userContextId,
+                // pass the origin principal (if any) and force its use to create
+                // an initial about:blank viewer if present:
+                window.arguments[7], !!window.arguments[7], window.arguments[8]);
+        window.focus();
+      } else {
+        // Note: loadOneOrMoreURIs *must not* be called if window.arguments.length >= 3.
+        // Such callers expect that window.arguments[0] is handled as a single URI.
+        loadOneOrMoreURIs(uriToLoad, Services.scriptSecurityManager.getSystemPrincipal());
+      }
+    });
+  },
+
+  /**
+   * Use this function as an entry point to schedule tasks that
+   * need to run once per window after startup, and can be scheduled
+   * by using an idle callback.
+   *
+   * The functions scheduled here will fire from idle callbacks
+   * once every window has finished being restored by session
+   * restore, and after the equivalent only-once tasks
+   * have run (from _scheduleStartupIdleTasks in nsBrowserGlue.js).
+   */
+  _schedulePerWindowIdleTasks() {
+    // Bail out if the window has been closed in the meantime.
+    if (window.closed) {
+      return;
+    }
+
+    function scheduleIdleTask(func, options) {
+      requestIdleCallback(function idleTaskRunner() {
+        if (!window.closed) {
+          func();
+        }
+      }, options);
+    }
+
+    scheduleIdleTask(() => {
+      // Initialize the Sync UI
+      gSync.init();
+    });
+
+    scheduleIdleTask(() => {
+      CombinedStopReload.startAnimationPrefMonitoring();
+    });
+
+    scheduleIdleTask(() => {
+      // setup simple gestures support
+      gGestureSupport.init(true);
+
+      // setup history swipe animation
+      gHistorySwipeAnimation.init();
+    });
+
+    scheduleIdleTask(() => {
+      gBrowserThumbnails.init();
+    });
+
+    scheduleIdleTask(() => {
+      // Initialize the download manager some time after the app starts so that
+      // auto-resume downloads begin (such as after crashing or quitting with
+      // active downloads) and speeds up the first-load of the download manager UI.
+      // If the user manually opens the download manager before the timeout, the
+      // downloads will start right away, and initializing again won't hurt.
+      try {
+        DownloadsCommon.initializeAllDataLinks();
+        Cu.import("resource:///modules/DownloadsTaskbar.jsm", {})
+          .DownloadsTaskbar.registerIndicator(window);
+      } catch (ex) {
+        Cu.reportError(ex);
+      }
+    }, {timeout: 10000});
+  },
+
+  // Returns the URI(s) to load at startup.
+  get _uriToLoadPromise() {
+    delete this._uriToLoadPromise;
+    return this._uriToLoadPromise = new Promise(resolve => {
+      // window.arguments[0]: URI to load (string), or an nsIArray of
+      //                      nsISupportsStrings to load, or a xul:tab of
+      //                      a tabbrowser, which will be replaced by this
+      //                      window (for this case, all other arguments are
+      //                      ignored).
+      if (!window.arguments || !window.arguments[0]) {
+        resolve(null);
+        return;
+      }
+
+      let uri = window.arguments[0];
+      let defaultArgs = Cc["@mozilla.org/browser/clh;1"]
+                          .getService(Ci.nsIBrowserHandler)
+                          .defaultArgs;
+
+      // If the given URI is different from the homepage, we want to load it.
+      if (uri != defaultArgs) {
+        resolve(uri);
+        return;
+      }
+
+      // The URI appears to be the the homepage. We want to load it only if
+      // session restore isn't about to override the homepage.
+      SessionStartup.willOverrideHomepagePromise.then(willOverrideHomepage => {
+        resolve(willOverrideHomepage ? null : uri);
+      });
+    });
+  },
+
+  onUnload() {
+    // In certain scenarios it's possible for unload to be fired before onload,
+    // (e.g. if the window is being closed after browser.js loads but before the
+    // load completes). In that case, there's nothing to do here.
+    if (!this._loadHandled)
+      return;
+
+    // First clean up services initialized in gBrowserInit.onLoad (or those whose
+    // uninit methods don't depend on the services having been initialized).
+
+    CombinedStopReload.uninit();
+
+    gGestureSupport.init(false);
+
+    gHistorySwipeAnimation.uninit();
+
+    FullScreen.uninit();
+
+    gSync.uninit();
+
+    gExtensionsNotifications.uninit();
+
+    Services.obs.removeObserver(gPluginHandler.NPAPIPluginCrashed, "plugin-crashed");
+
+    gUIDensity.uninit();
+
+    if (AppConstants.CAN_DRAW_IN_TITLEBAR) {
+      gDragSpaceObserver.uninit();
+    }
+
+    try {
+      gBrowser.removeProgressListener(window.XULBrowserWindow);
+      gBrowser.removeTabsProgressListener(window.TabsProgressListener);
+    } catch (ex) {
+    }
+
+    PlacesToolbarHelper.uninit();
+
+    BookmarkingUI.uninit();
+
+    TabsInTitlebar.uninit();
+
+    ToolbarIconColor.uninit();
+
+    TabletModeUpdater.uninit();
+
+    gTabletModePageCounter.finish();
+
+    BrowserOnClick.uninit();
+
+    FeedHandler.uninit();
+
+    CompactTheme.uninit();
+
+    TrackingProtection.uninit();
+
+    CaptivePortalWatcher.uninit();
+
+    SidebarUI.uninit();
+
+    DownloadsButton.uninit();
+
+    gAccessibilityServiceIndicator.uninit();
+
+    LanguagePrompt.uninit();
+
+    // Now either cancel delayedStartup, or clean up the services initialized from
+    // it.
+    if (this._boundDelayedStartup) {
+      this._cancelDelayedStartup();
+    } else {
+      if (Win7Features)
+        Win7Features.onCloseWindow();
+
+      Services.prefs.removeObserver(ctrlTab.prefName, ctrlTab);
+      ctrlTab.uninit();
+      gBrowserThumbnails.uninit();
+      FullZoom.destroy();
+
+      Services.obs.removeObserver(gIdentityHandler, "perm-changed");
+      Services.obs.removeObserver(gRemoteControl, "remote-active");
+      Services.obs.removeObserver(gSessionHistoryObserver, "browser:purge-session-history");
+      Services.obs.removeObserver(gStoragePressureObserver, "QuotaManager::StoragePressure");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-disabled");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-started");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-blocked");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-origin-blocked");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-failed");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-confirmation");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-complete");
+      window.messageManager.removeMessageListener("Browser:URIFixup", gKeywordURIFixup);
+      window.messageManager.removeMessageListener("Browser:LoadURI", RedirectLoad);
+
+      try {
+        Services.prefs.removeObserver(gHomeButton.prefDomain, gHomeButton);
+      } catch (ex) {
+        Cu.reportError(ex);
+      }
+
+      if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+        MenuTouchModeObserver.uninit();
+      }
+      BrowserOffline.uninit();
+      IndexedDBPromptHelper.uninit();
+      CanvasPermissionPromptHelper.uninit();
+      PanelUI.uninit();
+      AutoShowBookmarksToolbar.uninit();
+    }
+
+    // Final window teardown, do this last.
+    window.XULBrowserWindow = null;
+    window.QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIWebNavigation)
+          .QueryInterface(Ci.nsIDocShellTreeItem).treeOwner
+          .QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIXULWindow)
+          .XULBrowserWindow = null;
+    window.QueryInterface(Ci.nsIDOMChromeWindow).browserDOMWindow = null;
+  },
+};
+
+if (AppConstants.platform == "macosx") {
+  // nonBrowserWindowStartup(), nonBrowserWindowDelayedStartup(), and
+  // nonBrowserWindowShutdown() are used for non-browser windows in
+  // macBrowserOverlay
+  gBrowserInit.nonBrowserWindowStartup = function() {
+    // Disable inappropriate commands / submenus
+    var disabledItems = ["Browser:SavePage",
+                         "Browser:SendLink", "cmd_pageSetup", "cmd_print", "cmd_find", "cmd_findAgain",
+                         "viewToolbarsMenu", "viewSidebarMenuMenu", "Browser:Reload",
+                         "viewFullZoomMenu", "pageStyleMenu", "charsetMenu", "View:PageSource", "View:FullScreen",
+                         "viewHistorySidebar", "Browser:AddBookmarkAs", "Browser:BookmarkAllTabs",
+                         "View:PageInfo"];
+    var element;
+
+    for (let disabledItem of disabledItems) {
+      element = document.getElementById(disabledItem);
+      if (element)
+        element.setAttribute("disabled", "true");
+    }
+
+    // If no windows are active (i.e. we're the hidden window), disable the close, minimize
+    // and zoom menu commands as well
+    if (window.location.href == "chrome://browser/content/hiddenWindow.xul") {
+      var hiddenWindowDisabledItems = ["cmd_close", "minimizeWindow", "zoomWindow"];
+      for (let hiddenWindowDisabledItem of hiddenWindowDisabledItems) {
+        element = document.getElementById(hiddenWindowDisabledItem);
+        if (element)
+          element.setAttribute("disabled", "true");
+      }
+
+      // also hide the window-list separator
+      element = document.getElementById("sep-window-list");
+      element.setAttribute("hidden", "true");
+
+      // Setup the dock menu.
+      let dockMenuElement = document.getElementById("menu_mac_dockmenu");
+      if (dockMenuElement != null) {
+        let nativeMenu = Cc["@mozilla.org/widget/standalonenativemenu;1"]
+                         .createInstance(Ci.nsIStandaloneNativeMenu);
+
+        try {
+          nativeMenu.init(dockMenuElement);
+
+          let dockSupport = Cc["@mozilla.org/widget/macdocksupport;1"]
+                            .getService(Ci.nsIMacDockSupport);
+          dockSupport.dockMenu = nativeMenu;
+        } catch (e) {
+        }
+      }
+    }
+
+    if (PrivateBrowsingUtils.permanentPrivateBrowsing) {
+      document.getElementById("macDockMenuNewWindow").hidden = true;
+    }
+
+    this._delayedStartupTimeoutId = setTimeout(this.nonBrowserWindowDelayedStartup.bind(this), 0);
+  };
+
+  gBrowserInit.nonBrowserWindowDelayedStartup = function() {
+    this._delayedStartupTimeoutId = null;
+
+    // initialise the offline listener
+    BrowserOffline.init();
+
+    // initialize the private browsing UI
+    gPrivateBrowsingUI.init();
+
+  };
+
+  gBrowserInit.nonBrowserWindowShutdown = function() {
+    let dockSupport = Cc["@mozilla.org/widget/macdocksupport;1"]
+                      .getService(Ci.nsIMacDockSupport);
+    dockSupport.dockMenu = null;
+
+    // If nonBrowserWindowDelayedStartup hasn't run yet, we have no work to do -
+    // just cancel the pending timeout and return;
+    if (this._delayedStartupTimeoutId) {
+      clearTimeout(this._delayedStartupTimeoutId);
+      return;
+    }
+
+    BrowserOffline.uninit();
+  };
+}
+
+function HandleAppCommandEvent(evt) {
+  switch (evt.command) {
+  case "Back":
+    BrowserBack();
+    break;
+  case "Forward":
+    BrowserForward();
+    break;
+  case "Reload":
+    BrowserReloadSkipCache();
+    break;
+  case "Stop":
+    if (XULBrowserWindow.stopCommand.getAttribute("disabled") != "true")
+      BrowserStop();
+    break;
+  case "Search":
+    BrowserSearch.webSearch();
+    break;
+  case "Bookmarks":
+    SidebarUI.toggle("viewBookmarksSidebar");
+    break;
+  case "Home":
+    BrowserHome();
+    break;
+  case "New":
+    BrowserOpenTab();
+    break;
+  case "Close":
+    BrowserCloseTabOrWindow();
+    break;
+  case "Find":
+    gFindBar.onFindCommand();
+    break;
+  case "Help":
+    openHelpLink("firefox-help");
+    break;
+  case "Open":
+    BrowserOpenFileWindow();
+    break;
+  case "Print":
+    PrintUtils.printWindow(gBrowser.selectedBrowser.outerWindowID,
+                           gBrowser.selectedBrowser);
+    break;
+  case "Save":
+    saveBrowser(gBrowser.selectedBrowser);
+    break;
+  case "SendMail":
+    MailIntegration.sendLinkForBrowser(gBrowser.selectedBrowser);
+    break;
+  default:
+    return;
+  }
+  evt.stopPropagation();
+  evt.preventDefault();
+}
+
+function maybeRecordAbandonmentTelemetry(tab, type) {
+  if (!tab.hasAttribute("busy")) {
+    return;
+  }
+
+  let histogram = Services.telemetry
+                          .getHistogramById("BUSY_TAB_ABANDONED");
+  histogram.add(type);
+}
+
+function gotoHistoryIndex(aEvent) {
+  let index = aEvent.target.getAttribute("index");
+  if (!index)
+    return false;
+
+  let where = whereToOpenLink(aEvent);
+
+  if (where == "current") {
+    // Normal click. Go there in the current tab and update session history.
+
+    try {
+      maybeRecordAbandonmentTelemetry(gBrowser.selectedTab,
+                                      "historyNavigation");
+      gBrowser.gotoIndex(index);
+    } catch (ex) {
+      return false;
+    }
+    return true;
+  }
+  // Modified click. Go there in a new tab/window.
+
+  let historyindex = aEvent.target.getAttribute("historyindex");
+  duplicateTabIn(gBrowser.selectedTab, where, Number(historyindex));
+  return true;
+}
+
+function BrowserForward(aEvent) {
+  let where = whereToOpenLink(aEvent, false, true);
+
+  if (where == "current") {
+    try {
+      maybeRecordAbandonmentTelemetry(gBrowser.selectedTab, "forward");
+      gBrowser.goForward();
+    } catch (ex) {
+    }
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where, 1);
+  }
+}
+
+function BrowserBack(aEvent) {
+  let where = whereToOpenLink(aEvent, false, true);
+
+  if (where == "current") {
+    try {
+      maybeRecordAbandonmentTelemetry(gBrowser.selectedTab, "back");
+      gBrowser.goBack();
+    } catch (ex) {
+    }
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where, -1);
+  }
+}
+
+function BrowserHandleBackspace() {
+  switch (Services.prefs.getIntPref("browser.backspace_action")) {
+  case 0:
+    BrowserBack();
+    break;
+  case 1:
+    goDoCommand("cmd_scrollPageUp");
+    break;
+  }
+}
+
+function BrowserHandleShiftBackspace() {
+  switch (Services.prefs.getIntPref("browser.backspace_action")) {
+  case 0:
+    BrowserForward();
+    break;
+  case 1:
+    goDoCommand("cmd_scrollPageDown");
+    break;
+  }
+}
+
+function BrowserStop() {
+  const stopFlags = nsIWebNavigation.STOP_ALL;
+  maybeRecordAbandonmentTelemetry(gBrowser.selectedTab, "stop");
+  gBrowser.webNavigation.stop(stopFlags);
+}
+
+function BrowserReloadOrDuplicate(aEvent) {
+  let metaKeyPressed = AppConstants.platform == "macosx"
+                       ? aEvent.metaKey
+                       : aEvent.ctrlKey;
+  var backgroundTabModifier = aEvent.button == 1 || metaKeyPressed;
+
+  if (aEvent.shiftKey && !backgroundTabModifier) {
+    BrowserReloadSkipCache();
+    return;
+  }
+
+  let where = whereToOpenLink(aEvent, false, true);
+  if (where == "current")
+    BrowserReload();
+  else
+    duplicateTabIn(gBrowser.selectedTab, where);
+}
+
+function BrowserReload() {
+  if (gBrowser.currentURI.schemeIs("view-source")) {
+    // Bug 1167797: For view source, we always skip the cache
+    return BrowserReloadSkipCache();
+  }
+  const reloadFlags = nsIWebNavigation.LOAD_FLAGS_NONE;
+  BrowserReloadWithFlags(reloadFlags);
+}
+
+function BrowserReloadSkipCache() {
+  // Bypass proxy and cache.
+  const reloadFlags = nsIWebNavigation.LOAD_FLAGS_BYPASS_PROXY | nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;
+  BrowserReloadWithFlags(reloadFlags);
+}
+
+var BrowserHome = BrowserGoHome;
+function BrowserGoHome(aEvent) {
+  if (aEvent && "button" in aEvent &&
+      aEvent.button == 2) // right-click: do nothing
+    return;
+
+  var homePage = gHomeButton.getHomePage();
+  var where = whereToOpenLink(aEvent, false, true);
+  var urls;
+
+  // Home page should open in a new tab when current tab is an app tab
+  if (where == "current" &&
+      gBrowser &&
+      gBrowser.selectedTab.pinned)
+    where = "tab";
+
+  // openUILinkIn in utilityOverlay.js doesn't handle loading multiple pages
+  switch (where) {
+  case "current":
+    loadOneOrMoreURIs(homePage, Services.scriptSecurityManager.getSystemPrincipal());
+    gBrowser.selectedBrowser.focus();
+    break;
+  case "tabshifted":
+  case "tab":
+    urls = homePage.split("|");
+    var loadInBackground = getBoolPref("browser.tabs.loadBookmarksInBackground", false);
+    gBrowser.loadTabs(urls, {
+      inBackground: loadInBackground,
+      triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+    });
+    break;
+  case "window":
+    OpenBrowserWindow();
+    break;
+  }
+}
+
+function loadOneOrMoreURIs(aURIString, aTriggeringPrincipal) {
+  // we're not a browser window, pass the URI string to a new browser window
+  if (window.location.href != getBrowserURL()) {
+    window.openDialog(getBrowserURL(), "_blank", "all,dialog=no", aURIString);
+    return;
+  }
+
+  // This function throws for certain malformed URIs, so use exception handling
+  // so that we don't disrupt startup
+  try {
+    gBrowser.loadTabs(aURIString.split("|"), {
+      inBackground: false,
+      replace: true,
+      triggeringPrincipal: aTriggeringPrincipal,
+    });
+  } catch (e) {
+  }
+}
+
+/**
+ * Focuses the location bar input field and selects its contents.
+ *
+ * @param [optional] userInitiatedFocus
+ *        Whether this focus is caused by an user interaction whose intention
+ *        was to use the location bar. For example, using a shortcut to go to
+ *        the location bar, or a contextual menu to search from it.
+ *        The default is false and should be used in all those cases where the
+ *        code focuses the location bar but that's not the primary user
+ *        intention, like when opening a new tab.
+ */
+function focusAndSelectUrlBar(userInitiatedFocus = false) {
+  // In customize mode, the url bar is disabled. If a new tab is opened or the
+  // user switches to a different tab, this function gets called before we've
+  // finished leaving customize mode, and the url bar will still be disabled.
+  // We can't focus it when it's disabled, so we need to re-run ourselves when
+  // we've finished leaving customize mode.
+  if (CustomizationHandler.isExitingCustomizeMode) {
+    gNavToolbox.addEventListener("aftercustomization", function() {
+      focusAndSelectUrlBar(userInitiatedFocus);
+    }, {once: true});
+
+    return true;
+  }
+
+  if (gURLBar) {
+    if (window.fullScreen)
+      FullScreen.showNavToolbox();
+
+    gURLBar.userInitiatedFocus = userInitiatedFocus;
+    gURLBar.select();
+    gURLBar.userInitiatedFocus = false;
+    if (document.activeElement == gURLBar.inputField)
+      return true;
+  }
+  return false;
+}
+
+function openLocation() {
+  if (focusAndSelectUrlBar(true))
+    return;
+
+  if (window.location.href != getBrowserURL()) {
+    var win = getTopWin();
+    if (win) {
+      // If there's an open browser window, it should handle this command
+      win.focus();
+      win.openLocation();
+    } else {
+      // If there are no open browser windows, open a new one
+      window.openDialog("chrome://browser/content/", "_blank",
+                        "chrome,all,dialog=no", BROWSER_NEW_TAB_URL);
+    }
+  }
+}
+
+function BrowserOpenTab(event) {
+  // A notification intended to be useful for modular peformance tracking
+  // starting as close as is reasonably possible to the time when the user
+  // expressed the intent to open a new tab.  Since there are a lot of
+  // entry points, this won't catch every single tab created, but most
+  // initiated by the user should go through here.
+  Services.obs.notifyObservers(null, "browser-open-newtab-start");
+
+  let where = "tab";
+  let relatedToCurrent = false;
+
+  if (event) {
+    where = whereToOpenLink(event, false, true);
+
+    switch (where) {
+      case "tab":
+      case "tabshifted":
+        // When accel-click or middle-click are used, open the new tab as
+        // related to the current tab.
+        relatedToCurrent = true;
+        break;
+      case "current":
+        where = "tab";
+        break;
+    }
+  }
+
+  openUILinkIn(BROWSER_NEW_TAB_URL, where, { relatedToCurrent });
+}
+
+var gLastOpenDirectory = {
+  _lastDir: null,
+  get path() {
+    if (!this._lastDir || !this._lastDir.exists()) {
+      try {
+        this._lastDir = Services.prefs.getComplexValue("browser.open.lastDir",
+                                                       Ci.nsIFile);
+        if (!this._lastDir.exists())
+          this._lastDir = null;
+      } catch (e) {}
+    }
+    return this._lastDir;
+  },
+  set path(val) {
+    try {
+      if (!val || !val.isDirectory())
+        return;
+    } catch (e) {
+      return;
+    }
+    this._lastDir = val.clone();
+
+    // Don't save the last open directory pref inside the Private Browsing mode
+    if (!PrivateBrowsingUtils.isWindowPrivate(window))
+      Services.prefs.setComplexValue("browser.open.lastDir", Ci.nsIFile,
+                                     this._lastDir);
+  },
+  reset() {
+    this._lastDir = null;
+  }
+};
+
+function BrowserOpenFileWindow() {
+  // Get filepicker component.
+  try {
+    const nsIFilePicker = Ci.nsIFilePicker;
+    let fp = Cc["@mozilla.org/filepicker;1"].createInstance(nsIFilePicker);
+    let fpCallback = function fpCallback_done(aResult) {
+      if (aResult == nsIFilePicker.returnOK) {
+        try {
+          if (fp.file) {
+            gLastOpenDirectory.path =
+              fp.file.parent.QueryInterface(Ci.nsIFile);
+          }
+        } catch (ex) {
+        }
+        openUILinkIn(fp.fileURL.spec, "current");
+      }
+    };
+
+    fp.init(window, gNavigatorBundle.getString("openFile"),
+            nsIFilePicker.modeOpen);
+    fp.appendFilters(nsIFilePicker.filterAll | nsIFilePicker.filterText |
+                     nsIFilePicker.filterImages | nsIFilePicker.filterXML |
+                     nsIFilePicker.filterHTML);
+    fp.displayDirectory = gLastOpenDirectory.path;
+    fp.open(fpCallback);
+  } catch (ex) {
+  }
+}
+
+function BrowserCloseTabOrWindow(event) {
+  // If we're not a browser window, just close the window.
+  if (window.location.href != getBrowserURL()) {
+    closeWindow(true);
+    return;
+  }
+
+  // Keyboard shortcuts that would close a tab that is pinned select the first
+  // unpinned tab instead.
+  if (event &&
+      (event.ctrlKey || event.metaKey || event.altKey) &&
+      gBrowser.selectedTab.pinned) {
+    if (gBrowser.visibleTabs.length > gBrowser._numPinnedTabs) {
+      gBrowser.tabContainer.selectedIndex = gBrowser._numPinnedTabs;
+    }
+    return;
+  }
+
+  // If the current tab is the last one, this will close the window.
+  gBrowser.removeCurrentTab({animate: true});
+}
+
+function BrowserTryToCloseWindow() {
+  if (WindowIsClosing())
+    window.close(); // WindowIsClosing does all the necessary checks
+}
+
+function loadURI(uri, referrer, postData, allowThirdPartyFixup, referrerPolicy,
+                 userContextId, originPrincipal, forceAboutBlankViewerInCurrent,
+                 triggeringPrincipal) {
+  try {
+    openLinkIn(uri, "current",
+               { referrerURI: referrer,
+                 referrerPolicy,
+                 postData,
+                 allowThirdPartyFixup,
+                 userContextId,
+                 originPrincipal,
+                 triggeringPrincipal,
+                 forceAboutBlankViewerInCurrent,
+               });
+  } catch (e) {}
+}
+
+/**
+ * Given a string, will generate a more appropriate urlbar value if a Places
+ * keyword or a search alias is found at the beginning of it.
+ *
+ * @param url
+ *        A string that may begin with a keyword or an alias.
+ *
+ * @return {Promise}
+ * @resolves { url, postData, mayInheritPrincipal }. If it's not possible
+ *           to discern a keyword or an alias, url will be the input string.
+ */
+function getShortcutOrURIAndPostData(url, callback = null) {
+  if (callback) {
+    Deprecated.warning("Please use the Promise returned by " +
+                       "getShortcutOrURIAndPostData() instead of passing a " +
+                       "callback",
+                       "https://bugzilla.mozilla.org/show_bug.cgi?id=1100294");
+  }
+  return (async function() {
+    let mayInheritPrincipal = false;
+    let postData = null;
+    // Split on the first whitespace.
+    let [keyword, param = ""] = url.trim().split(/\s(.+)/, 2);
+
+    if (!keyword) {
+      return { url, postData, mayInheritPrincipal };
+    }
+
+    let engine = Services.search.getEngineByAlias(keyword);
+    if (engine) {
+      let submission = engine.getSubmission(param, null, "keyword");
+      return { url: submission.uri.spec,
+               postData: submission.postData,
+               mayInheritPrincipal };
+    }
+
+    // A corrupt Places database could make this throw, breaking navigation
+    // from the location bar.
+    let entry = null;
+    try {
+      entry = await PlacesUtils.keywords.fetch(keyword);
+    } catch (ex) {
+      Cu.reportError(`Unable to fetch Places keyword "${keyword}": ${ex}`);
+    }
+    if (!entry || !entry.url) {
+      // This is not a Places keyword.
+      return { url, postData, mayInheritPrincipal };
+    }
+
+    try {
+      [url, postData] =
+        await BrowserUtils.parseUrlAndPostData(entry.url.href,
+                                               entry.postData,
+                                               param);
+      if (postData) {
+        postData = getPostDataStream(postData);
+      }
+
+      // Since this URL came from a bookmark, it's safe to let it inherit the
+      // current document's principal.
+      mayInheritPrincipal = true;
+    } catch (ex) {
+      // It was not possible to bind the param, just use the original url value.
+    }
+
+    return { url, postData, mayInheritPrincipal };
+  })().then(data => {
+    if (callback) {
+      callback(data);
+    }
+    return data;
+  });
+}
+
+function getPostDataStream(aPostDataString,
+                           aType = "application/x-www-form-urlencoded") {
+  let dataStream = Cc["@mozilla.org/io/string-input-stream;1"]
+                     .createInstance(Ci.nsIStringInputStream);
+  dataStream.data = aPostDataString;
+
+  let mimeStream = Cc["@mozilla.org/network/mime-input-stream;1"]
+                     .createInstance(Ci.nsIMIMEInputStream);
+  mimeStream.addHeader("Content-Type", aType);
+  mimeStream.setData(dataStream);
+  return mimeStream.QueryInterface(Ci.nsIInputStream);
+}
+
+function getLoadContext() {
+  return window.QueryInterface(Ci.nsIInterfaceRequestor)
+               .getInterface(Ci.nsIWebNavigation)
+               .QueryInterface(Ci.nsILoadContext);
+}
+
+function readFromClipboard() {
+  var url;
+
+  try {
+    // Create transferable that will transfer the text.
+    var trans = Components.classes["@mozilla.org/widget/transferable;1"]
+                          .createInstance(Components.interfaces.nsITransferable);
+    trans.init(getLoadContext());
+
+    trans.addDataFlavor("text/unicode");
+
+    // If available, use selection clipboard, otherwise global one
+    if (Services.clipboard.supportsSelectionClipboard())
+      Services.clipboard.getData(trans, Services.clipboard.kSelectionClipboard);
+    else
+      Services.clipboard.getData(trans, Services.clipboard.kGlobalClipboard);
+
+    var data = {};
+    var dataLen = {};
+    trans.getTransferData("text/unicode", data, dataLen);
+
+    if (data) {
+      data = data.value.QueryInterface(Components.interfaces.nsISupportsString);
+      url = data.data.substring(0, dataLen.value / 2);
+    }
+  } catch (ex) {
+  }
+
+  return url;
+}
+
+/**
+ * Open the View Source dialog.
+ *
+ * @param aArgsOrDocument
+ *        Either an object or a Document. Passing a Document is deprecated,
+ *        and is not supported with e10s. This function will throw if
+ *        aArgsOrDocument is a CPOW.
+ *
+ *        If aArgsOrDocument is an object, that object can take the
+ *        following properties:
+ *
+ *        URL (required):
+ *          A string URL for the page we'd like to view the source of.
+ *        browser (optional):
+ *          The browser containing the document that we would like to view the
+ *          source of. This is required if outerWindowID is passed.
+ *        outerWindowID (optional):
+ *          The outerWindowID of the content window containing the document that
+ *          we want to view the source of. You only need to provide this if you
+ *          want to attempt to retrieve the document source from the network
+ *          cache.
+ *        lineNumber (optional):
+ *          The line number to focus on once the source is loaded.
+ */
+function BrowserViewSourceOfDocument(aArgsOrDocument) {
+  let args;
+
+  if (aArgsOrDocument instanceof Document) {
+    let doc = aArgsOrDocument;
+    // Deprecated API - callers should pass args object instead.
+    if (Cu.isCrossProcessWrapper(doc)) {
+      throw new Error("BrowserViewSourceOfDocument cannot accept a CPOW " +
+                      "as a document.");
+    }
+
+    let requestor = doc.defaultView
+                       .QueryInterface(Ci.nsIInterfaceRequestor);
+    let browser = requestor.getInterface(Ci.nsIWebNavigation)
+                           .QueryInterface(Ci.nsIDocShell)
+                           .chromeEventHandler;
+    let outerWindowID = requestor.getInterface(Ci.nsIDOMWindowUtils)
+                                 .outerWindowID;
+    let URL = browser.currentURI.spec;
+    args = { browser, outerWindowID, URL };
+  } else {
+    args = aArgsOrDocument;
+  }
+
+  let viewInternal = () => {
+    let inTab = Services.prefs.getBoolPref("view_source.tab");
+    if (inTab) {
+      let tabBrowser = gBrowser;
+      let preferredRemoteType;
+      if (args.browser) {
+        preferredRemoteType = args.browser.remoteType;
+      } else {
+        if (!tabBrowser) {
+          throw new Error("BrowserViewSourceOfDocument should be passed the " +
+                          "subject browser if called from a window without " +
+                          "gBrowser defined.");
+        }
+        // Some internal URLs (such as specific chrome: and about: URLs that are
+        // not yet remote ready) cannot be loaded in a remote browser.  View
+        // source in tab expects the new view source browser's remoteness to match
+        // that of the original URL, so disable remoteness if necessary for this
+        // URL.
+        preferredRemoteType =
+          E10SUtils.getRemoteTypeForURI(args.URL, gMultiProcessBrowser);
+      }
+
+      // In the case of popups, we need to find a non-popup browser window.
+      if (!tabBrowser || !window.toolbar.visible) {
+        // This returns only non-popup browser windows by default.
+        let browserWindow = RecentWindow.getMostRecentBrowserWindow();
+        tabBrowser = browserWindow.gBrowser;
+      }
+
+      // `viewSourceInBrowser` will load the source content from the page
+      // descriptor for the tab (when possible) or fallback to the network if
+      // that fails.  Either way, the view source module will manage the tab's
+      // location, so use "about:blank" here to avoid unnecessary redundant
+      // requests.
+      let tab = tabBrowser.loadOneTab("about:blank", {
+        relatedToCurrent: true,
+        inBackground: false,
+        preferredRemoteType,
+        sameProcessAsFrameLoader: args.browser ? args.browser.frameLoader : null,
+        triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+      });
+      args.viewSourceBrowser = tabBrowser.getBrowserForTab(tab);
+      top.gViewSourceUtils.viewSourceInBrowser(args);
+    } else {
+      top.gViewSourceUtils.viewSource(args);
+    }
+  };
+
+  // Check if external view source is enabled.  If so, try it.  If it fails,
+  // fallback to internal view source.
+  if (Services.prefs.getBoolPref("view_source.editor.external")) {
+    top.gViewSourceUtils
+       .openInExternalEditor(args, null, null, null, result => {
+      if (!result) {
+        viewInternal();
+      }
+    });
+  } else {
+    // Display using internal view source
+    viewInternal();
+  }
+}
+
+/**
+ * Opens the View Source dialog for the source loaded in the root
+ * top-level document of the browser. This is really just a
+ * convenience wrapper around BrowserViewSourceOfDocument.
+ *
+ * @param browser
+ *        The browser that we want to load the source of.
+ */
+function BrowserViewSource(browser) {
+  BrowserViewSourceOfDocument({
+    browser,
+    outerWindowID: browser.outerWindowID,
+    URL: browser.currentURI.spec,
+  });
+}
+
+// documentURL - URL of the document to view, or null for this window's document
+// initialTab - name of the initial tab to display, or null for the first tab
+// imageElement - image to load in the Media Tab of the Page Info window; can be null/omitted
+// frameOuterWindowID - the id of the frame that the context menu opened in; can be null/omitted
+// browser - the browser containing the document we're interested in inspecting; can be null/omitted
+function BrowserPageInfo(documentURL, initialTab, imageElement, frameOuterWindowID, browser) {
+  if (documentURL instanceof HTMLDocument) {
+    Deprecated.warning("Please pass the location URL instead of the document " +
+                       "to BrowserPageInfo() as the first argument.",
+                       "https://bugzilla.mozilla.org/show_bug.cgi?id=1238180");
+    documentURL = documentURL.location;
+  }
+
+  let args = { initialTab, imageElement, frameOuterWindowID, browser };
+  var windows = Services.wm.getEnumerator("Browser:page-info");
+
+  documentURL = documentURL || window.gBrowser.selectedBrowser.currentURI.spec;
+
+  // Check for windows matching the url
+  while (windows.hasMoreElements()) {
+    var currentWindow = windows.getNext();
+    if (currentWindow.closed) {
+      continue;
+    }
+    if (currentWindow.document.documentElement.getAttribute("relatedUrl") == documentURL) {
+      currentWindow.focus();
+      currentWindow.resetPageInfo(args);
+      return currentWindow;
+    }
+  }
+
+  // We didn't find a matching window, so open a new one.
+  return openDialog("chrome://browser/content/pageinfo/pageInfo.xul", "",
+                    "chrome,toolbar,dialog=no,resizable", args);
+}
+
+/**
+ * Sets the URI to display in the location bar.
+ *
+ * @param aURI [optional]
+ *        nsIURI to set. If this is unspecified, the current URI will be used.
+ */
+function URLBarSetURI(aURI) {
+  var value = gBrowser.userTypedValue;
+  var valid = false;
+
+  if (value == null) {
+    let uri = aURI || gBrowser.currentURI;
+    // Strip off "wyciwyg://" and passwords for the location bar
+    try {
+      uri = Services.uriFixup.createExposableURI(uri);
+    } catch (e) {}
+
+    // Replace initial page URIs with an empty string
+    // only if there's no opener (bug 370555).
+    if (isInitialPage(uri.spec) &&
+        checkEmptyPageOrigin(gBrowser.selectedBrowser, uri)) {
+      value = "";
+    } else {
+      // We should deal with losslessDecodeURI throwing for exotic URIs
+      try {
+        value = losslessDecodeURI(uri);
+      } catch (ex) {
+        value = "about:blank";
+      }
+    }
+
+    valid = !isBlankPageURL(uri.spec) || uri.schemeIs("moz-extension");
+  } else if (isInitialPage(value) &&
+             checkEmptyPageOrigin(gBrowser.selectedBrowser)) {
+    value = "";
+    valid = true;
+  }
+
+  let isDifferentValidValue = valid && value != gURLBar.value;
+  gURLBar.value = value;
+  gURLBar.valueIsTyped = !valid;
+  gURLBar.removeAttribute("usertyping");
+  if (isDifferentValidValue) {
+    gURLBar.selectionStart = gURLBar.selectionEnd = 0;
+  }
+
+  SetPageProxyState(valid ? "valid" : "invalid");
+}
+
+function losslessDecodeURI(aURI) {
+  let scheme = aURI.scheme;
+  if (scheme == "moz-action")
+    throw new Error("losslessDecodeURI should never get a moz-action URI");
+
+  var value = aURI.displaySpec;
+
+  let decodeASCIIOnly = !["https", "http", "file", "ftp"].includes(scheme);
+  // Try to decode as UTF-8 if there's no encoding sequence that we would break.
+  if (!/%25(?:3B|2F|3F|3A|40|26|3D|2B|24|2C|23)/i.test(value)) {
+    if (decodeASCIIOnly) {
+      // This only decodes ascii characters (hex) 20-7e, except 25 (%).
+      // This avoids both cases stipulated below (%-related issues, and \r, \n
+      // and \t, which would be %0d, %0a and %09, respectively) as well as any
+      // non-US-ascii characters.
+      value = value.replace(/%(2[0-4]|2[6-9a-f]|[3-6][0-9a-f]|7[0-9a-e])/g, decodeURI);
+    } else {
+      try {
+        value = decodeURI(value)
+                  // 1. decodeURI decodes %25 to %, which creates unintended
+                  //    encoding sequences. Re-encode it, unless it's part of
+                  //    a sequence that survived decodeURI, i.e. one for:
+                  //    ';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '#'
+                  //    (RFC 3987 section 3.2)
+                  // 2. Re-encode select whitespace so that it doesn't get eaten
+                  //    away by the location bar (bug 410726). Re-encode all
+                  //    adjacent whitespace, to prevent spoofing attempts where
+                  //    invisible characters would push part of the URL to
+                  //    overflow the location bar (bug 1395508).
+                  .replace(/%(?!3B|2F|3F|3A|40|26|3D|2B|24|2C|23)|[\r\n\t]|\s(?=\s)|\s$/ig,
+                           encodeURIComponent);
+      } catch (e) {}
+    }
+  }
+
+  // Encode invisible characters (C0/C1 control characters, U+007F [DEL],
+  // U+00A0 [no-break space], line and paragraph separator,
+  // object replacement character) (bug 452979, bug 909264)
+  value = value.replace(/[\u0000-\u001f\u007f-\u00a0\u2028\u2029\ufffc]/g,
+                        encodeURIComponent);
+
+  // Encode default ignorable characters (bug 546013)
+  // except ZWNJ (U+200C) and ZWJ (U+200D) (bug 582186).
+  // This includes all bidirectional formatting characters.
+  // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
+  value = value.replace(/[\u00ad\u034f\u061c\u115f-\u1160\u17b4-\u17b5\u180b-\u180d\u200b\u200e-\u200f\u202a-\u202e\u2060-\u206f\u3164\ufe00-\ufe0f\ufeff\uffa0\ufff0-\ufff8]|\ud834[\udd73-\udd7a]|[\udb40-\udb43][\udc00-\udfff]/g,
+                        encodeURIComponent);
+  return value;
+}
+
+function UpdateUrlbarSearchSplitterState() {
+  var splitter = document.getElementById("urlbar-search-splitter");
+  var urlbar = document.getElementById("urlbar-container");
+  var searchbar = document.getElementById("search-container");
+
+  if (document.documentElement.getAttribute("customizing") == "true") {
+    if (splitter) {
+      splitter.remove();
+    }
+    return;
+  }
+
+  // If the splitter is already in the right place, we don't need to do anything:
+  if (splitter &&
+      ((splitter.nextSibling == searchbar && splitter.previousSibling == urlbar) ||
+       (splitter.nextSibling == urlbar && splitter.previousSibling == searchbar))) {
+    return;
+  }
+
+  var ibefore = null;
+  if (urlbar && searchbar) {
+    if (urlbar.nextSibling == searchbar)
+      ibefore = searchbar;
+    else if (searchbar.nextSibling == urlbar)
+      ibefore = urlbar;
+  }
+
+  if (ibefore) {
+    if (!splitter) {
+      splitter = document.createElement("splitter");
+      splitter.id = "urlbar-search-splitter";
+      splitter.setAttribute("resizebefore", "flex");
+      splitter.setAttribute("resizeafter", "flex");
+      splitter.setAttribute("skipintoolbarset", "true");
+      splitter.setAttribute("overflows", "false");
+      splitter.className = "chromeclass-toolbar-additional";
+    }
+    urlbar.parentNode.insertBefore(splitter, ibefore);
+  } else if (splitter)
+    splitter.remove();
+}
+
+function UpdatePageProxyState() {
+  if (gURLBar && gURLBar.value != gLastValidURLStr)
+    SetPageProxyState("invalid");
+}
+
+/**
+ * Updates the user interface to indicate whether the URI in the location bar is
+ * different than the loaded page, because it's being edited or because a search
+ * result is currently selected and is displayed in the location bar.
+ *
+ * @param aState
+ *        The string "valid" indicates that the security indicators and other
+ *        related user interface elments should be shown because the URI in the
+ *        location bar matches the loaded page. The string "invalid" indicates
+ *        that the URI in the location bar is different than the loaded page.
+ */
+function SetPageProxyState(aState) {
+  if (!gURLBar)
+    return;
+
+  let oldPageProxyState = gURLBar.getAttribute("pageproxystate");
+  // The "browser_urlbar_stop_pending.js" test uses a MutationObserver to do
+  // some verifications at this point, and it breaks if we don't write the
+  // attribute, even if it hasn't changed (bug 1338115).
+  gURLBar.setAttribute("pageproxystate", aState);
+
+  // the page proxy state is set to valid via OnLocationChange, which
+  // gets called when we switch tabs.
+  if (aState == "valid") {
+    gLastValidURLStr = gURLBar.value;
+    gURLBar.addEventListener("input", UpdatePageProxyState);
+  } else if (aState == "invalid") {
+    gURLBar.removeEventListener("input", UpdatePageProxyState);
+  }
+
+  // After we've ensured that we've applied the listeners and updated the value
+  // of gLastValidURLStr, return early if the actual state hasn't changed.
+  if (oldPageProxyState == aState) {
+    return;
+  }
+
+  UpdatePopupNotificationsVisibility();
+}
+
+function UpdatePopupNotificationsVisibility() {
+  // Only need to do something if the PopupNotifications object for this window
+  // has already been initialized (i.e. its getter no longer exists).
+  if (Object.getOwnPropertyDescriptor(window, "PopupNotifications").get) {
+    return;
+  }
+
+  // Notify PopupNotifications that the visible anchors may have changed. This
+  // also checks the suppression state according to the "shouldSuppress"
+  // function defined earlier in this file.
+  PopupNotifications.anchorVisibilityChange();
+}
+
+function PageProxyClickHandler(aEvent) {
+  if (aEvent.button == 1 && Services.prefs.getBoolPref("middlemouse.paste"))
+    middleMousePaste(aEvent);
+}
+
+// Values for telemtery bins: see TLS_ERROR_REPORT_UI in Histograms.json
+const TLS_ERROR_REPORT_TELEMETRY_AUTO_CHECKED   = 2;
+const TLS_ERROR_REPORT_TELEMETRY_AUTO_UNCHECKED = 3;
+const TLS_ERROR_REPORT_TELEMETRY_MANUAL_SEND    = 4;
+const TLS_ERROR_REPORT_TELEMETRY_AUTO_SEND      = 5;
+
+const PREF_SSL_IMPACT_ROOTS = ["security.tls.version.", "security.ssl3."];
+
+/**
+ * Handle command events bubbling up from error page content
+ * or from about:newtab or from remote error pages that invoke
+ * us via async messaging.
+ */
+var BrowserOnClick = {
+  init() {
+    let mm = window.messageManager;
+    mm.addMessageListener("Browser:CertExceptionError", this);
+    mm.addMessageListener("Browser:OpenCaptivePortalPage", this);
+    mm.addMessageListener("Browser:SiteBlockedError", this);
+    mm.addMessageListener("Browser:EnableOnlineMode", this);
+    mm.addMessageListener("Browser:SetSSLErrorReportAuto", this);
+    mm.addMessageListener("Browser:ResetSSLPreferences", this);
+    mm.addMessageListener("Browser:SSLErrorReportTelemetry", this);
+    mm.addMessageListener("Browser:SSLErrorGoBack", this);
+
+    Services.obs.addObserver(this, "captive-portal-login-abort");
+    Services.obs.addObserver(this, "captive-portal-login-success");
+  },
+
+  uninit() {
+    let mm = window.messageManager;
+    mm.removeMessageListener("Browser:CertExceptionError", this);
+    mm.removeMessageListener("Browser:SiteBlockedError", this);
+    mm.removeMessageListener("Browser:EnableOnlineMode", this);
+    mm.removeMessageListener("Browser:SetSSLErrorReportAuto", this);
+    mm.removeMessageListener("Browser:ResetSSLPreferences", this);
+    mm.removeMessageListener("Browser:SSLErrorReportTelemetry", this);
+    mm.removeMessageListener("Browser:SSLErrorGoBack", this);
+
+    Services.obs.removeObserver(this, "captive-portal-login-abort");
+    Services.obs.removeObserver(this, "captive-portal-login-success");
+  },
+
+  observe(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "captive-portal-login-abort":
+      case "captive-portal-login-success":
+        // Broadcast when a captive portal is freed so that error pages
+        // can refresh themselves.
+        window.messageManager.broadcastAsyncMessage("Browser:CaptivePortalFreed");
+      break;
+    }
+  },
+
+  receiveMessage(msg) {
+    switch (msg.name) {
+      case "Browser:CertExceptionError":
+        this.onCertError(msg.target, msg.data.elementId,
+                         msg.data.isTopFrame, msg.data.location,
+                         msg.data.securityInfoAsString);
+      break;
+      case "Browser:OpenCaptivePortalPage":
+        CaptivePortalWatcher.ensureCaptivePortalTab();
+      break;
+      case "Browser:SiteBlockedError":
+        this.onAboutBlocked(msg.data.elementId, msg.data.reason,
+                            msg.data.isTopFrame, msg.data.location,
+                            msg.data.blockedInfo);
+      break;
+      case "Browser:EnableOnlineMode":
+        if (Services.io.offline) {
+          // Reset network state and refresh the page.
+          Services.io.offline = false;
+          msg.target.reload();
+        }
+      break;
+      case "Browser:ResetSSLPreferences":
+        let prefSSLImpact = PREF_SSL_IMPACT_ROOTS.reduce((prefs, root) => {
+                return prefs.concat(Services.prefs.getChildList(root));
+        }, []);
+        for (let prefName of prefSSLImpact) {
+          Services.prefs.clearUserPref(prefName);
+        }
+        msg.target.reload();
+      break;
+      case "Browser:SetSSLErrorReportAuto":
+        Services.prefs.setBoolPref("security.ssl.errorReporting.automatic", msg.json.automatic);
+        let bin = TLS_ERROR_REPORT_TELEMETRY_AUTO_UNCHECKED;
+        if (msg.json.automatic) {
+          bin = TLS_ERROR_REPORT_TELEMETRY_AUTO_CHECKED;
+        }
+        Services.telemetry.getHistogramById("TLS_ERROR_REPORT_UI").add(bin);
+      break;
+      case "Browser:SSLErrorReportTelemetry":
+        let reportStatus = msg.data.reportStatus;
+        Services.telemetry.getHistogramById("TLS_ERROR_REPORT_UI")
+          .add(reportStatus);
+      break;
+      case "Browser:SSLErrorGoBack":
+        goBackFromErrorPage();
+      break;
+    }
+  },
+
+  onCertError(browser, elementId, isTopFrame, location, securityInfoAsString) {
+    let secHistogram = Services.telemetry.getHistogramById("SECURITY_UI");
+    let securityInfo;
+
+    switch (elementId) {
+      case "exceptionDialogButton":
+        if (isTopFrame) {
+          secHistogram.add(Ci.nsISecurityUITelemetry.WARNING_BAD_CERT_TOP_CLICK_ADD_EXCEPTION);
+        }
+
+        securityInfo = getSecurityInfo(securityInfoAsString);
+        let sslStatus = securityInfo.QueryInterface(Ci.nsISSLStatusProvider)
+                                    .SSLStatus;
+        let params = { exceptionAdded: false,
+                       sslStatus };
+
+        try {
+          switch (Services.prefs.getIntPref("browser.ssl_override_behavior")) {
+            case 2 : // Pre-fetch & pre-populate
+              params.prefetchCert = true;
+            case 1 : // Pre-populate
+              params.location = location;
+          }
+        } catch (e) {
+          Components.utils.reportError("Couldn't get ssl_override pref: " + e);
+        }
+
+        window.openDialog("chrome://pippki/content/exceptionDialog.xul",
+                          "", "chrome,centerscreen,modal", params);
+
+        // If the user added the exception cert, attempt to reload the page
+        if (params.exceptionAdded) {
+          browser.reload();
+        }
+        break;
+
+      case "returnButton":
+        if (isTopFrame) {
+          secHistogram.add(Ci.nsISecurityUITelemetry.WARNING_BAD_CERT_TOP_GET_ME_OUT_OF_HERE);
+        }
+        goBackFromErrorPage();
+        break;
+
+      case "advancedButton":
+        if (isTopFrame) {
+          secHistogram.add(Ci.nsISecurityUITelemetry.WARNING_BAD_CERT_TOP_UNDERSTAND_RISKS);
+        }
+
+        securityInfo = getSecurityInfo(securityInfoAsString);
+        let errorInfo = getDetailedCertErrorInfo(location,
+                                                 securityInfo);
+        browser.messageManager.sendAsyncMessage( "CertErrorDetails", {
+            code: securityInfo.errorCode,
+            info: errorInfo
+        });
+        break;
+
+      case "copyToClipboard":
+        const gClipboardHelper = Cc["@mozilla.org/widget/clipboardhelper;1"]
+                                    .getService(Ci.nsIClipboardHelper);
+        securityInfo = getSecurityInfo(securityInfoAsString);
+        let detailedInfo = getDetailedCertErrorInfo(location,
+                                                    securityInfo);
+        gClipboardHelper.copyString(detailedInfo);
+        break;
+
+    }
+  },
+
+  onAboutBlocked(elementId, reason, isTopFrame, location, blockedInfo) {
+    // Depending on what page we are displaying here (malware/phishing/unwanted)
+    // use the right strings and links for each.
+    let bucketName = "";
+    let sendTelemetry = false;
+    if (reason === "malware") {
+      sendTelemetry = true;
+      bucketName = "WARNING_MALWARE_PAGE_";
+    } else if (reason === "phishing") {
+      sendTelemetry = true;
+      bucketName = "WARNING_PHISHING_PAGE_";
+    } else if (reason === "unwanted") {
+      sendTelemetry = true;
+      bucketName = "WARNING_UNWANTED_PAGE_";
+    } else if (reason === "harmful") {
+      sendTelemetry = true;
+      bucketName = "WARNING_HARMFUL_PAGE_";
+    }
+    let secHistogram = Services.telemetry.getHistogramById("URLCLASSIFIER_UI_EVENTS");
+    let nsISecTel = Ci.IUrlClassifierUITelemetry;
+    bucketName += isTopFrame ? "TOP_" : "FRAME_";
+
+    switch (elementId) {
+      case "goBackButton":
+        if (sendTelemetry) {
+          secHistogram.add(nsISecTel[bucketName + "GET_ME_OUT_OF_HERE"]);
+        }
+        getMeOutOfHere();
+        break;
+      case "ignore_warning_link":
+        if (Services.prefs.getBoolPref("browser.safebrowsing.allowOverride")) {
+          if (sendTelemetry) {
+            secHistogram.add(nsISecTel[bucketName + "IGNORE_WARNING"]);
+          }
+          this.ignoreWarningLink(reason, blockedInfo);
+        }
+        break;
+    }
+  },
+
+  ignoreWarningLink(reason, blockedInfo) {
+    // Allow users to override and continue through to the site,
+    // but add a notify bar as a reminder, so that they don't lose
+    // track after, e.g., tab switching.
+    gBrowser.loadURIWithFlags(gBrowser.currentURI.spec,
+                              nsIWebNavigation.LOAD_FLAGS_BYPASS_CLASSIFIER,
+                              null, null, null);
+
+    Services.perms.add(gBrowser.currentURI, "safe-browsing",
+                       Ci.nsIPermissionManager.ALLOW_ACTION,
+                       Ci.nsIPermissionManager.EXPIRE_SESSION);
+
+    let buttons = [{
+      label: gNavigatorBundle.getString("safebrowsing.getMeOutOfHereButton.label"),
+      accessKey: gNavigatorBundle.getString("safebrowsing.getMeOutOfHereButton.accessKey"),
+      callback() { getMeOutOfHere(); }
+    }];
+
+    let title;
+    if (reason === "malware") {
+      let reportUrl = gSafeBrowsing.getReportURL("MalwareMistake", blockedInfo);
+      title = gNavigatorBundle.getString("safebrowsing.reportedAttackSite");
+      // There's no button if we can not get report url, for example if the provider
+      // of blockedInfo is not Google
+      if (reportUrl) {
+        buttons[1] = {
+          label: gNavigatorBundle.getString("safebrowsing.notAnAttackButton.label"),
+          accessKey: gNavigatorBundle.getString("safebrowsing.notAnAttackButton.accessKey"),
+          callback() {
+            openUILinkIn(reportUrl, "tab");
+          }
+        };
+      }
+    } else if (reason === "phishing") {
+      let reportUrl = gSafeBrowsing.getReportURL("PhishMistake", blockedInfo);
+      title = gNavigatorBundle.getString("safebrowsing.deceptiveSite");
+      // There's no button if we can not get report url, for example if the provider
+      // of blockedInfo is not Google
+      if (reportUrl) {
+        buttons[1] = {
+          label: gNavigatorBundle.getString("safebrowsing.notADeceptiveSiteButton.label"),
+          accessKey: gNavigatorBundle.getString("safebrowsing.notADeceptiveSiteButton.accessKey"),
+          callback() {
+            openUILinkIn(reportUrl, "tab");
+          }
+        };
+      }
+    } else if (reason === "unwanted") {
+      title = gNavigatorBundle.getString("safebrowsing.reportedUnwantedSite");
+      // There is no button for reporting errors since Google doesn't currently
+      // provide a URL endpoint for these reports.
+    } else if (reason === "harmful") {
+      title = gNavigatorBundle.getString("safebrowsing.reportedHarmfulSite");
+      // There is no button for reporting errors since Google doesn't currently
+      // provide a URL endpoint for these reports.
+    }
+
+    let notificationBox = gBrowser.getNotificationBox();
+    let value = "blocked-badware-page";
+
+    let previousNotification = notificationBox.getNotificationWithValue(value);
+    if (previousNotification) {
+      notificationBox.removeNotification(previousNotification);
+    }
+
+    let notification = notificationBox.appendNotification(
+      title,
+      value,
+      "chrome://global/skin/icons/blacklist_favicon.png",
+      notificationBox.PRIORITY_CRITICAL_HIGH,
+      buttons
+    );
+    // Persist the notification until the user removes so it
+    // doesn't get removed on redirects.
+    notification.persistence = -1;
+  },
+};
+
+/**
+ * Re-direct the browser to a known-safe page.  This function is
+ * used when, for example, the user browses to a known malware page
+ * and is presented with about:blocked.  The "Get me out of here!"
+ * button should take the user to the default start page so that even
+ * when their own homepage is infected, we can get them somewhere safe.
+ */
+function getMeOutOfHere() {
+  gBrowser.loadURI(getDefaultHomePage());
+}
+
+/**
+ * Re-direct the browser to the previous page or a known-safe page if no
+ * previous page is found in history.  This function is used when the user
+ * browses to a secure page with certificate issues and is presented with
+ * about:certerror.  The "Go Back" button should take the user to the previous
+ * or a default start page so that even when their own homepage is on a server
+ * that has certificate errors, we can get them somewhere safe.
+ */
+function goBackFromErrorPage() {
+  const ss = Cc["@mozilla.org/browser/sessionstore;1"].
+             getService(Ci.nsISessionStore);
+  let state = JSON.parse(ss.getTabState(gBrowser.selectedTab));
+  if (state.index == 1) {
+    // If the unsafe page is the first or the only one in history, go to the
+    // start page.
+    gBrowser.loadURI(getDefaultHomePage());
+  } else {
+    BrowserBack();
+  }
+}
+
+/**
+ * Return the default start page for the cases when the user's own homepage is
+ * infected, so we can get them somewhere safe.
+ */
+function getDefaultHomePage() {
+  // Get the start page from the *default* pref branch, not the user's
+  var prefs = Services.prefs.getDefaultBranch(null);
+  var url = BROWSER_NEW_TAB_URL;
+  try {
+    url = prefs.getComplexValue("browser.startup.homepage",
+                                Ci.nsIPrefLocalizedString).data;
+    // If url is a pipe-delimited set of pages, just take the first one.
+    if (url.includes("|"))
+      url = url.split("|")[0];
+  } catch (e) {
+    Components.utils.reportError("Couldn't get homepage pref: " + e);
+  }
+  return url;
+}
+
+function BrowserFullScreen() {
+  window.fullScreen = !window.fullScreen;
+}
+
+function getWebNavigation() {
+  return gBrowser.webNavigation;
+}
+
+function BrowserReloadWithFlags(reloadFlags) {
+  let url = gBrowser.currentURI.spec;
+  if (gBrowser.updateBrowserRemotenessByURL(gBrowser.selectedBrowser, url)) {
+    // If the remoteness has changed, the new browser doesn't have any
+    // information of what was loaded before, so we need to load the previous
+    // URL again.
+    gBrowser.loadURIWithFlags(url, reloadFlags);
+    return;
+  }
+
+  // Do this after the above case where we might flip remoteness.
+  // Unfortunately, we'll count the remoteness flip case as a
+  // "newURL" load, since we're using loadURIWithFlags, but hopefully
+  // that's rare enough to not matter.
+  maybeRecordAbandonmentTelemetry(gBrowser.selectedTab, "reload");
+
+  // Reset temporary permissions on the current tab. This is done here
+  // because we only want to reset permissions on user reload.
+  SitePermissions.clearTemporaryPermissions(gBrowser.selectedBrowser);
+
+  let windowUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                          .getInterface(Ci.nsIDOMWindowUtils);
+
+  gBrowser.selectedBrowser
+          .messageManager
+          .sendAsyncMessage("Browser:Reload",
+                            { flags: reloadFlags,
+                              handlingUserInput: windowUtils.isHandlingUserInput });
+}
+
+function getSecurityInfo(securityInfoAsString) {
+  if (!securityInfoAsString)
+    return null;
+
+  const serhelper = Cc["@mozilla.org/network/serialization-helper;1"]
+                       .getService(Ci.nsISerializationHelper);
+  let securityInfo = serhelper.deserializeObject(securityInfoAsString);
+  securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
+
+  return securityInfo;
+}
+
+/**
+ * Returns a string with detailed information about the certificate validation
+ * failure from the specified URI that can be used to send a report.
+ */
+function getDetailedCertErrorInfo(location, securityInfo) {
+  if (!securityInfo)
+    return "";
+
+  let certErrorDetails = location;
+  let code = securityInfo.errorCode;
+  let errors = Cc["@mozilla.org/nss_errors_service;1"]
+                  .getService(Ci.nsINSSErrorsService);
+
+  certErrorDetails += "\r\n\r\n" + errors.getErrorMessage(errors.getXPCOMFromNSSError(code));
+
+  const sss = Cc["@mozilla.org/ssservice;1"]
+                 .getService(Ci.nsISiteSecurityService);
+  // SiteSecurityService uses different storage if the channel is
+  // private. Thus we must give isSecureURI correct flags or we
+  // might get incorrect results.
+  let flags = PrivateBrowsingUtils.isWindowPrivate(window) ?
+              Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;
+
+  let uri = Services.io.newURI(location);
+
+  let hasHSTS = sss.isSecureURI(sss.HEADER_HSTS, uri, flags);
+  let hasHPKP = sss.isSecureURI(sss.HEADER_HPKP, uri, flags);
+  certErrorDetails += "\r\n\r\n" +
+                      gNavigatorBundle.getFormattedString("certErrorDetailsHSTS.label",
+                                                          [hasHSTS]);
+  certErrorDetails += "\r\n" +
+                      gNavigatorBundle.getFormattedString("certErrorDetailsKeyPinning.label",
+                                                          [hasHPKP]);
+
+  let certChain = "";
+  if (securityInfo.failedCertChain) {
+    let certs = securityInfo.failedCertChain.getEnumerator();
+    while (certs.hasMoreElements()) {
+      let cert = certs.getNext();
+      cert.QueryInterface(Ci.nsIX509Cert);
+      certChain += getPEMString(cert);
+    }
+  }
+
+  certErrorDetails += "\r\n\r\n" +
+                      gNavigatorBundle.getString("certErrorDetailsCertChain.label") +
+                      "\r\n\r\n" + certChain;
+
+  return certErrorDetails;
+}
+
+// TODO: can we pull getDERString and getPEMString in from pippki.js instead of
+// duplicating them here?
+function getDERString(cert) {
+  var length = {};
+  var derArray = cert.getRawDER(length);
+  var derString = "";
+  for (var i = 0; i < derArray.length; i++) {
+    derString += String.fromCharCode(derArray[i]);
+  }
+  return derString;
+}
+
+function getPEMString(cert) {
+  var derb64 = btoa(getDERString(cert));
+  // Wrap the Base64 string into lines of 64 characters,
+  // with CRLF line breaks (as specified in RFC 1421).
+  var wrapped = derb64.replace(/(\S{64}(?!$))/g, "$1\r\n");
+  return "-----BEGIN CERTIFICATE-----\r\n"
+         + wrapped
+         + "\r\n-----END CERTIFICATE-----\r\n";
+}
+
+var PrintPreviewListener = {
+  _printPreviewTab: null,
+  _simplifiedPrintPreviewTab: null,
+  _tabBeforePrintPreview: null,
+  _simplifyPageTab: null,
+  _lastRequestedPrintPreviewTab: null,
+
+  _createPPBrowser() {
+    let browser = this.getSourceBrowser();
+    let preferredRemoteType = browser.remoteType;
+    return gBrowser.loadOneTab("about:printpreview", {
+      inBackground: true,
+      preferredRemoteType,
+      sameProcessAsFrameLoader: browser.frameLoader,
+      triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+    });
+  },
+  getPrintPreviewBrowser() {
+    if (!this._printPreviewTab) {
+      this._printPreviewTab = this._createPPBrowser();
+    }
+    gBrowser._allowTabChange = true;
+    this._lastRequestedPrintPreviewTab = gBrowser.selectedTab = this._printPreviewTab;
+    gBrowser._allowTabChange = false;
+    return gBrowser.getBrowserForTab(this._printPreviewTab);
+  },
+  getSimplifiedPrintPreviewBrowser() {
+    if (!this._simplifiedPrintPreviewTab) {
+      this._simplifiedPrintPreviewTab = this._createPPBrowser();
+    }
+    gBrowser._allowTabChange = true;
+    this._lastRequestedPrintPreviewTab = gBrowser.selectedTab = this._simplifiedPrintPreviewTab;
+    gBrowser._allowTabChange = false;
+    return gBrowser.getBrowserForTab(this._simplifiedPrintPreviewTab);
+  },
+  createSimplifiedBrowser() {
+    let browser = this.getSourceBrowser();
+    this._simplifyPageTab = gBrowser.loadOneTab("about:printpreview", {
+      inBackground: true,
+      sameProcessAsFrameLoader: browser.frameLoader,
+      triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+     });
+    return this.getSimplifiedSourceBrowser();
+  },
+  getSourceBrowser() {
+    if (!this._tabBeforePrintPreview) {
+      this._tabBeforePrintPreview = gBrowser.selectedTab;
+    }
+    return this._tabBeforePrintPreview.linkedBrowser;
+  },
+  getSimplifiedSourceBrowser() {
+    return this._simplifyPageTab ?
+      gBrowser.getBrowserForTab(this._simplifyPageTab) : null;
+  },
+  getNavToolbox() {
+    return gNavToolbox;
+  },
+  onEnter() {
+    // We might have accidentally switched tabs since the user invoked print
+    // preview
+    if (gBrowser.selectedTab != this._lastRequestedPrintPreviewTab) {
+      gBrowser.selectedTab = this._lastRequestedPrintPreviewTab;
+    }
+    gInPrintPreviewMode = true;
+    this._toggleAffectedChrome();
+  },
+  onExit() {
+    gBrowser._allowTabChange = true;
+    gBrowser.selectedTab = this._tabBeforePrintPreview;
+    gBrowser._allowTabChange = false;
+    this._tabBeforePrintPreview = null;
+    gInPrintPreviewMode = false;
+    this._toggleAffectedChrome();
+    let tabsToRemove = ["_simplifyPageTab", "_printPreviewTab", "_simplifiedPrintPreviewTab"];
+    for (let tabProp of tabsToRemove) {
+      if (this[tabProp]) {
+        gBrowser.removeTab(this[tabProp]);
+        this[tabProp] = null;
+      }
+    }
+    gBrowser.deactivatePrintPreviewBrowsers();
+    this._lastRequestedPrintPreviewTab = null;
+  },
+  _toggleAffectedChrome() {
+    gNavToolbox.collapsed = gInPrintPreviewMode;
+
+    if (gInPrintPreviewMode)
+      this._hideChrome();
+    else
+      this._showChrome();
+
+    TabsInTitlebar.allowedBy("print-preview", !gInPrintPreviewMode);
+  },
+  _hideChrome() {
+    this._chromeState = {};
+
+    this._chromeState.sidebarOpen = SidebarUI.isOpen;
+    this._sidebarCommand = SidebarUI.currentID;
+    SidebarUI.hide();
+
+    var notificationBox = gBrowser.getNotificationBox();
+    this._chromeState.notificationsOpen = !notificationBox.notificationsHidden;
+    notificationBox.notificationsHidden = true;
+
+    this._chromeState.findOpen = gFindBarInitialized && !gFindBar.hidden;
+    if (gFindBarInitialized)
+      gFindBar.close();
+
+    var globalNotificationBox = document.getElementById("global-notificationbox");
+    this._chromeState.globalNotificationsOpen = !globalNotificationBox.notificationsHidden;
+    globalNotificationBox.notificationsHidden = true;
+
+    this._chromeState.syncNotificationsOpen = false;
+    var syncNotifications = document.getElementById("sync-notifications");
+    if (syncNotifications) {
+      this._chromeState.syncNotificationsOpen = !syncNotifications.notificationsHidden;
+      syncNotifications.notificationsHidden = true;
+    }
+  },
+  _showChrome() {
+    if (this._chromeState.notificationsOpen)
+      gBrowser.getNotificationBox().notificationsHidden = false;
+
+    if (this._chromeState.findOpen)
+      gFindBar.open();
+
+    if (this._chromeState.globalNotificationsOpen)
+      document.getElementById("global-notificationbox").notificationsHidden = false;
+
+    if (this._chromeState.syncNotificationsOpen)
+      document.getElementById("sync-notifications").notificationsHidden = false;
+
+    if (this._chromeState.sidebarOpen)
+      SidebarUI.show(this._sidebarCommand);
+  },
+
+  activateBrowser(browser) {
+    gBrowser.activateBrowserForPrintPreview(browser);
+  },
+};
+
+var browserDragAndDrop = {
+  canDropLink: aEvent => Services.droppedLinkHandler.canDropLink(aEvent, true),
+
+  dragOver(aEvent) {
+    if (this.canDropLink(aEvent)) {
+      aEvent.preventDefault();
+    }
+  },
+
+  getTriggeringPrincipal(aEvent) {
+    return Services.droppedLinkHandler.getTriggeringPrincipal(aEvent);
+  },
+
+  dropLinks(aEvent, aDisallowInherit) {
+    return Services.droppedLinkHandler.dropLinks(aEvent, aDisallowInherit);
+  }
+};
+
+var homeButtonObserver = {
+  onDrop(aEvent) {
+      // disallow setting home pages that inherit the principal
+      let links = browserDragAndDrop.dropLinks(aEvent, true);
+      if (links.length) {
+        setTimeout(openHomeDialog, 0, links.map(link => link.url).join("|"));
+      }
+    },
+
+  onDragOver(aEvent) {
+      if (Services.prefs.prefIsLocked("browser.startup.homepage")) {
+        return;
+      }
+      browserDragAndDrop.dragOver(aEvent);
+      aEvent.dropEffect = "link";
+    },
+  onDragExit(aEvent) {
+    }
+};
+
+function openHomeDialog(aURL) {
+  var promptTitle = gNavigatorBundle.getString("droponhometitle");
+  var promptMsg;
+  if (aURL.includes("|")) {
+    promptMsg = gNavigatorBundle.getString("droponhomemsgMultiple");
+  } else {
+    promptMsg = gNavigatorBundle.getString("droponhomemsg");
+  }
+
+  var pressedVal  = Services.prompt.confirmEx(window, promptTitle, promptMsg,
+                          Services.prompt.STD_YES_NO_BUTTONS,
+                          null, null, null, null, {value: 0});
+
+  if (pressedVal == 0) {
+    try {
+      Services.prefs.setStringPref("browser.startup.homepage", aURL);
+    } catch (ex) {
+      dump("Failed to set the home page.\n" + ex + "\n");
+    }
+  }
+}
+
+var newTabButtonObserver = {
+  onDragOver(aEvent) {
+    browserDragAndDrop.dragOver(aEvent);
+  },
+  onDragExit(aEvent) {},
+  async onDrop(aEvent) {
+    let links = browserDragAndDrop.dropLinks(aEvent);
+    for (let link of links) {
+      if (link.url) {
+        let data = await getShortcutOrURIAndPostData(link.url);
+        // Allow third-party services to fixup this URL.
+        openNewTabWith(data.url, null, data.postData, aEvent, true);
+      }
+    }
+  }
+};
+
+var newWindowButtonObserver = {
+  onDragOver(aEvent) {
+    browserDragAndDrop.dragOver(aEvent);
+  },
+  onDragExit(aEvent) {},
+  async onDrop(aEvent) {
+    let links = browserDragAndDrop.dropLinks(aEvent);
+    for (let link of links) {
+      if (link.url) {
+        let data = await getShortcutOrURIAndPostData(link.url);
+        // Allow third-party services to fixup this URL.
+        openNewWindowWith(data.url, null, data.postData, true);
+      }
+    }
+  }
+};
+const DOMEventHandler = {
+  init() {
+    let mm = window.messageManager;
+    mm.addMessageListener("Link:AddFeed", this);
+    mm.addMessageListener("Link:SetIcon", this);
+    mm.addMessageListener("Link:AddSearch", this);
+    mm.addMessageListener("Meta:SetPageInfo", this);
+  },
+
+  receiveMessage(aMsg) {
+    switch (aMsg.name) {
+      case "Link:AddFeed":
+        let link = {type: aMsg.data.type, href: aMsg.data.href, title: aMsg.data.title};
+        FeedHandler.addFeed(link, aMsg.target);
+        break;
+
+      case "Link:SetIcon":
+        this.setIcon(aMsg.target, aMsg.data.url, aMsg.data.loadingPrincipal,
+                     aMsg.data.requestContextID, aMsg.data.canUseForTab);
+        break;
+
+      case "Link:AddSearch":
+        this.addSearch(aMsg.target, aMsg.data.engine, aMsg.data.url);
+        break;
+
+      case "Meta:SetPageInfo":
+        this.setPageInfo(aMsg.data);
+        break;
+    }
+  },
+
+  setPageInfo(aData) {
+    const {url, description, previewImageURL} = aData;
+    gBrowser.setPageInfo(url, description, previewImageURL);
+    return true;
+  },
+
+  setIcon(aBrowser, aURL, aLoadingPrincipal, aRequestContextID = 0, aCanUseForTab = true) {
+    if (gBrowser.isFailedIcon(aURL))
+      return false;
+
+    let tab = gBrowser.getTabForBrowser(aBrowser);
+    if (!tab)
+      return false;
+
+    let loadingPrincipal = aLoadingPrincipal ||
+                           Services.scriptSecurityManager.getSystemPrincipal();
+    if (aURL) {
+      gBrowser.storeIcon(aBrowser, aURL, loadingPrincipal, aRequestContextID);
+    }
+    if (aCanUseForTab) {
+      gBrowser.setIcon(tab, aURL, loadingPrincipal, aRequestContextID);
+    }
+    return true;
+  },
+
+  addSearch(aBrowser, aEngine, aURL) {
+    let tab = gBrowser.getTabForBrowser(aBrowser);
+    if (!tab)
+      return;
+
+    BrowserSearch.addEngine(aBrowser, aEngine, makeURI(aURL));
+  },
+};
+
+const BrowserSearch = {
+  addEngine(browser, engine, uri) {
+    // Check to see whether we've already added an engine with this title
+    if (browser.engines) {
+      if (browser.engines.some(e => e.title == engine.title))
+        return;
+    }
+
+    var hidden = false;
+    // If this engine (identified by title) is already in the list, add it
+    // to the list of hidden engines rather than to the main list.
+    // XXX This will need to be changed when engines are identified by URL;
+    // see bug 335102.
+    if (Services.search.getEngineByName(engine.title))
+      hidden = true;
+
+    var engines = (hidden ? browser.hiddenEngines : browser.engines) || [];
+
+    engines.push({ uri: engine.href,
+                   title: engine.title,
+                   get icon() { return browser.mIconURL; }
+                 });
+
+    if (hidden)
+      browser.hiddenEngines = engines;
+    else {
+      browser.engines = engines;
+      if (browser == gBrowser.selectedBrowser)
+        this.updateOpenSearchBadge();
+    }
+  },
+
+  /**
+   * Update the browser UI to show whether or not additional engines are
+   * available when a page is loaded or the user switches tabs to a page that
+   * has search engines.
+   */
+  updateOpenSearchBadge() {
+    var searchBar = this.searchBar;
+    if (!searchBar)
+      return;
+
+    var engines = gBrowser.selectedBrowser.engines;
+    if (engines && engines.length > 0)
+      searchBar.setAttribute("addengines", "true");
+    else
+      searchBar.removeAttribute("addengines");
+  },
+
+  /**
+   * Gives focus to the search bar, if it is present on the toolbar, or loads
+   * the default engine's search form otherwise. For Mac, opens a new window
+   * or focuses an existing window, if necessary.
+   */
+  webSearch: function BrowserSearch_webSearch() {
+    if (window.location.href != getBrowserURL()) {
+      var win = getTopWin();
+      if (win) {
+        // If there's an open browser window, it should handle this command
+        win.focus();
+        win.BrowserSearch.webSearch();
+      } else {
+        // If there are no open browser windows, open a new one
+        var observer = function(subject, topic, data) {
+          if (subject == win) {
+            BrowserSearch.webSearch();
+            Services.obs.removeObserver(observer, "browser-delayed-startup-finished");
+          }
+        };
+        win = window.openDialog(getBrowserURL(), "_blank",
+                                "chrome,all,dialog=no", "about:blank");
+        Services.obs.addObserver(observer, "browser-delayed-startup-finished");
+      }
+      return;
+    }
+
+    let focusUrlBarIfSearchFieldIsNotActive = function(aSearchBar) {
+      if (!aSearchBar || document.activeElement != aSearchBar.textbox.inputField) {
+        focusAndSelectUrlBar(true);
+      }
+    };
+
+    let searchBar = this.searchBar;
+    let placement = CustomizableUI.getPlacementOfWidget("search-container");
+    let focusSearchBar = () => {
+      searchBar = this.searchBar;
+      searchBar.select();
+      focusUrlBarIfSearchFieldIsNotActive(searchBar);
+    };
+    if (placement && searchBar &&
+        ((searchBar.parentNode.getAttribute("overflowedItem") == "true" &&
+          placement.area == CustomizableUI.AREA_NAVBAR) ||
+         placement.area == CustomizableUI.AREA_FIXED_OVERFLOW_PANEL)) {
+      let navBar = document.getElementById(CustomizableUI.AREA_NAVBAR);
+      navBar.overflowable.show().then(focusSearchBar);
+      return;
+    }
+    if (searchBar) {
+      if (window.fullScreen)
+        FullScreen.showNavToolbox();
+      searchBar.select();
+    }
+    focusUrlBarIfSearchFieldIsNotActive(searchBar);
+  },
+
+  /**
+   * Loads a search results page, given a set of search terms. Uses the current
+   * engine if the search bar is visible, or the default engine otherwise.
+   *
+   * @param searchText
+   *        The search terms to use for the search.
+   *
+   * @param useNewTab
+   *        Boolean indicating whether or not the search should load in a new
+   *        tab.
+   *
+   * @param purpose [optional]
+   *        A string meant to indicate the context of the search request. This
+   *        allows the search service to provide a different nsISearchSubmission
+   *        depending on e.g. where the search is triggered in the UI.
+   *
+   * @return engine The search engine used to perform a search, or null if no
+   *                search was performed.
+   */
+  _loadSearch(searchText, useNewTab, purpose) {
+    let engine;
+
+    // If the search bar is visible, use the current engine, otherwise, fall
+    // back to the default engine.
+    if (isElementVisible(this.searchBar))
+      engine = Services.search.currentEngine;
+    else
+      engine = Services.search.defaultEngine;
+
+    let submission = engine.getSubmission(searchText, null, purpose); // HTML response
+
+    // getSubmission can return null if the engine doesn't have a URL
+    // with a text/html response type.  This is unlikely (since
+    // SearchService._addEngineToStore() should fail for such an engine),
+    // but let's be on the safe side.
+    if (!submission) {
+      return null;
+    }
+
+    let inBackground = Services.prefs.getBoolPref("browser.search.context.loadInBackground");
+    openLinkIn(submission.uri.spec,
+               useNewTab ? "tab" : "current",
+               { postData: submission.postData,
+                 inBackground,
+                 relatedToCurrent: true });
+
+    return engine;
+  },
+
+  /**
+   * Just like _loadSearch, but preserving an old API.
+   *
+   * @return string Name of the search engine used to perform a search or null
+   *         if a search was not performed.
+   */
+  loadSearch: function BrowserSearch_search(searchText, useNewTab, purpose) {
+    let engine = BrowserSearch._loadSearch(searchText, useNewTab, purpose);
+    if (!engine) {
+      return null;
+    }
+    return engine.name;
+  },
+
+  /**
+   * Perform a search initiated from the context menu.
+   *
+   * This should only be called from the context menu. See
+   * BrowserSearch.loadSearch for the preferred API.
+   */
+  loadSearchFromContext(terms) {
+    let engine = BrowserSearch._loadSearch(terms, true, "contextmenu");
+    if (engine) {
+      BrowserSearch.recordSearchInTelemetry(engine, "contextmenu");
+    }
+  },
+
+  pasteAndSearch(event) {
+    BrowserSearch.searchBar.select();
+    goDoCommand("cmd_paste");
+    BrowserSearch.searchBar.handleSearchCommand(event);
+  },
+
+  /**
+   * Returns the search bar element if it is present in the toolbar, null otherwise.
+   */
+  get searchBar() {
+    return document.getElementById("searchbar");
+  },
+
+  get searchEnginesURL() {
+    return formatURL("browser.search.searchEnginesURL", true);
+  },
+
+  loadAddEngines: function BrowserSearch_loadAddEngines() {
+    var newWindowPref = Services.prefs.getIntPref("browser.link.open_newwindow");
+    var where = newWindowPref == 3 ? "tab" : "window";
+    openUILinkIn(this.searchEnginesURL, where);
+  },
+
+  _getSearchEngineId(engine) {
+    if (engine && engine.identifier) {
+      return engine.identifier;
+    }
+
+    if (!engine || (engine.name === undefined))
+      return "other";
+
+    return "other-" + engine.name;
+  },
+
+  /**
+   * Helper to record a search with Telemetry.
+   *
+   * Telemetry records only search counts and nothing pertaining to the search itself.
+   *
+   * @param engine
+   *        (nsISearchEngine) The engine handling the search.
+   * @param source
+   *        (string) Where the search originated from. See BrowserUsageTelemetry for
+   *        allowed values.
+   * @param details [optional]
+   *        An optional parameter passed to |BrowserUsageTelemetry.recordSearch|.
+   *        See its documentation for allowed options.
+   *        Additionally, if the search was a suggested search, |details.selection|
+   *        indicates where the item was in the suggestion list and how the user
+   *        selected it: {selection: {index: The selected index, kind: "key" or "mouse"}}
+   */
+  recordSearchInTelemetry(engine, source, details = {}) {
+    BrowserUITelemetry.countSearchEvent(source, null, details.selection);
+    try {
+      BrowserUsageTelemetry.recordSearch(engine, source, details);
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+  },
+
+  /**
+   * Helper to record a one-off search with Telemetry.
+   *
+   * Telemetry records only search counts and nothing pertaining to the search itself.
+   *
+   * @param engine
+   *        (nsISearchEngine) The engine handling the search.
+   * @param source
+   *        (string) Where the search originated from. See BrowserUsageTelemetry for
+   *        allowed values.
+   * @param type
+   *        (string) Indicates how the user selected the search item.
+   * @param where
+   *        (string) Where was the search link opened (e.g. new tab, current tab, ..).
+   */
+  recordOneoffSearchInTelemetry(engine, source, type, where) {
+    let id = this._getSearchEngineId(engine) + "." + source;
+    BrowserUITelemetry.countOneoffSearchEvent(id, type, where);
+    try {
+      const details = {type, isOneOff: true};
+      BrowserUsageTelemetry.recordSearch(engine, source, details);
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+  }
+};
+
+XPCOMUtils.defineConstant(this, "BrowserSearch", BrowserSearch);
+
+function FillHistoryMenu(aParent) {
+  // Lazily add the hover listeners on first showing and never remove them
+  if (!aParent.hasStatusListener) {
+    // Show history item's uri in the status bar when hovering, and clear on exit
+    aParent.addEventListener("DOMMenuItemActive", function(aEvent) {
+      // Only the current page should have the checked attribute, so skip it
+      if (!aEvent.target.hasAttribute("checked"))
+        XULBrowserWindow.setOverLink(aEvent.target.getAttribute("uri"));
+    });
+    aParent.addEventListener("DOMMenuItemInactive", function() {
+      XULBrowserWindow.setOverLink("");
+    });
+
+    aParent.hasStatusListener = true;
+  }
+
+  // Remove old entries if any
+  let children = aParent.childNodes;
+  for (var i = children.length - 1; i >= 0; --i) {
+    if (children[i].hasAttribute("index"))
+      aParent.removeChild(children[i]);
+  }
+
+  const MAX_HISTORY_MENU_ITEMS = 15;
+
+  const tooltipBack = gNavigatorBundle.getString("tabHistory.goBack");
+  const tooltipCurrent = gNavigatorBundle.getString("tabHistory.current");
+  const tooltipForward = gNavigatorBundle.getString("tabHistory.goForward");
+
+  function updateSessionHistory(sessionHistory, initial) {
+    let count = sessionHistory.entries.length;
+
+    if (!initial) {
+      if (count <= 1) {
+        // if there is only one entry now, close the popup.
+        aParent.hidePopup();
+        return;
+      } else if (aParent.id != "backForwardMenu" && !aParent.parentNode.open) {
+        // if the popup wasn't open before, but now needs to be, reopen the menu.
+        // It should trigger FillHistoryMenu again. This might happen with the
+        // delay from click-and-hold menus but skip this for the context menu
+        // (backForwardMenu) rather than figuring out how the menu should be
+        // positioned and opened as it is an extreme edgecase.
+        aParent.parentNode.open = true;
+        return;
+      }
+    }
+
+    let index = sessionHistory.index;
+    let half_length = Math.floor(MAX_HISTORY_MENU_ITEMS / 2);
+    let start = Math.max(index - half_length, 0);
+    let end = Math.min(start == 0 ? MAX_HISTORY_MENU_ITEMS : index + half_length + 1, count);
+    if (end == count) {
+      start = Math.max(count - MAX_HISTORY_MENU_ITEMS, 0);
+    }
+
+    let existingIndex = 0;
+
+    for (let j = end - 1; j >= start; j--) {
+      let entry = sessionHistory.entries[j];
+      let uri = entry.url;
+
+      let item = existingIndex < children.length ?
+                   children[existingIndex] : document.createElement("menuitem");
+
+      item.setAttribute("uri", uri);
+      item.setAttribute("label", entry.title || uri);
+      item.setAttribute("index", j);
+
+      // Cache this so that gotoHistoryIndex doesn't need the original index
+      item.setAttribute("historyindex", j - index);
+
+      if (j != index) {
+        // Use list-style-image rather than the image attribute in order to
+        // allow CSS to override this.
+        item.style.listStyleImage = `url(page-icon:${uri})`;
+      }
+
+      if (j < index) {
+        item.className = "unified-nav-back menuitem-iconic menuitem-with-favicon";
+        item.setAttribute("tooltiptext", tooltipBack);
+      } else if (j == index) {
+        item.setAttribute("type", "radio");
+        item.setAttribute("checked", "true");
+        item.className = "unified-nav-current";
+        item.setAttribute("tooltiptext", tooltipCurrent);
+      } else {
+        item.className = "unified-nav-forward menuitem-iconic menuitem-with-favicon";
+        item.setAttribute("tooltiptext", tooltipForward);
+      }
+
+      if (!item.parentNode) {
+        aParent.appendChild(item);
+      }
+
+      existingIndex++;
+    }
+
+    if (!initial) {
+      let existingLength = children.length;
+      while (existingIndex < existingLength) {
+        aParent.removeChild(aParent.lastChild);
+        existingIndex++;
+      }
+    }
+  }
+
+  let sessionHistory = SessionStore.getSessionHistory(gBrowser.selectedTab, updateSessionHistory);
+  if (!sessionHistory)
+    return false;
+
+  // don't display the popup for a single item
+  if (sessionHistory.entries.length <= 1)
+    return false;
+
+  updateSessionHistory(sessionHistory, true);
+  return true;
+}
+
+function addToUrlbarHistory(aUrlToAdd) {
+  if (!PrivateBrowsingUtils.isWindowPrivate(window) &&
+      aUrlToAdd &&
+      !aUrlToAdd.includes(" ") &&
+      !/[\x00-\x1F]/.test(aUrlToAdd)) // eslint-disable-line no-control-regex
+    PlacesUIUtils.markPageAsTyped(aUrlToAdd);
+}
+
+function BrowserDownloadsUI() {
+  if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+    openUILinkIn("about:downloads", "tab");
+  } else {
+    PlacesCommandHook.showPlacesOrganizer("Downloads");
+  }
+}
+
+function toOpenWindowByType(inType, uri, features) {
+  var topWindow = Services.wm.getMostRecentWindow(inType);
+
+  if (topWindow)
+    topWindow.focus();
+  else if (features)
+    window.open(uri, "_blank", features);
+  else
+    window.open(uri, "_blank", "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar");
+}
+
+function OpenBrowserWindow(options) {
+  var telemetryObj = {};
+  TelemetryStopwatch.start("FX_NEW_WINDOW_MS", telemetryObj);
+
+  var handler = Components.classes["@mozilla.org/browser/clh;1"]
+                          .getService(Components.interfaces.nsIBrowserHandler);
+  var defaultArgs = handler.defaultArgs;
+  var wintype = document.documentElement.getAttribute("windowtype");
+
+  var extraFeatures = "";
+  if (options && options.private) {
+    extraFeatures = ",private";
+    if (!PrivateBrowsingUtils.permanentPrivateBrowsing) {
+      // Force the new window to load about:privatebrowsing instead of the default home page
+      defaultArgs = "about:privatebrowsing";
+    }
+  } else {
+    extraFeatures = ",non-private";
+  }
+
+  if (options && options.remote) {
+    extraFeatures += ",remote";
+  } else if (options && options.remote === false) {
+    extraFeatures += ",non-remote";
+  }
+
+  // If the window is maximized, we want to skip the animation, since we're
+  // going to be taking up most of the screen anyways, and we want to optimize
+  // for showing the user a useful window as soon as possible.
+  if (window.windowState == window.STATE_MAXIMIZED) {
+    extraFeatures += ",suppressanimation";
+  }
+
+  // if and only if the current window is a browser window and it has a document with a character
+  // set, then extract the current charset menu setting from the current document and use it to
+  // initialize the new browser window...
+  var win;
+  if (window && (wintype == "navigator:browser") && window.content && window.content.document) {
+    var DocCharset = window.content.document.characterSet;
+    let charsetArg = "charset=" + DocCharset;
+
+    // we should "inherit" the charset menu setting in a new window
+    win = window.openDialog("chrome://browser/content/", "_blank", "chrome,all,dialog=no" + extraFeatures, defaultArgs, charsetArg);
+  } else {
+    // forget about the charset information.
+    win = window.openDialog("chrome://browser/content/", "_blank", "chrome,all,dialog=no" + extraFeatures, defaultArgs);
+  }
+
+  win.addEventListener("MozAfterPaint", () => {
+    TelemetryStopwatch.finish("FX_NEW_WINDOW_MS", telemetryObj);
+  }, {once: true});
+
+  return win;
+}
+
+/**
+ * Update the global flag that tracks whether or not any edit UI (the Edit menu,
+ * edit-related items in the context menu, and edit-related toolbar buttons
+ * is visible, then update the edit commands' enabled state accordingly.  We use
+ * this flag to skip updating the edit commands on focus or selection changes
+ * when no UI is visible to improve performance (including pageload performance,
+ * since focus changes when you load a new page).
+ *
+ * If UI is visible, we use goUpdateGlobalEditMenuItems to set the commands'
+ * enabled state so the UI will reflect it appropriately.
+ *
+ * If the UI isn't visible, we enable all edit commands so keyboard shortcuts
+ * still work and just lazily disable them as needed when the user presses a
+ * shortcut.
+ *
+ * This doesn't work on Mac, since Mac menus flash when users press their
+ * keyboard shortcuts, so edit UI is essentially always visible on the Mac,
+ * and we need to always update the edit commands.  Thus on Mac this function
+ * is a no op.
+ */
+function updateEditUIVisibility() {
+  if (AppConstants.platform == "macosx")
+    return;
+
+  let editMenuPopupState = document.getElementById("menu_EditPopup").state;
+  let contextMenuPopupState = document.getElementById("contentAreaContextMenu").state;
+  let placesContextMenuPopupState = document.getElementById("placesContext").state;
+
+  let oldVisible = gEditUIVisible;
+
+  // The UI is visible if the Edit menu is opening or open, if the context menu
+  // is open, or if the toolbar has been customized to include the Cut, Copy,
+  // or Paste toolbar buttons.
+  gEditUIVisible = editMenuPopupState == "showing" ||
+                   editMenuPopupState == "open" ||
+                   contextMenuPopupState == "showing" ||
+                   contextMenuPopupState == "open" ||
+                   placesContextMenuPopupState == "showing" ||
+                   placesContextMenuPopupState == "open";
+  const kOpenPopupStates = ["showing", "open"];
+  if (!gEditUIVisible) {
+    // Now check the edit-controls toolbar buttons.
+    let placement = CustomizableUI.getPlacementOfWidget("edit-controls");
+    let areaType = placement ? CustomizableUI.getAreaType(placement.area) : "";
+    if (areaType == CustomizableUI.TYPE_MENU_PANEL) {
+      let customizablePanel = PanelUI.overflowPanel;
+      gEditUIVisible = kOpenPopupStates.includes(customizablePanel.state);
+    } else if (areaType == CustomizableUI.TYPE_TOOLBAR && window.toolbar.visible) {
+      // The edit controls are on a toolbar, so they are visible,
+      // unless they're in a panel that isn't visible...
+      if (placement.area == "nav-bar") {
+        let editControls = document.getElementById("edit-controls");
+        gEditUIVisible = !editControls.hasAttribute("overflowedItem") ||
+                          kOpenPopupStates.includes(document.getElementById("widget-overflow").state);
+      } else {
+        gEditUIVisible = true;
+      }
+    }
+  }
+
+  // Now check the main menu panel
+  if (!gEditUIVisible) {
+    gEditUIVisible = kOpenPopupStates.includes(PanelUI.panel.state);
+  }
+
+  // No need to update commands if the edit UI visibility has not changed.
+  if (gEditUIVisible == oldVisible) {
+    return;
+  }
+
+  // If UI is visible, update the edit commands' enabled state to reflect
+  // whether or not they are actually enabled for the current focus/selection.
+  if (gEditUIVisible) {
+    goUpdateGlobalEditMenuItems();
+  } else {
+    // Otherwise, enable all commands, so that keyboard shortcuts still work,
+    // then lazily determine their actual enabled state when the user presses
+    // a keyboard shortcut.
+    goSetCommandEnabled("cmd_undo", true);
+    goSetCommandEnabled("cmd_redo", true);
+    goSetCommandEnabled("cmd_cut", true);
+    goSetCommandEnabled("cmd_copy", true);
+    goSetCommandEnabled("cmd_paste", true);
+    goSetCommandEnabled("cmd_selectAll", true);
+    goSetCommandEnabled("cmd_delete", true);
+    goSetCommandEnabled("cmd_switchTextDirection", true);
+  }
+}
+
+/**
+ * Opens a new tab with the userContextId specified as an attribute of
+ * sourceEvent. This attribute is propagated to the top level originAttributes
+ * living on the tab's docShell.
+ *
+ * @param event
+ *        A click event on a userContext File Menu option
+ */
+function openNewUserContextTab(event) {
+  openUILinkIn(BROWSER_NEW_TAB_URL, "tab", {
+    userContextId: parseInt(event.target.getAttribute("data-usercontextid")),
+  });
+}
+
+/**
+ * Updates File Menu User Context UI visibility depending on
+ * privacy.userContext.enabled pref state.
+ */
+function updateUserContextUIVisibility() {
+  let menu = document.getElementById("menu_newUserContext");
+  menu.hidden = !Services.prefs.getBoolPref("privacy.userContext.enabled");
+  if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+    menu.setAttribute("disabled", "true");
+  }
+}
+
+/**
+ * Updates the User Context UI indicators if the browser is in a non-default context
+ */
+function updateUserContextUIIndicator() {
+  let hbox = document.getElementById("userContext-icons");
+
+  let userContextId = gBrowser.selectedBrowser.getAttribute("usercontextid");
+  if (!userContextId) {
+    hbox.setAttribute("data-identity-color", "");
+    hbox.hidden = true;
+    return;
+  }
+
+  let identity = ContextualIdentityService.getPublicIdentityFromId(userContextId);
+  if (!identity) {
+    hbox.setAttribute("data-identity-color", "");
+    hbox.hidden = true;
+    return;
+  }
+
+  hbox.setAttribute("data-identity-color", identity.color);
+
+  let label = document.getElementById("userContext-label");
+  label.setAttribute("value", ContextualIdentityService.getUserContextLabel(userContextId));
+
+  let indicator = document.getElementById("userContext-indicator");
+  indicator.setAttribute("data-identity-icon", identity.icon);
+
+  hbox.hidden = false;
+}
+
+/**
+ * Makes the Character Encoding menu enabled or disabled as appropriate.
+ * To be called when the View menu or the app menu is opened.
+ */
+function updateCharacterEncodingMenuState() {
+  let charsetMenu = document.getElementById("charsetMenu");
+  // gBrowser is null on Mac when the menubar shows in the context of
+  // non-browser windows. The above elements may be null depending on
+  // what parts of the menubar are present. E.g. no app menu on Mac.
+  if (gBrowser && gBrowser.selectedBrowser.mayEnableCharacterEncodingMenu) {
+    if (charsetMenu) {
+      charsetMenu.removeAttribute("disabled");
+    }
+  } else if (charsetMenu) {
+    charsetMenu.setAttribute("disabled", "true");
+  }
+}
+
+var XULBrowserWindow = {
+  // Stored Status, Link and Loading values
+  status: "",
+  defaultStatus: "",
+  overLink: "",
+  startTime: 0,
+  statusText: "",
+  isBusy: false,
+  // Left here for add-on compatibility, see bug 752434
+  inContentWhitelist: [],
+
+  QueryInterface(aIID) {
+    if (aIID.equals(Ci.nsIWebProgressListener) ||
+        aIID.equals(Ci.nsIWebProgressListener2) ||
+        aIID.equals(Ci.nsISupportsWeakReference) ||
+        aIID.equals(Ci.nsIXULBrowserWindow) ||
+        aIID.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_NOINTERFACE;
+  },
+
+  get stopCommand() {
+    delete this.stopCommand;
+    return this.stopCommand = document.getElementById("Browser:Stop");
+  },
+  get reloadCommand() {
+    delete this.reloadCommand;
+    return this.reloadCommand = document.getElementById("Browser:Reload");
+  },
+  get statusTextField() {
+    return gBrowser.getStatusPanel();
+  },
+  get isImage() {
+    delete this.isImage;
+    return this.isImage = document.getElementById("isImage");
+  },
+  get canViewSource() {
+    delete this.canViewSource;
+    return this.canViewSource = document.getElementById("canViewSource");
+  },
+
+  setJSStatus() {
+    // unsupported
+  },
+
+  forceInitialBrowserRemote(aRemoteType) {
+    let initBrowser =
+      document.getAnonymousElementByAttribute(gBrowser, "anonid", "initialBrowser");
+    gBrowser.updateBrowserRemoteness(initBrowser, true, { remoteType: aRemoteType });
+  },
+
+  forceInitialBrowserNonRemote(aOpener) {
+    let initBrowser =
+      document.getAnonymousElementByAttribute(gBrowser, "anonid", "initialBrowser");
+    gBrowser.updateBrowserRemoteness(initBrowser, false, { opener: aOpener });
+  },
+
+  setDefaultStatus(status) {
+    this.defaultStatus = status;
+    this.updateStatusField();
+  },
+
+  setOverLink(url, anchorElt) {
+    const textToSubURI = Cc["@mozilla.org/intl/texttosuburi;1"].
+                         getService(Ci.nsITextToSubURI);
+    url = textToSubURI.unEscapeURIForUI("UTF-8", url);
+
+    // Encode bidirectional formatting characters.
+    // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
+    url = url.replace(/[\u200e\u200f\u202a\u202b\u202c\u202d\u202e]/g,
+                      encodeURIComponent);
+
+    if (gURLBar && gURLBar._mayTrimURLs /* corresponds to browser.urlbar.trimURLs */)
+      url = trimURL(url);
+
+    this.overLink = url;
+    LinkTargetDisplay.update();
+  },
+
+  showTooltip(x, y, tooltip, direction, browser) {
+    if (Cc["@mozilla.org/widget/dragservice;1"].getService(Ci.nsIDragService).
+        getCurrentSession()) {
+      return;
+    }
+
+    // The x,y coordinates are relative to the <browser> element using
+    // the chrome zoom level.
+    let elt = document.getElementById("remoteBrowserTooltip");
+    elt.label = tooltip;
+    elt.style.direction = direction;
+
+    elt.openPopupAtScreen(browser.boxObject.screenX + x, browser.boxObject.screenY + y, false, null);
+  },
+
+  hideTooltip() {
+    let elt = document.getElementById("remoteBrowserTooltip");
+    elt.hidePopup();
+  },
+
+  getTabCount() {
+    return gBrowser.tabs.length;
+  },
+
+  updateStatusField() {
+    var text, type, types = ["overLink"];
+    if (this._busyUI)
+      types.push("status");
+    types.push("defaultStatus");
+    for (type of types) {
+      text = this[type];
+      if (text)
+        break;
+    }
+
+    // check the current value so we don't trigger an attribute change
+    // and cause needless (slow!) UI updates
+    if (this.statusText != text) {
+      let field = this.statusTextField;
+      field.setAttribute("previoustype", field.getAttribute("type"));
+      field.setAttribute("type", type);
+      field.label = text;
+      field.setAttribute("crop", type == "overLink" ? "center" : "end");
+      this.statusText = text;
+    }
+  },
+
+  // Called before links are navigated to to allow us to retarget them if needed.
+  onBeforeLinkTraversal(originalTarget, linkURI, linkNode, isAppTab) {
+    return BrowserUtils.onBeforeLinkTraversal(originalTarget, linkURI, linkNode, isAppTab);
+  },
+
+  // Check whether this URI should load in the current process
+  shouldLoadURI(aDocShell, aURI, aReferrer, aHasPostData, aTriggeringPrincipal) {
+    if (!gMultiProcessBrowser)
+      return true;
+
+    let browser = aDocShell.QueryInterface(Ci.nsIDocShellTreeItem)
+                           .sameTypeRootTreeItem
+                           .QueryInterface(Ci.nsIDocShell)
+                           .chromeEventHandler;
+
+    // Ignore loads that aren't in the main tabbrowser
+    if (browser.localName != "browser" || !browser.getTabBrowser || browser.getTabBrowser() != gBrowser)
+      return true;
+
+    if (!E10SUtils.shouldLoadURI(aDocShell, aURI, aReferrer, aHasPostData)) {
+      // XXX: Do we want to complain if we have post data but are still
+      // redirecting the load? Perhaps a telemetry probe? Theoretically we
+      // shouldn't do this, as it throws out data. See bug 1348018.
+      E10SUtils.redirectLoad(aDocShell, aURI, aReferrer, aTriggeringPrincipal, false);
+      return false;
+    }
+
+    return true;
+  },
+
+  onProgressChange(aWebProgress, aRequest,
+                             aCurSelfProgress, aMaxSelfProgress,
+                             aCurTotalProgress, aMaxTotalProgress) {
+    // Do nothing.
+  },
+
+  onProgressChange64(aWebProgress, aRequest,
+                               aCurSelfProgress, aMaxSelfProgress,
+                               aCurTotalProgress, aMaxTotalProgress) {
+    return this.onProgressChange(aWebProgress, aRequest,
+      aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
+      aMaxTotalProgress);
+  },
+
+  // This function fires only for the currently selected tab.
+  onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+    const nsIWebProgressListener = Ci.nsIWebProgressListener;
+    const nsIChannel = Ci.nsIChannel;
+
+    let browser = gBrowser.selectedBrowser;
+
+    if (aStateFlags & nsIWebProgressListener.STATE_START &&
+        aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
+
+      if (aRequest && aWebProgress.isTopLevel) {
+        // clear out feed data
+        browser.feeds = null;
+
+        // clear out search-engine data
+        browser.engines = null;
+      }
+
+      this.isBusy = true;
+
+      if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING)) {
+        this._busyUI = true;
+
+        // XXX: This needs to be based on window activity...
+        this.stopCommand.removeAttribute("disabled");
+        CombinedStopReload.switchToStop(aRequest, aWebProgress);
+      }
+    } else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
+      // This (thanks to the filter) is a network stop or the last
+      // request stop outside of loading the document, stop throbbers
+      // and progress bars and such
+      if (aRequest) {
+        let msg = "";
+        let location;
+        let canViewSource = true;
+        // Get the URI either from a channel or a pseudo-object
+        if (aRequest instanceof nsIChannel || "URI" in aRequest) {
+          location = aRequest.URI;
+
+          // For keyword URIs clear the user typed value since they will be changed into real URIs
+          if (location.scheme == "keyword" && aWebProgress.isTopLevel)
+            gBrowser.userTypedValue = null;
+
+          canViewSource = !Services.prefs.getBoolPref("view_source.tab") ||
+                          location.scheme != "view-source";
+
+          if (location.spec != "about:blank") {
+            switch (aStatus) {
+              case Components.results.NS_ERROR_NET_TIMEOUT:
+                msg = gNavigatorBundle.getString("nv_timeout");
+                break;
+            }
+          }
+        }
+
+        this.status = "";
+        this.setDefaultStatus(msg);
+
+        // Disable menu entries for images, enable otherwise
+        if (browser.documentContentType && BrowserUtils.mimeTypeIsTextBased(browser.documentContentType)) {
+          this.isImage.removeAttribute("disabled");
+        } else {
+          canViewSource = false;
+          this.isImage.setAttribute("disabled", "true");
+        }
+
+        if (canViewSource) {
+          this.canViewSource.removeAttribute("disabled");
+        } else {
+          this.canViewSource.setAttribute("disabled", "true");
+        }
+      }
+
+      this.isBusy = false;
+
+      if (this._busyUI) {
+        this._busyUI = false;
+
+        this.stopCommand.setAttribute("disabled", "true");
+        CombinedStopReload.switchToReload(aRequest, aWebProgress);
+      }
+    }
+  },
+
+  onLocationChange(aWebProgress, aRequest, aLocationURI, aFlags) {
+    var location = aLocationURI ? aLocationURI.spec : "";
+
+    let pageTooltip = document.getElementById("aHTMLTooltip");
+    let tooltipNode = pageTooltip.triggerNode;
+    if (tooltipNode) {
+      // Optimise for the common case
+      if (aWebProgress.isTopLevel) {
+        pageTooltip.hidePopup();
+      } else {
+        for (let tooltipWindow = tooltipNode.ownerGlobal;
+             tooltipWindow != tooltipWindow.parent;
+             tooltipWindow = tooltipWindow.parent) {
+          if (tooltipWindow == aWebProgress.DOMWindow) {
+            pageTooltip.hidePopup();
+            break;
+          }
+        }
+      }
+    }
+
+    let browser = gBrowser.selectedBrowser;
+
+    // Disable menu entries for images, enable otherwise
+    if (browser.documentContentType && BrowserUtils.mimeTypeIsTextBased(browser.documentContentType))
+      this.isImage.removeAttribute("disabled");
+    else
+      this.isImage.setAttribute("disabled", "true");
+
+    this.hideOverLinkImmediately = true;
+    this.setOverLink("", null);
+    this.hideOverLinkImmediately = false;
+
+    // We should probably not do this if the value has changed since the user
+    // searched
+    // Update urlbar only if a new page was loaded on the primary content area
+    // Do not update urlbar if there was a subframe navigation
+
+    if (aWebProgress.isTopLevel) {
+      if ((location == "about:blank" && checkEmptyPageOrigin()) ||
+          location == "") { // Second condition is for new tabs, otherwise
+                             // reload function is enabled until tab is refreshed.
+        this.reloadCommand.setAttribute("disabled", "true");
+      } else {
+        this.reloadCommand.removeAttribute("disabled");
+      }
+
+      URLBarSetURI(aLocationURI);
+
+      BookmarkingUI.onLocationChange();
+
+      gIdentityHandler.onLocationChange();
+
+      BrowserPageActions.onLocationChange();
+
+      gTabletModePageCounter.inc();
+
+      // Utility functions for disabling find
+      var shouldDisableFind = function(aDocument) {
+        let docElt = aDocument.documentElement;
+        return docElt && docElt.getAttribute("disablefastfind") == "true";
+      };
+
+      var disableFindCommands = function(aDisable) {
+        let findCommands = [document.getElementById("cmd_find"),
+                            document.getElementById("cmd_findAgain"),
+                            document.getElementById("cmd_findPrevious")];
+        for (let elt of findCommands) {
+          if (aDisable)
+            elt.setAttribute("disabled", "true");
+          else
+            elt.removeAttribute("disabled");
+        }
+      };
+
+      var onContentRSChange = function(e) {
+        if (e.target.readyState != "interactive" && e.target.readyState != "complete")
+          return;
+
+        e.target.removeEventListener("readystatechange", onContentRSChange);
+        disableFindCommands(shouldDisableFind(e.target));
+      };
+
+      // Disable find commands in documents that ask for them to be disabled.
+      if (!gMultiProcessBrowser && aLocationURI &&
+          (aLocationURI.schemeIs("about") || aLocationURI.schemeIs("chrome"))) {
+        // Don't need to re-enable/disable find commands for same-document location changes
+        // (e.g. the replaceStates in about:addons)
+        if (!(aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT)) {
+          if (window.content.document.readyState == "interactive" || window.content.document.readyState == "complete")
+            disableFindCommands(shouldDisableFind(window.content.document));
+          else {
+            window.content.document.addEventListener("readystatechange", onContentRSChange);
+          }
+        }
+      } else
+        disableFindCommands(false);
+
+      // Try not to instantiate gCustomizeMode as much as possible,
+      // so don't use CustomizeMode.jsm to check for URI or customizing.
+      if (location == "about:blank" &&
+          gBrowser.selectedTab.hasAttribute("customizemode")) {
+        gCustomizeMode.enter();
+      } else if (CustomizationHandler.isEnteringCustomizeMode ||
+                 CustomizationHandler.isCustomizing()) {
+        gCustomizeMode.exit();
+      }
+    }
+    UpdateBackForwardCommands(gBrowser.webNavigation);
+    ReaderParent.updateReaderButton(gBrowser.selectedBrowser);
+
+    if (!gMultiProcessBrowser) // Bug 1108553 - Cannot rotate images with e10s
+      gGestureSupport.restoreRotationState();
+
+    // See bug 358202, when tabs are switched during a drag operation,
+    // timers don't fire on windows (bug 203573)
+    if (aRequest)
+      setTimeout(function() { XULBrowserWindow.asyncUpdateUI(); }, 0);
+    else
+      this.asyncUpdateUI();
+
+    if (AppConstants.MOZ_CRASHREPORTER && aLocationURI) {
+      let uri = aLocationURI.clone();
+      try {
+        // If the current URI contains a username/password, remove it.
+        uri.userPass = "";
+      } catch (ex) { /* Ignore failures on about: URIs. */ }
+
+      try {
+        gCrashReporter.annotateCrashReport("URL", uri.spec);
+      } catch (ex) {
+        // Don't make noise when the crash reporter is built but not enabled.
+        if (ex.result != Components.results.NS_ERROR_NOT_INITIALIZED) {
+          throw ex;
+        }
+      }
+    }
+  },
+
+  asyncUpdateUI() {
+    FeedHandler.updateFeeds();
+    BrowserSearch.updateOpenSearchBadge();
+  },
+
+  // Left here for add-on compatibility, see bug 752434
+  hideChromeForLocation() {},
+
+  onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
+    this.status = aMessage;
+    this.updateStatusField();
+  },
+
+  // Properties used to cache security state used to update the UI
+  _state: null,
+  _lastLocation: null,
+
+  // This is called in multiple ways:
+  //  1. Due to the nsIWebProgressListener.onSecurityChange notification.
+  //  2. Called by tabbrowser.xml when updating the current browser.
+  //  3. Called directly during this object's initializations.
+  // aRequest will be null always in case 2 and 3, and sometimes in case 1 (for
+  // instance, there won't be a request when STATE_BLOCKED_TRACKING_CONTENT is observed).
+  onSecurityChange(aWebProgress, aRequest, aState, aIsSimulated) {
+    // Don't need to do anything if the data we use to update the UI hasn't
+    // changed
+    let uri = gBrowser.currentURI;
+    let spec = uri.spec;
+    if (this._state == aState &&
+        this._lastLocation == spec) {
+      // Switching to a tab of the same URL doesn't change most security
+      // information, but tab specific permissions may be different.
+      gIdentityHandler.refreshIdentityBlock();
+      return;
+    }
+    this._state = aState;
+    this._lastLocation = spec;
+
+    if (typeof(aIsSimulated) != "boolean" && typeof(aIsSimulated) != "undefined") {
+      throw "onSecurityChange: aIsSimulated receieved an unexpected type";
+    }
+
+    // Make sure the "https" part of the URL is striked out or not,
+    // depending on the current mixed active content blocking state.
+    gURLBar.formatValue();
+
+    try {
+      uri = Services.uriFixup.createExposableURI(uri);
+    } catch (e) {}
+    gIdentityHandler.updateIdentity(this._state, uri);
+    TrackingProtection.onSecurityChange(this._state, aIsSimulated);
+  },
+
+  // simulate all change notifications after switching tabs
+  onUpdateCurrentBrowser: function XWB_onUpdateCurrentBrowser(aStateFlags, aStatus, aMessage, aTotalProgress) {
+    if (FullZoom.updateBackgroundTabs)
+      FullZoom.onLocationChange(gBrowser.currentURI, true);
+
+    CombinedStopReload.onTabSwitch();
+
+    var nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
+    var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
+    // use a pseudo-object instead of a (potentially nonexistent) channel for getting
+    // a correct error message - and make sure that the UI is always either in
+    // loading (STATE_START) or done (STATE_STOP) mode
+    this.onStateChange(
+      gBrowser.webProgress,
+      { URI: gBrowser.currentURI },
+      loadingDone ? nsIWebProgressListener.STATE_STOP : nsIWebProgressListener.STATE_START,
+      aStatus
+    );
+    // status message and progress value are undefined if we're done with loading
+    if (loadingDone)
+      return;
+    this.onStatusChange(gBrowser.webProgress, null, 0, aMessage);
+  },
+
+  navigateAndRestoreByIndex: function XWB_navigateAndRestoreByIndex(aBrowser, aIndex) {
+    let tab = gBrowser.getTabForBrowser(aBrowser);
+    if (tab) {
+      SessionStore.navigateAndRestore(tab, {}, aIndex);
+      return;
+    }
+
+    throw new Error("Trying to navigateAndRestore a browser which was " +
+                    "not attached to this tabbrowser is unsupported");
+  }
+};
+
+var LinkTargetDisplay = {
+  get DELAY_SHOW() {
+     delete this.DELAY_SHOW;
+     return this.DELAY_SHOW = Services.prefs.getIntPref("browser.overlink-delay");
+  },
+
+  DELAY_HIDE: 250,
+  _timer: 0,
+
+  get _isVisible() {
+    return XULBrowserWindow.statusTextField.label != "";
+  },
+
+  update() {
+    clearTimeout(this._timer);
+    window.removeEventListener("mousemove", this, true);
+
+    if (!XULBrowserWindow.overLink) {
+      if (XULBrowserWindow.hideOverLinkImmediately)
+        this._hide();
+      else
+        this._timer = setTimeout(this._hide.bind(this), this.DELAY_HIDE);
+      return;
+    }
+
+    if (this._isVisible) {
+      XULBrowserWindow.updateStatusField();
+    } else {
+      // Let the display appear when the mouse doesn't move within the delay
+      this._showDelayed();
+      window.addEventListener("mousemove", this, true);
+    }
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "mousemove":
+        // Restart the delay since the mouse was moved
+        clearTimeout(this._timer);
+        this._showDelayed();
+        break;
+    }
+  },
+
+  _showDelayed() {
+    this._timer = setTimeout(function(self) {
+      XULBrowserWindow.updateStatusField();
+      window.removeEventListener("mousemove", self, true);
+    }, this.DELAY_SHOW, this);
+  },
+
+  _hide() {
+    clearTimeout(this._timer);
+
+    XULBrowserWindow.updateStatusField();
+  }
+};
+
+var CombinedStopReload = {
+  // Try to initialize. Returns whether initialization was successful, which
+  // may mean we had already initialized.
+  ensureInitialized() {
+    if (this._initialized)
+      return true;
+    if (this._destroyed)
+      return false;
+
+    let reload = document.getElementById("reload-button");
+    let stop = document.getElementById("stop-button");
+    // It's possible the stop/reload buttons have been moved to the palette.
+    // They may be reinserted later, so we will retry initialization if/when
+    // we get notified of document loads.
+    if (!stop || !reload)
+      return false;
+
+    this._initialized = true;
+    if (XULBrowserWindow.stopCommand.getAttribute("disabled") != "true")
+      reload.setAttribute("displaystop", "true");
+    stop.addEventListener("click", this);
+
+    // Removing attributes based on the observed command doesn't happen if the button
+    // is in the palette when the command's attribute is removed (cf. bug 309953)
+    for (let button of [stop, reload]) {
+      if (button.hasAttribute("disabled")) {
+        let command = document.getElementById(button.getAttribute("command"));
+        if (!command.hasAttribute("disabled")) {
+          button.removeAttribute("disabled");
+        }
+      }
+    }
+
+    this.reload = reload;
+    this.stop = stop;
+    this.stopReloadContainer = this.reload.parentNode;
+    this.timeWhenSwitchedToStop = 0;
+
+    if (this._shouldStartPrefMonitoring) {
+      this.startAnimationPrefMonitoring();
+    }
+    return true;
+  },
+
+  uninit() {
+    this._destroyed = true;
+
+    if (!this._initialized)
+      return;
+
+    Services.prefs.removeObserver("toolkit.cosmeticAnimations.enabled", this);
+    this._cancelTransition();
+    this.stop.removeEventListener("click", this);
+    this.stopReloadContainer.removeEventListener("animationend", this);
+    this.stopReloadContainer = null;
+    this.reload = null;
+    this.stop = null;
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "click":
+        if (event.button == 0 &&
+            !this.stop.disabled) {
+          this._stopClicked = true;
+        }
+      case "animationend": {
+        if (event.target.classList.contains("toolbarbutton-animatable-image") &&
+            (event.animationName == "reload-to-stop" ||
+             event.animationName == "stop-to-reload" ||
+             event.animationName == "reload-to-stop-rtl" ||
+             event.animationName == "stop-to-reload-rtl")) {
+          this.stopReloadContainer.removeAttribute("animate");
+        }
+      }
+    }
+  },
+
+  observe(subject, topic, data) {
+    if (topic == "nsPref:changed") {
+      this.animate = Services.prefs.getBoolPref("toolkit.cosmeticAnimations.enabled");
+    }
+  },
+
+  startAnimationPrefMonitoring() {
+    // CombinedStopReload may have been uninitialized before the idleCallback is executed.
+    if (this._destroyed)
+      return;
+    if (!this.ensureInitialized()) {
+      this._shouldStartPrefMonitoring = true;
+      return;
+    }
+    this.animate = Services.prefs.getBoolPref("toolkit.cosmeticAnimations.enabled") &&
+                   Services.prefs.getBoolPref("browser.stopReloadAnimation.enabled");
+    Services.prefs.addObserver("toolkit.cosmeticAnimations.enabled", this);
+    this.stopReloadContainer.addEventListener("animationend", this);
+  },
+
+  onTabSwitch() {
+    // Reset the time in the event of a tabswitch since the stored time
+    // would have been associated with the previous tab, so the animation will
+    // still run if the page has been loading until long after the tab switch.
+    this.timeWhenSwitchedToStop = window.performance.now();
+  },
+
+  switchToStop(aRequest, aWebProgress) {
+    if (!this.ensureInitialized() || !this._shouldSwitch(aRequest, aWebProgress)) {
+      return;
+    }
+
+    // Store the time that we switched to the stop button only if a request
+    // is active. Requests are null if the switch is related to a tabswitch.
+    // This is used to determine if we should show the stop->reload animation.
+    if (aRequest instanceof Ci.nsIRequest) {
+      this.timeWhenSwitchedToStop = window.performance.now();
+    }
+
+    let shouldAnimate = aRequest instanceof Ci.nsIRequest &&
+                        aWebProgress.isTopLevel &&
+                        aWebProgress.isLoadingDocument &&
+                        !gBrowser.tabAnimationsInProgress &&
+                        this.stopReloadContainer.closest("#nav-bar-customization-target") &&
+                        this.animate;
+
+    this._cancelTransition();
+    if (shouldAnimate) {
+      BrowserUtils.setToolbarButtonHeightProperty(this.stopReloadContainer);
+      this.stopReloadContainer.setAttribute("animate", "true");
+    } else {
+      this.stopReloadContainer.removeAttribute("animate");
+    }
+    this.reload.setAttribute("displaystop", "true");
+  },
+
+  switchToReload(aRequest, aWebProgress) {
+    if (!this.ensureInitialized() || !this.reload.hasAttribute("displaystop")) {
+      return;
+    }
+
+    let shouldAnimate = aRequest instanceof Ci.nsIRequest &&
+                        aWebProgress.isTopLevel &&
+                        !aWebProgress.isLoadingDocument &&
+                        !gBrowser.tabAnimationsInProgress &&
+                        this._loadTimeExceedsMinimumForAnimation() &&
+                        this.stopReloadContainer.closest("#nav-bar-customization-target") &&
+                        this.animate;
+
+    if (shouldAnimate) {
+      BrowserUtils.setToolbarButtonHeightProperty(this.stopReloadContainer);
+      this.stopReloadContainer.setAttribute("animate", "true");
+    } else {
+      this.stopReloadContainer.removeAttribute("animate");
+    }
+
+    this.reload.removeAttribute("displaystop");
+
+    if (!shouldAnimate || this._stopClicked) {
+      this._stopClicked = false;
+      this._cancelTransition();
+      this.reload.disabled = XULBrowserWindow.reloadCommand
+                                             .getAttribute("disabled") == "true";
+      return;
+    }
+
+    if (this._timer)
+      return;
+
+    // Temporarily disable the reload button to prevent the user from
+    // accidentally reloading the page when intending to click the stop button
+    this.reload.disabled = true;
+    this._timer = setTimeout(function(self) {
+      self._timer = 0;
+      self.reload.disabled = XULBrowserWindow.reloadCommand
+                                             .getAttribute("disabled") == "true";
+    }, 650, this);
+  },
+
+  _loadTimeExceedsMinimumForAnimation() {
+    // If the time between switching to the stop button then switching to
+    // the reload button exceeds 150ms, then we will show the animation.
+    // If we don't know when we switched to stop (switchToStop is called
+    // after init but before switchToReload), then we will prevent the
+    // animation from occuring.
+    return this.timeWhenSwitchedToStop &&
+           window.performance.now() - this.timeWhenSwitchedToStop > 150;
+  },
+
+  _shouldSwitch(aRequest, aWebProgress) {
+    if (aRequest &&
+        aRequest.originalURI &&
+        (aRequest.originalURI.schemeIs("chrome") ||
+         (aRequest.originalURI.schemeIs("about") &&
+          aWebProgress.isTopLevel &&
+          !aRequest.originalURI.spec.startsWith("about:reader")))) {
+      return false;
+    }
+
+    return true;
+  },
+
+  _cancelTransition() {
+    if (this._timer) {
+      clearTimeout(this._timer);
+      this._timer = 0;
+    }
+  }
+};
+
+var TabsProgressListener = {
+  onStateChange(aBrowser, aWebProgress, aRequest, aStateFlags, aStatus) {
+    // Collect telemetry data about tab load times.
+    if (aWebProgress.isTopLevel && (!aRequest.originalURI || aRequest.originalURI.spec.scheme != "about")) {
+      let stopwatchRunning = TelemetryStopwatch.running("FX_PAGE_LOAD_MS", aBrowser);
+
+      if (aStateFlags & Ci.nsIWebProgressListener.STATE_IS_WINDOW) {
+        if (aStateFlags & Ci.nsIWebProgressListener.STATE_START) {
+          if (stopwatchRunning) {
+            // Oops, we're seeing another start without having noticed the previous stop.
+            TelemetryStopwatch.cancel("FX_PAGE_LOAD_MS", aBrowser);
+          }
+          TelemetryStopwatch.start("FX_PAGE_LOAD_MS", aBrowser);
+          Services.telemetry.getHistogramById("FX_TOTAL_TOP_VISITS").add(true);
+        } else if (aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
+                   stopwatchRunning /* we won't see STATE_START events for pre-rendered tabs */) {
+          TelemetryStopwatch.finish("FX_PAGE_LOAD_MS", aBrowser);
+        }
+      } else if (aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
+                 aStatus == Cr.NS_BINDING_ABORTED &&
+                 stopwatchRunning /* we won't see STATE_START events for pre-rendered tabs */) {
+        TelemetryStopwatch.cancel("FX_PAGE_LOAD_MS", aBrowser);
+      }
+    }
+
+    // We used to listen for clicks in the browser here, but when that
+    // became unnecessary, removing the code below caused focus issues.
+    // This code should be removed. Tracked in bug 1337794.
+    let isRemoteBrowser = aBrowser.isRemoteBrowser;
+    // We check isRemoteBrowser here to avoid requesting the doc CPOW
+    let doc = isRemoteBrowser ? null : aWebProgress.DOMWindow.document;
+
+    if (!isRemoteBrowser &&
+        aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
+        Components.isSuccessCode(aStatus) &&
+        doc.documentURI.startsWith("about:") &&
+        !doc.documentURI.toLowerCase().startsWith("about:blank") &&
+        !doc.documentURI.toLowerCase().startsWith("about:home") &&
+        !doc.documentElement.hasAttribute("hasBrowserHandlers")) {
+      // STATE_STOP may be received twice for documents, thus store an
+      // attribute to ensure handling it just once.
+      doc.documentElement.setAttribute("hasBrowserHandlers", "true");
+      aBrowser.addEventListener("pagehide", function onPageHide(event) {
+        if (event.target.defaultView.frameElement)
+          return;
+        aBrowser.removeEventListener("pagehide", onPageHide, true);
+        if (event.target.documentElement)
+          event.target.documentElement.removeAttribute("hasBrowserHandlers");
+      }, true);
+    }
+  },
+
+  onLocationChange(aBrowser, aWebProgress, aRequest, aLocationURI,
+                             aFlags) {
+    // Filter out location changes caused by anchor navigation
+    // or history.push/pop/replaceState.
+    if (aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT) {
+      // Reader mode actually cares about these:
+      let mm = gBrowser.selectedBrowser.messageManager;
+      mm.sendAsyncMessage("Reader:PushState", {isArticle: gBrowser.selectedBrowser.isArticle});
+      return;
+    }
+
+    // Filter out location changes in sub documents.
+    if (!aWebProgress.isTopLevel)
+      return;
+
+    // Only need to call locationChange if the PopupNotifications object
+    // for this window has already been initialized (i.e. its getter no
+    // longer exists)
+    if (!Object.getOwnPropertyDescriptor(window, "PopupNotifications").get)
+      PopupNotifications.locationChange(aBrowser);
+
+    let tab = gBrowser.getTabForBrowser(aBrowser);
+    if (tab && tab._sharingState) {
+      gBrowser.setBrowserSharing(aBrowser, {});
+    }
+    webrtcUI.forgetStreamsFromBrowser(aBrowser);
+
+    gBrowser.getNotificationBox(aBrowser).removeTransientNotifications();
+
+    FullZoom.onLocationChange(aLocationURI, false, aBrowser);
+  },
+};
+
+function nsBrowserAccess() { }
+
+nsBrowserAccess.prototype = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIBrowserDOMWindow, Ci.nsISupports]),
+
+  _openURIInNewTab(aURI, aReferrer, aReferrerPolicy, aIsPrivate,
+                   aIsExternal, aForceNotRemote = false,
+                   aUserContextId = Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID,
+                   aOpenerWindow = null, aOpenerBrowser = null,
+                   aTriggeringPrincipal = null, aNextTabParentId = 0, aName = "") {
+    let win, needToFocusWin;
+
+    // try the current window.  if we're in a popup, fall back on the most recent browser window
+    if (window.toolbar.visible)
+      win = window;
+    else {
+      win = RecentWindow.getMostRecentBrowserWindow({private: aIsPrivate});
+      needToFocusWin = true;
+    }
+
+    if (!win) {
+      // we couldn't find a suitable window, a new one needs to be opened.
+      return null;
+    }
+
+    if (aIsExternal && (!aURI || aURI.spec == "about:blank")) {
+      win.BrowserOpenTab(); // this also focuses the location bar
+      win.focus();
+      return win.gBrowser.selectedBrowser;
+    }
+
+    let loadInBackground = Services.prefs.getBoolPref("browser.tabs.loadDivertedInBackground");
+
+    let tab = win.gBrowser.loadOneTab(aURI ? aURI.spec : "about:blank", {
+                                      triggeringPrincipal: aTriggeringPrincipal,
+                                      referrerURI: aReferrer,
+                                      referrerPolicy: aReferrerPolicy,
+                                      userContextId: aUserContextId,
+                                      fromExternal: aIsExternal,
+                                      inBackground: loadInBackground,
+                                      forceNotRemote: aForceNotRemote,
+                                      opener: aOpenerWindow,
+                                      openerBrowser: aOpenerBrowser,
+                                      nextTabParentId: aNextTabParentId,
+                                      name: aName,
+                                      });
+    let browser = win.gBrowser.getBrowserForTab(tab);
+
+    if (needToFocusWin || (!loadInBackground && aIsExternal))
+      win.focus();
+
+    return browser;
+  },
+
+  createContentWindow(aURI, aOpener, aWhere, aFlags, aTriggeringPrincipal) {
+    return this.getContentWindowOrOpenURI(null, aOpener, aWhere, aFlags,
+                                          aTriggeringPrincipal);
+  },
+
+  openURI(aURI, aOpener, aWhere, aFlags, aTriggeringPrincipal) {
+    if (!aURI) {
+      Cu.reportError("openURI should only be called with a valid URI");
+      throw Cr.NS_ERROR_FAILURE;
+    }
+    return this.getContentWindowOrOpenURI(aURI, aOpener, aWhere, aFlags,
+                                          aTriggeringPrincipal);
+  },
+
+  getContentWindowOrOpenURI(aURI, aOpener, aWhere, aFlags, aTriggeringPrincipal) {
+    // This function should only ever be called if we're opening a URI
+    // from a non-remote browser window (via nsContentTreeOwner).
+    if (aOpener && Cu.isCrossProcessWrapper(aOpener)) {
+      Cu.reportError("nsBrowserAccess.openURI was passed a CPOW for aOpener. " +
+                     "openURI should only ever be called from non-remote browsers.");
+      throw Cr.NS_ERROR_FAILURE;
+    }
+
+    var newWindow = null;
+    var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+
+    if (aOpener && isExternal) {
+      Cu.reportError("nsBrowserAccess.openURI did not expect an opener to be " +
+                     "passed if the context is OPEN_EXTERNAL.");
+      throw Cr.NS_ERROR_FAILURE;
+    }
+
+    if (isExternal && aURI && aURI.schemeIs("chrome")) {
+      dump("use --chrome command-line option to load external chrome urls\n");
+      return null;
+    }
+
+    if (aWhere == Ci.nsIBrowserDOMWindow.OPEN_DEFAULTWINDOW) {
+      if (isExternal &&
+          Services.prefs.prefHasUserValue("browser.link.open_newwindow.override.external"))
+        aWhere = Services.prefs.getIntPref("browser.link.open_newwindow.override.external");
+      else
+        aWhere = Services.prefs.getIntPref("browser.link.open_newwindow");
+    }
+
+    let referrer = aOpener ? makeURI(aOpener.location.href) : null;
+    let referrerPolicy = Ci.nsIHttpChannel.REFERRER_POLICY_UNSET;
+    if (aOpener && aOpener.document) {
+      referrerPolicy = aOpener.document.referrerPolicy;
+    }
+    let isPrivate = aOpener
+                  ? PrivateBrowsingUtils.isContentWindowPrivate(aOpener)
+                  : PrivateBrowsingUtils.isWindowPrivate(window);
+
+    switch (aWhere) {
+      case Ci.nsIBrowserDOMWindow.OPEN_NEWWINDOW :
+        // FIXME: Bug 408379. So how come this doesn't send the
+        // referrer like the other loads do?
+        var url = aURI ? aURI.spec : "about:blank";
+        let features = "all,dialog=no";
+        if (isPrivate) {
+          features += ",private";
+        }
+        // Pass all params to openDialog to ensure that "url" isn't passed through
+        // loadOneOrMoreURIs, which splits based on "|"
+        newWindow = openDialog(getBrowserURL(), "_blank", features, url, null, null, null);
+        break;
+      case Ci.nsIBrowserDOMWindow.OPEN_NEWTAB :
+        // If we have an opener, that means that the caller is expecting access
+        // to the nsIDOMWindow of the opened tab right away. For e10s windows,
+        // this means forcing the newly opened browser to be non-remote so that
+        // we can hand back the nsIDOMWindow. The XULBrowserWindow.shouldLoadURI
+        // will do the job of shuttling off the newly opened browser to run in
+        // the right process once it starts loading a URI.
+        let forceNotRemote = !!aOpener;
+        let userContextId = aOpener && aOpener.document
+                              ? aOpener.document.nodePrincipal.originAttributes.userContextId
+                              : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+        let openerWindow = (aFlags & Ci.nsIBrowserDOMWindow.OPEN_NO_OPENER) ? null : aOpener;
+        let browser = this._openURIInNewTab(aURI, referrer, referrerPolicy,
+                                            isPrivate, isExternal,
+                                            forceNotRemote, userContextId,
+                                            openerWindow, null, aTriggeringPrincipal);
+        if (browser)
+          newWindow = browser.contentWindow;
+        break;
+      default : // OPEN_CURRENTWINDOW or an illegal value
+        newWindow = window.content;
+        if (aURI) {
+          let loadflags = isExternal ?
+                            Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL :
+                            Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+          gBrowser.loadURIWithFlags(aURI.spec, {
+                                    aTriggeringPrincipal,
+                                    flags: loadflags,
+                                    referrerURI: referrer,
+                                    referrerPolicy,
+                                    });
+        }
+        if (!Services.prefs.getBoolPref("browser.tabs.loadDivertedInBackground"))
+          window.focus();
+    }
+    return newWindow;
+  },
+
+  createContentWindowInFrame: function browser_createContentWindowInFrame(
+                              aURI, aParams, aWhere, aFlags, aNextTabParentId,
+                              aName) {
+    // Passing a null-URI to only create the content window.
+    return this.getContentWindowOrOpenURIInFrame(null, aParams, aWhere, aFlags,
+                                                 aNextTabParentId, aName);
+  },
+
+  openURIInFrame: function browser_openURIInFrame(aURI, aParams, aWhere, aFlags,
+                                                  aNextTabParentId, aName) {
+    return this.getContentWindowOrOpenURIInFrame(aURI, aParams, aWhere, aFlags,
+                                                 aNextTabParentId, aName);
+  },
+
+  getContentWindowOrOpenURIInFrame: function browser_getContentWindowOrOpenURIInFrame(
+                                    aURI, aParams, aWhere, aFlags,
+                                    aNextTabParentId, aName) {
+    if (aWhere != Ci.nsIBrowserDOMWindow.OPEN_NEWTAB) {
+      dump("Error: openURIInFrame can only open in new tabs");
+      return null;
+    }
+
+    var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+
+    var userContextId = aParams.openerOriginAttributes &&
+                        ("userContextId" in aParams.openerOriginAttributes)
+                          ? aParams.openerOriginAttributes.userContextId
+                          : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+
+    let referrer = aParams.referrer ? makeURI(aParams.referrer) : null;
+    return this._openURIInNewTab(aURI, referrer,
+                                 aParams.referrerPolicy,
+                                 aParams.isPrivate,
+                                 isExternal, false,
+                                 userContextId, null, aParams.openerBrowser,
+                                 aParams.triggeringPrincipal,
+                                 aNextTabParentId, aName);
+  },
+
+  isTabContentWindow(aWindow) {
+    return gBrowser.browsers.some(browser => browser.contentWindow == aWindow);
+  },
+
+  canClose() {
+    return CanCloseWindow();
+  },
+};
+
+function getTogglableToolbars() {
+  let toolbarNodes = Array.slice(gNavToolbox.childNodes);
+  toolbarNodes = toolbarNodes.concat(gNavToolbox.externalToolbars);
+  toolbarNodes = toolbarNodes.filter(node => node.getAttribute("toolbarname"));
+  return toolbarNodes;
+}
+
+function onViewToolbarsPopupShowing(aEvent, aInsertPoint) {
+  var popup = aEvent.target;
+  if (popup != aEvent.currentTarget)
+    return;
+
+  // Empty the menu
+  for (var i = popup.childNodes.length - 1; i >= 0; --i) {
+    var deadItem = popup.childNodes[i];
+    if (deadItem.hasAttribute("toolbarId"))
+      popup.removeChild(deadItem);
+  }
+
+  var firstMenuItem = aInsertPoint || popup.firstChild;
+
+  let toolbarNodes = getTogglableToolbars();
+
+  for (let toolbar of toolbarNodes) {
+    let menuItem = document.createElement("menuitem");
+    let hidingAttribute = toolbar.getAttribute("type") == "menubar" ?
+                          "autohide" : "collapsed";
+    menuItem.setAttribute("id", "toggle_" + toolbar.id);
+    menuItem.setAttribute("toolbarId", toolbar.id);
+    menuItem.setAttribute("type", "checkbox");
+    menuItem.setAttribute("label", toolbar.getAttribute("toolbarname"));
+    menuItem.setAttribute("checked", toolbar.getAttribute(hidingAttribute) != "true");
+    menuItem.setAttribute("accesskey", toolbar.getAttribute("accesskey"));
+    if (popup.id != "toolbar-context-menu")
+      menuItem.setAttribute("key", toolbar.getAttribute("key"));
+
+    popup.insertBefore(menuItem, firstMenuItem);
+
+    menuItem.addEventListener("command", onViewToolbarCommand);
+  }
+
+
+  let moveToPanel = popup.querySelector(".customize-context-moveToPanel");
+  let removeFromToolbar = popup.querySelector(".customize-context-removeFromToolbar");
+  // View -> Toolbars menu doesn't have the moveToPanel or removeFromToolbar items.
+  if (!moveToPanel || !removeFromToolbar) {
+    return;
+  }
+
+  // triggerNode can be a nested child element of a toolbaritem.
+  let toolbarItem = popup.triggerNode;
+
+  if (toolbarItem && toolbarItem.localName == "toolbarpaletteitem") {
+    toolbarItem = toolbarItem.firstChild;
+  } else if (toolbarItem && toolbarItem.localName != "toolbar") {
+    while (toolbarItem && toolbarItem.parentNode) {
+      let parent = toolbarItem.parentNode;
+      if (parent.nodeType !== Node.ELEMENT_NODE ||
+          (parent.classList && parent.classList.contains("customization-target")) ||
+          parent.getAttribute("overflowfortoolbar") || // Needs to work in the overflow list as well.
+          parent.localName == "toolbarpaletteitem" ||
+          parent.localName == "toolbar")
+        break;
+      toolbarItem = parent;
+    }
+  } else {
+    toolbarItem = null;
+  }
+
+  let showTabStripItems = toolbarItem && toolbarItem.id == "tabbrowser-tabs";
+  for (let node of popup.querySelectorAll('menuitem[contexttype="toolbaritem"]')) {
+    node.hidden = showTabStripItems;
+  }
+
+  for (let node of popup.querySelectorAll('menuitem[contexttype="tabbar"]')) {
+    node.hidden = !showTabStripItems;
+  }
+
+  if (showTabStripItems) {
+    PlacesCommandHook.updateBookmarkAllTabsCommand();
+
+    let haveMultipleTabs = gBrowser.visibleTabs.length > 1;
+    document.getElementById("toolbar-context-reloadAllTabs").disabled = !haveMultipleTabs;
+
+    document.getElementById("toolbar-context-undoCloseTab").disabled =
+      SessionStore.getClosedTabCount(window) == 0;
+    return;
+  }
+
+  // In some cases, we will exit the above loop with toolbarItem being the
+  // xul:document. That has no parentNode, and we should disable the items in
+  // this case.
+  let movable = toolbarItem && toolbarItem.parentNode &&
+                CustomizableUI.isWidgetRemovable(toolbarItem);
+  let isSpecial = toolbarItem && CustomizableUI.isSpecialWidget(toolbarItem.id);
+  if (movable) {
+    if (isSpecial) {
+      moveToPanel.setAttribute("disabled", true);
+    } else {
+      moveToPanel.removeAttribute("disabled");
+    }
+    removeFromToolbar.removeAttribute("disabled");
+  } else {
+    moveToPanel.setAttribute("disabled", true);
+    removeFromToolbar.setAttribute("disabled", true);
+  }
+}
+
+function onViewToolbarCommand(aEvent) {
+  let node = aEvent.originalTarget;
+  let toolbarId = node.getAttribute("toolbarId");
+  let isVisible = node.getAttribute("checked") == "true";
+  CustomizableUI.setToolbarVisibility(toolbarId, isVisible);
+  updateToggleControlLabel(node);
+}
+
+function setToolbarVisibility(toolbar, isVisible, persist = true) {
+  let hidingAttribute;
+  if (toolbar.getAttribute("type") == "menubar") {
+    hidingAttribute = "autohide";
+    if (AppConstants.platform == "linux") {
+      Services.prefs.setBoolPref("ui.key.menuAccessKeyFocuses", !isVisible);
+    }
+  } else {
+    hidingAttribute = "collapsed";
+  }
+
+  toolbar.setAttribute(hidingAttribute, !isVisible);
+  if (persist) {
+    document.persist(toolbar.id, hidingAttribute);
+  }
+
+  let eventParams = {
+    detail: {
+      visible: isVisible
+    },
+    bubbles: true
+  };
+  let event = new CustomEvent("toolbarvisibilitychange", eventParams);
+  toolbar.dispatchEvent(event);
+
+  BookmarkingUI.onToolbarVisibilityChange();
+
+  if (toolbar.getAttribute("type") == "menubar" && CustomizationHandler.isCustomizing()) {
+    gCustomizeMode._updateDragSpaceCheckbox();
+  }
+}
+
+function updateToggleControlLabel(control) {
+  if (!control.hasAttribute("label-checked")) {
+    return;
+  }
+
+  if (!control.hasAttribute("label-unchecked")) {
+    control.setAttribute("label-unchecked", control.getAttribute("label"));
+  }
+  let prefix = (control.getAttribute("checked") == "true") ? "" : "un";
+  control.setAttribute("label", control.getAttribute(`label-${prefix}checked`));
+}
+
+var TabletModeUpdater = {
+  init() {
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+      this.update(WindowsUIUtils.inTabletMode);
+      Services.obs.addObserver(this, "tablet-mode-change");
+    }
+  },
+
+  uninit() {
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+      Services.obs.removeObserver(this, "tablet-mode-change");
+    }
+  },
+
+  observe(subject, topic, data) {
+    this.update(data == "tablet-mode");
+  },
+
+  update(isInTabletMode) {
+    let wasInTabletMode = document.documentElement.hasAttribute("tabletmode");
+    if (isInTabletMode) {
+      document.documentElement.setAttribute("tabletmode", "true");
+    } else {
+      document.documentElement.removeAttribute("tabletmode");
+    }
+    if (wasInTabletMode != isInTabletMode) {
+      gUIDensity.update();
+    }
+  },
+};
+
+var gTabletModePageCounter = {
+  enabled: false,
+  inc() {
+    this.enabled = AppConstants.isPlatformAndVersionAtLeast("win", "10.0");
+    if (!this.enabled) {
+      this.inc = () => {};
+      return;
+    }
+    this.inc = this._realInc;
+    this.inc();
+  },
+
+  _desktopCount: 0,
+  _tabletCount: 0,
+  _realInc() {
+    let inTabletMode = document.documentElement.hasAttribute("tabletmode");
+    this[inTabletMode ? "_tabletCount" : "_desktopCount"]++;
+  },
+
+  finish() {
+    if (this.enabled) {
+      let histogram = Services.telemetry.getKeyedHistogramById("FX_TABLETMODE_PAGE_LOAD");
+      histogram.add("tablet", this._tabletCount);
+      histogram.add("desktop", this._desktopCount);
+    }
+  },
+};
+
+function displaySecurityInfo() {
+  BrowserPageInfo(null, "securityTab");
+}
+
+// Adds additional drag space to the window by listening to
+// the corresponding preference.
+var gDragSpaceObserver = {
+  pref: "browser.tabs.extraDragSpace",
+
+  init() {
+    this.update();
+    Services.prefs.addObserver(this.pref, this);
+  },
+
+  uninit() {
+    Services.prefs.removeObserver(this.pref, this);
+  },
+
+  observe(aSubject, aTopic, aPrefName) {
+    if (aTopic != "nsPref:changed" || aPrefName != this.pref) {
+      return;
+    }
+
+    this.update();
+  },
+
+  update() {
+    if (Services.prefs.getBoolPref(this.pref)) {
+      document.documentElement.setAttribute("extradragspace", "true");
+    } else {
+      document.documentElement.removeAttribute("extradragspace");
+    }
+    TabsInTitlebar.updateAppearance(true);
+  },
+};
+
+// Updates the UI density (for touch and compact mode) based on the uidensity pref.
+var gUIDensity = {
+  MODE_NORMAL: 0,
+  MODE_COMPACT: 1,
+  MODE_TOUCH: 2,
+  uiDensityPref: "browser.uidensity",
+  autoTouchModePref: "browser.touchmode.auto",
+
+  init() {
+    this.update();
+    Services.prefs.addObserver(this.uiDensityPref, this);
+    Services.prefs.addObserver(this.autoTouchModePref, this);
+  },
+
+  uninit() {
+    Services.prefs.removeObserver(this.uiDensityPref, this);
+    Services.prefs.removeObserver(this.autoTouchModePref, this);
+  },
+
+  observe(aSubject, aTopic, aPrefName) {
+    if (aTopic != "nsPref:changed" ||
+        (aPrefName != this.uiDensityPref &&
+         aPrefName != this.autoTouchModePref)) {
+      return;
+    }
+
+    this.update();
+  },
+
+  getCurrentDensity() {
+    // Automatically override the uidensity to touch in Windows tablet mode.
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10") &&
+        WindowsUIUtils.inTabletMode &&
+        Services.prefs.getBoolPref(this.autoTouchModePref)) {
+      return { mode: this.MODE_TOUCH, overridden: true };
+    }
+    return { mode: Services.prefs.getIntPref(this.uiDensityPref), overridden: false };
+  },
+
+  setCurrentMode(mode) {
+    Services.prefs.setIntPref(this.uiDensityPref, mode);
+  },
+
+  update(mode) {
+    if (mode == null) {
+      mode = this.getCurrentDensity().mode;
+    }
+
+    let docs = [
+      document.documentElement,
+      SidebarUI.browser.contentDocument.documentElement,
+    ];
+    for (let doc of docs) {
+      switch (mode) {
+      case this.MODE_COMPACT:
+        doc.setAttribute("uidensity", "compact");
+        break;
+      case this.MODE_TOUCH:
+        doc.setAttribute("uidensity", "touch");
+        break;
+      default:
+        doc.removeAttribute("uidensity");
+        break;
+      }
+    }
+    let tree = SidebarUI.browser.contentDocument.querySelector(".sidebar-placesTree");
+    if (tree) {
+      // Tree items don't update their styles without changing some property on the
+      // parent tree element, like background-color or border. See bug 1407399.
+      tree.style.border = "1px";
+      tree.style.border = "";
+    }
+
+    TabsInTitlebar.updateAppearance(true);
+    gBrowser.tabContainer.uiDensityChanged();
+  },
+};
+
+var gHomeButton = {
+  prefDomain: "browser.startup.homepage",
+  observe(aSubject, aTopic, aPrefName) {
+    if (aTopic != "nsPref:changed" || aPrefName != this.prefDomain)
+      return;
+
+    this.updateTooltip();
+  },
+
+  updateTooltip(homeButton) {
+    if (!homeButton)
+      homeButton = document.getElementById("home-button");
+    if (homeButton) {
+      var homePage = this.getHomePage();
+      homePage = homePage.replace(/\|/g, ", ");
+      if (["about:home", "about:newtab"].includes(homePage.toLowerCase()))
+        homeButton.setAttribute("tooltiptext", homeButton.getAttribute("aboutHomeOverrideTooltip"));
+      else
+        homeButton.setAttribute("tooltiptext", homePage);
+    }
+  },
+
+  getHomePage() {
+    var url;
+    try {
+      url = Services.prefs.getComplexValue(this.prefDomain,
+                                  Components.interfaces.nsIPrefLocalizedString).data;
+    } catch (e) {
+    }
+
+    // use this if we can't find the pref
+    if (!url) {
+      var configBundle = Services.strings
+                                 .createBundle("chrome://branding/locale/browserconfig.properties");
+      url = configBundle.GetStringFromName(this.prefDomain);
+    }
+
+    return url;
+  },
+};
+
+const nodeToTooltipMap = {
+  "bookmarks-menu-button": "bookmarksMenuButton.tooltip",
+  "context-reload": "reloadButton.tooltip",
+  "context-stop": "stopButton.tooltip",
+  "downloads-button": "downloads.tooltip",
+  "fullscreen-button": "fullscreenButton.tooltip",
+  "appMenu-fullscreen-button": "fullscreenButton.tooltip",
+  "new-window-button": "newWindowButton.tooltip",
+  "new-tab-button": "newTabButton.tooltip",
+  "tabs-newtab-button": "newTabButton.tooltip",
+  "reload-button": "reloadButton.tooltip",
+  "stop-button": "stopButton.tooltip",
+  "urlbar-zoom-button": "urlbar-zoom-button.tooltip",
+  "appMenu-cut-button": "cut-button.tooltip",
+  "appMenu-copy-button": "copy-button.tooltip",
+  "appMenu-paste-button": "paste-button.tooltip",
+  "appMenu-zoomEnlarge-button": "zoomEnlarge-button.tooltip",
+  "appMenu-zoomReset-button": "zoomReset-button.tooltip",
+  "appMenu-zoomReduce-button": "zoomReduce-button.tooltip",
+};
+const nodeToShortcutMap = {
+  "bookmarks-menu-button": "manBookmarkKb",
+  "context-reload": "key_reload",
+  "context-stop": "key_stop",
+  "downloads-button": "key_openDownloads",
+  "fullscreen-button": "key_fullScreen",
+  "appMenu-fullscreen-button": "key_fullScreen",
+  "new-window-button": "key_newNavigator",
+  "new-tab-button": "key_newNavigatorTab",
+  "tabs-newtab-button": "key_newNavigatorTab",
+  "reload-button": "key_reload",
+  "stop-button": "key_stop",
+  "urlbar-zoom-button": "key_fullZoomReset",
+  "appMenu-cut-button": "key_cut",
+  "appMenu-copy-button": "key_copy",
+  "appMenu-paste-button": "key_paste",
+  "appMenu-zoomEnlarge-button": "key_fullZoomEnlarge",
+  "appMenu-zoomReset-button": "key_fullZoomReset",
+  "appMenu-zoomReduce-button": "key_fullZoomReduce",
+};
+
+if (AppConstants.platform == "macosx") {
+  nodeToTooltipMap["print-button"] = "printButton.tooltip";
+  nodeToShortcutMap["print-button"] = "printKb";
+}
+
+const gDynamicTooltipCache = new Map();
+function UpdateDynamicShortcutTooltipText(aTooltip) {
+  let nodeId = aTooltip.triggerNode.id || aTooltip.triggerNode.getAttribute("anonid");
+  if (!gDynamicTooltipCache.has(nodeId) && nodeId in nodeToTooltipMap) {
+    let strId = nodeToTooltipMap[nodeId];
+    let args = [];
+    if (nodeId in nodeToShortcutMap) {
+      let shortcutId = nodeToShortcutMap[nodeId];
+      let shortcut = document.getElementById(shortcutId);
+      if (shortcut) {
+        args.push(ShortcutUtils.prettifyShortcut(shortcut));
+      }
+    }
+    gDynamicTooltipCache.set(nodeId, gNavigatorBundle.getFormattedString(strId, args));
+  }
+  aTooltip.setAttribute("label", gDynamicTooltipCache.get(nodeId));
+}
+
+var gWebPanelURI;
+function openWebPanel(title, uri) {
+  // Ensure that the web panels sidebar is open.
+  SidebarUI.show("viewWebPanelsSidebar");
+
+  // Set the title of the panel.
+  SidebarUI.title = title;
+
+  // Tell the Web Panels sidebar to load the bookmark.
+  if (SidebarUI.browser.docShell && SidebarUI.browser.contentDocument &&
+      SidebarUI.browser.contentDocument.getElementById("web-panels-browser")) {
+    SidebarUI.browser.contentWindow.loadWebPanel(uri);
+    if (gWebPanelURI) {
+      gWebPanelURI = "";
+      SidebarUI.browser.removeEventListener("load", asyncOpenWebPanel, true);
+    }
+  } else {
+    // The panel is still being constructed.  Attach an onload handler.
+    if (!gWebPanelURI) {
+      SidebarUI.browser.addEventListener("load", asyncOpenWebPanel, true);
+    }
+    gWebPanelURI = uri;
+  }
+}
+
+function asyncOpenWebPanel(event) {
+  if (gWebPanelURI && SidebarUI.browser.contentDocument &&
+      SidebarUI.browser.contentDocument.getElementById("web-panels-browser")) {
+    SidebarUI.browser.contentWindow.loadWebPanel(gWebPanelURI);
+    SidebarUI.setWebPageIcon(gWebPanelURI);
+  }
+  gWebPanelURI = "";
+  SidebarUI.browser.removeEventListener("load", asyncOpenWebPanel, true);
+}
+
+/*
+ * - [ Dependencies ] ---------------------------------------------------------
+ *  utilityOverlay.js:
+ *    - gatherTextUnder
+ */
+
+/**
+ * Extracts linkNode and href for the current click target.
+ *
+ * @param event
+ *        The click event.
+ * @return [href, linkNode].
+ *
+ * @note linkNode will be null if the click wasn't on an anchor
+ *       element (or XLink).
+ */
+function hrefAndLinkNodeForClickEvent(event) {
+  function isHTMLLink(aNode) {
+    // Be consistent with what nsContextMenu.js does.
+    return ((aNode instanceof HTMLAnchorElement && aNode.href) ||
+            (aNode instanceof HTMLAreaElement && aNode.href) ||
+            aNode instanceof HTMLLinkElement);
+  }
+
+  let node = event.target;
+  while (node && !isHTMLLink(node)) {
+    node = node.parentNode;
+  }
+
+  if (node)
+    return [node.href, node];
+
+  // If there is no linkNode, try simple XLink.
+  let href, baseURI;
+  node = event.target;
+  while (node && !href) {
+    if (node.nodeType == Node.ELEMENT_NODE &&
+        (node.localName == "a" ||
+         node.namespaceURI == "http://www.w3.org/1998/Math/MathML")) {
+      href = node.getAttribute("href") ||
+             node.getAttributeNS("http://www.w3.org/1999/xlink", "href");
+
+      if (href) {
+        baseURI = node.baseURI;
+        break;
+      }
+    }
+    node = node.parentNode;
+  }
+
+  // In case of XLink, we don't return the node we got href from since
+  // callers expect <a>-like elements.
+  return [href ? makeURLAbsolute(baseURI, href) : null, null];
+}
+
+/**
+ * Called whenever the user clicks in the content area.
+ *
+ * @param event
+ *        The click event.
+ * @param isPanelClick
+ *        Whether the event comes from a web panel.
+ * @note default event is prevented if the click is handled.
+ */
+function contentAreaClick(event, isPanelClick) {
+  if (!event.isTrusted || event.defaultPrevented || event.button == 2)
+    return;
+
+  let [href, linkNode] = hrefAndLinkNodeForClickEvent(event);
+  if (!href) {
+    // Not a link, handle middle mouse navigation.
+    if (event.button == 1 &&
+        Services.prefs.getBoolPref("middlemouse.contentLoadURL") &&
+        !Services.prefs.getBoolPref("general.autoScroll")) {
+      middleMousePaste(event);
+      event.preventDefault();
+    }
+    return;
+  }
+
+  // This code only applies if we have a linkNode (i.e. clicks on real anchor
+  // elements, as opposed to XLink).
+  if (linkNode && event.button == 0 &&
+      !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey) {
+    // A Web panel's links should target the main content area.  Do this
+    // if no modifier keys are down and if there's no target or the target
+    // equals _main (the IE convention) or _content (the Mozilla convention).
+    let target = linkNode.target;
+    let mainTarget = !target || target == "_content" || target == "_main";
+    if (isPanelClick && mainTarget) {
+      // javascript and data links should be executed in the current browser.
+      if (linkNode.getAttribute("onclick") ||
+          href.startsWith("javascript:") ||
+          href.startsWith("data:"))
+        return;
+
+      try {
+        urlSecurityCheck(href, linkNode.ownerDocument.nodePrincipal);
+      } catch (ex) {
+        // Prevent loading unsecure destinations.
+        event.preventDefault();
+        return;
+      }
+
+      loadURI(href, null, null, false);
+      event.preventDefault();
+      return;
+    }
+
+    if (linkNode.getAttribute("rel") == "sidebar") {
+      // This is the Opera convention for a special link that, when clicked,
+      // allows to add a sidebar panel.  The link's title attribute contains
+      // the title that should be used for the sidebar panel.
+      PlacesUIUtils.showBookmarkDialog({ action: "add",
+                                         type: "bookmark",
+                                         uri: makeURI(href),
+                                         title: linkNode.getAttribute("title"),
+                                         loadBookmarkInSidebar: true,
+                                         hiddenRows: [ "description",
+                                                       "location",
+                                                       "keyword" ]
+                                       }, window);
+      event.preventDefault();
+      return;
+    }
+  }
+
+  handleLinkClick(event, href, linkNode);
+
+  // Mark the page as a user followed link.  This is done so that history can
+  // distinguish automatic embed visits from user activated ones.  For example
+  // pages loaded in frames are embed visits and lost with the session, while
+  // visits across frames should be preserved.
+  try {
+    if (!PrivateBrowsingUtils.isWindowPrivate(window))
+      PlacesUIUtils.markPageAsFollowedLink(href);
+  } catch (ex) { /* Skip invalid URIs. */ }
+}
+
+/**
+ * Handles clicks on links.
+ *
+ * @return true if the click event was handled, false otherwise.
+ */
+function handleLinkClick(event, href, linkNode) {
+  if (event.button == 2) // right click
+    return false;
+
+  var where = whereToOpenLink(event);
+  if (where == "current")
+    return false;
+
+  var doc = event.target.ownerDocument;
+
+  if (where == "save") {
+    saveURL(href, linkNode ? gatherTextUnder(linkNode) : "", null, true,
+            true, doc.documentURIObject, doc);
+    event.preventDefault();
+    return true;
+  }
+
+  var referrerURI = doc.documentURIObject;
+  // if the mixedContentChannel is present and the referring URI passes
+  // a same origin check with the target URI, we can preserve the users
+  // decision of disabling MCB on a page for it's child tabs.
+  var persistAllowMixedContentInChildTab = false;
+
+  if (where == "tab" && gBrowser.docShell.mixedContentChannel) {
+    const sm = Services.scriptSecurityManager;
+    try {
+      var targetURI = makeURI(href);
+      sm.checkSameOriginURI(referrerURI, targetURI, false);
+      persistAllowMixedContentInChildTab = true;
+    } catch (e) { }
+  }
+
+  // first get document wide referrer policy, then
+  // get referrer attribute from clicked link and parse it and
+  // allow per element referrer to overrule the document wide referrer if enabled
+  let referrerPolicy = doc.referrerPolicy;
+  if (linkNode) {
+    let referrerAttrValue = Services.netUtils.parseAttributePolicyString(linkNode.
+                            getAttribute("referrerpolicy"));
+    if (referrerAttrValue != Ci.nsIHttpChannel.REFERRER_POLICY_UNSET) {
+      referrerPolicy = referrerAttrValue;
+    }
+  }
+
+  let frameOuterWindowID = WebNavigationFrames.getFrameId(doc.defaultView);
+
+  urlSecurityCheck(href, doc.nodePrincipal);
+  let params = {
+    charset: doc.characterSet,
+    allowMixedContent: persistAllowMixedContentInChildTab,
+    referrerURI,
+    referrerPolicy,
+    noReferrer: BrowserUtils.linkHasNoReferrer(linkNode),
+    originPrincipal: doc.nodePrincipal,
+    triggeringPrincipal: doc.nodePrincipal,
+    frameOuterWindowID,
+  };
+
+  // The new tab/window must use the same userContextId
+  if (doc.nodePrincipal.originAttributes.userContextId) {
+    params.userContextId = doc.nodePrincipal.originAttributes.userContextId;
+  }
+
+  openLinkIn(href, where, params);
+  event.preventDefault();
+  return true;
+}
+
+function middleMousePaste(event) {
+  let clipboard = readFromClipboard();
+  if (!clipboard)
+    return;
+
+  // Strip embedded newlines and surrounding whitespace, to match the URL
+  // bar's behavior (stripsurroundingwhitespace)
+  clipboard = clipboard.replace(/\s*\n\s*/g, "");
+
+  clipboard = stripUnsafeProtocolOnPaste(clipboard);
+
+  // if it's not the current tab, we don't need to do anything because the
+  // browser doesn't exist.
+  let where = whereToOpenLink(event, true, false);
+  let lastLocationChange;
+  if (where == "current") {
+    lastLocationChange = gBrowser.selectedBrowser.lastLocationChange;
+  }
+
+  getShortcutOrURIAndPostData(clipboard).then(data => {
+    try {
+      makeURI(data.url);
+    } catch (ex) {
+      // Not a valid URI.
+      return;
+    }
+
+    try {
+      addToUrlbarHistory(data.url);
+    } catch (ex) {
+      // Things may go wrong when adding url to session history,
+      // but don't let that interfere with the loading of the url.
+      Cu.reportError(ex);
+    }
+
+    if (where != "current" ||
+        lastLocationChange == gBrowser.selectedBrowser.lastLocationChange) {
+      openUILink(data.url, event,
+                 { ignoreButton: true,
+                   disallowInheritPrincipal: !data.mayInheritPrincipal });
+    }
+  });
+
+  event.stopPropagation();
+}
+
+function stripUnsafeProtocolOnPaste(pasteData) {
+  // Don't allow pasting javascript URIs since we don't support
+  // LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL for those.
+  while (true) {
+    let scheme = "";
+    try {
+      scheme = Services.io.extractScheme(pasteData);
+    } catch (ex) { }
+    if (scheme != "javascript") {
+      break;
+    }
+
+    pasteData = pasteData.substring(pasteData.indexOf(":") + 1);
+  }
+  return pasteData;
+}
+
+// handleDroppedLink has the following 2 overloads:
+//   handleDroppedLink(event, url, name, triggeringPrincipal)
+//   handleDroppedLink(event, links, triggeringPrincipal)
+function handleDroppedLink(event, urlOrLinks, nameOrTriggeringPrincipal, triggeringPrincipal) {
+  let links;
+  if (Array.isArray(urlOrLinks)) {
+    links = urlOrLinks;
+    triggeringPrincipal = nameOrTriggeringPrincipal;
+  } else {
+    links = [{ url: urlOrLinks, nameOrTriggeringPrincipal, type: "" }];
+  }
+
+  let lastLocationChange = gBrowser.selectedBrowser.lastLocationChange;
+
+  let userContextId = gBrowser.selectedBrowser.getAttribute("usercontextid");
+
+  // event is null if links are dropped in content process.
+  // inBackground should be false, as it's loading into current browser.
+  let inBackground = false;
+  if (event) {
+    inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
+    if (event.shiftKey)
+      inBackground = !inBackground;
+  }
+
+  (async function() {
+    let urls = [];
+    let postDatas = [];
+    for (let link of links) {
+      let data = await getShortcutOrURIAndPostData(link.url);
+      urls.push(data.url);
+      postDatas.push(data.postData);
+    }
+    if (lastLocationChange == gBrowser.selectedBrowser.lastLocationChange) {
+      gBrowser.loadTabs(urls, {
+        inBackground,
+        replace: true,
+        allowThirdPartyFixup: false,
+        postDatas,
+        userContextId,
+        triggeringPrincipal,
+      });
+    }
+  })();
+
+  // If links are dropped in content process, event.preventDefault() should be
+  // called in content process.
+  if (event) {
+    // Keep the event from being handled by the dragDrop listeners
+    // built-in to gecko if they happen to be above us.
+    event.preventDefault();
+  }
+}
+
+function BrowserSetForcedCharacterSet(aCharset) {
+  if (aCharset) {
+    gBrowser.selectedBrowser.characterSet = aCharset;
+    // Save the forced character-set
+    if (!PrivateBrowsingUtils.isWindowPrivate(window))
+      PlacesUtils.setCharsetForURI(getWebNavigation().currentURI, aCharset);
+  }
+  BrowserCharsetReload();
+}
+
+function BrowserCharsetReload() {
+  BrowserReloadWithFlags(nsIWebNavigation.LOAD_FLAGS_CHARSET_CHANGE);
+}
+
+function UpdateCurrentCharset(target) {
+  let selectedCharset = CharsetMenu.foldCharset(gBrowser.selectedBrowser.characterSet);
+  for (let menuItem of target.getElementsByTagName("menuitem")) {
+    let isSelected = menuItem.getAttribute("charset") === selectedCharset;
+    menuItem.setAttribute("checked", isSelected);
+  }
+}
+
+var gPageStyleMenu = {
+  // This maps from a <browser> element (or, more specifically, a
+  // browser's permanentKey) to an Object that contains the most recent
+  // information about the browser content's stylesheets. That Object
+  // is populated via the PageStyle:StyleSheets message from the content
+  // process. The Object should have the following structure:
+  //
+  // filteredStyleSheets (Array):
+  //   An Array of objects with a filtered list representing all stylesheets
+  //   that the current page offers. Each object has the following members:
+  //
+  //   title (String):
+  //     The title of the stylesheet
+  //
+  //   disabled (bool):
+  //     Whether or not the stylesheet is currently applied
+  //
+  //   href (String):
+  //     The URL of the stylesheet. Stylesheets loaded via a data URL will
+  //     have this property set to null.
+  //
+  // authorStyleDisabled (bool):
+  //   Whether or not the user currently has "No Style" selected for
+  //   the current page.
+  //
+  // preferredStyleSheetSet (bool):
+  //   Whether or not the user currently has the "Default" style selected
+  //   for the current page.
+  //
+  _pageStyleSheets: new WeakMap(),
+
+  init() {
+    let mm = window.messageManager;
+    mm.addMessageListener("PageStyle:StyleSheets", (msg) => {
+      this._pageStyleSheets.set(msg.target.permanentKey, msg.data);
+    });
+  },
+
+  /**
+   * Returns an array of Objects representing stylesheets in a
+   * browser. Note that the pageshow event needs to fire in content
+   * before this information will be available.
+   *
+   * @param browser (optional)
+   *        The <xul:browser> to search for stylesheets. If omitted, this
+   *        defaults to the currently selected tab's browser.
+   * @returns Array
+   *        An Array of Objects representing stylesheets in the browser.
+   *        See the documentation for gPageStyleMenu for a description
+   *        of the Object structure.
+   */
+  getBrowserStyleSheets(browser) {
+    if (!browser) {
+      browser = gBrowser.selectedBrowser;
+    }
+
+    let data = this._pageStyleSheets.get(browser.permanentKey);
+    if (!data) {
+      return [];
+    }
+    return data.filteredStyleSheets;
+  },
+
+  _getStyleSheetInfo(browser) {
+    let data = this._pageStyleSheets.get(browser.permanentKey);
+    if (!data) {
+      return {
+        filteredStyleSheets: [],
+        authorStyleDisabled: false,
+        preferredStyleSheetSet: true
+      };
+    }
+
+    return data;
+  },
+
+  fillPopup(menuPopup) {
+    let styleSheetInfo = this._getStyleSheetInfo(gBrowser.selectedBrowser);
+    var noStyle = menuPopup.firstChild;
+    var persistentOnly = noStyle.nextSibling;
+    var sep = persistentOnly.nextSibling;
+    while (sep.nextSibling)
+      menuPopup.removeChild(sep.nextSibling);
+
+    let styleSheets = styleSheetInfo.filteredStyleSheets;
+    var currentStyleSheets = {};
+    var styleDisabled = styleSheetInfo.authorStyleDisabled;
+    var haveAltSheets = false;
+    var altStyleSelected = false;
+
+    for (let currentStyleSheet of styleSheets) {
+      if (!currentStyleSheet.disabled)
+        altStyleSelected = true;
+
+      haveAltSheets = true;
+
+      let lastWithSameTitle = null;
+      if (currentStyleSheet.title in currentStyleSheets)
+        lastWithSameTitle = currentStyleSheets[currentStyleSheet.title];
+
+      if (!lastWithSameTitle) {
+        let menuItem = document.createElement("menuitem");
+        menuItem.setAttribute("type", "radio");
+        menuItem.setAttribute("label", currentStyleSheet.title);
+        menuItem.setAttribute("data", currentStyleSheet.title);
+        menuItem.setAttribute("checked", !currentStyleSheet.disabled && !styleDisabled);
+        menuItem.setAttribute("oncommand", "gPageStyleMenu.switchStyleSheet(this.getAttribute('data'));");
+        menuPopup.appendChild(menuItem);
+        currentStyleSheets[currentStyleSheet.title] = menuItem;
+      } else if (currentStyleSheet.disabled) {
+        lastWithSameTitle.removeAttribute("checked");
+      }
+    }
+
+    noStyle.setAttribute("checked", styleDisabled);
+    persistentOnly.setAttribute("checked", !altStyleSelected && !styleDisabled);
+    persistentOnly.hidden = styleSheetInfo.preferredStyleSheetSet ? haveAltSheets : false;
+    sep.hidden = (noStyle.hidden && persistentOnly.hidden) || !haveAltSheets;
+  },
+
+  switchStyleSheet(title) {
+    let mm = gBrowser.selectedBrowser.messageManager;
+    mm.sendAsyncMessage("PageStyle:Switch", {title});
+  },
+
+  disableStyle() {
+    let mm = gBrowser.selectedBrowser.messageManager;
+    mm.sendAsyncMessage("PageStyle:Disable");
+  },
+};
+
+var LanguageDetectionListener = {
+  init() {
+    window.messageManager.addMessageListener("Translation:DocumentState", msg => {
+      Translation.documentStateReceived(msg.target, msg.data);
+    });
+  }
+};
+
+
+var BrowserOffline = {
+  _inited: false,
+
+  // BrowserOffline Public Methods
+  init() {
+    if (!this._uiElement)
+      this._uiElement = document.getElementById("workOfflineMenuitemState");
+
+    Services.obs.addObserver(this, "network:offline-status-changed");
+
+    this._updateOfflineUI(Services.io.offline);
+
+    this._inited = true;
+  },
+
+  uninit() {
+    if (this._inited) {
+      Services.obs.removeObserver(this, "network:offline-status-changed");
+    }
+  },
+
+  toggleOfflineStatus() {
+    var ioService = Services.io;
+
+    if (!ioService.offline && !this._canGoOffline()) {
+      this._updateOfflineUI(false);
+      return;
+    }
+
+    ioService.offline = !ioService.offline;
+  },
+
+  // nsIObserver
+  observe(aSubject, aTopic, aState) {
+    if (aTopic != "network:offline-status-changed")
+      return;
+
+    // This notification is also received because of a loss in connectivity,
+    // which we ignore by updating the UI to the current value of io.offline
+    this._updateOfflineUI(Services.io.offline);
+  },
+
+  // BrowserOffline Implementation Methods
+  _canGoOffline() {
+    try {
+      var cancelGoOffline = Cc["@mozilla.org/supports-PRBool;1"].createInstance(Ci.nsISupportsPRBool);
+      Services.obs.notifyObservers(cancelGoOffline, "offline-requested");
+
+      // Something aborted the quit process.
+      if (cancelGoOffline.data)
+        return false;
+    } catch (ex) {
+    }
+
+    return true;
+  },
+
+  _uiElement: null,
+  _updateOfflineUI(aOffline) {
+    var offlineLocked = Services.prefs.prefIsLocked("network.online");
+    if (offlineLocked)
+      this._uiElement.setAttribute("disabled", "true");
+
+    this._uiElement.setAttribute("checked", aOffline);
+  }
+};
+
+var OfflineApps = {
+  warnUsage(browser, uri) {
+    if (!browser)
+      return;
+
+    let mainAction = {
+      label: gNavigatorBundle.getString("offlineApps.manageUsage"),
+      accessKey: gNavigatorBundle.getString("offlineApps.manageUsageAccessKey"),
+      callback: this.manage
+    };
+
+    let warnQuotaKB = Services.prefs.getIntPref("offline-apps.quota.warn");
+    // This message shows the quota in MB, and so we divide the quota (in kb) by 1024.
+    let message = gNavigatorBundle.getFormattedString("offlineApps.usage",
+                                                      [ uri.host,
+                                                        warnQuotaKB / 1024 ]);
+
+    let anchorID = "indexedDB-notification-icon";
+    let options = {
+      persistent: true,
+      hideClose: true,
+    };
+    PopupNotifications.show(browser, "offline-app-usage", message,
+                            anchorID, mainAction, null, options);
+
+    // Now that we've warned once, prevent the warning from showing up
+    // again.
+    Services.perms.add(uri, "offline-app",
+                       Ci.nsIOfflineCacheUpdateService.ALLOW_NO_WARN);
+  },
+
+  // XXX: duplicated in preferences/advanced.js
+  _getOfflineAppUsage(host, groups) {
+    let cacheService = Cc["@mozilla.org/network/application-cache-service;1"].
+                       getService(Ci.nsIApplicationCacheService);
+    if (!groups) {
+      try {
+        groups = cacheService.getGroups();
+      } catch (ex) {
+        return 0;
+      }
+    }
+
+    let usage = 0;
+    for (let group of groups) {
+      let uri = Services.io.newURI(group);
+      if (uri.asciiHost == host) {
+        let cache = cacheService.getActiveCache(group);
+        usage += cache.usage;
+      }
+    }
+
+    return usage;
+  },
+
+  _usedMoreThanWarnQuota(uri) {
+    // if the user has already allowed excessive usage, don't bother checking
+    if (Services.perms.testExactPermission(uri, "offline-app") !=
+        Ci.nsIOfflineCacheUpdateService.ALLOW_NO_WARN) {
+      let usageBytes = this._getOfflineAppUsage(uri.asciiHost);
+      let warnQuotaKB = Services.prefs.getIntPref("offline-apps.quota.warn");
+      // The pref is in kb, the usage we get is in bytes, so multiply the quota
+      // to compare correctly:
+      if (usageBytes >= warnQuotaKB * 1024) {
+        return true;
+      }
+    }
+
+    return false;
+  },
+
+  requestPermission(browser, docId, uri) {
+    let host = uri.asciiHost;
+    let notificationID = "offline-app-requested-" + host;
+    let notification = PopupNotifications.getNotification(notificationID, browser);
+
+    if (notification) {
+      notification.options.controlledItems.push([
+        Cu.getWeakReference(browser), docId, uri
+      ]);
+    } else {
+      let mainAction = {
+        label: gNavigatorBundle.getString("offlineApps.allowStoring.label"),
+        accessKey: gNavigatorBundle.getString("offlineApps.allowStoring.accesskey"),
+        callback() {
+          for (let [ciBrowser, ciDocId, ciUri] of notification.options.controlledItems) {
+            OfflineApps.allowSite(ciBrowser, ciDocId, ciUri);
+          }
+        }
+      };
+      let secondaryActions = [{
+        label: gNavigatorBundle.getString("offlineApps.dontAllow.label"),
+        accessKey: gNavigatorBundle.getString("offlineApps.dontAllow.accesskey"),
+        callback() {
+          for (let [, , ciUri] of notification.options.controlledItems) {
+            OfflineApps.disallowSite(ciUri);
+          }
+        }
+      }];
+      let message = gNavigatorBundle.getFormattedString("offlineApps.available2",
+                                                        [host]);
+      let anchorID = "indexedDB-notification-icon";
+      let options = {
+        persistent: true,
+        hideClose: true,
+        controlledItems: [[Cu.getWeakReference(browser), docId, uri]]
+      };
+      notification = PopupNotifications.show(browser, notificationID, message,
+                                             anchorID, mainAction,
+                                             secondaryActions, options);
+    }
+  },
+
+  disallowSite(uri) {
+    Services.perms.add(uri, "offline-app", Services.perms.DENY_ACTION);
+  },
+
+  allowSite(browserRef, docId, uri) {
+    Services.perms.add(uri, "offline-app", Services.perms.ALLOW_ACTION);
+
+    // When a site is enabled while loading, manifest resources will
+    // start fetching immediately.  This one time we need to do it
+    // ourselves.
+    let browser = browserRef.get();
+    if (browser && browser.messageManager) {
+      browser.messageManager.sendAsyncMessage("OfflineApps:StartFetching", {
+        docId,
+      });
+    }
+  },
+
+  manage() {
+    openPreferences("panePrivacy", { origin: "offlineApps" });
+  },
+
+  receiveMessage(msg) {
+    switch (msg.name) {
+      case "OfflineApps:CheckUsage":
+        let uri = makeURI(msg.data.uri);
+        if (this._usedMoreThanWarnQuota(uri)) {
+          this.warnUsage(msg.target, uri);
+        }
+        break;
+      case "OfflineApps:RequestPermission":
+        this.requestPermission(msg.target, msg.data.docId, makeURI(msg.data.uri));
+        break;
+    }
+  },
+
+  init() {
+    let mm = window.messageManager;
+    mm.addMessageListener("OfflineApps:CheckUsage", this);
+    mm.addMessageListener("OfflineApps:RequestPermission", this);
+  },
+};
+
+var IndexedDBPromptHelper = {
+  _permissionsPrompt: "indexedDB-permissions-prompt",
+  _permissionsResponse: "indexedDB-permissions-response",
+
+  _notificationIcon: "indexedDB-notification-icon",
+
+  init:
+  function IndexedDBPromptHelper_init() {
+    Services.obs.addObserver(this, this._permissionsPrompt);
+  },
+
+  uninit:
+  function IndexedDBPromptHelper_uninit() {
+    Services.obs.removeObserver(this, this._permissionsPrompt);
+  },
+
+  observe:
+  function IndexedDBPromptHelper_observe(subject, topic, data) {
+    if (topic != this._permissionsPrompt) {
+      throw new Error("Unexpected topic!");
+    }
+
+    var requestor = subject.QueryInterface(Ci.nsIInterfaceRequestor);
+
+    var browser = requestor.getInterface(Ci.nsIDOMNode);
+    if (browser.ownerGlobal != window) {
+      // Only listen for notifications for browsers in our chrome window.
+      return;
+    }
+
+    // Get the host name if available or the file path otherwise.
+    var host = browser.currentURI.asciiHost || browser.currentURI.pathQueryRef;
+
+    var message;
+    var responseTopic;
+    if (topic == this._permissionsPrompt) {
+      message = gNavigatorBundle.getFormattedString("offlineApps.available2",
+                                                    [ host ]);
+      responseTopic = this._permissionsResponse;
+    }
+
+    var observer = requestor.getInterface(Ci.nsIObserver);
+
+    var mainAction = {
+      label: gNavigatorBundle.getString("offlineApps.allowStoring.label"),
+      accessKey: gNavigatorBundle.getString("offlineApps.allowStoring.accesskey"),
+      callback() {
+        observer.observe(null, responseTopic,
+                         Ci.nsIPermissionManager.ALLOW_ACTION);
+      }
+    };
+
+    var secondaryActions = [
+      {
+        label: gNavigatorBundle.getString("offlineApps.dontAllow.label"),
+        accessKey: gNavigatorBundle.getString("offlineApps.dontAllow.accesskey"),
+        callback() {
+          observer.observe(null, responseTopic,
+                           Ci.nsIPermissionManager.DENY_ACTION);
+        }
+      }
+    ];
+
+    PopupNotifications.show(
+      browser, topic, message, this._notificationIcon, mainAction, secondaryActions,
+      {
+        persistent: true,
+        hideClose: !Services.prefs.getBoolPref("privacy.permissionPrompts.showCloseButton"),
+      });
+  }
+};
+
+var CanvasPermissionPromptHelper = {
+  _permissionsPrompt: "canvas-permissions-prompt",
+  _notificationIcon: "canvas-notification-icon",
+
+  init() {
+    Services.obs.addObserver(this, this._permissionsPrompt);
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, this._permissionsPrompt);
+  },
+
+  // aSubject is an nsIBrowser (e10s) or an nsIDOMWindow (non-e10s).
+  // aData is an URL string.
+  observe(aSubject, aTopic, aData) {
+    if (aTopic != this._permissionsPrompt) {
+      return;
+    }
+
+    let browser;
+    if (aSubject instanceof Ci.nsIDOMWindow) {
+      let contentWindow = aSubject.QueryInterface(Ci.nsIDOMWindow);
+      browser = gBrowser.getBrowserForContentWindow(contentWindow);
+    } else {
+      browser = aSubject.QueryInterface(Ci.nsIBrowser);
+    }
+
+    let uri = Services.io.newURI(aData);
+    if (gBrowser.selectedBrowser !== browser) {
+      // Must belong to some other window.
+      return;
+    }
+
+    let message = gNavigatorBundle.getFormattedString("canvas.siteprompt", [ uri.asciiHost ]);
+
+    function setCanvasPermission(aURI, aPerm, aPersistent) {
+      Services.perms.add(aURI, "canvas", aPerm,
+                          aPersistent ? Ci.nsIPermissionManager.EXPIRE_NEVER
+                                      : Ci.nsIPermissionManager.EXPIRE_SESSION);
+    }
+
+    let mainAction = {
+      label: gNavigatorBundle.getString("canvas.allow"),
+      accessKey: gNavigatorBundle.getString("canvas.allow.accesskey"),
+      callback(state) {
+        setCanvasPermission(uri, Ci.nsIPermissionManager.ALLOW_ACTION,
+                            state && state.checkboxChecked);
+      }
+    };
+
+    let secondaryActions = [{
+      label: gNavigatorBundle.getString("canvas.notAllow"),
+      accessKey: gNavigatorBundle.getString("canvas.notAllow.accesskey"),
+      callback(state) {
+        setCanvasPermission(uri, Ci.nsIPermissionManager.DENY_ACTION,
+                            state && state.checkboxChecked);
+      }
+    }];
+
+    let checkbox = {
+      // In PB mode, we don't want the "always remember" checkbox
+      show: !PrivateBrowsingUtils.isWindowPrivate(window)
+    };
+    if (checkbox.show) {
+      checkbox.checked = true;
+      checkbox.label = gBrowserBundle.GetStringFromName("canvas.remember");
+    }
+
+    let options = {
+      checkbox
+    };
+    PopupNotifications.show(browser, aTopic, message, this._notificationIcon,
+                            mainAction, secondaryActions, options);
+  }
+};
+
+function CanCloseWindow() {
+  // Avoid redundant calls to canClose from showing multiple
+  // PermitUnload dialogs.
+  if (Services.startup.shuttingDown || window.skipNextCanClose) {
+    return true;
+  }
+
+  let timedOutProcesses = new WeakSet();
+
+  for (let browser of gBrowser.browsers) {
+    // Don't instantiate lazy browsers.
+    if (!browser.isConnected) {
+      continue;
+    }
+
+    let pmm = browser.messageManager.processMessageManager;
+
+    if (timedOutProcesses.has(pmm)) {
+      continue;
+    }
+
+    let {permitUnload, timedOut} = browser.permitUnload();
+
+    if (timedOut) {
+      timedOutProcesses.add(pmm);
+      continue;
+    }
+
+    if (!permitUnload) {
+      return false;
+    }
+  }
+  return true;
+}
+
+function WindowIsClosing() {
+  if (!closeWindow(false, warnAboutClosingWindow))
+    return false;
+
+  // In theory we should exit here and the Window's internal Close
+  // method should trigger canClose on nsBrowserAccess. However, by
+  // that point it's too late to be able to show a prompt for
+  // PermitUnload. So we do it here, when we still can.
+  if (CanCloseWindow()) {
+    // This flag ensures that the later canClose call does nothing.
+    // It's only needed to make tests pass, since they detect the
+    // prompt even when it's not actually shown.
+    window.skipNextCanClose = true;
+    return true;
+  }
+
+  return false;
+}
+
+/**
+ * Checks if this is the last full *browser* window around. If it is, this will
+ * be communicated like quitting. Otherwise, we warn about closing multiple tabs.
+ * @returns true if closing can proceed, false if it got cancelled.
+ */
+function warnAboutClosingWindow() {
+  // Popups aren't considered full browser windows; we also ignore private windows.
+  let isPBWindow = PrivateBrowsingUtils.isWindowPrivate(window) &&
+        !PrivateBrowsingUtils.permanentPrivateBrowsing;
+  if (!isPBWindow && !toolbar.visible)
+    return gBrowser.warnAboutClosingTabs(gBrowser.closingTabsEnum.ALL);
+
+  // Figure out if there's at least one other browser window around.
+  let otherPBWindowExists = false;
+  let nonPopupPresent = false;
+  for (let win of browserWindows()) {
+    if (!win.closed && win != window) {
+      if (isPBWindow && PrivateBrowsingUtils.isWindowPrivate(win))
+        otherPBWindowExists = true;
+      if (win.toolbar.visible)
+        nonPopupPresent = true;
+      // If the current window is not in private browsing mode we don't need to
+      // look for other pb windows, we can leave the loop when finding the
+      // first non-popup window. If however the current window is in private
+      // browsing mode then we need at least one other pb and one non-popup
+      // window to break out early.
+      if ((!isPBWindow || otherPBWindowExists) && nonPopupPresent)
+        break;
+    }
+  }
+
+  if (isPBWindow && !otherPBWindowExists) {
+    let exitingCanceled = Cc["@mozilla.org/supports-PRBool;1"].
+                          createInstance(Ci.nsISupportsPRBool);
+    exitingCanceled.data = false;
+    Services.obs.notifyObservers(exitingCanceled,
+                                 "last-pb-context-exiting");
+    if (exitingCanceled.data)
+      return false;
+  }
+
+  if (nonPopupPresent) {
+    return isPBWindow || gBrowser.warnAboutClosingTabs(gBrowser.closingTabsEnum.ALL);
+  }
+
+  let os = Services.obs;
+
+  let closingCanceled = Cc["@mozilla.org/supports-PRBool;1"].
+                        createInstance(Ci.nsISupportsPRBool);
+  os.notifyObservers(closingCanceled,
+                     "browser-lastwindow-close-requested");
+  if (closingCanceled.data)
+    return false;
+
+  os.notifyObservers(null, "browser-lastwindow-close-granted");
+
+  // OS X doesn't quit the application when the last window is closed, but keeps
+  // the session alive. Hence don't prompt users to save tabs, but warn about
+  // closing multiple tabs.
+  return AppConstants.platform != "macosx"
+         || (isPBWindow || gBrowser.warnAboutClosingTabs(gBrowser.closingTabsEnum.ALL));
+}
+
+var MailIntegration = {
+  sendLinkForBrowser(aBrowser) {
+    this.sendMessage(gURLBar.makeURIReadable(aBrowser.currentURI).displaySpec, aBrowser.contentTitle);
+  },
+
+  sendMessage(aBody, aSubject) {
+    // generate a mailto url based on the url and the url's title
+    var mailtoUrl = "mailto:";
+    if (aBody) {
+      mailtoUrl += "?body=" + encodeURIComponent(aBody);
+      mailtoUrl += "&subject=" + encodeURIComponent(aSubject);
+    }
+
+    var uri = makeURI(mailtoUrl);
+
+    // now pass this uri to the operating system
+    this._launchExternalUrl(uri);
+  },
+
+  // a generic method which can be used to pass arbitrary urls to the operating
+  // system.
+  // aURL --> a nsIURI which represents the url to launch
+  _launchExternalUrl(aURL) {
+    var extProtocolSvc =
+       Cc["@mozilla.org/uriloader/external-protocol-service;1"]
+         .getService(Ci.nsIExternalProtocolService);
+    if (extProtocolSvc)
+      extProtocolSvc.loadURI(aURL);
+  }
+};
+
+function BrowserOpenAddonsMgr(aView) {
+  return new Promise(resolve => {
+    let emWindow;
+    let browserWindow;
+
+    var receivePong = function(aSubject, aTopic, aData) {
+      let browserWin = aSubject.QueryInterface(Ci.nsIInterfaceRequestor)
+                               .getInterface(Ci.nsIWebNavigation)
+                               .QueryInterface(Ci.nsIDocShellTreeItem)
+                               .rootTreeItem
+                               .QueryInterface(Ci.nsIInterfaceRequestor)
+                               .getInterface(Ci.nsIDOMWindow);
+      if (!emWindow || browserWin == window /* favor the current window */) {
+        emWindow = aSubject;
+        browserWindow = browserWin;
+      }
+    };
+    Services.obs.addObserver(receivePong, "EM-pong");
+    Services.obs.notifyObservers(null, "EM-ping");
+    Services.obs.removeObserver(receivePong, "EM-pong");
+
+    if (emWindow) {
+      if (aView) {
+        emWindow.loadView(aView);
+      }
+      browserWindow.gBrowser.selectedTab =
+        browserWindow.gBrowser._getTabForContentWindow(emWindow);
+      emWindow.focus();
+      resolve(emWindow);
+      return;
+    }
+
+    // This must be a new load, else the ping/pong would have
+    // found the window above.
+    let whereToOpen = (window.gBrowser && isTabEmpty(gBrowser.selectedTab)) ?
+                      "current" :
+                      "tab";
+    openUILinkIn("about:addons", whereToOpen);
+
+    Services.obs.addObserver(function observer(aSubject, aTopic, aData) {
+      Services.obs.removeObserver(observer, aTopic);
+      if (aView) {
+        aSubject.loadView(aView);
+      }
+      aSubject.QueryInterface(Ci.nsIDOMWindow);
+      aSubject.focus();
+      resolve(aSubject);
+    }, "EM-loaded");
+  });
+}
+
+function AddKeywordForSearchField() {
+  let mm = gBrowser.selectedBrowser.messageManager;
+
+  let onMessage = (message) => {
+    mm.removeMessageListener("ContextMenu:SearchFieldBookmarkData:Result", onMessage);
+
+    let bookmarkData = message.data;
+    let title = gNavigatorBundle.getFormattedString("addKeywordTitleAutoFill",
+                                                    [bookmarkData.title]);
+    PlacesUIUtils.showBookmarkDialog({ action: "add",
+                                       type: "bookmark",
+                                       uri: makeURI(bookmarkData.spec),
+                                       title,
+                                       description: bookmarkData.description,
+                                       keyword: "",
+                                       postData: bookmarkData.postData,
+                                       charSet: bookmarkData.charset,
+                                       hiddenRows: [ "location",
+                                                     "description",
+                                                     "tags",
+                                                     "loadInSidebar" ]
+                                     }, window);
+  };
+  mm.addMessageListener("ContextMenu:SearchFieldBookmarkData:Result", onMessage);
+
+  mm.sendAsyncMessage("ContextMenu:SearchFieldBookmarkData", {}, { target: gContextMenu.target });
+}
+
+/**
+ * Re-open a closed tab.
+ * @param aIndex
+ *        The index of the tab (via SessionStore.getClosedTabData)
+ * @returns a reference to the reopened tab.
+ */
+function undoCloseTab(aIndex) {
+  // wallpaper patch to prevent an unnecessary blank tab (bug 343895)
+  var blankTabToRemove = null;
+  if (gBrowser.tabs.length == 1 && isTabEmpty(gBrowser.selectedTab))
+    blankTabToRemove = gBrowser.selectedTab;
+
+  var tab = null;
+  if (SessionStore.getClosedTabCount(window) > (aIndex || 0)) {
+    tab = SessionStore.undoCloseTab(window, aIndex || 0);
+
+    if (blankTabToRemove)
+      gBrowser.removeTab(blankTabToRemove);
+  }
+
+  return tab;
+}
+
+/**
+ * Re-open a closed window.
+ * @param aIndex
+ *        The index of the window (via SessionStore.getClosedWindowData)
+ * @returns a reference to the reopened window.
+ */
+function undoCloseWindow(aIndex) {
+  let window = null;
+  if (SessionStore.getClosedWindowCount() > (aIndex || 0))
+    window = SessionStore.undoCloseWindow(aIndex || 0);
+
+  return window;
+}
+
+/*
+ * Determines if a tab is "empty", usually used in the context of determining
+ * if it's ok to close the tab.
+ */
+function isTabEmpty(aTab) {
+  if (aTab.hasAttribute("busy"))
+    return false;
+
+  if (aTab.hasAttribute("customizemode"))
+    return false;
+
+  let browser = aTab.linkedBrowser;
+  if (!isBlankPageURL(browser.currentURI.spec))
+    return false;
+
+  if (!checkEmptyPageOrigin(browser))
+    return false;
+
+  if (browser.canGoForward || browser.canGoBack)
+    return false;
+
+  return true;
+}
+
+/**
+ * Check whether a page can be considered as 'empty', that its URI
+ * reflects its origin, and that if it's loaded in a tab, that tab
+ * could be considered 'empty' (e.g. like the result of opening
+ * a 'blank' new tab).
+ *
+ * We have to do more than just check the URI, because especially
+ * for things like about:blank, it is possible that the opener or
+ * some other page has control over the contents of the page.
+ *
+ * @param browser {Browser}
+ *        The browser whose page we're checking (the selected browser
+ *        in this window if omitted).
+ * @param uri {nsIURI}
+ *        The URI against which we're checking (the browser's currentURI
+ *        if omitted).
+ *
+ * @return false if the page was opened by or is controlled by arbitrary web
+ *         content, unless that content corresponds with the URI.
+ *         true if the page is blank and controlled by a principal matching
+ *         that URI (or the system principal if the principal has no URI)
+ */
+function checkEmptyPageOrigin(browser = gBrowser.selectedBrowser,
+                              uri = browser.currentURI) {
+  // If another page opened this page with e.g. window.open, this page might
+  // be controlled by its opener - return false.
+  if (browser.hasContentOpener) {
+    return false;
+  }
+  let contentPrincipal = browser.contentPrincipal;
+  // Not all principals have URIs...
+  if (contentPrincipal.URI) {
+    // There are two special-cases involving about:blank. One is where
+    // the user has manually loaded it and it got created with a null
+    // principal. The other involves the case where we load
+    // some other empty page in a browser and the current page is the
+    // initial about:blank page (which has that as its principal, not
+    // just URI in which case it could be web-based). Especially in
+    // e10s, we need to tackle that case specifically to avoid race
+    // conditions when updating the URL bar.
+    //
+    // Note that we check the documentURI here, since the currentURI on
+    // the browser might have been set by SessionStore in order to
+    // support switch-to-tab without having actually loaded the content
+    // yet.
+    let uriToCheck = browser.documentURI || uri;
+    if ((uriToCheck.spec == "about:blank" && contentPrincipal.isNullPrincipal) ||
+        contentPrincipal.URI.spec == "about:blank") {
+      return true;
+    }
+    return contentPrincipal.URI.equals(uri);
+  }
+  // ... so for those that don't have them, enforce that the page has the
+  // system principal (this matches e.g. on about:newtab).
+  let ssm = Services.scriptSecurityManager;
+  return ssm.isSystemPrincipal(contentPrincipal);
+}
+
+function BrowserOpenSyncTabs() {
+  gSync.openSyncedTabsPanel();
+}
+
+function ReportFalseDeceptiveSite() {
+  let docURI = gBrowser.selectedBrowser.documentURI;
+  let isPhishingPage =
+    docURI && docURI.spec.startsWith("about:blocked?e=deceptiveBlocked");
+
+  if (isPhishingPage) {
+    let mm = gBrowser.selectedBrowser.messageManager;
+    let onMessage = (message) => {
+      mm.removeMessageListener("DeceptiveBlockedDetails:Result", onMessage);
+      let reportUrl = gSafeBrowsing.getReportURL("PhishMistake", message.data.blockedInfo);
+      if (reportUrl) {
+        openUILinkIn(reportUrl, "tab");
+      } else {
+        let bundle =
+          Services.strings.createBundle("chrome://browser/locale/safebrowsing/safebrowsing.properties");
+        Services.prompt.alert(window,
+                              bundle.GetStringFromName("errorReportFalseDeceptiveTitle"),
+                              bundle.formatStringFromName("errorReportFalseDeceptiveMessage",
+                                                          [message.data.blockedInfo.provider], 1));
+        }
+    };
+    mm.addMessageListener("DeceptiveBlockedDetails:Result", onMessage);
+
+    mm.sendAsyncMessage("DeceptiveBlockedDetails");
+  }
+}
+
+/**
+ * Format a URL
+ * eg:
+ * echo formatURL("https://addons.mozilla.org/%LOCALE%/%APP%/%VERSION%/");
+ * > https://addons.mozilla.org/en-US/firefox/3.0a1/
+ *
+ * Currently supported built-ins are LOCALE, APP, and any value from nsIXULAppInfo, uppercased.
+ */
+function formatURL(aFormat, aIsPref) {
+  return aIsPref ? Services.urlFormatter.formatURLPref(aFormat) :
+                   Services.urlFormatter.formatURL(aFormat);
+}
+
+/**
+ * Utility object to handle manipulations of the identity indicators in the UI
+ */
+var gIdentityHandler = {
+  /**
+   * nsIURI for which the identity UI is displayed. This has been already
+   * processed by nsIURIFixup.createExposableURI.
+   */
+  _uri: null,
+
+  /**
+   * We only know the connection type if this._uri has a defined "host" part.
+   *
+   * These URIs, like "about:", "file:" and "data:" URIs, will usually be treated as a
+   * an unknown connection.
+   */
+  _uriHasHost: false,
+
+  /**
+   * If this tab belongs to a WebExtension, contains its WebExtensionPolicy.
+   */
+  _pageExtensionPolicy: null,
+
+  /**
+   * Whether this._uri refers to an internally implemented browser page.
+   *
+   * Note that this is set for some "about:" pages, but general "chrome:" URIs
+   * are not included in this category by default.
+   */
+  _isSecureInternalUI: false,
+
+  /**
+   * nsISSLStatus metadata provided by gBrowser.securityUI the last time the
+   * identity UI was updated, or null if the connection is not secure.
+   */
+  _sslStatus: null,
+
+  /**
+   * Bitmask provided by nsIWebProgressListener.onSecurityChange.
+   */
+  _state: 0,
+
+  /**
+   * This flag gets set if the identity popup was opened by a keypress,
+   * to be able to focus it on the popupshown event.
+   */
+  _popupTriggeredByKeyboard: false,
+
+  /**
+   * RegExp used to decide if an about url should be shown as being part of
+   * the browser UI.
+   */
+  _secureInternalUIWhitelist: /^(?:accounts|addons|cache|config|crashes|customizing|downloads|healthreport|license|newaddon|permissions|preferences|rights|searchreset|sessionrestore|support|welcomeback)(?:[?#]|$)/i,
+
+  get _isBroken() {
+    return this._state & Ci.nsIWebProgressListener.STATE_IS_BROKEN;
+  },
+
+  get _isSecure() {
+    // If a <browser> is included within a chrome document, then this._state
+    // will refer to the security state for the <browser> and not the top level
+    // document. In this case, don't upgrade the security state in the UI
+    // with the secure state of the embedded <browser>.
+    return !this._isURILoadedFromFile && this._state & Ci.nsIWebProgressListener.STATE_IS_SECURE;
+  },
+
+  get _isEV() {
+    // If a <browser> is included within a chrome document, then this._state
+    // will refer to the security state for the <browser> and not the top level
+    // document. In this case, don't upgrade the security state in the UI
+    // with the EV state of the embedded <browser>.
+    return !this._isURILoadedFromFile && this._state & Ci.nsIWebProgressListener.STATE_IDENTITY_EV_TOPLEVEL;
+  },
+
+  get _isMixedActiveContentLoaded() {
+    return this._state & Ci.nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT;
+  },
+
+  get _isMixedActiveContentBlocked() {
+    return this._state & Ci.nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT;
+  },
+
+  get _isMixedPassiveContentLoaded() {
+    return this._state & Ci.nsIWebProgressListener.STATE_LOADED_MIXED_DISPLAY_CONTENT;
+  },
+
+  get _isCertUserOverridden() {
+    return this._state & Ci.nsIWebProgressListener.STATE_CERT_USER_OVERRIDDEN;
+  },
+
+  get _isCertDistrustImminent() {
+    return this._state & Ci.nsIWebProgressListener.STATE_CERT_DISTRUST_IMMINENT;
+  },
+
+  get _hasInsecureLoginForms() {
+    // checks if the page has been flagged for an insecure login. Also checks
+    // if the pref to degrade the UI is set to true
+    return LoginManagerParent.hasInsecureLoginForms(gBrowser.selectedBrowser) &&
+           Services.prefs.getBoolPref("security.insecure_password.ui.enabled");
+  },
+
+  // smart getters
+  get _identityPopup() {
+    delete this._identityPopup;
+    return this._identityPopup = document.getElementById("identity-popup");
+  },
+  get _identityBox() {
+    delete this._identityBox;
+    return this._identityBox = document.getElementById("identity-box");
+  },
+  get _identityPopupMultiView() {
+    delete this._identityPopupMultiView;
+    return this._identityPopupMultiView = document.getElementById("identity-popup-multiView");
+  },
+  get _identityPopupContentHosts() {
+    delete this._identityPopupContentHosts;
+    let selector = ".identity-popup-host";
+    return this._identityPopupContentHosts = [
+      ...this._identityPopupMultiView._mainView.querySelectorAll(selector),
+      ...document.querySelectorAll(selector)
+    ];
+  },
+  get _identityPopupContentHostless() {
+    delete this._identityPopupContentHostless;
+    let selector = ".identity-popup-hostless";
+    return this._identityPopupContentHostless = [
+      ...this._identityPopupMultiView._mainView.querySelectorAll(selector),
+      ...document.querySelectorAll(selector)
+    ];
+  },
+  get _identityPopupContentOwner() {
+    delete this._identityPopupContentOwner;
+    return this._identityPopupContentOwner =
+      document.getElementById("identity-popup-content-owner");
+  },
+  get _identityPopupContentSupp() {
+    delete this._identityPopupContentSupp;
+    return this._identityPopupContentSupp =
+      document.getElementById("identity-popup-content-supplemental");
+  },
+  get _identityPopupContentVerif() {
+    delete this._identityPopupContentVerif;
+    return this._identityPopupContentVerif =
+      document.getElementById("identity-popup-content-verifier");
+  },
+  get _identityPopupMixedContentLearnMore() {
+    delete this._identityPopupMixedContentLearnMore;
+    return this._identityPopupMixedContentLearnMore =
+      document.getElementById("identity-popup-mcb-learn-more");
+  },
+  get _identityPopupInsecureLoginFormsLearnMore() {
+    delete this._identityPopupInsecureLoginFormsLearnMore;
+    return this._identityPopupInsecureLoginFormsLearnMore =
+      document.getElementById("identity-popup-insecure-login-forms-learn-more");
+  },
+  get _identityIconLabels() {
+    delete this._identityIconLabels;
+    return this._identityIconLabels = document.getElementById("identity-icon-labels");
+  },
+  get _identityIconLabel() {
+    delete this._identityIconLabel;
+    return this._identityIconLabel = document.getElementById("identity-icon-label");
+  },
+  get _connectionIcon() {
+    delete this._connectionIcon;
+    return this._connectionIcon = document.getElementById("connection-icon");
+  },
+  get _extensionIcon() {
+    delete this._extensionIcon;
+    return this._extensionIcon = document.getElementById("extension-icon");
+  },
+  get _overrideService() {
+    delete this._overrideService;
+    return this._overrideService = Cc["@mozilla.org/security/certoverride;1"]
+                                     .getService(Ci.nsICertOverrideService);
+  },
+  get _identityIconCountryLabel() {
+    delete this._identityIconCountryLabel;
+    return this._identityIconCountryLabel = document.getElementById("identity-icon-country-label");
+  },
+  get _identityIcon() {
+    delete this._identityIcon;
+    return this._identityIcon = document.getElementById("identity-icon");
+  },
+  get _permissionList() {
+    delete this._permissionList;
+    return this._permissionList = document.getElementById("identity-popup-permission-list");
+  },
+  get _permissionEmptyHint() {
+    delete this._permissionEmptyHint;
+    return this._permissionEmptyHint = document.getElementById("identity-popup-permission-empty-hint");
+  },
+  get _permissionReloadHint() {
+    delete this._permissionReloadHint;
+    return this._permissionReloadHint = document.getElementById("identity-popup-permission-reload-hint");
+  },
+  get _popupExpander() {
+    delete this._popupExpander;
+    return this._popupExpander = document.getElementById("identity-popup-security-expander");
+  },
+  get _permissionAnchors() {
+    delete this._permissionAnchors;
+    let permissionAnchors = {};
+    for (let anchor of document.getElementById("blocked-permissions-container").children) {
+      permissionAnchors[anchor.getAttribute("data-permission-id")] = anchor;
+    }
+    return this._permissionAnchors = permissionAnchors;
+  },
+
+  /**
+   * Handler for mouseclicks on the "More Information" button in the
+   * "identity-popup" panel.
+   */
+  handleMoreInfoClick(event) {
+    displaySecurityInfo();
+    event.stopPropagation();
+    this._identityPopup.hidePopup();
+  },
+
+  showSecuritySubView() {
+    this._identityPopupMultiView.showSubView("identity-popup-securityView",
+                                             this._popupExpander);
+
+    // Elements of hidden views have -moz-user-focus:ignore but setting that
+    // per CSS selector doesn't blur a focused element in those hidden views.
+    Services.focus.clearFocus(window);
+  },
+
+  disableMixedContentProtection() {
+    // Use telemetry to measure how often unblocking happens
+    const kMIXED_CONTENT_UNBLOCK_EVENT = 2;
+    let histogram =
+      Services.telemetry.getHistogramById(
+        "MIXED_CONTENT_UNBLOCK_COUNTER");
+    histogram.add(kMIXED_CONTENT_UNBLOCK_EVENT);
+    // Reload the page with the content unblocked
+    BrowserReloadWithFlags(
+      Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_MIXED_CONTENT);
+    this._identityPopup.hidePopup();
+  },
+
+  enableMixedContentProtection() {
+    gBrowser.selectedBrowser.messageManager.sendAsyncMessage(
+      "MixedContent:ReenableProtection", {});
+    BrowserReload();
+    this._identityPopup.hidePopup();
+  },
+
+  removeCertException() {
+    if (!this._uriHasHost) {
+      Cu.reportError("Trying to revoke a cert exception on a URI without a host?");
+      return;
+    }
+    let host = this._uri.host;
+    let port = this._uri.port > 0 ? this._uri.port : 443;
+    this._overrideService.clearValidityOverride(host, port);
+    BrowserReloadSkipCache();
+    this._identityPopup.hidePopup();
+  },
+
+  /**
+   * Helper to parse out the important parts of _sslStatus (of the SSL cert in
+   * particular) for use in constructing identity UI strings
+  */
+  getIdentityData() {
+    var result = {};
+    var cert = this._sslStatus.serverCert;
+
+    // Human readable name of Subject
+    result.subjectOrg = cert.organization;
+
+    // SubjectName fields, broken up for individual access
+    if (cert.subjectName) {
+      result.subjectNameFields = {};
+      cert.subjectName.split(",").forEach(function(v) {
+        var field = v.split("=");
+        this[field[0]] = field[1];
+      }, result.subjectNameFields);
+
+      // Call out city, state, and country specifically
+      result.city = result.subjectNameFields.L;
+      result.state = result.subjectNameFields.ST;
+      result.country = result.subjectNameFields.C;
+    }
+
+    // Human readable name of Certificate Authority
+    result.caOrg =  cert.issuerOrganization || cert.issuerCommonName;
+    result.cert = cert;
+
+    return result;
+  },
+
+  /**
+   * Update the identity user interface for the page currently being displayed.
+   *
+   * This examines the SSL certificate metadata, if available, as well as the
+   * connection type and other security-related state information for the page.
+   *
+   * @param state
+   *        Bitmask provided by nsIWebProgressListener.onSecurityChange.
+   * @param uri
+   *        nsIURI for which the identity UI should be displayed, already
+   *        processed by nsIURIFixup.createExposableURI.
+   */
+  updateIdentity(state, uri) {
+    let shouldHidePopup = this._uri && (this._uri.spec != uri.spec);
+    this._state = state;
+
+    // Firstly, populate the state properties required to display the UI. See
+    // the documentation of the individual properties for details.
+    this.setURI(uri);
+    this._sslStatus = gBrowser.securityUI
+                              .QueryInterface(Ci.nsISSLStatusProvider)
+                              .SSLStatus;
+    if (this._sslStatus) {
+      this._sslStatus.QueryInterface(Ci.nsISSLStatus);
+    }
+
+    // Then, update the user interface with the available data.
+    this.refreshIdentityBlock();
+    // Handle a location change while the Control Center is focused
+    // by closing the popup (bug 1207542)
+    if (shouldHidePopup) {
+      this._identityPopup.hidePopup();
+    }
+
+    // NOTE: We do NOT update the identity popup (the control center) when
+    // we receive a new security state on the existing page (i.e. from a
+    // subframe). If the user opened the popup and looks at the provided
+    // information we don't want to suddenly change the panel contents.
+
+    // Finally, if there are warnings to issue, issue them
+    if (this._isCertDistrustImminent) {
+      let consoleMsg = Cc["@mozilla.org/scripterror;1"].createInstance(Ci.nsIScriptError);
+      let windowId = gBrowser.selectedBrowser.innerWindowID;
+      let message = gBrowserBundle.GetStringFromName("certImminentDistrust.message");
+      // Use uri.prePath instead of initWithSourceURI() so that these can be
+      // de-duplicated on the scheme+host+port combination.
+      consoleMsg.initWithWindowID(message, uri.prePath, null, 0, 0,
+                                  Ci.nsIScriptError.warningFlag, "SSL",
+                                  windowId);
+      Services.console.logMessage(consoleMsg);
+    }
+  },
+
+  /**
+   * This is called asynchronously when requested by the Logins module, after
+   * the insecure login forms state for the page has been updated.
+   */
+  refreshForInsecureLoginForms() {
+    // Check this._uri because we don't want to refresh the user interface if
+    // this is called before the first page load in the window for any reason.
+    if (!this._uri) {
+      return;
+    }
+    this.refreshIdentityBlock();
+  },
+
+  updateSharingIndicator() {
+    let tab = gBrowser.selectedTab;
+    let sharing = tab.getAttribute("sharing");
+    if (sharing)
+      this._identityBox.setAttribute("sharing", sharing);
+    else
+      this._identityBox.removeAttribute("sharing");
+
+    this._sharingState = tab._sharingState;
+
+    if (this._identityPopup.state == "open") {
+      this.updateSitePermissions();
+      this._identityPopupMultiView.descriptionHeightWorkaround();
+    }
+  },
+
+  /**
+   * Attempt to provide proper IDN treatment for host names
+   */
+  getEffectiveHost() {
+    if (!this._IDNService)
+      this._IDNService = Cc["@mozilla.org/network/idn-service;1"]
+                         .getService(Ci.nsIIDNService);
+    try {
+      return this._IDNService.convertToDisplayIDN(this._uri.host, {});
+    } catch (e) {
+      // If something goes wrong (e.g. host is an IP address) just fail back
+      // to the full domain.
+      return this._uri.host;
+    }
+  },
+
+  /**
+   * Return the CSS class name to set on the "fullscreen-warning" element to
+   * display information about connection security in the notification shown
+   * when a site enters the fullscreen mode.
+   */
+  get pointerlockFsWarningClassName() {
+    // Note that the fullscreen warning does not handle _isSecureInternalUI.
+    if (this._uriHasHost && this._isEV) {
+      return "verifiedIdentity";
+    }
+    if (this._uriHasHost && this._isSecure) {
+      return "verifiedDomain";
+    }
+    return "unknownIdentity";
+  },
+
+  /**
+   * Updates the identity block user interface with the data from this object.
+   */
+  refreshIdentityBlock() {
+    if (!this._identityBox) {
+      return;
+    }
+
+    let icon_label = "";
+    let tooltip = "";
+    let icon_country_label = "";
+    let icon_labels_dir = "ltr";
+
+    if (this._isSecureInternalUI) {
+      this._identityBox.className = "chromeUI";
+      let brandBundle = document.getElementById("bundle_brand");
+      icon_label = brandBundle.getString("brandShorterName");
+    } else if (this._uriHasHost && this._isEV) {
+      this._identityBox.className = "verifiedIdentity";
+      if (this._isMixedActiveContentBlocked) {
+        this._identityBox.classList.add("mixedActiveBlocked");
+      }
+
+      if (!this._isCertUserOverridden) {
+        // If it's identified, then we can populate the dialog with credentials
+        let iData = this.getIdentityData();
+        tooltip = gNavigatorBundle.getFormattedString("identity.identified.verifier",
+                                                      [iData.caOrg]);
+        icon_label = iData.subjectOrg;
+        if (iData.country)
+          icon_country_label = "(" + iData.country + ")";
+
+        // If the organization name starts with an RTL character, then
+        // swap the positions of the organization and country code labels.
+        // The Unicode ranges reflect the definition of the UTF16_CODE_UNIT_IS_BIDI
+        // macro in intl/unicharutil/util/nsBidiUtils.h. When bug 218823 gets
+        // fixed, this test should be replaced by one adhering to the
+        // Unicode Bidirectional Algorithm proper (at the paragraph level).
+        icon_labels_dir = /^[\u0590-\u08ff\ufb1d-\ufdff\ufe70-\ufefc\ud802\ud803\ud83a\ud83b]/.test(icon_label) ?
+                          "rtl" : "ltr";
+      }
+    } else if (this._pageExtensionPolicy) {
+      this._identityBox.className = "extensionPage";
+      let extensionName = this._pageExtensionPolicy.name;
+      icon_label = gNavigatorBundle.getFormattedString(
+        "identity.extension.label", [extensionName]);
+    } else if (this._uriHasHost && this._isSecure) {
+      this._identityBox.className = "verifiedDomain";
+      if (this._isMixedActiveContentBlocked) {
+        this._identityBox.classList.add("mixedActiveBlocked");
+      }
+      if (!this._isCertUserOverridden) {
+        // It's a normal cert, verifier is the CA Org.
+        tooltip = gNavigatorBundle.getFormattedString("identity.identified.verifier",
+                                                      [this.getIdentityData().caOrg]);
+      }
+    } else if (!this._uriHasHost) {
+      this._identityBox.className = "unknownIdentity";
+    } else if (gBrowser.selectedBrowser.documentURI &&
+               (gBrowser.selectedBrowser.documentURI.scheme == "about" ||
+               gBrowser.selectedBrowser.documentURI.scheme == "chrome")) {
+        // For net errors we should not show notSecure as it's likely confusing
+      this._identityBox.className = "unknownIdentity";
+    } else {
+      if (this._isBroken) {
+        this._identityBox.className = "unknownIdentity";
+
+        if (this._isMixedActiveContentLoaded) {
+          this._identityBox.classList.add("mixedActiveContent");
+        } else if (this._isMixedActiveContentBlocked) {
+          this._identityBox.classList.add("mixedDisplayContentLoadedActiveBlocked");
+        } else if (this._isMixedPassiveContentLoaded) {
+          this._identityBox.classList.add("mixedDisplayContent");
+        } else {
+          this._identityBox.classList.add("weakCipher");
+        }
+      } else {
+        let warnOnInsecure = Services.prefs.getBoolPref("security.insecure_connection_icon.enabled") ||
+                             (Services.prefs.getBoolPref("security.insecure_connection_icon.pbmode.enabled") &&
+                             PrivateBrowsingUtils.isWindowPrivate(window));
+        let className = warnOnInsecure ? "notSecure" : "unknownIdentity";
+
+        this._identityBox.className = className;
+      }
+      if (this._hasInsecureLoginForms) {
+        // Insecure login forms can only be present on "unknown identity"
+        // pages, either already insecure or with mixed active content loaded.
+        this._identityBox.classList.add("insecureLoginForms");
+      }
+    }
+
+    if (this._isCertUserOverridden) {
+      this._identityBox.classList.add("certUserOverridden");
+      // Cert is trusted because of a security exception, verifier is a special string.
+      tooltip = gNavigatorBundle.getString("identity.identified.verified_by_you");
+    }
+
+    let permissionAnchors = this._permissionAnchors;
+
+    // hide all permission icons
+    for (let icon of Object.values(permissionAnchors)) {
+      icon.removeAttribute("showing");
+    }
+
+    // keeps track if we should show an indicator that there are active permissions
+    let hasGrantedPermissions = false;
+
+    // show permission icons
+    let permissions = SitePermissions.getAllForBrowser(gBrowser.selectedBrowser);
+    for (let permission of permissions) {
+      if (permission.state == SitePermissions.BLOCK) {
+
+        let icon = permissionAnchors[permission.id];
+        if (icon) {
+          icon.setAttribute("showing", "true");
+        }
+
+      } else if (permission.state != SitePermissions.UNKNOWN) {
+        hasGrantedPermissions = true;
+      }
+    }
+
+    if (hasGrantedPermissions) {
+      this._identityBox.classList.add("grantedPermissions");
+    }
+
+    // Show blocked popup icon in the identity-box if popups are blocked
+    // irrespective of popup permission capability value.
+    if (gBrowser.selectedBrowser.blockedPopups &&
+        gBrowser.selectedBrowser.blockedPopups.length) {
+      let icon = permissionAnchors.popup;
+      icon.setAttribute("showing", "true");
+    }
+
+    // Push the appropriate strings out to the UI
+    this._connectionIcon.setAttribute("tooltiptext", tooltip);
+
+    if (this._pageExtensionPolicy) {
+      let extensionName = this._pageExtensionPolicy.name;
+      this._extensionIcon.setAttribute("tooltiptext",
+        gNavigatorBundle.getFormattedString("identity.extension.tooltip", [extensionName]));
+    }
+
+    this._identityIconLabels.setAttribute("tooltiptext", tooltip);
+    this._identityIcon.setAttribute("tooltiptext", gNavigatorBundle.getString("identity.icon.tooltip"));
+    this._identityIconLabel.setAttribute("value", icon_label);
+    this._identityIconCountryLabel.setAttribute("value", icon_country_label);
+    // Set cropping and direction
+    this._identityIconLabel.setAttribute("crop", icon_country_label ? "end" : "center");
+    this._identityIconLabel.parentNode.style.direction = icon_labels_dir;
+    // Hide completely if the organization label is empty
+    this._identityIconLabel.parentNode.collapsed = !icon_label;
+  },
+
+  /**
+   * Set up the title and content messages for the identity message popup,
+   * based on the specified mode, and the details of the SSL cert, where
+   * applicable
+   */
+  refreshIdentityPopup() {
+    // Update "Learn More" for Mixed Content Blocking and Insecure Login Forms.
+    let baseURL = Services.urlFormatter.formatURLPref("app.support.baseURL");
+    this._identityPopupMixedContentLearnMore
+        .setAttribute("href", baseURL + "mixed-content");
+    this._identityPopupInsecureLoginFormsLearnMore
+        .setAttribute("href", baseURL + "insecure-password");
+
+    // This is in the properties file because the expander used to switch its tooltip.
+    this._popupExpander.tooltipText = gNavigatorBundle.getString("identity.showDetails.tooltip");
+
+    // Determine connection security information.
+    let connection = "not-secure";
+    if (this._isSecureInternalUI) {
+      connection = "chrome";
+    } else if (this._pageExtensionPolicy) {
+      connection = "extension";
+    } else if (this._isURILoadedFromFile) {
+      connection = "file";
+    } else if (this._isEV) {
+      connection = "secure-ev";
+    } else if (this._isCertUserOverridden) {
+      connection = "secure-cert-user-overridden";
+    } else if (this._isSecure) {
+      connection = "secure";
+    }
+
+    // Determine if there are insecure login forms.
+    let loginforms = "secure";
+    if (this._hasInsecureLoginForms) {
+      loginforms = "insecure";
+    }
+
+    // Determine the mixed content state.
+    let mixedcontent = [];
+    if (this._isMixedPassiveContentLoaded) {
+      mixedcontent.push("passive-loaded");
+    }
+    if (this._isMixedActiveContentLoaded) {
+      mixedcontent.push("active-loaded");
+    } else if (this._isMixedActiveContentBlocked) {
+      mixedcontent.push("active-blocked");
+    }
+    mixedcontent = mixedcontent.join(" ");
+
+    // We have no specific flags for weak ciphers (yet). If a connection is
+    // broken and we can't detect any mixed content loaded then it's a weak
+    // cipher.
+    let ciphers = "";
+    if (this._isBroken && !this._isMixedActiveContentLoaded && !this._isMixedPassiveContentLoaded) {
+      ciphers = "weak";
+    }
+
+    // Update all elements.
+    let elementIDs = [
+      "identity-popup",
+      "identity-popup-securityView-body",
+    ];
+
+    function updateAttribute(elem, attr, value) {
+      if (value) {
+        elem.setAttribute(attr, value);
+      } else {
+        elem.removeAttribute(attr);
+      }
+    }
+
+    for (let id of elementIDs) {
+      let element = document.getElementById(id);
+      updateAttribute(element, "connection", connection);
+      updateAttribute(element, "loginforms", loginforms);
+      updateAttribute(element, "ciphers", ciphers);
+      updateAttribute(element, "mixedcontent", mixedcontent);
+      updateAttribute(element, "isbroken", this._isBroken);
+    }
+
+    // Initialize the optional strings to empty values
+    let supplemental = "";
+    let verifier = "";
+    let host = "";
+    let owner = "";
+    let hostless = false;
+
+    try {
+      host = this.getEffectiveHost();
+    } catch (e) {
+      // Some URIs might have no hosts.
+    }
+
+    // Fallback for special protocols.
+    if (!host) {
+      host = this._uri.specIgnoringRef;
+      // Special URIs without a host (eg, about:) should crop the end so
+      // the protocol can be seen.
+      hostless = true;
+    }
+
+    if (this._pageExtensionPolicy) {
+      host = this._pageExtensionPolicy.name;
+    }
+
+    // Fill in the CA name if we have a valid TLS certificate.
+    if (this._isSecure || this._isCertUserOverridden) {
+      verifier = this._identityIconLabels.tooltipText;
+    }
+
+    // Fill in organization information if we have a valid EV certificate.
+    if (this._isEV) {
+      let iData = this.getIdentityData();
+      host = owner = iData.subjectOrg;
+      verifier = this._identityIconLabels.tooltipText;
+
+      // Build an appropriate supplemental block out of whatever location data we have
+      if (iData.city)
+        supplemental += iData.city + "\n";
+      if (iData.state && iData.country)
+        supplemental += gNavigatorBundle.getFormattedString("identity.identified.state_and_country",
+                                                            [iData.state, iData.country]);
+      else if (iData.state) // State only
+        supplemental += iData.state;
+      else if (iData.country) // Country only
+        supplemental += iData.country;
+    }
+
+    // Push the appropriate strings out to the UI.
+    this._identityPopupContentHosts.forEach((el) => {
+      el.textContent = host;
+      el.hidden = hostless;
+    });
+    this._identityPopupContentHostless.forEach((el) => {
+      el.setAttribute("value", host);
+      el.hidden = !hostless;
+    });
+    this._identityPopupContentOwner.textContent = owner;
+    this._identityPopupContentSupp.textContent = supplemental;
+    this._identityPopupContentVerif.textContent = verifier;
+
+    // Update per-site permissions section.
+    this.updateSitePermissions();
+  },
+
+  setURI(uri) {
+    this._uri = uri;
+
+    try {
+      // Account for file: urls and catch when "" is the value
+      this._uriHasHost = !!this._uri.host;
+    } catch (ex) {
+      this._uriHasHost = false;
+    }
+
+    this._isSecureInternalUI = uri.schemeIs("about") &&
+      this._secureInternalUIWhitelist.test(uri.pathQueryRef);
+
+    this._pageExtensionPolicy = WebExtensionPolicy.getByURI(uri);
+
+    // Create a channel for the sole purpose of getting the resolved URI
+    // of the request to determine if it's loaded from the file system.
+    this._isURILoadedFromFile = false;
+    let chanOptions = {uri: this._uri, loadUsingSystemPrincipal: true};
+    let resolvedURI;
+    try {
+      resolvedURI = NetUtil.newChannel(chanOptions).URI;
+      if (resolvedURI.schemeIs("jar")) {
+        // Given a URI "jar:<jar-file-uri>!/<jar-entry>"
+        // create a new URI using <jar-file-uri>!/<jar-entry>
+        resolvedURI = NetUtil.newURI(resolvedURI.pathQueryRef);
+      }
+      // Check the URI again after resolving.
+      this._isURILoadedFromFile = resolvedURI.schemeIs("file");
+    } catch (ex) {
+      // NetUtil's methods will throw for malformed URIs and the like
+    }
+  },
+
+  /**
+   * Click handler for the identity-box element in primary chrome.
+   */
+  handleIdentityButtonEvent(event) {
+    event.stopPropagation();
+
+    if ((event.type == "click" && event.button != 0) ||
+        (event.type == "keypress" && event.charCode != KeyEvent.DOM_VK_SPACE &&
+         event.keyCode != KeyEvent.DOM_VK_RETURN)) {
+      return; // Left click, space or enter only
+    }
+
+    // Don't allow left click, space or enter if the location has been modified,
+    // so long as we're not sharing any devices.
+    // If we are sharing a device, the identity block is prevented by CSS from
+    // being focused (and therefore, interacted with) by the user. However, we
+    // want to allow opening the identity popup from the device control menu,
+    // which calls click() on the identity button, so we don't return early.
+    if (!this._sharingState &&
+        gURLBar.getAttribute("pageproxystate") != "valid") {
+      return;
+    }
+
+    this._popupTriggeredByKeyboard = event.type == "keypress";
+
+    // Make sure that the display:none style we set in xul is removed now that
+    // the popup is actually needed
+    this._identityPopup.hidden = false;
+
+    // Remove the reload hint that we show after a user has cleared a permission.
+    this._permissionReloadHint.setAttribute("hidden", "true");
+
+    // Update the popup strings
+    this.refreshIdentityPopup();
+
+    // Add the "open" attribute to the identity box for styling
+    this._identityBox.setAttribute("open", "true");
+
+    // Now open the popup, anchored off the primary chrome element
+    this._identityPopup.openPopup(this._identityIcon, "bottomcenter topleft");
+  },
+
+  onPopupShown(event) {
+    if (event.target == this._identityPopup) {
+      if (this._popupTriggeredByKeyboard) {
+        // Move focus to the next available element in the identity popup.
+        // This is required by role=alertdialog and fixes an issue where
+        // an already open panel would steal focus from the identity popup.
+        document.commandDispatcher.advanceFocusIntoSubtree(this._identityPopup);
+      }
+
+      window.addEventListener("focus", this, true);
+    }
+  },
+
+  onPopupHidden(event) {
+    if (event.target == this._identityPopup) {
+      window.removeEventListener("focus", this, true);
+      this._identityBox.removeAttribute("open");
+    }
+  },
+
+  handleEvent(event) {
+    let elem = document.activeElement;
+    let position = elem.compareDocumentPosition(this._identityPopup);
+
+    if (!(position & (Node.DOCUMENT_POSITION_CONTAINS |
+                      Node.DOCUMENT_POSITION_CONTAINED_BY)) &&
+        !this._identityPopup.hasAttribute("noautohide")) {
+      // Hide the panel when focusing an element that is
+      // neither an ancestor nor descendant unless the panel has
+      // @noautohide (e.g. for a tour).
+      this._identityPopup.hidePopup();
+    }
+  },
+
+  observe(subject, topic, data) {
+    if (topic == "perm-changed") {
+      this.refreshIdentityBlock();
+    }
+  },
+
+  onDragStart(event) {
+    if (gURLBar.getAttribute("pageproxystate") != "valid")
+      return;
+
+    let value = gBrowser.currentURI.displaySpec;
+    let urlString = value + "\n" + gBrowser.contentTitle;
+    let htmlString = "<a href=\"" + value + "\">" + value + "</a>";
+
+    let dt = event.dataTransfer;
+    dt.setData("text/x-moz-url", urlString);
+    dt.setData("text/uri-list", value);
+    dt.setData("text/plain", value);
+    dt.setData("text/html", htmlString);
+    dt.setDragImage(this._identityIcon, 16, 16);
+  },
+
+  onLocationChange() {
+    this._permissionReloadHint.setAttribute("hidden", "true");
+
+    if (!this._permissionList.hasChildNodes()) {
+      this._permissionEmptyHint.removeAttribute("hidden");
+    }
+  },
+
+  updateSitePermissions() {
+    while (this._permissionList.hasChildNodes())
+      this._permissionList.removeChild(this._permissionList.lastChild);
+
+    let permissions =
+      SitePermissions.getAllPermissionDetailsForBrowser(gBrowser.selectedBrowser);
+
+    if (this._sharingState) {
+      // If WebRTC device or screen permissions are in use, we need to find
+      // the associated permission item to set the inUse field to true.
+      for (let id of ["camera", "microphone", "screen"]) {
+        if (this._sharingState[id]) {
+          let found = false;
+          for (let permission of permissions) {
+            if (permission.id != id)
+              continue;
+            found = true;
+            permission.inUse = true;
+            break;
+          }
+          if (!found) {
+            // If the permission item we were looking for doesn't exist,
+            // the user has temporarily allowed sharing and we need to add
+            // an item in the permissions array to reflect this.
+            permissions.push({
+              id,
+              state: SitePermissions.ALLOW,
+              scope: SitePermissions.SCOPE_REQUEST,
+              inUse: true,
+            });
+          }
+        }
+      }
+    }
+
+    let hasBlockedPopupIndicator = false;
+    for (let permission of permissions) {
+      let item = this._createPermissionItem(permission);
+      this._permissionList.appendChild(item);
+
+      if (permission.id == "popup" &&
+          gBrowser.selectedBrowser.blockedPopups &&
+          gBrowser.selectedBrowser.blockedPopups.length) {
+        this._createBlockedPopupIndicator();
+        hasBlockedPopupIndicator = true;
+      }
+    }
+
+    if (gBrowser.selectedBrowser.blockedPopups &&
+        gBrowser.selectedBrowser.blockedPopups.length &&
+        !hasBlockedPopupIndicator) {
+      let permission = {
+        id: "popup",
+        state: SitePermissions.UNKNOWN,
+        scope: SitePermissions.SCOPE_PERSISTENT,
+      };
+      let item = this._createPermissionItem(permission);
+      this._permissionList.appendChild(item);
+      this._createBlockedPopupIndicator();
+    }
+
+    // Show a placeholder text if there's no permission and no reload hint.
+    if (!this._permissionList.hasChildNodes() &&
+        this._permissionReloadHint.hasAttribute("hidden")) {
+      this._permissionEmptyHint.removeAttribute("hidden");
+    } else {
+      this._permissionEmptyHint.setAttribute("hidden", "true");
+    }
+  },
+
+  _createPermissionItem(aPermission) {
+    let container = document.createElement("hbox");
+    container.setAttribute("class", "identity-popup-permission-item");
+    container.setAttribute("align", "center");
+
+    let img = document.createElement("image");
+    let classes = "identity-popup-permission-icon " + aPermission.id + "-icon";
+    if (aPermission.state == SitePermissions.BLOCK)
+      classes += " blocked-permission-icon";
+    if (aPermission.inUse)
+      classes += " in-use";
+    img.setAttribute("class", classes);
+
+    let nameLabel = document.createElement("label");
+    nameLabel.setAttribute("flex", "1");
+    nameLabel.setAttribute("class", "identity-popup-permission-label");
+    nameLabel.textContent = SitePermissions.getPermissionLabel(aPermission.id);
+
+    if (aPermission.id == "popup") {
+      let menulist = document.createElement("menulist");
+      let menupopup = document.createElement("menupopup");
+      let block = document.createElement("vbox");
+      block.setAttribute("id", "identity-popup-popup-container");
+      menulist.setAttribute("sizetopopup", "none");
+      menulist.setAttribute("class", "identity-popup-popup-menulist");
+      menulist.setAttribute("id", "identity-popup-popup-menulist");
+
+      for (let state of SitePermissions.getAvailableStates(aPermission.id)) {
+        let menuitem = document.createElement("menuitem");
+        if (state == SitePermissions.getDefault(aPermission.id)) {
+          menuitem.setAttribute("value", 0);
+        } else {
+          menuitem.setAttribute("value", state);
+        }
+        menuitem.setAttribute("label", SitePermissions.getMultichoiceStateLabel(state));
+        menupopup.appendChild(menuitem);
+      }
+
+      menulist.appendChild(menupopup);
+      menulist.setAttribute("value", aPermission.state);
+
+      // Avoiding listening to the "select" event on purpose. See Bug 1404262.
+      menulist.addEventListener("command", () => {
+        SitePermissions.set(gBrowser.currentURI, "popup", menulist.selectedItem.value);
+      });
+
+      container.appendChild(img);
+      container.appendChild(nameLabel);
+      container.appendChild(menulist);
+      block.appendChild(container);
+
+      return block;
+    }
+
+    let stateLabel = document.createElement("label");
+    stateLabel.setAttribute("flex", "1");
+    stateLabel.setAttribute("class", "identity-popup-permission-state-label");
+    let {state, scope} = aPermission;
+    // If the user did not permanently allow this device but it is currently
+    // used, set the variables to display a "temporarily allowed" info.
+    if (state != SitePermissions.ALLOW && aPermission.inUse) {
+      state = SitePermissions.ALLOW;
+      scope = SitePermissions.SCOPE_REQUEST;
+    }
+    stateLabel.textContent = SitePermissions.getCurrentStateLabel(state, scope);
+
+    let button = document.createElement("button");
+    button.setAttribute("class", "identity-popup-permission-remove-button");
+    let tooltiptext = gNavigatorBundle.getString("permissions.remove.tooltip");
+    button.setAttribute("tooltiptext", tooltiptext);
+    button.addEventListener("command", () => {
+      let browser = gBrowser.selectedBrowser;
+      this._permissionList.removeChild(container);
+      if (aPermission.inUse &&
+          ["camera", "microphone", "screen"].includes(aPermission.id)) {
+        let windowId = this._sharingState.windowId;
+        if (aPermission.id == "screen") {
+          windowId = "screen:" + windowId;
+        } else {
+          // If we set persistent permissions or the sharing has
+          // started due to existing persistent permissions, we need
+          // to handle removing these even for frames with different hostnames.
+          let uris = browser._devicePermissionURIs || [];
+          for (let uri of uris) {
+            // It's not possible to stop sharing one of camera/microphone
+            // without the other.
+            for (let id of ["camera", "microphone"]) {
+              if (this._sharingState[id]) {
+                let perm = SitePermissions.get(uri, id);
+                if (perm.state == SitePermissions.ALLOW &&
+                    perm.scope == SitePermissions.SCOPE_PERSISTENT) {
+                  SitePermissions.remove(uri, id);
+                }
+              }
+            }
+          }
+        }
+        browser.messageManager.sendAsyncMessage("webrtc:StopSharing", windowId);
+        webrtcUI.forgetActivePermissionsFromBrowser(gBrowser.selectedBrowser);
+      }
+      SitePermissions.remove(gBrowser.currentURI, aPermission.id, browser);
+
+      this._permissionReloadHint.removeAttribute("hidden");
+      this._identityPopupMultiView.descriptionHeightWorkaround();
+
+      // Set telemetry values for clearing a permission
+      let histogram = Services.telemetry.getKeyedHistogramById("WEB_PERMISSION_CLEARED");
+
+      let permissionType = 0;
+      if (aPermission.state == SitePermissions.ALLOW &&
+          aPermission.scope == SitePermissions.SCOPE_PERSISTENT) {
+        // 1 : clear permanently allowed permission
+        permissionType = 1;
+      } else if (aPermission.state == SitePermissions.BLOCK &&
+                 aPermission.scope == SitePermissions.SCOPE_PERSISTENT) {
+        // 2 : clear permanently blocked permission
+        permissionType = 2;
+      } else if (aPermission.state == SitePermissions.ALLOW) {
+        // 3 : clear temporary allowed permission
+        permissionType = 3;
+      } else if (aPermission.state == SitePermissions.BLOCK) {
+        // 4 : clear temporary blocked permission
+        permissionType = 4;
+      }
+
+      histogram.add("(all)", permissionType);
+      histogram.add(aPermission.id, permissionType);
+    });
+
+    container.appendChild(img);
+    container.appendChild(nameLabel);
+    container.appendChild(stateLabel);
+    container.appendChild(button);
+
+    return container;
+  },
+
+  _createBlockedPopupIndicator() {
+    let indicator = document.createElement("hbox");
+    indicator.setAttribute("class", "identity-popup-permission-item");
+    indicator.setAttribute("align", "center");
+    indicator.setAttribute("id", "blocked-popup-indicator-item");
+
+    let icon = document.createElement("image");
+    icon.setAttribute("class", "popup-subitem identity-popup-permission-icon");
+
+    let text = document.createElement("label");
+    text.setAttribute("flex", "1");
+    text.setAttribute("class", "identity-popup-permission-label text-link");
+
+    let popupCount = gBrowser.selectedBrowser.blockedPopups.length;
+    let messageBase = gNavigatorBundle.getString("popupShowBlockedPopupsIndicatorText");
+    let message = PluralForm.get(popupCount, messageBase)
+                                 .replace("#1", popupCount);
+    text.setAttribute("value", message);
+
+    text.addEventListener("click", () => {
+      gPopupBlockerObserver.showAllBlockedPopups(gBrowser.selectedBrowser);
+    });
+
+    indicator.appendChild(icon);
+    indicator.appendChild(text);
+
+    document.getElementById("identity-popup-popup-container").appendChild(indicator);
+  },
+};
+
+/**
+ * Fired on the "marionette-remote-control" system notification,
+ * indicating if the browser session is under remote control.
+ */
+const gRemoteControl = {
+  observe(subject, topic, data) {
+    gRemoteControl.updateVisualCue(data);
+  },
+
+  updateVisualCue(enabled) {
+    const mainWindow = document.documentElement;
+    if (enabled) {
+      mainWindow.setAttribute("remotecontrol", "true");
+    } else {
+      mainWindow.removeAttribute("remotecontrol");
+    }
+  },
+};
+
+function getNotificationBox(aWindow) {
+  var foundBrowser = gBrowser.getBrowserForDocument(aWindow.document);
+  if (foundBrowser)
+    return gBrowser.getNotificationBox(foundBrowser);
+  return null;
+}
+
+function getTabModalPromptBox(aWindow) {
+  var foundBrowser = gBrowser.getBrowserForDocument(aWindow.document);
+  if (foundBrowser)
+    return gBrowser.getTabModalPromptBox(foundBrowser);
+  return null;
+}
+
+/* DEPRECATED */
+function getBrowser() {
+  return gBrowser;
+}
+
+const gAccessibilityServiceIndicator = {
+  init() {
+    // Pref to enable accessibility service indicator.
+    Services.prefs.addObserver("accessibility.indicator.enabled", this);
+    // Accessibility service init/shutdown event.
+    Services.obs.addObserver(this, "a11y-init-or-shutdown");
+    this.update(Services.appinfo.accessibilityEnabled);
+  },
+
+  update(accessibilityEnabled = false) {
+    if (this.enabled && accessibilityEnabled) {
+      this._active = true;
+      document.documentElement.setAttribute("accessibilitymode", "true");
+      [...document.querySelectorAll(".accessibility-indicator")].forEach(
+        indicator => ["click", "keypress"].forEach(type =>
+          indicator.addEventListener(type, this)));
+      TabsInTitlebar.updateAppearance(true);
+    } else if (this._active) {
+      this._active = false;
+      document.documentElement.removeAttribute("accessibilitymode");
+      [...document.querySelectorAll(".accessibility-indicator")].forEach(
+        indicator => ["click", "keypress"].forEach(type =>
+          indicator.removeEventListener(type, this)));
+      TabsInTitlebar.updateAppearance(true);
+    }
+  },
+
+  observe(subject, topic, data) {
+    if (topic == "nsPref:changed" && data === "accessibility.indicator.enabled") {
+      this.update(Services.appinfo.accessibilityEnabled);
+    } else if (topic === "a11y-init-or-shutdown") {
+      // When "a11y-init-or-shutdown" event is fired, "1" indicates that
+      // accessibility service is started and "0" that it is shut down.
+      this.update(data === "1");
+    }
+  },
+
+  get enabled() {
+    return Services.prefs.getBoolPref("accessibility.indicator.enabled");
+  },
+
+  handleEvent({ key, type }) {
+    if ((type === "keypress" && [" ", "Enter"].includes(key)) ||
+         type === "click") {
+      let a11yServicesSupportURL =
+        Services.urlFormatter.formatURLPref("accessibility.support.url");
+      gBrowser.selectedTab = gBrowser.addTab(a11yServicesSupportURL);
+      Services.telemetry.scalarSet("a11y.indicator_acted_on", true);
+    }
+  },
+
+  uninit() {
+    Services.prefs.removeObserver("accessibility.indicator.enabled", this);
+    Services.obs.removeObserver(this, "a11y-init-or-shutdown");
+    this.update();
+  }
+};
+
+var gPrivateBrowsingUI = {
+  init: function PBUI_init() {
+    // Do nothing for normal windows
+    if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+
+    // Disable the Clear Recent History... menu item when in PB mode
+    // temporary fix until bug 463607 is fixed
+    document.getElementById("Tools:Sanitize").setAttribute("disabled", "true");
+
+    if (window.location.href == getBrowserURL()) {
+      // Adjust the window's title
+      let docElement = document.documentElement;
+      if (!PrivateBrowsingUtils.permanentPrivateBrowsing) {
+        docElement.setAttribute("title",
+          docElement.getAttribute("title_privatebrowsing"));
+        docElement.setAttribute("titlemodifier",
+          docElement.getAttribute("titlemodifier_privatebrowsing"));
+      }
+      docElement.setAttribute("privatebrowsingmode",
+        PrivateBrowsingUtils.permanentPrivateBrowsing ? "permanent" : "temporary");
+      gBrowser.updateTitlebar();
+
+      if (PrivateBrowsingUtils.permanentPrivateBrowsing) {
+        // Adjust the New Window menu entries
+        [
+          { normal: "menu_newNavigator", private: "menu_newPrivateWindow" },
+        ].forEach(function(menu) {
+          let newWindow = document.getElementById(menu.normal);
+          let newPrivateWindow = document.getElementById(menu.private);
+          if (newWindow && newPrivateWindow) {
+            newPrivateWindow.hidden = true;
+            newWindow.label = newPrivateWindow.label;
+            newWindow.accessKey = newPrivateWindow.accessKey;
+            newWindow.command = newPrivateWindow.command;
+          }
+        });
+      }
+    }
+
+    let urlBarSearchParam = gURLBar.getAttribute("autocompletesearchparam") || "";
+    if (!PrivateBrowsingUtils.permanentPrivateBrowsing &&
+        !urlBarSearchParam.includes("disable-private-actions")) {
+      // Disable switch to tab autocompletion for private windows.
+      // We leave it enabled for permanent private browsing mode though.
+      urlBarSearchParam += " disable-private-actions";
+    }
+    if (!urlBarSearchParam.includes("private-window")) {
+      urlBarSearchParam += " private-window";
+    }
+    gURLBar.setAttribute("autocompletesearchparam", urlBarSearchParam);
+  }
+};
+
+/**
+ * Switch to a tab that has a given URI, and focuses its browser window.
+ * If a matching tab is in this window, it will be switched to. Otherwise, other
+ * windows will be searched.
+ *
+ * @param aURI
+ *        URI to search for
+ * @param aOpenNew
+ *        True to open a new tab and switch to it, if no existing tab is found.
+ *        If no suitable window is found, a new one will be opened.
+ * @param aOpenParams
+ *        If switching to this URI results in us opening a tab, aOpenParams
+ *        will be the parameter object that gets passed to openUILinkIn. Please
+ *        see the documentation for openUILinkIn to see what parameters can be
+ *        passed via this object.
+ *        This object also allows:
+ *        - 'ignoreFragment' property to be set to true to exclude fragment-portion
+ *        matching when comparing URIs.
+ *          If set to "whenComparing", the fragment will be unmodified.
+ *          If set to "whenComparingAndReplace", the fragment will be replaced.
+ *        - 'ignoreQueryString' boolean property to be set to true to exclude query string
+ *        matching when comparing URIs.
+ *        - 'replaceQueryString' boolean property to be set to true to exclude query string
+ *        matching when comparing URIs and overwrite the initial query string with
+ *        the one from the new URI.
+ *        - 'adoptIntoActiveWindow' boolean property to be set to true to adopt the tab
+ *        into the current window.
+ * @return True if an existing tab was found, false otherwise
+ */
+function switchToTabHavingURI(aURI, aOpenNew, aOpenParams = {}) {
+  // Certain URLs can be switched to irrespective of the source or destination
+  // window being in private browsing mode:
+  const kPrivateBrowsingWhitelist = new Set([
+    "about:addons",
+  ]);
+
+  let ignoreFragment = aOpenParams.ignoreFragment;
+  let ignoreQueryString = aOpenParams.ignoreQueryString;
+  let replaceQueryString = aOpenParams.replaceQueryString;
+  let adoptIntoActiveWindow = aOpenParams.adoptIntoActiveWindow;
+
+  // These properties are only used by switchToTabHavingURI and should
+  // not be used as a parameter for the new load.
+  delete aOpenParams.ignoreFragment;
+  delete aOpenParams.ignoreQueryString;
+  delete aOpenParams.replaceQueryString;
+  delete aOpenParams.adoptIntoActiveWindow;
+
+  let isBrowserWindow = !!window.gBrowser;
+
+  // This will switch to the tab in aWindow having aURI, if present.
+  function switchIfURIInWindow(aWindow) {
+    // Only switch to the tab if neither the source nor the destination window
+    // are private and they are not in permanent private browsing mode
+    if (!kPrivateBrowsingWhitelist.has(aURI.spec) &&
+        (PrivateBrowsingUtils.isWindowPrivate(window) ||
+         PrivateBrowsingUtils.isWindowPrivate(aWindow)) &&
+        !PrivateBrowsingUtils.permanentPrivateBrowsing) {
+      return false;
+    }
+
+    // Remove the query string, fragment, both, or neither from a given url.
+    function cleanURL(url, removeQuery, removeFragment) {
+      let ret = url;
+      if (removeFragment) {
+        ret = ret.split("#")[0];
+        if (removeQuery) {
+          // This removes a query, if present before the fragment.
+          ret = ret.split("?")[0];
+        }
+      } else if (removeQuery) {
+        // This is needed in case there is a fragment after the query.
+        let fragment = ret.split("#")[1];
+        ret = ret.split("?")[0].concat(
+          (fragment != undefined) ? "#".concat(fragment) : "");
+      }
+      return ret;
+    }
+
+    // Need to handle nsSimpleURIs here too (e.g. about:...), which don't
+    // work correctly with URL objects - so treat them as strings
+    let ignoreFragmentWhenComparing = typeof ignoreFragment == "string" &&
+                                      ignoreFragment.startsWith("whenComparing");
+    let requestedCompare = cleanURL(
+          aURI.displaySpec, ignoreQueryString || replaceQueryString, ignoreFragmentWhenComparing);
+    let browsers = aWindow.gBrowser.browsers;
+    for (let i = 0; i < browsers.length; i++) {
+      let browser = browsers[i];
+      let browserCompare = cleanURL(
+          browser.currentURI.displaySpec, ignoreQueryString || replaceQueryString, ignoreFragmentWhenComparing);
+      if (requestedCompare == browserCompare) {
+        // If adoptIntoActiveWindow is set, and this is a cross-window switch,
+        // adopt the tab into the current window, after the active tab.
+        let doAdopt = adoptIntoActiveWindow && isBrowserWindow && aWindow != window;
+
+        if (doAdopt) {
+          window.gBrowser.adoptTab(
+            aWindow.gBrowser.getTabForBrowser(browser),
+            window.gBrowser.tabContainer.selectedIndex + 1,
+            /* aSelectTab = */ true
+          );
+        } else {
+          aWindow.focus();
+        }
+
+        if (ignoreFragment == "whenComparingAndReplace" || replaceQueryString) {
+          browser.loadURI(aURI.spec);
+        }
+
+        if (!doAdopt) {
+          aWindow.gBrowser.tabContainer.selectedIndex = i;
+        }
+
+        return true;
+      }
+    }
+    return false;
+  }
+
+  // This can be passed either nsIURI or a string.
+  if (!(aURI instanceof Ci.nsIURI))
+    aURI = Services.io.newURI(aURI);
+
+  // Prioritise this window.
+  if (isBrowserWindow && switchIfURIInWindow(window))
+    return true;
+
+  for (let browserWin of browserWindows()) {
+    // Skip closed (but not yet destroyed) windows,
+    // and the current window (which was checked earlier).
+    if (browserWin.closed || browserWin == window)
+      continue;
+    if (switchIfURIInWindow(browserWin))
+      return true;
+  }
+
+  // No opened tab has that url.
+  if (aOpenNew) {
+    if (isBrowserWindow && isTabEmpty(gBrowser.selectedTab))
+      openUILinkIn(aURI.spec, "current", aOpenParams);
+    else
+      openUILinkIn(aURI.spec, "tab", aOpenParams);
+  }
+
+  return false;
+}
+
+var RestoreLastSessionObserver = {
+  init() {
+    let browser_tabs_restorebutton_pref = Services.prefs.getIntPref("browser.tabs.restorebutton");
+    Services.telemetry.scalarSet("browser.session.restore.browser_tabs_restorebutton", browser_tabs_restorebutton_pref);
+    Services.telemetry.scalarSet("browser.session.restore.browser_startup_page", Services.prefs.getIntPref("browser.startup.page"));
+    if (SessionStore.canRestoreLastSession &&
+        !PrivateBrowsingUtils.isWindowPrivate(window)) {
+      if (browser_tabs_restorebutton_pref == 1) {
+        let {restoreTabsButton, restoreTabsButtonWrapperWidth} = gBrowser.tabContainer;
+        let restoreTabsButtonWrapper = restoreTabsButton.parentNode;
+        restoreTabsButtonWrapper.setAttribute("session-exists", "true");
+        gBrowser.tabContainer.updateSessionRestoreVisibility();
+        restoreTabsButton.style.maxWidth = `${restoreTabsButtonWrapperWidth}px`;
+        gBrowser.tabContainer.addEventListener("TabOpen", this);
+        Services.telemetry.scalarSet("browser.session.restore.tabbar_restore_available", true);
+        restoreTabsButton.addEventListener("click", () => {
+          Services.telemetry.scalarSet("browser.session.restore.tabbar_restore_clicked", true);
+        });
+      }
+      Services.obs.addObserver(this, "sessionstore-last-session-cleared", true);
+      goSetCommandEnabled("Browser:RestoreLastSession", true);
+    } else if (SessionStartup.isAutomaticRestoreEnabled()) {
+      document.getElementById("Browser:RestoreLastSession").setAttribute("hidden", true);
+    }
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+     case "TabOpen":
+        this.removeRestoreButton();
+        break;
+    }
+  },
+
+  removeRestoreButton() {
+    let {restoreTabsButton} = gBrowser.tabContainer;
+    let restoreTabsButtonWrapper = restoreTabsButton.parentNode;
+    gBrowser.tabContainer.addEventListener("transitionend", function maxWidthTransitionHandler(e) {
+      if (e.target == gBrowser.tabContainer && e.propertyName == "max-width") {
+        gBrowser.tabContainer.updateSessionRestoreVisibility();
+        gBrowser.tabContainer.removeEventListener("transitionend", maxWidthTransitionHandler);
+      }
+    });
+    restoreTabsButtonWrapper.removeAttribute("session-exists");
+    restoreTabsButton.style.maxWidth = 0;
+    gBrowser.tabContainer.removeEventListener("TabOpen", this);
+  },
+
+  observe() {
+    // The last session can only be restored once so there's
+    // no way we need to re-enable our menu item.
+    Services.obs.removeObserver(this, "sessionstore-last-session-cleared");
+    goSetCommandEnabled("Browser:RestoreLastSession", false);
+    this.removeRestoreButton();
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
+                                         Ci.nsISupportsWeakReference])
+};
+
+function restoreLastSession() {
+  SessionStore.restoreLastSession();
+}
+
+/* Observes menus and adjusts their size for better
+ * usability when opened via a touch screen. */
+var MenuTouchModeObserver = {
+  init() {
+    window.addEventListener("popupshowing", this, true);
+  },
+
+  handleEvent(event) {
+    let target = event.originalTarget;
+    if (event.mozInputSource == MouseEvent.MOZ_SOURCE_TOUCH) {
+      target.setAttribute("touchmode", "true");
+    } else {
+      target.removeAttribute("touchmode");
+    }
+  },
+
+  uninit() {
+    window.removeEventListener("popupshowing", this, true);
+  },
+};
+
+var TabContextMenu = {
+  contextTab: null,
+  _updateToggleMuteMenuItem(aTab, aConditionFn) {
+    ["muted", "soundplaying"].forEach(attr => {
+      if (!aConditionFn || aConditionFn(attr)) {
+        if (aTab.hasAttribute(attr)) {
+          aTab.toggleMuteMenuItem.setAttribute(attr, "true");
+        } else {
+          aTab.toggleMuteMenuItem.removeAttribute(attr);
+        }
+      }
+    });
+  },
+  updateContextMenu: function updateContextMenu(aPopupMenu) {
+    this.contextTab = aPopupMenu.triggerNode.localName == "tab" ?
+                      aPopupMenu.triggerNode : gBrowser.selectedTab;
+    let disabled = gBrowser.tabs.length == 1;
+
+    var menuItems = aPopupMenu.getElementsByAttribute("tbattr", "tabbrowser-multiple");
+    for (let menuItem of menuItems)
+      menuItem.disabled = disabled;
+
+    if (this.contextTab.hasAttribute("customizemode"))
+      document.getElementById("context_openTabInWindow").disabled = true;
+
+    disabled = gBrowser.visibleTabs.length == 1;
+    menuItems = aPopupMenu.getElementsByAttribute("tbattr", "tabbrowser-multiple-visible");
+    for (let menuItem of menuItems)
+      menuItem.disabled = disabled;
+
+    // Session store
+    document.getElementById("context_undoCloseTab").disabled =
+      SessionStore.getClosedTabCount(window) == 0;
+
+    // Only one of pin/unpin should be visible
+    document.getElementById("context_pinTab").hidden = this.contextTab.pinned;
+    document.getElementById("context_unpinTab").hidden = !this.contextTab.pinned;
+
+    // Disable "Close Tabs to the Right" if there are no tabs
+    // following it.
+    document.getElementById("context_closeTabsToTheEnd").disabled =
+      gBrowser.getTabsToTheEndFrom(this.contextTab).length == 0;
+
+    // Disable "Close other Tabs" if there are no unpinned tabs.
+    let unpinnedTabsToClose = gBrowser.visibleTabs.length - gBrowser._numPinnedTabs;
+    if (!this.contextTab.pinned) {
+      unpinnedTabsToClose--;
+    }
+    document.getElementById("context_closeOtherTabs").disabled = unpinnedTabsToClose < 1;
+
+    // Hide "Bookmark All Tabs" for a pinned tab.  Update its state if visible.
+    let bookmarkAllTabs = document.getElementById("context_bookmarkAllTabs");
+    bookmarkAllTabs.hidden = this.contextTab.pinned;
+    if (!bookmarkAllTabs.hidden)
+      PlacesCommandHook.updateBookmarkAllTabsCommand();
+
+    // Adjust the state of the toggle mute menu item.
+    let toggleMute = document.getElementById("context_toggleMuteTab");
+    if (this.contextTab.hasAttribute("activemedia-blocked")) {
+      toggleMute.label = gNavigatorBundle.getString("playTab.label");
+      toggleMute.accessKey = gNavigatorBundle.getString("playTab.accesskey");
+    } else if (this.contextTab.hasAttribute("muted")) {
+      toggleMute.label = gNavigatorBundle.getString("unmuteTab.label");
+      toggleMute.accessKey = gNavigatorBundle.getString("unmuteTab.accesskey");
+    } else {
+      toggleMute.label = gNavigatorBundle.getString("muteTab.label");
+      toggleMute.accessKey = gNavigatorBundle.getString("muteTab.accesskey");
+    }
+
+    this.contextTab.toggleMuteMenuItem = toggleMute;
+    this._updateToggleMuteMenuItem(this.contextTab);
+
+    this.contextTab.addEventListener("TabAttrModified", this);
+    aPopupMenu.addEventListener("popuphiding", this);
+
+    gSync.updateTabContextMenu(aPopupMenu, this.contextTab);
+  },
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "popuphiding":
+        gBrowser.removeEventListener("TabAttrModified", this);
+        aEvent.target.removeEventListener("popuphiding", this);
+        break;
+      case "TabAttrModified":
+        let tab = aEvent.target;
+        this._updateToggleMuteMenuItem(tab,
+          attr => aEvent.detail.changed.indexOf(attr) >= 0);
+        break;
+    }
+  }
+};
+
+// Prompt user to restart the browser in safe mode
+function safeModeRestart() {
+  if (Services.appinfo.inSafeMode) {
+    let cancelQuit = Cc["@mozilla.org/supports-PRBool;1"].
+                     createInstance(Ci.nsISupportsPRBool);
+    Services.obs.notifyObservers(cancelQuit, "quit-application-requested", "restart");
+
+    if (cancelQuit.data)
+      return;
+
+    Services.startup.quit(Ci.nsIAppStartup.eRestart | Ci.nsIAppStartup.eAttemptQuit);
+    return;
+  }
+
+  Services.obs.notifyObservers(null, "restart-in-safe-mode");
+}
+
+/* duplicateTabIn duplicates tab in a place specified by the parameter |where|.
+ *
+ * |where| can be:
+ *  "tab"         new tab
+ *  "tabshifted"  same as "tab" but in background if default is to select new
+ *                tabs, and vice versa
+ *  "window"      new window
+ *
+ * delta is the offset to the history entry that you want to load.
+ */
+function duplicateTabIn(aTab, where, delta) {
+  switch (where) {
+    case "window":
+      let otherWin = OpenBrowserWindow();
+      let delayedStartupFinished = (subject, topic) => {
+        if (topic == "browser-delayed-startup-finished" &&
+            subject == otherWin) {
+          Services.obs.removeObserver(delayedStartupFinished, topic);
+          let otherGBrowser = otherWin.gBrowser;
+          let otherTab = otherGBrowser.selectedTab;
+          SessionStore.duplicateTab(otherWin, aTab, delta);
+          otherGBrowser.removeTab(otherTab, { animate: false });
+        }
+      };
+
+      Services.obs.addObserver(delayedStartupFinished,
+                               "browser-delayed-startup-finished");
+      break;
+    case "tabshifted":
+      SessionStore.duplicateTab(window, aTab, delta);
+      // A background tab has been opened, nothing else to do here.
+      break;
+    case "tab":
+      let newTab = SessionStore.duplicateTab(window, aTab, delta);
+      gBrowser.selectedTab = newTab;
+      break;
+  }
+}
+
+var MousePosTracker = {
+  _listeners: new Set(),
+  _x: 0,
+  _y: 0,
+  get _windowUtils() {
+    delete this._windowUtils;
+    return this._windowUtils = window.getInterface(Ci.nsIDOMWindowUtils);
+  },
+
+  addListener(listener) {
+    if (this._listeners.has(listener))
+      return;
+
+    listener._hover = false;
+    this._listeners.add(listener);
+
+    this._callListener(listener);
+  },
+
+  removeListener(listener) {
+    this._listeners.delete(listener);
+  },
+
+  handleEvent(event) {
+    var fullZoom = this._windowUtils.fullZoom;
+    this._x = event.screenX / fullZoom - window.mozInnerScreenX;
+    this._y = event.screenY / fullZoom - window.mozInnerScreenY;
+
+    this._listeners.forEach(function(listener) {
+      try {
+        this._callListener(listener);
+      } catch (e) {
+        Cu.reportError(e);
+      }
+    }, this);
+  },
+
+  _callListener(listener) {
+    let rect = listener.getMouseTargetRect();
+    let hover = this._x >= rect.left &&
+                this._x <= rect.right &&
+                this._y >= rect.top &&
+                this._y <= rect.bottom;
+
+    if (hover == listener._hover)
+      return;
+
+    listener._hover = hover;
+
+    if (hover) {
+      if (listener.onMouseEnter)
+        listener.onMouseEnter();
+    } else if (listener.onMouseLeave) {
+      listener.onMouseLeave();
+    }
+  }
+};
+
+var ToolbarIconColor = {
+  _windowState: {
+    "active": false,
+    "fullscreen": false,
+    "tabsintitlebar": false
+  },
+  init() {
+    this._initialized = true;
+
+    window.addEventListener("activate", this);
+    window.addEventListener("deactivate", this);
+    window.addEventListener("toolbarvisibilitychange", this);
+    Services.obs.addObserver(this, "lightweight-theme-styling-update");
+
+    // If the window isn't active now, we assume that it has never been active
+    // before and will soon become active such that inferFromText will be
+    // called from the initial activate event.
+    if (Services.focus.activeWindow == window) {
+      this.inferFromText("activate");
+    }
+  },
+
+  uninit() {
+    this._initialized = false;
+
+    window.removeEventListener("activate", this);
+    window.removeEventListener("deactivate", this);
+    window.removeEventListener("toolbarvisibilitychange", this);
+    Services.obs.removeObserver(this, "lightweight-theme-styling-update");
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "activate": // falls through
+      case "deactivate":
+        this.inferFromText(event.type);
+        break;
+      case "toolbarvisibilitychange":
+        this.inferFromText(event.type, event.visible);
+        break;
+    }
+  },
+
+  observe(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "lightweight-theme-styling-update":
+        // inferFromText needs to run after LightweightThemeConsumer.jsm's
+        // lightweight-theme-styling-update observer.
+        setTimeout(() => {
+          this.inferFromText(aTopic);
+        }, 0);
+        break;
+    }
+  },
+
+  // a cache of luminance values for each toolbar
+  // to avoid unnecessary calls to getComputedStyle
+  _toolbarLuminanceCache: new Map(),
+
+  inferFromText(reason, reasonValue) {
+    if (!this._initialized)
+      return;
+    function parseRGB(aColorString) {
+      let rgb = aColorString.match(/^rgba?\((\d+), (\d+), (\d+)/);
+      rgb.shift();
+      return rgb.map(x => parseInt(x));
+    }
+
+    switch (reason) {
+      case "activate": // falls through
+      case "deactivate":
+        this._windowState.active = (reason === "activate");
+        break;
+      case "fullscreen":
+        this._windowState.fullscreen = reasonValue;
+        break;
+      case "lightweight-theme-styling-update":
+        // theme change, we'll need to recalculate all color values
+        this._toolbarLuminanceCache.clear();
+        break;
+      case "toolbarvisibilitychange":
+        // toolbar changes dont require reset of the cached color values
+        break;
+      case "tabsintitlebar":
+        this._windowState.tabsintitlebar = reasonValue;
+        break;
+    }
+
+    let toolbarSelector = "#navigator-toolbox > toolbar:not([collapsed=true])";
+    if (AppConstants.platform == "macosx")
+      toolbarSelector += ":not([type=menubar])";
+
+    // The getComputedStyle calls and setting the brighttext are separated in
+    // two loops to avoid flushing layout and making it dirty repeatedly.
+    let cachedLuminances = this._toolbarLuminanceCache;
+    let luminances = new Map();
+    for (let toolbar of document.querySelectorAll(toolbarSelector)) {
+      // toolbars *should* all have ids, but guard anyway to avoid blowing up
+      let cacheKey = toolbar.id && toolbar.id + JSON.stringify(this._windowState);
+      // lookup cached luminance value for this toolbar in this window state
+      let luminance = cacheKey && cachedLuminances.get(cacheKey);
+      if (isNaN(luminance)) {
+        let [r, g, b] = parseRGB(getComputedStyle(toolbar).color);
+        luminance = 0.2125 * r + 0.7154 * g + 0.0721 * b;
+        if (cacheKey) {
+          cachedLuminances.set(cacheKey, luminance);
+        }
+      }
+      luminances.set(toolbar, luminance);
+    }
+
+    for (let [toolbar, luminance] of luminances) {
+      if (luminance <= 110)
+        toolbar.removeAttribute("brighttext");
+      else
+        toolbar.setAttribute("brighttext", "true");
+    }
+  }
+};
+
+var PanicButtonNotifier = {
+  init() {
+    this._initialized = true;
+    if (window.PanicButtonNotifierShouldNotify) {
+      delete window.PanicButtonNotifierShouldNotify;
+      this.notify();
+    }
+  },
+  notify() {
+    if (!this._initialized) {
+      window.PanicButtonNotifierShouldNotify = true;
+      return;
+    }
+    // Display notification panel here...
+    try {
+      let popup = document.getElementById("panic-button-success-notification");
+      popup.hidden = false;
+      // To close the popup in 3 seconds after the popup is shown but left uninteracted.
+      let onTimeout = () => {
+        PanicButtonNotifier.close();
+        removeListeners();
+      };
+      popup.addEventListener("popupshown", function() {
+        PanicButtonNotifier.timer = setTimeout(onTimeout, 3000);
+      });
+      // To prevent the popup from closing when user tries to interact with the
+      // popup using mouse or keyboard.
+      let onUserInteractsWithPopup = () => {
+        clearTimeout(PanicButtonNotifier.timer);
+        removeListeners();
+       };
+      popup.addEventListener("mouseover", onUserInteractsWithPopup);
+      window.addEventListener("keydown", onUserInteractsWithPopup);
+      let removeListeners = () => {
+        popup.removeEventListener("mouseover", onUserInteractsWithPopup);
+        window.removeEventListener("keydown", onUserInteractsWithPopup);
+        popup.removeEventListener("popuphidden", removeListeners);
+      };
+      popup.addEventListener("popuphidden", removeListeners);
+
+      let widget = CustomizableUI.getWidget("panic-button").forWindow(window);
+      let anchor = widget.anchor;
+      anchor = document.getAnonymousElementByAttribute(anchor, "class", "toolbarbutton-icon");
+      popup.openPopup(anchor, popup.getAttribute("position"));
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+  },
+  close() {
+    let popup = document.getElementById("panic-button-success-notification");
+    popup.hidePopup();
+  },
+};
+
+var AboutPrivateBrowsingListener = {
+  init() {
+    window.messageManager.addMessageListener(
+      "AboutPrivateBrowsing:OpenPrivateWindow",
+      msg => {
+        OpenBrowserWindow({private: true});
+    });
+    window.messageManager.addMessageListener(
+      "AboutPrivateBrowsing:ToggleTrackingProtection",
+      msg => {
+        const PREF = "privacy.trackingprotection.pbmode.enabled";
+        Services.prefs.setBoolPref(PREF, !Services.prefs.getBoolPref(PREF));
+    });
+    window.messageManager.addMessageListener(
+      "AboutPrivateBrowsing:DontShowIntroPanelAgain",
+      msg => {
+        TrackingProtection.dontShowIntroPanelAgain();
+    });
+  }
+};
+
+function TabModalPromptBox(browser) {
+  this._weakBrowserRef = Cu.getWeakReference(browser);
+}
+
+TabModalPromptBox.prototype = {
+  _promptCloseCallback(onCloseCallback, principalToAllowFocusFor, allowFocusCheckbox, ...args) {
+    if (principalToAllowFocusFor && allowFocusCheckbox &&
+        allowFocusCheckbox.checked) {
+      Services.perms.addFromPrincipal(principalToAllowFocusFor, "focus-tab-by-prompt",
+                                      Services.perms.ALLOW_ACTION);
+    }
+    onCloseCallback.apply(this, args);
+  },
+
+  appendPrompt(args, onCloseCallback) {
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    let newPrompt = document.createElementNS(XUL_NS, "tabmodalprompt");
+    let browser = this.browser;
+    browser.parentNode.insertBefore(newPrompt, browser.nextSibling);
+    browser.setAttribute("tabmodalPromptShowing", true);
+
+    newPrompt.clientTop; // style flush to assure binding is attached
+
+    let prompts = this.listPrompts();
+    if (prompts.length > 1) {
+      // Let's hide ourself behind the current prompt.
+      newPrompt.hidden = true;
+    }
+
+    let principalToAllowFocusFor = this._allowTabFocusByPromptPrincipal;
+    delete this._allowTabFocusByPromptPrincipal;
+
+    let allowFocusCheckbox; // Define outside the if block so we can bind it into the callback.
+    let hostForAllowFocusCheckbox = "";
+    try {
+      hostForAllowFocusCheckbox = principalToAllowFocusFor.URI.host;
+    } catch (ex) { /* Ignore exceptions for host-less URIs */ }
+    if (hostForAllowFocusCheckbox) {
+      let allowFocusRow = document.createElementNS(XUL_NS, "row");
+      allowFocusCheckbox = document.createElementNS(XUL_NS, "checkbox");
+      let spacer = document.createElementNS(XUL_NS, "spacer");
+      allowFocusRow.appendChild(spacer);
+      let label = gTabBrowserBundle.formatStringFromName("tabs.allowTabFocusByPromptForSite",
+                                                      [hostForAllowFocusCheckbox], 1);
+      allowFocusCheckbox.setAttribute("label", label);
+      allowFocusRow.appendChild(allowFocusCheckbox);
+      newPrompt.appendChild(allowFocusRow);
+    }
+
+    let tab = gBrowser.getTabForBrowser(browser);
+    let closeCB = this._promptCloseCallback.bind(null, onCloseCallback, principalToAllowFocusFor,
+                                                 allowFocusCheckbox);
+    newPrompt.init(args, tab, closeCB);
+    return newPrompt;
+  },
+
+  removePrompt(aPrompt) {
+    let browser = this.browser;
+    browser.parentNode.removeChild(aPrompt);
+
+    let prompts = this.listPrompts();
+    if (prompts.length) {
+      let prompt = prompts[prompts.length - 1];
+      prompt.hidden = false;
+      prompt.Dialog.setDefaultFocus();
+    } else {
+      browser.removeAttribute("tabmodalPromptShowing");
+      browser.focus();
+    }
+  },
+
+  listPrompts(aPrompt) {
+    // Get the nodelist, then return as an array
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    let els = this.browser.parentNode.getElementsByTagNameNS(XUL_NS, "tabmodalprompt");
+    return Array.from(els);
+  },
+
+  onNextPromptShowAllowFocusCheckboxFor(principal) {
+    this._allowTabFocusByPromptPrincipal = principal;
+  },
+
+  get browser() {
+    let browser = this._weakBrowserRef.get();
+    if (!browser) {
+      throw "Stale promptbox! The associated browser is gone.";
+    }
+    return browser;
+  },
+};
+
+
+/***/ }),
+/* 2 */
+/***/ (function(module, exports) {
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+XPCOMUtils.defineLazyServiceGetter(this, "cps",
+                                   "@mozilla.org/network/captive-portal-service;1",
+                                   "nsICaptivePortalService");
+
+var CaptivePortalWatcher = {
+  /**
+   * This constant is chosen to be large enough for a portal recheck to complete,
+   * and small enough that the delay in opening a tab isn't too noticeable.
+   * Please see comments for _delayedCaptivePortalDetected for more details.
+   */
+  PORTAL_RECHECK_DELAY_MS: Services.prefs.getIntPref("captivedetect.portalRecheckDelayMS", 500),
+
+  // This is the value used to identify the captive portal notification.
+  PORTAL_NOTIFICATION_VALUE: "captive-portal-detected",
+
+  // This holds a weak reference to the captive portal tab so that we
+  // don't leak it if the user closes it.
+  _captivePortalTab: null,
+
+  /**
+   * If a portal is detected when we don't have focus, we first wait for focus
+   * and then add the tab if, after a recheck, the portal is still active. This
+   * is set to true while we wait so that in the unlikely event that we receive
+   * another notification while waiting, we don't do things twice.
+   */
+  _delayedCaptivePortalDetectedInProgress: false,
+
+  // In the situation above, this is set to true while we wait for the recheck.
+  // This flag exists so that tests can appropriately simulate a recheck.
+  _waitingForRecheck: false,
+
+  get _captivePortalNotification() {
+    let nb = document.getElementById("high-priority-global-notificationbox");
+    return nb.getNotificationWithValue(this.PORTAL_NOTIFICATION_VALUE);
+  },
+
+  get canonicalURL() {
+    return Services.prefs.getCharPref("captivedetect.canonicalURL");
+  },
+
+  get _browserBundle() {
+    delete this._browserBundle;
+    return this._browserBundle =
+      Services.strings.createBundle("chrome://browser/locale/browser.properties");
+  },
+
+  init() {
+    Services.obs.addObserver(this, "captive-portal-login");
+    Services.obs.addObserver(this, "captive-portal-login-abort");
+    Services.obs.addObserver(this, "captive-portal-login-success");
+
+    if (cps.state == cps.LOCKED_PORTAL) {
+      // A captive portal has already been detected.
+      this._captivePortalDetected();
+
+      // Automatically open a captive portal tab if there's no other browser window.
+      let windows = Services.wm.getEnumerator("navigator:browser");
+      if (windows.getNext() == window && !windows.hasMoreElements()) {
+        this.ensureCaptivePortalTab();
+      }
+    } else if (cps.state == cps.UNKNOWN) {
+      // We trigger a portal check after delayed startup to avoid doing a network
+      // request before first paint.
+      this._delayedRecheckPending = true;
+      Services.obs.addObserver(this, "browser-delayed-startup-finished");
+    }
+
+    XPCOMUtils.defineLazyPreferenceGetter(this, "PORTAL_RECHECK_DELAY_MS",
+                                          "captivedetect.portalRecheckDelayMS", 500);
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, "captive-portal-login");
+    Services.obs.removeObserver(this, "captive-portal-login-abort");
+    Services.obs.removeObserver(this, "captive-portal-login-success");
+
+    if (this._delayedRecheckPending) {
+      Services.obs.removeObserver(this, "browser-delayed-startup-finished");
+    }
+
+    if (this._delayedCaptivePortalDetectedInProgress) {
+      Services.obs.removeObserver(this, "xul-window-visible");
+    }
+  },
+
+  observe(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "browser-delayed-startup-finished":
+        Services.obs.removeObserver(this, "browser-delayed-startup-finished");
+        delete this._delayedRecheckPending;
+        cps.recheckCaptivePortal();
+        break;
+      case "captive-portal-login":
+        this._captivePortalDetected();
+        break;
+      case "captive-portal-login-abort":
+      case "captive-portal-login-success":
+        this._captivePortalGone();
+        break;
+      case "xul-window-visible":
+        this._delayedCaptivePortalDetected();
+        break;
+    }
+  },
+
+  _captivePortalDetected() {
+    if (this._delayedCaptivePortalDetectedInProgress) {
+      return;
+    }
+
+    let win = RecentWindow.getMostRecentBrowserWindow();
+    // If no browser window has focus, open and show the tab when we regain focus.
+    // This is so that if a different application was focused, when the user
+    // (re-)focuses a browser window, we open the tab immediately in that window
+    // so they can log in before continuing to browse.
+    if (win != Services.ww.activeWindow) {
+      this._delayedCaptivePortalDetectedInProgress = true;
+      Services.obs.addObserver(this, "xul-window-visible");
+    }
+
+    this._showNotification();
+  },
+
+  /**
+   * Called after we regain focus if we detect a portal while a browser window
+   * doesn't have focus. Triggers a portal recheck to reaffirm state, and adds
+   * the tab if needed after a short delay to allow the recheck to complete.
+   */
+  _delayedCaptivePortalDetected() {
+    if (!this._delayedCaptivePortalDetectedInProgress) {
+      return;
+    }
+
+    let win = RecentWindow.getMostRecentBrowserWindow();
+    if (win != Services.ww.activeWindow) {
+      // The window that got focused was not a browser window.
+      return;
+    }
+    Services.obs.removeObserver(this, "xul-window-visible");
+    this._delayedCaptivePortalDetectedInProgress = false;
+
+    if (win != window) {
+      // Some other browser window got focus, we don't have to do anything.
+      return;
+    }
+    // Trigger a portal recheck. The user may have logged into the portal via
+    // another client, or changed networks.
+    cps.recheckCaptivePortal();
+    this._waitingForRecheck = true;
+    let requestTime = Date.now();
+
+    let self = this;
+    Services.obs.addObserver(function observer() {
+      let time = Date.now() - requestTime;
+      Services.obs.removeObserver(observer, "captive-portal-check-complete");
+      self._waitingForRecheck = false;
+      if (cps.state != cps.LOCKED_PORTAL) {
+        // We're free of the portal!
+        return;
+      }
+
+      if (time <= self.PORTAL_RECHECK_DELAY_MS) {
+        // The amount of time elapsed since we requested a recheck (i.e. since
+        // the browser window was focused) was small enough that we can add and
+        // focus a tab with the login page with no noticeable delay.
+        self.ensureCaptivePortalTab();
+      }
+    }, "captive-portal-check-complete");
+  },
+
+  _captivePortalGone() {
+    if (this._delayedCaptivePortalDetectedInProgress) {
+      Services.obs.removeObserver(this, "xul-window-visible");
+      this._delayedCaptivePortalDetectedInProgress = false;
+    }
+
+    this._removeNotification();
+  },
+
+  handleEvent(aEvent) {
+    if (aEvent.type != "TabSelect" || !this._captivePortalTab || !this._captivePortalNotification) {
+      return;
+    }
+
+    let tab = this._captivePortalTab.get();
+    let n = this._captivePortalNotification;
+    if (!tab || !n) {
+      return;
+    }
+
+    let doc = tab.ownerDocument;
+    let button = n.querySelector("button.notification-button");
+    if (doc.defaultView.gBrowser.selectedTab == tab) {
+      button.style.visibility = "hidden";
+    } else {
+      button.style.visibility = "visible";
+    }
+  },
+
+  _showNotification() {
+    let buttons = [
+      {
+        label: this._browserBundle.GetStringFromName("captivePortal.showLoginPage2"),
+        callback: () => {
+          this.ensureCaptivePortalTab();
+
+          // Returning true prevents the notification from closing.
+          return true;
+        },
+        isDefault: true,
+      },
+    ];
+
+    let message = this._browserBundle.GetStringFromName("captivePortal.infoMessage3");
+
+    let closeHandler = (aEventName) => {
+      if (aEventName != "removed") {
+        return;
+      }
+      gBrowser.tabContainer.removeEventListener("TabSelect", this);
+    };
+
+    let nb = document.getElementById("high-priority-global-notificationbox");
+    nb.appendNotification(message, this.PORTAL_NOTIFICATION_VALUE, "",
+                          nb.PRIORITY_INFO_MEDIUM, buttons, closeHandler);
+
+    gBrowser.tabContainer.addEventListener("TabSelect", this);
+  },
+
+  _removeNotification() {
+    let n = this._captivePortalNotification;
+    if (!n || !n.parentNode) {
+      return;
+    }
+    n.close();
+  },
+
+  ensureCaptivePortalTab() {
+    let tab;
+    if (this._captivePortalTab) {
+      tab = this._captivePortalTab.get();
+    }
+
+    // If the tab is gone or going, we need to open a new one.
+    if (!tab || tab.closing || !tab.parentNode) {
+      tab = gBrowser.addTab(this.canonicalURL, { ownerTab: gBrowser.selectedTab });
+      this._captivePortalTab = Cu.getWeakReference(tab);
+    }
+
+    gBrowser.selectedTab = tab;
+
+    let canonicalURI = makeURI(this.canonicalURL);
+
+    // When we are no longer captive, close the tab if it's at the canonical URL.
+    let tabCloser = () => {
+      Services.obs.removeObserver(tabCloser, "captive-portal-login-abort");
+      Services.obs.removeObserver(tabCloser, "captive-portal-login-success");
+      if (!tab || tab.closing || !tab.parentNode || !tab.linkedBrowser ||
+          !tab.linkedBrowser.currentURI.equalsExceptRef(canonicalURI)) {
+        return;
+      }
+      gBrowser.removeTab(tab);
+    };
+    Services.obs.addObserver(tabCloser, "captive-portal-login-abort");
+    Services.obs.addObserver(tabCloser, "captive-portal-login-success");
+  },
+};
+
+
+/***/ }),
+/* 3 */
+/***/ (function(module, exports) {
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * Listeners for the compact theme.  This adds an extra stylesheet
+ * to browser.xul if a pref is set and no other themes are applied.
+ */
+var CompactTheme = {
+  styleSheetLocation: "chrome://browser/skin/compacttheme.css",
+  styleSheet: null,
+
+  get isStyleSheetEnabled() {
+    return this.styleSheet && !this.styleSheet.sheet.disabled;
+  },
+
+  get isThemeCurrentlyApplied() {
+    let theme = LightweightThemeManager.currentTheme;
+    return theme && (
+           theme.id == "firefox-compact-dark@mozilla.org" ||
+           theme.id == "firefox-compact-light@mozilla.org");
+  },
+
+  init() {
+    Services.obs.addObserver(this, "lightweight-theme-styling-update");
+
+    if (this.isThemeCurrentlyApplied) {
+      this._toggleStyleSheet(true);
+    }
+  },
+
+  createStyleSheet() {
+    let styleSheetAttr = `href="${this.styleSheetLocation}" type="text/css"`;
+    this.styleSheet = document.createProcessingInstruction(
+      "xml-stylesheet", styleSheetAttr);
+    document.insertBefore(this.styleSheet, document.documentElement);
+    this.styleSheet.sheet.disabled = true;
+  },
+
+  observe(subject, topic, data) {
+    if (topic == "lightweight-theme-styling-update") {
+      let newTheme = JSON.parse(data);
+      if (newTheme && (
+          newTheme.id == "firefox-compact-light@mozilla.org" ||
+          newTheme.id == "firefox-compact-dark@mozilla.org")) {
+        // We are using the theme ID on this object instead of always referencing
+        // LightweightThemeManager.currentTheme in case this is a preview
+        this._toggleStyleSheet(true);
+      } else {
+        this._toggleStyleSheet(false);
+      }
+
+    }
+  },
+
+  _toggleStyleSheet(enabled) {
+    let wasEnabled = this.isStyleSheetEnabled;
+    if (enabled) {
+      // The stylesheet may not have been created yet if it wasn't
+      // needed on initial load.  Make it now.
+      if (!this.styleSheet) {
+        this.createStyleSheet();
+      }
+      this.styleSheet.sheet.disabled = false;
+    } else if (!enabled && wasEnabled) {
+      this.styleSheet.sheet.disabled = true;
+    }
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, "lightweight-theme-styling-update");
+    this.styleSheet = null;
+  }
+};
+
+// If the compact theme is going to be applied in gBrowserInit.onLoad,
+// then preload it now.  This prevents a flash of unstyled content where the
+// normal theme is applied while the compact theme stylesheet is loading.
+if (this != Services.appShell.hiddenDOMWindow && CompactTheme.isThemeCurrentlyApplied) {
+  CompactTheme.createStyleSheet();
+}
+
+
+/***/ }),
+/* 4 */
+/***/ (function(module, exports) {
+
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+XPCOMUtils.defineLazyModuleGetter(this, "DeferredTask",
+                                  "resource://gre/modules/DeferredTask.jsm");
+
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const TYPE_MAYBE_AUDIO_FEED = "application/vnd.mozilla.maybe.audio.feed";
+const TYPE_MAYBE_VIDEO_FEED = "application/vnd.mozilla.maybe.video.feed";
+
+const PREF_SHOW_FIRST_RUN_UI = "browser.feeds.showFirstRunUI";
+
+const PREF_SELECTED_APP = "browser.feeds.handlers.application";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+
+const PREF_VIDEO_SELECTED_APP = "browser.videoFeeds.handlers.application";
+const PREF_VIDEO_SELECTED_WEB = "browser.videoFeeds.handlers.webservice";
+const PREF_VIDEO_SELECTED_ACTION = "browser.videoFeeds.handler";
+const PREF_VIDEO_SELECTED_READER = "browser.videoFeeds.handler.default";
+
+const PREF_AUDIO_SELECTED_APP = "browser.audioFeeds.handlers.application";
+const PREF_AUDIO_SELECTED_WEB = "browser.audioFeeds.handlers.webservice";
+const PREF_AUDIO_SELECTED_ACTION = "browser.audioFeeds.handler";
+const PREF_AUDIO_SELECTED_READER = "browser.audioFeeds.handler.default";
+
+const PREF_UPDATE_DELAY = 2000;
+
+const SETTABLE_PREFS = new Set([
+  PREF_VIDEO_SELECTED_ACTION,
+  PREF_AUDIO_SELECTED_ACTION,
+  PREF_SELECTED_ACTION,
+  PREF_VIDEO_SELECTED_READER,
+  PREF_AUDIO_SELECTED_READER,
+  PREF_SELECTED_READER,
+  PREF_VIDEO_SELECTED_WEB,
+  PREF_AUDIO_SELECTED_WEB,
+  PREF_SELECTED_WEB
+]);
+
+const EXECUTABLE_PREFS = new Set([
+  PREF_SELECTED_APP,
+  PREF_VIDEO_SELECTED_APP,
+  PREF_AUDIO_SELECTED_APP
+]);
+
+const VALID_ACTIONS = new Set(["ask", "reader", "bookmarks"]);
+const VALID_READERS = new Set(["web", "client", "default", "bookmarks"]);
+
+XPCOMUtils.defineLazyPreferenceGetter(this, "SHOULD_LOG",
+                                      "feeds.log", false);
+
+function LOG(str) {
+  if (SHOULD_LOG)
+    dump("*** Feeds: " + str + "\n");
+}
+
+function getPrefActionForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_ACTION;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_ACTION;
+
+    default:
+      return PREF_SELECTED_ACTION;
+  }
+}
+
+function getPrefReaderForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_READER;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_READER;
+
+    default:
+      return PREF_SELECTED_READER;
+  }
+}
+
+function getPrefWebForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_WEB;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_WEB;
+
+    default:
+      return PREF_SELECTED_WEB;
+  }
+}
+
+function getPrefAppForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_APP;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_APP;
+
+    default:
+      return PREF_SELECTED_APP;
+  }
+}
+
+/**
+ * Maps a feed type to a maybe-feed mimetype.
+ */
+function getMimeTypeForFeedType(aFeedType) {
+  switch (aFeedType) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return TYPE_MAYBE_VIDEO_FEED;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return TYPE_MAYBE_AUDIO_FEED;
+
+    default:
+      return TYPE_MAYBE_FEED;
+  }
+}
+
+/**
+ * The Feed Handler object manages discovery of RSS/ATOM feeds in web pages
+ * and shows UI when they are discovered.
+ */
+var FeedHandler = {
+  _prefChangeCallback: null,
+
+  /** Called when the user clicks on the Subscribe to This Page... menu item,
+   * or when the user clicks the feed button when the page contains multiple
+   * feeds.
+   * Builds a menu of unique feeds associated with the page, and if there
+   * is only one, shows the feed inline in the browser window.
+   * @param   container
+   *          The feed list container (menupopup or subview) to be populated.
+   * @param   isSubview
+   *          Whether we're creating a subview (true) or menu (false/undefined)
+   * @return  true if the menu/subview should be shown, false if there was only
+   *          one feed and the feed should be shown inline in the browser
+   *          window (do not show the menupopup/subview).
+   */
+  buildFeedList(container, isSubview) {
+    let feeds = gBrowser.selectedBrowser.feeds;
+    if (!isSubview && feeds == null) {
+      // XXX hack -- menu opening depends on setting of an "open"
+      // attribute, and the menu refuses to open if that attribute is
+      // set (because it thinks it's already open).  onpopupshowing gets
+      // called after the attribute is unset, and it doesn't get unset
+      // if we return false.  so we unset it here; otherwise, the menu
+      // refuses to work past this point.
+      container.parentNode.removeAttribute("open");
+      return false;
+    }
+
+    for (let i = container.childNodes.length - 1; i >= 0; --i) {
+      let node = container.childNodes[i];
+      if (isSubview && node.localName == "label")
+        continue;
+      container.removeChild(node);
+    }
+
+    if (!feeds || feeds.length <= 1)
+      return false;
+
+    // Build the menu showing the available feed choices for viewing.
+    let itemNodeType = isSubview ? "toolbarbutton" : "menuitem";
+    for (let feedInfo of feeds) {
+      let item = document.createElement(itemNodeType);
+      let baseTitle = feedInfo.title || feedInfo.href;
+      item.setAttribute("label", baseTitle);
+      item.setAttribute("feed", feedInfo.href);
+      item.setAttribute("tooltiptext", feedInfo.href);
+      item.setAttribute("crop", "center");
+      let className = "feed-" + itemNodeType;
+      if (isSubview) {
+        className += " subviewbutton";
+      }
+      item.setAttribute("class", className);
+      container.appendChild(item);
+    }
+    return true;
+  },
+
+  /**
+   * Subscribe to a given feed.  Called when
+   *   1. Page has a single feed and user clicks feed icon in location bar
+   *   2. Page has a single feed and user selects Subscribe menu item
+   *   3. Page has multiple feeds and user selects from feed icon popup (or subview)
+   *   4. Page has multiple feeds and user selects from Subscribe submenu
+   * @param   href
+   *          The feed to subscribe to. May be null, in which case the
+   *          event target's feed attribute is examined.
+   * @param   event
+   *          The event this method is handling. Used to decide where
+   *          to open the preview UI. (Optional, unless href is null)
+   */
+  subscribeToFeed(href, event) {
+    // Just load the feed in the content area to either subscribe or show the
+    // preview UI
+    if (!href)
+      href = event.target.getAttribute("feed");
+    urlSecurityCheck(href, gBrowser.contentPrincipal,
+                     Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);
+    this.loadFeed(href, event);
+  },
+
+  loadFeed(href, event) {
+    let feeds = gBrowser.selectedBrowser.feeds;
+    try {
+      openUILink(href, event, { ignoreAlt: true });
+    } finally {
+      // We might default to a livebookmarks modal dialog,
+      // so reset that if the user happens to click it again
+      gBrowser.selectedBrowser.feeds = feeds;
+    }
+  },
+
+  get _feedMenuitem() {
+    delete this._feedMenuitem;
+    return this._feedMenuitem = document.getElementById("singleFeedMenuitemState");
+  },
+
+  get _feedMenupopup() {
+    delete this._feedMenupopup;
+    return this._feedMenupopup = document.getElementById("multipleFeedsMenuState");
+  },
+
+  /**
+   * Update the browser UI to show whether or not feeds are available when
+   * a page is loaded or the user switches tabs to a page that has feeds.
+   */
+  updateFeeds() {
+    if (this._updateFeedTimeout)
+      clearTimeout(this._updateFeedTimeout);
+
+    let feeds = gBrowser.selectedBrowser.feeds;
+    let haveFeeds = feeds && feeds.length > 0;
+
+    let feedButton = document.getElementById("feed-button");
+    if (feedButton) {
+      if (haveFeeds) {
+        feedButton.removeAttribute("disabled");
+      } else {
+        feedButton.setAttribute("disabled", "true");
+      }
+    }
+
+    if (!haveFeeds) {
+      this._feedMenuitem.setAttribute("disabled", "true");
+      this._feedMenuitem.removeAttribute("hidden");
+      this._feedMenupopup.setAttribute("hidden", "true");
+      return;
+    }
+
+    if (feeds.length > 1) {
+      this._feedMenuitem.setAttribute("hidden", "true");
+      this._feedMenupopup.removeAttribute("hidden");
+    } else {
+      this._feedMenuitem.setAttribute("feed", feeds[0].href);
+      this._feedMenuitem.removeAttribute("disabled");
+      this._feedMenuitem.removeAttribute("hidden");
+      this._feedMenupopup.setAttribute("hidden", "true");
+    }
+  },
+
+  addFeed(link, browserForLink) {
+    if (!browserForLink.feeds)
+      browserForLink.feeds = [];
+
+    urlSecurityCheck(link.href, gBrowser.contentPrincipal,
+                     Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);
+
+    let feedURI = makeURI(link.href, document.characterSet);
+    if (!/^https?$/.test(feedURI.scheme))
+      return;
+
+    browserForLink.feeds.push({ href: link.href, title: link.title });
+
+    // If this addition was for the current browser, update the UI. For
+    // background browsers, we'll update on tab switch.
+    if (browserForLink == gBrowser.selectedBrowser) {
+      // Batch updates to avoid updating the UI for multiple onLinkAdded events
+      // fired within 100ms of each other.
+      if (this._updateFeedTimeout)
+        clearTimeout(this._updateFeedTimeout);
+      this._updateFeedTimeout = setTimeout(this.updateFeeds.bind(this), 100);
+    }
+  },
+
+   /**
+   * Get the human-readable display name of a file. This could be the
+   * application name.
+   * @param   file
+   *          A nsIFile to look up the name of
+   * @return  The display name of the application represented by the file.
+   */
+  _getFileDisplayName(file) {
+    switch (AppConstants.platform) {
+      case "win":
+        if (file instanceof Ci.nsILocalFileWin) {
+          try {
+            return file.getVersionInfoField("FileDescription");
+          } catch (e) {}
+        }
+        break;
+      case "macosx":
+        if (file instanceof Ci.nsILocalFileMac) {
+          try {
+            return file.bundleDisplayName;
+          } catch (e) {}
+        }
+        break;
+    }
+
+    return file.leafName;
+  },
+
+  _chooseClientApp(aTitle, aTypeName, aBrowser) {
+    const prefName = getPrefAppForType(aTypeName);
+    let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
+
+    fp.init(window, aTitle, Ci.nsIFilePicker.modeOpen);
+    fp.appendFilters(Ci.nsIFilePicker.filterApps);
+
+    fp.open((aResult) => {
+      if (aResult == Ci.nsIFilePicker.returnOK) {
+        let selectedApp = fp.file;
+        if (selectedApp) {
+          // XXXben - we need to compare this with the running instance
+          //          executable just don't know how to do that via script
+          // XXXmano TBD: can probably add this to nsIShellService
+          let appName = "";
+          switch (AppConstants.platform) {
+            case "win":
+              appName = AppConstants.MOZ_APP_NAME + ".exe";
+              break;
+            case "macosx":
+              appName = AppConstants.MOZ_MACBUNDLE_NAME;
+              break;
+            default:
+              appName = AppConstants.MOZ_APP_NAME + "-bin";
+              break;
+          }
+
+          if (fp.file.leafName != appName) {
+            Services.prefs.setComplexValue(prefName, Ci.nsIFile, selectedApp);
+            aBrowser.messageManager.sendAsyncMessage("FeedWriter:SetApplicationLauncherMenuItem",
+                                                    { name: this._getFileDisplayName(selectedApp),
+                                                      type: "SelectedAppMenuItem" });
+          }
+        }
+      }
+    });
+
+  },
+
+  executeClientApp(aSpec, aTitle, aSubtitle, aFeedHandler) {
+    // aFeedHandler is either "default", indicating the system default reader, or a pref-name containing
+    // an nsIFile pointing to the feed handler's executable.
+
+    let clientApp = null;
+    if (aFeedHandler == "default") {
+      clientApp = Cc["@mozilla.org/browser/shell-service;1"]
+                    .getService(Ci.nsIShellService)
+                    .defaultFeedReader;
+    } else {
+      clientApp = Services.prefs.getComplexValue(aFeedHandler, Ci.nsIFile);
+    }
+
+    // For the benefit of applications that might know how to deal with more
+    // URLs than just feeds, send feed: URLs in the following format:
+    //
+    // http urls: replace scheme with feed, e.g.
+    // http://foo.com/index.rdf -> feed://foo.com/index.rdf
+    // other urls: prepend feed: scheme, e.g.
+    // https://foo.com/index.rdf -> feed:https://foo.com/index.rdf
+    let feedURI = NetUtil.newURI(aSpec);
+    if (feedURI.schemeIs("http")) {
+      feedURI.scheme = "feed";
+      aSpec = feedURI.spec;
+    } else {
+      aSpec = "feed:" + aSpec;
+    }
+
+    // Retrieving the shell service might fail on some systems, most
+    // notably systems where GNOME is not installed.
+    try {
+      let ss = Cc["@mozilla.org/browser/shell-service;1"]
+                 .getService(Ci.nsIShellService);
+      ss.openApplicationWithURI(clientApp, aSpec);
+    } catch (e) {
+      // If we couldn't use the shell service, fallback to using a
+      // nsIProcess instance
+      let p = Cc["@mozilla.org/process/util;1"]
+                .createInstance(Ci.nsIProcess);
+      p.init(clientApp);
+      p.run(false, [aSpec], 1);
+    }
+  },
+
+  // nsISupports
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
+                                         Ci.nsISupportsWeakReference]),
+
+
+  init() {
+    window.messageManager.addMessageListener("FeedWriter:ChooseClientApp", this);
+    window.messageManager.addMessageListener("FeedWriter:GetSubscriptionUI", this);
+    window.messageManager.addMessageListener("FeedWriter:SetFeedPrefsAndSubscribe", this);
+    window.messageManager.addMessageListener("FeedWriter:ShownFirstRun", this);
+
+    Services.ppmm.addMessageListener("FeedConverter:ExecuteClientApp", this);
+
+    const prefs = Services.prefs;
+    prefs.addObserver(PREF_SELECTED_ACTION, this, true);
+    prefs.addObserver(PREF_SELECTED_READER, this, true);
+    prefs.addObserver(PREF_SELECTED_WEB, this, true);
+    prefs.addObserver(PREF_VIDEO_SELECTED_ACTION, this, true);
+    prefs.addObserver(PREF_VIDEO_SELECTED_READER, this, true);
+    prefs.addObserver(PREF_VIDEO_SELECTED_WEB, this, true);
+    prefs.addObserver(PREF_AUDIO_SELECTED_ACTION, this, true);
+    prefs.addObserver(PREF_AUDIO_SELECTED_READER, this, true);
+    prefs.addObserver(PREF_AUDIO_SELECTED_WEB, this, true);
+  },
+
+  uninit() {
+    Services.ppmm.removeMessageListener("FeedConverter:ExecuteClientApp", this);
+
+    this._prefChangeCallback = null;
+  },
+
+  // nsIObserver
+  observe(subject, topic, data) {
+    if (topic == "nsPref:changed") {
+      LOG(`Pref changed ${data}`);
+      if (this._prefChangeCallback) {
+        this._prefChangeCallback.disarm();
+      }
+      // Multiple prefs are set at the same time, debounce to reduce noise
+      // This can happen in one feed and we want to message all feed pages
+      this._prefChangeCallback = new DeferredTask(() => {
+        this._prefChanged(data);
+      }, PREF_UPDATE_DELAY);
+      this._prefChangeCallback.arm();
+    }
+  },
+
+  _prefChanged(prefName) {
+    // Don't observe for PREF_*SELECTED_APP as user likely just picked one
+    // That is also handled by SetApplicationLauncherMenuItem call
+    // Rather than the others which happen on subscription
+    switch (prefName) {
+      case PREF_SELECTED_READER:
+      case PREF_SELECTED_WEB:
+      case PREF_VIDEO_SELECTED_READER:
+      case PREF_VIDEO_SELECTED_WEB:
+      case PREF_AUDIO_SELECTED_READER:
+      case PREF_AUDIO_SELECTED_WEB:
+      case PREF_SELECTED_ACTION:
+      case PREF_VIDEO_SELECTED_ACTION:
+      case PREF_AUDIO_SELECTED_ACTION:
+        const response = {
+         default: this._getReaderForType(Ci.nsIFeed.TYPE_FEED),
+         [Ci.nsIFeed.TYPE_AUDIO]: this._getReaderForType(Ci.nsIFeed.TYPE_AUDIO),
+         [Ci.nsIFeed.TYPE_VIDEO]: this._getReaderForType(Ci.nsIFeed.TYPE_VIDEO)
+        };
+        Services.mm.broadcastAsyncMessage("FeedWriter:PreferenceUpdated",
+                                          response);
+        break;
+    }
+  },
+
+  _initSubscriptionUIResponse(feedType) {
+    const wccr = Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+               getService(Ci.nsIWebContentConverterService);
+    const handlersRaw = wccr.getContentHandlers(getMimeTypeForFeedType(feedType));
+    const handlers = [];
+    for (let handler of handlersRaw) {
+      LOG(`Handler found: ${handler}`);
+      handlers.push({
+        name: handler.name,
+        uri: handler.uri
+      });
+    }
+    let showFirstRunUI = true;
+    // eslint-disable-next-line mozilla/use-default-preference-values
+    try {
+      showFirstRunUI = Services.prefs.getBoolPref(PREF_SHOW_FIRST_RUN_UI);
+    } catch (ex) { }
+    const response = { handlers, showFirstRunUI };
+    let selectedClientApp;
+    const feedTypePref = getPrefAppForType(feedType);
+    try {
+      selectedClientApp = Services.prefs.getComplexValue(feedTypePref, Ci.nsIFile);
+    } catch (ex) {
+      // Just do nothing, then we won't bother populating
+    }
+
+    let defaultClientApp = null;
+    try {
+      // This can sometimes not exist
+      defaultClientApp = Cc["@mozilla.org/browser/shell-service;1"]
+                           .getService(Ci.nsIShellService)
+                           .defaultFeedReader;
+    } catch (ex) {
+      // Just do nothing, then we don't bother populating
+    }
+
+    if (selectedClientApp && selectedClientApp.exists()) {
+      if (defaultClientApp && selectedClientApp.path != defaultClientApp.path) {
+        // Only set the default menu item if it differs from the selected one
+        response.defaultMenuItem = this._getFileDisplayName(defaultClientApp);
+      }
+      response.selectedMenuItem = this._getFileDisplayName(selectedClientApp);
+    }
+    response.reader = this._getReaderForType(feedType);
+    return response;
+  },
+
+  _setPref(aPrefName, aPrefValue, aIsComplex = false) {
+    LOG(`FeedWriter._setPref ${aPrefName}`);
+    // Ensure we have a pref that is settable
+    if (aPrefName && SETTABLE_PREFS.has(aPrefName)) {
+      if (aIsComplex) {
+        Services.prefs.setStringPref(aPrefName, aPrefValue);
+      } else {
+        Services.prefs.setCharPref(aPrefName, aPrefValue);
+      }
+    } else {
+      LOG(`FeedWriter._setPref ${aPrefName} not allowed`);
+    }
+  },
+
+  _getReaderForType(feedType) {
+    let prefs = Services.prefs;
+    let handler = "bookmarks";
+    let url;
+    // eslint-disable-next-line mozilla/use-default-preference-values
+    try {
+      handler = prefs.getCharPref(getPrefReaderForType(feedType));
+    } catch (ex) { }
+
+    if (handler === "web") {
+      try {
+        url = prefs.getStringPref(getPrefWebForType(feedType));
+      } catch (ex) {
+        LOG("FeedWriter._setSelectedHandler: invalid or no handler in prefs");
+        url = null;
+      }
+    }
+    const alwaysUse = this._getAlwaysUseState(feedType);
+    const action = prefs.getCharPref(getPrefActionForType(feedType));
+    return { handler, url, alwaysUse, action };
+  },
+
+  _getAlwaysUseState(feedType) {
+    try {
+      return Services.prefs.getCharPref(getPrefActionForType(feedType)) != "ask";
+    } catch (ex) { }
+    return false;
+  },
+
+  receiveMessage(msg) {
+    let handler;
+    switch (msg.name) {
+      case "FeedWriter:GetSubscriptionUI":
+        const response = this._initSubscriptionUIResponse(msg.data.feedType);
+        msg.target.messageManager
+           .sendAsyncMessage("FeedWriter:GetSubscriptionUIResponse",
+                            response);
+        break;
+      case "FeedWriter:ChooseClientApp":
+        this._chooseClientApp(msg.data.title, msg.data.feedType, msg.target);
+        break;
+      case "FeedWriter:ShownFirstRun":
+        Services.prefs.setBoolPref(PREF_SHOW_FIRST_RUN_UI, false);
+        break;
+      case "FeedWriter:SetFeedPrefsAndSubscribe":
+        const settings = msg.data;
+        if (!settings.action || !VALID_ACTIONS.has(settings.action)) {
+          LOG(`Invalid action ${settings.action}`);
+          return;
+        }
+        if (!settings.reader || !VALID_READERS.has(settings.reader)) {
+          LOG(`Invalid reader ${settings.reader}`);
+          return;
+        }
+        const actionPref = getPrefActionForType(settings.feedType);
+        this._setPref(actionPref, settings.action);
+        const readerPref = getPrefReaderForType(settings.feedType);
+        this._setPref(readerPref, settings.reader);
+        handler = null;
+
+        switch (settings.reader) {
+          case "web":
+            // This is a web set URI by content using window.registerContentHandler()
+            // Lets make sure we know about it before setting it
+            const webPref = getPrefWebForType(settings.feedType);
+            let wccr = Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+                       getService(Ci.nsIWebContentConverterService);
+            // If the user provided an invalid web URL this function won't give us a reference
+            handler = wccr.getWebContentHandlerByURI(getMimeTypeForFeedType(settings.feedType), settings.uri);
+            if (handler) {
+              this._setPref(webPref, settings.uri, true);
+              if (settings.useAsDefault) {
+                wccr.setAutoHandler(getMimeTypeForFeedType(settings.feedType), handler);
+              }
+              msg.target.messageManager
+                 .sendAsyncMessage("FeedWriter:SetFeedPrefsAndSubscribeResponse",
+                                  { redirect: handler.getHandlerURI(settings.feedLocation) });
+            } else {
+              LOG(`No handler found for web ${settings.feedType} ${settings.uri}`);
+            }
+            break;
+          default:
+            const feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
+                                getService(Ci.nsIFeedResultService);
+
+            feedService.addToClientReader(settings.feedLocation,
+                                          settings.feedTitle,
+                                          settings.feedSubtitle,
+                                          settings.feedType,
+                                          settings.reader);
+         }
+         break;
+      case "FeedConverter:ExecuteClientApp":
+        // Always check feedHandler is from a set array of executable prefs
+        if (EXECUTABLE_PREFS.has(msg.data.feedHandler)) {
+          this.executeClientApp(msg.data.spec, msg.data.title,
+                                msg.data.subtitle, msg.data.feedHandler);
+        } else {
+          LOG(`FeedConverter:ExecuteClientApp - Will not exec ${msg.data.feedHandler}`);
+        }
+        break;
+    }
+  },
+};
+
+
+/***/ }),
+/* 5 */
+/***/ (function(module, exports, __webpack_require__) {
+
+"use strict";
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+
+var gEMEHandler = {
+  get uiEnabled() {
+    let emeUIEnabled = Services.prefs.getBoolPref("browser.eme.ui.enabled");
+    // Force-disable on WinXP:
+    if (navigator.platform.toLowerCase().startsWith("win")) {
+      emeUIEnabled = emeUIEnabled && parseFloat(Services.sysinfo.get("version")) >= 6;
+    }
+    return emeUIEnabled;
+  },
+  ensureEMEEnabled(browser, keySystem) {
+    Services.prefs.setBoolPref("media.eme.enabled", true);
+    if (keySystem &&
+        keySystem == "com.widevine.alpha" &&
+        Services.prefs.getPrefType("media.gmp-widevinecdm.enabled") &&
+        !Services.prefs.getBoolPref("media.gmp-widevinecdm.enabled")) {
+      Services.prefs.setBoolPref("media.gmp-widevinecdm.enabled", true);
+    }
+    browser.reload();
+  },
+  isKeySystemVisible(keySystem) {
+    if (!keySystem) {
+      return false;
+    }
+    if (keySystem == "com.widevine.alpha" &&
+        Services.prefs.getPrefType("media.gmp-widevinecdm.visible")) {
+      return Services.prefs.getBoolPref("media.gmp-widevinecdm.visible");
+    }
+    return true;
+  },
+  getLearnMoreLink(msgId) {
+    let text = gNavigatorBundle.getString("emeNotifications." + msgId + ".learnMoreLabel");
+    let baseURL = Services.urlFormatter.formatURLPref("app.support.baseURL");
+    return "<label class='text-link' href='" + baseURL + "drm-content'>" +
+           text + "</label>";
+  },
+  receiveMessage({target: browser, data: data}) {
+    let parsedData;
+    try {
+      parsedData = JSON.parse(data);
+    } catch (ex) {
+      Cu.reportError("Malformed EME video message with data: " + data);
+      return;
+    }
+    let {status: status, keySystem: keySystem} = parsedData;
+    // Don't need to show if disabled or keysystem not visible.
+    if (!this.uiEnabled || !this.isKeySystemVisible(keySystem)) {
+      return;
+    }
+
+    let notificationId;
+    let buttonCallback;
+    let params = [];
+    switch (status) {
+      case "available":
+      case "cdm-created":
+        // Only show the chain icon for proprietary CDMs. Clearkey is not one.
+        if (keySystem != "org.w3.clearkey") {
+          this.showPopupNotificationForSuccess(browser, keySystem);
+        }
+        // ... and bail!
+        return;
+
+      case "api-disabled":
+      case "cdm-disabled":
+        notificationId = "drmContentDisabled";
+        buttonCallback = gEMEHandler.ensureEMEEnabled.bind(gEMEHandler, browser, keySystem);
+        params = [this.getLearnMoreLink(notificationId)];
+        break;
+
+      case "cdm-insufficient-version":
+        notificationId = "drmContentCDMInsufficientVersion";
+        params = [this._brandShortName];
+        break;
+
+      case "cdm-not-installed":
+        notificationId = "drmContentCDMInstalling";
+        params = [this._brandShortName];
+        break;
+
+      case "cdm-not-supported":
+        // Not to pop up user-level notification because they cannot do anything
+        // about it.
+        return;
+      default:
+        Cu.reportError(new Error("Unknown message ('" + status + "') dealing with EME key request: " + data));
+        return;
+    }
+
+    this.showNotificationBar(browser, notificationId, keySystem, params, buttonCallback);
+  },
+  showNotificationBar(browser, notificationId, keySystem, labelParams, callback) {
+    let box = gBrowser.getNotificationBox(browser);
+    if (box.getNotificationWithValue(notificationId)) {
+      return;
+    }
+
+    let msgPrefix = "emeNotifications." + notificationId + ".";
+    let msgId = msgPrefix + "message";
+
+    let message = labelParams.length ?
+                  gNavigatorBundle.getFormattedString(msgId, labelParams) :
+                  gNavigatorBundle.getString(msgId);
+
+    let buttons = [];
+    if (callback) {
+      let btnLabelId = msgPrefix + "button.label";
+      let btnAccessKeyId = msgPrefix + "button.accesskey";
+      buttons.push({
+        label: gNavigatorBundle.getString(btnLabelId),
+        accessKey: gNavigatorBundle.getString(btnAccessKeyId),
+        callback
+      });
+    }
+
+    let iconURL = "chrome://browser/skin/drm-icon.svg";
+
+    // Do a little dance to get rich content into the notification:
+    let fragment = document.createDocumentFragment();
+    let descriptionContainer = document.createElement("description");
+    // eslint-disable-next-line no-unsanitized/property
+    descriptionContainer.innerHTML = message;
+    while (descriptionContainer.childNodes.length) {
+      fragment.appendChild(descriptionContainer.childNodes[0]);
+    }
+
+    box.appendNotification(fragment, notificationId, iconURL, box.PRIORITY_WARNING_MEDIUM,
+                           buttons);
+  },
+  showPopupNotificationForSuccess(browser, keySystem) {
+    // We're playing EME content! Remove any "we can't play because..." messages.
+    var box = gBrowser.getNotificationBox(browser);
+    ["drmContentDisabled",
+     "drmContentCDMInstalling"
+     ].forEach(function(value) {
+        var notification = box.getNotificationWithValue(value);
+        if (notification)
+          box.removeNotification(notification);
+      });
+
+    // Don't bother creating it if it's already there:
+    if (PopupNotifications.getNotification("drmContentPlaying", browser)) {
+      return;
+    }
+
+    let msgPrefix = "emeNotifications.drmContentPlaying.";
+    let msgId = msgPrefix + "message2";
+    let btnLabelId = msgPrefix + "button.label";
+    let btnAccessKeyId = msgPrefix + "button.accesskey";
+
+    let message = gNavigatorBundle.getFormattedString(msgId, [this._brandShortName]);
+    let anchorId = "eme-notification-icon";
+    let firstPlayPref = "browser.eme.ui.firstContentShown";
+    if (!Services.prefs.getPrefType(firstPlayPref) ||
+        !Services.prefs.getBoolPref(firstPlayPref)) {
+      document.getElementById(anchorId).setAttribute("firstplay", "true");
+      Services.prefs.setBoolPref(firstPlayPref, true);
+    } else {
+      document.getElementById(anchorId).removeAttribute("firstplay");
+    }
+
+    let mainAction = {
+      label: gNavigatorBundle.getString(btnLabelId),
+      accessKey: gNavigatorBundle.getString(btnAccessKeyId),
+      callback() {
+        openPreferences("general-drm", {origin: "browserMedia"});
+      },
+      dismiss: true
+    };
+    let options = {
+      dismissed: true,
+      eventCallback: aTopic => aTopic == "swapping",
+      learnMoreURL: Services.urlFormatter.formatURLPref("app.support.baseURL") + "drm-content",
+    };
+    PopupNotifications.show(browser, "drmContentPlaying", message, anchorId, mainAction, null, options);
+  },
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMessageListener])
+};
+
+XPCOMUtils.defineLazyGetter(gEMEHandler, "_brandShortName", function() {
+  return document.getElementById("bundle_brand").getString("brandShortName");
+});
+
+const TELEMETRY_DDSTAT_SHOWN = 0;
+const TELEMETRY_DDSTAT_SHOWN_FIRST = 1;
+const TELEMETRY_DDSTAT_CLICKED = 2;
+const TELEMETRY_DDSTAT_CLICKED_FIRST = 3;
+const TELEMETRY_DDSTAT_SOLVED = 4;
+
+let gDecoderDoctorHandler = {
+  getLabelForNotificationBox(type) {
+    if (type == "platform-decoder-not-found") {
+      if (AppConstants.platform == "win") {
+        return gNavigatorBundle.getString("decoder.noHWAcceleration.message");
+      }
+      if (AppConstants.platform == "linux") {
+        return gNavigatorBundle.getString("decoder.noCodecsLinux.message");
+      }
+    }
+    if (type == "cannot-initialize-pulseaudio") {
+      return gNavigatorBundle.getString("decoder.noPulseAudio.message");
+    }
+    if (type == "unsupported-libavcodec" &&
+        AppConstants.platform == "linux") {
+      return gNavigatorBundle.getString("decoder.unsupportedLibavcodec.message");
+    }
+    if (type == "decode-error") {
+      return gNavigatorBundle.getString("decoder.decodeError.message");
+    }
+    if (type == "decode-warning") {
+      return gNavigatorBundle.getString("decoder.decodeWarning.message");
+    }
+    return "";
+  },
+
+  getSumoForLearnHowButton(type) {
+    if (type == "platform-decoder-not-found" &&
+        AppConstants.platform == "win") {
+      return "fix-video-audio-problems-firefox-windows";
+    }
+    if (type == "cannot-initialize-pulseaudio") {
+      return "fix-common-audio-and-video-issues";
+    }
+    return "";
+  },
+
+  getEndpointForReportIssueButton(type) {
+    if (type == "decode-error" || type == "decode-warning") {
+      return Services.prefs.getStringPref("media.decoder-doctor.new-issue-endpoint", "");
+    }
+    return "";
+  },
+
+  receiveMessage({target: browser, data: data}) {
+    let box = gBrowser.getNotificationBox(browser);
+    let notificationId = "decoder-doctor-notification";
+    if (box.getNotificationWithValue(notificationId)) {
+      return;
+    }
+
+    let parsedData;
+    try {
+      parsedData = JSON.parse(data);
+    } catch (ex) {
+      Cu.reportError("Malformed Decoder Doctor message with data: " + data);
+      return;
+    }
+    // parsedData (the result of parsing the incoming 'data' json string)
+    // contains analysis information from Decoder Doctor:
+    // - 'type' is the type of issue, it determines which text to show in the
+    //   infobar.
+    // - 'isSolved' is true when the notification actually indicates the
+    //   resolution of that issue, to be reported as telemetry.
+    // - 'decoderDoctorReportId' is the Decoder Doctor issue identifier, to be
+    //   used here as key for the telemetry (counting infobar displays,
+    //   "Learn how" buttons clicks, and resolutions) and for the prefs used
+    //   to store at-issue formats.
+    // - 'formats' contains a comma-separated list of formats (or key systems)
+    //   that suffer the issue. These are kept in a pref, which the backend
+    //   uses to later find when an issue is resolved.
+    // - 'decodeIssue' is a description of the decode error/warning.
+    // - 'resourceURL' is the resource with the issue.
+    let {type, isSolved, decoderDoctorReportId,
+         formats, decodeIssue, docURL, resourceURL} = parsedData;
+    type = type.toLowerCase();
+    // Error out early on invalid ReportId
+    if (!(/^\w+$/mi).test(decoderDoctorReportId)) {
+      return;
+    }
+    let title = gDecoderDoctorHandler.getLabelForNotificationBox(type);
+    if (!title) {
+      return;
+    }
+
+    // We keep the list of formats in prefs for the sake of the decoder itself,
+    // which reads it to determine when issues get solved for these formats.
+    // (Writing prefs from e10s content is not allowed.)
+    let formatsPref = formats &&
+                      "media.decoder-doctor." + decoderDoctorReportId + ".formats";
+    let buttonClickedPref = "media.decoder-doctor." + decoderDoctorReportId + ".button-clicked";
+    let histogram =
+      Services.telemetry.getKeyedHistogramById("DECODER_DOCTOR_INFOBAR_STATS");
+
+    let formatsInPref = formats &&
+                        Services.prefs.getCharPref(formatsPref, "");
+
+    if (!isSolved) {
+      if (formats) {
+        if (!formatsInPref) {
+          Services.prefs.setCharPref(formatsPref, formats);
+          histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_SHOWN_FIRST);
+        } else {
+          // Split existing formats into an array of strings.
+          let existing = formatsInPref.split(",").map(x => x.trim());
+          // Keep given formats that were not already recorded.
+          let newbies = formats.split(",").map(x => x.trim())
+                        .filter(x => !existing.includes(x));
+          // And rewrite pref with the added new formats (if any).
+          if (newbies.length) {
+            Services.prefs.setCharPref(formatsPref,
+                                      existing.concat(newbies).join(", "));
+          }
+        }
+      } else if (!decodeIssue) {
+        Cu.reportError("Malformed Decoder Doctor unsolved message with no formats nor decode issue");
+        return;
+      }
+      histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_SHOWN);
+
+      let buttons = [];
+      let sumo = gDecoderDoctorHandler.getSumoForLearnHowButton(type);
+      if (sumo) {
+        buttons.push({
+          label: gNavigatorBundle.getString("decoder.noCodecs.button"),
+          accessKey: gNavigatorBundle.getString("decoder.noCodecs.accesskey"),
+          callback() {
+            let clickedInPref =
+              Services.prefs.getBoolPref(buttonClickedPref, false);
+            if (!clickedInPref) {
+              Services.prefs.setBoolPref(buttonClickedPref, true);
+              histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_CLICKED_FIRST);
+            }
+            histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_CLICKED);
+
+            let baseURL = Services.urlFormatter.formatURLPref("app.support.baseURL");
+            openUILinkIn(baseURL + sumo, "tab");
+          }
+        });
+      }
+      let endpoint = gDecoderDoctorHandler.getEndpointForReportIssueButton(type);
+      if (endpoint) {
+        buttons.push({
+          label: gNavigatorBundle.getString("decoder.decodeError.button"),
+          accessKey: gNavigatorBundle.getString("decoder.decodeError.accesskey"),
+          callback() {
+            let clickedInPref =
+              Services.prefs.getBoolPref(buttonClickedPref, false);
+            if (!clickedInPref) {
+              Services.prefs.setBoolPref(buttonClickedPref, true);
+              histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_CLICKED_FIRST);
+            }
+            histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_CLICKED);
+
+            let params = new URLSearchParams;
+            params.append("url", docURL);
+            params.append("label", "type-media");
+            params.append("problem_type", "video_bug");
+            params.append("src", "media-decode-error");
+            params.append("details",
+                          "Technical Information:\n" + decodeIssue +
+                          (resourceURL ? ("\nResource: " + resourceURL) : ""));
+            openUILinkIn(endpoint + "?" + params.toString(), "tab");
+          }
+        });
+      }
+
+      box.appendNotification(
+          title,
+          notificationId,
+          "", // This uses the info icon as specified below.
+          box.PRIORITY_INFO_LOW,
+          buttons
+      );
+    } else if (formatsInPref) {
+      // Issue is solved, and prefs haven't been cleared yet, meaning it's the
+      // first time we get this resolution -> Clear prefs and report telemetry.
+      Services.prefs.clearUserPref(formatsPref);
+      Services.prefs.clearUserPref(buttonClickedPref);
+      histogram.add(decoderDoctorReportId, TELEMETRY_DDSTAT_SOLVED);
+    }
+  },
+};
+
+window.getGroupMessageManager("browsers").addMessageListener("DecoderDoctor:Notification", gDecoderDoctorHandler);
+window.getGroupMessageManager("browsers").addMessageListener("EMEVideo:ContentMediaKeysRequest", gEMEHandler);
+window.addEventListener("unload", function() {
+  window.getGroupMessageManager("browsers").removeMessageListener("EMEVideo:ContentMediaKeysRequest", gEMEHandler);
+  window.getGroupMessageManager("browsers").removeMessageListener("DecoderDoctor:Notification", gDecoderDoctorHandler);
+});
+
+
+/***/ }),
+/* 6 */
+/***/ (function(module, exports) {
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var BrowserPageActions = {
+  /**
+   * The main page action button in the urlbar (DOM node)
+   */
+  get mainButtonNode() {
+    delete this.mainButtonNode;
+    return this.mainButtonNode = document.getElementById("pageActionButton");
+  },
+
+  /**
+   * The main page action panel DOM node (DOM node)
+   */
+  get panelNode() {
+    delete this.panelNode;
+    return this.panelNode = document.getElementById("pageActionPanel");
+  },
+
+  /**
+   * The panelmultiview node in the main page action panel (DOM node)
+   */
+  get multiViewNode() {
+    delete this.multiViewNode;
+    return this.multiViewNode = document.getElementById("pageActionPanelMultiView");
+  },
+
+  /**
+   * The main panelview node in the main page action panel (DOM node)
+   */
+  get mainViewNode() {
+    delete this.mainViewNode;
+    return this.mainViewNode = document.getElementById("pageActionPanelMainView");
+  },
+
+  /**
+   * The vbox body node in the main panelview node (DOM node)
+   */
+  get mainViewBodyNode() {
+    delete this.mainViewBodyNode;
+    return this.mainViewBodyNode = this.mainViewNode.querySelector(".panel-subview-body");
+  },
+
+  /**
+   * Inits.  Call to init.
+   */
+  init() {
+    this.placeAllActions();
+  },
+
+  /**
+   * Places all registered actions.
+   */
+  placeAllActions() {
+    // Place actions in the panel.  Notify of onBeforePlacedInWindow too.
+    for (let action of PageActions.actions) {
+      action.onBeforePlacedInWindow(window);
+      this.placeActionInPanel(action);
+    }
+
+    // Place actions in the urlbar.  Do this in reverse order.  The reason is
+    // subtle.  If there were no urlbar nodes already in markup (like the
+    // bookmark star button), then doing this in forward order would be fine.
+    // Forward order means that the insert-before relationship is always broken:
+    // there's never a next-sibling node before which to insert a new node, so
+    // node.insertBefore() is always passed null, and nodes are always appended.
+    // That will break the position of nodes that should be inserted before
+    // nodes that are in markup, which in turn can break other nodes.
+    let actionsInUrlbar = PageActions.actionsInUrlbar(window);
+    for (let i = actionsInUrlbar.length - 1; i >= 0; i--) {
+      let action = actionsInUrlbar[i];
+      this.placeActionInUrlbar(action);
+    }
+  },
+
+  /**
+   * Adds or removes as necessary DOM nodes for the given action.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action to place.
+   */
+  placeAction(action) {
+    action.onBeforePlacedInWindow(window);
+    this.placeActionInPanel(action);
+    this.placeActionInUrlbar(action);
+  },
+
+  /**
+   * Adds or removes as necessary DOM nodes for the action in the panel.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action to place.
+   */
+  placeActionInPanel(action) {
+    let id = this.panelButtonNodeIDForActionID(action.id);
+    let node = document.getElementById(id);
+    if (!node) {
+      let panelViewNode;
+      [node, panelViewNode] = this._makePanelButtonNodeForAction(action);
+      node.id = id;
+      let insertBeforeID = PageActions.nextActionIDInPanel(action);
+      let insertBeforeNode =
+        insertBeforeID ? this.panelButtonNodeForActionID(insertBeforeID) :
+        null;
+      this.mainViewBodyNode.insertBefore(node, insertBeforeNode);
+      this.updateAction(action);
+      this._updateActionDisabledInPanel(action);
+      action.onPlacedInPanel(node);
+      if (panelViewNode) {
+        action.subview.onPlaced(panelViewNode);
+      }
+    }
+  },
+
+  _makePanelButtonNodeForAction(action) {
+    if (action.__isSeparator) {
+      let node = document.createElement("toolbarseparator");
+      return [node, null];
+    }
+
+    let buttonNode = document.createElement("toolbarbutton");
+    buttonNode.classList.add(
+      "subviewbutton",
+      "subviewbutton-iconic",
+      "pageAction-panel-button"
+    );
+    buttonNode.setAttribute("actionid", action.id);
+    if (action.nodeAttributes) {
+      for (let name in action.nodeAttributes) {
+        buttonNode.setAttribute(name, action.nodeAttributes[name]);
+      }
+    }
+    let panelViewNode = null;
+    if (action.subview) {
+      buttonNode.classList.add("subviewbutton-nav");
+      panelViewNode = this._makePanelViewNodeForAction(action, false);
+      this.multiViewNode._panelViews = null;
+      this.multiViewNode.appendChild(panelViewNode);
+    }
+    buttonNode.addEventListener("command", event => {
+      this.doCommandForAction(action, event, buttonNode);
+    });
+    return [buttonNode, panelViewNode];
+  },
+
+  _makePanelViewNodeForAction(action, forUrlbar) {
+    let panelViewNode = document.createElement("panelview");
+    panelViewNode.id = this._panelViewNodeIDForActionID(action.id, forUrlbar);
+    panelViewNode.classList.add("PanelUI-subView");
+    let bodyNode = document.createElement("vbox");
+    bodyNode.id = panelViewNode.id + "-body";
+    bodyNode.classList.add("panel-subview-body");
+    panelViewNode.appendChild(bodyNode);
+    for (let button of action.subview.buttons) {
+      let buttonNode = document.createElement("toolbarbutton");
+      buttonNode.id =
+        this._panelViewButtonNodeIDForActionID(action.id, button.id, forUrlbar);
+      buttonNode.classList.add("subviewbutton", "subviewbutton-iconic");
+      buttonNode.setAttribute("label", button.title);
+      if (button.shortcut) {
+        buttonNode.setAttribute("shortcut", button.shortcut);
+      }
+      if (button.disabled) {
+        buttonNode.setAttribute("disabled", "true");
+      }
+      buttonNode.addEventListener("command", event => {
+        button.onCommand(event, buttonNode);
+      });
+      bodyNode.appendChild(buttonNode);
+    }
+    return panelViewNode;
+  },
+
+  /**
+   * Shows or hides a panel for an action.  You can supply your own panel;
+   * otherwise one is created.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action for which to toggle the panel.  If the action is in the
+   *         urlbar, then the panel will be anchored to it.  Otherwise, a
+   *         suitable anchor will be used.
+   * @param  panelNode (DOM node, optional)
+   *         The panel to use.  This method takes a hands-off approach with
+   *         regard to your panel in terms of attributes, styling, etc.
+   */
+  togglePanelForAction(action, panelNode = null) {
+    let aaPanelNode = this.activatedActionPanelNode;
+    if (panelNode) {
+      if (panelNode.state != "closed") {
+        panelNode.hidePopup();
+        return;
+      }
+      if (aaPanelNode) {
+        aaPanelNode.hidePopup();
+      }
+    } else if (aaPanelNode) {
+      aaPanelNode.hidePopup();
+      return;
+    } else {
+      panelNode = this._makeActivatedActionPanelForAction(action);
+    }
+
+    // Hide the main panel before showing the action's panel.
+    this.panelNode.hidePopup();
+
+    let anchorNode = this.panelAnchorNodeForAction(action);
+    anchorNode.setAttribute("open", "true");
+    panelNode.addEventListener("popuphiding", () => {
+      anchorNode.removeAttribute("open");
+    }, { once: true });
+
+    panelNode.openPopup(anchorNode, "bottomcenter topright");
+  },
+
+  _makeActivatedActionPanelForAction(action) {
+    let panelNode = document.createElement("panel");
+    panelNode.id = this._activatedActionPanelID;
+    panelNode.classList.add("cui-widget-panel");
+    panelNode.setAttribute("actionID", action.id);
+    panelNode.setAttribute("role", "group");
+    panelNode.setAttribute("type", "arrow");
+    panelNode.setAttribute("flip", "slide");
+    panelNode.setAttribute("noautofocus", "true");
+    panelNode.setAttribute("tabspecific", "true");
+    panelNode.setAttribute("photon", "true");
+
+    if (this._disablePanelAnimations) {
+      panelNode.setAttribute("animate", "false");
+    }
+
+    let panelViewNode = null;
+    let iframeNode = null;
+
+    if (action.subview) {
+      let multiViewNode = document.createElement("panelmultiview");
+      panelViewNode = this._makePanelViewNodeForAction(action, true);
+      multiViewNode.appendChild(panelViewNode);
+      panelNode.appendChild(multiViewNode);
+    } else if (action.wantsIframe) {
+      iframeNode = document.createElement("iframe");
+      iframeNode.setAttribute("type", "content");
+      panelNode.appendChild(iframeNode);
+    }
+
+    let popupSet = document.getElementById("mainPopupSet");
+    popupSet.appendChild(panelNode);
+    panelNode.addEventListener("popuphidden", () => {
+      panelNode.remove();
+    }, { once: true });
+
+    if (iframeNode) {
+      panelNode.addEventListener("popupshowing", () => {
+        action.onIframeShowing(iframeNode, panelNode);
+      }, { once: true });
+      panelNode.addEventListener("popuphiding", () => {
+        action.onIframeHiding(iframeNode, panelNode);
+      }, { once: true });
+      panelNode.addEventListener("popuphidden", () => {
+        action.onIframeHidden(iframeNode, panelNode);
+      }, { once: true });
+    }
+
+    if (panelViewNode) {
+      action.subview.onPlaced(panelViewNode);
+      panelNode.addEventListener("popupshowing", () => {
+        action.subview.onShowing(panelViewNode);
+      }, { once: true });
+    }
+
+    return panelNode;
+  },
+
+  // For tests.
+  get _disablePanelAnimations() {
+    return this.__disablePanelAnimations || false;
+  },
+  set _disablePanelAnimations(val) {
+    this.__disablePanelAnimations = val;
+    if (val) {
+      this.panelNode.setAttribute("animate", "false");
+    } else {
+      this.panelNode.removeAttribute("animate");
+    }
+  },
+
+  /**
+   * Returns the node in the urlbar to which popups for the given action should
+   * be anchored.  If the action is null, a sensible anchor is returned.
+   *
+   * @param  action (PageActions.Action, optional)
+   *         The action you want to anchor.
+   * @return (DOM node, nonnull) The node to which the action should be
+   *         anchored.
+   */
+  panelAnchorNodeForAction(action, event) {
+    if (event && event.target.closest("panel")) {
+      return this.mainButtonNode;
+    }
+
+    // Try each of the following nodes in order, using the first that's visible.
+    let potentialAnchorNodeIDs = [
+      action && action.anchorIDOverride,
+      action && this.urlbarButtonNodeIDForActionID(action.id),
+      this.mainButtonNode.id,
+      "identity-icon",
+    ];
+    let dwu = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                    .getInterface(Ci.nsIDOMWindowUtils);
+    for (let id of potentialAnchorNodeIDs) {
+      if (id) {
+        let node = document.getElementById(id);
+        if (node && !node.hidden) {
+          let bounds = dwu.getBoundsWithoutFlushing(node);
+          if (bounds.height > 0 && bounds.width > 0) {
+            return node;
+          }
+        }
+      }
+    }
+    let id = action ? action.id : "<no action>";
+    throw new Error(`PageActions: No anchor node for ${id}`);
+  },
+
+  get activatedActionPanelNode() {
+    return document.getElementById(this._activatedActionPanelID);
+  },
+
+  get _activatedActionPanelID() {
+    return "pageActionActivatedActionPanel";
+  },
+
+  /**
+   * Adds or removes as necessary a DOM node for the given action in the urlbar.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action to place.
+   */
+  placeActionInUrlbar(action) {
+    let id = this.urlbarButtonNodeIDForActionID(action.id);
+    let node = document.getElementById(id);
+
+    if (!action.shouldShowInUrlbar(window)) {
+      if (node) {
+        if (action.__urlbarNodeInMarkup) {
+          node.hidden = true;
+        } else {
+          node.remove();
+        }
+      }
+      return;
+    }
+
+    let newlyPlaced = false;
+    if (action.__urlbarNodeInMarkup) {
+      newlyPlaced = node && node.hidden;
+      node.hidden = false;
+    } else if (!node) {
+      newlyPlaced = true;
+      node = this._makeUrlbarButtonNode(action);
+      node.id = id;
+    }
+
+    if (newlyPlaced) {
+      let insertBeforeID = PageActions.nextActionIDInUrlbar(window, action);
+      let insertBeforeNode =
+        insertBeforeID ? this.urlbarButtonNodeForActionID(insertBeforeID) :
+        null;
+      this.mainButtonNode.parentNode.insertBefore(node, insertBeforeNode);
+      this.updateAction(action);
+      action.onPlacedInUrlbar(node);
+
+      // urlbar buttons should always have tooltips, so if the node doesn't have
+      // one, then as a last resort use the label of the corresponding panel
+      // button.  Why not set tooltiptext to action.title when the node is
+      // created?  Because the consumer may set a title dynamically.
+      if (!node.hasAttribute("tooltiptext")) {
+        let panelNode = this.panelButtonNodeForActionID(action.id);
+        if (panelNode) {
+          node.setAttribute("tooltiptext", panelNode.getAttribute("label"));
+        }
+      }
+    }
+  },
+
+  _makeUrlbarButtonNode(action) {
+    let buttonNode = document.createElement("image");
+    buttonNode.classList.add("urlbar-icon", "urlbar-page-action");
+    buttonNode.setAttribute("actionid", action.id);
+    buttonNode.setAttribute("role", "button");
+    if (action.nodeAttributes) {
+      for (let name in action.nodeAttributes) {
+        buttonNode.setAttribute(name, action.nodeAttributes[name]);
+      }
+    }
+    buttonNode.addEventListener("click", event => {
+      this.doCommandForAction(action, event, buttonNode);
+    });
+    return buttonNode;
+  },
+
+  /**
+   * Removes all the DOM nodes of the given action.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action to remove.
+   */
+  removeAction(action) {
+    this._removeActionFromPanel(action);
+    this._removeActionFromUrlbar(action);
+    action.onRemovedFromWindow(window);
+  },
+
+  _removeActionFromPanel(action) {
+    let node = this.panelButtonNodeForActionID(action.id);
+    if (node) {
+      node.remove();
+    }
+    if (action.subview) {
+      let panelViewNodeID = this._panelViewNodeIDForActionID(action.id, false);
+      let panelViewNode = document.getElementById(panelViewNodeID);
+      if (panelViewNode) {
+        panelViewNode.remove();
+      }
+    }
+    // If there are now no more non-built-in actions, remove the separator
+    // between the built-ins and non-built-ins.
+    if (!PageActions.nonBuiltInActions.length) {
+      let separator = document.getElementById(
+        this.panelButtonNodeIDForActionID(
+          PageActions.ACTION_ID_BUILT_IN_SEPARATOR
+        )
+      );
+      if (separator) {
+        separator.remove();
+      }
+    }
+  },
+
+  _removeActionFromUrlbar(action) {
+    let node = this.urlbarButtonNodeForActionID(action.id);
+    if (node) {
+      node.remove();
+    }
+  },
+
+  /**
+   * Updates the DOM nodes of an action to reflect either a changed property or
+   * all properties.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action to update.
+   * @param  propertyName (string, optional)
+   *         The name of the property to update.  If not given, then DOM nodes
+   *         will be updated to reflect the current values of all properties.
+   */
+  updateAction(action, propertyName = null) {
+    let propertyNames = propertyName ? [propertyName] : [
+      "iconURL",
+      "title",
+      "tooltip",
+    ];
+    for (let name of propertyNames) {
+      let upper = name[0].toUpperCase() + name.substr(1);
+      this[`_updateAction${upper}`](action);
+    }
+  },
+
+  _updateActionDisabled(action) {
+    this._updateActionDisabledInPanel(action);
+    this.placeActionInUrlbar(action);
+  },
+
+  _updateActionDisabledInPanel(action) {
+    let panelButton = this.panelButtonNodeForActionID(action.id);
+    if (panelButton) {
+      if (action.getDisabled(window)) {
+        panelButton.setAttribute("disabled", "true");
+      } else {
+        panelButton.removeAttribute("disabled");
+      }
+    }
+  },
+
+  _updateActionIconURL(action) {
+    let nodes = [
+      this.panelButtonNodeForActionID(action.id),
+      this.urlbarButtonNodeForActionID(action.id),
+    ].filter(n => !!n);
+    for (let node of nodes) {
+      for (let size of [16, 32]) {
+        let url = action.iconURLForSize(size, window);
+        let prop = `--pageAction-image-${size}px`;
+        if (url) {
+          node.style.setProperty(prop, `url("${url}")`);
+        } else {
+          node.style.removeProperty(prop);
+        }
+      }
+    }
+  },
+
+  _updateActionTitle(action) {
+    let title = action.getTitle(window);
+    if (!title) {
+      // `title` is a required action property, but the bookmark action's is an
+      // empty string since its actual title is set via
+      // BookmarkingUI.updateBookmarkPageMenuItem().  The purpose of this early
+      // return is to ignore that empty title.
+      return;
+    }
+    let attrNamesByNodeFnName = {
+      panelButtonNodeForActionID: "label",
+      urlbarButtonNodeForActionID: "aria-label",
+    };
+    for (let [fnName, attrName] of Object.entries(attrNamesByNodeFnName)) {
+      let node = this[fnName](action.id);
+      if (node) {
+        node.setAttribute(attrName, title);
+      }
+    }
+    // tooltiptext falls back to the title, so update it, too.
+    this._updateActionTooltip(action);
+  },
+
+  _updateActionTooltip(action) {
+    let node = this.urlbarButtonNodeForActionID(action.id);
+    if (node) {
+      let tooltip = action.getTooltip(window) || action.getTitle(window);
+      node.setAttribute("tooltiptext", tooltip);
+    }
+  },
+
+  doCommandForAction(action, event, buttonNode) {
+    if (event && event.type == "click" && event.button != 0) {
+      return;
+    }
+    PageActions.logTelemetry("used", action, buttonNode);
+    // If we're in the panel, open a subview inside the panel:
+    // Note that we can't use this.panelNode.contains(buttonNode) here
+    // because of XBL boundaries breaking Element.contains.
+    if (action.subview &&
+        buttonNode &&
+        buttonNode.closest("panel") == this.panelNode) {
+      let panelViewNodeID = this._panelViewNodeIDForActionID(action.id, false);
+      let panelViewNode = document.getElementById(panelViewNodeID);
+      action.subview.onShowing(panelViewNode);
+      this.multiViewNode.showSubView(panelViewNode, buttonNode);
+      return;
+    }
+    // Otherwise, hide the main popup in case it was open:
+    this.panelNode.hidePopup();
+
+    // Toggle the activated action's panel if necessary
+    if (action.subview || action.wantsIframe) {
+      this.togglePanelForAction(action);
+      return;
+    }
+
+    // Otherwise, run the action.
+    action.onCommand(event, buttonNode);
+  },
+
+  /**
+   * Returns the action for a node.
+   *
+   * @param  node (DOM node, required)
+   *         A button DOM node, either one that's shown in the page action panel
+   *         or the urlbar.
+   * @return (PageAction.Action) The node's related action, or null if none.
+   */
+  actionForNode(node) {
+    if (!node) {
+      return null;
+    }
+    let actionID = this._actionIDForNodeID(node.id);
+    let action = PageActions.actionForID(actionID);
+    if (!action) {
+      // The given node may be an ancestor of a node corresponding to an action,
+      // like how #star-button is contained in #star-button-box, the latter
+      // being the bookmark action's node.  Look up the ancestor chain.
+      for (let n = node.parentNode; n && !action; n = n.parentNode) {
+        if (n.id == "page-action-buttons" || n.localName == "panelview") {
+          // We reached the page-action-buttons or panelview container.
+          // Stop looking; no acton was found.
+          break;
+        }
+        actionID = this._actionIDForNodeID(n.id);
+        action = PageActions.actionForID(actionID);
+      }
+    }
+    return action;
+  },
+
+  /**
+   * The given action's top-level button in the main panel.
+   *
+   * @param  actionID (string, required)
+   *         The action ID.
+   * @return (DOM node) The action's button in the main panel.
+   */
+  panelButtonNodeForActionID(actionID) {
+    return document.getElementById(this.panelButtonNodeIDForActionID(actionID));
+  },
+
+  /**
+   * The ID of the given action's top-level button in the main panel.
+   *
+   * @param  actionID (string, required)
+   *         The action ID.
+   * @return (string) The ID of the action's button in the main panel.
+   */
+  panelButtonNodeIDForActionID(actionID) {
+    return `pageAction-panel-${actionID}`;
+  },
+
+  /**
+   * The given action's button in the urlbar.
+   *
+   * @param  actionID (string, required)
+   *         The action ID.
+   * @return (DOM node) The action's urlbar button node.
+   */
+  urlbarButtonNodeForActionID(actionID) {
+    return document.getElementById(this.urlbarButtonNodeIDForActionID(actionID));
+  },
+
+  /**
+   * The ID of the given action's button in the urlbar.
+   *
+   * @param  actionID (string, required)
+   *         The action ID.
+   * @return (string) The ID of the action's urlbar button node.
+   */
+  urlbarButtonNodeIDForActionID(actionID) {
+    let action = PageActions.actionForID(actionID);
+    if (action && action.urlbarIDOverride) {
+      return action.urlbarIDOverride;
+    }
+    return `pageAction-urlbar-${actionID}`;
+  },
+
+  // The ID of the given action's panelview.
+  _panelViewNodeIDForActionID(actionID, forUrlbar) {
+    let placementID = forUrlbar ? "urlbar" : "panel";
+    return `pageAction-${placementID}-${actionID}-subview`;
+  },
+
+  // The ID of the given button in the given action's panelview.
+  _panelViewButtonNodeIDForActionID(actionID, buttonID, forUrlbar) {
+    let placementID = forUrlbar ? "urlbar" : "panel";
+    return `pageAction-${placementID}-${actionID}-${buttonID}`;
+  },
+
+  // The ID of the action corresponding to the given top-level button in the
+  // panel or button in the urlbar.
+  _actionIDForNodeID(nodeID) {
+    if (!nodeID) {
+      return null;
+    }
+    let match = nodeID.match(/^pageAction-(?:panel|urlbar)-(.+)$/);
+    if (match) {
+      return match[1];
+    }
+    // Check all the urlbar ID overrides.
+    for (let action of PageActions.actions) {
+      if (action.urlbarIDOverride && action.urlbarIDOverride == nodeID) {
+        return action.id;
+      }
+    }
+    return null;
+  },
+
+  /**
+   * Call this when the main page action button in the urlbar is activated.
+   *
+   * @param  event (DOM event, required)
+   *         The click or whatever event.
+   */
+  mainButtonClicked(event) {
+    event.stopPropagation();
+    if ((event.type == "mousedown" && event.button != 0) ||
+        (event.type == "keypress" && event.charCode != KeyEvent.DOM_VK_SPACE &&
+         event.keyCode != KeyEvent.DOM_VK_RETURN)) {
+      return;
+    }
+
+    // If the activated-action panel is open and anchored to the main button,
+    // close it.
+    let panelNode = this.activatedActionPanelNode;
+    if (panelNode && panelNode.anchorNode.id == this.mainButtonNode.id) {
+      panelNode.hidePopup();
+      return;
+    }
+
+    if (this.panelNode.state == "open") {
+      this.panelNode.hidePopup();
+    } else if (this.panelNode.state == "closed") {
+      this.showPanel(event);
+    }
+  },
+
+  /**
+   * Show the page action panel
+   *
+   * @param  event (DOM event, optional)
+   *         The event that triggers showing the panel. (such as a mouse click,
+   *         if the user clicked something to open the panel)
+   */
+  showPanel(event = null) {
+    for (let action of PageActions.actions) {
+      let buttonNode = this.panelButtonNodeForActionID(action.id);
+      action.onShowingInPanel(buttonNode);
+    }
+
+    this.panelNode.hidden = false;
+    this.panelNode.addEventListener("popuphiding", () => {
+      this.mainButtonNode.removeAttribute("open");
+    }, {once: true});
+    this.mainButtonNode.setAttribute("open", "true");
+    this.panelNode.openPopup(this.mainButtonNode, {
+      position: "bottomcenter topright",
+      triggerEvent: event,
+    });
+  },
+
+  /**
+   * Call this on the context menu's popupshowing event.
+   *
+   * @param  event (DOM event, required)
+   *         The popupshowing event.
+   * @param  popup (DOM node, required)
+   *         The context menu popup DOM node.
+   */
+  onContextMenuShowing(event, popup) {
+    if (event.target != popup) {
+      return;
+    }
+
+    this._contextAction = this.actionForNode(popup.triggerNode);
+    if (!this._contextAction) {
+      event.preventDefault();
+      return;
+    }
+
+    let state;
+    if (this._contextAction._isBuiltIn) {
+      state =
+        this._contextAction.pinnedToUrlbar ?
+        "builtInPinned" :
+        "builtInUnpinned";
+    } else {
+      state =
+        this._contextAction.pinnedToUrlbar ?
+        "extensionPinned" :
+        "extensionUnpinned";
+    }
+    popup.setAttribute("state", state);
+  },
+
+  /**
+   * Call this from the menu item in the context menu that toggles pinning.
+   */
+  togglePinningForContextAction() {
+    if (!this._contextAction) {
+      return;
+    }
+    let action = this._contextAction;
+    this._contextAction = null;
+
+    let telemetryType = action.pinnedToUrlbar ? "removed" : "added";
+    PageActions.logTelemetry(telemetryType, action);
+
+    action.pinnedToUrlbar = !action.pinnedToUrlbar;
+  },
+
+  /**
+   * Call this from the menu item in the context menu that opens about:addons.
+   */
+  openAboutAddonsForContextAction() {
+    if (!this._contextAction) {
+      return;
+    }
+    let action = this._contextAction;
+    this._contextAction = null;
+
+    PageActions.logTelemetry("managed", action);
+
+    let viewID = "addons://detail/" + encodeURIComponent(action.extensionID);
+    window.BrowserOpenAddonsMgr(viewID);
+  },
+
+  _contextAction: null,
+
+  /**
+   * Titles for a few of the built-in actions are defined in DTD, but the
+   * actions are created in JS.  So what we do is for each title, set an
+   * attribute in markup on the main page action panel whose value is the DTD
+   * string.  In gBuiltInActions, where the built-in actions are defined, we set
+   * the action's initial title to the name of this attribute.  Then when the
+   * action is set up, we get the action's current title, and then get the
+   * attribute on the main panel whose name is that title.  If the attribute
+   * exists, then its value is the actual title, and we update the action with
+   * this title.  Otherwise the action's title has already been set up in this
+   * manner.
+   *
+   * @param  action (PageActions.Action, required)
+   *         The action whose title you're setting.
+   */
+  takeActionTitleFromPanel(action) {
+    let titleOrAttrNameOnPanel = action.getTitle();
+    let attrValueOnPanel = this.panelNode.getAttribute(titleOrAttrNameOnPanel);
+    if (attrValueOnPanel) {
+      this.panelNode.removeAttribute(titleOrAttrNameOnPanel);
+      action.setTitle(attrValueOnPanel);
+    }
+  },
+
+  /**
+   * This is similar to takeActionTitleFromPanel, except it sets an attribute on
+   * a DOM node instead of setting the title on an action.  The point is to map
+   * attributes on the node to strings on the main panel.  Use this for DOM
+   * nodes that don't correspond to actions, like buttons in subviews.
+   *
+   * @param  node (DOM node, required)
+   *         The node you're setting up.
+   * @param  attrName (string, required)
+   *         The name of the attribute *on the node you're setting up*.
+   */
+  takeNodeAttributeFromPanel(node, attrName) {
+    let panelAttrName = node.getAttribute(attrName);
+    if (!panelAttrName && attrName == "title") {
+      attrName = "label";
+      panelAttrName = node.getAttribute(attrName);
+    }
+    if (panelAttrName) {
+      let attrValue = this.panelNode.getAttribute(panelAttrName);
+      if (attrValue) {
+        node.setAttribute(attrName, attrValue);
+      }
+    }
+  },
+
+  /**
+   * Call this on tab switch or when the current <browser>'s location changes.
+   */
+  onLocationChange() {
+    for (let action of PageActions.actions) {
+      action.onLocationChange(window);
+    }
+  },
+};
+
+
+var BrowserPageActionFeedback = {
+  /**
+   * The feedback page action panel DOM node (DOM node)
+   */
+  get panelNode() {
+    delete this.panelNode;
+    return this.panelNode = document.getElementById("pageActionFeedback");
+  },
+
+  get feedbackAnimationBox() {
+    delete this.feedbackAnimationBox;
+    return this.feedbackAnimationBox = document.getElementById("pageActionFeedbackAnimatableBox");
+  },
+
+  get feedbackLabel() {
+    delete this.feedbackLabel;
+    return this.feedbackLabel = document.getElementById("pageActionFeedbackMessage");
+  },
+
+  show(action, event, textContentOverride) {
+    this.feedbackLabel.textContent = this.panelNode.getAttribute((textContentOverride || action.id) + "Feedback");
+    this.panelNode.hidden = false;
+
+    let anchor = BrowserPageActions.panelAnchorNodeForAction(action, event);
+    this.panelNode.openPopup(anchor, {
+      position: "bottomcenter topright",
+      triggerEvent: event,
+    });
+
+    this.panelNode.addEventListener("popupshown", () => {
+      this.feedbackAnimationBox.setAttribute("animate", "true");
+
+      // The timeout value used here allows the panel to stay open for
+      // 1 second after the text transition (duration=120ms) has finished.
+      setTimeout(() => {
+        this.panelNode.hidePopup(true);
+      }, Services.prefs.getIntPref("browser.pageActions.feedbackTimeoutMS", 1120));
+    }, {once: true});
+    this.panelNode.addEventListener("popuphidden", () => {
+      this.feedbackAnimationBox.removeAttribute("animate");
+    }, {once: true});
+  },
+};
+
+
+// built-in actions below //////////////////////////////////////////////////////
+
+// bookmark
+BrowserPageActions.bookmark = {
+  onShowingInPanel(buttonNode) {
+    // Update the button label via the bookmark observer.
+    BookmarkingUI.updateBookmarkPageMenuItem();
+  },
+
+  onCommand(event, buttonNode) {
+    BrowserPageActions.panelNode.hidePopup();
+    BookmarkingUI.onStarCommand(event);
+  },
+};
+
+// copy URL
+BrowserPageActions.copyURL = {
+  onPlacedInPanel(buttonNode) {
+    let action = PageActions.actionForID("copyURL");
+    BrowserPageActions.takeActionTitleFromPanel(action);
+  },
+
+  onCommand(event, buttonNode) {
+    BrowserPageActions.panelNode.hidePopup();
+    Cc["@mozilla.org/widget/clipboardhelper;1"]
+      .getService(Ci.nsIClipboardHelper)
+      .copyString(gURLBar.makeURIReadable(gBrowser.selectedBrowser.currentURI).displaySpec);
+    let action = PageActions.actionForID("copyURL");
+    BrowserPageActionFeedback.show(action, event);
+  },
+};
+
+// email link
+BrowserPageActions.emailLink = {
+  onPlacedInPanel(buttonNode) {
+    let action = PageActions.actionForID("emailLink");
+    BrowserPageActions.takeActionTitleFromPanel(action);
+  },
+
+  onCommand(event, buttonNode) {
+    BrowserPageActions.panelNode.hidePopup();
+    MailIntegration.sendLinkForBrowser(gBrowser.selectedBrowser);
+  },
+};
+
+// send to device
+BrowserPageActions.sendToDevice = {
+  onPlacedInPanel(buttonNode) {
+    let action = PageActions.actionForID("sendToDevice");
+    BrowserPageActions.takeActionTitleFromPanel(action);
+  },
+
+  onSubviewPlaced(panelViewNode) {
+    let bodyNode = panelViewNode.querySelector(".panel-subview-body");
+    for (let node of bodyNode.childNodes) {
+      BrowserPageActions.takeNodeAttributeFromPanel(node, "title");
+      BrowserPageActions.takeNodeAttributeFromPanel(node, "shortcut");
+    }
+  },
+
+  onLocationChange() {
+    let action = PageActions.actionForID("sendToDevice");
+    let browser = gBrowser.selectedBrowser;
+    let url = browser.currentURI.spec;
+    action.setDisabled(!gSync.isSendableURI(url), window);
+  },
+
+  onShowingSubview(panelViewNode) {
+    let browser = gBrowser.selectedBrowser;
+    let url = browser.currentURI.spec;
+    let title = browser.contentTitle;
+
+    let bodyNode = panelViewNode.querySelector(".panel-subview-body");
+    let panelNode = panelViewNode.closest("panel");
+
+    // This is on top because it also clears the device list between state
+    // changes.
+    gSync.populateSendTabToDevicesMenu(bodyNode, url, title, (clientId, name, clientType, lastModified) => {
+      if (!name) {
+        return document.createElement("toolbarseparator");
+      }
+      let item = document.createElement("toolbarbutton");
+      item.classList.add("pageAction-sendToDevice-device", "subviewbutton");
+      if (clientId) {
+        item.classList.add("subviewbutton-iconic");
+        item.setAttribute("tooltiptext", gSync.formatLastSyncDate(lastModified));
+      }
+
+      item.addEventListener("command", event => {
+        if (panelNode) {
+          panelNode.hidePopup();
+        }
+        // There are items in the subview that don't represent devices: "Sign
+        // in", "Learn about Sync", etc.  Device items will be .sendtab-target.
+        if (event.target.classList.contains("sendtab-target")) {
+          let action = PageActions.actionForID("sendToDevice");
+          let textOverride = gSync.offline && "sendToDeviceOffline";
+          BrowserPageActionFeedback.show(action, event, textOverride);
+        }
+      });
+      return item;
+    });
+
+    bodyNode.removeAttribute("state");
+    // In the first ~10 sec after startup, Sync may not be loaded and the list
+    // of devices will be empty.
+    if (gSync.syncConfiguredAndLoading) {
+      bodyNode.setAttribute("state", "notready");
+      // Force a background Sync
+      Services.tm.dispatchToMainThread(async () => {
+        await Weave.Service.sync({why: "pageactions", engines: []}); // [] = clients engine only
+        // There's no way Sync is still syncing at this point, but we check
+        // anyway to avoid infinite looping.
+        if (!window.closed && !gSync.syncConfiguredAndLoading) {
+          this.onShowingSubview(panelViewNode);
+        }
+      });
+    }
+  },
+};
+
+
+/***/ }),
+/* 7 */
+/***/ (function(module, exports) {
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This file is loaded into the browser window scope.
+/* eslint-env mozilla/browser-window */
+
+XPCOMUtils.defineLazyScriptGetter(this, ["PlacesToolbar", "PlacesMenu",
+                                         "PlacesPanelview", "PlacesPanelMenuView"],
+                                  "chrome://browser/content/places/browserPlacesViews.js");
+
+var StarUI = {
+  _itemGuids: null,
+  // TODO (bug 1131491): _itemIdsMap is only used for the old transactions manager.
+  _itemIdsMap: null,
+  _batching: false,
+  _isNewBookmark: false,
+  _isComposing: false,
+  _autoCloseTimer: 0,
+  // The autoclose timer is diasbled if the user interacts with the
+  // popup, such as making a change through typing or clicking on
+  // the popup.
+  _autoCloseTimerEnabled: true,
+  _removeBookmarksOnPopupHidden: false,
+
+  _element(aID) {
+    return document.getElementById(aID);
+  },
+
+  // Edit-bookmark panel
+  get panel() {
+    delete this.panel;
+    var element = this._element("editBookmarkPanel");
+    // initially the panel is hidden
+    // to avoid impacting startup / new window performance
+    element.hidden = false;
+    element.addEventListener("keypress", this);
+    element.addEventListener("mousedown", this);
+    element.addEventListener("mouseout", this);
+    element.addEventListener("mousemove", this);
+    element.addEventListener("compositionstart", this);
+    element.addEventListener("compositionend", this);
+    element.addEventListener("input", this);
+    element.addEventListener("popuphidden", this);
+    element.addEventListener("popupshown", this);
+    return this.panel = element;
+  },
+
+  // Array of command elements to disable when the panel is opened.
+  get _blockedCommands() {
+    delete this._blockedCommands;
+    return this._blockedCommands =
+      ["cmd_close", "cmd_closeWindow"].map(id => this._element(id));
+  },
+
+  _blockCommands: function SU__blockCommands() {
+    this._blockedCommands.forEach(function(elt) {
+      // make sure not to permanently disable this item (see bug 409155)
+      if (elt.hasAttribute("wasDisabled"))
+        return;
+      if (elt.getAttribute("disabled") == "true") {
+        elt.setAttribute("wasDisabled", "true");
+      } else {
+        elt.setAttribute("wasDisabled", "false");
+        elt.setAttribute("disabled", "true");
+      }
+    });
+  },
+
+  _restoreCommandsState: function SU__restoreCommandsState() {
+    this._blockedCommands.forEach(function(elt) {
+      if (elt.getAttribute("wasDisabled") != "true")
+        elt.removeAttribute("disabled");
+      elt.removeAttribute("wasDisabled");
+    });
+  },
+
+  // nsIDOMEventListener
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "mousemove":
+        clearTimeout(this._autoCloseTimer);
+        // The autoclose timer is not disabled on generic mouseout
+        // because the user may not have actually interacted with the popup.
+        break;
+      case "popuphidden": {
+        clearTimeout(this._autoCloseTimer);
+        if (aEvent.originalTarget == this.panel) {
+          if (!this._element("editBookmarkPanelContent").hidden)
+            this.quitEditMode();
+
+          if (this._anchorToolbarButton) {
+            this._anchorToolbarButton.removeAttribute("open");
+            this._anchorToolbarButton = null;
+          }
+          this._restoreCommandsState();
+          let removeBookmarksOnPopupHidden = this._removeBookmarksOnPopupHidden;
+          this._removeBookmarksOnPopupHidden = false;
+          let idsForRemoval = this._itemIdsMap;
+          let guidsForRemoval = this._itemGuids;
+          this._itemGuids = null;
+          this._itemIdsMap = null;
+
+          if (this._batching) {
+            this.endBatch();
+          }
+
+          if (removeBookmarksOnPopupHidden && guidsForRemoval) {
+            if (this._isNewBookmark) {
+              if (!PlacesUIUtils.useAsyncTransactions) {
+                PlacesUtils.transactionManager.undoTransaction();
+                break;
+              }
+              PlacesTransactions.undo().catch(Cu.reportError);
+              break;
+            }
+            // Remove all bookmarks for the bookmark's url, this also removes
+            // the tags for the url.
+            if (!PlacesUIUtils.useAsyncTransactions) {
+              if (idsForRemoval) {
+                for (let itemId of idsForRemoval.values()) {
+                  let txn = new PlacesRemoveItemTransaction(itemId);
+                  PlacesUtils.transactionManager.doTransaction(txn);
+                }
+              }
+              break;
+            }
+
+            PlacesTransactions.Remove(guidsForRemoval)
+                              .transact().catch(Cu.reportError);
+          } else if (this._isNewBookmark) {
+            LibraryUI.triggerLibraryAnimation("bookmark");
+          }
+        }
+        break;
+      }
+      case "keypress":
+        clearTimeout(this._autoCloseTimer);
+        this._autoCloseTimerEnabled = false;
+
+        if (aEvent.defaultPrevented) {
+          // The event has already been consumed inside of the panel.
+          break;
+        }
+
+        switch (aEvent.keyCode) {
+          case KeyEvent.DOM_VK_ESCAPE:
+            this.panel.hidePopup();
+            break;
+          case KeyEvent.DOM_VK_RETURN:
+            if (aEvent.target.classList.contains("expander-up") ||
+                aEvent.target.classList.contains("expander-down") ||
+                aEvent.target.id == "editBMPanel_newFolderButton" ||
+                aEvent.target.id == "editBookmarkPanelRemoveButton") {
+              // XXX Why is this necessary? The defaultPrevented check should
+              //    be enough.
+              break;
+            }
+            this.panel.hidePopup();
+            break;
+          // This case is for catching character-generating keypresses
+          case 0:
+            let accessKey = document.getElementById("key_close");
+            if (eventMatchesKey(aEvent, accessKey)) {
+                this.panel.hidePopup();
+            }
+            break;
+        }
+        break;
+      case "compositionend":
+        // After composition is committed, "mouseout" or something can set
+        // auto close timer.
+        this._isComposing = false;
+        break;
+      case "compositionstart":
+        if (aEvent.defaultPrevented) {
+          // If the composition was canceled, nothing to do here.
+          break;
+        }
+        this._isComposing = true;
+        // Explicit fall-through, during composition, panel shouldn't be
+        // hidden automatically.
+      case "input":
+        // Might have edited some text without keyboard events nor composition
+        // events. Fall-through to cancel auto close in such case.
+      case "mousedown":
+        clearTimeout(this._autoCloseTimer);
+        this._autoCloseTimerEnabled = false;
+        break;
+      case "mouseout":
+        if (!this._autoCloseTimerEnabled) {
+          // Don't autoclose the popup if the user has made a selection
+          // or keypress and then subsequently mouseout.
+          break;
+        }
+        // Explicit fall-through
+      case "popupshown":
+        // Don't handle events for descendent elements.
+        if (aEvent.target != aEvent.currentTarget) {
+          break;
+        }
+        // auto-close if new and not interacted with
+        if (this._isNewBookmark && !this._isComposing) {
+          // 3500ms matches the timeout that Pocket uses in
+          // browser/extensions/pocket/content/panels/js/saved.js
+          let delay = 3500;
+          if (this._closePanelQuickForTesting) {
+            delay /= 10;
+          }
+          clearTimeout(this._autoCloseTimer);
+          this._autoCloseTimer = setTimeout(() => {
+            if (!this.panel.mozMatchesSelector(":hover")) {
+              this.panel.hidePopup(true);
+            }
+          }, delay);
+          this._autoCloseTimerEnabled = true;
+        }
+        break;
+    }
+  },
+
+  _overlayLoaded: false,
+  _overlayLoading: false,
+  async showEditBookmarkPopup(aNode, aAnchorElement, aPosition, aIsNewBookmark, aUrl) {
+    // Slow double-clicks (not true double-clicks) shouldn't
+    // cause the panel to flicker.
+    if (this.panel.state == "showing" ||
+        this.panel.state == "open") {
+      return;
+    }
+
+    this._isNewBookmark = aIsNewBookmark;
+    this._itemIdsMap = null;
+    this._itemGuids = null;
+    // TODO (bug 1131491): Deprecate this once async transactions are enabled
+    // and the legacy transactions code is gone.
+    if (typeof(aNode) == "number") {
+      let itemId = aNode;
+      let guid = await PlacesUtils.promiseItemGuid(itemId);
+      aNode = await PlacesUIUtils.fetchNodeLike(guid);
+    }
+
+    // Performance: load the overlay the first time the panel is opened
+    // (see bug 392443).
+    if (this._overlayLoading)
+      return;
+
+    if (this._overlayLoaded) {
+      await this._doShowEditBookmarkPanel(aNode, aAnchorElement, aPosition, aUrl);
+      return;
+    }
+
+    this._overlayLoading = true;
+    document.loadOverlay(
+      "chrome://browser/content/places/editBookmarkOverlay.xul",
+      (aSubject, aTopic, aData) => {
+        // Move the header (star, title, button) into the grid,
+        // so that it aligns nicely with the other items (bug 484022).
+        let header = this._element("editBookmarkPanelHeader");
+        let rows = this._element("editBookmarkPanelGrid").lastChild;
+        rows.insertBefore(header, rows.firstChild);
+        header.hidden = false;
+
+        this._overlayLoading = false;
+        this._overlayLoaded = true;
+        this._doShowEditBookmarkPanel(aNode, aAnchorElement, aPosition, aUrl);
+      }
+    );
+  },
+
+  async _doShowEditBookmarkPanel(aNode, aAnchorElement, aPosition, aUrl) {
+    if (this.panel.state != "closed")
+      return;
+
+    this._blockCommands(); // un-done in the popuphidden handler
+
+    this._element("editBookmarkPanelTitle").value =
+      this._isNewBookmark ?
+        gNavigatorBundle.getString("editBookmarkPanel.pageBookmarkedTitle") :
+        gNavigatorBundle.getString("editBookmarkPanel.editBookmarkTitle");
+
+    // No description; show the Done, Remove;
+    this._element("editBookmarkPanelDescription").textContent = "";
+    this._element("editBookmarkPanelBottomButtons").hidden = false;
+    this._element("editBookmarkPanelContent").hidden = false;
+
+    // The label of the remove button differs if the URI is bookmarked
+    // multiple times.
+    this._itemGuids = [];
+
+    await PlacesUtils.bookmarks.fetch({url: aUrl},
+      bookmark => this._itemGuids.push(bookmark.guid));
+
+    if (!PlacesUIUtils.useAsyncTransactions) {
+      this._itemIdsMap = await PlacesUtils.promiseManyItemIds(this._itemGuids);
+    }
+    let forms = gNavigatorBundle.getString("editBookmark.removeBookmarks.label");
+    let bookmarksCount = this._itemGuids.length;
+    let label = PluralForm.get(bookmarksCount, forms)
+                          .replace("#1", bookmarksCount);
+    this._element("editBookmarkPanelRemoveButton").label = label;
+
+    this.beginBatch();
+
+    if (aAnchorElement && aAnchorElement.closest("#urlbar")) {
+      this._anchorToolbarButton = aAnchorElement;
+      aAnchorElement.setAttribute("open", "true");
+    } else {
+      this._anchorToolbarButton = null;
+    }
+
+    let onPanelReady = fn => {
+      let target = this.panel;
+      if (target.parentNode) {
+        // By targeting the panel's parent and using a capturing listener, we
+        // can have our listener called before others waiting for the panel to
+        // be shown (which probably expect the panel to be fully initialized)
+        target = target.parentNode;
+      }
+      target.addEventListener("popupshown", function(event) {
+        fn();
+      }, {"capture": true, "once": true});
+    };
+    gEditItemOverlay.initPanel({ node: aNode,
+                                 onPanelReady,
+                                 hiddenRows: ["description", "location",
+                                              "loadInSidebar", "keyword"],
+                                 focusedElement: "preferred"});
+    this.panel.openPopup(aAnchorElement, aPosition);
+  },
+
+  panelShown:
+  function SU_panelShown(aEvent) {
+    if (aEvent.target == this.panel) {
+      if (this._element("editBookmarkPanelContent").hidden) {
+        // Note this isn't actually used anymore, we should remove this
+        // once we decide not to bring back the page bookmarked notification
+        this.panel.focus();
+      }
+    }
+  },
+
+  quitEditMode: function SU_quitEditMode() {
+    this._element("editBookmarkPanelContent").hidden = true;
+    this._element("editBookmarkPanelBottomButtons").hidden = true;
+    gEditItemOverlay.uninitPanel(true);
+  },
+
+  removeBookmarkButtonCommand: function SU_removeBookmarkButtonCommand() {
+    this._removeBookmarksOnPopupHidden = true;
+    this.panel.hidePopup();
+  },
+
+  // Matching the way it is used in the Library, editBookmarkOverlay implements
+  // an instant-apply UI, having no batched-Undo/Redo support.
+  // However, in this context (the Star UI) we have a Cancel button whose
+  // expected behavior is to undo all the operations done in the panel.
+  // Sometime in the future this needs to be reimplemented using a
+  // non-instant apply code path, but for the time being, we patch-around
+  // editBookmarkOverlay so that all of the actions done in the panel
+  // are treated by PlacesTransactions as a single batch.  To do so,
+  // we start a PlacesTransactions batch when the star UI panel is shown, and
+  // we keep the batch ongoing until the panel is hidden.
+  _batchBlockingDeferred: null,
+  beginBatch() {
+    if (this._batching)
+      return;
+    if (PlacesUIUtils.useAsyncTransactions) {
+      this._batchBlockingDeferred = PromiseUtils.defer();
+      PlacesTransactions.batch(async () => {
+        await this._batchBlockingDeferred.promise;
+      });
+    } else {
+      PlacesUtils.transactionManager.beginBatch(null);
+    }
+    this._batching = true;
+  },
+
+  endBatch() {
+    if (!this._batching)
+      return;
+
+    if (PlacesUIUtils.useAsyncTransactions) {
+      this._batchBlockingDeferred.resolve();
+      this._batchBlockingDeferred = null;
+    } else {
+      PlacesUtils.transactionManager.endBatch(false);
+    }
+    this._batching = false;
+  }
+};
+
+// Checks if an element is visible without flushing layout changes.
+function isVisible(element) {
+  let windowUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                          .getInterface(Ci.nsIDOMWindowUtils);
+  let bounds = windowUtils.getBoundsWithoutFlushing(element);
+  return bounds.height > 0 && bounds.width > 0;
+}
+
+var PlacesCommandHook = {
+  /**
+   * Adds a bookmark to the page loaded in the given browser.
+   *
+   * @param aBrowser
+   *        a <browser> element.
+   * @param [optional] aShowEditUI
+   *        whether or not to show the edit-bookmark UI for the bookmark item
+   * @param [optional] aUrl
+   *        Option to provide a URL to bookmark rather than the current page
+   * @param [optional] aTitle
+   *        Option to provide a title for a bookmark to use rather than the
+   *        getting the current page's title
+   */
+  async bookmarkPage(aBrowser, aShowEditUI, aUrl = null, aTitle = null) {
+    if (PlacesUIUtils.useAsyncTransactions) {
+      await this._bookmarkPagePT(aBrowser, aShowEditUI, aUrl, aTitle);
+      return;
+    }
+
+    // If aUrl is provided, we want to bookmark that url rather than the
+    // the current page
+    var uri = aUrl ? Services.io.newURI(aUrl) : aBrowser.currentURI;
+    var itemId = PlacesUtils.getMostRecentBookmarkForURI(uri);
+    let isNewBookmark = itemId == -1;
+    if (isNewBookmark) {
+      // Bug 1148838 - Make this code work for full page plugins.
+      var title;
+      var description;
+      var charset;
+
+      let docInfo = aUrl ? {} : await this._getPageDetails(aBrowser);
+
+      try {
+        title = aTitle ||
+                (docInfo.isErrorPage ? PlacesUtils.history.getPageTitle(uri)
+                                     : aBrowser.contentTitle) ||
+                uri.displaySpec;
+        description = docInfo.description;
+        charset = aUrl ? null : aBrowser.characterSet;
+      } catch (e) { }
+
+      if (aShowEditUI) {
+        // If we bookmark the page here but open right into a cancelable
+        // state (i.e. new bookmark in Library), start batching here so
+        // all of the actions can be undone in a single undo step.
+        StarUI.beginBatch();
+      }
+
+      var descAnno = { name: PlacesUIUtils.DESCRIPTION_ANNO, value: description };
+      var txn = new PlacesCreateBookmarkTransaction(uri,
+                                                    PlacesUtils.unfiledBookmarksFolderId,
+                                                    PlacesUtils.bookmarks.DEFAULT_INDEX,
+                                                    title, null, [descAnno]);
+      PlacesUtils.transactionManager.doTransaction(txn);
+      itemId = txn.item.id;
+      // Set the character-set.
+      if (charset && !PrivateBrowsingUtils.isBrowserPrivate(aBrowser))
+        PlacesUtils.setCharsetForURI(uri, charset);
+    }
+
+    // Revert the contents of the location bar
+    gURLBar.handleRevert();
+
+    // If it was not requested to open directly in "edit" mode, we are done.
+    if (!aShowEditUI)
+      return;
+
+    let anchor = BookmarkingUI.anchor;
+    if (anchor) {
+      await StarUI.showEditBookmarkPopup(itemId, anchor,
+                                         "bottomcenter topright", isNewBookmark,
+                                         uri);
+      return;
+    }
+
+    // Fall back to showing the panel over the content area.
+    await StarUI.showEditBookmarkPopup(itemId, aBrowser, "overlap",
+                                       isNewBookmark, uri);
+  },
+
+  // TODO: Replace bookmarkPage code with this function once legacy
+  // transactions are removed.
+  async _bookmarkPagePT(aBrowser, aShowEditUI, aUrl, aTitle) {
+    // If aUrl is provided, we want to bookmark that url rather than the
+    // the current page
+    let url = aUrl ? new URL(aUrl) : new URL(aBrowser.currentURI.spec);
+    let info = await PlacesUtils.bookmarks.fetch({ url });
+    let isNewBookmark = !info;
+    if (!info) {
+      let parentGuid = PlacesUtils.bookmarks.unfiledGuid;
+      info = { url, parentGuid };
+      // Bug 1148838 - Make this code work for full page plugins.
+      let description = null;
+      let charset = null;
+
+      let docInfo = aUrl ? {} : await this._getPageDetails(aBrowser);
+
+      try {
+        if (docInfo.isErrorPage) {
+          let entry = await PlacesUtils.history.fetch(aBrowser.currentURI);
+          if (entry) {
+            info.title = entry.title;
+          }
+        } else {
+          info.title = aTitle || aBrowser.contentTitle;
+        }
+        info.title = info.title || url.href;
+        description = docInfo.description;
+        charset = aUrl ? null : aBrowser.characterSet;
+      } catch (e) {
+        Components.utils.reportError(e);
+      }
+
+      if (aShowEditUI && isNewBookmark) {
+        // If we bookmark the page here but open right into a cancelable
+        // state (i.e. new bookmark in Library), start batching here so
+        // all of the actions can be undone in a single undo step.
+        StarUI.beginBatch();
+      }
+
+      if (description) {
+        info.annotations = [{ name: PlacesUIUtils.DESCRIPTION_ANNO,
+                              value: description }];
+      }
+
+      info.guid = await PlacesTransactions.NewBookmark(info).transact();
+
+      // Set the character-set
+      if (charset && !PrivateBrowsingUtils.isBrowserPrivate(aBrowser))
+         PlacesUtils.setCharsetForURI(makeURI(url.href), charset);
+    }
+
+    // Revert the contents of the location bar
+    gURLBar.handleRevert();
+
+    // If it was not requested to open directly in "edit" mode, we are done.
+    if (!aShowEditUI)
+      return;
+
+    let node = await PlacesUIUtils.promiseNodeLikeFromFetchInfo(info);
+
+    let anchor = BookmarkingUI.anchor;
+    if (anchor) {
+      await StarUI.showEditBookmarkPopup(node, anchor, "bottomcenter topright",
+                                         isNewBookmark, url);
+      return;
+    }
+
+    // Fall back to showing the panel over the content area.
+    await StarUI.showEditBookmarkPopup(node, aBrowser, "overlap", isNewBookmark,
+                                       url);
+  },
+
+  _getPageDetails(browser) {
+    return new Promise(resolve => {
+      let mm = browser.messageManager;
+      mm.addMessageListener("Bookmarks:GetPageDetails:Result", function listener(msg) {
+        mm.removeMessageListener("Bookmarks:GetPageDetails:Result", listener);
+        resolve(msg.data);
+      });
+
+      mm.sendAsyncMessage("Bookmarks:GetPageDetails", { });
+    });
+  },
+
+  /**
+   * Adds a bookmark to the page targeted by a link.
+   * @param parentId
+   *        The folder in which to create a new bookmark if aURL isn't
+   *        bookmarked.
+   * @param url (string)
+   *        the address of the link target
+   * @param title
+   *        The link text
+   * @param [optional] description
+   *        The linked page description, if available
+   */
+  async bookmarkLink(parentId, url, title, description = "") {
+    let node = await PlacesUIUtils.fetchNodeLike({ url });
+    if (node) {
+      PlacesUIUtils.showBookmarkDialog({ action: "edit", node }, window.top);
+      return;
+    }
+
+    let parentGuid = parentId == PlacesUtils.bookmarksMenuFolderId ?
+                       PlacesUtils.bookmarks.menuGuid :
+                       await PlacesUtils.promiseItemGuid(parentId);
+    let defaultInsertionPoint = new InsertionPoint({ parentId, parentGuid });
+    PlacesUIUtils.showBookmarkDialog({ action: "add",
+                                       type: "bookmark",
+                                       uri: makeURI(url),
+                                       title,
+                                       description,
+                                       defaultInsertionPoint,
+                                       hiddenRows: [ "description",
+                                                     "location",
+                                                     "loadInSidebar",
+                                                     "keyword" ]
+                                     }, window.top);
+  },
+
+  /**
+   * List of nsIURI objects characterizing the tabs currently open in the
+   * browser, modulo pinned tabs.  The URIs will be in the order in which their
+   * corresponding tabs appeared and duplicates are discarded.
+   */
+  get uniqueCurrentPages() {
+    let uniquePages = {};
+    let URIs = [];
+
+    gBrowser.visibleTabs.forEach(tab => {
+      let browser = tab.linkedBrowser;
+      let uri = browser.currentURI;
+      let title = browser.contentTitle || tab.label;
+      let spec = uri.spec;
+      if (!tab.pinned && !(spec in uniquePages)) {
+        uniquePages[spec] = null;
+        URIs.push({ uri, title });
+      }
+    });
+    return URIs;
+  },
+
+  /**
+   * Adds a folder with bookmarks to all of the currently open tabs in this
+   * window.
+   */
+  bookmarkCurrentPages: function PCH_bookmarkCurrentPages() {
+    let pages = this.uniqueCurrentPages;
+    if (pages.length > 1) {
+    PlacesUIUtils.showBookmarkDialog({ action: "add",
+                                       type: "folder",
+                                       URIList: pages,
+                                       hiddenRows: [ "description" ]
+                                     }, window);
+    }
+  },
+
+  /**
+   * Updates disabled state for the "Bookmark All Tabs" command.
+   */
+  updateBookmarkAllTabsCommand:
+  function PCH_updateBookmarkAllTabsCommand() {
+    // There's nothing to do in non-browser windows.
+    if (window.location.href != getBrowserURL())
+      return;
+
+    // Disable "Bookmark All Tabs" if there are less than two
+    // "unique current pages".
+    goSetCommandEnabled("Browser:BookmarkAllTabs",
+                        this.uniqueCurrentPages.length >= 2);
+  },
+
+  /**
+   * Adds a Live Bookmark to a feed associated with the current page.
+   * @param     url
+   *            The nsIURI of the page the feed was attached to
+   * @title     title
+   *            The title of the feed. Optional.
+   * @subtitle  subtitle
+   *            A short description of the feed. Optional.
+   */
+  async addLiveBookmark(url, feedTitle, feedSubtitle) {
+    let toolbarIP = new InsertionPoint({
+      parentId: PlacesUtils.toolbarFolderId,
+      parentGuid: PlacesUtils.bookmarks.toolbarGuid
+    });
+
+    let feedURI = makeURI(url);
+    let title = feedTitle || gBrowser.contentTitle;
+    let description = feedSubtitle;
+    if (!description) {
+      description = (await this._getPageDetails(gBrowser.selectedBrowser)).description;
+    }
+
+    PlacesUIUtils.showBookmarkDialog({ action: "add",
+                                       type: "livemark",
+                                       feedURI,
+                                       siteURI: gBrowser.currentURI,
+                                       title,
+                                       description,
+                                       defaultInsertionPoint: toolbarIP,
+                                       hiddenRows: [ "feedLocation",
+                                                     "siteLocation",
+                                                     "description" ]
+                                     }, window);
+  },
+
+  /**
+   * Opens the Places Organizer.
+   * @param   aLeftPaneRoot
+   *          The query to select in the organizer window - options
+   *          are: History, AllBookmarks, BookmarksMenu, BookmarksToolbar,
+   *          UnfiledBookmarks, Tags and Downloads.
+   */
+  showPlacesOrganizer: function PCH_showPlacesOrganizer(aLeftPaneRoot) {
+    var organizer = Services.wm.getMostRecentWindow("Places:Organizer");
+    // Due to bug 528706, getMostRecentWindow can return closed windows.
+    if (!organizer || organizer.closed) {
+      // No currently open places window, so open one with the specified mode.
+      openDialog("chrome://browser/content/places/places.xul",
+                 "", "chrome,toolbar=yes,dialog=no,resizable", aLeftPaneRoot);
+    } else {
+      organizer.PlacesOrganizer.selectLeftPaneContainerByHierarchy(aLeftPaneRoot);
+      organizer.focus();
+    }
+  },
+
+  searchBookmarks() {
+    if (!focusAndSelectUrlBar()) {
+      return;
+    }
+    for (let char of ["*", " "]) {
+      let code = char.charCodeAt(0);
+      gURLBar.inputField.dispatchEvent(new KeyboardEvent("keypress", {
+        keyCode: code,
+        charCode: code,
+        bubbles: true
+      }));
+    }
+  }
+};
+
+XPCOMUtils.defineLazyModuleGetter(this, "RecentlyClosedTabsAndWindowsMenuUtils",
+  "resource:///modules/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm");
+
+// View for the history menu.
+function HistoryMenu(aPopupShowingEvent) {
+  // Workaround for Bug 610187.  The sidebar does not include all the Places
+  // views definitions, and we don't need them there.
+  // Defining the prototype inheritance in the prototype itself would cause
+  // browser.js to halt on "PlacesMenu is not defined" error.
+  this.__proto__.__proto__ = PlacesMenu.prototype;
+  PlacesMenu.call(this, aPopupShowingEvent,
+                  "place:sort=4&maxResults=15");
+}
+
+HistoryMenu.prototype = {
+  _getClosedTabCount() {
+    // SessionStore doesn't track the hidden window, so just return zero then.
+    if (window == Services.appShell.hiddenDOMWindow) {
+      return 0;
+    }
+
+    return SessionStore.getClosedTabCount(window);
+  },
+
+  toggleRecentlyClosedTabs: function HM_toggleRecentlyClosedTabs() {
+    // enable/disable the Recently Closed Tabs sub menu
+    var undoMenu = this._rootElt.getElementsByClassName("recentlyClosedTabsMenu")[0];
+
+    // no restorable tabs, so disable menu
+    if (this._getClosedTabCount() == 0)
+      undoMenu.setAttribute("disabled", true);
+    else
+      undoMenu.removeAttribute("disabled");
+  },
+
+  /**
+   * Populate when the history menu is opened
+   */
+  populateUndoSubmenu: function PHM_populateUndoSubmenu() {
+    var undoMenu = this._rootElt.getElementsByClassName("recentlyClosedTabsMenu")[0];
+    var undoPopup = undoMenu.firstChild;
+
+    // remove existing menu items
+    while (undoPopup.hasChildNodes())
+      undoPopup.firstChild.remove();
+
+    // no restorable tabs, so make sure menu is disabled, and return
+    if (this._getClosedTabCount() == 0) {
+      undoMenu.setAttribute("disabled", true);
+      return;
+    }
+
+    // enable menu
+    undoMenu.removeAttribute("disabled");
+
+    // populate menu
+    let tabsFragment = RecentlyClosedTabsAndWindowsMenuUtils.getTabsFragment(window, "menuitem");
+    undoPopup.appendChild(tabsFragment);
+  },
+
+  toggleRecentlyClosedWindows: function PHM_toggleRecentlyClosedWindows() {
+    // enable/disable the Recently Closed Windows sub menu
+    var undoMenu = this._rootElt.getElementsByClassName("recentlyClosedWindowsMenu")[0];
+
+    // no restorable windows, so disable menu
+    if (SessionStore.getClosedWindowCount() == 0)
+      undoMenu.setAttribute("disabled", true);
+    else
+      undoMenu.removeAttribute("disabled");
+  },
+
+  /**
+   * Populate when the history menu is opened
+   */
+  populateUndoWindowSubmenu: function PHM_populateUndoWindowSubmenu() {
+    let undoMenu = this._rootElt.getElementsByClassName("recentlyClosedWindowsMenu")[0];
+    let undoPopup = undoMenu.firstChild;
+
+    // remove existing menu items
+    while (undoPopup.hasChildNodes())
+      undoPopup.firstChild.remove();
+
+    // no restorable windows, so make sure menu is disabled, and return
+    if (SessionStore.getClosedWindowCount() == 0) {
+      undoMenu.setAttribute("disabled", true);
+      return;
+    }
+
+    // enable menu
+    undoMenu.removeAttribute("disabled");
+
+    // populate menu
+    let windowsFragment = RecentlyClosedTabsAndWindowsMenuUtils.getWindowsFragment(window, "menuitem");
+    undoPopup.appendChild(windowsFragment);
+  },
+
+  toggleTabsFromOtherComputers: function PHM_toggleTabsFromOtherComputers() {
+    // Enable/disable the Tabs From Other Computers menu. Some of the menus handled
+    // by HistoryMenu do not have this menuitem.
+    let menuitem = this._rootElt.getElementsByClassName("syncTabsMenuItem")[0];
+    if (!menuitem)
+      return;
+
+    if (!PlacesUIUtils.shouldShowTabsFromOtherComputersMenuitem()) {
+      menuitem.setAttribute("hidden", true);
+      return;
+    }
+
+    menuitem.setAttribute("hidden", false);
+  },
+
+  _onPopupShowing: function HM__onPopupShowing(aEvent) {
+    PlacesMenu.prototype._onPopupShowing.apply(this, arguments);
+
+    // Don't handle events for submenus.
+    if (aEvent.target != aEvent.currentTarget)
+      return;
+
+    this.toggleRecentlyClosedTabs();
+    this.toggleRecentlyClosedWindows();
+    this.toggleTabsFromOtherComputers();
+  },
+
+  _onCommand: function HM__onCommand(aEvent) {
+    let placesNode = aEvent.target._placesNode;
+    if (placesNode) {
+      if (!PrivateBrowsingUtils.isWindowPrivate(window))
+        PlacesUIUtils.markPageAsTyped(placesNode.uri);
+      openUILink(placesNode.uri, aEvent, { ignoreAlt: true });
+    }
+  }
+};
+
+/**
+ * Functions for handling events in the Bookmarks Toolbar and menu.
+ */
+var BookmarksEventHandler = {
+  /**
+   * Handler for click event for an item in the bookmarks toolbar or menu.
+   * Menus and submenus from the folder buttons bubble up to this handler.
+   * Left-click is handled in the onCommand function.
+   * When items are middle-clicked (or clicked with modifier), open in tabs.
+   * If the click came through a menu, close the menu.
+   * @param aEvent
+   *        DOMEvent for the click
+   * @param aView
+   *        The places view which aEvent should be associated with.
+   */
+
+  onMouseUp(aEvent) {
+    // Handles left-click with modifier if not browser.bookmarks.openInTabClosesMenu.
+    if (aEvent.button != 0 || PlacesUIUtils.openInTabClosesMenu)
+      return;
+    let target = aEvent.originalTarget;
+    if (target.tagName != "menuitem")
+      return;
+    let modifKey = AppConstants.platform === "macosx" ? aEvent.metaKey
+                                                      : aEvent.ctrlKey;
+    // Don't keep menu open for 'Open all in Tabs'.
+    if (modifKey && !target.classList.contains("openintabs-menuitem")) {
+      target.setAttribute("closemenu", "none");
+    }
+  },
+
+  onClick: function BEH_onClick(aEvent, aView) {
+    // Only handle middle-click or left-click with modifiers.
+    let modifKey;
+    if (AppConstants.platform == "macosx") {
+      modifKey = aEvent.metaKey || aEvent.shiftKey;
+    } else {
+      modifKey = aEvent.ctrlKey || aEvent.shiftKey;
+    }
+
+    if (aEvent.button == 2 || (aEvent.button == 0 && !modifKey))
+      return;
+
+    var target = aEvent.originalTarget;
+    // If this event bubbled up from a menu or menuitem,
+    // close the menus if browser.bookmarks.openInTabClosesMenu.
+    if ((PlacesUIUtils.openInTabClosesMenu && target.tagName == "menuitem") ||
+        target.tagName == "menu" ||
+        target.classList.contains("openintabs-menuitem")) {
+      closeMenus(aEvent.target);
+    }
+    // Command already precesssed so remove any closemenu attr set in onMouseUp.
+    if (aEvent.button == 0 &&
+        target.tagName == "menuitem" &&
+        target.getAttribute("closemenu") == "none") {
+      // On Mac we need to extend when we remove the flag, to avoid any pre-close
+      // animations.
+      setTimeout(() => {
+        target.removeAttribute("closemenu");
+      }, 500);
+    }
+
+    if (target._placesNode && PlacesUtils.nodeIsContainer(target._placesNode)) {
+      // Don't open the root folder in tabs when the empty area on the toolbar
+      // is middle-clicked or when a non-bookmark item except for Open in Tabs)
+      // in a bookmarks menupopup is middle-clicked.
+      if (target.localName == "menu" || target.localName == "toolbarbutton")
+        PlacesUIUtils.openContainerNodeInTabs(target._placesNode, aEvent, aView);
+    } else if (aEvent.button == 1) {
+      // left-clicks with modifier are already served by onCommand
+      this.onCommand(aEvent);
+    }
+  },
+
+  /**
+   * Handler for command event for an item in the bookmarks toolbar.
+   * Menus and submenus from the folder buttons bubble up to this handler.
+   * Opens the item.
+   * @param aEvent
+   *        DOMEvent for the command
+   */
+  onCommand: function BEH_onCommand(aEvent) {
+    var target = aEvent.originalTarget;
+    if (target._placesNode)
+      PlacesUIUtils.openNodeWithEvent(target._placesNode, aEvent);
+  },
+
+  fillInBHTooltip: function BEH_fillInBHTooltip(aDocument, aEvent) {
+    var node;
+    var cropped = false;
+    var targetURI;
+
+    if (aDocument.tooltipNode.localName == "treechildren") {
+      var tree = aDocument.tooltipNode.parentNode;
+      var tbo = tree.treeBoxObject;
+      var cell = tbo.getCellAt(aEvent.clientX, aEvent.clientY);
+      if (cell.row == -1)
+        return false;
+      node = tree.view.nodeForTreeIndex(cell.row);
+      cropped = tbo.isCellCropped(cell.row, cell.col);
+    } else {
+      // Check whether the tooltipNode is a Places node.
+      // In such a case use it, otherwise check for targetURI attribute.
+      var tooltipNode = aDocument.tooltipNode;
+      if (tooltipNode._placesNode)
+        node = tooltipNode._placesNode;
+      else {
+        // This is a static non-Places node.
+        targetURI = tooltipNode.getAttribute("targetURI");
+      }
+    }
+
+    if (!node && !targetURI)
+      return false;
+
+    // Show node.label as tooltip's title for non-Places nodes.
+    var title = node ? node.title : tooltipNode.label;
+
+    // Show URL only for Places URI-nodes or nodes with a targetURI attribute.
+    var url;
+    if (targetURI || PlacesUtils.nodeIsURI(node))
+      url = targetURI || node.uri;
+
+    // Show tooltip for containers only if their title is cropped.
+    if (!cropped && !url)
+      return false;
+
+    var tooltipTitle = aDocument.getElementById("bhtTitleText");
+    tooltipTitle.hidden = (!title || (title == url));
+    if (!tooltipTitle.hidden)
+      tooltipTitle.textContent = title;
+
+    var tooltipUrl = aDocument.getElementById("bhtUrlText");
+    tooltipUrl.hidden = !url;
+    if (!tooltipUrl.hidden)
+      tooltipUrl.value = url;
+
+    // Show tooltip.
+    return true;
+  }
+};
+
+// Handles special drag and drop functionality for Places menus that are not
+// part of a Places view (e.g. the bookmarks menu in the menubar).
+var PlacesMenuDNDHandler = {
+  _springLoadDelayMs: 350,
+  _closeDelayMs: 500,
+  _loadTimer: null,
+  _closeTimer: null,
+  _closingTimerNode: null,
+
+  /**
+   * Called when the user enters the <menu> element during a drag.
+   * @param   event
+   *          The DragEnter event that spawned the opening.
+   */
+  onDragEnter: function PMDH_onDragEnter(event) {
+    // Opening menus in a Places popup is handled by the view itself.
+    if (!this._isStaticContainer(event.target))
+      return;
+
+    // If we re-enter the same menu or anchor before the close timer runs out,
+    // we should ensure that we do not close:
+    if (this._closeTimer && this._closingTimerNode === event.currentTarget) {
+      this._closeTimer.cancel();
+      this._closingTimerNode = null;
+      this._closeTimer = null;
+    }
+
+    PlacesControllerDragHelper.currentDropTarget = event.target;
+    let popup = event.target.lastChild;
+    if (this._loadTimer || popup.state === "showing" || popup.state === "open")
+      return;
+
+    this._loadTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+    this._loadTimer.initWithCallback(() => {
+      this._loadTimer = null;
+      popup.setAttribute("autoopened", "true");
+      popup.showPopup(popup);
+    }, this._springLoadDelayMs, Ci.nsITimer.TYPE_ONE_SHOT);
+    event.preventDefault();
+    event.stopPropagation();
+  },
+
+  /**
+   * Handles dragleave on the <menu> element.
+   */
+  onDragLeave: function PMDH_onDragLeave(event) {
+    // Handle menu-button separate targets.
+    if (event.relatedTarget === event.currentTarget ||
+        (event.relatedTarget &&
+         event.relatedTarget.parentNode === event.currentTarget))
+      return;
+
+    // Closing menus in a Places popup is handled by the view itself.
+    if (!this._isStaticContainer(event.target))
+      return;
+
+    PlacesControllerDragHelper.currentDropTarget = null;
+    let popup = event.target.lastChild;
+
+    if (this._loadTimer) {
+      this._loadTimer.cancel();
+      this._loadTimer = null;
+    }
+    this._closeTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+    this._closingTimerNode = event.currentTarget;
+    this._closeTimer.initWithCallback(function() {
+      this._closeTimer = null;
+      this._closingTimerNode = null;
+      let node = PlacesControllerDragHelper.currentDropTarget;
+      let inHierarchy = false;
+      while (node && !inHierarchy) {
+        inHierarchy = node == event.target;
+        node = node.parentNode;
+      }
+      if (!inHierarchy && popup && popup.hasAttribute("autoopened")) {
+        popup.removeAttribute("autoopened");
+        popup.hidePopup();
+      }
+    }, this._closeDelayMs, Ci.nsITimer.TYPE_ONE_SHOT);
+  },
+
+  /**
+   * Determines if a XUL element represents a static container.
+   * @returns true if the element is a container element (menu or
+   *`         menu-toolbarbutton), false otherwise.
+   */
+  _isStaticContainer: function PMDH__isContainer(node) {
+    let isMenu = node.localName == "menu" ||
+                 (node.localName == "toolbarbutton" &&
+                  (node.getAttribute("type") == "menu" ||
+                   node.getAttribute("type") == "menu-button"));
+    let isStatic = !("_placesNode" in node) && node.lastChild &&
+                   node.lastChild.hasAttribute("placespopup") &&
+                   !node.parentNode.hasAttribute("placespopup");
+    return isMenu && isStatic;
+  },
+
+  /**
+   * Called when the user drags over the <menu> element.
+   * @param   event
+   *          The DragOver event.
+   */
+  onDragOver: function PMDH_onDragOver(event) {
+    let ip = new InsertionPoint({
+      parentId: PlacesUtils.bookmarksMenuFolderId,
+      parentGuid: PlacesUtils.bookmarks.menuGuid
+    });
+    if (ip && PlacesControllerDragHelper.canDrop(ip, event.dataTransfer))
+      event.preventDefault();
+
+    event.stopPropagation();
+  },
+
+  /**
+   * Called when the user drops on the <menu> element.
+   * @param   event
+   *          The Drop event.
+   */
+  onDrop: function PMDH_onDrop(event) {
+    // Put the item at the end of bookmark menu.
+    let ip = new InsertionPoint({
+      parentId: PlacesUtils.bookmarksMenuFolderId,
+      parentGuid: PlacesUtils.bookmarks.menuGuid
+    });
+    PlacesControllerDragHelper.onDrop(ip, event.dataTransfer);
+    PlacesControllerDragHelper.currentDropTarget = null;
+    event.stopPropagation();
+  }
+};
+
+/**
+ * This object handles the initialization and uninitialization of the bookmarks
+ * toolbar.
+ */
+var PlacesToolbarHelper = {
+  _place: "place:folder=TOOLBAR",
+
+  get _viewElt() {
+    return document.getElementById("PlacesToolbar");
+  },
+
+  init: function PTH_init() {
+    let viewElt = this._viewElt;
+    if (!viewElt || viewElt._placesView)
+      return;
+
+    // CustomizableUI.addListener is idempotent, so we can safely
+    // call this multiple times.
+    CustomizableUI.addListener(this);
+
+    if (!this._isObservingToolbars) {
+      this._isObservingToolbars = true;
+      window.addEventListener("toolbarvisibilitychange", this);
+    }
+
+    // If the bookmarks toolbar item is:
+    // - not in a toolbar, or;
+    // - the toolbar is collapsed, or;
+    // - the toolbar is hidden some other way:
+    // don't initialize.  Also, there is no need to initialize the toolbar if
+    // customizing, because that will happen when the customization is done.
+    let toolbar = this._getParentToolbar(viewElt);
+    if (!toolbar || toolbar.collapsed || this._isCustomizing ||
+        getComputedStyle(toolbar, "").display == "none") {
+      return;
+    }
+
+    new PlacesToolbar(this._place);
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "toolbarvisibilitychange":
+        if (event.target == this._getParentToolbar(this._viewElt))
+          this._resetView();
+        break;
+    }
+  },
+
+  uninit: function PTH_uninit() {
+    if (this._isObservingToolbars) {
+      delete this._isObservingToolbars;
+      window.removeEventListener("toolbarvisibilitychange", this);
+    }
+    CustomizableUI.removeListener(this);
+  },
+
+  customizeStart: function PTH_customizeStart() {
+    try {
+      let viewElt = this._viewElt;
+      if (viewElt && viewElt._placesView)
+        viewElt._placesView.uninit();
+    } finally {
+      this._isCustomizing = true;
+    }
+  },
+
+  customizeDone: function PTH_customizeDone() {
+    this._isCustomizing = false;
+    this.init();
+  },
+
+  onPlaceholderCommand() {
+    let widgetGroup = CustomizableUI.getWidget("personal-bookmarks");
+    let widget = widgetGroup.forWindow(window);
+    if (widget.overflowed ||
+        widgetGroup.areaType == CustomizableUI.TYPE_MENU_PANEL) {
+      PlacesCommandHook.showPlacesOrganizer("BookmarksToolbar");
+    }
+  },
+
+  _getParentToolbar(element) {
+    while (element) {
+      if (element.localName == "toolbar") {
+        return element;
+      }
+      element = element.parentNode;
+    }
+    return null;
+  },
+
+  onWidgetUnderflow(aNode, aContainer) {
+    // The view gets broken by being removed and reinserted by the overflowable
+    // toolbar, so we have to force an uninit and reinit.
+    let win = aNode.ownerGlobal;
+    if (aNode.id == "personal-bookmarks" && win == window) {
+      this._resetView();
+    }
+  },
+
+  onWidgetAdded(aWidgetId, aArea, aPosition) {
+    if (aWidgetId == "personal-bookmarks" && !this._isCustomizing) {
+      // It's possible (with the "Add to Menu", "Add to Toolbar" context
+      // options) that the Places Toolbar Items have been moved without
+      // letting us prepare and handle it with with customizeStart and
+      // customizeDone. If that's the case, we need to reset the views
+      // since they're probably broken from the DOM reparenting.
+      this._resetView();
+    }
+  },
+
+  _resetView() {
+    if (this._viewElt) {
+      // It's possible that the placesView might not exist, and we need to
+      // do a full init. This could happen if the Bookmarks Toolbar Items are
+      // moved to the Menu Panel, and then to the toolbar with the "Add to Toolbar"
+      // context menu option, outside of customize mode.
+      if (this._viewElt._placesView) {
+        this._viewElt._placesView.uninit();
+      }
+      this.init();
+    }
+  },
+};
+
+/**
+ * Handles the Library button in the toolbar.
+ */
+var LibraryUI = {
+  triggerLibraryAnimation(animation) {
+    if (!this.hasOwnProperty("COSMETIC_ANIMATIONS_ENABLED")) {
+      XPCOMUtils.defineLazyPreferenceGetter(this, "COSMETIC_ANIMATIONS_ENABLED",
+        "toolkit.cosmeticAnimations.enabled", true);
+    }
+
+    let libraryButton = document.getElementById("library-button");
+    if (!libraryButton ||
+        libraryButton.getAttribute("cui-areatype") == "menu-panel" ||
+        libraryButton.getAttribute("overflowedItem") == "true" ||
+        !libraryButton.closest("#nav-bar") ||
+        !window.toolbar.visible ||
+        !this.COSMETIC_ANIMATIONS_ENABLED) {
+      return;
+    }
+
+    let animatableBox = document.getElementById("library-animatable-box");
+    let navBar = document.getElementById("nav-bar");
+    let libraryIcon = document.getAnonymousElementByAttribute(libraryButton, "class", "toolbarbutton-icon");
+    let dwu = window.getInterface(Ci.nsIDOMWindowUtils);
+    let iconBounds = dwu.getBoundsWithoutFlushing(libraryIcon);
+    let libraryBounds = dwu.getBoundsWithoutFlushing(libraryButton);
+    let toolboxBounds = dwu.getBoundsWithoutFlushing(gNavToolbox);
+
+    animatableBox.style.setProperty("--toolbox-y", toolboxBounds.y + "px");
+    animatableBox.style.setProperty("--library-button-y", libraryBounds.y + "px");
+    animatableBox.style.setProperty("--library-button-height", libraryBounds.height + "px");
+    animatableBox.style.setProperty("--library-icon-x", iconBounds.x + "px");
+    if (navBar.hasAttribute("brighttext")) {
+      animatableBox.setAttribute("brighttext", "true");
+    } else {
+      animatableBox.removeAttribute("brighttext");
+    }
+    animatableBox.removeAttribute("fade");
+    libraryButton.setAttribute("animate", animation);
+    animatableBox.setAttribute("animate", animation);
+    if (!this._libraryButtonAnimationEndListeners[animation]) {
+      this._libraryButtonAnimationEndListeners[animation] = event => {
+        this._libraryButtonAnimationEndListener(event, animation);
+      };
+    }
+    animatableBox.addEventListener("animationend", this._libraryButtonAnimationEndListeners[animation]);
+
+    window.addEventListener("resize", this._onWindowResize);
+  },
+
+  _libraryButtonAnimationEndListeners: {},
+  _libraryButtonAnimationEndListener(aEvent, animation) {
+    let animatableBox = document.getElementById("library-animatable-box");
+    if (aEvent.animationName.startsWith(`library-${animation}-animation`)) {
+      animatableBox.setAttribute("fade", "true");
+    } else if (aEvent.animationName == `library-${animation}-fade`) {
+      animatableBox.removeEventListener("animationend", LibraryUI._libraryButtonAnimationEndListeners[animation]);
+      animatableBox.removeAttribute("animate");
+      animatableBox.removeAttribute("fade");
+      window.removeEventListener("resize", this._onWindowResize);
+      let libraryButton = document.getElementById("library-button");
+      // Put the 'fill' back in the normal icon.
+      libraryButton.removeAttribute("animate");
+    }
+  },
+
+  _windowResizeRunning: false,
+  _onWindowResize(aEvent) {
+    if (LibraryUI._windowResizeRunning) {
+      return;
+    }
+    LibraryUI._windowResizeRunning = true;
+
+    requestAnimationFrame(() => {
+      let libraryButton = document.getElementById("library-button");
+      // Only update the position if the library button remains in the
+      // navbar (not moved to the palette or elsewhere).
+      if (!libraryButton ||
+          libraryButton.getAttribute("cui-areatype") == "menu-panel" ||
+          libraryButton.getAttribute("overflowedItem") == "true" ||
+          !libraryButton.closest("#nav-bar")) {
+        return;
+      }
+
+      let animatableBox = document.getElementById("library-animatable-box");
+      let libraryIcon = document.getAnonymousElementByAttribute(libraryButton, "class", "toolbarbutton-icon");
+      let dwu = window.getInterface(Ci.nsIDOMWindowUtils);
+      let iconBounds = dwu.getBoundsWithoutFlushing(libraryIcon);
+
+      // Resizing the window will only have the ability to change the X offset of the
+      // library button.
+      animatableBox.style.setProperty("--library-icon-x", iconBounds.x + "px");
+
+      LibraryUI._windowResizeRunning = false;
+    });
+  },
+};
+
+/**
+ * Handles the bookmarks menu-button in the toolbar.
+ */
+
+var BookmarkingUI = {
+  STAR_ID: "star-button",
+  STAR_BOX_ID: "star-button-box",
+  BOOKMARK_BUTTON_ID: "bookmarks-menu-button",
+  BOOKMARK_BUTTON_SHORTCUT: "addBookmarkAsKb",
+  get button() {
+    delete this.button;
+    let widgetGroup = CustomizableUI.getWidget(this.BOOKMARK_BUTTON_ID);
+    return this.button = widgetGroup.forWindow(window).node;
+  },
+
+  get star() {
+    delete this.star;
+    return this.star = document.getElementById(this.STAR_ID);
+  },
+
+  get starBox() {
+    delete this.starBox;
+    return this.starBox = document.getElementById(this.STAR_BOX_ID);
+  },
+
+  get anchor() {
+    let action = PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK);
+    return BrowserPageActions.panelAnchorNodeForAction(action);
+  },
+
+  get notifier() {
+    delete this.notifier;
+    return this.notifier = document.getElementById("bookmarked-notification-anchor");
+  },
+
+  get dropmarkerNotifier() {
+    delete this.dropmarkerNotifier;
+    return this.dropmarkerNotifier = document.getElementById("bookmarked-notification-dropmarker-anchor");
+  },
+
+  get broadcaster() {
+    delete this.broadcaster;
+    let broadcaster = document.getElementById("bookmarkThisPageBroadcaster");
+    return this.broadcaster = broadcaster;
+  },
+
+  STATUS_UPDATING: -1,
+  STATUS_UNSTARRED: 0,
+  STATUS_STARRED: 1,
+  get status() {
+    if (this._pendingUpdate)
+      return this.STATUS_UPDATING;
+    return this.broadcaster.hasAttribute("starred") ? this.STATUS_STARRED
+                                                    : this.STATUS_UNSTARRED;
+  },
+
+  get _starredTooltip() {
+    delete this._starredTooltip;
+    return this._starredTooltip =
+      this._getFormattedTooltip("starButtonOn.tooltip2");
+  },
+
+  get _unstarredTooltip() {
+    delete this._unstarredTooltip;
+    return this._unstarredTooltip =
+      this._getFormattedTooltip("starButtonOff.tooltip2");
+  },
+
+  _getFormattedTooltip(strId) {
+    let args = [];
+    let shortcut = document.getElementById(this.BOOKMARK_BUTTON_SHORTCUT);
+    if (shortcut)
+      args.push(ShortcutUtils.prettifyShortcut(shortcut));
+    return gNavigatorBundle.getFormattedString(strId, args);
+  },
+
+  /**
+   * The popup contents must be updated when the user customizes the UI, or
+   * changes the personal toolbar collapsed status.  In such a case, any needed
+   * change should be handled in the popupshowing helper, for performance
+   * reasons.
+   */
+  _popupNeedsUpdate: true,
+  onToolbarVisibilityChange: function BUI_onToolbarVisibilityChange() {
+    this._popupNeedsUpdate = true;
+  },
+
+  onPopupShowing: function BUI_onPopupShowing(event) {
+    // Don't handle events for submenus.
+    if (event.target != event.currentTarget)
+      return;
+
+    // On non-photon, this code should never be reached. However, if you click
+    // the outer button's border, some cpp code for the menu button's XBL
+    // binding decides to open the popup even though the dropmarker is invisible.
+    //
+    // Separately, in Photon, if the button is in the dynamic portion of the
+    // overflow panel, we want to show a subview instead.
+    if (this.button.getAttribute("cui-areatype") == CustomizableUI.TYPE_MENU_PANEL ||
+        this.button.hasAttribute("overflowedItem")) {
+      this._showSubView();
+      event.preventDefault();
+      event.stopPropagation();
+      return;
+    }
+
+    let widget = CustomizableUI.getWidget(this.BOOKMARK_BUTTON_ID)
+                               .forWindow(window);
+    if (widget.overflowed) {
+      // Don't open a popup in the overflow popup, rather just open the Library.
+      event.preventDefault();
+      widget.node.removeAttribute("closemenu");
+      PlacesCommandHook.showPlacesOrganizer("BookmarksMenu");
+      return;
+    }
+
+    this._initMobileBookmarks(document.getElementById("BMB_mobileBookmarks"));
+
+    if (!this._popupNeedsUpdate)
+      return;
+    this._popupNeedsUpdate = false;
+
+    let popup = event.target;
+    let getPlacesAnonymousElement =
+      aAnonId => document.getAnonymousElementByAttribute(popup.parentNode,
+                                                         "placesanonid",
+                                                         aAnonId);
+
+    let viewToolbarMenuitem = getPlacesAnonymousElement("view-toolbar");
+    if (viewToolbarMenuitem) {
+      // Update View bookmarks toolbar checkbox menuitem.
+      viewToolbarMenuitem.classList.add("subviewbutton");
+      let personalToolbar = document.getElementById("PersonalToolbar");
+      viewToolbarMenuitem.setAttribute("checked", !personalToolbar.collapsed);
+    }
+  },
+
+  attachPlacesView(event, node) {
+    // If the view is already there, bail out early.
+    if (node.parentNode._placesView)
+      return;
+
+    new PlacesMenu(event, "place:folder=BOOKMARKS_MENU", {
+      extraClasses: {
+        entry: "subviewbutton",
+        footer: "panel-subview-footer"
+      },
+      insertionPoint: ".panel-subview-footer"
+    });
+  },
+
+  // Set by sync after syncing bookmarks successfully once.
+  MOBILE_BOOKMARKS_PREF: "browser.bookmarks.showMobileBookmarks",
+
+  _shouldShowMobileBookmarks() {
+    try {
+      return Services.prefs.getBoolPref(this.MOBILE_BOOKMARKS_PREF);
+    } catch (e) {}
+    // No pref set (or invalid pref set), look for a mobile bookmarks left pane query.
+    const organizerQueryAnno = "PlacesOrganizer/OrganizerQuery";
+    const mobileBookmarksAnno = "MobileBookmarks";
+    let shouldShow = PlacesUtils.annotations.getItemsWithAnnotation(organizerQueryAnno, {}).filter(
+      id => PlacesUtils.annotations.getItemAnnotation(id, organizerQueryAnno) == mobileBookmarksAnno
+    ).length > 0;
+    // Sync will change this pref if/when it adds a mobile bookmarks query.
+    Services.prefs.setBoolPref(this.MOBILE_BOOKMARKS_PREF, shouldShow);
+    return shouldShow;
+  },
+
+  _initMobileBookmarks(mobileMenuItem) {
+    mobileMenuItem.hidden = !this._shouldShowMobileBookmarks();
+  },
+
+  _uninitView: function BUI__uninitView() {
+    // When an element with a placesView attached is removed and re-inserted,
+    // XBL reapplies the binding causing any kind of issues and possible leaks,
+    // so kill current view and let popupshowing generate a new one.
+    if (this.button._placesView)
+      this.button._placesView.uninit();
+    // Also uninit the main menubar placesView, since it would have the same
+    // issues.
+    let menubar = document.getElementById("bookmarksMenu");
+    if (menubar && menubar._placesView)
+      menubar._placesView.uninit();
+
+    // We have to do the same thing for the "special" views underneath the
+    // the bookmarks menu.
+    const kSpecialViewNodeIDs = ["BMB_bookmarksToolbar", "BMB_unsortedBookmarks"];
+    for (let viewNodeID of kSpecialViewNodeIDs) {
+      let elem = document.getElementById(viewNodeID);
+      if (elem && elem._placesView) {
+        elem._placesView.uninit();
+      }
+    }
+  },
+
+  onCustomizeStart: function BUI_customizeStart(aWindow) {
+    if (aWindow == window) {
+      this._uninitView();
+      this._isCustomizing = true;
+    }
+  },
+
+  onWidgetAdded: function BUI_widgetAdded(aWidgetId) {
+    if (aWidgetId == this.BOOKMARK_BUTTON_ID) {
+      this._onWidgetWasMoved();
+    }
+  },
+
+  onWidgetRemoved: function BUI_widgetRemoved(aWidgetId) {
+    if (aWidgetId == this.BOOKMARK_BUTTON_ID) {
+      this._onWidgetWasMoved();
+    }
+  },
+
+  onWidgetReset: function BUI_widgetReset(aNode, aContainer) {
+    if (aNode == this.button) {
+      this._onWidgetWasMoved();
+    }
+  },
+
+  onWidgetUndoMove: function BUI_undoWidgetUndoMove(aNode, aContainer) {
+    if (aNode == this.button) {
+      this._onWidgetWasMoved();
+    }
+  },
+
+  _onWidgetWasMoved: function BUI_widgetWasMoved() {
+    // If we're moved outside of customize mode, we need to uninit
+    // our view so it gets reconstructed.
+    if (!this._isCustomizing) {
+      this._uninitView();
+    }
+  },
+
+  onCustomizeEnd: function BUI_customizeEnd(aWindow) {
+    if (aWindow == window) {
+      this._isCustomizing = false;
+      this.onToolbarVisibilityChange();
+    }
+  },
+
+  init() {
+    CustomizableUI.addListener(this);
+
+    if (Services.prefs.getBoolPref("toolkit.cosmeticAnimations.enabled")) {
+      let starButtonBox = document.getElementById("star-button-box");
+      starButtonBox.setAttribute("animationsenabled", "true");
+      this.star.addEventListener("mouseover", this, {once: true});
+    }
+  },
+
+  _hasBookmarksObserver: false,
+  _itemGuids: new Set(),
+  uninit: function BUI_uninit() {
+    this.updateBookmarkPageMenuItem(true);
+    CustomizableUI.removeListener(this);
+
+    this.star.removeEventListener("mouseover", this);
+
+    this._uninitView();
+
+    if (this._hasBookmarksObserver) {
+      PlacesUtils.bookmarks.removeObserver(this);
+    }
+
+    if (this._pendingUpdate) {
+      delete this._pendingUpdate;
+    }
+  },
+
+  onLocationChange: function BUI_onLocationChange() {
+    if (this._uri && gBrowser.currentURI.equals(this._uri)) {
+      return;
+    }
+    this.updateStarState();
+  },
+
+  updateStarState: function BUI_updateStarState() {
+    this._uri = gBrowser.currentURI;
+    this._itemGuids.clear();
+    let guids = new Set();
+
+    // those objects are use to check if we are in the current iteration before
+    // returning any result.
+    let pendingUpdate = this._pendingUpdate = {};
+
+    PlacesUtils.bookmarks.fetch({url: this._uri}, b => guids.add(b.guid), { concurrent: true })
+      .catch(Components.utils.reportError)
+      .then(() => {
+         if (pendingUpdate != this._pendingUpdate) {
+           return;
+         }
+
+         // It's possible that onItemAdded gets called before the async statement
+         // calls back.  For such an edge case, retain all unique entries from the
+         // array.
+         if (this._itemGuids.size > 0) {
+           this._itemGuids = new Set(...this._itemGuids, ...guids);
+         } else {
+           this._itemGuids = guids;
+         }
+
+         this._updateStar();
+
+         // Start observing bookmarks if needed.
+         if (!this._hasBookmarksObserver) {
+           try {
+             PlacesUtils.bookmarks.addObserver(this);
+             this._hasBookmarksObserver = true;
+           } catch (ex) {
+             Components.utils.reportError("BookmarkingUI failed adding a bookmarks observer: " + ex);
+           }
+         }
+
+         delete this._pendingUpdate;
+       });
+  },
+
+  _updateStar: function BUI__updateStar() {
+    if (this._itemGuids.size > 0) {
+      this.broadcaster.setAttribute("starred", "true");
+      this.broadcaster.setAttribute("buttontooltiptext", this._starredTooltip);
+      this.broadcaster.setAttribute("tooltiptext", this._starredTooltip);
+    } else {
+      this.star.removeAttribute("animate");
+      this.broadcaster.removeAttribute("starred");
+      this.broadcaster.setAttribute("buttontooltiptext", this._unstarredTooltip);
+      this.broadcaster.setAttribute("tooltiptext", this._unstarredTooltip);
+    }
+  },
+
+  /**
+   * forceReset is passed when we're destroyed and the label should go back
+   * to the default (Bookmark This Page) for OS X.
+   */
+  updateBookmarkPageMenuItem: function BUI_updateBookmarkPageMenuItem(forceReset) {
+    let isStarred = !forceReset && this._itemGuids.size > 0;
+    let label = isStarred ? "editlabel" : "bookmarklabel";
+    if (this.broadcaster) {
+      this.broadcaster.setAttribute("label", this.broadcaster.getAttribute(label));
+    }
+  },
+
+  onMainMenuPopupShowing: function BUI_onMainMenuPopupShowing(event) {
+    // Don't handle events for submenus.
+    if (event.target != event.currentTarget)
+      return;
+
+    this.updateBookmarkPageMenuItem();
+    PlacesCommandHook.updateBookmarkAllTabsCommand();
+    this._initMobileBookmarks(document.getElementById("menu_mobileBookmarks"));
+  },
+
+  _showBookmarkedNotification: function BUI_showBookmarkedNotification() {
+    function getCenteringTransformForRects(rectToPosition, referenceRect) {
+      let topDiff = referenceRect.top - rectToPosition.top;
+      let leftDiff = referenceRect.left - rectToPosition.left;
+      let heightDiff = referenceRect.height - rectToPosition.height;
+      let widthDiff = referenceRect.width - rectToPosition.width;
+      return [(leftDiff + .5 * widthDiff) + "px", (topDiff + .5 * heightDiff) + "px"];
+    }
+
+    if (this._notificationTimeout) {
+      clearTimeout(this._notificationTimeout);
+    }
+
+    if (this.notifier.style.transform == "") {
+      // Get all the relevant nodes and computed style objects
+      let dropmarker = document.getAnonymousElementByAttribute(this.button, "anonid", "dropmarker");
+      let dropmarkerIcon = document.getAnonymousElementByAttribute(dropmarker, "class", "dropmarker-icon");
+      let dropmarkerStyle = getComputedStyle(dropmarkerIcon);
+
+      // Check for RTL and get bounds
+      let isRTL = getComputedStyle(this.button).direction == "rtl";
+      let buttonRect = this.button.getBoundingClientRect();
+      let notifierRect = this.notifier.getBoundingClientRect();
+      let dropmarkerRect = dropmarkerIcon.getBoundingClientRect();
+      let dropmarkerNotifierRect = this.dropmarkerNotifier.getBoundingClientRect();
+
+      // Compute, but do not set, transform for star icon
+      let [translateX, translateY] = getCenteringTransformForRects(notifierRect, buttonRect);
+      let starIconTransform = "translate(" + translateX + ", " + translateY + ")";
+      if (isRTL) {
+        starIconTransform += " scaleX(-1)";
+      }
+
+      // Compute, but do not set, transform for dropmarker
+      [translateX, translateY] = getCenteringTransformForRects(dropmarkerNotifierRect, dropmarkerRect);
+      let dropmarkerTransform = "translate(" + translateX + ", " + translateY + ")";
+
+      // Do all layout invalidation in one go:
+      this.notifier.style.transform = starIconTransform;
+      this.dropmarkerNotifier.style.transform = dropmarkerTransform;
+
+      let dropmarkerAnimationNode = this.dropmarkerNotifier.firstChild;
+      dropmarkerAnimationNode.style.listStyleImage = dropmarkerStyle.listStyleImage;
+      dropmarkerAnimationNode.style.fill = dropmarkerStyle.fill;
+    }
+
+    let isInOverflowPanel = this.button.getAttribute("overflowedItem") == "true";
+    if (!isInOverflowPanel) {
+      this.notifier.setAttribute("notification", "finish");
+      this.button.setAttribute("notification", "finish");
+      this.dropmarkerNotifier.setAttribute("notification", "finish");
+    }
+
+    this._notificationTimeout = setTimeout( () => {
+      this.notifier.removeAttribute("notification");
+      this.dropmarkerNotifier.removeAttribute("notification");
+      this.button.removeAttribute("notification");
+
+      this.dropmarkerNotifier.style.transform = "";
+      this.notifier.style.transform = "";
+    }, 1000);
+  },
+
+  showSubView(anchor) {
+    this._showSubView(null, anchor);
+  },
+
+  _showSubView(event, anchor = document.getElementById(this.BOOKMARK_BUTTON_ID)) {
+    let view = document.getElementById("PanelUI-bookmarks");
+    view.addEventListener("ViewShowing", this);
+    view.addEventListener("ViewHiding", this);
+    anchor.setAttribute("closemenu", "none");
+    PanelUI.showSubView("PanelUI-bookmarks", anchor, event);
+  },
+
+  onCommand: function BUI_onCommand(aEvent) {
+    if (aEvent.target != aEvent.currentTarget) {
+      return;
+    }
+
+    // Handle special case when the button is in the panel.
+    if (this.button.getAttribute("cui-areatype") == CustomizableUI.TYPE_MENU_PANEL) {
+      this._showSubView(aEvent);
+      return;
+    }
+    let widget = CustomizableUI.getWidget(this.BOOKMARK_BUTTON_ID)
+                               .forWindow(window);
+    if (widget.overflowed) {
+      // Close the overflow panel because the Edit Bookmark panel will appear.
+      widget.node.removeAttribute("closemenu");
+    }
+    this.onStarCommand(aEvent);
+  },
+
+  onStarCommand(aEvent) {
+    // Ignore non-left clicks on the star, or if we are updating its state.
+    if (!this._pendingUpdate && (aEvent.type != "click" || aEvent.button == 0)) {
+      let isBookmarked = this._itemGuids.size > 0;
+      if (!isBookmarked) {
+        BrowserUtils.setToolbarButtonHeightProperty(this.star);
+        this.star.setAttribute("animate", "true");
+      }
+      PlacesCommandHook.bookmarkPage(gBrowser.selectedBrowser, true);
+    }
+  },
+
+  onCurrentPageContextPopupShowing() {
+    this.updateBookmarkPageMenuItem();
+  },
+
+  handleEvent: function BUI_handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "mouseover":
+        this.star.setAttribute("preloadanimations", "true");
+        break;
+      case "ViewShowing":
+        this.onPanelMenuViewShowing(aEvent);
+        break;
+      case "ViewHiding":
+        this.onPanelMenuViewHiding(aEvent);
+        break;
+    }
+  },
+
+  onPanelMenuViewShowing: function BUI_onViewShowing(aEvent) {
+    let panelview = aEvent.target;
+    this.updateBookmarkPageMenuItem();
+    // Update checked status of the toolbar toggle.
+    let viewToolbar = document.getElementById("panelMenu_viewBookmarksToolbar");
+    if (viewToolbar) {
+      let personalToolbar = document.getElementById("PersonalToolbar");
+      if (personalToolbar.collapsed)
+        viewToolbar.removeAttribute("checked");
+      else
+        viewToolbar.setAttribute("checked", "true");
+    }
+    // Get all statically placed buttons to supply them with keyboard shortcuts.
+    let staticButtons = panelview.getElementsByTagName("toolbarbutton");
+    for (let i = 0, l = staticButtons.length; i < l; ++i)
+      CustomizableUI.addShortcut(staticButtons[i]);
+    // Setup the Places view.
+    // We restrict the amount of results to 42. Not 50, but 42. Why? Because 42.
+    let query = "place:queryType=" + Ci.nsINavHistoryQueryOptions.QUERY_TYPE_BOOKMARKS +
+      "&sort=" + Ci.nsINavHistoryQueryOptions.SORT_BY_DATEADDED_DESCENDING +
+      "&maxResults=42&excludeQueries=1";
+
+    this._panelMenuView = new PlacesPanelview(document.getElementById("panelMenu_bookmarksMenu"),
+      panelview, query);
+    panelview.removeEventListener("ViewShowing", this);
+  },
+
+  onPanelMenuViewHiding: function BUI_onViewHiding(aEvent) {
+    this._panelMenuView.uninit();
+    delete this._panelMenuView;
+    aEvent.target.removeEventListener("ViewHiding", this);
+  },
+
+  onPanelMenuViewCommand: function BUI_onPanelMenuViewCommand(aEvent) {
+    let target = aEvent.originalTarget;
+    if (!target._placesNode)
+      return;
+    if (PlacesUtils.nodeIsContainer(target._placesNode))
+      PlacesCommandHook.showPlacesOrganizer([ "BookmarksMenu", target._placesNode.itemId ]);
+    else
+      PlacesUIUtils.openNodeWithEvent(target._placesNode, aEvent);
+    PanelUI.hide();
+  },
+
+  showBookmarkingTools(triggerNode) {
+    const panelID = "PanelUI-bookmarkingTools";
+    let viewNode = document.getElementById(panelID);
+    for (let button of [...viewNode.getElementsByTagName("toolbarbutton")]) {
+      let update = true;
+      switch (button.id) {
+        case "panelMenu_toggleBookmarksMenu":
+          let placement = CustomizableUI.getPlacementOfWidget(this.BOOKMARK_BUTTON_ID);
+          button.setAttribute("checked", !!placement && placement.area == CustomizableUI.AREA_NAVBAR);
+          break;
+        case "panelMenu_viewBookmarksSidebar":
+          button.setAttribute("checked", SidebarUI.currentID == "viewBookmarksSidebar");
+          break;
+        case "panelMenu_viewBookmarksToolbar":
+          let toolbar = document.getElementById("PersonalToolbar");
+          // This is an actual toolbarbutton[type=checkbox], and its checked
+          // attribute will get added/removed by the binding when clicked.
+          // Setting the attribute to 'false' breaks showing the toolbar,
+          // because the binding removes the attribute instead of setting it
+          // to 'true' when clicked.
+          if (toolbar.getAttribute("collapsed") != "true") {
+            button.setAttribute("checked", "true");
+          } else {
+            button.removeAttribute("checked");
+          }
+          break;
+        default:
+          update = false;
+          break;
+      }
+      if (update) {
+        updateToggleControlLabel(button);
+      }
+    }
+    PanelUI.showSubView(panelID, triggerNode);
+  },
+
+  toggleMenuButtonInToolbar(triggerNode) {
+    let placement = CustomizableUI.getPlacementOfWidget(this.BOOKMARK_BUTTON_ID);
+    const area = CustomizableUI.AREA_NAVBAR;
+    if (!placement) {
+      // Button is in the palette, so we can move it to the navbar.
+      let pos;
+      let widgetIDs = CustomizableUI.getWidgetIdsInArea(CustomizableUI.AREA_NAVBAR);
+      // If there's a spring inside the navbar, find it and use that as the
+      // placement marker.
+      let lastSpringID = null;
+      for (let i = widgetIDs.length - 1; i >= 0; --i) {
+        let id = widgetIDs[i];
+        if (CustomizableUI.isSpecialWidget(id) && /spring/.test(id)) {
+          lastSpringID = id;
+          break;
+        }
+      }
+      if (lastSpringID) {
+        pos = CustomizableUI.getPlacementOfWidget(lastSpringID).position + 1;
+      } else {
+        // Next alternative is to use the searchbar as the placement marker.
+        const searchWidgetID = "search-container";
+        if (widgetIDs.includes(searchWidgetID)) {
+          pos = CustomizableUI.getPlacementOfWidget(searchWidgetID).position + 1;
+        } else {
+          // Last alternative is to use the navbar as the placement marker.
+          pos = CustomizableUI.getPlacementOfWidget("urlbar-container").position + 1;
+        }
+      }
+
+      CustomizableUI.addWidgetToArea(this.BOOKMARK_BUTTON_ID, area, pos);
+    } else {
+      // Move it back to the palette.
+      CustomizableUI.removeWidgetFromArea(this.BOOKMARK_BUTTON_ID);
+    }
+    triggerNode.setAttribute("checked", !placement);
+    updateToggleControlLabel(triggerNode);
+  },
+
+  // nsINavBookmarkObserver
+  onItemAdded(aItemId, aParentId, aIndex, aItemType, aURI, aTitle, aDateAdded, aGuid) {
+    if (aURI && aURI.equals(this._uri)) {
+      // If a new bookmark has been added to the tracked uri, register it.
+      if (!this._itemGuids.has(aGuid)) {
+        this._itemGuids.add(aGuid);
+        // Only need to update the UI if it wasn't marked as starred before:
+        if (this._itemGuids.size == 1) {
+          this._updateStar();
+        }
+      }
+    }
+  },
+
+  onItemRemoved(aItemId, aParentId, aIndex, aItemType, aURI, aGuid) {
+    // If one of the tracked bookmarks has been removed, unregister it.
+    if (this._itemGuids.has(aGuid)) {
+      this._itemGuids.delete(aGuid);
+      // Only need to update the UI if the page is no longer starred
+      if (this._itemGuids.size == 0) {
+        this._updateStar();
+      }
+    }
+  },
+
+  onItemChanged(aItemId, aProperty, aIsAnnotationProperty, aNewValue, aLastModified,
+                aItemType, aParentId, aGuid) {
+    if (aProperty == "uri") {
+      // If the changed bookmark was tracked, check if it is now pointing to
+      // a different uri and unregister it.
+      if (this._itemGuids.has(aGuid) && aNewValue != this._uri.spec) {
+        this._itemGuids.delete(aGuid);
+        // Only need to update the UI if the page is no longer starred
+        if (this._itemGuids.size == 0) {
+          this._updateStar();
+        }
+      } else if (!this._itemGuids.has(aGuid) && aNewValue == this._uri.spec) {
+        // If another bookmark is now pointing to the tracked uri, register it.
+        this._itemGuids.add(aGuid);
+        // Only need to update the UI if it wasn't marked as starred before:
+        if (this._itemGuids.size == 1) {
+          this._updateStar();
+        }
+      }
+    }
+  },
+
+  onBeginUpdateBatch() {},
+  onEndUpdateBatch() {},
+  onBeforeItemRemoved() {},
+  onItemVisited() {},
+  onItemMoved() {},
+
+  onWidgetUnderflow(aNode, aContainer) {
+    let win = aNode.ownerGlobal;
+    if (aNode.id != this.BOOKMARK_BUTTON_ID || win != window)
+      return;
+
+    // The view gets broken by being removed and reinserted. Uninit
+    // here so popupshowing will generate a new one:
+    this._uninitView();
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([
+    Ci.nsINavBookmarkObserver
+  ])
+};
+
+var AutoShowBookmarksToolbar = {
+  init() {
+    Services.obs.addObserver(this, "autoshow-bookmarks-toolbar");
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, "autoshow-bookmarks-toolbar");
+  },
+
+  observe(subject, topic, data) {
+    let toolbar = document.getElementById("PersonalToolbar");
+    if (!toolbar.collapsed)
+      return;
+
+    let placement = CustomizableUI.getPlacementOfWidget("personal-bookmarks");
+    let area = placement && placement.area;
+    if (area != CustomizableUI.AREA_BOOKMARKS)
+      return;
+
+    setToolbarVisibility(toolbar, true);
+  }
+};
+
+
+/***/ }),
+/* 8 */
+/***/ (function(module, exports) {
+
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var gPluginHandler = {
+  PREF_SESSION_PERSIST_MINUTES: "plugin.sessionPermissionNow.intervalInMinutes",
+  PREF_PERSISTENT_DAYS: "plugin.persistentPermissionAlways.intervalInDays",
+  PREF_SHOW_INFOBAR: "plugins.show_infobar",
+  PREF_INFOBAR_DISMISSAL_PERMANENT: "plugins.remember_infobar_dismissal",
+
+  MESSAGES: [
+    "PluginContent:ShowClickToPlayNotification",
+    "PluginContent:RemoveNotification",
+    "PluginContent:UpdateHiddenPluginUI",
+    "PluginContent:HideNotificationBar",
+    "PluginContent:InstallSinglePlugin",
+    "PluginContent:ShowPluginCrashedNotification",
+    "PluginContent:SubmitReport",
+    "PluginContent:LinkClickCallback",
+  ],
+
+  init() {
+    const mm = window.messageManager;
+    for (let msg of this.MESSAGES) {
+      mm.addMessageListener(msg, this);
+    }
+    window.addEventListener("unload", this);
+  },
+
+  uninit() {
+    const mm = window.messageManager;
+    for (let msg of this.MESSAGES) {
+      mm.removeMessageListener(msg, this);
+    }
+    window.removeEventListener("unload", this);
+  },
+
+  handleEvent(event) {
+    if (event.type == "unload") {
+      this.uninit();
+    }
+  },
+
+  receiveMessage(msg) {
+    switch (msg.name) {
+      case "PluginContent:ShowClickToPlayNotification":
+        this.showClickToPlayNotification(msg.target, msg.data.plugins, msg.data.showNow,
+                                         msg.principal, msg.data.location);
+        break;
+      case "PluginContent:RemoveNotification":
+        this.removeNotification(msg.target, msg.data.name);
+        break;
+      case "PluginContent:UpdateHiddenPluginUI":
+        this.updateHiddenPluginUI(msg.target, msg.data.haveInsecure, msg.data.actions,
+                                  msg.principal, msg.data.location)
+          .catch(Cu.reportError);
+        break;
+      case "PluginContent:HideNotificationBar":
+        this.hideNotificationBar(msg.target, msg.data.name);
+        break;
+      case "PluginContent:InstallSinglePlugin":
+        this.installSinglePlugin(msg.data.pluginInfo);
+        break;
+      case "PluginContent:ShowPluginCrashedNotification":
+        this.showPluginCrashedNotification(msg.target, msg.data.messageString,
+                                           msg.data.pluginID);
+        break;
+      case "PluginContent:SubmitReport":
+        if (AppConstants.MOZ_CRASHREPORTER) {
+          this.submitReport(msg.data.runID, msg.data.keyVals, msg.data.submitURLOptIn);
+        }
+        break;
+      case "PluginContent:LinkClickCallback":
+        switch (msg.data.name) {
+          case "managePlugins":
+          case "openHelpPage":
+          case "openPluginUpdatePage":
+            this[msg.data.name](msg.data.pluginTag);
+            break;
+        }
+        break;
+      default:
+        Cu.reportError("gPluginHandler did not expect to handle message " + msg.name);
+        break;
+    }
+  },
+
+  // Callback for user clicking on a disabled plugin
+  managePlugins() {
+    BrowserOpenAddonsMgr("addons://list/plugin");
+  },
+
+  // Callback for user clicking on the link in a click-to-play plugin
+  // (where the plugin has an update)
+  openPluginUpdatePage(pluginTag) {
+    let url = Services.blocklist.getPluginInfoURL(pluginTag);
+    if (!url) {
+      url = Services.blocklist.getPluginBlocklistURL(pluginTag);
+    }
+    openUILinkIn(url, "tab");
+  },
+
+  submitReport: function submitReport(runID, keyVals, submitURLOptIn) {
+    if (!AppConstants.MOZ_CRASHREPORTER) {
+      return;
+    }
+    Services.prefs.setBoolPref("dom.ipc.plugins.reportCrashURL", submitURLOptIn);
+    PluginCrashReporter.submitCrashReport(runID, keyVals);
+  },
+
+  // Callback for user clicking a "reload page" link
+  reloadPage(browser) {
+    browser.reload();
+  },
+
+  // Callback for user clicking the help icon
+  openHelpPage() {
+    openHelpLink("plugin-crashed", false);
+  },
+
+  _clickToPlayNotificationEventCallback: function PH_ctpEventCallback(event) {
+    if (event == "showing") {
+      Services.telemetry.getHistogramById("PLUGINS_NOTIFICATION_SHOWN")
+        .add(!this.options.primaryPlugin);
+      // Histograms always start at 0, even though our data starts at 1
+      let histogramCount = this.options.pluginData.size - 1;
+      if (histogramCount > 4) {
+        histogramCount = 4;
+      }
+      Services.telemetry.getHistogramById("PLUGINS_NOTIFICATION_PLUGIN_COUNT")
+        .add(histogramCount);
+    } else if (event == "dismissed") {
+      // Once the popup is dismissed, clicking the icon should show the full
+      // list again
+      this.options.primaryPlugin = null;
+    }
+  },
+
+  /**
+   * Called from the plugin doorhanger to set the new permissions for a plugin
+   * and activate plugins if necessary.
+   * aNewState should be either "allownow" "allowalways" or "block"
+   */
+  _updatePluginPermission(aBrowser, aPluginInfo, aNewState) {
+    let permission;
+    let expireType;
+    let expireTime;
+    let histogram =
+      Services.telemetry.getHistogramById("PLUGINS_NOTIFICATION_USER_ACTION_2");
+
+    let notification = PopupNotifications.getNotification("click-to-play-plugins", aBrowser);
+
+    // Update the permission manager.
+    // Also update the current state of pluginInfo.fallbackType so that
+    // subsequent opening of the notification shows the current state.
+    switch (aNewState) {
+      case "allownow":
+        permission = Ci.nsIPermissionManager.ALLOW_ACTION;
+        expireType = Ci.nsIPermissionManager.EXPIRE_SESSION;
+        expireTime = Date.now() + Services.prefs.getIntPref(this.PREF_SESSION_PERSIST_MINUTES) * 60 * 1000;
+        histogram.add(0);
+        aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE;
+        notification.options.extraAttr = "active";
+        break;
+
+      case "allowalways":
+        permission = Ci.nsIPermissionManager.ALLOW_ACTION;
+        expireType = Ci.nsIPermissionManager.EXPIRE_TIME;
+        expireTime = Date.now() +
+          Services.prefs.getIntPref(this.PREF_PERSISTENT_DAYS) * 24 * 60 * 60 * 1000;
+        histogram.add(1);
+        aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE;
+        notification.options.extraAttr = "active";
+        break;
+
+      case "block":
+        permission = Ci.nsIPermissionManager.PROMPT_ACTION;
+        expireType = Ci.nsIPermissionManager.EXPIRE_NEVER;
+        expireTime = 0;
+        histogram.add(2);
+        switch (aPluginInfo.blocklistState) {
+          case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:
+            aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE;
+            break;
+          case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:
+            aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_NO_UPDATE;
+            break;
+          default:
+            // PLUGIN_CLICK_TO_PLAY_QUIET will only last until they reload the page, at
+            // which point it will be PLUGIN_CLICK_TO_PLAY (the overlays will appear)
+            aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET;
+        }
+        notification.options.extraAttr = "inactive";
+        break;
+
+      case "blockalways":
+        permission = Ci.nsIObjectLoadingContent.PLUGIN_PERMISSION_PROMPT_ACTION_QUIET;
+        expireType = Ci.nsIPermissionManager.EXPIRE_NEVER;
+        expireTime = 0;
+        histogram.add(3);
+        aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET;
+        notification.options.extraAttr = "inactive";
+        break;
+
+      // In case a plugin has already been allowed/disallowed in another tab, the
+      // buttons matching the existing block state shouldn't change any permissions
+      // but should run the plugin-enablement code below.
+      case "continue":
+        aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE;
+        notification.options.extraAttr = "active";
+        break;
+
+      case "continueblocking":
+        aPluginInfo.fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET;
+        notification.options.extraAttr = "inactive";
+        break;
+
+      default:
+        Cu.reportError(Error("Unexpected plugin state: " + aNewState));
+        return;
+    }
+
+    if (aNewState != "continue" && aNewState != "continueblocking") {
+      let principal = notification.options.principal;
+      Services.perms.addFromPrincipal(principal, aPluginInfo.permissionString,
+                                      permission, expireType, expireTime);
+      aPluginInfo.pluginPermissionType = expireType;
+    }
+
+    aBrowser.messageManager.sendAsyncMessage("BrowserPlugins:ActivatePlugins", {
+      pluginInfo: aPluginInfo,
+      newState: aNewState,
+    });
+  },
+
+  showClickToPlayNotification(browser, plugins, showNow,
+                                        principal, location) {
+    // It is possible that we've received a message from the frame script to show
+    // a click to play notification for a principal that no longer matches the one
+    // that the browser's content now has assigned (ie, the browser has browsed away
+    // after the message was sent, but before the message was received). In that case,
+    // we should just ignore the message.
+    if (!principal.equals(browser.contentPrincipal)) {
+      return;
+    }
+
+    // Data URIs, when linked to from some page, inherit the principal of that
+    // page. That means that we also need to compare the actual locations to
+    // ensure we aren't getting a message from a Data URI that we're no longer
+    // looking at.
+    let receivedURI = Services.io.newURI(location);
+    if (!browser.documentURI.equalsExceptRef(receivedURI)) {
+      return;
+    }
+
+    let notification = PopupNotifications.getNotification("click-to-play-plugins", browser);
+
+    // If this is a new notification, create a pluginData map, otherwise append
+    let pluginData;
+    if (notification) {
+      pluginData = notification.options.pluginData;
+    } else {
+      pluginData = new Map();
+    }
+
+    for (let pluginInfo of plugins) {
+      if (pluginData.has(pluginInfo.permissionString)) {
+        continue;
+      }
+
+      // If a block contains an infoURL, we should always prefer that to the default
+      // URL that we construct in-product, even for other blocklist types.
+      let url = Services.blocklist.getPluginInfoURL(pluginInfo.pluginTag);
+
+      if (pluginInfo.blocklistState != Ci.nsIBlocklistService.STATE_NOT_BLOCKED) {
+        if (!url) {
+          url = Services.blocklist.getPluginBlocklistURL(pluginInfo.pluginTag);
+        }
+      } else {
+        url = Services.urlFormatter.formatURLPref("app.support.baseURL") + "clicktoplay";
+      }
+      pluginInfo.detailsLink = url;
+
+      pluginData.set(pluginInfo.permissionString, pluginInfo);
+    }
+
+    let primaryPluginPermission = null;
+    if (showNow) {
+      primaryPluginPermission = plugins[0].permissionString;
+    }
+
+    if (notification) {
+      // Don't modify the notification UI while it's on the screen, that would be
+      // jumpy and might allow clickjacking.
+      if (showNow) {
+        notification.options.primaryPlugin = primaryPluginPermission;
+        notification.reshow();
+        browser.messageManager.sendAsyncMessage("BrowserPlugins:NotificationShown");
+      }
+      return;
+    }
+
+    if (plugins.length == 1) {
+      let pluginInfo = plugins[0];
+      // If a block contains an infoURL, we should always prefer that to the default
+      // URL that we construct in-product, even for other blocklist types.
+      let url = Services.blocklist.getPluginInfoURL(pluginInfo.pluginTag);
+
+      if (pluginInfo.blocklistState != Ci.nsIBlocklistService.STATE_NOT_BLOCKED) {
+        if (!url) {
+          url = Services.blocklist.getPluginBlocklistURL(pluginInfo.pluginTag);
+        }
+      } else {
+        url = Services.urlFormatter.formatURLPref("app.support.baseURL") + "clicktoplay";
+      }
+      pluginInfo.detailsLink = url;
+
+      let chromeWin = window.QueryInterface(Ci.nsIDOMChromeWindow);
+      let isWindowPrivate = PrivateBrowsingUtils.isWindowPrivate(chromeWin);
+
+      let active = pluginInfo.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE;
+
+      let options = {
+        dismissed: !showNow,
+        hideClose: !Services.prefs.getBoolPref("privacy.permissionPrompts.showCloseButton"),
+        persistent: showNow,
+        eventCallback: this._clickToPlayNotificationEventCallback,
+        primaryPlugin: primaryPluginPermission,
+        popupIconClass: "plugin-icon",
+        extraAttr: active ? "active" : "inactive",
+        pluginData,
+        principal,
+      };
+
+      let description;
+      if (pluginInfo.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE) {
+        description = gNavigatorBundle.getString("flashActivate.outdated.message");
+      } else {
+        description = gNavigatorBundle.getString("flashActivate.message");
+      }
+
+      let badge = document.getElementById("plugin-icon-badge");
+      badge.setAttribute("animate", "true");
+      badge.addEventListener("animationend", function animListener(event) {
+        if (event.animationName == "blink-badge" &&
+            badge.hasAttribute("animate")) {
+          badge.removeAttribute("animate");
+          badge.removeEventListener("animationend", animListener);
+        }
+      });
+
+      let weakBrowser = Cu.getWeakReference(browser);
+      let mainAction = {
+        callback: ({checkboxChecked}) => {
+          let browserRef = weakBrowser.get();
+          if (browserRef) {
+            if (checkboxChecked) {
+              this._updatePluginPermission(browserRef, pluginInfo, "allowalways");
+            } else if (pluginInfo.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE) {
+              this._updatePluginPermission(browserRef, pluginInfo, "continue");
+            } else {
+              this._updatePluginPermission(browserRef, pluginInfo, "allownow");
+            }
+          }
+        },
+        label: gNavigatorBundle.getString("flashActivate.allow"),
+        accessKey: gNavigatorBundle.getString("flashActivate.allow.accesskey"),
+        dismiss: true,
+      };
+
+      let secondaryActions = null;
+      if (!isWindowPrivate) {
+        options.checkbox = {
+          label: gNavigatorBundle.getString("flashActivate.remember"),
+        };
+        secondaryActions = [{
+          callback: ({checkboxChecked}) => {
+            let browserRef = weakBrowser.get();
+            if (browserRef) {
+              if (checkboxChecked) {
+                this._updatePluginPermission(browserRef, pluginInfo, "blockalways");
+              } else if (pluginInfo.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE) {
+                this._updatePluginPermission(browserRef, pluginInfo, "block");
+              } else {
+                this._updatePluginPermission(browserRef, pluginInfo, "continueblocking");
+              }
+            }
+          },
+          label: gNavigatorBundle.getString("flashActivate.noAllow"),
+          accessKey: gNavigatorBundle.getString("flashActivate.noAllow.accesskey"),
+          dismiss: true,
+        }];
+      }
+
+      PopupNotifications.show(browser, "click-to-play-plugins",
+                                             description, "plugins-notification-icon",
+                                             mainAction, secondaryActions, options);
+      browser.messageManager.sendAsyncMessage("BrowserPlugins:NotificationShown");
+    } else {
+      this.removeNotification(browser, "click-to-play-plugins");
+    }
+  },
+
+  removeNotification(browser, name) {
+    let notification = PopupNotifications.getNotification(name, browser);
+    if (notification)
+      PopupNotifications.remove(notification);
+  },
+
+  hideNotificationBar(browser, name) {
+    let notificationBox = gBrowser.getNotificationBox(browser);
+    let notification = notificationBox.getNotificationWithValue(name);
+    if (notification)
+      notificationBox.removeNotification(notification, true);
+  },
+
+  infobarBlockedForURI(uri) {
+    return new Promise((resolve, reject) => {
+      let tableName = Services.prefs.getStringPref("urlclassifier.flashInfobarTable", "");
+      if (!tableName) {
+        resolve(false);
+      }
+      let classifier = Cc["@mozilla.org/url-classifier/dbservice;1"]
+        .getService(Ci.nsIURIClassifier);
+      classifier.asyncClassifyLocalWithTables(uri, tableName, (c, list) => {
+        resolve(list.length > 0);
+      });
+    });
+  },
+
+  async updateHiddenPluginUI(browser, haveInsecure, actions,
+                                 principal, location) {
+    let origin = principal.originNoSuffix;
+
+    let shouldShowNotification = !(await this.infobarBlockedForURI(browser.documentURI));
+
+    // It is possible that we've received a message from the frame script to show
+    // the hidden plugin notification for a principal that no longer matches the one
+    // that the browser's content now has assigned (ie, the browser has browsed away
+    // after the message was sent, but before the message was received). In that case,
+    // we should just ignore the message.
+    if (!principal.equals(browser.contentPrincipal)) {
+      return;
+    }
+
+    // Data URIs, when linked to from some page, inherit the principal of that
+    // page. That means that we also need to compare the actual locations to
+    // ensure we aren't getting a message from a Data URI that we're no longer
+    // looking at.
+    let receivedURI = Services.io.newURI(location);
+    if (!browser.documentURI.equalsExceptRef(receivedURI)) {
+      return;
+    }
+
+    // Set up the icon
+    document.getElementById("plugins-notification-icon").classList.
+      toggle("plugin-blocked", haveInsecure);
+
+    // Now configure the notification bar
+    let notificationBox = gBrowser.getNotificationBox(browser);
+
+    function hideNotification() {
+      let n = notificationBox.getNotificationWithValue("plugin-hidden");
+      if (n) {
+        notificationBox.removeNotification(n, true);
+      }
+    }
+
+    // There are three different cases when showing an infobar:
+    // 1.  A single type of plugin is hidden on the page. Show the UI for that
+    //     plugin.
+    // 2a. Multiple types of plugins are hidden on the page. Show the multi-UI
+    //     with the vulnerable styling.
+    // 2b. Multiple types of plugins are hidden on the page, but none are
+    //     vulnerable. Show the nonvulnerable multi-UI.
+    function showNotification() {
+      if (!Services.prefs.getBoolPref(gPluginHandler.PREF_SHOW_INFOBAR, true)) {
+        return;
+      }
+
+      let n = notificationBox.getNotificationWithValue("plugin-hidden");
+      if (n) {
+        // If something is already shown, just keep it
+        return;
+      }
+
+      Services.telemetry.getHistogramById("PLUGINS_INFOBAR_SHOWN").
+        add(true);
+
+      let message;
+      // Icons set directly cannot be manipulated using moz-image-region, so
+      // we use CSS classes instead.
+      let brand = document.getElementById("bundle_brand").getString("brandShortName");
+
+      if (actions.length == 1) {
+        let pluginInfo = actions[0];
+        let pluginName = pluginInfo.pluginName;
+
+        switch (pluginInfo.fallbackType) {
+          case Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY:
+          case Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET:
+            message = gNavigatorBundle.getFormattedString(
+              "pluginActivationWarning.message",
+              [brand]);
+            break;
+          case Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE:
+            message = gNavigatorBundle.getFormattedString(
+              "pluginActivateOutdated.message",
+              [pluginName, origin, brand]);
+            break;
+          case Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_NO_UPDATE:
+            message = gNavigatorBundle.getFormattedString(
+              "pluginActivateVulnerable.message",
+              [pluginName, origin, brand]);
+        }
+      } else {
+        // Multi-plugin
+        message = gNavigatorBundle.getFormattedString(
+          "pluginActivateMultiple.message", [origin]);
+      }
+
+      let buttons = [
+        {
+          label: gNavigatorBundle.getString("pluginContinueBlocking.label"),
+          accessKey: gNavigatorBundle.getString("pluginContinueBlocking.accesskey"),
+          callback() {
+            Services.telemetry.getHistogramById("PLUGINS_INFOBAR_BLOCK").
+              add(true);
+
+            Services.perms.addFromPrincipal(principal,
+                                            "plugin-hidden-notification",
+                                            Services.perms.DENY_ACTION);
+          }
+        },
+        {
+          label: gNavigatorBundle.getString("pluginActivateTrigger.label"),
+          accessKey: gNavigatorBundle.getString("pluginActivateTrigger.accesskey"),
+          callback() {
+            Services.telemetry.getHistogramById("PLUGINS_INFOBAR_ALLOW").
+              add(true);
+
+            let curNotification =
+              PopupNotifications.getNotification("click-to-play-plugins",
+                                                 browser);
+            if (curNotification) {
+              curNotification.reshow();
+            }
+          }
+        }
+      ];
+      function notificationCallback(type) {
+        if (type == "dismissed") {
+          Services.telemetry.getHistogramById("PLUGINS_INFOBAR_DISMISSED").
+            add(true);
+          if (Services.prefs.getBoolPref(gPluginHandler.PREF_INFOBAR_DISMISSAL_PERMANENT, false)) {
+            Services.perms.addFromPrincipal(principal,
+                                            "plugin-hidden-notification",
+                                            Services.perms.DENY_ACTION);
+          }
+        }
+      }
+      n = notificationBox.
+        appendNotification(message, "plugin-hidden", null,
+                           notificationBox.PRIORITY_INFO_HIGH, buttons,
+                           notificationCallback);
+      if (haveInsecure) {
+        n.classList.add("pluginVulnerable");
+      }
+    }
+
+    if (actions.length == 0) {
+      shouldShowNotification = false;
+    }
+    if (shouldShowNotification &&
+        Services.perms.testPermissionFromPrincipal(principal, "plugin-hidden-notification") ==
+        Ci.nsIPermissionManager.DENY_ACTION) {
+      shouldShowNotification = false;
+    }
+    if (shouldShowNotification) {
+      showNotification();
+    } else {
+      hideNotification();
+    }
+  },
+
+  contextMenuCommand(browser, plugin, command) {
+    browser.messageManager.sendAsyncMessage("BrowserPlugins:ContextMenuCommand",
+      { command }, { plugin });
+  },
+
+  // Crashed-plugin observer. Notified once per plugin crash, before events
+  // are dispatched to individual plugin instances.
+  NPAPIPluginCrashed(subject, topic, data) {
+    let propertyBag = subject;
+    if (!(propertyBag instanceof Ci.nsIPropertyBag2) ||
+        !(propertyBag instanceof Ci.nsIWritablePropertyBag2) ||
+        !propertyBag.hasKey("runID") ||
+        !propertyBag.hasKey("pluginName")) {
+      Cu.reportError("A NPAPI plugin crashed, but the properties of this plugin " +
+                     "cannot be read.");
+      return;
+    }
+
+    let runID = propertyBag.getPropertyAsUint32("runID");
+    let uglyPluginName = propertyBag.getPropertyAsAString("pluginName");
+    let pluginName = BrowserUtils.makeNicePluginName(uglyPluginName);
+    let pluginDumpID = propertyBag.getPropertyAsAString("pluginDumpID");
+
+    // If we don't have a minidumpID, we can't (or didn't) submit anything.
+    // This can happen if the plugin is killed from the task manager.
+    let state;
+    if (!AppConstants.MOZ_CRASHREPORTER || !gCrashReporter.enabled) {
+      // This state tells the user that crash reporting is disabled, so we
+      // cannot send a report.
+      state = "noSubmit";
+    } else if (!pluginDumpID) {
+      // This state tells the user that there is no crash report available.
+      state = "noReport";
+    } else {
+      // This state asks the user to submit a crash report.
+      state = "please";
+    }
+
+    let mm = window.getGroupMessageManager("browsers");
+    mm.broadcastAsyncMessage("BrowserPlugins:NPAPIPluginProcessCrashed",
+                             { pluginName, runID, state });
+  },
+
+  /**
+   * Shows a plugin-crashed notification bar for a browser that has had an
+   * invisiable NPAPI plugin crash, or a GMP plugin crash.
+   *
+   * @param browser
+   *        The browser to show the notification for.
+   * @param messageString
+   *        The string to put in the notification bar
+   * @param pluginID
+   *        The unique-per-process identifier for the NPAPI plugin or GMP.
+   *        For a GMP, this is the pluginID. For NPAPI plugins (where "pluginID"
+   *        means something different), this is the runID.
+   */
+  showPluginCrashedNotification(browser, messageString, pluginID) {
+    // If there's already an existing notification bar, don't do anything.
+    let notificationBox = gBrowser.getNotificationBox(browser);
+    let notification = notificationBox.getNotificationWithValue("plugin-crashed");
+    if (notification) {
+      return;
+    }
+
+    // Configure the notification bar
+    let priority = notificationBox.PRIORITY_WARNING_MEDIUM;
+    let iconURL = "chrome://mozapps/skin/plugins/pluginGeneric.svg";
+    let reloadLabel = gNavigatorBundle.getString("crashedpluginsMessage.reloadButton.label");
+    let reloadKey   = gNavigatorBundle.getString("crashedpluginsMessage.reloadButton.accesskey");
+
+    let buttons = [{
+      label: reloadLabel,
+      accessKey: reloadKey,
+      popup: null,
+      callback() { browser.reload(); },
+    }];
+
+    if (AppConstants.MOZ_CRASHREPORTER &&
+        PluginCrashReporter.hasCrashReport(pluginID)) {
+      let submitLabel = gNavigatorBundle.getString("crashedpluginsMessage.submitButton.label");
+      let submitKey   = gNavigatorBundle.getString("crashedpluginsMessage.submitButton.accesskey");
+      let submitButton = {
+        label: submitLabel,
+        accessKey: submitKey,
+        popup: null,
+        callback: () => {
+          PluginCrashReporter.submitCrashReport(pluginID);
+        },
+      };
+
+      buttons.push(submitButton);
+    }
+
+    notification = notificationBox.appendNotification(messageString, "plugin-crashed",
+                                                      iconURL, priority, buttons);
+
+    // Add the "learn more" link.
+    let XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    let link = notification.ownerDocument.createElementNS(XULNS, "label");
+    link.className = "text-link";
+    link.setAttribute("value", gNavigatorBundle.getString("crashedpluginsMessage.learnMore"));
+    let crashurl = formatURL("app.support.baseURL", true);
+    crashurl += "plugin-crashed-notificationbar";
+    link.href = crashurl;
+    let description = notification.ownerDocument.getAnonymousElementByAttribute(notification, "anonid", "messageText");
+    description.appendChild(link);
+  },
+};
+
+gPluginHandler.init();
+
+
+/***/ }),
+/* 9 */
+/***/ (function(module, exports) {
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * SidebarUI controls showing and hiding the browser sidebar.
+ *
+ * @note
+ * Some of these methods take a commandID argument - we expect to find a
+ * xul:broadcaster element with the specified ID.
+ * The following attributes on that element may be used and/or modified:
+ *  - id           (required) the string to match commandID. The convention
+ *                 is to use this naming scheme: 'view<sidebar-name>Sidebar'.
+ *  - sidebarurl   (required) specifies the URL to load in this sidebar.
+ *  - sidebartitle or label (in that order) specify the title to
+ *                 display on the sidebar.
+ *  - checked      indicates whether the sidebar is currently displayed.
+ *                 Note that this attribute is updated when
+ *                 the sidebar's visibility is changed.
+ *  - group        this attribute must be set to "sidebar".
+ */
+var SidebarUI = {
+  // Avoid getting the browser element from init() to avoid triggering the
+  // <browser> constructor during startup if the sidebar is hidden.
+  get browser() {
+    if (this._browser)
+      return this._browser;
+    return this._browser = document.getElementById("sidebar");
+  },
+  POSITION_START_PREF: "sidebar.position_start",
+  DEFAULT_SIDEBAR_ID: "viewBookmarksSidebar",
+
+  // lastOpenedId is set in show() but unlike currentID it's not cleared out on hide
+  // and isn't persisted across windows
+  lastOpenedId: null,
+
+  _box: null,
+  // The constructor of this label accesses the browser element due to the
+  // control="sidebar" attribute, so avoid getting this label during startup.
+  get _title() {
+    if (this.__title)
+      return this.__title;
+    return this.__title = document.getElementById("sidebar-title");
+  },
+  _splitter: null,
+  _icon: null,
+  _reversePositionButton: null,
+  _switcherPanel: null,
+  _switcherTarget: null,
+  _switcherArrow: null,
+
+  init() {
+    this._box = document.getElementById("sidebar-box");
+    this._splitter = document.getElementById("sidebar-splitter");
+    this._icon = document.getElementById("sidebar-icon");
+    this._reversePositionButton = document.getElementById("sidebar-reverse-position");
+    this._switcherPanel = document.getElementById("sidebarMenu-popup");
+    this._switcherTarget = document.getElementById("sidebar-switcher-target");
+    this._switcherArrow = document.getElementById("sidebar-switcher-arrow");
+
+    this._switcherTarget.addEventListener("command", () => {
+      this.toggleSwitcherPanel();
+    });
+  },
+
+  uninit() {
+    // If this is the last browser window, persist various values that should be
+    // remembered for after a restart / reopening a browser window.
+    let enumerator = Services.wm.getEnumerator("navigator:browser");
+    if (!enumerator.hasMoreElements()) {
+      document.persist("sidebar-box", "sidebarcommand");
+
+      let xulStore = Cc["@mozilla.org/xul/xulstore;1"].getService(Ci.nsIXULStore);
+      if (this._box.hasAttribute("positionend")) {
+        document.persist("sidebar-box", "positionend");
+      } else {
+        xulStore.removeValue(document.documentURI, "sidebar-box", "positionend");
+      }
+      if (this._box.hasAttribute("checked")) {
+        document.persist("sidebar-box", "checked");
+      } else {
+        xulStore.removeValue(document.documentURI, "sidebar-box", "checked");
+      }
+
+      document.persist("sidebar-box", "width");
+      document.persist("sidebar-title", "value");
+    }
+  },
+
+  /**
+   * Opens the switcher panel if it's closed, or closes it if it's open.
+   */
+  toggleSwitcherPanel() {
+    if (this._switcherPanel.state == "open" || this._switcherPanel.state == "showing") {
+      this.hideSwitcherPanel();
+    } else if (this._switcherPanel.state == "closed") {
+      this.showSwitcherPanel();
+    }
+  },
+
+  hideSwitcherPanel() {
+    this._switcherPanel.hidePopup();
+  },
+
+  showSwitcherPanel() {
+    this._ensureShortcutsShown();
+    this._switcherPanel.addEventListener("popuphiding", () => {
+      this._switcherTarget.classList.remove("active");
+    }, {once: true});
+
+    // Combine start/end position with ltr/rtl to set the label in the popup appropriately.
+    let label = this._positionStart == this.isRTL ?
+                  gNavigatorBundle.getString("sidebar.moveToLeft") :
+                  gNavigatorBundle.getString("sidebar.moveToRight");
+    this._reversePositionButton.setAttribute("label", label);
+
+    this._switcherPanel.hidden = false;
+    this._switcherPanel.openPopup(this._icon);
+    this._switcherTarget.classList.add("active");
+  },
+
+  _addedShortcuts: false,
+  _ensureShortcutsShown() {
+    if (this._addedShortcuts) {
+      return;
+    }
+    this._addedShortcuts = true;
+    for (let button of this._switcherPanel.querySelectorAll("toolbarbutton[key]")) {
+      let keyId = button.getAttribute("key");
+      let key = document.getElementById(keyId);
+      if (!key) {
+        continue;
+      }
+      button.setAttribute("shortcut", ShortcutUtils.prettifyShortcut(key));
+    }
+  },
+
+  /**
+   * Change the pref that will trigger a call to setPosition
+   */
+  reversePosition() {
+    Services.prefs.setBoolPref(this.POSITION_START_PREF, !this._positionStart);
+  },
+
+  /**
+   * Read the positioning pref and position the sidebar and the splitter
+   * appropriately within the browser container.
+   */
+  setPosition() {
+    // First reset all ordinals to match DOM ordering.
+    let browser = document.getElementById("browser");
+    [...browser.childNodes].forEach((node, i) => {
+      node.ordinal = i + 1;
+    });
+
+    if (!this._positionStart) {
+      // DOM ordering is:     |  sidebar-box  | splitter |   appcontent  |
+      // Want to display as:  |   appcontent  | splitter |  sidebar-box  |
+      // So we just swap box and appcontent ordering
+      let appcontent = document.getElementById("appcontent");
+      let boxOrdinal = this._box.ordinal;
+      this._box.ordinal = appcontent.ordinal;
+      appcontent.ordinal = boxOrdinal;
+      // Indicate we've switched ordering to the box
+      this._box.setAttribute("positionend", true);
+    } else {
+      this._box.removeAttribute("positionend");
+    }
+
+    this.hideSwitcherPanel();
+  },
+
+  /**
+   * Try and adopt the status of the sidebar from another window.
+   * @param {Window} sourceWindow - Window to use as a source for sidebar status.
+   * @return true if we adopted the state, or false if the caller should
+   * initialize the state itself.
+   */
+  adoptFromWindow(sourceWindow) {
+    // If the opener had a sidebar, open the same sidebar in our window.
+    // The opener can be the hidden window too, if we're coming from the state
+    // where no windows are open, and the hidden window has no sidebar box.
+    let sourceUI = sourceWindow.SidebarUI;
+    if (!sourceUI || !sourceUI._box) {
+      // no source UI or no _box means we also can't adopt the state.
+      return false;
+    }
+
+    // Set sidebar command even if hidden, so that we keep the same sidebar
+    // even if it's currently closed.
+    let commandID = sourceUI._box.getAttribute("sidebarcommand");
+    if (commandID) {
+      this._box.setAttribute("sidebarcommand", commandID);
+    }
+
+    if (sourceUI._box.hidden) {
+      // just hidden means we have adopted the hidden state.
+      return true;
+    }
+
+    // dynamically generated sidebars will fail this check, but we still
+    // consider it adopted.
+    if (!document.getElementById(commandID)) {
+      return true;
+    }
+
+    this._box.setAttribute("width", sourceUI._box.boxObject.width);
+    this.showInitially(commandID);
+
+    return true;
+  },
+
+  windowPrivacyMatches(w1, w2) {
+    return PrivateBrowsingUtils.isWindowPrivate(w1) === PrivateBrowsingUtils.isWindowPrivate(w2);
+  },
+
+  /**
+   * If loading a sidebar was delayed on startup, start the load now.
+   */
+  startDelayedLoad() {
+    let sourceWindow = window.opener;
+    // No source window means this is the initial window.  If we're being
+    // opened from another window, check that it is one we might open a sidebar
+    // for.
+    if (sourceWindow) {
+      if (sourceWindow.closed || sourceWindow.location.protocol != "chrome:" ||
+        !this.windowPrivacyMatches(sourceWindow, window)) {
+        return;
+      }
+      // Try to adopt the sidebar state from the source window
+      if (this.adoptFromWindow(sourceWindow)) {
+        return;
+      }
+    }
+
+    // If we're not adopting settings from a parent window, set them now.
+    let wasOpen = this._box.getAttribute("checked");
+    if (!wasOpen) {
+      return;
+    }
+
+    let commandID = this._box.getAttribute("sidebarcommand");
+    if (commandID && document.getElementById(commandID)) {
+      this.showInitially(commandID);
+    } else {
+      this._box.removeAttribute("checked");
+      // Remove the |sidebarcommand| attribute, because the element it
+      // refers to no longer exists, so we should assume this sidebar
+      // panel has been uninstalled. (249883)
+      // We use setAttribute rather than removeAttribute so it persists
+      // correctly.
+      this._box.setAttribute("sidebarcommand", "");
+      // On a startup in which the startup cache was invalidated (e.g. app update)
+      // extensions will not be started prior to delayedLoad, thus the
+      // sidebarcommand element will not exist yet.  Store the commandID so
+      // extensions may reopen if necessary.  A startup cache invalidation
+      // can be forced (for testing) by deleting compatibility.ini from the
+      // profile.
+      this.lastOpenedId = commandID;
+    }
+  },
+
+  /**
+   * Fire a "SidebarShown" event on the sidebar to give any interested parties
+   * a chance to update the button or whatever.
+   */
+  _fireShowEvent() {
+    let event = new CustomEvent("SidebarShown", {bubbles: true});
+    this._switcherTarget.dispatchEvent(event);
+  },
+
+  /**
+   * Fire a "SidebarFocused" event on the sidebar's |window| to give the sidebar
+   * a chance to adjust focus as needed. An additional event is needed, because
+   * we don't want to focus the sidebar when it's opened on startup or in a new
+   * window, only when the user opens the sidebar.
+   */
+  _fireFocusedEvent() {
+    let event = new CustomEvent("SidebarFocused", {bubbles: true});
+    this.browser.contentWindow.dispatchEvent(event);
+  },
+
+  /**
+   * True if the sidebar is currently open.
+   */
+  get isOpen() {
+    return !this._box.hidden;
+  },
+
+  /**
+   * The ID of the current sidebar (ie, the ID of the broadcaster being used).
+   */
+  get currentID() {
+    return this.isOpen ? this._box.getAttribute("sidebarcommand") : "";
+  },
+
+  get title() {
+    return this._title.value;
+  },
+
+  set title(value) {
+    this._title.value = value;
+  },
+
+  getBroadcasterById(id) {
+    let sidebarBroadcaster = document.getElementById(id);
+    if (sidebarBroadcaster && sidebarBroadcaster.localName == "broadcaster") {
+      return sidebarBroadcaster;
+    }
+    return null;
+  },
+
+  /**
+   * Toggle the visibility of the sidebar. If the sidebar is hidden or is open
+   * with a different commandID, then the sidebar will be opened using the
+   * specified commandID. Otherwise the sidebar will be hidden.
+   *
+   * @param  {string}  commandID     ID of the xul:broadcaster element to use.
+   * @param  {DOMNode} [triggerNode] Node, usually a button, that triggered the
+   *                                 visibility toggling of the sidebar.
+   * @return {Promise}
+   */
+  toggle(commandID = this.lastOpenedId, triggerNode) {
+    // First priority for a default value is this.lastOpenedId which is set during show()
+    // and not reset in hide(), unlike currentID. If show() hasn't been called and we don't
+    // have a persisted command either, or the command doesn't exist anymore, then
+    // fallback to a default sidebar.
+    if (!commandID) {
+      commandID = this._box.getAttribute("sidebarcommand");
+    }
+    if (!commandID || !this.getBroadcasterById(commandID)) {
+      commandID = this.DEFAULT_SIDEBAR_ID;
+    }
+
+    if (this.isOpen && commandID == this.currentID) {
+      this.hide(triggerNode);
+      return Promise.resolve();
+    }
+    return this.show(commandID, triggerNode);
+  },
+
+  /**
+   * Show the sidebar, using the parameters from the specified broadcaster.
+   * @see SidebarUI note.
+   *
+   * This wraps the internal method, including a ping to telemetry.
+   *
+   * @param {string}  commandID     ID of the xul:broadcaster element to use.
+   * @param {DOMNode} [triggerNode] Node, usually a button, that triggered the
+   *                                showing of the sidebar.
+   */
+  show(commandID, triggerNode) {
+    return this._show(commandID).then(() => {
+      if (triggerNode) {
+        updateToggleControlLabel(triggerNode);
+      }
+
+      this._fireFocusedEvent();
+      BrowserUITelemetry.countSidebarEvent(commandID, "show");
+    });
+  },
+
+  /**
+   * Show the sidebar, without firing the focused event or logging telemetry.
+   * This is intended to be used when the sidebar is opened automatically
+   * when a window opens (not triggered by user interaction).
+   *
+   * @param {string} commandID ID of the xul:broadcaster element to use.
+   */
+   showInitially(commandID) {
+     return this._show(commandID);
+   },
+
+  /**
+   * Implementation for show. Also used internally for sidebars that are shown
+   * when a window is opened and we don't want to ping telemetry.
+   *
+   * @param {string} commandID ID of the xul:broadcaster element to use.
+   */
+  _show(commandID) {
+    return new Promise((resolve, reject) => {
+      let sidebarBroadcaster = this.getBroadcasterById(commandID);
+      if (!sidebarBroadcaster) {
+        reject(new Error("Invalid sidebar broadcaster specified: " + commandID));
+        return;
+      }
+
+      if (this.isOpen && commandID != this.currentID) {
+        BrowserUITelemetry.countSidebarEvent(this.currentID, "hide");
+      }
+
+      let broadcasters = document.querySelectorAll("broadcaster[group=sidebar]");
+      for (let broadcaster of broadcasters) {
+        if (broadcaster != sidebarBroadcaster) {
+          broadcaster.removeAttribute("checked");
+        } else {
+          sidebarBroadcaster.setAttribute("checked", "true");
+        }
+      }
+
+      this._box.hidden = this._splitter.hidden = false;
+      this.setPosition();
+
+      this.hideSwitcherPanel();
+
+      this._box.setAttribute("checked", "true");
+      this._box.setAttribute("sidebarcommand", sidebarBroadcaster.id);
+      this.lastOpenedId = sidebarBroadcaster.id;
+
+      let title = sidebarBroadcaster.getAttribute("sidebartitle") ||
+                  sidebarBroadcaster.getAttribute("label");
+
+      // When loading a web page in the sidebar there is no title set on the
+      // broadcaster, as it is instead set by openWebPanel. Don't clear out
+      // the title in this case.
+      if (title) {
+        this.title = title;
+      }
+
+      let url = sidebarBroadcaster.getAttribute("sidebarurl");
+      this.browser.setAttribute("src", url); // kick off async load
+
+      if (this.browser.contentDocument.location.href != url) {
+        this.browser.addEventListener("load", event => {
+          // We're handling the 'load' event before it bubbles up to the usual
+          // (non-capturing) event handlers. Let it bubble up before resolving.
+          setTimeout(() => {
+            resolve();
+
+            // Now that the currentId is updated, fire a show event.
+            this._fireShowEvent();
+          }, 0);
+        }, {capture: true, once: true});
+      } else {
+        resolve();
+
+        // Now that the currentId is updated, fire a show event.
+        this._fireShowEvent();
+      }
+
+      let selBrowser = gBrowser.selectedBrowser;
+      selBrowser.messageManager.sendAsyncMessage("Sidebar:VisibilityChange",
+        {commandID, isOpen: true}
+      );
+    });
+  },
+
+  /**
+  * Sets the webpage favicon in sidebar
+  *
+  */
+  setWebPageIcon(url) {
+    let iconURL = "url(page-icon:" + url + ")";
+    if (this._box.getAttribute("sidebarcommand") == "viewWebPanelsSidebar") {
+      this._icon.style.setProperty("--sidebar-webpage-icon", iconURL);
+    }
+  },
+
+  /**
+   * Hide the sidebar.
+   *
+   * @param {DOMNode} [triggerNode] Node, usually a button, that triggered the
+   *                                hiding of the sidebar.
+   */
+  hide(triggerNode) {
+    if (!this.isOpen) {
+      return;
+    }
+
+    this.hideSwitcherPanel();
+
+    let commandID = this._box.getAttribute("sidebarcommand");
+    let sidebarBroadcaster = document.getElementById(commandID);
+
+    if (sidebarBroadcaster.getAttribute("checked") != "true") {
+      return;
+    }
+
+    // Replace the document currently displayed in the sidebar with about:blank
+    // so that we can free memory by unloading the page. We need to explicitly
+    // create a new content viewer because the old one doesn't get destroyed
+    // until about:blank has loaded (which does not happen as long as the
+    // element is hidden).
+    this.browser.setAttribute("src", "about:blank");
+    this.browser.docShell.createAboutBlankContentViewer(null);
+
+    sidebarBroadcaster.removeAttribute("checked");
+    this._box.removeAttribute("checked");
+    this._box.hidden = this._splitter.hidden = true;
+
+    let selBrowser = gBrowser.selectedBrowser;
+    selBrowser.focus();
+    selBrowser.messageManager.sendAsyncMessage("Sidebar:VisibilityChange",
+      {commandID, isOpen: false}
+    );
+    if (triggerNode) {
+      updateToggleControlLabel(triggerNode);
+    }
+    BrowserUITelemetry.countSidebarEvent(commandID, "hide");
+  },
+};
+
+// Add getters related to the position here, since we will want them
+// available for both startDelayedLoad and init.
+XPCOMUtils.defineLazyPreferenceGetter(SidebarUI, "_positionStart",
+  SidebarUI.POSITION_START_PREF, true, SidebarUI.setPosition.bind(SidebarUI));
+XPCOMUtils.defineLazyGetter(SidebarUI, "isRTL", () => {
+  return getComputedStyle(document.documentElement).direction == "rtl";
+});
+
+
+/***/ }),
+/* 10 */
+/***/ (function(module, exports) {
+
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Note: the file browser-tabsintitlebar-stub.js is used instead of
+// this one on platforms which don't have CAN_DRAW_IN_TITLEBAR defined.
+
+var TabsInTitlebar = {
+  init() {
+    if (this._initialized) {
+      return;
+    }
+    this._readPref();
+    Services.prefs.addObserver(this._prefName, this);
+
+    // Always disable on unsupported GTK versions.
+    if (AppConstants.MOZ_WIDGET_TOOLKIT == "gtk3") {
+      this.allowedBy("gtk", window.matchMedia("(-moz-gtk-csd-available)"));
+    }
+
+    // We need to update the appearance of the titlebar when the menu changes
+    // from the active to the inactive state. We can't, however, rely on
+    // DOMMenuBarInactive, because the menu fires this event and then removes
+    // the inactive attribute after an event-loop spin.
+    //
+    // Because updating the appearance involves sampling the heights and margins
+    // of various elements, it's important that the layout be more or less
+    // settled before updating the titlebar. So instead of listening to
+    // DOMMenuBarActive and DOMMenuBarInactive, we use a MutationObserver to
+    // watch the "invalid" attribute directly.
+    let menu = document.getElementById("toolbar-menubar");
+    this._menuObserver = new MutationObserver(this._onMenuMutate);
+    this._menuObserver.observe(menu, {attributes: true});
+
+    this.onAreaReset = function(aArea) {
+      if (aArea == CustomizableUI.AREA_TABSTRIP || aArea == CustomizableUI.AREA_MENUBAR)
+        this._update(true);
+    };
+    this.onWidgetAdded = this.onWidgetRemoved = function(aWidgetId, aArea) {
+      if (aArea == CustomizableUI.AREA_TABSTRIP || aArea == CustomizableUI.AREA_MENUBAR)
+        this._update(true);
+    };
+    CustomizableUI.addListener(this);
+
+    addEventListener("resolutionchange", this, false);
+
+    this._initialized = true;
+    if (this._updateOnInit) {
+      // We don't need to call this with 'true', even if original calls
+      // (before init()) did, because this will be the first call and so
+      // we will update anyway.
+      this._update();
+    }
+  },
+
+  allowedBy(condition, allow) {
+    if (allow) {
+      if (condition in this._disallowed) {
+        delete this._disallowed[condition];
+        this._update(true);
+      }
+    } else if (!(condition in this._disallowed)) {
+      this._disallowed[condition] = null;
+      this._update(true);
+    }
+  },
+
+  updateAppearance: function updateAppearance(aForce) {
+    this._update(aForce);
+  },
+
+  get enabled() {
+    return document.documentElement.getAttribute("tabsintitlebar") == "true";
+  },
+
+  observe(subject, topic, data) {
+    if (topic == "nsPref:changed")
+      this._readPref();
+  },
+
+  handleEvent(aEvent) {
+    if (aEvent.type == "resolutionchange" && aEvent.target == window) {
+      this._update(true);
+    }
+  },
+
+  _onMenuMutate(aMutations) {
+    for (let mutation of aMutations) {
+      if (mutation.attributeName == "inactive" ||
+          mutation.attributeName == "autohide") {
+        TabsInTitlebar._update(true);
+        return;
+      }
+    }
+  },
+
+  _initialized: false,
+  _updateOnInit: false,
+  _disallowed: {},
+  _prefName: "browser.tabs.drawInTitlebar",
+  _lastSizeMode: null,
+
+  _readPref() {
+    this.allowedBy("pref",
+                   Services.prefs.getBoolPref(this._prefName));
+  },
+
+  _update(aForce = false) {
+    let $ = id => document.getElementById(id);
+    let rect = ele => ele.getBoundingClientRect();
+    let verticalMargins = cstyle => parseFloat(cstyle.marginBottom) + parseFloat(cstyle.marginTop);
+
+    if (window.fullScreen)
+      return;
+
+    // In some edgecases it is possible for this to fire before we've initialized.
+    // Don't run now, but don't forget to run it when we do initialize.
+    if (!this._initialized) {
+      this._updateOnInit = true;
+      return;
+    }
+
+    if (!aForce) {
+      // _update is called on resize events, because the window is not ready
+      // after sizemode events. However, we only care about the event when the
+      // sizemode is different from the last time we updated the appearance of
+      // the tabs in the titlebar.
+      let sizemode = document.documentElement.getAttribute("sizemode");
+      if (this._lastSizeMode == sizemode) {
+        return;
+      }
+      let oldSizeMode = this._lastSizeMode;
+      this._lastSizeMode = sizemode;
+      // Don't update right now if we are leaving fullscreen, since the UI is
+      // still changing in the consequent "fullscreen" event. Code there will
+      // call this function again when everything is ready.
+      // See browser-fullScreen.js: FullScreen.toggle and bug 1173768.
+      if (oldSizeMode == "fullscreen") {
+        return;
+      }
+    }
+
+    let allowed = (Object.keys(this._disallowed)).length == 0;
+
+    let titlebar = $("titlebar");
+    let titlebarContent = $("titlebar-content");
+    let menubar = $("toolbar-menubar");
+
+    if (allowed) {
+      // We set the tabsintitlebar attribute first so that our CSS for
+      // tabsintitlebar manifests before we do our measurements.
+      document.documentElement.setAttribute("tabsintitlebar", "true");
+      updateTitlebarDisplay();
+
+      // Reset the custom titlebar height if the menubar is shown,
+      // because we will want to calculate its original height.
+      if (AppConstants.isPlatformAndVersionAtLeast("win", "10.0") &&
+          (menubar.getAttribute("inactive") != "true" ||
+          menubar.getAttribute("autohide") != "true")) {
+        $("titlebar-buttonbox").style.removeProperty("height");
+      }
+
+      // Try to avoid reflows in this code by calculating dimensions first and
+      // then later set the properties affecting layout together in a batch.
+
+      // Get the height of the tabs toolbar:
+      let fullTabsHeight = rect($("TabsToolbar")).height;
+
+      // Buttons first:
+      let captionButtonsBoxWidth = rect($("titlebar-buttonbox")).width;
+
+      let secondaryButtonsWidth, menuHeight, fullMenuHeight, menuStyles;
+      if (AppConstants.platform == "macosx") {
+        secondaryButtonsWidth = rect($("titlebar-secondary-buttonbox")).width;
+        // No need to look up the menubar stuff on OS X:
+        menuHeight = 0;
+        fullMenuHeight = 0;
+      } else {
+        // Otherwise, get the height and margins separately for the menubar
+        menuHeight = rect(menubar).height;
+        menuStyles = window.getComputedStyle(menubar);
+        fullMenuHeight = verticalMargins(menuStyles) + menuHeight;
+      }
+
+      // And get the height of what's in the titlebar:
+      let titlebarContentHeight = rect(titlebarContent).height;
+
+      // Begin setting CSS properties which will cause a reflow
+
+      // On Windows 10, adjust the window controls to span the entire
+      // tab strip height if we're not showing a menu bar.
+      if (AppConstants.isPlatformAndVersionAtLeast("win", "10.0") &&
+          !menuHeight) {
+        titlebarContentHeight = fullTabsHeight;
+        $("titlebar-buttonbox").style.height = titlebarContentHeight + "px";
+      }
+
+      // If the menubar is around (menuHeight is non-zero), try to adjust
+      // its full height (i.e. including margins) to match the titlebar,
+      // by changing the menubar's bottom padding
+      if (menuHeight) {
+        // Calculate the difference between the titlebar's height and that of the menubar
+        let menuTitlebarDelta = titlebarContentHeight - fullMenuHeight;
+        let paddingBottom;
+        // The titlebar is bigger:
+        if (menuTitlebarDelta > 0) {
+          fullMenuHeight += menuTitlebarDelta;
+          // If there is already padding on the menubar, we need to add that
+          // to the difference so the total padding is correct:
+          if ((paddingBottom = menuStyles.paddingBottom)) {
+            menuTitlebarDelta += parseFloat(paddingBottom);
+          }
+          menubar.style.paddingBottom = menuTitlebarDelta + "px";
+        // The menubar is bigger, but has bottom padding we can remove:
+        } else if (menuTitlebarDelta < 0 && (paddingBottom = menuStyles.paddingBottom)) {
+          let existingPadding = parseFloat(paddingBottom);
+          // menuTitlebarDelta is negative; work out what's left, but don't set negative padding:
+          let desiredPadding = Math.max(0, existingPadding + menuTitlebarDelta);
+          menubar.style.paddingBottom = desiredPadding + "px";
+          // We've changed the menu height now:
+          fullMenuHeight += desiredPadding - existingPadding;
+        }
+      }
+
+      // Next, we calculate how much we need to stretch the titlebar down to
+      // go all the way to the bottom of the tab strip, if necessary.
+      let tabAndMenuHeight = fullTabsHeight + fullMenuHeight;
+
+      if (tabAndMenuHeight > titlebarContentHeight) {
+        // We need to increase the titlebar content's outer height (ie including margins)
+        // to match the tab and menu height:
+        let extraMargin = tabAndMenuHeight - titlebarContentHeight;
+        if (AppConstants.platform != "macosx") {
+          titlebarContent.style.marginBottom = extraMargin + "px";
+        }
+
+        titlebarContentHeight += extraMargin;
+      } else {
+        titlebarContent.style.removeProperty("margin-bottom");
+      }
+
+      // Then add a negative margin to the titlebar, so that the following elements
+      // will overlap it by the greater of the titlebar height or the tabstrip+menu.
+      let maxTitlebarOrTabsHeight = Math.max(titlebarContentHeight, tabAndMenuHeight);
+      titlebar.style.marginBottom = "-" + maxTitlebarOrTabsHeight + "px";
+
+      // Finally, size the placeholders:
+      if (AppConstants.platform == "macosx") {
+        this._sizePlaceholder("fullscreen-button", secondaryButtonsWidth);
+      }
+      this._sizePlaceholder("caption-buttons", captionButtonsBoxWidth);
+
+    } else {
+      document.documentElement.removeAttribute("tabsintitlebar");
+      updateTitlebarDisplay();
+
+      if (AppConstants.platform == "macosx") {
+        let secondaryButtonsWidth = rect($("titlebar-secondary-buttonbox")).width;
+        this._sizePlaceholder("fullscreen-button", secondaryButtonsWidth);
+      }
+
+      // Reset the margins and padding that might have been modified:
+      titlebarContent.style.marginTop = "";
+      titlebarContent.style.marginBottom = "";
+      titlebar.style.marginBottom = "";
+      menubar.style.paddingBottom = "";
+    }
+
+    ToolbarIconColor.inferFromText("tabsintitlebar", TabsInTitlebar.enabled);
+
+    if (document.documentElement.hasAttribute("customizing")) {
+      gCustomizeMode.updateLWTStyling();
+    }
+  },
+
+  _sizePlaceholder(type, width) {
+    Array.forEach(document.querySelectorAll(".titlebar-placeholder[type='" + type + "']"),
+                  function(node) { node.width = width; });
+  },
+
+  uninit() {
+    this._initialized = false;
+    removeEventListener("resolutionchange", this);
+    Services.prefs.removeObserver(this._prefName, this);
+    this._menuObserver.disconnect();
+    CustomizableUI.removeListener(this);
+  }
+};
+
+function updateTitlebarDisplay() {
+  if (AppConstants.platform == "macosx") {
+    if (TabsInTitlebar.enabled) {
+      document.documentElement.setAttribute("chromemargin", "0,-1,-1,-1");
+      document.documentElement.removeAttribute("drawtitle");
+    } else {
+      document.documentElement.removeAttribute("chromemargin");
+      document.documentElement.setAttribute("drawtitle", "true");
+    }
+  } else if (TabsInTitlebar.enabled) {
+    // not OS X
+    document.documentElement.setAttribute("chromemargin", "0,2,2,2");
+  } else {
+    document.documentElement.removeAttribute("chromemargin");
+  }
+}
+
+function onTitlebarMaxClick() {
+  if (window.windowState == window.STATE_MAXIMIZED)
+    window.restore();
+  else
+    window.maximize();
+}
+
+
+/***/ }),
+/* 11 */
+/***/ (function(module, exports) {
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var TrackingProtection = {
+  // If the user ignores the doorhanger, we stop showing it after some time.
+  MAX_INTROS: 20,
+  PREF_ENABLED_GLOBALLY: "privacy.trackingprotection.enabled",
+  PREF_ENABLED_IN_PRIVATE_WINDOWS: "privacy.trackingprotection.pbmode.enabled",
+  enabledGlobally: false,
+  enabledInPrivateWindows: false,
+  container: null,
+  content: null,
+  icon: null,
+  activeTooltipText: null,
+  disabledTooltipText: null,
+
+  init() {
+    let $ = selector => document.querySelector(selector);
+    this.container = $("#tracking-protection-container");
+    this.content = $("#tracking-protection-content");
+    this.icon = $("#tracking-protection-icon");
+
+    this.updateEnabled();
+    Services.prefs.addObserver(this.PREF_ENABLED_GLOBALLY, this);
+    Services.prefs.addObserver(this.PREF_ENABLED_IN_PRIVATE_WINDOWS, this);
+
+    this.activeTooltipText =
+      gNavigatorBundle.getString("trackingProtection.icon.activeTooltip");
+    this.disabledTooltipText =
+      gNavigatorBundle.getString("trackingProtection.icon.disabledTooltip");
+
+    this.enabledHistogramAdd(this.enabledGlobally);
+    this.disabledPBMHistogramAdd(!this.enabledInPrivateWindows);
+  },
+
+  uninit() {
+    Services.prefs.removeObserver(this.PREF_ENABLED_GLOBALLY, this);
+    Services.prefs.removeObserver(this.PREF_ENABLED_IN_PRIVATE_WINDOWS, this);
+  },
+
+  observe() {
+    this.updateEnabled();
+  },
+
+  get enabled() {
+    return this.enabledGlobally ||
+           (this.enabledInPrivateWindows &&
+            PrivateBrowsingUtils.isWindowPrivate(window));
+  },
+
+  updateEnabled() {
+    this.enabledGlobally =
+      Services.prefs.getBoolPref(this.PREF_ENABLED_GLOBALLY);
+    this.enabledInPrivateWindows =
+      Services.prefs.getBoolPref(this.PREF_ENABLED_IN_PRIVATE_WINDOWS);
+    this.container.hidden = !this.enabled;
+  },
+
+  enabledHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_ENABLED").add(value);
+  },
+
+  disabledPBMHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_PBM_DISABLED").add(value);
+  },
+
+  eventsHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_EVENTS").add(value);
+  },
+
+  shieldHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_SHIELD").add(value);
+  },
+
+  onSecurityChange(state, isSimulated) {
+    if (!this.enabled) {
+      return;
+    }
+
+    // Only animate the shield if the event was not fired directly from
+    // the tabbrowser (due to a browser change).
+    if (isSimulated) {
+      this.icon.removeAttribute("animate");
+    } else {
+      this.icon.setAttribute("animate", "true");
+    }
+
+    let isBlocking = state & Ci.nsIWebProgressListener.STATE_BLOCKED_TRACKING_CONTENT;
+    let isAllowing = state & Ci.nsIWebProgressListener.STATE_LOADED_TRACKING_CONTENT;
+
+    if (isBlocking) {
+      this.icon.setAttribute("tooltiptext", this.activeTooltipText);
+      this.icon.setAttribute("state", "blocked-tracking-content");
+      this.content.setAttribute("state", "blocked-tracking-content");
+
+      // Open the tracking protection introduction panel, if applicable.
+      if (this.enabledGlobally) {
+        let introCount = Services.prefs.getIntPref("privacy.trackingprotection.introCount");
+        if (introCount < TrackingProtection.MAX_INTROS) {
+          Services.prefs.setIntPref("privacy.trackingprotection.introCount", ++introCount);
+          Services.prefs.savePrefFile(null);
+          this.showIntroPanel();
+        }
+      }
+
+      this.shieldHistogramAdd(2);
+    } else if (isAllowing) {
+      this.icon.setAttribute("tooltiptext", this.disabledTooltipText);
+      this.icon.setAttribute("state", "loaded-tracking-content");
+      this.content.setAttribute("state", "loaded-tracking-content");
+
+      this.shieldHistogramAdd(1);
+    } else {
+      this.icon.removeAttribute("tooltiptext");
+      this.icon.removeAttribute("state");
+      this.content.removeAttribute("state");
+
+      // We didn't show the shield
+      this.shieldHistogramAdd(0);
+    }
+
+    // Telemetry for state change.
+    this.eventsHistogramAdd(0);
+  },
+
+  disableForCurrentPage() {
+    // Convert document URI into the format used by
+    // nsChannelClassifier::ShouldEnableTrackingProtection.
+    // Any scheme turned into https is correct.
+    let normalizedUrl = Services.io.newURI(
+      "https://" + gBrowser.selectedBrowser.currentURI.hostPort);
+
+    // Add the current host in the 'trackingprotection' consumer of
+    // the permission manager using a normalized URI. This effectively
+    // places this host on the tracking protection allowlist.
+    if (PrivateBrowsingUtils.isBrowserPrivate(gBrowser.selectedBrowser)) {
+      PrivateBrowsingUtils.addToTrackingAllowlist(normalizedUrl);
+    } else {
+      Services.perms.add(normalizedUrl,
+        "trackingprotection", Services.perms.ALLOW_ACTION);
+    }
+
+    // Telemetry for disable protection.
+    this.eventsHistogramAdd(1);
+
+    // Hide the control center.
+    document.getElementById("identity-popup").hidePopup();
+
+    BrowserReload();
+  },
+
+  enableForCurrentPage() {
+    // Remove the current host from the 'trackingprotection' consumer
+    // of the permission manager. This effectively removes this host
+    // from the tracking protection allowlist.
+    let normalizedUrl = Services.io.newURI(
+      "https://" + gBrowser.selectedBrowser.currentURI.hostPort);
+
+    if (PrivateBrowsingUtils.isBrowserPrivate(gBrowser.selectedBrowser)) {
+      PrivateBrowsingUtils.removeFromTrackingAllowlist(normalizedUrl);
+    } else {
+      Services.perms.remove(normalizedUrl, "trackingprotection");
+    }
+
+    // Telemetry for enable protection.
+    this.eventsHistogramAdd(2);
+
+    // Hide the control center.
+    document.getElementById("identity-popup").hidePopup();
+
+    BrowserReload();
+  },
+
+  dontShowIntroPanelAgain() {
+    // This function may be called in private windows, but it does not change
+    // any preference unless Tracking Protection is enabled globally.
+    if (this.enabledGlobally) {
+      Services.prefs.setIntPref("privacy.trackingprotection.introCount",
+                                this.MAX_INTROS);
+      Services.prefs.savePrefFile(null);
+    }
+  },
+
+  async showIntroPanel() {
+    let brandBundle = document.getElementById("bundle_brand");
+    let brandShortName = brandBundle.getString("brandShortName");
+
+    let openStep2 = () => {
+      // When the user proceeds in the tour, adjust the counter to indicate that
+      // the user doesn't need to see the intro anymore.
+      this.dontShowIntroPanelAgain();
+
+      let nextURL = Services.urlFormatter.formatURLPref("privacy.trackingprotection.introURL") +
+                    "?step=2&newtab=true";
+      switchToTabHavingURI(nextURL, true, {
+        // Ignore the fragment in case the intro is shown on the tour page
+        // (e.g. if the user manually visited the tour or clicked the link from
+        // about:privatebrowsing) so we can avoid a reload.
+        ignoreFragment: "whenComparingAndReplace",
+        triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+      });
+    };
+
+    let buttons = [
+      {
+        label: gNavigatorBundle.getString("trackingProtection.intro.step1of3"),
+        style: "text",
+      },
+      {
+        callback: openStep2,
+        label: gNavigatorBundle.getString("trackingProtection.intro.nextButton.label"),
+        style: "primary",
+      },
+    ];
+
+    let panelTarget = await UITour.getTarget(window, "trackingProtection");
+    UITour.initForBrowser(gBrowser.selectedBrowser, window);
+    UITour.showInfo(window, panelTarget,
+                    gNavigatorBundle.getString("trackingProtection.intro.title"),
+                    gNavigatorBundle.getFormattedString("trackingProtection.intro.description2",
+                                                        [brandShortName]),
+                    undefined, buttons,
+                    { closeButtonCallback: () => this.dontShowIntroPanelAgain() });
+  },
+};
+
+
+/***/ })
+/******/ ]);
\ No newline at end of file
diff --git a/browser/base/content/browser-fullScreenAndPointerLock.js.orig b/browser/base/content/browser-fullScreenAndPointerLock.js.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser-fullScreenAndPointerLock.js.orig
@@ -0,0 +1,676 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This file is loaded into the browser window scope.
+/* eslint-env mozilla/browser-window */
+
+var PointerlockFsWarning = {
+
+  _element: null,
+  _origin: null,
+
+  /**
+   * Timeout object for managing timeout request. If it is started when
+   * the previous call hasn't finished, it would automatically cancelled
+   * the previous one.
+   */
+  Timeout: class {
+    constructor(func, delay) {
+      this._id = 0;
+      this._func = func;
+      this._delay = delay;
+    }
+    start() {
+      this.cancel();
+      this._id = setTimeout(() => this._handle(), this._delay);
+    }
+    cancel() {
+      if (this._id) {
+        clearTimeout(this._id);
+        this._id = 0;
+      }
+    }
+    _handle() {
+      this._id = 0;
+      this._func();
+    }
+    get delay() {
+      return this._delay;
+    }
+  },
+
+  showPointerLock(aOrigin) {
+    if (!document.fullscreen) {
+      let timeout = gPrefService.getIntPref("pointer-lock-api.warning.timeout");
+      this.show(aOrigin, "pointerlock-warning", timeout, 0);
+    }
+  },
+
+  showFullScreen(aOrigin) {
+    let timeout = gPrefService.getIntPref("full-screen-api.warning.timeout");
+    let delay = gPrefService.getIntPref("full-screen-api.warning.delay");
+    this.show(aOrigin, "fullscreen-warning", timeout, delay);
+  },
+
+  // Shows a warning that the site has entered fullscreen or
+  // pointer lock for a short duration.
+  show(aOrigin, elementId, timeout, delay) {
+
+    if (!this._element) {
+      this._element = document.getElementById(elementId);
+      // Setup event listeners
+      this._element.addEventListener("transitionend", this);
+      window.addEventListener("mousemove", this, true);
+      // The timeout to hide the warning box after a while.
+      this._timeoutHide = new this.Timeout(() => {
+        this._state = "hidden";
+      }, timeout);
+      // The timeout to show the warning box when the pointer is at the top
+      this._timeoutShow = new this.Timeout(() => {
+        this._state = "ontop";
+        this._timeoutHide.start();
+      }, delay);
+    }
+
+    // Set the strings on the warning UI.
+    if (aOrigin) {
+      this._origin = aOrigin;
+    }
+    let uri = Services.io.newURI(this._origin);
+    let host = null;
+    try {
+      host = uri.host;
+    } catch (e) { }
+    let textElem = this._element.querySelector(".pointerlockfswarning-domain-text");
+    if (!host) {
+      textElem.setAttribute("hidden", true);
+    } else {
+      textElem.removeAttribute("hidden");
+      let hostElem = this._element.querySelector(".pointerlockfswarning-domain");
+      // Document's principal's URI has a host. Display a warning including it.
+      let utils = {};
+      Cu.import("resource://gre/modules/DownloadUtils.jsm", utils);
+      hostElem.textContent = utils.DownloadUtils.getURIHost(uri.spec)[0];
+    }
+
+    this._element.dataset.identity =
+      gIdentityHandler.pointerlockFsWarningClassName;
+
+    // User should be allowed to explicitly disable
+    // the prompt if they really want.
+    if (this._timeoutHide.delay <= 0) {
+      return;
+    }
+
+    // Explicitly set the last state to hidden to avoid the warning
+    // box being hidden immediately because of mousemove.
+    this._state = "onscreen";
+    this._lastState = "hidden";
+    this._timeoutHide.start();
+  },
+
+  close() {
+    if (!this._element) {
+      return;
+    }
+    // Cancel any pending timeout
+    this._timeoutHide.cancel();
+    this._timeoutShow.cancel();
+    // Reset state of the warning box
+    this._state = "hidden";
+    this._element.setAttribute("hidden", true);
+    // Remove all event listeners
+    this._element.removeEventListener("transitionend", this);
+    window.removeEventListener("mousemove", this, true);
+    // Clear fields
+    this._element = null;
+    this._timeoutHide = null;
+    this._timeoutShow = null;
+
+    // Ensure focus switches away from the (now hidden) warning box.
+    // If the user clicked buttons in the warning box, it would have
+    // been focused, and any key events would be directed at the (now
+    // hidden) chrome document instead of the target document.
+    gBrowser.selectedBrowser.focus();
+  },
+
+  // State could be one of "onscreen", "ontop", "hiding", and
+  // "hidden". Setting the state to "onscreen" and "ontop" takes
+  // effect immediately, while setting it to "hidden" actually
+  // turns the state to "hiding" before the transition finishes.
+  _lastState: null,
+  _STATES: ["hidden", "ontop", "onscreen"],
+  get _state() {
+    for (let state of this._STATES) {
+      if (this._element.hasAttribute(state)) {
+        return state;
+      }
+    }
+    return "hiding";
+  },
+  set _state(newState) {
+    let currentState = this._state;
+    if (currentState == newState) {
+      return;
+    }
+    if (currentState != "hiding") {
+      this._lastState = currentState;
+      this._element.removeAttribute(currentState);
+    }
+    if (newState != "hidden") {
+      if (currentState != "hidden") {
+        this._element.setAttribute(newState, true);
+      } else {
+        // When the previous state is hidden, the display was none,
+        // thus no box was constructed. We need to wait for the new
+        // display value taking effect first, otherwise, there won't
+        // be any transition. Since requestAnimationFrame callback is
+        // generally triggered before any style flush and layout, we
+        // should wait for the second animation frame.
+        requestAnimationFrame(() => {
+          requestAnimationFrame(() => {
+            if (this._element) {
+              this._element.setAttribute(newState, true);
+            }
+          });
+        });
+      }
+    }
+  },
+
+  handleEvent(event) {
+    console.log("handleEvent")
+    switch (event.type) {
+    case "mousemove": {
+      let state = this._state;
+      if (state == "hidden") {
+        // If the warning box is currently hidden, show it after
+        // a short delay if the pointer is at the top.
+        if (event.clientY != 0) {
+          this._timeoutShow.cancel();
+        } else if (this._timeoutShow.delay >= 0) {
+          this._timeoutShow.start();
+        }
+      } else {
+        let elemRect = this._element.getBoundingClientRect();
+        if (state == "hiding" && this._lastState != "hidden") {
+          // If we are on the hiding transition, and the pointer
+          // moved near the box, restore to the previous state.
+          if (event.clientY <= elemRect.bottom + 50) {
+            this._state = this._lastState;
+            this._timeoutHide.start();
+          }
+        } else if (state == "ontop" || this._lastState != "hidden") {
+          // State being "ontop" or the previous state not being
+          // "hidden" indicates this current warning box is shown
+          // in response to user's action. Hide it immediately when
+          // the pointer leaves that area.
+          if (event.clientY > elemRect.bottom + 50) {
+            this._state = "hidden";
+            this._timeoutHide.cancel();
+          }
+        }
+      }
+      break;
+    }
+    case "transitionend": {
+      if (this._state == "hiding") {
+        this._element.setAttribute("hidden", true);
+      }
+      break;
+    }
+    }
+  }
+};
+
+var PointerLock = {
+
+  init() {
+    window.messageManager.addMessageListener("PointerLock:Entered", this);
+    window.messageManager.addMessageListener("PointerLock:Exited", this);
+  },
+
+  receiveMessage(aMessage) {
+    switch (aMessage.name) {
+      case "PointerLock:Entered": {
+        PointerlockFsWarning.showPointerLock(aMessage.data.originNoSuffix);
+        break;
+      }
+      case "PointerLock:Exited": {
+        PointerlockFsWarning.close();
+        break;
+      }
+    }
+  }
+};
+
+var FullScreen = {
+  _MESSAGES: [
+    "DOMFullscreen:Request",
+    "DOMFullscreen:NewOrigin",
+    "DOMFullscreen:Exit",
+    "DOMFullscreen:Painted",
+  ],
+
+  init() {
+    // called when we go into full screen, even if initiated by a web page script
+    window.addEventListener("fullscreen", this, true);
+    window.addEventListener("MozDOMFullscreen:Entered", this,
+                            /* useCapture */ true,
+                            /* wantsUntrusted */ false);
+    window.addEventListener("MozDOMFullscreen:Exited", this,
+                            /* useCapture */ true,
+                            /* wantsUntrusted */ false);
+    for (let type of this._MESSAGES) {
+      window.messageManager.addMessageListener(type, this);
+    }
+
+    if (window.fullScreen)
+      this.toggle();
+  },
+
+  uninit() {
+    for (let type of this._MESSAGES) {
+      window.messageManager.removeMessageListener(type, this);
+    }
+    this.cleanup();
+  },
+
+  toggle() {
+    var enterFS = window.fullScreen;
+
+    // Toggle the View:FullScreen command, which controls elements like the
+    // fullscreen menuitem, and menubars.
+    let fullscreenCommand = document.getElementById("View:FullScreen");
+    if (enterFS) {
+      fullscreenCommand.setAttribute("checked", enterFS);
+    } else {
+      fullscreenCommand.removeAttribute("checked");
+    }
+
+    if (AppConstants.platform == "macosx") {
+      // Make sure the menu items are adjusted.
+      document.getElementById("enterFullScreenItem").hidden = enterFS;
+      document.getElementById("exitFullScreenItem").hidden = !enterFS;
+    }
+
+    if (!this._fullScrToggler) {
+      this._fullScrToggler = document.getElementById("fullscr-toggler");
+      this._fullScrToggler.addEventListener("mouseover", this._expandCallback);
+      this._fullScrToggler.addEventListener("dragenter", this._expandCallback);
+      this._fullScrToggler.addEventListener("touchmove", this._expandCallback, {passive: true});
+    }
+
+    if (enterFS) {
+      gNavToolbox.setAttribute("inFullscreen", true);
+      document.documentElement.setAttribute("inFullscreen", true);
+      if (!document.fullscreenElement && this.useLionFullScreen)
+        document.documentElement.setAttribute("OSXLionFullscreen", true);
+    } else {
+      gNavToolbox.removeAttribute("inFullscreen");
+      document.documentElement.removeAttribute("inFullscreen");
+      document.documentElement.removeAttribute("OSXLionFullscreen");
+    }
+
+    if (!document.fullscreenElement)
+      this._updateToolbars(enterFS);
+
+    if (enterFS) {
+      document.addEventListener("keypress", this._keyToggleCallback);
+      document.addEventListener("popupshown", this._setPopupOpen);
+      document.addEventListener("popuphidden", this._setPopupOpen);
+      // In DOM fullscreen mode, we hide toolbars with CSS
+      if (!document.fullscreenElement)
+        this.hideNavToolbox(true);
+    } else {
+      this.showNavToolbox(false);
+      // This is needed if they use the context menu to quit fullscreen
+      this._isPopupOpen = false;
+      this.cleanup();
+      // In TabsInTitlebar._update(), we cancel the appearance update on
+      // resize event for exiting fullscreen, since that happens before we
+      // change the UI here in the "fullscreen" event. Hence we need to
+      // call it here to ensure the appearance is properly updated. See
+      // TabsInTitlebar._update() and bug 1173768.
+      TabsInTitlebar.updateAppearance(true);
+    }
+
+    if (enterFS && !document.fullscreenElement) {
+      Services.telemetry.getHistogramById("FX_BROWSER_FULLSCREEN_USED")
+                        .add(1);
+    }
+  },
+
+  exitDomFullScreen() {
+    document.exitFullscreen();
+  },
+
+  handleEvent(event) {
+    console.log("Handle event", event.type);
+    switch (event.type) {
+      case "fullscreen":
+        this.toggle();
+        break;
+      case "MozDOMFullscreen:Entered": {
+        // The event target is the element which requested the DOM
+        // fullscreen. If we were entering DOM fullscreen for a remote
+        // browser, the target would be `gBrowser` and the original
+        // target would be the browser which was the parameter of
+        // `remoteFrameFullscreenChanged` call. If the fullscreen
+        // request was initiated from an in-process browser, we need
+        // to get its corresponding browser here.
+        let browser;
+        console.log(event.target, event.originalTarget);
+        if (event.target == gBrowser) {
+          browser = event.originalTarget;
+        } else {
+          let topWin = event.target.ownerGlobal.top;
+          browser = gBrowser.getBrowserForContentWindow(topWin);
+        }
+        TelemetryStopwatch.start("FULLSCREEN_CHANGE_MS");
+        this.enterDomFullscreen(browser);
+        break;
+      }
+      case "MozDOMFullscreen:Exited":
+        TelemetryStopwatch.start("FULLSCREEN_CHANGE_MS");
+        this.cleanupDomFullscreen();
+        break;
+    }
+  },
+
+  receiveMessage(aMessage) {
+    let browser = aMessage.target;
+    switch (aMessage.name) {
+      case "DOMFullscreen:Request": {
+        this._windowUtils.remoteFrameFullscreenChanged(browser);
+        break;
+      }
+      case "DOMFullscreen:NewOrigin": {
+        // Don't show the warning if we've already exited fullscreen.
+        if (document.fullscreen) {
+          PointerlockFsWarning.showFullScreen(aMessage.data.originNoSuffix);
+        }
+        break;
+      }
+      case "DOMFullscreen:Exit": {
+        this._windowUtils.remoteFrameFullscreenReverted();
+        break;
+      }
+      case "DOMFullscreen:Painted": {
+        Services.obs.notifyObservers(window, "fullscreen-painted");
+        TelemetryStopwatch.finish("FULLSCREEN_CHANGE_MS");
+        break;
+      }
+    }
+  },
+
+  enterDomFullscreen(aBrowser) {
+
+    if (!document.fullscreenElement) {
+      return;
+    }
+
+    // If we have a current pointerlock warning shown then hide it
+    // before transition.
+    PointerlockFsWarning.close();
+
+    // If it is a remote browser, send a message to ask the content
+    // to enter fullscreen state. We don't need to do so if it is an
+    // in-process browser, since all related document should have
+    // entered fullscreen state at this point.
+    // This should be done before the active tab check below to ensure
+    // that the content document handles the pending request. Doing so
+    // before the check is fine since we also check the activeness of
+    // the requesting document in content-side handling code.
+    if (this._isRemoteBrowser(aBrowser)) {
+      aBrowser.messageManager.sendAsyncMessage("DOMFullscreen:Entered");
+    }
+
+    // If we've received a fullscreen notification, we have to ensure that the
+    // element that's requesting fullscreen belongs to the browser that's currently
+    // active. If not, we exit fullscreen since the "full-screen document" isn't
+    // actually visible now.
+    if (!aBrowser || gBrowser.selectedBrowser != aBrowser ||
+        // The top-level window has lost focus since the request to enter
+        // full-screen was made. Cancel full-screen.
+        Services.focus.activeWindow != window) {
+      // This function is called synchronously in fullscreen change, so
+      // we have to avoid calling exitFullscreen synchronously here.
+      setTimeout(() => document.exitFullscreen(), 0);
+      return;
+    }
+
+    document.documentElement.setAttribute("inDOMFullscreen", true);
+
+    if (gFindBarInitialized) {
+      gFindBar.close(true);
+    }
+
+    // Exit DOM full-screen mode upon open, close, or change tab.
+    gBrowser.tabContainer.addEventListener("TabOpen", this.exitDomFullScreen);
+    gBrowser.tabContainer.addEventListener("TabClose", this.exitDomFullScreen);
+    gBrowser.tabContainer.addEventListener("TabSelect", this.exitDomFullScreen);
+
+    // Add listener to detect when the fullscreen window is re-focused.
+    // If a fullscreen window loses focus, we show a warning when the
+    // fullscreen window is refocused.
+    window.addEventListener("activate", this);
+  },
+
+  cleanup() {
+    if (!window.fullScreen) {
+      MousePosTracker.removeListener(this);
+      document.removeEventListener("keypress", this._keyToggleCallback);
+      document.removeEventListener("popupshown", this._setPopupOpen);
+      document.removeEventListener("popuphidden", this._setPopupOpen);
+    }
+  },
+
+  cleanupDomFullscreen() {
+    window.messageManager
+          .broadcastAsyncMessage("DOMFullscreen:CleanUp");
+
+    PointerlockFsWarning.close();
+    gBrowser.tabContainer.removeEventListener("TabOpen", this.exitDomFullScreen);
+    gBrowser.tabContainer.removeEventListener("TabClose", this.exitDomFullScreen);
+    gBrowser.tabContainer.removeEventListener("TabSelect", this.exitDomFullScreen);
+    window.removeEventListener("activate", this);
+
+    document.documentElement.removeAttribute("inDOMFullscreen");
+  },
+
+  _isRemoteBrowser(aBrowser) {
+    return gMultiProcessBrowser && aBrowser.getAttribute("remote") == "true";
+  },
+
+  get _windowUtils() {
+    return window.QueryInterface(Ci.nsIInterfaceRequestor)
+                 .getInterface(Ci.nsIDOMWindowUtils);
+  },
+
+  getMouseTargetRect() {
+    return this._mouseTargetRect;
+  },
+
+  // Event callbacks
+  _expandCallback() {
+    FullScreen.showNavToolbox();
+  },
+  onMouseEnter() {
+    FullScreen.hideNavToolbox();
+  },
+  _keyToggleCallback(aEvent) {
+    // if we can use the keyboard (eg Ctrl+L or Ctrl+E) to open the toolbars, we
+    // should provide a way to collapse them too.
+    if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE) {
+      FullScreen.hideNavToolbox();
+    } else if (aEvent.keyCode == aEvent.DOM_VK_F6) {
+      // F6 is another shortcut to the address bar, but its not covered in OpenLocation()
+      FullScreen.showNavToolbox();
+    }
+  },
+
+  // Checks whether we are allowed to collapse the chrome
+  _isPopupOpen: false,
+  _isChromeCollapsed: false,
+  _safeToCollapse() {
+    if (!gPrefService.getBoolPref("browser.fullscreen.autohide"))
+      return false;
+
+    // a popup menu is open in chrome: don't collapse chrome
+    if (this._isPopupOpen)
+      return false;
+
+    // On OS X Lion we don't want to hide toolbars.
+    if (this.useLionFullScreen)
+      return false;
+
+    // a textbox in chrome is focused (location bar anyone?): don't collapse chrome
+    if (document.commandDispatcher.focusedElement &&
+        document.commandDispatcher.focusedElement.ownerDocument == document &&
+        document.commandDispatcher.focusedElement.localName == "input") {
+      return false;
+    }
+
+    return true;
+  },
+
+  _setPopupOpen(aEvent) {
+    // Popups should only veto chrome collapsing if they were opened when the chrome was not collapsed.
+    // Otherwise, they would not affect chrome and the user would expect the chrome to go away.
+    // e.g. we wouldn't want the autoscroll icon firing this event, so when the user
+    // toggles chrome when moving mouse to the top, it doesn't go away again.
+    if (aEvent.type == "popupshown" && !FullScreen._isChromeCollapsed &&
+        aEvent.target.localName != "tooltip" && aEvent.target.localName != "window" &&
+        aEvent.target.getAttribute("nopreventnavboxhide") != "true")
+      FullScreen._isPopupOpen = true;
+    else if (aEvent.type == "popuphidden" && aEvent.target.localName != "tooltip" &&
+             aEvent.target.localName != "window") {
+      FullScreen._isPopupOpen = false;
+      // Try again to hide toolbar when we close the popup.
+      FullScreen.hideNavToolbox(true);
+    }
+  },
+
+  get navToolboxHidden() {
+    return this._isChromeCollapsed;
+  },
+
+  // Autohide helpers for the context menu item
+  getAutohide(aItem) {
+    aItem.setAttribute("checked", gPrefService.getBoolPref("browser.fullscreen.autohide"));
+  },
+  setAutohide() {
+    gPrefService.setBoolPref("browser.fullscreen.autohide", !gPrefService.getBoolPref("browser.fullscreen.autohide"));
+    // Try again to hide toolbar when we change the pref.
+    FullScreen.hideNavToolbox(true);
+  },
+
+  showNavToolbox(trackMouse = true) {
+    this._fullScrToggler.hidden = true;
+    gNavToolbox.removeAttribute("fullscreenShouldAnimate");
+    gNavToolbox.style.marginTop = "";
+
+    if (!this._isChromeCollapsed) {
+      return;
+    }
+
+    // Track whether mouse is near the toolbox
+    if (trackMouse && !this.useLionFullScreen) {
+      let rect = gBrowser.mPanelContainer.getBoundingClientRect();
+      this._mouseTargetRect = {
+        top: rect.top + 50,
+        bottom: rect.bottom,
+        left: rect.left,
+        right: rect.right
+      };
+      MousePosTracker.addListener(this);
+    }
+
+    this._isChromeCollapsed = false;
+    Services.obs.notifyObservers(null, "fullscreen-nav-toolbox", "shown");
+  },
+
+  hideNavToolbox(aAnimate = false) {
+    if (this._isChromeCollapsed || !this._safeToCollapse())
+      return;
+
+    this._fullScrToggler.hidden = false;
+
+    if (aAnimate && gPrefService.getBoolPref("toolkit.cosmeticAnimations.enabled")) {
+      gNavToolbox.setAttribute("fullscreenShouldAnimate", true);
+      // Hide the fullscreen toggler until the transition ends.
+      let listener = () => {
+        gNavToolbox.removeEventListener("transitionend", listener, true);
+        if (this._isChromeCollapsed)
+          this._fullScrToggler.hidden = false;
+      };
+      gNavToolbox.addEventListener("transitionend", listener, true);
+      this._fullScrToggler.hidden = true;
+    }
+
+    gNavToolbox.style.marginTop =
+      -gNavToolbox.getBoundingClientRect().height + "px";
+    this._isChromeCollapsed = true;
+    Services.obs.notifyObservers(null, "fullscreen-nav-toolbox", "hidden");
+
+    MousePosTracker.removeListener(this);
+  },
+
+  _updateToolbars(aEnterFS) {
+    for (let el of document.querySelectorAll("toolbar[fullscreentoolbar=true]")) {
+      if (aEnterFS) {
+        // Give the main nav bar and the tab bar the fullscreen context menu,
+        // otherwise remove context menu to prevent breakage
+        el.setAttribute("saved-context", el.getAttribute("context"));
+        if (el.id == "nav-bar" || el.id == "TabsToolbar")
+          el.setAttribute("context", "autohide-context");
+        else
+          el.removeAttribute("context");
+
+        // Set the inFullscreen attribute to allow specific styling
+        // in fullscreen mode
+        el.setAttribute("inFullscreen", true);
+      } else {
+        if (el.hasAttribute("saved-context")) {
+          el.setAttribute("context", el.getAttribute("saved-context"));
+          el.removeAttribute("saved-context");
+        }
+        el.removeAttribute("inFullscreen");
+      }
+    }
+
+    ToolbarIconColor.inferFromText("fullscreen", aEnterFS);
+
+
+    // For Lion fullscreen, all fullscreen controls are hidden, don't
+    // bother to touch them. If we don't stop here, the following code
+    // could cause the native fullscreen button be shown unexpectedly.
+    // See bug 1165570.
+    if (this.useLionFullScreen) {
+      return;
+    }
+
+    var fullscreenctls = document.getElementById("window-controls");
+    var navbar = document.getElementById("nav-bar");
+    var ctlsOnTabbar = window.toolbar.visible;
+    if (fullscreenctls.parentNode == navbar && ctlsOnTabbar) {
+      fullscreenctls.removeAttribute("flex");
+      document.getElementById("TabsToolbar").appendChild(fullscreenctls);
+    } else if (fullscreenctls.parentNode.id == "TabsToolbar" && !ctlsOnTabbar) {
+      fullscreenctls.setAttribute("flex", "1");
+      navbar.appendChild(fullscreenctls);
+    }
+    fullscreenctls.hidden = !aEnterFS;
+  }
+};
+XPCOMUtils.defineLazyGetter(FullScreen, "useLionFullScreen", function() {
+  // We'll only use OS X Lion full screen if we're
+  // * on OS X
+  // * on Lion or higher (Darwin 11+)
+  // * have fullscreenbutton="true"
+  return AppConstants.isPlatformAndVersionAtLeast("macosx", 11) &&
+         document.documentElement.getAttribute("fullscreenbutton") == "true";
+});
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1,30 +1,25 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* eslint-env mozilla/browser-window */
 
-var Ci = Components.interfaces;
-var Cu = Components.utils;
-var Cc = Components.classes;
-var Cr = Components.results;
-
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/AppConstants.jsm");
 Cu.import("resource://gre/modules/NotificationDB.jsm");
 
 const {WebExtensionPolicy} = Cu.getGlobalForObject(Services);
 
 // lazy module getters
 
-XPCOMUtils.defineLazyModuleGetters(this, {
+XPCOMUtils.defineLazyModuleGetters(window, {
   AboutHome: "resource:///modules/AboutHome.jsm",
   BrowserUITelemetry: "resource:///modules/BrowserUITelemetry.jsm",
   BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
   BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   CharsetMenu: "resource://gre/modules/CharsetMenu.jsm",
   Color: "resource://gre/modules/Color.jsm",
   ContentSearch: "resource:///modules/ContentSearch.jsm",
   ContextualIdentityService: "resource://gre/modules/ContextualIdentityService.jsm",
@@ -67,106 +62,106 @@ XPCOMUtils.defineLazyModuleGetters(this,
   ZoomUI: "resource:///modules/ZoomUI.jsm",
 });
 
 if (AppConstants.MOZ_CRASHREPORTER) {
   XPCOMUtils.defineLazyModuleGetter(this, "PluginCrashReporter",
     "resource:///modules/ContentCrashHandlers.jsm");
 }
 
-XPCOMUtils.defineLazyScriptGetter(this, "PrintUtils",
+XPCOMUtils.defineLazyScriptGetter(window, "PrintUtils",
                                   "chrome://global/content/printUtils.js");
-XPCOMUtils.defineLazyScriptGetter(this, "ZoomManager",
+XPCOMUtils.defineLazyScriptGetter(window, "ZoomManager",
                                   "chrome://global/content/viewZoomOverlay.js");
-XPCOMUtils.defineLazyScriptGetter(this, "FullZoom",
+XPCOMUtils.defineLazyScriptGetter(window, "FullZoom",
                                   "chrome://browser/content/browser-fullZoom.js");
-XPCOMUtils.defineLazyScriptGetter(this, "PanelUI",
+XPCOMUtils.defineLazyScriptGetter(window, "PanelUI",
                                   "chrome://browser/content/customizableui/panelUI.js");
-XPCOMUtils.defineLazyScriptGetter(this, "gViewSourceUtils",
+XPCOMUtils.defineLazyScriptGetter(window, "gViewSourceUtils",
                                   "chrome://global/content/viewSourceUtils.js");
-XPCOMUtils.defineLazyScriptGetter(this, ["LightWeightThemeWebInstaller",
+XPCOMUtils.defineLazyScriptGetter(window, ["LightWeightThemeWebInstaller",
                                          "gExtensionsNotifications",
                                          "gXPInstallObserver"],
                                   "chrome://browser/content/browser-addons.js");
-XPCOMUtils.defineLazyScriptGetter(this, "ctrlTab",
+XPCOMUtils.defineLazyScriptGetter(window, "ctrlTab",
                                   "chrome://browser/content/browser-ctrlTab.js");
-XPCOMUtils.defineLazyScriptGetter(this, "CustomizationHandler",
+XPCOMUtils.defineLazyScriptGetter(window, "CustomizationHandler",
                                   "chrome://browser/content/browser-customization.js");
-XPCOMUtils.defineLazyScriptGetter(this, ["PointerLock", "FullScreen"],
+XPCOMUtils.defineLazyScriptGetter(window, ["PointerLock", "FullScreen"],
                                   "chrome://browser/content/browser-fullScreenAndPointerLock.js");
-XPCOMUtils.defineLazyScriptGetter(this, ["gGestureSupport", "gHistorySwipeAnimation"],
+XPCOMUtils.defineLazyScriptGetter(window, ["gGestureSupport", "gHistorySwipeAnimation"],
                                   "chrome://browser/content/browser-gestureSupport.js");
-XPCOMUtils.defineLazyScriptGetter(this, "gSafeBrowsing",
+XPCOMUtils.defineLazyScriptGetter(window, "gSafeBrowsing",
                                   "chrome://browser/content/browser-safebrowsing.js");
-XPCOMUtils.defineLazyScriptGetter(this, "gSync",
+XPCOMUtils.defineLazyScriptGetter(window, "gSync",
                                   "chrome://browser/content/browser-sync.js");
-XPCOMUtils.defineLazyScriptGetter(this, "gBrowserThumbnails",
+XPCOMUtils.defineLazyScriptGetter(window, "gBrowserThumbnails",
                                   "chrome://browser/content/browser-thumbnails.js");
-XPCOMUtils.defineLazyScriptGetter(this, ["setContextMenuContentData",
+XPCOMUtils.defineLazyScriptGetter(window, ["setContextMenuContentData",
                                          "openContextMenu", "nsContextMenu"],
                                   "chrome://browser/content/nsContextMenu.js");
-XPCOMUtils.defineLazyScriptGetter(this, ["DownloadsPanel",
+XPCOMUtils.defineLazyScriptGetter(window, ["DownloadsPanel",
                                          "DownloadsOverlayLoader",
                                          "DownloadsSubview",
                                          "DownloadsView", "DownloadsViewUI",
                                          "DownloadsViewController",
                                          "DownloadsSummary", "DownloadsFooter",
                                          "DownloadsBlockedSubview"],
                                   "chrome://browser/content/downloads/downloads.js");
-XPCOMUtils.defineLazyScriptGetter(this, ["DownloadsButton",
+XPCOMUtils.defineLazyScriptGetter(window, ["DownloadsButton",
                                          "DownloadsIndicatorView"],
                                   "chrome://browser/content/downloads/indicator.js");
-XPCOMUtils.defineLazyScriptGetter(this, "gEditItemOverlay",
+XPCOMUtils.defineLazyScriptGetter(window, "gEditItemOverlay",
                                   "chrome://browser/content/places/editBookmarkOverlay.js");
 
 
 // lazy service getters
 
-XPCOMUtils.defineLazyServiceGetters(this, {
+XPCOMUtils.defineLazyServiceGetters(window, {
   Favicons: ["@mozilla.org/browser/favicon-service;1", "mozIAsyncFavicons"],
   gAboutNewTabService: ["@mozilla.org/browser/aboutnewtab-service;1", "nsIAboutNewTabService"],
   gDNSService: ["@mozilla.org/network/dns-service;1", "nsIDNSService"],
   gSerializationHelper: ["@mozilla.org/network/serialization-helper;1", "nsISerializationHelper"],
   Marionette: ["@mozilla.org/remote/marionette;1", "nsIMarionette"],
   SessionStartup: ["@mozilla.org/browser/sessionstartup;1", "nsISessionStartup"],
   WindowsUIUtils: ["@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils"],
 });
 
 if (AppConstants.MOZ_CRASHREPORTER) {
-  XPCOMUtils.defineLazyServiceGetter(this, "gCrashReporter",
+  XPCOMUtils.defineLazyServiceGetter(window, "gCrashReporter",
                                      "@mozilla.org/xre/app-info;1",
                                      "nsICrashReporter");
 }
 
-XPCOMUtils.defineLazyGetter(this, "gBrowserBundle", function() {
+XPCOMUtils.defineLazyGetter(window, "gBrowserBundle", function() {
   return Services.strings.createBundle("chrome://browser/locale/browser.properties");
 });
-XPCOMUtils.defineLazyGetter(this, "gTabBrowserBundle", function() {
+XPCOMUtils.defineLazyGetter(window, "gTabBrowserBundle", function() {
   return Services.strings.createBundle("chrome://browser/locale/tabbrowser.properties");
 });
 
-XPCOMUtils.defineLazyGetter(this, "gCustomizeMode", function() {
+XPCOMUtils.defineLazyGetter(window, "gCustomizeMode", function() {
   let scope = {};
   Cu.import("resource:///modules/CustomizeMode.jsm", scope);
   return new scope.CustomizeMode(window);
 });
 
-XPCOMUtils.defineLazyGetter(this, "InlineSpellCheckerUI", function() {
+XPCOMUtils.defineLazyGetter(window, "InlineSpellCheckerUI", function() {
   let tmp = {};
   Cu.import("resource://gre/modules/InlineSpellChecker.jsm", tmp);
   return new tmp.InlineSpellChecker();
 });
 
-XPCOMUtils.defineLazyGetter(this, "PageMenuParent", function() {
+XPCOMUtils.defineLazyGetter(window, "PageMenuParent", function() {
   let tmp = {};
   Cu.import("resource://gre/modules/PageMenu.jsm", tmp);
   return new tmp.PageMenuParent();
 });
 
-XPCOMUtils.defineLazyGetter(this, "PopupNotifications", function() {
+XPCOMUtils.defineLazyGetter(window, "PopupNotifications", function() {
   let tmp = {};
   Cu.import("resource://gre/modules/PopupNotifications.jsm", tmp);
   try {
     // Hide all notifications while the URL is being edited and the address bar
     // has focus, including the virtual focus in the results popup.
     // We also have to hide notifications explicitly when the window is
     // minimized because of the effects of the "noautohide" attribute on Linux.
     // This can be removed once bug 545265 and bug 1320361 are fixed.
@@ -180,17 +175,17 @@ XPCOMUtils.defineLazyGetter(this, "Popup
                                       document.getElementById("notification-popup-box"),
                                       { shouldSuppress });
   } catch (ex) {
     Cu.reportError(ex);
     return null;
   }
 });
 
-XPCOMUtils.defineLazyGetter(this, "Win7Features", function() {
+XPCOMUtils.defineLazyGetter(window, "Win7Features", function() {
   if (AppConstants.platform != "win")
     return null;
 
   const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
   if (WINTASKBAR_CONTRACTID in Cc &&
       Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar).available) {
     let AeroPeek = Cu.import("resource:///modules/WindowsPreviewPerTab.jsm", {}).AeroPeek;
     return {
diff --git a/browser/base/content/browser.xul.orig b/browser/base/content/browser.xul.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser.xul.orig
@@ -0,0 +1,1249 @@
+#filter substitution
+<?xml version="1.0"?>
+# -*- Mode: HTML -*-
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+<?xml-stylesheet href="chrome://browser/content/browser.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/places/places.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/usercontext/usercontext.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/controlcenter/panel.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/customizableui/panelUI.css" type="text/css"?>
+<?xml-stylesheet href="chrome://global/skin/popup.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/" type="text/css"?>
+
+<?xul-overlay href="chrome://global/content/editMenuOverlay.xul"?>
+<?xul-overlay href="chrome://browser/content/baseMenuOverlay.xul"?>
+<?xul-overlay href="chrome://browser/content/places/placesOverlay.xul"?>
+
+# All DTD information is stored in a separate file so that it can be shared by
+# hiddenWindow.xul.
+#include browser-doctype.inc
+
+<window id="main-window"
+        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+        xmlns:svg="http://www.w3.org/2000/svg"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        onload="gBrowserInit.onLoad()" onunload="gBrowserInit.onUnload()" onclose="return WindowIsClosing();"
+        title="&mainWindow.title;"
+        title_normal="&mainWindow.title;"
+#ifdef XP_MACOSX
+        title_privatebrowsing="&mainWindow.title;&mainWindow.titlemodifiermenuseparator;&mainWindow.titlePrivateBrowsingSuffix;"
+        titledefault="&mainWindow.title;"
+        titlemodifier=""
+        titlemodifier_normal=""
+        titlemodifier_privatebrowsing="&mainWindow.titlePrivateBrowsingSuffix;"
+#else
+        title_privatebrowsing="&mainWindow.titlemodifier; &mainWindow.titlePrivateBrowsingSuffix;"
+        titlemodifier="&mainWindow.titlemodifier;"
+        titlemodifier_normal="&mainWindow.titlemodifier;"
+        titlemodifier_privatebrowsing="&mainWindow.titlemodifier; &mainWindow.titlePrivateBrowsingSuffix;"
+#endif
+#ifdef CAN_DRAW_IN_TITLEBAR
+#ifdef XP_WIN
+        chromemargin="0,2,2,2"
+#else
+        chromemargin="0,-1,-1,-1"
+#endif
+        tabsintitlebar="true"
+#endif
+        titlemenuseparator="&mainWindow.titlemodifiermenuseparator;"
+        lightweightthemes="true"
+        windowtype="navigator:browser"
+        macanimationtype="document"
+        screenX="4" screenY="4"
+        fullscreenbutton="true"
+        sizemode="normal"
+        retargetdocumentfocus="urlbar"
+        persist="screenX screenY width height sizemode">
+
+# All JS files which are not content (only) dependent that browser.xul
+# wishes to include *must* go into the global-scripts.inc file
+# so that they can be shared by macBrowserOverlay.xul.
+#include global-scripts.inc
+
+<script type="application/javascript">
+  Services.scriptloader.loadSubScript("chrome://global/content/contentAreaUtils.js", this);
+</script>
+
+# All sets except for popupsets (commands, keys, stringbundles and broadcasters) *must* go into the
+# browser-sets.inc file for sharing with hiddenWindow.xul.
+#define FULL_BROWSER_WINDOW
+#include browser-sets.inc
+#undef FULL_BROWSER_WINDOW
+  <popupset id="mainPopupSet">
+    <menupopup id="tabContextMenu"
+               onpopupshowing="if (event.target == this) TabContextMenu.updateContextMenu(this);"
+               onpopuphidden="if (event.target == this) TabContextMenu.contextTab = null;">
+      <menuitem id="context_reloadTab" label="&reloadTab.label;" accesskey="&reloadTab.accesskey;"
+                oncommand="gBrowser.reloadTab(TabContextMenu.contextTab);"/>
+      <menuitem id="context_toggleMuteTab" oncommand="TabContextMenu.contextTab.toggleMuteAudio();"/>
+      <menuseparator/>
+      <menuitem id="context_pinTab" label="&pinTab.label;"
+                accesskey="&pinTab.accesskey;"
+                oncommand="gBrowser.pinTab(TabContextMenu.contextTab);"/>
+      <menuitem id="context_unpinTab" label="&unpinTab.label;" hidden="true"
+                accesskey="&unpinTab.accesskey;"
+                oncommand="gBrowser.unpinTab(TabContextMenu.contextTab);"/>
+      <menuitem id="context_duplicateTab" label="&duplicateTab.label;"
+                accesskey="&duplicateTab.accesskey;"
+                oncommand="duplicateTabIn(TabContextMenu.contextTab, 'tab');"/>
+      <menuitem id="context_openTabInWindow" label="&moveToNewWindow.label;"
+                accesskey="&moveToNewWindow.accesskey;"
+                tbattr="tabbrowser-multiple"
+                oncommand="gBrowser.replaceTabWithWindow(TabContextMenu.contextTab);"/>
+      <menuseparator id="context_sendTabToDevice_separator"/>
+      <menu id="context_sendTabToDevice" label="&sendTabToDevice.label;"
+            accesskey="&sendTabToDevice.accesskey;">
+        <menupopup id="context_sendTabToDevicePopupMenu"
+                   onpopupshowing="gSync.populateSendTabToDevicesMenu(event.target, TabContextMenu.contextTab.linkedBrowser.currentURI.spec, TabContextMenu.contextTab.linkedBrowser.contentTitle);"/>
+      </menu>
+      <menuseparator/>
+      <menuitem id="context_reloadAllTabs" label="&reloadAllTabs.label;" accesskey="&reloadAllTabs.accesskey;"
+                tbattr="tabbrowser-multiple-visible"
+                oncommand="gBrowser.reloadAllTabs();"/>
+      <menuitem id="context_bookmarkAllTabs"
+                label="&bookmarkAllTabs.label;"
+                accesskey="&bookmarkAllTabs.accesskey;"
+                command="Browser:BookmarkAllTabs"/>
+      <menuitem id="context_closeTabsToTheEnd" label="&closeTabsToTheEnd.label;" accesskey="&closeTabsToTheEnd.accesskey;"
+                oncommand="gBrowser.removeTabsToTheEndFrom(TabContextMenu.contextTab, {animate: true});"/>
+      <menuitem id="context_closeOtherTabs" label="&closeOtherTabs.label;" accesskey="&closeOtherTabs.accesskey;"
+                oncommand="gBrowser.removeAllTabsBut(TabContextMenu.contextTab);"/>
+      <menuseparator/>
+      <menuitem id="context_undoCloseTab"
+                label="&undoCloseTab.label;"
+                accesskey="&undoCloseTab.accesskey;"
+                observes="History:UndoCloseTab"/>
+      <menuitem id="context_closeTab" label="&closeTab.label;" accesskey="&closeTab.accesskey;"
+                oncommand="gBrowser.removeTab(TabContextMenu.contextTab, { animate: true });"/>
+    </menupopup>
+
+    <!-- bug 415444/582485: event.stopPropagation is here for the cloned version
+         of this menupopup -->
+    <menupopup id="backForwardMenu"
+               onpopupshowing="return FillHistoryMenu(event.target);"
+               oncommand="gotoHistoryIndex(event); event.stopPropagation();"
+               onclick="checkForMiddleClick(this, event);"/>
+    <tooltip id="aHTMLTooltip" page="true"/>
+    <tooltip id="remoteBrowserTooltip"/>
+
+    <!-- for search and content formfill/pw manager -->
+
+    <panel type="autocomplete-richlistbox"
+           id="PopupAutoComplete"
+           noautofocus="true"
+           hidden="true"
+           overflowpadding="4"
+           norolluponanchor="true"
+           nomaxresults="true" />
+
+    <!-- for search with one-off buttons -->
+    <panel type="autocomplete" id="PopupSearchAutoComplete" noautofocus="true" hidden="true"/>
+
+    <!-- for url bar autocomplete -->
+    <panel type="autocomplete-richlistbox"
+           id="PopupAutoCompleteRichResult"
+           noautofocus="true"
+           hidden="true"
+           flip="none"
+           level="parent"
+           overflowpadding="15" />
+
+   <!-- for date/time picker. consumeoutsideclicks is set to never, so that
+        clicks on the anchored input box are never consumed. -->
+    <panel id="DateTimePickerPanel"
+           type="arrow"
+           hidden="true"
+           orient="vertical"
+           noautofocus="true"
+           norolluponanchor="true"
+           consumeoutsideclicks="never"
+           level="parent"
+           tabspecific="true">
+    </panel>
+
+    <!-- for select dropdowns. The menupopup is what shows the list of options,
+         and the popuponly menulist makes things like the menuactive attributes
+         work correctly on the menupopup. ContentSelectDropdown expects the
+         popuponly menulist to be its immediate parent. -->
+    <menulist popuponly="true" id="ContentSelectDropdown" hidden="true">
+      <menupopup rolluponmousewheel="true"
+                 activateontab="true" position="after_start"
+                 level="parent"
+#ifdef XP_WIN
+                 consumeoutsideclicks="false" ignorekeys="shortcuts"
+#endif
+        />
+    </menulist>
+
+    <!-- for invalid form error message -->
+    <panel id="invalid-form-popup" type="arrow" orient="vertical" noautofocus="true" hidden="true" level="parent">
+      <description/>
+    </panel>
+
+    <panel id="editBookmarkPanel"
+           type="arrow"
+           orient="vertical"
+           ignorekeys="true"
+           hidden="true"
+           tabspecific="true"
+           onpopupshown="StarUI.panelShown(event);"
+           aria-labelledby="editBookmarkPanelTitle">
+      <row id="editBookmarkPanelHeader" align="center" hidden="true">
+        <vbox align="center">
+          <image id="editBookmarkPanelStarIcon"/>
+        </vbox>
+        <vbox>
+          <label id="editBookmarkPanelTitle"/>
+          <description id="editBookmarkPanelDescription"/>
+        </vbox>
+      </row>
+      <vbox id="editBookmarkPanelContent" flex="1" hidden="true"/>
+      <hbox id="editBookmarkPanelBottomButtons" pack="end">
+#ifndef XP_UNIX
+        <button id="editBookmarkPanelDoneButton"
+                class="editBookmarkPanelBottomButton"
+                label="&editBookmark.done.label;"
+                default="true"
+                oncommand="StarUI.panel.hidePopup();"/>
+        <button id="editBookmarkPanelRemoveButton"
+                class="editBookmarkPanelBottomButton"
+                oncommand="StarUI.removeBookmarkButtonCommand();"
+                accesskey="&editBookmark.removeBookmark.accessKey;"/>
+#else
+        <button id="editBookmarkPanelRemoveButton"
+                class="editBookmarkPanelBottomButton"
+                oncommand="StarUI.removeBookmarkButtonCommand();"
+                accesskey="&editBookmark.removeBookmark.accessKey;"/>
+        <button id="editBookmarkPanelDoneButton"
+                class="editBookmarkPanelBottomButton"
+                label="&editBookmark.done.label;"
+                default="true"
+                oncommand="StarUI.panel.hidePopup();"/>
+#endif
+      </hbox>
+    </panel>
+
+    <!-- UI tour experience -->
+    <panel id="UITourTooltip"
+           type="arrow"
+           hidden="true"
+           noautofocus="true"
+           noautohide="true"
+           align="start"
+           orient="vertical"
+           role="alert">
+     <vbox>
+      <hbox id="UITourTooltipBody">
+        <image id="UITourTooltipIcon"/>
+        <vbox flex="1">
+          <hbox id="UITourTooltipTitleContainer">
+            <label id="UITourTooltipTitle" flex="1"/>
+            <toolbarbutton id="UITourTooltipClose" class="close-icon"
+                           tooltiptext="&uiTour.infoPanel.close;"/>
+          </hbox>
+          <description id="UITourTooltipDescription" flex="1"/>
+        </vbox>
+      </hbox>
+      <hbox id="UITourTooltipButtons" flex="1" align="center"/>
+     </vbox>
+    </panel>
+    <!-- type="default" forces frames to be created so that the panel's size can be determined -->
+    <panel id="UITourHighlightContainer"
+           type="default"
+           hidden="true"
+           noautofocus="true"
+           noautohide="true"
+           flip="none"
+           consumeoutsideclicks="false"
+           mousethrough="always">
+      <box id="UITourHighlight"></box>
+    </panel>
+
+    <panel id="sidebarMenu-popup"
+           class="cui-widget-panel"
+           role="group"
+           type="arrow"
+           hidden="true"
+           flip="slide"
+           orient="vertical"
+           position="bottomcenter topleft">
+      <toolbarbutton id="sidebar-switcher-bookmarks"
+                     class="subviewbutton subviewbutton-iconic"
+                     key="viewBookmarksSidebarKb"
+                     observes="viewBookmarksSidebar"
+                     oncommand="SidebarUI.show('viewBookmarksSidebar');">
+        <observes element="viewBookmarksSidebar" attribute="checked"/>
+      </toolbarbutton>
+      <toolbarbutton id="sidebar-switcher-history"
+                     label="&historyButton.label;"
+                     class="subviewbutton subviewbutton-iconic"
+                     key="key_gotoHistory"
+                     observes="viewHistorySidebar"
+                     oncommand="SidebarUI.show('viewHistorySidebar');">
+        <observes element="viewHistorySidebar" attribute="checked"/>
+      </toolbarbutton>
+      <toolbarbutton id="sidebar-switcher-tabs"
+                     label="&syncedTabs.sidebar.label;"
+                     class="subviewbutton subviewbutton-iconic"
+                     observes="viewTabsSidebar"
+                     oncommand="SidebarUI.show('viewTabsSidebar');">
+        <observes element="viewTabsSidebar" attribute="checked"/>
+      </toolbarbutton>
+      <toolbarseparator/>
+      <vbox id="sidebar-extensions"></vbox>
+      <toolbarseparator/>
+      <toolbarbutton id="sidebar-reverse-position"
+                     class="subviewbutton"
+                     oncommand="SidebarUI.reversePosition()"/>
+      <toolbarseparator/>
+      <toolbarbutton label="&sidebarMenuClose.label;"
+                     class="subviewbutton"
+                     oncommand="SidebarUI.hide()"/>
+    </panel>
+
+    <menupopup id="toolbar-context-menu"
+               onpopupshowing="onViewToolbarsPopupShowing(event, document.getElementById('viewToolbarsMenuSeparator'));">
+      <menuitem oncommand="gCustomizeMode.addToPanel(document.popupNode)"
+                accesskey="&customizeMenu.pinToOverflowMenu.accesskey;"
+                label="&customizeMenu.pinToOverflowMenu.label;"
+                contexttype="toolbaritem"
+                class="customize-context-moveToPanel"/>
+      <menuitem oncommand="gCustomizeMode.removeFromArea(document.popupNode)"
+                accesskey="&customizeMenu.removeFromToolbar.accesskey;"
+                label="&customizeMenu.removeFromToolbar.label;"
+                contexttype="toolbaritem"
+                class="customize-context-removeFromToolbar"/>
+      <menuitem id="toolbar-context-reloadAllTabs"
+                class="toolbaritem-tabsmenu"
+                contexttype="tabbar"
+                oncommand="gBrowser.reloadAllTabs();"
+                label="&toolbarContextMenu.reloadAllTabs.label;"
+                accesskey="&toolbarContextMenu.reloadAllTabs.accesskey;"/>
+      <menuitem id="toolbar-context-bookmarkAllTabs"
+                class="toolbaritem-tabsmenu"
+                contexttype="tabbar"
+                command="Browser:BookmarkAllTabs"
+                label="&toolbarContextMenu.bookmarkAllTabs.label;"
+                accesskey="&toolbarContextMenu.bookmarkAllTabs.accesskey;"/>
+      <menuitem id="toolbar-context-undoCloseTab"
+                class="toolbaritem-tabsmenu"
+                contexttype="tabbar"
+                label="&toolbarContextMenu.undoCloseTab.label;"
+                accesskey="&toolbarContextMenu.undoCloseTab.accesskey;"
+                observes="History:UndoCloseTab"/>
+      <menuseparator/>
+      <menuseparator id="viewToolbarsMenuSeparator"/>
+      <!-- XXXgijs: we're using oncommand handler here to avoid the event being
+                    redirected to the command element, thus preventing
+                    listeners on the menupopup or further up the tree from
+                    seeing the command event pass by. The observes attribute is
+                    here so that the menuitem is still disabled and re-enabled
+                    correctly. -->
+      <menuitem oncommand="gCustomizeMode.enter()"
+                observes="cmd_CustomizeToolbars"
+                class="viewCustomizeToolbar"
+                label="&viewCustomizeToolbar.label;"
+                accesskey="&viewCustomizeToolbar.accesskey;"/>
+    </menupopup>
+
+    <menupopup id="blockedPopupOptions"
+               onpopupshowing="gPopupBlockerObserver.fillPopupList(event);"
+               onpopuphiding="gPopupBlockerObserver.onPopupHiding(event);">
+      <menuitem observes="blockedPopupAllowSite"/>
+      <menuitem observes="blockedPopupEditSettings"/>
+      <menuitem observes="blockedPopupDontShowMessage"/>
+      <menuseparator observes="blockedPopupsSeparator"/>
+    </menupopup>
+
+    <menupopup id="autohide-context"
+           onpopupshowing="FullScreen.getAutohide(this.firstChild);">
+      <menuitem type="checkbox" label="&fullScreenAutohide.label;"
+                accesskey="&fullScreenAutohide.accesskey;"
+                oncommand="FullScreen.setAutohide();"/>
+      <menuseparator/>
+      <menuitem label="&fullScreenExit.label;"
+                accesskey="&fullScreenExit.accesskey;"
+                oncommand="BrowserFullScreen();"/>
+    </menupopup>
+
+    <menupopup id="contentAreaContextMenu" pagemenu="#page-menu-separator"
+               onpopupshowing="if (event.target != this)
+                                 return true;
+                               gContextMenu = new nsContextMenu(this, event.shiftKey);
+                               if (gContextMenu.shouldDisplay)
+                                 updateEditUIVisibility();
+                               return gContextMenu.shouldDisplay;"
+               onpopuphiding="if (event.target != this)
+                                return;
+                              gContextMenu.hiding();
+                              gContextMenu = null;
+                              updateEditUIVisibility();">
+#include browser-context.inc
+    </menupopup>
+
+    <menupopup id="placesContext"/>
+
+    <panel id="ctrlTab-panel" hidden="true" norestorefocus="true" level="top">
+      <hbox>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+      </hbox>
+      <hbox pack="center">
+        <button id="ctrlTab-showAll" class="ctrlTab-preview" noicon="true"/>
+      </hbox>
+    </panel>
+
+    <panel id="pageActionPanel"
+           class="cui-widget-panel"
+           role="group"
+           type="arrow"
+           hidden="true"
+           flip="slide"
+           photon="true"
+           position="bottomcenter topright"
+           tabspecific="true"
+           noautofocus="true"
+           copyURL-title="&pageAction.copyLink.label;"
+           emailLink-title="&emailPageCmd.label;"
+           sendToDevice-title="&pageAction.sendTabToDevice.label;"
+           sendToDevice-notReadyTitle="&sendToDevice.syncNotReady.label;">
+      <panelmultiview id="pageActionPanelMultiView"
+                      mainViewId="pageActionPanelMainView"
+                      viewCacheId="appMenu-viewCache">
+        <panelview id="pageActionPanelMainView"
+                   context="pageActionContextMenu"
+                   class="PanelUI-subView">
+          <vbox class="panel-subview-body"/>
+        </panelview>
+      </panelmultiview>
+    </panel>
+    <panel id="pageActionFeedback"
+           role="alert"
+           type="arrow"
+           hidden="true"
+           flip="slide"
+           position="bottomcenter topright"
+           tabspecific="true"
+           noautofocus="true"
+           copyURLFeedback="&copyURLFeedback.label;"
+           sendToDeviceFeedback="&sendToDeviceFeedback.label;"
+           sendToDeviceOfflineFeedback="&sendToDeviceOfflineFeedback.label;">
+      <hbox id="pageActionFeedbackAnimatableBox">
+        <image id="pageActionFeedbackAnimatableImage"/>
+      </hbox>
+      <label id="pageActionFeedbackMessage"/>
+    </panel>
+
+    <menupopup id="pageActionContextMenu"
+               onpopupshowing="BrowserPageActions.onContextMenuShowing(event, this);">
+      <menuitem class="pageActionContextMenuItem builtInUnpinned"
+                label="&pageAction.addToUrlbar.label;"
+                oncommand="BrowserPageActions.togglePinningForContextAction();"/>
+      <menuitem class="pageActionContextMenuItem builtInPinned"
+                label="&pageAction.removeFromUrlbar.label;"
+                oncommand="BrowserPageActions.togglePinningForContextAction();"/>
+      <menuitem class="pageActionContextMenuItem extensionUnpinned"
+                label="&pageAction.allowInUrlbar.label;"
+                oncommand="BrowserPageActions.togglePinningForContextAction();"/>
+      <menuitem class="pageActionContextMenuItem extensionPinned"
+                label="&pageAction.disallowInUrlbar.label;"
+                oncommand="BrowserPageActions.togglePinningForContextAction();"/>
+      <menuseparator class="pageActionContextMenuItem extensionPinned extensionUnpinned"/>
+      <menuitem class="pageActionContextMenuItem extensionPinned extensionUnpinned"
+                label="&pageAction.manageExtension.label;"
+                oncommand="BrowserPageActions.openAboutAddonsForContextAction();"/>
+    </menupopup>
+
+    <!-- Bookmarks and history tooltip -->
+    <tooltip id="bhTooltip"/>
+
+    <tooltip id="tabbrowser-tab-tooltip" onpopupshowing="gBrowser.createTooltip(event);"/>
+
+    <tooltip id="back-button-tooltip">
+      <label class="tooltip-label" value="&backButton.tooltip;"/>
+#ifdef XP_MACOSX
+      <label class="tooltip-label" value="&backForwardButtonMenuMac.tooltip;"/>
+#else
+      <label class="tooltip-label" value="&backForwardButtonMenu.tooltip;"/>
+#endif
+    </tooltip>
+
+    <tooltip id="forward-button-tooltip">
+      <label class="tooltip-label" value="&forwardButton.tooltip;"/>
+#ifdef XP_MACOSX
+      <label class="tooltip-label" value="&backForwardButtonMenuMac.tooltip;"/>
+#else
+      <label class="tooltip-label" value="&backForwardButtonMenu.tooltip;"/>
+#endif
+    </tooltip>
+
+#include popup-notifications.inc
+
+#include ../../components/customizableui/content/panelUI.inc.xul
+#include ../../components/controlcenter/content/panel.inc.xul
+
+    <hbox id="downloads-animation-container" mousethrough="always">
+      <vbox id="downloads-notification-anchor" hidden="true">
+        <vbox id="downloads-indicator-notification"/>
+      </vbox>
+    </hbox>
+
+    <hbox id="bookmarked-notification-container" mousethrough="always">
+      <vbox id="bookmarked-notification-anchor">
+        <vbox id="bookmarked-notification"/>
+      </vbox>
+      <vbox id="bookmarked-notification-dropmarker-anchor">
+        <image id="bookmarked-notification-dropmarker-icon"/>
+      </vbox>
+    </hbox>
+
+    <tooltip id="dynamic-shortcut-tooltip"
+             onpopupshowing="UpdateDynamicShortcutTooltipText(this);"/>
+
+    <menupopup id="SyncedTabsSidebarContext">
+      <menuitem label="&syncedTabs.context.open.label;"
+                accesskey="&syncedTabs.context.open.accesskey;"
+                id="syncedTabsOpenSelected" where="current"/>
+      <menuitem label="&syncedTabs.context.openInNewTab.label;"
+                accesskey="&syncedTabs.context.openInNewTab.accesskey;"
+                id="syncedTabsOpenSelectedInTab" where="tab"/>
+      <menuitem label="&syncedTabs.context.openInNewWindow.label;"
+                accesskey="&syncedTabs.context.openInNewWindow.accesskey;"
+                id="syncedTabsOpenSelectedInWindow" where="window"/>
+      <menuitem label="&syncedTabs.context.openInNewPrivateWindow.label;"
+                accesskey="&syncedTabs.context.openInNewPrivateWindow.accesskey;"
+                id="syncedTabsOpenSelectedInPrivateWindow" where="window" private="true"/>
+      <menuseparator/>
+      <menuitem label="&syncedTabs.context.bookmarkSingleTab.label;"
+                accesskey="&syncedTabs.context.bookmarkSingleTab.accesskey;"
+                id="syncedTabsBookmarkSelected"/>
+      <menuitem label="&syncedTabs.context.copy.label;"
+                accesskey="&syncedTabs.context.copy.accesskey;"
+                id="syncedTabsCopySelected"/>
+      <menuseparator/>
+      <menuitem label="&syncedTabs.context.openAllInTabs.label;"
+                accesskey="&syncedTabs.context.openAllInTabs.accesskey;"
+                id="syncedTabsOpenAllInTabs"/>
+      <menuitem label="&syncedTabs.context.managedevices.label;"
+                accesskey="&syncedTabs.context.managedevices.accesskey;"
+                id="syncedTabsManageDevices"
+                oncommand="gSync.openDevicesManagementPage('syncedtabs-sidebar');"/>
+      <menuitem label="&syncSyncNowItem.label;"
+                accesskey="&syncSyncNowItem.accesskey;"
+                id="syncedTabsRefresh"/>
+    </menupopup>
+    <menupopup id="SyncedTabsSidebarTabsFilterContext"
+               class="textbox-contextmenu">
+      <menuitem label="&undoCmd.label;"
+                accesskey="&undoCmd.accesskey;"
+                cmd="cmd_undo"/>
+      <menuseparator/>
+      <menuitem label="&cutCmd.label;"
+                accesskey="&cutCmd.accesskey;"
+                cmd="cmd_cut"/>
+      <menuitem label="&copyCmd.label;"
+                accesskey="&copyCmd.accesskey;"
+                cmd="cmd_copy"/>
+      <menuitem label="&pasteCmd.label;"
+                accesskey="&pasteCmd.accesskey;"
+                cmd="cmd_paste"/>
+      <menuitem label="&deleteCmd.label;"
+                accesskey="&deleteCmd.accesskey;"
+                cmd="cmd_delete"/>
+      <menuseparator/>
+      <menuitem label="&selectAllCmd.label;"
+                accesskey="&selectAllCmd.accesskey;"
+                cmd="cmd_selectAll"/>
+      <menuseparator/>
+      <menuitem label="&syncSyncNowItem.label;"
+                accesskey="&syncSyncNowItem.accesskey;"
+                id="syncedTabsRefreshFilter"/>
+    </menupopup>
+  </popupset>
+  <box id="appMenu-viewCache" hidden="true"/>
+
+#ifdef CAN_DRAW_IN_TITLEBAR
+<vbox id="titlebar">
+  <hbox id="titlebar-content">
+    <spacer id="titlebar-spacer" flex="1"/>
+    <hbox id="titlebar-buttonbox-container">
+      <hbox id="titlebar-buttonbox">
+        <toolbarbutton class="titlebar-button" id="titlebar-min" oncommand="window.minimize();"/>
+        <toolbarbutton class="titlebar-button" id="titlebar-max" oncommand="onTitlebarMaxClick();"/>
+        <toolbarbutton class="titlebar-button" id="titlebar-close" command="cmd_closeWindow"/>
+      </hbox>
+    </hbox>
+#ifdef XP_MACOSX
+    <!-- OS X does not natively support RTL for its titlebar items, so we prevent this secondary
+         buttonbox from reversing order in RTL by forcing an LTR direction. -->
+    <hbox id="titlebar-secondary-buttonbox" dir="ltr">
+      <button class="accessibility-indicator" tooltiptext="&accessibilityIndicator.tooltip;" aria-live="polite"/>
+      <hbox class="private-browsing-indicator"/>
+      <hbox id="titlebar-fullscreen-button"/>
+    </hbox>
+#endif
+  </hbox>
+</vbox>
+#endif
+
+<deck flex="1" id="tab-view-deck">
+<vbox flex="1" id="browser-panel">
+
+  <toolbox id="navigator-toolbox" mode="icons">
+    <!-- Menu -->
+    <toolbar type="menubar" id="toolbar-menubar" class="chromeclass-menubar" customizable="true"
+             mode="icons" iconsize="small"
+#ifdef MENUBAR_CAN_AUTOHIDE
+             toolbarname="&menubarCmd.label;"
+             accesskey="&menubarCmd.accesskey;"
+             autohide="true"
+#endif
+             context="toolbar-context-menu">
+      <toolbaritem id="menubar-items" align="center">
+# The entire main menubar is placed into browser-menubar.inc, so that it can be shared by
+# hiddenWindow.xul.
+#include browser-menubar.inc
+      </toolbaritem>
+
+#ifdef CAN_DRAW_IN_TITLEBAR
+#ifndef XP_MACOSX
+      <hbox class="titlebar-placeholder" type="caption-buttons" ordinal="1000"
+            persist="width"
+            skipintoolbarset="true"/>
+#endif
+#endif
+    </toolbar>
+
+    <toolbar id="TabsToolbar"
+             fullscreentoolbar="true"
+             customizable="true"
+             mode="icons"
+             iconsize="small"
+             aria-label="&tabsToolbar.label;"
+             context="toolbar-context-menu"
+             collapsed="true">
+
+#ifdef CAN_DRAW_IN_TITLEBAR
+      <hbox class="titlebar-placeholder" type="pre-tabs"
+            skipintoolbarset="true"/>
+#endif
+
+      <tabs id="tabbrowser-tabs"
+            tabbrowser="content"
+            flex="1"
+            setfocus="false"
+            tooltip="tabbrowser-tab-tooltip"
+            stopwatchid="FX_TAB_CLICK_MS">
+        <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
+      </tabs>
+
+      <toolbarbutton id="new-tab-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     label="&tabCmd.label;"
+                     command="cmd_newNavigatorTab"
+                     onclick="checkForMiddleClick(this, event);"
+                     tooltip="dynamic-shortcut-tooltip"
+                     ondrop="newTabButtonObserver.onDrop(event)"
+                     ondragover="newTabButtonObserver.onDragOver(event)"
+                     ondragenter="newTabButtonObserver.onDragOver(event)"
+                     ondragexit="newTabButtonObserver.onDragExit(event)"
+                     cui-areatype="toolbar"
+                     removable="true"/>
+
+      <toolbarbutton id="alltabs-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional tabs-alltabs-button"
+                     type="menu"
+                     label="&listAllTabs.label;"
+                     tooltiptext="&listAllTabs.label;"
+                     removable="false">
+        <menupopup id="alltabs-popup"
+                   position="after_end">
+          <menuitem id="alltabs_undoCloseTab"
+                    key="key_undoCloseTab"
+                    label="&undoCloseTab.label;"
+                    observes="History:UndoCloseTab"/>
+          <menuseparator id="alltabs-popup-separator-1"/>
+          <menu id="alltabs_containersTab"
+                label="&newUserContext.label;">
+            <menupopup id="alltabs_containersMenuTab" />
+          </menu>
+          <menuseparator id="alltabs-popup-separator-2"/>
+        </menupopup>
+      </toolbarbutton>
+
+#ifdef CAN_DRAW_IN_TITLEBAR
+      <hbox class="titlebar-placeholder" type="post-tabs"
+            ordinal="1000"
+            skipintoolbarset="true"/>
+#endif
+
+      <button class="accessibility-indicator" tooltiptext="&accessibilityIndicator.tooltip;"
+              ordinal="1000"
+              aria-live="polite" skipintoolbarset="true"/>
+      <hbox class="private-browsing-indicator" skipintoolbarset="true"
+            ordinal="1000"/>
+#ifdef CAN_DRAW_IN_TITLEBAR
+      <hbox class="titlebar-placeholder" type="caption-buttons"
+            persist="width"
+#ifndef XP_MACOSX
+            ordinal="1000"
+#endif
+            skipintoolbarset="true"/>
+
+#ifdef XP_MACOSX
+      <hbox class="titlebar-placeholder" type="fullscreen-button"
+            persist="width"
+            skipintoolbarset="true"/>
+#endif
+#endif
+    </toolbar>
+
+    <toolbar id="nav-bar"
+             aria-label="&navbarCmd.label;"
+             fullscreentoolbar="true" mode="icons" customizable="true"
+             iconsize="small"
+             customizationtarget="nav-bar-customization-target"
+             overflowable="true"
+             overflowbutton="nav-bar-overflow-button"
+             overflowtarget="widget-overflow-list"
+             overflowpanel="widget-overflow"
+             context="toolbar-context-menu">
+      <hbox id="nav-bar-customization-target" flex="1">
+        <toolbarbutton id="back-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                       label="&backCmd.label;"
+                       removable="false" overflows="false"
+                       keepbroadcastattributeswhencustomizing="true"
+                       command="Browser:BackOrBackDuplicate"
+                       onclick="checkForMiddleClick(this, event);"
+                       tooltip="back-button-tooltip"
+                       context="backForwardMenu"/>
+        <toolbarbutton id="forward-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                       label="&forwardCmd.label;"
+                       removable="false" overflows="false"
+                       keepbroadcastattributeswhencustomizing="true"
+                       command="Browser:ForwardOrForwardDuplicate"
+                       onclick="checkForMiddleClick(this, event);"
+                       tooltip="forward-button-tooltip"
+                       context="backForwardMenu"/>
+        <toolbaritem id="stop-reload-button" class="chromeclass-toolbar-additional"
+                     title="&reloadCmd.label;"
+                     removable="true" overflows="false">
+          <toolbarbutton id="reload-button" class="toolbarbutton-1"
+                         label="&reloadCmd.label;"
+                         command="Browser:ReloadOrDuplicate"
+                         onclick="checkForMiddleClick(this, event);"
+                         tooltip="dynamic-shortcut-tooltip">
+            <box class="toolbarbutton-animatable-box">
+              <image class="toolbarbutton-animatable-image"/>
+            </box>
+          </toolbarbutton>
+          <toolbarbutton id="stop-button" class="toolbarbutton-1"
+                         label="&stopCmd.label;"
+                         command="Browser:Stop"
+                         tooltip="dynamic-shortcut-tooltip">
+            <box class="toolbarbutton-animatable-box">
+              <image class="toolbarbutton-animatable-image"/>
+            </box>
+          </toolbarbutton>
+        </toolbaritem>
+        <toolbarbutton id="home-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                       removable="true"
+                       label="&homeButton.label;"
+                       ondragover="homeButtonObserver.onDragOver(event)"
+                       ondragenter="homeButtonObserver.onDragOver(event)"
+                       ondrop="homeButtonObserver.onDrop(event)"
+                       ondragexit="homeButtonObserver.onDragExit(event)"
+                       key="goHome"
+                       onclick="BrowserGoHome(event);"
+                       cui-areatype="toolbar"
+                       aboutHomeOverrideTooltip="&abouthome.pageTitle;"/>
+        <toolbarspring cui-areatype="toolbar" class="chromeclass-toolbar-additional"/>
+        <toolbaritem id="urlbar-container" flex="400" persist="width"
+                     removable="false"
+                     class="chromeclass-location" overflows="false">
+            <textbox id="urlbar" flex="1"
+                     placeholder="&urlbar.placeholder2;"
+                     type="autocomplete"
+                     autocompletesearch="unifiedcomplete"
+                     autocompletesearchparam="enable-actions"
+                     autocompletepopup="PopupAutoCompleteRichResult"
+                     completeselectedindex="true"
+                     shrinkdelay="250"
+                     tabscrolling="true"
+                     showcommentcolumn="true"
+                     showimagecolumn="true"
+                     newlines="stripsurroundingwhitespace"
+                     ontextentered="this.handleCommand(param);"
+                     ontextreverted="return this.handleRevert();"
+                     pageproxystate="invalid">
+              <!-- Use onclick instead of normal popup= syntax since the popup
+                   code fires onmousedown, and hence eats our favicon drag events. -->
+              <box id="identity-box" role="button"
+                   align="center"
+                   aria-label="&urlbar.viewSiteInfo.label;"
+                   onclick="gIdentityHandler.handleIdentityButtonEvent(event);"
+                   onkeypress="gIdentityHandler.handleIdentityButtonEvent(event);"
+                   ondragstart="gIdentityHandler.onDragStart(event);">
+                <image id="identity-icon"
+                       consumeanchor="identity-box"
+                       onclick="PageProxyClickHandler(event);"/>
+                <image id="sharing-icon" mousethrough="always"/>
+                <image id="tracking-protection-icon"/>
+                <box id="blocked-permissions-container" align="center">
+                  <image data-permission-id="geo" class="blocked-permission-icon geo-icon" role="button"
+                         tooltiptext="&urlbar.geolocationBlocked.tooltip;"/>
+                  <image data-permission-id="desktop-notification" class="blocked-permission-icon desktop-notification-icon" role="button"
+                         tooltiptext="&urlbar.webNotificationsBlocked.tooltip;"/>
+                  <image data-permission-id="camera" class="blocked-permission-icon camera-icon" role="button"
+                         tooltiptext="&urlbar.cameraBlocked.tooltip;"/>
+                  <image data-permission-id="microphone" class="blocked-permission-icon microphone-icon" role="button"
+                         tooltiptext="&urlbar.microphoneBlocked.tooltip;"/>
+                  <image data-permission-id="screen" class="blocked-permission-icon screen-icon" role="button"
+                         tooltiptext="&urlbar.screenBlocked.tooltip;"/>
+                  <image data-permission-id="persistent-storage" class="blocked-permission-icon persistent-storage-icon" role="button"
+                         tooltiptext="&urlbar.persistentStorageBlocked.tooltip;"/>
+                  <image data-permission-id="popup" class="blocked-permission-icon popup-icon" role="button"
+                         tooltiptext="&urlbar.popupBlocked.tooltip;"/>
+                </box>
+                <box id="notification-popup-box"
+                     hidden="true"
+                     onmouseover="document.getElementById('identity-box').classList.add('no-hover');"
+                     onmouseout="document.getElementById('identity-box').classList.remove('no-hover');"
+                     align="center">
+                  <image id="default-notification-icon" class="notification-anchor-icon" role="button"
+                         tooltiptext="&urlbar.defaultNotificationAnchor.tooltip;"/>
+                  <image id="geo-notification-icon" class="notification-anchor-icon geo-icon" role="button"
+                         tooltiptext="&urlbar.geolocationNotificationAnchor.tooltip;"/>
+                  <image id="addons-notification-icon" class="notification-anchor-icon install-icon" role="button"
+                         tooltiptext="&urlbar.addonsNotificationAnchor.tooltip;"/>
+                  <image id="canvas-notification-icon" class="notification-anchor-icon" role="button"
+                         tooltiptext="&urlbar.canvasNotificationAnchor.tooltip;"/>
+                  <image id="indexedDB-notification-icon" class="notification-anchor-icon indexedDB-icon" role="button"
+                         tooltiptext="&urlbar.indexedDBNotificationAnchor.tooltip;"/>
+                  <image id="password-notification-icon" class="notification-anchor-icon login-icon" role="button"
+                         tooltiptext="&urlbar.passwordNotificationAnchor.tooltip;"/>
+                  <stack id="plugins-notification-icon" class="notification-anchor-icon" role="button" align="center"
+                         tooltiptext="&urlbar.pluginsNotificationAnchor.tooltip;">
+                    <image class="plugin-icon" />
+                    <image id="plugin-icon-badge" />
+                  </stack>
+                  <image id="web-notifications-notification-icon" class="notification-anchor-icon desktop-notification-icon" role="button"
+                         tooltiptext="&urlbar.webNotificationAnchor.tooltip;"/>
+                  <image id="webRTC-shareDevices-notification-icon" class="notification-anchor-icon camera-icon" role="button"
+                         tooltiptext="&urlbar.webRTCShareDevicesNotificationAnchor.tooltip;"/>
+                  <image id="webRTC-shareMicrophone-notification-icon" class="notification-anchor-icon microphone-icon" role="button"
+                         tooltiptext="&urlbar.webRTCShareMicrophoneNotificationAnchor.tooltip;"/>
+                  <image id="webRTC-shareScreen-notification-icon" class="notification-anchor-icon screen-icon" role="button"
+                         tooltiptext="&urlbar.webRTCShareScreenNotificationAnchor.tooltip;"/>
+                  <image id="servicesInstall-notification-icon" class="notification-anchor-icon service-icon" role="button"
+                         tooltiptext="&urlbar.servicesNotificationAnchor.tooltip;"/>
+                  <image id="translate-notification-icon" class="notification-anchor-icon translation-icon" role="button"
+                         tooltiptext="&urlbar.translateNotificationAnchor.tooltip;"/>
+                  <image id="translated-notification-icon" class="notification-anchor-icon translation-icon in-use" role="button"
+                         tooltiptext="&urlbar.translatedNotificationAnchor.tooltip;"/>
+                  <image id="eme-notification-icon" class="notification-anchor-icon drm-icon" role="button"
+                         tooltiptext="&urlbar.emeNotificationAnchor.tooltip;"/>
+                  <image id="persistent-storage-notification-icon" class="notification-anchor-icon persistent-storage-icon" role="button"
+                         tooltiptext="&urlbar.persistentStorageNotificationAnchor.tooltip;"/>
+                </box>
+                <image id="connection-icon"/>
+                <image id="extension-icon"/>
+                <image id="remote-control-icon"
+                       tooltiptext="&urlbar.remoteControlNotificationAnchor.tooltip;"/>
+                <hbox id="identity-icon-labels">
+                  <label id="identity-icon-label" class="plain" flex="1"/>
+                  <label id="identity-icon-country-label" class="plain"/>
+                </hbox>
+              </box>
+              <box id="urlbar-display-box" align="center">
+                <label id="switchtab" class="urlbar-display urlbar-display-switchtab" value="&urlbar.switchToTab.label;"/>
+                <label id="extension" class="urlbar-display urlbar-display-extension" value="&urlbar.extension.label;"/>
+              </box>
+              <hbox id="page-action-buttons" context="pageActionContextMenu">
+                <hbox id="userContext-icons" hidden="true">
+                  <label id="userContext-label"/>
+                  <image id="userContext-indicator"/>
+                </hbox>
+                <image id="reader-mode-button"
+                       class="urlbar-icon urlbar-page-action"
+                       role="button"
+                       hidden="true"
+                       onclick="ReaderParent.buttonClick(event);"/>
+                <toolbarbutton id="urlbar-zoom-button"
+                       onclick="FullZoom.reset();"
+                       tooltip="dynamic-shortcut-tooltip"
+                       hidden="true"/>
+                <box id="pageActionSeparator" class="urlbar-page-action"/>
+                <image id="pageActionButton"
+                       class="urlbar-icon urlbar-page-action"
+                       role="button"
+                       tooltiptext="&pageActionButton.tooltip;"
+                       onmousedown="BrowserPageActions.mainButtonClicked(event);"/>
+                <hbox id="star-button-box"
+                      hidden="true"
+                      class="urlbar-icon-wrapper urlbar-page-action"
+                      onclick="BrowserPageActions.doCommandForAction(PageActions.actionForID('bookmark'), event, this);">
+                  <image id="star-button"
+                         class="urlbar-icon"
+                         role="button"
+                         observes="bookmarkThisPageBroadcaster"/>
+                  <hbox id="star-button-animatable-box">
+                    <image id="star-button-animatable-image"
+                           role="presentation"
+                           observes="bookmarkThisPageBroadcaster"/>
+                  </hbox>
+                </hbox>
+              </hbox>
+            </textbox>
+        </toolbaritem>
+
+        <toolbarspring cui-areatype="toolbar" class="chromeclass-toolbar-additional"/>
+
+        <!-- This is a placeholder for the Downloads Indicator.  It is visible
+             during the customization of the toolbar, in the palette, and before
+             the Downloads Indicator overlay is loaded. -->
+        <toolbarbutton id="downloads-button"
+                       class="toolbarbutton-1 chromeclass-toolbar-additional badged-button"
+                       key="key_openDownloads"
+                       onmousedown="DownloadsIndicatorView.onCommand(event);"
+                       ondrop="DownloadsIndicatorView.onDrop(event);"
+                       ondragover="DownloadsIndicatorView.onDragOver(event);"
+                       ondragenter="DownloadsIndicatorView.onDragOver(event);"
+                       label="&downloads.label;"
+                       removable="true"
+                       overflows="false"
+                       cui-areatype="toolbar"
+                       hidden="true"
+                       tooltip="dynamic-shortcut-tooltip"/>
+
+        <toolbarbutton id="library-button" class="toolbarbutton-1 chromeclass-toolbar-additional subviewbutton-nav"
+                       removable="true"
+                       onmousedown="PanelUI.showSubView('appMenu-libraryView', this, event);"
+                       closemenu="none"
+                       cui-areatype="toolbar"
+                       tooltiptext="&libraryButton.tooltip;"
+                       label="&places.library.title;"/>
+
+      </hbox>
+
+      <toolbarbutton id="nav-bar-overflow-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional overflow-button"
+                     skipintoolbarset="true"
+                     tooltiptext="&navbarOverflow.label;">
+        <box class="toolbarbutton-animatable-box">
+          <image class="toolbarbutton-animatable-image"/>
+        </box>
+      </toolbarbutton>
+
+      <toolbaritem id="PanelUI-button"
+                   removable="false">
+        <toolbarbutton id="PanelUI-menu-button"
+                       class="toolbarbutton-1 badged-button"
+                       consumeanchor="PanelUI-button"
+                       label="&brandShortName;"
+                       tooltiptext="&appmenu.tooltip;"/>
+      </toolbaritem>
+
+      <hbox id="window-controls" hidden="true" pack="end" skipintoolbarset="true"
+            ordinal="1000">
+        <toolbarbutton id="minimize-button"
+                       tooltiptext="&fullScreenMinimize.tooltip;"
+                       oncommand="window.minimize();"/>
+
+        <toolbarbutton id="restore-button"
+#ifdef XP_MACOSX
+# Prior to 10.7 there wasn't a native fullscreen button so we use #restore-button
+# to exit fullscreen and want it to behave like other toolbar buttons.
+                       class="toolbarbutton-1"
+#endif
+                       tooltiptext="&fullScreenRestore.tooltip;"
+                       oncommand="BrowserFullScreen();"/>
+
+        <toolbarbutton id="close-button"
+                       tooltiptext="&fullScreenClose.tooltip;"
+                       oncommand="BrowserTryToCloseWindow();"/>
+      </hbox>
+    </toolbar>
+
+    <toolbarset id="customToolbars" context="toolbar-context-menu"/>
+
+    <toolbar id="PersonalToolbar"
+             mode="icons" iconsize="small"
+             class="chromeclass-directories"
+             context="toolbar-context-menu"
+             toolbarname="&personalbarCmd.label;" accesskey="&personalbarCmd.accesskey;"
+             collapsed="true"
+             customizable="true">
+      <toolbaritem id="personal-bookmarks"
+                   title="&bookmarksToolbarItem.label;"
+                   cui-areatype="toolbar"
+                   removable="true">
+        <toolbarbutton id="bookmarks-toolbar-placeholder"
+                       class="bookmark-item"
+                       label="&bookmarksToolbarItem.label;"/>
+        <toolbarbutton id="bookmarks-toolbar-button"
+                       class="toolbarbutton-1"
+                       flex="1"
+                       label="&bookmarksToolbarItem.label;"
+                       oncommand="PlacesToolbarHelper.onPlaceholderCommand();"/>
+        <hbox flex="1"
+              id="PlacesToolbar"
+              context="placesContext"
+              onmouseup="BookmarksEventHandler.onMouseUp(event);"
+              onclick="BookmarksEventHandler.onClick(event, this._placesView);"
+              oncommand="BookmarksEventHandler.onCommand(event);"
+              tooltip="bhTooltip"
+              popupsinherittooltip="true">
+          <hbox flex="1">
+            <hbox id="PlacesToolbarDropIndicatorHolder" align="center" collapsed="true">
+              <image id="PlacesToolbarDropIndicator"
+                     mousethrough="always"
+                     collapsed="true"/>
+            </hbox>
+            <scrollbox orient="horizontal"
+                       id="PlacesToolbarItems"
+                       flex="1"/>
+            <toolbarbutton type="menu"
+                           id="PlacesChevron"
+                           class="toolbarbutton-1"
+                           mousethrough="never"
+                           collapsed="true"
+                           tooltiptext="&bookmarksToolbarChevron.tooltip;"
+                           onpopupshowing="document.getElementById('PlacesToolbar')
+                                                   ._placesView._onChevronPopupShowing(event);">
+              <menupopup id="PlacesChevronPopup"
+                         placespopup="true"
+                         tooltip="bhTooltip" popupsinherittooltip="true"
+                         context="placesContext"/>
+            </toolbarbutton>
+          </hbox>
+        </hbox>
+      </toolbaritem>
+    </toolbar>
+
+    <toolbarpalette id="BrowserToolbarPalette">
+
+      <toolbarbutton id="print-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+#ifdef XP_MACOSX
+                     command="cmd_print"
+                     tooltip="dynamic-shortcut-tooltip"
+#else
+                     command="cmd_printPreview"
+                     tooltiptext="&printButton.tooltip;"
+#endif
+                     label="&printButton.label;"/>
+
+
+      <toolbarbutton id="new-window-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     label="&newNavigatorCmd.label;"
+                     command="cmd_newNavigator"
+                     tooltip="dynamic-shortcut-tooltip"
+                     ondrop="newWindowButtonObserver.onDrop(event)"
+                     ondragover="newWindowButtonObserver.onDragOver(event)"
+                     ondragenter="newWindowButtonObserver.onDragOver(event)"
+                     ondragexit="newWindowButtonObserver.onDragExit(event)"/>
+
+      <toolbarbutton id="fullscreen-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     observes="View:FullScreen"
+                     type="checkbox"
+                     label="&fullScreenCmd.label;"
+                     tooltip="dynamic-shortcut-tooltip"/>
+
+      <toolbarbutton id="bookmarks-menu-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional subviewbutton-nav"
+                     type="menu"
+                     label="&bookmarksMenuButton2.label;"
+                     tooltip="dynamic-shortcut-tooltip"
+                     anchor="dropmarker"
+                     ondragenter="PlacesMenuDNDHandler.onDragEnter(event);"
+                     ondragover="PlacesMenuDNDHandler.onDragOver(event);"
+                     ondragleave="PlacesMenuDNDHandler.onDragLeave(event);"
+                     ondrop="PlacesMenuDNDHandler.onDrop(event);"
+                     oncommand="BookmarkingUI.onCommand(event);">
+        <observes element="bookmarkThisPageBroadcaster" attribute="starred"/>
+        <observes element="bookmarkThisPageBroadcaster" attribute="buttontooltiptext"/>
+        <menupopup id="BMB_bookmarksPopup"
+                   class="cui-widget-panel cui-widget-panelview cui-widget-panelWithFooter PanelUI-subView"
+                   placespopup="true"
+                   context="placesContext"
+                   openInTabs="children"
+                   onmouseup="BookmarksEventHandler.onMouseUp(event);"
+                   oncommand="BookmarksEventHandler.onCommand(event);"
+                   onclick="BookmarksEventHandler.onClick(event, this.parentNode._placesView);"
+                   onpopupshowing="BookmarkingUI.onPopupShowing(event);
+                                   BookmarkingUI.attachPlacesView(event, this);"
+                   tooltip="bhTooltip" popupsinherittooltip="true">
+          <menuitem id="BMB_viewBookmarksSidebar"
+                    class="subviewbutton"
+                    label="&viewBookmarksSidebar2.label;"
+                    type="checkbox"
+                    oncommand="SidebarUI.toggle('viewBookmarksSidebar');">
+            <observes element="viewBookmarksSidebar" attribute="checked"/>
+          </menuitem>
+          <!-- NB: temporary solution for bug 985024, this should go away soon. -->
+          <menuitem id="BMB_bookmarksShowAllTop"
+                    class="menuitem-iconic subviewbutton"
+                    label="&showAllBookmarks2.label;"
+                    command="Browser:ShowAllBookmarks"
+                    key="manBookmarkKb"/>
+          <menuseparator/>
+          <menu id="BMB_bookmarksToolbar"
+                class="menu-iconic bookmark-item subviewbutton"
+                label="&personalbarCmd.label;"
+                container="true">
+            <menupopup id="BMB_bookmarksToolbarPopup"
+                       placespopup="true"
+                       context="placesContext"
+                       onpopupshowing="if (!this.parentNode._placesView)
+                                         new PlacesMenu(event, 'place:folder=TOOLBAR',
+                                                        PlacesUIUtils.getViewForNode(this.parentNode.parentNode).options);">
+              <menuitem id="BMB_viewBookmarksToolbar"
+                        placesanonid="view-toolbar"
+                        toolbarId="PersonalToolbar"
+                        type="checkbox"
+                        oncommand="onViewToolbarCommand(event)"
+                        label="&viewBookmarksToolbar.label;"/>
+              <menuseparator/>
+              <!-- Bookmarks toolbar items -->
+            </menupopup>
+          </menu>
+          <menu id="BMB_unsortedBookmarks"
+                class="menu-iconic bookmark-item subviewbutton"
+                label="&bookmarksMenuButton.other.label;"
+                container="true">
+            <menupopup id="BMB_unsortedBookmarksPopup"
+                       placespopup="true"
+                       context="placesContext"
+                       onpopupshowing="if (!this.parentNode._placesView)
+                                         new PlacesMenu(event, 'place:folder=UNFILED_BOOKMARKS',
+                                                        PlacesUIUtils.getViewForNode(this.parentNode.parentNode).options);"/>
+          </menu>
+          <menu id="BMB_mobileBookmarks"
+                class="menu-iconic bookmark-item subviewbutton"
+                label="&bookmarksMenuButton.mobile.label;"
+                hidden="true"
+                container="true">
+            <menupopup id="BMB_mobileBookmarksPopup"
+                       placespopup="true"
+                       context="placesContext"
+                       onpopupshowing="if (!this.parentNode._placesView)
+                                         new PlacesMenu(event, 'place:folder=MOBILE_BOOKMARKS',
+                                                        PlacesUIUtils.getViewForNode(this.parentNode.parentNode).options);"/>
+          </menu>
+
+          <menuseparator/>
+          <!-- Bookmarks menu items will go here -->
+          <menuitem id="BMB_bookmarksShowAll"
+                    class="subviewbutton panel-subview-footer"
+                    label="&showAllBookmarks2.label;"
+                    command="Browser:ShowAllBookmarks"
+                    key="manBookmarkKb"/>
+        </menupopup>
+      </toolbarbutton>
+
+      <toolbaritem id="search-container"
+                   class="chromeclass-toolbar-additional"
+                   title="&searchItem.title;"
+                   align="center"
+                   flex="100"
+                   persist="width">
+        <searchbar id="searchbar" flex="1"/>
+      </toolbaritem>
+    </toolbarpalette>
+    <box id="library-animatable-box" class="toolbarbutton-animatable-box">
+      <image class="toolbarbutton-animatable-image"/>
+    </box>
+  </toolbox>
+
+  <hbox id="fullscr-toggler" hidden="true"/>
+
+  <deck id="content-deck" flex="1">
+    <hbox flex="1" id="browser">
+      <vbox id="browser-border-start" hidden="true" layer="true"/>
+      <vbox id="sidebar-box" hidden="true" class="chromeclass-extrachrome">
+        <sidebarheader id="sidebar-header" align="center">
+          <toolbarbutton id="sidebar-switcher-target" flex="1" class="tabbable">
+            <image id="sidebar-icon" consumeanchor="sidebar-switcher-target"/>
+            <label id="sidebar-title" persist="value" crop="end" flex="1" control="sidebar"/>
+            <image id="sidebar-switcher-arrow"/>
+          </toolbarbutton>
+          <image id="sidebar-throbber"/>
+# To ensure the button label's intrinsic width doesn't expand the sidebar
+# if the label is long, the button needs flex=1.
+# To ensure the button doesn't expand unnecessarily for short labels, the
+# spacer should significantly out-flex the button.
+          <spacer flex="1000"/>
+          <toolbarbutton id="sidebar-close" class="close-icon tabbable" tooltiptext="&sidebarCloseButton.tooltip;" oncommand="SidebarUI.hide();"/>
+        </sidebarheader>
+        <browser id="sidebar" flex="1" autoscroll="false" disablehistory="true" disablefullscreen="true"
+                  style="min-width: 14em; width: 18em; max-width: 36em;" tooltip="aHTMLTooltip"/>
+      </vbox>
+
+      <splitter id="sidebar-splitter" class="chromeclass-extrachrome sidebar-splitter" hidden="true"/>
+      <vbox id="appcontent" flex="1">
+        <notificationbox id="high-priority-global-notificationbox" notificationside="top"/>
+        <tabbrowser id="content"
+                    flex="1" contenttooltip="aHTMLTooltip"
+                    tabcontainer="tabbrowser-tabs"
+                    contentcontextmenu="contentAreaContextMenu"
+                    autocompletepopup="PopupAutoComplete"
+                    selectmenulist="ContentSelectDropdown"
+                    datetimepicker="DateTimePickerPanel"/>
+      </vbox>
+      <vbox id="browser-border-end" hidden="true" layer="true"/>
+    </hbox>
+#include ../../components/customizableui/content/customizeMode.inc.xul
+  </deck>
+
+  <html:div id="fullscreen-warning" class="pointerlockfswarning" hidden="true">
+    <html:div class="pointerlockfswarning-domain-text">
+      &fullscreenWarning.beforeDomain.label;
+      <html:span class="pointerlockfswarning-domain"/>
+      &fullscreenWarning.afterDomain.label;
+    </html:div>
+    <html:div class="pointerlockfswarning-generic-text">
+      &fullscreenWarning.generic.label;
+    </html:div>
+    <html:button id="fullscreen-exit-button"
+                 onclick="FullScreen.exitDomFullScreen();">
+#ifdef XP_MACOSX
+            &exitDOMFullscreenMac.button;
+#else
+            &exitDOMFullscreen.button;
+#endif
+    </html:button>
+  </html:div>
+
+  <html:div id="pointerlock-warning" class="pointerlockfswarning" hidden="true">
+    <html:div class="pointerlockfswarning-domain-text">
+      &pointerlockWarning.beforeDomain.label;
+      <html:span class="pointerlockfswarning-domain"/>
+      &pointerlockWarning.afterDomain.label;
+    </html:div>
+    <html:div class="pointerlockfswarning-generic-text">
+      &pointerlockWarning.generic.label;
+    </html:div>
+  </html:div>
+
+  <vbox id="browser-bottombox" layer="true">
+    <notificationbox id="global-notificationbox" notificationside="bottom"/>
+  </vbox>
+
+</vbox>
+# <iframe id="tab-view"> is dynamically appended as the 2nd child of #tab-view-deck.
+#     Introducing the iframe dynamically, as needed, was found to be better than
+#     starting with an empty iframe here in browser.xul from a Ts standpoint.
+</deck>
+
+<script src="chrome://browser/content/customelements/custom-elements.js"></script>
+</window>
diff --git a/browser/base/content/customelements/custom-elements-polyfill.js b/browser/base/content/customelements/custom-elements-polyfill.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/custom-elements-polyfill.js
@@ -0,0 +1,48 @@
+(function(){
+'use strict';var g={},h=new function(){};g.default=h;var k={},l=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));k.isValidCustomElementName=function(b){return!l.has(b)&&!0};k.isConnected=function(b){var a=b.isConnected;if(void 0!==a)return a;for(;b&&!(b.__CE_isImportDocument||b instanceof Document);)b=b.parentNode||(window.ShadowRoot&&b instanceof ShadowRoot?b.host:void 0);return!(!b||!(b.__CE_isImportDocument||b instanceof Document))};
+k.walkDeepDescendantElements=function(b,a,f){void 0===f&&new Set;f=Components.interfaces;var c=Components.classes["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Components.interfaces.inIDeepTreeWalker);c.showAnonymousContent=!0;c.showSubDocuments=!1;c.showDocumentsAsNodes=!1;c.init(b,f.nsIDOMNodeFilter.SHOW_ELEMENT);for(a(b);c.nextNode();)c.currentNode instanceof Element&&a(c.currentNode)};k.setPropertyUnchecked=function(b,a,f){b[a]=f};var m={default:{custom:1,failed:2}};var r={};function t(){this._localNameToDefinition=new Map;this._constructorToDefinition=new Map;this._patches=[];this._hasPatches=!1}t.prototype.setDefinition=function(b,a){this._localNameToDefinition.set(b,a);this._constructorToDefinition.set(a.constructor,a)};t.prototype.localNameToDefinition=function(b){return this._localNameToDefinition.get(b)};t.prototype.constructorToDefinition=function(b){return this._constructorToDefinition.get(b)};t.prototype.addPatch=function(b){this._hasPatches=!0;this._patches.push(b)};
+t.prototype.patchTree=function(b){var a=this;this._hasPatches&&k.walkDeepDescendantElements(b,function(b){return a.patch(b)})};t.prototype.patch=function(b){if(this._hasPatches&&!b.__CE_patched){b.__CE_patched=!0;for(var a=0;a<this._patches.length;a++)this._patches[a](b)}};t.prototype.connectTree=function(b){var a=[];k.walkDeepDescendantElements(b,function(b){return a.push(b)});for(b=0;b<a.length;b++){var f=a[b];f.__CE_state===m.default.custom?this.connectedCallback(f):this.upgradeElement(f)}};
+t.prototype.disconnectTree=function(b){var a=[];k.walkDeepDescendantElements(b,function(b){return a.push(b)});for(b=0;b<a.length;b++){var f=a[b];f.__CE_state===m.default.custom&&this.disconnectedCallback(f)}};
+t.prototype.patchAndUpgradeTree=function(b,a){a=void 0===a?{}:a;var f=this,c=a.visitedImports||new Set,e=a.upgrade||function(b){return f.upgradeElement(b)},d=[];k.walkDeepDescendantElements(b,function(b){if("link"===b.localName&&"import"===b.getAttribute("rel")){var a=b.import;a instanceof Node&&"complete"===a.readyState?(a.__CE_isImportDocument=!0,a.__CE_hasRegistry=!0):b.addEventListener("load",function(){var a=b.import;a.__CE_documentLoadHandled||(a.__CE_documentLoadHandled=!0,a.__CE_isImportDocument=
+!0,a.__CE_hasRegistry=!0,new Set(c),c.delete(a),f.patchAndUpgradeTree(a,{visitedImports:c,upgrade:e}))})}else d.push(b)},c);if(this._hasPatches)for(b=0;b<d.length;b++)this.patch(d[b]);for(b=0;b<d.length;b++)e(d[b])};
+t.prototype.upgradeElement=function(b){if(void 0===b.__CE_state){var a=this.localNameToDefinition(b.localName);if(a){a.constructionStack.push(b);var f=a.constructor;try{try{if(new f!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{a.constructionStack.pop()}}catch(d){throw b.__CE_state=m.default.failed,d;}b.__CE_state=m.default.custom;b.__CE_definition=a;if(a.attributeChangedCallback)for(a=a.observedAttributes,f=0;f<a.length;f++){var c=a[f],e=b.getAttribute(c);
+null!==e&&this.attributeChangedCallback(b,c,null,e,null)}k.isConnected(b)&&this.connectedCallback(b)}}};t.prototype.connectedCallback=function(b){var a=b.__CE_definition;a.connectedCallback&&a.connectedCallback.call(b)};t.prototype.disconnectedCallback=function(b){var a=b.__CE_definition;a.disconnectedCallback&&a.disconnectedCallback.call(b)};
+t.prototype.attributeChangedCallback=function(b,a,f,c,e){var d=b.__CE_definition;d.attributeChangedCallback&&-1<d.observedAttributes.indexOf(a)&&d.attributeChangedCallback.call(b,a,f,c,e)};r.default=t;var u={};function v(b,a){this._internals=b;this._document=a;this._observer=void 0;this._internals.patchAndUpgradeTree(this._document);"loading"===this._document.readyState&&(this._observer=new MutationObserver(this._handleMutations.bind(this)),this._observer.observe(this._document,{childList:!0,subtree:!0}))}v.prototype.disconnect=function(){this._observer&&this._observer.disconnect()};
+v.prototype._handleMutations=function(b){var a=this._document.readyState;"interactive"!==a&&"complete"!==a||this.disconnect();for(a=0;a<b.length;a++)for(var f=b[a].addedNodes,c=0;c<f.length;c++)this._internals.patchAndUpgradeTree(f[c])};u.default=v;var w={};function x(){var b=this;this._resolve=this._value=void 0;this._promise=new Promise(function(a){b._resolve=a;b._value&&a(b._value)})}x.prototype.resolve=function(b){if(this._value)throw Error("Already resolved.");this._value=b;this._resolve&&this._resolve(b)};x.prototype.toPromise=function(){return this._promise};w.default=x;var y={};function z(b){this._elementDefinitionIsRunning=!1;this._internals=b;this._whenDefinedDeferred=new Map;this._flushCallback=function(b){return b()};this._flushPending=!1;this._pendingDefinitions=[];this._documentConstructionObserver=new u.default(b,document)}
+z.prototype.define=function(b,a){var f=this;if(!(a instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!k.isValidCustomElementName(b))throw new SyntaxError("The element name '"+b+"' is not valid.");if(this._internals.localNameToDefinition(b))throw Error("A custom element with name '"+b+"' has already been defined.");if(this._elementDefinitionIsRunning)throw Error("A custom element is already being defined.");this._elementDefinitionIsRunning=!0;var c,e,d,q,
+p;try{var n=function(b){var a=B[b];if(void 0!==a&&!(a instanceof Function))throw Error("The '"+b+"' callback must be a function.");return a},B=a.prototype;if(!(B instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");c=n("connectedCallback");e=n("disconnectedCallback");d=n("adoptedCallback");q=n("attributeChangedCallback");p=a.observedAttributes||[]}catch(L){return}finally{this._elementDefinitionIsRunning=!1}this._pendingDefinitions.push({localName:b,
+constructor:a,connectedCallback:c,disconnectedCallback:e,adoptedCallback:d,attributeChangedCallback:q,observedAttributes:p,constructionStack:[]});this._flushPending||(this._flushPending=!0,this._flushCallback(function(){return f._flush()}))};
+z.prototype._flush=function(){var b=this;if(!1!==this._flushPending){this._flushPending=!1;for(var a=this._pendingDefinitions,f=new Map,c=0;c<a.length;c++)f.set(a[c].localName,[]);for(this._internals.patchAndUpgradeTree(document,{upgrade:function(a){b._internals.upgradeElement(a);if(void 0===a.__CE_state){var e=f.get(a.localName);e&&e.push(a)}}});0<a.length;){var e=a.shift(),c=e.localName;this._internals.setDefinition(c,e);for(var e=f.get(e.localName),d=0;d<e.length;d++)this._internals.upgradeElement(e[d]);
+(c=this._whenDefinedDeferred.get(c))&&c.resolve(void 0)}}};z.prototype.get=function(b){if(b=this._internals.localNameToDefinition(b))return b.constructor};
+z.prototype.whenDefined=function(b){if(!k.isValidCustomElementName(b))return Promise.reject(new SyntaxError("'"+b+"' is not a valid custom element name."));var a=this._whenDefinedDeferred.get(b);if(a)return a.toPromise();a=new w.default;this._whenDefinedDeferred.set(b,a);this._internals.localNameToDefinition(b)&&!this._pendingDefinitions.some(function(a){return a.localName===b})&&a.resolve(void 0);return a.toPromise()};
+z.prototype.polyfillWrapFlushCallback=function(b){this._documentConstructionObserver.disconnect();var a=this._flushCallback;this._flushCallback=function(f){return b(function(){return a(f)})}};window.CustomElementRegistry=z;z.prototype.define=z.prototype.define;z.prototype.get=z.prototype.get;z.prototype.whenDefined=z.prototype.whenDefined;z.prototype.polyfillWrapFlushCallback=z.prototype.polyfillWrapFlushCallback;y.default=z;var A={},C={Document_createElement:window.Document.prototype.createElement,Document_createElementNS:window.Document.prototype.createElementNS,Document_importNode:window.Document.prototype.importNode,Document_prepend:window.Document.prototype.prepend,Document_append:window.Document.prototype.append,Node_cloneNode:window.Node.prototype.cloneNode,Node_appendChild:window.Node.prototype.appendChild,Node_insertBefore:window.Node.prototype.insertBefore,Node_removeChild:window.Node.prototype.removeChild,
+Node_replaceChild:window.Node.prototype.replaceChild,Node_textContent:Object.getOwnPropertyDescriptor(window.Node.prototype,"textContent"),Element_attachShadow:window.Element.prototype.attachShadow,Element_innerHTML:Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),Element_getAttribute:window.Element.prototype.getAttribute,Element_setAttribute:window.Element.prototype.setAttribute,Element_removeAttribute:window.Element.prototype.removeAttribute,Element_getAttributeNS:window.Element.prototype.getAttributeNS,
+Element_setAttributeNS:window.Element.prototype.setAttributeNS,Element_removeAttributeNS:window.Element.prototype.removeAttributeNS,Element_insertAdjacentElement:window.Element.prototype.insertAdjacentElement,Element_prepend:window.Element.prototype.prepend,Element_append:window.Element.prototype.append,Element_before:window.Element.prototype.before,Element_after:window.Element.prototype.after,Element_replaceWith:window.Element.prototype.replaceWith,Element_remove:window.Element.prototype.remove,
+XULElement:window.XULElement,XULElement_innerHTML:Object.getOwnPropertyDescriptor(window.XULElement.prototype,"innerHTML"),XULElement_insertAdjacentElement:window.XULElement.prototype.insertAdjacentElement};A.default=C;var D={default:function(b){window.XULElement=function(){function a(){var a=this.constructor,c=b.constructorToDefinition(a);if(!c)throw Error("The custom element being constructed was not registered with `customElements`.");var e=c.constructionStack;if(0===e.length)return e=A.default.Document_createElement.call(document,c.localName),Object.setPrototypeOf(e,a.prototype),e.__CE_state=m.default.custom,e.__CE_definition=c,b.patch(e),e;var c=e.length-1,d=e[c];if(d===g.default)throw Error("The XULElement constructor was either called reentrantly for this constructor or called multiple times.");
+e[c]=g.default;Object.setPrototypeOf(d,a.prototype);b.patch(d);return d}a.prototype=A.default.XULElement.prototype;return a}()}};var E={default:function(b,a,f){a.prepend=function(a){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];d=e.filter(function(b){return b instanceof Node&&k.isConnected(b)});f.prepend.apply(this,e);for(var c=0;c<d.length;c++)b.disconnectTree(d[c]);if(k.isConnected(this))for(d=0;d<e.length;d++)c=e[d],c instanceof Element&&b.connectTree(c)};a.append=function(a){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];d=e.filter(function(b){return b instanceof Node&&k.isConnected(b)});f.append.apply(this,
+e);for(var c=0;c<d.length;c++)b.disconnectTree(d[c]);if(k.isConnected(this))for(d=0;d<e.length;d++)c=e[d],c instanceof Element&&b.connectTree(c)}}};var F={default:function(b){k.setPropertyUnchecked(Document.prototype,"createElement",function(a){if(this.__CE_hasRegistry){var f=b.localNameToDefinition(a);if(f)return new f.constructor}a=A.default.Document_createElement.call(this,a);b.patch(a);return a});k.setPropertyUnchecked(Document.prototype,"importNode",function(a,f){a=A.default.Document_importNode.call(this,a,f);this.__CE_hasRegistry?b.patchAndUpgradeTree(a):b.patchTree(a);return a});k.setPropertyUnchecked(Document.prototype,"createElementNS",
+function(a,f){if(this.__CE_hasRegistry&&(null===a||"http://www.w3.org/1999/xhtml"===a)){var c=b.localNameToDefinition(f);if(c)return new c.constructor}a=A.default.Document_createElementNS.call(this,a,f);b.patch(a);return a});E.default(b,Document.prototype,{prepend:A.default.Document_prepend,append:A.default.Document_append})}};var G={default:function(b){function a(a,c){Object.defineProperty(a,"textContent",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(a){if(this.nodeType===Node.TEXT_NODE)c.set.call(this,a);else{var d=void 0;if(this.firstChild){var e=this.childNodes,f=e.length;if(0<f&&k.isConnected(this))for(var d=Array(f),n=0;n<f;n++)d[n]=e[n]}c.set.call(this,a);if(d)for(a=0;a<d.length;a++)b.disconnectTree(d[a])}}})}k.setPropertyUnchecked(Node.prototype,"insertBefore",function(a,c){if(a instanceof DocumentFragment){var e=
+Array.prototype.slice.apply(a.childNodes);a=A.default.Node_insertBefore.call(this,a,c);if(k.isConnected(this))for(c=0;c<e.length;c++)b.connectTree(e[c]);return a}e=k.isConnected(a);c=A.default.Node_insertBefore.call(this,a,c);e&&b.disconnectTree(a);k.isConnected(this)&&b.connectTree(a);return c});k.setPropertyUnchecked(Node.prototype,"appendChild",function(a){if(a instanceof DocumentFragment){var c=Array.prototype.slice.apply(a.childNodes);a=A.default.Node_appendChild.call(this,a);if(k.isConnected(this))for(var e=
+0;e<c.length;e++)b.connectTree(c[e]);return a}c=k.isConnected(a);e=A.default.Node_appendChild.call(this,a);c&&b.disconnectTree(a);k.isConnected(this)&&b.connectTree(a);return e});k.setPropertyUnchecked(Node.prototype,"cloneNode",function(a){a=A.default.Node_cloneNode.call(this,a);this.ownerDocument.__CE_hasRegistry?b.patchAndUpgradeTree(a):b.patchTree(a);return a});k.setPropertyUnchecked(Node.prototype,"removeChild",function(a){var c=k.isConnected(a),e=A.default.Node_removeChild.call(this,a);c&&b.disconnectTree(a);
+return e});k.setPropertyUnchecked(Node.prototype,"replaceChild",function(a,c){if(a instanceof DocumentFragment){var e=Array.prototype.slice.apply(a.childNodes);a=A.default.Node_replaceChild.call(this,a,c);if(k.isConnected(this))for(b.disconnectTree(c),c=0;c<e.length;c++)b.connectTree(e[c]);return a}var e=k.isConnected(a),d=A.default.Node_replaceChild.call(this,a,c),f=k.isConnected(this);f&&b.disconnectTree(c);e&&b.disconnectTree(a);f&&b.connectTree(a);return d});A.default.Node_textContent&&A.default.Node_textContent.get?
+a(Node.prototype,A.default.Node_textContent):b.addPatch(function(b){a(b,{enumerable:!0,configurable:!0,get:function(){for(var a=[],b=0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)A.default.Node_removeChild.call(this,this.firstChild);A.default.Node_appendChild.call(this,document.createTextNode(a))}})})}};var H={default:function(b,a,f){a.before=function(a){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];d=e.filter(function(a){return a instanceof Node&&k.isConnected(a)});f.before.apply(this,e);for(var c=0;c<d.length;c++)b.disconnectTree(d[c]);if(k.isConnected(this))for(d=0;d<e.length;d++)c=e[d],c instanceof Element&&b.connectTree(c)};a.after=function(a){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];d=e.filter(function(a){return a instanceof Node&&k.isConnected(a)});f.after.apply(this,
+e);for(var c=0;c<d.length;c++)b.disconnectTree(d[c]);if(k.isConnected(this))for(d=0;d<e.length;d++)c=e[d],c instanceof Element&&b.connectTree(c)};a.replaceWith=function(a){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];var d=e.filter(function(a){return a instanceof Node&&k.isConnected(a)}),c=k.isConnected(this);f.replaceWith.apply(this,e);for(var p=0;p<d.length;p++)b.disconnectTree(d[p]);if(c)for(b.disconnectTree(this),d=0;d<e.length;d++)c=e[d],c instanceof Element&&b.connectTree(c)};
+a.remove=function(){var a=k.isConnected(this);f.remove.call(this);a&&b.disconnectTree(this)}}};var I={default:function(b){function a(a,d){Object.defineProperty(a,"innerHTML",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(a){var e=this,c=void 0;k.isConnected(this)&&(c=[],k.walkDeepDescendantElements(this,function(a){a!==e&&c.push(a)}));d.set.call(this,a);if(c)for(var f=0;f<c.length;f++){var q=c[f];q.__CE_state===m.default.custom&&b.disconnectedCallback(q)}this.ownerDocument.__CE_hasRegistry?b.patchAndUpgradeTree(this):b.patchTree(this);return a}})}function f(a,d){k.setPropertyUnchecked(a,
+"insertAdjacentElement",function(a,c){var e=k.isConnected(c);a=d.call(this,a,c);e&&b.disconnectTree(c);k.isConnected(a)&&b.connectTree(c);return a})}A.default.Element_attachShadow?k.setPropertyUnchecked(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=A.default.Element_attachShadow.call(this,a)}):console.warn("Custom Elements: `Element#attachShadow` was not patched.");if(A.default.Element_innerHTML&&A.default.Element_innerHTML.get)a(Element.prototype,A.default.Element_innerHTML);
+else if(A.default.XULElement_innerHTML&&A.default.XULElement_innerHTML.get)a(XULElement.prototype,A.default.XULElement_innerHTML);else{var c=A.default.Document_createElement.call(document,"div");b.addPatch(function(b){a(b,{enumerable:!0,configurable:!0,get:function(){return A.default.Node_cloneNode.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName?this.content:this;for(c.innerHTML=a;0<b.childNodes.length;)A.default.Node_removeChild.call(b,b.childNodes[0]);for(;0<c.childNodes.length;)A.default.Node_appendChild.call(b,
+c.childNodes[0])}})})}k.setPropertyUnchecked(Element.prototype,"setAttribute",function(a,c){if(this.__CE_state!==m.default.custom)return A.default.Element_setAttribute.call(this,a,c);var d=A.default.Element_getAttribute.call(this,a);A.default.Element_setAttribute.call(this,a,c);c=A.default.Element_getAttribute.call(this,a);b.attributeChangedCallback(this,a,d,c,null)});k.setPropertyUnchecked(Element.prototype,"setAttributeNS",function(a,c,f){if(this.__CE_state!==m.default.custom)return A.default.Element_setAttributeNS.call(this,
+a,c,f);var d=A.default.Element_getAttributeNS.call(this,a,c);A.default.Element_setAttributeNS.call(this,a,c,f);f=A.default.Element_getAttributeNS.call(this,a,c);b.attributeChangedCallback(this,c,d,f,a)});k.setPropertyUnchecked(Element.prototype,"removeAttribute",function(a){if(this.__CE_state!==m.default.custom)return A.default.Element_removeAttribute.call(this,a);var c=A.default.Element_getAttribute.call(this,a);A.default.Element_removeAttribute.call(this,a);null!==c&&b.attributeChangedCallback(this,
+a,c,null,null)});k.setPropertyUnchecked(Element.prototype,"removeAttributeNS",function(a,c){if(this.__CE_state!==m.default.custom)return A.default.Element_removeAttributeNS.call(this,a,c);var d=A.default.Element_getAttributeNS.call(this,a,c);A.default.Element_removeAttributeNS.call(this,a,c);var e=A.default.Element_getAttributeNS.call(this,a,c);d!==e&&b.attributeChangedCallback(this,c,d,e,a)});A.default.XULElement_insertAdjacentElement?f(XULElement.prototype,A.default.XULElement_insertAdjacentElement):
+A.default.Element_insertAdjacentElement?f(Element.prototype,A.default.Element_insertAdjacentElement):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");E.default(b,Element.prototype,{prepend:A.default.Element_prepend,append:A.default.Element_append});H.default(b,Element.prototype,{before:A.default.Element_before,after:A.default.Element_after,replaceWith:A.default.Element_replaceWith,remove:A.default.Element_remove})}};/*
+
+ Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
+ This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
+ The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
+ The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
+ Code distributed by Google as part of the polymer project is also
+ subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
+*/
+var J=window.customElements;if(!J||J.forcePolyfill||"function"!=typeof J.define||"function"!=typeof J.get){var K=new r.default;D.default(K);F.default(K);G.default(K);I.default(K);document.__CE_hasRegistry=!0;var customElements=new y.default(K);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};
+}).call(self);
+
+//# sourceMappingURL=custom-elements.min.js.map
diff --git a/browser/base/content/global-scripts.inc b/browser/base/content/global-scripts.inc
--- a/browser/base/content/global-scripts.inc
+++ b/browser/base/content/global-scripts.inc
@@ -6,28 +6,17 @@
 # If you update this list, you may need to add a mapping within the following
 # file so that ESLint works correctly:
 # tools/lint/eslint/eslint-plugin-mozilla/lib/environments/browser-window.js
 
 <script type="application/javascript">
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 for (let script of [
-  "chrome://browser/content/browser.js",
-
-  "chrome://browser/content/browser-captivePortal.js",
-  "chrome://browser/content/browser-compacttheme.js",
-  "chrome://browser/content/browser-feeds.js",
-  "chrome://browser/content/browser-media.js",
-  "chrome://browser/content/browser-pageActions.js",
-  "chrome://browser/content/browser-places.js",
-  "chrome://browser/content/browser-plugins.js",
-  "chrome://browser/content/browser-sidebar.js",
-  "chrome://browser/content/browser-tabsintitlebar.js",
-  "chrome://browser/content/browser-trackingprotection.js",
+  "chrome://browser/content/browser-bundle.js",
 #ifdef MOZ_DATA_REPORTING
   "chrome://browser/content/browser-data-submission-info-bar.js",
 #endif
 #ifndef MOZILLA_OFFICIAL
   "chrome://browser/content/browser-development-helpers.js",
 #endif
 ]) {
   Services.scriptloader.loadSubScript(script, this);
diff --git a/browser/base/content/tabbrowser.xml.orig b/browser/base/content/tabbrowser.xml.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/tabbrowser.xml.orig
@@ -0,0 +1,8700 @@
+<?xml version="1.0"?>
+
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!-- eslint-env mozilla/browser-window -->
+
+<bindings id="tabBrowserBindings"
+          xmlns="http://www.mozilla.org/xbl"
+          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+          xmlns:xbl="http://www.mozilla.org/xbl">
+
+  <binding id="tabbrowser">
+    <resources>
+      <stylesheet src="chrome://browser/content/tabbrowser.css"/>
+    </resources>
+
+    <content>
+      <xul:tabbox anonid="tabbox" class="tabbrowser-tabbox"
+                  flex="1" eventnode="document" xbl:inherits="tabcontainer"
+                  onselect="if (event.target.localName == 'tabpanels') this.parentNode.updateCurrentBrowser();">
+        <xul:tabpanels flex="1" class="plain" selectedIndex="0" anonid="panelcontainer">
+          <xul:notificationbox flex="1" notificationside="top">
+            <xul:hbox flex="1" class="browserSidebarContainer">
+              <xul:vbox flex="1" class="browserContainer">
+                <xul:stack flex="1" class="browserStack" anonid="browserStack">
+                  <xul:browser anonid="initialBrowser" type="content" message="true" messagemanagergroup="browsers"
+                               primary="true" blank="true"
+                               xbl:inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup,selectmenulist,datetimepicker"/>
+                </xul:stack>
+              </xul:vbox>
+            </xul:hbox>
+          </xul:notificationbox>
+        </xul:tabpanels>
+      </xul:tabbox>
+      <children/>
+    </content>
+    <implementation implements="nsIDOMEventListener, nsIMessageListener, nsIObserver">
+
+      <property name="tabContextMenu" readonly="true"
+                onget="return this.tabContainer.contextMenu;"/>
+
+      <field name="tabContainer" readonly="true">
+        document.getElementById(this.getAttribute("tabcontainer"));
+      </field>
+      <field name="tabs" readonly="true">
+        this.tabContainer.childNodes;
+      </field>
+
+      <property name="visibleTabs" readonly="true">
+        <getter><![CDATA[
+          if (!this._visibleTabs)
+            this._visibleTabs = Array.filter(this.tabs,
+                                             tab => !tab.hidden && !tab.closing);
+          return this._visibleTabs;
+        ]]></getter>
+      </property>
+
+      <field name="closingTabsEnum" readonly="true">({ ALL: 0, OTHER: 1, TO_END: 2 });</field>
+
+      <field name="_visibleTabs">null</field>
+
+      <field name="mURIFixup" readonly="true">
+        Components.classes["@mozilla.org/docshell/urifixup;1"]
+                  .getService(Components.interfaces.nsIURIFixup);
+      </field>
+      <field name="_unifiedComplete" readonly="true">
+         Components.classes["@mozilla.org/autocomplete/search;1?name=unifiedcomplete"]
+                   .getService(Components.interfaces.mozIPlacesAutoComplete);
+      </field>
+      <field name="tabbox" readonly="true">
+        document.getAnonymousElementByAttribute(this, "anonid", "tabbox");
+      </field>
+      <field name="mPanelContainer" readonly="true">
+        document.getAnonymousElementByAttribute(this, "anonid", "panelcontainer");
+      </field>
+      <field name="mCurrentTab">
+        null
+      </field>
+      <field name="_lastRelatedTabMap">
+        new WeakMap();
+      </field>
+      <field name="mCurrentBrowser">
+        null
+      </field>
+      <field name="mProgressListeners">
+        []
+      </field>
+      <field name="mTabsProgressListeners">
+        []
+      </field>
+      <field name="_tabListeners">
+        new Map()
+      </field>
+      <field name="_tabFilters">
+        new Map()
+      </field>
+      <field name="mIsBusy">
+        false
+      </field>
+      <field name="_outerWindowIDBrowserMap">
+        new Map();
+      </field>
+      <field name="arrowKeysShouldWrap" readonly="true">
+        AppConstants == "macosx";
+      </field>
+
+      <field name="_autoScrollPopup">
+        null
+      </field>
+
+      <field name="_previewMode">
+        false
+      </field>
+
+      <field name="_lastFindValue">
+        ""
+      </field>
+
+      <field name="_contentWaitingCount">
+        0
+      </field>
+
+      <field name="tabAnimationsInProgress">
+        0
+      </field>
+
+      <property name="_numPinnedTabs" readonly="true">
+        <getter><![CDATA[
+          for (var i = 0; i < this.tabs.length; i++) {
+            if (!this.tabs[i].pinned)
+              break;
+          }
+          return i;
+        ]]></getter>
+      </property>
+
+      <property name="popupAnchor" readonly="true">
+        <getter><![CDATA[
+        if (this.mCurrentTab._popupAnchor) {
+          return this.mCurrentTab._popupAnchor;
+        }
+        let stack = this.mCurrentBrowser.parentNode;
+        // Create an anchor for the popup
+        const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+        let popupAnchor = document.createElementNS(NS_XUL, "hbox");
+        popupAnchor.className = "popup-anchor";
+        popupAnchor.hidden = true;
+        stack.appendChild(popupAnchor);
+        return this.mCurrentTab._popupAnchor = popupAnchor;
+        ]]></getter>
+      </property>
+
+      <method name="isFindBarInitialized">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          return (aTab || this.selectedTab)._findBar != undefined;
+        ]]></body>
+      </method>
+
+      <method name="getFindBar">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          if (!aTab)
+            aTab = this.selectedTab;
+
+          if (aTab._findBar)
+            return aTab._findBar;
+
+          let findBar = document.createElementNS(this.namespaceURI, "findbar");
+          let browser = this.getBrowserForTab(aTab);
+          let browserContainer = this.getBrowserContainer(browser);
+          browserContainer.appendChild(findBar);
+
+          // Force a style flush to ensure that our binding is attached.
+          findBar.clientTop;
+
+          findBar.browser = browser;
+          findBar._findField.value = this._lastFindValue;
+
+          aTab._findBar = findBar;
+
+          let event = document.createEvent("Events");
+          event.initEvent("TabFindInitialized", true, false);
+          aTab.dispatchEvent(event);
+
+          return findBar;
+        ]]></body>
+      </method>
+
+      <method name="getStatusPanel">
+        <body><![CDATA[
+          if (!this._statusPanel) {
+            this._statusPanel = document.createElementNS(this.namespaceURI, "statuspanel");
+            this._statusPanel.setAttribute("inactive", "true");
+            this._statusPanel.setAttribute("layer", "true");
+            this._appendStatusPanel();
+          }
+          return this._statusPanel;
+        ]]></body>
+      </method>
+
+      <method name="_appendStatusPanel">
+        <body><![CDATA[
+          if (this._statusPanel) {
+            let browser = this.selectedBrowser;
+            let browserContainer = this.getBrowserContainer(browser);
+            browserContainer.insertBefore(this._statusPanel, browser.parentNode.nextSibling);
+          }
+        ]]></body>
+      </method>
+
+      <method name="pinTab">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          if (aTab.pinned)
+            return;
+
+          if (aTab.hidden)
+            this.showTab(aTab);
+
+          this.moveTabTo(aTab, this._numPinnedTabs);
+          aTab.setAttribute("pinned", "true");
+          this.tabContainer._unlockTabSizing();
+          this.tabContainer._positionPinnedTabs();
+          this.tabContainer._updateCloseButtons();
+
+          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: true });
+
+          let event = document.createEvent("Events");
+          event.initEvent("TabPinned", true, false);
+          aTab.dispatchEvent(event);
+        ]]></body>
+      </method>
+
+      <method name="unpinTab">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          if (!aTab.pinned)
+            return;
+
+          this.moveTabTo(aTab, this._numPinnedTabs - 1);
+          aTab.removeAttribute("pinned");
+          aTab.style.marginInlineStart = "";
+          this.tabContainer._unlockTabSizing();
+          this.tabContainer._positionPinnedTabs();
+          this.tabContainer._updateCloseButtons();
+
+          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: false });
+
+          let event = document.createEvent("Events");
+          event.initEvent("TabUnpinned", true, false);
+          aTab.dispatchEvent(event);
+        ]]></body>
+      </method>
+
+      <method name="previewTab">
+        <parameter name="aTab"/>
+        <parameter name="aCallback"/>
+        <body>
+          <![CDATA[
+            let currentTab = this.selectedTab;
+            try {
+              // Suppress focus, ownership and selected tab changes
+              this._previewMode = true;
+              this.selectedTab = aTab;
+              aCallback();
+            } finally {
+              this.selectedTab = currentTab;
+              this._previewMode = false;
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="syncThrobberAnimations">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            BrowserUtils.promiseLayoutFlushed(aTab.ownerDocument, "style", () => {
+              if (!aTab.parentNode) {
+                return;
+              }
+
+              const animations =
+                Array.from(aTab.parentNode.getElementsByTagName("tab"))
+                .map(tab => {
+                  const throbber =
+                    document.getAnonymousElementByAttribute(tab, "anonid", "tab-throbber");
+                  return throbber ? throbber.getAnimations({ subtree: true }) : [];
+                })
+                .reduce((a, b) => a.concat(b))
+                .filter(anim =>
+                  anim instanceof CSSAnimation &&
+                  (anim.animationName === "tab-throbber-animation" ||
+                   anim.animationName === "tab-throbber-animation-rtl") &&
+                  (anim.playState === "running" || anim.playState === "pending"));
+
+              // Synchronize with the oldest running animation, if any.
+              const firstStartTime = Math.min(
+                ...animations.map(anim => anim.startTime === null ? Infinity : anim.startTime)
+              );
+              if (firstStartTime === Infinity) {
+                return;
+              }
+              requestAnimationFrame(() => {
+                for (let animation of animations) {
+                  // If |animation| has been cancelled since this rAF callback
+                  // was scheduled we don't want to set its startTime since
+                  // that would restart it. We check for a cancelled animation
+                  // by looking for a null currentTime rather than checking
+                  // the playState, since reading the playState of
+                  // a CSSAnimation object will flush style.
+                  if (animation.currentTime !== null) {
+                    animation.startTime = firstStartTime;
+                  }
+                }
+              });
+            });
+          ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserAtIndex">
+        <parameter name="aIndex"/>
+        <body>
+          <![CDATA[
+            return this.browsers[aIndex];
+          ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserIndexForDocument">
+        <parameter name="aDocument"/>
+        <body>
+          <![CDATA[
+            var tab = this._getTabForContentWindow(aDocument.defaultView);
+            return tab ? tab._tPos : -1;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserForDocument">
+        <parameter name="aDocument"/>
+        <body>
+          <![CDATA[
+            var tab = this._getTabForContentWindow(aDocument.defaultView);
+            return tab ? tab.linkedBrowser : null;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserForContentWindow">
+        <parameter name="aWindow"/>
+        <body>
+          <![CDATA[
+            var tab = this._getTabForContentWindow(aWindow);
+            return tab ? tab.linkedBrowser : null;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserForOuterWindowID">
+        <parameter name="aID"/>
+        <body>
+          <![CDATA[
+            return this._outerWindowIDBrowserMap.get(aID);
+          ]]>
+        </body>
+      </method>
+
+      <method name="_getTabForContentWindow">
+        <parameter name="aWindow"/>
+        <body>
+        <![CDATA[
+          // When not using remote browsers, we can take a fast path by getting
+          // directly from the content window to the browser without looping
+          // over all browsers.
+          if (!gMultiProcessBrowser) {
+            let browser = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                                 .getInterface(Ci.nsIWebNavigation)
+                                 .QueryInterface(Ci.nsIDocShell)
+                                 .chromeEventHandler;
+            return this.getTabForBrowser(browser);
+          }
+
+          for (let i = 0; i < this.browsers.length; i++) {
+            // NB: We use contentWindowAsCPOW so that this code works both
+            // for remote browsers as well. aWindow may be a CPOW.
+            if (this.browsers[i].contentWindowAsCPOW == aWindow)
+              return this.tabs[i];
+          }
+          return null;
+        ]]>
+        </body>
+      </method>
+
+      <!-- Binding from browser to tab -->
+      <field name="_tabForBrowser" readonly="true">
+      <![CDATA[
+        new WeakMap();
+      ]]>
+      </field>
+
+      <method name="getTabForBrowser">
+        <parameter name="aBrowser"/>
+        <body>
+        <![CDATA[
+          return this._tabForBrowser.get(aBrowser);
+        ]]>
+        </body>
+      </method>
+
+      <method name="getNotificationBox">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            return this.getSidebarContainer(aBrowser).parentNode;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getSidebarContainer">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            return this.getBrowserContainer(aBrowser).parentNode;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserContainer">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            return (aBrowser || this.mCurrentBrowser).parentNode.parentNode;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getTabModalPromptBox">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            let browser = (aBrowser || this.mCurrentBrowser);
+            if (!browser.tabModalPromptBox) {
+              browser.tabModalPromptBox = new TabModalPromptBox(browser);
+            }
+            return browser.tabModalPromptBox;
+          ]]>
+        </body>
+      </method>
+
+      <method name="getTabFromAudioEvent">
+        <parameter name="aEvent"/>
+        <body>
+        <![CDATA[
+          if (!Services.prefs.getBoolPref("browser.tabs.showAudioPlayingIcon") ||
+              !aEvent.isTrusted) {
+            return null;
+          }
+
+          var browser = aEvent.originalTarget;
+          var tab = this.getTabForBrowser(browser);
+          return tab;
+        ]]>
+        </body>
+      </method>
+
+      <method name="_callProgressListeners">
+        <parameter name="aBrowser"/>
+        <parameter name="aMethod"/>
+        <parameter name="aArguments"/>
+        <parameter name="aCallGlobalListeners"/>
+        <parameter name="aCallTabsListeners"/>
+        <body><![CDATA[
+          var rv = true;
+
+          function callListeners(listeners, args) {
+            for (let p of listeners) {
+              if (aMethod in p) {
+                try {
+                  if (!p[aMethod].apply(p, args))
+                    rv = false;
+                } catch (e) {
+                  // don't inhibit other listeners
+                  Components.utils.reportError(e);
+                }
+              }
+            }
+          }
+
+          if (!aBrowser)
+            aBrowser = this.mCurrentBrowser;
+
+          if (aCallGlobalListeners != false &&
+              aBrowser == this.mCurrentBrowser) {
+            callListeners(this.mProgressListeners, aArguments);
+          }
+
+          if (aCallTabsListeners != false) {
+            aArguments.unshift(aBrowser);
+
+            callListeners(this.mTabsProgressListeners, aArguments);
+          }
+
+          return rv;
+        ]]></body>
+      </method>
+
+      <!-- Determine if a URI is an about: page pointing to a local resource. -->
+      <method name="_isLocalAboutURI">
+        <parameter name="aURI"/>
+        <parameter name="aResolvedURI"/>
+        <body><![CDATA[
+          if (!aURI.schemeIs("about")) {
+            return false;
+          }
+
+          // Specially handle about:blank as local
+          if (aURI.pathQueryRef === "blank") {
+            return true;
+          }
+
+          try {
+            // Use the passed in resolvedURI if we have one
+            const resolvedURI = aResolvedURI || Services.io.newChannelFromURI2(
+              aURI,
+              null, // loadingNode
+              Services.scriptSecurityManager.getSystemPrincipal(), // loadingPrincipal
+              null, // triggeringPrincipal
+              Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL, // securityFlags
+              Ci.nsIContentPolicy.TYPE_OTHER // contentPolicyType
+            ).URI;
+            return resolvedURI.schemeIs("jar") || resolvedURI.schemeIs("file");
+          } catch (ex) {
+            // aURI might be invalid.
+            return false;
+          }
+        ]]></body>
+      </method>
+
+      <!-- A web progress listener object definition for a given tab. -->
+      <method name="mTabProgressListener">
+        <parameter name="aTab"/>
+        <parameter name="aBrowser"/>
+        <parameter name="aStartsBlank"/>
+        <parameter name="aWasPreloadedBrowser"/>
+        <parameter name="aOrigStateFlags"/>
+        <body>
+        <![CDATA[
+          let stateFlags = aOrigStateFlags || 0;
+          // Initialize mStateFlags to non-zero e.g. when creating a progress
+          // listener for preloaded browsers as there was no progress listener
+          // around when the content started loading. If the content didn't
+          // quite finish loading yet, mStateFlags will very soon be overridden
+          // with the correct value and end up at STATE_STOP again.
+          if (aWasPreloadedBrowser) {
+            stateFlags = Ci.nsIWebProgressListener.STATE_STOP |
+                         Ci.nsIWebProgressListener.STATE_IS_REQUEST;
+          }
+
+          return ({
+            mTabBrowser: this,
+            mTab: aTab,
+            mBrowser: aBrowser,
+            mBlank: aStartsBlank,
+
+            // cache flags for correct status UI update after tab switching
+            mStateFlags: stateFlags,
+            mStatus: 0,
+            mMessage: "",
+            mTotalProgress: 0,
+
+            // count of open requests (should always be 0 or 1)
+            mRequestCount: 0,
+
+            destroy() {
+              delete this.mTab;
+              delete this.mBrowser;
+              delete this.mTabBrowser;
+            },
+
+            _callProgressListeners() {
+              Array.unshift(arguments, this.mBrowser);
+              return this.mTabBrowser._callProgressListeners.apply(this.mTabBrowser, arguments);
+            },
+
+            _shouldShowProgress(aRequest) {
+              if (this.mBlank)
+                return false;
+
+              // Don't show progress indicators in tabs for about: URIs
+              // pointing to local resources.
+              if ((aRequest instanceof Ci.nsIChannel) &&
+                  this.mTabBrowser._isLocalAboutURI(aRequest.originalURI, aRequest.URI)) {
+                return false;
+              }
+
+              return true;
+            },
+
+            _isForInitialAboutBlank(aWebProgress, aStateFlags, aLocation) {
+              if (!this.mBlank || !aWebProgress.isTopLevel) {
+                return false;
+              }
+
+              // If the state has STATE_STOP, and no requests were in flight, then this
+              // must be the initial "stop" for the initial about:blank document.
+              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
+              if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
+                  this.mRequestCount == 0 &&
+                  !aLocation) {
+                return true;
+              }
+
+              let location = aLocation ? aLocation.spec : "";
+              return location == "about:blank";
+            },
+
+            onProgressChange(aWebProgress, aRequest,
+                             aCurSelfProgress, aMaxSelfProgress,
+                             aCurTotalProgress, aMaxTotalProgress) {
+              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
+
+              if (!this._shouldShowProgress(aRequest))
+                return;
+
+              if (this.mTotalProgress && this.mTab.hasAttribute("busy"))
+                this.mTab.setAttribute("progress", "true");
+
+              this._callProgressListeners("onProgressChange",
+                                          [aWebProgress, aRequest,
+                                           aCurSelfProgress, aMaxSelfProgress,
+                                           aCurTotalProgress, aMaxTotalProgress]);
+            },
+
+            onProgressChange64(aWebProgress, aRequest,
+                               aCurSelfProgress, aMaxSelfProgress,
+                               aCurTotalProgress, aMaxTotalProgress) {
+              return this.onProgressChange(aWebProgress, aRequest,
+                aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
+                aMaxTotalProgress);
+            },
+
+            onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+              if (!aRequest)
+                return;
+
+              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
+              const nsIChannel = Components.interfaces.nsIChannel;
+              let location, originalLocation;
+              try {
+                aRequest.QueryInterface(nsIChannel);
+                location = aRequest.URI;
+                originalLocation = aRequest.originalURI;
+              } catch (ex) {}
+
+              let ignoreBlank = this._isForInitialAboutBlank(aWebProgress, aStateFlags,
+                                                             location);
+
+              // If we were ignoring some messages about the initial about:blank, and we
+              // got the STATE_STOP for it, we'll want to pay attention to those messages
+              // from here forward. Similarly, if we conclude that this state change
+              // is one that we shouldn't be ignoring, then stop ignoring.
+              if ((ignoreBlank &&
+                   aStateFlags & nsIWebProgressListener.STATE_STOP &&
+                   aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) ||
+                  !ignoreBlank && this.mBlank) {
+                this.mBlank = false;
+              }
+
+              if (aStateFlags & nsIWebProgressListener.STATE_START) {
+                this.mRequestCount++;
+              } else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
+                const NS_ERROR_UNKNOWN_HOST = 2152398878;
+                if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
+                  // to prevent bug 235825: wait for the request handled
+                  // by the automatic keyword resolver
+                  return;
+                }
+                // since we (try to) only handle STATE_STOP of the last request,
+                // the count of open requests should now be 0
+                this.mRequestCount = 0;
+              }
+
+              if (aStateFlags & nsIWebProgressListener.STATE_START &&
+                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
+                if (aWebProgress.isTopLevel) {
+                  // Need to use originalLocation rather than location because things
+                  // like about:home and about:privatebrowsing arrive with nsIRequest
+                  // pointing to their resolved jar: or file: URIs.
+                  if (!(originalLocation && gInitialPages.includes(originalLocation.spec) &&
+                        originalLocation != "about:blank" &&
+                        this.mBrowser.initialPageLoadedFromURLBar != originalLocation.spec &&
+                        this.mBrowser.currentURI && this.mBrowser.currentURI.spec == "about:blank")) {
+                    // Indicating that we started a load will allow the location
+                    // bar to be cleared when the load finishes.
+                    // In order to not overwrite user-typed content, we avoid it
+                    // (see if condition above) in a very specific case:
+                    // If the load is of an 'initial' page (e.g. about:privatebrowsing,
+                    // about:newtab, etc.), was not explicitly typed in the location
+                    // bar by the user, is not about:blank (because about:blank can be
+                    // loaded by websites under their principal), and the current
+                    // page in the browser is about:blank (indicating it is a newly
+                    // created or re-created browser, e.g. because it just switched
+                    // remoteness or is a new tab/window).
+                    this.mBrowser.urlbarChangeTracker.startedLoad();
+                  }
+                  delete this.mBrowser.initialPageLoadedFromURLBar;
+                  // If the browser is loading it must not be crashed anymore
+                  this.mTab.removeAttribute("crashed");
+                }
+
+                if (this._shouldShowProgress(aRequest)) {
+                  if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING) &&
+                      aWebProgress && aWebProgress.isTopLevel) {
+                    this.mTab.setAttribute("busy", "true");
+                    this.mTab._notselectedsinceload = !this.mTab.selected;
+                    SchedulePressure.startMonitoring(window, {
+                      highPressureFn() {
+                        // Only switch back to the SVG loading indicator after getting
+                        // three consecutive low pressure callbacks. Used to prevent
+                        // switching quickly between the SVG and APNG loading indicators.
+                        gBrowser.tabContainer._schedulePressureCount = gBrowser.schedulePressureDefaultCount;
+                        gBrowser.tabContainer.setAttribute("schedulepressure", "true");
+                      },
+                      lowPressureFn() {
+                        if (!gBrowser.tabContainer._schedulePressureCount ||
+                            --gBrowser.tabContainer._schedulePressureCount <= 0) {
+                          gBrowser.tabContainer.removeAttribute("schedulepressure");
+                        }
+
+                        // If tabs are closed while they are loading we need to
+                        // stop monitoring schedule pressure. We don't stop monitoring
+                        // during high pressure times because we want to eventually
+                        // return to the SVG tab loading animations.
+                        let continueMonitoring = true;
+                        if (!document.querySelector(".tabbrowser-tab[busy]")) {
+                          SchedulePressure.stopMonitoring(window);
+                          continueMonitoring = false;
+                        }
+                        return {continueMonitoring};
+                      },
+                    });
+                    this.mTabBrowser.syncThrobberAnimations(this.mTab);
+                  }
+
+                  if (this.mTab.selected) {
+                    this.mTabBrowser.mIsBusy = true;
+                  }
+                }
+              } else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
+                         aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
+
+                if (this.mTab.hasAttribute("busy")) {
+                  this.mTab.removeAttribute("busy");
+                  if (!document.querySelector(".tabbrowser-tab[busy]")) {
+                    SchedulePressure.stopMonitoring(window);
+                    this.mTabBrowser.tabContainer.removeAttribute("schedulepressure");
+                  }
+
+                  // Only animate the "burst" indicating the page has loaded if
+                  // the top-level page is the one that finished loading.
+                  if (aWebProgress.isTopLevel && !aWebProgress.isLoadingDocument &&
+                      Components.isSuccessCode(aStatus) &&
+                      !this.mTabBrowser.tabAnimationsInProgress &&
+                      Services.prefs.getBoolPref("toolkit.cosmeticAnimations.enabled")) {
+                    if (this.mTab._notselectedsinceload) {
+                      this.mTab.setAttribute("notselectedsinceload", "true");
+                    } else {
+                      this.mTab.removeAttribute("notselectedsinceload");
+                    }
+
+                    this.mTab.setAttribute("bursting", "true");
+                  }
+
+                  this.mTabBrowser._tabAttrModified(this.mTab, ["busy"]);
+                  if (!this.mTab.selected)
+                    this.mTab.setAttribute("unread", "true");
+                }
+                this.mTab.removeAttribute("progress");
+
+                if (aWebProgress.isTopLevel) {
+                  let isSuccessful = Components.isSuccessCode(aStatus);
+                  if (!isSuccessful && !isTabEmpty(this.mTab)) {
+                    // Restore the current document's location in case the
+                    // request was stopped (possibly from a content script)
+                    // before the location changed.
+
+                    this.mBrowser.userTypedValue = null;
+
+                    let inLoadURI = this.mBrowser.inLoadURI;
+                    if (this.mTab.selected && gURLBar && !inLoadURI) {
+                      URLBarSetURI();
+                    }
+                  } else if (isSuccessful) {
+                    this.mBrowser.urlbarChangeTracker.finishedLoad();
+                  }
+
+                  // Ignore initial about:blank to prevent flickering.
+                  if (!this.mBrowser.mIconURL && !ignoreBlank) {
+                    this.mTabBrowser.useDefaultIcon(this.mTab);
+                  }
+                }
+
+                // For keyword URIs clear the user typed value since they will be changed into real URIs
+                if (location.scheme == "keyword")
+                  this.mBrowser.userTypedValue = null;
+
+                if (this.mTab.selected)
+                  this.mTabBrowser.mIsBusy = false;
+              }
+
+              if (ignoreBlank) {
+                this._callProgressListeners("onUpdateCurrentBrowser",
+                                            [aStateFlags, aStatus, "", 0],
+                                            true, false);
+              } else {
+                this._callProgressListeners("onStateChange",
+                                            [aWebProgress, aRequest, aStateFlags, aStatus],
+                                            true, false);
+              }
+
+              this._callProgressListeners("onStateChange",
+                                          [aWebProgress, aRequest, aStateFlags, aStatus],
+                                          false);
+
+              if (aStateFlags & (nsIWebProgressListener.STATE_START |
+                                 nsIWebProgressListener.STATE_STOP)) {
+                // reset cached temporary values at beginning and end
+                this.mMessage = "";
+                this.mTotalProgress = 0;
+              }
+              this.mStateFlags = aStateFlags;
+              this.mStatus = aStatus;
+            },
+
+            onLocationChange(aWebProgress, aRequest, aLocation,
+                             aFlags) {
+              // OnLocationChange is called for both the top-level content
+              // and the subframes.
+              let topLevel = aWebProgress.isTopLevel;
+
+              if (topLevel) {
+                let isSameDocument =
+                  !!(aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT);
+                // We need to clear the typed value
+                // if the document failed to load, to make sure the urlbar reflects the
+                // failed URI (particularly for SSL errors). However, don't clear the value
+                // if the error page's URI is about:blank, because that causes complete
+                // loss of urlbar contents for invalid URI errors (see bug 867957).
+                // Another reason to clear the userTypedValue is if this was an anchor
+                // navigation initiated by the user.
+                if (this.mBrowser.didStartLoadSinceLastUserTyping() ||
+                    ((aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE) &&
+                     aLocation.spec != "about:blank") ||
+                    (isSameDocument && this.mBrowser.inLoadURI)) {
+                  this.mBrowser.userTypedValue = null;
+                }
+
+                // If the tab has been set to "busy" outside the stateChange
+                // handler below (e.g. by sessionStore.navigateAndRestore), and
+                // the load results in an error page, it's possible that there
+                // isn't any (STATE_IS_NETWORK & STATE_STOP) state to cause busy
+                // attribute being removed. In this case we should remove the
+                // attribute here.
+                if ((aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE) &&
+                    this.mTab.hasAttribute("busy")) {
+                  this.mTab.removeAttribute("busy");
+                  this.mTabBrowser._tabAttrModified(this.mTab, ["busy"]);
+                }
+
+                // If the browser was playing audio, we should remove the playing state.
+                if (this.mTab.hasAttribute("soundplaying") && !isSameDocument) {
+                  clearTimeout(this.mTab._soundPlayingAttrRemovalTimer);
+                  this.mTab._soundPlayingAttrRemovalTimer = 0;
+                  this.mTab.removeAttribute("soundplaying");
+                  this.mTabBrowser._tabAttrModified(this.mTab, ["soundplaying"]);
+                }
+
+                // If the browser was previously muted, we should restore the muted state.
+                if (this.mTab.hasAttribute("muted")) {
+                  this.mTab.linkedBrowser.mute();
+                }
+
+                if (this.mTabBrowser.isFindBarInitialized(this.mTab)) {
+                  let findBar = this.mTabBrowser.getFindBar(this.mTab);
+
+                  // Close the Find toolbar if we're in old-style TAF mode
+                  if (findBar.findMode != findBar.FIND_NORMAL) {
+                    findBar.close();
+                  }
+                }
+
+                this.mTabBrowser.setTabTitle(this.mTab);
+
+                // Don't clear the favicon if this tab is in the pending
+                // state, as SessionStore will have set the icon for us even
+                // though we're pointed at an about:blank. Also don't clear it
+                // if onLocationChange was triggered by a pushState or a
+                // replaceState (bug 550565) or a hash change (bug 408415).
+                if (!this.mTab.hasAttribute("pending") &&
+                    aWebProgress.isLoadingDocument &&
+                    !isSameDocument) {
+                  this.mBrowser.mIconURL = null;
+                }
+
+                let userContextId = this.mBrowser.getAttribute("usercontextid") || 0;
+                if (this.mBrowser.registeredOpenURI) {
+                  this.mTabBrowser._unifiedComplete
+                                  .unregisterOpenPage(this.mBrowser.registeredOpenURI,
+                                                      userContextId);
+                  delete this.mBrowser.registeredOpenURI;
+                }
+                // Tabs in private windows aren't registered as "Open" so
+                // that they don't appear as switch-to-tab candidates.
+                if (!isBlankPageURL(aLocation.spec) &&
+                    (!PrivateBrowsingUtils.isWindowPrivate(window) ||
+                    PrivateBrowsingUtils.permanentPrivateBrowsing)) {
+                  this.mTabBrowser._unifiedComplete
+                                  .registerOpenPage(aLocation, userContextId);
+                  this.mBrowser.registeredOpenURI = aLocation;
+                }
+              }
+
+              if (!this.mBlank) {
+                this._callProgressListeners("onLocationChange",
+                                            [aWebProgress, aRequest, aLocation,
+                                             aFlags]);
+              }
+
+              if (topLevel) {
+                this.mBrowser.lastURI = aLocation;
+                this.mBrowser.lastLocationChange = Date.now();
+              }
+            },
+
+            onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
+              if (this.mBlank)
+                return;
+
+              this._callProgressListeners("onStatusChange",
+                                          [aWebProgress, aRequest, aStatus, aMessage]);
+
+              this.mMessage = aMessage;
+            },
+
+            onSecurityChange(aWebProgress, aRequest, aState) {
+              this._callProgressListeners("onSecurityChange",
+                                          [aWebProgress, aRequest, aState]);
+            },
+
+            onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI) {
+              return this._callProgressListeners("onRefreshAttempted",
+                                                 [aWebProgress, aURI, aDelay, aSameURI]);
+            },
+
+            QueryInterface(aIID) {
+              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
+                  aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
+                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
+                  aIID.equals(Components.interfaces.nsISupports))
+                return this;
+              throw Components.results.NS_NOINTERFACE;
+            }
+          });
+        ]]>
+        </body>
+      </method>
+
+      <field name="serializationHelper">
+        Cc["@mozilla.org/network/serialization-helper;1"]
+          .getService(Ci.nsISerializationHelper);
+      </field>
+
+      <method name="storeIcon">
+        <parameter name="aBrowser"/>
+        <parameter name="aURI"/>
+        <parameter name="aLoadingPrincipal"/>
+        <parameter name="aRequestContextID"/>
+        <body>
+          <![CDATA[
+          try {
+            if (!(aURI instanceof Ci.nsIURI)) {
+              aURI = makeURI(aURI);
+            }
+            PlacesUIUtils.loadFavicon(aBrowser, aLoadingPrincipal, aURI, aRequestContextID);
+          } catch (ex) {
+            Components.utils.reportError(ex);
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="setIcon">
+        <parameter name="aTab"/>
+        <parameter name="aURI"/>
+        <parameter name="aLoadingPrincipal"/>
+        <parameter name="aRequestContextID"/>
+        <body>
+          <![CDATA[
+            let browser = this.getBrowserForTab(aTab);
+            browser.mIconURL = aURI instanceof Ci.nsIURI ? aURI.spec : aURI;
+            let loadingPrincipal = aLoadingPrincipal ||
+                                   Services.scriptSecurityManager.getSystemPrincipal();
+            let requestContextID = aRequestContextID || 0;
+            let sizedIconUrl = browser.mIconURL || "";
+            if (sizedIconUrl != aTab.getAttribute("image")) {
+              if (sizedIconUrl) {
+                if (!browser.mIconLoadingPrincipal ||
+                    !browser.mIconLoadingPrincipal.equals(loadingPrincipal)) {
+                  aTab.setAttribute("iconloadingprincipal",
+                    this.serializationHelper.serializeToString(loadingPrincipal));
+                  aTab.setAttribute("requestcontextid", requestContextID);
+                  browser.mIconLoadingPrincipal = loadingPrincipal;
+                }
+                aTab.setAttribute("image", sizedIconUrl);
+              } else {
+                aTab.removeAttribute("iconloadingprincipal");
+                delete browser.mIconLoadingPrincipal;
+                aTab.removeAttribute("image");
+              }
+              this._tabAttrModified(aTab, ["image"]);
+            }
+
+            this._callProgressListeners(browser, "onLinkIconAvailable", [browser.mIconURL]);
+          ]]>
+        </body>
+      </method>
+
+      <method name="getIcon">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            let browser = aTab ? this.getBrowserForTab(aTab) : this.selectedBrowser;
+            return browser.mIconURL;
+          ]]>
+        </body>
+      </method>
+
+      <method name="setPageInfo">
+        <parameter name="aURL"/>
+        <parameter name="aDescription"/>
+        <parameter name="aPreviewImage"/>
+        <body>
+          <![CDATA[
+            if (aURL) {
+              let pageInfo = {url: aURL, description: aDescription, previewImageURL: aPreviewImage};
+              PlacesUtils.history.update(pageInfo).catch(Components.utils.reportError);
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="shouldLoadFavIcon">
+        <parameter name="aURI"/>
+        <body>
+          <![CDATA[
+            return (aURI &&
+                    Services.prefs.getBoolPref("browser.chrome.site_icons") &&
+                    Services.prefs.getBoolPref("browser.chrome.favicons") &&
+                    ("schemeIs" in aURI) && (aURI.schemeIs("http") || aURI.schemeIs("https")));
+          ]]>
+        </body>
+      </method>
+
+      <method name="useDefaultIcon">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            let browser = this.getBrowserForTab(aTab);
+            let documentURI = browser.documentURI;
+            let requestContextID = browser.contentRequestContextID;
+            let loadingPrincipal = browser.contentPrincipal;
+            let icon = null;
+
+            if (browser.imageDocument) {
+              if (Services.prefs.getBoolPref("browser.chrome.site_icons")) {
+                let sz = Services.prefs.getIntPref("browser.chrome.image_icons.max_size");
+                if (browser.imageDocument.width <= sz &&
+                    browser.imageDocument.height <= sz) {
+                  // Don't try to store the icon in Places, regardless it would
+                  // be skipped (see Bug 403651).
+                  icon = browser.currentURI;
+                }
+              }
+            }
+
+            // Use documentURIObject in the check for shouldLoadFavIcon so that we
+            // do the right thing with about:-style error pages.  Bug 453442
+            if (!icon && this.shouldLoadFavIcon(documentURI)) {
+              let url = documentURI.prePath + "/favicon.ico";
+              if (!this.isFailedIcon(url)) {
+                icon = url;
+                this.storeIcon(browser, icon, loadingPrincipal, requestContextID);
+              }
+            }
+
+            this.setIcon(aTab, icon, loadingPrincipal, requestContextID);
+          ]]>
+        </body>
+      </method>
+
+      <method name="isFailedIcon">
+        <parameter name="aURI"/>
+        <body>
+          <![CDATA[
+            if (!(aURI instanceof Ci.nsIURI))
+              aURI = makeURI(aURI);
+            return PlacesUtils.favicons.isFailedFavicon(aURI);
+          ]]>
+        </body>
+      </method>
+
+      <method name="getWindowTitleForBrowser">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            var newTitle = "";
+            var docElement = this.ownerDocument.documentElement;
+            var sep = docElement.getAttribute("titlemenuseparator");
+            let tab = this.getTabForBrowser(aBrowser);
+            let docTitle;
+
+            if (tab._labelIsContentTitle) {
+              // Strip out any null bytes in the content title, since the
+              // underlying widget implementations of nsWindow::SetTitle pass
+              // null-terminated strings to system APIs.
+              docTitle = tab.getAttribute("label").replace(/\0/g, "");
+            }
+
+            if (!docTitle)
+              docTitle = docElement.getAttribute("titledefault");
+
+            var modifier = docElement.getAttribute("titlemodifier");
+            if (docTitle) {
+              newTitle += docElement.getAttribute("titlepreface");
+              newTitle += docTitle;
+              if (modifier)
+                newTitle += sep;
+            }
+            newTitle += modifier;
+
+            // If location bar is hidden and the URL type supports a host,
+            // add the scheme and host to the title to prevent spoofing.
+            // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
+            try {
+              if (docElement.getAttribute("chromehidden").includes("location")) {
+                var uri = this.mURIFixup.createExposableURI(
+                            aBrowser.currentURI);
+                if (uri.scheme == "about")
+                  newTitle = uri.spec + sep + newTitle;
+                else
+                  newTitle = uri.prePath + sep + newTitle;
+              }
+            } catch (e) {}
+
+            return newTitle;
+          ]]>
+        </body>
+      </method>
+
+      <method name="updateTitlebar">
+        <body>
+          <![CDATA[
+            this.ownerDocument.title = this.getWindowTitleForBrowser(this.mCurrentBrowser);
+          ]]>
+        </body>
+      </method>
+
+      <!-- Holds a unique ID for the tab change that's currently being timed.
+           Used to make sure that multiple, rapid tab switches do not try to
+           create overlapping timers. -->
+      <field name="_tabSwitchID">null</field>
+
+      <method name="updateCurrentBrowser">
+        <parameter name="aForceUpdate"/>
+        <body>
+          <![CDATA[
+            var newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);
+            if (this.mCurrentBrowser == newBrowser && !aForceUpdate)
+              return;
+
+            if (!aForceUpdate) {
+              document.commandDispatcher.lock();
+
+              TelemetryStopwatch.start("FX_TAB_SWITCH_UPDATE_MS");
+              if (!gMultiProcessBrowser) {
+                // old way of measuring tab paint which is not valid with e10s.
+                // Waiting until the next MozAfterPaint ensures that we capture
+                // the time it takes to paint, upload the textures to the compositor,
+                // and then composite.
+                if (this._tabSwitchID) {
+                  TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_MS");
+                }
+
+                let tabSwitchID = Symbol();
+
+                TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_MS");
+                this._tabSwitchID = tabSwitchID;
+
+                let onMozAfterPaint = () => {
+                  if (this._tabSwitchID === tabSwitchID) {
+                    TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_MS");
+                    this._tabSwitchID = null;
+                  }
+                  window.removeEventListener("MozAfterPaint", onMozAfterPaint);
+                };
+                window.addEventListener("MozAfterPaint", onMozAfterPaint);
+              }
+            }
+
+            var oldTab = this.mCurrentTab;
+
+            // Preview mode should not reset the owner
+            if (!this._previewMode && !oldTab.selected)
+              oldTab.owner = null;
+
+            let lastRelatedTab = this._lastRelatedTabMap.get(oldTab);
+            if (lastRelatedTab) {
+              if (!lastRelatedTab.selected)
+                lastRelatedTab.owner = null;
+            }
+            this._lastRelatedTabMap = new WeakMap();
+
+            var oldBrowser = this.mCurrentBrowser;
+
+            if (!gMultiProcessBrowser) {
+              oldBrowser.removeAttribute("primary");
+              oldBrowser.docShellIsActive = false;
+              newBrowser.setAttribute("primary", "true");
+              newBrowser.docShellIsActive =
+                (window.windowState != window.STATE_MINIMIZED &&
+                 !window.isFullyOccluded);
+            }
+
+            var updateBlockedPopups = false;
+            if ((oldBrowser.blockedPopups && !newBrowser.blockedPopups) ||
+                (!oldBrowser.blockedPopups && newBrowser.blockedPopups))
+              updateBlockedPopups = true;
+
+            this.mCurrentBrowser = newBrowser;
+            this.mCurrentTab = this.tabContainer.selectedItem;
+            this.showTab(this.mCurrentTab);
+
+            gURLBar.setAttribute("switchingtabs", "true");
+            window.addEventListener("MozAfterPaint", function() {
+              gURLBar.removeAttribute("switchingtabs");
+            }, {once: true});
+
+            this._appendStatusPanel();
+
+            if (updateBlockedPopups)
+              this.mCurrentBrowser.updateBlockedPopups();
+
+            // Update the URL bar.
+            var loc = this.mCurrentBrowser.currentURI;
+
+            var webProgress = this.mCurrentBrowser.webProgress;
+            var securityUI = this.mCurrentBrowser.securityUI;
+
+            this._callProgressListeners(null, "onLocationChange",
+                                        [webProgress, null, loc, 0], true,
+                                        false);
+
+            if (securityUI) {
+              // Include the true final argument to indicate that this event is
+              // simulated (instead of being observed by the webProgressListener).
+              this._callProgressListeners(null, "onSecurityChange",
+                                          [webProgress, null, securityUI.state, true],
+                                          true, false);
+            }
+
+            var listener = this._tabListeners.get(this.mCurrentTab);
+            if (listener && listener.mStateFlags) {
+              this._callProgressListeners(null, "onUpdateCurrentBrowser",
+                                          [listener.mStateFlags, listener.mStatus,
+                                           listener.mMessage, listener.mTotalProgress],
+                                          true, false);
+            }
+
+            if (!this._previewMode) {
+              this.mCurrentTab.updateLastAccessed();
+              this.mCurrentTab.removeAttribute("unread");
+              oldTab.updateLastAccessed();
+
+              let oldFindBar = oldTab._findBar;
+              if (oldFindBar &&
+                  oldFindBar.findMode == oldFindBar.FIND_NORMAL &&
+                  !oldFindBar.hidden)
+                this._lastFindValue = oldFindBar._findField.value;
+
+              this.updateTitlebar();
+
+              this.mCurrentTab.removeAttribute("titlechanged");
+              this.mCurrentTab.removeAttribute("attention");
+
+              // The tab has been selected, it's not unselected anymore.
+              // (1) Call the current tab's finishUnselectedTabHoverTimer()
+              //     to save a telemetry record.
+              // (2) Call the current browser's unselectedTabHover() with false
+              //     to dispatch an event.
+              this.mCurrentTab.finishUnselectedTabHoverTimer();
+              this.mCurrentBrowser.unselectedTabHover(false);
+            }
+
+            // If the new tab is busy, and our current state is not busy, then
+            // we need to fire a start to all progress listeners.
+            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
+            if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
+              this.mIsBusy = true;
+              this._callProgressListeners(null, "onStateChange",
+                                          [webProgress, null,
+                                           nsIWebProgressListener.STATE_START |
+                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],
+                                          true, false);
+            }
+
+            // If the new tab is not busy, and our current state is busy, then
+            // we need to fire a stop to all progress listeners.
+            if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
+              this.mIsBusy = false;
+              this._callProgressListeners(null, "onStateChange",
+                                          [webProgress, null,
+                                           nsIWebProgressListener.STATE_STOP |
+                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],
+                                          true, false);
+            }
+
+            // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code
+            // that might rely upon the other changes suppressed.
+            // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window
+            if (!this._previewMode) {
+              // We've selected the new tab, so go ahead and notify listeners.
+              let event = new CustomEvent("TabSelect", {
+                bubbles: true,
+                cancelable: false,
+                detail: {
+                  previousTab: oldTab
+                }
+              });
+              this.mCurrentTab.dispatchEvent(event);
+
+              this._tabAttrModified(oldTab, ["selected"]);
+              this._tabAttrModified(this.mCurrentTab, ["selected"]);
+
+              if (oldBrowser != newBrowser &&
+                  oldBrowser.getInPermitUnload) {
+                oldBrowser.getInPermitUnload(inPermitUnload => {
+                  if (!inPermitUnload) {
+                    return;
+                  }
+                  // Since the user is switching away from a tab that has
+                  // a beforeunload prompt active, we remove the prompt.
+                  // This prevents confusing user flows like the following:
+                  //   1. User attempts to close Firefox
+                  //   2. User switches tabs (ingoring a beforeunload prompt)
+                  //   3. User returns to tab, presses "Leave page"
+                  let promptBox = this.getTabModalPromptBox(oldBrowser);
+                  let prompts = promptBox.listPrompts();
+                  // There might not be any prompts here if the tab was closed
+                  // while in an onbeforeunload prompt, which will have
+                  // destroyed aforementioned prompt already, so check there's
+                  // something to remove, first:
+                  if (prompts.length) {
+                    // NB: This code assumes that the beforeunload prompt
+                    //     is the top-most prompt on the tab.
+                    prompts[prompts.length - 1].abortPrompt();
+                  }
+                });
+              }
+
+              if (!gMultiProcessBrowser) {
+                this._adjustFocusBeforeTabSwitch(oldTab, this.mCurrentTab);
+                this._adjustFocusAfterTabSwitch(this.mCurrentTab);
+              }
+            }
+
+            updateUserContextUIIndicator();
+            gIdentityHandler.updateSharingIndicator();
+
+            this.tabContainer._setPositionalAttributes();
+
+            // Enable touch events to start a native dragging
+            // session to allow the user to easily drag the selected tab.
+            // This is currently only supported on Windows.
+            oldTab.removeAttribute("touchdownstartsdrag");
+            this.mCurrentTab.setAttribute("touchdownstartsdrag", "true");
+
+            if (!gMultiProcessBrowser) {
+              document.commandDispatcher.unlock();
+
+              let event = new CustomEvent("TabSwitchDone", {
+                bubbles: true,
+                cancelable: true
+              });
+              this.dispatchEvent(event);
+            }
+
+            if (!aForceUpdate)
+              TelemetryStopwatch.finish("FX_TAB_SWITCH_UPDATE_MS");
+          ]]>
+        </body>
+      </method>
+
+      <method name="_adjustFocusBeforeTabSwitch">
+        <parameter name="oldTab"/>
+        <parameter name="newTab"/>
+        <body><![CDATA[
+          if (this._previewMode) {
+            return;
+          }
+
+          let oldBrowser = oldTab.linkedBrowser;
+          let newBrowser = newTab.linkedBrowser;
+
+          oldBrowser._urlbarFocused = (gURLBar && gURLBar.focused);
+
+          if (this.isFindBarInitialized(oldTab)) {
+            let findBar = this.getFindBar(oldTab);
+            oldTab._findBarFocused = (!findBar.hidden &&
+              findBar._findField.getAttribute("focused") == "true");
+          }
+
+          let activeEl = document.activeElement;
+          // If focus is on the old tab, move it to the new tab.
+          if (activeEl == oldTab) {
+            newTab.focus();
+          } else if (gMultiProcessBrowser && activeEl != newBrowser && activeEl != newTab) {
+            // In e10s, if focus isn't already in the tabstrip or on the new browser,
+            // and the new browser's previous focus wasn't in the url bar but focus is
+            // there now, we need to adjust focus further.
+            let keepFocusOnUrlBar = newBrowser &&
+                                    newBrowser._urlbarFocused &&
+                                    gURLBar &&
+                                    gURLBar.focused;
+            if (!keepFocusOnUrlBar) {
+              // Clear focus so that _adjustFocusAfterTabSwitch can detect if
+              // some element has been focused and respect that.
+              document.activeElement.blur();
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="_adjustFocusAfterTabSwitch">
+        <parameter name="newTab"/>
+        <body><![CDATA[
+        // Don't steal focus from the tab bar.
+        if (document.activeElement == newTab)
+          return;
+
+        let newBrowser = this.getBrowserForTab(newTab);
+
+        // If there's a tabmodal prompt showing, focus it.
+        if (newBrowser.hasAttribute("tabmodalPromptShowing")) {
+          let XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+          let prompts = newBrowser.parentNode.getElementsByTagNameNS(XUL_NS, "tabmodalprompt");
+          let prompt = prompts[prompts.length - 1];
+          prompt.Dialog.setDefaultFocus();
+          return;
+        }
+
+        // Focus the location bar if it was previously focused for that tab.
+        // In full screen mode, only bother making the location bar visible
+        // if the tab is a blank one.
+        if (newBrowser._urlbarFocused && gURLBar) {
+          // Explicitly close the popup if the URL bar retains focus
+          gURLBar.closePopup();
+
+          // If the user happened to type into the URL bar for this browser
+          // by the time we got here, focusing will cause the text to be
+          // selected which could cause them to overwrite what they've
+          // already typed in.
+          if (gURLBar.focused && newBrowser.userTypedValue) {
+            return;
+          }
+
+          if (!window.fullScreen || isTabEmpty(newTab)) {
+            focusAndSelectUrlBar();
+            return;
+          }
+        }
+
+        // Focus the find bar if it was previously focused for that tab.
+        if (gFindBarInitialized && !gFindBar.hidden &&
+            this.selectedTab._findBarFocused) {
+          gFindBar._findField.focus();
+          return;
+        }
+
+        // Don't focus the content area if something has been focused after the
+        // tab switch was initiated.
+        if (gMultiProcessBrowser &&
+            document.activeElement != document.documentElement)
+          return;
+
+        // We're now committed to focusing the content area.
+        let fm = Services.focus;
+        let focusFlags = fm.FLAG_NOSCROLL;
+
+        if (!gMultiProcessBrowser) {
+          let newFocusedElement = fm.getFocusedElementForWindow(window.content, true, {});
+
+          // for anchors, use FLAG_SHOWRING so that it is clear what link was
+          // last clicked when switching back to that tab
+          if (newFocusedElement &&
+              (newFocusedElement instanceof HTMLAnchorElement ||
+               newFocusedElement.getAttributeNS("http://www.w3.org/1999/xlink", "type") == "simple"))
+            focusFlags |= fm.FLAG_SHOWRING;
+        }
+
+        fm.setFocus(newBrowser, focusFlags);
+        ]]></body>
+      </method>
+
+      <method name="_tabAttrModified">
+        <parameter name="aTab"/>
+        <parameter name="aChanged"/>
+        <body><![CDATA[
+          if (aTab.closing)
+            return;
+
+          let event = new CustomEvent("TabAttrModified", {
+            bubbles: true,
+            cancelable: false,
+            detail: {
+              changed: aChanged,
+            }
+          });
+          aTab.dispatchEvent(event);
+        ]]></body>
+      </method>
+
+      <method name="setBrowserSharing">
+        <parameter name="aBrowser"/>
+        <parameter name="aState"/>
+        <body><![CDATA[
+          let tab = this.getTabForBrowser(aBrowser);
+          if (!tab)
+            return;
+
+          let sharing;
+          if (aState.screen) {
+            sharing = "screen";
+          } else if (aState.camera) {
+            sharing = "camera";
+          } else if (aState.microphone) {
+            sharing = "microphone";
+          }
+
+          if (sharing) {
+            tab.setAttribute("sharing", sharing);
+            tab._sharingState = aState;
+          } else {
+            tab.removeAttribute("sharing");
+            tab._sharingState = null;
+          }
+          this._tabAttrModified(tab, ["sharing"]);
+
+          if (aBrowser == this.mCurrentBrowser)
+            gIdentityHandler.updateSharingIndicator();
+        ]]></body>
+      </method>
+
+
+      <!-- TODO: remove after 57, once we know add-ons can no longer use it. -->
+      <method name="setTabTitleLoading">
+        <parameter name="aTab"/>
+        <body/>
+      </method>
+
+      <method name="setInitialTabTitle">
+        <parameter name="aTab"/>
+        <parameter name="aTitle"/>
+        <parameter name="aOptions"/>
+        <body><![CDATA[
+          if (aTitle) {
+            if (!aTab.getAttribute("label")) {
+              aTab._labelIsInitialTitle = true;
+            }
+
+            this._setTabLabel(aTab, aTitle, aOptions);
+          }
+        ]]></body>
+      </method>
+
+      <method name="setTabTitle">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            var browser = this.getBrowserForTab(aTab);
+            var title = browser.contentTitle;
+
+            // Don't replace an initially set label with the URL while the tab
+            // is loading.
+            if (aTab._labelIsInitialTitle) {
+              if (!title) {
+                return false;
+              }
+              delete aTab._labelIsInitialTitle;
+            }
+
+            let isContentTitle = false;
+            if (title) {
+              isContentTitle = true;
+            } else if (aTab.hasAttribute("customizemode")) {
+              let brandBundle = document.getElementById("bundle_brand");
+              let brandShortName = brandBundle.getString("brandShortName");
+              title = gNavigatorBundle.getFormattedString("customizeMode.tabTitle",
+                                                          [ brandShortName ]);
+              isContentTitle = true;
+            } else {
+              if (browser.currentURI.displaySpec) {
+                try {
+                  title = this.mURIFixup.createExposableURI(browser.currentURI).displaySpec;
+                } catch (ex) {
+                  title = browser.currentURI.displaySpec;
+                }
+              }
+
+              if (title && !isBlankPageURL(title)) {
+                // At this point, we now have a URI.
+                // Let's try to unescape it using a character set
+                // in case the URI is not ASCII.
+                try {
+                  var characterSet = browser.characterSet;
+                  const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
+                                                 .getService(Components.interfaces.nsITextToSubURI);
+                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
+                  // If it's a long data: URI that uses base64 encoding, truncate to
+                  // a reasonable length rather than trying to display the entire thing.
+                  // We can't shorten arbitrary URIs like this, as bidi etc might mean
+                  // we need the trailing characters for display. But a base64-encoded
+                  // data-URI is plain ASCII, so this is OK for tab-title display.
+                  // (See bug 1408854.)
+                  if (title.length > 500 && title.match(/^data:[^,]+;base64,/)) {
+                    title = title.substring(0, 500) + "\u2026";
+                  }
+                } catch (ex) { /* Do nothing. */ }
+              } else {
+                // Still no title? Fall back to our untitled string.
+                title = gTabBrowserBundle.GetStringFromName("tabs.emptyTabTitle");
+              }
+            }
+
+            return this._setTabLabel(aTab, title, { isContentTitle });
+          ]]>
+        </body>
+      </method>
+
+      <method name="_setTabLabel">
+        <parameter name="aTab"/>
+        <parameter name="aLabel"/>
+        <parameter name="aOptions"/>
+        <body>
+          <![CDATA[
+            if (!aLabel) {
+              return false;
+            }
+
+            aTab._fullLabel = aLabel;
+
+            aOptions = aOptions || {};
+            if (!aOptions.isContentTitle) {
+              // Remove protocol and "www."
+              if (!("_regex_shortenURLForTabLabel" in this)) {
+                this._regex_shortenURLForTabLabel = /^[^:]+:\/\/(?:www\.)?/;
+              }
+              aLabel = aLabel.replace(this._regex_shortenURLForTabLabel, "");
+            }
+
+            aTab._labelIsContentTitle = aOptions.isContentTitle;
+
+            if (aTab.getAttribute("label") == aLabel) {
+              return false;
+            }
+
+            let dwu = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                            .getInterface(Ci.nsIDOMWindowUtils);
+            let isRTL = dwu.getDirectionFromText(aLabel) == Ci.nsIDOMWindowUtils.DIRECTION_RTL;
+
+            aTab.setAttribute("label", aLabel);
+            aTab.setAttribute("labeldirection", isRTL ? "rtl" : "ltr");
+
+            // Dispatch TabAttrModified event unless we're setting the label
+            // before the TabOpen event was dispatched.
+            if (!aOptions.beforeTabOpen) {
+              this._tabAttrModified(aTab, ["label"]);
+            }
+
+            if (aTab.selected) {
+              this.updateTitlebar();
+            }
+
+            return true;
+          ]]>
+        </body>
+      </method>
+
+      <method name="loadOneTab">
+        <parameter name="aURI"/>
+        <parameter name="aReferrerURI"/>
+        <parameter name="aCharset"/>
+        <parameter name="aPostData"/>
+        <parameter name="aLoadInBackground"/>
+        <parameter name="aAllowThirdPartyFixup"/>
+        <body>
+          <![CDATA[
+            var aTriggeringPrincipal;
+            var aReferrerPolicy;
+            var aFromExternal;
+            var aRelatedToCurrent;
+            var aAllowMixedContent;
+            var aSkipAnimation;
+            var aForceNotRemote;
+            var aPreferredRemoteType;
+            var aNoReferrer;
+            var aUserContextId;
+            var aSameProcessAsFrameLoader;
+            var aOriginPrincipal;
+            var aOpener;
+            var aOpenerBrowser;
+            var aIsPrerendered;
+            var aCreateLazyBrowser;
+            var aNextTabParentId;
+            var aFocusUrlBar;
+            var aName;
+            if (arguments.length == 2 &&
+                typeof arguments[1] == "object" &&
+                !(arguments[1] instanceof Ci.nsIURI)) {
+              let params = arguments[1];
+              aTriggeringPrincipal      = params.triggeringPrincipal;
+              aReferrerURI              = params.referrerURI;
+              aReferrerPolicy           = params.referrerPolicy;
+              aCharset                  = params.charset;
+              aPostData                 = params.postData;
+              aLoadInBackground         = params.inBackground;
+              aAllowThirdPartyFixup     = params.allowThirdPartyFixup;
+              aFromExternal             = params.fromExternal;
+              aRelatedToCurrent         = params.relatedToCurrent;
+              aAllowMixedContent        = params.allowMixedContent;
+              aSkipAnimation            = params.skipAnimation;
+              aForceNotRemote           = params.forceNotRemote;
+              aPreferredRemoteType      = params.preferredRemoteType;
+              aNoReferrer               = params.noReferrer;
+              aUserContextId            = params.userContextId;
+              aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;
+              aOriginPrincipal          = params.originPrincipal;
+              aOpener                   = params.opener;
+              aOpenerBrowser            = params.openerBrowser;
+              aIsPrerendered            = params.isPrerendered;
+              aCreateLazyBrowser        = params.createLazyBrowser;
+              aNextTabParentId          = params.nextTabParentId;
+              aFocusUrlBar              = params.focusUrlBar;
+              aName                     = params.name;
+            }
+
+            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
+                         Services.prefs.getBoolPref("browser.tabs.loadInBackground");
+            var owner = bgLoad ? null : this.selectedTab;
+
+            var tab = this.addTab(aURI, {
+                                  triggeringPrincipal: aTriggeringPrincipal,
+                                  referrerURI: aReferrerURI,
+                                  referrerPolicy: aReferrerPolicy,
+                                  charset: aCharset,
+                                  postData: aPostData,
+                                  ownerTab: owner,
+                                  allowThirdPartyFixup: aAllowThirdPartyFixup,
+                                  fromExternal: aFromExternal,
+                                  relatedToCurrent: aRelatedToCurrent,
+                                  skipAnimation: aSkipAnimation,
+                                  allowMixedContent: aAllowMixedContent,
+                                  forceNotRemote: aForceNotRemote,
+                                  createLazyBrowser: aCreateLazyBrowser,
+                                  preferredRemoteType: aPreferredRemoteType,
+                                  noReferrer: aNoReferrer,
+                                  userContextId: aUserContextId,
+                                  originPrincipal: aOriginPrincipal,
+                                  sameProcessAsFrameLoader: aSameProcessAsFrameLoader,
+                                  opener: aOpener,
+                                  openerBrowser: aOpenerBrowser,
+                                  isPrerendered: aIsPrerendered,
+                                  nextTabParentId: aNextTabParentId,
+                                  focusUrlBar: aFocusUrlBar,
+                                  name: aName });
+            if (!bgLoad)
+              this.selectedTab = tab;
+
+            return tab;
+         ]]>
+        </body>
+      </method>
+
+      <method name="loadTabs">
+        <parameter name="aURIs"/>
+        <parameter name="aLoadInBackground"/>
+        <parameter name="aReplace"/>
+        <body><![CDATA[
+          let aTriggeringPrincipal;
+          let aAllowThirdPartyFixup;
+          let aTargetTab;
+          let aNewIndex = -1;
+          let aPostDatas = [];
+          let aUserContextId;
+          if (arguments.length == 2 &&
+              typeof arguments[1] == "object") {
+            let params = arguments[1];
+            aLoadInBackground     = params.inBackground;
+            aReplace              = params.replace;
+            aAllowThirdPartyFixup = params.allowThirdPartyFixup;
+            aTargetTab            = params.targetTab;
+            aNewIndex             = typeof params.newIndex === "number" ?
+                                    params.newIndex : aNewIndex;
+            aPostDatas            = params.postDatas || aPostDatas;
+            aUserContextId        = params.userContextId;
+            aTriggeringPrincipal  = params.triggeringPrincipal;
+          }
+
+          if (!aURIs.length)
+            return;
+
+          // The tab selected after this new tab is closed (i.e. the new tab's
+          // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
+          // when several urls are opened here (i.e. closing the first should select
+          // the next of many URLs opened) or if the pref to have UI links opened in
+          // the background is set (i.e. the link is not being opened modally)
+          //
+          // i.e.
+          //    Number of URLs    Load UI Links in BG       Focus Last Viewed?
+          //    == 1              false                     YES
+          //    == 1              true                      NO
+          //    > 1               false/true                NO
+          var multiple = aURIs.length > 1;
+          var owner = multiple || aLoadInBackground ? null : this.selectedTab;
+          var firstTabAdded = null;
+          var targetTabIndex = -1;
+
+          if (aReplace) {
+            let browser;
+            if (aTargetTab) {
+              browser = this.getBrowserForTab(aTargetTab);
+              targetTabIndex = aTargetTab._tPos;
+            } else {
+              browser = this.mCurrentBrowser;
+              targetTabIndex = this.tabContainer.selectedIndex;
+            }
+            let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+            if (aAllowThirdPartyFixup) {
+              flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP |
+                       Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
+            }
+            try {
+              browser.loadURIWithFlags(aURIs[0], {
+                flags, postData: aPostDatas[0],
+                triggeringPrincipal: aTriggeringPrincipal,
+              });
+            } catch (e) {
+              // Ignore failure in case a URI is wrong, so we can continue
+              // opening the next ones.
+            }
+          } else {
+            firstTabAdded = this.addTab(aURIs[0], {
+              ownerTab: owner,
+              skipAnimation: multiple,
+              allowThirdPartyFixup: aAllowThirdPartyFixup,
+              postData: aPostDatas[0],
+              userContextId: aUserContextId,
+              triggeringPrincipal: aTriggeringPrincipal,
+            });
+            if (aNewIndex !== -1) {
+              this.moveTabTo(firstTabAdded, aNewIndex);
+              targetTabIndex = firstTabAdded._tPos;
+            }
+          }
+
+          let tabNum = targetTabIndex;
+          for (let i = 1; i < aURIs.length; ++i) {
+            let tab = this.addTab(aURIs[i], {
+              skipAnimation: true,
+              allowThirdPartyFixup: aAllowThirdPartyFixup,
+              postData: aPostDatas[i],
+              userContextId: aUserContextId,
+              triggeringPrincipal: aTriggeringPrincipal,
+            });
+            if (targetTabIndex !== -1)
+              this.moveTabTo(tab, ++tabNum);
+          }
+
+          if (firstTabAdded && !aLoadInBackground) {
+            this.selectedTab = firstTabAdded;
+          }
+        ]]></body>
+      </method>
+
+      <method name="updateBrowserRemoteness">
+        <parameter name="aBrowser"/>
+        <parameter name="aShouldBeRemote"/>
+        <parameter name="aOptions"/>
+        <body>
+          <![CDATA[
+            aOptions = aOptions || {};
+            let isRemote = aBrowser.getAttribute("remote") == "true";
+
+            if (!gMultiProcessBrowser && aShouldBeRemote) {
+              throw new Error("Cannot switch to remote browser in a window " +
+                              "without the remote tabs load context.");
+            }
+
+            // Default values for remoteType
+            if (!aOptions.remoteType) {
+              aOptions.remoteType = aShouldBeRemote ? E10SUtils.DEFAULT_REMOTE_TYPE : E10SUtils.NOT_REMOTE;
+            }
+
+            // If we are passed an opener, we must be making the browser non-remote, and
+            // if the browser is _currently_ non-remote, we need the openers to match,
+            // because it is already too late to change it.
+            if (aOptions.opener) {
+              if (aShouldBeRemote) {
+                throw new Error("Cannot set an opener on a browser which should be remote!");
+              }
+              if (!isRemote && aBrowser.contentWindow.opener != aOptions.opener) {
+                throw new Error("Cannot change opener on an already non-remote browser!");
+              }
+            }
+
+            // Abort if we're not going to change anything
+            let currentRemoteType = aBrowser.getAttribute("remoteType");
+            if (isRemote == aShouldBeRemote && !aOptions.newFrameloader &&
+                (!isRemote || currentRemoteType == aOptions.remoteType)) {
+              return false;
+            }
+
+            let tab = this.getTabForBrowser(aBrowser);
+            // aBrowser needs to be inserted now if it hasn't been already.
+            this._insertBrowser(tab);
+
+            let evt = document.createEvent("Events");
+            evt.initEvent("BeforeTabRemotenessChange", true, false);
+            tab.dispatchEvent(evt);
+
+            let wasActive = document.activeElement == aBrowser;
+
+            // Unmap the old outerWindowID.
+            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);
+
+            // Unhook our progress listener.
+            let filter = this._tabFilters.get(tab);
+            let listener = this._tabListeners.get(tab);
+            aBrowser.webProgress.removeProgressListener(filter);
+            filter.removeProgressListener(listener);
+
+            // We'll be creating a new listener, so destroy the old one.
+            listener.destroy();
+
+            let oldUserTypedValue = aBrowser.userTypedValue;
+            let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
+
+            // Make sure the browser is destroyed so it unregisters from observer notifications
+            aBrowser.destroy();
+
+            // Make sure to restore the original droppedLinkHandler and
+            // sameProcessAsFrameLoader.
+            let droppedLinkHandler = aBrowser.droppedLinkHandler;
+            let sameProcessAsFrameLoader = aBrowser.sameProcessAsFrameLoader;
+
+            // Change the "remote" attribute.
+            let parent = aBrowser.parentNode;
+            parent.removeChild(aBrowser);
+            if (aShouldBeRemote) {
+              aBrowser.setAttribute("remote", "true");
+              aBrowser.setAttribute("remoteType", aOptions.remoteType);
+            } else {
+              aBrowser.setAttribute("remote", "false");
+              aBrowser.removeAttribute("remoteType");
+            }
+
+            // NB: This works with the hack in the browser constructor that
+            // turns this normal property into a field.
+            if (aOptions.sameProcessAsFrameLoader) {
+              // Always set sameProcessAsFrameLoader when passed in aOptions.
+              aBrowser.sameProcessAsFrameLoader = aOptions.sameProcessAsFrameLoader;
+            } else if (!aShouldBeRemote || currentRemoteType == aOptions.remoteType) {
+              // Only copy existing sameProcessAsFrameLoader when not switching
+              // remote type otherwise it would stop the switch.
+              aBrowser.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
+            }
+
+            if (aOptions.opener) {
+              // Set the opener window on the browser, such that when the frame
+              // loader is created the opener is set correctly.
+              aBrowser.presetOpenerWindow(aOptions.opener);
+            }
+
+            parent.appendChild(aBrowser);
+
+            aBrowser.userTypedValue = oldUserTypedValue;
+            if (hadStartedLoad) {
+              aBrowser.urlbarChangeTracker.startedLoad();
+            }
+
+            aBrowser.droppedLinkHandler = droppedLinkHandler;
+
+            // Switching a browser's remoteness will create a new frameLoader.
+            // As frameLoaders start out with an active docShell we have to
+            // deactivate it if this is not the selected tab's browser or the
+            // browser window is minimized.
+            aBrowser.docShellIsActive = this.shouldActivateDocShell(aBrowser);
+
+            // Create a new tab progress listener for the new browser we just injected,
+            // since tab progress listeners have logic for handling the initial about:blank
+            // load
+            listener = this.mTabProgressListener(tab, aBrowser, true, false);
+            this._tabListeners.set(tab, listener);
+            filter.addProgressListener(listener, Ci.nsIWebProgress.NOTIFY_ALL);
+
+            // Restore the progress listener.
+            aBrowser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);
+
+            // Restore the securityUI state.
+            let securityUI = aBrowser.securityUI;
+            let state = securityUI ? securityUI.state
+                                   : Ci.nsIWebProgressListener.STATE_IS_INSECURE;
+            // Include the true final argument to indicate that this event is
+            // simulated (instead of being observed by the webProgressListener).
+            this._callProgressListeners(aBrowser, "onSecurityChange",
+                                        [aBrowser.webProgress, null, state, true],
+                                        true, false);
+
+            if (aShouldBeRemote) {
+              // Switching the browser to be remote will connect to a new child
+              // process so the browser can no longer be considered to be
+              // crashed.
+              tab.removeAttribute("crashed");
+            } else {
+              aBrowser.messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: tab.pinned });
+
+              // Register the new outerWindowID.
+              this._outerWindowIDBrowserMap.set(aBrowser.outerWindowID, aBrowser);
+            }
+
+            if (wasActive)
+              aBrowser.focus();
+
+            // If the findbar has been initialised, reset its browser reference.
+            if (this.isFindBarInitialized(tab)) {
+              this.getFindBar(tab).browser = aBrowser;
+            }
+
+            evt = document.createEvent("Events");
+            evt.initEvent("TabRemotenessChange", true, false);
+            tab.dispatchEvent(evt);
+
+            return true;
+          ]]>
+        </body>
+      </method>
+
+      <method name="updateBrowserRemotenessByURL">
+        <parameter name="aBrowser"/>
+        <parameter name="aURL"/>
+        <parameter name="aOptions"/>
+        <body>
+          <![CDATA[
+            aOptions = aOptions || {};
+
+            if (!gMultiProcessBrowser)
+              return this.updateBrowserRemoteness(aBrowser, false);
+
+            let currentRemoteType = aBrowser.getAttribute("remoteType") || null;
+
+            aOptions.remoteType =
+              E10SUtils.getRemoteTypeForURI(aURL,
+                                            gMultiProcessBrowser,
+                                            currentRemoteType,
+                                            aBrowser.currentURI);
+
+            // If this URL can't load in the current browser then flip it to the
+            // correct type.
+            if (currentRemoteType != aOptions.remoteType ||
+                aOptions.newFrameloader) {
+              let remote = aOptions.remoteType != E10SUtils.NOT_REMOTE;
+              return this.updateBrowserRemoteness(aBrowser, remote, aOptions);
+            }
+
+            return false;
+          ]]>
+        </body>
+      </method>
+
+      <method name="removePreloadedBrowser">
+        <body>
+          <![CDATA[
+            if (!this._isPreloadingEnabled()) {
+              return;
+            }
+
+            let browser = this._getPreloadedBrowser();
+
+            if (browser) {
+              browser.remove();
+            }
+          ]]>
+        </body>
+      </method>
+
+      <field name="_preloadedBrowser">null</field>
+      <method name="_getPreloadedBrowser">
+        <body>
+          <![CDATA[
+            if (!this._isPreloadingEnabled()) {
+              return null;
+            }
+
+            // The preloaded browser might be null.
+            let browser = this._preloadedBrowser;
+
+            // Consume the browser.
+            this._preloadedBrowser = null;
+
+            // Attach the nsIFormFillController now that we know the browser
+            // will be used. If we do that before and the preloaded browser
+            // won't be consumed until shutdown then we leak a docShell.
+            // Also, we do not need to take care of attaching nsIFormFillControllers
+            // in the case that the browser is remote, as remote browsers take
+            // care of that themselves.
+            if (browser && this.hasAttribute("autocompletepopup")) {
+              browser.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
+            }
+
+            return browser;
+          ]]>
+        </body>
+      </method>
+
+      <method name="_isPreloadingEnabled">
+        <body>
+          <![CDATA[
+            // Preloading for the newtab page is enabled when the pref is true
+            // and the URL is "about:newtab". We do not support preloading for
+            // custom newtab URLs.
+            return Services.prefs.getBoolPref("browser.newtab.preload") &&
+                   !aboutNewTabService.overridden;
+          ]]>
+        </body>
+      </method>
+
+      <method name="_createPreloadBrowser">
+        <body>
+          <![CDATA[
+            // Do nothing if we have a preloaded browser already
+            // or preloading of newtab pages is disabled.
+            if (this._preloadedBrowser || !this._isPreloadingEnabled()) {
+              return;
+            }
+
+            let remoteType =
+              E10SUtils.getRemoteTypeForURI(BROWSER_NEW_TAB_URL,
+                                            gMultiProcessBrowser);
+            let browser = this._createBrowser({isPreloadBrowser: true, remoteType});
+            this._preloadedBrowser = browser;
+
+            let notificationbox = this.getNotificationBox(browser);
+            this.mPanelContainer.appendChild(notificationbox);
+
+            if (remoteType != E10SUtils.NOT_REMOTE) {
+              // For remote browsers, we need to make sure that the webProgress is
+              // instantiated, otherwise the parent won't get informed about the state
+              // of the preloaded browser until it gets attached to a tab.
+              browser.webProgress;
+            }
+
+            browser.loadURI(BROWSER_NEW_TAB_URL);
+            browser.docShellIsActive = false;
+
+            // Make sure the preloaded browser is loaded with desired zoom level
+            let tabURI = Services.io.newURI(BROWSER_NEW_TAB_URL);
+            FullZoom.onLocationChange(tabURI, false, browser);
+          ]]>
+        </body>
+      </method>
+
+      <method name="_createBrowser">
+        <parameter name="aParams"/>
+        <body>
+          <![CDATA[
+            // Supported parameters:
+            // userContextId, remote, remoteType, isPreloadBrowser,
+            // uriIsAboutBlank, sameProcessAsFrameLoader, isPrerendered
+
+            const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+            let b = document.createElementNS(NS_XUL, "browser");
+            b.permanentKey = {};
+            b.setAttribute("type", "content");
+            b.setAttribute("message", "true");
+            b.setAttribute("messagemanagergroup", "browsers");
+            b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
+            b.setAttribute("tooltip", this.getAttribute("contenttooltip"));
+
+            if (aParams.isPrerendered) {
+              b.setAttribute("prerendered", "true");
+            }
+
+            if (aParams.userContextId) {
+              b.setAttribute("usercontextid", aParams.userContextId);
+            }
+
+            // remote parameter used by some addons, use default in this case.
+            if (aParams.remote && !aParams.remoteType) {
+              aParams.remoteType = E10SUtils.DEFAULT_REMOTE_TYPE;
+            }
+
+            if (aParams.remoteType) {
+              b.setAttribute("remoteType", aParams.remoteType);
+              b.setAttribute("remote", "true");
+            }
+
+            if (aParams.openerWindow) {
+              if (aParams.remoteType) {
+                throw new Error("Cannot set opener window on a remote browser!");
+              }
+              b.presetOpenerWindow(aParams.openerWindow);
+            }
+
+            if (!aParams.isPreloadBrowser && this.hasAttribute("autocompletepopup")) {
+              b.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
+            }
+
+            if (aParams.isPreloadBrowser) {
+              b.setAttribute("isPreloadBrowser", "true");
+            }
+
+            if (this.hasAttribute("selectmenulist"))
+              b.setAttribute("selectmenulist", this.getAttribute("selectmenulist"));
+
+            if (this.hasAttribute("datetimepicker")) {
+              b.setAttribute("datetimepicker", this.getAttribute("datetimepicker"));
+            }
+
+            b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
+
+            if (aParams.nextTabParentId) {
+              if (!aParams.remoteType) {
+                throw new Error("Cannot have nextTabParentId without a remoteType");
+              }
+              // Gecko is going to read this attribute and use it.
+              b.setAttribute("nextTabParentId", aParams.nextTabParentId.toString());
+            }
+
+            if (aParams.sameProcessAsFrameLoader) {
+              b.sameProcessAsFrameLoader = aParams.sameProcessAsFrameLoader;
+            }
+
+            // This will be used by gecko to control the name of the opened
+            // window.
+            if (aParams.name) {
+              // XXX: The `name` property is special in HTML and XUL. Should
+              // we use a different attribute name for this?
+              b.setAttribute("name", aParams.name);
+            }
+
+            // Create the browserStack container
+            var stack = document.createElementNS(NS_XUL, "stack");
+            stack.className = "browserStack";
+            stack.appendChild(b);
+            stack.setAttribute("flex", "1");
+
+            // Create the browserContainer
+            var browserContainer = document.createElementNS(NS_XUL, "vbox");
+            browserContainer.className = "browserContainer";
+            browserContainer.appendChild(stack);
+            browserContainer.setAttribute("flex", "1");
+
+            // Create the sidebar container
+            var browserSidebarContainer = document.createElementNS(NS_XUL,
+                                                                   "hbox");
+            browserSidebarContainer.className = "browserSidebarContainer";
+            browserSidebarContainer.appendChild(browserContainer);
+            browserSidebarContainer.setAttribute("flex", "1");
+
+            // Add the Message and the Browser to the box
+            var notificationbox = document.createElementNS(NS_XUL,
+                                                           "notificationbox");
+            notificationbox.setAttribute("flex", "1");
+            notificationbox.setAttribute("notificationside", "top");
+            notificationbox.appendChild(browserSidebarContainer);
+
+            // Prevent the superfluous initial load of a blank document
+            // if we're going to load something other than about:blank.
+            if (!aParams.uriIsAboutBlank) {
+              b.setAttribute("nodefaultsrc", "true");
+            }
+
+            return b;
+          ]]>
+        </body>
+      </method>
+
+      <!--
+        `_createLazyBrowser` will define properties on the unbound lazy browser
+        which correspond to properties defined in XBL which will be bound to
+        the browser when it is inserted into the document.  If any of these
+        properties are accessed by consumers, `_insertBrowser` is called and
+        the browser is inserted to ensure that things don't break.  This list
+        provides the names of properties that may be called while the browser
+        is in its unbound (lazy) state.
+      -->
+      <field name="_browserBindingProperties">[
+        "canGoBack", "canGoForward", "goBack", "goForward", "permitUnload",
+        "reload", "reloadWithFlags", "stop", "loadURI", "loadURIWithFlags",
+        "goHome", "homePage", "gotoIndex", "currentURI", "documentURI",
+        "preferences", "imageDocument", "isRemoteBrowser", "messageManager",
+        "getTabBrowser", "finder", "fastFind", "sessionHistory", "contentTitle",
+        "characterSet", "fullZoom", "textZoom", "webProgress",
+        "addProgressListener", "removeProgressListener", "audioPlaybackStarted",
+        "audioPlaybackStopped", "pauseMedia", "stopMedia",
+        "resumeMedia", "mute", "unmute", "blockedPopups", "lastURI",
+        "purgeSessionHistory", "stopScroll", "startScroll",
+        "userTypedValue", "userTypedClear", "mediaBlocked",
+        "didStartLoadSinceLastUserTyping"
+      ]</field>
+
+      <method name="_createLazyBrowser">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            let browser = aTab.linkedBrowser;
+
+            let names = this._browserBindingProperties;
+
+            for (let i = 0; i < names.length; i++) {
+              let name = names[i];
+              let getter;
+              let setter;
+              switch (name) {
+                case "audioMuted":
+                  getter = () => false;
+                  break;
+                case "contentTitle":
+                  getter = () => SessionStore.getLazyTabValue(aTab, "title");
+                  break;
+                case "currentURI":
+                  getter = () => {
+                    let url = SessionStore.getLazyTabValue(aTab, "url");
+                    return Services.io.newURI(url);
+                  };
+                  break;
+                case "didStartLoadSinceLastUserTyping":
+                  getter = () => () => false;
+                  break;
+                case "fullZoom":
+                case "textZoom":
+                  getter = () => 1;
+                  break;
+                case "getTabBrowser":
+                  getter = () => () => this;
+                  break;
+                case "isRemoteBrowser":
+                  getter = () => browser.getAttribute("remote") == "true";
+                  break;
+                case "permitUnload":
+                  getter = () => () => ({ permitUnload: true, timedOut: false });
+                  break;
+                case "reload":
+                case "reloadWithFlags":
+                  getter = () =>
+                    params => {
+                      // Wait for load handler to be instantiated before
+                      // initializing the reload.
+                      aTab.addEventListener("SSTabRestoring", () => {
+                        browser[name](params);
+                      }, { once: true });
+                      gBrowser._insertBrowser(aTab);
+                    };
+                  break;
+                case "resumeMedia":
+                  getter = () =>
+                    () => {
+                      // No need to insert a browser, so we just call the browser's
+                      // method.
+                      aTab.addEventListener("SSTabRestoring", () => {
+                        browser[name]();
+                      }, { once: true });
+                    };
+                  break;
+                case "userTypedValue":
+                case "userTypedClear":
+                case "mediaBlocked":
+                  getter = () => SessionStore.getLazyTabValue(aTab, name);
+                  break;
+                default:
+                  getter = () => {
+                    if (AppConstants.NIGHTLY_BUILD) {
+                      let message =
+                        `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\n`;
+                      console.log(message + new Error().stack);
+                    }
+                    this._insertBrowser(aTab);
+                    return browser[name];
+                  };
+                  setter = value => {
+                    if (AppConstants.NIGHTLY_BUILD) {
+                      let message =
+                        `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\n`;
+                      console.log(message + new Error().stack);
+                    }
+                    this._insertBrowser(aTab);
+                    return browser[name] = value;
+                  };
+              }
+              Object.defineProperty(browser, name, {
+                get: getter,
+                set: setter,
+                configurable: true,
+                enumerable: true
+              });
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="_insertBrowser">
+        <parameter name="aTab"/>
+        <parameter name="aInsertedOnTabCreation"/>
+        <body>
+          <![CDATA[
+            "use strict";
+
+            // If browser is already inserted or window is closed don't do anything.
+            if (aTab.linkedPanel || window.closed) {
+              return;
+            }
+
+            let browser = aTab.linkedBrowser;
+
+            // If browser is a lazy browser, delete the substitute properties.
+            if (this._browserBindingProperties[0] in browser) {
+              for (let name of this._browserBindingProperties) {
+                delete browser[name];
+              }
+            }
+
+            let { uriIsAboutBlank, remoteType, usingPreloadedContent } =
+                    aTab._browserParams;
+            delete aTab._browserParams;
+
+            let notificationbox = this.getNotificationBox(browser);
+            let uniqueId = this._generateUniquePanelID();
+            notificationbox.id = uniqueId;
+            aTab.linkedPanel = uniqueId;
+
+            // Inject the <browser> into the DOM if necessary.
+            if (!notificationbox.parentNode) {
+              // NB: this appendChild call causes us to run constructors for the
+              // browser element, which fires off a bunch of notifications. Some
+              // of those notifications can cause code to run that inspects our
+              // state, so it is important that the tab element is fully
+              // initialized by this point.
+              this.mPanelContainer.appendChild(notificationbox);
+            }
+
+            // wire up a progress listener for the new browser object.
+            let tabListener = this.mTabProgressListener(aTab, browser, uriIsAboutBlank, usingPreloadedContent);
+            const filter = Cc["@mozilla.org/appshell/component/browser-status-filter;1"]
+                                     .createInstance(Ci.nsIWebProgress);
+            filter.addProgressListener(tabListener, Ci.nsIWebProgress.NOTIFY_ALL);
+            browser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);
+            this._tabListeners.set(aTab, tabListener);
+            this._tabFilters.set(aTab, filter);
+
+            browser.droppedLinkHandler = handleDroppedLink;
+
+            // We start our browsers out as inactive, and then maintain
+            // activeness in the tab switcher.
+            browser.docShellIsActive = false;
+
+            // When addTab() is called with an URL that is not "about:blank" we
+            // set the "nodefaultsrc" attribute that prevents a frameLoader
+            // from being created as soon as the linked <browser> is inserted
+            // into the DOM. We thus have to register the new outerWindowID
+            // for non-remote browsers after we have called browser.loadURI().
+            if (remoteType == E10SUtils.NOT_REMOTE) {
+              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
+            }
+
+            var evt = new CustomEvent("TabBrowserInserted",
+              { bubbles: true, detail: { insertedOnTabCreation: aInsertedOnTabCreation } });
+            aTab.dispatchEvent(evt);
+          ]]>
+        </body>
+      </method>
+
+      <method name="discardBrowser">
+        <parameter name="aBrowser"/>
+        <parameter name="aForceDiscard"/>
+        <body>
+          <![CDATA[
+            "use strict";
+
+            let tab = this.getTabForBrowser(aBrowser);
+
+            let permitUnloadFlags = aForceDiscard ? aBrowser.dontPromptAndUnload : aBrowser.dontPromptAndDontUnload;
+
+            if (!tab ||
+                tab.selected ||
+                tab.closing ||
+                this._windowIsClosing ||
+                !aBrowser.isConnected ||
+                !aBrowser.isRemoteBrowser ||
+                !aBrowser.permitUnload(permitUnloadFlags).permitUnload) {
+              return;
+            }
+
+            // Set browser parameters for when browser is restored.  Also remove
+            // listeners and set up lazy restore data in SessionStore. This must
+            // be done before aBrowser is destroyed and removed from the document.
+            tab._browserParams = { uriIsAboutBlank: aBrowser.currentURI.spec == "about:blank",
+                                   remoteType: aBrowser.remoteType,
+                                   usingPreloadedContent: false };
+
+            SessionStore.resetBrowserToLazyState(tab);
+
+            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);
+
+            // Remove the tab's filter and progress listener.
+            let filter = this._tabFilters.get(tab);
+            let listener = this._tabListeners.get(tab);
+            aBrowser.webProgress.removeProgressListener(filter);
+            filter.removeProgressListener(listener);
+            listener.destroy();
+
+            this._tabListeners.delete(tab);
+            this._tabFilters.delete(tab);
+
+            aBrowser.destroy();
+
+            let notificationbox = this.getNotificationBox(aBrowser);
+            this.mPanelContainer.removeChild(notificationbox);
+            tab.removeAttribute("linkedpanel");
+
+            this._createLazyBrowser(tab);
+
+            let evt = new CustomEvent("TabBrowserDiscarded", { bubbles: true });
+            tab.dispatchEvent(evt);
+          ]]>
+        </body>
+      </method>
+
+      <method name="addTab">
+        <parameter name="aURI"/>
+        <parameter name="aReferrerURI"/>
+        <parameter name="aCharset"/>
+        <parameter name="aPostData"/>
+        <parameter name="aOwner"/>
+        <parameter name="aAllowThirdPartyFixup"/>
+        <body>
+          <![CDATA[
+            "use strict";
+
+            const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+            var aTriggeringPrincipal;
+            var aReferrerPolicy;
+            var aFromExternal;
+            var aRelatedToCurrent;
+            var aSkipAnimation;
+            var aAllowMixedContent;
+            var aForceNotRemote;
+            var aPreferredRemoteType;
+            var aNoReferrer;
+            var aUserContextId;
+            var aEventDetail;
+            var aSameProcessAsFrameLoader;
+            var aOriginPrincipal;
+            var aDisallowInheritPrincipal;
+            var aOpener;
+            var aOpenerBrowser;
+            var aIsPrerendered;
+            var aCreateLazyBrowser;
+            var aSkipBackgroundNotify;
+            var aNextTabParentId;
+            var aNoInitialLabel;
+            var aFocusUrlBar;
+            var aName;
+            if (arguments.length == 2 &&
+                typeof arguments[1] == "object" &&
+                !(arguments[1] instanceof Ci.nsIURI)) {
+              let params = arguments[1];
+              aTriggeringPrincipal      = params.triggeringPrincipal;
+              aReferrerURI              = params.referrerURI;
+              aReferrerPolicy           = params.referrerPolicy;
+              aCharset                  = params.charset;
+              aPostData                 = params.postData;
+              aOwner                    = params.ownerTab;
+              aAllowThirdPartyFixup     = params.allowThirdPartyFixup;
+              aFromExternal             = params.fromExternal;
+              aRelatedToCurrent         = params.relatedToCurrent;
+              aSkipAnimation            = params.skipAnimation;
+              aAllowMixedContent        = params.allowMixedContent;
+              aForceNotRemote           = params.forceNotRemote;
+              aPreferredRemoteType      = params.preferredRemoteType;
+              aNoReferrer               = params.noReferrer;
+              aUserContextId            = params.userContextId;
+              aEventDetail              = params.eventDetail;
+              aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;
+              aOriginPrincipal          = params.originPrincipal;
+              aDisallowInheritPrincipal = params.disallowInheritPrincipal;
+              aOpener                   = params.opener;
+              aOpenerBrowser            = params.openerBrowser;
+              aIsPrerendered            = params.isPrerendered;
+              aCreateLazyBrowser        = params.createLazyBrowser;
+              aSkipBackgroundNotify     = params.skipBackgroundNotify;
+              aNextTabParentId          = params.nextTabParentId;
+              aNoInitialLabel           = params.noInitialLabel;
+              aFocusUrlBar              = params.focusUrlBar;
+              aName                     = params.name;
+            }
+
+            // if we're adding tabs, we're past interrupt mode, ditch the owner
+            if (this.mCurrentTab.owner)
+              this.mCurrentTab.owner = null;
+
+            // Find the tab that opened this one, if any. This is used for
+            // determining positioning, and inherited attributes such as the
+            // user context ID.
+            //
+            // If we have a browser opener (which is usually the browser
+            // element from a remote window.open() call), use that.
+            //
+            // Otherwise, if the tab is related to the current tab (e.g.,
+            // because it was opened by a link click), use the selected tab as
+            // the owner. If aReferrerURI is set, and we don't have an
+            // explicit relatedToCurrent arg, we assume that the tab is
+            // related to the current tab, since aReferrerURI is null or
+            // undefined if the tab is opened from an external application or
+            // bookmark (i.e. somewhere other than an existing tab).
+            let relatedToCurrent = aRelatedToCurrent == null ? !!aReferrerURI : aRelatedToCurrent;
+            let openerTab = ((aOpenerBrowser && this.getTabForBrowser(aOpenerBrowser)) ||
+                             (relatedToCurrent && this.selectedTab));
+
+            var t = document.createElementNS(NS_XUL, "tab");
+
+            t.openerTab = openerTab;
+
+            aURI = aURI || "about:blank";
+            let aURIObject = null;
+            try {
+              aURIObject = Services.io.newURI(aURI);
+            } catch (ex) { /* we'll try to fix up this URL later */ }
+
+            let lazyBrowserURI;
+            if (aCreateLazyBrowser && aURI != "about:blank") {
+              lazyBrowserURI = aURIObject;
+              aURI = "about:blank";
+            }
+
+            var uriIsAboutBlank = aURI == "about:blank";
+
+            if (!aNoInitialLabel) {
+              if (isBlankPageURL(aURI)) {
+                t.setAttribute("label", gTabBrowserBundle.GetStringFromName("tabs.emptyTabTitle"));
+              } else {
+                // Set URL as label so that the tab isn't empty initially.
+                this.setInitialTabTitle(t, aURI, { beforeTabOpen: true });
+              }
+            }
+
+            if (aIsPrerendered) {
+              t.setAttribute("hidden", "true");
+            }
+
+            // Related tab inherits current tab's user context unless a different
+            // usercontextid is specified
+            if (aUserContextId == null && openerTab) {
+              aUserContextId = openerTab.getAttribute("usercontextid") || 0;
+            }
+
+            if (aUserContextId) {
+              t.setAttribute("usercontextid", aUserContextId);
+              ContextualIdentityService.setTabStyle(t);
+            }
+
+            t.setAttribute("onerror", "this.removeAttribute('image');");
+
+            if (aSkipBackgroundNotify) {
+              t.setAttribute("skipbackgroundnotify", true);
+            }
+
+            t.className = "tabbrowser-tab";
+
+            this.tabContainer._unlockTabSizing();
+
+            // When overflowing, new tabs are scrolled into view smoothly, which
+            // doesn't go well together with the width transition. So we skip the
+            // transition in that case.
+            let animate = !aSkipAnimation &&
+                          this.tabContainer.getAttribute("overflow") != "true" &&
+                          this.animationsEnabled;
+            if (!animate) {
+              t.setAttribute("fadein", "true");
+
+              // Call _handleNewTab asynchronously as it needs to know if the
+              // new tab is selected.
+              setTimeout(function(tabContainer) {
+                tabContainer._handleNewTab(t);
+              }, 0, this.tabContainer);
+            }
+
+            // invalidate cache
+            this._visibleTabs = null;
+
+            this.tabContainer.appendChild(t);
+
+            let usingPreloadedContent = false;
+            let b;
+
+            try {
+              // If this new tab is owned by another, assert that relationship
+              if (aOwner)
+                t.owner = aOwner;
+
+              var position = this.tabs.length - 1;
+              t._tPos = position;
+              this.tabContainer._setPositionalAttributes();
+
+              this.tabContainer.updateVisibility();
+
+              // If we don't have a preferred remote type, and we have a remote
+              // opener, use the opener's remote type.
+              if (!aPreferredRemoteType && aOpenerBrowser) {
+                aPreferredRemoteType = aOpenerBrowser.remoteType;
+              }
+
+              // If URI is about:blank and we don't have a preferred remote type,
+              // then we need to use the referrer, if we have one, to get the
+              // correct remote type for the new tab.
+              if (uriIsAboutBlank && !aPreferredRemoteType && aReferrerURI) {
+                aPreferredRemoteType =
+                  E10SUtils.getRemoteTypeForURI(aReferrerURI.spec,
+                                                gMultiProcessBrowser);
+              }
+
+              let remoteType =
+                aForceNotRemote ? E10SUtils.NOT_REMOTE
+                : E10SUtils.getRemoteTypeForURI(aURI, gMultiProcessBrowser,
+                                                aPreferredRemoteType);
+
+              // If we open a new tab with the newtab URL in the default
+              // userContext, check if there is a preloaded browser ready.
+              // Private windows are not included because both the label and the
+              // icon for the tab would be set incorrectly (see bug 1195981).
+              if (aURI == BROWSER_NEW_TAB_URL &&
+                  !aUserContextId &&
+                  !PrivateBrowsingUtils.isWindowPrivate(window)) {
+                b = this._getPreloadedBrowser();
+                if (b) {
+                  usingPreloadedContent = true;
+                }
+              }
+
+              if (!b) {
+                // No preloaded browser found, create one.
+                b = this._createBrowser({ remoteType,
+                                          uriIsAboutBlank,
+                                          userContextId: aUserContextId,
+                                          sameProcessAsFrameLoader: aSameProcessAsFrameLoader,
+                                          openerWindow: aOpener,
+                                          isPrerendered: aIsPrerendered,
+                                          nextTabParentId: aNextTabParentId,
+                                          name: aName });
+              }
+
+              t.linkedBrowser = b;
+
+              if (aFocusUrlBar) {
+                b._urlbarFocused = true;
+              }
+
+              this._tabForBrowser.set(b, t);
+              t.permanentKey = b.permanentKey;
+              t._browserParams = { uriIsAboutBlank,
+                                   remoteType,
+                                   usingPreloadedContent };
+
+              // If the caller opts in, create a lazy browser.
+              if (aCreateLazyBrowser) {
+                this._createLazyBrowser(t);
+
+                if (lazyBrowserURI) {
+                  // Lazy browser must be explicitly registered so tab will appear as
+                  // a switch-to-tab candidate in autocomplete.
+                  this._unifiedComplete.registerOpenPage(lazyBrowserURI, aUserContextId);
+                  b.registeredOpenURI = lazyBrowserURI;
+                }
+              } else {
+                this._insertBrowser(t, true);
+              }
+            } catch (e) {
+              Cu.reportError("Failed to create tab");
+              Cu.reportError(e);
+              t.remove();
+              if (t.linkedBrowser) {
+                this._tabFilters.delete(t);
+                this._tabListeners.delete(t);
+                let notificationbox = this.getNotificationBox(t.linkedBrowser);
+                notificationbox.remove();
+              }
+              throw e;
+            }
+
+            // Hack to ensure that the about:newtab favicon is loaded
+            // instantaneously, to avoid flickering and improve perceived performance.
+            if (aURI == BROWSER_NEW_TAB_URL) {
+              this.setIcon(t, "chrome://branding/content/icon32.png");
+            }
+
+            // Dispatch a new tab notification.  We do this once we're
+            // entirely done, so that things are in a consistent state
+            // even if the event listener opens or closes tabs.
+            var detail = aEventDetail || {};
+            var evt = new CustomEvent("TabOpen", { bubbles: true, detail });
+            t.dispatchEvent(evt);
+
+            if (!usingPreloadedContent && aOriginPrincipal && aURI) {
+              let {URI_INHERITS_SECURITY_CONTEXT} = Ci.nsIProtocolHandler;
+              // Unless we know for sure we're not inheriting principals,
+              // force the about:blank viewer to have the right principal:
+              if (!aURIObject ||
+                  (doGetProtocolFlags(aURIObject) & URI_INHERITS_SECURITY_CONTEXT)) {
+                b.createAboutBlankContentViewer(aOriginPrincipal);
+              }
+            }
+
+            // If we didn't swap docShells with a preloaded browser
+            // then let's just continue loading the page normally.
+            if (!usingPreloadedContent && (!uriIsAboutBlank || aDisallowInheritPrincipal)) {
+              // pretend the user typed this so it'll be available till
+              // the document successfully loads
+              if (aURI && gInitialPages.indexOf(aURI) == -1)
+                b.userTypedValue = aURI;
+
+              let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+              if (aAllowThirdPartyFixup) {
+                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
+                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
+              }
+              if (aFromExternal)
+                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
+              if (aAllowMixedContent)
+                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_MIXED_CONTENT;
+              if (aDisallowInheritPrincipal)
+                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL;
+              try {
+                b.loadURIWithFlags(aURI, {
+                  flags,
+                  triggeringPrincipal: aTriggeringPrincipal,
+                  referrerURI: aNoReferrer ? null : aReferrerURI,
+                  referrerPolicy: aReferrerPolicy,
+                  charset: aCharset,
+                  postData: aPostData,
+                });
+              } catch (ex) {
+                Cu.reportError(ex);
+              }
+            }
+
+            // If we're opening a tab related to the an existing tab, move it
+            // to a position after that tab.
+            if (openerTab &&
+                Services.prefs.getBoolPref("browser.tabs.insertRelatedAfterCurrent")) {
+
+              let lastRelatedTab = this._lastRelatedTabMap.get(openerTab);
+              let newTabPos = (lastRelatedTab || openerTab)._tPos + 1;
+              if (lastRelatedTab)
+                lastRelatedTab.owner = null;
+              else
+                t.owner = openerTab;
+              this.moveTabTo(t, newTabPos, true);
+              this._lastRelatedTabMap.set(openerTab, t);
+            }
+
+            // This field is updated regardless if we actually animate
+            // since it's important that we keep this count correct in all cases.
+            this.tabAnimationsInProgress++;
+
+            if (animate) {
+              requestAnimationFrame(function() {
+                // kick the animation off
+                t.setAttribute("fadein", "true");
+              });
+            }
+
+            return t;
+          ]]>
+        </body>
+      </method>
+
+      <method name="warnAboutClosingTabs">
+      <parameter name="aCloseTabs"/>
+      <parameter name="aTab"/>
+      <body>
+        <![CDATA[
+          var tabsToClose;
+          switch (aCloseTabs) {
+            case this.closingTabsEnum.ALL:
+              tabsToClose = this.tabs.length - this._removingTabs.length -
+                            gBrowser._numPinnedTabs;
+              break;
+            case this.closingTabsEnum.OTHER:
+              tabsToClose = this.visibleTabs.length - 1 - gBrowser._numPinnedTabs;
+              break;
+            case this.closingTabsEnum.TO_END:
+              if (!aTab)
+                throw new Error("Required argument missing: aTab");
+
+              tabsToClose = this.getTabsToTheEndFrom(aTab).length;
+              break;
+            default:
+              throw new Error("Invalid argument: " + aCloseTabs);
+          }
+
+          if (tabsToClose <= 1)
+            return true;
+
+          const pref = aCloseTabs == this.closingTabsEnum.ALL ?
+                       "browser.tabs.warnOnClose" : "browser.tabs.warnOnCloseOtherTabs";
+          var shouldPrompt = Services.prefs.getBoolPref(pref);
+          if (!shouldPrompt)
+            return true;
+
+          var ps = Services.prompt;
+
+          // default to true: if it were false, we wouldn't get this far
+          var warnOnClose = { value: true };
+
+          // focus the window before prompting.
+          // this will raise any minimized window, which will
+          // make it obvious which window the prompt is for and will
+          // solve the problem of windows "obscuring" the prompt.
+          // see bug #350299 for more details
+          window.focus();
+          var warningMessage =
+            PluralForm.get(tabsToClose, gTabBrowserBundle.GetStringFromName("tabs.closeWarningMultiple"))
+                      .replace("#1", tabsToClose);
+          var buttonPressed =
+            ps.confirmEx(window,
+                         gTabBrowserBundle.GetStringFromName("tabs.closeWarningTitle"),
+                         warningMessage,
+                         (ps.BUTTON_TITLE_IS_STRING * ps.BUTTON_POS_0)
+                         + (ps.BUTTON_TITLE_CANCEL * ps.BUTTON_POS_1),
+                         gTabBrowserBundle.GetStringFromName("tabs.closeButtonMultiple"),
+                         null, null,
+                         aCloseTabs == this.closingTabsEnum.ALL ?
+                           gTabBrowserBundle.GetStringFromName("tabs.closeWarningPromptMe") : null,
+                         warnOnClose);
+          var reallyClose = (buttonPressed == 0);
+
+          // don't set the pref unless they press OK and it's false
+          if (aCloseTabs == this.closingTabsEnum.ALL && reallyClose && !warnOnClose.value)
+            Services.prefs.setBoolPref(pref, false);
+
+          return reallyClose;
+        ]]>
+      </body>
+      </method>
+
+      <method name="getTabsToTheEndFrom">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            var tabsToEnd = [];
+            let tabs = this.visibleTabs;
+            for (let i = tabs.length - 1; tabs[i] != aTab && i >= 0; --i) {
+              tabsToEnd.push(tabs[i]);
+            }
+            return tabsToEnd;
+          ]]>
+        </body>
+      </method>
+
+      <method name="removeTabsToTheEndFrom">
+        <parameter name="aTab"/>
+        <parameter name="aParams"/>
+        <body>
+          <![CDATA[
+            if (!this.warnAboutClosingTabs(this.closingTabsEnum.TO_END, aTab))
+              return;
+
+            let removeTab = tab => {
+              // Avoid changing the selected browser several times.
+              if (tab.selected)
+                this.selectedTab = aTab;
+
+              this.removeTab(tab, aParams);
+            };
+
+            let tabs = this.getTabsToTheEndFrom(aTab);
+            let tabsWithBeforeUnload = [];
+            for (let i = tabs.length - 1; i >= 0; --i) {
+              let tab = tabs[i];
+              if (this._hasBeforeUnload(tab))
+                tabsWithBeforeUnload.push(tab);
+              else
+                removeTab(tab);
+            }
+            tabsWithBeforeUnload.forEach(removeTab);
+          ]]>
+        </body>
+      </method>
+
+      <method name="removeAllTabsBut">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            if (aTab.pinned ||
+                !this.warnAboutClosingTabs(this.closingTabsEnum.OTHER))
+              return;
+
+            let tabs = this.visibleTabs.reverse();
+            this.selectedTab = aTab;
+
+            let tabsWithBeforeUnload = [];
+            for (let i = tabs.length - 1; i >= 0; --i) {
+              let tab = tabs[i];
+              if (tab != aTab && !tab.pinned) {
+                if (this._hasBeforeUnload(tab))
+                  tabsWithBeforeUnload.push(tab);
+                else
+                  this.removeTab(tab, {animate: true});
+              }
+            }
+            for (let tab of tabsWithBeforeUnload) {
+              this.removeTab(tab, {animate: true});
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="removeCurrentTab">
+        <parameter name="aParams"/>
+        <body>
+          <![CDATA[
+            this.removeTab(this.mCurrentTab, aParams);
+          ]]>
+        </body>
+      </method>
+
+      <field name="_removingTabs">
+        []
+      </field>
+
+      <method name="removeTab">
+        <parameter name="aTab"/>
+        <parameter name="aParams"/>
+        <body>
+          <![CDATA[
+            if (aParams) {
+              var animate = aParams.animate;
+              var byMouse = aParams.byMouse;
+              var skipPermitUnload = aParams.skipPermitUnload;
+            }
+
+            // Telemetry stopwatches may already be running if removeTab gets
+            // called again for an already closing tab.
+            if (!TelemetryStopwatch.running("FX_TAB_CLOSE_TIME_ANIM_MS", aTab) &&
+                !TelemetryStopwatch.running("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab)) {
+              // Speculatevely start both stopwatches now. We'll cancel one of
+              // the two later depending on whether we're animating.
+              TelemetryStopwatch.start("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
+              TelemetryStopwatch.start("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
+            }
+            window.maybeRecordAbandonmentTelemetry(aTab, "tabClosed");
+
+            // Handle requests for synchronously removing an already
+            // asynchronously closing tab.
+            if (!animate &&
+                aTab.closing) {
+              this._endRemoveTab(aTab);
+              return;
+            }
+
+            var isLastTab = (this.tabs.length - this._removingTabs.length == 1);
+
+            if (!this._beginRemoveTab(aTab, null, null, true, skipPermitUnload)) {
+              TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
+              TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
+              return;
+            }
+
+            if (!aTab.pinned && !aTab.hidden && aTab._fullyOpen && byMouse)
+              this.tabContainer._lockTabSizing(aTab);
+            else
+              this.tabContainer._unlockTabSizing();
+
+            if (!animate /* the caller didn't opt in */ ||
+                isLastTab ||
+                aTab.pinned ||
+                aTab.hidden ||
+                this._removingTabs.length > 3 /* don't want lots of concurrent animations */ ||
+                aTab.getAttribute("fadein") != "true" /* fade-in transition hasn't been triggered yet */ ||
+                window.getComputedStyle(aTab).maxWidth == "0.1px" /* fade-in transition hasn't moved yet */ ||
+                !this.animationsEnabled) {
+              // We're not animating, so we can cancel the animation stopwatch.
+              TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
+              this._endRemoveTab(aTab);
+              return;
+            }
+
+            // We're animating, so we can cancel the non-animation stopwatch.
+            TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
+
+            aTab.style.maxWidth = ""; // ensure that fade-out transition happens
+            aTab.removeAttribute("fadein");
+            aTab.removeAttribute("bursting");
+
+            setTimeout(function(tab, tabbrowser) {
+              if (tab.parentNode &&
+                  window.getComputedStyle(tab).maxWidth == "0.1px") {
+                NS_ASSERT(false, "Giving up waiting for the tab closing animation to finish (bug 608589)");
+                tabbrowser._endRemoveTab(tab);
+              }
+            }, 3000, aTab, this);
+          ]]>
+        </body>
+      </method>
+
+      <!-- Tab close requests are ignored if the window is closing anyway,
+           e.g. when holding Ctrl+W. -->
+      <field name="_windowIsClosing">
+        false
+      </field>
+
+      <method name="_hasBeforeUnload">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            let browser = aTab.linkedBrowser;
+            return browser.isRemoteBrowser && browser.frameLoader &&
+                   browser.frameLoader.tabParent &&
+                   browser.frameLoader.tabParent.hasBeforeUnload;
+          ]]>
+        </body>
+      </method>
+
+      <method name="_beginRemoveTab">
+        <parameter name="aTab"/>
+        <parameter name="aAdoptedByTab"/>
+        <parameter name="aCloseWindowWithLastTab"/>
+        <parameter name="aCloseWindowFastpath"/>
+        <parameter name="aSkipPermitUnload"/>
+        <body>
+          <![CDATA[
+            if (aTab.closing ||
+                this._windowIsClosing)
+              return false;
+
+            var browser = this.getBrowserForTab(aTab);
+            if (!aSkipPermitUnload && !aAdoptedByTab &&
+                aTab.linkedPanel && !aTab._pendingPermitUnload &&
+                (!browser.isRemoteBrowser || this._hasBeforeUnload(aTab))) {
+              TelemetryStopwatch.start("FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS", aTab);
+
+              // We need to block while calling permitUnload() because it
+              // processes the event queue and may lead to another removeTab()
+              // call before permitUnload() returns.
+              aTab._pendingPermitUnload = true;
+              let {permitUnload, timedOut} = browser.permitUnload();
+              delete aTab._pendingPermitUnload;
+
+              TelemetryStopwatch.finish("FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS", aTab);
+
+              // If we were closed during onbeforeunload, we return false now
+              // so we don't (try to) close the same tab again. Of course, we
+              // also stop if the unload was cancelled by the user:
+              if (aTab.closing || (!timedOut && !permitUnload)) {
+                return false;
+              }
+            }
+
+            this._blurTab(aTab);
+
+            var closeWindow = false;
+            var newTab = false;
+            if (this.tabs.length - this._removingTabs.length == 1) {
+              closeWindow = aCloseWindowWithLastTab != null ? aCloseWindowWithLastTab :
+                            !window.toolbar.visible ||
+                              Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab");
+
+              if (closeWindow) {
+                // We've already called beforeunload on all the relevant tabs if we get here,
+                // so avoid calling it again:
+                window.skipNextCanClose = true;
+              }
+
+              // Closing the tab and replacing it with a blank one is notably slower
+              // than closing the window right away. If the caller opts in, take
+              // the fast path.
+              if (closeWindow &&
+                  aCloseWindowFastpath &&
+                  this._removingTabs.length == 0) {
+                // This call actually closes the window, unless the user
+                // cancels the operation.  We are finished here in both cases.
+                this._windowIsClosing = window.closeWindow(true, window.warnAboutClosingWindow);
+                return false;
+              }
+
+              newTab = true;
+            }
+            aTab._endRemoveArgs = [closeWindow, newTab];
+
+            // swapBrowsersAndCloseOther will take care of closing the window without animation.
+            if (closeWindow && aAdoptedByTab) {
+              // Remove the tab's filter to avoid leaking.
+              if (aTab.linkedPanel) {
+                this._tabFilters.delete(aTab);
+              }
+              return true;
+            }
+
+            if (!aTab._fullyOpen) {
+              // If the opening tab animation hasn't finished before we start closing the
+              // tab, decrement the animation count since _handleNewTab will not get called.
+              this.tabAnimationsInProgress--;
+            }
+
+            this.tabAnimationsInProgress++;
+
+            // Mute audio immediately to improve perceived speed of tab closure.
+            if (!aAdoptedByTab && aTab.hasAttribute("soundplaying")) {
+              // Don't persist the muted state as this wasn't a user action.
+              // This lets undo-close-tab return it to an unmuted state.
+              aTab.linkedBrowser.mute(true);
+            }
+
+            aTab.closing = true;
+            this._removingTabs.push(aTab);
+            this._visibleTabs = null; // invalidate cache
+
+            // Invalidate hovered tab state tracking for this closing tab.
+            if (this.tabContainer._hoveredTab == aTab)
+              aTab._mouseleave();
+
+            if (newTab)
+              this.addTab(BROWSER_NEW_TAB_URL, {skipAnimation: true});
+            else
+              this.tabContainer.updateVisibility();
+
+            // We're committed to closing the tab now.
+            // Dispatch a notification.
+            // We dispatch it before any teardown so that event listeners can
+            // inspect the tab that's about to close.
+            var evt = new CustomEvent("TabClose", { bubbles: true, detail: { adoptedBy: aAdoptedByTab } });
+            aTab.dispatchEvent(evt);
+
+            if (aTab.linkedPanel) {
+              if (!aAdoptedByTab && !gMultiProcessBrowser) {
+                // Prevent this tab from showing further dialogs, since we're closing it
+                var windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+                                  getInterface(Ci.nsIDOMWindowUtils);
+                windowUtils.disableDialogs();
+              }
+
+              // Remove the tab's filter and progress listener.
+              const filter = this._tabFilters.get(aTab);
+
+              browser.webProgress.removeProgressListener(filter);
+
+              const listener = this._tabListeners.get(aTab);
+              filter.removeProgressListener(listener);
+              listener.destroy();
+            }
+
+            if (browser.registeredOpenURI && !aAdoptedByTab) {
+              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI,
+                                                       browser.getAttribute("usercontextid") || 0);
+              delete browser.registeredOpenURI;
+            }
+
+            // We are no longer the primary content area.
+            browser.removeAttribute("primary");
+
+            // Remove this tab as the owner of any other tabs, since it's going away.
+            for (let tab of this.tabs) {
+              if ("owner" in tab && tab.owner == aTab)
+                // |tab| is a child of the tab we're removing, make it an orphan
+                tab.owner = null;
+            }
+
+            return true;
+          ]]>
+        </body>
+      </method>
+
+      <method name="_endRemoveTab">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            if (!aTab || !aTab._endRemoveArgs)
+              return;
+
+            var [aCloseWindow, aNewTab] = aTab._endRemoveArgs;
+            aTab._endRemoveArgs = null;
+
+            if (this._windowIsClosing) {
+              aCloseWindow = false;
+              aNewTab = false;
+            }
+
+            this.tabAnimationsInProgress--;
+
+            this._lastRelatedTabMap = new WeakMap();
+
+            // update the UI early for responsiveness
+            aTab.collapsed = true;
+            this._blurTab(aTab);
+
+            this._removingTabs.splice(this._removingTabs.indexOf(aTab), 1);
+
+            if (aCloseWindow) {
+              this._windowIsClosing = true;
+              while (this._removingTabs.length)
+                this._endRemoveTab(this._removingTabs[0]);
+            } else if (!this._windowIsClosing) {
+              if (aNewTab)
+                focusAndSelectUrlBar();
+
+              // workaround for bug 345399
+              this.tabContainer.arrowScrollbox._updateScrollButtonsDisabledState();
+            }
+
+            // We're going to remove the tab and the browser now.
+            this._tabFilters.delete(aTab);
+            this._tabListeners.delete(aTab);
+
+            var browser = this.getBrowserForTab(aTab);
+
+            if (aTab.linkedPanel) {
+              this._outerWindowIDBrowserMap.delete(browser.outerWindowID);
+
+              // Because of the way XBL works (fields just set JS
+              // properties on the element) and the code we have in place
+              // to preserve the JS objects for any elements that have
+              // JS properties set on them, the browser element won't be
+              // destroyed until the document goes away.  So we force a
+              // cleanup ourselves.
+              // This has to happen before we remove the child so that the
+              // XBL implementation of nsIObserver still works.
+              browser.destroy();
+            }
+
+            var wasPinned = aTab.pinned;
+
+            // Remove the tab ...
+            this.tabContainer.removeChild(aTab);
+
+            // ... and fix up the _tPos properties immediately.
+            for (let i = aTab._tPos; i < this.tabs.length; i++)
+              this.tabs[i]._tPos = i;
+
+            if (!this._windowIsClosing) {
+              if (wasPinned)
+                this.tabContainer._positionPinnedTabs();
+
+              // update tab close buttons state
+              this.tabContainer._updateCloseButtons();
+
+              setTimeout(function(tabs) {
+                tabs._lastTabClosedByMouse = false;
+              }, 0, this.tabContainer);
+            }
+
+            // update tab positional properties and attributes
+            this.selectedTab._selected = true;
+            this.tabContainer._setPositionalAttributes();
+
+            // Removing the panel requires fixing up selectedPanel immediately
+            // (see below), which would be hindered by the potentially expensive
+            // browser removal. So we remove the browser and the panel in two
+            // steps.
+
+            var panel = this.getNotificationBox(browser);
+
+            // In the multi-process case, it's possible an asynchronous tab switch
+            // is still underway. If so, then it's possible that the last visible
+            // browser is the one we're in the process of removing. There's the
+            // risk of displaying preloaded browsers that are at the end of the
+            // deck if we remove the browser before the switch is complete, so
+            // we alert the switcher in order to show a spinner instead.
+            if (this._switcher) {
+              this._switcher.onTabRemoved(aTab);
+            }
+
+            // This will unload the document. An unload handler could remove
+            // dependant tabs, so it's important that the tabbrowser is now in
+            // a consistent state (tab removed, tab positions updated, etc.).
+            browser.remove();
+
+            // Release the browser in case something is erroneously holding a
+            // reference to the tab after its removal.
+            this._tabForBrowser.delete(aTab.linkedBrowser);
+            aTab.linkedBrowser = null;
+
+            panel.remove();
+
+            // closeWindow might wait an arbitrary length of time if we're supposed
+            // to warn about closing the window, so we'll just stop the tab close
+            // stopwatches here instead.
+            TelemetryStopwatch.finish("FX_TAB_CLOSE_TIME_ANIM_MS", aTab,
+                                      true /* aCanceledOkay */);
+            TelemetryStopwatch.finish("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab,
+                                      true /* aCanceledOkay */);
+
+            if (aCloseWindow)
+              this._windowIsClosing = closeWindow(true, window.warnAboutClosingWindow);
+          ]]>
+        </body>
+      </method>
+
+      <method name="_blurTab">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            if (!aTab.selected)
+              return;
+
+            if (aTab.owner &&
+                !aTab.owner.hidden &&
+                !aTab.owner.closing &&
+                Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")) {
+              this.selectedTab = aTab.owner;
+              return;
+            }
+
+            // Switch to a visible tab unless there aren't any others remaining
+            let remainingTabs = this.visibleTabs;
+            let numTabs = remainingTabs.length;
+            if (numTabs == 0 || numTabs == 1 && remainingTabs[0] == aTab) {
+              remainingTabs = Array.filter(this.tabs, function(tab) {
+                return !tab.closing;
+              }, this);
+            }
+
+            // Try to find a remaining tab that comes after the given tab
+            var tab = aTab;
+            do {
+              tab = tab.nextSibling;
+            } while (tab && remainingTabs.indexOf(tab) == -1);
+
+            if (!tab) {
+              tab = aTab;
+
+              do {
+                tab = tab.previousSibling;
+              } while (tab && remainingTabs.indexOf(tab) == -1);
+            }
+
+            this.selectedTab = tab;
+          ]]>
+        </body>
+      </method>
+
+      <method name="swapBrowsersAndCloseOther">
+        <parameter name="aOurTab"/>
+        <parameter name="aOtherTab"/>
+        <body>
+          <![CDATA[
+            // Do not allow transfering a private tab to a non-private window
+            // and vice versa.
+            if (PrivateBrowsingUtils.isWindowPrivate(window) !=
+                PrivateBrowsingUtils.isWindowPrivate(aOtherTab.ownerGlobal))
+              return;
+
+            let ourBrowser = this.getBrowserForTab(aOurTab);
+            let otherBrowser = aOtherTab.linkedBrowser;
+
+            // Can't swap between chrome and content processes.
+            if (ourBrowser.isRemoteBrowser != otherBrowser.isRemoteBrowser)
+              return;
+
+            // Keep the userContextId if set on other browser
+            if (otherBrowser.hasAttribute("usercontextid")) {
+              ourBrowser.setAttribute("usercontextid", otherBrowser.getAttribute("usercontextid"));
+            }
+
+            // That's gBrowser for the other window, not the tab's browser!
+            var remoteBrowser = aOtherTab.ownerGlobal.gBrowser;
+            var isPending = aOtherTab.hasAttribute("pending");
+
+            let otherTabListener = remoteBrowser._tabListeners.get(aOtherTab);
+            let stateFlags = otherTabListener.mStateFlags;
+
+            // Expedite the removal of the icon if it was already scheduled.
+            if (aOtherTab._soundPlayingAttrRemovalTimer) {
+              clearTimeout(aOtherTab._soundPlayingAttrRemovalTimer);
+              aOtherTab._soundPlayingAttrRemovalTimer = 0;
+              aOtherTab.removeAttribute("soundplaying");
+              remoteBrowser._tabAttrModified(aOtherTab, ["soundplaying"]);
+            }
+
+            // First, start teardown of the other browser.  Make sure to not
+            // fire the beforeunload event in the process.  Close the other
+            // window if this was its last tab.
+            if (!remoteBrowser._beginRemoveTab(aOtherTab, aOurTab, true))
+              return;
+
+            // If this is the last tab of the window, hide the window
+            // immediately without animation before the docshell swap, to avoid
+            // about:blank being painted.
+            let [closeWindow] = aOtherTab._endRemoveArgs;
+            if (closeWindow) {
+              let win = aOtherTab.ownerGlobal;
+              let dwu = win.QueryInterface(Ci.nsIInterfaceRequestor)
+                           .getInterface(Ci.nsIDOMWindowUtils);
+              dwu.suppressAnimation(true);
+              // Only suppressing window animations isn't enough to avoid
+              // an empty content area being painted.
+              let baseWin = win.QueryInterface(Ci.nsIInterfaceRequestor)
+                               .getInterface(Ci.nsIDocShell)
+                               .QueryInterface(Ci.nsIDocShellTreeItem)
+                               .treeOwner
+                               .QueryInterface(Ci.nsIBaseWindow);
+              baseWin.visibility = false;
+            }
+
+            let modifiedAttrs = [];
+            if (aOtherTab.hasAttribute("muted")) {
+              aOurTab.setAttribute("muted", "true");
+              aOurTab.muteReason = aOtherTab.muteReason;
+              ourBrowser.mute();
+              modifiedAttrs.push("muted");
+            }
+            if (aOtherTab.hasAttribute("soundplaying")) {
+              aOurTab.setAttribute("soundplaying", "true");
+              modifiedAttrs.push("soundplaying");
+            }
+            if (aOtherTab.hasAttribute("usercontextid")) {
+              aOurTab.setUserContextId(aOtherTab.getAttribute("usercontextid"));
+              modifiedAttrs.push("usercontextid");
+            }
+            if (aOtherTab.hasAttribute("sharing")) {
+              aOurTab.setAttribute("sharing", aOtherTab.getAttribute("sharing"));
+              modifiedAttrs.push("sharing");
+              aOurTab._sharingState = aOtherTab._sharingState;
+              webrtcUI.swapBrowserForNotification(otherBrowser, ourBrowser);
+            }
+
+            SitePermissions.copyTemporaryPermissions(otherBrowser, ourBrowser);
+
+            // If the other tab is pending (i.e. has not been restored, yet)
+            // then do not switch docShells but retrieve the other tab's state
+            // and apply it to our tab.
+            if (isPending) {
+              SessionStore.setTabState(aOurTab, SessionStore.getTabState(aOtherTab));
+
+              // Make sure to unregister any open URIs.
+              this._swapRegisteredOpenURIs(ourBrowser, otherBrowser);
+            } else {
+              // Workarounds for bug 458697
+              // Icon might have been set on DOMLinkAdded, don't override that.
+              if (!ourBrowser.mIconURL && otherBrowser.mIconURL)
+                this.setIcon(aOurTab, otherBrowser.mIconURL, otherBrowser.contentPrincipal, otherBrowser.contentRequestContextID);
+              var isBusy = aOtherTab.hasAttribute("busy");
+              if (isBusy) {
+                aOurTab.setAttribute("busy", "true");
+                modifiedAttrs.push("busy");
+                if (aOurTab.selected)
+                  this.mIsBusy = true;
+              }
+
+              this._swapBrowserDocShells(aOurTab, otherBrowser, Ci.nsIBrowser.SWAP_DEFAULT, stateFlags);
+            }
+
+            // Unregister the previously opened URI
+            if (otherBrowser.registeredOpenURI) {
+              this._unifiedComplete.unregisterOpenPage(otherBrowser.registeredOpenURI,
+                                                       otherBrowser.getAttribute("usercontextid") || 0);
+              delete otherBrowser.registeredOpenURI;
+            }
+
+            // Handle findbar data (if any)
+            let otherFindBar = aOtherTab._findBar;
+            if (otherFindBar &&
+                otherFindBar.findMode == otherFindBar.FIND_NORMAL) {
+              let ourFindBar = this.getFindBar(aOurTab);
+              ourFindBar._findField.value = otherFindBar._findField.value;
+              if (!otherFindBar.hidden)
+                ourFindBar.onFindCommand();
+            }
+
+            // Finish tearing down the tab that's going away.
+            if (closeWindow) {
+              aOtherTab.ownerGlobal.close();
+            } else {
+              remoteBrowser._endRemoveTab(aOtherTab);
+            }
+
+            this.setTabTitle(aOurTab);
+
+            // If the tab was already selected (this happpens in the scenario
+            // of replaceTabWithWindow), notify onLocationChange, etc.
+            if (aOurTab.selected)
+              this.updateCurrentBrowser(true);
+
+            if (modifiedAttrs.length) {
+              this._tabAttrModified(aOurTab, modifiedAttrs);
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="swapBrowsers">
+        <parameter name="aOurTab"/>
+        <parameter name="aOtherTab"/>
+        <parameter name="aFlags"/>
+        <body>
+          <![CDATA[
+            let otherBrowser = aOtherTab.linkedBrowser;
+            let otherTabBrowser = otherBrowser.getTabBrowser();
+
+            // We aren't closing the other tab so, we also need to swap its tablisteners.
+            let filter = otherTabBrowser._tabFilters.get(aOtherTab);
+            let tabListener = otherTabBrowser._tabListeners.get(aOtherTab);
+            otherBrowser.webProgress.removeProgressListener(filter);
+            filter.removeProgressListener(tabListener);
+
+            // Perform the docshell swap through the common mechanism.
+            this._swapBrowserDocShells(aOurTab, otherBrowser, aFlags);
+
+            // Restore the listeners for the swapped in tab.
+            tabListener = otherTabBrowser.mTabProgressListener(aOtherTab, otherBrowser, false, false);
+            otherTabBrowser._tabListeners.set(aOtherTab, tabListener);
+
+            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
+            filter.addProgressListener(tabListener, notifyAll);
+            otherBrowser.webProgress.addProgressListener(filter, notifyAll);
+          ]]>
+        </body>
+      </method>
+
+      <method name="_swapBrowserDocShells">
+        <parameter name="aOurTab"/>
+        <parameter name="aOtherBrowser"/>
+        <parameter name="aFlags"/>
+        <parameter name="aStateFlags"/>
+        <body>
+          <![CDATA[
+            // aOurTab's browser needs to be inserted now if it hasn't already.
+            this._insertBrowser(aOurTab);
+
+            // Unhook our progress listener
+            const filter = this._tabFilters.get(aOurTab);
+            let tabListener = this._tabListeners.get(aOurTab);
+            let ourBrowser = this.getBrowserForTab(aOurTab);
+            ourBrowser.webProgress.removeProgressListener(filter);
+            filter.removeProgressListener(tabListener);
+
+            // Make sure to unregister any open URIs.
+            this._swapRegisteredOpenURIs(ourBrowser, aOtherBrowser);
+
+            // Unmap old outerWindowIDs.
+            this._outerWindowIDBrowserMap.delete(ourBrowser.outerWindowID);
+            let remoteBrowser = aOtherBrowser.ownerGlobal.gBrowser;
+            if (remoteBrowser) {
+              remoteBrowser._outerWindowIDBrowserMap.delete(aOtherBrowser.outerWindowID);
+            }
+
+            // If switcher is active, it will intercept swap events and
+            // react as needed.
+            if (!this._switcher) {
+              aOtherBrowser.docShellIsActive = this.shouldActivateDocShell(ourBrowser);
+            }
+
+            // Swap the docshells
+            ourBrowser.swapDocShells(aOtherBrowser);
+
+            if (ourBrowser.isRemoteBrowser) {
+              // Switch outerWindowIDs for remote browsers.
+              let ourOuterWindowID = ourBrowser._outerWindowID;
+              ourBrowser._outerWindowID = aOtherBrowser._outerWindowID;
+              aOtherBrowser._outerWindowID = ourOuterWindowID;
+            }
+
+            // Register new outerWindowIDs.
+            this._outerWindowIDBrowserMap.set(ourBrowser.outerWindowID, ourBrowser);
+            if (remoteBrowser) {
+              remoteBrowser._outerWindowIDBrowserMap.set(aOtherBrowser.outerWindowID, aOtherBrowser);
+            }
+
+            if (!(aFlags & Ci.nsIBrowser.SWAP_KEEP_PERMANENT_KEY)) {
+              // Swap permanentKey properties.
+              let ourPermanentKey = ourBrowser.permanentKey;
+              ourBrowser.permanentKey = aOtherBrowser.permanentKey;
+              aOtherBrowser.permanentKey = ourPermanentKey;
+              aOurTab.permanentKey = ourBrowser.permanentKey;
+              if (remoteBrowser) {
+                let otherTab = remoteBrowser.getTabForBrowser(aOtherBrowser);
+                if (otherTab) {
+                  otherTab.permanentKey = aOtherBrowser.permanentKey;
+                }
+              }
+            }
+
+            // Restore the progress listener
+            tabListener = this.mTabProgressListener(aOurTab, ourBrowser, false, false,
+                                                    aStateFlags);
+            this._tabListeners.set(aOurTab, tabListener);
+
+            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
+            filter.addProgressListener(tabListener, notifyAll);
+            ourBrowser.webProgress.addProgressListener(filter, notifyAll);
+          ]]>
+        </body>
+      </method>
+
+      <method name="_swapRegisteredOpenURIs">
+        <parameter name="aOurBrowser"/>
+        <parameter name="aOtherBrowser"/>
+        <body>
+          <![CDATA[
+            // Swap the registeredOpenURI properties of the two browsers
+            let tmp = aOurBrowser.registeredOpenURI;
+            delete aOurBrowser.registeredOpenURI;
+            if (aOtherBrowser.registeredOpenURI) {
+              aOurBrowser.registeredOpenURI = aOtherBrowser.registeredOpenURI;
+              delete aOtherBrowser.registeredOpenURI;
+            }
+            if (tmp) {
+              aOtherBrowser.registeredOpenURI = tmp;
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="reloadAllTabs">
+        <body>
+          <![CDATA[
+            let tabs = this.visibleTabs;
+            let l = tabs.length;
+            for (var i = 0; i < l; i++) {
+              try {
+                this.getBrowserForTab(tabs[i]).reload();
+              } catch (e) {
+                // ignore failure to reload so others will be reloaded
+              }
+            }
+          ]]>
+        </body>
+      </method>
+
+      <method name="reloadTab">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            let browser = this.getBrowserForTab(aTab);
+            // Reset temporary permissions on the current tab. This is done here
+            // because we only want to reset permissions on user reload.
+            SitePermissions.clearTemporaryPermissions(browser);
+            browser.reload();
+          ]]>
+        </body>
+      </method>
+
+      <method name="addProgressListener">
+        <parameter name="aListener"/>
+        <body>
+          <![CDATA[
+            if (arguments.length != 1) {
+              Components.utils.reportError("gBrowser.addProgressListener was " +
+                                           "called with a second argument, " +
+                                           "which is not supported. See bug " +
+                                           "608628. Call stack: " + new Error().stack);
+            }
+
+            this.mProgressListeners.push(aListener);
+          ]]>
+        </body>
+      </method>
+
+      <method name="removeProgressListener">
+        <parameter name="aListener"/>
+        <body>
+          <![CDATA[
+            this.mProgressListeners =
+              this.mProgressListeners.filter(l => l != aListener);
+         ]]>
+        </body>
+      </method>
+
+      <method name="addTabsProgressListener">
+        <parameter name="aListener"/>
+        <body>
+          this.mTabsProgressListeners.push(aListener);
+        </body>
+      </method>
+
+      <method name="removeTabsProgressListener">
+        <parameter name="aListener"/>
+        <body>
+        <![CDATA[
+          this.mTabsProgressListeners =
+            this.mTabsProgressListeners.filter(l => l != aListener);
+        ]]>
+        </body>
+      </method>
+
+      <method name="getBrowserForTab">
+        <parameter name="aTab"/>
+        <body>
+        <![CDATA[
+          return aTab.linkedBrowser;
+        ]]>
+        </body>
+      </method>
+
+      <method name="showOnlyTheseTabs">
+        <parameter name="aTabs"/>
+        <body>
+        <![CDATA[
+          for (let tab of this.tabs) {
+            if (aTabs.indexOf(tab) == -1)
+              this.hideTab(tab);
+            else
+              this.showTab(tab);
+          }
+
+          this.tabContainer._handleTabSelect(true);
+        ]]>
+        </body>
+      </method>
+
+      <method name="showTab">
+        <parameter name="aTab"/>
+        <body>
+        <![CDATA[
+          if (aTab.hidden) {
+            aTab.removeAttribute("hidden");
+            this._visibleTabs = null; // invalidate cache
+
+            this.tabContainer._updateCloseButtons();
+
+            this.tabContainer._setPositionalAttributes();
+
+            let event = document.createEvent("Events");
+            event.initEvent("TabShow", true, false);
+            aTab.dispatchEvent(event);
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="hideTab">
+        <parameter name="aTab"/>
+        <body>
+        <![CDATA[
+          if (!aTab.hidden && !aTab.pinned && !aTab.selected &&
+              !aTab.closing) {
+            aTab.setAttribute("hidden", "true");
+            this._visibleTabs = null; // invalidate cache
+
+            this.tabContainer._updateCloseButtons();
+
+            this.tabContainer._setPositionalAttributes();
+
+            let event = document.createEvent("Events");
+            event.initEvent("TabHide", true, false);
+            aTab.dispatchEvent(event);
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="selectTabAtIndex">
+        <parameter name="aIndex"/>
+        <parameter name="aEvent"/>
+        <body>
+        <![CDATA[
+          let tabs = this.visibleTabs;
+
+          // count backwards for aIndex < 0
+          if (aIndex < 0) {
+            aIndex += tabs.length;
+            // clamp at index 0 if still negative.
+            if (aIndex < 0)
+              aIndex = 0;
+          } else if (aIndex >= tabs.length) {
+            // clamp at right-most tab if out of range.
+            aIndex = tabs.length - 1;
+          }
+
+          this.selectedTab = tabs[aIndex];
+
+          if (aEvent) {
+            aEvent.preventDefault();
+            aEvent.stopPropagation();
+          }
+        ]]>
+        </body>
+      </method>
+
+      <property name="selectedTab">
+        <getter>
+          return this.mCurrentTab;
+        </getter>
+        <setter>
+          <![CDATA[
+          if (gNavToolbox.collapsed && !this._allowTabChange) {
+            return this.tabbox.selectedTab;
+          }
+          // Update the tab
+          this.tabbox.selectedTab = val;
+          return val;
+          ]]>
+        </setter>
+      </property>
+
+      <property name="selectedBrowser"
+                onget="return this.mCurrentBrowser;"
+                readonly="true"/>
+
+      <field name="browsers" readonly="true">
+        <![CDATA[
+          // This defines a proxy which allows us to access browsers by
+          // index without actually creating a full array of browsers.
+          new Proxy([], {
+            has: (target, name) => {
+              if (typeof name == "string" && Number.isInteger(parseInt(name))) {
+                return (name in this.tabs);
+              }
+              return false;
+            },
+            get: (target, name) => {
+              if (name == "length") {
+                return this.tabs.length;
+              }
+              if (typeof name == "string" && Number.isInteger(parseInt(name))) {
+                if (!(name in this.tabs)) {
+                  return undefined;
+                }
+                return this.tabs[name].linkedBrowser;
+              }
+              return target[name];
+            }
+          });
+        ]]>
+      </field>
+
+      <!-- Moves a tab to a new browser window, unless it's already the only tab
+           in the current window, in which case this will do nothing. -->
+      <method name="replaceTabWithWindow">
+        <parameter name="aTab"/>
+        <parameter name="aOptions"/>
+        <body>
+          <![CDATA[
+            if (this.tabs.length == 1)
+              return null;
+
+            var options = "chrome,dialog=no,all";
+            for (var name in aOptions)
+              options += "," + name + "=" + aOptions[name];
+
+            // Play the tab closing animation to give immediate feedback while
+            // waiting for the new window to appear.
+            // content area when the docshells are swapped.
+            if (this.animationsEnabled) {
+              aTab.style.maxWidth = ""; // ensure that fade-out transition happens
+              aTab.removeAttribute("fadein");
+            }
+
+            // tell a new window to take the "dropped" tab
+            return window.openDialog(getBrowserURL(), "_blank", options, aTab);
+          ]]>
+        </body>
+      </method>
+
+      <method name="moveTabTo">
+        <parameter name="aTab"/>
+        <parameter name="aIndex"/>
+        <parameter name="aKeepRelatedTabs"/>
+        <body>
+        <![CDATA[
+          var oldPosition = aTab._tPos;
+          if (oldPosition == aIndex)
+            return;
+
+          // Don't allow mixing pinned and unpinned tabs.
+          if (aTab.pinned)
+            aIndex = Math.min(aIndex, this._numPinnedTabs - 1);
+          else
+            aIndex = Math.max(aIndex, this._numPinnedTabs);
+          if (oldPosition == aIndex)
+            return;
+
+          if (!aKeepRelatedTabs) {
+            this._lastRelatedTabMap = new WeakMap();
+          }
+
+          let wasFocused = (document.activeElement == this.mCurrentTab);
+
+          aIndex = aIndex < aTab._tPos ? aIndex : aIndex + 1;
+
+          // invalidate cache
+          this._visibleTabs = null;
+
+          // use .item() instead of [] because dragging to the end of the strip goes out of
+          // bounds: .item() returns null (so it acts like appendChild), but [] throws
+          this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));
+
+          for (let i = 0; i < this.tabs.length; i++) {
+            this.tabs[i]._tPos = i;
+            this.tabs[i]._selected = false;
+          }
+
+          // If we're in the midst of an async tab switch while calling
+          // moveTabTo, we can get into a case where _visuallySelected
+          // is set to true on two different tabs.
+          //
+          // What we want to do in moveTabTo is to remove logical selection
+          // from all tabs, and then re-add logical selection to mCurrentTab
+          // (and visual selection as well if we're not running with e10s, which
+          // setting _selected will do automatically).
+          //
+          // If we're running with e10s, then the visual selection will not
+          // be changed, which is fine, since if we weren't in the midst of a
+          // tab switch, the previously visually selected tab should still be
+          // correct, and if we are in the midst of a tab switch, then the async
+          // tab switcher will set the visually selected tab once the tab switch
+          // has completed.
+          this.mCurrentTab._selected = true;
+
+          if (wasFocused)
+            this.mCurrentTab.focus();
+
+          this.tabContainer._handleTabSelect(true);
+
+          if (aTab.pinned)
+            this.tabContainer._positionPinnedTabs();
+
+          this.tabContainer._setPositionalAttributes();
+
+          var evt = document.createEvent("UIEvents");
+          evt.initUIEvent("TabMove", true, false, window, oldPosition);
+          aTab.dispatchEvent(evt);
+        ]]>
+        </body>
+      </method>
+
+      <method name="moveTabForward">
+        <body>
+          <![CDATA[
+            let nextTab = this.mCurrentTab.nextSibling;
+            while (nextTab && nextTab.hidden)
+              nextTab = nextTab.nextSibling;
+
+            if (nextTab)
+              this.moveTabTo(this.mCurrentTab, nextTab._tPos);
+            else if (this.arrowKeysShouldWrap)
+              this.moveTabToStart();
+          ]]>
+        </body>
+      </method>
+
+      <!-- Adopts a tab from another browser window, and inserts it at aIndex -->
+      <method name="adoptTab">
+        <parameter name="aTab"/>
+        <parameter name="aIndex"/>
+        <parameter name="aSelectTab"/>
+        <body>
+        <![CDATA[
+          // Swap the dropped tab with a new one we create and then close
+          // it in the other window (making it seem to have moved between
+          // windows). We also ensure that the tab we create to swap into has
+          // the same remote type and process as the one we're swapping in.
+          // This makes sure we don't get a short-lived process for the new tab.
+          let linkedBrowser = aTab.linkedBrowser;
+          let params = { eventDetail: { adoptedTab: aTab },
+                         preferredRemoteType: linkedBrowser.remoteType,
+                         sameProcessAsFrameLoader: linkedBrowser.frameLoader,
+                         skipAnimation: true };
+          if (aTab.hasAttribute("usercontextid")) {
+            // new tab must have the same usercontextid as the old one
+            params.userContextId = aTab.getAttribute("usercontextid");
+          }
+          let newTab = this.addTab("about:blank", params);
+          let newBrowser = this.getBrowserForTab(newTab);
+
+          // Stop the about:blank load.
+          newBrowser.stop();
+          // Make sure it has a docshell.
+          newBrowser.docShell;
+
+          let numPinned = this._numPinnedTabs;
+          if (aIndex < numPinned || (aTab.pinned && aIndex == numPinned)) {
+            this.pinTab(newTab);
+          }
+
+          this.moveTabTo(newTab, aIndex);
+
+          // We need to select the tab before calling swapBrowsersAndCloseOther
+          // so that window.content in chrome windows points to the right tab
+          // when pagehide/show events are fired. This is no longer necessary
+          // for any exiting browser code, but it may be necessary for add-on
+          // compatibility.
+          if (aSelectTab) {
+            this.selectedTab = newTab;
+          }
+
+          aTab.parentNode._finishAnimateTabMove();
+          this.swapBrowsersAndCloseOther(newTab, aTab);
+
+          if (aSelectTab) {
+            // Call updateCurrentBrowser to make sure the URL bar is up to date
+            // for our new tab after we've done swapBrowsersAndCloseOther.
+            this.updateCurrentBrowser(true);
+          }
+
+          return newTab;
+        ]]>
+        </body>
+      </method>
+
+
+      <method name="moveTabBackward">
+        <body>
+          <![CDATA[
+            let previousTab = this.mCurrentTab.previousSibling;
+            while (previousTab && previousTab.hidden)
+              previousTab = previousTab.previousSibling;
+
+            if (previousTab)
+              this.moveTabTo(this.mCurrentTab, previousTab._tPos);
+            else if (this.arrowKeysShouldWrap)
+              this.moveTabToEnd();
+          ]]>
+        </body>
+      </method>
+
+      <method name="moveTabToStart">
+        <body>
+          <![CDATA[
+            var tabPos = this.mCurrentTab._tPos;
+            if (tabPos > 0)
+              this.moveTabTo(this.mCurrentTab, 0);
+          ]]>
+        </body>
+      </method>
+
+      <method name="moveTabToEnd">
+        <body>
+          <![CDATA[
+            var tabPos = this.mCurrentTab._tPos;
+            if (tabPos < this.browsers.length - 1)
+              this.moveTabTo(this.mCurrentTab, this.browsers.length - 1);
+          ]]>
+        </body>
+      </method>
+
+      <method name="moveTabOver">
+        <parameter name="aEvent"/>
+        <body>
+          <![CDATA[
+            var direction = window.getComputedStyle(this.parentNode).direction;
+            if ((direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||
+                (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))
+              this.moveTabForward();
+            else
+              this.moveTabBackward();
+          ]]>
+        </body>
+      </method>
+
+      <method name="duplicateTab">
+        <parameter name="aTab"/><!-- can be from a different window as well -->
+        <parameter name="aRestoreTabImmediately"/><!-- can defer loading of the tab contents -->
+        <body>
+          <![CDATA[
+            return SessionStore.duplicateTab(window, aTab, 0, aRestoreTabImmediately);
+          ]]>
+        </body>
+      </method>
+
+      <!--
+        List of browsers whose docshells must be active in order for print preview
+        to work.
+      -->
+      <field name="_printPreviewBrowsers">
+        new Set()
+      </field>
+
+      <method name="activateBrowserForPrintPreview">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            this._printPreviewBrowsers.add(aBrowser);
+            if (this._switcher) {
+              this._switcher.activateBrowserForPrintPreview(aBrowser);
+            }
+            aBrowser.docShellIsActive = true;
+          ]]>
+        </body>
+      </method>
+
+      <method name="deactivatePrintPreviewBrowsers">
+        <body>
+          <![CDATA[
+            let browsers = this._printPreviewBrowsers;
+            this._printPreviewBrowsers = new Set();
+            for (let browser of browsers) {
+              browser.docShellIsActive = this.shouldActivateDocShell(browser);
+            }
+          ]]>
+        </body>
+      </method>
+
+      <!--
+        Returns true if a given browser's docshell should be active.
+      -->
+      <method name="shouldActivateDocShell">
+        <parameter name="aBrowser"/>
+        <body>
+          <![CDATA[
+            if (this._switcher) {
+              return this._switcher.shouldActivateDocShell(aBrowser);
+            }
+            return (aBrowser == this.selectedBrowser &&
+                    window.windowState != window.STATE_MINIMIZED &&
+                    !window.isFullyOccluded) ||
+                   this._printPreviewBrowsers.has(aBrowser);
+          ]]>
+        </body>
+      </method>
+
+      <!--
+        The tab switcher is responsible for asynchronously switching
+        tabs in e10s. It waits until the new tab is ready (i.e., the
+        layer tree is available) before switching to it. Then it
+        unloads the layer tree for the old tab.
+
+        The tab switcher is a state machine. For each tab, it
+        maintains state about whether the layer tree for the tab is
+        available, being loaded, being unloaded, or unavailable. It
+        also keeps track of the tab currently being displayed, the tab
+        it's trying to load, and the tab the user has asked to switch
+        to. The switcher object is created upon tab switch. It is
+        released when there are no pending tabs to load or unload.
+
+        The following general principles have guided the design:
+
+        1. We only request one layer tree at a time. If the user
+        switches to a different tab while waiting, we don't request
+        the new layer tree until the old tab has loaded or timed out.
+
+        2. If loading the layers for a tab times out, we show the
+        spinner and possibly request the layer tree for another tab if
+        the user has requested one.
+
+        3. We discard layer trees on a delay. This way, if the user is
+        switching among the same tabs frequently, we don't continually
+        load the same tabs.
+
+        It's important that we always show either the spinner or a tab
+        whose layers are available. Otherwise the compositor will draw
+        an entirely black frame, which is very jarring. To ensure this
+        never happens when switching away from a tab, we assume the
+        old tab might still be drawn until a MozAfterPaint event
+        occurs. Because layout and compositing happen asynchronously,
+        we don't have any other way of knowing when the switch
+        actually takes place. Therefore, we don't unload the old tab
+        until the next MozAfterPaint event.
+      -->
+      <field name="_switcher">null</field>
+      <method name="_getSwitcher">
+        <body><![CDATA[
+          if (this._switcher) {
+            return this._switcher;
+          }
+
+          let switcher = {
+            // How long to wait for a tab's layers to load. After this
+            // time elapses, we're free to put up the spinner and start
+            // trying to load a different tab.
+            TAB_SWITCH_TIMEOUT: 400 /* ms */,
+
+            // When the user hasn't switched tabs for this long, we unload
+            // layers for all tabs that aren't in use.
+            UNLOAD_DELAY: 300 /* ms */,
+
+            // The next three tabs form the principal state variables.
+            // See the assertions in postActions for their invariants.
+
+            // Tab the user requested most recently.
+            requestedTab: this.selectedTab,
+
+            // Tab we're currently trying to load.
+            loadingTab: null,
+
+            // We show this tab in case the requestedTab hasn't loaded yet.
+            lastVisibleTab: this.selectedTab,
+
+            // Auxilliary state variables:
+
+            visibleTab: this.selectedTab,   // Tab that's on screen.
+            spinnerTab: null,               // Tab showing a spinner.
+            blankTab: null,                 // Tab showing blank.
+            originalTab: this.selectedTab,  // Tab that we started on.
+
+            tabbrowser: this,  // Reference to gBrowser.
+            loadTimer: null,   // TAB_SWITCH_TIMEOUT nsITimer instance.
+            unloadTimer: null, // UNLOAD_DELAY nsITimer instance.
+
+            // Map from tabs to STATE_* (below).
+            tabState: new Map(),
+
+            // True if we're in the midst of switching tabs.
+            switchInProgress: false,
+
+            // Keep an exact list of content processes (tabParent) in which
+            // we're actively suppressing the display port. This gives a robust
+            // way to make sure we don't forget to un-suppress.
+            activeSuppressDisplayport: new Set(),
+
+            // Set of tabs that might be visible right now. We maintain
+            // this set because we can't be sure when a tab is actually
+            // drawn. A tab is added to this set when we ask to make it
+            // visible. All tabs but the most recently shown tab are
+            // removed from the set upon MozAfterPaint.
+            maybeVisibleTabs: new Set([this.selectedTab]),
+
+            // This holds onto the set of tabs that we've been asked to warm up.
+            // This is used only for Telemetry and logging, and (in order to not
+            // over-complicate the async tab switcher any further) has nothing to do
+            // with how warmed tabs are loaded and unloaded.
+            warmingTabs: new WeakSet(),
+
+            STATE_UNLOADED: 0,
+            STATE_LOADING: 1,
+            STATE_LOADED: 2,
+            STATE_UNLOADING: 3,
+
+            // re-entrancy guard:
+            _processing: false,
+
+            // Wraps nsITimer. Must not use the vanilla setTimeout and
+            // clearTimeout, because they will be blocked by nsIPromptService
+            // dialogs.
+            setTimer(callback, timeout) {
+              let event = {
+                notify: callback
+              };
+
+              var timer = Cc["@mozilla.org/timer;1"]
+                .createInstance(Components.interfaces.nsITimer);
+              timer.initWithCallback(event, timeout, Ci.nsITimer.TYPE_ONE_SHOT);
+              return timer;
+            },
+
+            clearTimer(timer) {
+              timer.cancel();
+            },
+
+            getTabState(tab) {
+              let state = this.tabState.get(tab);
+              if (state === undefined) {
+                return this.STATE_UNLOADED;
+              }
+              return state;
+            },
+
+            setTabStateNoAction(tab, state) {
+              if (state == this.STATE_UNLOADED) {
+                this.tabState.delete(tab);
+              } else {
+                this.tabState.set(tab, state);
+              }
+            },
+
+            setTabState(tab, state) {
+              this.setTabStateNoAction(tab, state);
+
+              let browser = tab.linkedBrowser;
+              let {tabParent} = browser.frameLoader;
+              if (state == this.STATE_LOADING) {
+                this.assert(!this.minimizedOrFullyOccluded);
+
+                if (!this.tabbrowser.tabWarmingEnabled) {
+                  browser.docShellIsActive = true;
+                }
+
+                if (tabParent) {
+                  browser.renderLayers = true;
+                } else {
+                  this.onLayersReady(browser);
+                }
+              } else if (state == this.STATE_UNLOADING) {
+                this.unwarmTab(tab);
+                // Setting the docShell to be inactive will also cause it
+                // to stop rendering layers.
+                browser.docShellIsActive = false;
+                if (!tabParent) {
+                  this.onLayersCleared(browser);
+                }
+              } else if (state == this.STATE_LOADED) {
+                this.maybeActivateDocShell(tab);
+              }
+
+              if (!tab.linkedBrowser.isRemoteBrowser) {
+                // setTabState is potentially re-entrant in the non-remote case,
+                // so we must re-get the state for this assertion.
+                let nonRemoteState = this.getTabState(tab);
+                // Non-remote tabs can never stay in the STATE_LOADING
+                // or STATE_UNLOADING states. By the time this function
+                // exits, a non-remote tab must be in STATE_LOADED or
+                // STATE_UNLOADED, since the painting and the layer
+                // upload happen synchronously.
+                this.assert(nonRemoteState == this.STATE_UNLOADED ||
+                            nonRemoteState == this.STATE_LOADED);
+              }
+            },
+
+            get minimizedOrFullyOccluded() {
+              return window.windowState == window.STATE_MINIMIZED ||
+                     window.isFullyOccluded;
+            },
+
+            init() {
+              this.log("START");
+
+              window.addEventListener("MozAfterPaint", this);
+              window.addEventListener("MozLayerTreeReady", this);
+              window.addEventListener("MozLayerTreeCleared", this);
+              window.addEventListener("TabRemotenessChange", this);
+              window.addEventListener("sizemodechange", this);
+              window.addEventListener("occlusionstatechange", this);
+              window.addEventListener("SwapDocShells", this, true);
+              window.addEventListener("EndSwapDocShells", this, true);
+
+              let initialTab = this.requestedTab;
+
+              for (let tab of this.tabbrowser.tabs) {
+                if (tab == initialTab && this.minimizedOrFullyOccluded) {
+                  continue;
+                }
+
+                if (tab.linkedPanel) {
+                  let b = tab.linkedBrowser;
+                  let state;
+                  if (b.renderLayers && b.hasLayers) {
+                    state = this.STATE_LOADED;
+                  } else if (b.renderLayers && !b.hasLayers) {
+                    state = this.STATE_LOADING;
+                  } else if (!b.renderLayers && b.hasLayers) {
+                    state = this.STATE_UNLOADING;
+                  } else {
+                    state = this.STATE_UNLOADED;
+                  }
+
+                  this.setTabState(tab, state);
+                }
+              }
+              this.logState("Tab states initialized");
+            },
+
+            destroy() {
+              if (this.unloadTimer) {
+                this.clearTimer(this.unloadTimer);
+                this.unloadTimer = null;
+              }
+              if (this.loadTimer) {
+                this.clearTimer(this.loadTimer);
+                this.loadTimer = null;
+              }
+
+              window.removeEventListener("MozAfterPaint", this);
+              window.removeEventListener("MozLayerTreeReady", this);
+              window.removeEventListener("MozLayerTreeCleared", this);
+              window.removeEventListener("TabRemotenessChange", this);
+              window.removeEventListener("sizemodechange", this);
+              window.removeEventListener("occlusionstatechange", this);
+              window.removeEventListener("SwapDocShells", this, true);
+              window.removeEventListener("EndSwapDocShells", this, true);
+
+              this.tabbrowser._switcher = null;
+
+              this.activeSuppressDisplayport.forEach(function(tabParent) {
+                tabParent.suppressDisplayport(false);
+              });
+              this.activeSuppressDisplayport.clear();
+            },
+
+            finish() {
+              this.log("FINISH");
+
+              this.assert(this.tabbrowser._switcher);
+              this.assert(this.tabbrowser._switcher === this);
+              this.assert(!this.spinnerTab);
+              this.assert(!this.blankTab);
+              this.assert(!this.loadTimer);
+              this.assert(!this.loadingTab);
+              this.assert(this.lastVisibleTab === this.requestedTab);
+              this.assert(this.minimizedOrFullyOccluded ||
+                          this.getTabState(this.requestedTab) == this.STATE_LOADED);
+
+              this.destroy();
+
+              let toBrowser = this.requestedTab.linkedBrowser;
+              toBrowser.setAttribute("primary", "true");
+
+              let fromBrowser = this.originalTab.linkedBrowser;
+              // It's possible that the tab we're switching from closed
+              // before we were able to finalize, in which case, fromBrowser
+              // doesn't exist.
+              if (fromBrowser) {
+                fromBrowser.removeAttribute("primary");
+              }
+
+              document.commandDispatcher.unlock();
+
+              let event = new CustomEvent("TabSwitchDone", {
+                bubbles: true,
+                cancelable: true
+              });
+              this.tabbrowser.dispatchEvent(event);
+            },
+
+            // This function is called after all the main state changes to
+            // make sure we display the right tab.
+            updateDisplay() {
+              let requestedTabState = this.getTabState(this.requestedTab);
+              let requestedBrowser = this.requestedTab.linkedBrowser;
+
+              // It is often more desirable to show a blank tab when appropriate than
+              // the tab switch spinner - especially since the spinner is usually
+              // preceded by a perceived lag of TAB_SWITCH_TIMEOUT ms in the
+              // tab switch. We can hide this lag, and hide the time being spent
+              // constructing TabChild's, layer trees, etc, by showing a blank
+              // tab instead and focusing it immediately.
+              let shouldBeBlank = false;
+              if (requestedBrowser.isRemoteBrowser) {
+                // If a tab is remote and the window is not minimized, we can show a
+                // blank tab instead of a spinner in the following cases:
+                //
+                // 1. The tab has just crashed, and we haven't started showing the
+                //    tab crashed page yet (in this case, the TabParent is null)
+                // 2. The tab has never presented, and has not finished loading
+                //    a non-local-about: page.
+                //
+                // For (2), "finished loading a non-local-about: page" is
+                // determined by the busy state on the tab element and checking
+                // if the loaded URI is local.
+                let hasSufficientlyLoaded =
+                  !this.requestedTab.hasAttribute("busy") &&
+                  !this.tabbrowser._isLocalAboutURI(requestedBrowser.currentURI);
+
+                let fl = requestedBrowser.frameLoader;
+                shouldBeBlank = !this.minimizedOrFullyOccluded &&
+                                (!fl.tabParent ||
+                                 (!hasSufficientlyLoaded && !fl.tabParent.hasPresented));
+              }
+
+              this.log("Tab should be blank: " + shouldBeBlank);
+              this.log("Requested tab is remote?: " + requestedBrowser.isRemoteBrowser);
+
+              // Figure out which tab we actually want visible right now.
+              let showTab = null;
+              if (requestedTabState != this.STATE_LOADED &&
+                  this.lastVisibleTab && this.loadTimer && !shouldBeBlank) {
+                // If we can't show the requestedTab, and lastVisibleTab is
+                // available, show it.
+                showTab = this.lastVisibleTab;
+              } else {
+                // Show the requested tab. If it's not available, we'll show the spinner or a blank tab.
+                showTab = this.requestedTab;
+              }
+
+              // First, let's deal with blank tabs, which we show instead
+              // of the spinner when the tab is not currently set up
+              // properly in the content process.
+              if (!shouldBeBlank && this.blankTab) {
+                this.blankTab.linkedBrowser.removeAttribute("blank");
+                this.blankTab = null;
+              } else if (shouldBeBlank && this.blankTab !== showTab) {
+                if (this.blankTab) {
+                  this.blankTab.linkedBrowser.removeAttribute("blank");
+                }
+                this.blankTab = showTab;
+                this.blankTab.linkedBrowser.setAttribute("blank", "true");
+              }
+
+              // Show or hide the spinner as needed.
+              let needSpinner = this.getTabState(showTab) != this.STATE_LOADED &&
+                                !this.minimizedOrFullyOccluded &&
+                                !shouldBeBlank;
+
+              if (!needSpinner && this.spinnerTab) {
+                this.spinnerHidden();
+                this.tabbrowser.removeAttribute("pendingpaint");
+                this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
+                this.spinnerTab = null;
+              } else if (needSpinner && this.spinnerTab !== showTab) {
+                if (this.spinnerTab) {
+                  this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
+                } else {
+                  this.spinnerDisplayed();
+                }
+                this.spinnerTab = showTab;
+                this.tabbrowser.setAttribute("pendingpaint", "true");
+                this.spinnerTab.linkedBrowser.setAttribute("pendingpaint", "true");
+              }
+
+              // Switch to the tab we've decided to make visible.
+              if (this.visibleTab !== showTab) {
+                this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
+                this.visibleTab = showTab;
+
+                this.maybeVisibleTabs.add(showTab);
+
+                let tabs = this.tabbrowser.tabbox.tabs;
+                let tabPanel = this.tabbrowser.mPanelContainer;
+                let showPanel = tabs.getRelatedElement(showTab);
+                let index = Array.indexOf(tabPanel.childNodes, showPanel);
+                if (index != -1) {
+                  this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
+                  tabPanel.setAttribute("selectedIndex", index);
+                  if (showTab === this.requestedTab) {
+                    if (this._requestingTab) {
+                      /*
+                       * If _requestingTab is set, that means that we're switching the
+                       * visibility of the tab synchronously, and we need to wait for
+                       * the "select" event before shifting focus so that
+                       * _adjustFocusAfterTabSwitch runs with the right information for
+                       * the tab switch.
+                       */
+                      this.tabbrowser.addEventListener("select", () => {
+                        this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
+                      }, {once: true});
+                    } else {
+                      this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
+                    }
+
+                    this.maybeActivateDocShell(this.requestedTab);
+                  }
+                }
+
+                // This doesn't necessarily exist if we're a new window and haven't switched tabs yet
+                if (this.lastVisibleTab)
+                  this.lastVisibleTab._visuallySelected = false;
+
+                this.visibleTab._visuallySelected = true;
+              }
+
+              this.lastVisibleTab = this.visibleTab;
+            },
+
+            assert(cond) {
+              if (!cond) {
+                dump("Assertion failure\n" + Error().stack);
+
+                // Don't break a user's browser if an assertion fails.
+                if (AppConstants.DEBUG) {
+                  throw new Error("Assertion failure");
+                }
+              }
+            },
+
+            // We've decided to try to load requestedTab.
+            loadRequestedTab() {
+              this.assert(!this.loadTimer);
+              this.assert(!this.minimizedOrFullyOccluded);
+
+              // loadingTab can be non-null here if we timed out loading the current tab.
+              // In that case we just overwrite it with a different tab; it's had its chance.
+              this.loadingTab = this.requestedTab;
+              this.log("Loading tab " + this.tinfo(this.loadingTab));
+
+              this.loadTimer = this.setTimer(() => this.onLoadTimeout(), this.TAB_SWITCH_TIMEOUT);
+              this.setTabState(this.requestedTab, this.STATE_LOADING);
+            },
+
+            maybeActivateDocShell(tab) {
+              // If we've reached the point where the requested tab has entered
+              // the loaded state, but the DocShell is still not yet active, we
+              // should activate it.
+              let browser = tab.linkedBrowser;
+              let state = this.getTabState(tab);
+              let canCheckDocShellState = !browser.mDestroyed &&
+                                          (browser.docShell ||
+                                           browser.frameLoader.tabParent);
+              if (tab == this.requestedTab &&
+                  canCheckDocShellState &&
+                  state == this.STATE_LOADED &&
+                  !browser.docShellIsActive &&
+                  !this.minimizedOrFullyOccluded) {
+                browser.docShellIsActive = true;
+                this.logState("Set requested tab docshell to active and preserveLayers to false");
+                // If we minimized the window before the switcher was activated,
+                // we might have set the preserveLayers flag for the current
+                // browser. Let's clear it.
+                browser.preserveLayers(false);
+              }
+            },
+
+            // This function runs before every event. It fixes up the state
+            // to account for closed tabs.
+            preActions() {
+              this.assert(this.tabbrowser._switcher);
+              this.assert(this.tabbrowser._switcher === this);
+
+              for (let [tab, ] of this.tabState) {
+                if (!tab.linkedBrowser) {
+                  this.tabState.delete(tab);
+                  this.unwarmTab(tab);
+                }
+              }
+
+              if (this.lastVisibleTab && !this.lastVisibleTab.linkedBrowser) {
+                this.lastVisibleTab = null;
+              }
+              if (this.blankTab && !this.blankTab.linkedBrowser) {
+                this.blankTab = null;
+              }
+              if (this.spinnerTab && !this.spinnerTab.linkedBrowser) {
+                this.spinnerHidden();
+                this.spinnerTab = null;
+              }
+              if (this.loadingTab && !this.loadingTab.linkedBrowser) {
+                this.loadingTab = null;
+                this.clearTimer(this.loadTimer);
+                this.loadTimer = null;
+              }
+            },
+
+            // This code runs after we've responded to an event or requested a new
+            // tab. It's expected that we've already updated all the principal
+            // state variables. This function takes care of updating any auxilliary
+            // state.
+            postActions() {
+              // Once we finish loading loadingTab, we null it out. So the state should
+              // always be LOADING.
+              this.assert(!this.loadingTab ||
+                          this.getTabState(this.loadingTab) == this.STATE_LOADING);
+
+              // We guarantee that loadingTab is non-null iff loadTimer is non-null. So
+              // the timer is set only when we're loading something.
+              this.assert(!this.loadTimer || this.loadingTab);
+              this.assert(!this.loadingTab || this.loadTimer);
+
+              // If we're switching to a non-remote tab, there's no need to wait
+              // for it to send layers to the compositor, as this will happen
+              // synchronously. Clearing this here means that in the next step,
+              // we can load the non-remote browser immediately.
+              if (!this.requestedTab.linkedBrowser.isRemoteBrowser) {
+                this.loadingTab = null;
+                if (this.loadTimer) {
+                  this.clearTimer(this.loadTimer);
+                  this.loadTimer = null;
+                }
+              }
+
+              // If we're not loading anything, try loading the requested tab.
+              let requestedState = this.getTabState(this.requestedTab);
+              if (!this.loadTimer && !this.minimizedOrFullyOccluded &&
+                  (requestedState == this.STATE_UNLOADED ||
+                   requestedState == this.STATE_UNLOADING)) {
+                this.loadRequestedTab();
+              }
+
+              // See how many tabs still have work to do.
+              let numPending = 0;
+              let numWarming = 0;
+              for (let [tab, state] of this.tabState) {
+                // Skip print preview browsers since they shouldn't affect tab switching.
+                if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
+                  continue;
+                }
+
+                if (state == this.STATE_LOADED && tab !== this.requestedTab) {
+                  numPending++;
+
+                  if (tab !== this.visibleTab) {
+                    numWarming++;
+                  }
+                }
+                if (state == this.STATE_LOADING || state == this.STATE_UNLOADING) {
+                  numPending++;
+                }
+              }
+
+              this.updateDisplay();
+
+              // It's possible for updateDisplay to trigger one of our own event
+              // handlers, which might cause finish() to already have been called.
+              // Check for that before calling finish() again.
+              if (!this.tabbrowser._switcher) {
+                return;
+              }
+
+              this.maybeFinishTabSwitch();
+
+              if (numWarming > this.tabbrowser.tabWarmingMax) {
+                this.logState("Hit tabWarmingMax");
+                if (this.unloadTimer) {
+                  this.clearTimer(this.unloadTimer);
+                }
+                this.unloadNonRequiredTabs();
+              }
+
+              if (numPending == 0) {
+                this.finish();
+              }
+
+              this.logState("done");
+            },
+
+            // Fires when we're ready to unload unused tabs.
+            onUnloadTimeout() {
+              this.logState("onUnloadTimeout");
+              this.preActions();
+              this.unloadTimer = null;
+
+              this.unloadNonRequiredTabs();
+
+              this.postActions();
+            },
+
+            // If there are any non-visible and non-requested tabs in
+            // STATE_LOADED, sets them to STATE_UNLOADING. Also queues
+            // up the unloadTimer to run onUnloadTimeout if there are still
+            // tabs in the process of unloading.
+            unloadNonRequiredTabs() {
+              this.warmingTabs = new WeakSet();
+              let numPending = 0;
+
+              // Unload any tabs that can be unloaded.
+              for (let [tab, state] of this.tabState) {
+                if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
+                  continue;
+                }
+
+                if (state == this.STATE_LOADED &&
+                    !this.maybeVisibleTabs.has(tab) &&
+                    tab !== this.lastVisibleTab &&
+                    tab !== this.loadingTab &&
+                    tab !== this.requestedTab) {
+                  this.setTabState(tab, this.STATE_UNLOADING);
+                }
+
+                if (state != this.STATE_UNLOADED && tab !== this.requestedTab) {
+                  numPending++;
+                }
+              }
+
+              if (numPending) {
+                // Keep the timer going since there may be more tabs to unload.
+                this.unloadTimer = this.setTimer(() => this.onUnloadTimeout(), this.UNLOAD_DELAY);
+              }
+            },
+
+            // Fires when an ongoing load has taken too long.
+            onLoadTimeout() {
+              this.logState("onLoadTimeout");
+              this.preActions();
+              this.loadTimer = null;
+              this.loadingTab = null;
+              this.postActions();
+            },
+
+            // Fires when the layers become available for a tab.
+            onLayersReady(browser) {
+              let tab = this.tabbrowser.getTabForBrowser(browser);
+              if (!tab) {
+                // We probably got a layer update from a tab that got before
+                // the switcher was created, or for browser that's not being
+                // tracked by the async tab switcher (like the preloaded about:newtab).
+                return;
+              }
+
+              this.logState(`onLayersReady(${tab._tPos}, ${browser.isRemoteBrowser})`);
+
+              this.assert(this.getTabState(tab) == this.STATE_LOADING ||
+                          this.getTabState(tab) == this.STATE_LOADED);
+              this.setTabState(tab, this.STATE_LOADED);
+
+              if (this.loadingTab === tab) {
+                this.clearTimer(this.loadTimer);
+                this.loadTimer = null;
+                this.loadingTab = null;
+              }
+            },
+
+            // Fires when we paint the screen. Any tab switches we initiated
+            // previously are done, so there's no need to keep the old layers
+            // around.
+            onPaint() {
+              this.maybeVisibleTabs.clear();
+            },
+
+            // Called when we're done clearing the layers for a tab.
+            onLayersCleared(browser) {
+              let tab = this.tabbrowser.getTabForBrowser(browser);
+              if (tab) {
+                this.logState(`onLayersCleared(${tab._tPos})`);
+                this.assert(this.getTabState(tab) == this.STATE_UNLOADING ||
+                            this.getTabState(tab) == this.STATE_UNLOADED);
+                this.setTabState(tab, this.STATE_UNLOADED);
+              }
+            },
+
+            // Called when a tab switches from remote to non-remote. In this case
+            // a MozLayerTreeReady notification that we requested may never fire,
+            // so we need to simulate it.
+            onRemotenessChange(tab) {
+              this.logState(`onRemotenessChange(${tab._tPos}, ${tab.linkedBrowser.isRemoteBrowser})`);
+              if (!tab.linkedBrowser.isRemoteBrowser) {
+                if (this.getTabState(tab) == this.STATE_LOADING) {
+                  this.onLayersReady(tab.linkedBrowser);
+                } else if (this.getTabState(tab) == this.STATE_UNLOADING) {
+                  this.onLayersCleared(tab.linkedBrowser);
+                }
+              } else if (this.getTabState(tab) == this.STATE_LOADED) {
+                // A tab just changed from non-remote to remote, which means
+                // that it's gone back into the STATE_LOADING state until
+                // it sends up a layer tree.
+                this.setTabState(tab, this.STATE_LOADING);
+              }
+            },
+
+            // Called when a tab has been removed, and the browser node is
+            // about to be removed from the DOM.
+            onTabRemoved(tab) {
+              if (this.lastVisibleTab == tab) {
+                // The browser that was being presented to the user is
+                // going to be removed during this tick of the event loop.
+                // This will cause us to show a tab spinner instead.
+                this.preActions();
+                this.lastVisibleTab = null;
+                this.postActions();
+              }
+            },
+
+            onSizeModeOrOcclusionStateChange() {
+              if (this.minimizedOrFullyOccluded) {
+                for (let [tab, state] of this.tabState) {
+                  // Skip print preview browsers since they shouldn't affect tab switching.
+                  if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
+                    continue;
+                  }
+
+                  if (state == this.STATE_LOADING || state == this.STATE_LOADED) {
+                    this.setTabState(tab, this.STATE_UNLOADING);
+                  }
+                }
+                if (this.loadTimer) {
+                  this.clearTimer(this.loadTimer);
+                  this.loadTimer = null;
+                }
+                this.loadingTab = null;
+              } else {
+                // Do nothing. We'll automatically start loading the requested tab in
+                // postActions.
+              }
+            },
+
+            onSwapDocShells(ourBrowser, otherBrowser) {
+              // This event fires before the swap. ourBrowser is from
+              // our window. We save the state of otherBrowser since ourBrowser
+              // needs to take on that state at the end of the swap.
+
+              let otherTabbrowser = otherBrowser.ownerGlobal.gBrowser;
+              let otherState;
+              if (otherTabbrowser && otherTabbrowser._switcher) {
+                let otherTab = otherTabbrowser.getTabForBrowser(otherBrowser);
+                let otherSwitcher = otherTabbrowser._switcher;
+                otherState = otherSwitcher.getTabState(otherTab);
+              } else {
+                otherState = (otherBrowser.docShellIsActive
+                              ? this.STATE_LOADED
+                              : this.STATE_UNLOADED);
+              }
+
+              if (!this.swapMap) {
+                this.swapMap = new WeakMap();
+              }
+              this.swapMap.set(otherBrowser, {
+                state: otherState,
+              });
+            },
+
+            onEndSwapDocShells(ourBrowser, otherBrowser) {
+              // The swap has happened. We reset the loadingTab in
+              // case it has been swapped. We also set ourBrowser's state
+              // to whatever otherBrowser's state was before the swap.
+
+              if (this.loadTimer) {
+                // Clearing the load timer means that we will
+                // immediately display a spinner if ourBrowser isn't
+                // ready yet. Typically it will already be ready
+                // though. If it's not, we're probably in a new window,
+                // in which case we have no other tabs to display anyway.
+                this.clearTimer(this.loadTimer);
+                this.loadTimer = null;
+              }
+              this.loadingTab = null;
+
+              let { state: otherState } = this.swapMap.get(otherBrowser);
+
+              this.swapMap.delete(otherBrowser);
+
+              let ourTab = this.tabbrowser.getTabForBrowser(ourBrowser);
+              if (ourTab) {
+                this.setTabStateNoAction(ourTab, otherState);
+              }
+            },
+
+            shouldActivateDocShell(browser) {
+              let tab = this.tabbrowser.getTabForBrowser(browser);
+              let state = this.getTabState(tab);
+              return state == this.STATE_LOADING || state == this.STATE_LOADED;
+            },
+
+            activateBrowserForPrintPreview(browser) {
+              let tab = this.tabbrowser.getTabForBrowser(browser);
+              let state = this.getTabState(tab);
+              if (state != this.STATE_LOADING &&
+                  state != this.STATE_LOADED) {
+                this.setTabState(tab, this.STATE_LOADING);
+                this.logState("Activated browser " + this.tinfo(tab) + " for print preview");
+              }
+            },
+
+            canWarmTab(tab) {
+              if (!this.tabbrowser.tabWarmingEnabled) {
+                return false;
+              }
+
+              // If the tab is not yet inserted, closing, not remote,
+              // crashed, already visible, or already requested, warming
+              // up the tab makes no sense.
+              if (this.minimizedOrFullyOccluded ||
+                  !tab.linkedPanel ||
+                  tab.closing ||
+                  !tab.linkedBrowser.isRemoteBrowser ||
+                  !tab.linkedBrowser.frameLoader.tabParent) {
+                return false;
+              }
+
+              // Similarly, if the tab is already in STATE_LOADING or
+              // STATE_LOADED somehow, there's no point in trying to
+              // warm it up.
+              let state = this.getTabState(tab);
+              if (state === this.STATE_LOADING ||
+                  state === this.STATE_LOADED) {
+                return false;
+              }
+
+              return true;
+            },
+
+            unwarmTab(tab) {
+              this.warmingTabs.delete(tab);
+            },
+
+            warmupTab(tab) {
+              if (!this.canWarmTab(tab)) {
+                return;
+              }
+
+              this.logState("warmupTab " + this.tinfo(tab));
+
+              this.warmingTabs.add(tab);
+              this.setTabState(tab, this.STATE_LOADING);
+              this.suppressDisplayPortAndQueueUnload(tab,
+                this.tabbrowser.tabWarmingUnloadDelay);
+            },
+
+            // Called when the user asks to switch to a given tab.
+            requestTab(tab) {
+              if (tab === this.requestedTab) {
+                return;
+              }
+
+              if (this.tabbrowser.tabWarmingEnabled) {
+                let warmingState = "disqualified";
+
+                if (this.warmingTabs.has(tab)) {
+                  let tabState = this.getTabState(tab);
+                  if (tabState == this.STATE_LOADING) {
+                    warmingState = "stillLoading";
+                  } else if (tabState == this.STATE_LOADED) {
+                    warmingState = "loaded";
+                  }
+                } else if (this.canWarmTab(tab)) {
+                  warmingState = "notWarmed";
+                }
+
+                Services.telemetry
+                        .getHistogramById("FX_TAB_SWITCH_REQUEST_TAB_WARMING_STATE")
+                        .add(warmingState);
+
+                this.unwarmTab(tab);
+              }
+
+              this._requestingTab = true;
+              this.logState("requestTab " + this.tinfo(tab));
+              this.startTabSwitch();
+
+              this.requestedTab = tab;
+
+              this.suppressDisplayPortAndQueueUnload(this.requestedTab, this.UNLOAD_DELAY);
+              this._requestingTab = false;
+            },
+
+            suppressDisplayPortAndQueueUnload(tab, unloadTimeout) {
+              let browser = tab.linkedBrowser;
+              let fl = browser.frameLoader;
+
+              if (fl && fl.tabParent && !this.activeSuppressDisplayport.has(fl.tabParent)) {
+                fl.tabParent.suppressDisplayport(true);
+                this.activeSuppressDisplayport.add(fl.tabParent);
+              }
+
+              this.preActions();
+
+              if (this.unloadTimer) {
+                this.clearTimer(this.unloadTimer);
+              }
+              this.unloadTimer = this.setTimer(() => this.onUnloadTimeout(), unloadTimeout);
+
+              this.postActions();
+            },
+
+            handleEvent(event, delayed = false) {
+              if (this._processing) {
+                this.setTimer(() => this.handleEvent(event, true), 0);
+                return;
+              }
+              if (delayed && this.tabbrowser._switcher != this) {
+                // if we delayed processing this event, we might be out of date, in which
+                // case we drop the delayed events
+                return;
+              }
+              this._processing = true;
+              this.preActions();
+
+              if (event.type == "MozLayerTreeReady") {
+                this.onLayersReady(event.originalTarget);
+              } if (event.type == "MozAfterPaint") {
+                this.onPaint();
+              } else if (event.type == "MozLayerTreeCleared") {
+                this.onLayersCleared(event.originalTarget);
+              } else if (event.type == "TabRemotenessChange") {
+                this.onRemotenessChange(event.target);
+              } else if (event.type == "sizemodechange" ||
+                         event.type == "occlusionstatechange") {
+                this.onSizeModeOrOcclusionStateChange();
+              } else if (event.type == "SwapDocShells") {
+                this.onSwapDocShells(event.originalTarget, event.detail);
+              } else if (event.type == "EndSwapDocShells") {
+                this.onEndSwapDocShells(event.originalTarget, event.detail);
+              }
+
+              this.postActions();
+              this._processing = false;
+            },
+
+            /*
+             * Telemetry and Profiler related helpers for recording tab switch
+             * timing.
+             */
+
+            startTabSwitch() {
+              TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+              TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+              this.addMarker("AsyncTabSwitch:Start");
+              this.switchInProgress = true;
+            },
+
+            /**
+             * Something has occurred that might mean that we've completed
+             * the tab switch (layers are ready, paints are done, spinners
+             * are hidden). This checks to make sure all conditions are
+             * satisfied, and then records the tab switch as finished.
+             */
+            maybeFinishTabSwitch() {
+              if (this.switchInProgress && this.requestedTab &&
+                  (this.getTabState(this.requestedTab) == this.STATE_LOADED ||
+                   this.requestedTab === this.blankTab)) {
+                // After this point the tab has switched from the content thread's point of view.
+                // The changes will be visible after the next refresh driver tick + composite.
+                let time = TelemetryStopwatch.timeElapsed("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+                if (time != -1) {
+                  TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
+                  this.log("DEBUG: tab switch time = " + time);
+                  this.addMarker("AsyncTabSwitch:Finish");
+                }
+                this.switchInProgress = false;
+              }
+            },
+
+            spinnerDisplayed() {
+              this.assert(!this.spinnerTab);
+              let browser = this.requestedTab.linkedBrowser;
+              this.assert(browser.isRemoteBrowser);
+              TelemetryStopwatch.start("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
+              // We have a second, similar probe for capturing recordings of
+              // when the spinner is displayed for very long periods.
+              TelemetryStopwatch.start("FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS", window);
+              this.addMarker("AsyncTabSwitch:SpinnerShown");
+            },
+
+            spinnerHidden() {
+              this.assert(this.spinnerTab);
+              this.log("DEBUG: spinner time = " +
+                       TelemetryStopwatch.timeElapsed("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window));
+              TelemetryStopwatch.finish("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
+              TelemetryStopwatch.finish("FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS", window);
+              this.addMarker("AsyncTabSwitch:SpinnerHidden");
+              // we do not get a onPaint after displaying the spinner
+            },
+
+            addMarker(marker) {
+              if (Services.profiler) {
+                Services.profiler.AddMarker(marker);
+              }
+            },
+
+            /*
+             * Debug related logging for switcher.
+             */
+
+            _useDumpForLogging: false,
+            _logInit: false,
+
+            logging() {
+              if (this._useDumpForLogging)
+                return true;
+              if (this._logInit)
+                return this._shouldLog;
+              let result = Services.prefs.getBoolPref("browser.tabs.remote.logSwitchTiming", false);
+              this._shouldLog = result;
+              this._logInit = true;
+              return this._shouldLog;
+            },
+
+            tinfo(tab) {
+              if (tab) {
+                return tab._tPos + "(" + tab.linkedBrowser.currentURI.spec + ")";
+              }
+              return "null";
+            },
+
+            log(s) {
+              if (!this.logging())
+                return;
+              if (this._useDumpForLogging) {
+                dump(s + "\n");
+              } else {
+                Services.console.logStringMessage(s);
+              }
+            },
+
+            logState(prefix) {
+              if (!this.logging())
+                return;
+
+              let accum = prefix + " ";
+              for (let i = 0; i < this.tabbrowser.tabs.length; i++) {
+                let tab = this.tabbrowser.tabs[i];
+                let state = this.getTabState(tab);
+                let isWarming = this.warmingTabs.has(tab);
+
+                accum += i + ":";
+                if (tab === this.lastVisibleTab) accum += "V";
+                if (tab === this.loadingTab) accum += "L";
+                if (tab === this.requestedTab) accum += "R";
+                if (tab === this.blankTab) accum += "B";
+                if (isWarming) accum += "(W)";
+                if (state == this.STATE_LOADED) accum += "(+)";
+                if (state == this.STATE_LOADING) accum += "(+?)";
+                if (state == this.STATE_UNLOADED) accum += "(-)";
+                if (state == this.STATE_UNLOADING) accum += "(-?)";
+                accum += " ";
+              }
+              if (this._useDumpForLogging) {
+                dump(accum + "\n");
+              } else {
+                Services.console.logStringMessage(accum);
+              }
+            },
+          };
+          this._switcher = switcher;
+          switcher.init();
+          return switcher;
+        ]]></body>
+      </method>
+
+      <method name="warmupTab">
+        <parameter name="aTab"/>
+        <body>
+          <![CDATA[
+            if (gMultiProcessBrowser) {
+              this._getSwitcher().warmupTab(aTab);
+            }
+          ]]>
+        </body>
+      </method>
+
+      <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
+           MAKE SURE TO ADD IT HERE AS WELL. -->
+      <property name="canGoBack"
+                onget="return this.mCurrentBrowser.canGoBack;"
+                readonly="true"/>
+
+      <property name="canGoForward"
+                onget="return this.mCurrentBrowser.canGoForward;"
+                readonly="true"/>
+
+      <method name="goBack">
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.goBack();
+          ]]>
+        </body>
+      </method>
+
+      <method name="goForward">
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.goForward();
+          ]]>
+        </body>
+      </method>
+
+      <method name="reload">
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.reload();
+          ]]>
+        </body>
+      </method>
+
+      <method name="reloadWithFlags">
+        <parameter name="aFlags"/>
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.reloadWithFlags(aFlags);
+          ]]>
+        </body>
+      </method>
+
+      <method name="stop">
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.stop();
+          ]]>
+        </body>
+      </method>
+
+      <!-- throws exception for unknown schemes -->
+      <method name="loadURI">
+        <parameter name="aURI"/>
+        <parameter name="aReferrerURI"/>
+        <parameter name="aCharset"/>
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
+          ]]>
+        </body>
+      </method>
+
+      <!-- throws exception for unknown schemes -->
+      <method name="loadURIWithFlags">
+        <parameter name="aURI"/>
+        <parameter name="aFlags"/>
+        <parameter name="aReferrerURI"/>
+        <parameter name="aCharset"/>
+        <parameter name="aPostData"/>
+        <body>
+          <![CDATA[
+            // Note - the callee understands both:
+            // (a) loadURIWithFlags(aURI, aFlags, ...)
+            // (b) loadURIWithFlags(aURI, { flags: aFlags, ... })
+            // Forwarding it as (a) here actually supports both (a) and (b),
+            // so you can call us either way too.
+            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData);
+          ]]>
+        </body>
+      </method>
+
+      <method name="goHome">
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.goHome();
+          ]]>
+        </body>
+      </method>
+
+      <property name="homePage">
+        <getter>
+          <![CDATA[
+            return this.mCurrentBrowser.homePage;
+          ]]>
+        </getter>
+        <setter>
+          <![CDATA[
+            this.mCurrentBrowser.homePage = val;
+            return val;
+          ]]>
+        </setter>
+      </property>
+
+      <method name="gotoIndex">
+        <parameter name="aIndex"/>
+        <body>
+          <![CDATA[
+            return this.mCurrentBrowser.gotoIndex(aIndex);
+          ]]>
+        </body>
+      </method>
+
+      <property name="currentURI"
+                onget="return this.mCurrentBrowser.currentURI;"
+                readonly="true"/>
+
+      <property name="finder"
+                onget="return this.mCurrentBrowser.finder"
+                readonly="true"/>
+
+      <property name="docShell"
+                onget="return this.mCurrentBrowser.docShell"
+                readonly="true"/>
+
+      <property name="webNavigation"
+                onget="return this.mCurrentBrowser.webNavigation"
+                readonly="true"/>
+
+      <property name="webBrowserFind"
+                readonly="true"
+                onget="return this.mCurrentBrowser.webBrowserFind"/>
+
+      <property name="webProgress"
+                readonly="true"
+                onget="return this.mCurrentBrowser.webProgress"/>
+
+      <property name="contentWindow"
+                readonly="true"
+                onget="return this.mCurrentBrowser.contentWindow"/>
+
+      <property name="contentWindowAsCPOW"
+                readonly="true"
+                onget="return this.mCurrentBrowser.contentWindowAsCPOW"/>
+
+      <property name="sessionHistory"
+                onget="return this.mCurrentBrowser.sessionHistory;"
+                readonly="true"/>
+
+      <property name="markupDocumentViewer"
+                onget="return this.mCurrentBrowser.markupDocumentViewer;"
+                readonly="true"/>
+
+      <property name="contentDocument"
+                onget="return this.mCurrentBrowser.contentDocument;"
+                readonly="true"/>
+
+      <property name="contentDocumentAsCPOW"
+                onget="return this.mCurrentBrowser.contentDocumentAsCPOW;"
+                readonly="true"/>
+
+      <property name="contentTitle"
+                onget="return this.mCurrentBrowser.contentTitle;"
+                readonly="true"/>
+
+      <property name="contentPrincipal"
+                onget="return this.mCurrentBrowser.contentPrincipal;"
+                readonly="true"/>
+
+      <property name="securityUI"
+                onget="return this.mCurrentBrowser.securityUI;"
+                readonly="true"/>
+
+      <property name="fullZoom"
+                onget="return this.mCurrentBrowser.fullZoom;"
+                onset="this.mCurrentBrowser.fullZoom = val;"/>
+
+      <property name="textZoom"
+                onget="return this.mCurrentBrowser.textZoom;"
+                onset="this.mCurrentBrowser.textZoom = val;"/>
+
+      <property name="isSyntheticDocument"
+                onget="return this.mCurrentBrowser.isSyntheticDocument;"
+                readonly="true"/>
+
+      <method name="_handleKeyDownEvent">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          if (!aEvent.isTrusted) {
+            // Don't let untrusted events mess with tabs.
+            return;
+          }
+
+          if (aEvent.altKey)
+            return;
+
+          // Don't check if the event was already consumed because tab
+          // navigation should always work for better user experience.
+
+          if (aEvent.ctrlKey && aEvent.shiftKey && !aEvent.metaKey) {
+            switch (aEvent.keyCode) {
+              case aEvent.DOM_VK_PAGE_UP:
+                this.moveTabBackward();
+                aEvent.preventDefault();
+                return;
+              case aEvent.DOM_VK_PAGE_DOWN:
+                this.moveTabForward();
+                aEvent.preventDefault();
+                return;
+            }
+          }
+
+          if (AppConstants.platform != "macosx") {
+            if (aEvent.ctrlKey && !aEvent.shiftKey && !aEvent.metaKey &&
+                aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
+                !this.mCurrentTab.pinned) {
+              this.removeCurrentTab({animate: true});
+              aEvent.preventDefault();
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="_handleKeyPressEventMac">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          if (!aEvent.isTrusted) {
+            // Don't let untrusted events mess with tabs.
+            return;
+          }
+
+          if (aEvent.altKey)
+            return;
+
+          if (AppConstants.platform == "macosx") {
+            if (!aEvent.metaKey)
+              return;
+
+            var offset = 1;
+            switch (aEvent.charCode) {
+              case "}".charCodeAt(0):
+                offset = -1;
+              case "{".charCodeAt(0):
+                if (window.getComputedStyle(this).direction == "ltr")
+                  offset *= -1;
+                this.tabContainer.advanceSelectedTab(offset, true);
+                aEvent.preventDefault();
+            }
+          }
+        ]]></body>
+      </method>
+
+      <property name="userTypedValue"
+                onget="return this.mCurrentBrowser.userTypedValue;"
+                onset="return this.mCurrentBrowser.userTypedValue = val;"/>
+
+      <method name="createTooltip">
+        <parameter name="event"/>
+        <body><![CDATA[
+          event.stopPropagation();
+          var tab = document.tooltipNode;
+          if (tab.localName != "tab") {
+            event.preventDefault();
+            return;
+          }
+
+          let stringWithShortcut = (stringId, keyElemId) => {
+            let keyElem = document.getElementById(keyElemId);
+            let shortcut = ShortcutUtils.prettifyShortcut(keyElem);
+            return gTabBrowserBundle.formatStringFromName(stringId, [shortcut], 1);
+          };
+
+          var label;
+          if (tab.mOverCloseButton) {
+            label = tab.selected ?
+                    stringWithShortcut("tabs.closeSelectedTab.tooltip", "key_close") :
+                    gTabBrowserBundle.GetStringFromName("tabs.closeTab.tooltip");
+          } else if (tab._overPlayingIcon) {
+            let stringID;
+            if (tab.selected) {
+              stringID = tab.linkedBrowser.audioMuted ?
+                "tabs.unmuteAudio.tooltip" :
+                "tabs.muteAudio.tooltip";
+              label = stringWithShortcut(stringID, "key_toggleMute");
+            } else {
+              if (tab.hasAttribute("activemedia-blocked")) {
+                stringID = "tabs.unblockAudio.tooltip";
+              } else {
+                stringID = tab.linkedBrowser.audioMuted ?
+                  "tabs.unmuteAudio.background.tooltip" :
+                  "tabs.muteAudio.background.tooltip";
+              }
+
+              label = gTabBrowserBundle.GetStringFromName(stringID);
+            }
+          } else {
+            label = tab._fullLabel || tab.getAttribute("label");
+            if (AppConstants.NIGHTLY_BUILD &&
+                tab.linkedBrowser &&
+                tab.linkedBrowser.isRemoteBrowser &&
+                tab.linkedBrowser.frameLoader) {
+              label += " (pid " + tab.linkedBrowser.frameLoader.tabParent.osPid + ")";
+            }
+            if (tab.userContextId) {
+              label = gTabBrowserBundle.formatStringFromName("tabs.containers.tooltip", [label, ContextualIdentityService.getUserContextLabel(tab.userContextId)], 2);
+            }
+          }
+
+          event.target.setAttribute("label", label);
+        ]]></body>
+      </method>
+
+      <method name="handleEvent">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          switch (aEvent.type) {
+            case "keydown":
+              this._handleKeyDownEvent(aEvent);
+              break;
+            case "keypress":
+              this._handleKeyPressEventMac(aEvent);
+              break;
+            case "sizemodechange":
+            case "occlusionstatechange":
+              if (aEvent.target == window && !this._switcher) {
+                this.mCurrentBrowser.preserveLayers(
+                  window.windowState == window.STATE_MINIMIZED || window.isFullyOccluded);
+                this.mCurrentBrowser.docShellIsActive = this.shouldActivateDocShell(this.mCurrentBrowser);
+              }
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <method name="receiveMessage">
+        <parameter name="aMessage"/>
+        <body><![CDATA[
+          let data = aMessage.data;
+          let browser = aMessage.target;
+
+          switch (aMessage.name) {
+            case "DOMTitleChanged": {
+              let tab = this.getTabForBrowser(browser);
+              if (!tab || tab.hasAttribute("pending"))
+                return undefined;
+              let titleChanged = this.setTabTitle(tab);
+              if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
+                tab.setAttribute("titlechanged", "true");
+              break;
+            }
+            case "DOMWindowClose": {
+              if (this.tabs.length == 1) {
+                // We already did PermitUnload in the content process
+                // for this tab (the only one in the window). So we don't
+                // need to do it again for any tabs.
+                window.skipNextCanClose = true;
+                window.close();
+                return undefined;
+              }
+
+              let tab = this.getTabForBrowser(browser);
+              if (tab) {
+                // Skip running PermitUnload since it already happened in
+                // the content process.
+                this.removeTab(tab, {skipPermitUnload: true});
+              }
+              break;
+            }
+            case "contextmenu": {
+              openContextMenu(aMessage);
+              break;
+            }
+            case "DOMWindowFocus": {
+              let tab = this.getTabForBrowser(browser);
+              if (!tab)
+                return undefined;
+              this.selectedTab = tab;
+              window.focus();
+              break;
+            }
+            case "Browser:Init": {
+              let tab = this.getTabForBrowser(browser);
+              if (!tab)
+                return undefined;
+
+              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
+              browser.messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: tab.pinned });
+              break;
+            }
+            case "Browser:WindowCreated": {
+              let tab = this.getTabForBrowser(browser);
+              if (tab && data.userContextId) {
+                ContextualIdentityService.telemetry(data.userContextId);
+                tab.setUserContextId(data.userContextId);
+              }
+
+              // We don't want to update the container icon and identifier if
+              // this is not the selected browser.
+              if (browser == gBrowser.selectedBrowser) {
+                updateUserContextUIIndicator();
+              }
+
+              break;
+            }
+            case "Findbar:Keypress": {
+              let tab = this.getTabForBrowser(browser);
+              // If the find bar for this tab is not yet alive, only initialize
+              // it if there's a possibility FindAsYouType will be used.
+              // There's no point in doing it for most random keypresses.
+              if (!this.isFindBarInitialized(tab) &&
+                data.shouldFastFind) {
+                let shouldFastFind = this._findAsYouType;
+                if (!shouldFastFind) {
+                  // Please keep in sync with toolkit/content/widgets/findbar.xml
+                  const FAYT_LINKS_KEY = "'";
+                  const FAYT_TEXT_KEY = "/";
+                  let charCode = data.fakeEvent.charCode;
+                  let key = charCode ? String.fromCharCode(charCode) : null;
+                  shouldFastFind = key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY;
+                }
+                if (shouldFastFind) {
+                  // Make sure we return the result.
+                  return this.getFindBar(tab).receiveMessage(aMessage);
+                }
+              }
+              break;
+            }
+            case "RefreshBlocker:Blocked": {
+              // The data object is expected to contain the following properties:
+              //  - URI (string)
+              //     The URI that a page is attempting to refresh or redirect to.
+              //  - delay (int)
+              //     The delay (in milliseconds) before the page was going to
+              //     reload or redirect.
+              //  - sameURI (bool)
+              //     true if we're refreshing the page. false if we're redirecting.
+              //  - outerWindowID (int)
+              //     The outerWindowID of the frame that requested the refresh or
+              //     redirect.
+
+              let brandBundle = document.getElementById("bundle_brand");
+              let brandShortName = brandBundle.getString("brandShortName");
+              let message =
+                gNavigatorBundle.getFormattedString("refreshBlocked." +
+                                                    (data.sameURI ? "refreshLabel"
+                                                                  : "redirectLabel"),
+                                                    [brandShortName]);
+
+              let notificationBox = this.getNotificationBox(browser);
+              let notification = notificationBox.getNotificationWithValue("refresh-blocked");
+
+              if (notification) {
+                notification.label = message;
+              } else {
+                let refreshButtonText =
+                  gNavigatorBundle.getString("refreshBlocked.goButton");
+                let refreshButtonAccesskey =
+                  gNavigatorBundle.getString("refreshBlocked.goButton.accesskey");
+
+                let buttons = [{
+                  label: refreshButtonText,
+                  accessKey: refreshButtonAccesskey,
+                  callback() {
+                    if (browser.messageManager) {
+                      browser.messageManager.sendAsyncMessage("RefreshBlocker:Refresh", data);
+                    }
+                  }
+                }];
+
+                notificationBox.appendNotification(message, "refresh-blocked",
+                                                   "chrome://browser/skin/notification-icons/popup.svg",
+                                                   notificationBox.PRIORITY_INFO_MEDIUM,
+                                                   buttons);
+              }
+              break;
+            }
+
+            case "Prerender:Request": {
+              let sendCancelPrerendering = () => {
+                browser.frameloader.messageManager.
+                  sendAsyncMessage("Prerender:Canceled", { id: data.id });
+              };
+
+              let tab = this.getTabForBrowser(browser);
+              if (!tab) {
+                // No tab?
+                sendCancelPrerendering();
+                break;
+              }
+
+              if (tab.hidden) {
+                // Skip prerender on hidden tab.
+                sendCancelPrerendering();
+                break;
+              }
+
+              if (browser.canGoForward) {
+                // Skip prerender on history navigation as we don't support it
+                // yet. Remove this check once bug 1323650 is implemented.
+                sendCancelPrerendering();
+                break;
+              }
+
+              if (!data.href) {
+                // If we don't have data.href, loadOneTab will load about:blank
+                // which is meaningless for prerendering.
+                sendCancelPrerendering();
+                break;
+              }
+
+              let groupedSHistory = browser.frameLoader.ensureGroupedSHistory();
+
+              let newTab = this.loadOneTab(data.href, {
+                referrerURI: (data.referrer ? makeURI(data.referrer) : null),
+                referrerPolicy: Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,
+                postData: null,
+                allowThirdPartyFixup: true,
+                relatedToCurrent: true,
+                isPrerendered: true,
+                triggeringPrincipal: Utils.deserializePrincipal(data.triggeringPrincipal),
+              });
+              let partialSHistory = newTab.linkedBrowser.frameLoader.partialSHistory;
+              groupedSHistory.addPrerenderingPartialSHistory(partialSHistory, data.id);
+              break;
+            }
+
+            case "Prerender:Cancel": {
+              let groupedSHistory = browser.frameLoader.groupedSHistory;
+              if (groupedSHistory) {
+                groupedSHistory.cancelPrerendering(data.id);
+              }
+              break;
+            }
+
+            case "Prerender:Swap": {
+              let frameloader = browser.frameLoader;
+              let groupedSHistory = browser.frameLoader.groupedSHistory;
+              if (groupedSHistory) {
+                groupedSHistory.activatePrerendering(data.id).then(
+                  () => frameloader.messageManager.sendAsyncMessage("Prerender:Swapped", data),
+                  () => frameloader.messageManager.sendAsyncMessage("Prerender:Canceled", data),
+                );
+              }
+              break;
+            }
+
+          }
+          return undefined;
+        ]]></body>
+      </method>
+
+      <method name="observe">
+        <parameter name="aSubject"/>
+        <parameter name="aTopic"/>
+        <parameter name="aData"/>
+        <body><![CDATA[
+          switch (aTopic) {
+            case "contextual-identity-updated": {
+              for (let tab of this.tabs) {
+                if (tab.getAttribute("usercontextid") == aData) {
+                  ContextualIdentityService.setTabStyle(tab);
+                }
+              }
+              break;
+            }
+            case "nsPref:changed": {
+              // This is the only pref observed.
+              this._findAsYouType = Services.prefs.getBoolPref("accessibility.typeaheadfind");
+              break;
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="_updateNewTabVisibility">
+        <body><![CDATA[
+          // Helper functions to help deal with customize mode wrapping some items
+          let wrap = n => n.parentNode.localName == "toolbarpaletteitem" ? n.parentNode : n;
+          let unwrap = n => n && n.localName == "toolbarpaletteitem" ? n.firstElementChild : n;
+
+          let sib = this.tabContainer;
+          do {
+            sib = unwrap(wrap(sib).nextElementSibling);
+          } while (sib && sib.hidden);
+
+          const kAttr = "hasadjacentnewtabbutton";
+          if (sib && sib.id == "new-tab-button") {
+            this.tabContainer.setAttribute(kAttr, "true");
+          } else {
+            this.tabContainer.removeAttribute(kAttr);
+          }
+        ]]></body>
+      </method>
+
+      <method name="onWidgetAfterDOMChange">
+        <parameter name="aNode"/>
+        <parameter name="aNextNode"/>
+        <parameter name="aContainer"/>
+        <body><![CDATA[
+          if (aContainer.ownerDocument == document &&
+              aContainer.id == "TabsToolbar") {
+            this._updateNewTabVisibility();
+          }
+        ]]></body>
+      </method>
+      <method name="onAreaNodeRegistered">
+        <parameter name="aArea"/>
+        <parameter name="aContainer"/>
+        <body><![CDATA[
+          if (aContainer.ownerDocument == document &&
+              aArea == "TabsToolbar") {
+            this._updateNewTabVisibility();
+          }
+        ]]></body>
+      </method>
+      <method name="onAreaReset">
+        <parameter name="aArea"/>
+        <parameter name="aContainer"/>
+        <body><![CDATA[
+          this.onAreaNodeRegistered(aArea, aContainer);
+        ]]></body>
+      </method>
+
+      <field name="_tabMinWidthLimit">50</field>
+      <property name="tabMinWidth">
+        <setter><![CDATA[
+          let root = document.documentElement;
+          root.style.setProperty("--tab-min-width", val + "px");
+          return val;
+        ]]></setter>
+      </property>
+
+      <constructor>
+        <![CDATA[
+          this.mCurrentBrowser = document.getAnonymousElementByAttribute(this, "anonid", "initialBrowser");
+          this.mCurrentBrowser.permanentKey = {};
+
+          CustomizableUI.addListener(this);
+          this._updateNewTabVisibility();
+
+          Services.obs.addObserver(this, "contextual-identity-updated");
+
+          this.mCurrentTab = this.tabContainer.firstChild;
+          const nsIEventListenerService =
+            Components.interfaces.nsIEventListenerService;
+          let els = Components.classes["@mozilla.org/eventlistenerservice;1"]
+                              .getService(nsIEventListenerService);
+          els.addSystemEventListener(document, "keydown", this, false);
+          if (AppConstants.platform == "macosx") {
+            els.addSystemEventListener(document, "keypress", this, false);
+          }
+          window.addEventListener("sizemodechange", this);
+          window.addEventListener("occlusionstatechange", this);
+
+          var uniqueId = this._generateUniquePanelID();
+          this.mPanelContainer.childNodes[0].id = uniqueId;
+          this.mCurrentTab.linkedPanel = uniqueId;
+          this.mCurrentTab.permanentKey = this.mCurrentBrowser.permanentKey;
+          this.mCurrentTab._tPos = 0;
+          this.mCurrentTab._fullyOpen = true;
+          this.mCurrentTab.linkedBrowser = this.mCurrentBrowser;
+          this._tabForBrowser.set(this.mCurrentBrowser, this.mCurrentTab);
+
+          // set up the shared autoscroll popup
+          this._autoScrollPopup = this.mCurrentBrowser._createAutoScrollPopup();
+          this._autoScrollPopup.id = "autoscroller";
+          this.appendChild(this._autoScrollPopup);
+          this.mCurrentBrowser.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
+          this.mCurrentBrowser.droppedLinkHandler = handleDroppedLink;
+
+          // Hook up the event listeners to the first browser
+          var tabListener = this.mTabProgressListener(this.mCurrentTab, this.mCurrentBrowser, true, false);
+          const nsIWebProgress = Components.interfaces.nsIWebProgress;
+          const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
+                                   .createInstance(nsIWebProgress);
+          filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);
+          this._tabListeners.set(this.mCurrentTab, tabListener);
+          this._tabFilters.set(this.mCurrentTab, filter);
+          this.webProgress.addProgressListener(filter, nsIWebProgress.NOTIFY_ALL);
+
+          if (Services.prefs.getBoolPref("browser.display.use_system_colors"))
+            this.style.backgroundColor = "-moz-default-background-color";
+
+          let messageManager = window.getGroupMessageManager("browsers");
+
+          let remote = window.QueryInterface(Ci.nsIInterfaceRequestor)
+            .getInterface(Ci.nsIWebNavigation)
+            .QueryInterface(Ci.nsILoadContext)
+            .useRemoteTabs;
+          if (remote) {
+            messageManager.addMessageListener("DOMTitleChanged", this);
+            messageManager.addMessageListener("DOMWindowClose", this);
+            window.messageManager.addMessageListener("contextmenu", this);
+            messageManager.addMessageListener("Browser:Init", this);
+
+            // If this window has remote tabs, switch to our tabpanels fork
+            // which does asynchronous tab switching.
+            this.mPanelContainer.classList.add("tabbrowser-tabpanels");
+          } else {
+            this._outerWindowIDBrowserMap.set(this.mCurrentBrowser.outerWindowID,
+                                              this.mCurrentBrowser);
+          }
+          messageManager.addMessageListener("DOMWindowFocus", this);
+          messageManager.addMessageListener("RefreshBlocker:Blocked", this);
+          messageManager.addMessageListener("Browser:WindowCreated", this);
+
+          // To correctly handle keypresses for potential FindAsYouType, while
+          // the tab's find bar is not yet initialized.
+          this._findAsYouType = Services.prefs.getBoolPref("accessibility.typeaheadfind");
+          Services.prefs.addObserver("accessibility.typeaheadfind", this);
+          messageManager.addMessageListener("Findbar:Keypress", this);
+
+          // Add listeners for prerender messages
+          messageManager.addMessageListener("Prerender:Request", this);
+          messageManager.addMessageListener("Prerender:Cancel", this);
+          messageManager.addMessageListener("Prerender:Swap", this);
+
+          XPCOMUtils.defineLazyPreferenceGetter(this, "animationsEnabled",
+                                                "toolkit.cosmeticAnimations.enabled", true);
+          XPCOMUtils.defineLazyPreferenceGetter(this, "schedulePressureDefaultCount",
+                                                "browser.schedulePressure.defaultCount", 3);
+          XPCOMUtils.defineLazyPreferenceGetter(this, "tabWarmingEnabled",
+                                                "browser.tabs.remote.warmup.enabled", false);
+          XPCOMUtils.defineLazyPreferenceGetter(this, "tabWarmingMax",
+                                                "browser.tabs.remote.warmup.maxTabs", 3);
+          XPCOMUtils.defineLazyPreferenceGetter(this, "tabWarmingUnloadDelay" /* ms */,
+                                                "browser.tabs.remote.warmup.unloadDelayMs", 2000);
+          XPCOMUtils.defineLazyPreferenceGetter(this, "tabMinWidthPref",
+                                                "browser.tabs.tabMinWidth", this._tabMinWidthLimit,
+            (pref, prevValue, newValue) => this.tabMinWidth = newValue,
+            newValue => Math.max(newValue, this._tabMinWidthLimit),
+          );
+
+          this.tabMinWidth = this.tabMinWidthPref;
+        ]]>
+      </constructor>
+
+      <method name="_generateUniquePanelID">
+        <body><![CDATA[
+          if (!this._uniquePanelIDCounter) {
+            this._uniquePanelIDCounter = 0;
+          }
+
+          let outerID = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                              .getInterface(Ci.nsIDOMWindowUtils)
+                              .outerWindowID;
+
+          // We want panel IDs to be globally unique, that's why we include the
+          // window ID. We switched to a monotonic counter as Date.now() lead
+          // to random failures because of colliding IDs.
+          return "panel-" + outerID + "-" + (++this._uniquePanelIDCounter);
+        ]]></body>
+      </method>
+
+      <destructor>
+        <![CDATA[
+          Services.obs.removeObserver(this, "contextual-identity-updated");
+
+          CustomizableUI.removeListener(this);
+
+          for (let tab of this.tabs) {
+            let browser = tab.linkedBrowser;
+            if (browser.registeredOpenURI) {
+              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI,
+                                                       browser.getAttribute("usercontextid") || 0);
+              delete browser.registeredOpenURI;
+            }
+
+            let filter = this._tabFilters.get(tab);
+            if (filter) {
+              browser.webProgress.removeProgressListener(filter);
+
+              let listener = this._tabListeners.get(tab);
+              if (listener) {
+                filter.removeProgressListener(listener);
+                listener.destroy();
+              }
+
+              this._tabFilters.delete(tab);
+              this._tabListeners.delete(tab);
+            }
+          }
+          const nsIEventListenerService =
+            Components.interfaces.nsIEventListenerService;
+          let els = Components.classes["@mozilla.org/eventlistenerservice;1"]
+                              .getService(nsIEventListenerService);
+          els.removeSystemEventListener(document, "keydown", this, false);
+          if (AppConstants.platform == "macosx") {
+            els.removeSystemEventListener(document, "keypress", this, false);
+          }
+          window.removeEventListener("sizemodechange", this);
+          window.removeEventListener("occlusionstatechange", this);
+
+          if (gMultiProcessBrowser) {
+            let messageManager = window.getGroupMessageManager("browsers");
+            messageManager.removeMessageListener("DOMTitleChanged", this);
+            window.messageManager.removeMessageListener("contextmenu", this);
+
+            if (this._switcher) {
+              this._switcher.destroy();
+            }
+          }
+
+          Services.prefs.removeObserver("accessibility.typeaheadfind", this);
+        ]]>
+      </destructor>
+
+      <field name="_soundPlayingAttrRemovalTimer">0</field>
+      <field name="_hoverTabTimer">null</field>
+    </implementation>
+
+    <handlers>
+      <handler event="DOMWindowClose" phase="capturing">
+        <![CDATA[
+          if (!event.isTrusted)
+            return;
+
+          if (this.tabs.length == 1) {
+            // We already did PermitUnload in nsGlobalWindow::Close
+            // for this tab. There are no other tabs we need to do
+            // PermitUnload for.
+            window.skipNextCanClose = true;
+            return;
+          }
+
+          var tab = this._getTabForContentWindow(event.target);
+          if (tab) {
+            // Skip running PermitUnload since it already happened.
+            this.removeTab(tab, {skipPermitUnload: true});
+            event.preventDefault();
+          }
+        ]]>
+      </handler>
+      <handler event="DOMWillOpenModalDialog" phase="capturing">
+        <![CDATA[
+          if (!event.isTrusted)
+            return;
+
+          let targetIsWindow = event.target instanceof Window;
+
+          // We're about to open a modal dialog, so figure out for which tab:
+          // If this is a same-process modal dialog, then we're given its DOM
+          // window as the event's target. For remote dialogs, we're given the
+          // browser, but that's in the originalTarget and not the target,
+          // because it's across the tabbrowser's XBL boundary.
+          let tabForEvent = targetIsWindow ?
+                            this._getTabForContentWindow(event.target.top) :
+                            this.getTabForBrowser(event.originalTarget);
+
+          // Focus window for beforeunload dialog so it is seen but don't
+          // steal focus from other applications.
+          if (event.detail &&
+              event.detail.tabPrompt &&
+              event.detail.inPermitUnload &&
+              Services.focus.activeWindow)
+            window.focus();
+
+          // Don't need to act if the tab is already selected or if there isn't
+          // a tab for the event (e.g. for the webextensions options_ui remote
+          // browsers embedded in the "about:addons" page):
+          if (!tabForEvent || tabForEvent.selected)
+            return;
+
+          // We always switch tabs for beforeunload tab-modal prompts.
+          if (event.detail &&
+              event.detail.tabPrompt &&
+              !event.detail.inPermitUnload) {
+            let docPrincipal = targetIsWindow ? event.target.document.nodePrincipal : null;
+            // At least one of these should/will be non-null:
+            let promptPrincipal = event.detail.promptPrincipal || docPrincipal ||
+                                  tabForEvent.linkedBrowser.contentPrincipal;
+            // For null principals, we bail immediately and don't show the checkbox:
+            if (!promptPrincipal || promptPrincipal.isNullPrincipal) {
+              tabForEvent.setAttribute("attention", "true");
+              return;
+            }
+
+            // For non-system/expanded principals, we bail and show the checkbox
+            if (promptPrincipal.URI &&
+                !Services.scriptSecurityManager.isSystemPrincipal(promptPrincipal)) {
+              let permission = Services.perms.testPermissionFromPrincipal(promptPrincipal,
+                                                                          "focus-tab-by-prompt");
+              if (permission != Services.perms.ALLOW_ACTION) {
+                // Tell the prompt box we want to show the user a checkbox:
+                let tabPrompt = this.getTabModalPromptBox(tabForEvent.linkedBrowser);
+                tabPrompt.onNextPromptShowAllowFocusCheckboxFor(promptPrincipal);
+                tabForEvent.setAttribute("attention", "true");
+                return;
+              }
+            }
+            // ... so system and expanded principals, as well as permitted "normal"
+            // URI-based principals, always get to steal focus for the tab when prompting.
+          }
+
+          // If permissions/origins dictate so, bring tab to the front.
+          this.selectedTab = tabForEvent;
+        ]]>
+      </handler>
+      <handler event="DOMTitleChanged">
+        <![CDATA[
+          if (!event.isTrusted)
+            return;
+
+          var contentWin = event.target.defaultView;
+          if (contentWin != contentWin.top)
+            return;
+
+          var tab = this._getTabForContentWindow(contentWin);
+          if (!tab || tab.hasAttribute("pending"))
+            return;
+
+          var titleChanged = this.setTabTitle(tab);
+          if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
+            tab.setAttribute("titlechanged", "true");
+        ]]>
+      </handler>
+      <handler event="oop-browser-crashed">
+        <![CDATA[
+          if (!event.isTrusted)
+            return;
+
+          let browser = event.originalTarget;
+
+          // Preloaded browsers do not actually have any tabs. If one crashes,
+          // it should be released and removed.
+          if (browser === this._preloadedBrowser) {
+            this.removePreloadedBrowser();
+            return;
+          }
+
+          let icon = browser.mIconURL;
+          let tab = this.getTabForBrowser(browser);
+
+          if (this.selectedBrowser == browser) {
+            TabCrashHandler.onSelectedBrowserCrash(browser);
+          } else {
+            this.updateBrowserRemoteness(browser, false);
+            SessionStore.reviveCrashedTab(tab);
+          }
+
+          tab.removeAttribute("soundplaying");
+          this.setIcon(tab, icon, browser.contentPrincipal, browser.contentRequestContextID);
+        ]]>
+      </handler>
+      <handler event="DOMAudioPlaybackStarted">
+        <![CDATA[
+          var tab = this.getTabFromAudioEvent(event);
+          if (!tab) {
+            return;
+          }
+
+          clearTimeout(tab._soundPlayingAttrRemovalTimer);
+          tab._soundPlayingAttrRemovalTimer = 0;
+
+          let modifiedAttrs = [];
+          if (tab.hasAttribute("soundplaying-scheduledremoval")) {
+            tab.removeAttribute("soundplaying-scheduledremoval");
+            modifiedAttrs.push("soundplaying-scheduledremoval");
+          }
+
+          if (!tab.hasAttribute("soundplaying")) {
+            tab.setAttribute("soundplaying", true);
+            modifiedAttrs.push("soundplaying");
+          }
+
+          if (modifiedAttrs.length) {
+            // Flush style so that the opacity takes effect immediately, in
+            // case the media is stopped before the style flushes naturally.
+            getComputedStyle(tab).opacity;
+          }
+
+          this._tabAttrModified(tab, modifiedAttrs);
+        ]]>
+      </handler>
+      <handler event="DOMAudioPlaybackStopped">
+        <![CDATA[
+          var tab = this.getTabFromAudioEvent(event);
+          if (!tab) {
+            return;
+          }
+
+          if (tab.hasAttribute("soundplaying")) {
+            let removalDelay = Services.prefs.getIntPref("browser.tabs.delayHidingAudioPlayingIconMS");
+
+            tab.style.setProperty("--soundplaying-removal-delay", `${removalDelay - 300}ms`);
+            tab.setAttribute("soundplaying-scheduledremoval", "true");
+            this._tabAttrModified(tab, ["soundplaying-scheduledremoval"]);
+
+            tab._soundPlayingAttrRemovalTimer = setTimeout(() => {
+              tab.removeAttribute("soundplaying-scheduledremoval");
+              tab.removeAttribute("soundplaying");
+              this._tabAttrModified(tab, ["soundplaying", "soundplaying-scheduledremoval"]);
+            }, removalDelay);
+          }
+        ]]>
+      </handler>
+      <handler event="DOMAudioPlaybackBlockStarted">
+        <![CDATA[
+          var tab = this.getTabFromAudioEvent(event);
+          if (!tab) {
+            return;
+          }
+
+          if (!tab.hasAttribute("activemedia-blocked")) {
+            tab.setAttribute("activemedia-blocked", true);
+            this._tabAttrModified(tab, ["activemedia-blocked"]);
+            tab.startMediaBlockTimer();
+          }
+        ]]>
+      </handler>
+      <handler event="DOMAudioPlaybackBlockStopped">
+        <![CDATA[
+          var tab = this.getTabFromAudioEvent(event);
+          if (!tab) {
+            return;
+          }
+
+          if (tab.hasAttribute("activemedia-blocked")) {
+            tab.removeAttribute("activemedia-blocked");
+            this._tabAttrModified(tab, ["activemedia-blocked"]);
+            let hist = Services.telemetry.getHistogramById("TAB_AUDIO_INDICATOR_USED");
+            hist.add(2 /* unblockByVisitingTab */);
+            tab.finishMediaBlockTimer();
+          }
+        ]]>
+      </handler>
+    </handlers>
+  </binding>
+
+  <binding id="tabbrowser-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
+    <implementation>
+      <!-- Override scrollbox.xml method, since our scrollbox's children are
+           inherited from the binding parent -->
+      <method name="_getScrollableElements">
+        <body><![CDATA[
+          return Array.filter(document.getBindingParent(this).childNodes,
+                              this._canScrollToElement, this);
+        ]]></body>
+      </method>
+      <method name="_canScrollToElement">
+        <parameter name="tab"/>
+        <body><![CDATA[
+          return !tab.pinned && !tab.hidden;
+        ]]></body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="underflow" phase="capturing"><![CDATA[
+        if (event.originalTarget != this._scrollbox)
+          return;
+
+        // Ignore vertical events
+        if (event.detail == 0)
+          return;
+
+        var tabs = document.getBindingParent(this);
+        tabs.removeAttribute("overflow");
+
+        if (tabs._lastTabClosedByMouse)
+          tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);
+
+        for (let tab of Array.from(tabs.tabbrowser._removingTabs))
+          tabs.tabbrowser.removeTab(tab);
+
+        tabs._positionPinnedTabs();
+      ]]></handler>
+      <handler event="overflow"><![CDATA[
+        if (event.originalTarget != this._scrollbox)
+          return;
+
+        // Ignore vertical events
+        if (event.detail == 0)
+          return;
+
+        var tabs = document.getBindingParent(this);
+        tabs.setAttribute("overflow", "true");
+        tabs._positionPinnedTabs();
+        tabs._handleTabSelect(true);
+      ]]></handler>
+    </handlers>
+  </binding>
+
+  <binding id="tabbrowser-tabs"
+           extends="chrome://global/content/bindings/tabbox.xml#tabs">
+    <resources>
+      <stylesheet src="chrome://browser/content/tabbrowser.css"/>
+    </resources>
+
+    <content>
+      <xul:hbox class="tab-drop-indicator-box">
+        <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
+      </xul:hbox>
+      <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
+                          style="min-width: 1px;"
+                          class="tabbrowser-arrowscrollbox">
+<!--
+ This is a hack to circumvent bug 472020, otherwise the tabs show up on the
+ right of the newtab button.
+-->
+        <children includes="tab"/>
+<!--
+  This is to ensure anything extensions put here will go before the newtab
+  button, necessary due to the previous hack.
+-->
+        <children/>
+        <xul:toolbarbutton class="tabs-newtab-button toolbarbutton-1"
+                           anonid="tabs-newtab-button"
+                           command="cmd_newNavigatorTab"
+                           onclick="checkForMiddleClick(this, event);"
+                           tooltip="dynamic-shortcut-tooltip"/>
+        <xul:hbox class="restore-tabs-button-wrapper"
+                  anonid="restore-tabs-button-wrapper">
+          <xul:toolbarbutton anonid="restore-tabs-button"
+                             class="restore-tabs-button"
+                             onclick="SessionStore.restoreLastSession();"/>
+        </xul:hbox>
+
+        <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
+                    style="width: 0;"/>
+      </xul:arrowscrollbox>
+    </content>
+
+    <implementation implements="nsIDOMEventListener, nsIObserver">
+      <constructor>
+        <![CDATA[
+          this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
+
+          let { restoreTabsButton } = this;
+          restoreTabsButton.setAttribute("label", gTabBrowserBundle.GetStringFromName("tabs.restoreLastTabs"));
+
+          var tab = this.firstChild;
+          tab.label = gTabBrowserBundle.GetStringFromName("tabs.emptyTabTitle");
+          tab.setAttribute("onerror", "this.removeAttribute('image');");
+
+          window.addEventListener("resize", this);
+          window.addEventListener("load", this);
+
+          Services.prefs.addObserver("privacy.userContext", this);
+          this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
+
+          this._setPositionalAttributes();
+        ]]>
+      </constructor>
+
+      <destructor>
+        <![CDATA[
+          Services.prefs.removeObserver("privacy.userContext", this);
+        ]]>
+      </destructor>
+
+      <field name="tabbrowser" readonly="true">
+        document.getElementById(this.getAttribute("tabbrowser"));
+      </field>
+
+      <field name="tabbox" readonly="true">
+        this.tabbrowser.tabbox;
+      </field>
+
+      <field name="contextMenu" readonly="true">
+        document.getElementById("tabContextMenu");
+      </field>
+
+      <field name="arrowScrollbox">
+        document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
+      </field>
+
+      <field name="_firstTab">null</field>
+      <field name="_lastTab">null</field>
+      <field name="_beforeSelectedTab">null</field>
+      <field name="_beforeHoveredTab">null</field>
+      <field name="_afterHoveredTab">null</field>
+      <field name="_hoveredTab">null</field>
+      <field name="restoreTabsButton">
+        document.getAnonymousElementByAttribute(this, "anonid", "restore-tabs-button");
+      </field>
+      <field name="_restoreTabsButtonWrapperWidth">0</field>
+      <field name="windowUtils">
+        window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
+      </field>
+
+      <property name="restoreTabsButtonWrapperWidth" readonly="true">
+        <getter>
+          if (!this._restoreTabsButtonWrapperWidth) {
+            this._restoreTabsButtonWrapperWidth = this.windowUtils
+              .getBoundsWithoutFlushing(this.restoreTabsButton.parentNode)
+              .width;
+          }
+          return this._restoreTabsButtonWrapperWidth;
+        </getter>
+      </property>
+
+      <method name="updateSessionRestoreVisibility">
+        <body><![CDATA[
+          let {restoreTabsButton, restoreTabsButtonWrapperWidth, windowUtils} = this;
+          let restoreTabsButtonWrapper = restoreTabsButton.parentNode;
+
+          if (!restoreTabsButtonWrapper.getAttribute("session-exists")) {
+            restoreTabsButtonWrapper.removeAttribute("shown");
+            return;
+          }
+
+          let arrowScrollboxWidth = this.arrowScrollbox.clientWidth;
+
+          let newTabButton = document.getAnonymousElementByAttribute(
+            this, "anonid", "tabs-newtab-button");
+
+          // If there are no pinned tabs it will multiply by 0 and result in 0
+          let pinnedTabsWidth = windowUtils.getBoundsWithoutFlushing(this.firstChild).width * this._lastNumPinned;
+
+          let numUnpinnedTabs = this.childNodes.length - this._lastNumPinned;
+          let unpinnedTabsWidth = windowUtils.getBoundsWithoutFlushing(this.lastChild).width * numUnpinnedTabs;
+
+          let tabbarUsedSpace = pinnedTabsWidth + unpinnedTabsWidth
+            + windowUtils.getBoundsWithoutFlushing(newTabButton).width;
+
+          // Subtract the elements' widths from the available space to ensure
+          // that showing the restoreTabsButton won't cause any overflow.
+          if (arrowScrollboxWidth - tabbarUsedSpace > restoreTabsButtonWrapperWidth) {
+            restoreTabsButtonWrapper.setAttribute("shown", "true");
+          } else {
+            restoreTabsButtonWrapper.removeAttribute("shown");
+          }
+        ]]></body>
+      </method>
+
+      <method name="observe">
+        <parameter name="aSubject"/>
+        <parameter name="aTopic"/>
+        <parameter name="aData"/>
+        <body><![CDATA[
+          switch (aTopic) {
+            case "nsPref:changed":
+              // This is has to deal with changes in
+              // privacy.userContext.enabled and
+              // privacy.userContext.longPressBehavior.
+              let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled")
+                                        && !PrivateBrowsingUtils.isWindowPrivate(window);
+
+              // This pref won't change so often, so just recreate the menu.
+              let longPressBehavior = Services.prefs.getIntPref("privacy.userContext.longPressBehavior");
+
+              // If longPressBehavior pref is set to 0 (or any invalid value)
+              // long press menu is disabled.
+              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
+                containersEnabled = false;
+              }
+
+              const newTab = document.getElementById("new-tab-button");
+              const newTab2 = document.getAnonymousElementByAttribute(this, "anonid", "tabs-newtab-button");
+
+              for (let parent of [newTab, newTab2]) {
+                if (!parent)
+                  continue;
+
+                gClickAndHoldListenersOnElement.remove(parent);
+                parent.removeAttribute("type");
+                if (parent.firstChild) {
+                  parent.firstChild.remove();
+                }
+
+                if (containersEnabled) {
+                  let popup = document.createElementNS(
+                                "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+                                "menupopup");
+                  if (parent.id) {
+                    popup.id = "newtab-popup";
+                  } else {
+                    popup.setAttribute("anonid", "newtab-popup");
+                  }
+                  popup.className = "new-tab-popup";
+                  popup.setAttribute("position", "after_end");
+                  parent.appendChild(popup);
+
+                  // longPressBehavior == 2 means that the menu is shown after X
+                  // millisecs. Otherwise, with 1, the menu is open immediatelly.
+                  if (longPressBehavior == 2) {
+                    gClickAndHoldListenersOnElement.add(parent);
+                  }
+
+                  parent.setAttribute("type", "menu");
+                }
+              }
+
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <property name="_isCustomizing" readonly="true">
+        <getter><![CDATA[
+          return document.documentElement.getAttribute("customizing") == "true";
+        ]]></getter>
+      </property>
+
+      <method name="_setPositionalAttributes">
+        <body><![CDATA[
+          let visibleTabs = this.tabbrowser.visibleTabs;
+
+          if (!visibleTabs.length)
+            return;
+
+          let selectedIndex = visibleTabs.indexOf(this.selectedItem);
+
+          if (this._beforeSelectedTab) {
+            this._beforeSelectedTab.removeAttribute("beforeselected-visible");
+          }
+
+          if (this.selectedItem.closing || selectedIndex == 0) {
+            this._beforeSelectedTab = null;
+          } else {
+            let beforeSelectedTab = visibleTabs[selectedIndex - 1];
+            let separatedByScrollButton = this.getAttribute("overflow") == "true" &&
+              beforeSelectedTab.pinned && !this.selectedItem.pinned;
+            if (!separatedByScrollButton) {
+              this._beforeSelectedTab = beforeSelectedTab;
+              this._beforeSelectedTab.setAttribute("beforeselected-visible",
+                                                   "true");
+            }
+          }
+
+          if (this._firstTab)
+            this._firstTab.removeAttribute("first-visible-tab");
+          this._firstTab = visibleTabs[0];
+          this._firstTab.setAttribute("first-visible-tab", "true");
+          if (this._lastTab)
+            this._lastTab.removeAttribute("last-visible-tab");
+          this._lastTab = visibleTabs[visibleTabs.length - 1];
+          this._lastTab.setAttribute("last-visible-tab", "true");
+
+          let hoveredTab = this._hoveredTab;
+          if (hoveredTab) {
+            hoveredTab._mouseleave();
+          }
+          hoveredTab = this.querySelector("tab:hover");
+          if (hoveredTab) {
+            hoveredTab._mouseenter();
+          }
+        ]]></body>
+      </method>
+
+      <field name="_blockDblClick">false</field>
+
+      <field name="_tabDropIndicator">
+        document.getAnonymousElementByAttribute(this, "anonid", "tab-drop-indicator");
+      </field>
+
+      <field name="_dragOverDelay">350</field>
+      <field name="_dragTime">0</field>
+
+      <field name="_container" readonly="true"><![CDATA[
+        this.parentNode && this.parentNode.localName == "toolbar" ? this.parentNode : this;
+      ]]></field>
+
+      <field name="_propagatedVisibilityOnce">false</field>
+
+      <property name="visible"
+                onget="return !this._container.collapsed;">
+        <setter><![CDATA[
+          if (val == this.visible &&
+              this._propagatedVisibilityOnce)
+            return val;
+
+          this._container.collapsed = !val;
+
+          this._propagateVisibility();
+          this._propagatedVisibilityOnce = true;
+
+          return val;
+        ]]></setter>
+      </property>
+
+      <method name="_propagateVisibility">
+        <body><![CDATA[
+          let visible = this.visible;
+
+          document.getElementById("menu_closeWindow").hidden = !visible;
+          document.getElementById("menu_close").setAttribute("label",
+            gTabBrowserBundle.GetStringFromName(visible ? "tabs.closeTab" : "tabs.close"));
+
+          TabsInTitlebar.allowedBy("tabs-visible", visible);
+        ]]></body>
+      </method>
+
+      <method name="updateVisibility">
+        <body><![CDATA[
+          if (this.childNodes.length - this.tabbrowser._removingTabs.length == 1)
+            this.visible = window.toolbar.visible;
+          else
+            this.visible = true;
+        ]]></body>
+      </method>
+
+      <field name="_closeButtonsUpdatePending">false</field>
+      <method name="_updateCloseButtons">
+        <body><![CDATA[
+          // If we're overflowing, tabs are at their minimum widths.
+          if (this.getAttribute("overflow") == "true") {
+            this.setAttribute("closebuttons", "activetab");
+            return;
+          }
+
+          if (this._closeButtonsUpdatePending) {
+            return;
+          }
+          this._closeButtonsUpdatePending = true;
+
+          // Wait until after the next paint to get current layout data from
+          // getBoundsWithoutFlushing.
+          window.requestAnimationFrame(() => {
+            window.requestAnimationFrame(() => {
+              this._closeButtonsUpdatePending = false;
+
+              // The scrollbox may have started overflowing since we checked
+              // overflow earlier, so check again.
+              if (this.getAttribute("overflow") == "true") {
+                this.setAttribute("closebuttons", "activetab");
+                return;
+              }
+
+              // Check if tab widths are below the threshold where we want to
+              // remove close buttons from background tabs so that people don't
+              // accidentally close tabs by selecting them.
+              let rect = ele => {
+                return window.QueryInterface(Ci.nsIInterfaceRequestor)
+                             .getInterface(Ci.nsIDOMWindowUtils)
+                             .getBoundsWithoutFlushing(ele);
+              };
+              let tab = this.tabbrowser.visibleTabs[this.tabbrowser._numPinnedTabs];
+              if (tab && rect(tab).width <= this._tabClipWidth) {
+                this.setAttribute("closebuttons", "activetab");
+              } else {
+                this.removeAttribute("closebuttons");
+              }
+            });
+          });
+        ]]></body>
+      </method>
+
+      <method name="_handleTabSelect">
+        <parameter name="aInstant"/>
+        <body><![CDATA[
+          if (this.getAttribute("overflow") == "true")
+            this.arrowScrollbox.ensureElementIsVisible(this.selectedItem, aInstant);
+
+          this.selectedItem._notselectedsinceload = false;
+        ]]></body>
+      </method>
+
+      <field name="_closingTabsSpacer">
+        document.getAnonymousElementByAttribute(this, "anonid", "closing-tabs-spacer");
+      </field>
+
+      <field name="_tabDefaultMaxWidth">NaN</field>
+      <field name="_lastTabClosedByMouse">false</field>
+      <field name="_hasTabTempMaxWidth">false</field>
+
+      <!-- Try to keep the active tab's close button under the mouse cursor -->
+      <method name="_lockTabSizing">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          var tabs = this.tabbrowser.visibleTabs;
+          if (!tabs.length)
+            return;
+
+          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);
+          var tabWidth = aTab.getBoundingClientRect().width;
+
+          if (!this._tabDefaultMaxWidth)
+            this._tabDefaultMaxWidth =
+              parseFloat(window.getComputedStyle(aTab).maxWidth);
+          this._lastTabClosedByMouse = true;
+
+          if (this.getAttribute("overflow") == "true") {
+            // Don't need to do anything if we're in overflow mode and aren't scrolled
+            // all the way to the right, or if we're closing the last tab.
+            if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled)
+              return;
+
+            // If the tab has an owner that will become the active tab, the owner will
+            // be to the left of it, so we actually want the left tab to slide over.
+            // This can't be done as easily in non-overflow mode, so we don't bother.
+            if (aTab.owner)
+              return;
+
+            this._expandSpacerBy(tabWidth);
+          } else { // non-overflow mode
+            // Locking is neither in effect nor needed, so let tabs expand normally.
+            if (isEndTab && !this._hasTabTempMaxWidth)
+              return;
+
+            let numPinned = this.tabbrowser._numPinnedTabs;
+            // Force tabs to stay the same width, unless we're closing the last tab,
+            // which case we need to let them expand just enough so that the overall
+            // tabbar width is the same.
+            if (isEndTab) {
+              let numNormalTabs = tabs.length - numPinned;
+              tabWidth = tabWidth * (numNormalTabs + 1) / numNormalTabs;
+              if (tabWidth > this._tabDefaultMaxWidth)
+                tabWidth = this._tabDefaultMaxWidth;
+            }
+            tabWidth += "px";
+            for (let i = numPinned; i < tabs.length; i++) {
+              let tab = tabs[i];
+              tab.style.setProperty("max-width", tabWidth, "important");
+              if (!isEndTab) { // keep tabs the same width
+                tab.style.transition = "none";
+                tab.clientTop; // flush styles to skip animation; see bug 649247
+                tab.style.transition = "";
+              }
+            }
+            this._hasTabTempMaxWidth = true;
+            this.tabbrowser.addEventListener("mousemove", this);
+            window.addEventListener("mouseout", this);
+          }
+        ]]></body>
+      </method>
+
+      <method name="_expandSpacerBy">
+        <parameter name="pixels"/>
+        <body><![CDATA[
+          let spacer = this._closingTabsSpacer;
+          spacer.style.width = parseFloat(spacer.style.width) + pixels + "px";
+          this.setAttribute("using-closing-tabs-spacer", "true");
+          this.tabbrowser.addEventListener("mousemove", this);
+          window.addEventListener("mouseout", this);
+        ]]></body>
+      </method>
+
+      <method name="_unlockTabSizing">
+        <body><![CDATA[
+          this.tabbrowser.removeEventListener("mousemove", this);
+          window.removeEventListener("mouseout", this);
+
+          if (this._hasTabTempMaxWidth) {
+            this._hasTabTempMaxWidth = false;
+            let tabs = this.tabbrowser.visibleTabs;
+            for (let i = 0; i < tabs.length; i++)
+              tabs[i].style.maxWidth = "";
+          }
+
+          if (this.hasAttribute("using-closing-tabs-spacer")) {
+            this.removeAttribute("using-closing-tabs-spacer");
+            this._closingTabsSpacer.style.width = 0;
+          }
+        ]]></body>
+      </method>
+
+      <method name="uiDensityChanged">
+        <body><![CDATA[
+          this._positionPinnedTabs();
+          this._updateCloseButtons();
+          this._handleTabSelect(true);
+        ]]></body>
+      </method>
+
+      <field name="_lastNumPinned">0</field>
+      <field name="_pinnedTabsLayoutCache">null</field>
+      <method name="_positionPinnedTabs">
+        <body><![CDATA[
+          var numPinned = this.tabbrowser._numPinnedTabs;
+          var doPosition = this.getAttribute("overflow") == "true" &&
+                           numPinned > 0;
+
+          if (doPosition) {
+            this.setAttribute("positionpinnedtabs", "true");
+
+            let layoutData = this._pinnedTabsLayoutCache;
+            let uiDensity = document.documentElement.getAttribute("uidensity");
+            if (!layoutData ||
+                layoutData.uiDensity != uiDensity) {
+              let arrowScrollbox = this.arrowScrollbox;
+              layoutData = this._pinnedTabsLayoutCache = {
+                uiDensity,
+                pinnedTabWidth: this.childNodes[0].getBoundingClientRect().width,
+                scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width
+              };
+            }
+
+            let width = 0;
+            for (let i = numPinned - 1; i >= 0; i--) {
+              let tab = this.childNodes[i];
+              width += layoutData.pinnedTabWidth;
+              tab.style.marginInlineStart = -(width + layoutData.scrollButtonWidth) + "px";
+            }
+            this.style.paddingInlineStart = width + "px";
+          } else {
+            this.removeAttribute("positionpinnedtabs");
+
+            for (let i = 0; i < numPinned; i++) {
+              let tab = this.childNodes[i];
+              tab.style.marginInlineStart = "";
+            }
+
+            this.style.paddingInlineStart = "";
+          }
+
+          if (this._lastNumPinned != numPinned) {
+            this._lastNumPinned = numPinned;
+            this._handleTabSelect(true);
+          }
+        ]]></body>
+      </method>
+
+      <method name="_animateTabMove">
+        <parameter name="event"/>
+        <body><![CDATA[
+          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
+
+          if (this.getAttribute("movingtab") != "true") {
+            this.setAttribute("movingtab", "true");
+            this.parentNode.setAttribute("movingtab", "true");
+            this.selectedItem = draggedTab;
+          }
+
+          if (!("animLastScreenX" in draggedTab._dragData))
+            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;
+
+          let screenX = event.screenX;
+          if (screenX == draggedTab._dragData.animLastScreenX)
+            return;
+
+          draggedTab._dragData.animLastScreenX = screenX;
+
+          let rtl = (window.getComputedStyle(this).direction == "rtl");
+          let pinned = draggedTab.pinned;
+          let numPinned = this.tabbrowser._numPinnedTabs;
+          let tabs = this.tabbrowser.visibleTabs
+                                    .slice(pinned ? 0 : numPinned,
+                                           pinned ? numPinned : undefined);
+          if (rtl)
+            tabs.reverse();
+          let tabWidth = draggedTab.getBoundingClientRect().width;
+          draggedTab._dragData.tabWidth = tabWidth;
+
+          // Move the dragged tab based on the mouse position.
+
+          let leftTab = tabs[0];
+          let rightTab = tabs[tabs.length - 1];
+          let tabScreenX = draggedTab.boxObject.screenX;
+          let translateX = screenX - draggedTab._dragData.screenX;
+          if (!pinned)
+            translateX += this.arrowScrollbox._scrollbox.scrollLeft - draggedTab._dragData.scrollX;
+          let leftBound = leftTab.boxObject.screenX - tabScreenX;
+          let rightBound = (rightTab.boxObject.screenX + rightTab.boxObject.width) -
+                           (tabScreenX + tabWidth);
+          translateX = Math.max(translateX, leftBound);
+          translateX = Math.min(translateX, rightBound);
+          draggedTab.style.transform = "translateX(" + translateX + "px)";
+          draggedTab._dragData.translateX = translateX;
+
+          // Determine what tab we're dragging over.
+          // * Point of reference is the center of the dragged tab. If that
+          //   point touches a background tab, the dragged tab would take that
+          //   tab's position when dropped.
+          // * We're doing a binary search in order to reduce the amount of
+          //   tabs we need to check.
+
+          let tabCenter = tabScreenX + translateX + tabWidth / 2;
+          let newIndex = -1;
+          let oldIndex = "animDropIndex" in draggedTab._dragData ?
+                         draggedTab._dragData.animDropIndex : draggedTab._tPos;
+          let low = 0;
+          let high = tabs.length - 1;
+          while (low <= high) {
+            let mid = Math.floor((low + high) / 2);
+            if (tabs[mid] == draggedTab &&
+                ++mid > high)
+              break;
+            let boxObject = tabs[mid].boxObject;
+            screenX = boxObject.screenX + getTabShift(tabs[mid], oldIndex);
+            if (screenX > tabCenter) {
+              high = mid - 1;
+            } else if (screenX + boxObject.width < tabCenter) {
+              low = mid + 1;
+            } else {
+              newIndex = tabs[mid]._tPos;
+              break;
+            }
+          }
+          if (newIndex >= oldIndex)
+            newIndex++;
+          if (newIndex < 0 || newIndex == oldIndex)
+            return;
+          draggedTab._dragData.animDropIndex = newIndex;
+
+          // Shift background tabs to leave a gap where the dragged tab
+          // would currently be dropped.
+
+          for (let tab of tabs) {
+            if (tab != draggedTab) {
+              let shift = getTabShift(tab, newIndex);
+              tab.style.transform = shift ? "translateX(" + shift + "px)" : "";
+            }
+          }
+
+          function getTabShift(tab, dropIndex) {
+            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)
+              return rtl ? -tabWidth : tabWidth;
+            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)
+              return rtl ? tabWidth : -tabWidth;
+            return 0;
+          }
+        ]]></body>
+      </method>
+
+      <method name="_finishAnimateTabMove">
+        <body><![CDATA[
+          if (this.getAttribute("movingtab") != "true")
+            return;
+
+          for (let tab of this.tabbrowser.visibleTabs)
+            tab.style.transform = "";
+
+          this.removeAttribute("movingtab");
+          this.parentNode.removeAttribute("movingtab");
+
+          this._handleTabSelect();
+        ]]></body>
+      </method>
+
+      <method name="handleEvent">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          switch (aEvent.type) {
+            case "load":
+              this.updateVisibility();
+              TabsInTitlebar.init();
+              break;
+            case "resize":
+              if (aEvent.target != window)
+                break;
+
+              TabsInTitlebar.updateAppearance();
+              this._updateCloseButtons();
+              this._handleTabSelect(true);
+              this.updateSessionRestoreVisibility();
+              break;
+            case "mouseout":
+              // If the "related target" (the node to which the pointer went) is not
+              // a child of the current document, the mouse just left the window.
+              let relatedTarget = aEvent.relatedTarget;
+              if (relatedTarget && relatedTarget.ownerDocument == document)
+                break;
+            case "mousemove":
+              if (document.getElementById("tabContextMenu").state != "open")
+                this._unlockTabSizing();
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <field name="_animateElement">
+        this.arrowScrollbox._scrollButtonDown;
+      </field>
+
+      <method name="_notifyBackgroundTab">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          if (aTab.pinned || aTab.hidden)
+            return;
+
+          var scrollRect = this.arrowScrollbox.scrollClientRect;
+          var tab = aTab.getBoundingClientRect();
+
+          // DOMRect left/right properties are immutable.
+          tab = {left: tab.left, right: tab.right};
+
+          // Is the new tab already completely visible?
+          if (scrollRect.left <= tab.left && tab.right <= scrollRect.right)
+            return;
+
+          if (this.arrowScrollbox.smoothScroll) {
+            let selected = !this.selectedItem.pinned &&
+                           this.selectedItem.getBoundingClientRect();
+
+            // Can we make both the new tab and the selected tab completely visible?
+            if (!selected ||
+                Math.max(tab.right - selected.left, selected.right - tab.left) <=
+                  scrollRect.width) {
+              this.arrowScrollbox.ensureElementIsVisible(aTab);
+              return;
+            }
+
+            this.arrowScrollbox.scrollByPixels(this.arrowScrollbox._isRTLScrollbox ?
+                                                 selected.right - scrollRect.right :
+                                                 selected.left - scrollRect.left);
+          }
+
+          if (!this._animateElement.hasAttribute("highlight")) {
+            this._animateElement.setAttribute("highlight", "true");
+            setTimeout(function(ele) {
+              ele.removeAttribute("highlight");
+            }, 150, this._animateElement);
+          }
+        ]]></body>
+      </method>
+
+      <method name="_getDragTargetTab">
+        <parameter name="event"/>
+        <parameter name="isLink"/>
+        <body><![CDATA[
+          let tab = event.target.localName == "tab" ? event.target : null;
+          if (tab && isLink) {
+            let boxObject = tab.boxObject;
+            if (event.screenX < boxObject.screenX + boxObject.width * .25 ||
+                event.screenX > boxObject.screenX + boxObject.width * .75)
+              return null;
+          }
+          return tab;
+        ]]></body>
+      </method>
+
+      <method name="_getDropIndex">
+        <parameter name="event"/>
+        <parameter name="isLink"/>
+        <body><![CDATA[
+          var tabs = this.childNodes;
+          var tab = this._getDragTargetTab(event, isLink);
+          if (window.getComputedStyle(this).direction == "ltr") {
+            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
+              if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
+                return i;
+          } else {
+            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
+              if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
+                return i;
+          }
+          return tabs.length;
+        ]]></body>
+      </method>
+
+      <method name="_getDropEffectForTabDrag">
+        <parameter name="event"/>
+        <body><![CDATA[
+          var dt = event.dataTransfer;
+          if (dt.mozItemCount == 1) {
+            var types = dt.mozTypesAt(0);
+            // tabs are always added as the first type
+            if (types[0] == TAB_DROP_TYPE) {
+              let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+              if (sourceNode instanceof XULElement &&
+                  sourceNode.localName == "tab" &&
+                  sourceNode.ownerGlobal.isChromeWindow &&
+                  sourceNode.ownerDocument.documentElement.getAttribute("windowtype") == "navigator:browser" &&
+                  sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {
+                // Do not allow transfering a private tab to a non-private window
+                // and vice versa.
+                if (PrivateBrowsingUtils.isWindowPrivate(window) !=
+                    PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))
+                  return "none";
+
+                if (window.gMultiProcessBrowser !=
+                    sourceNode.ownerGlobal.gMultiProcessBrowser)
+                  return "none";
+
+                return dt.dropEffect == "copy" ? "copy" : "move";
+              }
+            }
+          }
+
+          if (browserDragAndDrop.canDropLink(event)) {
+            return "link";
+          }
+          return "none";
+        ]]></body>
+      </method>
+
+      <method name="_handleNewTab">
+        <parameter name="tab"/>
+        <body><![CDATA[
+          if (tab.parentNode != this)
+            return;
+          tab._fullyOpen = true;
+          this.tabbrowser.tabAnimationsInProgress--;
+
+          this._updateCloseButtons();
+
+          if (tab.getAttribute("selected") == "true") {
+            this._handleTabSelect();
+          } else if (!tab.hasAttribute("skipbackgroundnotify")) {
+            this._notifyBackgroundTab(tab);
+          }
+
+          // XXXmano: this is a temporary workaround for bug 345399
+          // We need to manually update the scroll buttons disabled state
+          // if a tab was inserted to the overflow area or removed from it
+          // without any scrolling and when the tabbar has already
+          // overflowed.
+          this.arrowScrollbox._updateScrollButtonsDisabledState();
+
+          // Preload the next about:newtab if there isn't one already.
+          this.tabbrowser._createPreloadBrowser();
+        ]]></body>
+      </method>
+
+      <method name="_canAdvanceToTab">
+        <parameter name="aTab"/>
+        <body>
+        <![CDATA[
+          return !aTab.closing;
+        ]]>
+        </body>
+      </method>
+
+      <method name="getRelatedElement">
+        <parameter name="aTab"/>
+        <body>
+        <![CDATA[
+          if (!aTab)
+            return null;
+          // If the tab's browser is lazy, we need to `_insertBrowser` in order
+          // to have a linkedPanel.  This will also serve to bind the browser
+          // and make it ready to use when the tab is selected.
+          this.tabbrowser._insertBrowser(aTab);
+          return document.getElementById(aTab.linkedPanel);
+        ]]>
+        </body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="TabSelect" action="this._handleTabSelect();"/>
+
+      <handler event="transitionend"><![CDATA[
+        if (event.propertyName != "max-width")
+          return;
+
+        var tab = event.target;
+
+        if (tab.getAttribute("fadein") == "true") {
+          if (tab._fullyOpen)
+            this._updateCloseButtons();
+          else
+            this._handleNewTab(tab);
+        } else if (tab.closing) {
+          this.tabbrowser._endRemoveTab(tab);
+        }
+      ]]></handler>
+
+      <handler event="dblclick"><![CDATA[
+        // When the tabbar has an unified appearance with the titlebar
+        // and menubar, a double-click in it should have the same behavior
+        // as double-clicking the titlebar
+        if (TabsInTitlebar.enabled || this.parentNode._dragBindingAlive)
+          return;
+
+        if (event.button != 0 ||
+            event.originalTarget.localName != "box")
+          return;
+
+        // See hack note in the tabbrowser-close-tab-button binding
+        if (!this._blockDblClick)
+          BrowserOpenTab();
+
+        event.preventDefault();
+      ]]></handler>
+
+      <handler event="click" button="0" phase="capturing"><![CDATA[
+        /* Catches extra clicks meant for the in-tab close button.
+         * Placed here to avoid leaking (a temporary handler added from the
+         * in-tab close button binding would close over the tab and leak it
+         * until the handler itself was removed). (bug 897751)
+         *
+         * The only sequence in which a second click event (i.e. dblclik)
+         * can be dispatched on an in-tab close button is when it is shown
+         * after the first click (i.e. the first click event was dispatched
+         * on the tab). This happens when we show the close button only on
+         * the active tab. (bug 352021)
+         * The only sequence in which a third click event can be dispatched
+         * on an in-tab close button is when the tab was opened with a
+         * double click on the tabbar. (bug 378344)
+         * In both cases, it is most likely that the close button area has
+         * been accidentally clicked, therefore we do not close the tab.
+         *
+         * We don't want to ignore processing of more than one click event,
+         * though, since the user might actually be repeatedly clicking to
+         * close many tabs at once.
+         */
+        let target = event.originalTarget;
+        if (target.classList.contains("tab-close-button")) {
+          // We preemptively set this to allow the closing-multiple-tabs-
+          // in-a-row case.
+          if (this._blockDblClick) {
+            target._ignoredCloseButtonClicks = true;
+          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {
+            target._ignoredCloseButtonClicks = true;
+            event.stopPropagation();
+            return;
+          } else {
+            // Reset the "ignored click" flag
+            target._ignoredCloseButtonClicks = false;
+          }
+        }
+
+        /* Protects from close-tab-button errant doubleclick:
+         * Since we're removing the event target, if the user
+         * double-clicks the button, the dblclick event will be dispatched
+         * with the tabbar as its event target (and explicit/originalTarget),
+         * which treats that as a mouse gesture for opening a new tab.
+         * In this context, we're manually blocking the dblclick event
+         * (see tabbrowser-close-tab-button dblclick handler).
+         */
+        if (this._blockDblClick) {
+          if (!("_clickedTabBarOnce" in this)) {
+            this._clickedTabBarOnce = true;
+            return;
+          }
+          delete this._clickedTabBarOnce;
+          this._blockDblClick = false;
+        }
+      ]]></handler>
+
+      <handler event="click"><![CDATA[
+        if (event.button != 1)
+          return;
+
+        if (event.target.localName == "tab") {
+          this.tabbrowser.removeTab(event.target, {animate: true,
+                byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE});
+        } else if (event.originalTarget.localName == "box") {
+          // The user middleclicked an open space on the tabstrip. This could
+          // be because they intend to open a new tab, but it could also be
+          // because they just removed a tab and they now middleclicked on the
+          // resulting space while that tab is closing. In that case, we don't
+          // want to open a tab. So if we're removing one or more tabs, and
+          // the tab click is before the end of the last visible tab, we do
+          // nothing.
+          if (this.tabbrowser._removingTabs.length) {
+            let visibleTabs = this.tabbrowser.visibleTabs;
+            let ltr = (window.getComputedStyle(this).direction == "ltr");
+            let lastTab = visibleTabs[visibleTabs.length - 1];
+            let endOfTab = lastTab.getBoundingClientRect()[ltr ? "right" : "left"];
+            if ((ltr && event.clientX > endOfTab) ||
+                (!ltr && event.clientX < endOfTab)) {
+              BrowserOpenTab();
+            }
+          } else {
+            BrowserOpenTab();
+          }
+        } else {
+          return;
+        }
+
+        event.stopPropagation();
+      ]]></handler>
+
+      <handler event="keydown" group="system"><![CDATA[
+        if (event.altKey || event.shiftKey)
+          return;
+
+        let wrongModifiers;
+        if (AppConstants.platform == "macosx") {
+          wrongModifiers = !event.metaKey;
+        } else {
+          wrongModifiers = !event.ctrlKey || event.metaKey;
+        }
+
+        if (wrongModifiers)
+          return;
+
+        // Don't check if the event was already consumed because tab navigation
+        // should work always for better user experience.
+
+        switch (event.keyCode) {
+          case KeyEvent.DOM_VK_UP:
+            this.tabbrowser.moveTabBackward();
+            break;
+          case KeyEvent.DOM_VK_DOWN:
+            this.tabbrowser.moveTabForward();
+            break;
+          case KeyEvent.DOM_VK_RIGHT:
+          case KeyEvent.DOM_VK_LEFT:
+            this.tabbrowser.moveTabOver(event);
+            break;
+          case KeyEvent.DOM_VK_HOME:
+            this.tabbrowser.moveTabToStart();
+            break;
+          case KeyEvent.DOM_VK_END:
+            this.tabbrowser.moveTabToEnd();
+            break;
+          default:
+            // Consume the keydown event for the above keyboard
+            // shortcuts only.
+            return;
+        }
+        event.preventDefault();
+      ]]></handler>
+
+      <handler event="dragstart"><![CDATA[
+        var tab = this._getDragTargetTab(event, false);
+        if (!tab || this._isCustomizing)
+          return;
+
+        let dt = event.dataTransfer;
+        dt.mozSetDataAt(TAB_DROP_TYPE, tab, 0);
+        let browser = tab.linkedBrowser;
+
+        // We must not set text/x-moz-url or text/plain data here,
+        // otherwise trying to deatch the tab by dropping it on the desktop
+        // may result in an "internet shortcut"
+        dt.mozSetDataAt("text/x-moz-text-internal", browser.currentURI.spec, 0);
+
+        // Set the cursor to an arrow during tab drags.
+        dt.mozCursor = "default";
+
+        // Set the tab as the source of the drag, which ensures we have a stable
+        // node to deliver the `dragend` event.  See bug 1345473.
+        dt.addElement(tab);
+
+        // Create a canvas to which we capture the current tab.
+        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired
+        // canvas size (in CSS pixels) to the window's backing resolution in order
+        // to get a full-resolution drag image for use on HiDPI displays.
+        let windowUtils = window.getInterface(Ci.nsIDOMWindowUtils);
+        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;
+        let canvas = this._dndCanvas;
+        if (!canvas) {
+          this._dndCanvas = canvas =
+            document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
+          canvas.style.width = "100%";
+          canvas.style.height = "100%";
+          canvas.mozOpaque = true;
+        }
+
+        canvas.width = 160 * scale;
+        canvas.height = 90 * scale;
+        let toDrag = canvas;
+        let dragImageOffset = -16;
+        if (gMultiProcessBrowser) {
+          var context = canvas.getContext("2d");
+          context.fillStyle = "white";
+          context.fillRect(0, 0, canvas.width, canvas.height);
+
+          let captureListener;
+          let platform = AppConstants.platform;
+          // On Windows and Mac we can update the drag image during a drag
+          // using updateDragImage. On Linux, we can use a panel.
+          if (platform == "win" || platform == "macosx") {
+            captureListener = function() {
+              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);
+            };
+          } else {
+            // Create a panel to use it in setDragImage
+            // which will tell xul to render a panel that follows
+            // the pointer while a dnd session is on.
+            if (!this._dndPanel) {
+              this._dndCanvas = canvas;
+              this._dndPanel = document.createElement("panel");
+              this._dndPanel.className = "dragfeedback-tab";
+              this._dndPanel.setAttribute("type", "drag");
+              let wrapper = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
+              wrapper.style.width = "160px";
+              wrapper.style.height = "90px";
+              wrapper.appendChild(canvas);
+              this._dndPanel.appendChild(wrapper);
+              document.documentElement.appendChild(this._dndPanel);
+            }
+            toDrag = this._dndPanel;
+          }
+          // PageThumb is async with e10s but that's fine
+          // since we can update the image during the dnd.
+          PageThumbs.captureToCanvas(browser, canvas, captureListener);
+        } else {
+          // For the non e10s case we can just use PageThumbs
+          // sync, so let's use the canvas for setDragImage.
+          PageThumbs.captureToCanvas(browser, canvas);
+          dragImageOffset = dragImageOffset * scale;
+        }
+        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);
+
+        // _dragData.offsetX/Y give the coordinates that the mouse should be
+        // positioned relative to the corner of the new window created upon
+        // dragend such that the mouse appears to have the same position
+        // relative to the corner of the dragged tab.
+        function clientX(ele) {
+          return ele.getBoundingClientRect().left;
+        }
+        let tabOffsetX = clientX(tab) - clientX(this);
+        tab._dragData = {
+          offsetX: event.screenX - window.screenX - tabOffsetX,
+          offsetY: event.screenY - window.screenY,
+          scrollX: this.arrowScrollbox._scrollbox.scrollLeft,
+          screenX: event.screenX
+        };
+
+        event.stopPropagation();
+      ]]></handler>
+
+      <handler event="dragover"><![CDATA[
+        var effects = this._getDropEffectForTabDrag(event);
+
+        var ind = this._tabDropIndicator;
+        if (effects == "" || effects == "none") {
+          ind.collapsed = true;
+          return;
+        }
+        event.preventDefault();
+        event.stopPropagation();
+
+        var arrowScrollbox = this.arrowScrollbox;
+        var ltr = (window.getComputedStyle(this).direction == "ltr");
+
+        // autoscroll the tab strip if we drag over the scroll
+        // buttons, even if we aren't dragging a tab, but then
+        // return to avoid drawing the drop indicator
+        var pixelsToScroll = 0;
+        if (this.getAttribute("overflow") == "true") {
+          var targetAnonid = event.originalTarget.getAttribute("anonid");
+          switch (targetAnonid) {
+            case "scrollbutton-up":
+              pixelsToScroll = arrowScrollbox.scrollIncrement * -1;
+              break;
+            case "scrollbutton-down":
+              pixelsToScroll = arrowScrollbox.scrollIncrement;
+              break;
+          }
+          if (pixelsToScroll)
+            arrowScrollbox.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll, true);
+        }
+
+        if (effects == "move" &&
+            this == event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0).parentNode) {
+          ind.collapsed = true;
+          this._animateTabMove(event);
+          return;
+        }
+
+        this._finishAnimateTabMove();
+
+        if (effects == "link") {
+          let tab = this._getDragTargetTab(event, true);
+          if (tab) {
+            if (!this._dragTime)
+              this._dragTime = Date.now();
+            if (Date.now() >= this._dragTime + this._dragOverDelay)
+              this.selectedItem = tab;
+            ind.collapsed = true;
+            return;
+          }
+        }
+
+        var rect = arrowScrollbox.getBoundingClientRect();
+        var newMargin;
+        if (pixelsToScroll) {
+          // if we are scrolling, put the drop indicator at the edge
+          // so that it doesn't jump while scrolling
+          let scrollRect = arrowScrollbox.scrollClientRect;
+          let minMargin = scrollRect.left - rect.left;
+          let maxMargin = Math.min(minMargin + scrollRect.width,
+                                   scrollRect.right);
+          if (!ltr)
+            [minMargin, maxMargin] = [this.clientWidth - maxMargin,
+                                      this.clientWidth - minMargin];
+          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
+        } else {
+          let newIndex = this._getDropIndex(event, effects == "link");
+          if (newIndex == this.childNodes.length) {
+            let tabRect = this.childNodes[newIndex - 1].getBoundingClientRect();
+            if (ltr)
+              newMargin = tabRect.right - rect.left;
+            else
+              newMargin = rect.right - tabRect.left;
+          } else {
+            let tabRect = this.childNodes[newIndex].getBoundingClientRect();
+            if (ltr)
+              newMargin = tabRect.left - rect.left;
+            else
+              newMargin = rect.right - tabRect.right;
+          }
+        }
+
+        ind.collapsed = false;
+
+        newMargin += ind.clientWidth / 2;
+        if (!ltr)
+          newMargin *= -1;
+
+        ind.style.transform = "translate(" + Math.round(newMargin) + "px)";
+        ind.style.marginInlineStart = (-ind.clientWidth) + "px";
+      ]]></handler>
+
+      <handler event="drop"><![CDATA[
+        var dt = event.dataTransfer;
+        var dropEffect = dt.dropEffect;
+        var draggedTab;
+        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move
+          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+          // not our drop then
+          if (!draggedTab)
+            return;
+        }
+
+        this._tabDropIndicator.collapsed = true;
+        event.stopPropagation();
+        if (draggedTab && dropEffect == "copy") {
+          // copy the dropped tab (wherever it's from)
+          let newIndex = this._getDropIndex(event, false);
+          let newTab = this.tabbrowser.duplicateTab(draggedTab);
+          this.tabbrowser.moveTabTo(newTab, newIndex);
+          if (draggedTab.parentNode != this || event.shiftKey)
+            this.selectedItem = newTab;
+        } else if (draggedTab && draggedTab.parentNode == this) {
+          let oldTranslateX = Math.round(draggedTab._dragData.translateX);
+          let tabWidth = Math.round(draggedTab._dragData.tabWidth);
+          let translateOffset = oldTranslateX % tabWidth;
+          let newTranslateX = oldTranslateX - translateOffset;
+          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {
+            newTranslateX += tabWidth;
+          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {
+            newTranslateX -= tabWidth;
+          }
+
+          let dropIndex = "animDropIndex" in draggedTab._dragData &&
+                          draggedTab._dragData.animDropIndex;
+          if (dropIndex && dropIndex > draggedTab._tPos)
+            dropIndex--;
+
+          let animate = this.tabbrowser.animationsEnabled;
+          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {
+            draggedTab.setAttribute("tabdrop-samewindow", "true");
+            draggedTab.style.transform = "translateX(" + newTranslateX + "px)";
+            let onTransitionEnd = transitionendEvent => {
+              if (transitionendEvent.propertyName != "transform" ||
+                  transitionendEvent.originalTarget != draggedTab) {
+                return;
+              }
+              draggedTab.removeEventListener("transitionend", onTransitionEnd);
+
+              draggedTab.removeAttribute("tabdrop-samewindow");
+
+              this._finishAnimateTabMove();
+              if (dropIndex !== false)
+                this.tabbrowser.moveTabTo(draggedTab, dropIndex);
+
+              this.tabbrowser.syncThrobberAnimations(draggedTab);
+            };
+            draggedTab.addEventListener("transitionend", onTransitionEnd);
+          } else {
+            this._finishAnimateTabMove();
+            if (dropIndex !== false)
+              this.tabbrowser.moveTabTo(draggedTab, dropIndex);
+          }
+        } else if (draggedTab) {
+          let newIndex = this._getDropIndex(event, false);
+          this.tabbrowser.adoptTab(draggedTab, newIndex, true);
+        } else {
+          // Pass true to disallow dropping javascript: or data: urls
+          let links;
+          try {
+            links = browserDragAndDrop.dropLinks(event, true);
+          } catch (ex) {}
+
+          if (!links || links.length === 0)
+            return;
+
+          let inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
+
+          if (event.shiftKey)
+            inBackground = !inBackground;
+
+          let targetTab = this._getDragTargetTab(event, true);
+          let userContextId = this.selectedItem.getAttribute("usercontextid");
+          let replace = !!targetTab;
+          let newIndex = this._getDropIndex(event, true);
+          let urls = links.map(link => link.url);
+
+          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);
+          this.tabbrowser.loadTabs(urls, {
+            inBackground,
+            replace,
+            allowThirdPartyFixup: true,
+            targetTab,
+            newIndex,
+            userContextId,
+            triggeringPrincipal,
+          });
+        }
+
+        if (draggedTab) {
+          delete draggedTab._dragData;
+        }
+      ]]></handler>
+
+      <handler event="dragend"><![CDATA[
+        var dt = event.dataTransfer;
+        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+
+        // Prevent this code from running if a tabdrop animation is
+        // running since calling _finishAnimateTabMove would clear
+        // any CSS transition that is running.
+        if (draggedTab.hasAttribute("tabdrop-samewindow"))
+          return;
+
+        this._finishAnimateTabMove();
+
+        if (dt.mozUserCancelled || dt.dropEffect != "none" || this._isCustomizing) {
+          delete draggedTab._dragData;
+          return;
+        }
+
+        // Disable detach within the browser toolbox
+        var eX = event.screenX;
+        var eY = event.screenY;
+        var wX = window.screenX;
+        // check if the drop point is horizontally within the window
+        if (eX > wX && eX < (wX + window.outerWidth)) {
+          let bo = this.arrowScrollbox.boxObject;
+          // also avoid detaching if the the tab was dropped too close to
+          // the tabbar (half a tab)
+          let endScreenY = bo.screenY + 1.5 * bo.height;
+          if (eY < endScreenY && eY > window.screenY)
+            return;
+        }
+
+        // screen.availLeft et. al. only check the screen that this window is on,
+        // but we want to look at the screen the tab is being dropped onto.
+        var screen = Cc["@mozilla.org/gfx/screenmanager;1"]
+                       .getService(Ci.nsIScreenManager)
+                       .screenForRect(eX, eY, 1, 1);
+        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};
+        var availX = {}, availY = {}, availWidth = {}, availHeight = {};
+        // get full screen rect and available rect, both in desktop pix
+        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);
+        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);
+
+        // scale factor to convert desktop pixels to CSS px
+        var scaleFactor =
+          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;
+        // synchronize CSS-px top-left coordinates with the screen's desktop-px
+        // coordinates, to ensure uniqueness across multiple screens
+        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()
+        // and related methods)
+        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;
+        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;
+        availWidth.value *= scaleFactor;
+        availHeight.value *= scaleFactor;
+
+        // ensure new window entirely within screen
+        var winWidth = Math.min(window.outerWidth, availWidth.value);
+        var winHeight = Math.min(window.outerHeight, availHeight.value);
+        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),
+                            availX.value + availWidth.value - winWidth);
+        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),
+                           availY.value + availHeight.value - winHeight);
+
+        delete draggedTab._dragData;
+
+        if (this.tabbrowser.tabs.length == 1) {
+          // resize _before_ move to ensure the window fits the new screen.  if
+          // the window is too large for its screen, the window manager may do
+          // automatic repositioning.
+          window.resizeTo(winWidth, winHeight);
+          window.moveTo(left, top);
+          window.focus();
+        } else {
+          let props = { screenX: left, screenY: top, suppressanimation: 1 };
+          if (AppConstants.platform != "win") {
+            props.outerWidth = winWidth;
+            props.outerHeight = winHeight;
+          }
+          this.tabbrowser.replaceTabWithWindow(draggedTab, props);
+        }
+        event.stopPropagation();
+      ]]></handler>
+
+      <handler event="dragexit"><![CDATA[
+        this._dragTime = 0;
+
+        // This does not work at all (see bug 458613)
+        var target = event.relatedTarget;
+        while (target && target != this)
+          target = target.parentNode;
+        if (target)
+          return;
+
+        this._tabDropIndicator.collapsed = true;
+        event.stopPropagation();
+      ]]></handler>
+    </handlers>
+  </binding>
+
+  <!-- close-tab-button binding
+       This binding relies on the structure of the tabbrowser binding.
+       Therefore it should only be used as a child of the tab or the tabs
+       element (in both cases, when they are anonymous nodes of <tabbrowser>).
+  -->
+  <binding id="tabbrowser-close-tab-button"
+           extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton">
+    <handlers>
+      <handler event="click" button="0"><![CDATA[
+        var bindingParent = document.getBindingParent(this);
+        var tabContainer = bindingParent.parentNode;
+        tabContainer.tabbrowser.removeTab(bindingParent, {animate: true,
+                byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE});
+        // This enables double-click protection for the tab container
+        // (see tabbrowser-tabs 'click' handler).
+        tabContainer._blockDblClick = true;
+      ]]></handler>
+
+      <handler event="dblclick" button="0" phase="capturing">
+        // for the one-close-button case
+        event.stopPropagation();
+      </handler>
+
+      <handler event="dragstart">
+        event.stopPropagation();
+      </handler>
+    </handlers>
+  </binding>
+
+  <binding id="tabbrowser-tab" display="xul:hbox"
+           extends="chrome://global/content/bindings/tabbox.xml#tab">
+    <resources>
+      <stylesheet src="chrome://browser/content/tabbrowser.css"/>
+    </resources>
+
+    <content context="tabContextMenu">
+      <xul:stack class="tab-stack" flex="1">
+        <xul:vbox xbl:inherits="selected=visuallyselected,fadein"
+                  class="tab-background">
+          <xul:hbox xbl:inherits="selected=visuallyselected"
+                    class="tab-line"/>
+          <xul:spacer flex="1"/>
+          <xul:hbox class="tab-bottom-line"/>
+        </xul:vbox>
+        <xul:hbox xbl:inherits="pinned,bursting,notselectedsinceload"
+                  anonid="tab-loading-burst"
+                  class="tab-loading-burst"/>
+        <xul:hbox xbl:inherits="pinned,selected=visuallyselected,titlechanged,attention"
+                  class="tab-content" align="center">
+          <xul:hbox xbl:inherits="fadein,pinned,busy,progress,selected=visuallyselected"
+                    anonid="tab-throbber"
+                    class="tab-throbber"
+                    layer="true"/>
+          <xul:image xbl:inherits="fadein,pinned,busy,progress,selected=visuallyselected"
+                     class="tab-throbber-fallback"
+                     role="presentation"
+                     layer="true"/>
+          <xul:image xbl:inherits="src=image,triggeringprincipal=iconloadingprincipal,requestcontextid,fadein,pinned,selected=visuallyselected,busy,crashed,sharing"
+                     anonid="tab-icon-image"
+                     class="tab-icon-image"
+                     validate="never"
+                     role="presentation"/>
+          <xul:image xbl:inherits="sharing,selected=visuallyselected,pinned"
+                     anonid="sharing-icon"
+                     class="tab-sharing-icon-overlay"
+                     role="presentation"/>
+          <xul:image xbl:inherits="crashed,busy,soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked"
+                     anonid="overlay-icon"
+                     class="tab-icon-overlay"
+                     role="presentation"/>
+          <xul:hbox class="tab-label-container"
+                    xbl:inherits="pinned,selected=visuallyselected,labeldirection"
+                    onoverflow="this.setAttribute('textoverflow', 'true');"
+                    onunderflow="this.removeAttribute('textoverflow');"
+                    flex="1">
+            <xul:label class="tab-text tab-label"
+                       xbl:inherits="xbl:text=label,accesskey,fadein,pinned,selected=visuallyselected,attention"
+                       role="presentation"/>
+          </xul:hbox>
+          <xul:image xbl:inherits="soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked"
+                     anonid="soundplaying-icon"
+                     class="tab-icon-sound"
+                     role="presentation"/>
+          <xul:toolbarbutton anonid="close-button"
+                             xbl:inherits="fadein,pinned,selected=visuallyselected"
+                             class="tab-close-button close-icon"/>
+        </xul:hbox>
+      </xul:stack>
+    </content>
+
+    <implementation>
+      <constructor><![CDATA[
+        if (!("_lastAccessed" in this)) {
+          this.updateLastAccessed();
+        }
+      ]]></constructor>
+
+      <property name="_visuallySelected">
+        <setter>
+          <![CDATA[
+          if (val)
+            this.setAttribute("visuallyselected", "true");
+          else
+            this.removeAttribute("visuallyselected");
+          this.parentNode.tabbrowser._tabAttrModified(this, ["visuallyselected"]);
+
+          this._setPositionAttributes(val);
+
+          return val;
+          ]]>
+        </setter>
+      </property>
+
+      <property name="_selected">
+        <setter>
+          <![CDATA[
+          // in e10s we want to only pseudo-select a tab before its rendering is done, so that
+          // the rest of the system knows that the tab is selected, but we don't want to update its
+          // visual status to selected until after we receive confirmation that its content has painted.
+          if (val)
+            this.setAttribute("selected", "true");
+          else
+            this.removeAttribute("selected");
+
+          // If we're non-e10s we should update the visual selection as well at the same time,
+          // *or* if we're e10s and the visually selected tab isn't changing, in which case the
+          // tab switcher code won't run and update anything else (like the before- and after-
+          // selected attributes).
+          if (!gMultiProcessBrowser || (val && this.hasAttribute("visuallyselected"))) {
+            this._visuallySelected = val;
+          }
+
+          return val;
+        ]]>
+        </setter>
+      </property>
+
+      <property name="pinned" readonly="true">
+        <getter>
+          return this.getAttribute("pinned") == "true";
+        </getter>
+      </property>
+      <property name="hidden" readonly="true">
+        <getter>
+          return this.getAttribute("hidden") == "true";
+        </getter>
+      </property>
+      <property name="muted" readonly="true">
+        <getter>
+          return this.getAttribute("muted") == "true";
+        </getter>
+      </property>
+      <!--
+      Describes how the tab ended up in this mute state. May be any of:
+
+       - undefined: The tabs mute state has never changed.
+       - null: The mute state was last changed through the UI.
+       - Any string: The ID was changed through an extension API. The string
+                     must be the ID of the extension which changed it.
+      -->
+      <field name="muteReason">undefined</field>
+
+      <property name="userContextId" readonly="true">
+        <getter>
+          return this.hasAttribute("usercontextid")
+                   ? parseInt(this.getAttribute("usercontextid"))
+                   : 0;
+        </getter>
+      </property>
+
+      <property name="soundPlaying" readonly="true">
+        <getter>
+          return this.getAttribute("soundplaying") == "true";
+        </getter>
+      </property>
+
+      <property name="activeMediaBlocked" readonly="true">
+        <getter>
+          return this.getAttribute("activemedia-blocked") == "true";
+        </getter>
+      </property>
+
+      <property name="lastAccessed">
+        <getter>
+          return this._lastAccessed == Infinity ? Date.now() : this._lastAccessed;
+        </getter>
+      </property>
+      <method name="updateLastAccessed">
+        <parameter name="aDate"/>
+        <body><![CDATA[
+          this._lastAccessed = this.selected ? Infinity : (aDate || Date.now());
+        ]]></body>
+      </method>
+
+      <field name="mOverCloseButton">false</field>
+      <property name="_overPlayingIcon" readonly="true">
+        <getter><![CDATA[
+          let iconVisible = this.hasAttribute("soundplaying") ||
+                            this.hasAttribute("muted") ||
+                            this.hasAttribute("activemedia-blocked");
+          let soundPlayingIcon =
+            document.getAnonymousElementByAttribute(this, "anonid", "soundplaying-icon");
+          let overlayIcon =
+            document.getAnonymousElementByAttribute(this, "anonid", "overlay-icon");
+
+          return soundPlayingIcon && soundPlayingIcon.matches(":hover") ||
+                 (overlayIcon && overlayIcon.matches(":hover") && iconVisible);
+        ]]></getter>
+      </property>
+      <field name="mCorrespondingMenuitem">null</field>
+
+      <!--
+      While it would make sense to track this in a field, the field will get nuked
+      once the node is gone from the DOM, which causes us to think the tab is not
+      closed, which causes us to make wrong decisions. So we use an expando instead.
+      <field name="closing">false</field>
+      -->
+
+      <method name="_mouseenter">
+        <body><![CDATA[
+          if (this.hidden || this.closing)
+            return;
+
+          let tabContainer = this.parentNode;
+          let visibleTabs = tabContainer.tabbrowser.visibleTabs;
+          let tabIndex = visibleTabs.indexOf(this);
+
+          if (this.selected)
+            tabContainer._handleTabSelect();
+
+          if (tabIndex == 0) {
+            tabContainer._beforeHoveredTab = null;
+          } else {
+            let candidate = visibleTabs[tabIndex - 1];
+            let separatedByScrollButton =
+              tabContainer.getAttribute("overflow") == "true" &&
+              candidate.pinned && !this.pinned;
+            if (!candidate.selected && !separatedByScrollButton) {
+              tabContainer._beforeHoveredTab = candidate;
+              candidate.setAttribute("beforehovered", "true");
+            }
+          }
+
+          if (tabIndex == visibleTabs.length - 1) {
+            tabContainer._afterHoveredTab = null;
+          } else {
+            let candidate = visibleTabs[tabIndex + 1];
+            if (!candidate.selected) {
+              tabContainer._afterHoveredTab = candidate;
+              candidate.setAttribute("afterhovered", "true");
+            }
+          }
+
+          tabContainer._hoveredTab = this;
+          if (this.linkedPanel && !this.selected) {
+            this.linkedBrowser.unselectedTabHover(true);
+            this.startUnselectedTabHoverTimer();
+          }
+
+          // Prepare connection to host beforehand.
+          SessionStore.speculativeConnectOnTabHover(this);
+          tabContainer.tabbrowser.warmupTab(this);
+        ]]></body>
+      </method>
+
+      <method name="_mouseleave">
+        <body><![CDATA[
+          let tabContainer = this.parentNode;
+          if (tabContainer._beforeHoveredTab) {
+            tabContainer._beforeHoveredTab.removeAttribute("beforehovered");
+            tabContainer._beforeHoveredTab = null;
+          }
+          if (tabContainer._afterHoveredTab) {
+            tabContainer._afterHoveredTab.removeAttribute("afterhovered");
+            tabContainer._afterHoveredTab = null;
+          }
+
+          tabContainer._hoveredTab = null;
+          if (this.linkedPanel && !this.selected) {
+            this.linkedBrowser.unselectedTabHover(false);
+            this.cancelUnselectedTabHoverTimer();
+          }
+        ]]></body>
+      </method>
+
+      <method name="startUnselectedTabHoverTimer">
+        <body><![CDATA[
+          // Only record data when we need to.
+          if (!this.linkedBrowser.shouldHandleUnselectedTabHover) {
+            return;
+          }
+
+          if (!TelemetryStopwatch.running("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this)) {
+            TelemetryStopwatch.start("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this);
+          }
+
+          if (this._hoverTabTimer) {
+            clearTimeout(this._hoverTabTimer);
+            this._hoverTabTimer = null;
+          }
+        ]]></body>
+      </method>
+
+      <method name="cancelUnselectedTabHoverTimer">
+        <body><![CDATA[
+          // Since we're listening "mouseout" event, instead of "mouseleave".
+          // Every time the cursor is moving from the tab to its child node (icon),
+          // it would dispatch "mouseout"(for tab) first and then dispatch
+          // "mouseover" (for icon, eg: close button, speaker icon) soon.
+          // It causes we would cancel present TelemetryStopwatch immediately
+          // when cursor is moving on the icon, and then start a new one.
+          // In order to avoid this situation, we could delay cancellation and
+          // remove it if we get "mouseover" within very short period.
+          this._hoverTabTimer = setTimeout(() => {
+            if (TelemetryStopwatch.running("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this)) {
+              TelemetryStopwatch.cancel("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this);
+            }
+          }, 100);
+        ]]></body>
+      </method>
+
+      <method name="finishUnselectedTabHoverTimer">
+        <body><![CDATA[
+          // Stop timer when the tab is opened.
+          if (TelemetryStopwatch.running("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this)) {
+            TelemetryStopwatch.finish("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this);
+          }
+        ]]></body>
+      </method>
+
+      <method name="startMediaBlockTimer">
+        <body><![CDATA[
+          TelemetryStopwatch.start("TAB_MEDIA_BLOCKING_TIME_MS", this);
+        ]]></body>
+      </method>
+
+       <method name="finishMediaBlockTimer">
+        <body><![CDATA[
+          TelemetryStopwatch.finish("TAB_MEDIA_BLOCKING_TIME_MS", this);
+        ]]></body>
+      </method>
+
+      <method name="toggleMuteAudio">
+        <parameter name="aMuteReason"/>
+        <body>
+        <![CDATA[
+          // Do not attempt to toggle mute state if browser is lazy.
+          if (!this.linkedPanel) {
+            return;
+          }
+
+          let tabContainer = this.parentNode;
+          let browser = this.linkedBrowser;
+          let modifiedAttrs = [];
+          let hist = Services.telemetry.getHistogramById("TAB_AUDIO_INDICATOR_USED");
+
+          if (this.hasAttribute("activemedia-blocked")) {
+            this.removeAttribute("activemedia-blocked");
+            modifiedAttrs.push("activemedia-blocked");
+
+            browser.resumeMedia();
+            hist.add(3 /* unblockByClickingIcon */);
+            this.finishMediaBlockTimer();
+          } else {
+            if (browser.audioMuted) {
+              browser.unmute();
+              this.removeAttribute("muted");
+              BrowserUITelemetry.countTabMutingEvent("unmute", aMuteReason);
+              hist.add(1 /* unmute */);
+            } else {
+              browser.mute();
+              this.setAttribute("muted", "true");
+              BrowserUITelemetry.countTabMutingEvent("mute", aMuteReason);
+              hist.add(0 /* mute */);
+            }
+            this.muteReason = aMuteReason || null;
+            modifiedAttrs.push("muted");
+          }
+          tabContainer.tabbrowser._tabAttrModified(this, modifiedAttrs);
+        ]]>
+        </body>
+      </method>
+
+      <method name="setUserContextId">
+        <parameter name="aUserContextId"/>
+        <body>
+        <![CDATA[
+          if (aUserContextId) {
+            if (this.linkedBrowser) {
+              this.linkedBrowser.setAttribute("usercontextid", aUserContextId);
+            }
+            this.setAttribute("usercontextid", aUserContextId);
+          } else {
+            if (this.linkedBrowser) {
+              this.linkedBrowser.removeAttribute("usercontextid");
+            }
+            this.removeAttribute("usercontextid");
+          }
+
+          ContextualIdentityService.setTabStyle(this);
+        ]]>
+        </body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="mouseover"><![CDATA[
+        let anonid = event.originalTarget.getAttribute("anonid");
+        if (anonid == "close-button")
+          this.mOverCloseButton = true;
+
+        this._mouseenter();
+      ]]></handler>
+      <handler event="mouseout"><![CDATA[
+        let anonid = event.originalTarget.getAttribute("anonid");
+        if (anonid == "close-button")
+          this.mOverCloseButton = false;
+
+        this._mouseleave();
+      ]]></handler>
+      <handler event="dragstart" phase="capturing">
+        this.style.MozUserFocus = "";
+      </handler>
+      <handler event="mousedown" phase="capturing">
+      <![CDATA[
+        if (this.selected) {
+          this.style.MozUserFocus = "ignore";
+        } else if (this.mOverCloseButton ||
+                   this._overPlayingIcon) {
+          // Prevent tabbox.xml from selecting the tab.
+          event.stopPropagation();
+        }
+      ]]>
+      </handler>
+      <handler event="mouseup">
+        this.style.MozUserFocus = "";
+      </handler>
+      <handler event="click">
+      <![CDATA[
+        if (event.button != 0) {
+          return;
+        }
+
+        if (this._overPlayingIcon) {
+          this.toggleMuteAudio();
+        }
+      ]]>
+      </handler>
+      <handler event="animationend">
+      <![CDATA[
+        let anonid = event.originalTarget.getAttribute("anonid");
+        if (anonid == "tab-loading-burst") {
+          this.removeAttribute("bursting");
+        }
+      ]]>
+      </handler>
+    </handlers>
+  </binding>
+
+  <binding id="tabbrowser-alltabs-popup"
+           extends="chrome://global/content/bindings/popup.xml#popup">
+    <implementation implements="nsIDOMEventListener">
+      <method name="_tabOnAttrModified">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          var tab = aEvent.target;
+          if (tab.mCorrespondingMenuitem)
+            this._setMenuitemAttributes(tab.mCorrespondingMenuitem, tab);
+        ]]></body>
+      </method>
+
+      <method name="_tabOnTabClose">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          var tab = aEvent.target;
+          if (tab.mCorrespondingMenuitem)
+            this.removeChild(tab.mCorrespondingMenuitem);
+        ]]></body>
+      </method>
+
+      <method name="handleEvent">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          switch (aEvent.type) {
+            case "TabAttrModified":
+              this._tabOnAttrModified(aEvent);
+              break;
+            case "TabClose":
+              this._tabOnTabClose(aEvent);
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <method name="_updateTabsVisibilityStatus">
+        <body><![CDATA[
+          var tabContainer = gBrowser.tabContainer;
+          // We don't want menu item decoration unless there is overflow.
+          if (tabContainer.getAttribute("overflow") != "true") {
+            return;
+          }
+
+          let windowUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                  .getInterface(Ci.nsIDOMWindowUtils);
+          let arrowScrollboxRect = windowUtils.getBoundsWithoutFlushing(tabContainer.arrowScrollbox);
+          for (let menuitem of this.childNodes) {
+            let curTab = menuitem.tab;
+            if (!curTab) {
+              // "Undo close tab", menuseparator, or entries put here by addons.
+              continue;
+            }
+            let curTabRect = windowUtils.getBoundsWithoutFlushing(curTab);
+            if (curTabRect.left >= arrowScrollboxRect.left &&
+                curTabRect.right <= arrowScrollboxRect.right) {
+              menuitem.setAttribute("tabIsVisible", "true");
+            } else {
+              menuitem.removeAttribute("tabIsVisible");
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="_createTabMenuItem">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          var menuItem = document.createElementNS(
+            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+            "menuitem");
+
+          menuItem.setAttribute("class", "menuitem-iconic alltabs-item menuitem-with-favicon");
+
+          this._setMenuitemAttributes(menuItem, aTab);
+
+          aTab.mCorrespondingMenuitem = menuItem;
+          menuItem.tab = aTab;
+
+          this.appendChild(menuItem);
+        ]]></body>
+      </method>
+
+      <method name="_setMenuitemAttributes">
+        <parameter name="aMenuitem"/>
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          aMenuitem.setAttribute("label", aTab.label);
+          aMenuitem.setAttribute("crop", "end");
+
+          if (aTab.hasAttribute("busy")) {
+            aMenuitem.setAttribute("busy", aTab.getAttribute("busy"));
+            aMenuitem.removeAttribute("iconloadingprincipal");
+            aMenuitem.removeAttribute("image");
+          } else {
+            aMenuitem.setAttribute("iconloadingprincipal", aTab.getAttribute("iconloadingprincipal"));
+            aMenuitem.setAttribute("image", aTab.getAttribute("image"));
+            aMenuitem.removeAttribute("busy");
+          }
+
+          if (aTab.hasAttribute("pending"))
+            aMenuitem.setAttribute("pending", aTab.getAttribute("pending"));
+          else
+            aMenuitem.removeAttribute("pending");
+
+          if (aTab.selected)
+            aMenuitem.setAttribute("selected", "true");
+          else
+            aMenuitem.removeAttribute("selected");
+
+          function addEndImage() {
+            let endImage = document.createElement("image");
+            endImage.setAttribute("class", "alltabs-endimage");
+            let endImageContainer = document.createElement("hbox");
+            endImageContainer.setAttribute("align", "center");
+            endImageContainer.setAttribute("pack", "center");
+            endImageContainer.appendChild(endImage);
+            aMenuitem.appendChild(endImageContainer);
+            return endImage;
+          }
+
+          if (aMenuitem.firstChild)
+            aMenuitem.firstChild.remove();
+          if (aTab.hasAttribute("muted"))
+            addEndImage().setAttribute("muted", "true");
+          else if (aTab.hasAttribute("soundplaying"))
+            addEndImage().setAttribute("soundplaying", "true");
+        ]]></body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="popupshowing">
+      <![CDATA[
+        if (event.target.getAttribute("id") == "alltabs_containersMenuTab") {
+          createUserContextMenu(event, {useAccessKeys: false});
+          return;
+        }
+
+        let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled");
+
+        if (event.target.getAttribute("anonid") == "newtab-popup" ||
+            event.target.id == "newtab-popup") {
+          createUserContextMenu(event, {
+            useAccessKeys: false,
+            showDefaultTab: Services.prefs.getIntPref("privacy.userContext.longPressBehavior") == 1
+          });
+        } else {
+          document.getElementById("alltabs-popup-separator-1").hidden = !containersEnabled;
+          let containersTab = document.getElementById("alltabs_containersTab");
+
+          containersTab.hidden = !containersEnabled;
+          if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+            containersTab.setAttribute("disabled", "true");
+          }
+
+          document.getElementById("alltabs_undoCloseTab").disabled =
+            SessionStore.getClosedTabCount(window) == 0;
+
+          var tabcontainer = gBrowser.tabContainer;
+
+          // Listen for changes in the tab bar.
+          tabcontainer.addEventListener("TabAttrModified", this);
+          tabcontainer.addEventListener("TabClose", this);
+
+          let tabs = gBrowser.visibleTabs;
+          for (var i = 0; i < tabs.length; i++) {
+            if (!tabs[i].pinned)
+              this._createTabMenuItem(tabs[i]);
+          }
+          this._updateTabsVisibilityStatus();
+        }
+      ]]></handler>
+
+      <handler event="popuphidden">
+      <![CDATA[
+        if (event.target.getAttribute("id") == "alltabs_containersMenuTab") {
+          return;
+        }
+
+        // clear out the menu popup and remove the listeners
+        for (let i = this.childNodes.length - 1; i > 0; i--) {
+          let menuItem = this.childNodes[i];
+          if (menuItem.tab) {
+            menuItem.tab.mCorrespondingMenuitem = null;
+            this.removeChild(menuItem);
+          }
+          if (menuItem.hasAttribute("usercontextid")) {
+            this.removeChild(menuItem);
+          }
+        }
+        var tabcontainer = gBrowser.tabContainer;
+        tabcontainer.removeEventListener("TabAttrModified", this);
+        tabcontainer.removeEventListener("TabClose", this);
+      ]]></handler>
+
+      <handler event="DOMMenuItemActive">
+      <![CDATA[
+        var tab = event.target.tab;
+        if (tab) {
+          let overLink = tab.linkedBrowser.currentURI.displaySpec;
+          if (overLink == "about:blank")
+            overLink = "";
+          XULBrowserWindow.setOverLink(overLink, null);
+        }
+      ]]></handler>
+
+      <handler event="DOMMenuItemInactive">
+      <![CDATA[
+        XULBrowserWindow.setOverLink("", null);
+      ]]></handler>
+
+      <handler event="command"><![CDATA[
+        if (event.target.tab) {
+          if (gBrowser.selectedTab != event.target.tab) {
+            gBrowser.selectedTab = event.target.tab;
+          } else {
+            gBrowser.tabContainer._handleTabSelect();
+          }
+        }
+      ]]></handler>
+
+    </handlers>
+  </binding>
+
+  <binding id="statuspanel" display="xul:hbox">
+    <content>
+      <xul:hbox class="statuspanel-inner">
+        <xul:label class="statuspanel-label"
+                   role="status"
+                   aria-live="off"
+                   xbl:inherits="value=label,crop,mirror"
+                   flex="1"
+                   crop="end"/>
+      </xul:hbox>
+    </content>
+
+    <implementation implements="nsIDOMEventListener">
+      <constructor><![CDATA[
+        window.addEventListener("resize", this);
+      ]]></constructor>
+
+      <destructor><![CDATA[
+        window.removeEventListener("resize", this);
+        MousePosTracker.removeListener(this);
+      ]]></destructor>
+
+      <property name="label">
+        <setter><![CDATA[
+          if (!this.label) {
+            this.removeAttribute("mirror");
+            this.removeAttribute("sizelimit");
+          }
+
+          if (this.getAttribute("type") == "status" &&
+              this.getAttribute("previoustype") == "status") {
+            // Before updating the label, set the panel's current width as its
+            // min-width to let the panel grow but not shrink and prevent
+            // unnecessary flicker while loading pages. We only care about the
+            // panel's width once it has been painted, so we can do this
+            // without flushing layout.
+            this.style.minWidth =
+              window.QueryInterface(Ci.nsIInterfaceRequestor)
+                    .getInterface(Ci.nsIDOMWindowUtils)
+                    .getBoundsWithoutFlushing(this).width + "px";
+          } else {
+            this.style.minWidth = "";
+          }
+
+          if (val) {
+            this.setAttribute("label", val);
+            this.removeAttribute("inactive");
+            this._mouseTargetRect = null;
+            MousePosTracker.addListener(this);
+          } else {
+            this.setAttribute("inactive", "true");
+            MousePosTracker.removeListener(this);
+          }
+
+          return val;
+        ]]></setter>
+        <getter>
+          return this.hasAttribute("inactive") ? "" : this.getAttribute("label");
+        </getter>
+      </property>
+
+      <method name="getMouseTargetRect">
+        <body><![CDATA[
+          if (!this._mouseTargetRect) {
+            this._calcMouseTargetRect();
+          }
+          return this._mouseTargetRect;
+        ]]></body>
+      </method>
+
+      <method name="onMouseEnter">
+        <body>
+          this._mirror();
+        </body>
+      </method>
+
+      <method name="onMouseLeave">
+        <body>
+          this._mirror();
+        </body>
+      </method>
+
+      <method name="handleEvent">
+        <parameter name="event"/>
+        <body><![CDATA[
+          if (!this.label)
+            return;
+
+          switch (event.type) {
+            case "resize":
+              this._mouseTargetRect = null;
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <method name="_calcMouseTargetRect">
+        <body><![CDATA[
+          let container = this.parentNode;
+          let alignRight = (getComputedStyle(container).direction == "rtl");
+          let panelRect = this.getBoundingClientRect();
+          let containerRect = container.getBoundingClientRect();
+
+          this._mouseTargetRect = {
+            top:    panelRect.top,
+            bottom: panelRect.bottom,
+            left:   alignRight ? containerRect.right - panelRect.width : containerRect.left,
+            right:  alignRight ? containerRect.right : containerRect.left + panelRect.width
+          };
+        ]]></body>
+      </method>
+
+      <method name="_mirror">
+        <body>
+          if (this.hasAttribute("mirror"))
+            this.removeAttribute("mirror");
+          else
+            this.setAttribute("mirror", "true");
+
+          if (!this.hasAttribute("sizelimit")) {
+            this.setAttribute("sizelimit", "true");
+            this._mouseTargetRect = null;
+          }
+        </body>
+      </method>
+    </implementation>
+  </binding>
+
+  <binding id="tabbrowser-tabpanels"
+           extends="chrome://global/content/bindings/tabbox.xml#tabpanels">
+    <implementation>
+      <field name="_selectedIndex">0</field>
+
+      <property name="selectedIndex">
+        <getter>
+        <![CDATA[
+          return this._selectedIndex;
+        ]]>
+        </getter>
+
+        <setter>
+        <![CDATA[
+          if (val < 0 || val >= this.childNodes.length)
+            return val;
+
+          let toTab = this.getRelatedElement(this.childNodes[val]);
+
+          gBrowser._getSwitcher().requestTab(toTab);
+
+          var panel = this._selectedPanel;
+          var newPanel = this.childNodes[val];
+          this._selectedPanel = newPanel;
+          if (this._selectedPanel != panel) {
+            var event = document.createEvent("Events");
+            event.initEvent("select", true, true);
+            this.dispatchEvent(event);
+
+            this._selectedIndex = val;
+          }
+
+          return val;
+        ]]>
+        </setter>
+      </property>
+    </implementation>
+  </binding>
+
+  <binding id="tabbrowser-browser"
+           extends="chrome://global/content/bindings/browser.xml#browser">
+    <implementation>
+      <field name="tabModalPromptBox">null</field>
+
+      <!-- throws exception for unknown schemes -->
+      <method name="loadURIWithFlags">
+        <parameter name="aURI"/>
+        <parameter name="aFlags"/>
+        <parameter name="aReferrerURI"/>
+        <parameter name="aCharset"/>
+        <parameter name="aPostData"/>
+        <body>
+          <![CDATA[
+            var params = arguments[1];
+            if (typeof(params) == "number") {
+              params = {
+                flags: aFlags,
+                referrerURI: aReferrerURI,
+                charset: aCharset,
+                postData: aPostData,
+              };
+            }
+            _loadURIWithFlags(this, aURI, params);
+          ]]>
+        </body>
+      </method>
+    </implementation>
+  </binding>
+
+  <binding id="tabbrowser-remote-browser"
+           extends="chrome://global/content/bindings/remote-browser.xml#remote-browser">
+    <implementation>
+      <field name="tabModalPromptBox">null</field>
+
+      <!-- throws exception for unknown schemes -->
+      <method name="loadURIWithFlags">
+        <parameter name="aURI"/>
+        <parameter name="aFlags"/>
+        <parameter name="aReferrerURI"/>
+        <parameter name="aCharset"/>
+        <parameter name="aPostData"/>
+        <body>
+          <![CDATA[
+            var params = arguments[1];
+            if (typeof(params) == "number") {
+              params = {
+                flags: aFlags,
+                referrerURI: aReferrerURI,
+                charset: aCharset,
+                postData: aPostData,
+              };
+            }
+            _loadURIWithFlags(this, aURI, params);
+          ]]>
+        </body>
+      </method>
+    </implementation>
+  </binding>
+
+</bindings>
diff --git a/browser/base/content/test/general/browser.ini.orig b/browser/base/content/test/general/browser.ini.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser.ini.orig
@@ -0,0 +1,614 @@
+###############################################################################
+# DO NOT ADD MORE TESTS HERE.                                                 #
+# TRY ONE OF THE MORE TOPICAL SIBLING DIRECTORIES.                            #
+# THIS DIRECTORY HAS 200+ TESTS AND TAKES AGES TO RUN ON A DEBUG BUILD.       #
+# PLEASE, FOR THE LOVE OF WHATEVER YOU HOLD DEAR, DO NOT ADD MORE TESTS HERE. #
+###############################################################################
+
+[DEFAULT]
+support-files =
+  POSTSearchEngine.xml
+  alltabslistener.html
+  app_bug575561.html
+  app_subframe_bug575561.html
+  audio.ogg
+  browser_bug479408_sample.html
+  browser_bug678392-1.html
+  browser_bug678392-2.html
+  browser_bug970746.xhtml
+  browser_registerProtocolHandler_notification.html
+  browser_star_hsts.sjs
+  browser_tab_dragdrop2_frame1.xul
+  browser_tab_dragdrop_embed.html
+  browser_web_channel.html
+  browser_web_channel_iframe.html
+  bug592338.html
+  bug792517-2.html
+  bug792517.html
+  bug792517.sjs
+  bug839103.css
+  clipboard_pastefile.html
+  contextmenu_common.js
+  ctxmenu-image.png
+  discovery.html
+  download_page.html
+  download_page_1.txt
+  download_page_2.txt
+  dummy_page.html
+  feed_tab.html
+  file_generic_favicon.ico
+  file_with_favicon.html
+  file_mediaPlayback.html
+  file_bug970276_popup1.html
+  file_bug970276_popup2.html
+  file_bug970276_favicon1.ico
+  file_bug970276_favicon2.ico
+  file_documentnavigation_frameset.html
+  file_double_close_tab.html
+  file_favicon_change.html
+  file_favicon_change_not_in_document.html
+  file_fullscreen-window-open.html
+  file_with_link_to_http.html
+  head.js
+  moz.png
+  navigating_window_with_download.html
+  offlineQuotaNotification.cacheManifest
+  offlineQuotaNotification.html
+  page_style_sample.html
+  pinning_headers.sjs
+  ssl_error_reports.sjs
+  print_postdata.sjs
+  searchSuggestionEngine.sjs
+  searchSuggestionEngine.xml
+  searchSuggestionEngine2.xml
+  subtst_contextmenu.html
+  subtst_contextmenu_input.html
+  subtst_contextmenu_xul.xul
+  test_bug462673.html
+  test_bug628179.html
+  test_bug839103.html
+  test_process_flags_chrome.html
+  title_test.svg
+  unknownContentType_file.pif
+  unknownContentType_file.pif^headers^
+  video.ogg
+  web_video.html
+  web_video1.ogv
+  web_video1.ogv^headers^
+  zoom_test.html
+  !/image/test/mochitest/blue.png
+  !/toolkit/content/tests/browser/common/mockTransfer.js
+  !/toolkit/modules/tests/browser/metadata_*.html
+  !/toolkit/mozapps/extensions/test/xpinstall/amosigned.xpi
+  !/toolkit/mozapps/extensions/test/xpinstall/corrupt.xpi
+  !/toolkit/mozapps/extensions/test/xpinstall/incompatible.xpi
+  !/toolkit/mozapps/extensions/test/xpinstall/installtrigger.html
+  !/toolkit/mozapps/extensions/test/xpinstall/redirect.sjs
+  !/toolkit/mozapps/extensions/test/xpinstall/restartless-unsigned.xpi
+  !/toolkit/mozapps/extensions/test/xpinstall/restartless.xpi
+  !/toolkit/mozapps/extensions/test/xpinstall/theme.xpi
+  !/toolkit/mozapps/extensions/test/xpinstall/slowinstall.sjs
+
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_addKeywordSearch.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_alltabslistener.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_audioTabIcon.js]
+tags = audiochannel
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_backButtonFitts.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_beforeunload_duplicate_dialogs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_blob-channelname.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bookmark_popup.js]
+skip-if = (os == "linux" && debug) # mouseover not reliable on linux debug builds
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bookmark_titles.js]
+skip-if = toolkit == "windows" # Disabled on Windows due to frequent failures (bugs 825739, 841341)
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug321000.js]
+subsuite = clipboard
+skip-if = true # browser_bug321000.js is disabled because newline handling is shaky (bug 592528)
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug356571.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug380960.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug386835.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug406216.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug408415.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug409624.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug413915.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug416661.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug417483.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug419612.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug423833.js]
+skip-if = true # bug 428712
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug424101.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug427559.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug431826.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug432599.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug435325.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug441778.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug455852.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug462289.js]
+skip-if = toolkit == "cocoa"
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug462673.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug477014.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug479408.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug481560.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug484315.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug491431.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug495058.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug519216.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug520538.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug521216.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug533232.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug537013.js]
+subsuite = clipboard
+skip-if = true # bug 1393813
+# skip-if = e10s # Bug 1134458 - Find bar doesn't work correctly in a detached tab
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug537474.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug550565.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug553455.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug555224.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug555767.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug559991.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug561636.js]
+skip-if = true # bug 1057615
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug563588.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug565575.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug567306.js]
+subsuite = clipboard
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug1261299.js]
+subsuite = clipboard
+skip-if = toolkit != "cocoa" # Because of tests for supporting Service Menu of macOS, bug 1261299
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug1297539.js]
+skip-if = toolkit != "cocoa" # Because of tests for supporting pasting from Service Menu of macOS, bug 1297539
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug575561.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug575830.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug577121.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug578534.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug579872.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug580638.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug580956.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug581242.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug581253.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug585785.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug585830.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug590206.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug592338.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug594131.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug595507.js]
+skip-if = true # bug 1057615
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug596687.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug597218.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug609700.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug623893.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug624734.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug633691.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug647886.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug655584.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug664672.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug676619.js]
+skip-if = os == "mac" # mac: Intermittent failures, bug 925225
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug678392.js]
+skip-if = os == "mac" # Bug 1102331 - does focus things on the content window which break in e10s mode (still causes orange on Mac 10.10)
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug710878.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug719271.js]
+skip-if = os == "win" && debug && e10s # Bug 1315042
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug724239.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug734076.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug735471.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug749738.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug763468_perwindowpb.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug767836_perwindowpb.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug817947.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug832435.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug839103.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug882977.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug970746.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug1015721.js]
+skip-if = os == 'win'
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_accesskeys.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_clipboard.js]
+subsuite = clipboard
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_clipboard_pastefile.js]
+skip-if = true # Disabled due to the clipboard not supporting real file types yet (bug 1288773)
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_compacttheme.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_contentAreaClick.js]
+skip-if = e10s # Clicks in content don't go through contentAreaClick with e10s.
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_contentAltClick.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_contextmenu.js]
+subsuite = clipboard
+tags = fullscreen
+skip-if = toolkit == "gtk2" || toolkit == "gtk3" # disabled on Linux due to bug 513558
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_contextmenu_input.js]
+skip-if = toolkit == "gtk2" || toolkit == "gtk3" # disabled on Linux due to bug 513558
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_ctrlTab.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_datachoices_notification.js]
+skip-if = !datareporting
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_decoderDoctor.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_search_discovery.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_double_close_tab.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_documentnavigation.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_duplicateIDs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_drag.js]
+skip-if = true # browser_drag.js is disabled, as it needs to be updated for the new behavior from bug 320638.
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_favicon_change.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_favicon_change_not_in_document.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_findbarClose.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_focusonkeydown.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_fullscreen-window-open.js]
+tags = fullscreen
+skip-if = os == "linux" # Linux: Intermittent failures - bug 941575.
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_gestureSupport.js]
+skip-if = e10s # Bug 863514 - no gesture support.
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_getshortcutoruri.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_hide_removing.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_homeDrop.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_invalid_uri_back_forward_manipulation.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_keywordBookmarklets.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_keywordSearch.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_keywordSearch_postData.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_lastAccessedTab.js]
+skip-if = toolkit == "windows" # Disabled on Windows due to frequent failures (bug 969405)
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_menuButtonFitts.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_middleMouse_noJSPaste.js]
+subsuite = clipboard
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_minimize.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_modifiedclick_inherit_principal.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_new_http_window_opened_from_file_tab.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_offlineQuotaNotification.js]
+skip-if = os == "linux" && !debug # bug 1304273
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_feed_discovery.js]
+support-files = feed_discovery.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_gZipOfflineChild.js]
+support-files = test_offline_gzip.html gZipOfflineChild.cacheManifest gZipOfflineChild.cacheManifest^headers^ gZipOfflineChild.html gZipOfflineChild.html^headers^
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_page_style_menu.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_page_style_menu_update.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_pinnedTabs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_plainTextLinks.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_printpreview.js]
+skip-if = os == 'win' # Bug 1384127
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_private_browsing_window.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_private_no_prompt.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_purgehistory_clears_sh.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_PageMetaData_pushstate.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_refreshBlocker.js]
+support-files =
+  refresh_header.sjs
+  refresh_meta.sjs
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_relatedTabs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_remoteTroubleshoot.js]
+skip-if = !updater
+reason = depends on UpdateUtils .Locale
+support-files =
+  test_remoteTroubleshoot.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_remoteWebNavigation_postdata.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_removeTabsToTheEnd.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_restore_isAppTab.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_sanitize-passwordDisabledHosts.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_sanitize-sitepermissions.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_sanitize-timespans.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_sanitizeDialog.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_save_link-perwindowpb.js]
+skip-if = e10s && debug && os == "win" # Bug 1280505
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_save_private_link_perwindowpb.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_save_link_when_window_navigates.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_save_video.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_save_video_frame.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_scope.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_contentSearchUI.js]
+support-files =
+  contentSearchUI.html
+  contentSearchUI.js
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_selectTabAtIndex.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_ssl_error_reports.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_star_hsts.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_storagePressure_notification.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_subframe_favicons_not_used.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tab_close_dependent_window.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabDrop.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabReorder.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tab_detach_restore.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tab_drag_drop_perwindow.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tab_dragdrop.js]
+skip-if = buildapp == 'mulet' || (e10s && debug) # Bug 1312436
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tab_dragdrop2.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabbar_big_widgets.js]
+skip-if = os == "linux" || os == "mac" # No tabs in titlebar on linux
+                                       # Disabled on OS X because of bug 967917
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabfocus.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabkeynavigation.js]
+skip-if = (os == "mac" && !e10s) # Bug 1237713 - OSX eats keypresses for some reason
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabs_close_beforeunload.js]
+support-files =
+  close_beforeunload_opens_second_tab.html
+  close_beforeunload.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabs_isActive.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_tabs_owner.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_testOpenNewRemoteTabsFromNonRemoteBrowsers.js]
+run-if = e10s
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_1.js]
+tags = trackingprotection
+support-files =
+  trackingPage.html
+  benignPage.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_2.js]
+tags = trackingprotection
+support-files =
+  trackingPage.html
+  benignPage.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_3.js]
+tags = trackingprotection
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_4.js]
+tags = trackingprotection
+support-files =
+  trackingPage.html
+  benignPage.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_5.js]
+tags = trackingprotection
+support-files =
+  trackingPage.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_6.js]
+tags = trackingprotection
+support-files =
+  file_trackingUI_6.html
+  file_trackingUI_6.js
+  file_trackingUI_6.js^headers^
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_trackingUI_telemetry.js]
+tags = trackingprotection
+support-files =
+  trackingPage.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_typeAheadFind.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_unknownContentType_title.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_unloaddialogs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_utilityOverlay.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_viewSourceInTabOnViewSource.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_visibleFindSelection.js]
+skip-if = true # Bug 1409184 disabled because interactive find next is not automating properly
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_visibleTabs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_visibleTabs_bookmarkAllPages.js]
+skip-if = true # Bug 1005420 - fails intermittently. also with e10s enabled: bizarre problem with hidden tab having _mouseenter called, via _setPositionalAttributes, and tab not being found resulting in 'candidate is undefined'
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_visibleTabs_bookmarkAllTabs.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_visibleTabs_contextMenu.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_visibleTabs_tabPreview.js]
+skip-if = (os == "win" && !debug)
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_web_channel.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_zbug569342.js]
+skip-if = e10s || debug # Bug 1094240 - has findbar-related failures
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_registerProtocolHandler_notification.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_addCertException.js]
+skip-if = true # When counting XBL this breaks for some reason
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_e10s_about_page_triggeringprincipal.js]
+support-files =
+  file_about_child.html
+  file_about_parent.html
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_e10s_switchbrowser.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_e10s_about_process.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_e10s_chrome_process.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_e10s_javascript.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_blockHPKP.js]
+tags = psm
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_windowactivation.js]
+support-files =
+  file_window_activation.html
+  file_window_activation2.html
+skip-if = stylo # bug 1390694
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_contextmenu_childprocess.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug963945.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_domFullscreen_fullscreenMode.js]
+tags = fullscreen
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_newTabDrop.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_newWindowDrop.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_newwindow_focus.js]
+skip-if = (os == "linux" && !e10s) # Bug 1263254 - Perma fails on Linux without e10s for some reason.
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_bug1299667.js]
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_close_dependent_tabs.js]
+skip-if = !e10s # GroupedSHistory is e10s-only
+# DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
diff --git a/browser/base/content/test/general/browser.ini.rej b/browser/base/content/test/general/browser.ini.rej
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser.ini.rej
@@ -0,0 +1,20 @@
+--- browser.ini
++++ browser.ini
+@@ -564,16 +564,17 @@ skip-if = (os == "win" && !debug)
+ [browser_web_channel.js]
+ # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+ [browser_zbug569342.js]
+ skip-if = e10s || debug # Bug 1094240 - has findbar-related failures
+ # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+ [browser_registerProtocolHandler_notification.js]
+ # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+ [browser_addCertException.js]
++skip-if = true # When counting XBL this breaks for some reason
+ # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+ [browser_e10s_about_page_triggeringprincipal.js]
+ support-files =
+   file_about_child.html
+   file_about_parent.html
+ # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+ [browser_e10s_switchbrowser.js]
+ # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
diff --git a/browser/base/content/test/general/browser_bug427559.js.orig b/browser/base/content/test/general/browser_bug427559.js.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser_bug427559.js.orig
@@ -0,0 +1,10 @@
+"use strict";
+
+const URL = `data:text/html,<script>class FirefoxStringbundle extends HTMLElement { connectedCallback() { this.innerHTML = "foo"; } disconnectedCallback() { }}customElements.define("firefox-stringbundle", FirefoxStringbundle);document.addEventListener("DOMContentLoaded", () => {document.documentElement.appendChild(document.createElement("firefox-stringbundle"));});</script>`;
+
+add_task(async function() {
+  ok(true);
+  let testTab = await BrowserTestUtils.openNewForegroundTab(gBrowser, URL);
+  gBrowser.removeCurrentTab();
+  // await new Promise(r=>r);
+});
diff --git a/browser/base/content/urlbarBindings.xml.orig b/browser/base/content/urlbarBindings.xml.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/content/urlbarBindings.xml.orig
@@ -0,0 +1,3009 @@
+<?xml version="1.0"?>
+
+<!--
+-*- Mode: HTML -*-
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!-- eslint-env mozilla/browser-window -->
+
+<!DOCTYPE bindings [
+<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
+%notificationDTD;
+<!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd">
+%browserDTD;
+<!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
+%brandDTD;
+]>
+
+<bindings id="urlbarBindings" xmlns="http://www.mozilla.org/xbl"
+          xmlns:html="http://www.w3.org/1999/xhtml"
+          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+          xmlns:xbl="http://www.mozilla.org/xbl">
+
+  <binding id="urlbar" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete">
+
+    <content sizetopopup="pref">
+      <xul:hbox anonid="textbox-container"
+                class="autocomplete-textbox-container urlbar-textbox-container"
+                flex="1" xbl:inherits="focused">
+        <children includes="image|deck|stack|box">
+          <xul:image class="autocomplete-icon" allowevents="true"/>
+        </children>
+        <xul:hbox anonid="textbox-input-box"
+                  class="textbox-input-box urlbar-input-box"
+                  flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
+          <children/>
+          <html:input anonid="input"
+                      class="autocomplete-textbox urlbar-input textbox-input"
+                      allowevents="true"
+                      inputmode="mozAwesomebar"
+                      xbl:inherits="tooltiptext=inputtooltiptext,value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow"/>
+        </xul:hbox>
+        <xul:image anonid="urlbar-go-button"
+                   class="urlbar-go-button urlbar-icon"
+                   onclick="gURLBar.handleCommand(event);"
+                   tooltiptext="&goEndCap.tooltip;"
+                   xbl:inherits="pageproxystate,parentfocused=focused,usertyping"/>
+        <xul:dropmarker anonid="historydropmarker"
+                        class="urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional"
+                        tooltiptext="&urlbar.openHistoryPopup.tooltip;"
+                        allowevents="true"
+                        xbl:inherits="open,parentfocused=focused,usertyping"/>
+        <children includes="hbox"/>
+      </xul:hbox>
+      <xul:popupset anonid="popupset"
+                    class="autocomplete-result-popupset"/>
+      <children includes="toolbarbutton"/>
+    </content>
+
+    <implementation implements="nsIObserver, nsIDOMEventListener">
+      <field name="ExtensionSearchHandler" readonly="true">
+        (Components.utils.import("resource://gre/modules/ExtensionSearchHandler.jsm", {})).ExtensionSearchHandler;
+      </field>
+
+      <constructor><![CDATA[
+        this._prefs = Components.classes["@mozilla.org/preferences-service;1"]
+                                .getService(Components.interfaces.nsIPrefService)
+                                .getBranch("browser.urlbar.");
+        this._prefs.addObserver("", this);
+
+        this._defaultPrefs = Components.classes["@mozilla.org/preferences-service;1"]
+                                       .getService(Components.interfaces.nsIPrefService)
+                                       .getDefaultBranch("browser.urlbar.");
+
+        Services.prefs.addObserver("browser.search.suggest.enabled", this);
+        this.browserSearchSuggestEnabled = Services.prefs.getBoolPref("browser.search.suggest.enabled");
+
+        this.clickSelectsAll = this._prefs.getBoolPref("clickSelectsAll");
+        this.doubleClickSelectsAll = this._prefs.getBoolPref("doubleClickSelectsAll");
+        this.completeDefaultIndex = this._prefs.getBoolPref("autoFill");
+        this.speculativeConnectEnabled = this._prefs.getBoolPref("speculativeConnect.enabled");
+        this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref("suggest.searches");
+        this.timeout = this._prefs.getIntPref("delay");
+        this._formattingEnabled = this._prefs.getBoolPref("formatting.enabled");
+        this._mayTrimURLs = this._prefs.getBoolPref("trimURLs");
+        this._adoptIntoActiveWindow = this._prefs.getBoolPref("switchTabs.adoptIntoActiveWindow");
+        this.inputField.controllers.insertControllerAt(0, this._copyCutController);
+        this.inputField.addEventListener("paste", this);
+        this.inputField.addEventListener("mousedown", this);
+        this.inputField.addEventListener("mousemove", this);
+        this.inputField.addEventListener("mouseout", this);
+        this.inputField.addEventListener("overflow", this);
+        this.inputField.addEventListener("underflow", this);
+
+        var textBox = document.getAnonymousElementByAttribute(this,
+                                                "anonid", "textbox-input-box");
+        var cxmenu = document.getAnonymousElementByAttribute(textBox,
+                                            "anonid", "input-box-contextmenu");
+        var pasteAndGo;
+        cxmenu.addEventListener("popupshowing", function() {
+          if (!pasteAndGo)
+            return;
+          var controller = document.commandDispatcher.getControllerForCommand("cmd_paste");
+          var enabled = controller.isCommandEnabled("cmd_paste");
+          if (enabled)
+            pasteAndGo.removeAttribute("disabled");
+          else
+            pasteAndGo.setAttribute("disabled", "true");
+        });
+
+        var insertLocation = cxmenu.firstChild;
+        while (insertLocation.nextSibling &&
+               insertLocation.getAttribute("cmd") != "cmd_paste")
+          insertLocation = insertLocation.nextSibling;
+        if (insertLocation) {
+          pasteAndGo = document.createElement("menuitem");
+          let label = Services.strings.createBundle("chrome://browser/locale/browser.properties").
+                                   GetStringFromName("pasteAndGo.label");
+          pasteAndGo.setAttribute("label", label);
+          pasteAndGo.setAttribute("anonid", "paste-and-go");
+          pasteAndGo.setAttribute("oncommand",
+              "gURLBar.select(); goDoCommand('cmd_paste'); gURLBar.handleCommand();");
+          cxmenu.insertBefore(pasteAndGo, insertLocation.nextSibling);
+        }
+
+        this.popup.addEventListener("popupshowing", () => {
+          this._enableOrDisableOneOffSearches();
+        }, {capturing: true, once: true});
+
+        // history dropmarker open state
+        this.popup.addEventListener("popupshowing", () => {
+          this.setAttribute("open", "true");
+        });
+        this.popup.addEventListener("popuphidden", () => {
+          requestAnimationFrame(() => {
+            this.removeAttribute("open");
+          });
+        });
+
+        // The autocomplete controller uses heuristic on some internal caches
+        // to handle cases like backspace, autofill or repeated searches.
+        // Ensure to clear those internal caches when switching tabs.
+        window.addEventListener("TabSelect", this);
+      ]]></constructor>
+
+      <destructor><![CDATA[
+        this._prefs.removeObserver("", this);
+        this._prefs = null;
+        Services.prefs.removeObserver("browser.search.suggest.enabled", this);
+        this.inputField.controllers.removeController(this._copyCutController);
+        this.inputField.removeEventListener("paste", this);
+        this.inputField.removeEventListener("mousedown", this);
+        this.inputField.removeEventListener("mousemove", this);
+        this.inputField.removeEventListener("mouseout", this);
+        this.inputField.removeEventListener("overflow", this);
+        this.inputField.removeEventListener("underflow", this);
+
+        if (this._deferredKeyEventTimeout) {
+          clearTimeout(this._deferredKeyEventTimeout);
+          this._deferredKeyEventTimeout = null;
+        }
+
+        // Null out the one-offs' popup and textbox so that it cleans up its
+        // internal state for both.  Most importantly, it removes the event
+        // listeners that it added to both.
+        this.popup.oneOffSearchButtons.popup = null;
+        this.popup.oneOffSearchButtons.textbox = null;
+      ]]></destructor>
+
+      <field name="goButton">
+        document.getAnonymousElementByAttribute(this, "anonid", "urlbar-go-button");
+      </field>
+
+      <field name="_value">""</field>
+      <field name="gotResultForCurrentQuery">false</field>
+
+      <!--
+        This is set around HandleHenter so it can be used in handleCommand.
+        It is also used to track whether we must handle a delayed handleEnter,
+        by checking if it has been cleared.
+      -->
+      <field name="handleEnterInstance">null</field>
+
+      <!--
+        For performance reasons we want to limit the size of the text runs we
+        build and show to the user.
+      -->
+      <field name="textRunsMaxLen">255</field>
+
+      <!--
+        Since we never want scrollbars, we always use the maxResults value.
+      -->
+      <property name="maxRows"
+                onget="return this.popup.maxResults;"/>
+
+      <!--
+        Set by focusAndSelectUrlBar to indicate whether the next focus event was
+        initiated by an explicit user action. See the "focus" handler below.
+      -->
+      <field name="userInitiatedFocus">false</field>
+
+      <!--
+        onBeforeValueGet is called by the base-binding's .value getter.
+        It can return an object with a "value" property, to override the
+        return value of the getter.
+      -->
+      <method name="onBeforeValueGet">
+        <body><![CDATA[
+          return { value: this._value };
+        ]]></body>
+      </method>
+
+      <!--
+        onBeforeValueSet is called by the base-binding's .value setter.
+        It should return the value that the setter should use.
+      -->
+      <method name="onBeforeValueSet">
+        <parameter name="aValue"/>
+        <body><![CDATA[
+          this._value = aValue;
+          var returnValue = aValue;
+          var action = this._parseActionUrl(aValue);
+
+          if (action) {
+            switch (action.type) {
+              case "switchtab": // Fall through.
+              case "remotetab": // Fall through.
+              case "visiturl": {
+                returnValue = action.params.displayUrl;
+                break;
+              }
+              case "keyword": // Fall through.
+              case "searchengine": {
+                returnValue = action.params.input;
+                break;
+              }
+              case "extension": {
+                returnValue = action.params.content;
+                break;
+              }
+            }
+          } else {
+            let originalUrl = ReaderMode.getOriginalUrlObjectForDisplay(aValue);
+            if (originalUrl) {
+              returnValue = originalUrl.displaySpec;
+            }
+          }
+
+          // Set the actiontype only if the user is not overriding actions.
+          if (action && this._pressedNoActionKeys.size == 0) {
+            this.setAttribute("actiontype", action.type);
+          } else {
+            this.removeAttribute("actiontype");
+          }
+          return returnValue;
+        ]]></body>
+      </method>
+
+      <method name="onKeyPress">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          switch (aEvent.keyCode) {
+            case KeyEvent.DOM_VK_LEFT:
+            case KeyEvent.DOM_VK_RIGHT:
+            case KeyEvent.DOM_VK_HOME:
+              // Reset the selected index so that nsAutoCompleteController
+              // simply closes the popup without trying to fill anything.
+              this.popup.selectedIndex = -1;
+              break;
+          }
+          if (!this.popup.disableKeyNavigation) {
+            if (this._keyCodesToDefer.has(aEvent.keyCode) &&
+                this._shouldDeferKeyEvent(aEvent)) {
+              this._deferKeyEvent(aEvent, "onKeyPress");
+              return false;
+            }
+            if (this.popup.popupOpen && this.popup.handleKeyPress(aEvent)) {
+              return true;
+            }
+          }
+          return this.handleKeyPress(aEvent);
+        ]]></body>
+      </method>
+
+      <!--
+        Search results arrive asynchronously, which means that keypresses may
+        arrive before results do and therefore not have the effect the user
+        intends.  That's especially likely to happen with the down arrow and
+        enter keys due to the one-off search buttons: if the user very quickly
+        pastes something in the input, presses the down arrow key, and then hits
+        enter, they are probably expecting to visit the first result.  But if
+        there are no results, then pressing down and enter will trigger the
+        first one-off button.  To prevent that undesirable behavior, certain
+        keys are buffered and deferred until more results arrive, at which time
+        they're replayed.
+
+        @param event
+               The key event that should maybe be deferred.  You can pass null
+               or undefined if you don't have one to see whether the next key
+               event in general should be deferred.
+        @return True if the event should be deferred, false if not.
+       -->
+      <method name="_shouldDeferKeyEvent">
+        <parameter name="event"/>
+        <body><![CDATA[
+          let waitedLongEnough =
+            this._searchStartDate + this._deferredKeyEventTimeoutMs < Date.now();
+          if (waitedLongEnough && !this._deferredKeyEventTimeout) {
+            return false;
+          }
+          if (event && event.keyCode == KeyEvent.DOM_VK_TAB && !this.popupOpen) {
+            // In this case, the popup is closed and the user pressed the Tab
+            // key.  The focus should move out of the urlbar immediately.
+            return false;
+          }
+          if (!this.gotResultForCurrentQuery || !this.popupOpen) {
+            return true;
+          }
+          let maxResultsRemaining =
+            this.popup.maxResults - this.popup._matchCount;
+          let lastResultSelected =
+            this.popup.selectedIndex + 1 == this.popup._matchCount;
+          return maxResultsRemaining > 0 && lastResultSelected;
+        ]]></body>
+      </method>
+
+      <!--
+        Adds a key event to the deferred event queue.
+
+        @param event
+               The key event to defer.
+        @param methodName
+               The name of the method on `this` to call.  It's expected to take
+               a single argument, the event.
+      -->
+      <method name="_deferKeyEvent">
+        <parameter name="event"/>
+        <parameter name="methodName"/>
+        <body><![CDATA[
+          // Somehow event.defaultPrevented ends up true for deferred events.
+          // autocomplete ignores defaultPrevented events, which means it would
+          // ignore replayed deferred events if we didn't tell it to bypass
+          // defaultPrevented.  That's the purpose of this expando.  If we could
+          // figure out what's setting defaultPrevented and prevent it, then we
+          // could get rid of this.
+          event.urlbarDeferred = true;
+
+          this._deferredKeyEventQueue.push({
+            methodName,
+            event,
+            searchString: this.mController.searchString,
+          });
+
+          if (!this._deferredKeyEventTimeout) {
+            this._deferredKeyEventTimeout = setTimeout(() => {
+              this._deferredKeyEventTimeout = null;
+              this.maybeReplayDeferredKeyEvents();
+            }, this._deferredKeyEventTimeoutMs);
+          }
+        ]]></body>
+      </method>
+
+      <!-- The enter key is always deferred, so it's not included here. -->
+      <field name="_keyCodesToDefer">new Set([
+        Ci.nsIDOMKeyEvent.DOM_VK_DOWN,
+        Ci.nsIDOMKeyEvent.DOM_VK_TAB,
+      ])</field>
+      <field name="_deferredKeyEventQueue">[]</field>
+      <field name="_deferredKeyEventTimeout">null</field>
+      <field name="_deferredKeyEventTimeoutMs">200</field>
+      <field name="_searchStartDate">0</field>
+
+      <method name="maybeReplayDeferredKeyEvents">
+        <body><![CDATA[
+          if (!this._deferredKeyEventQueue.length ||
+              this._shouldDeferKeyEvent()) {
+            return;
+          }
+          if (this._deferredKeyEventTimeout) {
+            clearTimeout(this._deferredKeyEventTimeout);
+            this._deferredKeyEventTimeout = null;
+          }
+          let instance = this._deferredKeyEventQueue.shift();
+          // Safety check: handle only if the search string didn't change.
+          if (this.mController.searchString == instance.searchString) {
+            this[instance.methodName](instance.event);
+          }
+          setTimeout(() => {
+            this.maybeReplayDeferredKeyEvents();
+          });
+        ]]></body>
+      </method>
+
+      <field name="_mayTrimURLs">true</field>
+      <method name="trimValue">
+        <parameter name="aURL"/>
+        <body><![CDATA[
+          // This method must not modify the given URL such that calling
+          // nsIURIFixup::createFixupURI with the result will produce a different URI.
+          return this._mayTrimURLs ? trimURL(aURL) : aURL;
+        ]]></body>
+      </method>
+
+      <field name="_formattingEnabled">true</field>
+      <method name="formatValue">
+        <body><![CDATA[
+          if (!this._formattingEnabled || !this.editor)
+            return;
+
+          let controller = this.editor.selectionController;
+          let strikeOut = controller.getSelection(controller.SELECTION_URLSTRIKEOUT);
+          strikeOut.removeAllRanges();
+
+          let selection = controller.getSelection(controller.SELECTION_URLSECONDARY);
+          selection.removeAllRanges();
+
+          if (this.focused)
+            return;
+
+          let textNode = this.editor.rootElement.firstChild;
+          let value = textNode.textContent;
+          if (!value)
+            return;
+
+          // Get the URL from the fixup service:
+          let flags = Services.uriFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS |
+                      Services.uriFixup.FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;
+          let uriInfo;
+          try {
+            uriInfo = Services.uriFixup.getFixupURIInfo(value, flags);
+          } catch (ex) {}
+          // Ignore if we couldn't make a URI out of this, the URI resulted in a search,
+          // or the URI has a non-http(s)/ftp protocol.
+          if (!uriInfo ||
+              !uriInfo.fixedURI ||
+              uriInfo.keywordProviderName ||
+              ["http", "https", "ftp"].indexOf(uriInfo.fixedURI.scheme) == -1) {
+            return;
+          }
+
+          // If we trimmed off the http scheme, ensure we stick it back on before
+          // trying to figure out what domain we're accessing, so we don't get
+          // confused by user:pass@host http URLs. We later use
+          // trimmedLength to ensure we don't count the length of a trimmed protocol
+          // when determining which parts of the URL to highlight as "preDomain".
+          let trimmedLength = 0;
+          if (uriInfo.fixedURI.scheme == "http" && !value.startsWith("http://")) {
+            value = "http://" + value;
+            trimmedLength = "http://".length;
+          }
+
+          let matchedURL = value.match(/^((?:[a-z]+:\/\/)(?:[^\/#?]+@)?)(\S+?)(?::\d+)?\s*(?:[\/#?]|$)/);
+          if (!matchedURL)
+            return;
+
+          // Strike out the "https" part if mixed active content is loaded.
+          if (this.getAttribute("pageproxystate") == "valid" &&
+              value.startsWith("https:") &&
+              gBrowser.securityUI.state &
+                Ci.nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT) {
+            let range = document.createRange();
+            range.setStart(textNode, 0);
+            range.setEnd(textNode, 5);
+            strikeOut.addRange(range);
+          }
+
+          let [, preDomain, domain] = matchedURL;
+          let baseDomain = domain;
+          let subDomain = "";
+          try {
+            baseDomain = Services.eTLD.getBaseDomainFromHost(uriInfo.fixedURI.host);
+            if (!domain.endsWith(baseDomain)) {
+              // getBaseDomainFromHost converts its resultant to ACE.
+              let IDNService = Cc["@mozilla.org/network/idn-service;1"]
+                               .getService(Ci.nsIIDNService);
+              baseDomain = IDNService.convertACEtoUTF8(baseDomain);
+            }
+          } catch (e) {}
+          if (baseDomain != domain) {
+            subDomain = domain.slice(0, -baseDomain.length);
+          }
+
+          let rangeLength = preDomain.length + subDomain.length - trimmedLength;
+          if (rangeLength) {
+            let range = document.createRange();
+            range.setStart(textNode, 0);
+            range.setEnd(textNode, rangeLength);
+            selection.addRange(range);
+          }
+
+          let startRest = preDomain.length + domain.length - trimmedLength;
+          if (startRest < value.length - trimmedLength) {
+            let range = document.createRange();
+            range.setStart(textNode, startRest);
+            range.setEnd(textNode, value.length - trimmedLength);
+            selection.addRange(range);
+          }
+        ]]></body>
+      </method>
+
+      <method name="handleRevert">
+        <body><![CDATA[
+          var isScrolling = this.popupOpen;
+
+          gBrowser.userTypedValue = null;
+
+          // don't revert to last valid url unless page is NOT loading
+          // and user is NOT key-scrolling through autocomplete list
+          if (!XULBrowserWindow.isBusy && !isScrolling) {
+            URLBarSetURI();
+
+            // If the value isn't empty and the urlbar has focus, select the value.
+            if (this.value && this.hasAttribute("focused"))
+              this.select();
+          }
+
+          // tell widget to revert to last typed text only if the user
+          // was scrolling when they hit escape
+          return !isScrolling;
+        ]]></body>
+      </method>
+
+      <!--
+        This is ultimately called by the autocomplete controller as the result
+        of handleEnter when the Return key is pressed in the textbox.  Since
+        onPopupClick also calls handleEnter, this is also called as a result in
+        that case.
+
+        @param event
+               The event that triggered the command.
+        @param openUILinkWhere
+               Optional.  The "where" to pass to openUILinkIn.  This method
+               computes the appropriate "where" given the event, but you can
+               use this to override it.
+        @param openUILinkParams
+               Optional.  The parameters to pass to openUILinkIn.  As with
+               "where", this method computes the appropriate parameters, but
+               any parameters you supply here will override those.
+      -->
+      <method name="handleCommand">
+        <parameter name="event"/>
+        <parameter name="openUILinkWhere"/>
+        <parameter name="openUILinkParams"/>
+        <body><![CDATA[
+          let isMouseEvent = event instanceof MouseEvent;
+          if (isMouseEvent && event.button == 2) {
+            // Do nothing for right clicks.
+            return;
+          }
+
+          BrowserUsageTelemetry.recordUrlbarSelectedResultMethod(event);
+
+          // Determine whether to use the selected one-off search button.  In
+          // one-off search buttons parlance, "selected" means that the button
+          // has been navigated to via the keyboard.  So we want to use it if
+          // the triggering event is not a mouse click -- i.e., it's a Return
+          // key -- or if the one-off was mouse-clicked.
+          let selectedOneOff = this.popup.oneOffSearchButtons.selectedButton;
+          if (selectedOneOff &&
+              isMouseEvent &&
+              event.originalTarget != selectedOneOff) {
+            selectedOneOff = null;
+          }
+
+          // Do the command of the selected one-off if it's not an engine.
+          if (selectedOneOff && !selectedOneOff.engine) {
+            selectedOneOff.doCommand();
+            return;
+          }
+
+          let where = openUILinkWhere;
+          if (!where) {
+            if (isMouseEvent) {
+              where = whereToOpenLink(event, false, false);
+            } else {
+              // If the current tab is empty, ignore Alt+Enter (reuse this tab)
+              let altEnter = !isMouseEvent &&
+                             event &&
+                             event.altKey &&
+                             !isTabEmpty(gBrowser.selectedTab);
+              where = altEnter ? "tab" : "current";
+            }
+          }
+
+          let url = this.value;
+          if (!url) {
+            return;
+          }
+
+          let mayInheritPrincipal = false;
+          let postData = null;
+          let browser = gBrowser.selectedBrowser;
+          let action = this._parseActionUrl(url);
+
+          if (selectedOneOff && selectedOneOff.engine) {
+            // If there's a selected one-off button then load a search using
+            // the one-off's engine.
+            [url, postData] =
+              this._parseAndRecordSearchEngineLoad(selectedOneOff.engine,
+                                                   this.oneOffSearchQuery,
+                                                   event, where,
+                                                   openUILinkParams);
+          } else if (action) {
+            switch (action.type) {
+              case "visiturl":
+                // Unifiedcomplete uses fixupURI to tell if something is a visit
+                // or a search, and passes out the fixedURI as the url param.
+                // By using that uri we would end up passing a different string
+                // to the docshell that may run a different not-found heuristic.
+                // For example, "mozilla/run" would be fixed by unifiedcomplete
+                // to "http://mozilla/run". The docshell, once it can't resolve
+                // mozilla, would note the string has a scheme, and try to load
+                // http://mozilla.com/run instead of searching "mozilla/run".
+                // So, if we have the original input at hand, we pass it through
+                // and let the docshell handle it.
+                if (action.params.input) {
+                  url = action.params.input;
+                  break;
+                }
+                url = action.params.url;
+                break;
+              case "remotetab":
+                url = action.params.url;
+                break;
+              case "keyword":
+                if (action.params.postData) {
+                  postData = getPostDataStream(action.params.postData);
+                }
+                mayInheritPrincipal = true;
+                url = action.params.url;
+                break;
+              case "switchtab":
+                url = action.params.url;
+                if (this.hasAttribute("actiontype")) {
+                  this.handleRevert();
+                  let prevTab = gBrowser.selectedTab;
+                  let loadOpts = {
+                    adoptIntoActiveWindow: this._adoptIntoActiveWindow,
+                  };
+
+                  if (switchToTabHavingURI(url, false, loadOpts) &&
+                      isTabEmpty(prevTab)) {
+                    gBrowser.removeTab(prevTab);
+                  }
+                  return;
+                }
+                break;
+              case "searchengine":
+                if (selectedOneOff && selectedOneOff.engine) {
+                  // Replace the engine with the selected one-off engine.
+                  action.params.engineName = selectedOneOff.engine.name;
+                }
+                const actionDetails = {
+                  isSuggestion: !!action.params.searchSuggestion,
+                  isAlias: !!action.params.alias
+                };
+                [url, postData] = this._parseAndRecordSearchEngineLoad(
+                  action.params.engineName,
+                  action.params.searchSuggestion || action.params.searchQuery,
+                  event,
+                  where,
+                  openUILinkParams,
+                  actionDetails
+                );
+                break;
+              case "extension":
+                this.handleRevert();
+                // Give the extension control of handling the command.
+                let searchString = action.params.content;
+                let keyword = action.params.keyword;
+                this.ExtensionSearchHandler.handleInputEntered(keyword, searchString, where);
+                return;
+            }
+          } else {
+            // This is a fallback for add-ons and old testing code that directly
+            // set value and try to confirm it. UnifiedComplete should always
+            // resolve to a valid url.
+            try {
+              new URL(url);
+            } catch (ex) {
+              let lastLocationChange = browser.lastLocationChange;
+              getShortcutOrURIAndPostData(url).then(data => {
+                if (where != "current" ||
+                    browser.lastLocationChange == lastLocationChange) {
+                  this._loadURL(data.url, browser, data.postData, where,
+                                openUILinkParams, data.mayInheritPrincipal);
+                }
+              });
+              return;
+            }
+          }
+
+          this._loadURL(url, browser, postData, where, openUILinkParams,
+                        mayInheritPrincipal);
+        ]]></body>
+      </method>
+
+      <property name="oneOffSearchQuery">
+        <getter><![CDATA[
+          // If the user has selected a search suggestion, chances are they
+          // want to use the one off search engine to search for that suggestion,
+          // not the string that they manually entered into the location bar.
+          let action = this._parseActionUrl(this.value);
+          if (action && action.type == "searchengine") {
+            return action.params.input;
+          }
+          // this.textValue may be an autofilled string.  Search only with the
+          // portion that the user typed, if any, by preferring the autocomplete
+          // controller's searchString (including handleEnterInstance.searchString).
+          return this.handleEnterSearchString ||
+                 this.mController.searchString ||
+                 this.textValue;
+        ]]></getter>
+      </property>
+
+      <method name="_loadURL">
+        <parameter name="url"/>
+        <parameter name="browser"/>
+        <parameter name="postData"/>
+        <parameter name="openUILinkWhere"/>
+        <parameter name="openUILinkParams"/>
+        <parameter name="mayInheritPrincipal"/>
+        <body><![CDATA[
+          this.value = url;
+          browser.userTypedValue = url;
+          if (gInitialPages.includes(url)) {
+            browser.initialPageLoadedFromURLBar = url;
+          }
+          try {
+            addToUrlbarHistory(url);
+          } catch (ex) {
+            // Things may go wrong when adding url to session history,
+            // but don't let that interfere with the loading of the url.
+            Cu.reportError(ex);
+          }
+
+          let params = {
+            postData,
+            allowThirdPartyFixup: true,
+          };
+          if (openUILinkWhere == "current") {
+            params.targetBrowser = browser;
+            params.indicateErrorPageLoad = true;
+            params.allowPinnedTabHostChange = true;
+            params.disallowInheritPrincipal = !mayInheritPrincipal;
+            params.allowPopups = url.startsWith("javascript:");
+          } else {
+            params.initiatingDoc = document;
+          }
+
+          if (openUILinkParams) {
+            for (let key in openUILinkParams) {
+              params[key] = openUILinkParams[key];
+            }
+          }
+
+          // Focus the content area before triggering loads, since if the load
+          // occurs in a new tab, we want focus to be restored to the content
+          // area when the current tab is re-selected.
+          browser.focus();
+
+          if (openUILinkWhere != "current") {
+            this.handleRevert();
+          }
+
+          try {
+            openUILinkIn(url, openUILinkWhere, params);
+          } catch (ex) {
+            // This load can throw an exception in certain cases, which means
+            // we'll want to replace the URL with the loaded URL:
+            if (ex.result != Cr.NS_ERROR_LOAD_SHOWED_ERRORPAGE) {
+              this.handleRevert();
+            }
+          }
+
+          if (openUILinkWhere == "current") {
+            // Ensure the start of the URL is visible for usability reasons.
+            this.selectionStart = this.selectionEnd = 0;
+          }
+        ]]></body>
+      </method>
+
+      <method name="_parseAndRecordSearchEngineLoad">
+        <parameter name="engineOrEngineName"/>
+        <parameter name="query"/>
+        <parameter name="event"/>
+        <parameter name="openUILinkWhere"/>
+        <parameter name="openUILinkParams"/>
+        <parameter name="searchActionDetails"/>
+        <body><![CDATA[
+          let engine =
+            typeof(engineOrEngineName) == "string" ?
+              Services.search.getEngineByName(engineOrEngineName) :
+              engineOrEngineName;
+          let isOneOff = this.popup.oneOffSearchButtons
+              .maybeRecordTelemetry(event, openUILinkWhere, openUILinkParams);
+          // Infer the type of the event which triggered the search.
+          let eventType = "unknown";
+          if (event instanceof KeyboardEvent) {
+            eventType = "key";
+          } else if (event instanceof MouseEvent) {
+            eventType = "mouse";
+          }
+          // Augment the search action details object.
+          let details = searchActionDetails || {};
+          details.isOneOff = isOneOff;
+          details.type = eventType;
+
+          BrowserSearch.recordSearchInTelemetry(engine, "urlbar", details);
+          let submission = engine.getSubmission(query, null, "keyword");
+          return [submission.uri.spec, submission.postData];
+        ]]></body>
+      </method>
+
+      <method name="maybeCanonizeURL">
+        <parameter name="aTriggeringEvent"/>
+        <parameter name="aUrl"/>
+        <body><![CDATA[
+          // Only add the suffix when the URL bar value isn't already "URL-like",
+          // and only if we get a keyboard event, to match user expectations.
+          if (!/^\s*[^.:\/\s]+(?:\/.*|\s*)$/i.test(aUrl) ||
+              !(aTriggeringEvent instanceof KeyboardEvent)) {
+            return;
+          }
+
+          let url = aUrl;
+          let accel = AppConstants.platform == "macosx" ?
+                      aTriggeringEvent.metaKey :
+                      aTriggeringEvent.ctrlKey;
+          let shift = aTriggeringEvent.shiftKey;
+          let suffix = "";
+
+          switch (true) {
+            case (accel && shift):
+              suffix = ".org/";
+              break;
+            case (shift):
+              suffix = ".net/";
+              break;
+            case (accel):
+              try {
+                suffix = gPrefService.getCharPref("browser.fixup.alternate.suffix");
+                if (suffix.charAt(suffix.length - 1) != "/")
+                  suffix += "/";
+              } catch (e) {
+                suffix = ".com/";
+              }
+              break;
+          }
+
+          if (!suffix)
+            return;
+
+          // trim leading/trailing spaces (bug 233205)
+          url = url.trim();
+
+          // Tack www. and suffix on.  If user has appended directories, insert
+          // suffix before them (bug 279035).  Be careful not to get two slashes.
+          let firstSlash = url.indexOf("/");
+          if (firstSlash >= 0) {
+            url = url.substring(0, firstSlash) + suffix +
+                  url.substring(firstSlash + 1);
+          } else {
+            url = url + suffix;
+          }
+
+          this.popup.overrideValue = "http://www." + url;
+        ]]></body>
+      </method>
+
+      <method name="_initURLTooltip">
+        <body><![CDATA[
+          if (this.focused || !this.hasAttribute("textoverflow"))
+            return;
+          this.inputField.setAttribute("tooltiptext", this.value);
+        ]]></body>
+      </method>
+
+      <method name="_hideURLTooltip">
+        <body><![CDATA[
+          this.inputField.removeAttribute("tooltiptext");
+        ]]></body>
+      </method>
+
+      <!-- Returns:
+           null if there's a security issue and we should do nothing.
+           a URL object if there is one that we're OK with loading,
+           a text value otherwise.
+           -->
+      <method name="_getDroppableItem">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          let links;
+          try {
+            links = browserDragAndDrop.dropLinks(aEvent);
+          } catch (ex) {
+            // this is possibly a security exception, in which case we should return
+            // null. Always return null because we can't *know* what exception is
+            // being returned.
+            return null;
+          }
+          // The URL bar automatically handles inputs with newline characters,
+          // so we can get away with treating text/x-moz-url flavours as text/plain.
+          if (links.length > 0 && links[0].url) {
+            aEvent.preventDefault();
+            let url = links[0].url;
+            let strippedURL = stripUnsafeProtocolOnPaste(url);
+            if (strippedURL != url) {
+              aEvent.stopImmediatePropagation();
+              return null;
+            }
+            let urlObj;
+            try {
+              // If this throws, urlSecurityCheck would also throw, as that's what it
+              // does with things that don't pass the IO service's newURI constructor
+              // without fixup. It's conceivable we may want to relax this check in
+              // the future (so e.g. www.foo.com gets fixed up), but not right now.
+              urlObj = new URL(url);
+              // If we succeed, try to pass security checks. If this works, return the
+              // URL object. If the *security checks* fail, return null.
+              try {
+                urlSecurityCheck(url,
+                                 gBrowser.contentPrincipal,
+                                 Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);
+                return urlObj;
+              } catch (ex) {
+                return null;
+              }
+            } catch (ex) {
+              // We couldn't make a URL out of this. Continue on, and return text below.
+            }
+          }
+          return aEvent.dataTransfer.getData("text/unicode");
+        ]]></body>
+      </method>
+
+      <method name="onDragOver">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          if (!this._getDroppableItem(aEvent)) {
+            aEvent.dataTransfer.dropEffect = "none";
+          }
+        ]]></body>
+      </method>
+
+      <method name="onDrop">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          let droppedItem = this._getDroppableItem(aEvent);
+          if (droppedItem) {
+            this.value = droppedItem instanceof URL ? droppedItem.href : droppedItem;
+            SetPageProxyState("invalid");
+            this.focus();
+            if (droppedItem instanceof URL) {
+              this.handleCommand();
+              // Force not showing the dropped URI immediately.
+              gBrowser.userTypedValue = null;
+              URLBarSetURI();
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="makeURIReadable">
+        <parameter name="aURI"/>
+        <body>
+          <![CDATA[
+            // Avoid copying 'about:reader?url=', and always provide the original URI:
+            // Reader mode ensures we call createExposableURI itself.
+            let readerStrippedURI = ReaderMode.getOriginalUrlObjectForDisplay(aURI.displaySpec);
+            if (readerStrippedURI) {
+              aURI = readerStrippedURI;
+            } else {
+              // Only copy exposable URIs
+              try {
+                aURI = Services.uriFixup.createExposableURI(aURI);
+              } catch (ex) {}
+            }
+            return aURI;
+          ]]>
+        </body>
+      </method>
+
+      <method name="_getSelectedValueForClipboard">
+        <body><![CDATA[
+          // Grab the actual input field's value, not our value, which could include moz-action:
+          var inputVal = this.inputField.value;
+          let selection = this.editor.selection;
+          const flags = Ci.nsIDocumentEncoder.OutputPreformatted |
+                        Ci.nsIDocumentEncoder.OutputRaw;
+          let selectedVal = selection.QueryInterface(Ci.nsISelectionPrivate)
+                                     .toStringWithFormat("text/plain", flags, 0);
+
+          // Handle multiple-range selection as a string for simplicity.
+          if (selection.rangeCount > 1) {
+             return selectedVal;
+          }
+
+          // If the selection doesn't start at the beginning or doesn't span the full domain or
+          // the URL bar is modified or there is no text at all, nothing else to do here.
+          if (this.selectionStart > 0 || this.valueIsTyped || selectedVal == "")
+            return selectedVal;
+          // The selection doesn't span the full domain if it doesn't contain a slash and is
+          // followed by some character other than a slash.
+          if (!selectedVal.includes("/")) {
+            let remainder = inputVal.replace(selectedVal, "");
+            if (remainder != "" && remainder[0] != "/")
+              return selectedVal;
+          }
+
+          let uriFixup = Cc["@mozilla.org/docshell/urifixup;1"].getService(Ci.nsIURIFixup);
+
+          let uri;
+          if (this.getAttribute("pageproxystate") == "valid") {
+            uri = gBrowser.currentURI;
+          } else {
+            // We're dealing with an autocompleted value, create a new URI from that.
+            try {
+              uri = uriFixup.createFixupURI(inputVal, Ci.nsIURIFixup.FIXUP_FLAG_NONE);
+            } catch (e) {}
+            if (!uri)
+              return selectedVal;
+          }
+
+          uri = this.makeURIReadable(uri);
+
+          // If the entire URL is selected, just use the actual loaded URI,
+          // unless we want a decoded URI, or it's a data: or javascript: URI,
+          // since those are hard to read when encoded.
+          if (inputVal == selectedVal &&
+              !uri.schemeIs("javascript") && !uri.schemeIs("data") &&
+              !Services.prefs.getBoolPref("browser.urlbar.decodeURLsOnCopy")) {
+            return uri.displaySpec;
+          }
+
+          // Just the beginning of the URL is selected, or we want a decoded
+          // url. First check for a trimmed value.
+          let spec = uri.displaySpec;
+          let trimmedSpec = this.trimValue(spec);
+          if (spec != trimmedSpec) {
+            // Prepend the portion that trimValue removed from the beginning.
+            // This assumes trimValue will only truncate the URL at
+            // the beginning or end (or both).
+            let trimmedSegments = spec.split(trimmedSpec);
+            selectedVal = trimmedSegments[0] + selectedVal;
+          }
+
+          return selectedVal;
+        ]]></body>
+      </method>
+
+      <field name="_copyCutController"><![CDATA[
+        ({
+          urlbar: this,
+          doCommand(aCommand) {
+            var urlbar = this.urlbar;
+            var val = urlbar._getSelectedValueForClipboard();
+            if (!val)
+              return;
+
+            if (aCommand == "cmd_cut" && this.isCommandEnabled(aCommand)) {
+              let start = urlbar.selectionStart;
+              let end = urlbar.selectionEnd;
+              urlbar.inputField.value = urlbar.inputField.value.substring(0, start) +
+                                        urlbar.inputField.value.substring(end);
+              urlbar.selectionStart = urlbar.selectionEnd = start;
+
+              let event = document.createEvent("UIEvents");
+              event.initUIEvent("input", true, false, window, 0);
+              urlbar.dispatchEvent(event);
+
+              SetPageProxyState("invalid");
+            }
+
+            Cc["@mozilla.org/widget/clipboardhelper;1"]
+              .getService(Ci.nsIClipboardHelper)
+              .copyString(val);
+          },
+          supportsCommand(aCommand) {
+            switch (aCommand) {
+              case "cmd_copy":
+              case "cmd_cut":
+                return true;
+            }
+            return false;
+          },
+          isCommandEnabled(aCommand) {
+            return this.supportsCommand(aCommand) &&
+                   (aCommand != "cmd_cut" || !this.urlbar.readOnly) &&
+                   this.urlbar.selectionStart < this.urlbar.selectionEnd;
+          },
+          onEvent(aEventName) {}
+        })
+      ]]></field>
+
+      <method name="observe">
+        <parameter name="aSubject"/>
+        <parameter name="aTopic"/>
+        <parameter name="aData"/>
+        <body><![CDATA[
+          if (aTopic == "nsPref:changed") {
+            switch (aData) {
+              case "clickSelectsAll":
+              case "doubleClickSelectsAll":
+                this[aData] = this._prefs.getBoolPref(aData);
+                break;
+              case "autoFill":
+                this.completeDefaultIndex = this._prefs.getBoolPref(aData);
+                break;
+              case "delay":
+                this.timeout = this._prefs.getIntPref(aData);
+                break;
+              case "formatting.enabled":
+                this._formattingEnabled = this._prefs.getBoolPref(aData);
+                break;
+              case "speculativeConnect.enabled":
+                this.speculativeConnectEnabled = this._prefs.getBoolPref(aData);
+                break;
+              case "browser.search.suggest.enabled":
+                this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(aData);
+                break;
+              case "suggest.searches":
+                this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(aData);
+              case "userMadeSearchSuggestionsChoice":
+                // Mirror the value for future use, see the comment in the
+                // binding's constructor.
+                this._prefs.setBoolPref("searchSuggestionsChoice",
+                  this.urlbarSearchSuggestEnabled);
+                // Clear the cached value to allow changing conditions in tests.
+                delete this._whichSearchSuggestionsNotification;
+                break;
+              case "trimURLs":
+                this._mayTrimURLs = this._prefs.getBoolPref(aData);
+                break;
+              case "oneOffSearches":
+                this._enableOrDisableOneOffSearches();
+                break;
+              case "maxRichResults":
+                this.popup.maxResults = this._prefs.getIntPref(aData);
+                break;
+              case "switchTabs.adoptIntoActiveWindow":
+                this._adoptIntoActiveWindow =
+                  this._prefs.getBoolPref("switchTabs.adoptIntoActiveWindow");
+                break;
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="_enableOrDisableOneOffSearches">
+        <body><![CDATA[
+          let enable = this._prefs.getBoolPref("oneOffSearches");
+          this.popup.enableOneOffSearches(enable);
+        ]]></body>
+      </method>
+
+      <method name="handleEvent">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          switch (aEvent.type) {
+            case "paste":
+              let originalPasteData = aEvent.clipboardData.getData("text/plain");
+              if (!originalPasteData) {
+                return;
+              }
+
+              let oldValue = this.inputField.value;
+              let oldStart = oldValue.substring(0, this.inputField.selectionStart);
+              // If there is already non-whitespace content in the URL bar
+              // preceding the pasted content, it's not necessary to check
+              // protocols used by the pasted content:
+              if (oldStart.trim()) {
+                return;
+              }
+              let oldEnd = oldValue.substring(this.inputField.selectionEnd);
+
+              let pasteData = stripUnsafeProtocolOnPaste(originalPasteData);
+              if (originalPasteData != pasteData) {
+                // Unfortunately we're not allowed to set the bits being pasted
+                // so cancel this event:
+                aEvent.preventDefault();
+                aEvent.stopImmediatePropagation();
+
+                this.inputField.value = oldStart + pasteData + oldEnd;
+                // Fix up cursor/selection:
+                let newCursorPos = oldStart.length + pasteData.length;
+                this.inputField.selectionStart = newCursorPos;
+                this.inputField.selectionEnd = newCursorPos;
+              }
+              break;
+            case "mousedown":
+              if (this.doubleClickSelectsAll &&
+                  aEvent.button == 0 && aEvent.detail == 2) {
+                this.editor.selectAll();
+                aEvent.preventDefault();
+              }
+              break;
+            case "mousemove":
+              this._initURLTooltip();
+              break;
+            case "mouseout":
+              this._hideURLTooltip();
+              break;
+            case "overflow":
+              if (!this.value) {
+                // We initially get a spurious overflow event from the
+                // anonymous div containing the placeholder text; bail out.
+                break;
+              }
+              this.setAttribute("textoverflow", "true");
+              break;
+            case "underflow":
+              this.removeAttribute("textoverflow");
+              this._hideURLTooltip();
+              break;
+            case "TabSelect":
+              dump("TABSELECT");
+              this.controller.resetInternalState();
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <!--
+        onBeforeTextValueSet is called by the base-binding's .textValue getter.
+        It should return the value that the getter should use.
+      -->
+      <method name="onBeforeTextValueGet">
+        <body><![CDATA[
+          return { value: this.inputField.value };
+        ]]></body>
+      </method>
+
+      <!--
+        onBeforeTextValueSet is called by the base-binding's .textValue setter.
+        It should return the value that the setter should use.
+      -->
+      <method name="onBeforeTextValueSet">
+        <parameter name="aValue"/>
+        <body><![CDATA[
+          let val = aValue;
+          let uri;
+          try {
+            uri = makeURI(val);
+          } catch (ex) {}
+
+          if (uri) {
+            // Do not touch moz-action URIs at all.  They depend on being
+            // properly encoded and decoded and will break if decoded
+            // unexpectedly.
+            if (!this._parseActionUrl(val)) {
+              val = losslessDecodeURI(uri);
+            }
+          }
+
+          return val;
+        ]]></body>
+      </method>
+
+      <method name="_parseActionUrl">
+        <parameter name="aUrl"/>
+        <body><![CDATA[
+          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;
+          if (!MOZ_ACTION_REGEX.test(aUrl))
+            return null;
+
+          // URL is in the format moz-action:ACTION,PARAMS
+          // Where PARAMS is a JSON encoded object.
+          let [, type, params] = aUrl.match(MOZ_ACTION_REGEX);
+
+          let action = {
+            type,
+          };
+
+          action.params = JSON.parse(params);
+          for (let key in action.params) {
+            action.params[key] = decodeURIComponent(action.params[key]);
+          }
+
+          if ("url" in action.params) {
+            let uri;
+            try {
+              uri = makeURI(action.params.url);
+              action.params.displayUrl = losslessDecodeURI(uri);
+            } catch (e) {
+              action.params.displayUrl = action.params.url;
+            }
+          }
+
+          return action;
+        ]]></body>
+      </method>
+
+      <property name="_noActionKeys" readonly="true">
+        <getter><![CDATA[
+          if (!this.__noActionKeys) {
+            this.__noActionKeys = new Set([
+              KeyEvent.DOM_VK_ALT,
+              KeyEvent.DOM_VK_SHIFT,
+            ]);
+            let modifier = AppConstants.platform == "macosx" ?
+                           KeyEvent.DOM_VK_META :
+                           KeyEvent.DOM_VK_CONTROL;
+            this.__noActionKeys.add(modifier);
+          }
+          return this.__noActionKeys;
+        ]]></getter>
+      </property>
+
+      <field name="_pressedNoActionKeys"><![CDATA[
+        new Set()
+      ]]></field>
+
+      <method name="_clearNoActions">
+        <parameter name="aURL"/>
+        <body><![CDATA[
+          this._pressedNoActionKeys.clear();
+          this.popup.removeAttribute("noactions");
+          let action = this._parseActionUrl(this._value);
+          if (action)
+            this.setAttribute("actiontype", action.type);
+        ]]></body>
+      </method>
+
+      <method name="onInput">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          if (!this.mIgnoreInput && this.mController.input == this) {
+            this._value = this.inputField.value;
+            gBrowser.userTypedValue = this.value;
+            this.valueIsTyped = true;
+            if (this.inputField.value) {
+              this.setAttribute("usertyping", "true");
+            } else {
+              this.removeAttribute("usertyping");
+            }
+            // Only wait for a result when we are sure to get one.  In some
+            // cases, like when pasting the same exact text, we may not fire
+            // a new search and we won't get a result.
+            if (this.mController.handleText()) {
+              this.gotResultForCurrentQuery = false;
+              this._searchStartDate = Date.now();
+              this._deferredKeyEventQueue = [];
+              if (this._deferredKeyEventTimeout) {
+                clearTimeout(this._deferredKeyEventTimeout);
+                this._deferredKeyEventTimeout = null;
+              }
+            }
+          }
+          this.resetActionType();
+        ]]></body>
+      </method>
+
+      <method name="handleEnter">
+        <parameter name="event"/>
+        <body><![CDATA[
+          // We need to ensure we're using a selected autocomplete result.
+          // A result should automatically be selected by default,
+          // however autocomplete is async and therefore we may not
+          // have a result set relating to the current input yet. If that
+          // happens, we need to mark that when the first result does get added,
+          // it needs to be handled as if enter was pressed with that first
+          // result selected.
+          // If anything other than the default (first) result is selected, then
+          // it must have been manually selected by the human. We let this
+          // explicit choice be used, even if it may be related to a previous
+          // input.
+          // However, if the default result is automatically selected, we
+          // ensure that it corresponds to the current input.
+
+          // Store the current search string so it can be used in handleCommand,
+          // which will be called as a result of mController.handleEnter().
+          this.handleEnterSearchString = this.mController.searchString;
+
+          if (!this._deferredKeyEventQueue.length &&
+              (this.popup.selectedIndex != 0 || this.gotResultForCurrentQuery)) {
+            let canonizeValue = this.value;
+            if (event.shiftKey || (AppConstants.platform === "macosx" ?
+                                   event.metaKey :
+                                   event.ctrlKey)) {
+              let action = this._parseActionUrl(canonizeValue);
+              if (action && "searchSuggestion" in action.params) {
+                canonizeValue = action.params.searchSuggestion;
+              } else if (this.popup.selectedIndex === 0 &&
+                         this.mController.getStyleAt(0).includes("autofill")) {
+                canonizeValue = this.handleEnterSearchString;
+              }
+            }
+            this.maybeCanonizeURL(event, canonizeValue);
+            let handled = this.mController.handleEnter(false, event);
+            this.handleEnterSearchString = null;
+            this.popup.overrideValue = null;
+            return handled;
+          }
+
+          // Defer the event until the first non-heuristic result comes in.
+          this._deferKeyEvent(event, "handleEnter");
+          return false;
+        ]]></body>
+      </method>
+
+      <method name="handleDelete">
+        <body><![CDATA[
+          // If the heuristic result is selected, then the autocomplete
+          // controller's handleDelete implementation will remove it, which is
+          // not what we want.  So in that case, call handleText so it acts as
+          // a backspace on the text value instead of removing the result.
+          if (this.popup.selectedIndex == 0 &&
+              this.popup._isFirstResultHeuristic) {
+            this.mController.handleText();
+            return false;
+          }
+          return this.mController.handleDelete();
+        ]]></body>
+      </method>
+
+      <property name="_userMadeSearchSuggestionsChoice" readonly="true">
+        <getter><![CDATA[
+          return this._prefs.getBoolPref("userMadeSearchSuggestionsChoice") ||
+                 this._defaultPrefs.getBoolPref("suggest.searches") != this._prefs.getBoolPref("suggest.searches");
+        ]]></getter>
+      </property>
+
+      <property name="whichSearchSuggestionsNotification" readonly="true">
+        <getter><![CDATA[
+          // Once we return "none" once, we'll always return "none".
+          // If available, use the cached value, rather than running all of the
+          // checks again at every locationbar focus.
+          if (this._whichSearchSuggestionsNotification) {
+            return this._whichSearchSuggestionsNotification;
+          }
+
+          if (this.browserSearchSuggestEnabled && !this.inPrivateContext &&
+              // In any case, if the user made a choice we should not nag him.
+              !this._userMadeSearchSuggestionsChoice) {
+            if (this._defaultPrefs.getBoolPref("suggest.searches") &&
+                this.urlbarSearchSuggestEnabled && // Has not been switched off.
+                this._prefs.getIntPref("timesBeforeHidingSuggestionsHint")) {
+              return "opt-out";
+            }
+          }
+          return this._whichSearchSuggestionsNotification = "none";
+        ]]></getter>
+      </property>
+
+      <method name="updateSearchSuggestionsNotificationImpressions">
+        <parameter name="whichNotification"/>
+        <body><![CDATA[
+          if (whichNotification == "none") {
+            throw new Error("Unexpected notification type");
+          }
+
+          let remaining = this._prefs.getIntPref("timesBeforeHidingSuggestionsHint");
+          if (remaining > 0) {
+            this._prefs.setIntPref("timesBeforeHidingSuggestionsHint", remaining - 1);
+          }
+        ]]></body>
+      </method>
+
+      <method name="maybeShowSearchSuggestionsNotificationOnFocus">
+        <parameter name="mouseFocused"/>
+        <body><![CDATA[
+          let whichNotification = this.whichSearchSuggestionsNotification;
+          if (this._showSearchSuggestionNotificationOnMouseFocus &&
+              mouseFocused) {
+            // Force showing the opt-out notification.
+            this._whichSearchSuggestionsNotification = whichNotification = "opt-out";
+          }
+          if (whichNotification == "opt-out") {
+            try {
+              this.popup.openAutocompletePopup(this, this);
+            } finally {
+              if (mouseFocused) {
+                delete this._whichSearchSuggestionsNotification;
+                this._showSearchSuggestionNotificationOnMouseFocus = false;
+              }
+            }
+          }
+        ]]></body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="keydown"><![CDATA[
+        if (this._noActionKeys.has(event.keyCode) &&
+            this.popup.selectedIndex >= 0 &&
+            !this._pressedNoActionKeys.has(event.keyCode)) {
+          if (this._pressedNoActionKeys.size == 0) {
+            this.popup.setAttribute("noactions", "true");
+            this.removeAttribute("actiontype");
+          }
+          this._pressedNoActionKeys.add(event.keyCode);
+        }
+      ]]></handler>
+
+      <handler event="keyup"><![CDATA[
+        if (this._noActionKeys.has(event.keyCode) &&
+            this._pressedNoActionKeys.has(event.keyCode)) {
+          this._pressedNoActionKeys.delete(event.keyCode);
+          if (this._pressedNoActionKeys.size == 0)
+            this._clearNoActions();
+        }
+      ]]></handler>
+
+      <handler event="mousedown"><![CDATA[
+        if (event.button == 0) {
+          if (event.originalTarget.getAttribute("anonid") == "historydropmarker") {
+            this.toggleHistoryPopup();
+          }
+
+          // Eventually show the opt-out notification even if the location bar is
+          // empty, focused, and the user clicks on it.
+          if (this.focused && this.textValue == "") {
+            this.maybeShowSearchSuggestionsNotificationOnFocus(true);
+          }
+        }
+      ]]></handler>
+
+      <handler event="focus"><![CDATA[
+        if (event.originalTarget == this.inputField) {
+          this._hideURLTooltip();
+          this.formatValue();
+          if (this.getAttribute("pageproxystate") != "valid") {
+            UpdatePopupNotificationsVisibility();
+          }
+
+          // We show the opt-out notification when the mouse/keyboard focus the
+          // urlbar, but in any case we want to enforce at least one
+          // notification when the user focuses it with the mouse.
+          let whichNotification = this.whichSearchSuggestionsNotification;
+          if (whichNotification == "opt-out" &&
+              this._showSearchSuggestionNotificationOnMouseFocus === undefined) {
+            this._showSearchSuggestionNotificationOnMouseFocus = true;
+          }
+
+          // Check whether the focus change came from a keyboard/mouse action.
+          let focusMethod = Services.focus.getLastFocusMethod(window);
+          // If it's a focus started by code and the primary user intention was
+          // not to go to the location bar, don't show a notification.
+          if (!focusMethod && !this.userInitiatedFocus) {
+            return;
+          }
+
+          let mouseFocused = !!(focusMethod & Services.focus.FLAG_BYMOUSE);
+          this.maybeShowSearchSuggestionsNotificationOnFocus(mouseFocused);
+        }
+      ]]></handler>
+
+      <handler event="blur"><![CDATA[
+        if (event.originalTarget == this.inputField) {
+          this._clearNoActions();
+          this.formatValue();
+          if (this.getAttribute("pageproxystate") != "valid") {
+            UpdatePopupNotificationsVisibility();
+          }
+        }
+        if (this.ExtensionSearchHandler.hasActiveInputSession()) {
+          this.ExtensionSearchHandler.handleInputCancelled();
+        }
+        if (this._deferredKeyEventTimeout) {
+          clearTimeout(this._deferredKeyEventTimeout);
+          this._deferredKeyEventTimeout = null;
+        }
+        this._deferredKeyEventQueue = [];
+      ]]></handler>
+
+      <handler event="dragstart" phase="capturing"><![CDATA[
+        // Drag only if the gesture starts from the input field.
+        if (this.inputField != event.originalTarget &&
+            !(this.inputField.compareDocumentPosition(event.originalTarget) &
+              Node.DOCUMENT_POSITION_CONTAINED_BY))
+          return;
+
+        // Drag only if the entire value is selected and it's a valid URI.
+        var isFullSelection = this.selectionStart == 0 &&
+                              this.selectionEnd == this.textLength;
+        if (!isFullSelection ||
+            this.getAttribute("pageproxystate") != "valid")
+          return;
+
+        var urlString = gBrowser.selectedBrowser.currentURI.displaySpec;
+        var title = gBrowser.selectedBrowser.contentTitle || urlString;
+        var htmlString = "<a href=\"" + urlString + "\">" + urlString + "</a>";
+
+        var dt = event.dataTransfer;
+        dt.setData("text/x-moz-url", urlString + "\n" + title);
+        dt.setData("text/unicode", urlString);
+        dt.setData("text/html", htmlString);
+
+        dt.effectAllowed = "copyLink";
+        event.stopPropagation();
+      ]]></handler>
+
+      <handler event="dragover" phase="capturing" action="this.onDragOver(event, this);"/>
+      <handler event="drop" phase="capturing" action="this.onDrop(event, this);"/>
+      <handler event="select"><![CDATA[
+        if (!Cc["@mozilla.org/widget/clipboard;1"]
+               .getService(Ci.nsIClipboard)
+               .supportsSelectionClipboard())
+          return;
+
+        if (!window.QueryInterface(Ci.nsIInterfaceRequestor)
+                   .getInterface(Ci.nsIDOMWindowUtils)
+                   .isHandlingUserInput)
+          return;
+
+        var val = this._getSelectedValueForClipboard();
+        if (!val)
+          return;
+
+        Cc["@mozilla.org/widget/clipboardhelper;1"]
+          .getService(Ci.nsIClipboardHelper)
+          .copyStringToClipboard(val, Ci.nsIClipboard.kSelectionClipboard);
+      ]]></handler>
+    </handlers>
+
+  </binding>
+
+  <binding id="urlbar-rich-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup">
+
+    <resources>
+      <stylesheet src="chrome://browser/content/search/searchbarBindings.css"/>
+      <stylesheet src="chrome://browser/skin/searchbar.css"/>
+    </resources>
+
+    <content ignorekeys="true" level="top" consumeoutsideclicks="never"
+             aria-owns="richlistbox">
+      <xul:deck anonid="search-suggestions-notification"
+                align="center"
+                role="alert"
+                selectedIndex="0">
+        <!-- OPT-OUT -->
+        <xul:hbox flex="1" align="center" anonid="search-suggestions-opt-out">
+          <xul:image class="ac-site-icon" type="searchengine"/>
+          <xul:hbox anonid="search-suggestions-hint-typing">
+            <xul:description class="ac-title-text">&brandShortName;</xul:description>
+          </xul:hbox>
+          <xul:hbox anonid="search-suggestions-hint-box" flex="1">
+            <xul:description id="search-suggestions-hint">
+              <html:span class="prefix">&#x1f4a1; &urlbar.searchSuggestionsNotification.hintPrefix;</html:span>
+              <html:span>&urlbar.searchSuggestionsNotification.hint;</html:span>
+            </xul:description>
+          </xul:hbox>
+          <xul:label id="search-suggestions-change-settings"
+                     class="text-link"
+                     role="link"
+#ifdef XP_WIN
+                     value="&urlbar.searchSuggestionsNotification.changeSettingsWin;"
+                     accesskey="&urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;"
+#else
+                     value="&urlbar.searchSuggestionsNotification.changeSettingsUnix;"
+                     accesskey="&urlbar.searchSuggestionsNotification.changeSettingsUnix.accesskey;"
+#endif
+                     onclick="openPreferences('paneSearch');"
+                     control="search-suggestions-change-settings"/>
+        </xul:hbox>
+      </xul:deck>
+      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox"
+                       flex="1"/>
+      <xul:hbox anonid="footer">
+        <children/>
+        <xul:vbox anonid="one-off-search-buttons"
+                  class="search-one-offs"
+                  compact="true"
+                  includecurrentengine="true"
+                  disabletab="true"
+                  flex="1"/>
+      </xul:hbox>
+    </content>
+
+    <implementation>
+      <field name="DOMWindowUtils">
+        window.QueryInterface(Ci.nsIInterfaceRequestor)
+              .getInterface(Ci.nsIDOMWindowUtils);
+      </field>
+
+      <field name="_maxResults">0</field>
+
+      <field name="_bundle" readonly="true">
+        Cc["@mozilla.org/intl/stringbundle;1"].
+          getService(Ci.nsIStringBundleService).
+          createBundle("chrome://browser/locale/places/places.properties");
+      </field>
+
+      <field name="searchSuggestionsNotification" readonly="true">
+        document.getAnonymousElementByAttribute(
+          this, "anonid", "search-suggestions-notification"
+        );
+      </field>
+
+      <field name="footer" readonly="true">
+        document.getAnonymousElementByAttribute(this, "anonid", "footer");
+      </field>
+
+      <field name="oneOffSearchButtons" readonly="true">
+        document.getAnonymousElementByAttribute(this, "anonid",
+                                                "one-off-search-buttons");
+      </field>
+
+      <field name="_oneOffSearchesEnabled">false</field>
+
+      <field name="_overrideValue">null</field>
+      <property name="overrideValue"
+                onget="return this._overrideValue;"
+                onset="this._overrideValue = val; return val;"/>
+
+      <method name="onPopupClick">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          if (aEvent.button == 2) {
+            // Ignore right-clicks.
+            return;
+          }
+          // Otherwise "call super" -- do what autocomplete-base-popup does.
+          let controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);
+          controller.handleEnter(true, aEvent);
+        ]]></body>
+      </method>
+
+      <method name="enableOneOffSearches">
+        <parameter name="enable"/>
+        <body><![CDATA[
+          this._oneOffSearchesEnabled = enable;
+          if (enable) {
+            this.oneOffSearchButtons.telemetryOrigin = "urlbar";
+            this.oneOffSearchButtons.style.display = "-moz-box";
+            // Set .textbox first, since the popup setter will cause
+            // a _rebuild call that uses it.
+            this.oneOffSearchButtons.textbox = this.input;
+            this.oneOffSearchButtons.popup = this;
+          } else {
+            this.oneOffSearchButtons.telemetryOrigin = null;
+            this.oneOffSearchButtons.style.display = "none";
+            this.oneOffSearchButtons.textbox = null;
+            this.oneOffSearchButtons.popup = null;
+          }
+        ]]></body>
+      </method>
+
+      <!-- Override this so that navigating between items results in an item
+           always being selected. -->
+      <method name="getNextIndex">
+        <parameter name="reverse"/>
+        <parameter name="amount"/>
+        <parameter name="index"/>
+        <parameter name="maxRow"/>
+        <body><![CDATA[
+          if (maxRow < 0)
+            return -1;
+
+          let newIndex = index + (reverse ? -1 : 1) * amount;
+
+          // We only want to wrap if navigation is in any direction by one item,
+          // otherwise we clamp to one end of the list.
+          // ie, hitting page-down will only cause is to wrap if we're already
+          // at one end of the list.
+
+          // Allow the selection to be removed if the first result is not a
+          // heuristic result.
+          if (!this._isFirstResultHeuristic) {
+            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)
+              newIndex = maxRow;
+            else if (!reverse && index == -1 || newIndex < 0 && index != 0)
+              newIndex = 0;
+
+            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)
+              newIndex = -1;
+
+            return newIndex;
+          }
+
+          // Otherwise do not allow the selection to be removed.
+          if (newIndex < 0) {
+            newIndex = index > 0 ? 0 : maxRow;
+          } else if (newIndex > maxRow) {
+            newIndex = index < maxRow ? maxRow : 0;
+          }
+          return newIndex;
+        ]]></body>
+      </method>
+
+      <property name="_isFirstResultHeuristic" readonly="true">
+        <getter>
+          <![CDATA[
+            // The popup usually has a special "heuristic" first result (added
+            // by UnifiedComplete.js) that is automatically selected when the
+            // popup opens.
+            return this.input.mController.matchCount > 0 &&
+                   this.input.mController
+                             .getStyleAt(0)
+                             .split(/\s+/).indexOf("heuristic") > 0;
+          ]]>
+        </getter>
+      </property>
+
+      <property name="maxResults">
+        <getter>
+          <![CDATA[
+            if (!this._maxResults) {
+              this._maxResults = Services.prefs.getIntPref("browser.urlbar.maxRichResults");
+            }
+            return this._maxResults;
+          ]]>
+        </getter>
+        <setter>
+          <![CDATA[
+            return this._maxResults = parseInt(val);
+          ]]>
+        </setter>
+      </property>
+
+      <method name="openAutocompletePopup">
+        <parameter name="aInput"/>
+        <parameter name="aElement"/>
+        <body>
+          <![CDATA[
+          // initially the panel is hidden
+          // to avoid impacting startup / new window performance
+          aInput.popup.hidden = false;
+
+          this._openAutocompletePopup(aInput, aElement);
+          ]]>
+        </body>
+      </method>
+
+      <method name="_openAutocompletePopup">
+        <parameter name="aInput"/>
+        <parameter name="aElement"/>
+        <body><![CDATA[
+          if (this.mPopupOpen) {
+            return;
+          }
+
+          // Set the direction of the popup based on the textbox (bug 649840).
+          // getComputedStyle causes a layout flush, so avoid calling it if a
+          // direction has already been set.
+          if (!this.style.direction) {
+            this.style.direction =
+              aElement.ownerGlobal.getComputedStyle(aElement).direction;
+          }
+          let popupDirection = this.style.direction;
+
+          // Make the popup span the width of the window.  First, set its width.
+          let documentRect =
+            this.DOMWindowUtils
+                .getBoundsWithoutFlushing(window.document.documentElement);
+          let width = documentRect.right - documentRect.left;
+          this.setAttribute("width", width);
+
+          // Now make its starting margin negative so that its leading edge
+          // aligns with the window border.
+          let elementRect =
+            this.DOMWindowUtils.getBoundsWithoutFlushing(aElement);
+          if (popupDirection == "rtl") {
+            let offset = elementRect.right - documentRect.right
+            this.style.marginRight = offset + "px";
+          } else {
+            let offset = documentRect.left - elementRect.left;
+            this.style.marginLeft = offset + "px";
+          }
+
+          // Keep the popup items' site icons aligned with the urlbar's identity
+          // icon if it's not too far from the edge of the window.  We define
+          // "too far" as "more than 30% of the window's width AND more than
+          // 250px".  Do this *before* adding any items because when the new
+          // value of siteIconStart is different from the previous value, over-
+          // and underflow must be handled for each item already in the popup.
+          let boundToCheck = popupDirection == "rtl" ? "right" : "left";
+          let inputRect = this.DOMWindowUtils.getBoundsWithoutFlushing(aInput);
+          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);
+          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;
+          if (alignSiteIcons) {
+            let identityIcon = document.getElementById("identity-icon");
+            let identityRect =
+              this.DOMWindowUtils.getBoundsWithoutFlushing(identityIcon);
+            if (popupDirection == "rtl") {
+              this.siteIconStart = documentRect.right - identityRect.right;
+            } else {
+              this.siteIconStart = identityRect.left;
+            }
+          } else {
+            // Reset the alignment so that the site icons are positioned
+            // according to whatever's in the CSS.
+            this.siteIconStart = undefined;
+          }
+
+          // Now that siteIconStart has been set, start adding items (via
+          // _invalidate).
+          this.mInput = aInput;
+          aInput.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);
+          this.view = aInput.controller.QueryInterface(Components.interfaces.nsITreeView);
+          this._invalidate();
+
+          try {
+            let whichNotification = aInput.whichSearchSuggestionsNotification;
+            if (whichNotification != "none") {
+              // Update the impressions count on real popupshown, since there's
+              // no guarantee openPopup will be respected by the platform.
+              // Though, we must ensure the handled event is the expected one.
+              let impressionId = this._searchSuggestionsImpressionId = {};
+              this.addEventListener("popupshown", () => {
+                if (this._searchSuggestionsImpressionId == impressionId)
+                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);
+              }, {once: true});
+              this._showSearchSuggestionsNotification(whichNotification, popupDirection);
+            } else if (this.classList.contains("showSearchSuggestionsNotification")) {
+              this._hideSearchSuggestionsNotification();
+            }
+          } catch (ex) {
+            // Not critical for the urlbar functionality, just report the error.
+            Components.utils.reportError(ex);
+          }
+
+          // Position the popup below the navbar.  To get the y-coordinate,
+          // which is an offset from the bottom of the input, subtract the
+          // bottom of the navbar from the buttom of the input.
+          let yOffset = Math.round(
+            this.DOMWindowUtils.getBoundsWithoutFlushing(document.getElementById("nav-bar")).bottom -
+            this.DOMWindowUtils.getBoundsWithoutFlushing(aInput).bottom);
+
+          this.openPopup(aElement, "after_start", 0, yOffset, false, false);
+        ]]></body>
+      </method>
+
+      <method name="_showSearchSuggestionsNotification">
+        <parameter name="whichNotification"/>
+        <parameter name="popupDirection"/>
+        <body>
+          <![CDATA[
+          if (whichNotification == "opt-out") {
+            if (this.siteIconStart) {
+              this.searchSuggestionsNotification.style.paddingInlineStart =
+                this.siteIconStart + "px";
+            } else {
+              this.searchSuggestionsNotification.style.removeProperty("padding-inline-start");
+            }
+
+            // We want to animate the opt-out hint only once.
+            if (!this._firstSearchSuggestionsNotification) {
+              this._firstSearchSuggestionsNotification = true;
+              this.searchSuggestionsNotification.setAttribute("animate", "true");
+            }
+          }
+
+          this.searchSuggestionsNotification.setAttribute("aria-describedby",
+                                                          "search-suggestions-hint");
+
+          // With the notification shown, the listbox's height can sometimes be
+          // too small when it's flexed, as it normally is.  Also, it can start
+          // out slightly scrolled down.  Both problems appear together, most
+          // often when the popup is very narrow and the notification's text
+          // must wrap.  Work around them by removing the flex.
+          //
+          // But without flexing the listbox, the listbox's height animation
+          // sometimes fails to complete, leaving the popup too tall.  Work
+          // around that problem by disabling the listbox animation.
+          this.richlistbox.flex = 0;
+          this.setAttribute("dontanimate", "true");
+
+          this.classList.add("showSearchSuggestionsNotification");
+          // Don't show the one-off buttons if we are showing onboarding and
+          // there's no result, since it would be ugly and pointless.
+          this.footer.collapsed = this._matchCount == 0;
+          this.input.tabScrolling = this._matchCount != 0;
+
+          // This event allows accessibility APIs to see the notification.
+          if (!this.popupOpen) {
+            let event = document.createEvent("Events");
+            event.initEvent("AlertActive", true, true);
+            this.searchSuggestionsNotification.dispatchEvent(event);
+          }
+          ]]>
+        </body>
+      </method>
+
+      <method name="_hideSearchSuggestionsNotification">
+        <body>
+          <![CDATA[
+          this.classList.remove("showSearchSuggestionsNotification");
+          this.richlistbox.flex = 1;
+          this.removeAttribute("dontanimate");
+          this.searchSuggestionsNotification.removeAttribute("animate");
+          if (this._matchCount) {
+            // Update popup height.
+            this._invalidate();
+          } else {
+            this.closePopup();
+          }
+          ]]>
+        </body>
+      </method>
+
+      <method name="_selectedOneOffChanged">
+        <body><![CDATA[
+          // Update all searchengine result items to use the newly selected
+          // engine.
+          for (let item of this.richlistbox.childNodes) {
+            if (item.collapsed) {
+              break;
+            }
+            let url = item.getAttribute("url");
+            if (url) {
+              let action = item._parseActionUrl(url);
+              if (action && action.type == "searchengine") {
+                item._adjustAcItem();
+              }
+            }
+          }
+        ]]></body>
+      </method>
+
+      <!-- This handles keypress changes to the selection among the one-off
+           search buttons and between the one-offs and the listbox.  It returns
+           true if the keypress was consumed and false if not. -->
+      <method name="handleKeyPress">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          this.oneOffSearchButtons.handleKeyPress(aEvent, this._matchCount,
+                                                  !this._isFirstResultHeuristic,
+                                                  gBrowser.userTypedValue);
+          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;
+        ]]></body>
+      </method>
+
+      <!-- This is called when a one-off is clicked and when "search in new tab"
+           is selected from a one-off context menu. -->
+      <method name="handleOneOffSearch">
+        <parameter name="event"/>
+        <parameter name="engine"/>
+        <parameter name="where"/>
+        <parameter name="params"/>
+        <body><![CDATA[
+          this.input.handleCommand(event, where, params);
+        ]]></body>
+      </method>
+
+      <!-- Result listitems call this to determine which search engine they
+           should show in their labels and include in their url attributes. -->
+      <property name="overrideSearchEngineName" readonly="true">
+        <getter><![CDATA[
+          let button = this.oneOffSearchButtons.selectedButton;
+          return button && button.engine && button.engine.name;
+        ]]></getter>
+      </property>
+
+      <method name="createResultLabel">
+        <parameter name="item"/>
+        <parameter name="proposedLabel"/>
+        <body>
+          <![CDATA[
+            let parts = [proposedLabel];
+
+            let action = this.mInput._parseActionUrl(item.getAttribute("url"));
+            if (action) {
+              switch (action.type) {
+              case "searchengine":
+                parts = [
+                  action.params.searchSuggestion || action.params.searchQuery,
+                  action.params.engineName,
+                ];
+                break;
+              case "switchtab":
+              case "remotetab":
+                parts = [
+                  item.getAttribute("title"),
+                  item.getAttribute("displayurl"),
+                ];
+                break;
+              }
+            }
+
+            let types = item.getAttribute("type").split(/\s+/);
+            let type = types.find(t => t != "action" && t != "heuristic");
+            try {
+              // Some types intentionally do not map to strings, which is not
+              // an error.
+              parts.push(this._bundle.GetStringFromName(type + "ResultLabel"));
+            } catch (e) {}
+
+            return parts.filter(str => str).join(" ");
+          ]]>
+        </body>
+      </method>
+
+      <method name="maybeSetupSpeculativeConnect">
+        <parameter name="aUriString"/>
+        <body><![CDATA[
+          try {
+            let uri = makeURI(aUriString);
+            Services.io.speculativeConnect2(uri, gBrowser.contentPrincipal, null);
+          } catch (ex) {
+            // Can't setup speculative connection for this uri string for some
+            // reason, just ignore it.
+          }
+        ]]></body>
+      </method>
+
+      <method name="onResultsAdded">
+        <body>
+          <![CDATA[
+            // If nothing is selected yet, select the first result if it is a
+            // pre-selected "heuristic" result.  (See UnifiedComplete.js.)
+            if (this.selectedIndex == -1 && this._isFirstResultHeuristic) {
+              // Don't fire DOMMenuItemActive so that screen readers still see
+              // the input as being focused.
+              this.richlistbox.suppressMenuItemEvent = true;
+              this.input.controller.setInitiallySelectedIndex(0);
+              this.richlistbox.suppressMenuItemEvent = false;
+            }
+            // If this is the first time we get the result from the current
+            // search and we are not in the private context, we can speculatively
+            // connect to the intended site as a performance optimization.
+            if (!this.input.gotResultForCurrentQuery &&
+                this.input.speculativeConnectEnabled &&
+                !this.input.inPrivateContext &&
+                this.input.mController.matchCount > 0) {
+              let firstStyle = this.input.mController.getStyleAt(0);
+              if (firstStyle.includes("autofill")) {
+                let uri = this.input.mController.getFinalCompleteValueAt(0);
+                // "http" will be stripped out, but other scheme won't.
+                if (!uri.includes("://")) {
+                  uri = "http://" + uri;
+                }
+                this.maybeSetupSpeculativeConnect(uri);
+              } else if (firstStyle.includes("searchengine") &&
+                         this.input.browserSearchSuggestEnabled &&
+                         this.input.urlbarSearchSuggestEnabled) {
+                // Preconnect to the current search engine only if the search
+                // suggestions are enabled.
+                let engine = Services.search.currentEngine;
+                engine.speculativeConnect({window,
+                                           originAttributes: gBrowser.contentPrincipal.originAttributes});
+              }
+            }
+
+            // When a result is present the footer should always be visible.
+            this.footer.collapsed = false;
+            this.input.tabScrolling = true;
+
+            this.input.gotResultForCurrentQuery = true;
+            this.input.maybeReplayDeferredKeyEvents();
+          ]]>
+        </body>
+      </method>
+
+      <method name="_onSearchBegin">
+        <body><![CDATA[
+          // Set the selected index to 0 (heuristic) until a result comes back
+          // and we can evaluate it better.
+          //
+          // This is required to properly manage delayed handleEnter:
+          // 1. if a search starts we set selectedIndex to 0 here, and it will
+          //    be updated by onResultsAdded. Since selectedIndex is 0,
+          //    handleEnter will delay the action if a result didn't arrive yet.
+          // 2. if a search doesn't start (for example if autocomplete is
+          //    disabled), this won't be called, and the selectedIndex will be
+          //    the default -1 value. Then handleEnter will know it should not
+          //    delay the action, cause a result wont't ever arrive.
+          this.input.controller.setInitiallySelectedIndex(0);
+
+          // Since we are starting a new search, reset the currently selected
+          // one-off button, to cover those cases where the oneoff buttons
+          // binding won't receive an actual DOM event. For example, a search
+          // could be started without an actual input event, and the popup may
+          // not have been closed from the previous search.
+          this.oneOffSearchButtons.selectedButton = null;
+        ]]></body>
+      </method>
+
+      <field name="_addonIframe">null</field>
+      <field name="_addonIframeOwner">null</field>
+      <field name="_addonIframeOverriddenFunctionsByName">{}</field>
+
+      <!-- These methods must be overridden and properly handled by the API
+           runtime so that it doesn't break the popup.  If any of these methods
+           is not overridden, then initAddonIframe should throw. -->
+      <field name="_addonIframeOverrideFunctionNames">[
+        "_invalidate",
+      ]</field>
+
+      <field name="_addonIframeHiddenAnonids">[
+        "search-suggestions-notification",
+        "richlistbox",
+        "one-off-search-buttons",
+      ]</field>
+      <field name="_addonIframeHiddenDisplaysByAnonid">{}</field>
+
+      <method name="initAddonIframe">
+        <parameter name="owner"/>
+        <parameter name="overrides"/>
+        <body><![CDATA[
+          if (this._addonIframeOwner) {
+            // Another add-on has already requested the iframe.  Return null to
+            // signal to the calling add-on that it should not take over the
+            // popup.  First add-on wins for now.
+            return null;
+          }
+          // Make sure all overrides are provided before doing anything.
+          for (let name of this._addonIframeOverrideFunctionNames) {
+            if (typeof(overrides[name]) != "function") {
+              throw new Error(
+                "Override for method '" + name + "' must be given"
+              );
+            }
+          }
+          // OK, insert the iframe.
+          this._addonIframeOwner = owner;
+          this._addonIframe = this._makeAddonIframe();
+          this._addonIframeOverriddenFunctionsByName = {};
+          for (let name of this._addonIframeOverrideFunctionNames) {
+            this._addonIframeOverriddenFunctionsByName[name] = this[name];
+            this[name] = overrides[name];
+          }
+          return this._addonIframe;
+        ]]></body>
+      </method>
+
+      <method name="destroyAddonIframe">
+        <parameter name="owner"/>
+        <body><![CDATA[
+          if (this._addonIframeOwner != owner) {
+            throw new Error("You're not the iframe owner");
+          }
+          this._addonIframeOwner = null;
+          this._addonIframe.remove();
+          this._addonIframe = null;
+          for (let anonid of this._addonIframeHiddenAnonids) {
+            let child = document.getAnonymousElementByAttribute(
+              this, "anonid", anonid
+            );
+            child.style.display =
+              this._addonIframeHiddenDisplaysByAnonid[anonid];
+          }
+          for (let name in this._addonIframeOverriddenFunctionsByName) {
+            this[name] = this._addonIframeOverriddenFunctionsByName[name];
+          }
+          this._addonIframeOverriddenFunctionsByName = {};
+        ]]></body>
+      </method>
+
+      <method name="_makeAddonIframe">
+        <body><![CDATA[
+          this._addonIframeHiddenDisplaysByAnonid = {};
+          for (let anonid of this._addonIframeHiddenAnonids) {
+            let child = document.getAnonymousElementByAttribute(
+              this, "anonid", anonid
+            );
+            this._addonIframeHiddenDisplaysByAnonid[anonid] =
+              child.style.display;
+            child.style.display = "none";
+          }
+          let XUL_NS =
+            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+          let iframe = document.createElementNS(XUL_NS, "iframe");
+          iframe.setAttribute("type", "content");
+          iframe.setAttribute("flex", "1");
+          iframe.style.transition = "height 100ms";
+          this.appendChild(iframe);
+          return iframe;
+        ]]></body>
+      </method>
+
+    </implementation>
+    <handlers>
+
+      <handler event="SelectedOneOffButtonChanged"><![CDATA[
+        this._selectedOneOffChanged();
+      ]]></handler>
+
+      <handler event="mousedown"><![CDATA[
+        // Required to make the xul:label.text-link elements in the search
+        // suggestions notification work correctly when clicked on Linux.
+        // This is copied from the mousedown handler in
+        // browser-search-autocomplete-result-popup, which apparently had a
+        // similar problem.
+        event.preventDefault();
+
+        if (!this.input.speculativeConnectEnabled) {
+          return;
+        }
+        if (event.button == 2) {
+          // Ignore right-clicks.
+          return;
+        }
+        // Ensure the user is clicking on an url instead of other buttons
+        // on the popup.
+        let elt = event.originalTarget;
+        while (elt && elt.localName != "richlistitem" && elt != this) {
+          elt = elt.parentNode;
+        }
+        if (!elt || elt.localName != "richlistitem") {
+          return;
+        }
+        // The user might click on a ghost entry which was removed because of
+        // the coming new results.
+        if (this.input.controller.matchCount <= this.selectedIndex) {
+          return;
+        }
+
+        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);
+
+        // Whitelist the cases that we want to speculative connect, and ignore
+        // other moz-action uris or fancy protocols.
+        // Note that it's likely we've speculatively connected to the first
+        // url because it is a heuristic "autofill" result (see bug 1348275).
+        // "moz-action:searchengine" is also the same case. (see bug 1355443)
+        // So we won't duplicate the effort here.
+        if (url.startsWith("http") && this.selectedIndex > 0) {
+          this.maybeSetupSpeculativeConnect(url);
+        } else if (url.startsWith("moz-action:remotetab")) {
+          // URL is in the format moz-action:ACTION,PARAMS
+          // Where PARAMS is a JSON encoded object.
+          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;
+          if (!MOZ_ACTION_REGEX.test(url))
+            return;
+
+          let params = JSON.parse(url.match(MOZ_ACTION_REGEX)[2]);
+          if (params.url) {
+            this.maybeSetupSpeculativeConnect(decodeURIComponent(params.url));
+          }
+        }
+
+      ]]></handler>
+
+    </handlers>
+  </binding>
+
+  <binding id="addon-progress-notification" extends="chrome://global/content/bindings/notification.xml#popup-notification">
+    <implementation>
+      <constructor><![CDATA[
+        if (!this.notification)
+          return;
+
+        this.notification.options.installs.forEach(function(aInstall) {
+          aInstall.addListener(this);
+        }, this);
+
+        // Calling updateProgress can sometimes cause this notification to be
+        // removed in the middle of refreshing the notification panel which
+        // makes the panel get refreshed again. Just initialise to the
+        // undetermined state and then schedule a proper check at the next
+        // opportunity
+        this.setProgress(0, -1);
+        this._updateProgressTimeout = setTimeout(this.updateProgress.bind(this), 0);
+      ]]></constructor>
+
+      <destructor><![CDATA[
+        this.destroy();
+      ]]></destructor>
+
+      <field name="progressmeter" readonly="true">
+        document.getElementById("addon-progress-notification-progressmeter");
+      </field>
+      <field name="progresstext" readonly="true">
+        document.getElementById("addon-progress-notification-progresstext");
+      </field>
+      <property name="DownloadUtils" readonly="true">
+        <getter><![CDATA[
+          let module = {};
+          Components.utils.import("resource://gre/modules/DownloadUtils.jsm", module);
+          Object.defineProperty(this, "DownloadUtils", {
+            configurable: true,
+            enumerable: true,
+            writable: true,
+            value: module.DownloadUtils
+          });
+          return module.DownloadUtils;
+        ]]></getter>
+      </property>
+
+      <method name="destroy">
+        <body><![CDATA[
+          if (!this.notification)
+            return;
+
+          this.notification.options.installs.forEach(function(aInstall) {
+            aInstall.removeListener(this);
+          }, this);
+          clearTimeout(this._updateProgressTimeout);
+        ]]></body>
+      </method>
+
+      <method name="setProgress">
+        <parameter name="aProgress"/>
+        <parameter name="aMaxProgress"/>
+        <body><![CDATA[
+          if (aMaxProgress == -1) {
+            this.progressmeter.setAttribute("mode", "undetermined");
+          } else {
+            this.progressmeter.setAttribute("mode", "determined");
+            this.progressmeter.setAttribute("value", (aProgress * 100) / aMaxProgress);
+          }
+
+          let now = Date.now();
+
+          if (!this.notification.lastUpdate) {
+            this.notification.lastUpdate = now;
+            this.notification.lastProgress = aProgress;
+            return;
+          }
+
+          let delta = now - this.notification.lastUpdate;
+          if ((delta < 400) && (aProgress < aMaxProgress))
+            return;
+
+          delta /= 1000;
+
+          // This algorithm is the same used by the downloads code.
+          let speed = (aProgress - this.notification.lastProgress) / delta;
+          if (this.notification.speed)
+            speed = speed * 0.9 + this.notification.speed * 0.1;
+
+          this.notification.lastUpdate = now;
+          this.notification.lastProgress = aProgress;
+          this.notification.speed = speed;
+
+          let status = null;
+          [status, this.notification.last] = this.DownloadUtils.getDownloadStatus(aProgress, aMaxProgress, speed, this.notification.last);
+          this.progresstext.setAttribute("value", status);
+          this.progresstext.setAttribute("tooltiptext", status);
+        ]]></body>
+      </method>
+
+      <method name="cancel">
+        <body><![CDATA[
+          let installs = this.notification.options.installs;
+          installs.forEach(function(aInstall) {
+            try {
+              aInstall.cancel();
+            } catch (e) {
+              // Cancel will throw if the download has already failed
+            }
+          }, this);
+
+          PopupNotifications.remove(this.notification);
+        ]]></body>
+      </method>
+
+      <method name="updateProgress">
+        <body><![CDATA[
+          if (!this.notification)
+            return;
+
+          let downloadingCount = 0;
+          let progress = 0;
+          let maxProgress = 0;
+
+          this.notification.options.installs.forEach(function(aInstall) {
+            if (aInstall.maxProgress == -1)
+              maxProgress = -1;
+            progress += aInstall.progress;
+            if (maxProgress >= 0)
+              maxProgress += aInstall.maxProgress;
+            if (aInstall.state < AddonManager.STATE_DOWNLOADED)
+              downloadingCount++;
+          });
+
+          if (downloadingCount == 0) {
+            this.destroy();
+            if (Services.prefs.getBoolPref("xpinstall.customConfirmationUI", false)) {
+              this.progressmeter.setAttribute("mode", "undetermined");
+              let status = gNavigatorBundle.getString("addonDownloadVerifying");
+              this.progresstext.setAttribute("value", status);
+              this.progresstext.setAttribute("tooltiptext", status);
+            } else {
+              PopupNotifications.remove(this.notification);
+            }
+          } else {
+            this.setProgress(progress, maxProgress);
+          }
+        ]]></body>
+      </method>
+
+      <method name="onDownloadProgress">
+        <body><![CDATA[
+          this.updateProgress();
+        ]]></body>
+      </method>
+
+      <method name="onDownloadFailed">
+        <body><![CDATA[
+          this.updateProgress();
+        ]]></body>
+      </method>
+
+      <method name="onDownloadCancelled">
+        <body><![CDATA[
+          this.updateProgress();
+        ]]></body>
+      </method>
+
+      <method name="onDownloadEnded">
+        <body><![CDATA[
+          this.updateProgress();
+        ]]></body>
+      </method>
+    </implementation>
+  </binding>
+
+  <binding id="plugin-popupnotification-center-item">
+    <content align="center">
+      <xul:vbox pack="center" anonid="itemBox" class="itemBox">
+        <xul:description anonid="center-item-label" class="center-item-label" />
+        <xul:hbox flex="1" pack="start" align="center" anonid="center-item-warning">
+          <xul:image anonid="center-item-warning-icon" class="center-item-warning-icon"/>
+          <xul:label anonid="center-item-warning-label"/>
+          <xul:label anonid="center-item-link" value="&checkForUpdates;" class="text-link"/>
+        </xul:hbox>
+      </xul:vbox>
+      <xul:vbox pack="center">
+        <xul:menulist class="center-item-menulist"
+                      anonid="center-item-menulist">
+          <xul:menupopup>
+            <xul:menuitem anonid="allownow" value="allownow"
+                          label="&pluginActivateNow.label;" />
+            <xul:menuitem anonid="allowalways" value="allowalways"
+                          label="&pluginActivateAlways.label;" />
+            <xul:menuitem anonid="block" value="block"
+                          label="&pluginBlockNow.label;" />
+          </xul:menupopup>
+        </xul:menulist>
+      </xul:vbox>
+    </content>
+    <resources>
+      <stylesheet src="chrome://global/skin/notification.css"/>
+    </resources>
+    <implementation>
+      <constructor><![CDATA[
+        document.getAnonymousElementByAttribute(this, "anonid", "center-item-label").value = this.action.pluginName;
+
+        let curState = "block";
+        if (this.action.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE) {
+          if (this.action.pluginPermissionType == Ci.nsIPermissionManager.EXPIRE_SESSION) {
+            curState = "allownow";
+          } else {
+            curState = "allowalways";
+          }
+        }
+        document.getAnonymousElementByAttribute(this, "anonid", "center-item-menulist").value = curState;
+
+        let warningString = "";
+        let linkString = "";
+
+        let link = document.getAnonymousElementByAttribute(this, "anonid", "center-item-link");
+
+        let url;
+        let linkHandler;
+
+        if (this.action.pluginTag.enabledState == Ci.nsIPluginTag.STATE_DISABLED) {
+          document.getAnonymousElementByAttribute(this, "anonid", "center-item-menulist").hidden = true;
+          warningString = gNavigatorBundle.getString("pluginActivateDisabled.label");
+          linkString = gNavigatorBundle.getString("pluginActivateDisabled.manage");
+          linkHandler = function(event) {
+            event.preventDefault();
+            gPluginHandler.managePlugins();
+          };
+          document.getAnonymousElementByAttribute(this, "anonid", "center-item-warning-icon").hidden = true;
+        } else {
+          url = this.action.detailsLink;
+
+          switch (this.action.blocklistState) {
+          case Ci.nsIBlocklistService.STATE_NOT_BLOCKED:
+            document.getAnonymousElementByAttribute(this, "anonid", "center-item-warning").hidden = true;
+            break;
+          case Ci.nsIBlocklistService.STATE_BLOCKED:
+            document.getAnonymousElementByAttribute(this, "anonid", "center-item-menulist").hidden = true;
+            warningString = gNavigatorBundle.getString("pluginActivateBlocked.label");
+            linkString = gNavigatorBundle.getString("pluginActivate.learnMore");
+            break;
+          case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:
+            warningString = gNavigatorBundle.getString("pluginActivateOutdated.label");
+            linkString = gNavigatorBundle.getString("pluginActivate.updateLabel");
+            break;
+          case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:
+            warningString = gNavigatorBundle.getString("pluginActivateVulnerable.label");
+            linkString = gNavigatorBundle.getString("pluginActivate.riskLabel");
+            break;
+          }
+        }
+        document.getAnonymousElementByAttribute(this, "anonid", "center-item-warning-label").value = warningString;
+
+        let chromeWin = window.QueryInterface(Ci.nsIDOMChromeWindow);
+        let isWindowPrivate = PrivateBrowsingUtils.isWindowPrivate(chromeWin);
+
+        if (isWindowPrivate) {
+          // TODO: temporary compromise of hiding some privacy leaks, remove once bug 892487 is fixed
+          let allowalways = document.getAnonymousElementByAttribute(this, "anonid", "allowalways");
+          let block = document.getAnonymousElementByAttribute(this, "anonid", "block");
+          let allownow = document.getAnonymousElementByAttribute(this, "anonid", "allownow");
+
+          allowalways.hidden = curState !== "allowalways";
+          block.hidden       = curState !== "block";
+          allownow.hidden    = curState === "allowalways";
+        }
+
+        if (url || linkHandler) {
+          link.value = linkString;
+          if (url) {
+            link.href = url;
+          }
+          if (linkHandler) {
+            link.addEventListener("click", linkHandler);
+          }
+        } else {
+          link.hidden = true;
+        }
+      ]]></constructor>
+      <property name="value">
+        <getter>
+          return document.getAnonymousElementByAttribute(this, "anonid",
+                   "center-item-menulist").value;
+        </getter>
+        <setter><!-- This should be used only in automated tests -->
+          document.getAnonymousElementByAttribute(this, "anonid",
+                    "center-item-menulist").value = val;
+        </setter>
+      </property>
+    </implementation>
+  </binding>
+
+  <binding id="click-to-play-plugins-notification" extends="chrome://global/content/bindings/notification.xml#popup-notification">
+    <content align="start" style="width: &pluginNotification.width;;">
+      <xul:vbox flex="1" align="stretch" class="click-to-play-plugins-notification-main-box"
+                xbl:inherits="popupid">
+        <xul:hbox class="click-to-play-plugins-notification-description-box" flex="1" align="start">
+          <xul:description class="click-to-play-plugins-outer-description" flex="1">
+            <html:span anonid="click-to-play-plugins-notification-description" />
+            <html:br/>
+            <xul:label class="text-link click-to-play-plugins-notification-link popup-notification-learnmore-link"
+                       anonid="click-to-play-plugins-notification-link" />
+          </xul:description>
+        </xul:hbox>
+        <xul:grid anonid="click-to-play-plugins-notification-center-box"
+                  class="click-to-play-plugins-notification-center-box">
+          <xul:columns>
+            <xul:column flex="1"/>
+            <xul:column/>
+          </xul:columns>
+          <xul:rows>
+            <children includes="row"/>
+            <xul:hbox pack="start" anonid="plugin-notification-showbox">
+              <xul:button label="&pluginNotification.showAll.label;"
+                          accesskey="&pluginNotification.showAll.accesskey;"
+                          class="plugin-notification-showbutton"
+                          oncommand="document.getBindingParent(this)._setState(2)"/>
+            </xul:hbox>
+          </xul:rows>
+        </xul:grid>
+        <xul:hbox anonid="button-container"
+                  class="click-to-play-plugins-notification-button-container"
+                  pack="center" align="center">
+          <xul:button anonid="primarybutton"
+                      class="click-to-play-popup-button popup-notification-button"
+                      oncommand="document.getBindingParent(this)._onButton(this)"
+                      flex="1"/>
+          <xul:button anonid="secondarybutton"
+                      default="true"
+                      highlight="true"
+                      class="click-to-play-popup-button popup-notification-button"
+                      oncommand="document.getBindingParent(this)._onButton(this);"
+                      flex="1"/>
+        </xul:hbox>
+        <xul:box hidden="true">
+          <children/>
+        </xul:box>
+      </xul:vbox>
+    </content>
+    <resources>
+      <stylesheet src="chrome://global/skin/notification.css"/>
+    </resources>
+    <implementation>
+      <field name="_states">
+        ({SINGLE: 0, MULTI_COLLAPSED: 1, MULTI_EXPANDED: 2})
+      </field>
+      <field name="_primaryButton">
+        document.getAnonymousElementByAttribute(this, "anonid", "primarybutton");
+      </field>
+      <field name="_secondaryButton">
+        document.getAnonymousElementByAttribute(this, "anonid", "secondarybutton")
+      </field>
+      <field name="_buttonContainer">
+        document.getAnonymousElementByAttribute(this, "anonid", "button-container")
+      </field>
+      <field name="_brandShortName">
+        document.getElementById("bundle_brand").getString("brandShortName")
+      </field>
+      <field name="_items">[]</field>
+      <constructor><![CDATA[
+        const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+        let sortedActions = [];
+        for (let action of this.notification.options.pluginData.values()) {
+          sortedActions.push(action);
+        }
+        sortedActions.sort((a, b) => a.pluginName.localeCompare(b.pluginName));
+
+        for (let action of sortedActions) {
+          let item = document.createElementNS(XUL_NS, "row");
+          item.setAttribute("class", "plugin-popupnotification-centeritem");
+          item.action = action;
+          this.appendChild(item);
+          this._items.push(item);
+        }
+        switch (this._items.length) {
+          case 0:
+            PopupNotifications._dismiss();
+            break;
+          case 1:
+            this._setState(this._states.SINGLE);
+            break;
+          default:
+            if (this.notification.options.primaryPlugin) {
+              this._setState(this._states.MULTI_COLLAPSED);
+            } else {
+              this._setState(this._states.MULTI_EXPANDED);
+            }
+        }
+      ]]></constructor>
+      <method name="_setState">
+        <parameter name="state" />
+        <body><![CDATA[
+          var grid = document.getAnonymousElementByAttribute(this, "anonid", "click-to-play-plugins-notification-center-box");
+
+          if (this._states.SINGLE == state) {
+            grid.hidden = true;
+            this._setupSingleState();
+            return;
+          }
+
+          let prePath = this.notification.options.principal.URI.prePath;
+          this._setupDescription("pluginActivateMultiple.message", null, prePath);
+
+          var showBox = document.getAnonymousElementByAttribute(this, "anonid", "plugin-notification-showbox");
+
+          var dialogStrings = Services.strings.createBundle("chrome://global/locale/dialog.properties");
+          this._primaryButton.label = dialogStrings.GetStringFromName("button-accept");
+          this._primaryButton.setAttribute("default", "true");
+
+          this._secondaryButton.label = dialogStrings.GetStringFromName("button-cancel");
+          this._primaryButton.setAttribute("action", "_multiAccept");
+          this._secondaryButton.setAttribute("action", "_cancel");
+
+          grid.hidden = false;
+
+          if (this._states.MULTI_COLLAPSED == state) {
+            for (let child of this.childNodes) {
+              if (child.tagName != "row") {
+                continue;
+              }
+              child.hidden = this.notification.options.primaryPlugin !=
+                             child.action.permissionString;
+            }
+            showBox.hidden = false;
+          } else {
+            for (let child of this.childNodes) {
+              if (child.tagName != "row") {
+                continue;
+              }
+              child.hidden = false;
+            }
+            showBox.hidden = true;
+          }
+          this._setupLink(null);
+        ]]></body>
+      </method>
+      <method name="_setupSingleState">
+        <body><![CDATA[
+          var action = this._items[0].action;
+          var prePath = action.pluginPermissionPrePath;
+          let chromeWin = window.QueryInterface(Ci.nsIDOMChromeWindow);
+          let isWindowPrivate = PrivateBrowsingUtils.isWindowPrivate(chromeWin);
+
+          let label, linkLabel, button1, button2;
+
+          if (action.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE) {
+            button1 = {
+              label: "pluginBlockNow.label",
+              accesskey: "pluginBlockNow.accesskey",
+              action: "_singleBlock"
+            };
+            button2 = {
+              label: "pluginContinue.label",
+              accesskey: "pluginContinue.accesskey",
+              action: "_singleContinue",
+              default: true
+            };
+            switch (action.blocklistState) {
+            case Ci.nsIBlocklistService.STATE_NOT_BLOCKED:
+              label = "pluginEnabled.message";
+              linkLabel = "pluginActivate.learnMore";
+              break;
+
+            case Ci.nsIBlocklistService.STATE_BLOCKED:
+              Cu.reportError(Error("Cannot happen!"));
+              break;
+
+            case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:
+              label = "pluginEnabledOutdated.message";
+              linkLabel = "pluginActivate.updateLabel";
+              break;
+
+            case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:
+              label = "pluginEnabledVulnerable.message";
+              linkLabel = "pluginActivate.riskLabel"
+              break;
+
+            default:
+              Cu.reportError(Error("Unexpected blocklist state"));
+            }
+
+            // TODO: temporary compromise, remove this once bug 892487 is fixed
+            if (isWindowPrivate) {
+              this._buttonContainer.hidden = true;
+            }
+          } else if (action.pluginTag.enabledState == Ci.nsIPluginTag.STATE_DISABLED) {
+            let linkElement =
+              document.getAnonymousElementByAttribute(
+                         this, "anonid", "click-to-play-plugins-notification-link");
+            linkElement.textContent = gNavigatorBundle.getString("pluginActivateDisabled.manage");
+            linkElement.setAttribute("onclick", "gPluginHandler.managePlugins()");
+
+            let descElement = document.getAnonymousElementByAttribute(this, "anonid", "click-to-play-plugins-notification-description");
+            descElement.textContent = gNavigatorBundle.getFormattedString(
+              "pluginActivateDisabled.message", [action.pluginName, this._brandShortName]) + " ";
+            this._buttonContainer.hidden = true;
+            return;
+          } else if (action.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {
+            let descElement = document.getAnonymousElementByAttribute(this, "anonid", "click-to-play-plugins-notification-description");
+            descElement.textContent = gNavigatorBundle.getFormattedString(
+              "pluginActivateBlocked.message", [action.pluginName, this._brandShortName]) + " ";
+            this._setupLink("pluginActivate.learnMore", action.detailsLink);
+            this._buttonContainer.hidden = true;
+            return;
+          } else {
+            button1 = {
+              label: "pluginActivateNow.label",
+              accesskey: "pluginActivateNow.accesskey",
+              action: "_singleActivateNow"
+            };
+            button2 = {
+              label: "pluginActivateAlways.label",
+              accesskey: "pluginActivateAlways.accesskey",
+              action: "_singleActivateAlways"
+            };
+            switch (action.blocklistState) {
+            case Ci.nsIBlocklistService.STATE_NOT_BLOCKED:
+              label = "pluginActivate2.message";
+              linkLabel = "pluginActivate.learnMore";
+              button2.default = true;
+              break;
+
+            case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:
+              label = "pluginActivateOutdated.message";
+              linkLabel = "pluginActivate.updateLabel";
+              button1.default = true;
+              break;
+
+            case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:
+              label = "pluginActivateVulnerable.message";
+              linkLabel = "pluginActivate.riskLabel"
+              button1.default = true;
+              break;
+
+            default:
+              Cu.reportError(Error("Unexpected blocklist state"));
+            }
+
+            // TODO: temporary compromise, remove this once bug 892487 is fixed
+            if (isWindowPrivate) {
+              button1.default = true;
+              this._secondaryButton.hidden = true;
+            }
+          }
+          this._setupDescription(label, action.pluginName, prePath);
+          this._setupLink(linkLabel, action.detailsLink);
+
+          this._primaryButton.label = gNavigatorBundle.getString(button1.label);
+          this._primaryButton.accessKey = gNavigatorBundle.getString(button1.accesskey);
+          this._primaryButton.setAttribute("action", button1.action);
+
+          this._secondaryButton.label = gNavigatorBundle.getString(button2.label);
+          this._secondaryButton.accessKey = gNavigatorBundle.getString(button2.accesskey);
+          this._secondaryButton.setAttribute("action", button2.action);
+          if (button1.default) {
+            this._primaryButton.setAttribute("default", "true");
+          } else if (button2.default) {
+            this._secondaryButton.setAttribute("default", "true");
+          }
+        ]]></body>
+      </method>
+      <method name="_setupDescription">
+        <parameter name="baseString" />
+        <parameter name="pluginName" /> <!-- null for the multiple-plugin case -->
+        <parameter name="prePath" />
+        <body><![CDATA[
+          var span = document.getAnonymousElementByAttribute(this, "anonid", "click-to-play-plugins-notification-description");
+          while (span.lastChild) {
+            span.removeChild(span.lastChild);
+          }
+
+          var args = ["__prepath__", this._brandShortName];
+          if (pluginName) {
+            args.unshift(pluginName);
+          }
+          var bases = gNavigatorBundle.getFormattedString(baseString, args).
+            split("__prepath__", 2);
+
+          span.appendChild(document.createTextNode(bases[0]));
+          var prePathSpan = document.createElementNS("http://www.w3.org/1999/xhtml", "em");
+          prePathSpan.appendChild(document.createTextNode(prePath));
+          span.appendChild(prePathSpan);
+          span.appendChild(document.createTextNode(bases[1] + " "));
+        ]]></body>
+      </method>
+      <method name="_setupLink">
+        <parameter name="linkString"/>
+        <parameter name="linkUrl" />
+        <body><![CDATA[
+          var link = document.getAnonymousElementByAttribute(this, "anonid", "click-to-play-plugins-notification-link");
+          if (!linkString || !linkUrl) {
+            link.hidden = true;
+            return;
+          }
+
+          link.hidden = false;
+          link.textContent = gNavigatorBundle.getString(linkString);
+          link.href = linkUrl;
+        ]]></body>
+      </method>
+      <method name="_onButton">
+        <parameter name="aButton" />
+        <body><![CDATA[
+          let methodName = aButton.getAttribute("action");
+          this[methodName]();
+        ]]></body>
+      </method>
+      <method name="_singleActivateNow">
+        <body><![CDATA[
+          gPluginHandler._updatePluginPermission(this.notification,
+            this._items[0].action,
+            "allownow");
+          this._cancel();
+        ]]></body>
+      </method>
+      <method name="_singleBlock">
+        <body><![CDATA[
+          gPluginHandler._updatePluginPermission(this.notification,
+            this._items[0].action,
+            "block");
+            this._cancel();
+        ]]></body>
+      </method>
+      <method name="_singleActivateAlways">
+        <body><![CDATA[
+          gPluginHandler._updatePluginPermission(this.notification,
+            this._items[0].action,
+            "allowalways");
+          this._cancel();
+        ]]></body>
+      </method>
+      <method name="_singleContinue">
+        <body><![CDATA[
+          gPluginHandler._updatePluginPermission(this.notification,
+            this._items[0].action,
+            "continue");
+          this._cancel();
+        ]]></body>
+      </method>
+      <method name="_multiAccept">
+        <body><![CDATA[
+          for (let item of this._items) {
+            let action = item.action;
+            if (action.pluginTag.enabledState == Ci.nsIPluginTag.STATE_DISABLED ||
+                action.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {
+              continue;
+            }
+            gPluginHandler._updatePluginPermission(this.notification,
+              item.action, item.value);
+          }
+          this._cancel();
+        ]]></body>
+      </method>
+      <method name="_cancel">
+        <body><![CDATA[
+          PopupNotifications._dismiss();
+        ]]></body>
+      </method>
+      <method name="_accept">
+        <parameter name="aEvent" />
+        <body><![CDATA[
+          if (aEvent.defaultPrevented)
+            return;
+          aEvent.preventDefault();
+          if (this._primaryButton.getAttribute("default") == "true") {
+            this._primaryButton.click();
+          } else if (this._secondaryButton.getAttribute("default") == "true") {
+            this._secondaryButton.click();
+          }
+        ]]></body>
+      </method>
+    </implementation>
+    <handlers>
+      <!-- The _accept method checks for .defaultPrevented so that if focus is in a button,
+           enter activates the button and not this default action -->
+      <handler event="keypress" keycode="VK_RETURN" group="system" action="this._accept(event);"/>
+    </handlers>
+  </binding>
+</bindings>
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -43,16 +43,17 @@ browser.jar:
         content/browser/illustrations/error-malformed-url.svg (content/illustrations/error-malformed-url.svg)
         content/browser/aboutNetError.xhtml            (content/aboutNetError.xhtml)
         content/browser/aboutRobots-icon.png          (content/aboutRobots-icon.png)
         content/browser/aboutRobots-widget-left.png   (content/aboutRobots-widget-left.png)
         content/browser/aboutTabCrashed.css           (content/aboutTabCrashed.css)
         content/browser/aboutTabCrashed.js            (content/aboutTabCrashed.js)
         content/browser/aboutTabCrashed.xhtml         (content/aboutTabCrashed.xhtml)
 *       content/browser/browser.css                   (content/browser.css)
+        content/browser/browser-bundle.js             (content/browser-bundle.js)
         content/browser/browser.js                    (content/browser.js)
 *       content/browser/browser.xul                   (content/browser.xul)
         content/browser/browser-addons.js             (content/browser-addons.js)
         content/browser/browser-captivePortal.js      (content/browser-captivePortal.js)
         content/browser/browser-ctrlTab.js            (content/browser-ctrlTab.js)
         content/browser/browser-customization.js      (content/browser-customization.js)
         content/browser/browser-data-submission-info-bar.js (content/browser-data-submission-info-bar.js)
         content/browser/browser-compacttheme.js       (content/browser-compacttheme.js)
diff --git a/browser/base/jar.mn.orig b/browser/base/jar.mn.orig
new file mode 100644
--- /dev/null
+++ b/browser/base/jar.mn.orig
@@ -0,0 +1,159 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+browser.jar:
+%  content browser %content/browser/ contentaccessible=yes
+#ifdef XP_MACOSX
+%  overlay chrome://mozapps/content/update/updates.xul chrome://browser/content/softwareUpdateOverlay.xul
+#endif
+%  overlay chrome://global/content/viewSource.xul chrome://browser/content/viewSourceOverlay.xul
+%  overlay chrome://global/content/viewPartialSource.xul chrome://browser/content/viewSourceOverlay.xul
+
+        content/browser/aboutDialog-appUpdater.js     (content/aboutDialog-appUpdater.js)
+*       content/browser/aboutDialog.xul               (content/aboutDialog.xul)
+        content/browser/aboutDialog.js                (content/aboutDialog.js)
+        content/browser/aboutDialog.css               (content/aboutDialog.css)
+        content/browser/aboutRobots.xhtml             (content/aboutRobots.xhtml)
+*       content/browser/abouthome/aboutHome.xhtml     (content/abouthome/aboutHome.xhtml)
+        content/browser/abouthome/aboutHome.js        (content/abouthome/aboutHome.js)
+*       content/browser/abouthome/aboutHome.css       (content/abouthome/aboutHome.css)
+        content/browser/abouthome/snippet1.png        (content/abouthome/snippet1.png)
+        content/browser/abouthome/snippet2.png        (content/abouthome/snippet2.png)
+        content/browser/abouthome/downloads.png       (content/abouthome/downloads.png)
+        content/browser/abouthome/bookmarks.png       (content/abouthome/bookmarks.png)
+        content/browser/abouthome/history.png         (content/abouthome/history.png)
+        content/browser/abouthome/addons.png          (content/abouthome/addons.png)
+        content/browser/abouthome/sync.png            (content/abouthome/sync.png)
+        content/browser/abouthome/settings.png        (content/abouthome/settings.png)
+        content/browser/abouthome/restore.png         (content/abouthome/restore.png)
+        content/browser/abouthome/restore-large.png   (content/abouthome/restore-large.png)
+        content/browser/abouthome/snippet1@2x.png      (content/abouthome/snippet1@2x.png)
+        content/browser/abouthome/snippet2@2x.png      (content/abouthome/snippet2@2x.png)
+        content/browser/abouthome/downloads@2x.png     (content/abouthome/downloads@2x.png)
+        content/browser/abouthome/bookmarks@2x.png     (content/abouthome/bookmarks@2x.png)
+        content/browser/abouthome/history@2x.png       (content/abouthome/history@2x.png)
+        content/browser/abouthome/addons@2x.png        (content/abouthome/addons@2x.png)
+        content/browser/abouthome/sync@2x.png          (content/abouthome/sync@2x.png)
+        content/browser/abouthome/settings@2x.png      (content/abouthome/settings@2x.png)
+        content/browser/abouthome/restore@2x.png       (content/abouthome/restore@2x.png)
+        content/browser/abouthome/restore-large@2x.png (content/abouthome/restore-large@2x.png)
+
+        content/browser/illustrations/error-connection-failure.svg (content/illustrations/error-connection-failure.svg)
+        content/browser/illustrations/error-server-not-found.svg (content/illustrations/error-server-not-found.svg)
+        content/browser/illustrations/error-malformed-url.svg (content/illustrations/error-malformed-url.svg)
+        content/browser/aboutNetError.xhtml            (content/aboutNetError.xhtml)
+        content/browser/aboutRobots-icon.png          (content/aboutRobots-icon.png)
+        content/browser/aboutRobots-widget-left.png   (content/aboutRobots-widget-left.png)
+        content/browser/aboutTabCrashed.css           (content/aboutTabCrashed.css)
+        content/browser/aboutTabCrashed.js            (content/aboutTabCrashed.js)
+        content/browser/aboutTabCrashed.xhtml         (content/aboutTabCrashed.xhtml)
+*       content/browser/browser.css                   (content/browser.css)
+        content/browser/browser.js                    (content/browser.js)
+*       content/browser/browser.xul                   (content/browser.xul)
+        content/browser/browser-addons.js             (content/browser-addons.js)
+        content/browser/browser-captivePortal.js      (content/browser-captivePortal.js)
+        content/browser/browser-ctrlTab.js            (content/browser-ctrlTab.js)
+        content/browser/browser-customization.js      (content/browser-customization.js)
+        content/browser/browser-data-submission-info-bar.js (content/browser-data-submission-info-bar.js)
+        content/browser/browser-compacttheme.js       (content/browser-compacttheme.js)
+#ifndef MOZILLA_OFFICIAL
+        content/browser/browser-development-helpers.js (content/browser-development-helpers.js)
+#endif
+        content/browser/browser-feeds.js              (content/browser-feeds.js)
+        content/browser/browser-fullScreenAndPointerLock.js  (content/browser-fullScreenAndPointerLock.js)
+        content/browser/browser-fullZoom.js           (content/browser-fullZoom.js)
+        content/browser/browser-gestureSupport.js     (content/browser-gestureSupport.js)
+        content/browser/browser-media.js              (content/browser-media.js)
+        content/browser/browser-pageActions.js        (content/browser-pageActions.js)
+        content/browser/browser-places.js             (content/browser-places.js)
+        content/browser/browser-plugins.js            (content/browser-plugins.js)
+        content/browser/browser-safebrowsing.js       (content/browser-safebrowsing.js)
+        content/browser/browser-sidebar.js            (content/browser-sidebar.js)
+        content/browser/browser-sync.js               (content/browser-sync.js)
+*       content/browser/browser-tabPreviews.xml       (content/browser-tabPreviews.xml)
+#ifdef CAN_DRAW_IN_TITLEBAR
+        content/browser/browser-tabsintitlebar.js       (content/browser-tabsintitlebar.js)
+#else
+        content/browser/browser-tabsintitlebar.js       (content/browser-tabsintitlebar-stub.js)
+#endif
+        content/browser/browser-thumbnails.js         (content/browser-thumbnails.js)
+        content/browser/browser-trackingprotection.js (content/browser-trackingprotection.js)
+        content/browser/tab-content.js                (content/tab-content.js)
+        content/browser/content.js                    (content/content.js)
+*       content/browser/customelements/custom-elements.js (content/customelements/custom-elements.js)
+        content/browser/default-theme-icon.svg        (content/default-theme-icon.svg)
+        content/browser/defaultthemes/1.header.jpg    (content/defaultthemes/1.header.jpg)
+        content/browser/defaultthemes/1.icon.jpg      (content/defaultthemes/1.icon.jpg)
+        content/browser/defaultthemes/1.preview.jpg   (content/defaultthemes/1.preview.jpg)
+        content/browser/defaultthemes/2.header.jpg    (content/defaultthemes/2.header.jpg)
+        content/browser/defaultthemes/2.icon.jpg      (content/defaultthemes/2.icon.jpg)
+        content/browser/defaultthemes/2.preview.jpg   (content/defaultthemes/2.preview.jpg)
+        content/browser/defaultthemes/3.header.png    (content/defaultthemes/3.header.png)
+        content/browser/defaultthemes/3.icon.png      (content/defaultthemes/3.icon.png)
+        content/browser/defaultthemes/3.preview.png   (content/defaultthemes/3.preview.png)
+        content/browser/defaultthemes/4.header.png    (content/defaultthemes/4.header.png)
+        content/browser/defaultthemes/4.icon.png      (content/defaultthemes/4.icon.png)
+        content/browser/defaultthemes/4.preview.png   (content/defaultthemes/4.preview.png)
+        content/browser/defaultthemes/5.header.png    (content/defaultthemes/5.header.png)
+        content/browser/defaultthemes/5.icon.jpg      (content/defaultthemes/5.icon.jpg)
+        content/browser/defaultthemes/5.preview.jpg   (content/defaultthemes/5.preview.jpg)
+        content/browser/defaultthemes/compact.header.png    (content/defaultthemes/compact.header.png)
+        content/browser/defaultthemes/dark.icon.svg  (content/defaultthemes/dark.icon.svg)
+        content/browser/defaultthemes/light.icon.svg (content/defaultthemes/light.icon.svg)
+        content/browser/newtab/newTab.xhtml           (content/newtab/newTab.xhtml)
+*       content/browser/newtab/newTab.js              (content/newtab/newTab.js)
+        content/browser/newtab/newTab.css             (content/newtab/newTab.css)
+        content/browser/newtab/alternativeDefaultSites.json   (content/newtab/alternativeDefaultSites.json)
+*       content/browser/pageinfo/pageInfo.xul         (content/pageinfo/pageInfo.xul)
+        content/browser/pageinfo/pageInfo.js          (content/pageinfo/pageInfo.js)
+        content/browser/pageinfo/pageInfo.css         (content/pageinfo/pageInfo.css)
+        content/browser/pageinfo/feeds.js             (content/pageinfo/feeds.js)
+        content/browser/pageinfo/feeds.xml            (content/pageinfo/feeds.xml)
+        content/browser/pageinfo/permissions.js       (content/pageinfo/permissions.js)
+        content/browser/pageinfo/security.js          (content/pageinfo/security.js)
+        content/browser/robot.ico                     (content/robot.ico)
+        content/browser/static-robot.png              (content/static-robot.png)
+        content/browser/safeMode.css                  (content/safeMode.css)
+        content/browser/safeMode.js                   (content/safeMode.js)
+        content/browser/safeMode.xul                  (content/safeMode.xul)
+        content/browser/sanitize.js                   (content/sanitize.js)
+        content/browser/sanitize.xul                  (content/sanitize.xul)
+        content/browser/sanitizeDialog.js             (content/sanitizeDialog.js)
+        content/browser/sanitizeDialog.css            (content/sanitizeDialog.css)
+        content/browser/contentSearchUI.js            (content/contentSearchUI.js)
+        content/browser/contentSearchUI.css           (content/contentSearchUI.css)
+        content/browser/tabbrowser.css                (content/tabbrowser.css)
+        content/browser/tabbrowser.xml                (content/tabbrowser.xml)
+*       content/browser/urlbarBindings.xml            (content/urlbarBindings.xml)
+        content/browser/utilityOverlay.js             (content/utilityOverlay.js)
+        content/browser/web-panels.js                 (content/web-panels.js)
+*       content/browser/web-panels.xul                (content/web-panels.xul)
+        content/browser/webext-panels.js              (content/webext-panels.js)
+*       content/browser/webext-panels.xul             (content/webext-panels.xul)
+*       content/browser/baseMenuOverlay.xul           (content/baseMenuOverlay.xul)
+        content/browser/nsContextMenu.js              (content/nsContextMenu.js)
+# XXX: We should exclude this one as well (bug 71895)
+*       content/browser/hiddenWindow.xul              (content/hiddenWindow.xul)
+#ifdef XP_MACOSX
+*       content/browser/macBrowserOverlay.xul         (content/macBrowserOverlay.xul)
+*       content/browser/softwareUpdateOverlay.xul     (content/softwareUpdateOverlay.xul)
+#endif
+*       content/browser/viewSourceOverlay.xul         (content/viewSourceOverlay.xul)
+#ifndef XP_MACOSX
+*       content/browser/webrtcIndicator.xul           (content/webrtcIndicator.xul)
+        content/browser/webrtcIndicator.js            (content/webrtcIndicator.js)
+#endif
+# the following files are browser-specific overrides
+*       content/browser/license.html                  (/toolkit/content/license.html)
+% override chrome://global/content/license.html chrome://browser/content/license.html
+        content/browser/report-phishing-overlay.xul     (content/report-phishing-overlay.xul)
+        content/browser/blockedSite.xhtml               (content/blockedSite.xhtml)
+% overlay chrome://browser/content/browser.xul chrome://browser/content/report-phishing-overlay.xul
+
+% override chrome://global/content/netError.xhtml chrome://browser/content/aboutNetError.xhtml
+
+# L10n resources and overrides.
+% override chrome://global/locale/appstrings.properties chrome://browser/locale/appstrings.properties
+% override chrome://global/locale/netError.dtd chrome://browser/locale/netError.dtd
+% override chrome://mozapps/locale/downloads/settingsChange.dtd chrome://browser/locale/downloads/settingsChange.dtd
+% resource search-plugins chrome://browser/locale/searchplugins/
diff --git a/browser/base/package-lock.json b/browser/base/package-lock.json
new file mode 100644
--- /dev/null
+++ b/browser/base/package-lock.json
@@ -0,0 +1,3728 @@
+{
+  "name": "async-await",
+  "version": "1.0.0",
+  "lockfileVersion": 1,
+  "requires": true,
+  "dependencies": {
+    "acorn": {
+      "version": "5.3.0",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-5.3.0.tgz",
+      "integrity": "sha512-Yej+zOJ1Dm/IMZzzj78OntP/r3zHEaKcyNoU2lAaxPtrseM6rF0xwqoz5Q5ysAiED9hTjI2hgtvLXitlCN1/Ug==",
+      "dev": true
+    },
+    "acorn-dynamic-import": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/acorn-dynamic-import/-/acorn-dynamic-import-2.0.2.tgz",
+      "integrity": "sha1-x1K9IQvvZ5UBtsbLf8hPj0cVjMQ=",
+      "dev": true,
+      "requires": {
+        "acorn": "4.0.13"
+      },
+      "dependencies": {
+        "acorn": {
+          "version": "4.0.13",
+          "resolved": "https://registry.npmjs.org/acorn/-/acorn-4.0.13.tgz",
+          "integrity": "sha1-EFSVrlNh1pe9GVyCUZLhrX8lN4c=",
+          "dev": true
+        }
+      }
+    },
+    "ajv": {
+      "version": "5.5.2",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-5.5.2.tgz",
+      "integrity": "sha1-c7Xuyj+rZT49P5Qis0GtQiBdyWU=",
+      "dev": true,
+      "requires": {
+        "co": "4.6.0",
+        "fast-deep-equal": "1.0.0",
+        "fast-json-stable-stringify": "2.0.0",
+        "json-schema-traverse": "0.3.1"
+      }
+    },
+    "ajv-keywords": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-2.1.1.tgz",
+      "integrity": "sha1-YXmX/F9gV2iUxDX5QNgZ4TW4B2I=",
+      "dev": true
+    },
+    "align-text": {
+      "version": "0.1.4",
+      "resolved": "https://registry.npmjs.org/align-text/-/align-text-0.1.4.tgz",
+      "integrity": "sha1-DNkKVhCT810KmSVsIrcGlDP60Rc=",
+      "dev": true,
+      "requires": {
+        "kind-of": "3.2.2",
+        "longest": "1.0.1",
+        "repeat-string": "1.6.1"
+      }
+    },
+    "ansi-regex": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
+      "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8=",
+      "dev": true
+    },
+    "ansi-styles": {
+      "version": "2.2.1",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
+      "integrity": "sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4=",
+      "dev": true
+    },
+    "anymatch": {
+      "version": "1.3.2",
+      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-1.3.2.tgz",
+      "integrity": "sha512-0XNayC8lTHQ2OI8aljNCN3sSx6hsr/1+rlcDAotXJR7C1oZZHCNsfpbKwMjRA3Uqb5tF1Rae2oloTr4xpq+WjA==",
+      "dev": true,
+      "requires": {
+        "micromatch": "2.3.11",
+        "normalize-path": "2.1.1"
+      }
+    },
+    "arr-diff": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/arr-diff/-/arr-diff-2.0.0.tgz",
+      "integrity": "sha1-jzuCf5Vai9ZpaX5KQlasPOrjVs8=",
+      "dev": true,
+      "requires": {
+        "arr-flatten": "1.1.0"
+      }
+    },
+    "arr-flatten": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/arr-flatten/-/arr-flatten-1.1.0.tgz",
+      "integrity": "sha512-L3hKV5R/p5o81R7O02IGnwpDmkp6E982XhtbuwSe3O4qOtMMMtodicASA1Cny2U+aCXcNpml+m4dPsvsJ3jatg==",
+      "dev": true
+    },
+    "array-unique": {
+      "version": "0.2.1",
+      "resolved": "https://registry.npmjs.org/array-unique/-/array-unique-0.2.1.tgz",
+      "integrity": "sha1-odl8yvy8JiXMcPrc6zalDFiwGlM=",
+      "dev": true
+    },
+    "asn1.js": {
+      "version": "4.9.2",
+      "resolved": "https://registry.npmjs.org/asn1.js/-/asn1.js-4.9.2.tgz",
+      "integrity": "sha512-b/OsSjvWEo8Pi8H0zsDd2P6Uqo2TK2pH8gNLSJtNLM2Db0v2QaAZ0pBQJXVjAn4gBuugeVDr7s63ZogpUIwWDg==",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "inherits": "2.0.3",
+        "minimalistic-assert": "1.0.0"
+      }
+    },
+    "assert": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/assert/-/assert-1.4.1.tgz",
+      "integrity": "sha1-mZEtWRg2tab1s0XA8H7vwI/GXZE=",
+      "dev": true,
+      "requires": {
+        "util": "0.10.3"
+      }
+    },
+    "async": {
+      "version": "2.6.0",
+      "resolved": "https://registry.npmjs.org/async/-/async-2.6.0.tgz",
+      "integrity": "sha512-xAfGg1/NTLBBKlHFmnd7PlmUW9KhVQIUuSrYem9xzFUZy13ScvtyGGejaae9iAVRiRq9+Cx7DPFaAAhCpyxyPw==",
+      "dev": true,
+      "requires": {
+        "lodash": "4.17.4"
+      }
+    },
+    "async-each": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/async-each/-/async-each-1.0.1.tgz",
+      "integrity": "sha1-GdOGodntxufByF04iu28xW0zYC0=",
+      "dev": true
+    },
+    "babel-code-frame": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz",
+      "integrity": "sha1-Y/1D99weO7fONZR9uP42mj9Yx0s=",
+      "dev": true,
+      "requires": {
+        "chalk": "1.1.3",
+        "esutils": "2.0.2",
+        "js-tokens": "3.0.2"
+      }
+    },
+    "babel-helper-call-delegate": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-helper-call-delegate/-/babel-helper-call-delegate-6.24.1.tgz",
+      "integrity": "sha1-7Oaqzdx25Bw0YfiL/Fdb0Nqi340=",
+      "dev": true,
+      "requires": {
+        "babel-helper-hoist-variables": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-helper-define-map": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-helper-define-map/-/babel-helper-define-map-6.26.0.tgz",
+      "integrity": "sha1-pfVtq0GiX5fstJjH66ypgZ+Vvl8=",
+      "dev": true,
+      "requires": {
+        "babel-helper-function-name": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0",
+        "lodash": "4.17.4"
+      }
+    },
+    "babel-helper-function-name": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-helper-function-name/-/babel-helper-function-name-6.24.1.tgz",
+      "integrity": "sha1-00dbjAPtmCQqJbSDUasYOZ01gKk=",
+      "dev": true,
+      "requires": {
+        "babel-helper-get-function-arity": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-helper-get-function-arity": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-helper-get-function-arity/-/babel-helper-get-function-arity-6.24.1.tgz",
+      "integrity": "sha1-j3eCqpNAfEHTqlCQj4mwMbG2hT0=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-helper-hoist-variables": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-helper-hoist-variables/-/babel-helper-hoist-variables-6.24.1.tgz",
+      "integrity": "sha1-HssnaJydJVE+rbyZFKc/VAi+enY=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-helper-optimise-call-expression": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-helper-optimise-call-expression/-/babel-helper-optimise-call-expression-6.24.1.tgz",
+      "integrity": "sha1-96E0J7qfc/j0+pk8VKl4gtEkQlc=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-helper-regex": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-helper-regex/-/babel-helper-regex-6.26.0.tgz",
+      "integrity": "sha1-MlxZ+QL4LyS3T6zu0DY5VPZJXnI=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0",
+        "lodash": "4.17.4"
+      }
+    },
+    "babel-helper-replace-supers": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-helper-replace-supers/-/babel-helper-replace-supers-6.24.1.tgz",
+      "integrity": "sha1-v22/5Dk40XNpohPKiov3S2qQqxo=",
+      "dev": true,
+      "requires": {
+        "babel-helper-optimise-call-expression": "6.24.1",
+        "babel-messages": "6.23.0",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-messages": {
+      "version": "6.23.0",
+      "resolved": "https://registry.npmjs.org/babel-messages/-/babel-messages-6.23.0.tgz",
+      "integrity": "sha1-8830cDhYA1sqKVHG7F7fbGLyYw4=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-check-es2015-constants": {
+      "version": "6.22.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-check-es2015-constants/-/babel-plugin-check-es2015-constants-6.22.0.tgz",
+      "integrity": "sha1-NRV7EBQm/S/9PaP3XH0ekYNbv4o=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-arrow-functions": {
+      "version": "6.22.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-arrow-functions/-/babel-plugin-transform-es2015-arrow-functions-6.22.0.tgz",
+      "integrity": "sha1-RSaSy3EdX3ncf4XkQM5BufJE0iE=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-block-scoped-functions": {
+      "version": "6.22.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoped-functions/-/babel-plugin-transform-es2015-block-scoped-functions-6.22.0.tgz",
+      "integrity": "sha1-u8UbSflk1wy42OC5ToICRs46YUE=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-block-scoping": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoping/-/babel-plugin-transform-es2015-block-scoping-6.26.0.tgz",
+      "integrity": "sha1-1w9SmcEwjQXBL0Y4E7CgnnOxiV8=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0",
+        "lodash": "4.17.4"
+      }
+    },
+    "babel-plugin-transform-es2015-classes": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-classes/-/babel-plugin-transform-es2015-classes-6.24.1.tgz",
+      "integrity": "sha1-WkxYpQyclGHlZLSyo7+ryXolhNs=",
+      "dev": true,
+      "requires": {
+        "babel-helper-define-map": "6.26.0",
+        "babel-helper-function-name": "6.24.1",
+        "babel-helper-optimise-call-expression": "6.24.1",
+        "babel-helper-replace-supers": "6.24.1",
+        "babel-messages": "6.23.0",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-computed-properties": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-computed-properties/-/babel-plugin-transform-es2015-computed-properties-6.24.1.tgz",
+      "integrity": "sha1-b+Ko0WiV1WNPTNmZttNICjCBWbM=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-destructuring": {
+      "version": "6.23.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-destructuring/-/babel-plugin-transform-es2015-destructuring-6.23.0.tgz",
+      "integrity": "sha1-mXux8auWf2gtKwh2/jWNYOdlxW0=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-duplicate-keys": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-duplicate-keys/-/babel-plugin-transform-es2015-duplicate-keys-6.24.1.tgz",
+      "integrity": "sha1-c+s9MQypaePvnskcU3QabxV2Qj4=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-for-of": {
+      "version": "6.23.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-for-of/-/babel-plugin-transform-es2015-for-of-6.23.0.tgz",
+      "integrity": "sha1-9HyVsrYT3x0+zC/bdXNiPHUkhpE=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-function-name": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-function-name/-/babel-plugin-transform-es2015-function-name-6.24.1.tgz",
+      "integrity": "sha1-g0yJhTvDaxrw86TF26qU/Y6sqos=",
+      "dev": true,
+      "requires": {
+        "babel-helper-function-name": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-literals": {
+      "version": "6.22.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-literals/-/babel-plugin-transform-es2015-literals-6.22.0.tgz",
+      "integrity": "sha1-T1SgLWzWbPkVKAAZox0xklN3yi4=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-modules-amd": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-modules-amd/-/babel-plugin-transform-es2015-modules-amd-6.24.1.tgz",
+      "integrity": "sha1-Oz5UAXI5hC1tGcMBHEvS8AoA0VQ=",
+      "dev": true,
+      "requires": {
+        "babel-plugin-transform-es2015-modules-commonjs": "6.26.0",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-modules-commonjs": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-modules-commonjs/-/babel-plugin-transform-es2015-modules-commonjs-6.26.0.tgz",
+      "integrity": "sha1-DYOUApt9xqvhqX7xgeAHWN0uXYo=",
+      "dev": true,
+      "requires": {
+        "babel-plugin-transform-strict-mode": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-modules-systemjs": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-modules-systemjs/-/babel-plugin-transform-es2015-modules-systemjs-6.24.1.tgz",
+      "integrity": "sha1-/4mhQrkRmpBhlfXxBuzzBdlAfSM=",
+      "dev": true,
+      "requires": {
+        "babel-helper-hoist-variables": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-modules-umd": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-modules-umd/-/babel-plugin-transform-es2015-modules-umd-6.24.1.tgz",
+      "integrity": "sha1-rJl+YoXNGO1hdq22B9YCNErThGg=",
+      "dev": true,
+      "requires": {
+        "babel-plugin-transform-es2015-modules-amd": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-object-super": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-object-super/-/babel-plugin-transform-es2015-object-super-6.24.1.tgz",
+      "integrity": "sha1-JM72muIcuDp/hgPa0CH1cusnj40=",
+      "dev": true,
+      "requires": {
+        "babel-helper-replace-supers": "6.24.1",
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-parameters": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-parameters/-/babel-plugin-transform-es2015-parameters-6.24.1.tgz",
+      "integrity": "sha1-V6w1GrScrxSpfNE7CfZv3wpiXys=",
+      "dev": true,
+      "requires": {
+        "babel-helper-call-delegate": "6.24.1",
+        "babel-helper-get-function-arity": "6.24.1",
+        "babel-runtime": "6.26.0",
+        "babel-template": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-shorthand-properties": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-shorthand-properties/-/babel-plugin-transform-es2015-shorthand-properties-6.24.1.tgz",
+      "integrity": "sha1-JPh11nIch2YbvZmkYi5R8U3jiqA=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-spread": {
+      "version": "6.22.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-spread/-/babel-plugin-transform-es2015-spread-6.22.0.tgz",
+      "integrity": "sha1-1taKmfia7cRTbIGlQujdnxdG+NE=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-sticky-regex": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-sticky-regex/-/babel-plugin-transform-es2015-sticky-regex-6.24.1.tgz",
+      "integrity": "sha1-AMHNsaynERLN8M9hJsLta0V8zbw=",
+      "dev": true,
+      "requires": {
+        "babel-helper-regex": "6.26.0",
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-template-literals": {
+      "version": "6.22.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-template-literals/-/babel-plugin-transform-es2015-template-literals-6.22.0.tgz",
+      "integrity": "sha1-qEs0UPfp+PH2g51taH2oS7EjbY0=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-typeof-symbol": {
+      "version": "6.23.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-typeof-symbol/-/babel-plugin-transform-es2015-typeof-symbol-6.23.0.tgz",
+      "integrity": "sha1-3sCfHN3/lLUqxz1QXITfWdzOs3I=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0"
+      }
+    },
+    "babel-plugin-transform-es2015-unicode-regex": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-es2015-unicode-regex/-/babel-plugin-transform-es2015-unicode-regex-6.24.1.tgz",
+      "integrity": "sha1-04sS9C6nMj9yk4fxinxa4frrNek=",
+      "dev": true,
+      "requires": {
+        "babel-helper-regex": "6.26.0",
+        "babel-runtime": "6.26.0",
+        "regexpu-core": "2.0.0"
+      }
+    },
+    "babel-plugin-transform-regenerator": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-regenerator/-/babel-plugin-transform-regenerator-6.26.0.tgz",
+      "integrity": "sha1-4HA2lvveJ/Cj78rPi03KL3s6jy8=",
+      "dev": true,
+      "requires": {
+        "regenerator-transform": "0.10.1"
+      }
+    },
+    "babel-plugin-transform-strict-mode": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-transform-strict-mode/-/babel-plugin-transform-strict-mode-6.24.1.tgz",
+      "integrity": "sha1-1fr3qleKZbvlkc9e2uBKDGcCB1g=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0"
+      }
+    },
+    "babel-preset-es2015": {
+      "version": "6.24.1",
+      "resolved": "https://registry.npmjs.org/babel-preset-es2015/-/babel-preset-es2015-6.24.1.tgz",
+      "integrity": "sha1-1EBQ1rwsn+6nAqrzjXJ6AhBTiTk=",
+      "dev": true,
+      "requires": {
+        "babel-plugin-check-es2015-constants": "6.22.0",
+        "babel-plugin-transform-es2015-arrow-functions": "6.22.0",
+        "babel-plugin-transform-es2015-block-scoped-functions": "6.22.0",
+        "babel-plugin-transform-es2015-block-scoping": "6.26.0",
+        "babel-plugin-transform-es2015-classes": "6.24.1",
+        "babel-plugin-transform-es2015-computed-properties": "6.24.1",
+        "babel-plugin-transform-es2015-destructuring": "6.23.0",
+        "babel-plugin-transform-es2015-duplicate-keys": "6.24.1",
+        "babel-plugin-transform-es2015-for-of": "6.23.0",
+        "babel-plugin-transform-es2015-function-name": "6.24.1",
+        "babel-plugin-transform-es2015-literals": "6.22.0",
+        "babel-plugin-transform-es2015-modules-amd": "6.24.1",
+        "babel-plugin-transform-es2015-modules-commonjs": "6.26.0",
+        "babel-plugin-transform-es2015-modules-systemjs": "6.24.1",
+        "babel-plugin-transform-es2015-modules-umd": "6.24.1",
+        "babel-plugin-transform-es2015-object-super": "6.24.1",
+        "babel-plugin-transform-es2015-parameters": "6.24.1",
+        "babel-plugin-transform-es2015-shorthand-properties": "6.24.1",
+        "babel-plugin-transform-es2015-spread": "6.22.0",
+        "babel-plugin-transform-es2015-sticky-regex": "6.24.1",
+        "babel-plugin-transform-es2015-template-literals": "6.22.0",
+        "babel-plugin-transform-es2015-typeof-symbol": "6.23.0",
+        "babel-plugin-transform-es2015-unicode-regex": "6.24.1",
+        "babel-plugin-transform-regenerator": "6.26.0"
+      }
+    },
+    "babel-runtime": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-runtime/-/babel-runtime-6.26.0.tgz",
+      "integrity": "sha1-llxwWGaOgrVde/4E/yM3vItWR/4=",
+      "dev": true,
+      "requires": {
+        "core-js": "2.5.3",
+        "regenerator-runtime": "0.11.1"
+      }
+    },
+    "babel-template": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-template/-/babel-template-6.26.0.tgz",
+      "integrity": "sha1-3gPi0WOWsGn0bdn/+FIfsaDjXgI=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-traverse": "6.26.0",
+        "babel-types": "6.26.0",
+        "babylon": "6.18.0",
+        "lodash": "4.17.4"
+      }
+    },
+    "babel-traverse": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-traverse/-/babel-traverse-6.26.0.tgz",
+      "integrity": "sha1-RqnL1+3MYsjlwGTi0tjQ9ANXZu4=",
+      "dev": true,
+      "requires": {
+        "babel-code-frame": "6.26.0",
+        "babel-messages": "6.23.0",
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0",
+        "babylon": "6.18.0",
+        "debug": "2.6.9",
+        "globals": "9.18.0",
+        "invariant": "2.2.2",
+        "lodash": "4.17.4"
+      }
+    },
+    "babel-types": {
+      "version": "6.26.0",
+      "resolved": "https://registry.npmjs.org/babel-types/-/babel-types-6.26.0.tgz",
+      "integrity": "sha1-o7Bz+Uq0nrb6Vc1lInozQ4BjJJc=",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "esutils": "2.0.2",
+        "lodash": "4.17.4",
+        "to-fast-properties": "1.0.3"
+      }
+    },
+    "babylon": {
+      "version": "6.18.0",
+      "resolved": "https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz",
+      "integrity": "sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ==",
+      "dev": true
+    },
+    "balanced-match": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
+      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c=",
+      "dev": true
+    },
+    "base64-js": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.2.1.tgz",
+      "integrity": "sha512-dwVUVIXsBZXwTuwnXI9RK8sBmgq09NDHzyR9SAph9eqk76gKK2JSQmZARC2zRC81JC2QTtxD0ARU5qTS25gIGw==",
+      "dev": true
+    },
+    "big.js": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/big.js/-/big.js-3.2.0.tgz",
+      "integrity": "sha512-+hN/Zh2D08Mx65pZ/4g5bsmNiZUuChDiQfTUQ7qJr4/kuopCr88xZsAXv6mBoZEsUI4OuGHlX59qE94K2mMW8Q==",
+      "dev": true
+    },
+    "binary-extensions": {
+      "version": "1.11.0",
+      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.11.0.tgz",
+      "integrity": "sha1-RqoXUftqL5PuXmibsQh9SxTGwgU=",
+      "dev": true
+    },
+    "bn.js": {
+      "version": "4.11.8",
+      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
+      "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
+      "dev": true
+    },
+    "brace-expansion": {
+      "version": "1.1.8",
+      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.8.tgz",
+      "integrity": "sha1-wHshHHyVLsH479Uad+8NHTmQopI=",
+      "dev": true,
+      "requires": {
+        "balanced-match": "1.0.0",
+        "concat-map": "0.0.1"
+      }
+    },
+    "braces": {
+      "version": "1.8.5",
+      "resolved": "https://registry.npmjs.org/braces/-/braces-1.8.5.tgz",
+      "integrity": "sha1-uneWLhLf+WnWt2cR6RS3N4V79qc=",
+      "dev": true,
+      "requires": {
+        "expand-range": "1.8.2",
+        "preserve": "0.2.0",
+        "repeat-element": "1.1.2"
+      }
+    },
+    "brorand": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
+      "integrity": "sha1-EsJe/kCkXjwyPrhnWgoM5XsiNx8=",
+      "dev": true
+    },
+    "browserify-aes": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/browserify-aes/-/browserify-aes-1.1.1.tgz",
+      "integrity": "sha512-UGnTYAnB2a3YuYKIRy1/4FB2HdM866E0qC46JXvVTYKlBlZlnvfpSfY6OKfXZAkv70eJ2a1SqzpAo5CRhZGDFg==",
+      "dev": true,
+      "requires": {
+        "buffer-xor": "1.0.3",
+        "cipher-base": "1.0.4",
+        "create-hash": "1.1.3",
+        "evp_bytestokey": "1.0.3",
+        "inherits": "2.0.3",
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "browserify-cipher": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/browserify-cipher/-/browserify-cipher-1.0.0.tgz",
+      "integrity": "sha1-mYgkSHS/XtTijalWZtzWasj8Njo=",
+      "dev": true,
+      "requires": {
+        "browserify-aes": "1.1.1",
+        "browserify-des": "1.0.0",
+        "evp_bytestokey": "1.0.3"
+      }
+    },
+    "browserify-des": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/browserify-des/-/browserify-des-1.0.0.tgz",
+      "integrity": "sha1-2qJ3cXRwki7S/hhZQRihdUOXId0=",
+      "dev": true,
+      "requires": {
+        "cipher-base": "1.0.4",
+        "des.js": "1.0.0",
+        "inherits": "2.0.3"
+      }
+    },
+    "browserify-rsa": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/browserify-rsa/-/browserify-rsa-4.0.1.tgz",
+      "integrity": "sha1-IeCr+vbyApzy+vsTNWenAdQTVSQ=",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "randombytes": "2.0.6"
+      }
+    },
+    "browserify-sign": {
+      "version": "4.0.4",
+      "resolved": "https://registry.npmjs.org/browserify-sign/-/browserify-sign-4.0.4.tgz",
+      "integrity": "sha1-qk62jl17ZYuqa/alfmMMvXqT0pg=",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "browserify-rsa": "4.0.1",
+        "create-hash": "1.1.3",
+        "create-hmac": "1.1.6",
+        "elliptic": "6.4.0",
+        "inherits": "2.0.3",
+        "parse-asn1": "5.1.0"
+      }
+    },
+    "browserify-zlib": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/browserify-zlib/-/browserify-zlib-0.2.0.tgz",
+      "integrity": "sha512-Z942RysHXmJrhqk88FmKBVq/v5tqmSkDz7p54G/MGyjMnCFFnC79XWNbg+Vta8W6Wb2qtSZTSxIGkJrRpCFEiA==",
+      "dev": true,
+      "requires": {
+        "pako": "1.0.6"
+      }
+    },
+    "buffer": {
+      "version": "4.9.1",
+      "resolved": "https://registry.npmjs.org/buffer/-/buffer-4.9.1.tgz",
+      "integrity": "sha1-bRu2AbB6TvztlwlBMgkwJ8lbwpg=",
+      "dev": true,
+      "requires": {
+        "base64-js": "1.2.1",
+        "ieee754": "1.1.8",
+        "isarray": "1.0.0"
+      }
+    },
+    "buffer-xor": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/buffer-xor/-/buffer-xor-1.0.3.tgz",
+      "integrity": "sha1-JuYe0UIvtw3ULm42cp7VHYVf6Nk=",
+      "dev": true
+    },
+    "builtin-modules": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz",
+      "integrity": "sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8=",
+      "dev": true
+    },
+    "builtin-status-codes": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/builtin-status-codes/-/builtin-status-codes-3.0.0.tgz",
+      "integrity": "sha1-hZgoeOIbmOHGZCXgPQF0eI9Wnug=",
+      "dev": true
+    },
+    "camelcase": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-1.2.1.tgz",
+      "integrity": "sha1-m7UwTS4LVmmLLHWLCKPqqdqlijk=",
+      "dev": true
+    },
+    "center-align": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/center-align/-/center-align-0.1.3.tgz",
+      "integrity": "sha1-qg0yYptu6XIgBBHL1EYckHvCt60=",
+      "dev": true,
+      "requires": {
+        "align-text": "0.1.4",
+        "lazy-cache": "1.0.4"
+      }
+    },
+    "chalk": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
+      "integrity": "sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=",
+      "dev": true,
+      "requires": {
+        "ansi-styles": "2.2.1",
+        "escape-string-regexp": "1.0.5",
+        "has-ansi": "2.0.0",
+        "strip-ansi": "3.0.1",
+        "supports-color": "2.0.0"
+      },
+      "dependencies": {
+        "supports-color": {
+          "version": "2.0.0",
+          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
+          "integrity": "sha1-U10EXOa2Nj+kARcIRimZXp3zJMc=",
+          "dev": true
+        }
+      }
+    },
+    "chokidar": {
+      "version": "1.7.0",
+      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-1.7.0.tgz",
+      "integrity": "sha1-eY5ol3gVHIB2tLNg5e3SjNortGg=",
+      "dev": true,
+      "requires": {
+        "anymatch": "1.3.2",
+        "async-each": "1.0.1",
+        "fsevents": "1.1.3",
+        "glob-parent": "2.0.0",
+        "inherits": "2.0.3",
+        "is-binary-path": "1.0.1",
+        "is-glob": "2.0.1",
+        "path-is-absolute": "1.0.1",
+        "readdirp": "2.1.0"
+      }
+    },
+    "cipher-base": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/cipher-base/-/cipher-base-1.0.4.tgz",
+      "integrity": "sha512-Kkht5ye6ZGmwv40uUDZztayT2ThLQGfnj/T71N/XzeZeo3nf8foyW7zGTsPYkEya3m5f3cAypH+qe7YOrM1U2Q==",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.3",
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "cliui": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/cliui/-/cliui-2.1.0.tgz",
+      "integrity": "sha1-S0dXYP+AJkx2LDoXGQMukcf+oNE=",
+      "dev": true,
+      "requires": {
+        "center-align": "0.1.3",
+        "right-align": "0.1.3",
+        "wordwrap": "0.0.2"
+      }
+    },
+    "co": {
+      "version": "4.6.0",
+      "resolved": "https://registry.npmjs.org/co/-/co-4.6.0.tgz",
+      "integrity": "sha1-bqa989hTrlTMuOR7+gvz+QMfsYQ=",
+      "dev": true
+    },
+    "code-point-at": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz",
+      "integrity": "sha1-DQcLTQQ6W+ozovGkDi7bPZpMz3c=",
+      "dev": true
+    },
+    "concat-map": {
+      "version": "0.0.1",
+      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
+      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
+      "dev": true
+    },
+    "console-browserify": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/console-browserify/-/console-browserify-1.1.0.tgz",
+      "integrity": "sha1-8CQcRXMKn8YyOyBtvzjtx0HQuxA=",
+      "dev": true,
+      "requires": {
+        "date-now": "0.1.4"
+      }
+    },
+    "constants-browserify": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/constants-browserify/-/constants-browserify-1.0.0.tgz",
+      "integrity": "sha1-wguW2MYXdIqvHBYCF2DNJ/y4y3U=",
+      "dev": true
+    },
+    "core-js": {
+      "version": "2.5.3",
+      "resolved": "https://registry.npmjs.org/core-js/-/core-js-2.5.3.tgz",
+      "integrity": "sha1-isw4NFgk8W2DZbfJtCWRaOjtYD4=",
+      "dev": true
+    },
+    "core-util-is": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz",
+      "integrity": "sha1-tf1UIgqivFq1eqtxQMlAdUUDwac=",
+      "dev": true
+    },
+    "create-ecdh": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/create-ecdh/-/create-ecdh-4.0.0.tgz",
+      "integrity": "sha1-iIxyNZbN92EvZJgjPuvXo1MBc30=",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "elliptic": "6.4.0"
+      }
+    },
+    "create-hash": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/create-hash/-/create-hash-1.1.3.tgz",
+      "integrity": "sha1-YGBCrIuSYnUPSDyt2rD1gZFy2P0=",
+      "dev": true,
+      "requires": {
+        "cipher-base": "1.0.4",
+        "inherits": "2.0.3",
+        "ripemd160": "2.0.1",
+        "sha.js": "2.4.9"
+      }
+    },
+    "create-hmac": {
+      "version": "1.1.6",
+      "resolved": "https://registry.npmjs.org/create-hmac/-/create-hmac-1.1.6.tgz",
+      "integrity": "sha1-rLniIaThe9sHbpBlfEK5PjcmzwY=",
+      "dev": true,
+      "requires": {
+        "cipher-base": "1.0.4",
+        "create-hash": "1.1.3",
+        "inherits": "2.0.3",
+        "ripemd160": "2.0.1",
+        "safe-buffer": "5.1.1",
+        "sha.js": "2.4.9"
+      }
+    },
+    "cross-spawn": {
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-5.1.0.tgz",
+      "integrity": "sha1-6L0O/uWPz/b4+UUQoKVUu/ojVEk=",
+      "dev": true,
+      "requires": {
+        "lru-cache": "4.1.1",
+        "shebang-command": "1.2.0",
+        "which": "1.3.0"
+      }
+    },
+    "crypto-browserify": {
+      "version": "3.12.0",
+      "resolved": "https://registry.npmjs.org/crypto-browserify/-/crypto-browserify-3.12.0.tgz",
+      "integrity": "sha512-fz4spIh+znjO2VjL+IdhEpRJ3YN6sMzITSBijk6FK2UvTqruSQW+/cCZTSNsMiZNvUeq0CqurF+dAbyiGOY6Wg==",
+      "dev": true,
+      "requires": {
+        "browserify-cipher": "1.0.0",
+        "browserify-sign": "4.0.4",
+        "create-ecdh": "4.0.0",
+        "create-hash": "1.1.3",
+        "create-hmac": "1.1.6",
+        "diffie-hellman": "5.0.2",
+        "inherits": "2.0.3",
+        "pbkdf2": "3.0.14",
+        "public-encrypt": "4.0.0",
+        "randombytes": "2.0.6",
+        "randomfill": "1.0.3"
+      }
+    },
+    "d": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/d/-/d-1.0.0.tgz",
+      "integrity": "sha1-dUu1v+VUUdpppYuU1F9MWwRi1Y8=",
+      "dev": true,
+      "requires": {
+        "es5-ext": "0.10.37"
+      }
+    },
+    "date-now": {
+      "version": "0.1.4",
+      "resolved": "https://registry.npmjs.org/date-now/-/date-now-0.1.4.tgz",
+      "integrity": "sha1-6vQ5/U1ISK105cx9vvIAZyueNFs=",
+      "dev": true
+    },
+    "debug": {
+      "version": "2.6.9",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
+      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
+      "dev": true,
+      "requires": {
+        "ms": "2.0.0"
+      }
+    },
+    "decamelize": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz",
+      "integrity": "sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=",
+      "dev": true
+    },
+    "des.js": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/des.js/-/des.js-1.0.0.tgz",
+      "integrity": "sha1-wHTS4qpqipoH29YfmhXCzYPsjsw=",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.3",
+        "minimalistic-assert": "1.0.0"
+      }
+    },
+    "diffie-hellman": {
+      "version": "5.0.2",
+      "resolved": "https://registry.npmjs.org/diffie-hellman/-/diffie-hellman-5.0.2.tgz",
+      "integrity": "sha1-tYNXOScM/ias9jIJn97SoH8gnl4=",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "miller-rabin": "4.0.1",
+        "randombytes": "2.0.6"
+      }
+    },
+    "domain-browser": {
+      "version": "1.1.7",
+      "resolved": "https://registry.npmjs.org/domain-browser/-/domain-browser-1.1.7.tgz",
+      "integrity": "sha1-hnqksJP6oF8d4IwG9NeyH9+GmLw=",
+      "dev": true
+    },
+    "elliptic": {
+      "version": "6.4.0",
+      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz",
+      "integrity": "sha1-ysmvh2LIWDYYcAPI3+GT5eLq5d8=",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "brorand": "1.1.0",
+        "hash.js": "1.1.3",
+        "hmac-drbg": "1.0.1",
+        "inherits": "2.0.3",
+        "minimalistic-assert": "1.0.0",
+        "minimalistic-crypto-utils": "1.0.1"
+      }
+    },
+    "emojis-list": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/emojis-list/-/emojis-list-2.1.0.tgz",
+      "integrity": "sha1-TapNnbAPmBmIDHn6RXrlsJof04k=",
+      "dev": true
+    },
+    "enhanced-resolve": {
+      "version": "3.4.1",
+      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-3.4.1.tgz",
+      "integrity": "sha1-BCHjOf1xQZs9oT0Smzl5BAIwR24=",
+      "dev": true,
+      "requires": {
+        "graceful-fs": "4.1.11",
+        "memory-fs": "0.4.1",
+        "object-assign": "4.1.1",
+        "tapable": "0.2.8"
+      }
+    },
+    "errno": {
+      "version": "0.1.6",
+      "resolved": "https://registry.npmjs.org/errno/-/errno-0.1.6.tgz",
+      "integrity": "sha512-IsORQDpaaSwcDP4ZZnHxgE85werpo34VYn1Ud3mq+eUsF593faR8oCZNXrROVkpFu2TsbrNhHin0aUrTsQ9vNw==",
+      "dev": true,
+      "requires": {
+        "prr": "1.0.1"
+      }
+    },
+    "error-ex": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.1.tgz",
+      "integrity": "sha1-+FWobOYa3E6GIcPNoh56dhLDqNw=",
+      "dev": true,
+      "requires": {
+        "is-arrayish": "0.2.1"
+      }
+    },
+    "es5-ext": {
+      "version": "0.10.37",
+      "resolved": "https://registry.npmjs.org/es5-ext/-/es5-ext-0.10.37.tgz",
+      "integrity": "sha1-DudB0Ui4AGm6J9AgOTdWryV978M=",
+      "dev": true,
+      "requires": {
+        "es6-iterator": "2.0.3",
+        "es6-symbol": "3.1.1"
+      }
+    },
+    "es6-iterator": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/es6-iterator/-/es6-iterator-2.0.3.tgz",
+      "integrity": "sha1-p96IkUGgWpSwhUQDstCg+/qY87c=",
+      "dev": true,
+      "requires": {
+        "d": "1.0.0",
+        "es5-ext": "0.10.37",
+        "es6-symbol": "3.1.1"
+      }
+    },
+    "es6-map": {
+      "version": "0.1.5",
+      "resolved": "https://registry.npmjs.org/es6-map/-/es6-map-0.1.5.tgz",
+      "integrity": "sha1-kTbgUD3MBqMBaQ8LsU/042TpSfA=",
+      "dev": true,
+      "requires": {
+        "d": "1.0.0",
+        "es5-ext": "0.10.37",
+        "es6-iterator": "2.0.3",
+        "es6-set": "0.1.5",
+        "es6-symbol": "3.1.1",
+        "event-emitter": "0.3.5"
+      }
+    },
+    "es6-set": {
+      "version": "0.1.5",
+      "resolved": "https://registry.npmjs.org/es6-set/-/es6-set-0.1.5.tgz",
+      "integrity": "sha1-0rPsXU2ADO2BjbU40ol02wpzzLE=",
+      "dev": true,
+      "requires": {
+        "d": "1.0.0",
+        "es5-ext": "0.10.37",
+        "es6-iterator": "2.0.3",
+        "es6-symbol": "3.1.1",
+        "event-emitter": "0.3.5"
+      }
+    },
+    "es6-symbol": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/es6-symbol/-/es6-symbol-3.1.1.tgz",
+      "integrity": "sha1-vwDvT9q2uhtG7Le2KbTH7VcVzHc=",
+      "dev": true,
+      "requires": {
+        "d": "1.0.0",
+        "es5-ext": "0.10.37"
+      }
+    },
+    "es6-weak-map": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/es6-weak-map/-/es6-weak-map-2.0.2.tgz",
+      "integrity": "sha1-XjqzIlH/0VOKH45f+hNXdy+S2W8=",
+      "dev": true,
+      "requires": {
+        "d": "1.0.0",
+        "es5-ext": "0.10.37",
+        "es6-iterator": "2.0.3",
+        "es6-symbol": "3.1.1"
+      }
+    },
+    "escape-string-regexp": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
+      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
+      "dev": true
+    },
+    "escope": {
+      "version": "3.6.0",
+      "resolved": "https://registry.npmjs.org/escope/-/escope-3.6.0.tgz",
+      "integrity": "sha1-4Bl16BJ4GhY6ba392AOY3GTIicM=",
+      "dev": true,
+      "requires": {
+        "es6-map": "0.1.5",
+        "es6-weak-map": "2.0.2",
+        "esrecurse": "4.2.0",
+        "estraverse": "4.2.0"
+      }
+    },
+    "esrecurse": {
+      "version": "4.2.0",
+      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.2.0.tgz",
+      "integrity": "sha1-+pVo2Y04I/mkHZHpAtyrnqblsWM=",
+      "dev": true,
+      "requires": {
+        "estraverse": "4.2.0",
+        "object-assign": "4.1.1"
+      }
+    },
+    "estraverse": {
+      "version": "4.2.0",
+      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz",
+      "integrity": "sha1-De4/7TH81GlhjOc0IJn8GvoL2xM=",
+      "dev": true
+    },
+    "esutils": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz",
+      "integrity": "sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs=",
+      "dev": true
+    },
+    "event-emitter": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/event-emitter/-/event-emitter-0.3.5.tgz",
+      "integrity": "sha1-34xp7vFkeSPHFXuc6DhAYQsCzDk=",
+      "dev": true,
+      "requires": {
+        "d": "1.0.0",
+        "es5-ext": "0.10.37"
+      }
+    },
+    "events": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/events/-/events-1.1.1.tgz",
+      "integrity": "sha1-nr23Y1rQmccNzEwqH1AEKI6L2SQ=",
+      "dev": true
+    },
+    "evp_bytestokey": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/evp_bytestokey/-/evp_bytestokey-1.0.3.tgz",
+      "integrity": "sha512-/f2Go4TognH/KvCISP7OUsHn85hT9nUkxxA9BEWxFn+Oj9o8ZNLm/40hdlgSLyuOimsrTKLUMEorQexp/aPQeA==",
+      "dev": true,
+      "requires": {
+        "md5.js": "1.3.4",
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "execa": {
+      "version": "0.7.0",
+      "resolved": "https://registry.npmjs.org/execa/-/execa-0.7.0.tgz",
+      "integrity": "sha1-lEvs00zEHuMqY6n68nrVpl/Fl3c=",
+      "dev": true,
+      "requires": {
+        "cross-spawn": "5.1.0",
+        "get-stream": "3.0.0",
+        "is-stream": "1.1.0",
+        "npm-run-path": "2.0.2",
+        "p-finally": "1.0.0",
+        "signal-exit": "3.0.2",
+        "strip-eof": "1.0.0"
+      }
+    },
+    "expand-brackets": {
+      "version": "0.1.5",
+      "resolved": "https://registry.npmjs.org/expand-brackets/-/expand-brackets-0.1.5.tgz",
+      "integrity": "sha1-3wcoTjQqgHzXM6xa9yQR5YHRF3s=",
+      "dev": true,
+      "requires": {
+        "is-posix-bracket": "0.1.1"
+      }
+    },
+    "expand-range": {
+      "version": "1.8.2",
+      "resolved": "https://registry.npmjs.org/expand-range/-/expand-range-1.8.2.tgz",
+      "integrity": "sha1-opnv/TNf4nIeuujiV+x5ZE/IUzc=",
+      "dev": true,
+      "requires": {
+        "fill-range": "2.2.3"
+      }
+    },
+    "extglob": {
+      "version": "0.3.2",
+      "resolved": "https://registry.npmjs.org/extglob/-/extglob-0.3.2.tgz",
+      "integrity": "sha1-Lhj/PS9JqydlzskCPwEdqo2DSaE=",
+      "dev": true,
+      "requires": {
+        "is-extglob": "1.0.0"
+      }
+    },
+    "fast-deep-equal": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-1.0.0.tgz",
+      "integrity": "sha1-liVqO8l1WV6zbYLpkp0GDYk0Of8=",
+      "dev": true
+    },
+    "fast-json-stable-stringify": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.0.0.tgz",
+      "integrity": "sha1-1RQsDK7msRifh9OnYREGT4bIu/I=",
+      "dev": true
+    },
+    "filename-regex": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/filename-regex/-/filename-regex-2.0.1.tgz",
+      "integrity": "sha1-wcS5vuPglyXdsQa3XB4wH+LxiyY=",
+      "dev": true
+    },
+    "fill-range": {
+      "version": "2.2.3",
+      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-2.2.3.tgz",
+      "integrity": "sha1-ULd9/X5Gm8dJJHCWNpn+eoSFpyM=",
+      "dev": true,
+      "requires": {
+        "is-number": "2.1.0",
+        "isobject": "2.1.0",
+        "randomatic": "1.1.7",
+        "repeat-element": "1.1.2",
+        "repeat-string": "1.6.1"
+      }
+    },
+    "find-up": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/find-up/-/find-up-2.1.0.tgz",
+      "integrity": "sha1-RdG35QbHF93UgndaK3eSCjwMV6c=",
+      "dev": true,
+      "requires": {
+        "locate-path": "2.0.0"
+      }
+    },
+    "for-in": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/for-in/-/for-in-1.0.2.tgz",
+      "integrity": "sha1-gQaNKVqBQuwKxybG4iAMMPttXoA=",
+      "dev": true
+    },
+    "for-own": {
+      "version": "0.1.5",
+      "resolved": "https://registry.npmjs.org/for-own/-/for-own-0.1.5.tgz",
+      "integrity": "sha1-UmXGgaTylNq78XyVCbZ2OqhFEM4=",
+      "dev": true,
+      "requires": {
+        "for-in": "1.0.2"
+      }
+    },
+    "fsevents": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-1.1.3.tgz",
+      "integrity": "sha512-WIr7iDkdmdbxu/Gh6eKEZJL6KPE74/5MEsf2whTOFNxbIoIixogroLdKYqB6FDav4Wavh/lZdzzd3b2KxIXC5Q==",
+      "dev": true,
+      "optional": true,
+      "requires": {
+        "nan": "2.8.0",
+        "node-pre-gyp": "0.6.39"
+      },
+      "dependencies": {
+        "abbrev": {
+          "version": "1.1.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "ajv": {
+          "version": "4.11.8",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "co": "4.6.0",
+            "json-stable-stringify": "1.0.1"
+          }
+        },
+        "ansi-regex": {
+          "version": "2.1.1",
+          "bundled": true,
+          "dev": true
+        },
+        "aproba": {
+          "version": "1.1.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "are-we-there-yet": {
+          "version": "1.1.4",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "delegates": "1.0.0",
+            "readable-stream": "2.2.9"
+          }
+        },
+        "asn1": {
+          "version": "0.2.3",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "assert-plus": {
+          "version": "0.2.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "asynckit": {
+          "version": "0.4.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "aws-sign2": {
+          "version": "0.6.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "aws4": {
+          "version": "1.6.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "balanced-match": {
+          "version": "0.4.2",
+          "bundled": true,
+          "dev": true
+        },
+        "bcrypt-pbkdf": {
+          "version": "1.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "tweetnacl": "0.14.5"
+          }
+        },
+        "block-stream": {
+          "version": "0.0.9",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "inherits": "2.0.3"
+          }
+        },
+        "boom": {
+          "version": "2.10.1",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "hoek": "2.16.3"
+          }
+        },
+        "brace-expansion": {
+          "version": "1.1.7",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "balanced-match": "0.4.2",
+            "concat-map": "0.0.1"
+          }
+        },
+        "buffer-shims": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true
+        },
+        "caseless": {
+          "version": "0.12.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "co": {
+          "version": "4.6.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "code-point-at": {
+          "version": "1.1.0",
+          "bundled": true,
+          "dev": true
+        },
+        "combined-stream": {
+          "version": "1.0.5",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "delayed-stream": "1.0.0"
+          }
+        },
+        "concat-map": {
+          "version": "0.0.1",
+          "bundled": true,
+          "dev": true
+        },
+        "console-control-strings": {
+          "version": "1.1.0",
+          "bundled": true,
+          "dev": true
+        },
+        "core-util-is": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true
+        },
+        "cryptiles": {
+          "version": "2.0.5",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "boom": "2.10.1"
+          }
+        },
+        "dashdash": {
+          "version": "1.14.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "assert-plus": "1.0.0"
+          },
+          "dependencies": {
+            "assert-plus": {
+              "version": "1.0.0",
+              "bundled": true,
+              "dev": true,
+              "optional": true
+            }
+          }
+        },
+        "debug": {
+          "version": "2.6.8",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "ms": "2.0.0"
+          }
+        },
+        "deep-extend": {
+          "version": "0.4.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "delayed-stream": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true
+        },
+        "delegates": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "detect-libc": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "ecc-jsbn": {
+          "version": "0.1.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "jsbn": "0.1.1"
+          }
+        },
+        "extend": {
+          "version": "3.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "extsprintf": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true
+        },
+        "forever-agent": {
+          "version": "0.6.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "form-data": {
+          "version": "2.1.4",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "asynckit": "0.4.0",
+            "combined-stream": "1.0.5",
+            "mime-types": "2.1.15"
+          }
+        },
+        "fs.realpath": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true
+        },
+        "fstream": {
+          "version": "1.0.11",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "graceful-fs": "4.1.11",
+            "inherits": "2.0.3",
+            "mkdirp": "0.5.1",
+            "rimraf": "2.6.1"
+          }
+        },
+        "fstream-ignore": {
+          "version": "1.0.5",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "fstream": "1.0.11",
+            "inherits": "2.0.3",
+            "minimatch": "3.0.4"
+          }
+        },
+        "gauge": {
+          "version": "2.7.4",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "aproba": "1.1.1",
+            "console-control-strings": "1.1.0",
+            "has-unicode": "2.0.1",
+            "object-assign": "4.1.1",
+            "signal-exit": "3.0.2",
+            "string-width": "1.0.2",
+            "strip-ansi": "3.0.1",
+            "wide-align": "1.1.2"
+          }
+        },
+        "getpass": {
+          "version": "0.1.7",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "assert-plus": "1.0.0"
+          },
+          "dependencies": {
+            "assert-plus": {
+              "version": "1.0.0",
+              "bundled": true,
+              "dev": true,
+              "optional": true
+            }
+          }
+        },
+        "glob": {
+          "version": "7.1.2",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "fs.realpath": "1.0.0",
+            "inflight": "1.0.6",
+            "inherits": "2.0.3",
+            "minimatch": "3.0.4",
+            "once": "1.4.0",
+            "path-is-absolute": "1.0.1"
+          }
+        },
+        "graceful-fs": {
+          "version": "4.1.11",
+          "bundled": true,
+          "dev": true
+        },
+        "har-schema": {
+          "version": "1.0.5",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "har-validator": {
+          "version": "4.2.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "ajv": "4.11.8",
+            "har-schema": "1.0.5"
+          }
+        },
+        "has-unicode": {
+          "version": "2.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "hawk": {
+          "version": "3.1.3",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "boom": "2.10.1",
+            "cryptiles": "2.0.5",
+            "hoek": "2.16.3",
+            "sntp": "1.0.9"
+          }
+        },
+        "hoek": {
+          "version": "2.16.3",
+          "bundled": true,
+          "dev": true
+        },
+        "http-signature": {
+          "version": "1.1.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "assert-plus": "0.2.0",
+            "jsprim": "1.4.0",
+            "sshpk": "1.13.0"
+          }
+        },
+        "inflight": {
+          "version": "1.0.6",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "once": "1.4.0",
+            "wrappy": "1.0.2"
+          }
+        },
+        "inherits": {
+          "version": "2.0.3",
+          "bundled": true,
+          "dev": true
+        },
+        "ini": {
+          "version": "1.3.4",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "is-fullwidth-code-point": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "number-is-nan": "1.0.1"
+          }
+        },
+        "is-typedarray": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "isarray": {
+          "version": "1.0.0",
+          "bundled": true,
+          "dev": true
+        },
+        "isstream": {
+          "version": "0.1.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "jodid25519": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "jsbn": "0.1.1"
+          }
+        },
+        "jsbn": {
+          "version": "0.1.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "json-schema": {
+          "version": "0.2.3",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "json-stable-stringify": {
+          "version": "1.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "jsonify": "0.0.0"
+          }
+        },
+        "json-stringify-safe": {
+          "version": "5.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "jsonify": {
+          "version": "0.0.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "jsprim": {
+          "version": "1.4.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "assert-plus": "1.0.0",
+            "extsprintf": "1.0.2",
+            "json-schema": "0.2.3",
+            "verror": "1.3.6"
+          },
+          "dependencies": {
+            "assert-plus": {
+              "version": "1.0.0",
+              "bundled": true,
+              "dev": true,
+              "optional": true
+            }
+          }
+        },
+        "mime-db": {
+          "version": "1.27.0",
+          "bundled": true,
+          "dev": true
+        },
+        "mime-types": {
+          "version": "2.1.15",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "mime-db": "1.27.0"
+          }
+        },
+        "minimatch": {
+          "version": "3.0.4",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "brace-expansion": "1.1.7"
+          }
+        },
+        "minimist": {
+          "version": "0.0.8",
+          "bundled": true,
+          "dev": true
+        },
+        "mkdirp": {
+          "version": "0.5.1",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "minimist": "0.0.8"
+          }
+        },
+        "ms": {
+          "version": "2.0.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "node-pre-gyp": {
+          "version": "0.6.39",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "detect-libc": "1.0.2",
+            "hawk": "3.1.3",
+            "mkdirp": "0.5.1",
+            "nopt": "4.0.1",
+            "npmlog": "4.1.0",
+            "rc": "1.2.1",
+            "request": "2.81.0",
+            "rimraf": "2.6.1",
+            "semver": "5.3.0",
+            "tar": "2.2.1",
+            "tar-pack": "3.4.0"
+          }
+        },
+        "nopt": {
+          "version": "4.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "abbrev": "1.1.0",
+            "osenv": "0.1.4"
+          }
+        },
+        "npmlog": {
+          "version": "4.1.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "are-we-there-yet": "1.1.4",
+            "console-control-strings": "1.1.0",
+            "gauge": "2.7.4",
+            "set-blocking": "2.0.0"
+          }
+        },
+        "number-is-nan": {
+          "version": "1.0.1",
+          "bundled": true,
+          "dev": true
+        },
+        "oauth-sign": {
+          "version": "0.8.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "object-assign": {
+          "version": "4.1.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "once": {
+          "version": "1.4.0",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "wrappy": "1.0.2"
+          }
+        },
+        "os-homedir": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "os-tmpdir": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "osenv": {
+          "version": "0.1.4",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "os-homedir": "1.0.2",
+            "os-tmpdir": "1.0.2"
+          }
+        },
+        "path-is-absolute": {
+          "version": "1.0.1",
+          "bundled": true,
+          "dev": true
+        },
+        "performance-now": {
+          "version": "0.2.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "process-nextick-args": {
+          "version": "1.0.7",
+          "bundled": true,
+          "dev": true
+        },
+        "punycode": {
+          "version": "1.4.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "qs": {
+          "version": "6.4.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "rc": {
+          "version": "1.2.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "deep-extend": "0.4.2",
+            "ini": "1.3.4",
+            "minimist": "1.2.0",
+            "strip-json-comments": "2.0.1"
+          },
+          "dependencies": {
+            "minimist": {
+              "version": "1.2.0",
+              "bundled": true,
+              "dev": true,
+              "optional": true
+            }
+          }
+        },
+        "readable-stream": {
+          "version": "2.2.9",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "buffer-shims": "1.0.0",
+            "core-util-is": "1.0.2",
+            "inherits": "2.0.3",
+            "isarray": "1.0.0",
+            "process-nextick-args": "1.0.7",
+            "string_decoder": "1.0.1",
+            "util-deprecate": "1.0.2"
+          }
+        },
+        "request": {
+          "version": "2.81.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "aws-sign2": "0.6.0",
+            "aws4": "1.6.0",
+            "caseless": "0.12.0",
+            "combined-stream": "1.0.5",
+            "extend": "3.0.1",
+            "forever-agent": "0.6.1",
+            "form-data": "2.1.4",
+            "har-validator": "4.2.1",
+            "hawk": "3.1.3",
+            "http-signature": "1.1.1",
+            "is-typedarray": "1.0.0",
+            "isstream": "0.1.2",
+            "json-stringify-safe": "5.0.1",
+            "mime-types": "2.1.15",
+            "oauth-sign": "0.8.2",
+            "performance-now": "0.2.0",
+            "qs": "6.4.0",
+            "safe-buffer": "5.0.1",
+            "stringstream": "0.0.5",
+            "tough-cookie": "2.3.2",
+            "tunnel-agent": "0.6.0",
+            "uuid": "3.0.1"
+          }
+        },
+        "rimraf": {
+          "version": "2.6.1",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "glob": "7.1.2"
+          }
+        },
+        "safe-buffer": {
+          "version": "5.0.1",
+          "bundled": true,
+          "dev": true
+        },
+        "semver": {
+          "version": "5.3.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "set-blocking": {
+          "version": "2.0.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "signal-exit": {
+          "version": "3.0.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "sntp": {
+          "version": "1.0.9",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "hoek": "2.16.3"
+          }
+        },
+        "sshpk": {
+          "version": "1.13.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "asn1": "0.2.3",
+            "assert-plus": "1.0.0",
+            "bcrypt-pbkdf": "1.0.1",
+            "dashdash": "1.14.1",
+            "ecc-jsbn": "0.1.1",
+            "getpass": "0.1.7",
+            "jodid25519": "1.0.2",
+            "jsbn": "0.1.1",
+            "tweetnacl": "0.14.5"
+          },
+          "dependencies": {
+            "assert-plus": {
+              "version": "1.0.0",
+              "bundled": true,
+              "dev": true,
+              "optional": true
+            }
+          }
+        },
+        "string-width": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "code-point-at": "1.1.0",
+            "is-fullwidth-code-point": "1.0.0",
+            "strip-ansi": "3.0.1"
+          }
+        },
+        "string_decoder": {
+          "version": "1.0.1",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "safe-buffer": "5.0.1"
+          }
+        },
+        "stringstream": {
+          "version": "0.0.5",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "strip-ansi": {
+          "version": "3.0.1",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "ansi-regex": "2.1.1"
+          }
+        },
+        "strip-json-comments": {
+          "version": "2.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "tar": {
+          "version": "2.2.1",
+          "bundled": true,
+          "dev": true,
+          "requires": {
+            "block-stream": "0.0.9",
+            "fstream": "1.0.11",
+            "inherits": "2.0.3"
+          }
+        },
+        "tar-pack": {
+          "version": "3.4.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "debug": "2.6.8",
+            "fstream": "1.0.11",
+            "fstream-ignore": "1.0.5",
+            "once": "1.4.0",
+            "readable-stream": "2.2.9",
+            "rimraf": "2.6.1",
+            "tar": "2.2.1",
+            "uid-number": "0.0.6"
+          }
+        },
+        "tough-cookie": {
+          "version": "2.3.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "punycode": "1.4.1"
+          }
+        },
+        "tunnel-agent": {
+          "version": "0.6.0",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "safe-buffer": "5.0.1"
+          }
+        },
+        "tweetnacl": {
+          "version": "0.14.5",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "uid-number": {
+          "version": "0.0.6",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "util-deprecate": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true
+        },
+        "uuid": {
+          "version": "3.0.1",
+          "bundled": true,
+          "dev": true,
+          "optional": true
+        },
+        "verror": {
+          "version": "1.3.6",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "extsprintf": "1.0.2"
+          }
+        },
+        "wide-align": {
+          "version": "1.1.2",
+          "bundled": true,
+          "dev": true,
+          "optional": true,
+          "requires": {
+            "string-width": "1.0.2"
+          }
+        },
+        "wrappy": {
+          "version": "1.0.2",
+          "bundled": true,
+          "dev": true
+        }
+      }
+    },
+    "get-caller-file": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-1.0.2.tgz",
+      "integrity": "sha1-9wLmMSfn4jHBYKgMFVSstw1QR+U=",
+      "dev": true
+    },
+    "get-stream": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-3.0.0.tgz",
+      "integrity": "sha1-jpQ9E1jcN1VQVOy+LtsFqhdO3hQ=",
+      "dev": true
+    },
+    "glob-base": {
+      "version": "0.3.0",
+      "resolved": "https://registry.npmjs.org/glob-base/-/glob-base-0.3.0.tgz",
+      "integrity": "sha1-27Fk9iIbHAscz4Kuoyi0l98Oo8Q=",
+      "dev": true,
+      "requires": {
+        "glob-parent": "2.0.0",
+        "is-glob": "2.0.1"
+      }
+    },
+    "glob-parent": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-2.0.0.tgz",
+      "integrity": "sha1-gTg9ctsFT8zPUzbaqQLxgvbtuyg=",
+      "dev": true,
+      "requires": {
+        "is-glob": "2.0.1"
+      }
+    },
+    "globals": {
+      "version": "9.18.0",
+      "resolved": "https://registry.npmjs.org/globals/-/globals-9.18.0.tgz",
+      "integrity": "sha512-S0nG3CLEQiY/ILxqtztTWH/3iRRdyBLw6KMDxnKMchrtbj2OFmehVh0WUCfW3DUrIgx/qFrJPICrq4Z4sTR9UQ==",
+      "dev": true
+    },
+    "graceful-fs": {
+      "version": "4.1.11",
+      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.1.11.tgz",
+      "integrity": "sha1-Dovf5NHduIVNZOBOp8AOKgJuVlg=",
+      "dev": true
+    },
+    "has-ansi": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz",
+      "integrity": "sha1-NPUEnOHs3ysGSa8+8k5F7TVBbZE=",
+      "dev": true,
+      "requires": {
+        "ansi-regex": "2.1.1"
+      }
+    },
+    "has-flag": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-2.0.0.tgz",
+      "integrity": "sha1-6CB68cx7MNRGzHC3NLXovhj4jVE=",
+      "dev": true
+    },
+    "hash-base": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/hash-base/-/hash-base-2.0.2.tgz",
+      "integrity": "sha1-ZuodhW206KVHDK32/OI65SRO8uE=",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.3"
+      }
+    },
+    "hash.js": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.3.tgz",
+      "integrity": "sha512-/UETyP0W22QILqS+6HowevwhEFJ3MBJnwTf75Qob9Wz9t0DPuisL8kW8YZMK62dHAKE1c1p+gY1TtOLY+USEHA==",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.3",
+        "minimalistic-assert": "1.0.0"
+      }
+    },
+    "hmac-drbg": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
+      "integrity": "sha1-0nRXAQJabHdabFRXk+1QL8DGSaE=",
+      "dev": true,
+      "requires": {
+        "hash.js": "1.1.3",
+        "minimalistic-assert": "1.0.0",
+        "minimalistic-crypto-utils": "1.0.1"
+      }
+    },
+    "hosted-git-info": {
+      "version": "2.5.0",
+      "resolved": "https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.5.0.tgz",
+      "integrity": "sha512-pNgbURSuab90KbTqvRPsseaTxOJCZBD0a7t+haSN33piP9cCM4l0CqdzAif2hUqm716UovKB2ROmiabGAKVXyg==",
+      "dev": true
+    },
+    "https-browserify": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/https-browserify/-/https-browserify-1.0.0.tgz",
+      "integrity": "sha1-7AbBDgo0wPL68Zn3/X/Hj//QPHM=",
+      "dev": true
+    },
+    "ieee754": {
+      "version": "1.1.8",
+      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.1.8.tgz",
+      "integrity": "sha1-vjPUCsEO8ZJnAfbwii2G+/0a0+Q=",
+      "dev": true
+    },
+    "indexof": {
+      "version": "0.0.1",
+      "resolved": "https://registry.npmjs.org/indexof/-/indexof-0.0.1.tgz",
+      "integrity": "sha1-gtwzbSMrkGIXnQWrMpOmYFn9Q10=",
+      "dev": true
+    },
+    "inherits": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
+      "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=",
+      "dev": true
+    },
+    "interpret": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/interpret/-/interpret-1.1.0.tgz",
+      "integrity": "sha1-ftGxQQxqDg94z5XTuEQMY/eLhhQ=",
+      "dev": true
+    },
+    "invariant": {
+      "version": "2.2.2",
+      "resolved": "https://registry.npmjs.org/invariant/-/invariant-2.2.2.tgz",
+      "integrity": "sha1-nh9WrArNtr8wMwbzOL47IErmA2A=",
+      "dev": true,
+      "requires": {
+        "loose-envify": "1.3.1"
+      }
+    },
+    "invert-kv": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/invert-kv/-/invert-kv-1.0.0.tgz",
+      "integrity": "sha1-EEqOSqym09jNFXqO+L+rLXo//bY=",
+      "dev": true
+    },
+    "is-arrayish": {
+      "version": "0.2.1",
+      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
+      "integrity": "sha1-d8mYQFJ6qOyxqLppe4BkWnqSap0=",
+      "dev": true
+    },
+    "is-binary-path": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-1.0.1.tgz",
+      "integrity": "sha1-dfFmQrSA8YenEcgUFh/TpKdlWJg=",
+      "dev": true,
+      "requires": {
+        "binary-extensions": "1.11.0"
+      }
+    },
+    "is-buffer": {
+      "version": "1.1.6",
+      "resolved": "https://registry.npmjs.org/is-buffer/-/is-buffer-1.1.6.tgz",
+      "integrity": "sha512-NcdALwpXkTm5Zvvbk7owOUSvVvBKDgKP5/ewfXEznmQFfs4ZRmanOeKBTjRVjka3QFoN6XJ+9F3USqfHqTaU5w==",
+      "dev": true
+    },
+    "is-builtin-module": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/is-builtin-module/-/is-builtin-module-1.0.0.tgz",
+      "integrity": "sha1-VAVy0096wxGfj3bDDLwbHgN6/74=",
+      "dev": true,
+      "requires": {
+        "builtin-modules": "1.1.1"
+      }
+    },
+    "is-dotfile": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/is-dotfile/-/is-dotfile-1.0.3.tgz",
+      "integrity": "sha1-pqLzL/0t+wT1yiXs0Pa4PPeYoeE=",
+      "dev": true
+    },
+    "is-equal-shallow": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/is-equal-shallow/-/is-equal-shallow-0.1.3.tgz",
+      "integrity": "sha1-IjgJj8Ih3gvPpdnqxMRdY4qhxTQ=",
+      "dev": true,
+      "requires": {
+        "is-primitive": "2.0.0"
+      }
+    },
+    "is-extendable": {
+      "version": "0.1.1",
+      "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-0.1.1.tgz",
+      "integrity": "sha1-YrEQ4omkcUGOPsNqYX1HLjAd/Ik=",
+      "dev": true
+    },
+    "is-extglob": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-1.0.0.tgz",
+      "integrity": "sha1-rEaBd8SUNAWgkvyPKXYMb/xiBsA=",
+      "dev": true
+    },
+    "is-fullwidth-code-point": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
+      "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
+      "dev": true,
+      "requires": {
+        "number-is-nan": "1.0.1"
+      }
+    },
+    "is-glob": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-2.0.1.tgz",
+      "integrity": "sha1-0Jb5JqPe1WAPP9/ZEZjLCIjC2GM=",
+      "dev": true,
+      "requires": {
+        "is-extglob": "1.0.0"
+      }
+    },
+    "is-number": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/is-number/-/is-number-2.1.0.tgz",
+      "integrity": "sha1-Afy7s5NGOlSPL0ZszhbezknbkI8=",
+      "dev": true,
+      "requires": {
+        "kind-of": "3.2.2"
+      }
+    },
+    "is-posix-bracket": {
+      "version": "0.1.1",
+      "resolved": "https://registry.npmjs.org/is-posix-bracket/-/is-posix-bracket-0.1.1.tgz",
+      "integrity": "sha1-MzTceXdDaOkvAW5vvAqI9c1ua8Q=",
+      "dev": true
+    },
+    "is-primitive": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/is-primitive/-/is-primitive-2.0.0.tgz",
+      "integrity": "sha1-IHurkWOEmcB7Kt8kCkGochADRXU=",
+      "dev": true
+    },
+    "is-stream": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz",
+      "integrity": "sha1-EtSj3U5o4Lec6428hBc66A2RykQ=",
+      "dev": true
+    },
+    "isarray": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
+      "integrity": "sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE=",
+      "dev": true
+    },
+    "isexe": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
+      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
+      "dev": true
+    },
+    "isobject": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/isobject/-/isobject-2.1.0.tgz",
+      "integrity": "sha1-8GVWEJaj8dou9GJy+BXIQNh+DIk=",
+      "dev": true,
+      "requires": {
+        "isarray": "1.0.0"
+      }
+    },
+    "js-tokens": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-3.0.2.tgz",
+      "integrity": "sha1-mGbfOVECEw449/mWvOtlRDIJwls=",
+      "dev": true
+    },
+    "jsesc": {
+      "version": "0.5.0",
+      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-0.5.0.tgz",
+      "integrity": "sha1-597mbjXW/Bb3EP6R1c9p9w8IkR0=",
+      "dev": true
+    },
+    "json-loader": {
+      "version": "0.5.7",
+      "resolved": "https://registry.npmjs.org/json-loader/-/json-loader-0.5.7.tgz",
+      "integrity": "sha512-QLPs8Dj7lnf3e3QYS1zkCo+4ZwqOiF9d/nZnYozTISxXWCfNs9yuky5rJw4/W34s7POaNlbZmQGaB5NiXCbP4w==",
+      "dev": true
+    },
+    "json-schema-traverse": {
+      "version": "0.3.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.3.1.tgz",
+      "integrity": "sha1-NJptRMU6Ud6JtAgFxdXlm0F9M0A=",
+      "dev": true
+    },
+    "json5": {
+      "version": "0.5.1",
+      "resolved": "https://registry.npmjs.org/json5/-/json5-0.5.1.tgz",
+      "integrity": "sha1-Hq3nrMASA0rYTiOWdn6tn6VJWCE=",
+      "dev": true
+    },
+    "kind-of": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
+      "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
+      "dev": true,
+      "requires": {
+        "is-buffer": "1.1.6"
+      }
+    },
+    "lazy-cache": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/lazy-cache/-/lazy-cache-1.0.4.tgz",
+      "integrity": "sha1-odePw6UEdMuAhF07O24dpJpEbo4=",
+      "dev": true
+    },
+    "lcid": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/lcid/-/lcid-1.0.0.tgz",
+      "integrity": "sha1-MIrMr6C8SDo4Z7S28rlQYlHRuDU=",
+      "dev": true,
+      "requires": {
+        "invert-kv": "1.0.0"
+      }
+    },
+    "load-json-file": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/load-json-file/-/load-json-file-2.0.0.tgz",
+      "integrity": "sha1-eUfkIUmvgNaWy/eXvKq8/h/inKg=",
+      "dev": true,
+      "requires": {
+        "graceful-fs": "4.1.11",
+        "parse-json": "2.2.0",
+        "pify": "2.3.0",
+        "strip-bom": "3.0.0"
+      }
+    },
+    "loader-runner": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/loader-runner/-/loader-runner-2.3.0.tgz",
+      "integrity": "sha1-9IKuqC1UPgeSFwDVpG7yb9rGuKI=",
+      "dev": true
+    },
+    "loader-utils": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-1.1.0.tgz",
+      "integrity": "sha1-yYrvSIvM7aL/teLeZG1qdUQp9c0=",
+      "dev": true,
+      "requires": {
+        "big.js": "3.2.0",
+        "emojis-list": "2.1.0",
+        "json5": "0.5.1"
+      }
+    },
+    "locate-path": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-2.0.0.tgz",
+      "integrity": "sha1-K1aLJl7slExtnA3pw9u7ygNUzY4=",
+      "dev": true,
+      "requires": {
+        "p-locate": "2.0.0",
+        "path-exists": "3.0.0"
+      }
+    },
+    "lodash": {
+      "version": "4.17.4",
+      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.4.tgz",
+      "integrity": "sha1-eCA6TRwyiuHYbcpkYONptX9AVa4=",
+      "dev": true
+    },
+    "longest": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/longest/-/longest-1.0.1.tgz",
+      "integrity": "sha1-MKCy2jj3N3DoKUoNIuZiXtd9AJc=",
+      "dev": true
+    },
+    "loose-envify": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.3.1.tgz",
+      "integrity": "sha1-0aitM/qc4OcT1l/dCsi3SNR4yEg=",
+      "dev": true,
+      "requires": {
+        "js-tokens": "3.0.2"
+      }
+    },
+    "lru-cache": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.1.tgz",
+      "integrity": "sha512-q4spe4KTfsAS1SUHLO0wz8Qiyf1+vMIAgpRYioFYDMNqKfHQbg+AVDH3i4fvpl71/P1L0dBl+fQi+P37UYf0ew==",
+      "dev": true,
+      "requires": {
+        "pseudomap": "1.0.2",
+        "yallist": "2.1.2"
+      }
+    },
+    "md5.js": {
+      "version": "1.3.4",
+      "resolved": "https://registry.npmjs.org/md5.js/-/md5.js-1.3.4.tgz",
+      "integrity": "sha1-6b296UogpawYsENA/Fdk1bCdkB0=",
+      "dev": true,
+      "requires": {
+        "hash-base": "3.0.4",
+        "inherits": "2.0.3"
+      },
+      "dependencies": {
+        "hash-base": {
+          "version": "3.0.4",
+          "resolved": "https://registry.npmjs.org/hash-base/-/hash-base-3.0.4.tgz",
+          "integrity": "sha1-X8hoaEfs1zSZQDMZprCj8/auSRg=",
+          "dev": true,
+          "requires": {
+            "inherits": "2.0.3",
+            "safe-buffer": "5.1.1"
+          }
+        }
+      }
+    },
+    "mem": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/mem/-/mem-1.1.0.tgz",
+      "integrity": "sha1-Xt1StIXKHZAP5kiVUFOZoN+kX3Y=",
+      "dev": true,
+      "requires": {
+        "mimic-fn": "1.1.0"
+      }
+    },
+    "memory-fs": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/memory-fs/-/memory-fs-0.4.1.tgz",
+      "integrity": "sha1-OpoguEYlI+RHz7x+i7gO1me/xVI=",
+      "dev": true,
+      "requires": {
+        "errno": "0.1.6",
+        "readable-stream": "2.3.3"
+      }
+    },
+    "micromatch": {
+      "version": "2.3.11",
+      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-2.3.11.tgz",
+      "integrity": "sha1-hmd8l9FyCzY0MdBNDRUpO9OMFWU=",
+      "dev": true,
+      "requires": {
+        "arr-diff": "2.0.0",
+        "array-unique": "0.2.1",
+        "braces": "1.8.5",
+        "expand-brackets": "0.1.5",
+        "extglob": "0.3.2",
+        "filename-regex": "2.0.1",
+        "is-extglob": "1.0.0",
+        "is-glob": "2.0.1",
+        "kind-of": "3.2.2",
+        "normalize-path": "2.1.1",
+        "object.omit": "2.0.1",
+        "parse-glob": "3.0.4",
+        "regex-cache": "0.4.4"
+      }
+    },
+    "miller-rabin": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/miller-rabin/-/miller-rabin-4.0.1.tgz",
+      "integrity": "sha512-115fLhvZVqWwHPbClyntxEVfVDfl9DLLTuJvq3g2O/Oxi8AiNouAHvDSzHS0viUJc+V5vm3eq91Xwqn9dp4jRA==",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "brorand": "1.1.0"
+      }
+    },
+    "mimic-fn": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-1.1.0.tgz",
+      "integrity": "sha1-5md4PZLonb00KBi1IwudYqZyrRg=",
+      "dev": true
+    },
+    "minimalistic-assert": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.0.tgz",
+      "integrity": "sha1-cCvi3aazf0g2vLP121ZkG2Sh09M=",
+      "dev": true
+    },
+    "minimalistic-crypto-utils": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
+      "integrity": "sha1-9sAMHAsIIkblxNmd+4x8CDsrWCo=",
+      "dev": true
+    },
+    "minimatch": {
+      "version": "3.0.4",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
+      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
+      "dev": true,
+      "requires": {
+        "brace-expansion": "1.1.8"
+      }
+    },
+    "minimist": {
+      "version": "0.0.8",
+      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz",
+      "integrity": "sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0=",
+      "dev": true
+    },
+    "mkdirp": {
+      "version": "0.5.1",
+      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz",
+      "integrity": "sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=",
+      "dev": true,
+      "requires": {
+        "minimist": "0.0.8"
+      }
+    },
+    "ms": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
+      "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
+      "dev": true
+    },
+    "nan": {
+      "version": "2.8.0",
+      "resolved": "https://registry.npmjs.org/nan/-/nan-2.8.0.tgz",
+      "integrity": "sha1-7XFfP+neArV6XmJS2QqWZ14fCFo=",
+      "dev": true,
+      "optional": true
+    },
+    "node-libs-browser": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/node-libs-browser/-/node-libs-browser-2.1.0.tgz",
+      "integrity": "sha512-5AzFzdoIMb89hBGMZglEegffzgRg+ZFoUmisQ8HI4j1KDdpx13J0taNp2y9xPbur6W61gepGDDotGBVQ7mfUCg==",
+      "dev": true,
+      "requires": {
+        "assert": "1.4.1",
+        "browserify-zlib": "0.2.0",
+        "buffer": "4.9.1",
+        "console-browserify": "1.1.0",
+        "constants-browserify": "1.0.0",
+        "crypto-browserify": "3.12.0",
+        "domain-browser": "1.1.7",
+        "events": "1.1.1",
+        "https-browserify": "1.0.0",
+        "os-browserify": "0.3.0",
+        "path-browserify": "0.0.0",
+        "process": "0.11.10",
+        "punycode": "1.4.1",
+        "querystring-es3": "0.2.1",
+        "readable-stream": "2.3.3",
+        "stream-browserify": "2.0.1",
+        "stream-http": "2.7.2",
+        "string_decoder": "1.0.3",
+        "timers-browserify": "2.0.4",
+        "tty-browserify": "0.0.0",
+        "url": "0.11.0",
+        "util": "0.10.3",
+        "vm-browserify": "0.0.4"
+      }
+    },
+    "normalize-package-data": {
+      "version": "2.4.0",
+      "resolved": "https://registry.npmjs.org/normalize-package-data/-/normalize-package-data-2.4.0.tgz",
+      "integrity": "sha512-9jjUFbTPfEy3R/ad/2oNbKtW9Hgovl5O1FvFWKkKblNXoN/Oou6+9+KKohPK13Yc3/TyunyWhJp6gvRNR/PPAw==",
+      "dev": true,
+      "requires": {
+        "hosted-git-info": "2.5.0",
+        "is-builtin-module": "1.0.0",
+        "semver": "5.4.1",
+        "validate-npm-package-license": "3.0.1"
+      }
+    },
+    "normalize-path": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-2.1.1.tgz",
+      "integrity": "sha1-GrKLVW4Zg2Oowab35vogE3/mrtk=",
+      "dev": true,
+      "requires": {
+        "remove-trailing-separator": "1.1.0"
+      }
+    },
+    "npm-run-path": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-2.0.2.tgz",
+      "integrity": "sha1-NakjLfo11wZ7TLLd8jV7GHFTbF8=",
+      "dev": true,
+      "requires": {
+        "path-key": "2.0.1"
+      }
+    },
+    "number-is-nan": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz",
+      "integrity": "sha1-CXtgK1NCKlIsGvuHkDGDNpQaAR0=",
+      "dev": true
+    },
+    "object-assign": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
+      "integrity": "sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=",
+      "dev": true
+    },
+    "object.omit": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/object.omit/-/object.omit-2.0.1.tgz",
+      "integrity": "sha1-Gpx0SCnznbuFjHbKNXmuKlTr0fo=",
+      "dev": true,
+      "requires": {
+        "for-own": "0.1.5",
+        "is-extendable": "0.1.1"
+      }
+    },
+    "os-browserify": {
+      "version": "0.3.0",
+      "resolved": "https://registry.npmjs.org/os-browserify/-/os-browserify-0.3.0.tgz",
+      "integrity": "sha1-hUNzx/XCMVkU/Jv8a9gjj92h7Cc=",
+      "dev": true
+    },
+    "os-locale": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/os-locale/-/os-locale-2.1.0.tgz",
+      "integrity": "sha512-3sslG3zJbEYcaC4YVAvDorjGxc7tv6KVATnLPZONiljsUncvihe9BQoVCEs0RZ1kmf4Hk9OBqlZfJZWI4GanKA==",
+      "dev": true,
+      "requires": {
+        "execa": "0.7.0",
+        "lcid": "1.0.0",
+        "mem": "1.1.0"
+      }
+    },
+    "p-finally": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/p-finally/-/p-finally-1.0.0.tgz",
+      "integrity": "sha1-P7z7FbiZpEEjs0ttzBi3JDNqLK4=",
+      "dev": true
+    },
+    "p-limit": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-1.2.0.tgz",
+      "integrity": "sha512-Y/OtIaXtUPr4/YpMv1pCL5L5ed0rumAaAeBSj12F+bSlMdys7i8oQF/GUJmfpTS/QoaRrS/k6pma29haJpsMng==",
+      "dev": true,
+      "requires": {
+        "p-try": "1.0.0"
+      }
+    },
+    "p-locate": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-2.0.0.tgz",
+      "integrity": "sha1-IKAQOyIqcMj9OcwuWAaA893l7EM=",
+      "dev": true,
+      "requires": {
+        "p-limit": "1.2.0"
+      }
+    },
+    "p-try": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/p-try/-/p-try-1.0.0.tgz",
+      "integrity": "sha1-y8ec26+P1CKOE/Yh8rGiN8GyB7M=",
+      "dev": true
+    },
+    "pako": {
+      "version": "1.0.6",
+      "resolved": "https://registry.npmjs.org/pako/-/pako-1.0.6.tgz",
+      "integrity": "sha512-lQe48YPsMJAig+yngZ87Lus+NF+3mtu7DVOBu6b/gHO1YpKwIj5AWjZ/TOS7i46HD/UixzWb1zeWDZfGZ3iYcg==",
+      "dev": true
+    },
+    "parse-asn1": {
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/parse-asn1/-/parse-asn1-5.1.0.tgz",
+      "integrity": "sha1-N8T5t+06tlx0gXtfJICTf7+XxxI=",
+      "dev": true,
+      "requires": {
+        "asn1.js": "4.9.2",
+        "browserify-aes": "1.1.1",
+        "create-hash": "1.1.3",
+        "evp_bytestokey": "1.0.3",
+        "pbkdf2": "3.0.14"
+      }
+    },
+    "parse-glob": {
+      "version": "3.0.4",
+      "resolved": "https://registry.npmjs.org/parse-glob/-/parse-glob-3.0.4.tgz",
+      "integrity": "sha1-ssN2z7EfNVE7rdFz7wu246OIORw=",
+      "dev": true,
+      "requires": {
+        "glob-base": "0.3.0",
+        "is-dotfile": "1.0.3",
+        "is-extglob": "1.0.0",
+        "is-glob": "2.0.1"
+      }
+    },
+    "parse-json": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-2.2.0.tgz",
+      "integrity": "sha1-9ID0BDTvgHQfhGkJn43qGPVaTck=",
+      "dev": true,
+      "requires": {
+        "error-ex": "1.3.1"
+      }
+    },
+    "path-browserify": {
+      "version": "0.0.0",
+      "resolved": "https://registry.npmjs.org/path-browserify/-/path-browserify-0.0.0.tgz",
+      "integrity": "sha1-oLhwcpquIUAFt9UDLsLLuw+0RRo=",
+      "dev": true
+    },
+    "path-exists": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-3.0.0.tgz",
+      "integrity": "sha1-zg6+ql94yxiSXqfYENe1mwEP1RU=",
+      "dev": true
+    },
+    "path-is-absolute": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
+      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
+      "dev": true
+    },
+    "path-key": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/path-key/-/path-key-2.0.1.tgz",
+      "integrity": "sha1-QRyttXTFoUDTpLGRDUDYDMn0C0A=",
+      "dev": true
+    },
+    "path-type": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/path-type/-/path-type-2.0.0.tgz",
+      "integrity": "sha1-8BLMuEFbcJb8LaoQVMPXI4lZTHM=",
+      "dev": true,
+      "requires": {
+        "pify": "2.3.0"
+      }
+    },
+    "pbkdf2": {
+      "version": "3.0.14",
+      "resolved": "https://registry.npmjs.org/pbkdf2/-/pbkdf2-3.0.14.tgz",
+      "integrity": "sha512-gjsZW9O34fm0R7PaLHRJmLLVfSoesxztjPjE9o6R+qtVJij90ltg1joIovN9GKrRW3t1PzhDDG3UMEMFfZ+1wA==",
+      "dev": true,
+      "requires": {
+        "create-hash": "1.1.3",
+        "create-hmac": "1.1.6",
+        "ripemd160": "2.0.1",
+        "safe-buffer": "5.1.1",
+        "sha.js": "2.4.9"
+      }
+    },
+    "pify": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
+      "integrity": "sha1-7RQaasBDqEnqWISY59yosVMw6Qw=",
+      "dev": true
+    },
+    "preserve": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/preserve/-/preserve-0.2.0.tgz",
+      "integrity": "sha1-gV7R9uvGWSb4ZbMQwHE7yzMVzks=",
+      "dev": true
+    },
+    "private": {
+      "version": "0.1.8",
+      "resolved": "https://registry.npmjs.org/private/-/private-0.1.8.tgz",
+      "integrity": "sha512-VvivMrbvd2nKkiG38qjULzlc+4Vx4wm/whI9pQD35YrARNnhxeiRktSOhSukRLFNlzg6Br/cJPet5J/u19r/mg==",
+      "dev": true
+    },
+    "process": {
+      "version": "0.11.10",
+      "resolved": "https://registry.npmjs.org/process/-/process-0.11.10.tgz",
+      "integrity": "sha1-czIwDoQBYb2j5podHZGn1LwW8YI=",
+      "dev": true
+    },
+    "process-nextick-args": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-1.0.7.tgz",
+      "integrity": "sha1-FQ4gt1ZZCtP5EJPyWk8q2L/zC6M=",
+      "dev": true
+    },
+    "prr": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/prr/-/prr-1.0.1.tgz",
+      "integrity": "sha1-0/wRS6BplaRexok/SEzrHXj19HY=",
+      "dev": true
+    },
+    "pseudomap": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/pseudomap/-/pseudomap-1.0.2.tgz",
+      "integrity": "sha1-8FKijacOYYkX7wqKw0wa5aaChrM=",
+      "dev": true
+    },
+    "public-encrypt": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/public-encrypt/-/public-encrypt-4.0.0.tgz",
+      "integrity": "sha1-OfaZ86RlYN1eusvKaTyvfGXBjMY=",
+      "dev": true,
+      "requires": {
+        "bn.js": "4.11.8",
+        "browserify-rsa": "4.0.1",
+        "create-hash": "1.1.3",
+        "parse-asn1": "5.1.0",
+        "randombytes": "2.0.6"
+      }
+    },
+    "punycode": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.4.1.tgz",
+      "integrity": "sha1-wNWmOycYgArY4esPpSachN1BhF4=",
+      "dev": true
+    },
+    "querystring": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/querystring/-/querystring-0.2.0.tgz",
+      "integrity": "sha1-sgmEkgO7Jd+CDadW50cAWHhSFiA=",
+      "dev": true
+    },
+    "querystring-es3": {
+      "version": "0.2.1",
+      "resolved": "https://registry.npmjs.org/querystring-es3/-/querystring-es3-0.2.1.tgz",
+      "integrity": "sha1-nsYfeQSYdXB9aUFFlv2Qek1xHnM=",
+      "dev": true
+    },
+    "randomatic": {
+      "version": "1.1.7",
+      "resolved": "https://registry.npmjs.org/randomatic/-/randomatic-1.1.7.tgz",
+      "integrity": "sha512-D5JUjPyJbaJDkuAazpVnSfVkLlpeO3wDlPROTMLGKG1zMFNFRgrciKo1ltz/AzNTkqE0HzDx655QOL51N06how==",
+      "dev": true,
+      "requires": {
+        "is-number": "3.0.0",
+        "kind-of": "4.0.0"
+      },
+      "dependencies": {
+        "is-number": {
+          "version": "3.0.0",
+          "resolved": "https://registry.npmjs.org/is-number/-/is-number-3.0.0.tgz",
+          "integrity": "sha1-JP1iAaR4LPUFYcgQJ2r8fRLXEZU=",
+          "dev": true,
+          "requires": {
+            "kind-of": "3.2.2"
+          },
+          "dependencies": {
+            "kind-of": {
+              "version": "3.2.2",
+              "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
+              "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
+              "dev": true,
+              "requires": {
+                "is-buffer": "1.1.6"
+              }
+            }
+          }
+        },
+        "kind-of": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-4.0.0.tgz",
+          "integrity": "sha1-IIE989cSkosgc3hpGkUGb65y3Vc=",
+          "dev": true,
+          "requires": {
+            "is-buffer": "1.1.6"
+          }
+        }
+      }
+    },
+    "randombytes": {
+      "version": "2.0.6",
+      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.0.6.tgz",
+      "integrity": "sha512-CIQ5OFxf4Jou6uOKe9t1AOgqpeU5fd70A8NPdHSGeYXqXsPe6peOwI0cUl88RWZ6sP1vPMV3avd/R6cZ5/sP1A==",
+      "dev": true,
+      "requires": {
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "randomfill": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/randomfill/-/randomfill-1.0.3.tgz",
+      "integrity": "sha512-YL6GrhrWoic0Eq8rXVbMptH7dAxCs0J+mh5Y0euNekPPYaxEmdVGim6GdoxoRzKW2yJoU8tueifS7mYxvcFDEQ==",
+      "dev": true,
+      "requires": {
+        "randombytes": "2.0.6",
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "read-pkg": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/read-pkg/-/read-pkg-2.0.0.tgz",
+      "integrity": "sha1-jvHAYjxqbbDcZxPEv6xGMysjaPg=",
+      "dev": true,
+      "requires": {
+        "load-json-file": "2.0.0",
+        "normalize-package-data": "2.4.0",
+        "path-type": "2.0.0"
+      }
+    },
+    "read-pkg-up": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/read-pkg-up/-/read-pkg-up-2.0.0.tgz",
+      "integrity": "sha1-a3KoBImE4MQeeVEP1en6mbO1Sb4=",
+      "dev": true,
+      "requires": {
+        "find-up": "2.1.0",
+        "read-pkg": "2.0.0"
+      }
+    },
+    "readable-stream": {
+      "version": "2.3.3",
+      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.3.tgz",
+      "integrity": "sha512-m+qzzcn7KUxEmd1gMbchF+Y2eIUbieUaxkWtptyHywrX0rE8QEYqPC07Vuy4Wm32/xE16NcdBctb8S0Xe/5IeQ==",
+      "dev": true,
+      "requires": {
+        "core-util-is": "1.0.2",
+        "inherits": "2.0.3",
+        "isarray": "1.0.0",
+        "process-nextick-args": "1.0.7",
+        "safe-buffer": "5.1.1",
+        "string_decoder": "1.0.3",
+        "util-deprecate": "1.0.2"
+      }
+    },
+    "readdirp": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-2.1.0.tgz",
+      "integrity": "sha1-TtCtBg3zBzMAxIRANz9y0cxkLXg=",
+      "dev": true,
+      "requires": {
+        "graceful-fs": "4.1.11",
+        "minimatch": "3.0.4",
+        "readable-stream": "2.3.3",
+        "set-immediate-shim": "1.0.1"
+      }
+    },
+    "regenerate": {
+      "version": "1.3.3",
+      "resolved": "https://registry.npmjs.org/regenerate/-/regenerate-1.3.3.tgz",
+      "integrity": "sha512-jVpo1GadrDAK59t/0jRx5VxYWQEDkkEKi6+HjE3joFVLfDOh9Xrdh0dF1eSq+BI/SwvTQ44gSscJ8N5zYL61sg==",
+      "dev": true
+    },
+    "regenerator-runtime": {
+      "version": "0.11.1",
+      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.11.1.tgz",
+      "integrity": "sha512-MguG95oij0fC3QV3URf4V2SDYGJhJnJGqvIIgdECeODCT98wSWDAJ94SSuVpYQUoTcGUIL6L4yNB7j1DFFHSBg==",
+      "dev": true
+    },
+    "regenerator-transform": {
+      "version": "0.10.1",
+      "resolved": "https://registry.npmjs.org/regenerator-transform/-/regenerator-transform-0.10.1.tgz",
+      "integrity": "sha512-PJepbvDbuK1xgIgnau7Y90cwaAmO/LCLMI2mPvaXq2heGMR3aWW5/BQvYrhJ8jgmQjXewXvBjzfqKcVOmhjZ6Q==",
+      "dev": true,
+      "requires": {
+        "babel-runtime": "6.26.0",
+        "babel-types": "6.26.0",
+        "private": "0.1.8"
+      }
+    },
+    "regex-cache": {
+      "version": "0.4.4",
+      "resolved": "https://registry.npmjs.org/regex-cache/-/regex-cache-0.4.4.tgz",
+      "integrity": "sha512-nVIZwtCjkC9YgvWkpM55B5rBhBYRZhAaJbgcFYXXsHnbZ9UZI9nnVWYZpBlCqv9ho2eZryPnWrZGsOdPwVWXWQ==",
+      "dev": true,
+      "requires": {
+        "is-equal-shallow": "0.1.3"
+      }
+    },
+    "regexpu-core": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-2.0.0.tgz",
+      "integrity": "sha1-SdA4g3uNz4v6W5pCE5k45uoq4kA=",
+      "dev": true,
+      "requires": {
+        "regenerate": "1.3.3",
+        "regjsgen": "0.2.0",
+        "regjsparser": "0.1.5"
+      }
+    },
+    "regjsgen": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.2.0.tgz",
+      "integrity": "sha1-bAFq3qxVT3WCP+N6wFuS1aTtsfc=",
+      "dev": true
+    },
+    "regjsparser": {
+      "version": "0.1.5",
+      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.1.5.tgz",
+      "integrity": "sha1-fuj4Tcb6eS0/0K4ijSS9lJ6tIFw=",
+      "dev": true,
+      "requires": {
+        "jsesc": "0.5.0"
+      }
+    },
+    "remove-trailing-separator": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/remove-trailing-separator/-/remove-trailing-separator-1.1.0.tgz",
+      "integrity": "sha1-wkvOKig62tW8P1jg1IJJuSN52O8=",
+      "dev": true
+    },
+    "repeat-element": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/repeat-element/-/repeat-element-1.1.2.tgz",
+      "integrity": "sha1-7wiaF40Ug7quTZPrmLT55OEdmQo=",
+      "dev": true
+    },
+    "repeat-string": {
+      "version": "1.6.1",
+      "resolved": "https://registry.npmjs.org/repeat-string/-/repeat-string-1.6.1.tgz",
+      "integrity": "sha1-jcrkcOHIirwtYA//Sndihtp15jc=",
+      "dev": true
+    },
+    "require-directory": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
+      "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
+      "dev": true
+    },
+    "require-main-filename": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-1.0.1.tgz",
+      "integrity": "sha1-l/cXtp1IeE9fUmpsWqj/3aBVpNE=",
+      "dev": true
+    },
+    "right-align": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/right-align/-/right-align-0.1.3.tgz",
+      "integrity": "sha1-YTObci/mo1FWiSENJOFMlhSGE+8=",
+      "dev": true,
+      "requires": {
+        "align-text": "0.1.4"
+      }
+    },
+    "ripemd160": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/ripemd160/-/ripemd160-2.0.1.tgz",
+      "integrity": "sha1-D0WEKVxTo2KK9+bXmsohzlfRxuc=",
+      "dev": true,
+      "requires": {
+        "hash-base": "2.0.2",
+        "inherits": "2.0.3"
+      }
+    },
+    "safe-buffer": {
+      "version": "5.1.1",
+      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.1.tgz",
+      "integrity": "sha512-kKvNJn6Mm93gAczWVJg7wH+wGYWNrDHdWvpUmHyEsgCtIwwo3bqPtV4tR5tuPaUhTOo/kvhVwd8XwwOllGYkbg==",
+      "dev": true
+    },
+    "semver": {
+      "version": "5.4.1",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-5.4.1.tgz",
+      "integrity": "sha512-WfG/X9+oATh81XtllIo/I8gOiY9EXRdv1cQdyykeXK17YcUW3EXUAi2To4pcH6nZtJPr7ZOpM5OMyWJZm+8Rsg==",
+      "dev": true
+    },
+    "set-blocking": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
+      "integrity": "sha1-BF+XgtARrppoA93TgrJDkrPYkPc=",
+      "dev": true
+    },
+    "set-immediate-shim": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/set-immediate-shim/-/set-immediate-shim-1.0.1.tgz",
+      "integrity": "sha1-SysbJ+uAip+NzEgaWOXlb1mfP2E=",
+      "dev": true
+    },
+    "setimmediate": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/setimmediate/-/setimmediate-1.0.5.tgz",
+      "integrity": "sha1-KQy7Iy4waULX1+qbg3Mqt4VvgoU=",
+      "dev": true
+    },
+    "sha.js": {
+      "version": "2.4.9",
+      "resolved": "https://registry.npmjs.org/sha.js/-/sha.js-2.4.9.tgz",
+      "integrity": "sha512-G8zektVqbiPHrylgew9Zg1VRB1L/DtXNUVAM6q4QLy8NE3qtHlFXTf8VLL4k1Yl6c7NMjtZUTdXV+X44nFaT6A==",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.3",
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "shebang-command": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-1.2.0.tgz",
+      "integrity": "sha1-RKrGW2lbAzmJaMOfNj/uXer98eo=",
+      "dev": true,
+      "requires": {
+        "shebang-regex": "1.0.0"
+      }
+    },
+    "shebang-regex": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-1.0.0.tgz",
+      "integrity": "sha1-2kL0l0DAtC2yypcoVxyxkMmO/qM=",
+      "dev": true
+    },
+    "signal-exit": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.2.tgz",
+      "integrity": "sha1-tf3AjxKH6hF4Yo5BXiUTK3NkbG0=",
+      "dev": true
+    },
+    "source-list-map": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/source-list-map/-/source-list-map-2.0.0.tgz",
+      "integrity": "sha512-I2UmuJSRr/T8jisiROLU3A3ltr+swpniSmNPI4Ml3ZCX6tVnDsuZzK7F2hl5jTqbZBWCEKlj5HRQiPExXLgE8A==",
+      "dev": true
+    },
+    "source-map": {
+      "version": "0.5.7",
+      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
+      "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
+      "dev": true
+    },
+    "spdx-correct": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/spdx-correct/-/spdx-correct-1.0.2.tgz",
+      "integrity": "sha1-SzBz2TP/UfORLwOsVRlJikFQ20A=",
+      "dev": true,
+      "requires": {
+        "spdx-license-ids": "1.2.2"
+      }
+    },
+    "spdx-expression-parse": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/spdx-expression-parse/-/spdx-expression-parse-1.0.4.tgz",
+      "integrity": "sha1-m98vIOH0DtRH++JzJmGR/O1RYmw=",
+      "dev": true
+    },
+    "spdx-license-ids": {
+      "version": "1.2.2",
+      "resolved": "https://registry.npmjs.org/spdx-license-ids/-/spdx-license-ids-1.2.2.tgz",
+      "integrity": "sha1-yd96NCRZSt5r0RkA1ZZpbcBrrFc=",
+      "dev": true
+    },
+    "stream-browserify": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/stream-browserify/-/stream-browserify-2.0.1.tgz",
+      "integrity": "sha1-ZiZu5fm9uZQKTkUUyvtDu3Hlyds=",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.3",
+        "readable-stream": "2.3.3"
+      }
+    },
+    "stream-http": {
+      "version": "2.7.2",
+      "resolved": "https://registry.npmjs.org/stream-http/-/stream-http-2.7.2.tgz",
+      "integrity": "sha512-c0yTD2rbQzXtSsFSVhtpvY/vS6u066PcXOX9kBB3mSO76RiUQzL340uJkGBWnlBg4/HZzqiUXtaVA7wcRcJgEw==",
+      "dev": true,
+      "requires": {
+        "builtin-status-codes": "3.0.0",
+        "inherits": "2.0.3",
+        "readable-stream": "2.3.3",
+        "to-arraybuffer": "1.0.1",
+        "xtend": "4.0.1"
+      }
+    },
+    "string-width": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
+      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
+      "dev": true,
+      "requires": {
+        "is-fullwidth-code-point": "2.0.0",
+        "strip-ansi": "4.0.0"
+      },
+      "dependencies": {
+        "ansi-regex": {
+          "version": "3.0.0",
+          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
+          "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
+          "dev": true
+        },
+        "is-fullwidth-code-point": {
+          "version": "2.0.0",
+          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
+          "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=",
+          "dev": true
+        },
+        "strip-ansi": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
+          "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
+          "dev": true,
+          "requires": {
+            "ansi-regex": "3.0.0"
+          }
+        }
+      }
+    },
+    "string_decoder": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.0.3.tgz",
+      "integrity": "sha512-4AH6Z5fzNNBcH+6XDMfA/BTt87skxqJlO0lAh3Dker5zThcAxG6mKz+iGu308UKoPPQ8Dcqx/4JhujzltRa+hQ==",
+      "dev": true,
+      "requires": {
+        "safe-buffer": "5.1.1"
+      }
+    },
+    "strip-ansi": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
+      "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
+      "dev": true,
+      "requires": {
+        "ansi-regex": "2.1.1"
+      }
+    },
+    "strip-bom": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
+      "integrity": "sha1-IzTBjpx1n3vdVv3vfprj1YjmjtM=",
+      "dev": true
+    },
+    "strip-eof": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
+      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=",
+      "dev": true
+    },
+    "supports-color": {
+      "version": "4.5.0",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-4.5.0.tgz",
+      "integrity": "sha1-vnoN5ITexcXN34s9WRJQRJEvY1s=",
+      "dev": true,
+      "requires": {
+        "has-flag": "2.0.0"
+      }
+    },
+    "tapable": {
+      "version": "0.2.8",
+      "resolved": "https://registry.npmjs.org/tapable/-/tapable-0.2.8.tgz",
+      "integrity": "sha1-mTcqXJmb8t8WCvwNdL7U9HlIzSI=",
+      "dev": true
+    },
+    "timers-browserify": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/timers-browserify/-/timers-browserify-2.0.4.tgz",
+      "integrity": "sha512-uZYhyU3EX8O7HQP+J9fTVYwsq90Vr68xPEFo7yrVImIxYvHgukBEgOB/SgGoorWVTzGM/3Z+wUNnboA4M8jWrg==",
+      "dev": true,
+      "requires": {
+        "setimmediate": "1.0.5"
+      }
+    },
+    "to-arraybuffer": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/to-arraybuffer/-/to-arraybuffer-1.0.1.tgz",
+      "integrity": "sha1-fSKbH8xjfkZsoIEYCDanqr/4P0M=",
+      "dev": true
+    },
+    "to-fast-properties": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-1.0.3.tgz",
+      "integrity": "sha1-uDVx+k2MJbguIxsG46MFXeTKGkc=",
+      "dev": true
+    },
+    "tty-browserify": {
+      "version": "0.0.0",
+      "resolved": "https://registry.npmjs.org/tty-browserify/-/tty-browserify-0.0.0.tgz",
+      "integrity": "sha1-oVe6QC2iTpv5V/mqadUk7tQpAaY=",
+      "dev": true
+    },
+    "uglify-js": {
+      "version": "2.8.29",
+      "resolved": "https://registry.npmjs.org/uglify-js/-/uglify-js-2.8.29.tgz",
+      "integrity": "sha1-KcVzMUgFe7Th913zW3qcty5qWd0=",
+      "dev": true,
+      "requires": {
+        "source-map": "0.5.7",
+        "uglify-to-browserify": "1.0.2",
+        "yargs": "3.10.0"
+      },
+      "dependencies": {
+        "yargs": {
+          "version": "3.10.0",
+          "resolved": "https://registry.npmjs.org/yargs/-/yargs-3.10.0.tgz",
+          "integrity": "sha1-9+572FfdfB0tOMDnTvvWgdFDH9E=",
+          "dev": true,
+          "requires": {
+            "camelcase": "1.2.1",
+            "cliui": "2.1.0",
+            "decamelize": "1.2.0",
+            "window-size": "0.1.0"
+          }
+        }
+      }
+    },
+    "uglify-to-browserify": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/uglify-to-browserify/-/uglify-to-browserify-1.0.2.tgz",
+      "integrity": "sha1-bgkk1r2mta/jSeOabWMoUKD4grc=",
+      "dev": true,
+      "optional": true
+    },
+    "uglifyjs-webpack-plugin": {
+      "version": "0.4.6",
+      "resolved": "https://registry.npmjs.org/uglifyjs-webpack-plugin/-/uglifyjs-webpack-plugin-0.4.6.tgz",
+      "integrity": "sha1-uVH0q7a9YX5m9j64kUmOORdj4wk=",
+      "dev": true,
+      "requires": {
+        "source-map": "0.5.7",
+        "uglify-js": "2.8.29",
+        "webpack-sources": "1.1.0"
+      }
+    },
+    "url": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/url/-/url-0.11.0.tgz",
+      "integrity": "sha1-ODjpfPxgUh63PFJajlW/3Z4uKPE=",
+      "dev": true,
+      "requires": {
+        "punycode": "1.3.2",
+        "querystring": "0.2.0"
+      },
+      "dependencies": {
+        "punycode": {
+          "version": "1.3.2",
+          "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.3.2.tgz",
+          "integrity": "sha1-llOgNvt8HuQjQvIyXM7v6jkmxI0=",
+          "dev": true
+        }
+      }
+    },
+    "util": {
+      "version": "0.10.3",
+      "resolved": "https://registry.npmjs.org/util/-/util-0.10.3.tgz",
+      "integrity": "sha1-evsa/lCAUkZInj23/g7TeTNqwPk=",
+      "dev": true,
+      "requires": {
+        "inherits": "2.0.1"
+      },
+      "dependencies": {
+        "inherits": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz",
+          "integrity": "sha1-sX0I0ya0Qj5Wjv9xn5GwscvfafE=",
+          "dev": true
+        }
+      }
+    },
+    "util-deprecate": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
+      "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8=",
+      "dev": true
+    },
+    "validate-npm-package-license": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/validate-npm-package-license/-/validate-npm-package-license-3.0.1.tgz",
+      "integrity": "sha1-KAS6vnEq0zeUWaz74kdGqywwP7w=",
+      "dev": true,
+      "requires": {
+        "spdx-correct": "1.0.2",
+        "spdx-expression-parse": "1.0.4"
+      }
+    },
+    "vm-browserify": {
+      "version": "0.0.4",
+      "resolved": "https://registry.npmjs.org/vm-browserify/-/vm-browserify-0.0.4.tgz",
+      "integrity": "sha1-XX6kW7755Kb/ZflUOOCofDV9WnM=",
+      "dev": true,
+      "requires": {
+        "indexof": "0.0.1"
+      }
+    },
+    "watchpack": {
+      "version": "1.4.0",
+      "resolved": "https://registry.npmjs.org/watchpack/-/watchpack-1.4.0.tgz",
+      "integrity": "sha1-ShRyvLuVK9Cpu0A2gB+VTfs5+qw=",
+      "dev": true,
+      "requires": {
+        "async": "2.6.0",
+        "chokidar": "1.7.0",
+        "graceful-fs": "4.1.11"
+      }
+    },
+    "webpack": {
+      "version": "3.10.0",
+      "resolved": "https://registry.npmjs.org/webpack/-/webpack-3.10.0.tgz",
+      "integrity": "sha512-fxxKXoicjdXNUMY7LIdY89tkJJJ0m1Oo8PQutZ5rLgWbV5QVKI15Cn7+/IHnRTd3vfKfiwBx6SBqlorAuNA8LA==",
+      "dev": true,
+      "requires": {
+        "acorn": "5.3.0",
+        "acorn-dynamic-import": "2.0.2",
+        "ajv": "5.5.2",
+        "ajv-keywords": "2.1.1",
+        "async": "2.6.0",
+        "enhanced-resolve": "3.4.1",
+        "escope": "3.6.0",
+        "interpret": "1.1.0",
+        "json-loader": "0.5.7",
+        "json5": "0.5.1",
+        "loader-runner": "2.3.0",
+        "loader-utils": "1.1.0",
+        "memory-fs": "0.4.1",
+        "mkdirp": "0.5.1",
+        "node-libs-browser": "2.1.0",
+        "source-map": "0.5.7",
+        "supports-color": "4.5.0",
+        "tapable": "0.2.8",
+        "uglifyjs-webpack-plugin": "0.4.6",
+        "watchpack": "1.4.0",
+        "webpack-sources": "1.1.0",
+        "yargs": "8.0.2"
+      }
+    },
+    "webpack-sources": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/webpack-sources/-/webpack-sources-1.1.0.tgz",
+      "integrity": "sha512-aqYp18kPphgoO5c/+NaUvEeACtZjMESmDChuD3NBciVpah3XpMEU9VAAtIaB1BsfJWWTSdv8Vv1m3T0aRk2dUw==",
+      "dev": true,
+      "requires": {
+        "source-list-map": "2.0.0",
+        "source-map": "0.6.1"
+      },
+      "dependencies": {
+        "source-map": {
+          "version": "0.6.1",
+          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
+          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
+          "dev": true
+        }
+      }
+    },
+    "which": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/which/-/which-1.3.0.tgz",
+      "integrity": "sha512-xcJpopdamTuY5duC/KnTTNBraPK54YwpenP4lzxU8H91GudWpFv38u0CKjclE1Wi2EH2EDz5LRcHcKbCIzqGyg==",
+      "dev": true,
+      "requires": {
+        "isexe": "2.0.0"
+      }
+    },
+    "which-module": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/which-module/-/which-module-2.0.0.tgz",
+      "integrity": "sha1-2e8H3Od7mQK4o6j6SzHD4/fm6Ho=",
+      "dev": true
+    },
+    "window-size": {
+      "version": "0.1.0",
+      "resolved": "https://registry.npmjs.org/window-size/-/window-size-0.1.0.tgz",
+      "integrity": "sha1-VDjNLqk7IC76Ohn+iIeu58lPnJ0=",
+      "dev": true
+    },
+    "wordwrap": {
+      "version": "0.0.2",
+      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.2.tgz",
+      "integrity": "sha1-t5Zpu0LstAn4PVg8rVLKF+qhZD8=",
+      "dev": true
+    },
+    "wrap-ansi": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
+      "integrity": "sha1-2Pw9KE3QV5T+hJc8rs3Rz4JP3YU=",
+      "dev": true,
+      "requires": {
+        "string-width": "1.0.2",
+        "strip-ansi": "3.0.1"
+      },
+      "dependencies": {
+        "string-width": {
+          "version": "1.0.2",
+          "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
+          "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
+          "dev": true,
+          "requires": {
+            "code-point-at": "1.1.0",
+            "is-fullwidth-code-point": "1.0.0",
+            "strip-ansi": "3.0.1"
+          }
+        }
+      }
+    },
+    "xtend": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.1.tgz",
+      "integrity": "sha1-pcbVMr5lbiPbgg77lDofBJmNY68=",
+      "dev": true
+    },
+    "y18n": {
+      "version": "3.2.1",
+      "resolved": "https://registry.npmjs.org/y18n/-/y18n-3.2.1.tgz",
+      "integrity": "sha1-bRX7qITAhnnA136I53WegR4H+kE=",
+      "dev": true
+    },
+    "yallist": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmjs.org/yallist/-/yallist-2.1.2.tgz",
+      "integrity": "sha1-HBH5IY8HYImkfdUS+TxmmaaoHVI=",
+      "dev": true
+    },
+    "yargs": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/yargs/-/yargs-8.0.2.tgz",
+      "integrity": "sha1-YpmpBVsc78lp/355wdkY3Osiw2A=",
+      "dev": true,
+      "requires": {
+        "camelcase": "4.1.0",
+        "cliui": "3.2.0",
+        "decamelize": "1.2.0",
+        "get-caller-file": "1.0.2",
+        "os-locale": "2.1.0",
+        "read-pkg-up": "2.0.0",
+        "require-directory": "2.1.1",
+        "require-main-filename": "1.0.1",
+        "set-blocking": "2.0.0",
+        "string-width": "2.1.1",
+        "which-module": "2.0.0",
+        "y18n": "3.2.1",
+        "yargs-parser": "7.0.0"
+      },
+      "dependencies": {
+        "camelcase": {
+          "version": "4.1.0",
+          "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-4.1.0.tgz",
+          "integrity": "sha1-1UVjW+HjPFQmScaRc+Xeas+uNN0=",
+          "dev": true
+        },
+        "cliui": {
+          "version": "3.2.0",
+          "resolved": "https://registry.npmjs.org/cliui/-/cliui-3.2.0.tgz",
+          "integrity": "sha1-EgYBU3qRbSmUD5NNo7SNWFo5IT0=",
+          "dev": true,
+          "requires": {
+            "string-width": "1.0.2",
+            "strip-ansi": "3.0.1",
+            "wrap-ansi": "2.1.0"
+          },
+          "dependencies": {
+            "string-width": {
+              "version": "1.0.2",
+              "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
+              "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
+              "dev": true,
+              "requires": {
+                "code-point-at": "1.1.0",
+                "is-fullwidth-code-point": "1.0.0",
+                "strip-ansi": "3.0.1"
+              }
+            }
+          }
+        }
+      }
+    },
+    "yargs-parser": {
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-7.0.0.tgz",
+      "integrity": "sha1-jQrELxbqVd69MyyvTEA4s+P139k=",
+      "dev": true,
+      "requires": {
+        "camelcase": "4.1.0"
+      },
+      "dependencies": {
+        "camelcase": {
+          "version": "4.1.0",
+          "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-4.1.0.tgz",
+          "integrity": "sha1-1UVjW+HjPFQmScaRc+Xeas+uNN0=",
+          "dev": true
+        }
+      }
+    }
+  }
+}
diff --git a/browser/base/package.json b/browser/base/package.json
new file mode 100644
--- /dev/null
+++ b/browser/base/package.json
@@ -0,0 +1,11 @@
+{
+  "name": "async-await",
+  "version": "1.0.0",
+  "description": "",
+  "author": "",
+  "license": "",
+  "devDependencies": {
+    "babel-preset-es2015": "^6.24.1",
+    "webpack": "^3.10.0"
+  }
+}
diff --git a/browser/base/webpack-input.js b/browser/base/webpack-input.js
new file mode 100644
--- /dev/null
+++ b/browser/base/webpack-input.js
@@ -0,0 +1,18 @@
+
+var Ci = Components.interfaces;
+var Cu = Components.utils;
+var Cc = Components.classes;
+var Cr = Components.results;
+
+
+require("./content/browser");
+require("./content/browser-captivePortal.js");
+require("./content/browser-compacttheme.js");
+require("./content/browser-feeds.js");
+require("./content/browser-media.js");
+require("./content/browser-pageActions.js");
+require("./content/browser-places.js");
+require("./content/browser-plugins.js");
+require("./content/browser-sidebar.js");
+require("./content/browser-tabsintitlebar.js");
+require("./content/browser-trackingprotection.js");
diff --git a/browser/base/webpack.config.js b/browser/base/webpack.config.js
new file mode 100644
--- /dev/null
+++ b/browser/base/webpack.config.js
@@ -0,0 +1,12 @@
+module.exports = {
+  entry: './webpack-input.js',
+  output: {
+    filename: './content/browser-bundle.js'
+  },
+  externals: [
+    {
+      "promise": "var Promise",
+      "LightweightThemeManager": "var LightweightThemeManager",
+    }
+  ],
+};
