
# HG changeset patch
# User Nicolas Chevobbe <nchevobbe@mozilla.com>
# Date 1531905701 -7200
# Node ID a0a39efa7f87e490024e1406463e7bc07a3cdcb1
# Parent  d71bdfd64f39273223b2dfc966c6a5cfa435ad1f
Bug 1136299 - Add a test for the new in-line inputt in the console;r=bgrins.

The test relies on the css custom property changes to properly wait since
the resize event is throttled. I confess this is not ideal, and we might
instead fire a "webconsole-resized" event instead.

MozReview-Commit-ID: 4RIQar4ytX

diff --git a/devtools/client/themes/webconsole.css b/devtools/client/themes/webconsole.css
--- a/devtools/client/themes/webconsole.css
+++ b/devtools/client/themes/webconsole.css
@@ -347,41 +347,33 @@
 
 /* Unset the bottom right radius on the jsterm inputs when the sidebar is visible */
 :root[platform="mac"] .sidebar ~ .jsterm-input-container textarea.jsterm-input-node,
 :root[platform="mac"] .sidebar ~ .jsterm-input-container textarea.jsterm-complete-node {
   border-bottom-right-radius: 0;
 }
 
 /* CodeMirror-powered JsTerm */
+.jsterm-cm .webconsole-output:empty ~ .jsterm-input-container {
+  border-top: none;
+}
+
 .jsterm-cm .jsterm-input-container > .CodeMirror {
-  border: 1px solid transparent;
   font-size: inherit;
   line-height: 16px;
   padding-inline-start: 20px;
   /* input icon */
   background-image: var(--theme-command-line-image);
   background-repeat: no-repeat;
   background-size: 16px 16px;
   background-position: 4px 4px;
 }
 
 .jsterm-cm .jsterm-input-container > .CodeMirror-focused {
   background-image: var(--theme-command-line-image-focus);
-  border: 1px solid var(--blue-50);
-  transition: border-color 0.2s ease-in-out;
-}
-
-:root[platform="mac"] .jsterm-cm .jsterm-input-container > .CodeMirror {
-  border-radius: 0 0 4px 4px;
-}
-
-/* Unset the bottom right radius on the jsterm inputs when the sidebar is visible */
-:root[platform="mac"]  .jsterm-cm .sidebar ~ .jsterm-input-container > .CodeMirror {
-  border-bottom-right-radius: 0;
 }
 
 .jsterm-cm .cm-auto-complete-shadow-text::after {
   content: attr(title);
   color: var(--theme-comment);
 }
 
 /* Security styles */
diff --git a/devtools/client/webconsole/test/mochitest/browser.ini b/devtools/client/webconsole/test/mochitest/browser.ini
--- a/devtools/client/webconsole/test/mochitest/browser.ini
+++ b/devtools/client/webconsole/test/mochitest/browser.ini
@@ -286,16 +286,17 @@
 [browser_webconsole_filter_scroll.js]
 [browser_webconsole_filters.js]
 [browser_webconsole_filters_persist.js]
 [browser_webconsole_highlighter_console_helper.js]
 [browser_webconsole_hpkp_invalid-headers.js]
 [browser_webconsole_hsts_invalid-headers.js]
 [browser_webconsole_iframe_wrong_hud.js]
 [browser_webconsole_ineffective_iframe_sandbox_warning.js]
+[browser_webconsole_in_line_layout.js]
 [browser_webconsole_init.js]
 [browser_webconsole_input_field_focus_on_panel_select.js]
 [browser_webconsole_input_focus.js]
 [browser_webconsole_insecure_passwords_about_blank_web_console_warning.js]
 [browser_webconsole_insecure_passwords_web_console_warning.js]
 [browser_webconsole_inspect_cross_domain_object.js]
 [browser_webconsole_js_input_expansion.js]
 [browser_webconsole_keyboard_accessibility.js]
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_input_expansion.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_input_expansion.js
--- a/devtools/client/webconsole/test/mochitest/browser_jsterm_input_expansion.js
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_input_expansion.js
@@ -5,29 +5,25 @@
 
 "use strict";
 
 // Check that the jsterm input supports multiline values. See Bug 588967.
 
 const TEST_URI = "data:text/html;charset=utf-8,Test for jsterm multine input";
 
 add_task(async function() {
-  // Run test with legacy JsTerm
-  await performTests();
-  // And then run it with the CodeMirror-powered one.
-  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
-  await performTests();
-});
+  // Run test only with legacy JsTerm since we have a dedicated test for
+  // codeMirror in-line JsTerm.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
 
-async function performTests() {
   const {jsterm, ui} = await openNewTabAndConsole(TEST_URI);
   const inputContainer = ui.window.document.querySelector(".jsterm-input-container");
 
   const ordinaryHeight = inputContainer.clientHeight;
 
   // Set a multiline value
   jsterm.setInputValue("hello\nworld\n");
   ok(inputContainer.clientHeight > ordinaryHeight, "the input expanded");
 
   info("Erase the value and test if the inputNode shrinks again");
   jsterm.setInputValue("");
   is(inputContainer.clientHeight, ordinaryHeight, "the input's height is normal again");
-}
+});
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_in_line_layout.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_in_line_layout.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_in_line_layout.js
@@ -0,0 +1,132 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the in-line layout works as expected
+
+const TEST_URI = "data:text/html,<meta charset=utf8>Test in-line console layout";
+
+const MINIMUM_MESSAGE_HEIGHT = 19;
+
+add_task(async function() {
+  // The style is only enabled in the new jsterm.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
+  const hud = await openNewTabAndConsole(TEST_URI);
+  const {jsterm, ui} = hud;
+  const {document} = ui;
+  const wrapper = document.querySelector(".webconsole-output-wrapper");
+  const [filterBarNode, outputNode, notificationBoxNode, inputNode] = wrapper.childNodes;
+
+  testWrapperLayout(wrapper);
+
+  is(outputNode.offsetHeight, 0, "output node has no height");
+  is(filterBarNode.offsetHeight + inputNode.offsetHeight, wrapper.offsetHeight,
+    "The entire height is taken by filter bar and input");
+
+  await setFilterBarVisible(hud, true);
+  testWrapperLayout(wrapper);
+  is(filterBarNode.offsetHeight + inputNode.offsetHeight, wrapper.offsetHeight,
+    "The entire height is still taken by filter bar and input");
+
+  info("Logging a message in the content window");
+  const onLogMessage = waitForMessage(hud, "simple text message");
+  ContentTask.spawn(gBrowser.selectedBrowser, null, () => {
+    content.wrappedJSObject.console.log("simple text message");
+  });
+  const logMessage = await onLogMessage;
+  testWrapperLayout(wrapper);
+  is(outputNode.clientHeight, logMessage.node.clientHeight,
+    "Output node is only the height of the message it contains");
+
+  info("Logging multiple messages to make the output overflow");
+  const onLastMessage = waitForMessage(hud, "message-100");
+  ContentTask.spawn(gBrowser.selectedBrowser, null, () => {
+    for (let i = 1; i <= 100; i++) {
+      content.wrappedJSObject.console.log("message-" + i);
+    }
+  });
+  await onLastMessage;
+  ok(outputNode.scrollHeight > outputNode.clientHeight, "Output node overflows");
+  testWrapperLayout(wrapper);
+
+  info("Make sure setting a tall value in the input does not break the layout");
+  jsterm.setInputValue("multiline\n".repeat(100));
+  is(outputNode.clientHeight, MINIMUM_MESSAGE_HEIGHT,
+    "One message is still visible in the output node");
+  testWrapperLayout(wrapper);
+
+  info("Hide secondary filter bar");
+  await setFilterBarVisible(hud, false);
+  is(outputNode.clientHeight, MINIMUM_MESSAGE_HEIGHT,
+    "One message is still visible in the output node");
+  testWrapperLayout(wrapper);
+
+  const filterBarHeight = filterBarNode.clientHeight;
+
+  info("Show the hidden messages label");
+  let filterBarHeightCssVariable = getFilterBarHeightCssVariableValue(wrapper);
+  const onHiddenMessagesLabelVisible = waitFor(() =>
+    document.querySelector(".webconsole-filterbar-filtered-messages"));
+  ui.filterBox.focus();
+  ui.filterBox.select();
+  EventUtils.sendString("message-");
+  await onHiddenMessagesLabelVisible;
+
+  info("Shrink the window so the label is on its own line");
+  const toolbox = hud.ui.consoleOutput.toolbox;
+  const hostWindow = toolbox.win.parent;
+  hostWindow.resizeTo(300, window.screen.availHeight);
+
+  // wait until the css property is modified. We need to do this since there is a throttle
+  // on the resize event.
+  await waitForFilterBarHeightCssVariableChange(wrapper, filterBarHeightCssVariable);
+  filterBarHeightCssVariable = getFilterBarHeightCssVariableValue(wrapper);
+  ok(filterBarNode.clientHeight > filterBarHeight, "The filter bar is taller");
+  testWrapperLayout(wrapper);
+
+  info("Show filter bar");
+  await setFilterBarVisible(hud, true);
+  await waitForFilterBarHeightCssVariableChange(wrapper, filterBarHeightCssVariable);
+  filterBarHeightCssVariable = getFilterBarHeightCssVariableValue(wrapper);
+  testWrapperLayout(wrapper);
+
+  info("Hide filter bar");
+  await setFilterBarVisible(hud, false);
+  await waitForFilterBarHeightCssVariableChange(wrapper, filterBarHeightCssVariable);
+  filterBarHeightCssVariable = getFilterBarHeightCssVariableValue(wrapper);
+
+  info("Expand the window so hidden label isn't on its own line anymore");
+  hostWindow.resizeTo(window.screen.availWidth, window.screen.availHeight);
+  await waitForFilterBarHeightCssVariableChange(wrapper, filterBarHeightCssVariable);
+  testWrapperLayout(wrapper);
+
+  jsterm.setInputValue("");
+  testWrapperLayout(wrapper);
+
+  ui.clearOutput();
+  testWrapperLayout(wrapper);
+  is(outputNode.offsetHeight, 0, "output node has no height");
+  is(filterBarNode.offsetHeight + inputNode.offsetHeight, wrapper.offsetHeight,
+    "The entire height is taken by filter bar and input");
+});
+
+function waitForFilterBarHeightCssVariableChange(wrapper, valueToDifferFrom) {
+  return waitFor(() => getFilterBarHeightCssVariableValue(wrapper) !== valueToDifferFrom);
+}
+
+function getFilterBarHeightCssVariableValue(wrapper) {
+  return wrapper.style.getPropertyValue("--filter-bar-height");
+}
+
+function testWrapperLayout(wrapper) {
+  is(wrapper.offsetHeight, wrapper.scrollHeight, "there's no scrollbar on the wrapper");
+  ok(wrapper.offsetHeight <= wrapper.ownerDocument.body.offsetHeight,
+    "console is not taller than document body");
+  const childSumHeight = [...wrapper.childNodes].reduce(
+    (height, node) => height + node.offsetHeight, 0);
+  ok(wrapper.offsetHeight >= childSumHeight,
+    "the sum of the height of wrapper child nodes is not taller than wrapper's one");
+}

