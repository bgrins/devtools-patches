# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b590381602220c9e7d240660ab1205a4a0e4aa91
Bug 1189928 - Disable Tracking Protection telemetry in private browsing mode;r=MattN

diff --git a/browser/base/content/browser-trackingprotection.js b/browser/base/content/browser-trackingprotection.js
--- a/browser/base/content/browser-trackingprotection.js
+++ b/browser/base/content/browser-trackingprotection.js
@@ -24,17 +24,17 @@ let TrackingProtection = {
     Services.prefs.addObserver(this.PREF_ENABLED_GLOBALLY, this, false);
     Services.prefs.addObserver(this.PREF_ENABLED_IN_PRIVATE_WINDOWS, this, false);
 
     this.activeTooltipText =
       gNavigatorBundle.getString("trackingProtection.icon.activeTooltip");
     this.disabledTooltipText =
       gNavigatorBundle.getString("trackingProtection.icon.disabledTooltip");
 
-    this.enabledHistogram.add(this.enabledGlobally);
+    this.enabledHistogramAdd(this.enabledGlobally);
   },
 
   uninit() {
     Services.prefs.removeObserver(this.PREF_ENABLED_GLOBALLY, this);
     Services.prefs.removeObserver(this.PREF_ENABLED_IN_PRIVATE_WINDOWS, this);
   },
 
   observe() {
@@ -50,26 +50,35 @@ let TrackingProtection = {
   updateEnabled() {
     this.enabledGlobally =
       Services.prefs.getBoolPref(this.PREF_ENABLED_GLOBALLY);
     this.enabledInPrivateWindows =
       Services.prefs.getBoolPref(this.PREF_ENABLED_IN_PRIVATE_WINDOWS);
     this.container.hidden = !this.enabled;
   },
 
-  get enabledHistogram() {
-    return Services.telemetry.getHistogramById("TRACKING_PROTECTION_ENABLED");
+  enabledHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_ENABLED").add(value);
   },
 
-  get eventsHistogram() {
-    return Services.telemetry.getHistogramById("TRACKING_PROTECTION_EVENTS");
+  eventsHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_EVENTS").add(value);
   },
 
-  get shieldHistogram() {
-    return Services.telemetry.getHistogramById("TRACKING_PROTECTION_SHIELD");
+  shieldHistogramAdd(value) {
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+    Services.telemetry.getHistogramById("TRACKING_PROTECTION_SHIELD").add(value);
   },
 
   onSecurityChange(state, isSimulated) {
     if (!this.enabled) {
       return;
     }
 
     // Only animate the shield if the event was not fired directly from
@@ -91,34 +100,34 @@ let TrackingProtection = {
       // Open the tracking protection introduction panel, if applicable.
       let introCount = gPrefService.getIntPref("privacy.trackingprotection.introCount");
       if (introCount < TrackingProtection.MAX_INTROS) {
         gPrefService.setIntPref("privacy.trackingprotection.introCount", ++introCount);
         gPrefService.savePrefFile(null);
         this.showIntroPanel();
       }
 
-      this.shieldHistogram.add(2);
+      this.shieldHistogramAdd(2);
     } else if (isAllowing) {
       this.icon.setAttribute("tooltiptext", this.disabledTooltipText);
       this.icon.setAttribute("state", "loaded-tracking-content");
       this.content.setAttribute("state", "loaded-tracking-content");
 
-      this.shieldHistogram.add(1);
+      this.shieldHistogramAdd(1);
     } else {
       this.icon.removeAttribute("tooltiptext");
       this.icon.removeAttribute("state");
       this.content.removeAttribute("state");
 
       // We didn't show the shield
-      this.shieldHistogram.add(0);
+      this.shieldHistogramAdd(0);
     }
 
     // Telemetry for state change.
-    this.eventsHistogram.add(0);
+    this.eventsHistogramAdd(0);
   },
 
   disableForCurrentPage() {
     // Convert document URI into the format used by
     // nsChannelClassifier::ShouldEnableTrackingProtection.
     // Any scheme turned into https is correct.
     let normalizedUrl = Services.io.newURI(
       "https://" + gBrowser.selectedBrowser.currentURI.hostPort,
@@ -130,17 +139,17 @@ let TrackingProtection = {
     if (PrivateBrowsingUtils.isBrowserPrivate(gBrowser.selectedBrowser)) {
       PrivateBrowsingUtils.addToTrackingAllowlist(normalizedUrl);
     } else {
       Services.perms.add(normalizedUrl,
         "trackingprotection", Services.perms.ALLOW_ACTION);
     }
 
     // Telemetry for disable protection.
-    this.eventsHistogram.add(1);
+    this.eventsHistogramAdd(1);
 
     // Hide the control center.
     document.getElementById("identity-popup").hidePopup();
 
     BrowserReload();
   },
 
   enableForCurrentPage() {
@@ -153,17 +162,17 @@ let TrackingProtection = {
 
     if (PrivateBrowsingUtils.isBrowserPrivate(gBrowser.selectedBrowser)) {
       PrivateBrowsingUtils.removeFromTrackingAllowlist(normalizedUrl);
     } else {
       Services.perms.remove(normalizedUrl, "trackingprotection");
     }
 
     // Telemetry for enable protection.
-    this.eventsHistogram.add(2);
+    this.eventsHistogramAdd(2);
 
     // Hide the control center.
     document.getElementById("identity-popup").hidePopup();
 
     BrowserReload();
   },
 
   showIntroPanel: Task.async(function*() {
diff --git a/browser/base/content/test/general/browser.ini b/browser/base/content/test/general/browser.ini
--- a/browser/base/content/test/general/browser.ini
+++ b/browser/base/content/test/general/browser.ini
@@ -433,16 +433,20 @@ tags = trackingprotection
 tags = trackingprotection
 support-files =
   trackingPage.html
   benignPage.html
 [browser_trackingUI_5.js]
 tags = trackingprotection
 support-files =
   trackingPage.html
+[browser_trackingUI_telemetry.js]
+tags = trackingprotection
+support-files =
+  trackingPage.html
 [browser_typeAheadFind.js]
 skip-if = buildapp == 'mulet'
 [browser_unknownContentType_title.js]
 [browser_unloaddialogs.js]
 skip-if = e10s # Bug 1100700 - test relies on unload event firing on closed tabs, which it doesn't
 [browser_urlHighlight.js]
 [browser_urlbarAutoFillTrimURLs.js]
 [browser_urlbarCopying.js]
diff --git a/browser/base/content/test/general/browser_trackingUI_telemetry.js b/browser/base/content/test/general/browser_trackingUI_telemetry.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser_trackingUI_telemetry.js
@@ -0,0 +1,145 @@
+/*
+ * Test telemetry for Tracking Protection
+ */
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+const PREF = "privacy.trackingprotection.enabled";
+const BENIGN_PAGE = "http://tracking.example.org/browser/browser/base/content/test/general/benignPage.html";
+const TRACKING_PAGE = "http://tracking.example.org/browser/browser/base/content/test/general/trackingPage.html";
+const {UrlClassifierTestUtils} = Cu.import("resource://testing-common/UrlClassifierTestUtils.jsm", {});
+
+/**
+ * Enable local telemetry recording for the duration of the tests.
+ */
+let oldCanRecord = Services.telemetry.canRecordExtended;
+Services.telemetry.canRecordExtended = true;
+Services.prefs.setBoolPref(PREF, false);
+Services.telemetry.getHistogramById("TRACKING_PROTECTION_ENABLED").clear();
+registerCleanupFunction(function () {
+  UrlClassifierTestUtils.cleanupTestTrackers();
+  Services.telemetry.canRecordExtended = oldCanRecord;
+  Services.prefs.clearUserPref(PREF);
+});
+
+function getShieldHistogram() {
+  return Services.telemetry.getHistogramById("TRACKING_PROTECTION_SHIELD");
+}
+
+function getEnabledHistogram() {
+  return Services.telemetry.getHistogramById("TRACKING_PROTECTION_ENABLED");
+}
+
+function getEventsHistogram() {
+  return Services.telemetry.getHistogramById("TRACKING_PROTECTION_EVENTS");
+}
+
+function getShieldCounts() {
+  return getShieldHistogram().snapshot().counts;
+}
+
+function getEnabledCounts() {
+  return getEnabledHistogram().snapshot().counts;
+}
+
+function getEventCounts() {
+  return getEventsHistogram().snapshot().counts;
+}
+
+add_task(function* setup() {
+  yield UrlClassifierTestUtils.addTestTrackers();
+
+  let TrackingProtection = gBrowser.ownerGlobal.TrackingProtection;
+  ok(TrackingProtection, "TP is attached to the browser window");
+  ok(!TrackingProtection.enabled, "TP is not enabled");
+
+  // Open a window with TP disabled to make sure 'enabled' is logged correctly.
+  let newWin = yield promiseOpenAndLoadWindow({}, true);
+  yield promiseWindowClosed(newWin);
+
+  is(getEnabledCounts()[0], 1, "TP was disabled once on start up");
+  is(getEnabledCounts()[1], 0, "TP was not enabled on start up");
+
+  // Enable TP so the next browser to open will log 'enabled'
+  Services.prefs.setBoolPref(PREF, true);
+});
+
+
+add_task(function* testNewWindow() {
+  let newWin = yield promiseOpenAndLoadWindow({}, true);
+  let tab = newWin.gBrowser.selectedTab = newWin.gBrowser.addTab();
+  TrackingProtection = newWin.TrackingProtection;
+  ok(TrackingProtection, "TP is attached to the browser window");
+
+  is(getEnabledCounts()[0], 1, "TP was disabled once on start up");
+  is(getEnabledCounts()[1], 1, "TP was enabled once on start up");
+
+  // Reset these to make counting easier
+  getEventsHistogram().clear();
+  getShieldHistogram().clear();
+
+  yield promiseTabLoadEvent(tab, BENIGN_PAGE);
+  is(getEventCounts()[0], 1, "Total page loads");
+  is(getEventCounts()[1], 0, "Disable actions");
+  is(getEventCounts()[2], 0, "Enable actions");
+  is(getShieldCounts()[0], 1, "Page loads without tracking");
+
+  yield promiseTabLoadEvent(tab, TRACKING_PAGE);
+  // Note that right now the events and shield histogram is not measuring what
+  // you might think.  Since onSecurityChange fires twice for a tracking page,
+  // the total page loads count is double counting, and the shield count
+  // (which is meant to measure times when the shield wasn't shown) fires even
+  // when tracking elements exist on the page.
+  todo_is(getEventCounts()[0], 2, "FIXME: TOTAL PAGE LOADS IS DOUBLE COUNTING");
+  is(getEventCounts()[1], 0, "Disable actions");
+  is(getEventCounts()[2], 0, "Enable actions");
+  todo_is(getShieldCounts()[0], 1, "FIXME: TOTAL PAGE LOADS WITHOUT TRACKING IS DOUBLE COUNTING");
+
+  info("Disable TP for the page (which reloads the page)");
+  let tabReloadPromise = promiseTabLoadEvent(tab);
+  newWin.document.querySelector("#tracking-action-unblock").doCommand();
+  yield tabReloadPromise;
+  todo_is(getEventCounts()[0], 3, "FIXME: TOTAL PAGE LOADS IS DOUBLE COUNTING");
+  is(getEventCounts()[1], 1, "Disable actions");
+  is(getEventCounts()[2], 0, "Enable actions");
+  todo_is(getShieldCounts()[0], 1, "FIXME: TOTAL PAGE LOADS WITHOUT TRACKING IS DOUBLE COUNTING");
+
+  info("Re-enable TP for the page (which reloads the page)");
+  tabReloadPromise = promiseTabLoadEvent(tab);
+  newWin.document.querySelector("#tracking-action-block").doCommand();
+  yield tabReloadPromise;
+  todo_is(getEventCounts()[0], 4, "FIXME: TOTAL PAGE LOADS IS DOUBLE COUNTING");
+  is(getEventCounts()[1], 1, "Disable actions");
+  is(getEventCounts()[2], 1, "Enable actions");
+  todo_is(getShieldCounts()[0], 1, "FIXME: TOTAL PAGE LOADS WITHOUT TRACKING IS DOUBLE COUNTING");
+
+  yield promiseWindowClosed(newWin);
+
+  // Reset these to make counting easier for the next test
+  getEventsHistogram().clear();
+  getShieldHistogram().clear();
+  getEnabledHistogram().clear();
+});
+
+add_task(function* testPrivateBrowsing() {
+  let privateWin = yield promiseOpenAndLoadWindow({private: true}, true);
+  let tab = privateWin.gBrowser.selectedTab = privateWin.gBrowser.addTab();
+  let TrackingProtection = privateWin.TrackingProtection;
+  ok(TrackingProtection, "TP is attached to the browser window");
+
+  // Do a bunch of actions and make sure that no telemetry data is gathered
+  yield promiseTabLoadEvent(tab, BENIGN_PAGE);
+  yield promiseTabLoadEvent(tab, TRACKING_PAGE);
+  let tabReloadPromise = promiseTabLoadEvent(tab);
+  privateWin.document.querySelector("#tracking-action-unblock").doCommand();
+  yield tabReloadPromise;
+  tabReloadPromise = promiseTabLoadEvent(tab);
+  privateWin.document.querySelector("#tracking-action-block").doCommand();
+  yield tabReloadPromise;
+
+  // Sum up all the counts to make sure that nothing got logged
+  is(getEnabledCounts().reduce((p,c)=>p+c), 0, "Telemetry logging off in PB mode");
+  is(getEventCounts().reduce((p,c)=>p+c), 0, "Telemetry logging off in PB mode");
+  is(getShieldCounts().reduce((p,c)=>p+c), 0, "Telemetry logging off in PB mode");
+
+  yield promiseWindowClosed(privateWin);
+});
