# HG changeset patch
# Parent 8f4ecbf938cd15199f017b5b21ca3c3e167802a3
inDeepTreeWalker

diff --git a/layout/inspector/inDeepTreeWalker.cpp b/layout/inspector/inDeepTreeWalker.cpp
--- a/layout/inspector/inDeepTreeWalker.cpp
+++ b/layout/inspector/inDeepTreeWalker.cpp
@@ -71,21 +71,21 @@ inDeepTreeWalker::SetShowSubDocuments(bo
   mShowSubDocuments = aShowSubDocuments;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::Init(nsIDOMNode* aRoot, uint32_t aWhatToShow)
 {
   mRoot = aRoot;
+  mCurrentNode = aRoot;
   mWhatToShow = aWhatToShow;
-  
-  PushNode(aRoot);
 
-  return NS_OK;
+  mDOMUtils = do_GetService("@mozilla.org/inspector/dom-utils;1");
+  return mDOMUtils ? NS_OK : NS_ERROR_UNEXPECTED;
 }
 
 ////////////////////////////////////////////////////
 // nsIDOMTreeWalker
 
 NS_IMETHODIMP
 inDeepTreeWalker::GetRoot(nsIDOMNode** aRoot)
 {
@@ -112,152 +112,194 @@ NS_IMETHODIMP
 inDeepTreeWalker::GetCurrentNode(nsIDOMNode** aCurrentNode)
 {
   *aCurrentNode = mCurrentNode;
   NS_IF_ADDREF(*aCurrentNode);
   
   return NS_OK;
 }
 
+already_AddRefed<nsIDOMNode>
+inDeepTreeWalker::GetParent()
+{
+  if (!mCurrentNode || mCurrentNode == mRoot) {
+    return nullptr;
+  }
+
+  nsCOMPtr<nsIDOMNode> parent;
+  MOZ_ASSERT(mDOMUtils, "mDOMUtils should have been initiated already in Init");
+  mDOMUtils->GetParentForNode(mCurrentNode, mShowAnonymousContent,
+                              getter_AddRefs(parent));
+
+  return parent.forget();
+}
+
 NS_IMETHODIMP
 inDeepTreeWalker::SetCurrentNode(nsIDOMNode* aCurrentNode)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return SetCurrentNode(aCurrentNode, nullptr);
+}
+
+
+NS_IMETHODIMP
+inDeepTreeWalker::SetCurrentNode(nsIDOMNode* aCurrentNode,
+                                 nsINodeList* aSiblings)
+{
+  if (!aCurrentNode) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mCurrentNode = aCurrentNode;
+  mSiblings = aSiblings;
+  if (!mSiblings) {
+    nsCOMPtr<nsIDOMNode> parent = GetParent();
+    if (parent) {
+      nsCOMPtr<nsIContent> parentContent = do_QueryInterface(parent);
+      if (parentContent) {
+        nsCOMPtr<nsIDOMNodeList> list = parentContent->GetChildren(mShowAnonymousContent ?
+                                                                   nsIContent::eAllChildren :
+                                                                   nsIContent::eAllButXBL);
+        mSiblings = do_QueryInterface(list);
+      }
+    }
+  }
+
+  if (mSiblings) {
+    // We cached all the siblings (if there are any) of the current node, but we
+    // still have to set the index too, to be able to iterate over them.
+    if (mSiblings->Length() == 0) {
+      mSiblings = nullptr;
+    } else {
+      nsCOMPtr<nsIContent> currentAsContent = do_QueryInterface(mCurrentNode);
+      mCurrentIndex = mSiblings->IndexOf(currentAsContent);
+    }
+  }
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::ParentNode(nsIDOMNode** _retval)
 {
   *_retval = nullptr;
-  if (!mCurrentNode) return NS_OK;
-
-  if (mStack.Length() == 1) {
-    // No parent
+  if (!mCurrentNode || mCurrentNode == mRoot) {
     return NS_OK;
   }
 
-  // Pop off the current node, and push the new one
-  mStack.RemoveElementAt(mStack.Length()-1);
-  DeepTreeStackItem& top = mStack.ElementAt(mStack.Length() - 1);
-  mCurrentNode = top.node;
-  top.lastIndex = 0;
-  NS_ADDREF(*_retval = mCurrentNode);
+  nsCOMPtr<nsIDOMNode> parent = GetParent();
+
+  if (!parent) {
+    return NS_OK;
+  }
+
+  nsresult rv = SetCurrentNode(parent);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  parent.forget(_retval);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-inDeepTreeWalker::FirstChild(nsIDOMNode **_retval)
+inDeepTreeWalker::FirstChild(nsIDOMNode** _retval)
 {
   *_retval = nullptr;
   if (!mCurrentNode) {
     return NS_OK;
   }
 
-  DeepTreeStackItem& top = mStack.ElementAt(mStack.Length() - 1);
-  nsCOMPtr<nsIDOMNode> kid;
-  top.kids->Item(0, getter_AddRefs(kid));
-  if (!kid) {
-    return NS_OK;
+  nsCOMPtr<nsIContent> currentAsContent = do_QueryInterface(mCurrentNode);
+  nsCOMPtr<nsIDOMNode> fchild;
+  nsCOMPtr<nsINodeList> children;
+  if (currentAsContent) {
+    nsCOMPtr<nsIDOMNodeList> list = currentAsContent->GetChildren(mShowAnonymousContent ?
+                                                                  nsIContent::eAllChildren :
+                                                                  nsIContent::eAllButXBL);
+    children = do_QueryInterface(list);
+    if (children && children->Length() > 0) {
+      nsIContent* childAsContent = children->Item(0);
+      fchild = childAsContent->AsDOMNode();
+    }
+  } else {
+    // If it's not a content, then it's a document (or an attribute but we can ignore that
+    // case here). GetFirstChild should just work then.
+    mCurrentNode->GetFirstChild(getter_AddRefs(fchild));
   }
-  top.lastIndex = 1;
-  PushNode(kid);
-  kid.forget(_retval);
+
+  if (fchild) {
+    nsresult rv = SetCurrentNode(fchild, children);
+    NS_ENSURE_SUCCESS(rv, rv);
+    NS_ADDREF(*_retval = mCurrentNode);
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::LastChild(nsIDOMNode **_retval)
 {
   *_retval = nullptr;
   if (!mCurrentNode) {
     return NS_OK;
   }
 
-  DeepTreeStackItem& top = mStack.ElementAt(mStack.Length() - 1);
-  nsCOMPtr<nsIDOMNode> kid;
-  uint32_t length;
-  top.kids->GetLength(&length);
-  top.kids->Item(length - 1, getter_AddRefs(kid));
-  if (!kid) {
-    return NS_OK;
+  nsCOMPtr<nsIContent> currentAsContent = do_QueryInterface(mCurrentNode);
+  nsCOMPtr<nsIDOMNode> lchild;
+  nsCOMPtr<nsINodeList> children;
+  if (currentAsContent) {
+    nsCOMPtr<nsIDOMNodeList> list = currentAsContent->GetChildren(mShowAnonymousContent ?
+                                                                  nsIContent::eAllChildren :
+                                                                  nsIContent::eAllButXBL);
+    children = do_QueryInterface(list);
+    if (children && children->Length() > 0) {
+      nsIContent* childAsContent = children->Item(children->Length()-1);
+      lchild = childAsContent->AsDOMNode();
+    }
+  } else {
+    mCurrentNode->GetLastChild(getter_AddRefs(lchild));
   }
-  top.lastIndex = length;
-  PushNode(kid);
-  kid.forget(_retval);
+
+  if (lchild) {
+    nsresult rv = SetCurrentNode(lchild, children);
+    NS_ENSURE_SUCCESS(rv, rv);
+    NS_ADDREF(*_retval = mCurrentNode);
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::PreviousSibling(nsIDOMNode **_retval)
 {
   *_retval = nullptr;
-  if (!mCurrentNode) {
+  if (!mCurrentNode || !mSiblings || mCurrentIndex < 1) {
     return NS_OK;
   }
 
-  NS_ASSERTION(mStack.Length() > 0, "Should have things in mStack");
-
-  if (mStack.Length() == 1) {
-    // No previous sibling
-    return NS_OK;
-  }
-
-  DeepTreeStackItem& parent = mStack.ElementAt(mStack.Length()-2);
-  nsCOMPtr<nsIDOMNode> previousSibling;
-  parent.kids->Item(parent.lastIndex-2, getter_AddRefs(previousSibling));
-  if (!previousSibling) {
-    return NS_OK;
-  }
-
-  // Our mStack's topmost element is our current node. Since we're trying to
-  // change that to the previous sibling, pop off the current node, and push
-  // the new one.
-  mStack.RemoveElementAt(mStack.Length() - 1);
-  parent.lastIndex--;
-  PushNode(previousSibling);
-  previousSibling.forget(_retval);
+  nsIContent* prev = mSiblings->Item(--mCurrentIndex);
+  mCurrentNode = prev->AsDOMNode();
+  NS_ADDREF(*_retval = mCurrentNode);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::NextSibling(nsIDOMNode **_retval)
 {
   *_retval = nullptr;
-  if (!mCurrentNode) {
+  if (!mCurrentNode || !mSiblings || mCurrentIndex + 2 > mSiblings->Length()) {
     return NS_OK;
   }
 
-  NS_ASSERTION(mStack.Length() > 0, "Should have things in mStack");
-
-  if (mStack.Length() == 1) {
-    // No next sibling
-    return NS_OK;
-  }
-
-  DeepTreeStackItem& parent = mStack.ElementAt(mStack.Length()-2);
-  nsCOMPtr<nsIDOMNode> nextSibling;
-  parent.kids->Item(parent.lastIndex, getter_AddRefs(nextSibling));
-  if (!nextSibling) {
-    return NS_OK;
-  }
-
-  // Our mStack's topmost element is our current node. Since we're trying to
-  // change that to the next sibling, pop off the current node, and push
-  // the new one.
-  mStack.RemoveElementAt(mStack.Length() - 1);
-  parent.lastIndex++;
-  PushNode(nextSibling);
-  nextSibling.forget(_retval);
+  nsIContent* next = mSiblings->Item(++mCurrentIndex);
+  mCurrentNode = next->AsDOMNode();
+  NS_ADDREF(*_retval = mCurrentNode);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDeepTreeWalker::PreviousNode(nsIDOMNode **_retval)
 {
-  if (!mCurrentNode || mStack.Length() == 1) {
+  if (!mCurrentNode || mCurrentNode == mRoot) {
     // Nowhere to go from here
     *_retval = nullptr;
     return NS_OK;
   }
 
   nsCOMPtr<nsIDOMNode> node;
   PreviousSibling(getter_AddRefs(node));
 
@@ -315,92 +357,8 @@ inDeepTreeWalker::NextNode(nsIDOMNode **
       return NS_OK;
     }
     ++lastChildCallsToMake;
   }
 
   NS_NOTREACHED("how did we get here?");
   return NS_OK;
 }
-
-void
-inDeepTreeWalker::PushNode(nsIDOMNode* aNode)
-{
-  mCurrentNode = aNode;
-  if (!aNode) return;
-
-  DeepTreeStackItem item;
-  item.node = aNode;
-
-  nsCOMPtr<nsIDOMNodeList> kids;
-  if (mShowSubDocuments) {
-    nsCOMPtr<nsIDOMDocument> domdoc = inLayoutUtils::GetSubDocumentFor(aNode);
-    if (domdoc) {
-      domdoc->GetChildNodes(getter_AddRefs(kids));
-    }
-  }
-  
-  if (!kids) {
-    nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
-    if (content && mShowAnonymousContent) {
-      kids = content->GetChildren(nsIContent::eAllChildren);
-    }
-  }
-  if (!kids) {
-    aNode->GetChildNodes(getter_AddRefs(kids));
-  }
-  
-  item.kids = kids;
-  item.lastIndex = 0;
-  mStack.AppendElement(item);
-}
-
-/*
-// This NextNode implementation does not require the use of stacks, 
-// as does the one above. However, it does not handle anonymous 
-// content and sub-documents.
-NS_IMETHODIMP
-inDeepTreeWalker::NextNode(nsIDOMNode **_retval)
-{
-  if (!mCurrentNode) return NS_OK;
-  
-  // walk down the tree first
-  nsCOMPtr<nsIDOMNode> next;
-  mCurrentNode->GetFirstChild(getter_AddRefs(next));
-  if (!next) {
-    mCurrentNode->GetNextSibling(getter_AddRefs(next));
-    if (!next) { 
-      // we've hit the end, so walk back up the tree until another
-      // downward opening is found, or the top of the tree
-      nsCOMPtr<nsIDOMNode> subject = mCurrentNode;
-      nsCOMPtr<nsIDOMNode> parent;
-      while (1) {
-        subject->GetParentNode(getter_AddRefs(parent));
-        if (!parent) // hit the top of the tree
-          break;
-        parent->GetNextSibling(getter_AddRefs(subject));
-        if (subject) { // found a downward opening
-          next = subject;
-          break;
-        } else // walk up another level
-          subject = parent;
-      } 
-    }
-  }
-  
-  mCurrentNode = next;
-  
-  *_retval = next;
-  NS_IF_ADDREF(*_retval);
-  
-  return NS_OK;
-}
-
-
-char* getURL(nsIDOMDocument* aDoc)
-{
-  nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDoc);
-  nsIURI *uri = doc->GetDocumentURI();
-  char* s;
-  uri->GetSpec(&s);
-  return s;
-}
-*/
diff --git a/layout/inspector/inDeepTreeWalker.h b/layout/inspector/inDeepTreeWalker.h
--- a/layout/inspector/inDeepTreeWalker.h
+++ b/layout/inspector/inDeepTreeWalker.h
@@ -8,48 +8,39 @@
 #include "inIDeepTreeWalker.h"
 
 #include "nsCOMPtr.h"
 #include "nsIDOMNode.h"
 #include "nsTArray.h"
 
 class inIDOMUtils;
 
-////////////////////////////////////////////////////
-
-struct DeepTreeStackItem
-{
-  nsCOMPtr<nsIDOMNode> node;
-  nsCOMPtr<nsIDOMNodeList> kids;
-  uint32_t lastIndex; // Index one bigger than the index of whatever
-                      // kid we're currently at in |kids|.
-};
-
-////////////////////////////////////////////////////
-
 class inDeepTreeWalker : public inIDeepTreeWalker
 {
 public:
-	NS_DECL_ISUPPORTS
-	NS_DECL_NSIDOMTREEWALKER
-	NS_DECL_INIDEEPTREEWALKER
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMTREEWALKER
+  NS_DECL_INIDEEPTREEWALKER
+
+  NS_IMETHODIMP SetCurrentNode(nsIDOMNode* aCurrentNode,
+                               nsINodeList* aSiblings);
 
   inDeepTreeWalker();
   virtual ~inDeepTreeWalker();
 
-protected:
-  void PushNode(nsIDOMNode* aNode);
+private:
+  already_AddRefed<nsIDOMNode> GetParent();
 
   bool mShowAnonymousContent;
   bool mShowSubDocuments;
   nsCOMPtr<nsIDOMNode> mRoot;
   nsCOMPtr<nsIDOMNode> mCurrentNode;
+  nsCOMPtr<inIDOMUtils> mDOMUtils;
+  nsCOMPtr<nsINodeList> mSiblings;
+  uint32_t mCurrentIndex;
   uint32_t mWhatToShow;
-  
-  nsAutoTArray<DeepTreeStackItem, 8> mStack;
-  nsCOMPtr<inIDOMUtils> mDOMUtils;
 };
 
 // {BFCB82C2-5611-4318-90D6-BAF4A7864252}
 #define IN_DEEPTREEWALKER_CID \
 { 0xbfcb82c2, 0x5611, 0x4318, { 0x90, 0xd6, 0xba, 0xf4, 0xa7, 0x86, 0x42, 0x52 } }
 
 #endif // __inDeepTreeWalker_h___
