# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1545164470 28800
#      Tue Dec 18 12:21:10 2018 -0800
# Node ID 8579458d0c202560dd41987b2534e41b22f7e124
# Parent  6b4a345b50e94310091b01e8db32b3028ca58f89
Bug 1441935 - `hg cp toolkit/content/widgets/browser.xml toolkit/content/widgets/browser.js`

Differential Revision: https://phabricator.services.mozilla.com/D14909
* * *
Bug 1441935 - Import generated MozBrowser Custom Element implementation

Differential Revision: https://phabricator.services.mozilla.com/D14910
* * *
Bug 1441935 - WIP - Modifications on top of the generated Custom Element

Steps to build:

this.observer instead of this
./mach eslint toolkit/content/widgets/browser.js --fix

Differential Revision: https://phabricator.services.mozilla.com/D14911

diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -108,17 +108,17 @@ window._gBrowser = {
    * Binding from browser to tab
    */
   _tabForBrowser: new WeakMap(),
 
   _preloadedBrowser: null,
 
   /**
    * `_createLazyBrowser` will define properties on the unbound lazy browser
-   * which correspond to properties defined in XBL which will be bound to
+   * which correspond to properties defined in MozBrowser which will be bound to
    * the browser when it is inserted into the document.  If any of these
    * properties are accessed by consumers, `_insertBrowser` is called and
    * the browser is inserted to ensure that things don't break.  This list
    * provides the names of properties that may be called while the browser
    * is in its unbound (lazy) state.
    */
   _browserBindingProperties: [
     "canGoBack", "canGoForward", "goBack", "goForward", "permitUnload",
@@ -3088,24 +3088,24 @@ window._gBrowser = {
     this._tabFilters.delete(aTab);
     this._tabListeners.delete(aTab);
 
     var browser = this.getBrowserForTab(aTab);
 
     if (aTab.linkedPanel) {
       this._outerWindowIDBrowserMap.delete(browser.outerWindowID);
 
-      // Because of the way XBL works (fields just set JS
-      // properties on the element) and the code we have in place
+      // Because of the fact that we are setting JS properties on
+      // the browser elements, and we have code in place
       // to preserve the JS objects for any elements that have
       // JS properties set on them, the browser element won't be
       // destroyed until the document goes away.  So we force a
       // cleanup ourselves.
-      // This has to happen before we remove the child so that the
-      // XBL implementation of nsIObserver still works.
+      // This has to happen before we remove the child since functions
+      // like `getBrowserContainer` expect the browser to be parented.
       browser.destroy();
     }
 
     var wasPinned = aTab.pinned;
 
     // Remove the tab ...
     aTab.remove();
 
diff --git a/devtools/client/responsive.html/browser/tunnel.js b/devtools/client/responsive.html/browser/tunnel.js
--- a/devtools/client/responsive.html/browser/tunnel.js
+++ b/devtools/client/responsive.html/browser/tunnel.js
@@ -59,17 +59,17 @@ const PROPERTIES_FROM_BROWSER_WINDOW = [
 
 /**
  * This module takes an "outer" <xul:browser> from a browser tab as described by
  * Firefox's tabbrowser.xml and wires it up to an "inner" <iframe mozbrowser>
  * browser element containing arbitrary page content of interest.
  *
  * The inner <iframe mozbrowser> element is _just_ the page content.  It is not
  * enough to to replace <xul:browser> on its own.  <xul:browser> comes along
- * with lots of associated functionality via XBL binding defined for such
+ * with lots of associated functionality via a Custom Element defined for such
  * elements in browser.xml, and the Firefox UI depends on these various things
  * to make the UI function.
  *
  * By mapping various methods, properties, and messages from the outer browser
  * to the inner browser, we can control the content inside the inner browser
  * using the standard Firefox UI elements for navigation, reloading, and more.
  *
  * The approaches used in this module were chosen to avoid needing changes to
@@ -148,22 +148,22 @@ function tunnelToInnerBrowser(outer, inn
       // copy the content's `permanentKey` up to the outer browser.
       debug("Copy inner permanentKey to outer browser");
       outer.permanentKey = inner.permanentKey;
 
       // Replace the outer browser's native messageManager with a message manager tunnel
       // which we can use to route messages of interest to the inner browser instead.
       // Note: The _actual_ messageManager accessible from
       // `browser.frameLoader.messageManager` is not overridable and is left unchanged.
-      // Only the XBL getter `browser.messageManager` is overridden.  Browser UI code
-      // always uses this getter instead of `browser.frameLoader.messageManager` directly,
+      // Only the Custom Element getter `browser.messageManager` is overridden. This
+      // getter is always used instead of `browser.frameLoader.messageManager` directly,
       // so this has the effect of overriding the message manager for browser UI code.
       mmTunnel = new MessageManagerTunnel(outer, inner);
 
-      // Clear out any cached state that references the XBL binding's non-remote state,
+      // Clear out any cached state that references the Custom Element's non-remote state,
       // such as form fill controllers.  Otherwise they will remain in place and leak the
       // outer docshell.
       outer.destroy();
 
       // We are tunneling to an inner browser with a specific remoteness, so it is simpler
       // for the logic of the browser UI to assume this tab has taken on that remoteness,
       // even though it's not true.  Since the actions the browser UI performs are sent
       // down to the inner browser by this tunnel, the tab's remoteness effectively is the
@@ -188,19 +188,19 @@ function tunnelToInnerBrowser(outer, inn
       // remote browser binding creates.  We do not care about it's original value
       // because stop() will remove the browser binding and these will no longer bee
       // used.
       const webNavigation = new BrowserElementWebNavigation(inner);
       webNavigation.copyStateFrom(inner._remoteWebNavigationImpl);
       outer._remoteWebNavigation = webNavigation;
       outer._remoteWebNavigationImpl = webNavigation;
 
-      // Now that we've flipped to the remote browser XBL binding, add `progressListener`
+      // Now that we've flipped to the remote browser mode, add `progressListener`
       // onto the remote version of `webProgress`.  Normally tabbrowser.xml does this step
-      // when it creates a new browser, etc.  Since we manually changed the XBL binding
+      // when it creates a new browser, etc.  Since we manually changed the mode
       // above, it caused a fresh webProgress object to be created which does not have any
       // listeners added.  So, we get the listener that gBrowser is using for the tab and
       // reattach it here.
       const tab = gBrowser.getTabForBrowser(outer);
       const filteredProgressListener = gBrowser._tabFilters.get(tab);
       outer.webProgress.addProgressListener(filteredProgressListener);
 
       // Add the inner browser to tabbrowser's WeakMap from browser to tab.  This assists
@@ -300,17 +300,17 @@ function tunnelToInnerBrowser(outer, inn
       }
 
       // Remove the inner browser from the WeakMap from browser to tab.
       gBrowser._tabForBrowser.delete(inner);
 
       // Remove the progress listener we added manually.
       outer.webProgress.removeProgressListener(filteredProgressListener);
 
-      // Reset the XBL binding back to the original state.
+      // Reset the Custom Element back to the original state.
       outer.destroy();
 
       // Reset @remote since this is now back to a regular, non-remote browser
       outer.setAttribute("remote", "false");
       outer.removeAttribute("remoteType");
       outer.construct();
 
       // Delete browser window properties exposed on content's owner global
diff --git a/dom/ipc/tests/process_error.xul b/dom/ipc/tests/process_error.xul
--- a/dom/ipc/tests/process_error.xul
+++ b/dom/ipc/tests/process_error.xul
@@ -26,12 +26,16 @@
       }
 
       Services.obs.removeObserver(crashObserver, 'ipc:content-shutdown');
       done();
     }
 
     Services.obs.addObserver(crashObserver, 'ipc:content-shutdown');
 
-    BrowserTestUtils.crashBrowser(document.getElementById('thebrowser'), true, false);
+    // Allow the browser to get connected before using the messageManager to cause
+    // a crash:
+    addEventListener("DOMContentLoaded", () => {
+      BrowserTestUtils.crashBrowser(document.getElementById('thebrowser'), true, false);
+    });
   ]]></script>
 
 </window>
diff --git a/toolkit/components/processsingleton/CustomElementsListener.jsm b/toolkit/components/processsingleton/CustomElementsListener.jsm
--- a/toolkit/components/processsingleton/CustomElementsListener.jsm
+++ b/toolkit/components/processsingleton/CustomElementsListener.jsm
@@ -8,15 +8,16 @@ ChromeUtils.import("resource://gre/modul
 // Set up Custom Elements for XUL and XHTML documents before anything else
 // happens. Anything loaded here should be considered part of core XUL functionality.
 // Any window-specific elements can be registered via <script> tags at the
 // top of individual documents.
 Services.obs.addObserver({
   observe(doc) {
     if (doc.nodePrincipal.isSystemPrincipal && (
       doc.contentType == "application/vnd.mozilla.xul+xml" ||
-      doc.contentType == "application/xhtml+xml"
+      doc.contentType == "application/xhtml+xml" ||
+      doc.contentType == "text/html"
     )) {
       Services.scriptloader.loadSubScript(
         "chrome://global/content/customElements.js", doc.ownerGlobal);
     }
   },
 }, "document-element-inserted");
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -284,16 +284,18 @@ MozElements.BaseControl = class BaseCont
 MozXULElement.implementCustomInterface(MozElements.BaseControl,
                                        [Ci.nsIDOMXULControlElement]);
 
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozElements = MozElements;
 
+Services.scriptloader.loadSubScript("chrome://global/content/elements/browser.js", window);
+
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/radio.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -57,17 +57,16 @@ toolkit.jar:
    content/global/TopLevelVideoDocument.js
    content/global/timepicker.xhtml
    content/global/treeUtils.js
 #ifndef MOZ_FENNEC
    content/global/viewZoomOverlay.js
 #endif
    content/global/widgets.css
    content/global/bindings/autocomplete.xml    (widgets/autocomplete.xml)
-   content/global/bindings/browser.xml         (widgets/browser.xml)
    content/global/bindings/button.xml          (widgets/button.xml)
    content/global/bindings/calendar.js         (widgets/calendar.js)
    content/global/bindings/checkbox.xml        (widgets/checkbox.xml)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimepopup.xml   (widgets/datetimepopup.xml)
    content/global/bindings/datetimebox.xml     (widgets/datetimebox.xml)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
@@ -87,16 +86,17 @@ toolkit.jar:
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
+   content/global/elements/browser.js          (widgets/browser.js)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js          (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
diff --git a/toolkit/content/widgets/browser.xml b/toolkit/content/widgets/browser.js
copy from toolkit/content/widgets/browser.xml
copy to toolkit/content/widgets/browser.js
--- a/toolkit/content/widgets/browser.xml
+++ b/toolkit/content/widgets/browser.js
@@ -1,2085 +1,1841 @@
-<?xml version="1.0"?>
-
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<bindings id="browserBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-  <binding id="browser">
-    <content clickthrough="never">
-      <children/>
-    </content>
-    <implementation type="application/javascript" implements="nsIObserver, nsIBrowser">
-      <property name="autoscrollEnabled">
-        <getter>
-          <![CDATA[
-            if (this.getAttribute("autoscroll") == "false")
-              return false;
-
-            return this.mPrefs.getBoolPref("general.autoScroll", true);
-          ]]>
-        </getter>
-      </property>
+"use strict";
 
-      <property name="canGoBack"
-                onget="return this.webNavigation.canGoBack;"
-                readonly="true"/>
-
-      <property name="canGoForward"
-                onget="return this.webNavigation.canGoForward;"
-                readonly="true"/>
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
 
-      <method name="_wrapURIChangeCall">
-        <parameter name="fn"/>
-        <body>
-          <![CDATA[
-            if (!this.isRemoteBrowser) {
-              this.inLoadURI = true;
-              try {
-                fn();
-              } finally {
-                this.inLoadURI = false;
-              }
-            } else {
-              fn();
-            }
-          ]]>
-        </body>
-      </method>
-
+const elementsToDestroyOnUnload = new Set();
 
-      <method name="goBack">
-        <body>
-          <![CDATA[
-            var webNavigation = this.webNavigation;
-            if (webNavigation.canGoBack)
-              this._wrapURIChangeCall(() => webNavigation.goBack());
-          ]]>
-        </body>
-      </method>
-
-      <method name="goForward">
-        <body>
-          <![CDATA[
-            var webNavigation = this.webNavigation;
-            if (webNavigation.canGoForward)
-              this._wrapURIChangeCall(() => webNavigation.goForward());
-          ]]>
-        </body>
-      </method>
-
-      <method name="reload">
-        <body>
-          <![CDATA[
-            const nsIWebNavigation = Ci.nsIWebNavigation;
-            const flags = nsIWebNavigation.LOAD_FLAGS_NONE;
-            this.reloadWithFlags(flags);
-          ]]>
-        </body>
-      </method>
+// Only attach the listener after a browser has been created, to avoid
+// running JS in the trivial document case (XXX: test_WorkerDebugger_frozen.xul)
+let unloadHandlerRegistered = false;
+function trackBrowserForUnload(browser) {
+  if (!unloadHandlerRegistered) {
+    unloadHandlerRegistered = true;
+    window.addEventListener("unload", function unload(e) {
+      if (e.originalTarget == document) {
+        window.removeEventListener("unload", unload);
+        for (let element of elementsToDestroyOnUnload.values()) {
+          element.remove();
+        }
+        elementsToDestroyOnUnload.clear();
+      }
+    }, { mozSystemGroup: true });
+  }
+  elementsToDestroyOnUnload.add(browser);
+}
+function untrackBrowserForUnload(browser) {
+  elementsToDestroyOnUnload.delete(browser);
+}
 
-      <method name="reloadWithFlags">
-        <parameter name="aFlags"/>
-        <body>
-          <![CDATA[
-            this.webNavigation.reload(aFlags);
-          ]]>
-        </body>
-      </method>
-
-      <method name="stop">
-        <body>
-          <![CDATA[
-            const nsIWebNavigation = Ci.nsIWebNavigation;
-            const flags = nsIWebNavigation.STOP_ALL;
-            this.webNavigation.stop(flags);
-          ]]>
-        </body>
-      </method>
-
-      <!-- throws exception for unknown schemes -->
-      <method name="loadURI">
-        <parameter name="aURI"/>
-        <parameter name="aParams"/>
-        <body>
-          <![CDATA[
-            if (!aURI) {
-              aURI = "about:blank";
-            }
-
-            let {
-              flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE,
-              referrerURI,
-              referrerPolicy = Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,
-              triggeringPrincipal,
-              postData,
-            } = aParams || {};
+class MozBrowser extends MozElementMixin(XULFrameElement) {
+  static get observedAttributes() {
+    return ["remote"];
+  }
 
-            this._wrapURIChangeCall(() =>
-              this.webNavigation.loadURIWithOptions(
-                  aURI, flags, referrerURI, referrerPolicy,
-                  postData, null, null, triggeringPrincipal));
-          ]]>
-        </body>
-      </method>
+  attributeChangedCallback(name, oldValue, newValue) {
+    // When we have already been set up via connectedCallback and the
+    // and the [remote] value changes, we need to start over. This used
+    // to happen due to a XBL binding change.
+    if (name === "remote" && oldValue != newValue && this.isConnected) {
+      this.destroy();
+      this.construct();
+    }
+  }
 
-      <method name="gotoIndex">
-        <parameter name="aIndex"/>
-        <body>
-          <![CDATA[
-            this._wrapURIChangeCall(() => this.webNavigation.gotoIndex(aIndex));
-          ]]>
-        </body>
-      </method>
-
-      <property name="currentURI" readonly="true">
-       <getter><![CDATA[
-          if (this.webNavigation) {
-            return this.webNavigation.currentURI;
-          }
-          return null;
-       ]]>
-       </getter>
-      </property>
+  constructor() {
+    super();
 
-      <!--
-        Used by session restore to ensure that currentURI is set so
-        that switch-to-tab works before the tab is fully
-        restored. This function also invokes onLocationChanged
-        listeners in tabbrowser.xml.
-      -->
-      <method name="_setCurrentURI">
-        <parameter name="aURI"/>
-        <body><![CDATA[
-          if (this.isRemoteBrowser) {
-            this._remoteWebProgressManager.setCurrentURI(aURI);
-          } else {
-            this.docShell.setCurrentURI(aURI);
-          }
-        ]]></body>
-      </method>
+    this.onPageHide = this.onPageHide.bind(this);
 
-      <field name="_documentURI">null</field>
-      <property name="documentURI"
-                onget="return this.isRemoteBrowser ? this._documentURI : this.contentDocument.documentURIObject;"
-                readonly="true"/>
-
+    /**
+     * These are managed by the tabbrowser:
+     */
+    this.droppedLinkHandler = null;
+    this.mIconURL = null;
+    this.lastURI = null;
 
-      <field name="_documentContentType">null</field>
-      <property name="documentContentType"
-                readonly="true">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._documentContentType;
-          }
-          return this.contentDocument ? this.contentDocument.contentType : null;
-        ]]></getter>
-      </property>
+    this.addEventListener("keypress", (event) => {
+      if (event.keyCode != KeyEvent.DOM_VK_F7) { return; }
+      if (event.defaultPrevented || !event.isTrusted)
+        return;
 
-      <!--
-        Weak reference to an optional frame loader that can be used to influence
-        process selection for this browser.
-        See nsIBrowser.sameProcessAsFrameLoader.
-      -->
-      <field name="_sameProcessAsFrameLoader">null</field>
-      <property name="sameProcessAsFrameLoader">
-        <getter><![CDATA[
-          return this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get();
-        ]]></getter>
-        <setter><![CDATA[
-          this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
-        ]]></setter>
-      </property>
+      const kPrefShortcutEnabled = "accessibility.browsewithcaret_shortcut.enabled";
+      const kPrefWarnOnEnable = "accessibility.warn_on_browsewithcaret";
+      const kPrefCaretBrowsingOn = "accessibility.browsewithcaret";
 
-      <field name="_loadContext">null</field>
-
-      <property name="loadContext" readonly="true">
-        <getter><![CDATA[
-          if (this._loadContext)
-            return this._loadContext;
-
-          let {frameLoader} = this;
-          if (!frameLoader)
-            return null;
-          this._loadContext = frameLoader.loadContext;
-          return this._loadContext;
-        ]]></getter>
-      </property>
+      var isEnabled = this.mPrefs.getBoolPref(kPrefShortcutEnabled);
+      if (!isEnabled)
+        return;
 
-      <property name="autoCompletePopup"
-                onget="return document.getElementById(this.getAttribute('autocompletepopup'))"
-                readonly="true"/>
-
-      <property name="dateTimePicker"
-                onget="return document.getElementById(this.getAttribute('datetimepicker'))"
-                readonly="true"/>
+      // Toggle browse with caret mode
+      var browseWithCaretOn = this.mPrefs.getBoolPref(kPrefCaretBrowsingOn, false);
+      var warn = this.mPrefs.getBoolPref(kPrefWarnOnEnable, true);
+      if (warn && !browseWithCaretOn) {
+        var checkValue = { value: false };
+        var promptService = Services.prompt;
 
-      <property name="docShellIsActive">
-        <getter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              return this.frameLoader.tabParent.docShellIsActive;
-            }
-            return this.docShell && this.docShell.isActive;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              this.frameLoader.tabParent.docShellIsActive = val;
-              return val;
-            }
-            if (this.docShell)
-              return this.docShell.isActive = val;
-            return false;
-          ]]>
-        </setter>
-      </property>
-
-      <method name="preserveLayers">
-        <parameter name="preserve"/>
-        <body><![CDATA[
-          if (!this.isRemoteBrowser) {
-            return;
+        var buttonPressed = promptService.confirmEx(window,
+          this.mStrBundle.GetStringFromName("browsewithcaret.checkWindowTitle"),
+          this.mStrBundle.GetStringFromName("browsewithcaret.checkLabel"),
+          // Make "No" the default:
+          promptService.STD_YES_NO_BUTTONS | promptService.BUTTON_POS_1_DEFAULT,
+          null, null, null, this.mStrBundle.GetStringFromName("browsewithcaret.checkMsg"),
+          checkValue);
+        if (buttonPressed != 0) {
+          if (checkValue.value) {
+            try {
+              this.mPrefs.setBoolPref(kPrefShortcutEnabled, false);
+            } catch (ex) {}
           }
-          let {frameLoader} = this;
-          if (frameLoader.tabParent) {
-            frameLoader.tabParent.preserveLayers(preserve);
-          }
-        ]]></body>
-      </method>
-
-      <method name="deprioritize">
-        <body><![CDATA[
-          if (!this.isRemoteBrowser) {
-            return;
-          }
-          let {frameLoader} = this;
-          if (frameLoader.tabParent) {
-            frameLoader.tabParent.deprioritize();
-          }
-        ]]></body>
-      </method>
-
+          return;
+        }
+        if (checkValue.value) {
+          try {
+            this.mPrefs.setBoolPref(kPrefWarnOnEnable, false);
+          } catch (ex) {}
+        }
+      }
 
-      <property name="renderLayers">
-        <getter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              let {frameLoader} = this;
-              if (frameLoader && frameLoader.tabParent) {
-                return frameLoader.tabParent.renderLayers;
-              }
-              return false;
-            }
-            return this.docShellIsActive;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              let {frameLoader} = this;
-              if (frameLoader && frameLoader.tabParent) {
-                return frameLoader.tabParent.renderLayers = val;
-              }
-              return false;
-            }
-            return this.docShellIsActive = val;
-          ]]>
-        </setter>
-      </property>
+      // Toggle the pref
+      try {
+        this.mPrefs.setBoolPref(kPrefCaretBrowsingOn, !browseWithCaretOn);
+      } catch (ex) {}
+    }, { mozSystemGroup: true });
 
-      <property name="hasLayers" readonly="true">
-        <getter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              let {frameLoader} = this;
-              if (frameLoader.tabParent) {
-                return frameLoader.tabParent.hasLayers;
-              }
-              return false;
-            }
+    this.addEventListener("dragover", (event) => {
+      if (!this.droppedLinkHandler || event.defaultPrevented)
+        return;
 
-            return this.docShellIsActive;
-          ]]>
-        </getter>
-      </property>
-
-      <method name="forceRepaint">
-        <body>
-          <![CDATA[
-            if (!this.isRemoteBrowser) {
-              return;
-            }
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              frameLoader.tabParent.forceRepaint();
-            }
-          ]]>
-        </body>
-      </method>
-
-      <field name="_imageDocument">null</field>
-      <property name="imageDocument"
-                readonly="true">
-        <getter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              return this._imageDocument;
-            }
-            var document = this.contentDocument;
-            if (!document || !(document instanceof Ci.nsIImageDocument))
-              return null;
+      // For drags that appear to be internal text (for example, tab drags),
+      // set the dropEffect to 'none'. This prevents the drop even if some
+      // other listener cancelled the event.
+      var types = event.dataTransfer.types;
+      if (types.includes("text/x-moz-text-internal") && !types.includes("text/plain")) {
+        event.dataTransfer.dropEffect = "none";
+        event.stopPropagation();
+        event.preventDefault();
+      }
 
-            try {
-                return {width: document.imageRequest.image.width, height: document.imageRequest.image.height };
-            } catch (e) {}
-            return null;
-          ]]>
-        </getter>
-      </property>
-
-      <property name="isRemoteBrowser"
-                onget="return (this.getAttribute('remote') == 'true');"
-                readonly="true"/>
+      // No need to handle "dragover" in e10s, since nsDocShellTreeOwner.cpp in the child process
+      // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
+      if (this.isRemoteBrowser)
+        return;
 
-      <property name="remoteType"
-                readonly="true">
-        <getter>
-          <![CDATA[
-            if (!this.isRemoteBrowser) {
-              return null;
-            }
+      let linkHandler = Services.droppedLinkHandler;
+      if (linkHandler.canDropLink(event, false))
+        event.preventDefault();
+    }, { mozSystemGroup: true });
 
-            let remoteType = this.getAttribute("remoteType");
-            if (remoteType) {
-              return remoteType;
-            }
-
-            let E10SUtils = ChromeUtils.import("resource://gre/modules/E10SUtils.jsm", {}).E10SUtils;
-            return E10SUtils.DEFAULT_REMOTE_TYPE;
-          ]]>
-        </getter>
-      </property>
+    this.addEventListener("drop", (event) => {
+      // No need to handle "drop" in e10s, since nsDocShellTreeOwner.cpp in the child process
+      // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
+      if (!this.droppedLinkHandler || event.defaultPrevented || this.isRemoteBrowser)
+        return;
 
-      <property name="messageManager"
-                readonly="true">
-        <getter>
-          <![CDATA[
-            if (this.frameLoader) {
-              return this.frameLoader.messageManager;
-            }
-            return null;
-          ]]>
-        </getter>
-
-      </property>
+      let linkHandler = Services.droppedLinkHandler;
+      try {
+        // Pass true to prevent the dropping of javascript:/data: URIs
+        var links = linkHandler.dropLinks(event, true);
+      } catch (ex) {
+        return;
+      }
 
-      <field name="_webBrowserFind">null</field>
+      if (links.length) {
+        let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
+        this.droppedLinkHandler(event, links, triggeringPrincipal);
+      }
+    }, { mozSystemGroup: true });
 
-      <property name="webBrowserFind"
-                readonly="true">
-        <getter>
-        <![CDATA[
-          if (!this._webBrowserFind)
-            this._webBrowserFind = this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebBrowserFind);
-          return this._webBrowserFind;
-        ]]>
-        </getter>
-      </property>
+    this.addEventListener("dragstart", (event) => {
+      // If we're a remote browser dealing with a dragstart, stop it
+      // from propagating up, since our content process should be dealing
+      // with the mouse movement.
+      if (this.isRemoteBrowser) {
+        event.stopPropagation();
+      }
+    });
+
+  }
 
-      <method name="getTabBrowser">
-        <body>
-          <![CDATA[
-            if (this.ownerGlobal.gBrowser &&
-                this.ownerGlobal.gBrowser.getTabForBrowser &&
-                this.ownerGlobal.gBrowser.getTabForBrowser(this)) {
-              return this.ownerGlobal.gBrowser;
-            }
-            return null;
-          ]]>
-        </body>
-      </method>
+  initializeFields() {
+    if (this.observer) {
+      try {
+        Services.obs.removeObserver(this.observer, "browser:purge-session-history");
+      } catch (ex) {
+        // It's not clear why this sometimes throws an exception.
+      }
+      this.observer = null;
+    }
 
-      <field name="_finder">null</field>
-      <field name="_remoteFinder">null</field>
-      <property name="finder" readonly="true">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            if (!this._remoteFinder) {
-              // Don't attempt to create the remote finder if the
-              // messageManager has already gone away
-              if (!this.messageManager)
-                return null;
+    let browser = this;
+    this.observer = {
+      observe(aSubject, aTopic, aState) {
+        if (aTopic == "browser:purge-session-history") {
+          browser.purgeSessionHistory();
+        } else if (aTopic == "apz:cancel-autoscroll") {
+          if (aState == browser._autoScrollScrollId) {
+            // Set this._autoScrollScrollId to null, so in stopScroll() we
+            // don't call stopApzAutoscroll() (since it's APZ that
+            // initiated the stopping).
+            browser._autoScrollScrollId = null;
+            browser._autoScrollPresShellId = null;
 
-              let jsm = "resource://gre/modules/FinderParent.jsm";
-              let { FinderParent } = ChromeUtils.import(jsm, {});
-              this._remoteFinder = new FinderParent(this);
-            }
-            return this._remoteFinder;
-          }
-          if (!this._finder) {
-            if (!this.docShell)
-              return null;
-
-            let Finder = ChromeUtils.import("resource://gre/modules/Finder.jsm", {}).Finder;
-            this._finder = new Finder(this.docShell);
+            browser._autoScrollPopup.hidePopup();
           }
-          return this._finder;
-        ]]></getter>
-      </property>
-
-      <field name="_fastFind">null</field>
-      <property name="fastFind" readonly="true">
-        <getter><![CDATA[
-          if (!this._fastFind) {
-            if (!("@mozilla.org/typeaheadfind;1" in Cc))
-              return null;
-
-            var tabBrowser = this.getTabBrowser();
-            if (tabBrowser && "fastFind" in tabBrowser)
-              return this._fastFind = tabBrowser.fastFind;
-
-            if (!this.docShell)
-              return null;
-
-            this._fastFind = Cc["@mozilla.org/typeaheadfind;1"]
-                               .createInstance(Ci.nsITypeAheadFind);
-            this._fastFind.init(this.docShell);
-          }
-          return this._fastFind;
-        ]]></getter>
-      </property>
-
-      <field name="_outerWindowID">null</field>
-      <property name="outerWindowID" readonly="true">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._outerWindowID;
-          }
-          return this.docShell.outerWindowID;
-        ]]></getter>
-      </property>
-
-      <field name="_innerWindowID">null</field>
-      <property name="innerWindowID" readonly="true">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._innerWindowID;
-          }
-          try {
-            return this.contentWindow.windowUtils.currentInnerWindowID;
-          } catch (e) {
-            if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {
-              throw e;
-            }
-            return null;
-          }
-        ]]></getter>
-      </property>
-
-      <field name="_browsingContextId">null</field>
-
-      <property name="browsingContext" readonly="true">
-        <getter><![CDATA[
-          if (!this.isRemoteBrowser) {
-            return this.docShell.browsingContext;
-          }
-
-          return ChromeUtils.getBrowsingContext(this._browsingContextId);
-        ]]></getter>
-      </property>
-
-      <field name="_lastSearchString">null</field>
+        }
+      },
+      QueryInterface: ChromeUtils.generateQI([
+        Ci.nsIObserver,
+        Ci.nsISupportsWeakReference,
+      ]),
+    };
 
 
-      <field name="_controller">null</field>
+    this._documentURI = null;
+
+    this._documentContentType = null;
+
+    /**
+     * Weak reference to an optional frame loader that can be used to influence
+     * process selection for this browser.
+     * See nsIBrowser.sameProcessAsFrameLoader.
+     */
+    this._sameProcessAsFrameLoader = null;
+
+    this._loadContext = null;
+
+    this._imageDocument = null;
+
+    this._webBrowserFind = null;
+
+    this._finder = null;
+
+    this._remoteFinder = null;
+
+    this._fastFind = null;
+
+    this._outerWindowID = null;
+
+    this._innerWindowID = null;
+
+    this._browsingContextId = null;
+
+    this._lastSearchString = null;
+
+    this._controller = null;
+
+    this._selectParentHelper = null;
+
+    this._remoteWebNavigation = null;
+
+    this._remoteWebProgress = null;
+
+    this._contentTitle = "";
+
+    this._characterSet = "";
+
+    this._mayEnableCharacterEncodingMenu = null;
+
+    this._contentPrincipal = null;
+
+    this._contentRequestContextID = null;
+
+    this._fullZoom = 1;
+
+    this._textZoom = 1;
 
-      <field name="_selectParentHelper">null</field>
+    this._isSyntheticDocument = false;
+
+    this.mPrefs = Services.prefs;
+
+    this._mStrBundle = null;
+
+    this.blockedPopups = null;
+
+    this._audioMuted = false;
+
+    this._hasAnyPlayingMediaBeenBlocked = false;
+
+    /**
+     * Only send the message "Browser:UnselectedTabHover" when someone requests
+     * for the message, which can reduce non-necessary communication.
+     */
+    this._shouldSendUnselectedTabHover = false;
+
+    this._unselectedTabHoverMessageListenerCount = 0;
+
+    this._securityUI = null;
+
+    this.urlbarChangeTracker = {
+      _startedLoadSinceLastUserTyping: false,
+
+      startedLoad() {
+        this._startedLoadSinceLastUserTyping = true;
+      },
+      finishedLoad() {
+        this._startedLoadSinceLastUserTyping = false;
+      },
+      userTyped() {
+        this._startedLoadSinceLastUserTyping = false;
+      },
+    };
+
+    this._userTypedValue = null;
+
+    this._AUTOSCROLL_SNAP = 10;
+
+    this._scrolling = false;
+
+    this._startX = null;
+
+    this._startY = null;
+
+    this._autoScrollPopup = null;
+
+    this._autoScrollNeedsCleanup = false;
+
+    /**
+     * These IDs identify the scroll frame being autoscrolled.
+     */
+    this._autoScrollScrollId = null;
 
-      <field name="_remoteWebNavigation">null</field>
-      <!-- Note that this overrides webNavigation on XULFrameElement, and duplicates the return value for the non-remote case -->
-      <property name="webNavigation"
-                readonly="true"
-                onget="return this.isRemoteBrowser ? this._remoteWebNavigation : this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);"/>
+    this._autoScrollPresShellId = null;
+
+    this._permitUnloadId = 0;
+  }
+
+  connectedCallback() {
+    this.construct();
+  }
+
+  get autoscrollEnabled() {
+    if (this.getAttribute("autoscroll") == "false")
+      return false;
+
+    return this.mPrefs.getBoolPref("general.autoScroll", true);
+  }
+
+  get canGoBack() {
+    return this.webNavigation.canGoBack;
+  }
+
+  get canGoForward() {
+    return this.webNavigation.canGoForward;
+  }
+
+  get currentURI() {
+    if (this.webNavigation) {
+      return this.webNavigation.currentURI;
+    }
+    return null;
+  }
+
+  get documentURI() {
+    return this.isRemoteBrowser ? this._documentURI : this.contentDocument.documentURIObject;
+  }
+
+  get documentContentType() {
+    if (this.isRemoteBrowser) {
+      return this._documentContentType;
+    }
+    return this.contentDocument ? this.contentDocument.contentType : null;
+  }
+
+  set sameProcessAsFrameLoader(val) {
+    this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+  }
+
+  get sameProcessAsFrameLoader() {
+    return this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get();
+  }
+
+  get loadContext() {
+    if (this._loadContext)
+      return this._loadContext;
+
+    let { frameLoader } = this;
+    if (!frameLoader)
+      return null;
+    this._loadContext = frameLoader.loadContext;
+    return this._loadContext;
+  }
+
+  get autoCompletePopup() {
+    return document.getElementById(this.getAttribute("autocompletepopup"));
+  }
+
+  get dateTimePicker() {
+    return document.getElementById(this.getAttribute("datetimepicker"));
+  }
+
+  set docShellIsActive(val) {
+    if (this.isRemoteBrowser) {
+      this.frameLoader.tabParent.docShellIsActive = val;
+      return val;
+    }
+    if (this.docShell)
+      return this.docShell.isActive = val;
+    return false;
+  }
+
+  get docShellIsActive() {
+    if (this.isRemoteBrowser) {
+      return this.frameLoader.tabParent.docShellIsActive;
+    }
+    return this.docShell && this.docShell.isActive;
+  }
+
+  set renderLayers(val) {
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader && frameLoader.tabParent) {
+        return frameLoader.tabParent.renderLayers = val;
+      }
+      return false;
+    }
+    return this.docShellIsActive = val;
+  }
+
+  get renderLayers() {
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader && frameLoader.tabParent) {
+        return frameLoader.tabParent.renderLayers;
+      }
+      return false;
+    }
+    return this.docShellIsActive;
+  }
 
-      <field name="_remoteWebProgress">null</field>
-      <property name="webProgress"
-                readonly="true"
-                onget="return this.isRemoteBrowser ? this._remoteWebProgress : this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);"/>
+  get hasLayers() {
+    if (this.isRemoteBrowser) {
+      let { frameLoader } = this;
+      if (frameLoader.tabParent) {
+        return frameLoader.tabParent.hasLayers;
+      }
+      return false;
+    }
+
+    return this.docShellIsActive;
+  }
+
+  get imageDocument() {
+    if (this.isRemoteBrowser) {
+      return this._imageDocument;
+    }
+    var document = this.contentDocument;
+    if (!document || !(document instanceof Ci.nsIImageDocument))
+      return null;
+
+    try {
+      return { width: document.imageRequest.image.width, height: document.imageRequest.image.height };
+    } catch (e) {}
+    return null;
+  }
+
+  get isRemoteBrowser() {
+    return (this.getAttribute("remote") == "true");
+  }
+
+  get remoteType() {
+    if (!this.isRemoteBrowser) {
+      return null;
+    }
+
+    let remoteType = this.getAttribute("remoteType");
+    if (remoteType) {
+      return remoteType;
+    }
+
+    let E10SUtils = ChromeUtils.import("resource://gre/modules/E10SUtils.jsm", {}).E10SUtils;
+    return E10SUtils.DEFAULT_REMOTE_TYPE;
+  }
+
+  get messageManager() {
+    if (this.frameLoader) {
+      return this.frameLoader.messageManager;
+    }
+    return null;
+  }
 
-      <property name="sessionHistory"
-                onget="return this.webNavigation.sessionHistory;"
-                readonly="true"/>
+  get webBrowserFind() {
+    if (!this._webBrowserFind)
+      this._webBrowserFind = this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebBrowserFind);
+    return this._webBrowserFind;
+  }
+
+  get finder() {
+    if (this.isRemoteBrowser) {
+      if (!this._remoteFinder) {
+        // Don't attempt to create the remote finder if the
+        // messageManager has already gone away
+        if (!this.messageManager)
+          return null;
+
+        let jsm = "resource://gre/modules/FinderParent.jsm";
+        let { FinderParent } = ChromeUtils.import(jsm, {});
+        this._remoteFinder = new FinderParent(this);
+      }
+      return this._remoteFinder;
+    }
+    if (!this._finder) {
+      if (!this.docShell)
+        return null;
+
+      let Finder = ChromeUtils.import("resource://gre/modules/Finder.jsm", {}).Finder;
+      this._finder = new Finder(this.docShell);
+    }
+    return this._finder;
+  }
+
+  get fastFind() {
+    if (!this._fastFind) {
+      if (!("@mozilla.org/typeaheadfind;1" in Cc))
+        return null;
+
+      var tabBrowser = this.getTabBrowser();
+      if (tabBrowser && "fastFind" in tabBrowser)
+        return this._fastFind = tabBrowser.fastFind;
+
+      if (!this.docShell)
+        return null;
+
+      this._fastFind = Cc["@mozilla.org/typeaheadfind;1"]
+        .createInstance(Ci.nsITypeAheadFind);
+      this._fastFind.init(this.docShell);
+    }
+    return this._fastFind;
+  }
+
+  get outerWindowID() {
+    if (this.isRemoteBrowser) {
+      return this._outerWindowID;
+    }
+    return this.docShell.outerWindowID;
+  }
 
-      <property name="markupDocumentViewer"
-                onget="return this.docShell.contentViewer;"
-                readonly="true"/>
+  get innerWindowID() {
+    if (this.isRemoteBrowser) {
+      return this._innerWindowID;
+    }
+    try {
+      return this.contentWindow.windowUtils.currentInnerWindowID;
+    } catch (e) {
+      if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {
+        throw e;
+      }
+      return null;
+    }
+  }
+
+  get browsingContext() {
+    if (!this.isRemoteBrowser) {
+      return this.docShell.browsingContext;
+    }
+
+    return ChromeUtils.getBrowsingContext(this._browsingContextId);
+  }
+  /**
+   * Note that this overrides webNavigation on XULFrameElement, and duplicates the return value for the non-remote case
+   */
+  get webNavigation() {
+    return this.isRemoteBrowser ? this._remoteWebNavigation : this.docShell && this.docShell.QueryInterface(Ci.nsIWebNavigation);
+  }
+
+  get webProgress() {
+    return this.isRemoteBrowser ? this._remoteWebProgress : this.docShell && this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebProgress);
+  }
+
+  get sessionHistory() {
+    return this.webNavigation.sessionHistory;
+  }
+
+  get markupDocumentViewer() {
+    return this.docShell.contentViewer;
+  }
+
+  get contentTitle() {
+    return this.isRemoteBrowser ? this._contentTitle : this.contentDocument.title;
+  }
+
+  set characterSet(val) {
+    if (this.isRemoteBrowser) {
+      this.messageManager.sendAsyncMessage("UpdateCharacterSet", { value: val });
+      this._characterSet = val;
+    } else {
+      this.docShell.charset = val;
+      this.docShell.gatherCharsetMenuTelemetry();
+    }
+  }
 
-      <field name="_contentTitle">""</field>
-      <property name="contentTitle"
-                onget="return this.isRemoteBrowser ? this._contentTitle : this.contentDocument.title;"
-                readonly="true"/>
+  get characterSet() {
+    return this.isRemoteBrowser ? this._characterSet : this.docShell.charset;
+  }
+
+  get mayEnableCharacterEncodingMenu() {
+    return this.isRemoteBrowser ? this._mayEnableCharacterEncodingMenu : this.docShell.mayEnableCharacterEncodingMenu;
+  }
+
+  get contentPrincipal() {
+    return this.isRemoteBrowser ? this._contentPrincipal : this.contentDocument.nodePrincipal;
+  }
+
+  get contentRequestContextID() {
+    if (this.isRemoteBrowser) {
+      return this._contentRequestContextID;
+    }
+    try {
+      return this.contentDocument.documentLoadGroup
+        .requestContextID;
+    } catch (e) {
+      return null;
+    }
+  }
+
+  set showWindowResizer(val) {
+    if (val) this.setAttribute("showresizer", "true");
+    else this.removeAttribute("showresizer");
+    return val;
+  }
+
+  get showWindowResizer() {
+    return this.getAttribute("showresizer") == "true";
+  }
+
+  set fullZoom(val) {
+    if (this.isRemoteBrowser) {
+      let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
+
+      if (changed) {
+        this._fullZoom = val;
+        try {
+          this.messageManager.sendAsyncMessage("FullZoom", { value: val });
+        } catch (ex) {}
+
+        let event = new Event("FullZoomChange", { bubbles: true });
+        this.dispatchEvent(event);
+      }
+    } else {
+      this.markupDocumentViewer.fullZoom = val;
+    }
+  }
+
+  get fullZoom() {
+    if (this.isRemoteBrowser) {
+      return this._fullZoom;
+    }
+    return this.markupDocumentViewer.fullZoom;
+  }
 
-      <field name="_characterSet">""</field>
-      <property name="characterSet"
-                onget="return this.isRemoteBrowser ? this._characterSet : this.docShell.charset;">
-        <setter><![CDATA[
-          if (this.isRemoteBrowser) {
-            this.messageManager.sendAsyncMessage("UpdateCharacterSet", {value: val});
-            this._characterSet = val;
-          } else {
-            this.docShell.charset = val;
-            this.docShell.gatherCharsetMenuTelemetry();
-          }
-        ]]></setter>
-      </property>
+  set textZoom(val) {
+    if (this.isRemoteBrowser) {
+      let changed = val.toFixed(2) != this._textZoom.toFixed(2);
+
+      if (changed) {
+        this._textZoom = val;
+        try {
+          this.messageManager.sendAsyncMessage("TextZoom", { value: val });
+        } catch (ex) {}
+
+        let event = new Event("TextZoomChange", { bubbles: true });
+        this.dispatchEvent(event);
+      }
+    } else {
+      this.markupDocumentViewer.textZoom = val;
+    }
+
+  }
+
+  get textZoom() {
+    if (this.isRemoteBrowser) {
+      return this._textZoom;
+    }
+    return this.markupDocumentViewer.textZoom;
+  }
+
+  get isSyntheticDocument() {
+    if (this.isRemoteBrowser) {
+      return this._isSyntheticDocument;
+    }
+    return this.contentDocument.mozSyntheticDocument;
+  }
+
+  get hasContentOpener() {
+    if (this.isRemoteBrowser) {
+      return this.frameLoader.tabParent.hasContentOpener;
+    }
+    return !!this.contentWindow.opener;
+  }
+
+  get mStrBundle() {
+    if (!this._mStrBundle) {
+      // need to create string bundle manually instead of using <xul:stringbundle/>
+      // see bug 63370 for details
+      this._mStrBundle = Services.strings
+        .createBundle("chrome://global/locale/browser.properties");
+    }
+    return this._mStrBundle;
+  }
+
+  get audioMuted() {
+    return this._audioMuted;
+  }
+
+  get shouldHandleUnselectedTabHover() {
+    return this._shouldSendUnselectedTabHover;
+  }
+
+  get securityUI() {
+    if (this.isRemoteBrowser) {
+      if (!this._securityUI) {
+        // Don't attempt to create the remote web progress if the
+        // messageManager has already gone away
+        if (!this.messageManager)
+          return null;
+
+        let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
+        let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
+        this._securityUI = new RemoteSecurityUI();
+      }
+
+      // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
+      var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
+        .createInstance(Ci.nsISupportsInterfacePointer);
+      ptr.data = this._securityUI;
+      return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
+    }
+
+    if (!this.docShell.securityUI) {
+      const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
+      var securityUI = Cc[SECUREBROWSERUI_CONTRACTID]
+        .createInstance(Ci.nsISecureBrowserUI);
+      securityUI.init(this.docShell);
+    }
+
+    return this.docShell.securityUI;
+  }
+
+  set userTypedValue(val) {
+    this.urlbarChangeTracker.userTyped();
+    this._userTypedValue = val;
+    return val;
+  }
+
+  get userTypedValue() {
+    return this._userTypedValue;
+  }
+
+  get dontPromptAndDontUnload() {
+    return 1;
+  }
+
+  get dontPromptAndUnload() {
+    return 2;
+  }
+
+  _wrapURIChangeCall(fn) {
+    if (!this.isRemoteBrowser) {
+      this.inLoadURI = true;
+      try {
+        fn();
+      } finally {
+        this.inLoadURI = false;
+      }
+    } else {
+      fn();
+    }
+  }
+
+  goBack() {
+    var webNavigation = this.webNavigation;
+    if (webNavigation.canGoBack)
+      this._wrapURIChangeCall(() => webNavigation.goBack());
+  }
+
+  goForward() {
+    var webNavigation = this.webNavigation;
+    if (webNavigation.canGoForward)
+      this._wrapURIChangeCall(() => webNavigation.goForward());
+  }
+
+  reload() {
+    const nsIWebNavigation = Ci.nsIWebNavigation;
+    const flags = nsIWebNavigation.LOAD_FLAGS_NONE;
+    this.reloadWithFlags(flags);
+  }
+
+  reloadWithFlags(aFlags) {
+    this.webNavigation.reload(aFlags);
+  }
+
+  stop() {
+    const nsIWebNavigation = Ci.nsIWebNavigation;
+    const flags = nsIWebNavigation.STOP_ALL;
+    this.webNavigation.stop(flags);
+  }
+
+  /**
+   * throws exception for unknown schemes
+   */
+  loadURI(aURI, aParams) {
+    if (!aURI) {
+      aURI = "about:blank";
+    }
+
+    let {
+      flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE,
+        referrerURI,
+        referrerPolicy = Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,
+        triggeringPrincipal,
+        postData,
+    } = aParams || {};
+
+    this._wrapURIChangeCall(() =>
+      this.webNavigation.loadURIWithOptions(
+        aURI, flags, referrerURI, referrerPolicy,
+        postData, null, null, triggeringPrincipal));
+  }
+
+  gotoIndex(aIndex) {
+    this._wrapURIChangeCall(() => this.webNavigation.gotoIndex(aIndex));
+  }
+
+  /**
+   * Used by session restore to ensure that currentURI is set so
+   * that switch-to-tab works before the tab is fully
+   * restored. This function also invokes onLocationChanged
+   * listeners in tabbrowser.xml.
+   */
+  _setCurrentURI(aURI) {
+    if (this.isRemoteBrowser) {
+      this._remoteWebProgressManager.setCurrentURI(aURI);
+    } else {
+      this.docShell.setCurrentURI(aURI);
+    }
+  }
+
+  preserveLayers(preserve) {
+    if (!this.isRemoteBrowser) {
+      return;
+    }
+    let { frameLoader } = this;
+    if (frameLoader.tabParent) {
+      frameLoader.tabParent.preserveLayers(preserve);
+    }
+  }
+
+  deprioritize() {
+    if (!this.isRemoteBrowser) {
+      return;
+    }
+    let { frameLoader } = this;
+    if (frameLoader.tabParent) {
+      frameLoader.tabParent.deprioritize();
+    }
+  }
+
+  forceRepaint() {
+    if (!this.isRemoteBrowser) {
+      return;
+    }
+    let { frameLoader } = this;
+    if (frameLoader && frameLoader.tabParent) {
+      frameLoader.tabParent.forceRepaint();
+    }
+  }
 
-      <field name="_mayEnableCharacterEncodingMenu">null</field>
-      <property name="mayEnableCharacterEncodingMenu"
-                onget="return this.isRemoteBrowser ? this._mayEnableCharacterEncodingMenu : this.docShell.mayEnableCharacterEncodingMenu;"
-                readonly="true"/>
+  getTabBrowser() {
+    if (this.ownerGlobal.gBrowser &&
+      this.ownerGlobal.gBrowser.getTabForBrowser &&
+      this.ownerGlobal.gBrowser.getTabForBrowser(this)) {
+      return this.ownerGlobal.gBrowser;
+    }
+    return null;
+  }
+
+  addProgressListener(aListener, aNotifyMask) {
+    if (!aNotifyMask) {
+      aNotifyMask = Ci.nsIWebProgress.NOTIFY_ALL;
+    }
+    this.webProgress.addProgressListener(aListener, aNotifyMask);
+  }
+
+  removeProgressListener(aListener) {
+    this.webProgress.removeProgressListener(aListener);
+  }
+
+  onPageHide(aEvent) {
+    if (!this.docShell || !this.fastFind)
+      return;
+    var tabBrowser = this.getTabBrowser();
+    if (!tabBrowser || !("fastFind" in tabBrowser) ||
+      tabBrowser.selectedBrowser == this)
+      this.fastFind.setDocShell(this.docShell);
+  }
+
+  updateBlockedPopups() {
+    let event = document.createEvent("Events");
+    event.initEvent("DOMUpdateBlockedPopups", true, true);
+    this.dispatchEvent(event);
+  }
+
+  retrieveListOfBlockedPopups() {
+    this.messageManager.sendAsyncMessage("PopupBlocking:GetBlockedPopupList", null);
+    return new Promise(resolve => {
+      let self = this;
+      this.messageManager.addMessageListener("PopupBlocking:ReplyGetBlockedPopupList",
+        function replyReceived(msg) {
+          self.messageManager.removeMessageListener("PopupBlocking:ReplyGetBlockedPopupList",
+            replyReceived);
+          resolve(msg.data.popupData);
+        }
+      );
+    });
+  }
+
+  unblockPopup(aPopupIndex) {
+    this.messageManager.sendAsyncMessage("PopupBlocking:UnblockPopup", { index: aPopupIndex });
+  }
+
+  audioPlaybackStarted() {
+    if (this._audioMuted) {
+      return;
+    }
+    let event = document.createEvent("Events");
+    event.initEvent("DOMAudioPlaybackStarted", true, false);
+    this.dispatchEvent(event);
+  }
+
+  audioPlaybackStopped() {
+    let event = document.createEvent("Events");
+    event.initEvent("DOMAudioPlaybackStopped", true, false);
+    this.dispatchEvent(event);
+  }
+
+  notifyAudibleAutoplayMediaOccurred() {
+    let event = document.createEvent("Events");
+    event.initEvent("AudibleAutoplayMediaOccurred", true, false);
+    this.dispatchEvent(event);
+  }
+
+  /**
+   * When the pref "media.block-autoplay-until-in-foreground" is on,
+   * Gecko delays starting playback of media resources in tabs until the
+   * tab has been in the foreground or resumed by tab's play tab icon.
+   * - When Gecko delays starting playback of a media resource in a window,
+   * it sends a message to call activeMediaBlockStarted(). This causes the
+   * tab audio indicator to show.
+   * - When a tab is foregrounded, Gecko starts playing all delayed media
+   * resources in that tab, and sends a message to call
+   * activeMediaBlockStopped(). This causes the tab audio indicator to hide.
+   */
+  activeMediaBlockStarted() {
+    this._hasAnyPlayingMediaBeenBlocked = true;
+    let event = document.createEvent("Events");
+    event.initEvent("DOMAudioPlaybackBlockStarted", true, false);
+    this.dispatchEvent(event);
+  }
+
+  activeMediaBlockStopped() {
+    if (!this._hasAnyPlayingMediaBeenBlocked) {
+      return;
+    }
+    this._hasAnyPlayingMediaBeenBlocked = false;
+    let event = document.createEvent("Events");
+    event.initEvent("DOMAudioPlaybackBlockStopped", true, false);
+    this.dispatchEvent(event);
+  }
+
+  mute(transientState) {
+    if (!transientState) {
+      this._audioMuted = true;
+    }
+    this.messageManager.sendAsyncMessage("AudioPlayback", { type: "mute" });
+  }
 
-      <field name="_contentPrincipal">null</field>
-      <property name="contentPrincipal"
-                onget="return this.isRemoteBrowser ? this._contentPrincipal : this.contentDocument.nodePrincipal;"
-                readonly="true"/>
+  unmute() {
+    this._audioMuted = false;
+    this.messageManager.sendAsyncMessage("AudioPlayback", { type: "unmute" });
+  }
+
+  pauseMedia(disposable) {
+    let suspendedReason;
+    if (disposable) {
+      suspendedReason = "mediaControlPaused";
+    } else {
+      suspendedReason = "lostAudioFocusTransiently";
+    }
+
+    this.messageManager.sendAsyncMessage("AudioPlayback", { type: suspendedReason });
+  }
+
+  stopMedia() {
+    this.messageManager.sendAsyncMessage("AudioPlayback", { type: "mediaControlStopped" });
+  }
+
+  resumeMedia() {
+    this.messageManager.sendAsyncMessage("AudioPlayback", { type: "resumeMedia" });
+    if (this._hasAnyPlayingMediaBeenBlocked) {
+      this._hasAnyPlayingMediaBeenBlocked = false;
+      let event = document.createEvent("Events");
+      event.initEvent("DOMAudioPlaybackBlockStopped", true, false);
+      this.dispatchEvent(event);
+    }
+  }
+
+  unselectedTabHover(hovered) {
+    if (!this._shouldSendUnselectedTabHover) {
+      return;
+    }
+    this.messageManager.sendAsyncMessage("Browser:UnselectedTabHover", { hovered });
+  }
+
+  didStartLoadSinceLastUserTyping() {
+    return !this.inLoadURI &&
+      this.urlbarChangeTracker._startedLoadSinceLastUserTyping;
+  }
+
+  construct() {
+    trackBrowserForUnload(this);
+    this.initializeFields();
+    this.mDestroyed = false;
+    if (this.isRemoteBrowser) {
+      /*
+       * Don't try to send messages from this function. The message manager for
+       * the <browser> element may not be initialized yet.
+       */
+
+      this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
+        .createInstance(Ci.nsIWebNavigation);
+      this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
+      this._remoteWebNavigationImpl.swapBrowser(this);
 
-      <field name="_contentRequestContextID">null</field>
-      <property name="contentRequestContextID" readonly="true">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._contentRequestContextID;
-          }
+      // Initialize contentPrincipal to the about:blank principal for this loadcontext
+      let { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
+      let aboutBlank = Services.io.newURI("about:blank");
+      let ssm = Services.scriptSecurityManager;
+      this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
+
+      this.messageManager.addMessageListener("Browser:Init", this);
+      this.messageManager.addMessageListener("DOMTitleChanged", this);
+      this.messageManager.addMessageListener("ImageDocumentLoaded", this);
+      this.messageManager.addMessageListener("FullZoomChange", this);
+      this.messageManager.addMessageListener("TextZoomChange", this);
+      this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
+
+      // browser-child messages, such as Content:LocationChange, are handled in
+      // RemoteWebProgress, ensure it is loaded and ready.
+      let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
+      let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
+
+      let oldManager = this._remoteWebProgressManager;
+      this._remoteWebProgressManager = new RemoteWebProgressManager(this);
+      if (oldManager) {
+        // We're transitioning from one remote type to another. This means that
+        // the RemoteWebProgress listener is listening to the old message manager,
+        // and needs to be pointed at the new one.
+        this._remoteWebProgressManager.swapListeners(oldManager);
+      }
+
+      this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
+
+      this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
+
+      if (this.hasAttribute("selectmenulist")) {
+        this.messageManager.addMessageListener("Forms:ShowDropDown", this);
+        this.messageManager.addMessageListener("Forms:HideDropDown", this);
+      }
+
+      if (!this.hasAttribute("disablehistory")) {
+        Services.obs.addObserver(this.observer, "browser:purge-session-history", true);
+      }
+
+      let rc_js = "resource://gre/modules/RemoteController.js";
+      let scope = {};
+      Services.scriptloader.loadSubScript(rc_js, scope);
+      let RemoteController = scope.RemoteController;
+      this._controller = new RemoteController(this);
+      this.controllers.appendController(this._controller);
+    }
+
+    try {
+      // |webNavigation.sessionHistory| will have been set by the frame
+      // loader when creating the docShell as long as this xul:browser
+      // doesn't have the 'disablehistory' attribute set.
+      if (this.docShell && this.webNavigation.sessionHistory) {
+        Services.obs.addObserver(this.observer, "browser:purge-session-history", true);
+
+        // enable global history if we weren't told otherwise
+        if (!this.hasAttribute("disableglobalhistory") && !this.isRemoteBrowser) {
           try {
-            return this.contentDocument.documentLoadGroup
-                       .requestContextID;
-          } catch (e) {
-            return null;
+            this.docShell.useGlobalHistory = true;
+          } catch (ex) {
+            // This can occur if the Places database is locked
+            Cu.reportError("Error enabling browser global history: " + ex);
           }
-        ]]></getter>
-      </property>
+        }
+      }
+    } catch (e) {
+      Cu.reportError(e);
+    }
+    try {
+      // Ensures the securityUI is initialized.
+      var securityUI = this.securityUI; // eslint-disable-line no-unused-vars
+    } catch (e) {}
 
-      <property name="showWindowResizer"
-                onset="if (val) this.setAttribute('showresizer', 'true');
-                       else this.removeAttribute('showresizer');
-                       return val;"
-                onget="return this.getAttribute('showresizer') == 'true';"/>
+    // tabbrowser.xml sets "sameProcessAsFrameLoader" as a direct property
+    // on some browsers before they are put into a DOM (and get a
+    // binding).  This hack makes sure that we hold a weak reference to
+    // the other browser (and go through the proper getter and setter).
+    if (this.hasOwnProperty("sameProcessAsFrameLoader")) {
+      var sameProcessAsFrameLoader = this.sameProcessAsFrameLoader;
+      delete this.sameProcessAsFrameLoader;
+      this.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
+    }
+
+    if (!this.isRemoteBrowser) {
+      // If we've transitioned from remote to non-remote, we'll give up trying to
+      // keep the web progress listeners persisted during the transition.
+      delete this._remoteWebProgressManager;
+      delete this._remoteWebProgress;
+
+      this.addEventListener("pagehide", this.onPageHide, true);
+    }
 
-      <field name="_fullZoom">1</field>
-      <property name="fullZoom">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._fullZoom;
-          }
-          return this.markupDocumentViewer.fullZoom;
-        ]]></getter>
-        <setter><![CDATA[
-          if (this.isRemoteBrowser) {
-            let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
+    if (this.messageManager) {
+      this.messageManager.addMessageListener("PopupBlocking:UpdateBlockedPopups", this);
+      this.messageManager.addMessageListener("Autoscroll:Start", this);
+      this.messageManager.addMessageListener("Autoscroll:Cancel", this);
+      this.messageManager.addMessageListener("AudioPlayback:Start", this);
+      this.messageManager.addMessageListener("AudioPlayback:Stop", this);
+      this.messageManager.addMessageListener("AudioPlayback:ActiveMediaBlockStart", this);
+      this.messageManager.addMessageListener("AudioPlayback:ActiveMediaBlockStop", this);
+      this.messageManager.addMessageListener("UnselectedTabHover:Toggle", this);
+      this.messageManager.addMessageListener("AudibleAutoplayMediaOccurred", this);
+
+      if (this.hasAttribute("selectmenulist")) {
+        this.messageManager.addMessageListener("Forms:ShowDropDown", this);
+        this.messageManager.addMessageListener("Forms:HideDropDown", this);
+      }
+
+    }
+  }
 
-            if (changed) {
-              this._fullZoom = val;
-              try {
-                this.messageManager.sendAsyncMessage("FullZoom", {value: val});
-              } catch (ex) {}
+  /**
+   * This is necessary because the destructor doesn't always get called when
+   * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
+   */
+  destroy() {
+    untrackBrowserForUnload(this);
+
+    // Make sure that any open select is closed.
+    if (this._selectParentHelper) {
+      let menulist = document.getElementById(this.getAttribute("selectmenulist"));
+      this._selectParentHelper.hide(menulist, this);
+    }
+
+    this.initializeFields();
+
+    if (this.mDestroyed)
+      return;
+
+    this.mDestroyed = true;
+
+    if (this.isRemoteBrowser) {
+      try {
+        this.controllers.removeController(this._controller);
+      } catch (ex) {
+        // This can fail when this browser element is not attached to a
+        // BrowserDOMWindow.
+      }
+      return;
+    }
 
-              let event = new Event("FullZoomChange", {bubbles: true});
-              this.dispatchEvent(event);
-            }
-          } else {
-            this.markupDocumentViewer.fullZoom = val;
-          }
-        ]]></setter>
-      </property>
+    this.lastURI = null;
+
+    if (!this.isRemoteBrowser) {
+      this.removeEventListener("pagehide", this.onPageHide, true);
+    }
+
+    if (this._autoScrollNeedsCleanup) {
+      // we polluted the global scope, so clean it up
+      this._autoScrollPopup.remove();
+    }
+  }
 
-      <field name="_textZoom">1</field>
-      <property name="textZoom">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._textZoom;
+  /**
+   * We call this _receiveMessage (and alias receiveMessage to it) so that
+   * bindings that inherit from this one can delegate to it.
+   */
+  _receiveMessage(aMessage) {
+    let data = aMessage.data;
+    switch (aMessage.name) {
+      case "PopupBlocking:UpdateBlockedPopups":
+        {
+          this.blockedPopups = {
+            length: data.count,
+            reported: !data.freshPopup,
+          };
+
+          this.updateBlockedPopups();
+          break;
+        }
+      case "Autoscroll:Start":
+        {
+          if (!this.autoscrollEnabled) {
+            return { autoscrollEnabled: false, usingApz: false };
           }
-          return this.markupDocumentViewer.textZoom;
-        ]]></getter>
-        <setter><![CDATA[
-          if (this.isRemoteBrowser) {
-            let changed = val.toFixed(2) != this._textZoom.toFixed(2);
+          this.startScroll(data.scrolldir, data.screenX, data.screenY);
+          let usingApz = false;
+          if (this.isRemoteBrowser && data.scrollId != null &&
+            this.mPrefs.getBoolPref("apz.autoscroll.enabled", false)) {
+            let { tabParent } = this.frameLoader;
+            if (tabParent) {
+              // If APZ is handling the autoscroll, it may decide to cancel
+              // it of its own accord, so register an observer to allow it
+              // to notify us of that.
+              var os = Services.obs;
+              os.addObserver(this.observer, "apz:cancel-autoscroll", true);
 
-            if (changed) {
-              this._textZoom = val;
-              try {
-                this.messageManager.sendAsyncMessage("TextZoom", {value: val});
-              } catch (ex) {}
-
-              let event = new Event("TextZoomChange", {bubbles: true});
-              this.dispatchEvent(event);
+              usingApz = tabParent.startApzAutoscroll(
+                data.screenX, data.screenY,
+                data.scrollId, data.presShellId);
             }
-          } else {
-            this.markupDocumentViewer.textZoom = val;
+            // Save the IDs for later
+            this._autoScrollScrollId = data.scrollId;
+            this._autoScrollPresShellId = data.presShellId;
+          }
+          return { autoscrollEnabled: true, usingApz };
+        }
+      case "Autoscroll:Cancel":
+        this._autoScrollPopup.hidePopup();
+        break;
+      case "AudioPlayback:Start":
+        this.audioPlaybackStarted();
+        break;
+      case "AudioPlayback:Stop":
+        this.audioPlaybackStopped();
+        break;
+      case "AudioPlayback:ActiveMediaBlockStart":
+        this.activeMediaBlockStarted();
+        break;
+      case "AudioPlayback:ActiveMediaBlockStop":
+        this.activeMediaBlockStopped();
+        break;
+      case "UnselectedTabHover:Toggle":
+        this._shouldSendUnselectedTabHover = data.enable ?
+          ++this._unselectedTabHoverMessageListenerCount > 0 :
+          --this._unselectedTabHoverMessageListenerCount == 0;
+        break;
+      case "AudibleAutoplayMediaOccurred":
+        this.notifyAudibleAutoplayMediaOccurred();
+        break;
+      case "Forms:ShowDropDown":
+        {
+          if (!this._selectParentHelper) {
+            this._selectParentHelper =
+              ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
           }
 
-        ]]></setter>
-        <setter><![CDATA[
-        ]]></setter>
-      </property>
-
-      <field name="_isSyntheticDocument">false</field>
-      <property name="isSyntheticDocument">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this._isSyntheticDocument;
-          }
-          return this.contentDocument.mozSyntheticDocument;
-        ]]></getter>
-      </property>
-
-      <property name="hasContentOpener">
-        <getter><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this.frameLoader.tabParent.hasContentOpener;
-          }
-          return !!this.contentWindow.opener;
-        ]]></getter>
-      </property>
-
-      <field name="mPrefs" readonly="true">
-        Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
-      </field>
-
-      <field name="_mStrBundle">null</field>
-
-      <property name="mStrBundle">
-        <getter>
-        <![CDATA[
-          if (!this._mStrBundle) {
-            // need to create string bundle manually instead of using <xul:stringbundle/>
-            // see bug 63370 for details
-            this._mStrBundle = Cc["@mozilla.org/intl/stringbundle;1"]
-                                 .getService(Ci.nsIStringBundleService)
-                                 .createBundle("chrome://global/locale/browser.properties");
-          }
-          return this._mStrBundle;
-        ]]></getter>
-      </property>
-
-      <method name="addProgressListener">
-        <parameter name="aListener"/>
-        <parameter name="aNotifyMask"/>
-        <body>
-          <![CDATA[
-            if (!aNotifyMask) {
-              aNotifyMask = Ci.nsIWebProgress.NOTIFY_ALL;
-            }
-            this.webProgress.addProgressListener(aListener, aNotifyMask);
-          ]]>
-        </body>
-      </method>
-
-      <method name="removeProgressListener">
-        <parameter name="aListener"/>
-        <body>
-          <![CDATA[
-            this.webProgress.removeProgressListener(aListener);
-         ]]>
-        </body>
-      </method>
-
-      <method name="onPageHide">
-        <parameter name="aEvent"/>
-        <body>
-          <![CDATA[
-            if (!this.docShell || !this.fastFind)
-              return;
-            var tabBrowser = this.getTabBrowser();
-            if (!tabBrowser || !("fastFind" in tabBrowser) ||
-                tabBrowser.selectedBrowser == this)
-              this.fastFind.setDocShell(this.docShell);
-         ]]>
-        </body>
-      </method>
-
-      <method name="updateBlockedPopups">
-        <body>
-          <![CDATA[
-            let event = document.createEvent("Events");
-            event.initEvent("DOMUpdateBlockedPopups", true, true);
-            this.dispatchEvent(event);
-          ]]>
-        </body>
-      </method>
-
-      <method name="retrieveListOfBlockedPopups">
-        <body>
-          <![CDATA[
-          this.messageManager.sendAsyncMessage("PopupBlocking:GetBlockedPopupList", null);
-          return new Promise(resolve => {
-            let self = this;
-            this.messageManager.addMessageListener("PopupBlocking:ReplyGetBlockedPopupList",
-              function replyReceived(msg) {
-                self.messageManager.removeMessageListener("PopupBlocking:ReplyGetBlockedPopupList",
-                                                          replyReceived);
-                resolve(msg.data.popupData);
-              }
-            );
-          });
-          ]]>
-        </body>
-      </method>
-
-      <method name="unblockPopup">
-        <parameter name="aPopupIndex"/>
-        <body><![CDATA[
-          this.messageManager.sendAsyncMessage("PopupBlocking:UnblockPopup",
-                                               {index: aPopupIndex});
-        ]]></body>
-      </method>
-
-      <field name="blockedPopups">null</field>
-
-      <method name="audioPlaybackStarted">
-        <body>
-          <![CDATA[
-            if (this._audioMuted) {
-              return;
-            }
-            let event = document.createEvent("Events");
-            event.initEvent("DOMAudioPlaybackStarted", true, false);
-            this.dispatchEvent(event);
-          ]]>
-        </body>
-      </method>
-
-      <method name="audioPlaybackStopped">
-        <body>
-          <![CDATA[
-            let event = document.createEvent("Events");
-            event.initEvent("DOMAudioPlaybackStopped", true, false);
-            this.dispatchEvent(event);
-          ]]>
-        </body>
-      </method>
-
-      <method name="notifyAudibleAutoplayMediaOccurred">
-        <body>
-          <![CDATA[
-            let event = document.createEvent("Events");
-            event.initEvent("AudibleAutoplayMediaOccurred", true, false);
-            this.dispatchEvent(event);
-          ]]>
-        </body>
-      </method>
-
-      <!--
-        When the pref "media.block-autoplay-until-in-foreground" is on,
-        Gecko delays starting playback of media resources in tabs until the
-        tab has been in the foreground or resumed by tab's play tab icon.
-        - When Gecko delays starting playback of a media resource in a window,
-        it sends a message to call activeMediaBlockStarted(). This causes the
-        tab audio indicator to show.
-        - When a tab is foregrounded, Gecko starts playing all delayed media
-        resources in that tab, and sends a message to call
-        activeMediaBlockStopped(). This causes the tab audio indicator to hide.
-       -->
-      <method name="activeMediaBlockStarted">
-        <body>
-          <![CDATA[
-            this._hasAnyPlayingMediaBeenBlocked = true;
-            let event = document.createEvent("Events");
-            event.initEvent("DOMAudioPlaybackBlockStarted", true, false);
-            this.dispatchEvent(event);
-          ]]>
-        </body>
-      </method>
-
-      <method name="activeMediaBlockStopped">
-        <body>
-          <![CDATA[
-            if (!this._hasAnyPlayingMediaBeenBlocked) {
-              return;
-            }
-            this._hasAnyPlayingMediaBeenBlocked = false;
-            let event = document.createEvent("Events");
-            event.initEvent("DOMAudioPlaybackBlockStopped", true, false);
-            this.dispatchEvent(event);
-          ]]>
-        </body>
-      </method>
-
-      <field name="_audioMuted">false</field>
-      <property name="audioMuted"
-                onget="return this._audioMuted;"
-                readonly="true"/>
-
-      <field name="_hasAnyPlayingMediaBeenBlocked">false</field>
-
-      <method name="mute">
-        <parameter name="transientState"/>
-        <body>
-          <![CDATA[
-            if (!transientState) {
-              this._audioMuted = true;
-            }
-            this.messageManager.sendAsyncMessage("AudioPlayback",
-                                                 {type: "mute"});
-          ]]>
-        </body>
-      </method>
-
-      <method name="unmute">
-        <body>
-          <![CDATA[
-            this._audioMuted = false;
-            this.messageManager.sendAsyncMessage("AudioPlayback",
-                                                 {type: "unmute"});
-          ]]>
-        </body>
-      </method>
-
-      <method name="pauseMedia">
-        <parameter name="disposable"/>
-        <body>
-          <![CDATA[
-            let suspendedReason;
-            if (disposable) {
-              suspendedReason = "mediaControlPaused";
-            } else {
-              suspendedReason = "lostAudioFocusTransiently";
-            }
-
-            this.messageManager.sendAsyncMessage("AudioPlayback",
-                                                 {type: suspendedReason});
-          ]]>
-        </body>
-      </method>
-
-      <method name="stopMedia">
-        <body>
-          <![CDATA[
-            this.messageManager.sendAsyncMessage("AudioPlayback",
-                                                 {type: "mediaControlStopped"});
-          ]]>
-        </body>
-      </method>
+          let menulist = document.getElementById(this.getAttribute("selectmenulist"));
+          menulist.menupopup.style.direction = data.direction;
+          this._selectParentHelper.populate(menulist, data.options, data.selectedIndex, this._fullZoom,
+            data.uaSelectBackgroundColor, data.uaSelectColor,
+            data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
+          this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
+          break;
+        }
 
-      <method name="resumeMedia">
-        <body>
-          <![CDATA[
-            this.messageManager.sendAsyncMessage("AudioPlayback",
-                                                 {type: "resumeMedia"});
-            if (this._hasAnyPlayingMediaBeenBlocked) {
-              this._hasAnyPlayingMediaBeenBlocked = false;
-              let event = document.createEvent("Events");
-              event.initEvent("DOMAudioPlaybackBlockStopped", true, false);
-              this.dispatchEvent(event);
-            }
-          ]]>
-        </body>
-      </method>
-
-      <!--
-        Only send the message "Browser:UnselectedTabHover" when someone requests
-        for the message, which can reduce non-necessary communication.
-      -->
-      <field name="_shouldSendUnselectedTabHover">false</field>
-      <field name="_unselectedTabHoverMessageListenerCount">0</field>
-      <property name="shouldHandleUnselectedTabHover"
-                onget="return this._shouldSendUnselectedTabHover;"
-                readonly="true"/>
-
-      <method name="unselectedTabHover">
-        <parameter name="hovered"/>
-        <body>
-          <![CDATA[
-            if (!this._shouldSendUnselectedTabHover) {
-              return;
-            }
-            this.messageManager.sendAsyncMessage("Browser:UnselectedTabHover",
-              { hovered });
-          ]]>
-        </body>
-      </method>
-
-      <field name="_securityUI">null</field>
-      <property name="securityUI"
-                readonly="true">
-        <getter>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              if (!this._securityUI) {
-                // Don't attempt to create the remote web progress if the
-                // messageManager has already gone away
-                if (!this.messageManager)
-                  return null;
-
-                let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
-                let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
-                this._securityUI = new RemoteSecurityUI();
-              }
-
-              // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
-              var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
-                          .createInstance(Ci.nsISupportsInterfacePointer);
-              ptr.data = this._securityUI;
-              return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
-            }
-
-            if (!this.docShell.securityUI) {
-              const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
-              var securityUI = Cc[SECUREBROWSERUI_CONTRACTID]
-                                 .createInstance(Ci.nsISecureBrowserUI);
-              securityUI.init(this.docShell);
-            }
-
-            return this.docShell.securityUI;
-          ]]>
-        </getter>
-      </property>
-
-      <field name="urlbarChangeTracker">
-        ({
-          _startedLoadSinceLastUserTyping: false,
-
-          startedLoad() {
-            this._startedLoadSinceLastUserTyping = true;
-          },
-          finishedLoad() {
-            this._startedLoadSinceLastUserTyping = false;
-          },
-          userTyped() {
-            this._startedLoadSinceLastUserTyping = false;
-          },
-        })
-      </field>
-
-      <method name="didStartLoadSinceLastUserTyping">
-        <body><![CDATA[
-          return !this.inLoadURI &&
-                 this.urlbarChangeTracker._startedLoadSinceLastUserTyping;
-        ]]></body>
-      </method>
-
-      <field name="_userTypedValue">
-        null
-      </field>
-
-      <property name="userTypedValue"
-                onget="return this._userTypedValue;">
-        <setter><![CDATA[
-          this.urlbarChangeTracker.userTyped();
-          this._userTypedValue = val;
-          return val;
-        ]]></setter>
-      </property>
-
-      <field name="droppedLinkHandler">
-        null
-      </field>
-
-      <field name="mIconURL">null</field>
-
-      <!-- This is managed by the tabbrowser -->
-      <field name="lastURI">null</field>
-
-      <field name="mDestroyed">false</field>
-
-      <constructor>
-        <![CDATA[
-        this.construct();
-        ]]>
-      </constructor>
-
-      <method name="construct">
-        <body><![CDATA[
-          if (this.isRemoteBrowser) {
-            /*
-            * Don't try to send messages from this function. The message manager for
-            * the <browser> element may not be initialized yet.
-            */
-
-            this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
-                                          .createInstance(Ci.nsIWebNavigation);
-            this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
-            this._remoteWebNavigationImpl.swapBrowser(this);
-
-            // Initialize contentPrincipal to the about:blank principal for this loadcontext
-            let {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
-            let aboutBlank = Services.io.newURI("about:blank");
-            let ssm = Services.scriptSecurityManager;
-            this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
-
-            this.messageManager.addMessageListener("Browser:Init", this);
-            this.messageManager.addMessageListener("DOMTitleChanged", this);
-            this.messageManager.addMessageListener("ImageDocumentLoaded", this);
-            this.messageManager.addMessageListener("FullZoomChange", this);
-            this.messageManager.addMessageListener("TextZoomChange", this);
-            this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
-
-            // browser-child messages, such as Content:LocationChange, are handled in
-            // RemoteWebProgress, ensure it is loaded and ready.
-            let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
-            let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
-
-            let oldManager = this._remoteWebProgressManager;
-            this._remoteWebProgressManager = new RemoteWebProgressManager(this);
-            if (oldManager) {
-              // We're transitioning from one remote type to another. This means that
-              // the RemoteWebProgress listener is listening to the old message manager,
-              // and needs to be pointed at the new one.
-              this._remoteWebProgressManager.swapListeners(oldManager);
-            }
-
-            this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
-
-            this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
-
-            if (this.hasAttribute("selectmenulist")) {
-              this.messageManager.addMessageListener("Forms:ShowDropDown", this);
-              this.messageManager.addMessageListener("Forms:HideDropDown", this);
-            }
-
-            if (!this.hasAttribute("disablehistory")) {
-              Services.obs.addObserver(this, "browser:purge-session-history", true);
-            }
-
-            let rc_js = "resource://gre/modules/RemoteController.js";
-            let scope = {};
-            Services.scriptloader.loadSubScript(rc_js, scope);
-            let RemoteController = scope.RemoteController;
-            this._controller = new RemoteController(this);
-            this.controllers.appendController(this._controller);
-          }
-
-          try {
-            // |webNavigation.sessionHistory| will have been set by the frame
-            // loader when creating the docShell as long as this xul:browser
-            // doesn't have the 'disablehistory' attribute set.
-            if (this.docShell && this.webNavigation.sessionHistory) {
-              var os = Cc["@mozilla.org/observer-service;1"]
-                         .getService(Ci.nsIObserverService);
-              os.addObserver(this, "browser:purge-session-history", true);
-
-              // enable global history if we weren't told otherwise
-              if (!this.hasAttribute("disableglobalhistory") && !this.isRemoteBrowser) {
-                try {
-                  this.docShell.useGlobalHistory = true;
-                } catch (ex) {
-                  // This can occur if the Places database is locked
-                  Cu.reportError("Error enabling browser global history: " + ex);
-                }
-              }
-            }
-          } catch (e) {
-            Cu.reportError(e);
-          }
-          try {
-            // Ensures the securityUI is initialized.
-            var securityUI = this.securityUI; // eslint-disable-line no-unused-vars
-          } catch (e) {
-          }
-
-          // tabbrowser.xml sets "sameProcessAsFrameLoader" as a direct property
-          // on some browsers before they are put into a DOM (and get a
-          // binding).  This hack makes sure that we hold a weak reference to
-          // the other browser (and go through the proper getter and setter).
-          if (this.hasOwnProperty("sameProcessAsFrameLoader")) {
-            var sameProcessAsFrameLoader = this.sameProcessAsFrameLoader;
-            delete this.sameProcessAsFrameLoader;
-            this.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
-          }
-
-          if (!this.isRemoteBrowser) {
-            // If we've transitioned from remote to non-remote, we'll give up trying to
-            // keep the web progress listeners persisted during the transition.
-            delete this._remoteWebProgressManager;
-            delete this._remoteWebProgress;
-
-            this.addEventListener("pagehide", this.onPageHide, true);
-          }
-
-          if (this.messageManager) {
-            this.messageManager.addMessageListener("PopupBlocking:UpdateBlockedPopups", this);
-            this.messageManager.addMessageListener("Autoscroll:Start", this);
-            this.messageManager.addMessageListener("Autoscroll:Cancel", this);
-            this.messageManager.addMessageListener("AudioPlayback:Start", this);
-            this.messageManager.addMessageListener("AudioPlayback:Stop", this);
-            this.messageManager.addMessageListener("AudioPlayback:ActiveMediaBlockStart", this);
-            this.messageManager.addMessageListener("AudioPlayback:ActiveMediaBlockStop", this);
-            this.messageManager.addMessageListener("UnselectedTabHover:Toggle", this);
-            this.messageManager.addMessageListener("AudibleAutoplayMediaOccurred", this);
-
-            if (this.hasAttribute("selectmenulist")) {
-              this.messageManager.addMessageListener("Forms:ShowDropDown", this);
-              this.messageManager.addMessageListener("Forms:HideDropDown", this);
-            }
-
-          }
-        ]]></body>
-      </method>
-
-      <destructor>
-        <![CDATA[
-          this.destroy();
-        ]]>
-      </destructor>
-
-      <!-- This is necessary because the destructor doesn't always get called when
-           we are removed from a tabbrowser. This will be explicitly called by tabbrowser.-->
-      <method name="destroy">
-        <body><![CDATA[
-          // Make sure that any open select is closed.
+      case "Forms:HideDropDown":
+        {
           if (this._selectParentHelper) {
             let menulist = document.getElementById(this.getAttribute("selectmenulist"));
             this._selectParentHelper.hide(menulist, this);
           }
-          if (this.mDestroyed)
-            return;
-          this.mDestroyed = true;
+          break;
+        }
+    }
+    return undefined;
+  }
 
-          if (this.isRemoteBrowser) {
-            try {
-              this.controllers.removeController(this._controller);
-            } catch (ex) {
-              // This can fail when this browser element is not attached to a
-              // BrowserDOMWindow.
-            }
-
-            if (!this.hasAttribute("disablehistory")) {
-              let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-              try {
-                Services.obs.removeObserver(this, "browser:purge-session-history");
-              } catch (ex) {
-                // It's not clear why this sometimes throws an exception.
-              }
-            }
+  receiveMessage(aMessage) {
+    if (!this.isRemoteBrowser) {
+      return this._receiveMessage(aMessage);
+    }
 
-            return;
-          }
+    let data = aMessage.data;
+    switch (aMessage.name) {
+      case "Browser:Init":
+        this._outerWindowID = data.outerWindowID;
+        this._browsingContextId = data.browsingContextId;
+        break;
+      case "DOMTitleChanged":
+        this._contentTitle = data.title;
+        break;
+      case "ImageDocumentLoaded":
+        this._imageDocument = {
+          width: data.width,
+          height: data.height,
+        };
+        break;
 
-          if (this.docShell && this.webNavigation.sessionHistory) {
-            var os = Cc["@mozilla.org/observer-service;1"]
-                       .getService(Ci.nsIObserverService);
-            try {
-              os.removeObserver(this, "browser:purge-session-history");
-            } catch (ex) {
-              // It's not clear why this sometimes throws an exception.
-            }
-          }
-
-          this._fastFind = null;
-          this._webBrowserFind = null;
-
-          this.lastURI = null;
-
-          if (!this.isRemoteBrowser) {
-            this.removeEventListener("pagehide", this.onPageHide, true);
+      case "Forms:ShowDropDown":
+        {
+          if (!this._selectParentHelper) {
+            this._selectParentHelper =
+              ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
           }
 
-          if (this._autoScrollNeedsCleanup) {
-            // we polluted the global scope, so clean it up
-            this._autoScrollPopup.remove();
-          }
-        ]]></body>
-      </method>
+          let menulist = document.getElementById(this.getAttribute("selectmenulist"));
+          menulist.menupopup.style.direction = data.direction;
 
+          let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
+            this.isSyntheticDocument ? this._fullZoom : this._textZoom;
+          this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
+            zoom,
+            data.uaSelectBackgroundColor, data.uaSelectColor,
+            data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
+          this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
+          break;
+        }
+
+      case "FullZoomChange":
+        {
+          this._fullZoom = data.value;
+          let event = document.createEvent("Events");
+          event.initEvent("FullZoomChange", true, false);
+          this.dispatchEvent(event);
+          break;
+        }
 
-      <!--
-        We call this _receiveMessage (and alias receiveMessage to it) so that
-        bindings that inherit from this one can delegate to it.
-      -->
-      <method name="_receiveMessage">
-        <parameter name="aMessage"/>
-        <body><![CDATA[
-          let data = aMessage.data;
-          switch (aMessage.name) {
-            case "PopupBlocking:UpdateBlockedPopups": {
-              this.blockedPopups = {
-                length: data.count,
-                reported: !data.freshPopup,
-              };
+      case "TextZoomChange":
+        {
+          this._textZoom = data.value;
+          let event = document.createEvent("Events");
+          event.initEvent("TextZoomChange", true, false);
+          this.dispatchEvent(event);
+          break;
+        }
+
+      case "ZoomChangeUsingMouseWheel":
+        {
+          let event = document.createEvent("Events");
+          event.initEvent("ZoomChangeUsingMouseWheel", true, false);
+          this.dispatchEvent(event);
+          break;
+        }
+
+      default:
+        return this._receiveMessage(aMessage);
+    }
+    return undefined;
+
+  }
+
+  enableDisableCommandsRemoteOnly(aAction, aEnabledLength, aEnabledCommands, aDisabledLength, aDisabledCommands) {
+    if (this._controller) {
+      this._controller.enableDisableCommands(aAction,
+        aEnabledLength, aEnabledCommands,
+        aDisabledLength, aDisabledCommands);
+    }
+  }
 
-              this.updateBlockedPopups();
-              break;
-            }
-            case "Autoscroll:Start": {
-              if (!this.autoscrollEnabled) {
-                return {autoscrollEnabled: false, usingApz: false};
-              }
-              this.startScroll(data.scrolldir, data.screenX, data.screenY);
-              let usingApz = false;
-              if (this.isRemoteBrowser && data.scrollId != null &&
-                  this.mPrefs.getBoolPref("apz.autoscroll.enabled", false)) {
-                let { tabParent } = this.frameLoader;
-                if (tabParent) {
-                  // If APZ is handling the autoscroll, it may decide to cancel
-                  // it of its own accord, so register an observer to allow it
-                  // to notify us of that.
-                  var os = Cc["@mozilla.org/observer-service;1"]
-                             .getService(Ci.nsIObserverService);
-                  os.addObserver(this, "apz:cancel-autoscroll", true);
+  purgeSessionHistory() {
+    if (this.isRemoteBrowser) {
+      try {
+        this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+      } catch (ex) {
+        // This can throw if the browser has started to go away.
+        if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
+          throw ex;
+        }
+      }
+      this._remoteWebNavigationImpl.canGoBack = false;
+      this._remoteWebNavigationImpl.canGoForward = false;
+      return;
+    }
+    this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+  }
+
+  createAboutBlankContentViewer(aPrincipal) {
+    if (this.isRemoteBrowser) {
+      // Ensure that the content process has the permissions which are
+      // needed to create a document with the given principal.
+      let permissionPrincipal =
+        BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
+      this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
 
-                  usingApz = tabParent.startApzAutoscroll(
-                      data.screenX, data.screenY,
-                      data.scrollId, data.presShellId);
-                }
-                // Save the IDs for later
-                this._autoScrollScrollId = data.scrollId;
-                this._autoScrollPresShellId = data.presShellId;
-              }
-              return {autoscrollEnabled: true, usingApz};
-            }
-            case "Autoscroll:Cancel":
-              this._autoScrollPopup.hidePopup();
-              break;
-            case "AudioPlayback:Start":
-              this.audioPlaybackStarted();
-              break;
-            case "AudioPlayback:Stop":
-              this.audioPlaybackStopped();
-              break;
-            case "AudioPlayback:ActiveMediaBlockStart":
-              this.activeMediaBlockStarted();
-              break;
-            case "AudioPlayback:ActiveMediaBlockStop":
-              this.activeMediaBlockStopped();
-              break;
-            case "UnselectedTabHover:Toggle":
-              this._shouldSendUnselectedTabHover = data.enable ?
-                ++this._unselectedTabHoverMessageListenerCount > 0 :
-                --this._unselectedTabHoverMessageListenerCount == 0;
-              break;
-            case "AudibleAutoplayMediaOccurred":
-              this.notifyAudibleAutoplayMediaOccurred();
-              break;
-            case "Forms:ShowDropDown": {
-              if (!this._selectParentHelper) {
-                this._selectParentHelper =
-                  ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
-              }
+      // Create the about blank content viewer in the content process
+      this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
+      return;
+    }
+    let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
+    this.docShell.createAboutBlankContentViewer(principal);
+  }
+
+  stopScroll() {
+    if (this._scrolling) {
+      this._scrolling = false;
+      window.removeEventListener("mousemove", this, true);
+      window.removeEventListener("mousedown", this, true);
+      window.removeEventListener("mouseup", this, true);
+      window.removeEventListener("DOMMouseScroll", this, true);
+      window.removeEventListener("contextmenu", this, true);
+      window.removeEventListener("keydown", this, true);
+      window.removeEventListener("keypress", this, true);
+      window.removeEventListener("keyup", this, true);
+      this.messageManager.sendAsyncMessage("Autoscroll:Stop");
+
+      try {
+        Services.obs.removeObserver(this.observer, "apz:cancel-autoscroll");
+      } catch (ex) {
+        // It's not clear why this sometimes throws an exception
+      }
+
+      if (this.isRemoteBrowser && this._autoScrollScrollId != null) {
+        let { tabParent } = this.frameLoader;
+        if (tabParent) {
+          tabParent.stopApzAutoscroll(this._autoScrollScrollId,
+            this._autoScrollPresShellId);
+        }
+        this._autoScrollScrollId = null;
+        this._autoScrollPresShellId = null;
+      }
+    }
+  }
 
-              let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-              menulist.menupopup.style.direction = data.direction;
-              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex, this._fullZoom,
-                                                data.uaSelectBackgroundColor, data.uaSelectColor,
-                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
-              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
-              break;
-            }
+  _createAutoScrollPopup() {
+    var popup = document.createXULElement("panel");
+    popup.className = "autoscroller";
+    // We set this attribute on the element so that mousemove
+    // events can be handled by browser-content.js.
+    popup.setAttribute("mousethrough", "always");
+    popup.setAttribute("consumeoutsideclicks", "true");
+    popup.setAttribute("rolluponmousewheel", "true");
+    popup.setAttribute("hidden", "true");
+    return popup;
+  }
 
-            case "Forms:HideDropDown": {
-              if (this._selectParentHelper) {
-                let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-                this._selectParentHelper.hide(menulist, this);
-              }
-              break;
-            }
+  startScroll(scrolldir, screenX, screenY) {
+    const POPUP_SIZE = 32;
+    if (!this._autoScrollPopup) {
+      if (this.hasAttribute("autoscrollpopup")) {
+        // our creator provided a popup to share
+        this._autoScrollPopup = document.getElementById(this.getAttribute("autoscrollpopup"));
+      } else {
+        // we weren't provided a popup; we have to use the global scope
+        this._autoScrollPopup = this._createAutoScrollPopup();
+        document.documentElement.appendChild(this._autoScrollPopup);
+        this._autoScrollNeedsCleanup = true;
+      }
+      this._autoScrollPopup.removeAttribute("hidden");
+      this._autoScrollPopup.setAttribute("noautofocus", "true");
+      this._autoScrollPopup.style.height = POPUP_SIZE + "px";
+      this._autoScrollPopup.style.width = POPUP_SIZE + "px";
+      this._autoScrollPopup.style.margin = -POPUP_SIZE / 2 + "px";
+    }
 
-          }
-          return undefined;
-        ]]></body>
-      </method>
+    let screenManager = Cc["@mozilla.org/gfx/screenmanager;1"]
+      .getService(Ci.nsIScreenManager);
+    let screen = screenManager.screenForRect(screenX, screenY, 1, 1);
+
+    // we need these attributes so themers don't need to create per-platform packages
+    if (screen.colorDepth > 8) { // need high color for transparency
+      // Exclude second-rate platforms
+      this._autoScrollPopup.setAttribute("transparent", !/BeOS|OS\/2/.test(navigator.appVersion));
+      // Enable translucency on Windows and Mac
+      this._autoScrollPopup.setAttribute("translucent", /Win|Mac/.test(navigator.platform));
+    }
 
-      <method name="receiveMessage">
-        <parameter name="aMessage"/>
-        <body><![CDATA[
-          if (!this.isRemoteBrowser) {
-            return this._receiveMessage(aMessage);
-          }
+    this._autoScrollPopup.setAttribute("scrolldir", scrolldir);
+    this._autoScrollPopup.addEventListener("popuphidden", this, true);
+
+    // Sanitize screenX/screenY for available screen size with half the size
+    // of the popup removed. The popup uses negative margins to center on the
+    // coordinates we pass. Unfortunately `window.screen.availLeft` can be negative
+    // on Windows in multi-monitor setups, so we use nsIScreenManager instead:
+    let left = {},
+      top = {},
+      width = {},
+      height = {};
+    screen.GetAvailRect(left, top, width, height);
 
-          let data = aMessage.data;
-          switch (aMessage.name) {
-            case "Browser:Init":
-              this._outerWindowID = data.outerWindowID;
-              this._browsingContextId = data.browsingContextId;
-              break;
-            case "DOMTitleChanged":
-              this._contentTitle = data.title;
-              break;
-            case "ImageDocumentLoaded":
-              this._imageDocument = {
-                width: data.width,
-                height: data.height,
-              };
-              break;
+    // We need to get screen CSS-pixel (rather than display-pixel) coordinates.
+    // With 175% DPI, the actual ratio of display pixels to CSS pixels is
+    // 1.7647 because of rounding inside gecko. Unfortunately defaultCSSScaleFactor
+    // returns the original 1.75 dpi factor. While window.devicePixelRatio would
+    // get us the correct ratio, if the window is split between 2 screens,
+    // window.devicePixelRatio isn't guaranteed to match the screen we're
+    // autoscrolling on. So instead we do the same math as Gecko.
+    const scaleFactor = 60 / Math.round(60 / screen.defaultCSSScaleFactor);
+    let minX = left.value / scaleFactor + 0.5 * POPUP_SIZE;
+    let maxX = (left.value + width.value) / scaleFactor - 0.5 * POPUP_SIZE;
+    let minY = top.value / scaleFactor + 0.5 * POPUP_SIZE;
+    let maxY = (top.value + height.value) / scaleFactor - 0.5 * POPUP_SIZE;
+    let popupX = Math.max(minX, Math.min(maxX, screenX));
+    let popupY = Math.max(minY, Math.min(maxY, screenY));
+    this._autoScrollPopup.openPopupAtScreen(popupX, popupY);
+    this._ignoreMouseEvents = true;
+    this._scrolling = true;
+    this._startX = screenX;
+    this._startY = screenY;
 
-            case "Forms:ShowDropDown": {
-              if (!this._selectParentHelper) {
-                this._selectParentHelper =
-                  ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
-              }
-
-              let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-              menulist.menupopup.style.direction = data.direction;
+    window.addEventListener("mousemove", this, true);
+    window.addEventListener("mousedown", this, true);
+    window.addEventListener("mouseup", this, true);
+    window.addEventListener("DOMMouseScroll", this, true);
+    window.addEventListener("contextmenu", this, true);
+    window.addEventListener("keydown", this, true);
+    window.addEventListener("keypress", this, true);
+    window.addEventListener("keyup", this, true);
+  }
 
-              let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
-                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;
-              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
-                                                zoom,
-                                                data.uaSelectBackgroundColor, data.uaSelectColor,
-                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
-              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
-              break;
-            }
+  handleEvent(aEvent) {
+    if (this._scrolling) {
+      switch (aEvent.type) {
+        case "mousemove":
+          {
+            var x = aEvent.screenX - this._startX;
+            var y = aEvent.screenY - this._startY;
 
-            case "FullZoomChange": {
-              this._fullZoom = data.value;
-              let event = document.createEvent("Events");
-              event.initEvent("FullZoomChange", true, false);
-              this.dispatchEvent(event);
-              break;
+            if ((x > this._AUTOSCROLL_SNAP || x < -this._AUTOSCROLL_SNAP) ||
+              (y > this._AUTOSCROLL_SNAP || y < -this._AUTOSCROLL_SNAP))
+              this._ignoreMouseEvents = false;
+            break;
+          }
+        case "mouseup":
+        case "mousedown":
+        case "contextmenu":
+          {
+            if (!this._ignoreMouseEvents) {
+              // Use a timeout to prevent the mousedown from opening the popup again.
+              // Ideally, we could use preventDefault here, but contenteditable
+              // and middlemouse paste don't interact well. See bug 1188536.
+              setTimeout(() => this._autoScrollPopup.hidePopup(), 0);
             }
-
-            case "TextZoomChange": {
-              this._textZoom = data.value;
-              let event = document.createEvent("Events");
-              event.initEvent("TextZoomChange", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            case "ZoomChangeUsingMouseWheel": {
-              let event = document.createEvent("Events");
-              event.initEvent("ZoomChangeUsingMouseWheel", true, false);
-              this.dispatchEvent(event);
+            this._ignoreMouseEvents = false;
+            break;
+          }
+        case "DOMMouseScroll":
+          {
+            this._autoScrollPopup.hidePopup();
+            aEvent.preventDefault();
+            break;
+          }
+        case "popuphidden":
+          {
+            this._autoScrollPopup.removeEventListener("popuphidden", this, true);
+            this.stopScroll();
+            break;
+          }
+        case "keydown":
+          {
+            if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE) {
+              // the escape key will be processed by
+              // nsXULPopupManager::KeyDown and the panel will be closed.
+              // So, don't consume the key event here.
               break;
             }
-
-            default:
-              return this._receiveMessage(aMessage);
-          }
-          return undefined;
-
-        ]]></body>
-      </method>
-
-      <method name="enableDisableCommandsRemoteOnly">
-        <parameter name="aAction"/>
-        <parameter name="aEnabledLength"/>
-        <parameter name="aEnabledCommands"/>
-        <parameter name="aDisabledLength"/>
-        <parameter name="aDisabledCommands"/>
-        <body>
-          <![CDATA[
-          if (this._controller) {
-            this._controller.enableDisableCommands(aAction,
-                                                   aEnabledLength, aEnabledCommands,
-                                                   aDisabledLength, aDisabledCommands);
+            // don't break here. we need to eat keydown events.
           }
-          ]]>
-        </body>
-      </method>
-
-      <method name="observe">
-        <parameter name="aSubject"/>
-        <parameter name="aTopic"/>
-        <parameter name="aState"/>
-        <body>
-          <![CDATA[
-            if (aTopic == "browser:purge-session-history") {
-              this.purgeSessionHistory();
-            } else if (aTopic == "apz:cancel-autoscroll") {
-              if (aState == this._autoScrollScrollId) {
-                // Set this._autoScrollScrollId to null, so in stopScroll() we
-                // don't call stopApzAutoscroll() (since it's APZ that
-                // initiated the stopping).
-                this._autoScrollScrollId = null;
-                this._autoScrollPresShellId = null;
-
-                this._autoScrollPopup.hidePopup();
-              }
-            }
-          ]]>
-        </body>
-      </method>
-
-      <method name="purgeSessionHistory">
-        <body>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              try {
-                this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
-              } catch (ex) {
-                // This can throw if the browser has started to go away.
-                if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
-                  throw ex;
-                }
-              }
-              this._remoteWebNavigationImpl.canGoBack = false;
-              this._remoteWebNavigationImpl.canGoForward = false;
-              return;
-            }
-            this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
-          ]]>
-        </body>
-      </method>
+        case "keypress":
+        case "keyup":
+          {
+            // All keyevents should be eaten here during autoscrolling.
+            aEvent.stopPropagation();
+            aEvent.preventDefault();
+            break;
+          }
+      }
+    }
+  }
 
-      <method name="createAboutBlankContentViewer">
-        <parameter name="aPrincipal"/>
-        <body>
-          <![CDATA[
-            if (this.isRemoteBrowser) {
-              // Ensure that the content process has the permissions which are
-              // needed to create a document with the given principal.
-              let permissionPrincipal =
-                BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
-              this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
+  closeBrowser() {
+    // The request comes from a XPCOM component, we'd want to redirect
+    // the request to tabbrowser.
+    let tabbrowser = this.getTabBrowser();
+    if (tabbrowser) {
+      let tab = tabbrowser.getTabForBrowser(this);
+      if (tab) {
+        tabbrowser.removeTab(tab);
+        return;
+      }
+    }
 
-              // Create the about blank content viewer in the content process
-              this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
-              return;
-            }
-            let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
-            this.docShell.createAboutBlankContentViewer(principal);
-          ]]>
-        </body>
-      </method>
-
-      <field name="_AUTOSCROLL_SNAP">10</field>
-      <field name="_scrolling">false</field>
-      <field name="_startX">null</field>
-      <field name="_startY">null</field>
-      <field name="_autoScrollPopup">null</field>
-      <field name="_autoScrollNeedsCleanup">false</field>
-      <!-- These IDs identify the scroll frame being autoscrolled. -->
-      <field name="_autoScrollScrollId">null</field>
-      <field name="_autoScrollPresShellId">null</field>
+    throw new Error("Closing a browser which was not attached to a tabbrowser is unsupported.");
+  }
 
-      <method name="stopScroll">
-        <body>
-          <![CDATA[
-            if (this._scrolling) {
-              this._scrolling = false;
-              window.removeEventListener("mousemove", this, true);
-              window.removeEventListener("mousedown", this, true);
-              window.removeEventListener("mouseup", this, true);
-              window.removeEventListener("DOMMouseScroll", this, true);
-              window.removeEventListener("contextmenu", this, true);
-              window.removeEventListener("keydown", this, true);
-              window.removeEventListener("keypress", this, true);
-              window.removeEventListener("keyup", this, true);
-              this.messageManager.sendAsyncMessage("Autoscroll:Stop");
-
-              var os = Cc["@mozilla.org/observer-service;1"]
-                         .getService(Ci.nsIObserverService);
-              try {
-                os.removeObserver(this, "apz:cancel-autoscroll");
-              } catch (ex) {
-                // It's not clear why this sometimes throws an exception
-              }
+  swapBrowsers(aOtherBrowser, aFlags) {
+    // The request comes from a XPCOM component, we'd want to redirect
+    // the request to tabbrowser so tabbrowser will be setup correctly,
+    // and it will eventually call swapDocShells.
+    let ourTabBrowser = this.getTabBrowser();
+    let otherTabBrowser = aOtherBrowser.getTabBrowser();
+    if (ourTabBrowser && otherTabBrowser) {
+      let ourTab = ourTabBrowser.getTabForBrowser(this);
+      let otherTab = otherTabBrowser.getTabForBrowser(aOtherBrowser);
+      ourTabBrowser.swapBrowsers(ourTab, otherTab, aFlags);
+      return;
+    }
 
-              if (this.isRemoteBrowser && this._autoScrollScrollId != null) {
-                let { tabParent } = this.frameLoader;
-                if (tabParent) {
-                  tabParent.stopApzAutoscroll(this._autoScrollScrollId,
-                                              this._autoScrollPresShellId);
-                }
-                this._autoScrollScrollId = null;
-                this._autoScrollPresShellId = null;
-              }
-            }
-         ]]>
-       </body>
-     </method>
+    // One of us is not connected to a tabbrowser, so just swap.
+    this.swapDocShells(aOtherBrowser);
+  }
 
-      <method name="_createAutoScrollPopup">
-        <body>
-          <![CDATA[
-            var popup = document.createXULElement("panel");
-            popup.className = "autoscroller";
-            // We set this attribute on the element so that mousemove
-            // events can be handled by browser-content.js.
-            popup.setAttribute("mousethrough", "always");
-            popup.setAttribute("consumeoutsideclicks", "true");
-            popup.setAttribute("rolluponmousewheel", "true");
-            popup.setAttribute("hidden", "true");
-            return popup;
-          ]]>
-        </body>
-      </method>
+  swapDocShells(aOtherBrowser) {
+    if (this.isRemoteBrowser != aOtherBrowser.isRemoteBrowser)
+      throw new Error("Can only swap docshells between browsers in the same process.");
 
-      <method name="startScroll">
-        <parameter name="scrolldir"/>
-        <parameter name="screenX"/>
-        <parameter name="screenY"/>
-        <body><![CDATA[
-            const POPUP_SIZE = 32;
-            if (!this._autoScrollPopup) {
-              if (this.hasAttribute("autoscrollpopup")) {
-                // our creator provided a popup to share
-                this._autoScrollPopup = document.getElementById(this.getAttribute("autoscrollpopup"));
-              } else {
-                // we weren't provided a popup; we have to use the global scope
-                this._autoScrollPopup = this._createAutoScrollPopup();
-                document.documentElement.appendChild(this._autoScrollPopup);
-                this._autoScrollNeedsCleanup = true;
-              }
-              this._autoScrollPopup.removeAttribute("hidden");
-              this._autoScrollPopup.setAttribute("noautofocus", "true");
-              this._autoScrollPopup.style.height = POPUP_SIZE + "px";
-              this._autoScrollPopup.style.width = POPUP_SIZE + "px";
-              this._autoScrollPopup.style.margin = -POPUP_SIZE / 2 + "px";
-            }
-
-            let screenManager = Cc["@mozilla.org/gfx/screenmanager;1"]
-              .getService(Ci.nsIScreenManager);
-            let screen = screenManager.screenForRect(screenX, screenY, 1, 1);
-
-            // we need these attributes so themers don't need to create per-platform packages
-            if (screen.colorDepth > 8) { // need high color for transparency
-              // Exclude second-rate platforms
-              this._autoScrollPopup.setAttribute("transparent", !/BeOS|OS\/2/.test(navigator.appVersion));
-              // Enable translucency on Windows and Mac
-              this._autoScrollPopup.setAttribute("translucent", /Win|Mac/.test(navigator.platform));
-            }
-
-            this._autoScrollPopup.setAttribute("scrolldir", scrolldir);
-            this._autoScrollPopup.addEventListener("popuphidden", this, true);
-
-            // Sanitize screenX/screenY for available screen size with half the size
-            // of the popup removed. The popup uses negative margins to center on the
-            // coordinates we pass. Unfortunately `window.screen.availLeft` can be negative
-            // on Windows in multi-monitor setups, so we use nsIScreenManager instead:
-            let left = {}, top = {}, width = {}, height = {};
-            screen.GetAvailRect(left, top, width, height);
-
-            // We need to get screen CSS-pixel (rather than display-pixel) coordinates.
-            // With 175% DPI, the actual ratio of display pixels to CSS pixels is
-            // 1.7647 because of rounding inside gecko. Unfortunately defaultCSSScaleFactor
-            // returns the original 1.75 dpi factor. While window.devicePixelRatio would
-            // get us the correct ratio, if the window is split between 2 screens,
-            // window.devicePixelRatio isn't guaranteed to match the screen we're
-            // autoscrolling on. So instead we do the same math as Gecko.
-            const scaleFactor = 60 / Math.round(60 / screen.defaultCSSScaleFactor);
-            let minX = left.value / scaleFactor + 0.5 * POPUP_SIZE;
-            let maxX = (left.value + width.value) / scaleFactor - 0.5 * POPUP_SIZE;
-            let minY = top.value / scaleFactor + 0.5 * POPUP_SIZE;
-            let maxY = (top.value + height.value) / scaleFactor - 0.5 * POPUP_SIZE;
-            let popupX = Math.max(minX, Math.min(maxX, screenX));
-            let popupY = Math.max(minY, Math.min(maxY, screenY));
-            this._autoScrollPopup.openPopupAtScreen(popupX, popupY);
-            this._ignoreMouseEvents = true;
-            this._scrolling = true;
-            this._startX = screenX;
-            this._startY = screenY;
-
-            window.addEventListener("mousemove", this, true);
-            window.addEventListener("mousedown", this, true);
-            window.addEventListener("mouseup", this, true);
-            window.addEventListener("DOMMouseScroll", this, true);
-            window.addEventListener("contextmenu", this, true);
-            window.addEventListener("keydown", this, true);
-            window.addEventListener("keypress", this, true);
-            window.addEventListener("keyup", this, true);
-         ]]>
-        </body>
-      </method>
-
-      <method name="handleEvent">
-        <parameter name="aEvent"/>
-        <body>
-        <![CDATA[
-          if (this._scrolling) {
-            switch (aEvent.type) {
-              case "mousemove": {
-                var x = aEvent.screenX - this._startX;
-                var y = aEvent.screenY - this._startY;
+    // Give others a chance to swap state.
+    // IMPORTANT: Since a swapDocShells call does not swap the messageManager
+    //            instances attached to a browser to aOtherBrowser, others
+    //            will need to add the message listeners to the new
+    //            messageManager.
+    //            This is not a bug in swapDocShells or the FrameLoader,
+    //            merely a design decision: If message managers were swapped,
+    //            so that no new listeners were needed, the new
+    //            aOtherBrowser.messageManager would have listeners pointing
+    //            to the JS global of the current browser, which would rather
+    //            easily create leaks while swapping.
+    // IMPORTANT2: When the current browser element is removed from DOM,
+    //             which is quite common after a swpDocShells call, its
+    //             frame loader is destroyed, and that destroys the relevant
+    //             message manager, which will remove the listeners.
+    let event = new CustomEvent("SwapDocShells", { "detail": aOtherBrowser });
+    this.dispatchEvent(event);
+    event = new CustomEvent("SwapDocShells", { "detail": this });
+    aOtherBrowser.dispatchEvent(event);
 
-                if ((x > this._AUTOSCROLL_SNAP || x < -this._AUTOSCROLL_SNAP) ||
-                    (y > this._AUTOSCROLL_SNAP || y < -this._AUTOSCROLL_SNAP))
-                  this._ignoreMouseEvents = false;
-                break;
-              }
-              case "mouseup":
-              case "mousedown":
-              case "contextmenu": {
-                if (!this._ignoreMouseEvents) {
-                  // Use a timeout to prevent the mousedown from opening the popup again.
-                  // Ideally, we could use preventDefault here, but contenteditable
-                  // and middlemouse paste don't interact well. See bug 1188536.
-                  setTimeout(() => this._autoScrollPopup.hidePopup(), 0);
-                }
-                this._ignoreMouseEvents = false;
-                break;
-              }
-              case "DOMMouseScroll": {
-                this._autoScrollPopup.hidePopup();
-                aEvent.preventDefault();
-                break;
-              }
-              case "popuphidden": {
-                this._autoScrollPopup.removeEventListener("popuphidden", this, true);
-                this.stopScroll();
-                break;
-              }
-              case "keydown": {
-                if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE) {
-                  // the escape key will be processed by
-                  // nsXULPopupManager::KeyDown and the panel will be closed.
-                  // So, don't consume the key event here.
-                  break;
-                }
-                // don't break here. we need to eat keydown events.
-              }
-              case "keypress":
-              case "keyup": {
-                // All keyevents should be eaten here during autoscrolling.
-                aEvent.stopPropagation();
-                aEvent.preventDefault();
-                break;
-              }
-            }
-          }
-        ]]>
-        </body>
-      </method>
+    // We need to swap fields that are tied to our docshell or related to
+    // the loaded page
+    // Fields which are built as a result of notifactions (pageshow/hide,
+    // DOMLinkAdded/Removed, onStateChange) should not be swapped here,
+    // because these notifications are dispatched again once the docshells
+    // are swapped.
+    var fieldsToSwap = [
+      "_webBrowserFind",
+    ];
 
-      <method name="closeBrowser">
-        <body>
-        <![CDATA[
-          // The request comes from a XPCOM component, we'd want to redirect
-          // the request to tabbrowser.
-          let tabbrowser = this.getTabBrowser();
-          if (tabbrowser) {
-            let tab = tabbrowser.getTabForBrowser(this);
-            if (tab) {
-              tabbrowser.removeTab(tab);
-              return;
-            }
-          }
-
-          throw new Error("Closing a browser which was not attached to a tabbrowser is unsupported.");
-        ]]>
-        </body>
-      </method>
+    if (this.isRemoteBrowser) {
+      fieldsToSwap.push(...[
+        "_remoteWebNavigation",
+        "_remoteWebNavigationImpl",
+        "_remoteWebProgressManager",
+        "_remoteWebProgress",
+        "_remoteFinder",
+        "_securityUI",
+        "_documentURI",
+        "_documentContentType",
+        "_contentTitle",
+        "_characterSet",
+        "_mayEnableCharacterEncodingMenu",
+        "_contentPrincipal",
+        "_imageDocument",
+        "_fullZoom",
+        "_textZoom",
+        "_isSyntheticDocument",
+        "_innerWindowID",
+      ]);
+    }
 
-      <method name="swapBrowsers">
-        <parameter name="aOtherBrowser"/>
-        <parameter name="aFlags"/>
-        <body>
-        <![CDATA[
-          // The request comes from a XPCOM component, we'd want to redirect
-          // the request to tabbrowser so tabbrowser will be setup correctly,
-          // and it will eventually call swapDocShells.
-          let ourTabBrowser = this.getTabBrowser();
-          let otherTabBrowser = aOtherBrowser.getTabBrowser();
-          if (ourTabBrowser && otherTabBrowser) {
-            let ourTab = ourTabBrowser.getTabForBrowser(this);
-            let otherTab = otherTabBrowser.getTabForBrowser(aOtherBrowser);
-            ourTabBrowser.swapBrowsers(ourTab, otherTab, aFlags);
-            return;
-          }
-
-          // One of us is not connected to a tabbrowser, so just swap.
-          this.swapDocShells(aOtherBrowser);
-        ]]>
-        </body>
-      </method>
-
-      <method name="swapDocShells">
-        <parameter name="aOtherBrowser"/>
-        <body>
-        <![CDATA[
-          if (this.isRemoteBrowser != aOtherBrowser.isRemoteBrowser)
-            throw new Error("Can only swap docshells between browsers in the same process.");
+    var ourFieldValues = {};
+    var otherFieldValues = {};
+    for (let field of fieldsToSwap) {
+      ourFieldValues[field] = this[field];
+      otherFieldValues[field] = aOtherBrowser[field];
+    }
 
-          // Give others a chance to swap state.
-          // IMPORTANT: Since a swapDocShells call does not swap the messageManager
-          //            instances attached to a browser to aOtherBrowser, others
-          //            will need to add the message listeners to the new
-          //            messageManager.
-          //            This is not a bug in swapDocShells or the FrameLoader,
-          //            merely a design decision: If message managers were swapped,
-          //            so that no new listeners were needed, the new
-          //            aOtherBrowser.messageManager would have listeners pointing
-          //            to the JS global of the current browser, which would rather
-          //            easily create leaks while swapping.
-          // IMPORTANT2: When the current browser element is removed from DOM,
-          //             which is quite common after a swpDocShells call, its
-          //             frame loader is destroyed, and that destroys the relevant
-          //             message manager, which will remove the listeners.
-          let event = new CustomEvent("SwapDocShells", {"detail": aOtherBrowser});
-          this.dispatchEvent(event);
-          event = new CustomEvent("SwapDocShells", {"detail": this});
-          aOtherBrowser.dispatchEvent(event);
+    if (window.PopupNotifications)
+      PopupNotifications._swapBrowserNotifications(aOtherBrowser, this);
 
-          // We need to swap fields that are tied to our docshell or related to
-          // the loaded page
-          // Fields which are built as a result of notifactions (pageshow/hide,
-          // DOMLinkAdded/Removed, onStateChange) should not be swapped here,
-          // because these notifications are dispatched again once the docshells
-          // are swapped.
-          var fieldsToSwap = [
-            "_webBrowserFind",
-          ];
+    try {
+      this.swapFrameLoaders(aOtherBrowser);
+    } catch (ex) {
+      // This may not be implemented for browser elements that are not
+      // attached to a BrowserDOMWindow.
+    }
 
-          if (this.isRemoteBrowser) {
-            fieldsToSwap.push(...[
-              "_remoteWebNavigation",
-              "_remoteWebNavigationImpl",
-              "_remoteWebProgressManager",
-              "_remoteWebProgress",
-              "_remoteFinder",
-              "_securityUI",
-              "_documentURI",
-              "_documentContentType",
-              "_contentTitle",
-              "_characterSet",
-              "_mayEnableCharacterEncodingMenu",
-              "_contentPrincipal",
-              "_imageDocument",
-              "_fullZoom",
-              "_textZoom",
-              "_isSyntheticDocument",
-              "_innerWindowID",
-            ]);
-          }
+    for (let field of fieldsToSwap) {
+      this[field] = otherFieldValues[field];
+      aOtherBrowser[field] = ourFieldValues[field];
+    }
 
-          var ourFieldValues = {};
-          var otherFieldValues = {};
-          for (let field of fieldsToSwap) {
-            ourFieldValues[field] = this[field];
-            otherFieldValues[field] = aOtherBrowser[field];
-          }
-
-          if (window.PopupNotifications)
-            PopupNotifications._swapBrowserNotifications(aOtherBrowser, this);
-
-          try {
-            this.swapFrameLoaders(aOtherBrowser);
-          } catch (ex) {
-            // This may not be implemented for browser elements that are not
-            // attached to a BrowserDOMWindow.
-          }
-
-          for (let field of fieldsToSwap) {
-            this[field] = otherFieldValues[field];
-            aOtherBrowser[field] = ourFieldValues[field];
-          }
-
-          if (!this.isRemoteBrowser) {
-            // Null the current nsITypeAheadFind instances so that they're
-            // lazily re-created on access. We need to do this because they
-            // might have attached the wrong docShell.
-            this._fastFind = aOtherBrowser._fastFind = null;
-          } else {
-            // Rewire the remote listeners
-            this._remoteWebNavigationImpl.swapBrowser(this);
-            aOtherBrowser._remoteWebNavigationImpl.swapBrowser(aOtherBrowser);
+    if (!this.isRemoteBrowser) {
+      // Null the current nsITypeAheadFind instances so that they're
+      // lazily re-created on access. We need to do this because they
+      // might have attached the wrong docShell.
+      this._fastFind = aOtherBrowser._fastFind = null;
+    } else {
+      // Rewire the remote listeners
+      this._remoteWebNavigationImpl.swapBrowser(this);
+      aOtherBrowser._remoteWebNavigationImpl.swapBrowser(aOtherBrowser);
 
-            if (this._remoteWebProgressManager && aOtherBrowser._remoteWebProgressManager) {
-              this._remoteWebProgressManager.swapBrowser(this);
-              aOtherBrowser._remoteWebProgressManager.swapBrowser(aOtherBrowser);
-            }
-
-            if (this._remoteFinder)
-              this._remoteFinder.swapBrowser(this);
-            if (aOtherBrowser._remoteFinder)
-              aOtherBrowser._remoteFinder.swapBrowser(aOtherBrowser);
-          }
+      if (this._remoteWebProgressManager && aOtherBrowser._remoteWebProgressManager) {
+        this._remoteWebProgressManager.swapBrowser(this);
+        aOtherBrowser._remoteWebProgressManager.swapBrowser(aOtherBrowser);
+      }
 
-          event = new CustomEvent("EndSwapDocShells", {"detail": aOtherBrowser});
-          this.dispatchEvent(event);
-          event = new CustomEvent("EndSwapDocShells", {"detail": this});
-          aOtherBrowser.dispatchEvent(event);
-        ]]>
-        </body>
-      </method>
-
-      <field name="_permitUnloadId">0</field>
-      <method name="getInPermitUnload">
-        <parameter name="aCallback"/>
-        <body>
-        <![CDATA[
-          if (this.isRemoteBrowser) {
-            let id = this._permitUnloadId++;
-            let mm = this.messageManager;
-            mm.sendAsyncMessage("InPermitUnload", {id});
-            mm.addMessageListener("InPermitUnload", function listener(msg) {
-              if (msg.data.id != id) {
-                return;
-              }
-              aCallback(msg.data.inPermitUnload);
-            });
-            return;
-          }
+      if (this._remoteFinder)
+        this._remoteFinder.swapBrowser(this);
+      if (aOtherBrowser._remoteFinder)
+        aOtherBrowser._remoteFinder.swapBrowser(aOtherBrowser);
+    }
 
-          if (!this.docShell || !this.docShell.contentViewer) {
-            aCallback(false);
-            return;
-          }
-          aCallback(this.docShell.contentViewer.inPermitUnload);
-        ]]>
-        </body>
-      </method>
-
-      <property name="dontPromptAndDontUnload"
-                onget="return 1;"
-                readonly="true"/>
-
-      <property name="dontPromptAndUnload"
-                onget="return 2;"
-                readonly="true"/>
-
-      <method name="permitUnload">
-        <parameter name="aPermitUnloadFlags"/>
-        <body>
-        <![CDATA[
-          if (this.isRemoteBrowser) {
-            let {tabParent} = this.frameLoader;
+    event = new CustomEvent("EndSwapDocShells", { "detail": aOtherBrowser });
+    this.dispatchEvent(event);
+    event = new CustomEvent("EndSwapDocShells", { "detail": this });
+    aOtherBrowser.dispatchEvent(event);
+  }
 
-            if (!tabParent.hasBeforeUnload) {
-              return { permitUnload: true, timedOut: false };
-            }
-
-            const kTimeout = 1000;
-
-            let finished = false;
-            let responded = false;
-            let permitUnload;
-            let id = this._permitUnloadId++;
-            let mm = this.messageManager;
-            let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-
-            let msgListener = msg => {
-              if (msg.data.id != id) {
-                return;
-              }
-              if (msg.data.kind == "start") {
-                responded = true;
-                return;
-              }
-              done(msg.data.permitUnload);
-            };
-
-            let observer = subject => {
-              if (subject == mm) {
-                done(true);
-              }
-            };
+  getInPermitUnload(aCallback) {
+    if (this.isRemoteBrowser) {
+      let id = this._permitUnloadId++;
+      let mm = this.messageManager;
+      mm.sendAsyncMessage("InPermitUnload", { id });
+      mm.addMessageListener("InPermitUnload", function listener(msg) {
+        if (msg.data.id != id) {
+          return;
+        }
+        aCallback(msg.data.inPermitUnload);
+      });
+      return;
+    }
 
-            function done(result) {
-              finished = true;
-              permitUnload = result;
-              mm.removeMessageListener("PermitUnload", msgListener);
-              Services.obs.removeObserver(observer, "message-manager-close");
-            }
-
-            mm.sendAsyncMessage("PermitUnload", {id, aPermitUnloadFlags});
-            mm.addMessageListener("PermitUnload", msgListener);
-            Services.obs.addObserver(observer, "message-manager-close");
+    if (!this.docShell || !this.docShell.contentViewer) {
+      aCallback(false);
+      return;
+    }
+    aCallback(this.docShell.contentViewer.inPermitUnload);
+  }
 
-            let timedOut = false;
-            function timeout() {
-              if (!responded) {
-                timedOut = true;
-              }
-
-              // Dispatch something to ensure that the main thread wakes up.
-              Services.tm.dispatchToMainThread(function() {});
-            }
-
-            let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-            timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
-
-            while (!finished && !timedOut) {
-              Services.tm.currentThread.processNextEvent(true);
-            }
-
-            return {permitUnload, timedOut};
-          }
+  permitUnload(aPermitUnloadFlags) {
+    if (this.isRemoteBrowser) {
+      let { tabParent } = this.frameLoader;
 
-          if (!this.docShell || !this.docShell.contentViewer) {
-            return {permitUnload: true, timedOut: false};
-          }
-          return {permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),
-                  timedOut: false};
-        ]]>
-        </body>
-      </method>
+      if (!tabParent.hasBeforeUnload) {
+        return { permitUnload: true, timedOut: false };
+      }
 
-      <method name="print">
-        <parameter name="aOuterWindowID"/>
-        <parameter name="aPrintSettings"/>
-        <parameter name="aPrintProgressListener"/>
-        <body>
-          <![CDATA[
-            if (!this.frameLoader) {
-              throw Components.Exception("No frame loader.",
-                                         Cr.NS_ERROR_FAILURE);
-            }
+      const kTimeout = 1000;
 
-            this.frameLoader.print(aOuterWindowID, aPrintSettings,
-                                   aPrintProgressListener);
-          ]]>
-        </body>
-      </method>
-
-      <method name="drawSnapshot">
-        <parameter name="x"/>
-        <parameter name="y"/>
-        <parameter name="w"/>
-        <parameter name="h"/>
-        <parameter name="scale"/>
-        <parameter name="backgroundColor"/>
-        <body>
-          <![CDATA[
-            if (!this.frameLoader) {
-              throw Components.Exception("No frame loader.",
-                                         Cr.NS_ERROR_FAILURE);
-            }
-            return this.frameLoader.drawSnapshot(x, y, w, h, scale, backgroundColor);
-          ]]>
-        </body>
-      </method>
+      let finished = false;
+      let responded = false;
+      let permitUnload;
+      let id = this._permitUnloadId++;
+      let mm = this.messageManager;
+      let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
 
-      <method name="dropLinks">
-        <parameter name="aLinksCount"/>
-        <parameter name="aLinks"/>
-        <parameter name="aTriggeringPrincipal"/>
-        <body><![CDATA[
-          if (!this.droppedLinkHandler) {
-            return false;
-          }
-          let links = [];
-          for (let i = 0; i < aLinksCount; i += 3) {
-            links.push({
-              url: aLinks[i],
-              name: aLinks[i + 1],
-              type: aLinks[i + 2],
-            });
-          }
-          this.droppedLinkHandler(null, links, aTriggeringPrincipal);
-          return true;
-        ]]></body>
-      </method>
+      let msgListener = msg => {
+        if (msg.data.id != id) {
+          return;
+        }
+        if (msg.data.kind == "start") {
+          responded = true;
+          return;
+        }
+        done(msg.data.permitUnload);
+      };
 
-      <method name="getContentBlockingLog">
-        <body><![CDATA[
-          if (this.isRemoteBrowser) {
-            return this.frameLoader.tabParent.getContentBlockingLog();
-          }
-          return this.docShell ?
-                   this.docShell.getContentBlockingLog() :
-                   Promise.reject("docshell isn't available");
-        ]]></body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <handler event="keypress" keycode="VK_F7" group="system">
-        <![CDATA[
-          if (event.defaultPrevented || !event.isTrusted)
-            return;
-
-          const kPrefShortcutEnabled = "accessibility.browsewithcaret_shortcut.enabled";
-          const kPrefWarnOnEnable    = "accessibility.warn_on_browsewithcaret";
-          const kPrefCaretBrowsingOn = "accessibility.browsewithcaret";
-
-          var isEnabled = this.mPrefs.getBoolPref(kPrefShortcutEnabled);
-          if (!isEnabled)
-            return;
+      let observer = subject => {
+        if (subject == mm) {
+          done(true);
+        }
+      };
 
-          // Toggle browse with caret mode
-          var browseWithCaretOn = this.mPrefs.getBoolPref(kPrefCaretBrowsingOn, false);
-          var warn = this.mPrefs.getBoolPref(kPrefWarnOnEnable, true);
-          if (warn && !browseWithCaretOn) {
-            var checkValue = {value: false};
-            var promptService = Cc["@mozilla.org/embedcomp/prompt-service;1"]
-                                  .getService(Ci.nsIPromptService);
+      function done(result) {
+        finished = true;
+        permitUnload = result;
+        mm.removeMessageListener("PermitUnload", msgListener);
+        Services.obs.removeObserver(observer, "message-manager-close");
+      }
 
-            var buttonPressed = promptService.confirmEx(window,
-              this.mStrBundle.GetStringFromName("browsewithcaret.checkWindowTitle"),
-              this.mStrBundle.GetStringFromName("browsewithcaret.checkLabel"),
-              // Make "No" the default:
-              promptService.STD_YES_NO_BUTTONS | promptService.BUTTON_POS_1_DEFAULT,
-              null, null, null, this.mStrBundle.GetStringFromName("browsewithcaret.checkMsg"),
-              checkValue);
-            if (buttonPressed != 0) {
-              if (checkValue.value) {
-                try {
-                  this.mPrefs.setBoolPref(kPrefShortcutEnabled, false);
-                } catch (ex) {
-                }
-              }
-              return;
-            }
-            if (checkValue.value) {
-              try {
-                this.mPrefs.setBoolPref(kPrefWarnOnEnable, false);
-              } catch (ex) {
-              }
-            }
-          }
+      mm.sendAsyncMessage("PermitUnload", { id, aPermitUnloadFlags });
+      mm.addMessageListener("PermitUnload", msgListener);
+      Services.obs.addObserver(observer, "message-manager-close");
 
-          // Toggle the pref
-          try {
-            this.mPrefs.setBoolPref(kPrefCaretBrowsingOn, !browseWithCaretOn);
-          } catch (ex) {
-          }
-        ]]>
-      </handler>
-      <handler event="dragover" group="system">
-      <![CDATA[
-        if (!this.droppedLinkHandler || event.defaultPrevented)
-          return;
+      let timedOut = false;
 
-        // For drags that appear to be internal text (for example, tab drags),
-        // set the dropEffect to 'none'. This prevents the drop even if some
-        // other listener cancelled the event.
-        var types = event.dataTransfer.types;
-        if (types.includes("text/x-moz-text-internal") && !types.includes("text/plain")) {
-          event.dataTransfer.dropEffect = "none";
-          event.stopPropagation();
-          event.preventDefault();
+      function timeout() {
+        if (!responded) {
+          timedOut = true;
         }
 
-        // No need to handle "dragover" in e10s, since nsDocShellTreeOwner.cpp in the child process
-        // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
-        if (this.isRemoteBrowser)
-          return;
+        // Dispatch something to ensure that the main thread wakes up.
+        Services.tm.dispatchToMainThread(function() {});
+      }
+
+      let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+      timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
+
+      while (!finished && !timedOut) {
+        Services.tm.currentThread.processNextEvent(true);
+      }
+
+      return { permitUnload, timedOut };
+    }
 
-        let linkHandler = Cc["@mozilla.org/content/dropped-link-handler;1"].
-                            getService(Ci.nsIDroppedLinkHandler);
-        if (linkHandler.canDropLink(event, false))
-          event.preventDefault();
-      ]]>
-      </handler>
-      <handler event="drop" group="system">
-      <![CDATA[
-        // No need to handle "drop" in e10s, since nsDocShellTreeOwner.cpp in the child process
-        // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
-        if (!this.droppedLinkHandler || event.defaultPrevented || this.isRemoteBrowser)
-          return;
+    if (!this.docShell || !this.docShell.contentViewer) {
+      return { permitUnload: true, timedOut: false };
+    }
+    return {
+      permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),
+      timedOut: false,
+    };
+  }
+
+  print(aOuterWindowID, aPrintSettings, aPrintProgressListener) {
+    if (!this.frameLoader) {
+      throw Components.Exception("No frame loader.",
+        Cr.NS_ERROR_FAILURE);
+    }
+
+    this.frameLoader.print(aOuterWindowID, aPrintSettings,
+      aPrintProgressListener);
+  }
 
-        let linkHandler = Cc["@mozilla.org/content/dropped-link-handler;1"].
-                            getService(Ci.nsIDroppedLinkHandler);
-        try {
-          // Pass true to prevent the dropping of javascript:/data: URIs
-          var links = linkHandler.dropLinks(event, true);
-        } catch (ex) {
-          return;
-        }
+  drawSnapshot(x, y, w, h, scale, backgroundColor) {
+    if (!this.frameLoader) {
+      throw Components.Exception("No frame loader.",
+        Cr.NS_ERROR_FAILURE);
+    }
+    return this.frameLoader.drawSnapshot(x, y, w, h, scale, backgroundColor);
+  }
 
-        if (links.length) {
-          let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
-          this.droppedLinkHandler(event, links, triggeringPrincipal);
-        }
-      ]]>
-      </handler>
-      <handler event="dragstart">
-      <![CDATA[
-        // If we're a remote browser dealing with a dragstart, stop it
-        // from propagating up, since our content process should be dealing
-        // with the mouse movement.
-        if (this.isRemoteBrowser) {
-          event.stopPropagation();
-        }
-      ]]>
-      </handler>
-    </handlers>
+  dropLinks(aLinksCount, aLinks, aTriggeringPrincipal) {
+    if (!this.droppedLinkHandler) {
+      return false;
+    }
+    let links = [];
+    for (let i = 0; i < aLinksCount; i += 3) {
+      links.push({
+        url: aLinks[i],
+        name: aLinks[i + 1],
+        type: aLinks[i + 2],
+      });
+    }
+    this.droppedLinkHandler(null, links, aTriggeringPrincipal);
+    return true;
+  }
 
-  </binding>
+  getContentBlockingLog() {
+    if (this.isRemoteBrowser) {
+      return this.frameLoader.tabParent.getContentBlockingLog();
+    }
+    return this.docShell ?
+      this.docShell.getContentBlockingLog() :
+      Promise.reject("docshell isn't available");
+  }
+  disconnectedCallback() {
+    this.destroy();
+  }
+}
 
-</bindings>
+MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIBrowser, Ci.nsIFrameLoaderOwner]);
+customElements.define("browser", MozBrowser);
+
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -167,20 +167,16 @@ iframe {
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   browser,
   editor,
   iframe {
     display: block;
   }
 }
 
-browser {
-  -moz-binding: url("chrome://global/content/bindings/browser.xml#browser");
-}
-
 /*********** popup notification ************/
 popupnotification {
   -moz-binding: url("chrome://global/content/bindings/notification.xml#popup-notification");
 }
 
 .popup-notification-menubutton:not([label]) {
   display: none;
 }
