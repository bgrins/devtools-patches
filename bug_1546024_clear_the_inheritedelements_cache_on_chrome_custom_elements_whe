# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1555886096 25200
#      Sun Apr 21 15:34:56 2019 -0700
# Node ID 001ede888bdda0926ce84a0ce580bbace22f7866
# Parent  5b2a282f73d3a6dfef9094f7f64eb72d0f227e13
Bug 1546024 - Clear the _inheritedElements cache on chrome custom elements when re-calling initializeAttributeInheritance

Otherwise we can end  up setting the proper attribute on removed children when elements get disconnected
and reconnected.

Differential Revision: https://phabricator.services.mozilla.com/D28306

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -306,16 +306,19 @@ MozElements.MozElementMixin = Base => {
   *
   */
   initializeAttributeInheritance() {
     let {flippedInheritedAttributes} = this.constructor;
     if (!flippedInheritedAttributes) {
       return;
     }
 
+    // Clear out any existing cached elements:
+    this._inheritedElements = null;
+
     this.initializedAttributeInheritance = true;
     for (let attr in flippedInheritedAttributes) {
       if (this.hasAttribute(attr)) {
         this.inheritAttribute(flippedInheritedAttributes[attr], attr);
       }
     }
   }
 
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -128,16 +128,17 @@
       static get inheritedAttributes() {
         return {
           "label": "text=label,foo,empty-string,bardo=bar",
           "unmatched": "foo", // Make sure we don't throw on unmatched selectors
         };
       }
 
       connectedCallback() {
+        this.textContent = "";
         this.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.querySelector("label");
         this.initializeAttributeInheritance();
       }
     }
     customElements.define("inherited-element-declarative", InheritsElementDeclarative);
     let declarativeEl = document.querySelector("inherited-element-declarative");
     ok(declarativeEl, "declarative inheritance element exists");
@@ -145,25 +146,29 @@
     class InheritsElementDerived extends InheritsElementDeclarative {
       static get inheritedAttributes() {
         return { label: "renamedfoo=foo" };
       }
     }
     customElements.define("inherited-element-derived", InheritsElementDerived);
 
     class InheritsElementShadowDOMDeclarative extends MozXULElement {
+      constructor() {
+        super();
+        this.attachShadow({ mode: "open" });
+      }
       static get inheritedAttributes() {
         return {
           "label": "text=label,foo,empty-string,bardo=bar",
           "unmatched": "foo", // Make sure we don't throw on unmatched selectors
         };
       }
 
       connectedCallback() {
-        this.attachShadow({ mode: "open" });
+        this.shadowRoot.textContent = "";
         this.shadowRoot.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.shadowRoot.querySelector("label");
         this.initializeAttributeInheritance();
       }
     }
     customElements.define("inherited-element-shadowdom-declarative", InheritsElementShadowDOMDeclarative);
     let shadowDOMDeclarativeEl = document.querySelector("inherited-element-shadowdom-declarative");
     ok(shadowDOMDeclarativeEl, "declarative inheritance element with shadow DOM exists");
@@ -187,28 +192,31 @@
           "bar": [[ "label", "bardo" ]],
         };
         for (let attr of InheritsElementImperative.observedAttributes) {
           this.inheritAttribute(map[attr], attr);
         }
       }
 
       connectedCallback() {
+        // Typically `initializeAttributeInheritance` handles this for us:
+        this._inheritedElements = null;
+
+        this.textContent = "";
         this.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.querySelector("label");
         this.inherit();
       }
     }
 
     customElements.define("inherited-element-imperative", InheritsElementImperative);
     let imperativeEl = document.querySelector("inherited-element-imperative");
     ok(imperativeEl, "imperative inheritance element exists");
 
-    for (let el of [declarativeEl, shadowDOMDeclarativeEl, imperativeEl]) {
-      info(`Running checks for ${el.tagName}`);
+    function checkElement(el) {
       is(el.label.getAttribute("foo"), "fuagra", "predefined attribute @foo");
       ok(el.label.hasAttribute("empty-string"), "predefined attribute @empty-string");
       ok(!el.label.hasAttribute("bardo"), "predefined attribute @bardo");
       ok(!el.label.textContent, "predefined attribute @label");
 
       el.setAttribute("empty-string", "not-empty-anymore");
       is(el.label.getAttribute("empty-string"), "not-empty-anymore",
         "attribute inheritance: empty-string");
@@ -235,16 +243,28 @@
 
       el.removeAttribute("bar");
       ok(!el.label.hasAttribute("bardo"),
         "attribute inheritance: does apply when host attr has been removed");
 
       el.setAttribute("bar", "changed-from-host-2");
       is(el.label.getAttribute("bardo"), "changed-from-host-2",
         "attribute inheritance: does apply when host attr has changed after being removed");
+
+      // Restore to the original state so this can be ran again with the same element:
+      el.removeAttribute("label");
+      el.removeAttribute("bar");
+    }
+
+    for (let el of [declarativeEl, shadowDOMDeclarativeEl, imperativeEl]) {
+      info(`Running checks for ${el.tagName}`);
+      checkElement(el);
+      info(`Remove and re-add ${el.tagName} to make sure attribute inheritance still works`);
+      el.replaceWith(el);
+      checkElement(el);
     }
 
     let derivedEl = document.querySelector("inherited-element-derived");
     ok(derivedEl, "derived inheritance element exists");
     ok(!derivedEl.label.hasAttribute("foo"),
        "attribute inheritance: base class attribute is not applied in derived class that overrides it");
     ok(derivedEl.label.hasAttribute("renamedfoo"),
        "attribute inheritance: attribute defined in derived class is present");
