# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b89147ab84c1ec9ebe303ed3d7341e4002127430
Track duplicate usages for XulCounter

diff --git a/browser/tools/xulcount/XulCounter.jsm b/browser/tools/xulcount/XulCounter.jsm
--- a/browser/tools/xulcount/XulCounter.jsm
+++ b/browser/tools/xulcount/XulCounter.jsm
@@ -17,21 +17,23 @@ const SVG_NS = "http://www.w3.org/2000/s
 const ELEMENT_NODE = 1;
 const DOCUMENT_NODE = 9;
 
 function XulCounter() {
   this.xblBindingsMap = new Map();
   this.xulTagMap = new Map();
   this.htmlTagMap = new Map();
   this.unknownTagMap = new Map();
+  this.duplicateNodeSet = new Map();
 }
 
 XulCounter.prototype = {
 
   numElementsTraversed: 0,
+  numDuplicateElements: 0,
 
   get numXblElements() {
     return [...this.xblBindingsMap.values()].reduce((a, v) => {
       return a + v;
     }, 0);
   },
   get numXulElements() {
     return [...this.xulTagMap.values()].reduce((a, v) => {
@@ -60,57 +62,67 @@ XulCounter.prototype = {
     }).map(e => [e[1], e[0]]);
   },
   get htmlList() {
     return [...this.htmlTagMap.entries()].sort((a, b) => {
       return b[1] - a[1];
     }).map(e => [e[1], e[0]]);
   },
 
-  nodeFilter(node) {
-    return node.nodeType == ELEMENT_NODE ? Ci.nsIDOMNodeFilter.FILTER_ACCEPT : Ci.nsIDOMNodeFilter.FILTER_SKIP;
-  },
-
   countNodes(element) {
     var win = element.ownerGlobal;
     var dw = new DocumentWalker(element,
                                 win,
                                 Ci.nsIDOMNodeFilter.SHOW_ELEMENT,
-                                this.nodeFilter);
+                                nodeFilter);
     var node = element.nodeType === DOCUMENT_NODE ? dw.nextNode() : dw.currentNode;
     while (node) {
       this.numElementsTraversed++;
+      var cssPath = getCssPath(node);
       var style = node.ownerGlobal.getComputedStyle(node);
       var binding = style && style.getPropertyValue("-moz-binding");
       var isXBL = binding && binding != "none";
       var isXUL = node.namespaceURI === XUL_NS;
       var isHTML = node.namespaceURI === HTML_NS || node.namespaceURI === SVG_NS;
 
-      if (isXBL) {
-        this.xblBindingsMap.set(binding, (this.xblBindingsMap.get(binding) || 0) + 1);
-      }
+      if (!this.duplicateNodeSet.has(cssPath)) {
+        this.duplicateNodeSet.set(cssPath, node);
+
+        if (isXBL) {
+          this.xblBindingsMap.set(binding, (this.xblBindingsMap.get(binding) || 0) + 1);
+          console.log(`Found XBL element: ${cssPath}`);
+        }
 
-      if (isXUL) {
-        this.xulTagMap.set(node.nodeName, (this.xulTagMap.get(node.nodeName) || 0) + 1);
-      } else if (isHTML) {
-        // Explicitly don't count HTML elements inside a xbl binding like
-        //   <html:span anonid="accessKeyParens">
-        if (!isXBLAnonymous(node)) {
-          this.htmlTagMap.set(node.nodeName, (this.htmlTagMap.get(node.nodeName) || 0) + 1);
+        if (isXUL) {
+          this.xulTagMap.set(node.nodeName, (this.xulTagMap.get(node.nodeName) || 0) + 1);
+          console.log(`Found XUL element: ${cssPath}`);
+        } else if (isHTML) {
+          // Explicitly don't count HTML elements inside a xbl binding like
+          //   <html:span anonid="accessKeyParens">
+          if (!isXBLAnonymous(node)) {
+            console.log(`Found HTML element: ${cssPath}`);
+            this.htmlTagMap.set(node.nodeName, (this.htmlTagMap.get(node.nodeName) || 0) + 1);
+          }
+        } else if (!isNativeAnonymous(node)) {
+          console.warn("Unknown node detected", node);
+          this.unknownTagMap.set(node.nodeName, (this.unknownTagMap.get(node.nodeName) || 0) + 1);
         }
-      } else if (!isNativeAnonymous(node)) {
-        console.warn("Unknown node detected", node);
-        this.unknownTagMap.set(node.nodeName, (this.unknownTagMap.get(node.nodeName) || 0) + 1);
+      } else {
+        this.numDuplicateElements++;
       }
 
       node = dw.nextNode();
     }
   }
 }
 
+function nodeFilter(node) {
+  return node.nodeType == ELEMENT_NODE ? Ci.nsIDOMNodeFilter.FILTER_ACCEPT : Ci.nsIDOMNodeFilter.FILTER_SKIP;
+}
+
 function getBindingParent(node) {
   let doc = node.ownerDocument;
   if (!doc) {
     return null;
   }
 
   // If there is no binding parent then it is not anonymous.
   let parent = doc.getBindingParent(node);
@@ -181,16 +193,59 @@ function isShadowAnonymous(node) {
   }
 
   // If there is a shadowRoot and this is part of it then this
   // is not native anonymous
   return parent.shadowRoot && parent.shadowRoot.contains(node);
 }
 
 /**
+ * Get an individual selector for the element.
+ * Use ID if available, otherwise tagname+nth-child
+ * @returns string
+ */
+function getElementSelector (element, siblingPos = -1) {
+  if (!element.localName) {
+    return "";
+  }
+
+  let label = element.localName.toLowerCase();
+  if (element.id) {
+    label += "#" + element.id;
+  } else {
+    label += ":nth-child(" + siblingPos + ")";
+  }
+
+  return label;
+};
+
+/**
+ * Get the full CSS path for a given element.
+ * @returns a string that can be used as a CSS selector for the element
+ */
+function getCssPath(ele) {
+  let paths = [];
+
+  // Create a walker with the top window as a root, and walk up (this way we can traverse
+  // frame boundaries)
+  var dw = new DocumentWalker(ele, ele.ownerGlobal.top,
+                              Ci.nsIDOMNodeFilter.SHOW_ELEMENT, nodeFilter);
+  while (ele) {
+    let siblingPos = 0;
+    while (dw.previousSibling()) {
+      siblingPos++;
+    }
+    paths.splice(0, 0, getElementSelector(ele, siblingPos));
+    ele = dw.parentNode();
+  }
+
+  return paths.length ? paths.join(" ") : "";
+}
+
+/**
  * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
  * See inDeepTreeWalker for more information about the methods.
  *
  * @param {DOMNode} node
  * @param {Window} rootWin
  * @param {Number} whatToShow
  *        See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
  * @param {Function} filter
@@ -222,29 +277,39 @@ DocumentWalker.prototype = {
     return this.walker.whatToShow;
   },
   get currentNode() {
     return this.walker.currentNode;
   },
   set currentNode(val) {
     this.walker.currentNode = val;
   },
+  parentNode() {
+    return this.walker.parentNode();
+  },
   nextNode() {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
 
     let nextNode = this.walker.nextNode();
     while (nextNode && this.isSkippedNode(nextNode)) {
       nextNode = this.walker.nextNode();
     }
 
     return nextNode;
   },
+  previousSibling() {
+    let node = this.walker.previousSibling();
+    while (node && this.isSkippedNode(node)) {
+      node = this.walker.previousSibling();
+    }
+    return node;
+  },
   getStartingNode(node, skipTo) {
     // Keep a reference on the starting node in case we can't find a node compatible with
     // the filter.
     let startingNode = node;
 
     while (node && this.isSkippedNode(node)) {
       node = node.parentNode;
     }
diff --git a/browser/tools/xulcount/test/browser_count_elements.js b/browser/tools/xulcount/test/browser_count_elements.js
--- a/browser/tools/xulcount/test/browser_count_elements.js
+++ b/browser/tools/xulcount/test/browser_count_elements.js
@@ -1,31 +1,45 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+SimpleTest.requestCompleteLog();
 const {XulCounter} = Components.utils.import("resource:///modules/XulCounter.jsm", {});
 
+add_task(async function test_unique() {
+  const counter = new XulCounter();
+  counter.countNodes(document);
+  const numXblElements = counter.numXblElements;
+  counter.countNodes(document.querySelector("#sidebar-box"));
+  is(counter.numXblElements, numXblElements,
+    "Re-running the counter on a child doesn't increase the number of elements detected");
+  ok(counter.numDuplicateElements > 0,
+    "Some duplicate elements have been detected");
+});
+
 add_task(async function test_print_count() {
   const counter = new XulCounter();
   counter.countNodes(document);
   ok(counter.numElementsTraversed > 0, "some nodes have been traversed");
 
+  info(`XULCOUNT SUMMARY:`);
   info(`${counter.numElementsTraversed} elements traversed`);
   info(`There are ${counter.numXulElements} xul elements`);
   info(`There are ${counter.numXblElements} elements with xbl bindings`);
   info(`There are ${counter.numHtmlElements} html elements`);
   info(`There are ${counter.numUnknownElements} unknown elements`);
+  info(`${counter.numDuplicateElements} duplicate elements with xbl bindings detected`);
 
   const xulList = counter.xulList;
-  info(`${xulList.length} unique xul elements`);
+  info(`XUL: ${xulList.length} unique xul elements (${counter.numXulElements} total)`);
   info("Sorted list of xul elements:\n" + xulList.map(b => b[0] + "\t" + b[1]).join("\n"));
 
   const xblList = counter.xblList;
-  info(`${xblList.length} unique xbl bindings`);
+  info(`XBL: ${xblList.length} unique xbl bindings (${counter.numXblElements} total)`);
   info("Sorted list of xbl bindings:\n" + xblList.map(b => b[0] + "\t" + b[1]).join("\n"));
 
   const htmlList = counter.htmlList;
-  info(`${htmlList.length} unique html elements`);
+  info(`HTML: ${htmlList.length} unique html elements (${counter.numHtmlElements} total)`);
   info("Sorted list of html elements:\n" + htmlList.map(b => b[0] + "\t" + b[1]).join("\n"));
 });
