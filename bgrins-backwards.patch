exporting patch:
# HG changeset patch
# User Dave Camp <dcamp@mozilla.com>
# Date 1378739482 25200
#      Mon Sep 09 08:11:22 2013 -0700
# Node ID 7eed2e58e2dabf96198c59b5a634e057142ccfc8
# Parent  6f6bf27de9b51c7d96a69a7b8190468caee77797
Bug 909121 - Inspector breaks when navigating backwards

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -51,18 +51,18 @@ InspectorPanel.prototype = {
     }).then(defaultSelection => {
       return this._deferredOpen(defaultSelection);
     }).then(null, console.error);
   },
 
   _deferredOpen: function(defaultSelection) {
     let deferred = promise.defer();
 
-    this.onNavigatedAway = this.onNavigatedAway.bind(this);
-    this.target.on("navigate", this.onNavigatedAway);
+    this.onNewRoot = this.onNewRoot.bind(this);
+    this.walker.on("new-root", this.onNewRoot);
 
     this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
     this.lastNodemenuItem = this.nodemenu.lastChild;
     this._setupNodeMenu = this._setupNodeMenu.bind(this);
     this._resetNodeMenu = this._resetNodeMenu.bind(this);
     this.nodemenu.addEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.addEventListener("popuphiding", this._resetNodeMenu, true);
 
@@ -287,19 +287,19 @@ InspectorPanel.prototype = {
     let ruleViewTab = this.sidebar.getTab("ruleview");
     ruleViewTab.addEventListener("mouseover", this.toggleHighlighter, false);
     ruleViewTab.addEventListener("mouseout", this.toggleHighlighter, false);
 
     this.sidebar.show();
   },
 
   /**
-   * Reset the inspector on navigate away.
+   * Reset the inspector on new root mutation.
    */
-  onNavigatedAway: function InspectorPanel_onNavigatedAway() {
+  onNewRoot: function InspectorPanel_onNewRoot() {
     this._defaultNode = null;
     this.selection.setNodeFront(null);
     this._destroyMarkup();
     this.isDirty = false;
 
     this._getDefaultNodeForSelection().then(defaultNode => {
       if (this._destroyPromise) {
         return;
@@ -443,33 +443,32 @@ InspectorPanel.prototype = {
   /**
    * Destroy the inspector.
    */
   destroy: function InspectorPanel__destroy() {
     if (this._destroyPromise) {
       return this._destroyPromise;
     }
     if (this.walker) {
+      this.walker.off("new-root", this.onNewRoot);
       this._destroyPromise = this.walker.release().then(null, console.error);
       delete this.walker;
       delete this.pageStyle;
     } else {
       this._destroyPromise = promise.resolve(null);
     }
 
     this.cancelUpdate();
     this.cancelLayoutChange();
 
     if (this.browser) {
       this.browser.removeEventListener("resize", this.scheduleLayoutChange, true);
       this.browser = null;
     }
 
-    this.target.off("navigate", this.onNavigatedAway);
-
     if (this.highlighter) {
       this.highlighter.off("locked", this.onLockStateChanged);
       this.highlighter.off("unlocked", this.onLockStateChanged);
       this.highlighter.destroy();
     }
 
     this.target.off("thread-paused", this.updateDebuggerPausedWarning);
     this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
diff --git a/browser/devtools/inspector/test/Makefile.in b/browser/devtools/inspector/test/Makefile.in
--- a/browser/devtools/inspector/test/Makefile.in
+++ b/browser/devtools/inspector/test/Makefile.in
@@ -33,14 +33,15 @@ MOCHITEST_BROWSER_FILES := \
 		browser_inspector_bug_650804_search.js \
 		browser_inspector_bug_650804_search.html \
 		browser_inspector_bug_831693_input_suggestion.js \
 		browser_inspector_bug_831693_combinator_suggestions.js \
 		browser_inspector_bug_831693_search_suggestions.html \
 		browser_inspector_bug_835722_infobar_reappears.js \
 		browser_inspector_bug_840156_destroy_after_navigation.js \
 		browser_inspector_reload.js \
+		browser_inspector_navigation.js \
 		browser_inspector_select_last_selected.js \
 		browser_inspector_select_last_selected.html \
 		browser_inspector_select_last_selected2.html \
 		browser_inspector_basic_highlighter.js \
 		head.js \
 		$(NULL)
diff --git a/browser/devtools/inspector/test/browser_inspector_navigation.js b/browser/devtools/inspector/test/browser_inspector_navigation.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_navigation.js
@@ -0,0 +1,67 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+function test() {
+  let inspector, toolbox;
+
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function onload() {
+    gBrowser.selectedBrowser.removeEventListener("load", onload, true);
+    waitForFocus(function() {
+      let target = TargetFactory.forTab(gBrowser.selectedTab);
+      gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
+        startInspectorTests(toolbox);
+      }).then(null, console.error);
+    }, content);
+  }, true);
+
+  content.location = "http://test1.example.org/browser/browser/devtools/inspector/test/browser_inspector_breadcrumbs.html";
+
+  function startInspectorTests(aToolbox)
+  {
+    toolbox = aToolbox;
+    inspector = toolbox.getCurrentPanel();
+    info("Inspector started");
+    let node = content.document.querySelector("#i1");
+    inspector.selection.setNode(node);
+    inspector.once("inspector-updated", () => {
+      is(inspector.selection.node, node, "Node selected.");
+      inspector.once("markuploaded", onSecondLoad);
+      content.location = "http://test2.example.org/browser/browser/devtools/inspector/test/browser_inspector_breadcrumbs.html";
+    });
+  }
+
+  function onSecondLoad() {
+    info("New page loaded");
+    let node = content.document.querySelector("#i1");
+    inspector.selection.setNode(node);
+
+    inspector.once("inspector-updated", () => {
+      is(inspector.selection.node, node, "Node re-selected.");
+      inspector.once("markuploaded", onThirdLoad);
+      content.history.go(-1);
+    });
+  }
+
+  function onThirdLoad() {
+    info("Old page loaded");
+    is(content.location.href, "http://test1.example.org/browser/browser/devtools/inspector/test/browser_inspector_breadcrumbs.html");
+    let node = content.document.querySelector("#i1");
+    inspector.selection.setNode(node);
+    inspector.once("inspector-updated", () => {
+      is(inspector.selection.node, node, "Node re-selected.");
+      inspector.once("markuploaded", onThirdLoad);
+      toolbox.destroy();
+      gBrowser.removeCurrentTab();
+      finish();
+    });
+  }
+}
+
+
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1843,17 +1843,17 @@ var WalkerFront = exports.WalkerFront = 
     return this._pick().then(response => {
       return response.node;
     });
   }, {
     impl: "_pick"
   }),
 
   initialize: function(client, form) {
-    this._rootNodeDeferred = promise.defer();
+    this._createRootNodePromise();
     protocol.Front.prototype.initialize.call(this, client, form);
     this._orphaned = new Set();
     this._retainedOrphans = new Set();
   },
 
   destroy: function() {
     protocol.Front.prototype.destroy.call(this);
   },
@@ -1871,16 +1871,27 @@ var WalkerFront = exports.WalkerFront = 
    * method returns a promise that will resolve to the root node when it is
    * set.
    */
   getRootNode: function() {
     return this._rootNodeDeferred.promise;
   },
 
   /**
+   * Create the root node promise, triggering the "new-root" notification
+   * on resolution.
+   */
+  _createRootNodePromise: function() {
+    this._rootNodeDeferred = promise.defer();
+    this._rootNodeDeferred.promise.then(() => {
+      events.emit(this, "new-root");
+    });
+  },
+
+  /**
    * When reading an actor form off the wire, we want to hook it up to its
    * parent front.  The protocol guarantees that the parent will be seen
    * by the client in either a previous or the current request.
    * So if we've already seen this parent return it, otherwise create
    * a bare-bones stand-in node.  The stand-in node will be updated
    * with a real form by the end of the deserialization.
    */
   ensureParentFront: function(id) {
@@ -2042,18 +2053,17 @@ var WalkerFront = exports.WalkerFront = 
           // first.
           for (let child of targetFront.treeChildren()) {
             if (child.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE) {
               console.trace("Got an unexpected frameLoad in the inspector, please file a bug on bugzilla.mozilla.org!");
             }
           }
         } else if (change.type === "documentUnload") {
           if (targetFront === this.rootNode) {
-            this.rootNode = null;
-            this._rootNodeDeferred = promise.defer();
+            this._createRootNodePromise();
           }
 
           // We try to give fronts instead of actorIDs, but these fronts need
           // to be destroyed now.
           emittedMutation.target = targetFront.actorID;
           emittedMutation.targetParent = targetFront.parentNode();
 
           // Release the document node and all of its children, even retained.
