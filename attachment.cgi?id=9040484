# HG changeset patch
# User Neil Deakin <neil@mozilla.com>
# Parent  af02238bdfe7b2de724e2bfc073736e095cafaac

diff --git a/layout/generic/CSSOrderAwareFrameIterator.cpp b/layout/generic/CSSOrderAwareFrameIterator.cpp
--- a/layout/generic/CSSOrderAwareFrameIterator.cpp
+++ b/layout/generic/CSSOrderAwareFrameIterator.cpp
@@ -14,17 +14,17 @@ template <>
 bool CSSOrderAwareFrameIterator::CSSOrderComparator(nsIFrame* const& a,
                                                     nsIFrame* const& b) {
   return a->StylePosition()->mOrder < b->StylePosition()->mOrder;
 }
 
 template <>
 bool CSSOrderAwareFrameIterator::CSSBoxOrdinalGroupComparator(
     nsIFrame* const& a, nsIFrame* const& b) {
-  return a->StyleXUL()->mBoxOrdinal < b->StyleXUL()->mBoxOrdinal;
+  return a->GetXULOrdinal() < b->GetXULOrdinal();
 }
 
 template <>
 bool CSSOrderAwareFrameIterator::IsForward() const {
   return true;
 }
 
 template <>
diff --git a/layout/generic/CSSOrderAwareFrameIterator.h b/layout/generic/CSSOrderAwareFrameIterator.h
--- a/layout/generic/CSSOrderAwareFrameIterator.h
+++ b/layout/generic/CSSOrderAwareFrameIterator.h
@@ -92,17 +92,17 @@ class CSSOrderAwareFrameIteratorT {
         if (aOrderProp == eUseBoxOrdinalGroup) {
           // We'll be using mBoxOrdinal, which has type uint32_t. However, the
           // modern 'order' property (whose functionality we're co-opting) has
           // type int32_t.  So: if we happen to have a uint32_t value that's
           // greater than INT32_MAX, we clamp it rather than letting it
           // overflow. Chances are, this is just an author using BIG_VALUE
           // anyway, so the clamped value should be fine.
           uint32_t clampedBoxOrdinal = std::min(
-              child->StyleXUL()->mBoxOrdinal, static_cast<uint32_t>(INT32_MAX));
+              child->GetXULOrdinal(), static_cast<uint32_t>(INT32_MAX));
           order = static_cast<int32_t>(clampedBoxOrdinal);
         } else {
           order = child->StylePosition()->mOrder;
         }
 
         if (order < maxOrder) {
           isOrdered = false;
           break;
diff --git a/layout/generic/nsFlexContainerFrame.cpp b/layout/generic/nsFlexContainerFrame.cpp
--- a/layout/generic/nsFlexContainerFrame.cpp
+++ b/layout/generic/nsFlexContainerFrame.cpp
@@ -108,19 +108,43 @@ static CSSOrderAwareFrameIterator::Order
     const nsFlexContainerFrame* aFlexContainer) {
   return IsLegacyBox(aFlexContainer)
              ? CSSOrderAwareFrameIterator::OrderingProperty::eUseBoxOrdinalGroup
              : CSSOrderAwareFrameIterator::OrderingProperty::eUseOrder;
 }
 
 // Returns the "align-items" value that's equivalent to the legacy "box-align"
 // value in the given style struct.
-static uint8_t ConvertLegacyStyleToAlignItems(const nsStyleXUL* aStyleXUL) {
+static uint8_t ConvertLegacyStyleToAlignItems(const nsIFrame* aFrame) {
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::stretch, eCaseMatters)) {
+      return NS_STYLE_ALIGN_STRETCH;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::start, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_START;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::center, eCaseMatters)) {
+      return NS_STYLE_ALIGN_CENTER;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::baseline, eCaseMatters)) {
+      return NS_STYLE_ALIGN_BASELINE;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::end, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_END;
+    }
+  }
+
   // -[moz|webkit]-box-align corresponds to modern "align-items"
-  switch (aStyleXUL->mBoxAlign) {
+  switch (aFrame->StyleXUL()->mBoxAlign) {
     case StyleBoxAlign::Stretch:
       return NS_STYLE_ALIGN_STRETCH;
     case StyleBoxAlign::Start:
       return NS_STYLE_ALIGN_FLEX_START;
     case StyleBoxAlign::Center:
       return NS_STYLE_ALIGN_CENTER;
     case StyleBoxAlign::Baseline:
       return NS_STYLE_ALIGN_BASELINE;
@@ -130,19 +154,35 @@ static uint8_t ConvertLegacyStyleToAlign
 
   MOZ_ASSERT_UNREACHABLE("Unrecognized mBoxAlign enum value");
   // Fall back to default value of "align-items" property:
   return NS_STYLE_ALIGN_STRETCH;
 }
 
 // Returns the "justify-content" value that's equivalent to the legacy
 // "box-pack" value in the given style struct.
-static uint8_t ConvertLegacyStyleToJustifyContent(const nsStyleXUL* aStyleXUL) {
+static uint8_t ConvertLegacyStyleToJustifyContent(const nsIFrame* aFrame) {
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::pack,
+                                          nsGkAtoms::start, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_START;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::pack,
+                                          nsGkAtoms::center, eCaseMatters)) {
+      return NS_STYLE_ALIGN_CENTER;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::pack,
+                                          nsGkAtoms::end, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_END;
+    }
+  }
+
   // -[moz|webkit]-box-pack corresponds to modern "justify-content"
-  switch (aStyleXUL->mBoxPack) {
+  switch (aFrame->StyleXUL()->mBoxPack) {
     case StyleBoxPack::Start:
       return NS_STYLE_ALIGN_FLEX_START;
     case StyleBoxPack::Center:
       return NS_STYLE_ALIGN_CENTER;
     case StyleBoxPack::End:
       return NS_STYLE_ALIGN_FLEX_END;
     case StyleBoxPack::Justify:
       return NS_STYLE_ALIGN_SPACE_BETWEEN;
@@ -1276,17 +1316,19 @@ UniquePtr<FlexItem> nsFlexContainerFrame
   ReflowInput childRI(
       aPresContext, aParentReflowInput, aChildFrame,
       aParentReflowInput.ComputedSize(aChildFrame->GetWritingMode()));
 
   // FLEX GROW & SHRINK WEIGHTS
   // --------------------------
   float flexGrow, flexShrink;
   if (IsLegacyBox(this)) {
-    flexGrow = flexShrink = aChildFrame->StyleXUL()->mBoxFlex;
+    nscoord flex;
+    nsFrame::AddXULFlex(aChildFrame, flex);
+    flexGrow = flexShrink = flex;
   } else {
     const nsStylePosition* stylePos = aChildFrame->StylePosition();
     flexGrow = stylePos->mFlexGrow;
     flexShrink = stylePos->mFlexShrink;
   }
 
   WritingMode childWM = childRI.GetWritingMode();
 
@@ -1915,18 +1957,17 @@ FlexItem::FlexItem(ReflowInput& aFlexIte
   if (IsLegacyBox(containerRS->mFrame)) {
     // For -webkit-{inline-}box and -moz-{inline-}box, we need to:
     // (1) Use prefixed "box-align" instead of "align-items" to determine the
     //     container's cross-axis alignment behavior.
     // (2) Suppress the ability for flex items to override that with their own
     //     cross-axis alignment. (The legacy box model doesn't support this.)
     // So, each FlexItem simply copies the container's converted "align-items"
     // value and disregards their own "align-self" property.
-    const nsStyleXUL* containerStyleXUL = containerRS->mFrame->StyleXUL();
-    mAlignSelf = ConvertLegacyStyleToAlignItems(containerStyleXUL);
+    mAlignSelf = ConvertLegacyStyleToAlignItems(containerRS->mFrame);
   } else {
     mAlignSelf = aFlexItemReflowInput.mStylePosition->UsedAlignSelf(
         containerRS->mFrame->Style());
     if (MOZ_LIKELY(mAlignSelf == NS_STYLE_ALIGN_NORMAL)) {
       mAlignSelf = NS_STYLE_ALIGN_STRETCH;
     }
 
     // Store and strip off the <overflow-position> bits
@@ -3580,22 +3621,74 @@ FlexboxAxisTracker::FlexboxAxisTracker(
       mCrossAxis = GetReverseAxis(mCrossAxis);
       mAreAxesInternallyReversed = true;
       mIsMainAxisReversed = !mIsMainAxisReversed;
       mIsCrossAxisReversed = !mIsCrossAxisReversed;
     }
   }
 }
 
+bool GetXULFlexOrientIsHorizontal(const nsIFrame* aFrame)
+{
+  bool horizontal = (aFrame->StyleXUL()->mBoxOrient == StyleBoxOrient::Horizontal);
+
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    // Now see if we have an attribute.  The attribute overrides the style system value.
+    static const Element::AttrValuesArray strings[] =
+      {nsGkAtoms::vertical, nsGkAtoms::horizontal, nullptr};
+    int32_t index = content->AsElement()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::orient,
+                                                          strings, eCaseMatters);
+    if (index >= 0) {
+      horizontal = index == 1;
+    }
+  }
+
+  return horizontal;
+}
+
+mozilla::StyleBoxDirection GetXULFlexDirection(const nsIFrame* aFrame)
+{
+  const nsStyleXUL* boxInfo = aFrame->StyleXUL();
+
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    bool horizontal = GetXULFlexOrientIsHorizontal(aFrame);
+
+    bool normalDir = true;
+    if (horizontal) {
+      normalDir = (aFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR);
+    }
+    if (boxInfo->mBoxDirection == StyleBoxDirection::Reverse) {
+      normalDir = !normalDir;
+    }
+
+    if (horizontal) {
+      static const Element::AttrValuesArray strings[] =
+        {nsGkAtoms::reverse, nsGkAtoms::ltr, nsGkAtoms::rtl, nullptr};
+      int32_t index = content->AsElement()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
+                                                            strings, eCaseMatters);
+      if (index >= 0) {
+        bool values[] = {!normalDir, true, false};
+        normalDir = values[index];
+      }
+    } else if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,
+                                                 nsGkAtoms::reverse, eCaseMatters)) {
+      normalDir = !normalDir;
+    }
+
+    return normalDir ? StyleBoxDirection::Normal : StyleBoxDirection::Reverse;
+  }
+
+  return boxInfo->mBoxDirection;
+}
+
 void FlexboxAxisTracker::InitAxesFromLegacyProps(
     const nsFlexContainerFrame* aFlexContainer) {
-  const nsStyleXUL* styleXUL = aFlexContainer->StyleXUL();
-
-  const bool boxOrientIsVertical =
-      (styleXUL->mBoxOrient == StyleBoxOrient::Vertical);
+  const bool boxOrientIsVertical = !GetXULFlexOrientIsHorizontal(aFlexContainer);
   const bool wmIsVertical = mWM.IsVertical();
 
   // If box-orient agrees with our writing-mode, then we're "row-oriented"
   // (i.e. the flexbox main axis is the same as our writing mode's inline
   // direction).  Otherwise, we're column-oriented (i.e. the flexbox's main
   // axis is perpendicular to the writing-mode's inline direction).
   mIsRowOriented = (boxOrientIsVertical == wmIsVertical);
 
@@ -3614,17 +3707,17 @@ void FlexboxAxisTracker::InitAxesFromLeg
   if (!mWM.IsBidiLTR()) {
     AxisOrientationType& axisToFlip = mIsRowOriented ? mMainAxis : mCrossAxis;
     axisToFlip = GetReverseAxis(axisToFlip);
   }
   // XXXdholbert END CODE TO SET DEPRECATED MEMBER-VARS
 
   // Legacy flexbox can use "-webkit-box-direction: reverse" to reverse the
   // main axis (so it runs in the reverse direction of the inline axis):
-  if (styleXUL->mBoxDirection == StyleBoxDirection::Reverse) {
+  if (GetXULFlexDirection(aFlexContainer) == StyleBoxDirection::Reverse) {
     mMainAxis = GetReverseAxis(mMainAxis);
     mIsMainAxisReversed = true;
   } else {
     mIsMainAxisReversed = false;
   }
 
   // Legacy flexbox does not support reversing the cross axis -- it has no
   // equivalent of modern flexbox's "flex-wrap: wrap-reverse".
@@ -4423,19 +4516,17 @@ bool nsFlexContainerFrame::IsItemInlineA
   MOZ_ASSERT(aFrame && aFrame->IsFlexItem(), "expecting arg to be a flex item");
   const WritingMode flexItemWM = aFrame->GetWritingMode();
   const nsIFrame* flexContainer = aFrame->GetParent();
 
   if (IsLegacyBox(flexContainer)) {
     // For legacy boxes, the main axis is determined by "box-orient", and we can
     // just directly check if that's vertical, and compare that to whether the
     // item's WM is also vertical:
-    bool boxOrientIsVertical =
-        (flexContainer->StyleXUL()->mBoxOrient == StyleBoxOrient::Vertical);
-    return flexItemWM.IsVertical() == boxOrientIsVertical;
+    return flexItemWM.IsVertical() == !GetXULFlexOrientIsHorizontal(flexContainer);
   }
 
   // For modern CSS flexbox, we get our return value by asking two questions
   // and comparing their answers.
   // Question 1: does aFrame have the same inline axis as its flex container?
   bool itemInlineAxisIsParallelToParent =
       !flexItemWM.IsOrthogonalTo(flexContainer->GetWritingMode());
 
@@ -4700,17 +4791,17 @@ void nsFlexContainerFrame::DoFlexLayout(
       flexContainerAscent = ComputePhysicalAscentFromFlexRelativeAscent(
           crossAxisPosnTracker.GetPosition() + firstLineBaselineOffset,
           contentBoxCrossSize, aReflowInput, aAxisTracker);
     }
   }
 
   const auto justifyContent =
       IsLegacyBox(aReflowInput.mFrame)
-          ? ConvertLegacyStyleToJustifyContent(StyleXUL())
+          ? ConvertLegacyStyleToJustifyContent(aReflowInput.mFrame)
           : aReflowInput.mStylePosition->mJustifyContent;
 
   // Recalculate the gap sizes if necessary now that the container size has
   // been determined.
   if (aReflowInput.ComputedBSize() == NS_INTRINSICSIZE &&
       aReflowInput.mStylePosition->mRowGap.HasPercent()) {
     bool rowIsCross = aAxisTracker.IsRowOriented();
     nscoord newBlockGapSize = nsLayoutUtils::ResolveGapToLength(
@@ -5215,8 +5306,38 @@ nscoord nsFlexContainerFrame::IntrinsicI
     mCachedPrefISize =
         StyleDisplay()->IsContainSize()
             ? 0
             : IntrinsicISize(aRenderingContext, nsLayoutUtils::PREF_ISIZE);
   }
 
   return mCachedPrefISize;
 }
+
+nsresult
+nsFlexContainerFrame::AttributeChanged(int32_t aNameSpaceID,
+                                       nsAtom* aAttribute,
+                                       int32_t aModType)
+{
+  nsresult rv = nsContainerFrame::AttributeChanged(aNameSpaceID, aAttribute,
+                                                   aModType);
+
+  nsIContent* content = GetContent();
+  if (!content || !content->IsXULElement()) {
+    return NS_OK;
+  }
+
+  if (aAttribute == nsGkAtoms::flex ||
+      aAttribute == nsGkAtoms::orient ||
+      aAttribute == nsGkAtoms::align ||
+      aAttribute == nsGkAtoms::pack ||
+      aAttribute == nsGkAtoms::dir) {
+    PresContext()->PresShell()->
+      FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+  }
+  else if (aAttribute == nsGkAtoms::ordinal) {
+    PresContext()->PresShell()->
+      FrameNeedsReflow(GetParent(), nsIPresShell::eStyleChange,
+                       NS_FRAME_IS_DIRTY);
+  }
+
+  return rv;
+}
diff --git a/layout/generic/nsFlexContainerFrame.h b/layout/generic/nsFlexContainerFrame.h
--- a/layout/generic/nsFlexContainerFrame.h
+++ b/layout/generic/nsFlexContainerFrame.h
@@ -145,16 +145,20 @@ class nsFlexContainerFrame final : publi
       return false;
     }
     *aBaseline = aBaselineGroup == BaselineSharingGroup::eFirst
                      ? mBaselineFromLastReflow
                      : mLastBaselineFromLastReflow;
     return true;
   }
 
+  nsresult AttributeChanged(int32_t aNameSpaceID,
+                            nsAtom* aAttribute,
+                            int32_t aModType) override;
+
   // nsContainerFrame overrides
   uint16_t CSSAlignmentForAbsPosChild(
       const ReflowInput& aChildRI,
       mozilla::LogicalAxis aLogicalAxis) const override;
 
   /**
    * Helper function to calculate packing space and initial offset of alignment
    * subjects in MainAxisPositionTracker() and CrossAxisPositionTracker() for
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -739,56 +739,8 @@ tabmodalprompt {
 .button-highlightable-text:not([highlightable="true"]),
 .button-text[highlightable="true"],
 .menulist-highlightable-label:not([highlightable="true"]),
 .menulist-label[highlightable="true"],
 .menu-iconic-highlightable-text:not([highlightable="true"]),
 .menu-iconic-text[highlightable="true"] {
   display: none;
 }
-
-@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
-  /* Support common XUL attributes in the emulated flex mode so we can
-     test the browser in this configuration without mass-changing existing
-     markup and CSS. */
-  [orient="vertical"] { -moz-box-orient: vertical; }
-  [orient="horizontal"] { -moz-box-orient: horizontal; }
-
-  [dir="reverse"] { -moz-box-direction: reverse; }
-
-  [align="start"] { -moz-box-align: start; }
-  [align="center"] { -moz-box-align: center; }
-  [align="end"] { -moz-box-align: end; }
-  [align="baseline"] { -moz-box-align: baseline; }
-  [align="stretch"] { -moz-box-align: stretch; }
-
-  [pack="start"] { -moz-box-pack: start; }
-  [pack="center"] { -moz-box-pack: center; }
-  [pack="end"] { -moz-box-pack: end; }
-
-  /* This isn't a real solution for [flex] and [ordinal], but it covers enough
-     cases to render the browser chrome. If we get attr() in Bug 435426 this could
-     work for all cases. */
-  [flex="1"] { -moz-box-flex: 1; }
-  [flex="2"] { -moz-box-flex: 2; }
-  [flex="3"] { -moz-box-flex: 3; }
-  [flex="4"] { -moz-box-flex: 4; }
-  [flex="5"] { -moz-box-flex: 5; }
-  [flex="6"] { -moz-box-flex: 6; }
-  [flex="7"] { -moz-box-flex: 7; }
-  [flex="8"] { -moz-box-flex: 8; }
-  [flex="9"] { -moz-box-flex: 9; }
-  [flex="100"] { -moz-box-flex: 100; }
-  [flex="400"] { -moz-box-flex: 400; }
-  [flex="1000"] { -moz-box-flex: 1000; }
-  [flex="10000"] { -moz-box-flex: 10000; }
-
-  [ordinal="1"] { -moz-box-ordinal-group: 1; }
-  [ordinal="2"] { -moz-box-ordinal-group: 2; }
-  [ordinal="3"] { -moz-box-ordinal-group: 3; }
-  [ordinal="4"] { -moz-box-ordinal-group: 4; }
-  [ordinal="5"] { -moz-box-ordinal-group: 5; }
-  [ordinal="6"] { -moz-box-ordinal-group: 6; }
-  [ordinal="7"] { -moz-box-ordinal-group: 7; }
-  [ordinal="8"] { -moz-box-ordinal-group: 8; }
-  [ordinal="9"] { -moz-box-ordinal-group: 9; }
-  [ordinal="1000"] { -moz-box-ordinal-group: 1000; }
-}
