# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1538345489 25200
#      Sun Sep 30 15:11:29 2018 -0700
# Node ID c271148ff6df9ad0f85a65996c47c0756ac288e3
# Parent  e28e2921e6f4b5e51eefab0642962210a2d81391
Bug 1481949 - Use querySelectorAll instead of a treeWalker for finding radios underneath a radiogroup;r=timdream

This removes support for having a child radiogroup within another radiogroup, but that
behavior is undocumented and unused in tree.

Differential Revision: https://phabricator.services.mozilla.com/D7255

diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -112,16 +112,20 @@ class MozRadiogroup extends MozBaseContr
   }
 
   connectedCallback() {
     this._radioChildren = null;
 
     if (this.getAttribute("disabled") == "true")
       this.disabled = true;
 
+    if (this.querySelector("radiogroup")) {
+      throw new Error("A radiogroup shouldn't have a nested radiogroup");
+    }
+
     var children = this._getRadioChildren();
     var length = children.length;
     for (var i = 0; i < length; i++) {
       if (children[i].getAttribute("selected") == "true") {
         this.selectedIndex = i;
         return;
       }
     }
@@ -306,56 +310,35 @@ class MozRadiogroup extends MozBaseContr
     }
   }
 
   _getRadioChildren() {
     if (this._radioChildren)
       return this._radioChildren;
 
     var radioChildren = [];
-    var doc = this.ownerDocument;
 
     if (this.hasChildNodes()) {
-      // Don't store the collected child nodes immediately,
-      // collecting the child nodes could trigger constructors
-      // which would blow away our list.
-
-      var iterator = doc.createTreeWalker(this,
-        NodeFilter.SHOW_ELEMENT,
-        this._filterRadioGroup);
-      while (iterator.nextNode())
-        radioChildren.push(iterator.currentNode);
-      return this._radioChildren = radioChildren;
+      return this._radioChildren = [...this.querySelectorAll("radio")];
     }
 
     // We don't have child nodes.
     const XUL_NS = "http://www.mozilla.org/keymaster/" +
       "gatekeeper/there.is.only.xul";
-    var elems = doc.getElementsByAttribute("group", this.id);
+
+    var elems = this.ownerDocument.getElementsByAttribute("group", this.id);
     for (var i = 0; i < elems.length; i++) {
       if ((elems[i].namespaceURI == XUL_NS) &&
         (elems[i].localName == "radio")) {
         radioChildren.push(elems[i]);
       }
     }
     return this._radioChildren = radioChildren;
   }
 
-  _filterRadioGroup(node) {
-    switch (node.localName) {
-      case "radio":
-        return NodeFilter.FILTER_ACCEPT;
-      case "template":
-      case "radiogroup":
-        return NodeFilter.FILTER_REJECT;
-      default:
-        return NodeFilter.FILTER_SKIP;
-    }
-  }
-
   getIndexOfItem(item) {
     return this._getRadioChildren().indexOf(item);
   }
 
   getItemAtIndex(index) {
     var children = this._getRadioChildren();
     return (index >= 0 && index < children.length) ? children[index] : null;
   }
