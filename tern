# HG changeset patch
# Parent 49bf1fa2a369b22f3304986b805bbca3f0ce4efb
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1029162 - Update tern to 0.6.2;r=past

diff --git a/toolkit/devtools/tern/README b/toolkit/devtools/tern/README
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/tern/README
@@ -0,0 +1,10 @@
+This is the Tern code-analysis engine packaged for the Mozilla Project.
+
+Tern is a stand-alone code-analysis engine for JavaScript. It is intended to be used with a code editor plugin to enhance the editor's support for intelligent JavaScript editing
+
+
+# Upgrade
+
+Currently used version is 0.6.2.  To upgrade, download the latest release from http://ternjs.net/, and copy the files from lib/ into this directory.
+
+You may also need to update the CodeMirror plugin found in browser/devtools/sourceeditor/codemirror/tern, but it will most likely work without updating.
diff --git a/toolkit/devtools/tern/browser.js b/toolkit/devtools/tern/browser.js
--- a/toolkit/devtools/tern/browser.js
+++ b/toolkit/devtools/tern/browser.js
@@ -1238,17 +1238,17 @@ module.exports = {
         "!type": "+HTMLCollection",
         "!url": "https://developer.mozilla.org/en/docs/DOM/document.forms",
         "!doc": "Returns a collection (an HTMLCollection) of the form elements within the current document."
       },
       "styleSheets": {
         "!type": "+HTMLCollection",
         "!url": "https://developer.mozilla.org/en/docs/DOM/document.styleSheets",
         "!doc": "Returns a list of stylesheet objects for stylesheets explicitly linked into or embedded in a document."
-      }
+      },
     },
     "!url": "https://developer.mozilla.org/en/docs/DOM/document",
     "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
   },
   "document": {
     "!type": "+Document",
     "!url": "https://developer.mozilla.org/en/docs/DOM/document",
     "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
diff --git a/toolkit/devtools/tern/comment.js b/toolkit/devtools/tern/comment.js
old mode 100644
new mode 100755
diff --git a/toolkit/devtools/tern/condense.js b/toolkit/devtools/tern/condense.js
old mode 100644
new mode 100755
--- a/toolkit/devtools/tern/condense.js
+++ b/toolkit/devtools/tern/condense.js
@@ -78,30 +78,26 @@
     var len = 1, pos = 0, dot;
     while ((dot = path.indexOf(".", pos)) != -1) {
       pos = dot + 1;
       len += path.charAt(pos) == "!" ? 10 : 1;
     }
     return len;
   }
 
-  function isConcrete(path) {
-    return !/\!|<i>/.test(path);
-  }
-
   function hop(obj, prop) {
     return Object.prototype.hasOwnProperty.call(obj, prop);
   }
 
   function isSimpleInstance(o) {
     return o.proto && !(o instanceof infer.Fn) && o.proto != infer.cx().protos.Object &&
       o.proto.hasCtor && !o.hasCtor;
   }
 
-  function reach(type, path, id, state) {
+  function reach(type, path, id, state, byName) {
     var actual = type.getType(false);
     if (!actual) return;
     var orig = type.origin || actual.origin, relevant = false;
     if (orig) {
       var origPos = state.cx.origins.indexOf(orig);
       // This is a path that is newer than the code we are interested in.
       if (origPos > state.maxOrigin) return;
       relevant = state.isTarget(orig);
@@ -114,40 +110,41 @@
         var data = state.types[oldPath];
         if (data) {
           delete state.types[oldPath];
           state.altPaths[oldPath] = actual;
         } else data = {type: actual};
         data.span = state.getSpan(type) || (actual != type && state.isTarget(actual.origin) && state.getSpan(actual)) || data.span;
         data.doc = type.doc || (actual != type && state.isTarget(actual.origin) && type.doc) || data.doc;
         data.data = actual.metaData;
+        data.byName = data.byName == null ? !!byName : data.byName && byName;
         state.types[newPath] = data;
       }
     } else {
       if (relevant) state.altPaths[newPath] = actual;
     }
   }
-  function reachTypeOnly(aval, path, id, state) {
+  function reachByName(aval, path, id, state) {
     var type = aval.getType();
-    if (type) reach(type, path, id, state);
+    if (type) reach(type, path, id, state, true);
   }
 
   infer.Prim.prototype.reached = function() {return true;};
 
   infer.Arr.prototype.reached = function(path, state, concrete) {
-    if (!concrete) reachTypeOnly(this.getProp("<i>"), path, "<i>", state);
+    if (!concrete) reachByName(this.getProp("<i>"), path, "<i>", state);
     return true;
   };
 
   infer.Fn.prototype.reached = function(path, state, concrete) {
     infer.Obj.prototype.reached.call(this, path, state, concrete);
     if (!concrete) {
       for (var i = 0; i < this.args.length; ++i)
-        reachTypeOnly(this.args[i], path, "!" + i, state);
-      reachTypeOnly(this.retval, path, "!ret", state);
+        reachByName(this.args[i], path, "!" + i, state);
+      reachByName(this.retval, path, "!ret", state);
     }
     return true;
   };
 
   infer.Obj.prototype.reached = function(path, state, concrete) {
     if (isSimpleInstance(this) && !this.condenseForceInclude) {
       if (state.patchUp.indexOf(this) == -1) state.patchUp.push(this);
       return true;
@@ -173,27 +170,30 @@
     } else {
       path = obj.path;
     }
     for (var prop in obj.props)
       reach(obj.props[prop], path, prop, state);
   }
 
   function createPath(parts, state) {
-    var base = state.output;
-    for (var i = parts.length - 1; i >= 0; --i) if (!isConcrete(parts[i])) {
-      var def = parts.slice(0, i + 1).join(".");
-      var defs = state.output["!define"];
-      if (hop(defs, def)) base = defs[def];
-      else defs[def] = base = {};
-      parts = parts.slice(i + 1);
-    }
-    for (var i = 0; i < parts.length; ++i) {
-      if (hop(base, parts[i])) base = base[parts[i]];
-      else base = base[parts[i]] = {};
+    var base = state.output, defs = state.output["!define"];
+    for (var i = 0, path; i < parts.length; ++i) {
+      var part = parts[i], known = path && state.types[path];
+      path = path ? path + "." + part : part;
+      var me = state.types[path];
+      if (part.charAt(0) == "!" ||
+          known && known.type.constructor != infer.Obj ||
+          me && me.byName) {
+        if (hop(defs, path)) base = defs[path];
+        else defs[path] = base = {};
+      } else {
+        if (hop(base, parts[i])) base = base[part];
+        else base = base[part] = {};
+      }
     }
     return base;
   }
 
   function store(out, info, state) {
     var name = typeName(info.type);
     if (name != info.type.path && name != "?") {
       out["!type"] = name;
@@ -203,17 +203,20 @@
     }
     if (info.span) out["!span"] = info.span;
     if (info.doc) out["!doc"] = info.doc;
     if (info.data) out["!data"] = info.data;
   }
 
   function storeAlt(path, type, state) {
     var parts = path.split("."), last = parts.pop();
+    if (last[0] == "!") return;
+    var known = state.types[parts.join(".")];
     var base = createPath(parts, state);
+    if (known && known.type.constructor != infer.Obj) return;
     if (!hop(base, last)) base[last] = type.nameOverride || type.path;
   }
 
   var typeNameStack = [];
   function typeName(type) {
     var actual = type.getType(false);
     if (!actual || typeNameStack.indexOf(actual) > -1)
       return actual && actual.path || "?";
@@ -263,20 +266,22 @@
         data[prop] = simplify(data[prop], sort);
     }
     if (sawType && !sawOther) return data["!type"];
     return sort ? sortObject(data) : data;
   }
 
   function sortObject(obj) {
     var props = [], out = {};
-    for (var prop in obj) props.push({name: prop, val: obj[prop]});
-    props.sort(function(a, b) { return a.name < b.name ? -1 : 1; });
-    for (var i = 0; i < props.length; ++i)
-      out[props[i].name] = props[i].val;
+    for (var prop in obj) props.push(prop);
+    props.sort();
+    for (var i = 0; i < props.length; ++i) {
+      var prop = props[i];
+      out[prop] = obj[prop];
+    }
     return out;
   }
 
   function runPass(functions) {
     if (functions) for (var i = 0; i < functions.length; ++i)
       functions[i].apply(null, Array.prototype.slice.call(arguments, 1));
   }
 });
diff --git a/toolkit/devtools/tern/def.js b/toolkit/devtools/tern/def.js
old mode 100644
new mode 100755
--- a/toolkit/devtools/tern/def.js
+++ b/toolkit/devtools/tern/def.js
@@ -1,15 +1,15 @@
 // Type description parser
-
+//
 // Type description JSON files (such as ecma5.json and browser.json)
 // are used to
 //
 // A) describe types that come from native code
-
+//
 // B) to cheaply load the types for big libraries, or libraries that
 //    can't be inferred well
 
 (function(mod) {
   if (typeof exports == "object" && typeof module == "object") // CommonJS
     return exports.init = mod;
   if (typeof define == "function" && define.amd) // AMD
     return define({init: mod});
@@ -76,16 +76,20 @@
       if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
       return fn;
     },
     parseType: function(name, top) {
       if (this.eat("fn(")) {
         return this.parseFnType(name, top);
       } else if (this.eat("[")) {
         var inner = this.parseType();
+        if (inner == infer.ANull && this.spec == "[b.<i>]") {
+          var b = parsePath("b");
+          console.log(b.props["<i>"].types.length);
+        }
         this.eat("]") || this.error();
         if (top && this.base) {
           infer.Arr.call(this.base, inner);
           return this.base;
         }
         return new infer.Arr(inner);
       } else if (this.eat("+")) {
         var path = this.word(/[\w$<>\.!]/);
@@ -245,20 +249,20 @@
       if (prop.charAt(0) == "!") {
         if (prop == "!proto") {
           base = (base instanceof infer.Obj && base.proto) || infer.ANull;
         } else {
           var fn = base.getFunctionType();
           if (!fn) {
             base = infer.ANull;
           } else if (prop == "!ret") {
-            base = fn.retval && fn.retval.getType() || infer.ANull;
+            base = fn.retval && fn.retval.getType(false) || infer.ANull;
           } else {
             var arg = fn.args && fn.args[Number(prop.slice(1))];
-            base = (arg && arg.getType()) || infer.ANull;
+            base = (arg && arg.getType(false)) || infer.ANull;
           }
         }
       } else if (base instanceof infer.Obj) {
         var propVal = (prop == "prototype" && base instanceof infer.Fn) ? base.getProp(prop) : base.props[prop];
         if (!propVal || propVal.isEmpty())
           base = infer.ANull;
         else
           base = propVal.types[0];
@@ -273,17 +277,17 @@
   function emptyObj(ctor) {
     var empty = Object.create(ctor.prototype);
     empty.props = Object.create(null);
     empty.isShell = true;
     return empty;
   }
 
   function isSimpleAnnotation(spec) {
-    if (!spec["!type"] || /^fn\(/.test(spec["!type"])) return false;
+    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
     for (var prop in spec)
       if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
         return false;
     return true;
   }
 
   function passOne(base, spec, path) {
     if (!base) {
@@ -299,17 +303,17 @@
       }
       base.name = path;
     }
 
     for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
       var inner = spec[name];
       if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
       var prop = base.defProp(name);
-      passOne(prop.getType(), inner, path ? path + "." + name : name).propagate(prop);
+      passOne(prop.getType(false), inner, path ? path + "." + name : name).propagate(prop);
     }
     return base;
   }
 
   function passTwo(base, spec, path) {
     if (base.isShell) {
       delete base.isShell;
       var tp = spec["!type"];
@@ -323,26 +327,26 @@
 
     var effects = spec["!effects"];
     if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
       parseEffect(effects[i], base);
     copyInfo(spec, base);
 
     for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
       var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
-      var type = known.getType();
+      var type = known.getType(false);
       if (typeof inner == "string") {
         if (type) continue;
         parseType(inner, innerPath).propagate(known);
       } else {
         if (!isSimpleAnnotation(inner)) {
           passTwo(type, inner, innerPath);
         } else if (!type) {
           parseType(inner["!type"], innerPath, null, true).propagate(known);
-          type = known.getType();
+          type = known.getType(false);
           if (type instanceof infer.Obj) copyInfo(inner, type);
         } else continue;
         if (inner["!doc"]) known.doc = inner["!doc"];
         if (inner["!url"]) known.url = inner["!url"];
         if (inner["!span"]) known.span = inner["!span"];
       }
     }
   }
@@ -403,22 +407,22 @@
   // computation.
   var customFunctions = Object.create(null);
   infer.registerFunction = function(name, f) { customFunctions[name] = f; };
 
   var IsCreated = infer.constraint("created, target, spec", {
     addType: function(tp) {
       if (tp instanceof infer.Obj && this.created++ < 5) {
         var derived = new infer.Obj(tp), spec = this.spec;
-        if (spec instanceof infer.AVal) spec = spec.getType();
+        if (spec instanceof infer.AVal) spec = spec.getType(false);
         if (spec instanceof infer.Obj) for (var prop in spec.props) {
           var cur = spec.props[prop].types[0];
           var p = derived.defProp(prop);
           if (cur && cur instanceof infer.Obj && cur.props.value) {
-            var vtp = cur.props.value.getType();
+            var vtp = cur.props.value.getType(false);
             if (vtp) p.addType(vtp);
           }
         }
         this.target.addType(derived);
       }
     }
   });
 
diff --git a/toolkit/devtools/tern/infer.js b/toolkit/devtools/tern/infer.js
old mode 100644
new mode 100755
--- a/toolkit/devtools/tern/infer.js
+++ b/toolkit/devtools/tern/infer.js
@@ -114,27 +114,37 @@
     },
 
     getType: function(guess) {
       if (this.types.length == 0 && guess !== false) return this.makeupType();
       if (this.types.length == 1) return this.types[0];
       return canonicalType(this.types);
     },
 
+    computedPropType: function() {
+      if (!this.propertyOf || !this.propertyOf.hasProp("<i>")) return null;
+      var computedProp = this.propertyOf.getProp("<i>");
+      if (computedProp == this) return null;
+      return computedProp.getType();
+    },
+
     makeupType: function() {
+      var computed = this.computedPropType();
+      if (computed) return computed;
+
       if (!this.forward) return null;
       for (var i = this.forward.length - 1; i >= 0; --i) {
         var hint = this.forward[i].typeHint();
         if (hint && !hint.isEmpty()) {guessing = true; return hint;}
       }
 
       var props = Object.create(null), foundProp = null;
       for (var i = 0; i < this.forward.length; ++i) {
         var prop = this.forward[i].propHint();
-        if (prop && prop != "length" && prop != "<i>" && prop != "✖") {
+        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
           props[prop] = true;
           foundProp = prop;
         }
       }
       if (!foundProp) return null;
 
       var objs = objsWithProp(foundProp);
       if (objs) {
@@ -158,16 +168,18 @@
         this.types[i].gatherProperties(f, depth);
     },
 
     guessProperties: function(f) {
       if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
         var prop = this.forward[i].propHint();
         if (prop) f(prop, null, 0);
       }
+      var guessed = this.makeupType();
+      if (guessed) guessed.gatherProperties(f);
     }
   });
 
   function canonicalType(types) {
     var arrays = 0, fns = 0, objs = 0, prim = null;
     for (var i = 0; i < types.length; ++i) {
       var tp = types[i];
       if (tp instanceof Arr) ++arrays;
@@ -219,17 +231,18 @@
 
   var PropIsSubset = constraint("prop, target", {
     addType: function(type, weight) {
       if (type.getProp)
         type.getProp(this.prop).propagate(this.target, weight);
     },
     propHint: function() { return this.prop; },
     propagatesTo: function() {
-      return {target: this.target, pathExt: "." + this.prop};
+      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
+        return {target: this.target, pathExt: "." + this.prop};
     }
   });
 
   var PropHasSubset = exports.PropHasSubset = constraint("prop, type, originNode", {
     addType: function(type, weight) {
       if (!(type instanceof Obj)) return;
       var prop = type.defProp(this.prop, this.originNode);
       prop.origin = this.origin;
@@ -374,25 +387,27 @@
     typeHint: function() { return this.inner.typeHint(); },
     propHint: function() { return this.inner.propHint(); }
   });
 
   // TYPE OBJECTS
 
   var Type = exports.Type = function() {};
   Type.prototype = extend(ANull, {
+    constructor: Type,
     propagate: function(c, w) { c.addType(this, w); },
     hasType: function(other) { return other == this; },
     isEmpty: function() { return false; },
     typeHint: function() { return this; },
     getType: function() { return this; }
   });
 
   var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
   Prim.prototype = extend(Type.prototype, {
+    constructor: Prim,
     toString: function() { return this.name; },
     getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
     gatherProperties: function(f, depth) {
       if (this.proto) this.proto.gatherProperties(f, depth);
     }
   });
 
   var Obj = exports.Obj = function(proto, name) {
@@ -402,16 +417,17 @@
       var match = /^(.*)\.prototype$/.exec(this.proto.name);
       if (match) name = match[1];
     }
     this.name = name;
     this.maybeProps = null;
     this.origin = cx.curOrigin;
   };
   Obj.prototype = extend(Type.prototype, {
+    constructor: Obj,
     toString: function(maxDepth) {
       if (!maxDepth && this.name) return this.name;
       var props = [], etc = false;
       for (var prop in this.props) if (prop != "<i>") {
         if (props.length > 5) { etc = true; break; }
         if (maxDepth)
           props.push(prop + ": " + toString(this.props[prop].getType(), maxDepth - 1));
         else
@@ -425,40 +441,44 @@
       var found = this.props[prop];
       if (searchProto !== false)
         for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
       return found;
     },
     defProp: function(prop, originNode) {
       var found = this.hasProp(prop, false);
       if (found) {
+        if (found.maybePurge) found.maybePurge = false;
         if (originNode && !found.originNode) found.originNode = originNode;
         return found;
       }
       if (prop == "__proto__" || prop == "✖") return ANull;
 
       var av = this.maybeProps && this.maybeProps[prop];
       if (av) {
         delete this.maybeProps[prop];
         this.maybeUnregProtoPropHandler();
       } else {
         av = new AVal;
+        av.propertyOf = this;
       }
 
       this.props[prop] = av;
       av.originNode = originNode;
       av.origin = cx.curOrigin;
       this.broadcastProp(prop, av, true);
       return av;
     },
     getProp: function(prop) {
       var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
       if (found) return found;
       if (prop == "__proto__" || prop == "✖") return ANull;
-      return this.ensureMaybeProps()[prop] = new AVal;
+      var av = this.ensureMaybeProps()[prop] = new AVal;
+      av.propertyOf = this;
+      return av;
     },
     broadcastProp: function(prop, val, local) {
       if (local) {
         this.signal("addProp", prop, val);
         // If this is a scope, it shouldn't be registered
         if (!(this instanceof Scope)) registerProp(prop, this);
       }
 
@@ -524,16 +544,17 @@
   var Fn = exports.Fn = function(name, self, args, argNames, retval) {
     Obj.call(this, cx.protos.Function, name);
     this.self = self;
     this.args = args;
     this.argNames = argNames;
     this.retval = retval;
   };
   Fn.prototype = extend(Obj.prototype, {
+    constructor: Fn,
     toString: function(maxDepth) {
       if (maxDepth) maxDepth--;
       var str = "fn(";
       for (var i = 0; i < this.args.length; ++i) {
         if (i) str += ", ";
         var name = this.argNames[i];
         if (name && name != "?") str += name + ": ";
         str += toString(this.args[i].getType(), maxDepth, this);
@@ -571,16 +592,17 @@
   });
 
   var Arr = exports.Arr = function(contentType) {
     Obj.call(this, cx.protos.Array);
     var content = this.defProp("<i>");
     if (contentType) contentType.propagate(content);
   };
   Arr.prototype = extend(Obj.prototype, {
+    constructor: Arr,
     toString: function(maxDepth) {
       return "[" + toString(this.getProp("<i>").getType(), maxDepth, this) + "]";
     }
   });
 
   // THE PROPERTY REGISTRY
 
   function registerProp(prop, obj) {
@@ -631,48 +653,68 @@
 
   exports.withContext = function(context, f) {
     var old = cx;
     cx = context;
     try { return f(); }
     finally { cx = old; }
   };
 
+  exports.TimedOut = function() {
+    this.message = "Timed out";
+    this.stack = (new Error()).stack;
+  }
+  exports.TimedOut.prototype = Object.create(Error.prototype);
+  exports.TimedOut.prototype.name = "infer.TimedOut";
+
+  var timeout;
+  exports.withTimeout = function(ms, f) {
+    var end = +new Date + ms;
+    var oldEnd = timeout;
+    if (oldEnd && oldEnd < end) return f();
+    timeout = end;
+    try { return f(); }
+    finally { timeout = oldEnd; }
+  };
+
   exports.addOrigin = function(origin) {
     if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
   };
 
   var baseMaxWorkDepth = 20, reduceMaxWorkDepth = .0001;
   function withWorklist(f) {
     if (cx.workList) return f(cx.workList);
 
     var list = [], depth = 0;
     var add = cx.workList = function(type, target, weight) {
       if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
         list.push(type, target, weight, depth);
     };
     try {
       var ret = f(add);
       for (var i = 0; i < list.length; i += 4) {
+        if (timeout && +new Date >= timeout)
+          throw new exports.TimedOut();
         depth = list[i + 3] + 1;
         list[i + 1].addType(list[i], list[i + 2]);
       }
       return ret;
     } finally {
       cx.workList = null;
     }
   }
 
   // SCOPES
 
   var Scope = exports.Scope = function(prev) {
     Obj.call(this, prev || true);
     this.prev = prev;
   };
   Scope.prototype = extend(Obj.prototype, {
+    constructor: Scope,
     defVar: function(name, originNode) {
       for (var s = this; ; s = s.proto) {
         var found = s.props[name];
         if (found) return found;
         if (!s.prev) return s.defProp(name, originNode);
       }
     }
   });
@@ -712,18 +754,19 @@
     for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
     fn.self = new AVal;
     fn.computeRet = function(self, args) {
       // Prevent recursion
       return withDisabledComputing(fn, function() {
         var oldOrigin = cx.curOrigin;
         cx.curOrigin = fn.origin;
         var scopeCopy = new Scope(scope.prev);
+        scopeCopy.originNode = scope.originNode;
         for (var v in scope.props) {
-          var local = scopeCopy.defProp(v);
+          var local = scopeCopy.defProp(v, scope.props[v].originNode);
           for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
             args[i].propagate(local);
         }
         var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
         while (argNames.length < args.length) argNames.push("?");
         scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull);
         if (fn.arguments) {
           var argset = scopeCopy.fnType.arguments = new AVal;
@@ -775,25 +818,23 @@
       fn.computeRetSource = foundPath;
       return true;
     }
   }
 
   // SCOPE GATHERING PASS
 
   function addVar(scope, nameNode) {
-    var val = scope.defProp(nameNode.name, nameNode);
-    if (val.maybePurge) val.maybePurge = false;
-    return val;
+    return scope.defProp(nameNode.name, nameNode);
   }
 
   var scopeGatherer = walk.make({
     Function: function(node, scope, c) {
       var inner = node.body.scope = new Scope(scope);
-      inner.node = node;
+      inner.originNode = node;
       var argVals = [], argNames = [];
       for (var i = 0; i < node.params.length; ++i) {
         var param = node.params[i];
         argNames.push(param.name);
         argVals.push(addVar(inner, param));
       }
       inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull);
       inner.fnType.originNode = node;
@@ -1070,20 +1111,23 @@
       for (var i = 0; i < node.declarations.length; ++i) {
         var decl = node.declarations[i], prop = scope.getProp(decl.id.name);
         if (decl.init)
           infer(decl.init, scope, c, prop, decl.id.name);
       }
     },
 
     ReturnStatement: function(node, scope, c) {
-      if (node.argument && scope.fnType) {
+      if (!node.argument) return;
+      var output = ANull;
+      if (scope.fnType) {
         if (scope.fnType.retval == ANull) scope.fnType.retval = new AVal;
-        infer(node.argument, scope, c, scope.fnType.retval);
+        output = scope.fnType.retval;
       }
+      infer(node.argument, scope, c, output);
     },
 
     ForInStatement: function(node, scope, c) {
       var source = infer(node.right, scope, c);
       if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
           (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
         maybeInstantiate(scope, 5);
         var varName;
@@ -1181,16 +1225,17 @@
         f.purge(test);
       }
     }
   };
   ANull.purge = function() {};
   Obj.prototype.purge = function(test) {
     if (this.purgeGen == cx.purgeGen) return true;
     this.purgeGen = cx.purgeGen;
+    var props = [];
     for (var p in this.props) {
       var av = this.props[p];
       if (test(av, av.originNode))
         this.removeProp(p);
       av.purge(test);
     }
   };
   Fn.prototype.purge = function(test) {
diff --git a/toolkit/devtools/tern/signal.js b/toolkit/devtools/tern/signal.js
old mode 100644
new mode 100755
diff --git a/toolkit/devtools/tern/tern.js b/toolkit/devtools/tern/tern.js
old mode 100644
new mode 100755
--- a/toolkit/devtools/tern/tern.js
+++ b/toolkit/devtools/tern/tern.js
@@ -12,23 +12,24 @@
     return define(["exports", "./infer", "./signal", "acorn/acorn", "acorn/util/walk"], mod);
   mod(self.tern || (self.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
 })(function(exports, infer, signal, acorn, walk) {
   "use strict";
 
   var plugins = Object.create(null);
   exports.registerPlugin = function(name, init) { plugins[name] = init; };
 
-  var defaultOptions = {
+  var defaultOptions = exports.defaultOptions = {
     debug: false,
     async: false,
     getFile: function(_f, c) { if (this.async) c(null, null); },
     defs: [],
     plugins: {},
-    fetchTimeout: 1000
+    fetchTimeout: 1000,
+    dependencyBudget: 20000
   };
 
   var queryTypes = {
     completions: {
       takesFile: true,
       run: findCompletions
     },
     properties: {
@@ -58,36 +59,39 @@
     },
     files: {
       run: listFiles
     }
   };
 
   exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };
 
-  function File(name) {
+  function File(name, parent) {
     this.name = name;
+    this.parent = parent;
     this.scope = this.text = this.ast = this.lineOffsets = null;
   }
   File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };
 
   function updateText(file, text, srv) {
     file.text = text;
-    file.ast = infer.parse(text, srv.passes, {directSourceFile: file});
+    file.ast = infer.parse(text, srv.passes, {directSourceFile: file, allowReturnOutsideFunction: true});
     file.lineOffsets = null;
   }
 
   var Server = exports.Server = function(options) {
     this.cx = null;
     this.options = options || {};
     for (var o in defaultOptions) if (!options.hasOwnProperty(o))
       options[o] = defaultOptions[o];
 
     this.handlers = Object.create(null);
     this.files = [];
+    this.fileMap = Object.create(null);
+    this.budgets = Object.create(null);
     this.uses = 0;
     this.pending = 0;
     this.asyncError = null;
     this.passes = Object.create(null);
 
     this.defs = options.defs.slice(0);
     for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin) && plugin in plugins) {
       var init = plugins[plugin](this, options.plugins[plugin]);
@@ -97,57 +101,61 @@
       }
       if (init && init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
         (this.passes[type] || (this.passes[type] = [])).push(init.passes[type]);
     }
 
     this.reset();
   };
   Server.prototype = signal.mixin({
-    addFile: function(name, /*optional*/ text) {
-      ensureFile(this, name, text);
+    addFile: function(name, /*optional*/ text, parent) {
+      // Don't crash when sloppy plugins pass non-existent parent ids
+      if (parent && !parent in this.fileMap) parent = null;
+      ensureFile(this, name, parent, text);
     },
     delFile: function(name) {
       for (var i = 0, f; i < this.files.length; ++i) if ((f = this.files[i]).name == name) {
-        clearFile(this, f);
+        clearFile(this, f, null, true);
         this.files.splice(i--, 1);
+        delete this.fileMap[name];
         return;
       }
     },
     reset: function() {
       this.signal("reset");
       this.cx = new infer.Context(this.defs, this);
       this.uses = 0;
+      this.budgets = Object.create(null);
       for (var i = 0; i < this.files.length; ++i) {
         var file = this.files[i];
         file.scope = null;
       }
     },
 
     request: function(doc, c) {
       var inv = invalidDoc(doc);
       if (inv) return c(inv);
 
       var self = this;
       doRequest(this, doc, function(err, data) {
         c(err, data);
         if (self.uses > 40) {
           self.reset();
-          analyzeAll(self, function(){});
+          analyzeAll(self, null, function(){});
         }
       });
     },
 
     findFile: function(name) {
-      return findFile(this.files, name);
+      return this.fileMap[name];
     },
 
     flush: function(c) {
       var cx = this.cx;
-      analyzeAll(this, function(err) {
+      analyzeAll(this, null, function(err) {
         if (err) return c(err);
         infer.withContext(cx, c);
       });
     },
 
     startAsyncAction: function() {
       ++this.pending;
     },
@@ -164,91 +172,100 @@
     var query = doc.query;
     // Respond as soon as possible when this just uploads files
     if (!query) c(null, {});
 
     var files = doc.files || [];
     if (files.length) ++srv.uses;
     for (var i = 0; i < files.length; ++i) {
       var file = files[i];
-      ensureFile(srv, file.name, file.type == "full" ? file.text : null);
+      ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
     }
 
+    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
     if (!query) {
-      analyzeAll(srv, function(){});
+      analyzeAll(srv, timeBudget, function(){});
       return;
     }
 
     var queryType = queryTypes[query.type];
     if (queryType.takesFile) {
       if (typeof query.file != "string") return c(".query.file must be a string");
-      if (!/^#/.test(query.file)) ensureFile(srv, query.file);
+      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
     }
 
-    analyzeAll(srv, function(err) {
+    analyzeAll(srv, timeBudget, function(err) {
       if (err) return c(err);
       var file = queryType.takesFile && resolveFile(srv, files, query.file);
       if (queryType.fullFile && file.type == "part")
         return c("Can't run a " + query.type + " query on a file fragment");
 
-      infer.withContext(srv.cx, function() {
+      function run() {
         var result;
         try {
           result = queryType.run(srv, query, file);
         } catch (e) {
           if (srv.options.debug && e.name != "TernError") console.error(e.stack);
           return c(e);
         }
         c(null, result);
-      });
+      }
+      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
     });
   }
 
   function analyzeFile(srv, file) {
     infer.withContext(srv.cx, function() {
       file.scope = srv.cx.topScope;
       srv.signal("beforeLoad", file);
       infer.markVariablesDefinedBy(file.scope, file.name);
       infer.analyze(file.ast, file.name, file.scope, srv.passes);
       infer.purgeMarkedVariables(file.scope);
       srv.signal("afterLoad", file);
     });
     return file;
   }
 
-  function ensureFile(srv, name, text) {
-    var known = findFile(srv.files, name);
+  function ensureFile(srv, name, parent, text) {
+    var known = srv.findFile(name);
     if (known) {
-      if (text) clearFile(srv, known, text);
+      if (text != null) clearFile(srv, known, text);
+      if (parentDepth(known.parent) > parentDepth(parent)) {
+        known.parent = parent;
+        if (known.excluded) known.excluded = null;
+      }
       return;
     }
 
-    var file = new File(name);
+    var file = new File(name, parent);
     srv.files.push(file);
-    if (text) {
+    srv.fileMap[name] = file;
+    if (text != null) {
       updateText(file, text, srv);
     } else if (srv.options.async) {
       srv.startAsyncAction();
       srv.options.getFile(name, function(err, text) {
         updateText(file, text || "", srv);
         srv.finishAsyncAction(err);
       });
     } else {
       updateText(file, srv.options.getFile(name) || "", srv);
     }
   }
 
-  function clearFile(srv, file, newText) {
+  function clearFile(srv, file, newText, purgeVars) {
     if (file.scope) {
       infer.withContext(srv.cx, function() {
         // FIXME try to batch purges into a single pass (each call needs
         // to traverse the whole graph)
         infer.purgeTypes(file.name);
-        infer.markVariablesDefinedBy(file.scope, file.name);
-        infer.purgeMarkedVariables(file.scope);
+        if (purgeVars) {
+          infer.markVariablesDefinedBy(file.scope, file.name);
+          infer.purgeMarkedVariables(file.scope);
+        }
       });
       file.scope = null;
     }
     if (newText != null) updateText(file, newText, srv);
   }
 
   function fetchAll(srv, c) {
     var done = true, returned = false;
@@ -266,47 +283,58 @@
         try {
           updateText(file, srv.options.getFile(file.name) || "", srv);
         } catch (e) { return c(e); }
       }
     }
     if (done) c();
   }
 
-  function waitOnFetch(srv, c) {
+  function waitOnFetch(srv, timeBudget, c) {
     var done = function() {
       srv.off("everythingFetched", done);
       clearTimeout(timeout);
-      analyzeAll(srv, c);
+      analyzeAll(srv, timeBudget, c);
     };
     srv.on("everythingFetched", done);
     var timeout = setTimeout(done, srv.options.fetchTimeout);
   }
 
-  function analyzeAll(srv, c) {
-    if (srv.pending) return waitOnFetch(srv, c);
+  function analyzeAll(srv, timeBudget, c) {
+    if (srv.pending) return waitOnFetch(srv, timeBudget, c);
 
     var e = srv.fetchError;
     if (e) { srv.fetchError = null; return c(e); }
 
     var done = true;
-    for (var i = 0; i < srv.files.length; ++i) {
-      var file = srv.files[i];
-      if (file.text == null) done = false;
-      else if (file.scope == null) analyzeFile(srv, file);
+    // The second inner loop might add new files. The outer loop keeps
+    // repeating both inner loops until all files have been looked at.
+    for (var i = 0; i < srv.files.length;) {
+      var toAnalyze = [];
+      for (; i < srv.files.length; ++i) {
+        var file = srv.files[i];
+        if (file.text == null) done = false;
+        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
+      }
+      toAnalyze.sort(function(a, b) { return parentDepth(a.parent) - parentDepth(b.parent); });
+      for (var j = 0; j < toAnalyze.length; j++) {
+        var file = toAnalyze[j];
+        if (file.parent && !chargeOnBudget(srv, file)) {
+          file.excluded = true;
+        } else if (timeBudget) {
+          var startTime = +new Date;
+          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
+          timeBudget[0] -= +new Date - startTime;
+        } else {
+          analyzeFile(srv, file);
+        }
+      }
     }
     if (done) c();
-    else waitOnFetch(srv, c);
-  }
-
-  function findFile(arr, name) {
-    for (var i = 0; i < arr.length; ++i) {
-      var file = arr[i];
-      if (file.name == name && file.type != "part") return file;
-    }
+    else waitOnFetch(srv, timeBudget, c);
   }
 
   function firstLine(str) {
     var end = str.indexOf("\n");
     if (end < 0) return str;
     return str.slice(0, end);
   }
 
@@ -330,25 +358,25 @@
   function ternError(msg) {
     var err = new Error(msg);
     err.name = "TernError";
     return err;
   }
 
   function resolveFile(srv, localFiles, name) {
     var isRef = name.match(/^#(\d+)$/);
-    if (!isRef) return findFile(srv.files, name);
+    if (!isRef) return srv.findFile(name);
 
     var file = localFiles[isRef[1]];
     if (!file) throw ternError("Reference to unknown file " + name);
-    if (file.type == "full") return findFile(srv.files, file.name);
+    if (file.type == "full") return srv.findFile(file.name);
 
     // This is a partial file
 
-    var realFile = file.backing = findFile(srv.files, file.name);
+    var realFile = file.backing = srv.findFile(file.name);
     var offset = file.offset;
     if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
     file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
     var line = firstLine(file.text);
     var foundPos = findMatchingPosition(line, realFile.text, offset);
     var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
 
     infer.withContext(srv.cx, function() {
@@ -366,17 +394,17 @@
         text = white + text.slice(cut);
         var atFunction = true;
       }
 
       var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
       var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
       var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
       infer.markVariablesDefinedBy(scopeStart, file.name, pos, pos + file.text.length);
-      file.ast = infer.parse(file.text, srv.passes, {directSourceFile: file});
+      file.ast = infer.parse(file.text, srv.passes, {directSourceFile: file, allowReturnOutsideFunction: true});
       infer.analyze(file.ast, file.name, scope, srv.passes);
       infer.purgeMarkedVariables(scopeStart);
 
       // This is a kludge to tie together the function types (if any)
       // outside and inside of the fragment, so that arguments and
       // return values have some information known about them.
       tieTogether: if (inObject || atFunction) {
         var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
@@ -394,16 +422,55 @@
           fOld.self.propagate(fNew.self);
           fNew.retval.propagate(fOld.retval);
         }
       }
     });
     return file;
   }
 
+  // Budget management
+
+  function astSize(node) {
+    var size = 0;
+    walk.simple(node, {Expression: function() { ++size; }});
+    return size;
+  }
+
+  function parentDepth(srv, parent) {
+    var depth = 0;
+    while (parent) {
+      parent = srv.findFile(parent).parent;
+      ++depth;
+    }
+    return depth;
+  }
+
+  function budgetName(srv, file) {
+    for (;;) {
+      var parent = srv.findFile(file.parent);
+      if (!parent.parent) break;
+      file = parent;
+    }
+    return file.name;
+  }
+
+  function chargeOnBudget(srv, file) {
+    var bName = budgetName(srv, file);
+    var size = astSize(file.ast);
+    var known = srv.budgets[bName];
+    if (known == null)
+      known = srv.budgets[bName] = srv.options.dependencyBudget;
+    if (known < size) return false;
+    srv.budgets[bName] = known - size;
+    return true;
+  }
+
+  // Query helpers
+
   function isPosition(val) {
     return typeof val == "number" || typeof val == "object" &&
       typeof val.line == "number" && typeof val.ch == "number";
   }
 
   // Baseline query document validation
   function invalidDoc(doc) {
     if (doc.query) {
@@ -506,16 +573,20 @@
     else return aUp ? 1 : -1;
   }
 
   function isStringAround(node, start, end) {
     return node.type == "Literal" && typeof node.value == "string" &&
       node.start == start - 1 && node.end <= end + 1;
   }
 
+  var jsKeywords = ("break do instanceof typeof case else new var " +
+    "catch finally return void continue for switch while debugger " +
+    "function this with default if throw delete in try").split(" ");
+
   function findCompletions(srv, query, file) {
     if (query.end == null) throw ternError("missing .query.end field");
     var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
     while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
     if (query.expandWordForward !== false)
       while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
     var word = text.slice(wordStart, wordEnd), completions = [];
     if (query.caseInsensitive) word = word.toLowerCase();
@@ -547,36 +618,44 @@
           maybeSet(rec, "url", val.url || type && type.url);
         if (query.origins)
           maybeSet(rec, "origin", val.origin || type && type.origin);
       }
       if (query.depths) rec.depth = depth;
     }
 
     var memberExpr = infer.findExpressionAround(file.ast, null, wordStart, file.scope, "MemberExpression");
+    var hookname;
     if (memberExpr &&
         (memberExpr.node.computed ? isStringAround(memberExpr.node.property, wordStart, wordEnd)
                                   : memberExpr.node.object.end < wordStart)) {
       var prop = memberExpr.node.property;
       prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
+      srv.cx.completingProperty = prop;
 
       memberExpr.node = memberExpr.node.object;
       var tp = infer.expressionType(memberExpr);
       if (tp) infer.forAllPropertiesOf(tp, gather);
 
       if (!completions.length && query.guess !== false && tp && tp.guessProperties) {
         tp.guessProperties(function(p, o, d) {if (p != prop && p != "✖") gather(p, o, d);});
       }
       if (!completions.length && word.length >= 2 && query.guess !== false)
         for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
+      hookname = "memberCompletion";
     } else {
       infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
+      if (query.includeKeywords) jsKeywords.forEach(function(kw) { gather(kw, null, 0); });
+      hookname = "completion";
     }
+    if (srv.passes[hookname])
+      srv.passes[hookname].forEach(function(hook) {hook(file, wordStart, wordEnd, gather);});
 
     if (query.sort !== false) completions.sort(compareCompletions);
+    srv.cx.completingProperty = null;
 
     return {start: outputPos(query, file, wordStart),
             end: outputPos(query, file, wordEnd),
             completions: completions};
   }
 
   function findProperties(srv, query) {
     var prefix = query.prefix, found = [];
@@ -663,17 +742,17 @@
 
   var storeSpan = exports.storeSpan = function(srv, query, span, target) {
     target.origin = span.origin;
     if (span.span) {
       var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
       target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
       target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
     } else {
-      var file = findFile(srv.files, span.origin);
+      var file = srv.findFile(span.origin);
       target.start = outputPos(query, file, span.node.start);
       target.end = outputPos(query, file, span.node.end);
     }
   };
 
   function findDef(srv, query, file) {
     var expr = findExpr(file, query);
     infer.resetGuessing();
@@ -685,17 +764,17 @@
 
     if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
       var tp = type.types[i];
       storeTypeDocs(tp, result);
       if (!span) span = getSpan(tp);
     }
 
     if (span && span.node) { // refers to a loaded file
-      var spanFile = span.node.sourceFile || findFile(srv.files, span.origin);
+      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
       var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
       result.start = start; result.end = end;
       result.file = span.origin;
       var cxStart = Math.max(0, span.node.start - 50);
       result.contextOffset = span.node.start - cxStart;
       result.context = spanFile.text.slice(cxStart, cxStart + 50);
     } else if (span) { // external
       result.file = span.origin;
@@ -721,27 +800,27 @@
                             (asLineChar(file, exists.name.start).line + 1));
         }
         refs.push({file: file.name,
                    start: outputPos(query, file, node.start),
                    end: outputPos(query, file, node.end)});
       };
     }
 
-    if (scope.node) {
+    if (scope.originNode) {
       type = "local";
       if (checkShadowing) {
         for (var prev = scope.prev; prev; prev = prev.prev)
           if (checkShadowing in prev.props) break;
-        if (prev) infer.findRefs(scope.node, scope, checkShadowing, prev, function(node) {
+        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
           throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
                           (asLineChar(file, node.start).line + 1));
         });
       }
-      infer.findRefs(scope.node, scope, name, scope, storeRef(file));
+      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
     } else {
       type = "global";
       for (var i = 0; i < srv.files.length; ++i) {
         var cur = srv.files[i];
         infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
       }
     }
 
@@ -805,10 +884,10 @@
 
     return data;
   }
 
   function listFiles(srv) {
     return {files: srv.files.map(function(f){return f.name;})};
   }
 
-  exports.version = "0.5.1";
+  exports.version = "0.6.2";
 });
