# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  154931ca3b074a5bdb9bd7465bf1f1b98ff52aa3

diff --git a/accessible/html/HTMLFormControlAccessible.cpp b/accessible/html/HTMLFormControlAccessible.cpp
--- a/accessible/html/HTMLFormControlAccessible.cpp
+++ b/accessible/html/HTMLFormControlAccessible.cpp
@@ -221,17 +221,17 @@ HTMLTextFieldAccessible::NativeAttribute
   // Expose type for text input elements as it gives some useful context,
   // especially for mobile.
   nsAutoString type;
   // In the case of this element being part of a binding, the binding's
   // parent's type should have precedence. For example an input[type=number]
   // has an embedded anonymous input[type=text] (along with spinner buttons).
   // In that case, we would want to take the input type from the parent
   // and not the anonymous content.
-  nsIContent* widgetElm = BindingParent();
+  nsIContent* widgetElm = BindingOrWidgetParent();
   if ((widgetElm && widgetElm->AsElement()->GetAttr(kNameSpaceID_None,
                                                     nsGkAtoms::type, type)) ||
       mContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::type,
                                      type)) {
     nsAccUtils::SetAccAttr(attributes, nsGkAtoms::textInputType, type);
     if (!ARIARoleMap() && type.EqualsLiteral("search")) {
       nsAccUtils::SetAccAttr(attributes, nsGkAtoms::xmlroles,
                              NS_LITERAL_STRING("searchbox"));
@@ -254,17 +254,17 @@ HTMLTextFieldAccessible::NativeAttribute
   return attributes.forget();
 }
 
 ENameValueFlag HTMLTextFieldAccessible::NativeName(nsString& aName) const {
   ENameValueFlag nameFlag = Accessible::NativeName(aName);
   if (!aName.IsEmpty()) return nameFlag;
 
   // If part of compound of XUL widget then grab a name from XUL widget element.
-  nsIContent* widgetElm = BindingParent();
+  nsIContent* widgetElm = BindingOrWidgetParent();
   if (widgetElm) XULElmName(mDoc, widgetElm, aName);
 
   if (!aName.IsEmpty()) return eNameOK;
 
   // text inputs and textareas might have useful placeholder text
   mContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::placeholder,
                                  aName);
   return eNameOK;
@@ -290,17 +290,17 @@ void HTMLTextFieldAccessible::Value(nsSt
 }
 
 void HTMLTextFieldAccessible::ApplyARIAState(uint64_t* aState) const {
   HyperTextAccessibleWrap::ApplyARIAState(aState);
   aria::MapToState(aria::eARIAAutoComplete, mContent->AsElement(), aState);
 
   // If part of compound of XUL widget then pick up ARIA stuff from XUL widget
   // element.
-  nsIContent* widgetElm = BindingParent();
+  nsIContent* widgetElm = BindingOrWidgetParent();
   if (widgetElm)
     aria::MapToState(aria::eARIAAutoComplete, widgetElm->AsElement(), aState);
 }
 
 uint64_t HTMLTextFieldAccessible::NativeState() const {
   uint64_t state = HyperTextAccessibleWrap::NativeState();
 
   // Text fields are always editable, even if they are also read only or
@@ -333,17 +333,17 @@ uint64_t HTMLTextFieldAccessible::Native
     return state;
   }
 
   // Expose autocomplete state if it has associated autocomplete list.
   if (mContent->AsElement()->HasAttr(kNameSpaceID_None, nsGkAtoms::list_))
     return state | states::SUPPORTS_AUTOCOMPLETION | states::HASPOPUP;
 
   // Ordinal XUL textboxes don't support autocomplete.
-  if (!BindingParent() && Preferences::GetBool("browser.formfill.enable")) {
+  if (!BindingOrWidgetParent() && Preferences::GetBool("browser.formfill.enable")) {
     // Check to see if autocompletion is allowed on this input. We don't expose
     // it for password fields even though the entire password can be remembered
     // for a page if the user asks it to be. However, the kind of autocomplete
     // we're talking here is based on what the user types, where a popup of
     // possible choices comes up.
     nsAutoString autocomplete;
     mContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::autocomplete,
                                    autocomplete);
diff --git a/accessible/html/HTMLFormControlAccessible.h b/accessible/html/HTMLFormControlAccessible.h
--- a/accessible/html/HTMLFormControlAccessible.h
+++ b/accessible/html/HTMLFormControlAccessible.h
@@ -93,19 +93,29 @@ class HTMLTextFieldAccessible final : pu
 
  protected:
   virtual ~HTMLTextFieldAccessible() {}
 
   // Accessible
   virtual ENameValueFlag NativeName(nsString& aName) const override;
 
   /**
-   * Return a XUL widget element this input is part of.
+   * Return a XUL widget element this input is part of, either native
+   * anonymous content, XBL content, or a XUL Custom Element.
    */
-  nsIContent* BindingParent() const { return mContent->GetBindingParent(); }
+  nsIContent* BindingOrWidgetParent() const {
+    if (mContent->GetBindingParent()) {
+      return mContent->GetBindingParent();
+    }
+    // XXX: Do this better.
+    if (mContent->GetParent() && mContent->GetParent()->GetParent() && mContent->GetParent()->GetParent()->IsXULElement(nsGkAtoms::textbox)) {
+      return mContent->GetParent()->GetParent();
+    }
+    return null;
+  }
 };
 
 /**
  * Accessible for input@type="file" element.
  */
 class HTMLFileInputAccessible : public HyperTextAccessibleWrap {
  public:
   HTMLFileInputAccessible(nsIContent* aContent, DocAccessible* aDoc);
