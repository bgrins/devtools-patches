
# HG changeset patch
# User Nicolas Chevobbe <nchevobbe@mozilla.com>
# Date 1501610364 -7200
# Node ID ea076d7c7e8f778fe0fcf7fe1c5b5e22e3e736a8
# Parent  51ffb9283f0c7c00e08eb8c39b33fbee218c370d
Bug 1386221 - Fix test for inspect binding on 56. r=bgrins.

The test was failing on 56 because the new console frontend isn't enabled there and thus
the ObjectInspector that we were testing are not in the old frontend.
This patch adds a branch in the test so we can wait for the correct element (VariableView or ObjectInspector)
either the new console frontend is enabled or not.

MozReview-Commit-ID: HGGgr7CWMpe

diff --git a/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js b/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
--- a/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
+++ b/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
@@ -116,31 +116,44 @@
   info("Wait for the toolbox to switch to the inspector and the expected node has been selected");
   await inspectorPanelSelectedPromise;
   info("Toolbox has been switched to the inspector as expected");
 
   info("Test inspectedWindow.eval inspect() binding called for a JS object");
 
   const splitPanelOpenedPromise = (async () => {
     await toolbox.once("split-console");
-    let jsterm = toolbox.getPanel("webconsole").hud.jsterm;
+    const {hud} = toolbox.getPanel("webconsole");
+    let {jsterm} = hud;
 
-    // Wait for the message to appear on the console.
-    const messageNode = await new Promise(resolve => {
-      jsterm.hud.on("new-messages", function onThisMessage(e, messages) {
-        for (let m of messages) {
-          resolve(m.node);
-          jsterm.hud.off("new-messages", onThisMessage);
-          return;
-        }
+    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1386221.
+    if (hud.NEW_CONSOLE_OUTPUT_ENABLED === true) {
+      // Wait for the message to appear on the console.
+      const messageNode = await new Promise(resolve => {
+        jsterm.hud.on("new-messages", function onThisMessage(e, messages) {
+          for (let m of messages) {
+            resolve(m.node);
+            jsterm.hud.off("new-messages", onThisMessage);
+            return;
+          }
+        });
       });
-    });
+      let objectInspectors = [...messageNode.querySelectorAll(".tree")];
+      is(objectInspectors.length, 1, "There is the expected number of object inspectors");
+    } else {
+      const options = await new Promise(resolve => {
+        jsterm.once("variablesview-open", (evt, view, options) => resolve(options));
+      });
 
-    let objectInspectors = [...messageNode.querySelectorAll(".tree")];
-    is(objectInspectors.length, 1, "There is the expected number of object inspectors");
+      const objectType = options.objectActor.type;
+      const objectPreviewProperties = options.objectActor.preview.ownProperties;
+      is(objectType, "object", "The inspected object has the expected type");
+      Assert.deepEqual(Object.keys(objectPreviewProperties), ["testkey"],
+                        "The inspected object has the expected preview properties");
+    }
   })();
 
   const inspectJSObjectPromise = extension.awaitMessage(`inspectedWindow-eval-result`);
   extension.sendMessage(`inspectedWindow-eval-request`, "inspect({testkey: 'testvalue'})");
   await inspectJSObjectPromise;
 
   info("Wait for the split console to be opened and the JS object inspected");
   await splitPanelOpenedPromise;

