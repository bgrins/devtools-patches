# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1553628413 25200
#      Tue Mar 26 12:26:53 2019 -0700
# Node ID ff1d6a5608e00765dce1ef9650a1e2ffac675fb6
# Parent  e31357c7759379d2279b6883cb09c91997bfaa5d
Bug 1515799 - POC - Instrument base custom element class and print call information in a table at startup

This isn't intended to land, just a demonstration of a way we could get more insight into how much
time we are spending inside of individual classes.

Differential Revision: https://phabricator.services.mozilla.com/D24953

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -13,18 +13,148 @@
 (() => {
 // Handle customElements.js being loaded as a script in addition to the subscriptLoader
 // from MainProcessSingleton, to handle pages that can open both before and after
 // MainProcessSingleton starts. See Bug 1501845.
 if (window.MozXULElement) {
   return;
 }
 
+const MozElements = {};
+window.MozElements = MozElements;
+
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
+const instrumentClasses = true; // Flip this to get logging for perf data at startup
+const instrumentedClasses = new Set();
+const baseClasses = new WeakSet();
+
+// Wrap the normal customElements.define to give us a chance to modify the
+// class so we can instrument function calls in local development:
+let define = window.customElements.define;
+window.customElements.define = function(name, c, opts) {
+  instrumentCustomElementClass(c);
+  return define.call(this, name, c, opts);
+};
+
+MozElements.printInstrumentation = function(collapsed) {
+  if (instrumentedClasses.size) {
+    let groupName = `Instrumentation data for custom elements in ${document.documentURI}`;
+    console[collapsed ? "groupCollapsed" : "group"](groupName);
+    for (let c of instrumentedClasses) {
+      let stats = c.stats;
+      if (stats) {
+        console.log(`${c.name}`);
+        console.table(stats);
+      }
+    }
+    console.groupEnd(groupName);
+  }
+};
+
+function instrumentCustomElementClass(c) {
+  if (!instrumentClasses) {
+    return;
+  }
+
+  // Climb up prototype chain to see if we inherit from a MozElement.
+  // Keep track of classes to instrument, for example:
+  //   MozMenuCaption->MozMenuBase->BaseText->BaseControl->MozXULElement
+  let inheritsFromBase = baseClasses.has(c);
+  let classesToInstrument = [c];
+  let proto = Object.getPrototypeOf(c);
+  while (proto) {
+    classesToInstrument.push(proto);
+    if (baseClasses.has(proto)) {
+      inheritsFromBase = true;
+      break;
+    }
+    proto = Object.getPrototypeOf(proto);
+  }
+
+  if (inheritsFromBase) {
+    for (let c of classesToInstrument.reverse()) {
+      instrumentIndividualClass(c);
+    }
+  }
+}
+
+function instrumentIndividualClass(c) {
+  if (instrumentedClasses.has((c))) {
+    return;
+  }
+  instrumentedClasses.add((c));
+  let data = {};
+
+  function wrapFunction(name, fn) {
+    return function() {
+      if (!data[name]) {
+        data[name] = {time: 0, calls: 0};
+      }
+      data[name].calls++;
+      let n = performance.now();
+      let r = fn.apply(this, arguments);
+      data[name].time += performance.now() - n;
+      return r;
+    };
+  }
+  function wrapPropertyDescriptor(obj, name) {
+    if (name == "constructor") {
+      return;
+    }
+    let prop = Object.getOwnPropertyDescriptor(obj, name);
+    if (prop.get) {
+      prop.get = wrapFunction(`<get> ${name}`, prop.get);
+    }
+    if (prop.set) {
+      prop.set = wrapFunction(`<set> ${name}`, prop.set);
+    }
+    if (prop.writable && prop.value && prop.value.apply) {
+      prop.value = wrapFunction(name, prop.value);
+    }
+    Object.defineProperty(obj, name, prop);
+  }
+
+  // Handle static properties
+  for (let name of Object.getOwnPropertyNames((c))) {
+    wrapPropertyDescriptor(c, name);
+  }
+
+  // Handle instance properties
+
+  for (let name of Object.getOwnPropertyNames(c.prototype)) {
+    wrapPropertyDescriptor(c.prototype, name);
+  }
+
+  Object.defineProperty(c, "stats", {
+    enumerable: false,
+    configurable: false,
+    get() {
+      if (!Object.keys(data).length) {
+        return null;
+      }
+
+      let clonedData = JSON.parse(JSON.stringify(data));
+      let totalCalls = 0;
+      let totalTime = 0;
+      for (let d in clonedData) {
+        let {time, calls} = clonedData[d];
+        totalCalls += calls;
+        totalTime += time;
+        clonedData[d]["time (ms)"] = time;
+        delete clonedData[d].time;
+        clonedData[d].timePerCall = time / calls;
+      }
+
+      // Add a spaced-out final row with summed up totals
+      clonedData["\ntotals"]  = { "time (ms)": `\n${totalTime}`, calls: `\n${totalCalls}`, timePerCall: `\n${totalTime / totalCalls}` };
+      return clonedData;
+    },
+  });
+}
 
 // The listener of DOMContentLoaded must be set on window, rather than
 // document, because the window can go away before the event is fired.
 // In that case, we don't want to initialize anything, otherwise we
 // may be leaking things because they will never be destroyed after.
 let gIsDOMContentLoaded = false;
 const gElementsPendingConnection = new Set();
 window.addEventListener("DOMContentLoaded", () => {
@@ -34,24 +164,24 @@ window.addEventListener("DOMContentLoade
       if (element.isConnected) {
         element.isRunningDelayedConnectedCallback = true;
         element.connectedCallback();
       }
     } catch (ex) { console.error(ex); }
     element.isRunningDelayedConnectedCallback = false;
   }
   gElementsPendingConnection.clear();
+  MozElements.printInstrumentation(true);
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
-const MozElements = {};
-
-MozElements.MozElementMixin = Base => class MozElement extends Base {
+MozElements.MozElementMixin = Base => {
+  let MozElementBase = class extends Base {
   /*
    * A declarative way to wire up attribute inheritance and automatically generate
    * the `observedAttributes` getter.  For example, if you returned:
    *    {
    *      ".foo": "bar,baz=bat"
    *    }
    *
    * Then the base class will automatically return ["bar", "bat"] from `observedAttributes`,
@@ -110,16 +240,17 @@ MozElements.MozElementMixin = Base => cl
   *   this.initializeAttributeInheritance();
   *
   */
   initializeAttributeInheritance() {
     let {inheritedAttributes} = this.constructor;
     if (!inheritedAttributes) {
       return;
     }
+
     this._inheritedAttributesValuesCache = null;
     this.inheritedAttributesCache = new Map();
     for (let selector in inheritedAttributes) {
       let parent = this.shadowRoot || this;
       let el = parent.querySelector(selector);
       // Skip unmatched selectors in case an element omits some elements in certain cases:
       if (!el) {
         continue;
@@ -367,16 +498,22 @@ MozElements.MozElementMixin = Base => cl
     cls.prototype.QueryInterface = ChromeUtils.generateQI(ifaces);
     cls.prototype.getCustomInterfaceCallback = function getCustomInterfaceCallback(ifaceToCheck) {
       if (cls.prototype.customInterfaces.some(iface => iface.equals(ifaceToCheck))) {
         return getInterfaceProxy(this);
       }
       return null;
     };
   }
+  };
+
+  // Rename the class so we can distinguish between MozXULElement and MozXULPopupElement, for example.
+  Object.defineProperty(MozElementBase, "name", {value: `Moz${Base.name}`});
+  baseClasses.add(MozElementBase);
+  return MozElementBase;
 };
 
 const MozXULElement = MozElements.MozElementMixin(XULElement);
 
 /**
  * Given an object, add a proxy that reflects interface implementations
  * onto the object itself.
  */
@@ -430,17 +567,17 @@ MozElements.BaseControlMixin = Base => {
   }
 
   Base.implementCustomInterface(BaseControl,
                                 [Ci.nsIDOMXULControlElement]);
   return BaseControl;
 };
 MozElements.BaseControl = MozElements.BaseControlMixin(MozXULElement);
 
-const BaseTextMixin = Base => class extends MozElements.BaseControlMixin(Base) {
+const BaseTextMixin = Base => class BaseText extends MozElements.BaseControlMixin(Base) {
   set label(val) {
     this.setAttribute("label", val);
     return val;
   }
 
   get label() {
     return this.getAttribute("label");
   }
@@ -486,17 +623,16 @@ const BaseTextMixin = Base => class exte
   get accessKey() {
     return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
   }
 };
 MozElements.BaseText = BaseTextMixin(MozXULElement);
 
 // Attach the base class to the window so other scripts can use it:
 window.MozXULElement = MozXULElement;
-window.MozElements = MozElements;
 
 customElements.setElementCreationCallback("browser", () => {
   Services.scriptloader.loadSubScript("chrome://global/content/elements/browser-custom-element.js", window);
 });
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
