# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7bf0c322a8bc1ecc2c4180cbe7410dd7f657212d

diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -93,17 +93,17 @@ xmlns="http://www.w3.org/1999/xhtml"
   window.onunload = gBrowserInit.onUnload.bind(gBrowserInit);
   window.onclose = WindowIsClosing;
 
 #ifdef BROWSER_XHTML
   window.addEventListener("readystatechange", () => {
     // We initially hide the window to prevent layouts during parse. This lets us
     // avoid accidental XBL construction and better match browser.xul (see Bug 1497975).
     gBrowserInit.onBeforeInitialXULLayout();
-    document.documentElement.removeAttribute("hidden");
+    // document.documentElement.removeAttribute("hidden");
   }, { once: true, capture: true });
 #else
   window.addEventListener("MozBeforeInitialXULLayout",
     gBrowserInit.onBeforeInitialXULLayout.bind(gBrowserInit), { once: true });
 #endif
   // The listener of DOMContentLoaded must be set on window, rather than
   // document, because the window can go away before the event is fired.
   // In that case, we don't want to initialize anything, otherwise we
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -318,16 +318,20 @@ window._gBrowser = {
     }
 
     this._tabForBrowser.set(browser, tab);
 
     this._appendStatusPanel();
 
     this.initialBrowser = browser;
 
+    // XXX: Unhide documentElement and force reflow:
+    document.documentElement.removeAttribute("hidden");
+    browser.scrollWidth;
+
     let autoScrollPopup = browser._createAutoScrollPopup();
     autoScrollPopup.id = "autoscroller";
     document.getElementById("mainPopupSet").appendChild(autoScrollPopup);
     browser.setAttribute("autoscrollpopup", autoScrollPopup.id);
     this._autoScrollPopup = autoScrollPopup;
 
     // Hook the browser up with a progress listener.
     let tabListener = new TabProgressListener(tab, browser, true, false);
