# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  3a496a28e22f85f155023a787e2db90e040a232b
Bug 1240196 - Replace instances of console jsterm inputNode.value with a getInputValue function;r=lclark

diff --git a/devtools/client/sourceeditor/editor.js b/devtools/client/sourceeditor/editor.js
--- a/devtools/client/sourceeditor/editor.js
+++ b/devtools/client/sourceeditor/editor.js
@@ -373,17 +373,17 @@ Editor.prototype = {
           } else {
             cm.execCommand("findNext");
           }
         }
       });
 
       cm.on("focus", () => this.emit("focus"));
       cm.on("scroll", () => this.emit("scroll"));
-      cm.on("change", () => {
+      cm.on("changes", () => {
         this.emit("change");
         if (!this._lastDirty) {
           this._lastDirty = true;
           this.emit("dirty-change");
         }
       });
       cm.on("cursorActivity", () => this.emit("cursorActivity"));
 
@@ -448,16 +448,30 @@ Editor.prototype = {
    * Returns the currently active highlighting mode.
    * See Editor.modes for the list of all suppoert modes.
    */
   getMode: function() {
     return this.getOption("mode");
   },
 
   /**
+   * Returns the currently active highlighting mode.
+   * See Editor.modes for the list of all suppoert modes.
+   */
+  getScrollHeight: function () {
+    let cm = editors.get(this);
+    let wrapper = cm.getWrapperElement();
+    let scroller = wrapper.querySelector(".CodeMirror-sizer");
+    // wrapper.style.height = "auto";
+    let scrollHeight = scroller.scrollHeight;
+    // delete wrapper.style.height;
+    return scrollHeight;
+  },
+
+  /**
    * Loads a script into editor's containing window.
    */
   loadScript: function(url) {
     if (!this.container) {
       throw new Error("Can't load a script until the editor is loaded.");
     }
     let win = this.container.contentWindow.wrappedJSObject;
     Services.scriptloader.loadSubScript(url, win, "utf8");
@@ -835,16 +849,46 @@ Editor.prototype = {
     let mark = cm.markText(from, to, { replacedWith: span });
     return {
       anchor: span,
       clear: () => mark.clear()
     };
   },
 
   /**
+   * Add some text directly next to a position
+   */
+  addWidget: function (pos, text, className = "widget-text") {
+    let cm = editors.get(this);
+
+    if (this.widget) {
+      this.widget.remove();
+    }
+    let wrapper = cm.getWrapperElement();
+    let widget = this.widget = wrapper.ownerDocument.createElement("span");
+    widget.style.position = "absolute";
+    widget.className = className;
+
+    let lineHeight = cm.defaultTextHeight();
+    // let lineHeight = wrapper.ownerDocument.defaultView.getComputedStyle(wrapper, "").lineHeight;
+    widget.style.marginTop = "-" + lineHeight + "px";
+    widget.textContent = text;
+    console.log("Adding widget", pos, cm.cursorCoords(pos));
+    // cm.setBookmark(pos, {
+    //   widget: widget
+    // });
+    cm.addWidget(pos, widget);
+
+    return {
+      anchor: widget,
+      clear: () => widget.remove()
+    };
+  },
+
+  /**
    * Calculates and returns one or more {line, ch} objects for
    * a zero-based index who's value is relative to the start of
    * the editor's text.
    *
    * If only one argument is given, this method returns a single
    * {line,ch} object. Otherwise it returns an array.
    */
   getPosition: function(...args) {
diff --git a/devtools/client/webconsole/test/browser_console_history_persist.js b/devtools/client/webconsole/test/browser_console_history_persist.js
--- a/devtools/client/webconsole/test/browser_console_history_persist.js
+++ b/devtools/client/webconsole/test/browser_console_history_persist.js
@@ -108,11 +108,11 @@ function* testNaviatingHistoryInUI(hud) 
   let jsterm = hud.jsterm;
   let {inputNode} = jsterm;
   inputNode.focus();
 
   // Count backwards from original input and make sure that pressing up
   // restores this.
   for (let i = INPUT_HISTORY_COUNT - 1; i >= 0; i--) {
     EventUtils.synthesizeKey("VK_UP", {});
-    is(inputNode.value, i, "Pressing up restores last input");
+    is(jsterm.getInputValue(), i, "Pressing up restores last input");
   }
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js b/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
--- a/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
+++ b/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
@@ -66,33 +66,33 @@ function consoleOpened(HUD) {
     for (let i = 0; i <= 3; i++) {
       jsterm.setInputValue(i);
       jsterm.execute();
     }
     is(WebConsoleUtils.usageCount, 4, "Usage count incremented");
     WebConsoleUtils.usageCount = 0;
     updateEditUIVisibility();
 
-    let oldVal = jsterm.inputNode.value;
+    let oldVal = jsterm.getInputValue();
     goDoCommand("cmd_paste");
     let notificationbox = jsterm.hud.document.getElementById("webconsole-notificationbox");
     let notification = notificationbox.getNotificationWithValue("selfxss-notification");
     ok(notification, "Self-xss notification shown");
-    is(oldVal, jsterm.inputNode.value, "Paste blocked by self-xss prevention");
+    is(oldVal, jsterm.getInputValue(), "Paste blocked by self-xss prevention");
 
     // Allow pasting
-    jsterm.inputNode.value = "allow pasting";
+    jsterm.setInputValue("allow pasting");
     let evt = document.createEvent("KeyboardEvent");
     evt.initKeyEvent("keyup", true, true, window,
                      0, 0, 0, 0,
                      0, " ".charCodeAt(0));
     jsterm.inputNode.dispatchEvent(evt);
-    jsterm.inputNode.value = "";
+    jsterm.setInputValue("");
     goDoCommand("cmd_paste");
-    isnot("", jsterm.inputNode.value, "Paste works");
+    isnot("", jsterm.getInputValue(), "Paste works");
   }
   function onClipboardPaste() {
     ok(!jsterm.completeNode.value, "no completion value after paste");
 
     info("wait for completion update after undo");
     jsterm.once("autocomplete-updated", onCompletionValueAfterUndo);
 
     // Get out of the webconsole event loop.
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -83,17 +83,17 @@ var consoleOpened = Task.async(function*
         "watch",
       ][index] === prop;
     }), "getItems returns the items we expect");
 
     is(popup.selectedIndex, 18,
        "Index of the first item from bottom is selected.");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
@@ -144,44 +144,44 @@ var consoleOpened = Task.async(function*
 });
 
 function popupHideAfterTab() {
   let deferred = promise.defer();
 
   // At this point the completion suggestion should be accepted.
   ok(!popup.isOpen, "popup is not open");
 
-  is(inputNode.value, "window.foobarBug585991.watch",
+  is(jsterm.getInputValue(), "window.foobarBug585991.watch",
      "completion was successful after VK_TAB");
 
   ok(!completeNode.value, "completeNode is empty");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 19, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 18, "First index from bottom is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     popup._panel.addEventListener("popuphidden", function onHidden() {
       popup._panel.removeEventListener("popuphidden", onHidden, false);
 
       ok(!popup.isOpen, "popup is not open after VK_ESCAPE");
 
-      is(inputNode.value, "window.foobarBug585991.",
+      is(jsterm.getInputValue(), "window.foobarBug585991.",
          "completion was cancelled");
 
       ok(!completeNode.value, "completeNode is empty");
 
       deferred.resolve();
     }, false);
 
     info("press Escape to close the popup");
@@ -207,17 +207,17 @@ function testReturnKey() {
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 19, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 18, "First index from bottom is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
@@ -226,17 +226,17 @@ function testReturnKey() {
     is(completeNode.value, prefix + "valueOf",
        "completeNode.value holds valueOf");
 
     popup._panel.addEventListener("popuphidden", function onHidden() {
       popup._panel.removeEventListener("popuphidden", onHidden, false);
 
       ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
-      is(inputNode.value, "window.foobarBug585991.valueOf",
+      is(jsterm.getInputValue(), "window.foobarBug585991.valueOf",
          "completion was successful after VK_RETURN");
 
       ok(!completeNode.value, "completeNode is empty");
 
       deferred.resolve();
     }, false);
 
     info("press Return to accept suggestion. wait for popup to hide");
@@ -319,17 +319,17 @@ function testReturnWithNoSelection() {
   });
 
   return deferred.promise;
 }
 
 function popupHideAfterReturnWithNoSelection() {
   ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
-  is(inputNode.value, "", "inputNode is empty after VK_RETURN");
+  is(jsterm.getInputValue(), "", "inputNode is empty after VK_RETURN");
   is(completeNode.value, "", "completeNode is empty");
   is(jsterm.history[jsterm.history.length - 1], "window.testBug",
      "jsterm history is correct");
 
   return promise.resolve();
 }
 
 function testCompletionInText() {
@@ -364,17 +364,17 @@ function testCompletionInText() {
   inputNode.selectionStart = inputNode.selectionEnd = 18;
   EventUtils.synthesizeKey("g", {});
   return deferred.promise;
 }
 
 function popupHideAfterCompletionInText() {
   // At this point the completion suggestion should be accepted.
   ok(!popup.isOpen, "popup is not open");
-  is(inputNode.value, "dump(window.testBug873250b)",
+  is(jsterm.getInputValue(), "dump(window.testBug873250b)",
      "completion was successful after VK_TAB");
   is(inputNode.selectionStart, 26, "cursor location is correct");
   is(inputNode.selectionStart, inputNode.selectionEnd,
      "cursor location (confirmed)");
   ok(!completeNode.value, "completeNode is empty");
 
   return promise.resolve();
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js b/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
@@ -5,154 +5,156 @@
  *
  * Contributor(s):
  *  Mihai Șucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 "use strict";
 
-var inputNode, values;
+var jsterm, inputNode, values;
 
 var TEST_URI = "data:text/html;charset=utf-8,Web Console test for " +
                "bug 594497 and bug 619598";
 
 add_task(function* () {
   yield loadTab(TEST_URI);
 
   let hud = yield openConsole();
 
   setup(hud);
   performTests();
 
-  inputNode = values = null;
+  jsterm = values = null;
 });
 
 function setup(HUD) {
-  inputNode = HUD.jsterm.inputNode;
+  jsterm = HUD.jsterm;
+  inputNode = jsterm.inputNode;
 
   inputNode.focus();
 
-  ok(!inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "jsterm.getInputValue() is empty");
 
   values = ["document", "window", "document.body"];
   values.push(values.join(";\n"), "document.location");
 
   // Execute each of the values;
   for (let i = 0; i < values.length; i++) {
-    HUD.jsterm.setInputValue(values[i]);
-    HUD.jsterm.execute();
+    jsterm.setInputValue(values[i]);
+    jsterm.execute();
   }
 }
 
 function performTests() {
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[4],
-     "VK_UP: inputNode.value #4 is correct");
+
+  is(jsterm.getInputValue(), values[4],
+     "VK_UP: jsterm.getInputValue() #4 is correct");
 
   ok(inputNode.selectionStart == values[4].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[3],
-     "VK_UP: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_UP: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == values[3].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   inputNode.setSelectionRange(values[3].length - 2, values[3].length - 2);
 
   EventUtils.synthesizeKey("VK_UP", {});
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[3],
-     "VK_UP two times: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_UP two times: jsterm.getInputValue() #3 is correct");
 
-  ok(inputNode.selectionStart == inputNode.value.indexOf("\n") &&
+  ok(inputNode.selectionStart == jsterm.getInputValue().indexOf("\n") &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[3],
-     "VK_UP again: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_UP again: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == 0 &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[2],
-     "VK_UP: inputNode.value #2 is correct");
+  is(jsterm.getInputValue(), values[2],
+     "VK_UP: jsterm.getInputValue() #2 is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[1],
-     "VK_UP: inputNode.value #1 is correct");
+  is(jsterm.getInputValue(), values[1],
+     "VK_UP: jsterm.getInputValue() #1 is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[0],
-     "VK_UP: inputNode.value #0 is correct");
+  is(jsterm.getInputValue(), values[0],
+     "VK_UP: jsterm.getInputValue() #0 is correct");
 
   ok(inputNode.selectionStart == values[0].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[1],
-     "VK_DOWN: inputNode.value #1 is correct");
+  is(jsterm.getInputValue(), values[1],
+     "VK_DOWN: jsterm.getInputValue() #1 is correct");
 
   ok(inputNode.selectionStart == values[1].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[2],
-     "VK_DOWN: inputNode.value #2 is correct");
+  is(jsterm.getInputValue(), values[2],
+     "VK_DOWN: jsterm.getInputValue() #2 is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[3],
-     "VK_DOWN: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_DOWN: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == values[3].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   inputNode.setSelectionRange(2, 2);
 
   EventUtils.synthesizeKey("VK_DOWN", {});
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[3],
-     "VK_DOWN two times: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_DOWN two times: jsterm.getInputValue() #3 is correct");
 
-  ok(inputNode.selectionStart > inputNode.value.lastIndexOf("\n") &&
+  ok(inputNode.selectionStart > jsterm.getInputValue().lastIndexOf("\n") &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[3],
-     "VK_DOWN again: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_DOWN again: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == values[3].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[4],
-     "VK_DOWN: inputNode.value #4 is correct");
+  is(jsterm.getInputValue(), values[4],
+     "VK_DOWN: jsterm.getInputValue() #4 is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  ok(!inputNode.value,
-     "VK_DOWN: inputNode.value is empty");
+  ok(!jsterm.getInputValue(),
+     "VK_DOWN: jsterm.getInputValue() is empty");
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js b/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
@@ -26,17 +26,17 @@ add_task(function* () {
   doTests(hud);
 
   jsterm = inputNode = null;
 });
 
 function doTests(HUD) {
   jsterm = HUD.jsterm;
   inputNode = jsterm.inputNode;
-  ok(!jsterm.inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "inputNode.value is empty");
   is(jsterm.inputNode.selectionStart, 0);
   is(jsterm.inputNode.selectionEnd, 0);
 
   testSingleLineInputNavNoHistory();
   testMultiLineInputNavNoHistory();
   testNavWithHistory();
 }
 
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js b/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
@@ -23,41 +23,41 @@ add_task(function* () {
   let hud = yield openConsole();
 
   testEditedInputHistory(hud);
 });
 
 function testEditedInputHistory(HUD) {
   let jsterm = HUD.jsterm;
   let inputNode = jsterm.inputNode;
-  ok(!inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "jsterm.getInputValue() is empty");
   is(inputNode.selectionStart, 0);
   is(inputNode.selectionEnd, 0);
 
   jsterm.setInputValue('"first item"');
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"first item"', "null test history up");
+  is(jsterm.getInputValue(), '"first item"', "null test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"first item"', "null test history down");
+  is(jsterm.getInputValue(), '"first item"', "null test history down");
 
   jsterm.execute();
-  is(inputNode.value, "", "cleared input line after submit");
+  is(jsterm.getInputValue(), "", "cleared input line after submit");
 
   jsterm.setInputValue('"editing input 1"');
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"first item"', "test history up");
+  is(jsterm.getInputValue(), '"first item"', "test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"editing input 1"',
+  is(jsterm.getInputValue(), '"editing input 1"',
     "test history down restores in-progress input");
 
   jsterm.setInputValue('"second item"');
   jsterm.execute();
   jsterm.setInputValue('"editing input 2"');
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"second item"', "test history up");
+  is(jsterm.getInputValue(), '"second item"', "test history up");
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"first item"', "test history up");
+  is(jsterm.getInputValue(), '"first item"', "test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"second item"', "test history down");
+  is(jsterm.getInputValue(), '"second item"', "test history down");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"editing input 2"',
+  is(jsterm.getInputValue(), '"editing input 2"',
      "test history down restores new in-progress input again");
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
--- a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
+++ b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
@@ -52,15 +52,15 @@ add_task(function*() {
   yield waitForContextMenu(contextMenu, text, () => {
     ok(storeAsGlobalItem.disabled === true, "The \"Store as global\" " +
       "context menu item should be disabled for texts");
   });
 
   info("Waiting for input to be set");
   yield onceInputSet;
 
-  is(hud.jsterm.inputNode.value, "temp0", "Input was set");
+  is(hud.jsterm.getInputValue(), "temp0", "Input was set");
   let executedResult = yield hud.jsterm.execute();
 
   ok(executedResult.textContent.includes("{ baz: 1 }"),
      "Correct variable assigned into console");
 
 });
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -20,16 +20,17 @@ loader.lazyRequireGetter(this, "Autocomp
 loader.lazyRequireGetter(this, "ToolSidebar", "devtools/client/framework/sidebar", true);
 loader.lazyRequireGetter(this, "ConsoleOutput", "devtools/client/webconsole/console-output", true);
 loader.lazyRequireGetter(this, "Messages", "devtools/client/webconsole/console-output", true);
 loader.lazyRequireGetter(this, "asyncStorage", "devtools/shared/async-storage");
 loader.lazyRequireGetter(this, "EnvironmentClient", "devtools/shared/client/main", true);
 loader.lazyRequireGetter(this, "ObjectClient", "devtools/shared/client/main", true);
 loader.lazyRequireGetter(this, "system", "devtools/shared/system");
 loader.lazyRequireGetter(this, "Timers", "sdk/timers");
+loader.lazyRequireGetter(this, "Editor", "devtools/client/sourceeditor/editor");
 loader.lazyImporter(this, "VariablesView", "resource://devtools/client/shared/widgets/VariablesView.jsm");
 loader.lazyImporter(this, "VariablesViewController", "resource://devtools/client/shared/widgets/VariablesViewController.jsm");
 loader.lazyImporter(this, "PluralForm", "resource://gre/modules/PluralForm.jsm");
 loader.lazyImporter(this, "gDevTools", "resource://devtools/client/framework/gDevTools.jsm");
 
 const STRINGS_URI = "chrome://devtools/locale/webconsole.properties";
 var l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
@@ -548,39 +549,39 @@ WebConsoleFrame.prototype = {
     /*
      * Focus input line whenever the output area is clicked.
      * Reusing _addMEssageLinkCallback since it correctly filters
      * drag and select events.
      */
     this._addFocusCallback(this.outputNode, (evt) => {
       if ((evt.target.nodeName.toLowerCase() != "a") &&
           (evt.target.parentNode.nodeName.toLowerCase() != "a")) {
-        this.jsterm.inputNode.focus();
+        this.jsterm.focus()
       }
     });
 
     // Toggle the timestamp on preference change
     gDevTools.on("pref-changed", this._onToolboxPrefChanged);
     this._onToolboxPrefChanged("pref-changed", {
       pref: PREF_MESSAGE_TIMESTAMP,
       newValue: Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP),
     });
 
     // focus input node
-    this.jsterm.inputNode.focus();
+    this.jsterm.focus();
   },
 
   /**
    * Sets the focus to JavaScript input field when the web console tab is
    * selected or when there is a split console present.
    * @private
    */
   _onPanelSelected: function WCF__onPanelSelected(evt, id)
   {
-    this.jsterm.inputNode.focus();
+    this.jsterm.focus();
   },
 
   /**
    * Initialize the default filter preferences.
    * @private
    */
   _initDefaultFilterPrefs: function WCF__initDefaultFilterPrefs()
   {
@@ -2100,16 +2101,20 @@ WebConsoleFrame.prototype = {
     if (this._outputQueue.length === 0 && this._flushCallback) {
       if (this._flushCallback() === false) {
         this._flushCallback = null;
       }
     }
 
     this._initOutputTimer();
 
+    // XXX: This is needed for now with codemirror console otherwise the
+    // input line takes up too much space...
+    this.jsterm.resizeInput();
+
     this._lastOutputFlush = Date.now();
   },
 
   /**
    * Initialize the output timer.
    * @private
    */
   _initOutputTimer: function WCF__initOutputTimer()
@@ -3143,19 +3148,18 @@ JSTerm.prototype = {
       this.inputNode.addEventListener("focus", this._focusEventHandler, false);
     }
 
     this.hud.window.addEventListener("blur", this._blurEventHandler, false);
     this.lastInputValue && this.setInputValue(this.lastInputValue);
   },
 
   focus: function() {
-    let inputNode = this.inputNode;
-    if (!inputNode.getAttribute("focused")) {
-      inputNode.focus();
+    if (!this.inputNode.getAttribute("focused")) {
+      this.inputNode.focus();
     }
   },
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
    * @param function [callback]
@@ -3247,17 +3251,17 @@ JSTerm.prototype = {
     }
   },
 
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [executeString]
    *        The string you want to execute. If this is not provided, the current
-   *        user input is used - taken from |this.inputNode.value|.
+   *        user input is used - taken from |this.getInputValue()|.
    * @param function [callback]
    *        Optional function to invoke when the result is displayed.
    *        This is deprecated - please use the promise return value instead.
    * @returns Promise
    *          Resolves with the message once the result is displayed.
    */
   execute: function JST_execute(executeString, callback)
   {
@@ -3265,17 +3269,17 @@ JSTerm.prototype = {
     let resultCallback = function(msg) {
       deferred.resolve(msg);
       if (callback) {
         callback(msg);
       }
     }
 
     // attempt to execute the content of the inputNode
-    executeString = executeString || this.inputNode.value;
+    executeString = executeString || this.getInputValue();
     if (!executeString) {
       return;
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
     if (inspectorSelection && inspectorSelection.nodeFront) {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
@@ -3527,17 +3531,17 @@ JSTerm.prototype = {
     let tag = event.target.nodeName;
     if (event.keyCode != Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE || event.shiftKey ||
         event.altKey || event.ctrlKey || event.metaKey ||
         ["input", "textarea", "select", "textbox"].indexOf(tag) > -1) {
         return;
     }
 
     this._sidebarDestroy();
-    this.inputNode.focus();
+    this.focus();
     event.stopPropagation();
   },
 
   /**
    * Create a variables view instance.
    *
    * @private
    * @param object options
@@ -3859,25 +3863,41 @@ JSTerm.prototype = {
     this.lastInputValue = newValue;
     this.completeNode.value = "";
     this.resizeInput();
     this._inputChanged = true;
     this.emit("set-input-value");
   },
 
   /**
+   * Gets the value from the input field
+   */
+  getInputValue: function()
+  {
+    return this.inputNode.value || "";
+  },
+
+  /**
+   * Is there text selected? In other words, is the selection *not* collapsed?
+   */
+  get isSomethingSelected()
+  {
+    return this.inputNode.selectionStart !== this.inputNode.selectionEnd;
+  },
+
+  /**
    * The inputNode "input" and "keyup" event handler.
    * @private
    */
   _inputEventHandler: function JST__inputEventHandler()
   {
-    if (this.lastInputValue != this.inputNode.value) {
+    if (this.lastInputValue != this.getInputValue()) {
       this.resizeInput();
       this.complete(this.COMPLETE_HINT_ONLY);
-      this.lastInputValue = this.inputNode.value;
+      this.lastInputValue = this.getInputValue();
       this._inputChanged = true;
     }
   },
 
   /**
    * The window "blur" event handler.
    * @private
    */
@@ -3892,31 +3912,32 @@ JSTerm.prototype = {
    * The inputNode "keypress" event handler.
    *
    * @private
    * @param nsIDOMEvent event
    */
   _keyPress: function JST__keyPress(event)
   {
     let inputNode = this.inputNode;
+    let inputValue = this.getInputValue();
     let inputUpdated = false;
 
     if (event.ctrlKey) {
       switch (event.charCode) {
         case 101:
           // control-e
           if (Services.appinfo.OS == "WINNT") {
             break;
           }
-          let lineEndPos = inputNode.value.length;
+          let lineEndPos = this.getInputValue().length;
           if (this.hasMultilineInput()) {
             // find index of closest newline >= cursor
             for (let i = inputNode.selectionEnd; i<lineEndPos; i++) {
-              if (inputNode.value.charAt(i) == "\r" ||
-                  inputNode.value.charAt(i) == "\n") {
+              if (inputValue.charAt(i) == "\r" ||
+                  inputValue.charAt(i) == "\n") {
                 lineEndPos = i;
                 break;
               }
             }
           }
           inputNode.setSelectionRange(lineEndPos, lineEndPos);
           event.preventDefault();
           this.clearCompletion();
@@ -4055,43 +4076,42 @@ JSTerm.prototype = {
         }
         event.preventDefault();
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_HOME:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectedIndex = 0;
           event.preventDefault();
-        } else if (this.inputNode.value.length <= 0) {
+        } else if (this.inputValue.length <= 0) {
           this.hud.outputNode.parentNode.scrollTop = 0;
           event.preventDefault();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_END:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectedIndex = this.autocompletePopup.itemCount - 1;
           event.preventDefault();
-        } else if (this.inputNode.value.length <= 0) {
+        } else if (this.inputValue.length <= 0) {
           this.hud.outputNode.parentNode.scrollTop = this.hud.outputNode.parentNode.scrollHeight;
           event.preventDefault();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
         if (this.autocompletePopup.isOpen || this.lastCompletion.value) {
           this.clearCompletion();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_RIGHT: {
-        let cursorAtTheEnd = this.inputNode.selectionStart ==
-                             this.inputNode.selectionEnd &&
+        let cursorAtTheEnd = this.isSomethingSelected &&
                              this.inputNode.selectionStart ==
-                             this.inputNode.value.length;
+                             this.inputValue.length;
         let haveSuggestion = this.autocompletePopup.isOpen ||
                              this.lastCompletion.value;
         let useCompletion = cursorAtTheEnd || this._autocompletePopupNavigated;
         if (haveSuggestion && useCompletion &&
             this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion.value &&
             this.acceptProposedCompletion()) {
           event.preventDefault();
@@ -4149,17 +4169,17 @@ JSTerm.prototype = {
       }
       let inputVal = this.history[--this.historyPlaceHolder];
 
       // Save the current input value as the latest entry in history, only if
       // the user is already at the last entry.
       // Note: this code does not store changes to items that are already in
       // history.
       if (this.historyPlaceHolder+1 == this.historyIndex) {
-        this.history[this.historyIndex] = this.inputNode.value || "";
+        this.history[this.historyIndex] = this.getInputValue() || "";
       }
 
       this.setInputValue(inputVal);
     }
     // Down Arrow key
     else if (direction == HISTORY_FORWARD) {
       if (this.historyPlaceHolder >= (this.history.length-1)) {
         return false;
@@ -4178,34 +4198,35 @@ JSTerm.prototype = {
   /**
    * Test for multiline input.
    *
    * @return boolean
    *         True if CR or LF found in node value; else false.
    */
   hasMultilineInput: function JST_hasMultilineInput()
   {
-    return /[\r\n]/.test(this.inputNode.value);
+    return /[\r\n]/.test(this.getInputValue());
   },
 
   /**
    * Check if the caret is at a location that allows selecting the previous item
    * in history when the user presses the Up arrow key.
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the
    *         previous item in history when the user presses the Up arrow key,
    *         otherwise false.
    */
   canCaretGoPrevious: function JST_canCaretGoPrevious()
   {
+    if (this.isSomethingSelected) {
+      return false;
+    }
+
     let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
-      return false;
-    }
 
     let multiline = /[\r\n]/.test(node.value);
     return node.selectionStart == 0 ? true :
            node.selectionStart == node.value.length && !multiline;
   },
 
   /**
    * Check if the caret is at a location that allows selecting the next item in
@@ -4213,20 +4234,21 @@ JSTerm.prototype = {
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the next
    *         item in history when the user presses the Down arrow key, otherwise
    *         false.
    */
   canCaretGoNext: function JST_canCaretGoNext()
   {
+    if (this.isSomethingSelected) {
+      return false;
+    }
+
     let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
-      return false;
-    }
 
     let multiline = /[\r\n]/.test(node.value);
     return node.selectionStart == node.value.length ? true :
            node.selectionStart == 0 && !multiline;
   },
 
   /**
    * Completes the current typed text in the inputNode. Completion is performed
@@ -4248,40 +4270,40 @@ JSTerm.prototype = {
    *    - this.COMPLETE_PAGEUP: Scroll up one page if available or select the first
    *          item.
    *    - this.COMPLETE_PAGEDOWN: Scroll down one page if available or select the
    *          last item.
    *    - this.COMPLETE_HINT_ONLY: If there is more than one possible
    *          completion and the input value stayed the same compared to the
    *          last time this function was called, then the same completion is
    *          used again. If there is only one possible completion, then
-   *          the inputNode.value is set to this value and the selection is set
+   *          the this.getInputValue() is set to this value and the selection is set
    *          from the current cursor position to the end of the completed text.
    * @param function callback
    *        Optional function invoked when the autocomplete properties are
    *        updated.
    * @returns boolean true if there existed a completion for the current input,
    *          or false otherwise.
    */
   complete: function JSTF_complete(type, callback)
   {
     let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
+    let inputValue = this.getInputValue();
     let frameActor = this.getFrameActor(this.SELECTED_FRAME);
 
     // If the inputNode has no value, then don't try to complete on it.
     if (!inputValue) {
       this.clearCompletion();
       callback && callback(this);
       this.emit("autocomplete-updated");
       return false;
     }
 
     // Only complete if the selection is empty.
-    if (inputNode.selectionStart != inputNode.selectionEnd) {
+    if (this.isSomethingSelected) {
       this.clearCompletion();
       callback && callback(this);
       this.emit("autocomplete-updated");
       return false;
     }
 
     // Update the completion results.
     if (this.lastCompletion.value != inputValue || frameActor != this._lastFrameActorId) {
@@ -4323,23 +4345,24 @@ JSTerm.prototype = {
    *        Completion type. See this.complete() for details.
    * @param function [callback]
    *        Optional, function to invoke when completion results are received.
    */
   _updateCompletionResult:
   function JST__updateCompletionResult(type, callback)
   {
     let frameActor = this.getFrameActor(this.SELECTED_FRAME);
-    if (this.lastCompletion.value == this.inputNode.value && frameActor == this._lastFrameActorId) {
+    if (this.lastCompletion.value == this.getInputValue() &&
+        frameActor == this._lastFrameActorId) {
       return;
     }
 
     let requestId = gSequenceId();
     let cursor = this.inputNode.selectionStart;
-    let input = this.inputNode.value.substring(0, cursor);
+    let input = this.getInputValue().substring(0, cursor);
     let cache = this._autocompleteCache;
 
     // If the current input starts with the previous input, then we already
     // have a list of suggestions and we just need to filter the cached
     // suggestions. When the current input ends with a non-alphanumeric
     // character we ask the server again for suggestions.
 
     // Check if last character is non-alphanumeric
@@ -4399,17 +4422,17 @@ JSTerm.prototype = {
    * @param object message
    *        The JSON message which holds the completion results received from
    *        the content process.
    */
   _receiveAutocompleteProperties:
   function JST__receiveAutocompleteProperties(requestId, callback, message)
   {
     let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
+    let inputValue = this.getInputValue();
     if (this.lastCompletion.value == inputValue ||
         requestId != this.lastCompletion.requestId) {
       return;
     }
     // Cache whatever came from the server if the last char is alphanumeric or '.'
     let cursor = inputNode.selectionStart;
     let inputUntilCursor = inputValue.substring(0, cursor);
 
@@ -4436,17 +4459,17 @@ JSTerm.prototype = {
 
     let completionType = this.lastCompletion.completionType;
     this.lastCompletion = {
       value: inputValue,
       matchProp: lastPart,
     };
 
     if (items.length > 1 && !popup.isOpen) {
-      let str = this.inputNode.value.substr(0, this.inputNode.selectionStart);
+      let str = this.getInputValue().substr(0, this.inputNode.selectionStart);
       let offset = str.length - (str.lastIndexOf("\n") + 1) - lastPart.length;
       let x = offset * this.hud._inputCharWidth;
       popup.openPopup(inputNode, x + this.hud._chevronWidth);
       this._autocompletePopupNavigated = false;
     }
     else if (items.length < 2 && popup.isOpen) {
       popup.hidePopup();
       this._autocompletePopupNavigated = false;
@@ -4470,17 +4493,17 @@ JSTerm.prototype = {
 
     callback && callback(this);
     this.emit("autocomplete-updated");
   },
 
   onAutocompleteSelect: function JSTF_onAutocompleteSelect()
   {
     // Render the suggestion only if the cursor is at the end of the input.
-    if (this.inputNode.selectionStart != this.inputNode.value.length) {
+    if (this.inputNode.selectionStart != this.getInputValue().length) {
       return;
     }
 
     let currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.updateCompleteNode(suffix);
@@ -4516,17 +4539,17 @@ JSTerm.prototype = {
   {
     let updated = false;
 
     let currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       let cursor = this.inputNode.selectionStart;
-      let value = this.inputNode.value;
+      let value = this.getInputValue();
       this.setInputValue(value.substr(0, cursor) + suffix + value.substr(cursor));
       let newCursor = cursor + suffix.length;
       this.inputNode.selectionStart = this.inputNode.selectionEnd = newCursor;
       updated = true;
     }
 
     this.clearCompletion();
 
@@ -4537,17 +4560,17 @@ JSTerm.prototype = {
    * Update the node that displays the currently selected autocomplete proposal.
    *
    * @param string suffix
    *        The proposed suffix for the inputNode value.
    */
   updateCompleteNode: function JSTF_updateCompleteNode(suffix)
   {
     // completion prefix = input, with non-control chars replaced by spaces
-    let prefix = suffix ? this.inputNode.value.replace(/[\S]/g, " ") : "";
+    let prefix = suffix ? this.getInputValue().replace(/[\S]/g, " ") : "";
     this.completeNode.value = prefix + suffix;
   },
 
 
   /**
    * Destroy the sidebar.
    * @private
    */
