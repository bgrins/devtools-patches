# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  d26925accc511cc16a5aef23991de7e620fea4ae
Bug 1240196 - Replace instances of console jsterm inputNode.value with a getInputValue function;r=linclark

diff --git a/devtools/client/webconsole/test/browser_console_history_persist.js b/devtools/client/webconsole/test/browser_console_history_persist.js
--- a/devtools/client/webconsole/test/browser_console_history_persist.js
+++ b/devtools/client/webconsole/test/browser_console_history_persist.js
@@ -108,11 +108,11 @@ function* testNaviatingHistoryInUI(hud) 
   let jsterm = hud.jsterm;
   let {inputNode} = jsterm;
   inputNode.focus();
 
   // Count backwards from original input and make sure that pressing up
   // restores this.
   for (let i = INPUT_HISTORY_COUNT - 1; i >= 0; i--) {
     EventUtils.synthesizeKey("VK_UP", {});
-    is(inputNode.value, i, "Pressing up restores last input");
+    is(jsterm.getInputValue(), i, "Pressing up restores last input");
   }
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js b/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
--- a/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
+++ b/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
@@ -66,33 +66,33 @@ function consoleOpened(HUD) {
     for (let i = 0; i <= 3; i++) {
       jsterm.setInputValue(i);
       jsterm.execute();
     }
     is(WebConsoleUtils.usageCount, 4, "Usage count incremented");
     WebConsoleUtils.usageCount = 0;
     updateEditUIVisibility();
 
-    let oldVal = jsterm.inputNode.value;
+    let oldVal = jsterm.getInputValue();
     goDoCommand("cmd_paste");
     let notificationbox = jsterm.hud.document.getElementById("webconsole-notificationbox");
     let notification = notificationbox.getNotificationWithValue("selfxss-notification");
     ok(notification, "Self-xss notification shown");
-    is(oldVal, jsterm.inputNode.value, "Paste blocked by self-xss prevention");
+    is(oldVal, jsterm.getInputValue(), "Paste blocked by self-xss prevention");
 
     // Allow pasting
-    jsterm.inputNode.value = "allow pasting";
+    jsterm.setInputValue("allow pasting");
     let evt = document.createEvent("KeyboardEvent");
     evt.initKeyEvent("keyup", true, true, window,
                      0, 0, 0, 0,
                      0, " ".charCodeAt(0));
     jsterm.inputNode.dispatchEvent(evt);
-    jsterm.inputNode.value = "";
+    jsterm.setInputValue("");
     goDoCommand("cmd_paste");
-    isnot("", jsterm.inputNode.value, "Paste works");
+    isnot("", jsterm.getInputValue(), "Paste works");
   }
   function onClipboardPaste() {
     ok(!jsterm.completeNode.value, "no completion value after paste");
 
     info("wait for completion update after undo");
     jsterm.once("autocomplete-updated", onCompletionValueAfterUndo);
 
     // Get out of the webconsole event loop.
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -83,17 +83,17 @@ var consoleOpened = Task.async(function*
         "watch",
       ][index] === prop;
     }), "getItems returns the items we expect");
 
     is(popup.selectedIndex, 18,
        "Index of the first item from bottom is selected.");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
@@ -144,44 +144,44 @@ var consoleOpened = Task.async(function*
 });
 
 function popupHideAfterTab() {
   let deferred = promise.defer();
 
   // At this point the completion suggestion should be accepted.
   ok(!popup.isOpen, "popup is not open");
 
-  is(inputNode.value, "window.foobarBug585991.watch",
+  is(jsterm.getInputValue(), "window.foobarBug585991.watch",
      "completion was successful after VK_TAB");
 
   ok(!completeNode.value, "completeNode is empty");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 19, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 18, "First index from bottom is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     popup._panel.addEventListener("popuphidden", function onHidden() {
       popup._panel.removeEventListener("popuphidden", onHidden, false);
 
       ok(!popup.isOpen, "popup is not open after VK_ESCAPE");
 
-      is(inputNode.value, "window.foobarBug585991.",
+      is(jsterm.getInputValue(), "window.foobarBug585991.",
          "completion was cancelled");
 
       ok(!completeNode.value, "completeNode is empty");
 
       deferred.resolve();
     }, false);
 
     info("press Escape to close the popup");
@@ -207,17 +207,17 @@ function testReturnKey() {
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 19, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 18, "First index from bottom is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
@@ -226,17 +226,17 @@ function testReturnKey() {
     is(completeNode.value, prefix + "valueOf",
        "completeNode.value holds valueOf");
 
     popup._panel.addEventListener("popuphidden", function onHidden() {
       popup._panel.removeEventListener("popuphidden", onHidden, false);
 
       ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
-      is(inputNode.value, "window.foobarBug585991.valueOf",
+      is(jsterm.getInputValue(), "window.foobarBug585991.valueOf",
          "completion was successful after VK_RETURN");
 
       ok(!completeNode.value, "completeNode is empty");
 
       deferred.resolve();
     }, false);
 
     info("press Return to accept suggestion. wait for popup to hide");
@@ -319,17 +319,17 @@ function testReturnWithNoSelection() {
   });
 
   return deferred.promise;
 }
 
 function popupHideAfterReturnWithNoSelection() {
   ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
-  is(inputNode.value, "", "inputNode is empty after VK_RETURN");
+  is(jsterm.getInputValue(), "", "inputNode is empty after VK_RETURN");
   is(completeNode.value, "", "completeNode is empty");
   is(jsterm.history[jsterm.history.length - 1], "window.testBug",
      "jsterm history is correct");
 
   return promise.resolve();
 }
 
 function testCompletionInText() {
@@ -364,17 +364,17 @@ function testCompletionInText() {
   inputNode.selectionStart = inputNode.selectionEnd = 18;
   EventUtils.synthesizeKey("g", {});
   return deferred.promise;
 }
 
 function popupHideAfterCompletionInText() {
   // At this point the completion suggestion should be accepted.
   ok(!popup.isOpen, "popup is not open");
-  is(inputNode.value, "dump(window.testBug873250b)",
+  is(jsterm.getInputValue(), "dump(window.testBug873250b)",
      "completion was successful after VK_TAB");
   is(inputNode.selectionStart, 26, "cursor location is correct");
   is(inputNode.selectionStart, inputNode.selectionEnd,
      "cursor location (confirmed)");
   ok(!completeNode.value, "completeNode is empty");
 
   return promise.resolve();
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js b/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
@@ -5,154 +5,156 @@
  *
  * Contributor(s):
  *  Mihai È˜ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 "use strict";
 
-var inputNode, values;
+var jsterm, inputNode, values;
 
 var TEST_URI = "data:text/html;charset=utf-8,Web Console test for " +
                "bug 594497 and bug 619598";
 
 add_task(function* () {
   yield loadTab(TEST_URI);
 
   let hud = yield openConsole();
 
   setup(hud);
   performTests();
 
-  inputNode = values = null;
+  jsterm = inputNode = values = null;
 });
 
 function setup(HUD) {
-  inputNode = HUD.jsterm.inputNode;
+  jsterm = HUD.jsterm;
+  inputNode = jsterm.inputNode;
 
   inputNode.focus();
 
-  ok(!inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "jsterm.getInputValue() is empty");
 
   values = ["document", "window", "document.body"];
   values.push(values.join(";\n"), "document.location");
 
   // Execute each of the values;
   for (let i = 0; i < values.length; i++) {
-    HUD.jsterm.setInputValue(values[i]);
-    HUD.jsterm.execute();
+    jsterm.setInputValue(values[i]);
+    jsterm.execute();
   }
 }
 
 function performTests() {
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[4],
-     "VK_UP: inputNode.value #4 is correct");
+
+  is(jsterm.getInputValue(), values[4],
+     "VK_UP: jsterm.getInputValue() #4 is correct");
 
   ok(inputNode.selectionStart == values[4].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[3],
-     "VK_UP: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_UP: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == values[3].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   inputNode.setSelectionRange(values[3].length - 2, values[3].length - 2);
 
   EventUtils.synthesizeKey("VK_UP", {});
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[3],
-     "VK_UP two times: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_UP two times: jsterm.getInputValue() #3 is correct");
 
-  ok(inputNode.selectionStart == inputNode.value.indexOf("\n") &&
+  ok(inputNode.selectionStart == jsterm.getInputValue().indexOf("\n") &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[3],
-     "VK_UP again: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_UP again: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == 0 &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[2],
-     "VK_UP: inputNode.value #2 is correct");
+  is(jsterm.getInputValue(), values[2],
+     "VK_UP: jsterm.getInputValue() #2 is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[1],
-     "VK_UP: inputNode.value #1 is correct");
+  is(jsterm.getInputValue(), values[1],
+     "VK_UP: jsterm.getInputValue() #1 is correct");
 
   EventUtils.synthesizeKey("VK_UP", {});
 
-  is(inputNode.value, values[0],
-     "VK_UP: inputNode.value #0 is correct");
+  is(jsterm.getInputValue(), values[0],
+     "VK_UP: jsterm.getInputValue() #0 is correct");
 
   ok(inputNode.selectionStart == values[0].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[1],
-     "VK_DOWN: inputNode.value #1 is correct");
+  is(jsterm.getInputValue(), values[1],
+     "VK_DOWN: jsterm.getInputValue() #1 is correct");
 
   ok(inputNode.selectionStart == values[1].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[2],
-     "VK_DOWN: inputNode.value #2 is correct");
+  is(jsterm.getInputValue(), values[2],
+     "VK_DOWN: jsterm.getInputValue() #2 is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[3],
-     "VK_DOWN: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_DOWN: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == values[3].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   inputNode.setSelectionRange(2, 2);
 
   EventUtils.synthesizeKey("VK_DOWN", {});
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[3],
-     "VK_DOWN two times: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_DOWN two times: jsterm.getInputValue() #3 is correct");
 
-  ok(inputNode.selectionStart > inputNode.value.lastIndexOf("\n") &&
+  ok(inputNode.selectionStart > jsterm.getInputValue().lastIndexOf("\n") &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[3],
-     "VK_DOWN again: inputNode.value #3 is correct");
+  is(jsterm.getInputValue(), values[3],
+     "VK_DOWN again: jsterm.getInputValue() #3 is correct");
 
   ok(inputNode.selectionStart == values[3].length &&
      inputNode.selectionStart == inputNode.selectionEnd,
      "caret location is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  is(inputNode.value, values[4],
-     "VK_DOWN: inputNode.value #4 is correct");
+  is(jsterm.getInputValue(), values[4],
+     "VK_DOWN: jsterm.getInputValue() #4 is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
-  ok(!inputNode.value,
-     "VK_DOWN: inputNode.value is empty");
+  ok(!jsterm.getInputValue(),
+     "VK_DOWN: jsterm.getInputValue() is empty");
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js b/devtools/client/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js
@@ -15,16 +15,16 @@ add_task(function* () {
 
   let jsterm = hud.jsterm;
   jsterm.setInputValue("Ignore These Four Words");
   let inputNode = jsterm.inputNode;
 
   // Test select all with Control + A.
   EventUtils.synthesizeKey("a", { ctrlKey: true });
   let inputLength = inputNode.selectionEnd - inputNode.selectionStart;
-  is(inputLength, inputNode.value.length, "Select all of input");
+  is(inputLength, jsterm.getInputValue().length, "Select all of input");
 
   // Test do nothing on Control + E.
   jsterm.setInputValue("Ignore These Four Words");
   inputNode.selectionStart = 0;
   EventUtils.synthesizeKey("e", { ctrlKey: true });
   is(inputNode.selectionStart, 0, "Control + E does not move to end of input");
 });
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js b/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
@@ -26,17 +26,17 @@ add_task(function* () {
   doTests(hud);
 
   jsterm = inputNode = null;
 });
 
 function doTests(HUD) {
   jsterm = HUD.jsterm;
   inputNode = jsterm.inputNode;
-  ok(!jsterm.inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "jsterm.getInputValue() is empty");
   is(jsterm.inputNode.selectionStart, 0);
   is(jsterm.inputNode.selectionEnd, 0);
 
   testSingleLineInputNavNoHistory();
   testMultiLineInputNavNoHistory();
   testNavWithHistory();
 }
 
@@ -91,79 +91,79 @@ function testSingleLineInputNavNoHistory
   is(inputNode.selectionStart, 2, "ctrl-n moves to end of line");
 }
 
 function testMultiLineInputNavNoHistory() {
   let lineValues = ["one", "2", "something longer", "", "", "three!"];
   jsterm.setInputValue("");
   // simulate shift-return
   for (let i = 0; i < lineValues.length; i++) {
-    jsterm.setInputValue(inputNode.value + lineValues[i]);
+    jsterm.setInputValue(jsterm.getInputValue() + lineValues[i]);
     EventUtils.synthesizeKey("VK_RETURN", { shiftKey: true });
   }
-  let inputValue = inputNode.value;
+  let inputValue = jsterm.getInputValue();
   is(inputNode.selectionStart, inputNode.selectionEnd);
   is(inputNode.selectionStart, inputValue.length,
      "caret at end of multiline input");
 
   // possibility newline is represented by one ('\r', '\n') or two
   // ('\r\n') chars
   let newlineString = inputValue.match(/(\r\n?|\n\r?)$/)[0];
 
   // Ok, test navigating within the multi-line string!
   EventUtils.synthesizeKey("VK_UP", {});
   let expectedStringAfterCarat = lineValues[5] + newlineString;
-  is(inputNode.value.slice(inputNode.selectionStart), expectedStringAfterCarat,
+  is(jsterm.getInputValue().slice(inputNode.selectionStart), expectedStringAfterCarat,
      "up arrow from end of multiline");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value.slice(inputNode.selectionStart), "",
+  is(jsterm.getInputValue().slice(inputNode.selectionStart), "",
      "down arrow from within multiline");
 
   // navigate up through input lines
   EventUtils.synthesizeKey("p", { ctrlKey: true });
-  is(inputNode.value.slice(inputNode.selectionStart), expectedStringAfterCarat,
+  is(jsterm.getInputValue().slice(inputNode.selectionStart), expectedStringAfterCarat,
      "ctrl-p from end of multiline");
 
   for (let i = 4; i >= 0; i--) {
     EventUtils.synthesizeKey("p", { ctrlKey: true });
     expectedStringAfterCarat = lineValues[i] + newlineString +
       expectedStringAfterCarat;
-    is(inputNode.value.slice(inputNode.selectionStart),
+    is(jsterm.getInputValue().slice(inputNode.selectionStart),
       expectedStringAfterCarat, "ctrl-p from within line " + i +
       " of multiline input");
   }
   EventUtils.synthesizeKey("p", { ctrlKey: true });
   is(inputNode.selectionStart, 0, "reached start of input");
-  is(inputNode.value, inputValue,
+  is(jsterm.getInputValue(), inputValue,
      "no change to multiline input on ctrl-p from beginning of multiline");
 
   // navigate to end of first line
   EventUtils.synthesizeKey("e", { ctrlKey: true });
   let caretPos = inputNode.selectionStart;
   let expectedStringBeforeCarat = lineValues[0];
-  is(inputNode.value.slice(0, caretPos), expectedStringBeforeCarat,
+  is(jsterm.getInputValue().slice(0, caretPos), expectedStringBeforeCarat,
      "ctrl-e into multiline input");
   EventUtils.synthesizeKey("e", { ctrlKey: true });
   is(inputNode.selectionStart, caretPos,
      "repeat ctrl-e doesn't change caret position in multiline input");
 
   // navigate down one line; ctrl-a to the beginning; ctrl-e to end
   for (let i = 1; i < lineValues.length; i++) {
     EventUtils.synthesizeKey("n", { ctrlKey: true });
     EventUtils.synthesizeKey("a", { ctrlKey: true });
     caretPos = inputNode.selectionStart;
     expectedStringBeforeCarat += newlineString;
-    is(inputNode.value.slice(0, caretPos), expectedStringBeforeCarat,
+    is(jsterm.getInputValue().slice(0, caretPos), expectedStringBeforeCarat,
        "ctrl-a to beginning of line " + (i + 1) + " in multiline input");
 
     EventUtils.synthesizeKey("e", { ctrlKey: true });
     caretPos = inputNode.selectionStart;
     expectedStringBeforeCarat += lineValues[i];
-    is(inputNode.value.slice(0, caretPos), expectedStringBeforeCarat,
+    is(jsterm.getInputValue().slice(0, caretPos), expectedStringBeforeCarat,
        "ctrl-e to end of line " + (i + 1) + "in multiline input");
   }
 }
 
 function testNavWithHistory() {
   // NOTE: Tests does NOT currently define behaviour for ctrl-p/ctrl-n with
   // caret placed _within_ single line input
   let values = ['"single line input"',
@@ -190,44 +190,44 @@ function testNavWithHistory() {
       for (let j = 0; j < match.length; j++) {
         EventUtils.synthesizeKey("p", { ctrlKey: true });
       }
       EventUtils.synthesizeKey("p", { ctrlKey: true });
     } else {
       // single-line inputs will update from history from end of line
       EventUtils.synthesizeKey("p", { ctrlKey: true });
     }
-    is(inputNode.value, values[i - 1],
+    is(jsterm.getInputValue(), values[i - 1],
        "ctrl-p updates inputNode from backwards history values[" + i - 1 + "]");
   }
-  let inputValue = inputNode.value;
+  let inputValue = jsterm.getInputValue();
   EventUtils.synthesizeKey("p", { ctrlKey: true });
   is(inputNode.selectionStart, 0,
      "ctrl-p at beginning of history moves caret location to beginning " +
      "of line");
-  is(inputNode.value, inputValue,
+  is(jsterm.getInputValue(), inputValue,
      "no change to input value on ctrl-p from beginning of line");
 
   // Navigate forwards history with ctrl-n
   for (let i = 1; i < values.length; i++) {
     EventUtils.synthesizeKey("n", { ctrlKey: true });
-    is(inputNode.value, values[i],
+    is(jsterm.getInputValue(), values[i],
        "ctrl-n updates inputNode from forwards history values[" + i + "]");
     is(inputNode.selectionStart, values[i].length,
        "caret location correct at end of history input for values[" + i + "]");
   }
   EventUtils.synthesizeKey("n", { ctrlKey: true });
-  ok(!inputNode.value, "ctrl-n at end of history updates to empty input");
+  ok(!jsterm.getInputValue(), "ctrl-n at end of history updates to empty input");
 
   // Simulate editing multi-line
   inputValue = "one\nlinebreak";
   jsterm.setInputValue(inputValue);
 
   // Attempt nav within input
   EventUtils.synthesizeKey("p", { ctrlKey: true });
-  is(inputNode.value, inputValue,
+  is(jsterm.getInputValue(), inputValue,
      "ctrl-p from end of multi-line does not trigger history");
 
   EventUtils.synthesizeKey("a", { ctrlKey: true });
   EventUtils.synthesizeKey("p", { ctrlKey: true });
-  is(inputNode.value, values[values.length - 1],
+  is(jsterm.getInputValue(), values[values.length - 1],
      "ctrl-p from start of multi-line triggers history");
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js b/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
@@ -23,41 +23,41 @@ add_task(function* () {
   let hud = yield openConsole();
 
   testEditedInputHistory(hud);
 });
 
 function testEditedInputHistory(HUD) {
   let jsterm = HUD.jsterm;
   let inputNode = jsterm.inputNode;
-  ok(!inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "jsterm.getInputValue() is empty");
   is(inputNode.selectionStart, 0);
   is(inputNode.selectionEnd, 0);
 
   jsterm.setInputValue('"first item"');
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"first item"', "null test history up");
+  is(jsterm.getInputValue(), '"first item"', "null test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"first item"', "null test history down");
+  is(jsterm.getInputValue(), '"first item"', "null test history down");
 
   jsterm.execute();
-  is(inputNode.value, "", "cleared input line after submit");
+  is(jsterm.getInputValue(), "", "cleared input line after submit");
 
   jsterm.setInputValue('"editing input 1"');
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"first item"', "test history up");
+  is(jsterm.getInputValue(), '"first item"', "test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"editing input 1"',
+  is(jsterm.getInputValue(), '"editing input 1"',
     "test history down restores in-progress input");
 
   jsterm.setInputValue('"second item"');
   jsterm.execute();
   jsterm.setInputValue('"editing input 2"');
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"second item"', "test history up");
+  is(jsterm.getInputValue(), '"second item"', "test history up");
   EventUtils.synthesizeKey("VK_UP", {});
-  is(inputNode.value, '"first item"', "test history up");
+  is(jsterm.getInputValue(), '"first item"', "test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"second item"', "test history down");
+  is(jsterm.getInputValue(), '"second item"', "test history down");
   EventUtils.synthesizeKey("VK_DOWN", {});
-  is(inputNode.value, '"editing input 2"',
+  is(jsterm.getInputValue(), '"editing input 2"',
      "test history down restores new in-progress input again");
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
--- a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
+++ b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
@@ -52,15 +52,15 @@ add_task(function*() {
   yield waitForContextMenu(contextMenu, text, () => {
     ok(storeAsGlobalItem.disabled === true, "The \"Store as global\" " +
       "context menu item should be disabled for texts");
   });
 
   info("Waiting for input to be set");
   yield onceInputSet;
 
-  is(hud.jsterm.inputNode.value, "temp0", "Input was set");
+  is(hud.jsterm.getInputValue(), "temp0", "Input was set");
   let executedResult = yield hud.jsterm.execute();
 
   ok(executedResult.textContent.includes("{ baz: 1 }"),
      "Correct variable assigned into console");
 
 });
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -3247,17 +3247,17 @@ JSTerm.prototype = {
     }
   },
 
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [executeString]
    *        The string you want to execute. If this is not provided, the current
-   *        user input is used - taken from |this.inputNode.value|.
+   *        user input is used - taken from |this.getInputValue()|.
    * @param function [callback]
    *        Optional function to invoke when the result is displayed.
    *        This is deprecated - please use the promise return value instead.
    * @returns Promise
    *          Resolves with the message once the result is displayed.
    */
   execute: function JST_execute(executeString, callback)
   {
@@ -3265,17 +3265,17 @@ JSTerm.prototype = {
     let resultCallback = function(msg) {
       deferred.resolve(msg);
       if (callback) {
         callback(msg);
       }
     }
 
     // attempt to execute the content of the inputNode
-    executeString = executeString || this.inputNode.value;
+    executeString = executeString || this.getInputValue();
     if (!executeString) {
       return;
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
     if (inspectorSelection && inspectorSelection.nodeFront) {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
@@ -3859,25 +3859,33 @@ JSTerm.prototype = {
     this.lastInputValue = newValue;
     this.completeNode.value = "";
     this.resizeInput();
     this._inputChanged = true;
     this.emit("set-input-value");
   },
 
   /**
+   * Gets the value from the input field
+   */
+  getInputValue: function()
+  {
+    return this.inputNode.value || "";
+  },
+
+  /**
    * The inputNode "input" and "keyup" event handler.
    * @private
    */
   _inputEventHandler: function JST__inputEventHandler()
   {
-    if (this.lastInputValue != this.inputNode.value) {
+    if (this.lastInputValue != this.getInputValue()) {
       this.resizeInput();
       this.complete(this.COMPLETE_HINT_ONLY);
-      this.lastInputValue = this.inputNode.value;
+      this.lastInputValue = this.getInputValue();
       this._inputChanged = true;
     }
   },
 
   /**
    * The window "blur" event handler.
    * @private
    */
@@ -3892,31 +3900,32 @@ JSTerm.prototype = {
    * The inputNode "keypress" event handler.
    *
    * @private
    * @param nsIDOMEvent event
    */
   _keyPress: function JST__keyPress(event)
   {
     let inputNode = this.inputNode;
+    let inputValue = this.getInputValue();
     let inputUpdated = false;
 
     if (event.ctrlKey) {
       switch (event.charCode) {
         case 101:
           // control-e
           if (Services.appinfo.OS == "WINNT") {
             break;
           }
-          let lineEndPos = inputNode.value.length;
+          let lineEndPos = inputValue.length;
           if (this.hasMultilineInput()) {
             // find index of closest newline >= cursor
             for (let i = inputNode.selectionEnd; i<lineEndPos; i++) {
-              if (inputNode.value.charAt(i) == "\r" ||
-                  inputNode.value.charAt(i) == "\n") {
+              if (inputValue.charAt(i) == "\r" ||
+                  inputValue.charAt(i) == "\n") {
                 lineEndPos = i;
                 break;
               }
             }
           }
           inputNode.setSelectionRange(lineEndPos, lineEndPos);
           event.preventDefault();
           this.clearCompletion();
@@ -4055,43 +4064,43 @@ JSTerm.prototype = {
         }
         event.preventDefault();
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_HOME:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectedIndex = 0;
           event.preventDefault();
-        } else if (this.inputNode.value.length <= 0) {
+        } else if (inputValue.length <= 0) {
           this.hud.outputNode.parentNode.scrollTop = 0;
           event.preventDefault();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_END:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectedIndex = this.autocompletePopup.itemCount - 1;
           event.preventDefault();
-        } else if (this.inputNode.value.length <= 0) {
+        } else if (inputValue.length <= 0) {
           this.hud.outputNode.parentNode.scrollTop = this.hud.outputNode.parentNode.scrollHeight;
           event.preventDefault();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
         if (this.autocompletePopup.isOpen || this.lastCompletion.value) {
           this.clearCompletion();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_RIGHT: {
         let cursorAtTheEnd = this.inputNode.selectionStart ==
                              this.inputNode.selectionEnd &&
                              this.inputNode.selectionStart ==
-                             this.inputNode.value.length;
+                             inputValue.length;
         let haveSuggestion = this.autocompletePopup.isOpen ||
                              this.lastCompletion.value;
         let useCompletion = cursorAtTheEnd || this._autocompletePopupNavigated;
         if (haveSuggestion && useCompletion &&
             this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion.value &&
             this.acceptProposedCompletion()) {
           event.preventDefault();
@@ -4149,17 +4158,17 @@ JSTerm.prototype = {
       }
       let inputVal = this.history[--this.historyPlaceHolder];
 
       // Save the current input value as the latest entry in history, only if
       // the user is already at the last entry.
       // Note: this code does not store changes to items that are already in
       // history.
       if (this.historyPlaceHolder+1 == this.historyIndex) {
-        this.history[this.historyIndex] = this.inputNode.value || "";
+        this.history[this.historyIndex] = this.getInputValue() || "";
       }
 
       this.setInputValue(inputVal);
     }
     // Down Arrow key
     else if (direction == HISTORY_FORWARD) {
       if (this.historyPlaceHolder >= (this.history.length-1)) {
         return false;
@@ -4178,17 +4187,17 @@ JSTerm.prototype = {
   /**
    * Test for multiline input.
    *
    * @return boolean
    *         True if CR or LF found in node value; else false.
    */
   hasMultilineInput: function JST_hasMultilineInput()
   {
-    return /[\r\n]/.test(this.inputNode.value);
+    return /[\r\n]/.test(this.getInputValue());
   },
 
   /**
    * Check if the caret is at a location that allows selecting the previous item
    * in history when the user presses the Up arrow key.
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the
@@ -4248,28 +4257,28 @@ JSTerm.prototype = {
    *    - this.COMPLETE_PAGEUP: Scroll up one page if available or select the first
    *          item.
    *    - this.COMPLETE_PAGEDOWN: Scroll down one page if available or select the
    *          last item.
    *    - this.COMPLETE_HINT_ONLY: If there is more than one possible
    *          completion and the input value stayed the same compared to the
    *          last time this function was called, then the same completion is
    *          used again. If there is only one possible completion, then
-   *          the inputNode.value is set to this value and the selection is set
+   *          the this.getInputValue() is set to this value and the selection is set
    *          from the current cursor position to the end of the completed text.
    * @param function callback
    *        Optional function invoked when the autocomplete properties are
    *        updated.
    * @returns boolean true if there existed a completion for the current input,
    *          or false otherwise.
    */
   complete: function JSTF_complete(type, callback)
   {
     let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
+    let inputValue = this.getInputValue();
     let frameActor = this.getFrameActor(this.SELECTED_FRAME);
 
     // If the inputNode has no value, then don't try to complete on it.
     if (!inputValue) {
       this.clearCompletion();
       callback && callback(this);
       this.emit("autocomplete-updated");
       return false;
@@ -4323,23 +4332,24 @@ JSTerm.prototype = {
    *        Completion type. See this.complete() for details.
    * @param function [callback]
    *        Optional, function to invoke when completion results are received.
    */
   _updateCompletionResult:
   function JST__updateCompletionResult(type, callback)
   {
     let frameActor = this.getFrameActor(this.SELECTED_FRAME);
-    if (this.lastCompletion.value == this.inputNode.value && frameActor == this._lastFrameActorId) {
+    if (this.lastCompletion.value == this.getInputValue() &&
+        frameActor == this._lastFrameActorId) {
       return;
     }
 
     let requestId = gSequenceId();
     let cursor = this.inputNode.selectionStart;
-    let input = this.inputNode.value.substring(0, cursor);
+    let input = this.getInputValue().substring(0, cursor);
     let cache = this._autocompleteCache;
 
     // If the current input starts with the previous input, then we already
     // have a list of suggestions and we just need to filter the cached
     // suggestions. When the current input ends with a non-alphanumeric
     // character we ask the server again for suggestions.
 
     // Check if last character is non-alphanumeric
@@ -4399,17 +4409,17 @@ JSTerm.prototype = {
    * @param object message
    *        The JSON message which holds the completion results received from
    *        the content process.
    */
   _receiveAutocompleteProperties:
   function JST__receiveAutocompleteProperties(requestId, callback, message)
   {
     let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
+    let inputValue = this.getInputValue();
     if (this.lastCompletion.value == inputValue ||
         requestId != this.lastCompletion.requestId) {
       return;
     }
     // Cache whatever came from the server if the last char is alphanumeric or '.'
     let cursor = inputNode.selectionStart;
     let inputUntilCursor = inputValue.substring(0, cursor);
 
@@ -4436,17 +4446,17 @@ JSTerm.prototype = {
 
     let completionType = this.lastCompletion.completionType;
     this.lastCompletion = {
       value: inputValue,
       matchProp: lastPart,
     };
 
     if (items.length > 1 && !popup.isOpen) {
-      let str = this.inputNode.value.substr(0, this.inputNode.selectionStart);
+      let str = this.getInputValue().substr(0, this.inputNode.selectionStart);
       let offset = str.length - (str.lastIndexOf("\n") + 1) - lastPart.length;
       let x = offset * this.hud._inputCharWidth;
       popup.openPopup(inputNode, x + this.hud._chevronWidth);
       this._autocompletePopupNavigated = false;
     }
     else if (items.length < 2 && popup.isOpen) {
       popup.hidePopup();
       this._autocompletePopupNavigated = false;
@@ -4470,17 +4480,17 @@ JSTerm.prototype = {
 
     callback && callback(this);
     this.emit("autocomplete-updated");
   },
 
   onAutocompleteSelect: function JSTF_onAutocompleteSelect()
   {
     // Render the suggestion only if the cursor is at the end of the input.
-    if (this.inputNode.selectionStart != this.inputNode.value.length) {
+    if (this.inputNode.selectionStart != this.getInputValue().length) {
       return;
     }
 
     let currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.updateCompleteNode(suffix);
@@ -4516,17 +4526,17 @@ JSTerm.prototype = {
   {
     let updated = false;
 
     let currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       let cursor = this.inputNode.selectionStart;
-      let value = this.inputNode.value;
+      let value = this.getInputValue();
       this.setInputValue(value.substr(0, cursor) + suffix + value.substr(cursor));
       let newCursor = cursor + suffix.length;
       this.inputNode.selectionStart = this.inputNode.selectionEnd = newCursor;
       updated = true;
     }
 
     this.clearCompletion();
 
@@ -4537,17 +4547,17 @@ JSTerm.prototype = {
    * Update the node that displays the currently selected autocomplete proposal.
    *
    * @param string suffix
    *        The proposed suffix for the inputNode value.
    */
   updateCompleteNode: function JSTF_updateCompleteNode(suffix)
   {
     // completion prefix = input, with non-control chars replaced by spaces
-    let prefix = suffix ? this.inputNode.value.replace(/[\S]/g, " ") : "";
+    let prefix = suffix ? this.getInputValue().replace(/[\S]/g, " ") : "";
     this.completeNode.value = prefix + suffix;
   },
 
 
   /**
    * Destroy the sidebar.
    * @private
    */
