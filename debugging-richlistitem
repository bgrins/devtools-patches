# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  74001bb2abbeaa766f5a29c39c5553c693dfc2d0

diff --git a/browser/components/preferences/in-content/main.js b/browser/components/preferences/in-content/main.js
--- a/browser/components/preferences/in-content/main.js
+++ b/browser/components/preferences/in-content/main.js
@@ -1537,18 +1537,20 @@ var gMainPane = {
 
     var visibleTypes = this._visibleTypes;
 
     // If the user is filtering the list, then only show matching types.
     if (this._filter.value)
       visibleTypes = visibleTypes.filter(this._matchesFilter, this);
 
     for (let visibleType of visibleTypes) {
-      let item = new HandlerListItem(visibleType);
-      this._list.appendChild(item.node);
+      let node = document.createElement("richlistitem");
+      this._list.appendChild(node);
+      // this._list.appendChild(item.node);
+      let item = new HandlerListItem(visibleType, node);
 
       if (visibleType.type === lastSelectedType) {
         this._list.selectedItem = item.node;
       }
     }
   },
 
   _matchesFilter(aType) {
@@ -1605,18 +1607,18 @@ var gMainPane = {
    * Rebuild the actions menu for the selected entry.  Gets called by
    * the richlistitem constructor when an entry in the list gets selected.
    */
   rebuildActionsMenu() {
     var typeItem = this._list.selectedItem;
     var handlerInfo = this.selectedHandlerListItem.handlerInfoWrapper;
     var menu = typeItem.querySelector("[class=actionsMenu]");
 
+    console.log("rebuildActionsMenu", typeItem, menu, menu.innerHTML, document.getAnonymousNodes(menu), handlerInfo, menu.menupopup, window.getComputedStyle(menu).getPropertyValue("-moz-binding"));
     var menuPopup = menu.menupopup;
-
     // Clear out existing items.
     while (menuPopup.hasChildNodes())
       menuPopup.removeChild(menuPopup.lastChild);
 
     let internalMenuItem;
     // Add the "Preview in Firefox" option for optional internal handlers.
     if (handlerInfo instanceof InternalHandlerInfoWrapper) {
       internalMenuItem = document.createElement("menuitem");
@@ -2441,60 +2443,84 @@ ArrayEnumerator.prototype = {
     return this._contents[this._index++];
   }
 };
 
 function isFeedType(t) {
   return t == TYPE_MAYBE_FEED || t == TYPE_MAYBE_VIDEO_FEED || t == TYPE_MAYBE_AUDIO_FEED;
 }
 
+
+// Helper function needed to create a DOM that will still get XBL attached
+// when accessing DOM nodes. This is needed because:
+// If you do something like `textbox = document.createElement("textbox")`,
+// then `textbox` won't have a XBL binding attached, since the JS reflector
+// gets created before it's in the document. This is usually fine, since
+// the textbox will get a binding attached after layout, but if the
+// parent node is hidden, then the textbox never will get it.
+// Using this function, we append the elements into the DOM before accessing
+// them directly from JS, so the constructor will run eagerly on the next
+// JS access once it's appended into the parent.
 function parseDOM(str) {
   const d = new DOMParser();
-  d.forceEnableXULXBL();
+  d.forceEnableXULXBL()
   const doc = d.parseFromString(
-    `<xul:box xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">${str}</xul:box>`,
+    `<box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">${str}</box>`,
     "application/xml");
-  //const range = doc.createRange();
-  //range.selectNodeContents(doc.firstChild);
-  //return range.extractContents();
-  return doc.firstChild.firstElementChild;
+  const range = doc.createRange();
+  range.selectNodeContents(doc.firstChild);
+  return range.extractContents();
 }
 
+
+// function parseDOM(str) {
+//   const d = new DOMParser();
+//   d.forceEnableXULXBL();
+//   const doc = d.parseFromString(
+//     `<box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">${str}</box>`,
+//     "application/xml");
+//   const range = doc.createRange();
+//   range.selectNodeContents(doc.firstChild);
+//   return range.extractContents();
+//   // return doc.firstChild.firstElementChild;
+// }
+
 /**
  * This is associated to <richlistitem> elements in the handlers view.
  */
 class HandlerListItem {
   static forNode(node) {
     return gNodeToObjectMap.get(node);
   }
 
-  constructor(handlerInfoWrapper) {
+  constructor(handlerInfoWrapper, node) {
     this.handlerInfoWrapper = handlerInfoWrapper;
-    this.node = document.createElement("richlistitem");
+    this.node = node;
     this.node.appendChild(parseDOM(`
-      <xul:hbox flex="1" equalsize="always">
-        <xul:hbox flex="1" align="center" inherits="tooltiptext=typeDescription">
-          <xul:image src="moz-icon://goat?size=16" class="typeIcon"
+      <hbox flex="1" equalsize="always">
+        <hbox flex="1" align="center" inherits="tooltiptext=typeDescription">
+          <image src="moz-icon://goat?size=16" class="typeIcon"
                      inherits="src=typeIcon" height="16" width="16"/>
-          <xul:label flex="1" crop="end" inherits="value=typeDescription"/>
-        </xul:hbox>
-        <xul:hbox anonid="not-selected" flex="1" align="center" inherits="tooltiptext=actionDescription">
-          <xul:image inherits="src=actionIcon" height="16" width="16" class="actionIcon"/>
-          <xul:label flex="1" crop="end" inherits="value=actionDescription"/>
-        </xul:hbox>
-        <xul:hbox hidden="true" anonid="selected" flex="1">
-          <xul:menulist class="actionsMenu" flex="1" crop="end" selectedIndex="1"
+          <label flex="1" crop="end" inherits="value=typeDescription"/>
+        </hbox>
+        <hbox anonid="not-selected" flex="1" align="center" inherits="tooltiptext=actionDescription">
+          <image inherits="src=actionIcon" height="16" width="16" class="actionIcon"/>
+          <label flex="1" crop="end" inherits="value=actionDescription"/>
+        </hbox>
+        <hbox hidden="true" anonid="selected" flex="1">
+          <menulist class="actionsMenu" flex="1" crop="end" selectedIndex="1"
                         inherits="tooltiptext=actionDescription">
-            <xul:menupopup/>
-          </xul:menulist>
-        </xul:hbox>
-      </xul:hbox>
+            <menupopup/>
+          </menulist>
+        </hbox>
+      </hbox>
     `));
     gNodeToObjectMap.set(this.node, this);
 
+    console.log("Appended!", this.node.querySelector(".actionsMenu").menupopup);
     this.node.querySelector('[class="actionsMenu"]').addEventListener("command",
       event => gMainPane.onSelectAction(event.originalTarget));
 
     this.node.setAttribute("type", this.handlerInfoWrapper.type);
     this.node.querySelector('[inherits="value=typeDescription"]')
              .setAttribute("value", this.handlerInfoWrapper.typeDescription);
     if (this.handlerInfoWrapper.smallIcon) {
       this.node.querySelector('[inherits="src=typeIcon"]')
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -145,19 +145,23 @@
                             onget="return this.hasAttribute('open');"/>
 
       <property name="itemCount" readonly="true"
                 onget="return this.menupopup ? this.menupopup.childNodes.length : 0"/>
 
       <property name="menupopup" readonly="true">
         <getter>
           <![CDATA[
+          console.log("Calling menupopup getter");
             var popup = this.firstChild;
-            while (popup && popup.localName != "menupopup")
+            while (popup && popup.localName != "menupopup") {
+            console.log(popup.localName);
               popup = popup.nextSibling;
+              }
+            console.log(popup && popup.localName);
             return popup;
           ]]>
         </getter>
       </property>
 
       <method name="contains">
         <parameter name="item"/>
         <body>
