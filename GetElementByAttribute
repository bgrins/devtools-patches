# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4f12d77b4f9b6adaf06615c1c8cdc14de836dc1a
Bug 1475342 - Support document.getElementsByAttribute[NS] in chrome HTML documents

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -5970,16 +5970,63 @@ GetElementByAttribute(Element* aElement,
                             aUniversalMatch);
     if (matchedElement)
       return matchedElement;
   }
 
   return nullptr;
 }
 
+already_AddRefed<nsINodeList>
+nsIDocument::GetElementsByAttribute(const nsAString& aAttribute,
+                       const nsAString& aValue)
+{
+    RefPtr<nsAtom> attrAtom(NS_Atomize(aAttribute));
+    nsAutoPtr<nsString> attrValue(new nsString(aValue));
+    RefPtr<nsContentList> list = new nsContentList(this,
+                                            MatchAttribute,
+                                            nsContentUtils::DestroyMatchString,
+                                            attrValue.forget(),
+                                            true,
+                                            attrAtom,
+                                            kNameSpaceID_Unknown);
+
+    return list.forget();
+}
+
+already_AddRefed<nsINodeList>
+nsIDocument::GetElementsByAttributeNS(const nsAString& aNamespaceURI,
+                         const nsAString& aAttribute,
+                         const nsAString& aValue,
+                         ErrorResult& aRv)
+{
+    RefPtr<nsAtom> attrAtom(NS_Atomize(aAttribute));
+    nsAutoPtr<nsString> attrValue(new nsString(aValue));
+
+    int32_t nameSpaceId = kNameSpaceID_Wildcard;
+    if (!aNamespaceURI.EqualsLiteral("*")) {
+      nsresult rv =
+        nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
+                                                              nameSpaceId);
+      if (NS_FAILED(rv)) {
+          aRv.Throw(rv);
+          return nullptr;
+      }
+    }
+
+    RefPtr<nsContentList> list = new nsContentList(this,
+                                            MatchAttribute,
+                                            nsContentUtils::DestroyMatchString,
+                                            attrValue.forget(),
+                                            true,
+                                            attrAtom,
+                                            nameSpaceId);
+    return list.forget();
+}
+
 Element*
 nsIDocument::GetAnonymousElementByAttribute(nsIContent* aElement,
                                             nsAtom* aAttrName,
                                             const nsAString& aAttrValue) const
 {
   nsINodeList* nodeList = BindingManager()->GetAnonymousNodesFor(aElement);
   if (!nodeList)
     return nullptr;
@@ -6698,16 +6745,57 @@ nsIDocument::Anchors()
   if (!mAnchors) {
     mAnchors = new nsContentList(this, MatchAnchors, nullptr, nullptr);
   }
   return mAnchors;
 }
 
 /* static */
 bool
+nsIDocument::MatchAttribute(Element* aElement,
+               int32_t aNamespaceID,
+               nsAtom* aAttrName,
+               void* aData)
+{
+    MOZ_ASSERT(aElement, "Must have content node to work with!");
+    nsString* attrValue = static_cast<nsString*>(aData);
+    if (aNamespaceID != kNameSpaceID_Unknown &&
+        aNamespaceID != kNameSpaceID_Wildcard) {
+        return attrValue->EqualsLiteral("*") ?
+            aElement->HasAttr(aNamespaceID, aAttrName) :
+            aElement->AttrValueIs(aNamespaceID, aAttrName, *attrValue,
+                                  eCaseMatters);
+    }
+
+    // Qualified name match. This takes more work.
+
+    uint32_t count = aElement->GetAttrCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        const nsAttrName* name = aElement->GetAttrNameAt(i);
+        bool nameMatch;
+        if (name->IsAtom()) {
+            nameMatch = name->Atom() == aAttrName;
+        } else if (aNamespaceID == kNameSpaceID_Wildcard) {
+            nameMatch = name->NodeInfo()->Equals(aAttrName);
+        } else {
+            nameMatch = name->NodeInfo()->QualifiedNameEquals(aAttrName);
+        }
+
+        if (nameMatch) {
+            return attrValue->EqualsLiteral("*") ||
+                aElement->AttrValueIs(name->NamespaceID(), name->LocalName(),
+                                      *attrValue, eCaseMatters);
+        }
+    }
+
+    return false;
+}
+
+/* static */
+bool
 nsIDocument::MatchNameAttribute(Element* aElement, int32_t aNamespaceID,
                                 nsAtom* aAtom, void* aData)
 {
   MOZ_ASSERT(aElement, "Must have element to work with!");
 
   if (!aElement->HasName()) {
     return false;
   }
diff --git a/dom/base/nsIDocument.h b/dom/base/nsIDocument.h
--- a/dom/base/nsIDocument.h
+++ b/dom/base/nsIDocument.h
@@ -2295,16 +2295,25 @@ public:
    * Check whether we've ever fired a DOMTitleChanged event for this
    * document.
    */
   bool HaveFiredDOMTitleChange() const
   {
     return mHaveFiredTitleChange;
   }
 
+  already_AddRefed<nsINodeList>
+    GetElementsByAttribute(const nsAString& aAttribute,
+                           const nsAString& aValue);
+  already_AddRefed<nsINodeList>
+    GetElementsByAttributeNS(const nsAString& aNamespaceURI,
+                             const nsAString& aAttribute,
+                             const nsAString& aValue,
+                             ErrorResult& aRv);
+
   Element* GetAnonymousElementByAttribute(nsIContent* aElement,
                                           nsAtom* aAttrName,
                                           const nsAString& aAttrValue) const;
 
   nsresult NodesFromRectHelper(float aX, float aY,
                                float aTopSize, float aRightSize,
                                float aBottomSize, float aLeftSize,
                                bool aIgnoreRootScrollFrame,
@@ -3694,16 +3703,21 @@ protected:
   // Helper for GetScrollingElement/IsScrollingElement.
   bool IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement* aBody);
 
   // Return the same type parent docuement if exists, or return null.
   nsIDocument* GetSameTypeParentDocument();
 
   void MaybeAllowStorageForOpener();
 
+  static bool MatchAttribute(Element* aContent,
+                             int32_t aNameSpaceID,
+                             nsAtom* aAttrName,
+                             void* aData);
+
   // Helpers for GetElementsByName.
   static bool MatchNameAttribute(mozilla::dom::Element* aElement,
                                  int32_t aNamespaceID,
                                  nsAtom* aAtom, void* aData);
   static void* UseExistingNameString(nsINode* aRootNode, const nsString* aName);
 
   void MaybeResolveReadyForIdle();
 
diff --git a/dom/webidl/Document.webidl b/dom/webidl/Document.webidl
--- a/dom/webidl/Document.webidl
+++ b/dom/webidl/Document.webidl
@@ -344,16 +344,23 @@ partial interface Document {
   [Func="IsChromeOrXBL"]
   Element? getAnonymousElementByAttribute(Element elt, DOMString attrName,
                                           DOMString attrValue);
   [Func="IsChromeOrXBL"]
   Element? getBindingParent(Node node);
   [Throws, Func="IsChromeOrXBL", NeedsSubjectPrincipal]
   void loadBindingDocument(DOMString documentURL);
 
+  [Func="IsChromeOrXBL"]
+  NodeList getElementsByAttribute(DOMString name,
+                                  [TreatNullAs=EmptyString] DOMString value);
+  [Throws, Func="IsChromeOrXBL"]
+  NodeList getElementsByAttributeNS(DOMString? namespaceURI, DOMString name,
+                                    [TreatNullAs=EmptyString] DOMString value);
+
   // Touch bits
   // XXXbz I can't find the sane spec for this stuff, so just cribbing
   // from our xpidl for now.
   [NewObject, Func="nsGenericHTMLElement::TouchEventsEnabled"]
   Touch createTouch(optional Window? view = null,
                     optional EventTarget? target = null,
                     optional long identifier = 0,
                     optional long pageX = 0,
diff --git a/dom/webidl/XULDocument.webidl b/dom/webidl/XULDocument.webidl
--- a/dom/webidl/XULDocument.webidl
+++ b/dom/webidl/XULDocument.webidl
@@ -21,22 +21,16 @@ interface XULDocument : Document {
   readonly attribute Node? popupRangeParent;
   [Throws, ChromeOnly]
   readonly attribute long  popupRangeOffset;
 
            attribute Node? tooltipNode;
 
   readonly attribute XULCommandDispatcher? commandDispatcher;
 
-  NodeList getElementsByAttribute(DOMString name,
-                                  [TreatNullAs=EmptyString] DOMString value);
-  [Throws]
-  NodeList getElementsByAttributeNS(DOMString? namespaceURI, DOMString name,
-                                    [TreatNullAs=EmptyString] DOMString value);
-
   [Throws]
   void addBroadcastListenerFor(Element broadcaster, Element observer,
                                DOMString attr);
   void removeBroadcastListenerFor(Element broadcaster, Element observer,
                                   DOMString attr);
 
   [Throws]
   void persist([TreatNullAs=EmptyString] DOMString id, DOMString attr);
diff --git a/dom/xul/XULDocument.cpp b/dom/xul/XULDocument.cpp
--- a/dom/xul/XULDocument.cpp
+++ b/dom/xul/XULDocument.cpp
@@ -946,63 +946,16 @@ XULDocument::ResolveForwardReferences()
     return NS_OK;
 }
 
 //----------------------------------------------------------------------
 //
 // nsIDocument interface
 //
 
-already_AddRefed<nsINodeList>
-XULDocument::GetElementsByAttribute(const nsAString& aAttribute,
-                                    const nsAString& aValue)
-{
-    RefPtr<nsAtom> attrAtom(NS_Atomize(aAttribute));
-    nsAutoPtr<nsString> attrValue(new nsString(aValue));
-    RefPtr<nsContentList> list = new nsContentList(this,
-                                            MatchAttribute,
-                                            nsContentUtils::DestroyMatchString,
-                                            attrValue.forget(),
-                                            true,
-                                            attrAtom,
-                                            kNameSpaceID_Unknown);
-
-    return list.forget();
-}
-
-already_AddRefed<nsINodeList>
-XULDocument::GetElementsByAttributeNS(const nsAString& aNamespaceURI,
-                                      const nsAString& aAttribute,
-                                      const nsAString& aValue,
-                                      ErrorResult& aRv)
-{
-    RefPtr<nsAtom> attrAtom(NS_Atomize(aAttribute));
-    nsAutoPtr<nsString> attrValue(new nsString(aValue));
-
-    int32_t nameSpaceId = kNameSpaceID_Wildcard;
-    if (!aNamespaceURI.EqualsLiteral("*")) {
-      nsresult rv =
-        nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
-                                                              nameSpaceId);
-      if (NS_FAILED(rv)) {
-          aRv.Throw(rv);
-          return nullptr;
-      }
-    }
-
-    RefPtr<nsContentList> list = new nsContentList(this,
-                                            MatchAttribute,
-                                            nsContentUtils::DestroyMatchString,
-                                            attrValue.forget(),
-                                            true,
-                                            attrAtom,
-                                            nameSpaceId);
-    return list.forget();
-}
-
 void
 XULDocument::Persist(const nsAString& aID,
                      const nsAString& aAttr,
                      ErrorResult& aRv)
 {
     // If we're currently reading persisted attributes out of the
     // localstore, _don't_ re-enter and try to set them again!
     if (mApplyingPersistedAttrs) {
@@ -1418,57 +1371,16 @@ XULDocument::StartLayout(void)
 
         nsresult rv = shell->Initialize();
         NS_ENSURE_SUCCESS(rv, rv);
     }
 
     return NS_OK;
 }
 
-/* static */
-bool
-XULDocument::MatchAttribute(Element* aElement,
-                            int32_t aNamespaceID,
-                            nsAtom* aAttrName,
-                            void* aData)
-{
-    MOZ_ASSERT(aElement, "Must have content node to work with!");
-    nsString* attrValue = static_cast<nsString*>(aData);
-    if (aNamespaceID != kNameSpaceID_Unknown &&
-        aNamespaceID != kNameSpaceID_Wildcard) {
-        return attrValue->EqualsLiteral("*") ?
-            aElement->HasAttr(aNamespaceID, aAttrName) :
-            aElement->AttrValueIs(aNamespaceID, aAttrName, *attrValue,
-                                  eCaseMatters);
-    }
-
-    // Qualified name match. This takes more work.
-
-    uint32_t count = aElement->GetAttrCount();
-    for (uint32_t i = 0; i < count; ++i) {
-        const nsAttrName* name = aElement->GetAttrNameAt(i);
-        bool nameMatch;
-        if (name->IsAtom()) {
-            nameMatch = name->Atom() == aAttrName;
-        } else if (aNamespaceID == kNameSpaceID_Wildcard) {
-            nameMatch = name->NodeInfo()->Equals(aAttrName);
-        } else {
-            nameMatch = name->NodeInfo()->QualifiedNameEquals(aAttrName);
-        }
-
-        if (nameMatch) {
-            return attrValue->EqualsLiteral("*") ||
-                aElement->AttrValueIs(name->NamespaceID(), name->LocalName(),
-                                      *attrValue, eCaseMatters);
-        }
-    }
-
-    return false;
-}
-
 nsresult
 XULDocument::PrepareToLoadPrototype(nsIURI* aURI, const char* aCommand,
                                     nsIPrincipal* aDocumentPrincipal,
                                     nsIParser** aResult)
 {
     nsresult rv;
 
     // Create a new prototype document.
