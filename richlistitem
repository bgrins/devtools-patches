# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  19480c5351171537652af013289a595fa4d66ede
Bug XXX - Convert richlistitem to a Custom Element

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -279,29 +279,94 @@ MozElements.BaseControl = class BaseCont
       this.removeAttribute("tabindex");
     }
   }
 };
 
 MozXULElement.implementCustomInterface(MozElements.BaseControl,
                                        [Ci.nsIDOMXULControlElement]);
 
+MozElements.BaseText = class Basetext extends MozXULElement {
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    this.labelElement = "";
+
+  }
+  /**
+   * public implementation
+   */
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set crop(val) {
+    this.setAttribute("crop", val);
+    return val;
+  }
+
+  get crop() {
+    return this.getAttribute("crop");
+  }
+
+  set image(val) {
+    this.setAttribute("image", val);
+    return val;
+  }
+
+  get image() {
+    return this.getAttribute("image");
+  }
+
+  set command(val) {
+    this.setAttribute("command", val);
+    return val;
+  }
+
+  get command() {
+    return this.getAttribute("command");
+  }
+
+  set accessKey(val) {
+    // Always store on the control
+    this.setAttribute("accesskey", val);
+    // If there is a label, change the accesskey on the labelElement
+    // if it's also set there
+    if (this.labelElement) {
+      this.labelElement.accessKey = val;
+    }
+    return val;
+  }
+
+  get accessKey() {
+    return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+  }
+};
+
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozElements = MozElements;
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/radio.js",
+    "chrome://global/content/elements/richlistitem.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
     "chrome://global/content/elements/tree.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
   for (let [tag, script] of [
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -94,16 +94,17 @@ toolkit.jar:
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js          (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
+   content/global/elements/richlistitem.js     (widgets/richlistitem.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
    content/global/elements/marquee.js          (widgets/marquee.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
 #ifdef XP_MACOSX
diff --git a/toolkit/content/widgets/richlistitem.js b/toolkit/content/widgets/richlistitem.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/richlistitem.js
@@ -0,0 +1,175 @@
+
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+class MozRichlistitem extends MozElements.BaseText {
+  constructor() {
+    super();
+
+    this.selectedByMouseOver = false;
+
+    /**
+     * If there is no modifier key, we select on mousedown, not
+     * click, so that drags work correctly.
+     */
+    this.addEventListener("mousedown", (event) => {
+      var control = this.control;
+      if (!control || control.disabled)
+        return;
+      if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&
+        !event.shiftKey && !event.metaKey) {
+        if (!this.selected) {
+          control.selectItem(this);
+        }
+        control.currentItem = this;
+      }
+    });
+
+    /**
+     * On a click (up+down on the same item), deselect everything
+     * except this item.
+     */
+    this.addEventListener("click", (event) => {
+      if (event.button != 0) { return; }
+      var control = this.control;
+      if (!control || control.disabled)
+        return;
+      control._userSelecting = true;
+      if (control.selType != "multiple") {
+        control.selectItem(this);
+      } else if (event.ctrlKey || event.metaKey) {
+        control.toggleItemSelection(this);
+        control.currentItem = this;
+      } else if (event.shiftKey) {
+        control.selectItemRange(null, this);
+        control.currentItem = this;
+      } else {
+        /* We want to deselect all the selected items except what was
+          clicked, UNLESS it was a right-click.  We have to do this
+          in click rather than mousedown so that you can drag a
+          selected group of items */
+
+        // use selectItemRange instead of selectItem, because this
+        // doesn"t de- and reselect this item if it is selected
+        control.selectItemRange(this, this);
+      }
+      control._userSelecting = false;
+    });
+  }
+
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  get label() {
+    const XULNS =
+      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    return Array.map(this.getElementsByTagNameNS(XULNS, "label"),
+        label => label.value)
+      .join(" ");
+  }
+
+  set searchLabel(val) {
+    if (val !== null)
+      this.setAttribute("searchlabel", val);
+    else
+      // fall back to the label property (default value)
+      this.removeAttribute("searchlabel");
+    return val;
+  }
+
+  get searchLabel() {
+    return this.hasAttribute("searchlabel") ?
+      this.getAttribute("searchlabel") : this.label;
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  set value(val) {
+    this.setAttribute("value", val);
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  set selected(val) {
+    if (val)
+      this.setAttribute("selected", "true");
+    else
+      this.removeAttribute("selected");
+
+    return val;
+  }
+
+  get selected() {
+    return this.getAttribute("selected") == "true";
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  get control() {
+    var parent = this.parentNode;
+    while (parent) {
+      if (parent instanceof Ci.nsIDOMXULSelectControlElement)
+        return parent;
+      parent = parent.parentNode;
+    }
+    return null;
+  }
+
+  set current(val) {
+    if (val)
+      this.setAttribute("current", "true");
+    else
+      this.removeAttribute("current");
+
+    let control = this.control;
+    if (!control || !control.suppressMenuItemEvent) {
+      this._fireEvent(val ? "DOMMenuItemActive" : "DOMMenuItemInactive");
+    }
+
+    return val;
+  }
+
+  get current() {
+    return this.getAttribute("current") == "true";
+  }
+
+  _fireEvent(name) {
+    var event = document.createEvent("Events");
+    event.initEvent(name, true, true);
+    this.dispatchEvent(event);
+  }
+  disconnectedCallback() {
+    var control = this.control;
+    if (!control)
+      return;
+    // When we are destructed and we are current or selected, unselect ourselves
+    // so that richlistbox"s selection doesn"t point to something not in the DOM.
+    // We don"t want to reset last-selected, so we set _suppressOnSelect.
+    if (this.selected) {
+      var suppressSelect = control._suppressOnSelect;
+      control._suppressOnSelect = true;
+      control.removeItemFromSelection(this);
+      control._suppressOnSelect = suppressSelect;
+    }
+    if (this.current)
+      control.currentItem = null;
+  }
+}
+
+MozXULElement.implementCustomInterface(MozRichlistitem, [Ci.nsIDOMXULSelectControlItemElement]);
+customElements.define("richlistitem", MozRichlistitem);
+
+}
\ No newline at end of file
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -730,21 +730,16 @@ wizardpage {
 /********** Rich Listbox ********/
 
 richlistbox {
   -moz-binding: url('chrome://global/content/bindings/richlistbox.xml#richlistbox');
   -moz-user-focus: normal;
   -moz-box-orient: vertical;
 }
 
-richlistitem {
-  -moz-binding: url('chrome://global/content/bindings/richlistbox.xml#richlistitem');
-}
-
-
 /*********** findbar ************/
 findbar {
   overflow-x: hidden;
 }
 
 /*********** tabmodalprompt ************/
 tabmodalprompt {
   -moz-binding: url("chrome://global/content/tabprompts.xml#tabmodalprompt");
