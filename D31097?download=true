diff --git a/layout/generic/CSSOrderAwareFrameIterator.h b/layout/generic/CSSOrderAwareFrameIterator.h
--- a/layout/generic/CSSOrderAwareFrameIterator.h
+++ b/layout/generic/CSSOrderAwareFrameIterator.h
@@ -97,7 +97,7 @@
           // overflow. Chances are, this is just an author using BIG_VALUE
           // anyway, so the clamped value should be fine.
           uint32_t clampedBoxOrdinal = std::min(
-              child->StyleXUL()->mBoxOrdinal, static_cast<uint32_t>(INT32_MAX));
+              child->GetXULOrdinal(), static_cast<uint32_t>(INT32_MAX));
           order = static_cast<int32_t>(clampedBoxOrdinal);
         } else {
           order = child->StylePosition()->mOrder;
diff --git a/layout/generic/CSSOrderAwareFrameIterator.cpp b/layout/generic/CSSOrderAwareFrameIterator.cpp
--- a/layout/generic/CSSOrderAwareFrameIterator.cpp
+++ b/layout/generic/CSSOrderAwareFrameIterator.cpp
@@ -19,7 +19,7 @@
 template <>
 bool CSSOrderAwareFrameIterator::CSSBoxOrdinalGroupComparator(
     nsIFrame* const& a, nsIFrame* const& b) {
-  return a->StyleXUL()->mBoxOrdinal < b->StyleXUL()->mBoxOrdinal;
+  return a->GetXULOrdinal() < b->GetXULOrdinal();
 }
 
 template <>
diff --git a/layout/generic/nsFlexContainerFrame.h b/layout/generic/nsFlexContainerFrame.h
--- a/layout/generic/nsFlexContainerFrame.h
+++ b/layout/generic/nsFlexContainerFrame.h
@@ -159,6 +159,10 @@
    */
   uint32_t GetLineClampValue() const;
 
+  nsresult AttributeChanged(int32_t aNameSpaceID,
+                            nsAtom* aAttribute,
+                            int32_t aModType) override;
+
   // nsContainerFrame overrides
   uint16_t CSSAlignmentForAbsPosChild(
       const ReflowInput& aChildRI,
diff --git a/layout/generic/nsFlexContainerFrame.cpp b/layout/generic/nsFlexContainerFrame.cpp
--- a/layout/generic/nsFlexContainerFrame.cpp
+++ b/layout/generic/nsFlexContainerFrame.cpp
@@ -114,9 +114,33 @@
 
 // Returns the "align-items" value that's equivalent to the legacy "box-align"
 // value in the given style struct.
-static uint8_t ConvertLegacyStyleToAlignItems(const nsStyleXUL* aStyleXUL) {
+static uint8_t ConvertLegacyStyleToAlignItems(const nsIFrame* aFrame) {
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::stretch, eCaseMatters)) {
+      return NS_STYLE_ALIGN_STRETCH;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::start, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_START;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::center, eCaseMatters)) {
+      return NS_STYLE_ALIGN_CENTER;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::baseline, eCaseMatters)) {
+      return NS_STYLE_ALIGN_BASELINE;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
+                                          nsGkAtoms::end, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_END;
+    }
+  }
+
   // -[moz|webkit]-box-align corresponds to modern "align-items"
-  switch (aStyleXUL->mBoxAlign) {
+  switch (aFrame->StyleXUL()->mBoxAlign) {
     case StyleBoxAlign::Stretch:
       return NS_STYLE_ALIGN_STRETCH;
     case StyleBoxAlign::Start:
@@ -136,9 +160,25 @@
 
 // Returns the "justify-content" value that's equivalent to the legacy
 // "box-pack" value in the given style struct.
-static uint8_t ConvertLegacyStyleToJustifyContent(const nsStyleXUL* aStyleXUL) {
+static uint8_t ConvertLegacyStyleToJustifyContent(const nsIFrame* aFrame) {
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::pack,
+                                          nsGkAtoms::start, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_START;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::pack,
+                                          nsGkAtoms::center, eCaseMatters)) {
+      return NS_STYLE_ALIGN_CENTER;
+    }
+    if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::pack,
+                                          nsGkAtoms::end, eCaseMatters)) {
+      return NS_STYLE_ALIGN_FLEX_END;
+    }
+  }
+
   // -[moz|webkit]-box-pack corresponds to modern "justify-content"
-  switch (aStyleXUL->mBoxPack) {
+  switch (aFrame->StyleXUL()->mBoxPack) {
     case StyleBoxPack::Start:
       return NS_STYLE_ALIGN_FLEX_START;
     case StyleBoxPack::Center:
@@ -1283,7 +1323,11 @@
       // Items affected by -webkit-line-clamp are always inflexible.
       flexGrow = flexShrink = 0;
     } else {
-      flexGrow = flexShrink = aChildFrame->StyleXUL()->mBoxFlex;
+      nscoord flex = 0;
+      if (aChildFrame->Style()->GetPseudoType() != PseudoStyleType::anonymousFlexItem) {
+        nsFrame::AddXULFlex(aChildFrame, flex);
+      }
+      flexGrow = flexShrink = flex;
     }
   } else {
     const nsStylePosition* stylePos = aChildFrame->StylePosition();
@@ -1925,8 +1969,7 @@
     //     cross-axis alignment. (The legacy box model doesn't support this.)
     // So, each FlexItem simply copies the container's converted "align-items"
     // value and disregards their own "align-self" property.
-    const nsStyleXUL* containerStyleXUL = containerRS->mFrame->StyleXUL();
-    mAlignSelf = ConvertLegacyStyleToAlignItems(containerStyleXUL);
+    mAlignSelf = ConvertLegacyStyleToAlignItems(containerRS->mFrame);
     mAlignSelfFlags = 0;
   } else {
     mAlignSelf = aFlexItemReflowInput.mStylePosition->UsedAlignSelf(
@@ -3604,12 +3647,64 @@
   }
 }
 
+bool GetXULFlexOrientIsHorizontal(const nsIFrame* aFrame)
+{
+  bool horizontal = (aFrame->StyleXUL()->mBoxOrient == StyleBoxOrient::Horizontal);
+
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    // Now see if we have an attribute.  The attribute overrides the style system value.
+    static const Element::AttrValuesArray strings[] =
+      {nsGkAtoms::vertical, nsGkAtoms::horizontal, nullptr};
+    int32_t index = content->AsElement()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::orient,
+                                                          strings, eCaseMatters);
+    if (index >= 0) {
+      horizontal = index == 1;
+    }
+  }
+
+  return horizontal;
+}
+
+mozilla::StyleBoxDirection GetXULFlexDirection(const nsIFrame* aFrame)
+{
+  const nsStyleXUL* boxInfo = aFrame->StyleXUL();
+
+  nsIContent* content = aFrame->GetContent();
+  if (content && content->IsXULElement()) {
+    bool horizontal = GetXULFlexOrientIsHorizontal(aFrame);
+
+    bool normalDir = true;
+    if (horizontal) {
+      normalDir = (aFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR);
+    }
+    if (boxInfo->mBoxDirection == StyleBoxDirection::Reverse) {
+      normalDir = !normalDir;
+    }
+
+    if (horizontal) {
+      static const Element::AttrValuesArray strings[] =
+        {nsGkAtoms::reverse, nsGkAtoms::ltr, nsGkAtoms::rtl, nullptr};
+      int32_t index = content->AsElement()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
+                                                            strings, eCaseMatters);
+      if (index >= 0) {
+        bool values[] = {!normalDir, true, false};
+        normalDir = values[index];
+      }
+    } else if (content->AsElement()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,
+                                                 nsGkAtoms::reverse, eCaseMatters)) {
+      normalDir = !normalDir;
+    }
+
+    return normalDir ? StyleBoxDirection::Normal : StyleBoxDirection::Reverse;
+  }
+
+  return boxInfo->mBoxDirection;
+}
+
 void FlexboxAxisTracker::InitAxesFromLegacyProps(
     const nsFlexContainerFrame* aFlexContainer) {
-  const nsStyleXUL* styleXUL = aFlexContainer->StyleXUL();
-
-  const bool boxOrientIsVertical =
-      (styleXUL->mBoxOrient == StyleBoxOrient::Vertical);
+  const bool boxOrientIsVertical = !GetXULFlexOrientIsHorizontal(aFlexContainer);
   const bool wmIsVertical = mWM.IsVertical();
 
   // If box-orient agrees with our writing-mode, then we're "row-oriented"
@@ -3638,7 +3733,7 @@
 
   // Legacy flexbox can use "-webkit-box-direction: reverse" to reverse the
   // main axis (so it runs in the reverse direction of the inline axis):
-  if (styleXUL->mBoxDirection == StyleBoxDirection::Reverse) {
+  if (GetXULFlexDirection(aFlexContainer) == StyleBoxDirection::Reverse) {
     mMainAxis = GetReverseAxis(mMainAxis);
     mIsMainAxisReversed = true;
   } else {
@@ -4485,9 +4580,7 @@
     // For legacy boxes, the main axis is determined by "box-orient", and we can
     // just directly check if that's vertical, and compare that to whether the
     // item's WM is also vertical:
-    bool boxOrientIsVertical =
-        (flexContainer->StyleXUL()->mBoxOrient == StyleBoxOrient::Vertical);
-    return flexItemWM.IsVertical() == boxOrientIsVertical;
+    return flexItemWM.IsVertical() == !GetXULFlexOrientIsHorizontal(flexContainer);
   }
 
   // For modern CSS flexbox, we get our return value by asking two questions
@@ -4764,7 +4857,7 @@
 
   const auto justifyContent =
       IsLegacyBox(aReflowInput.mFrame)
-          ? ConvertLegacyStyleToJustifyContent(StyleXUL())
+          ? ConvertLegacyStyleToJustifyContent(aReflowInput.mFrame)
           : aReflowInput.mStylePosition->mJustifyContent;
 
   // Recalculate the gap sizes if necessary now that the container size has
@@ -5299,6 +5392,36 @@
   return mCachedPrefISize;
 }
 
+nsresult
+nsFlexContainerFrame::AttributeChanged(int32_t aNameSpaceID,
+                                       nsAtom* aAttribute,
+                                       int32_t aModType)
+{
+  nsresult rv = nsContainerFrame::AttributeChanged(aNameSpaceID, aAttribute,
+                                                   aModType);
+
+  nsIContent* content = GetContent();
+  if (!content || !content->IsXULElement()) {
+    return NS_OK;
+  }
+
+  if (aAttribute == nsGkAtoms::flex ||
+      aAttribute == nsGkAtoms::orient ||
+      aAttribute == nsGkAtoms::align ||
+      aAttribute == nsGkAtoms::pack ||
+      aAttribute == nsGkAtoms::dir) {
+    PresContext()->PresShell()->
+      FrameNeedsReflow(this, IntrinsicDirty::StyleChange, NS_FRAME_IS_DIRTY);
+  }
+  else if (aAttribute == nsGkAtoms::ordinal) {
+    PresContext()->PresShell()->
+      FrameNeedsReflow(GetParent(), IntrinsicDirty::StyleChange,
+                       NS_FRAME_IS_DIRTY);
+  }
+
+  return rv;
+}
+
 uint32_t nsFlexContainerFrame::GetLineClampValue() const {
   // -webkit-line-clamp should only work on items in flex containers that are
   // display:-webkit-(inline-)box and -webkit-box-orient:vertical.
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -641,51 +641,3 @@
 .menu-iconic-text[highlightable="true"] {
   display: none;
 }
-
-@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
-  /* Support common XUL attributes in the emulated flex mode so we can
-     test the browser in this configuration without mass-changing existing
-     markup and CSS. */
-  [orient="vertical"] { -moz-box-orient: vertical; }
-  [orient="horizontal"] { -moz-box-orient: horizontal; }
-
-  [dir="reverse"] { -moz-box-direction: reverse; }
-
-  [align="start"] { -moz-box-align: start; }
-  [align="center"] { -moz-box-align: center; }
-  [align="end"] { -moz-box-align: end; }
-  [align="baseline"] { -moz-box-align: baseline; }
-  [align="stretch"] { -moz-box-align: stretch; }
-
-  [pack="start"] { -moz-box-pack: start; }
-  [pack="center"] { -moz-box-pack: center; }
-  [pack="end"] { -moz-box-pack: end; }
-
-  /* This isn't a real solution for [flex] and [ordinal], but it covers enough
-     cases to render the browser chrome. If we get attr() in Bug 435426 this could
-     work for all cases. */
-  [flex="1"] { -moz-box-flex: 1; }
-  [flex="2"] { -moz-box-flex: 2; }
-  [flex="3"] { -moz-box-flex: 3; }
-  [flex="4"] { -moz-box-flex: 4; }
-  [flex="5"] { -moz-box-flex: 5; }
-  [flex="6"] { -moz-box-flex: 6; }
-  [flex="7"] { -moz-box-flex: 7; }
-  [flex="8"] { -moz-box-flex: 8; }
-  [flex="9"] { -moz-box-flex: 9; }
-  [flex="100"] { -moz-box-flex: 100; }
-  [flex="400"] { -moz-box-flex: 400; }
-  [flex="1000"] { -moz-box-flex: 1000; }
-  [flex="10000"] { -moz-box-flex: 10000; }
-
-  [ordinal="1"] { -moz-box-ordinal-group: 1; }
-  [ordinal="2"] { -moz-box-ordinal-group: 2; }
-  [ordinal="3"] { -moz-box-ordinal-group: 3; }
-  [ordinal="4"] { -moz-box-ordinal-group: 4; }
-  [ordinal="5"] { -moz-box-ordinal-group: 5; }
-  [ordinal="6"] { -moz-box-ordinal-group: 6; }
-  [ordinal="7"] { -moz-box-ordinal-group: 7; }
-  [ordinal="8"] { -moz-box-ordinal-group: 8; }
-  [ordinal="9"] { -moz-box-ordinal-group: 9; }
-  [ordinal="1000"] { -moz-box-ordinal-group: 1000; }
-}

