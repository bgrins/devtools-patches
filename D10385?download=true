diff --git a/dom/html/HTMLMarqueeElement.h b/dom/html/HTMLMarqueeElement.h
--- a/dom/html/HTMLMarqueeElement.h
+++ b/dom/html/HTMLMarqueeElement.h
@@ -21,6 +21,11 @@
   {
   }
 
+  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent) override;
+  virtual void UnbindFromTree(bool aDeep = true,
+                              bool aNullParent = true) override;
+
   static const int kDefaultLoop = -1;
   static const int kDefaultScrollAmount = 6;
   static const int kDefaultScrollDelayMS = 85;
@@ -129,6 +134,11 @@
                               const nsAString& aValue,
                               nsIPrincipal* aMaybeScriptedPrincipal,
                               nsAttrValue& aResult) override;
+  virtual nsresult AfterSetAttr(int32_t aNameSpaceID, nsAtom* aName,
+                                const nsAttrValue* aValue,
+                                const nsAttrValue* aOldValue,
+                                nsIPrincipal* aMaybeScriptedPrincipal,
+                                bool aNotify) override;
   NS_IMETHOD_(bool) IsAttributeMapped(const nsAtom* aAttribute) const override;
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const override;
 
diff --git a/dom/html/HTMLMarqueeElement.cpp b/dom/html/HTMLMarqueeElement.cpp
--- a/dom/html/HTMLMarqueeElement.cpp
+++ b/dom/html/HTMLMarqueeElement.cpp
@@ -8,8 +8,10 @@
 #include "nsGenericHTMLElement.h"
 #include "nsStyleConsts.h"
 #include "nsMappedAttributes.h"
+#include "mozilla/AsyncEventDispatcher.h"
 #include "mozilla/dom/HTMLMarqueeElementBinding.h"
 #include "mozilla/dom/CustomEvent.h"
+#include "mozilla/dom/ShadowRoot.h"
 
 NS_IMPL_NS_NEW_HTML_ELEMENT(Marquee)
 
@@ -49,6 +51,43 @@
   return dom::HTMLMarqueeElement_Binding::Wrap(aCx, this, aGivenProto);
 }
 
+nsresult
+HTMLMarqueeElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent)
+{
+
+  nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
+                                                 aBindingParent);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (nsContentUtils::IsUAWidgetEnabled() && IsInComposedDoc()) {
+    AttachAndSetUAShadowRoot();
+    AsyncEventDispatcher* dispatcher =
+      new AsyncEventDispatcher(this,
+                               NS_LITERAL_STRING("UAWidgetBindToTree"),
+                               CanBubble::eYes,
+                               ChromeOnlyDispatch::eYes);
+    dispatcher->RunDOMEventWhenSafe();
+  }
+
+  return rv;
+}
+
+void
+HTMLMarqueeElement::UnbindFromTree(bool aDeep, bool aNullParent)
+{
+  nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
+
+  if (GetShadowRoot() && IsInComposedDoc()) {
+    AsyncEventDispatcher* dispatcher =
+      new AsyncEventDispatcher(this,
+                               NS_LITERAL_STRING("UAWidgetUnbindFromTree"),
+                               CanBubble::eYes,
+                               ChromeOnlyDispatch::eYes);
+    dispatcher->RunDOMEventWhenSafe();    
+  }
+}
+
 void
 HTMLMarqueeElement::GetBehavior(nsAString& aValue)
 {
@@ -104,6 +143,29 @@
                                               aMaybeScriptedPrincipal, aResult);
 }
 
+nsresult
+HTMLMarqueeElement::AfterSetAttr(int32_t aNameSpaceID, nsAtom* aName,
+                                 const nsAttrValue* aValue,
+                                 const nsAttrValue* aOldValue,
+                                 nsIPrincipal* aMaybeScriptedPrincipal,
+                                 bool aNotify)
+{
+  if (nsContentUtils::IsUAWidgetEnabled() &&
+      IsInComposedDoc() &&
+      aNameSpaceID == kNameSpaceID_None &&
+      aName == nsGkAtoms::direction) {
+    AsyncEventDispatcher* dispatcher =
+      new AsyncEventDispatcher(this,
+                               NS_LITERAL_STRING("UAWidgetAttributeChanged"),
+                               CanBubble::eYes,
+                               ChromeOnlyDispatch::eYes);
+    dispatcher->RunDOMEventWhenSafe();
+  }
+  return nsGenericHTMLElement::AfterSetAttr(
+    aNameSpaceID, aName, aValue, aOldValue, aMaybeScriptedPrincipal, aNotify);
+}
+
+
 void
 HTMLMarqueeElement::MapAttributesIntoRule(const nsMappedAttributes* aAttributes, MappedDeclarations& aDecls)
 {
@@ -175,7 +237,14 @@
   event->SetTrusted(true);
 
   ErrorResult err;
-  this->DispatchEvent(*event, err);
+  if (GetShadowRoot()) {
+    // Dispatch to the Shadow Root to UA Widget
+    static_cast<nsINode*>(GetShadowRoot())->DispatchEvent(*event, err);
+  } else {
+    // Dispatch the event on the element, for XBL
+    // XXX this is web-exposed.
+    this->DispatchEvent(*event, err);
+  }
 }
 
 void
@@ -187,7 +256,14 @@
   event->SetTrusted(true);
 
   ErrorResult err;
-  this->DispatchEvent(*event, err);
+  if (GetShadowRoot()) {
+    // Dispatch to the Shadow Root to UA Widget
+    static_cast<nsINode*>(GetShadowRoot())->DispatchEvent(*event, err);
+  } else {
+    // Dispatch the event on the element, for XBL
+    // XXX this is web-exposed.
+    this->DispatchEvent(*event, err);
+  }
 }
 
 } // namespace dom
diff --git a/layout/style/contenteditable.css b/layout/style/contenteditable.css
--- a/layout/style/contenteditable.css
+++ b/layout/style/contenteditable.css
@@ -23,13 +23,13 @@
   -moz-user-select: text;
 }
 
-/* Use default arrow over objects with size that 
+/* Use default arrow over objects with size that
    are selected when clicked on.
    Override the browser's pointer cursor over links
 */
 
 img:-moz-read-write, img:-moz-read-write[usemap], area:-moz-read-write,
-object:-moz-read-write, object:-moz-read-write[usemap], 
+object:-moz-read-write, object:-moz-read-write[usemap],
 applet:-moz-read-write, hr:-moz-read-write, button:-moz-read-write,
 select:-moz-read-write,
 a:-moz-read-write:link img, a:-moz-read-write:visited img,
@@ -47,7 +47,7 @@
   -moz-user-input: none;
 }
 
-/* We suppress user/author's prefs for link underline, 
+/* We suppress user/author's prefs for link underline,
    so we must set explicitly. This isn't good!
 */
 a:link:-moz-read-write {
@@ -80,12 +80,17 @@
 }
 
 /* emulation of non-standard HTML <marquee> tag */
-marquee:-moz-read-write {
-  -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-horizontal-editable');
-}
+
+@supports not -moz-bool-pref("dom.ua_widget.enabled") {
 
-marquee[direction="up"]:-moz-read-write, marquee[direction="down"]:-moz-read-write {
-  -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-vertical-editable');
+  marquee:-moz-read-write {
+    -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-horizontal-editable');
+  }
+
+  marquee[direction="up"]:-moz-read-write, marquee[direction="down"]:-moz-read-write {
+    -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-vertical-editable');
+  }
+
 }
 
 *|*:-moz-read-write > input[type="hidden"],
diff --git a/layout/style/res/html.css b/layout/style/res/html.css
--- a/layout/style/res/html.css
+++ b/layout/style/res/html.css
@@ -287,7 +287,7 @@
      in what authors should expect */
 
   /* Put this first so 'border' and 'frame' rules can override it. */
-table[rules] { 
+table[rules] {
   border-width: thin;
   border-style: hidden;
 }
@@ -299,7 +299,7 @@
   /* :-moz-table-border-nonzero is like [border]:not([border="0"]) except it
      also checks for other zero-like values according to HTML attribute
      parsing rules */
-table:-moz-table-border-nonzero { 
+table:-moz-table-border-nonzero {
   border-width: thin;
   border-style: outset;
 }
@@ -319,7 +319,7 @@
 table[frame="box"],
 table[frame="border"] { border-style: outset; }
 
- 
+
 /* Internal Table Borders */
 
   /* 'border' cell borders first */
@@ -340,7 +340,7 @@
   border-collapse: collapse;
 }
 
-/* only specified rules override 'border' settings  
+/* only specified rules override 'border' settings
   (increased specificity to achieve this) */
 table[rules]:not([rules=""])> tr > td,
 table[rules]:not([rules=""])> * > tr > td,
@@ -370,7 +370,7 @@
 table[rules][rules="all"] > tr > th,
 table[rules][rules="all"] > * > tr > th,
 table[rules][rules="all"] > td,
-table[rules][rules="all"] > th 
+table[rules][rules="all"] > th
 {
   border-width: thin;
   border-style: solid;
@@ -409,9 +409,9 @@
   border-block-start-style: solid;
   border-block-start-style: solid;
 }
-  
-  
-/* caption inherits from table not table-outer */  
+
+
+/* caption inherits from table not table-outer */
 caption {
   display: table-caption;
   text-align: center;
@@ -469,10 +469,10 @@
   vertical-align: middle;
 }
 
-td { 
+td {
   display: table-cell;
   vertical-align: inherit;
-  text-align: unset; 
+  text-align: unset;
   padding: 1px;
 }
 
@@ -682,7 +682,7 @@
   border: none ! important;
 }
 
-link { 
+link {
   display: none;
 }
 
@@ -843,14 +843,24 @@
   display: inline-block;
   vertical-align: text-bottom;
   text-align: start;
-  -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-horizontal');
 }
 
 marquee[direction="up"], marquee[direction="down"] {
-  -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-vertical');
   block-size: 200px;
 }
 
+@supports not -moz-bool-pref("dom.ua_widget.enabled") {
+
+  marquee {
+    -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-horizontal');
+  }
+
+  marquee[direction="up"], marquee[direction="down"] {
+    -moz-binding: url('chrome://xbl-marquee/content/xbl-marquee.xml#marquee-vertical');
+  }
+
+}
+
 /* PRINT ONLY rules follow */
 @media print {
 
diff --git a/toolkit/actors/UAWidgetsChild.jsm b/toolkit/actors/UAWidgetsChild.jsm
--- a/toolkit/actors/UAWidgetsChild.jsm
+++ b/toolkit/actors/UAWidgetsChild.jsm
@@ -60,6 +60,10 @@
       case "object":
         // TODO (pluginProblems)
         break;
+      case "marquee":
+        uri = "chrome://global/content/elements/marquee.js";
+        widgetName = "MarqueeWidget";
+        break;
     }
 
     if (!uri || !widgetName) {
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -98,6 +98,8 @@
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/progressmeter.js    (widgets/progressmeter.js)
    content/global/elements/radio.js            (widgets/radio.js)
+   content/global/elements/marquee.css         (widgets/marquee.css)
+   content/global/elements/marquee.js          (widgets/marquee.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
diff --git a/toolkit/content/widgets/docs/ua_widget.rst b/toolkit/content/widgets/docs/ua_widget.rst
--- a/toolkit/content/widgets/docs/ua_widget.rst
+++ b/toolkit/content/widgets/docs/ua_widget.rst
@@ -46,3 +46,5 @@
 
 * Do not dispatch non-spec compliant events on the UA Widget Shadow Root host element, as event listeners in web content scripts can access them.
 * The layout and the dimensions of the widget should be ready by the time the constructor returns, since they can be detectable as soon as the content script gets the reference of the host element (i.e. when ``appendChild()`` returns). In order to make this easier we load ``<link>`` elements load chrome stylesheets synchronously when inside a UA Widget Shadow DOM.
+* There shouldn't be any white-spaces nodes in the Shadow DOM, because UA Widget could be placed inside ``white-space: pre``. See bug 1502205.
+* CSP will block inline styles in the Shadow DOM. ``<link>`` is the only safe way to load styles.
diff --git a/layout/style/xbl-marquee/xbl-marquee.css b/toolkit/content/widgets/marquee.css
copy from layout/style/xbl-marquee/xbl-marquee.css
copy to toolkit/content/widgets/marquee.css
--- a/layout/style/xbl-marquee/xbl-marquee.css
+++ b/toolkit/content/widgets/marquee.css
@@ -2,11 +2,33 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+.horizontalContainer {
+  overflow-x: hidden;
+  width: -moz-available;
+}
+
+.horizontalInnerDiv {
+  display: inline-block;
+  inline-size: -moz-max-content;
+}
+
+.verticalContainer {
+  overflow: hidden;
+  width: -moz-available;
+}
+
+/* disable scrolling in contenteditable */
+:host(:-moz-read-write) .horizontalInnerDiv,
+:host(:-moz-read-write) .verticalInnerDiv {
+  margin: 0 !important;
+  padding: 0 !important;
+}
+
 /* PRINT ONLY rules */
 @media print {
-
-  marquee > * > * { 
-    margin: 0 !important; 
+  .horizontalInnerDiv,
+  .verticalInnerDiv {
+    margin: 0 !important;
     padding: 0 !important;
-  } /* This hack is needed until bug 119078 gets fixed */
+  }
 }
diff --git a/layout/style/xbl-marquee/xbl-marquee.xml b/toolkit/content/widgets/marquee.js
copy from layout/style/xbl-marquee/xbl-marquee.xml
copy to toolkit/content/widgets/marquee.js
--- a/layout/style/xbl-marquee/xbl-marquee.xml
+++ b/toolkit/content/widgets/marquee.js
@@ -1,373 +1,365 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/*
+ * This is the class of entry. It will construct the actual implementation
+ * according to the value of the "direction" property.
+ */
+this.MarqueeWidget = class {
+  constructor(shadowRoot) {
+    this.shadowRoot = shadowRoot;
+    this.element = shadowRoot.host;
+    this.document = this.element.ownerDocument;
+    this.window = this.document.defaultView;
+
+    this.switchImpl();
+  }
+
+  /*
+   * Callback called by UAWidgetsChild wheen the direction property
+   * changes.
+   */
+  onattributechange() {
+    this.switchImpl();
+  }
+
+  switchImpl() {
+    let newImpl;
+    switch (this.element.direction) {
+      case "up":
+      case "down":
+        newImpl = MarqueeVerticalImplWidget;
+        break;
+      case "left":
+      case "right":
+        newImpl = MarqueeHorizontalImplWidget;
+        break;
+    }
+
+    // Skip if we are asked to load the same implementation.
+    // This can happen if the property is set again w/o value change.
+    if (this.impl && this.impl.constructor == newImpl) {
+      return;
+    }
+    if (this.impl) {
+      this.impl.destructor();
+      this.shadowRoot.firstChild.remove();
+    }
+    if (newImpl) {
+      this.impl = new newImpl(this.shadowRoot);
+    } else {
+      this.impl = undefined;
+    }
+  }
 
-<bindings id="marqueeBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:html="http://www.w3.org/1999/xhtml"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:xbl="http://www.mozilla.org/xbl">
+  destructor() {
+    if (!this.impl) {
+      return;
+    }
+    this.impl.destructor();
+    this.shadowRoot.firstChild.remove();
+    delete this.impl;
+  }
+};
+
+this.MarqueeBaseImplWidget = class {
+  constructor(shadowRoot) {
+    this.shadowRoot = shadowRoot;
+    this.element = shadowRoot.host;
+    this.document = this.element.ownerDocument;
+    this.window = this.document.defaultView;
+
+    this.generateContent();
+
+    // Set up state.
+    this._currentDirection = this.element.direction || "left";
+    this._currentLoop = this.element.loop;
+    this.dirsign = 1;
+    this.startAt = 0;
+    this.stopAt = 0;
+    this.newPosition = 0;
+    this.runId = 0;
+    this.originalHeight = 0;
+    this.invalidateCache = true;
 
+    // hack needed to fix js error, see bug 386470
+    var myThis = this;
+    var lambda = function myScopeFunction() { if (myThis.init) myThis.init(); };
 
-  <binding id="marquee" bindToUntrustedContent="true">
+    this._mutationObserver = new this.window.MutationObserver(
+      (aMutations) => this._mutationActor(aMutations));
+    this._mutationObserver.observe(this.element, { attributes: true,
+      attributeOldValue: true,
+      attributeFilter: ["loop", "", "behavior",
+        "direction", "width", "height"] });
+
+    // init needs to be run after the page has loaded in order to calculate
+    // the correct height/width
+    if (this.document.readyState == "complete") {
+      lambda();
+    } else {
+      this.window.addEventListener("load", lambda);
+    }
+
+    this.shadowRoot.addEventListener("marquee-start", this);
+    this.shadowRoot.addEventListener("marquee-stop", this);
+  }
+
+  destructor() {
+    this._mutationObserver.disconnect();
+    this.window.clearTimeout(this.runId);
+
+    this.shadowRoot.removeEventListener("marquee-start", this);
+    this.shadowRoot.removeEventListener("marquee-stop", this);
+  }
 
-    <resources>
-      <stylesheet src="chrome://xbl-marquee/content/xbl-marquee.css"/>
-    </resources>
-    <handlers>
-      <handler event="marquee-start" allowuntrusted="false">
-        <![CDATA[
-          if (this.runId == 0) {
-            var myThis = this;
-            var lambda = function myTimeOutFunction(){myThis._doMove(false);}
-            this.runId = window.setTimeout(lambda, this.scrollDelayWithTruespeed - this._deltaStartStop);
-            this._deltaStartStop = 0;
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "marquee-start":
+        if (this.runId == 0) {
+          var myThis = this;
+          var lambda = function myTimeOutFunction() { myThis._doMove(false); };
+          this.runId = this.window.setTimeout(lambda, this.scrollDelayWithTruespeed - this._deltaStartStop);
+          this._deltaStartStop = 0;
+        }
+        break;
+      case "marquee-stop":
+        if (this.runId != 0) {
+          this._deltaStartStop = Date.now() - this._lastMoveDate;
+          this.window.clearTimeout(this.runId);
+        }
+
+        this.runId = 0;
+        break;
+    }
+  }
+
+  get outerDiv() {
+    return this.shadowRoot.firstChild;
+  }
+
+  get innerDiv() {
+    return this.shadowRoot.getElementById("innerDiv");
+  }
+
+  get scrollDelayWithTruespeed() {
+    if (this.element.scrollDelay < 60 && !this.element.trueSpeed) {
+      return 60;
+    }
+    return this.element.scrollDelay;
+  }
+
+  _fireEvent(aName, aBubbles, aCancelable) {
+    var e = this.document.createEvent("Events");
+    e.initEvent(aName, aBubbles, aCancelable);
+    this.element.dispatchEvent(e);
+  }
+
+  _doMove(aResetPosition) {
+    this._lastMoveDate = Date.now();
+
+    // invalidateCache is true at first load and whenever an attribute
+    // is changed
+    if (this.invalidateCache) {
+      this.invalidateCache = false; // we only want this to run once every scroll direction change
+
+      var corrvalue = 0;
+
+      switch (this._currentDirection) {
+        case "up": {
+          let height = this.document.defaultView.getComputedStyle(this.element).height;
+          this.outerDiv.style.height = height;
+          if (this.originalHeight > this.outerDiv.offsetHeight) {
+              corrvalue = this.originalHeight - this.outerDiv.offsetHeight;
           }
-        ]]>
-      </handler>
-      <handler event="marquee-stop" allowuntrusted="false">
-        <![CDATA[
-          if (this.runId != 0) {
-            this._deltaStartStop = Date.now()- this._lastMoveDate;
-            clearTimeout(this.runId);
+          this.innerDiv.style.padding = height + " 0";
+          this.dirsign = 1;
+          this.startAt = (this.element.behavior == "alternate") ? (this.originalHeight - corrvalue) : 0;
+          this.stopAt  = (this.element.behavior == "alternate" || this.element.behavior == "slide") ?
+                          (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));
+        }
+        break;
+
+        case "down": {
+          let height = this.document.defaultView.getComputedStyle(this.element).height;
+          this.outerDiv.style.height = height;
+          if (this.originalHeight > this.outerDiv.offsetHeight) {
+              corrvalue = this.originalHeight - this.outerDiv.offsetHeight;
+          }
+          this.innerDiv.style.padding = height + " 0";
+          this.dirsign = -1;
+          this.startAt  = (this.element.behavior == "alternate") ?
+                          (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));
+          this.stopAt = (this.element.behavior == "alternate" || this.element.behavior == "slide") ?
+                        (this.originalHeight - corrvalue) : 0;
+        }
+        break;
+
+        case "right":
+          if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {
+              corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;
+          }
+          this.dirsign = -1;
+          this.stopAt  = (this.element.behavior == "alternate" || this.element.behavior == "slide") ?
+                         (this.innerDiv.offsetWidth - corrvalue) : 0;
+          this.startAt = this.outerDiv.offsetWidth + ((this.element.behavior == "alternate") ?
+                         corrvalue : (this.innerDiv.offsetWidth + this.stopAt));
+        break;
+
+        case "left":
+        default:
+          if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {
+              corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;
+          }
+          this.dirsign = 1;
+          this.startAt = (this.element.behavior == "alternate") ? (this.innerDiv.offsetWidth - corrvalue) : 0;
+          this.stopAt  = this.outerDiv.offsetWidth +
+                         ((this.element.behavior == "alternate" || this.element.behavior == "slide") ?
+                         corrvalue : (this.innerDiv.offsetWidth + this.startAt));
+      }
+
+      if (aResetPosition) {
+        this.newPosition = this.startAt;
+        this._fireEvent("start", false, false);
+      }
+    } // end if
+
+    this.newPosition = this.newPosition + (this.dirsign * this.element.scrollAmount);
+
+    if ((this.dirsign == 1 && this.newPosition > this.stopAt) ||
+        (this.dirsign == -1 && this.newPosition < this.stopAt)) {
+      switch (this.element.behavior) {
+        case "alternate":
+          // lets start afresh
+          this.invalidateCache = true;
+
+          // swap direction
+          const swap = {left: "right", down: "up", up: "down", right: "left"};
+          this._currentDirection = swap[this._currentDirection] || "left";
+          this.newPosition = this.stopAt;
+
+          if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
+            this.outerDiv.scrollTop = this.newPosition;
+          } else {
+            this.outerDiv.scrollLeft = this.newPosition;
           }
 
-          this.runId = 0;
-        ]]>
-      </handler>
-    </handlers>
-    <implementation>
-
-      <property name="outerDiv"
-        onget="return document.getAnonymousNodes(this)[0]"
-      />
-
-      <property name="innerDiv"
-        onget="return document.getAnonymousElementByAttribute(this, 'class', 'innerDiv');"
-      />
-
-      <property name="scrollDelayWithTruespeed">
-        <getter>
-          <![CDATA[
-          if (this.scrollDelay < 60 && !this.trueSpeed) {
-            return 60;
+          if (this._currentLoop != 1) {
+            this._fireEvent("bounce", false, true);
           }
-          return this.scrollDelay;
-          ]]>
-        </getter>
-      </property>
-
-      <method name="_fireEvent">
-        <parameter name="aName"/>
-        <parameter name="aBubbles"/>
-        <parameter name="aCancelable"/>
-        <body>
-        <![CDATA[
-          var e = document.createEvent("Events");
-          e.initEvent(aName, aBubbles, aCancelable);
-          this.dispatchEvent(e);
-        ]]>
-        </body>
-      </method>
-
-      <method name="_doMove">
-        <parameter name="aResetPosition"/>
-        <body>
-        <![CDATA[
-          this._lastMoveDate = Date.now();
-
-          // invalidateCache is true at first load and whenever an attribute
-          // is changed
-          if (this.invalidateCache) {
-            this.invalidateCache = false; //we only want this to run once every scroll direction change
-
-            var corrvalue = 0;
-
-            switch (this._currentDirection)
-            {
-              case "up":
-                var height = document.defaultView.getComputedStyle(this).height;
-                this.outerDiv.style.height = height;
-                if (this.originalHeight > this.outerDiv.offsetHeight) {
-                    corrvalue = this.originalHeight - this.outerDiv.offsetHeight;
-                }
-                this.innerDiv.style.padding = height + " 0";
-                this.dirsign = 1;
-                this.startAt = (this.behavior == 'alternate') ? (this.originalHeight - corrvalue) : 0;
-                this.stopAt  = (this.behavior == 'alternate' || this.behavior == 'slide') ? 
-                                (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));
-              break;
-
-              case "down":
-                var height = document.defaultView.getComputedStyle(this).height;
-                this.outerDiv.style.height = height;
-                if (this.originalHeight > this.outerDiv.offsetHeight) {
-                    corrvalue = this.originalHeight - this.outerDiv.offsetHeight;
-                }
-                this.innerDiv.style.padding = height + " 0";
-                this.dirsign = -1;
-                this.startAt  = (this.behavior == 'alternate') ?
-                                (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));
-                this.stopAt = (this.behavior == 'alternate' || this.behavior == 'slide') ? 
-                              (this.originalHeight - corrvalue) : 0;
-              break;
+        break;
 
-              case "right":
-                if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {
-                    corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;
-                }
-                this.dirsign = -1;
-                this.stopAt  = (this.behavior == 'alternate' || this.behavior == 'slide') ? 
-                               (this.innerDiv.offsetWidth - corrvalue) : 0;
-                this.startAt = this.outerDiv.offsetWidth + ((this.behavior == 'alternate') ? 
-                               corrvalue : (this.innerDiv.offsetWidth + this.stopAt));   
-              break;
-
-              case "left":
-              default:
-                if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {
-                    corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;
-                }
-                this.dirsign = 1;
-                this.startAt = (this.behavior == 'alternate') ? (this.innerDiv.offsetWidth - corrvalue) : 0;
-                this.stopAt  = this.outerDiv.offsetWidth + 
-                               ((this.behavior == 'alternate' || this.behavior == 'slide') ? 
-                               corrvalue : (this.innerDiv.offsetWidth + this.startAt));
-            }
-
-            if (aResetPosition) {
-              this.newPosition = this.startAt;
-              this._fireEvent("start", false, false);
-            }
-          } //end if
-
-          this.newPosition = this.newPosition + (this.dirsign * this.scrollAmount);
-
-          if ((this.dirsign == 1 && this.newPosition > this.stopAt) ||
-              (this.dirsign == -1 && this.newPosition < this.stopAt))
-          {
-            switch (this.behavior) 
-            {
-              case 'alternate':
-                // lets start afresh
-                this.invalidateCache = true;
-
-                // swap direction
-                const swap = {left: "right", down: "up", up: "down", right: "left"};
-                this._currentDirection = swap[this._currentDirection] || "left";
-                this.newPosition = this.stopAt;
+        case "slide":
+          if (this._currentLoop > 1) {
+            this.newPosition = this.startAt;
+          }
+        break;
 
-                if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
-                  this.outerDiv.scrollTop = this.newPosition;
-                } else {
-                  this.outerDiv.scrollLeft = this.newPosition;
-                }
-
-                if (this._currentLoop != 1) {
-                  this._fireEvent("bounce", false, true);
-                }
-              break;
-
-              case 'slide':
-                if (this._currentLoop > 1) {
-                  this.newPosition = this.startAt;
-                }
-              break;
-
-              default:
-                this.newPosition = this.startAt;
+        default:
+          this.newPosition = this.startAt;
 
-                if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
-                  this.outerDiv.scrollTop = this.newPosition;
-                } else {
-                  this.outerDiv.scrollLeft = this.newPosition;
-                }
-
-                //dispatch start event, even when this._currentLoop == 1, comp. with IE6
-                this._fireEvent("start", false, false);
-            }
-
-            if (this._currentLoop > 1) {
-              this._currentLoop--;
-            } else if (this._currentLoop == 1) {
-              if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
-                this.outerDiv.scrollTop = this.stopAt;
-              } else {
-                this.outerDiv.scrollLeft = this.stopAt;
-              }
-              this.stop();
-              this._fireEvent("finish", false, true);
-              return;
-            }
-          }
-          else {
-            if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
-              this.outerDiv.scrollTop = this.newPosition;
-            } else {
-              this.outerDiv.scrollLeft = this.newPosition;
-            }
+          if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
+            this.outerDiv.scrollTop = this.newPosition;
+          } else {
+            this.outerDiv.scrollLeft = this.newPosition;
           }
 
-          var myThis = this;
-          var lambda = function myTimeOutFunction(){myThis._doMove(false);}
-          this.runId = window.setTimeout(lambda, this.scrollDelayWithTruespeed);
-        ]]>
-        </body>
-      </method>
-
-      <method name="init">
-        <body>
-        <![CDATA[
-          this.stop();
-
-          if ((this._currentDirection != "up") && (this._currentDirection != "down")) {
-            var width = window.getComputedStyle(this).width;
-            this.innerDiv.parentNode.style.margin = '0 ' + width;
-
-            //XXX Adding the margin sometimes causes the marquee to widen, 
-            // see testcase from bug bug 364434: 
-            // https://bugzilla.mozilla.org/attachment.cgi?id=249233
-            // Just add a fixed width with current marquee's width for now
-            if (width != window.getComputedStyle(this).width) {
-              var width = window.getComputedStyle(this).width;
-              this.outerDiv.style.width = width;
-              this.innerDiv.parentNode.style.margin = '0 ' + width;
-            }
-          }
-          else {
-            // store the original height before we add padding
-            this.innerDiv.style.padding = 0;
-            this.originalHeight = this.innerDiv.offsetHeight;
-          }
-
-          this._doMove(true);
-        ]]>
-        </body>
-      </method>
+          // dispatch start event, even when this._currentLoop == 1, comp. with IE6
+          this._fireEvent("start", false, false);
+      }
 
-      <method name="_mutationActor">
-        <parameter name="aMutations"/>
-        <body>
-        <![CDATA[
-          while (aMutations.length > 0) {
-            var mutation = aMutations.shift();
-            var attrName = mutation.attributeName.toLowerCase();
-            var oldValue = mutation.oldValue;
-            var target = mutation.target;
-            var newValue = target.getAttribute(attrName);
+      if (this._currentLoop > 1) {
+        this._currentLoop--;
+      } else if (this._currentLoop == 1) {
+        if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
+          this.outerDiv.scrollTop = this.stopAt;
+        } else {
+          this.outerDiv.scrollLeft = this.stopAt;
+        }
+        this.element.stop();
+        this._fireEvent("finish", false, true);
+        return;
+      }
+    } else if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
+        this.outerDiv.scrollTop = this.newPosition;
+      } else {
+        this.outerDiv.scrollLeft = this.newPosition;
+      }
 
-            if (oldValue != newValue) {
-              target.invalidateCache = true;
-              switch (attrName) {
-                case "loop":
-                  target._currentLoop = target.loop;
-                  break;
-                case "direction":
-                  target._currentDirection = target.direction;
-                  break;
-              }
-            }
-          }
-        ]]>
-        </body>
-      </method>
+    var myThis = this;
+    var lambda = function myTimeOutFunction() { myThis._doMove(false); };
+    this.runId = this.window.setTimeout(lambda, this.scrollDelayWithTruespeed);
+  }
 
-      <constructor>
-        <![CDATA[
-          // Set up state.
-          this._currentDirection = this.direction || "left";
-          this._currentLoop = this.loop;
-          this.dirsign = 1;
-          this.startAt = 0;
-          this.stopAt = 0;
-          this.newPosition = 0;
-          this.runId = 0;
-          this.originalHeight = 0;
-          this.invalidateCache = true;
+  init() {
+    this.element.stop();
 
-          // hack needed to fix js error, see bug 386470
-          var myThis = this;
-          var lambda = function myScopeFunction() { if (myThis.init) myThis.init(); }
+    if ((this._currentDirection != "up") && (this._currentDirection != "down")) {
+      var width = this.window.getComputedStyle(this.element).width;
+      this.innerDiv.style.margin = "0 " + width;
 
-          this._mutationObserver = new MutationObserver(this._mutationActor);
-          this._mutationObserver.observe(this, { attributes: true,
-            attributeOldValue: true,
-            attributeFilter: ['loop', '', 'behavior',
-              'direction', 'width', 'height'] });
-
-          // init needs to be run after the page has loaded in order to calculate
-          // the correct height/width
-          if (document.readyState == "complete") {
-            lambda();
-          } else {
-            window.addEventListener("load", lambda);
-          }
-        ]]>
-      </constructor>
-    </implementation>
-
-  </binding>
+      // XXX Adding the margin sometimes causes the marquee to widen,
+      // see testcase from bug bug 364434:
+      // https://bugzilla.mozilla.org/attachment.cgi?id=249233
+      // Just add a fixed width with current marquee's width for now
+      if (width != this.window.getComputedStyle(this.element).width) {
+        width = this.window.getComputedStyle(this.element).width;
+        this.outerDiv.style.width = width;
+        this.innerDiv.style.margin = "0 " + width;
+      }
+    } else {
+      // store the original height before we add padding
+      this.innerDiv.style.padding = 0;
+      this.originalHeight = this.innerDiv.offsetHeight;
+    }
 
-  <binding id="marquee-horizontal" bindToUntrustedContent="true"
-           extends="chrome://xbl-marquee/content/xbl-marquee.xml#marquee"
-           inheritstyle="false">
+    this._doMove(true);
+  }
 
-    <!-- White-space isn't allowed because a marquee could be 
-         inside 'white-space: pre' -->
-    <content>
-      <html:div style="display: -moz-box; overflow: hidden; width: -moz-available;"
-        ><html:div style="display: -moz-box;"
-          ><html:div class="innerDiv" style="display: table; border-spacing: 0;"
-            ><html:div
-              ><children
-            /></html:div
-          ></html:div
-        ></html:div
-      ></html:div>
-    </content>
-
-  </binding>
+  _mutationActor(aMutations) {
+    while (aMutations.length > 0) {
+      var mutation = aMutations.shift();
+      var attrName = mutation.attributeName.toLowerCase();
+      var oldValue = mutation.oldValue;
+      var target = mutation.target;
+      var newValue = target.getAttribute(attrName);
 
-  <binding id="marquee-vertical" bindToUntrustedContent="true"
-           extends="chrome://xbl-marquee/content/xbl-marquee.xml#marquee"
-           inheritstyle="false">
-
-    <!-- White-space isn't allowed because a marquee could be 
-         inside 'white-space: pre' -->
-    <content>
-      <html:div style="overflow: hidden; width: -moz-available;"
-        ><html:div class="innerDiv"
-          ><children
-        /></html:div
-      ></html:div>
-    </content>
-
-  </binding>
-
-  <binding id="marquee-horizontal-editable" bindToUntrustedContent="true"
-           inheritstyle="false">
+      if (oldValue != newValue) {
+        this.invalidateCache = true;
+        switch (attrName) {
+          case "loop":
+            this._currentLoop = target.loop;
+            break;
+          case "direction":
+            this._currentDirection = target.direction;
+            break;
+        }
+      }
+    }
+  }
+};
 
-    <!-- White-space isn't allowed because a marquee could be 
-         inside 'white-space: pre' -->
-    <content>
-      <html:div style="display: inline-block; overflow: auto; width: -moz-available;"
-        ><children
-      /></html:div>
-    </content>
-
-  </binding>
+this.MarqueeHorizontalImplWidget = class extends MarqueeBaseImplWidget {
+  // White-space isn't allowed because a marquee could be
+  // inside 'white-space: pre'
+  generateContent() {
+    this.shadowRoot.innerHTML = `<div class="horizontalContainer"
+        ><link rel="stylesheet" type="text/css" href="chrome://global/content/elements/marquee.css"
+          /><div id="innerDiv" class="horizontalInnerDiv"><slot/></div
+      ></div>`;
+  }
+};
 
-  <binding id="marquee-vertical-editable" bindToUntrustedContent="true"
-           inheritstyle="false">
-
-    <!-- White-space isn't allowed because a marquee could be 
-         inside 'white-space: pre' -->
-    <content>
-      <html:div style="overflow: auto; height: inherit; width: -moz-available;"
-        ><children/></html:div>
-    </content>
-
-  </binding>
-
-</bindings>
+this.MarqueeVerticalImplWidget = class extends MarqueeBaseImplWidget {
+  // White-space isn't allowed because a marquee could be
+  // inside 'white-space: pre'
+  generateContent() {
+    this.shadowRoot.innerHTML = `<div class="verticalContainer"
+        ><link rel="stylesheet" type="text/css" href="chrome://global/content/elements/marquee.css"
+          /><div id="innerDiv" class="verticalInnerDiv"><slot /></div
+      ></div>`;
+  }
+};

