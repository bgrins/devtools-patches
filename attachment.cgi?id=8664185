# HG changeset patch
# User Hallvord R. M. Steen <hsteen@mozilla.com>
# Date 1442920847 -7200
#      Tue Sep 22 13:20:47 2015 +0200
# Node ID 07f8c496cfd6bdaedf98e28cc8d5267dd7b14998
# Parent  139446daedab3d00b9f0faba25e1e82191c8c8d1
debugger shortcut keys when split console has focus, bug 1183325

diff --git a/devtools/client/debugger/debugger-controller.js b/devtools/client/debugger/debugger-controller.js
--- a/devtools/client/debugger/debugger-controller.js
+++ b/devtools/client/debugger/debugger-controller.js
@@ -697,17 +697,20 @@ StackFrames.prototype = {
       case "interrupted":
         if (!aPacket.why.onNext) {
           return;
         }
         break;
     }

     this.activeThread.fillFrames(CALL_STACK_PAGE_SIZE);
-    DebuggerView.editor.focus();
+    // Focus the debugger editor - but only if focus is not inside a split console pane
+    if (!DebuggerController._toolbox.isSplitConsoleFocused()) {
+      DebuggerView.editor.focus();
+    }
   },

   /**
    * Handler for the thread client's resumed notification.
    */
   _onResumed: function() {
     // Prepare the watch expression evaluation string for the next pause.
     if (this._currentFrameDescription != FRAME_TYPE.WATCH_EXPRESSIONS_EVAL) {
diff --git a/devtools/client/debugger/panel.js b/devtools/client/debugger/panel.js
--- a/devtools/client/debugger/panel.js
+++ b/devtools/client/debugger/panel.js
@@ -52,16 +52,25 @@ DebuggerPanel.prototype = {

     return targetPromise
       .then(() => this._controller.startupDebugger())
       .then(() => this._controller.connect())
       .then(() => {
         this._toolbox.on("host-changed", this.handleHostChanged);
         this.target.on("thread-paused", this.highlightWhenPaused);
         this.target.on("thread-resumed", this.unhighlightWhenResumed);
+        // Add keys from this document's keyset to the toolbox, so they
+        // can work when the split console is focused.
+        let keysToClone = ["resumeKey", "resumeKey2", "stepOverKey",
+                          "stepOverKey2", "stepInKey", "stepInKey2",
+                          "stepOutKey", "stepOutKey2"];
+        for (let key of keysToClone) {
+          let elm = this.panelWin.document.getElementById(key);
+          this._toolbox.useKeyWithSplitConsole(elm, "jsdebugger");
+        }
         this.isReady = true;
         this.emit("ready");
         return this;
       })
       .then(null, function onError(aReason) {
         DevToolsUtils.reportException("DebuggerPanel.prototype.open", aReason);
       });
   },
diff --git a/devtools/client/debugger/test/mochitest/browser.ini b/devtools/client/debugger/test/mochitest/browser.ini
--- a/devtools/client/debugger/test/mochitest/browser.ini
+++ b/devtools/client/debugger/test/mochitest/browser.ini
@@ -96,16 +96,17 @@ support-files =
   doc_scope-variable-2.html
   doc_scope-variable-3.html
   doc_scope-variable-4.html
   doc_script-eval.html
   doc_script-bookmarklet.html
   doc_script-switching-01.html
   doc_script-switching-02.html
   doc_split-console-paused-reload.html
+  doc_step-many-statements.html
   doc_step-out.html
   doc_terminate-on-tab-close.html
   doc_watch-expressions.html
   doc_watch-expression-button.html
   doc_with-frame.html
   doc_WorkerActor.attach-tab1.html
   doc_WorkerActor.attach-tab2.html
   doc_WorkerActor.attachThread-tab.html
@@ -566,8 +567,10 @@ skip-if = e10s && debug
 [browser_dbg_watch-expressions-01.js]
 skip-if = e10s && debug
 [browser_dbg_watch-expressions-02.js]
 skip-if = e10s && debug
 [browser_dbg_WorkerActor.attach.js]
 skip-if = e10s && debug
 [browser_dbg_WorkerActor.attachThread.js]
 skip-if = e10s && debug
+[browser_dbg_split-console-keypress.js]
+skip-if = e10s && debug
diff --git a/devtools/client/debugger/test/mochitest/browser_dbg_split-console-keypress.js b/devtools/client/debugger/test/mochitest/browser_dbg_split-console-keypress.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/debugger/test/mochitest/browser_dbg_split-console-keypress.js
@@ -0,0 +1,119 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * When the split console is focused and the debugger is open,
+ * debugger shortcut keys like F11 should work
+ */
+const TAB_URL = EXAMPLE_URL + "doc_step-many-statements.html";
+
+function test() {
+  let gDebugger, gToolbox, gThreadClient, gTab, gPanel;
+  initDebugger(TAB_URL).then(([aTab,debuggeeWin,aPanel]) => {
+    gPanel = aPanel;
+    gDebugger = aPanel.panelWin;
+    gToolbox = gDevTools.getToolbox(aPanel.target);
+    gTab = aTab;
+    gThreadClient = gDebugger.DebuggerController.activeThread;
+    waitForSourceShown(aPanel, TAB_URL).then(testConsole);
+  });
+  let testConsole = Task.async(function *() {
+    // We need to open the split console (with an ESC keypress),
+    // then get the script into a paused state by pressing a button in the page,
+    // ensure focus is in the split console,
+    // synthesize a few keys - important ones we share listener for are
+    // "resumeKey", "stepOverKey", "stepInKey", "stepOutKey"
+    // then check that
+    //   * The input cursor remains in the console's input box
+    //   * The paused state is as expected
+    //   * the debugger cursor is where we want it
+    let jsterm = yield getSplitConsole();
+    // The console is now open (if not make the test fail already)
+    ok(gToolbox.splitConsole, "Split console is shown.");
+
+    // Information for sub-tests. When 'key' is synthesized 'keyRepeat' times,
+    // cursor should be at 'caretLine' of this test..
+    let stepTests = [
+      {key: 'VK_F11', keyRepeat: 1, caretLine: 16},
+      {key: 'VK_F11', keyRepeat: 2, caretLine: 18},
+      {key: 'VK_F11', keyRepeat: 11, caretLine: 29},
+      {key: 'VK_F10', keyRepeat: 1, caretLine: 30},
+      {key: 'VK_F11', keyRepeat: 1, caretLine: 30},
+      {key: 'VK_F11', keyRepeat: 30, caretLine: 40},
+      {key: 'VK_F11', modifier:'Shift', keyRepeat: 1, caretLine: 37},
+      {key: 'VK_F11', modifier:'Shift', keyRepeat: 2, caretLine: 40},
+      {key: 'VK_F11', modifier:'Shift', keyRepeat: 11, caretLine: 21}
+    ], testCounter = 1;
+    // Trigger script that stops at debugger statement
+    executeSoon(() => generateMouseClickInTab(gTab,
+      "content.document.getElementById('start')"));
+    yield waitForPause(gThreadClient);
+
+    // Focus the console and add event listener to track whether it looses focus
+    // (Must happen after generateMouseClickInTab() call)
+    let consoleInputLostFocus = false;
+    jsterm.inputNode.focus();
+    jsterm.inputNode.addEventListener('blur',
+      () => {consoleInputLostFocus = true;});
+
+    is(gThreadClient.paused, true,
+      "Should be paused at debugger statement.");
+    // As long as we have test work to do..
+    while (stepTests[0]) {
+      // First we send another key event if required by the test
+      if (stepTests[0].keyRepeat > 0) {
+        stepTests[0].keyRepeat --;
+        let keyMods = stepTests[0].modifier === 'Shift' ? {shiftKey:true} : {};
+        executeSoon(() => {EventUtils.synthesizeKey(stepTests[0].key,
+          keyMods, gDebugger)});
+        yield waitForPause(gThreadClient);
+        continue;
+      }
+
+      // We've sent the required number of keys
+      // Here are the conditions we're interested in: paused state,
+      // cursor still in console (tested later), caret correct in debugger's editor
+      is(gThreadClient.paused, true,
+        "Should still be paused");
+      ok(isCaretPos(gPanel, stepTests[0].caretLine),
+        "Test " + testCounter + ": CaretPos at line " + stepTests[0].caretLine);
+      ok(isDebugPos(gPanel, stepTests[0].caretLine),
+        "Test " + testCounter + ": DebugPos at line " + stepTests[0].caretLine);
+
+      // Now we're done with this test, go for the next one
+      stepTests.shift();
+      testCounter++;
+    }
+    // Did focus go missing while we were stepping?
+    is(consoleInputLostFocus, false, "Console input should not loose focus");
+    // We're done with the tests in the stepTests array
+    // Last key we test is "resume"
+    executeSoon(() => EventUtils.synthesizeKey('VK_F8', {}, gDebugger));
+
+    // We reset the variable tracking loss of focus to test the resume case
+    consoleInputLostFocus = false;
+
+    gPanel.target.on("thread-resumed", () => {
+      is(gThreadClient.paused, false,
+        "Should not be paused after resume");
+      // Final test: did we preserve console inputNode focus during resume?
+      is(consoleInputLostFocus, false, "Resume - console should keep focus");
+      closeDebuggerAndFinish(gPanel);
+    });
+  });
+
+  function getSplitConsole() {
+    return new Promise(resolve => {
+      gToolbox.once("webconsole-ready", () => {
+        let jsterm = gToolbox.getPanel("webconsole").hud.jsterm;
+        resolve(jsterm);
+      });
+      EventUtils.synthesizeKey("VK_ESCAPE", {}, gDebugger);
+    });
+  }
+}
+
+registerCleanupFunction(() => {
+  // We don't want the open split console to confuse other tests..
+  Services.prefs.clearUserPref("devtools.toolbox.splitconsoleEnabled");
+});
diff --git a/devtools/client/debugger/test/mochitest/doc_step-many-statements.html b/devtools/client/debugger/test/mochitest/doc_step-many-statements.html
new file mode 100644
--- /dev/null
+++ b/devtools/client/debugger/test/mochitest/doc_step-many-statements.html
@@ -0,0 +1,50 @@
+<!-- Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/publicdomain/zero/1.0/ -->
+<!doctype html>
+
+<html>
+  <head>
+    <meta charset="utf-8"/>
+    <title>Debugger test page</title>
+  </head>
+
+  <body>
+    <button id="start">Start!</button>
+
+    <script type="text/javascript">
+      function normal(aArg) {
+        debugger;
+        var r = 10;
+        var a = squareAndOne(r);
+        var b = squareUntil(r, 99999999999); //recurses 3 times, returns on 4th call
+        var c = addUntil(r, 5, 1050); // recurses 208 times and returns on the 209th call
+        return a + b + c;
+
+      }
+
+      function squareAndOne(arg){
+        return (arg * arg) + 1;
+      }
+      function squareUntil(arg, limit){
+        if(arg * arg >= limit){
+          return arg * arg;
+        }else{
+          return squareUntil(arg * arg, limit);
+        }
+      }
+
+      function addUntil(arg1, arg2, limit){
+        if(arg1 + arg2 > limit){
+          return arg1 + arg2;
+        }else{
+          return addUntil(arg1 + arg2, arg2, limit);
+        }
+      }
+
+      var normalBtn = document.getElementById("start");
+      normalBtn.addEventListener("click", normal, false);
+
+    </script>
+  </body>
+
+</html>
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -327,16 +327,29 @@ Toolbox.prototype = {
   /**
    * Get the toggled state of the split console
    */
   get splitConsole() {
     return this._splitConsole;
   },

   /**
+   * Get the focused state of the split console
+   */
+  isSplitConsoleFocused: function() {
+    if (!this._splitConsole) {
+      return false;
+    }
+    let focusedWin = Services.focus.focusedWindow ?
+      Services.focus.focusedWindow : null;
+    return focusedWin && focusedWin ===
+      this.doc.querySelector("#toolbox-panel-iframe-webconsole").contentWindow;
+  },
+
+  /**
    * Open the toolbox
    */
   open: function() {
     return Task.spawn(function*() {
       let iframe = yield this._host.create();
       let domReady = promise.defer();

       // Load the toolbox-level actor fronts and utilities now
@@ -481,16 +494,39 @@ Toolbox.prototype = {
       // navigation.
       let jsdebugger = this.getPanel("jsdebugger");
       if (jsdebugger && jsdebugger.panelWin.gThreadClient.state == "paused") {
         e.preventDefault();
       }
     }
   },

+  /**
+   * Add a shortcut key that should work when a split console
+   * has focus to the toolbox.
+   *
+   * @param {element} keyElement
+   *        They <key> XUL element describing the shortcut key
+   * @param {string} whichTool
+   *        The tool the key belongs to. The corresponding command
+   *        will only trigger if this tool is active.
+   */
+  useKeyWithSplitConsole: function(keyElement, whichTool) {
+    let cloned = keyElement.cloneNode();
+    cloned.setAttribute("oncommand", "void(0)");
+    cloned.removeAttribute("command");
+    cloned.addEventListener("command", (e) => {
+      // Only forward the command if the tool is active
+      if (this.currentToolId === whichTool && this.isSplitConsoleFocused()) {
+        keyElement.doCommand();
+      }
+    }, true);
+    this.doc.getElementById("toolbox-keyset").appendChild(cloned);
+  },
+
   _addReloadKeys: function() {
     [
       ["toolbox-reload-key", false],
       ["toolbox-reload-key2", false],
       ["toolbox-force-reload-key", true],
       ["toolbox-force-reload-key2", true]
     ].forEach(([id, force]) => {
       this.doc.getElementById(id).addEventListener("command", () => {
