# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1540592062 25200
#      Fri Oct 26 15:14:22 2018 -0700
# Node ID 6baeeb46578b7fc06885f28c0b572c45fa4cdf82
# Parent  e0bc4d0aaf54f5402ad2a3d4933c3a52e8bc334b
Bug 1425874 - WIP - Also implement onbounce, onfinish, onstart with WebIDL

Differential Revision: https://phabricator.services.mozilla.com/D9970

diff --git a/dom/html/HTMLMarqueeElement.cpp b/dom/html/HTMLMarqueeElement.cpp
--- a/dom/html/HTMLMarqueeElement.cpp
+++ b/dom/html/HTMLMarqueeElement.cpp
@@ -125,16 +125,52 @@ HTMLMarqueeElement::IsAttributeMapped(co
 }
 
 nsMapRuleToAttributesFunc
 HTMLMarqueeElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
 
+EventHandlerNonNull*
+HTMLMarqueeElement::GetOnbounce()
+{
+  return EventTarget::GetEventHandler(nsGkAtoms::onbounce);
+}
+
+void
+HTMLMarqueeElement::SetOnbounce(EventHandlerNonNull* aCallback)
+{
+  EventTarget::SetEventHandler(nsGkAtoms::onbounce, aCallback);
+}
+
+EventHandlerNonNull*
+HTMLMarqueeElement::GetOnfinish()
+{
+  return EventTarget::GetEventHandler(nsGkAtoms::onfinish);
+}
+
+void
+HTMLMarqueeElement::SetOnfinish(EventHandlerNonNull* aCallback)
+{
+  EventTarget::SetEventHandler(nsGkAtoms::onfinish, aCallback);
+}
+
+EventHandlerNonNull*
+HTMLMarqueeElement::GetOnstart()
+{
+  return EventTarget::GetEventHandler(nsGkAtoms::onstart);
+}
+
+void
+HTMLMarqueeElement::SetOnstart(EventHandlerNonNull* aCallback)
+{
+  EventTarget::SetEventHandler(nsGkAtoms::onstart, aCallback);
+}
+
 void
 HTMLMarqueeElement::Start()
 {
   RefPtr<CustomEvent> event = NS_NewDOMCustomEvent(this, nullptr, nullptr);
   MOZ_ASSERT(event);
   event->InitCustomEvent(nullptr, NS_LITERAL_STRING("marquee-start"), false, false, JS::NullHandleValue);
   event->SetTrusted(true);
 
diff --git a/dom/html/HTMLMarqueeElement.h b/dom/html/HTMLMarqueeElement.h
--- a/dom/html/HTMLMarqueeElement.h
+++ b/dom/html/HTMLMarqueeElement.h
@@ -107,16 +107,25 @@ public:
   {
     return GetIntAttr(nsGkAtoms::vspace, 0);
   }
   void SetVspace(uint32_t aValue, mozilla::ErrorResult& aError)
   {
     SetUnsignedIntAttr(nsGkAtoms::vspace, aValue, 0, aError);
   }
 
+  mozilla::dom::EventHandlerNonNull* GetOnbounce();
+  void SetOnbounce(mozilla::dom::EventHandlerNonNull* aCallback);
+
+  mozilla::dom::EventHandlerNonNull* GetOnfinish();
+  void SetOnfinish(mozilla::dom::EventHandlerNonNull* aCallback);
+
+  mozilla::dom::EventHandlerNonNull* GetOnstart();
+  void SetOnstart(mozilla::dom::EventHandlerNonNull* aCallback);
+
   void Start();
   void Stop();
 
   virtual bool ParseAttribute(int32_t aNamespaceID,
                               nsAtom* aAttribute,
                               const nsAString& aValue,
                               nsIPrincipal* aMaybeScriptedPrincipal,
                               nsAttrValue& aResult) override;
diff --git a/dom/webidl/HTMLMarqueeElement.webidl b/dom/webidl/HTMLMarqueeElement.webidl
--- a/dom/webidl/HTMLMarqueeElement.webidl
+++ b/dom/webidl/HTMLMarqueeElement.webidl
@@ -21,15 +21,15 @@ interface HTMLMarqueeElement : HTMLEleme
   [CEReactions, SetterThrows] attribute unsigned long hspace;
   [CEReactions, SetterThrows] attribute long loop;
   [CEReactions, SetterThrows] attribute unsigned long scrollAmount;
   [CEReactions, SetterThrows] attribute unsigned long scrollDelay;
   [CEReactions, SetterThrows] attribute boolean trueSpeed;
   [CEReactions, SetterThrows] attribute unsigned long vspace;
   [CEReactions, SetterThrows] attribute DOMString width;
 
-  //attribute EventHandler onbounce;
-  //attribute EventHandler onfinish;
-  //attribute EventHandler onstart;
+  attribute EventHandler onbounce;
+  attribute EventHandler onfinish;
+  attribute EventHandler onstart;
 
   void start();
   void stop();
 };
\ No newline at end of file
diff --git a/layout/style/xbl-marquee/xbl-marquee.xml b/layout/style/xbl-marquee/xbl-marquee.xml
--- a/layout/style/xbl-marquee/xbl-marquee.xml
+++ b/layout/style/xbl-marquee/xbl-marquee.xml
@@ -33,45 +33,16 @@
             clearTimeout(this.runId);
           }
 
           this.runId = 0;
         ]]>
       </handler>
     </handlers>
     <implementation>
-      <property name="onstart" exposeToUntrustedContent="true">
-        <getter>
-          return this.getAttribute("onstart");
-        </getter>
-        <setter>
-          this._setEventListener("start", val, true);
-          this.setAttribute("onstart", val);
-        </setter>
-      </property>
-
-      <property name="onfinish" exposeToUntrustedContent="true">
-        <getter>
-          return this.getAttribute("onfinish");
-        </getter>
-        <setter>
-          this._setEventListener("finish", val, true);
-          this.setAttribute("onfinish", val);
-        </setter>
-      </property>
-
-      <property name="onbounce" exposeToUntrustedContent="true">
-        <getter>
-          return this.getAttribute("onbounce");
-        </getter>
-        <setter>
-          this._setEventListener("bounce", val, true);
-          this.setAttribute("onbounce", val);
-        </setter>
-      </property>
 
       <property name="outerDiv"
         onget="return document.getAnonymousNodes(this)[0]"
       />
 
       <property name="innerDiv"
         onget="return document.getAnonymousElementByAttribute(this, 'class', 'innerDiv');"
       />
@@ -82,83 +53,16 @@
           if (this.scrollDelay < 60 && !this.trueSpeed) {
             return 60;
           }
           return this.scrollDelay;
           ]]>
         </getter>
       </property>
 
-      <method name="_setEventListener">
-        <parameter name="aName"/>
-        <parameter name="aValue"/>
-        <parameter name="aIgnoreNextCall"/>
-        <body>
-          <![CDATA[
-          // _setEventListener is only used for setting the attribute event
-          // handlers, which we want to ignore if our document is sandboxed
-          // without the allow-scripts keyword.
-          if (document.hasScriptsBlockedBySandbox) {
-            return true;
-          }
-
-          // attribute event handlers should only be added if the
-          // document's CSP allows it.
-          if (!document.inlineScriptAllowedByCSP) {
-            return true;
-          }
-
-          if (this._ignoreNextCall) {
-            return this._ignoreNextCall = false;
-          }
-
-          if (aIgnoreNextCall) {
-            this._ignoreNextCall = true;
-          }
-
-          if (typeof this["_on" + aName] == 'function') {
-            this.removeEventListener(aName, this["_on" + aName]);
-          }
-
-          switch (typeof aValue)
-          {
-            case "function":
-              this["_on" + aName] = aValue;
-              this.addEventListener(aName, this["_on" + aName]);
-            break;
-
-            case "string":
-              if (!aIgnoreNextCall) {
-                try {
-                  // Function Xrays make this simple and safe. \o/
-                  this["_on" + aName] = new window.Function("event", aValue);
-                }
-                catch(e) {
-                  return false;
-                }
-                this.addEventListener(aName, this["_on" + aName]);
-              }
-              else {
-                this["_on" + aName] = aValue;
-              }
-            break;
-
-            case "object":
-              this["_on" + aName] = aValue;
-            break;
-
-            default:
-              this._ignoreNextCall = false;
-              throw new Error("Invalid argument for Marquee::on" + aName);
-          }
-          return true;
-          ]]>
-        </body>
-      </method>
-
       <method name="_fireEvent">
         <parameter name="aName"/>
         <parameter name="aBubbles"/>
         <parameter name="aCancelable"/>
         <body>
         <![CDATA[
           var e = document.createEvent("Events");
           e.initEvent(aName, aBubbles, aCancelable);
@@ -357,25 +261,16 @@
               target.invalidateCache = true;
               switch (attrName) {
                 case "loop":
                   target._currentLoop = target.loop;
                   break;
                 case "direction":
                   target._currentDirection = target.direction;
                   break;
-                case "onstart":
-                  target._setEventListener("start", newValue);
-                  break;
-                case "onfinish":
-                  target._setEventListener("finish", newValue);
-                  break;
-                case "onbounce":
-                  target._setEventListener("bounce", newValue);
-                  break;
               }
             }
           }
         ]]>
         </body>
       </method>
 
       <constructor>
@@ -390,25 +285,21 @@
           this.runId = 0;
           this.originalHeight = 0;
           this.invalidateCache = true;
 
           // hack needed to fix js error, see bug 386470
           var myThis = this;
           var lambda = function myScopeFunction() { if (myThis.init) myThis.init(); }
 
-          this._setEventListener("start", this.getAttribute("onstart"));
-          this._setEventListener("finish", this.getAttribute("onfinish"));
-          this._setEventListener("bounce", this.getAttribute("onbounce"));
-
           this._mutationObserver = new MutationObserver(this._mutationActor);
           this._mutationObserver.observe(this, { attributes: true,
             attributeOldValue: true,
             attributeFilter: ['loop', '', 'behavior',
-              'direction', 'width', 'height', 'onstart', 'onfinish', 'onbounce'] });
+              'direction', 'width', 'height'] });
 
           // init needs to be run after the page has loaded in order to calculate
           // the correct height/width
           if (document.readyState == "complete") {
             lambda();
           } else {
             window.addEventListener("load", lambda);
           }
