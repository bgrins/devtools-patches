# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1540497534 25200
#      Thu Oct 25 12:58:54 2018 -0700
# Node ID 2bc4953af111318eb3a9f6cf188cc5d670d48ff7
# Parent  3cc04ee79005058d817daf66da7963dfac3f0a3a
Bug 1455433 - WIP - implement inheritAttribute(s) helper functions on MozXULElement

Differential Revision: https://phabricator.services.mozilla.com/D9843

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -30,16 +30,57 @@ window.addEventListener("DOMContentLoade
   }
   gElementsPendingConnection.clear();
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 const MozElementMixin = Base => class MozElement extends Base {
+
+  /*
+   * XXX
+   *
+   * @param child
+   * @param attrs
+   */
+  inheritAttributes(child, attrs) {
+    for (let attr of attrs) {
+      this.inheritAttribute(child, attr);
+    }
+  }
+
+  /*
+   * XXX
+   *
+   * @param child
+   * @param attrName
+   * @param attrNewName
+   */
+  inheritAttribute(child, attrName, attrNewName = attrName) {
+
+    // Support XBL inherit syntax of to=from
+    let split = attrName.split("=");
+    if (split.length == 2) {
+      attrName = split[1];
+      attrNewName = split[0];
+    }
+
+    if (attrNewName === "text") {
+      child.textContent = this.hasAttribute(attrName) ? this.getAttribute(attrName) : "";
+      return;
+    }
+
+    if (this.hasAttribute(attrName)) {
+      child.setAttribute(attrNewName, this.getAttribute(attrName));
+    } else {
+      child.removeAttribute(attrNewName);
+    }
+  }
+
   /**
    * Sometimes an element may not want to run connectedCallback logic during
    * parse. This could be because we don't want to initialize the element before
    * the element's contents have been fully parsed, or for performance reasons.
    * If you'd like to opt-in to this, then add this to the beginning of your
    * `connectedCallback` and `disconnectedCallback`:
    *
    *    if (this.delayConnectedCallback()) { return }
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -11,27 +11,29 @@
 
   <!-- test results are displayed in the html:body -->
   <body xmlns="http://www.w3.org/1999/xhtml" style="height: 300px; overflow: auto;"/>
 
   <button id="one"/>
   <simpleelement id="two" style="-moz-user-focus: normal;"/>
   <simpleelement id="three" disabled="true" style="-moz-user-focus: normal;"/>
   <button id="four"/>
+  <inherited-element></inherited-element>
 
 
   <!-- test code goes here -->
   <script type="application/javascript"><![CDATA[
 
   SimpleTest.waitForExplicitFinish();
 
   async function runTests() {
     ok(MozXULElement, "MozXULElement defined on the window");
     testMixin();
     testParseXULToFragment();
+    testInherits();
     await testCustomInterface();
 
     let htmlWin = await new Promise(resolve => {
       let htmlIframe = document.createElement("iframe");
       htmlIframe.src = "file_empty.xhtml";
       htmlIframe.onload = () => resolve(htmlIframe.contentWindow);
       document.documentElement.appendChild(htmlIframe);
     });
@@ -57,16 +59,55 @@
     let deck = document.documentElement.lastChild;
     ok(deck instanceof MozXULElement, "instance of MozXULElement");
     ok(deck instanceof XULElement, "instance of XULElement");
     is(deck.id, "foo", "attribute set");
     is(deck.selectedIndex, "0", "Custom Element is property attached");
     deck.remove();
   }
 
+  function testInherits() {
+    class InheritsElement extends MozXULElement {
+      static get observedAttributes() {
+        return ["label", "foo", "bar"];
+      }
+
+      attributeChangedCallback() {
+        this.inherit();
+      }
+
+      inherit() {
+        this.inheritAttributes(this.label, ["foo", "bar"]);
+        this.inheritAttribute(this.label, "label");
+      }
+
+      connectedCallback() {
+        this.append(MozXULElement.parseXULToFragment(`<label />`));
+        this.label = this.querySelector("label");
+        this.inherit();
+      }
+    }
+
+    customElements.define("inherited-element", InheritsElement);
+    let el = document.querySelector("inherited-element");
+    ok(el, "element exists");
+    ok(!el.label.hasAttribute("foo"), "foo");
+    ok(!el.label.hasAttribute("bar"), "bar");
+    ok(!el.label.hasAttribute("label"), "label");
+
+    el.setAttribute("label", "'label' set from test");
+    is(el.label.getAttribute("label"), "'label' set from test", "label attr change");
+    el.inheritAttribute(el.label, "text=label");
+    is(el.label.textContent, "'label' set from test", "attr mapping (to textContent)");
+
+    ok(!el.label.hasAttribute("baz"), "baz");
+    el.inheritAttribute(el.label, "baz=label");
+    is(el.label.getAttribute("baz"), "'label' set from test", "attr mapping (to attr)");
+  }
+
   async function testCustomInterface() {
     class SimpleElement extends MozXULElement {
       get disabled() {
         return this.getAttribute("disabled") == "true";
       }
 
       set disabled(val) {
         if (val) this.setAttribute("disabled", "true");
