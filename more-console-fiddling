# HG changeset patch
# Parent d14f1a013830f51dc006bcba2f8719eb5983eb6d
# User Brian Grinstead <bgrinstead@mozilla.com>
fidding with console


diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -142,27 +142,27 @@ const MAX_HTTP_ERROR_CODE = 599;
 const HISTORY_BACK = -1;
 const HISTORY_FORWARD = 1;
 
 // The indent of a console group in pixels.
 const GROUP_INDENT = 12;
 
 // The number of messages to display in a single display update. If we display
 // too many messages at once we slow the Firefox UI too much.
-const MESSAGES_IN_INTERVAL = DEFAULT_LOG_LIMIT;
+const MESSAGES_IN_INTERVAL = 10;
 
 // The delay between display updates - tells how often we should *try* to push
 // new messages to screen. This value is optimistic, updates won't always
 // happen. Keep this low so the Web Console output feels live.
-const OUTPUT_INTERVAL = 50; // milliseconds
+const OUTPUT_INTERVAL = 16; // milliseconds
 
 // When the output queue has more than MESSAGES_IN_INTERVAL items we throttle
 // output updates to this number of milliseconds. So during a lot of output we
 // update every N milliseconds given here.
-const THROTTLE_UPDATES = 1000; // milliseconds
+const THROTTLE_UPDATES = 100; // milliseconds
 
 // The preference prefix for all of the Web Console filters.
 const FILTER_PREFS_PREFIX = "devtools.webconsole.filter.";
 
 // The minimum font size.
 const MIN_FONT_SIZE = 10;
 
 const PREF_CONNECTION_TIMEOUT = "devtools.debugger.remote-timeout";
@@ -2071,87 +2071,89 @@ WebConsoleFrame.prototype = {
     let toDisplay = Math.min(this._outputQueue.length, MESSAGES_IN_INTERVAL);
     if (toDisplay < 1) {
       this._outputTimerInitialized = false;
       return;
     }
 
     // Try to prune the message queue.
     let shouldPrune = false;
+    console.time("PRUNING");
     if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
       toDisplay = Math.min(this._outputQueue.length, toDisplay);
       shouldPrune = true;
     }
+    console.timeEnd("PRUNING");
 
     let batch = this._outputQueue.splice(0, toDisplay);
     if (!batch.length) {
       this._outputTimerInitialized = false;
       return;
     }
     console.time("Flush message queue outer");
     let outputNode = this.outputNode;
     let lastVisibleNode = null;
     let scrollNode = outputNode.parentNode;
     let scrolledToBottom = Utils.isOutputScrolledToBottom(outputNode);
     let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
 
-    console.time("Output the current batch of messages.");
+    console.time("Output the current batch of messages. " + batch.length + " of " + this._outputQueue.length);
     // Output the current batch of messages.
     let newMessages = new Set();
     let updatedMessages = new Set();
-    for (let item of batch) {
-      let result = this._outputMessageFromQueue(hudIdSupportsString, item);
+    for (let i = 0; i < batch.length; i++) {
+      let result = this._outputMessageFromQueue(hudIdSupportsString, batch[i]);
       if (result) {
         if (result.isRepeated) {
           updatedMessages.add(result.isRepeated);
         }
         else {
           newMessages.add(result.node);
         }
         if (result.visible && result.node == this.outputNode.lastChild) {
           lastVisibleNode = result.node;
         }
       }
     }
-    console.timeEnd("Output the current batch of messages.");
+    console.timeEnd("Output the current batch of messages. " + batch.length + " of " + this._outputQueue.length);
 
     let oldScrollHeight = 0;
 
     // Prune messages if needed. We do not do this for every flush call to
     // improve performance.
     let removedNodes = 0;
     console.time("Prune messages if needed");
-    if (shouldPrune || !this._outputQueue.length) {
-      oldScrollHeight = scrollNode.scrollHeight;
-
-      let categories = Object.keys(this._pruneCategoriesQueue);
-      categories.forEach(function _pruneOutput(aCategory) {
-        removedNodes += this.pruneOutputIfNecessary(aCategory);
-      }, this);
-      this._pruneCategoriesQueue = {};
-    }
+    // if (shouldPrune || !this._outputQueue.length) {
+    //   oldScrollHeight = scrollNode.scrollHeight;
+
+    //   let categories = Object.keys(this._pruneCategoriesQueue);
+    //   categories.forEach(function _pruneOutput(aCategory) {
+    //     removedNodes += this.pruneOutputIfNecessary(aCategory);
+    //   }, this);
+    //   this._pruneCategoriesQueue = {};
+    // }
     console.timeEnd("Prune messages if needed");
 
     let isInputOutput = lastVisibleNode &&
                         (lastVisibleNode.category == CATEGORY_INPUT ||
                          lastVisibleNode.category == CATEGORY_OUTPUT);
 
     // Scroll to the new node if it is not filtered, and if the output node is
     // scrolled at the bottom or if the new node is a jsterm input/output
     // message.
     console.time("scrollToVisible");
-    if (lastVisibleNode && (scrolledToBottom || isInputOutput)) {
-      Utils.scrollToVisible(lastVisibleNode);
-    }
-    else if (!scrolledToBottom && removedNodes > 0 &&
-             oldScrollHeight != scrollNode.scrollHeight) {
-      // If there were pruned messages and if scroll is not at the bottom, then
-      // we need to adjust the scroll location.
-      scrollNode.scrollTop -= oldScrollHeight - scrollNode.scrollHeight;
-    }
+    // if (lastVisibleNode && (scrolledToBottom || isInputOutput)) {
+    //   Utils.scrollToVisible(lastVisibleNode);
+    // }
+    // else if (!scrolledToBottom && removedNodes > 0 &&
+    //          oldScrollHeight != scrollNode.scrollHeight) {
+    //   // If there were pruned messages and if scroll is not at the bottom, then
+    //   // we need to adjust the scroll location.
+    //   scrollNode.scrollTop -= oldScrollHeight - scrollNode.scrollHeight;
+    // }
     console.timeEnd("scrollToVisible");
 
     console.time("finishing up");
     if (newMessages.size) {
       this.emit("messages-added", newMessages);
     }
     if (updatedMessages.size) {
       this.emit("messages-updated", updatedMessages);
@@ -2202,16 +2204,22 @@ WebConsoleFrame.prototype = {
    *         - node: the DOM element of the message.
    *         - isRepeated: the DOM element of the original message, if this is
    *         a repeated message, otherwise null.
    *         - visible: boolean that tells if the message is visible.
    */
   _outputMessageFromQueue:
   function WCF__outputMessageFromQueue(aHudIdSupportsString, aItem)
   {
+    // XXX: Print a fake node to narrow down perf issues
+    // let node = this.outputNode.ownerDocument.createElement("div");
+    // node.textContent = aItem[2][0].arguments;
+    // this.outputNode.insertBefore(node, null);
+    // return;
+
     let [category, methodOrNode, args] = aItem;
 
     let node = typeof methodOrNode == "function" ?
                methodOrNode.apply(this, args || []) :
                methodOrNode;
     if (!node) {
       return null;
     }
@@ -4662,22 +4670,22 @@ var Utils = {
    *        CATEGORY_* constants.
    * @return number
    *         The number of messages allowed for the specific category.
    */
   logLimitForCategory: function Utils_logLimitForCategory(aCategory)
   {
     let logLimit = DEFAULT_LOG_LIMIT;
 
-    try {
-      let prefName = CATEGORY_CLASS_FRAGMENTS[aCategory];
-      logLimit = Services.prefs.getIntPref("devtools.hud.loglimit." + prefName);
-      logLimit = Math.max(logLimit, 1);
-    }
-    catch (e) { }
+    // try {
+    //   let prefName = CATEGORY_CLASS_FRAGMENTS[aCategory];
+    //   logLimit = Services.prefs.getIntPref("devtools.hud.loglimit." + prefName);
+    //   logLimit = Math.max(logLimit, 1);
+    // }
+    // catch (e) { }
 
     return logLimit;
   },
 };
 
 ///////////////////////////////////////////////////////////////////////////////
 // CommandController
 ///////////////////////////////////////////////////////////////////////////////
