# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dc4023d54436f3a1fd4c93adfdc595aedab5b082
Bug xxx - queue webconsole messages

diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -206,17 +206,22 @@ function WebConsoleFrame(aWebConsoleOwne
   this._itemDestroyQueue = [];
   this._pruneCategoriesQueue = {};
   this.filterPrefs = {};
 
   this.output = new ConsoleOutput(this);
 
   this._toggleFilter = this._toggleFilter.bind(this);
   this._onPanelSelected = this._onPanelSelected.bind(this);
-  this._flushMessageQueue = this._flushMessageQueue.bind(this);
+  let f = this._flushMessageQueue;
+  this._flushMessageQueue = () => {
+    let now = Date.now();
+    f.call(this);
+    dump("Message queue flushed now " + (Date.now() - now) + "\n");
+  };
   this._onToolboxPrefChanged = this._onToolboxPrefChanged.bind(this);
 
   this._outputTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
   this._outputTimerInitialized = false;
 
   EventEmitter.decorate(this);
 }
 exports.WebConsoleFrame = WebConsoleFrame;
@@ -2194,23 +2199,23 @@ WebConsoleFrame.prototype = {
     let isInputOutput = lastVisibleNode &&
                         (lastVisibleNode.category == CATEGORY_INPUT ||
                          lastVisibleNode.category == CATEGORY_OUTPUT);
 
     // Scroll to the new node if it is not filtered, and if the output node is
     // scrolled at the bottom or if the new node is a jsterm input/output
     // message.
     if (lastVisibleNode && (scrolledToBottom || isInputOutput)) {
-      Utils.scrollToVisible(lastVisibleNode);
+      // Utils.scrollToVisible(lastVisibleNode);
     }
     else if (!scrolledToBottom && removedNodes > 0 &&
              oldScrollHeight != scrollNode.scrollHeight) {
       // If there were pruned messages and if scroll is not at the bottom, then
       // we need to adjust the scroll location.
-      scrollNode.scrollTop -= oldScrollHeight - scrollNode.scrollHeight;
+      // scrollNode.scrollTop -= oldScrollHeight - scrollNode.scrollHeight;
     }
 
     if (messages.size) {
       this.emit("new-messages", messages);
     }
 
     // If the output queue is empty, then run _flushCallback.
     if (this._outputQueue.length === 0 && this._flushCallback) {
@@ -4746,16 +4751,17 @@ var Utils = {
    *
    * @param nsIDOMNode aOutputNode
    * @return boolean
    *         True if the output node is scrolled to the bottom, or false
    *         otherwise.
    */
   isOutputScrolledToBottom: function Utils_isOutputScrolledToBottom(aOutputNode)
   {
+    return false;
     let lastNodeHeight = aOutputNode.lastChild ?
                          aOutputNode.lastChild.clientHeight : 0;
     let scrollNode = aOutputNode.parentNode;
     return scrollNode.scrollTop + scrollNode.clientHeight >=
            scrollNode.scrollHeight - lastNodeHeight / 2;
   },
 
   /**
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -14,16 +14,17 @@ loader.lazyImporter(this, "Services", "r
 loader.lazyImporter(this, "LayoutHelpers", "resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 // TODO: Bug 842672 - toolkit/ imports modules from browser/.
 // Note that these are only used in WebConsoleCommands, see $0 and pprint().
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "devtools", "resource://gre/modules/devtools/Loader.jsm");
 loader.lazyImporter(this, "VariablesView", "resource:///modules/devtools/VariablesView.jsm");
 loader.lazyImporter(this, "DevToolsUtils", "resource://gre/modules/devtools/DevToolsUtils.jsm");
+loader.lazyImporter(this, "DeferredTask", "resource://gre/modules/DeferredTask.jsm");
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
 // (function foobar(a, b) { ...
 // function foobar2(a) { ...
 // function() { ...
 const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;
@@ -1390,16 +1391,24 @@ ConsoleServiceListener.prototype =
  * @param string aConsoleID
  *        Options - The consoleID that this listener should listen to
  */
 function ConsoleAPIListener(aWindow, aOwner, aConsoleID)
 {
   this.window = aWindow;
   this.owner = aOwner;
   this.consoleID = aConsoleID;
+  this._pendingMessages = [];
+  this.onMessage = new DeferredTask(() => {
+    dump("Num pending messages: " + this._pendingMessages.length + "\n");
+    for (let msg of this._pendingMessages) {
+      this.owner.onConsoleAPICall(msg);
+    }
+    this._pendingMessages = [];
+  }, 100);
   if (this.window) {
     this.layoutHelpers = new LayoutHelpers(this.window);
   }
 }
 exports.ConsoleAPIListener = ConsoleAPIListener;
 
 ConsoleAPIListener.prototype =
 {
@@ -1459,17 +1468,18 @@ ConsoleAPIListener.prototype =
         // Not the same window!
         return;
       }
     }
     if (this.consoleID && apiMessage.consoleID != this.consoleID) {
       return;
     }
 
-    this.owner.onConsoleAPICall(apiMessage);
+    this._pendingMessages.push(apiMessage);
+    this.onMessage.arm();
   },
 
   /**
    * Get the cached messages for the current inner window and its (i)frames.
    *
    * @param boolean [aIncludePrivate=false]
    *        Tells if you want to also retrieve messages coming from private
    *        windows. Defaults to false.
