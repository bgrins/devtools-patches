# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  183ee39bf309cd8463d8db5b5c8eb232cd0dac53
Bug 1476333 - Expose browser.chromeURI through BrowserUtils

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -16,17 +16,17 @@
 #
 
 #ifdef XP_UNIX
 #ifndef XP_MACOSX
 #define UNIX_BUT_NOT_MAC
 #endif
 #endif
 
-pref("browser.chromeURL","chrome://browser/content/");
+pref("browser.chromeURL", "chrome://browser/content/browser.xul");
 pref("browser.hiddenWindowChromeURL", "chrome://browser/content/hiddenWindow.xul");
 
 // Enables some extra Extension System Logging (can reduce performance)
 pref("extensions.logging.enabled", false);
 
 // Disables strict compatibility, making addons compatible-by-default.
 pref("extensions.strictCompatibility", false);
 
diff --git a/browser/base/content/browser-places.js b/browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js
+++ b/browser/base/content/browser-places.js
@@ -525,17 +525,17 @@ var PlacesCommandHook = {
   },
 
   /**
    * Updates disabled state for the "Bookmark All Tabs" command.
    */
   updateBookmarkAllTabsCommand:
   function PCH_updateBookmarkAllTabsCommand() {
     // There's nothing to do in non-browser windows.
-    if (window.location.href != getBrowserURL())
+    if (window.location.href != BrowserUtils.browserURL)
       return;
 
     // Disable "Bookmark All Tabs" if there are less than two
     // "unique current pages".
     goSetCommandEnabled("Browser:BookmarkAllTabs",
                         this.uniqueCurrentPages.length >= 2);
   },
 
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -2178,18 +2178,18 @@ function BrowserGoHome(aEvent) {
     // homepage, if necessary. Observers are only notified if the homepage
     // becomes the active page.
     Services.obs.notifyObservers(null, "browser-open-homepage-start");
   }
 }
 
 function loadOneOrMoreURIs(aURIString, aTriggeringPrincipal) {
   // we're not a browser window, pass the URI string to a new browser window
-  if (window.location.href != getBrowserURL()) {
-    window.openDialog(getBrowserURL(), "_blank", "all,dialog=no", aURIString);
+  if (window.location.href != BrowserUtils.browserURL) {
+    window.openDialog(BrowserUtils.browserURL, "_blank", "all,dialog=no", aURIString);
     return;
   }
 
   // This function throws for certain malformed URIs, so use exception handling
   // so that we don't disrupt startup
   try {
     gBrowser.loadTabs(aURIString.split("|"), {
       inBackground: false,
@@ -2229,31 +2229,31 @@ function focusAndSelectUrlBar(userInitia
   }
 
   gURLBar.userInitiatedFocus = userInitiatedFocus;
   gURLBar.select();
   gURLBar.userInitiatedFocus = false;
 }
 
 function openLocation() {
-  if (window.location.href == getBrowserURL()) {
+  if (window.location.href == BrowserUtils.browserURL) {
     focusAndSelectUrlBar(true);
     return;
   }
 
   // If there's an open browser window, redirect the command there.
   let win = getTopWin();
   if (win) {
     win.focus();
     win.openLocation();
     return;
   }
 
   // There are no open browser windows; open a new one.
-  window.openDialog("chrome://browser/content/", "_blank",
+  window.openDialog(BrowserUtils.browserURL, "_blank",
                     "chrome,all,dialog=no", BROWSER_NEW_TAB_URL);
 }
 
 function BrowserOpenTab(event) {
   let where = "tab";
   let relatedToCurrent = false;
 
   if (event) {
@@ -2350,17 +2350,17 @@ function BrowserOpenFileWindow() {
     fp.displayDirectory = gLastOpenDirectory.path;
     fp.open(fpCallback);
   } catch (ex) {
   }
 }
 
 function BrowserCloseTabOrWindow(event) {
   // If we're not a browser window, just close the window.
-  if (window.location.href != getBrowserURL()) {
+  if (window.location.href != BrowserUtils.browserURL) {
     closeWindow(true);
     return;
   }
 
   // In a multi-select context, close all selected tabs
   if (gBrowser.multiSelectedTabsCount) {
     gBrowser.removeMultiSelectedTabs();
     return;
@@ -3918,31 +3918,31 @@ const BrowserSearch = {
   },
 
   /**
    * Gives focus to the search bar, if it is present on the toolbar, or loads
    * the default engine's search form otherwise. For Mac, opens a new window
    * or focuses an existing window, if necessary.
    */
   webSearch: function BrowserSearch_webSearch() {
-    if (window.location.href != getBrowserURL()) {
+    if (window.location.href != BrowserUtils.browserURL) {
       var win = getTopWin();
       if (win) {
         // If there's an open browser window, it should handle this command
         win.focus();
         win.BrowserSearch.webSearch();
       } else {
         // If there are no open browser windows, open a new one
         var observer = function(subject, topic, data) {
           if (subject == win) {
             BrowserSearch.webSearch();
             Services.obs.removeObserver(observer, "browser-delayed-startup-finished");
           }
         };
-        win = window.openDialog(getBrowserURL(), "_blank",
+        win = window.openDialog(BrowserUtils.browserURL, "_blank",
                                 "chrome,all,dialog=no", "about:blank");
         Services.obs.addObserver(observer, "browser-delayed-startup-finished");
       }
       return;
     }
 
     let focusUrlBarIfSearchFieldIsNotActive = function(aSearchBar) {
       if (!aSearchBar || document.activeElement != aSearchBar.textbox.inputField) {
@@ -4307,20 +4307,20 @@ function OpenBrowserWindow(options) {
   // set, then extract the current charset menu setting from the current document and use it to
   // initialize the new browser window...
   var win;
   if (window && (wintype == "navigator:browser") && window.content && window.content.document) {
     var DocCharset = window.content.document.characterSet;
     let charsetArg = "charset=" + DocCharset;
 
     // we should "inherit" the charset menu setting in a new window
-    win = window.openDialog("chrome://browser/content/", "_blank", "chrome,all,dialog=no" + extraFeatures, defaultArgs, charsetArg);
+    win = window.openDialog(BrowserUtils.browserURL, "_blank", "chrome,all,dialog=no" + extraFeatures, defaultArgs, charsetArg);
   } else {
     // forget about the charset information.
-    win = window.openDialog("chrome://browser/content/", "_blank", "chrome,all,dialog=no" + extraFeatures, defaultArgs);
+    win = window.openDialog(BrowserUtils.browserURL, "_blank", "chrome,all,dialog=no" + extraFeatures, defaultArgs);
   }
 
   win.addEventListener("MozAfterPaint", () => {
     TelemetryStopwatch.finish("FX_NEW_WINDOW_MS", telemetryObj);
     if (Services.prefs.getIntPref("browser.startup.page") == 1
         && defaultArgs == HomePage.get()) {
       // A notification for when a user has triggered their homepage. This is used
       // to display a doorhanger explaining that an extension has modified the
@@ -5433,17 +5433,17 @@ nsBrowserAccess.prototype = {
         // referrer like the other loads do?
         var url = aURI ? aURI.spec : "about:blank";
         let features = "all,dialog=no";
         if (isPrivate) {
           features += ",private";
         }
         // Pass all params to openDialog to ensure that "url" isn't passed through
         // loadOneOrMoreURIs, which splits based on "|"
-        newWindow = openDialog(getBrowserURL(), "_blank", features, url, null, null, null);
+        newWindow = openDialog(BrowserUtils.browserURL, "_blank", features, url, null, null, null);
         break;
       case Ci.nsIBrowserDOMWindow.OPEN_NEWTAB :
         // If we have an opener, that means that the caller is expecting access
         // to the nsIDOMWindow of the opened tab right away. For e10s windows,
         // this means forcing the newly opened browser to be non-remote so that
         // we can hand back the nsIDOMWindow. The XULBrowserWindow.shouldLoadURI
         // will do the job of shuttling off the newly opened browser to run in
         // the right process once it starts loading a URI.
@@ -7402,17 +7402,17 @@ var gPrivateBrowsingUI = {
     if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
       return;
     }
 
     // Disable the Clear Recent History... menu item when in PB mode
     // temporary fix until bug 463607 is fixed
     document.getElementById("Tools:Sanitize").setAttribute("disabled", "true");
 
-    if (window.location.href == getBrowserURL()) {
+    if (window.location.href == BrowserUtils.browserURL) {
       // Adjust the window's title
       let docElement = document.documentElement;
       if (!PrivateBrowsingUtils.permanentPrivateBrowsing) {
         docElement.setAttribute("title",
           docElement.getAttribute("title_privatebrowsing"));
         docElement.setAttribute("titlemodifier",
           docElement.getAttribute("titlemodifier_privatebrowsing"));
       }
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -3411,17 +3411,17 @@ window._gBrowser = {
     // waiting for the new window to appear.
     // content area when the docshells are swapped.
     if (this.animationsEnabled) {
       aTab.style.maxWidth = ""; // ensure that fade-out transition happens
       aTab.removeAttribute("fadein");
     }
 
     // tell a new window to take the "dropped" tab
-    return window.openDialog(getBrowserURL(), "_blank", options, aTab);
+    return window.openDialog(BrowserUtils.browserURL, "_blank", options, aTab);
   },
 
   /**
    * Move contextTab (or selected tabs in a mutli-select context)
    * to a new browser window, unless it is (they are) already the only tab(s)
    * in the current window, in which case this will do nothing.
    */
   replaceTabsWithWindow(contextTab) {
diff --git a/browser/base/content/test/general/browser_bug462673.js b/browser/base/content/test/general/browser_bug462673.js
--- a/browser/base/content/test/general/browser_bug462673.js
+++ b/browser/base/content/test/general/browser_bug462673.js
@@ -1,25 +1,25 @@
 add_task(async function() {
-  var win = openDialog(getBrowserURL(), "_blank", "chrome,all,dialog=no");
+  var win = openDialog(BrowserUtils.browserURL, "_blank", "chrome,all,dialog=no");
   await SimpleTest.promiseFocus(win);
 
   let tab = win.gBrowser.tabContainer.firstChild;
   await promiseTabLoadEvent(tab, getRootDirectory(gTestPath) + "test_bug462673.html");
 
   is(win.gBrowser.browsers.length, 2, "test_bug462673.html has opened a second tab");
   is(win.gBrowser.selectedTab, tab.nextSibling, "dependent tab is selected");
   win.gBrowser.removeTab(tab);
 
   // Closing a tab will also close its parent chrome window, but async
   await promiseWindowWillBeClosed(win);
 });
 
 add_task(async function() {
-  var win = openDialog(getBrowserURL(), "_blank", "chrome,all,dialog=no");
+  var win = openDialog(BrowserUtils.browserURL, "_blank", "chrome,all,dialog=no");
   await SimpleTest.promiseFocus(win);
 
   let tab = win.gBrowser.tabContainer.firstChild;
   await promiseTabLoadEvent(tab, getRootDirectory(gTestPath) + "test_bug462673.html");
 
   var newTab = win.gBrowser.addTab();
   var newBrowser = newTab.linkedBrowser;
   win.gBrowser.removeTab(tab);
diff --git a/browser/base/content/test/general/browser_fullscreen-window-open.js b/browser/base/content/test/general/browser_fullscreen-window-open.js
--- a/browser/base/content/test/general/browser_fullscreen-window-open.js
+++ b/browser/base/content/test/general/browser_fullscreen-window-open.js
@@ -246,17 +246,17 @@ function waitForWindowOpen(aOptions) {
 
   let onFinalize = function() {
     aOptions.finalizeFn();
 
     info("Finished: " + message.title);
     runNextTest();
   };
 
-  let listener = new WindowListener(message.title, getBrowserURL(), {
+  let listener = new WindowListener(message.title, BrowserUtils.browserURL, {
     onSuccess: aOptions.successFn,
     onFinalize,
   });
   Services.wm.addListener(listener);
 
   executeWindowOpenInContent({
     uri: url,
     title: message.title,
@@ -287,17 +287,17 @@ function waitForWindowOpenFromChrome(aOp
 
   let onFinalize = function() {
     aOptions.finalizeFn();
 
     info("Finished: " + message.title);
     runNextTest();
   };
 
-  let listener = new WindowListener(message.title, getBrowserURL(), {
+  let listener = new WindowListener(message.title, BrowserUtils.browserURL, {
     onSuccess: aOptions.successFn,
     onFinalize,
   });
   Services.wm.addListener(listener);
 
   newWin.open(url, message.title, message.option);
 }
 
diff --git a/browser/base/content/test/general/browser_tab_dragdrop2.js b/browser/base/content/test/general/browser_tab_dragdrop2.js
--- a/browser/base/content/test/general/browser_tab_dragdrop2.js
+++ b/browser/base/content/test/general/browser_tab_dragdrop2.js
@@ -5,17 +5,17 @@ const URI = ROOT + "browser_tab_dragdrop
 
 // Load the test page (which runs some child popup tests) in a new window.
 // After the tests were run, tear off the tab into a new window and run popup
 // tests a second time. We don't care about tests results, exceptions and
 // crashes will be caught.
 add_task(async function() {
   // Open a new window.
   let args = "chrome,all,dialog=no";
-  let win = window.openDialog(getBrowserURL(), "_blank", args, URI);
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank", args, URI);
 
   // Wait until the tests were run.
   await promiseTestsDone(win);
   ok(true, "tests succeeded");
 
   // Create a second tab so that we can move the original one out.
   win.gBrowser.addTab("about:blank", {skipAnimation: true});
 
diff --git a/browser/base/content/test/performance/browser_windowopen.js b/browser/base/content/test/performance/browser_windowopen.js
--- a/browser/base/content/test/performance/browser_windowopen.js
+++ b/browser/base/content/test/performance/browser_windowopen.js
@@ -54,17 +54,17 @@ if (Services.appinfo.OS == "WINNT" || Se
 add_task(async function() {
   // Flushing all caches helps to ensure that we get consistent
   // behaviour when opening a new window, even if windows have been
   // opened in previous tests.
   Services.obs.notifyObservers(null, "startupcache-invalidate");
   Services.obs.notifyObservers(null, "chrome-flush-skin-caches");
   Services.obs.notifyObservers(null, "chrome-flush-caches");
 
-  let win = window.openDialog("chrome://browser/content/", "_blank",
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank",
                               "chrome,all,dialog=no,remote,suppressanimation",
                               "about:home");
 
   let alreadyFocused = false;
   let inRange = (val, min, max) => min <= val && val <= max;
   let expectations = {
     expectedReflows: EXPECTED_REFLOWS,
     frames: {
diff --git a/browser/base/content/test/static/browser_all_files_referenced.js b/browser/base/content/test/static/browser_all_files_referenced.js
--- a/browser/base/content/test/static/browser_all_files_referenced.js
+++ b/browser/base/content/test/static/browser_all_files_referenced.js
@@ -571,17 +571,17 @@ add_task(async function checkAllTheFiles
     uri = convertToCodeURI(uri.spec);
     if ((uri.startsWith("chrome://") || uri.startsWith("resource://")) &&
         isDevtools == hasDevtoolsPrefix(uri))
       chromeFiles.push(uri);
   }
 
   if (isDevtools) {
     // chrome://devtools/skin/devtools-browser.css is included from browser.xul
-    gReferencesFromCode.set("chrome://browser/content/browser.xul", null);
+    gReferencesFromCode.set(BrowserUtils.browserURL, null);
     // devtools' css is currently included from browser.css, see bug 1204810.
     gReferencesFromCode.set("chrome://browser/skin/browser.css", null);
   }
 
   let isUnreferenced = file => {
     if (gExceptionPaths.some(e => file.startsWith(e)))
       return false;
     if (gReferencesFromCode.has(file)) {
diff --git a/browser/base/content/test/webrtc/get_user_media_content_script.js b/browser/base/content/test/webrtc/get_user_media_content_script.js
--- a/browser/base/content/test/webrtc/get_user_media_content_script.js
+++ b/browser/base/content/test/webrtc/get_user_media_content_script.js
@@ -17,17 +17,17 @@ const kObservedTopics = [
   "recording-window-ended"
 ];
 
 var gObservedTopics = {};
 
 function ignoreEvent(aSubject, aTopic, aData) {
   // With e10s disabled, our content script receives notifications for the
   // preview displayed in our screen sharing permission prompt; ignore them.
-  const kBrowserURL = "chrome://browser/content/browser.xul";
+  const kBrowserURL = BrowserUtils.browserURL;
   const nsIPropertyBag = Ci.nsIPropertyBag;
   if (aTopic == "recording-device-events" &&
       aSubject.QueryInterface(nsIPropertyBag).getProperty("requestURL") == kBrowserURL) {
     return true;
   }
   if (aTopic == "recording-window-ended") {
     let win = Services.wm.getOuterWindowWithId(aData).top;
     if (win.document.documentURI == kBrowserURL)
diff --git a/browser/base/content/utilityOverlay.js b/browser/base/content/utilityOverlay.js
--- a/browser/base/content/utilityOverlay.js
+++ b/browser/base/content/utilityOverlay.js
@@ -7,16 +7,17 @@
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 
 ChromeUtils.defineModuleGetter(this, "PrivateBrowsingUtils",
                                "resource://gre/modules/PrivateBrowsingUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   ContextualIdentityService: "resource://gre/modules/ContextualIdentityService.jsm",
   ShellService: "resource:///modules/ShellService.jsm"
 });
 
 XPCOMUtils.defineLazyServiceGetter(this, "aboutNewTabService",
                                    "@mozilla.org/browser/aboutnewtab-service;1",
                                    "nsIAboutNewTabService");
@@ -43,20 +44,16 @@ var gBidiUI = false;
  */
 function isBlankPageURL(aURL) {
   return aURL == "about:blank" ||
          aURL == "about:home" ||
          aURL == "about:welcome" ||
          aURL == BROWSER_NEW_TAB_URL;
 }
 
-function getBrowserURL() {
-  return "chrome://browser/content/browser.xul";
-}
-
 function getTopWin(skipPopups) {
   // If this is called in a browser window, use that window regardless of
   // whether it's the frontmost window, since commands can be executed in
   // background windows (bug 626148).
   if (top.document.documentElement.getAttribute("windowtype") == "navigator:browser" &&
       (!skipPopups || top.toolbar.visible))
     return top;
 
@@ -422,17 +419,17 @@ function openLinkIn(url, where, params) 
               sourceTabBrowser,
               sourceFrameOuterWindowID: params.frameOuterWindowID,
             },
           }, "webNavigation-createdNavigationTarget");
         }
       };
       Services.obs.addObserver(delayedStartupObserver, "browser-delayed-startup-finished");
     }
-    win = Services.ww.openWindow(sourceWindow, getBrowserURL(), null, features, sa);
+    win = Services.ww.openWindow(sourceWindow, BrowserUtils.browserURL, null, features, sa);
     return;
   }
 
   // We're now committed to loading the link in an existing browser window.
 
   // Raise the target window before loading the URI, since loading it may
   // result in a new frontmost window (e.g. "javascript:window.open('');").
   w.focus();
@@ -842,17 +839,17 @@ function openPreferences(paneID, extraAr
   if (!win) {
     let windowArguments = Cc["@mozilla.org/array;1"]
       .createInstance(Ci.nsIMutableArray);
     let supportsStringPrefURL = Cc["@mozilla.org/supports-string;1"]
       .createInstance(Ci.nsISupportsString);
     supportsStringPrefURL.data = preferencesURL;
     windowArguments.appendElement(supportsStringPrefURL);
 
-    win = Services.ww.openWindow(null, Services.prefs.getCharPref("browser.chromeURL"),
+    win = Services.ww.openWindow(null, BrowserUtils.browserURL,
       "_blank", "chrome,dialog=no,all", windowArguments);
   } else {
     let shouldReplaceFragment = friendlyCategoryName ? "whenComparingAndReplace" : "whenComparing";
     newLoad = !win.switchToTabHavingURI(preferencesURL, true, {
       ignoreFragment: shouldReplaceFragment,
       replaceQueryString: true,
       triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
     });
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -6,16 +6,17 @@
 
 var EXPORTED_SYMBOLS = ["CustomizableUI"];
 
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   SearchWidgetTracker: "resource:///modules/SearchWidgetTracker.jsm",
   CustomizableWidgets: "resource:///modules/CustomizableWidgets.jsm",
   DeferredTask: "resource://gre/modules/DeferredTask.jsm",
   PanelMultiView: "resource:///modules/PanelMultiView.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   ShortcutUtils: "resource://gre/modules/ShortcutUtils.jsm",
   LightweightThemeManager: "resource://gre/modules/LightweightThemeManager.jsm",
 });
@@ -36,18 +37,16 @@ const kPrefCustomizationState        = "
 const kPrefCustomizationAutoAdd      = "browser.uiCustomization.autoAdd";
 const kPrefCustomizationDebug        = "browser.uiCustomization.debug";
 const kPrefDrawInTitlebar            = "browser.tabs.drawInTitlebar";
 const kPrefExtraDragSpace            = "browser.tabs.extraDragSpace";
 const kPrefUIDensity                 = "browser.uidensity";
 const kPrefAutoTouchMode             = "browser.touchmode.auto";
 const kPrefAutoHideDownloadsButton   = "browser.download.autohideButton";
 
-const kExpectedWindowURL = "chrome://browser/content/browser.xul";
-
 /**
  * The keys are the handlers that are fired when the event type (the value)
  * is fired on the subview. A widget that provides a subview has the option
  * of providing onViewShowing and onViewHiding event handlers.
  */
 const kSubviewEvents = [
   "ViewShowing",
   "ViewHiding"
@@ -1431,17 +1430,17 @@ var CustomizableUIInternal = {
           return element;
         }
       }
     }
     return null;
   },
 
   buildWidget(aDocument, aWidget) {
-    if (aDocument.documentURI != kExpectedWindowURL) {
+    if (aDocument.documentURI != BrowserUtils.browserURL) {
       throw new Error("buildWidget was called for a non-browser window!");
     }
     if (typeof aWidget == "string") {
       aWidget = gPalette.get(aWidget);
     }
     if (!aWidget) {
       throw new Error("buildWidget was passed a non-widget to build.");
     }
diff --git a/browser/components/customizableui/test/browser_947914_button_newPrivateWindow.js b/browser/components/customizableui/test/browser_947914_button_newPrivateWindow.js
--- a/browser/components/customizableui/test/browser_947914_button_newPrivateWindow.js
+++ b/browser/components/customizableui/test/browser_947914_button_newPrivateWindow.js
@@ -17,17 +17,17 @@ add_task(async function() {
   let windowWasHandled = false;
   let privateWindow = null;
 
   let observerWindowOpened = {
     observe(aSubject, aTopic, aData) {
       if (aTopic == "domwindowopened") {
         privateWindow = aSubject.QueryInterface(Ci.nsIDOMWindow);
         privateWindow.addEventListener("load", function() {
-          is(privateWindow.location.href, "chrome://browser/content/browser.xul",
+          is(privateWindow.location.href, BrowserUtils.browserURL,
              "A new browser window was opened");
           ok(PrivateBrowsingUtils.isWindowPrivate(privateWindow), "Window is private");
           windowWasHandled = true;
         }, {once: true});
       }
     }
   };
 
diff --git a/browser/components/customizableui/test/browser_947914_button_newWindow.js b/browser/components/customizableui/test/browser_947914_button_newWindow.js
--- a/browser/components/customizableui/test/browser_947914_button_newWindow.js
+++ b/browser/components/customizableui/test/browser_947914_button_newWindow.js
@@ -17,17 +17,17 @@ add_task(async function() {
   let windowWasHandled = false;
   let newWindow = null;
 
   let observerWindowOpened = {
     observe(aSubject, aTopic, aData) {
       if (aTopic == "domwindowopened") {
         newWindow = aSubject.QueryInterface(Ci.nsIDOMWindow);
         newWindow.addEventListener("load", function() {
-          is(newWindow.location.href, "chrome://browser/content/browser.xul",
+          is(newWindow.location.href, BrowserUtils.browserURL,
              "A new browser window was opened");
           ok(!PrivateBrowsingUtils.isWindowPrivate(newWindow), "Window is not private");
           windowWasHandled = true;
         }, {once: true});
       }
     }
   };
 
diff --git a/browser/components/distribution.js b/browser/components/distribution.js
--- a/browser/components/distribution.js
+++ b/browser/components/distribution.js
@@ -8,20 +8,22 @@ const DISTRIBUTION_CUSTOMIZATION_COMPLET
   "distribution-customization-complete";
 
 const PREF_CACHED_FILE_EXISTENCE  = "distribution.iniFile.exists.value";
 const PREF_CACHED_FILE_APPVERSION = "distribution.iniFile.exists.appversion";
 
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
-ChromeUtils.defineModuleGetter(this, "Preferences",
-                               "resource://gre/modules/Preferences.jsm");
-ChromeUtils.defineModuleGetter(this, "PlacesUtils",
-                               "resource://gre/modules/PlacesUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
+  Preferences: "resource://gre/modules/Preferences.jsm",
+  PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
+});
 
 function DistributionCustomizer() {
 }
 
 DistributionCustomizer.prototype = {
   get _iniFile() {
     // For parallel xpcshell testing purposes allow loading the distribution.ini
     // file from the profile folder through an hidden pref.
@@ -416,17 +418,17 @@ DistributionCustomizer.prototype = {
         } catch (e) { /* ignore bad prefs and move on */ }
       }
     }
 
     return this._checkCustomizationComplete();
   },
 
   _checkCustomizationComplete: function DIST__checkCustomizationComplete() {
-    const BROWSER_DOCURL = "chrome://browser/content/browser.xul";
+    const BROWSER_DOCURL = BrowserUtils.browserURL;
 
     if (this._newProfile) {
       let xulStore = Services.xulStore;
 
       try {
         var showPersonalToolbar = Services.prefs.getBoolPref("browser.showPersonalToolbar");
         if (showPersonalToolbar) {
           xulStore.setValue(BROWSER_DOCURL, "PersonalToolbar", "collapsed", "false");
diff --git a/browser/components/enterprisepolicies/Policies.jsm b/browser/components/enterprisepolicies/Policies.jsm
--- a/browser/components/enterprisepolicies/Policies.jsm
+++ b/browser/components/enterprisepolicies/Policies.jsm
@@ -8,23 +8,24 @@ ChromeUtils.import("resource://gre/modul
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 XPCOMUtils.defineLazyServiceGetter(this, "gXulStore",
                                    "@mozilla.org/xul/xulstore;1",
                                    "nsIXULStore");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManager: "resource://gre/modules/AddonManager.jsm",
   BookmarksPolicies: "resource:///modules/policies/BookmarksPolicies.jsm",
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   CustomizableUI: "resource:///modules/CustomizableUI.jsm",
   ProxyPolicies: "resource:///modules/policies/ProxyPolicies.jsm",
   WebsiteFilter: "resource:///modules/policies/WebsiteFilter.jsm",
 });
 
 const PREF_LOGLEVEL           = "browser.policies.loglevel";
-const BROWSER_DOCUMENT_URL    = "chrome://browser/content/browser.xul";
+const BROWSER_DOCUMENT_URL    = BrowserUtils.browserURL;
 
 XPCOMUtils.defineLazyGetter(this, "log", () => {
   let { ConsoleAPI } = ChromeUtils.import("resource://gre/modules/Console.jsm", {});
   return new ConsoleAPI({
     prefix: "Policies.jsm",
     // tip: set maxLogLevel to "debug" and use log.debug() to create detailed
     // messages during development. See LOG_LEVELS in Console.jsm for details.
     maxLogLevel: "error",
@@ -953,17 +954,17 @@ function blockAboutPage(manager, feature
 }
 
 let ChromeURLBlockPolicy = {
   shouldLoad(contentLocation, loadInfo, mimeTypeGuess) {
     let contentType = loadInfo.externalContentPolicyType;
     if (contentLocation.scheme == "chrome" &&
         contentType == Ci.nsIContentPolicy.TYPE_DOCUMENT &&
         loadInfo.loadingContext &&
-        loadInfo.loadingContext.baseURI == "chrome://browser/content/browser.xul" &&
+        loadInfo.loadingContext.baseURI == BrowserUtils.browserURL &&
         contentLocation.host != "mochitests") {
       return Ci.nsIContentPolicy.REJECT_REQUEST;
     }
     return Ci.nsIContentPolicy.ACCEPT;
   },
   shouldProcess(contentLocation, loadInfo, mimeTypeGuess) {
     return Ci.nsIContentPolicy.ACCEPT;
   },
diff --git a/browser/components/extensions/parent/ext-windows.js b/browser/components/extensions/parent/ext-windows.js
--- a/browser/components/extensions/parent/ext-windows.js
+++ b/browser/components/extensions/parent/ext-windows.js
@@ -3,16 +3,20 @@
 "use strict";
 
 XPCOMUtils.defineLazyServiceGetter(this, "aboutNewTabService",
                                    "@mozilla.org/browser/aboutnewtab-service;1",
                                    "nsIAboutNewTabService");
 ChromeUtils.defineModuleGetter(this, "PrivateBrowsingUtils",
                                "resource://gre/modules/PrivateBrowsingUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
+});
+
 var {
   promiseObserved,
 } = ExtensionUtils;
 
 const onXULFrameLoaderCreated = ({target}) => {
   target.messageManager.sendAsyncMessage("AllowScriptsToClose", {});
 };
 
@@ -192,17 +196,17 @@ this.windows = class extends ExtensionAP
             }
           }
 
           let {allowScriptsToClose, url} = createData;
           if (allowScriptsToClose === null) {
             allowScriptsToClose = typeof url === "string" && url.startsWith("moz-extension://");
           }
 
-          let window = Services.ww.openWindow(null, "chrome://browser/content/browser.xul", "_blank",
+          let window = Services.ww.openWindow(null, BrowserUtils.browserURL, "_blank",
                                               features.join(","), args);
 
           let win = windowManager.getWrapper(window);
           win.updateGeometry(createData);
 
           // TODO: focused, type
 
           return new Promise(resolve => {
diff --git a/browser/components/extensions/test/browser/browser_ext_browserAction_pageAction_icon_permissions.js b/browser/components/extensions/test/browser/browser_ext_browserAction_pageAction_icon_permissions.js
--- a/browser/components/extensions/test/browser/browser_ext_browserAction_pageAction_icon_permissions.js
+++ b/browser/components/extensions/test/browser/browser_ext_browserAction_pageAction_icon_permissions.js
@@ -133,17 +133,17 @@ add_task(async function testSecureURLsDe
       "browser_action": {},
       "page_action": {},
     },
 
     background: function() {
       browser.tabs.query({active: true, currentWindow: true}, tabs => {
         let tabId = tabs[0].id;
 
-        let urls = ["chrome://browser/content/browser.xul",
+        let urls = [BrowserUtils.browserURL,
                     "javascript:true"];
 
         let promises = [];
         for (let url of urls) {
           for (let api of ["pageAction", "browserAction"]) {
             promises.push(
               browser.test.assertRejects(
                 browser[api].setIcon({tabId, path: url}),
@@ -164,17 +164,17 @@ add_task(async function testSecureURLsDe
   await extension.awaitFinish("setIcon security tests");
   await extension.unload();
 });
 
 
 add_task(async function testSecureManifestURLsDenied() {
   // Test URLs included in the manifest.
 
-  let urls = ["chrome://browser/content/browser.xul",
+  let urls = [BrowserUtils.browserURL,
               "javascript:true"];
 
   let apis = ["browser_action", "page_action"];
 
   for (let url of urls) {
     for (let api of apis) {
       info(`TEST ${api} icon url: ${url}`);
 
diff --git a/browser/components/extensions/test/browser/browser_ext_pageAction_popup.js b/browser/components/extensions/test/browser/browser_ext_pageAction_popup.js
--- a/browser/components/extensions/test/browser/browser_ext_pageAction_popup.js
+++ b/browser/components/extensions/test/browser/browser_ext_pageAction_popup.js
@@ -207,17 +207,17 @@ add_task(async function testPageActionPo
   let panel = document.getElementById(panelId);
   is(panel, null, "pageAction panel removed from document");
 
   BrowserTestUtils.removeTab(tab);
 });
 
 
 add_task(async function testPageActionSecurity() {
-  const URL = "chrome://browser/content/browser.xul";
+  const URL = BrowserUtils.browserURL;
 
   let apis = ["browser_action", "page_action"];
 
   for (let api of apis) {
     info(`TEST ${api} icon url: ${URL}`);
 
     let messages = [/Access to restricted URI denied/];
 
diff --git a/browser/components/extensions/test/browser/browser_ext_windows.js b/browser/components/extensions/test/browser/browser_ext_windows.js
--- a/browser/components/extensions/test/browser/browser_ext_windows.js
+++ b/browser/components/extensions/test/browser/browser_ext_windows.js
@@ -1,15 +1,15 @@
 /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set sts=2 sw=2 et tw=80: */
 "use strict";
 
 add_task(async function testWindowGetAll() {
   let raisedWin = Services.ww.openWindow(
-    null, Services.prefs.getCharPref("browser.chromeURL"), "_blank",
+    null, BrowserUtils.browserURL, "_blank",
     "chrome,dialog=no,all,alwaysRaised", null);
 
   await TestUtils.topicObserved("browser-delayed-startup-finished",
                                 subject => subject == raisedWin);
 
   let extension = ExtensionTestUtils.loadExtension({
     background: async function() {
       let wins = await browser.windows.getAll();
diff --git a/browser/components/migration/tests/marionette/test_refresh_firefox.py b/browser/components/migration/tests/marionette/test_refresh_firefox.py
--- a/browser/components/migration/tests/marionette/test_refresh_firefox.py
+++ b/browser/components/migration/tests/marionette/test_refresh_firefox.py
@@ -219,17 +219,17 @@ class TestFirefoxRefresh(MarionetteTestC
             bookmark => resolve(bookmark ? bookmark.title : ""),
             ex => resolve(ex)
           );
         """, script_args=(self._bookmarkURL,))
         self.assertEqual(titleInBookmarks, self._bookmarkText)
 
     def checkBookmarkToolbarVisibility(self):
         toolbarVisible = self.marionette.execute_script("""
-          const BROWSER_DOCURL = "chrome://browser/content/browser.xul";
+          const BROWSER_DOCURL = BrowserUtils.browserURL;
           return Services.xulStore.getValue(BROWSER_DOCURL, "PersonalToolbar", "collapsed");
         """)
         self.assertEqual(toolbarVisible, "false")
 
     def checkHistory(self):
         historyResult = self.runAsyncCode("""
           let resolve = arguments[arguments.length - 1];
           PlacesUtils.history.fetch(arguments[0]).then(pageInfo => {
diff --git a/browser/components/nsBrowserContentHandler.js b/browser/components/nsBrowserContentHandler.js
--- a/browser/components/nsBrowserContentHandler.js
+++ b/browser/components/nsBrowserContentHandler.js
@@ -2,16 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   HeadlessShell: "resource:///modules/HeadlessShell.jsm",
   HomePage: "resource:///modules/HomePage.jsm",
   LaterRun: "resource:///modules/LaterRun.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   ShellService: "resource:///modules/ShellService.jsm",
   UpdatePing: "resource://gre/modules/UpdatePing.jsm"
 });
@@ -171,17 +172,17 @@ function getPostUpdateOverridePage(defau
  * @param postData (optional)
  *        An nsIInputStream object to use as POST data when loading the provided
  *        url, or null.
  * @param forcePrivate (optional)
  *        Boolean. If set to true, the new window will be a private browsing one.
  */
 function openBrowserWindow(cmdLine, urlOrUrlList, postData = null,
                            forcePrivate = false) {
-  let chromeURL = Services.prefs.getCharPref("browser.chromeURL");
+  let chromeURL = BrowserUtils.browserURL;
 
   let args;
   if (!urlOrUrlList) {
     // Just pass in the defaultArgs directly
     args = [gBrowserContentHandler.defaultArgs];
   } else if (Array.isArray(urlOrUrlList)) {
     // Passing an nsIArray for the url disables the "|"-splitting behavior.
     let uriArray = Cc["@mozilla.org/array;1"]
diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -3,23 +3,27 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 
+XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
+});
+
 (function earlyBlankFirstPaint() {
   if (!Services.prefs.getBoolPref("browser.startup.blankWindow", false))
     return;
 
   let store = Services.xulStore;
   let getValue = attr =>
-    store.getValue("chrome://browser/content/browser.xul", "main-window", attr);
+    store.getValue(BrowserUtils.browserURL, "main-window", attr);
   let width = getValue("width");
   let height = getValue("height");
 
   // The clean profile case isn't handled yet. Return early for now.
   if (!width || !height)
     return;
 
   let screenX = getValue("screenX");
@@ -1784,17 +1788,17 @@ BrowserGlue.prototype = {
   /**
    * Uncollapses PersonalToolbar if its collapsed status is not
    * persisted, and user customized it or changed default bookmarks.
    *
    * If the user does not have a persisted value for the toolbar's
    * "collapsed" attribute, try to determine whether it's customized.
    */
   _maybeToggleBookmarkToolbarVisibility() {
-    const BROWSER_DOCURL = "chrome://browser/content/browser.xul";
+    const BROWSER_DOCURL = BrowserUtils.browserURL;
     const NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE = 3;
     let xulStore = Services.xulStore;
 
     if (!xulStore.hasValue(BROWSER_DOCURL, "PersonalToolbar", "collapsed")) {
       // We consider the toolbar customized if it has more than NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE
       // children, or if it has a persisted currentset value.
       let toolbarIsCustomized = xulStore.hasValue(BROWSER_DOCURL, "PersonalToolbar", "currentset");
       let getToolbarFolderCount = () => {
@@ -1810,17 +1814,17 @@ BrowserGlue.prototype = {
     }
   },
 
   // eslint-disable-next-line complexity
   _migrateUI: function BG__migrateUI() {
     // Use an increasing number to keep track of the current migration state.
     // Completely unrelated to the current Firefox release number.
     const UI_VERSION = 69;
-    const BROWSER_DOCURL = "chrome://browser/content/browser.xul";
+    const BROWSER_DOCURL = BrowserUtils.browserURL;
 
     let currentUIVersion;
     if (Services.prefs.prefHasUserValue("browser.migration.version")) {
       currentUIVersion = Services.prefs.getIntPref("browser.migration.version");
     } else {
       // This is a new profile, nothing to migrate.
       Services.prefs.setIntPref("browser.migration.version", UI_VERSION);
 
@@ -2361,17 +2365,17 @@ BrowserGlue.prototype = {
     let chromeWindow = BrowserWindowTracker.getTopWindow();
     chromeWindow.openPreferences(...args);
   },
 
   _openURLInNewWindow(url) {
     let urlString = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
     urlString.data = url;
     return new Promise(resolve => {
-      let win = Services.ww.openWindow(null, Services.prefs.getCharPref("browser.chromeURL"),
+      let win = Services.ww.openWindow(null, BrowserUtils.browserURL,
                                        "_blank", "chrome,all,dialog=no", urlString);
       win.addEventListener("load", () => { resolve(win); }, {once: true});
     });
   },
 
   /**
    * Called as an observer when Sync's "display URIs" notification is fired.
    *
diff --git a/browser/components/places/PlacesUIUtils.jsm b/browser/components/places/PlacesUIUtils.jsm
--- a/browser/components/places/PlacesUIUtils.jsm
+++ b/browser/components/places/PlacesUIUtils.jsm
@@ -8,16 +8,17 @@ var EXPORTED_SYMBOLS = ["PlacesUIUtils"]
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/Timer.jsm");
 
 XPCOMUtils.defineLazyGlobalGetters(this, ["Element"]);
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   AppConstants: "resource://gre/modules/AppConstants.jsm",
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   OpenInTabsUtils: "resource:///modules/OpenInTabsUtils.jsm",
   PlacesTransactions: "resource://gre/modules/PlacesTransactions.jsm",
   PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
   PluralForm: "resource://gre/modules/PluralForm.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
   Weave: "resource://services-sync/main.js",
@@ -600,17 +601,17 @@ var PlacesUIUtils = {
                 browserWindow.whereToOpenLink(aEvent, false, true) : "window";
     if (where == "window") {
       // There is no browser window open, thus open a new one.
       var uriList = PlacesUtils.toISupportsString(urls.join("|"));
       var args = Cc["@mozilla.org/array;1"].
                   createInstance(Ci.nsIMutableArray);
       args.appendElement(uriList);
       browserWindow = Services.ww.openWindow(aWindow,
-                                             "chrome://browser/content/browser.xul",
+                                             BrowserUtils.browserURL,
                                              null, "chrome,dialog=no,all", args);
       return;
     }
 
     var loadInBackground = where == "tabshifted";
     // For consistency, we want all the bookmarks to open in new tabs, instead
     // of having one of them replace the currently focused tab.  Hence we call
     // loadTabs with aReplace set to false.
diff --git a/browser/components/sessionstore/test/browser_394759_behavior.js b/browser/components/sessionstore/test/browser_394759_behavior.js
--- a/browser/components/sessionstore/test/browser_394759_behavior.js
+++ b/browser/components/sessionstore/test/browser_394759_behavior.js
@@ -22,17 +22,17 @@
 function testWindows(windowsToOpen, expectedResults) {
   return (async function() {
     for (let winData of windowsToOpen) {
       let features = "chrome,dialog=no," +
                      (winData.isPopup ? "all=no" : "all");
       let url = "http://example.com/?window=" + windowsToOpen.length;
 
       let openWindowPromise = BrowserTestUtils.waitForNewWindow({url});
-      openDialog(getBrowserURL(), "", features, url);
+      openDialog(BrowserUtils.browserURL, "", features, url);
       let win = await openWindowPromise;
       await BrowserTestUtils.closeWindow(win);
     }
 
     let closedWindowData = JSON.parse(ss.getClosedWindowData());
     let numPopups = closedWindowData.filter(function(el, i, arr) {
       return el.isPopup;
     }).length;
diff --git a/browser/components/sessionstore/test/browser_580512.js b/browser/components/sessionstore/test/browser_580512.js
--- a/browser/components/sessionstore/test/browser_580512.js
+++ b/browser/components/sessionstore/test/browser_580512.js
@@ -47,17 +47,17 @@ function checkSecondWin(win) {
     finish();
   });
 }
 
 function openWinWithCb(cb, argURIs, expectedURIs) {
   if (!expectedURIs)
     expectedURIs = argURIs;
 
-  var win = openDialog(getBrowserURL(), "_blank",
+  var win = openDialog(BrowserUtils.browserURL, "_blank",
                        "chrome,all,dialog=no", argURIs.join("|"));
 
   win.addEventListener("load", function() {
     info("the window loaded");
 
     var expectedLoads = expectedURIs.length;
 
     win.gBrowser.addTabsProgressListener({
diff --git a/browser/components/sessionstore/test/browser_588426.js b/browser/components/sessionstore/test/browser_588426.js
--- a/browser/components/sessionstore/test/browser_588426.js
+++ b/browser/components/sessionstore/test/browser_588426.js
@@ -19,17 +19,17 @@ function test() {
     is(tab.linkedBrowser.currentURI.spec, "about:mozilla", "visible tab is about:mozilla");
 
     finish();
   });
 }
 
 function newWindowWithState(state, callback) {
   let opts = "chrome,all,dialog=no,height=800,width=800";
-  let win = window.openDialog(getBrowserURL(), "_blank", opts);
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank", opts);
 
   win.addEventListener("load", function() {
     executeSoon(function() {
       win.addEventListener("SSWindowStateReady", function() {
         promiseTabRestored(win.gBrowser.tabs[0]).then(() => callback(win));
       }, {once: true});
 
       ss.setWindowState(win, JSON.stringify(state), true);
diff --git a/browser/components/sessionstore/test/browser_590563.js b/browser/components/sessionstore/test/browser_590563.js
--- a/browser/components/sessionstore/test/browser_590563.js
+++ b/browser/components/sessionstore/test/browser_590563.js
@@ -53,17 +53,17 @@ async function middleClickTest(win) {
      "The total number of tabs should be 3 after restoring 2 tabs by middle click.");
   is(win.gBrowser.visibleTabs.length, 3,
      "The total number of visible tabs should be 3 after restoring 2 tabs by middle click");
   finish();
 }
 
 function newWindowWithState(state, callback) {
   let opts = "chrome,all,dialog=no,height=800,width=800";
-  let win = window.openDialog(getBrowserURL(), "_blank", opts);
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank", opts);
 
   win.addEventListener("load", function() {
     // The form data will be restored before SSTabRestored, so we want to listen
     // for that on the currently selected tab
     let onSSTabRestored = event => {
       let tab = event.target;
       if (tab.selected) {
         win.gBrowser.tabContainer.removeEventListener("SSTabRestored", onSSTabRestored, true);
diff --git a/browser/components/sessionstore/test/browser_595601-restore_hidden.js b/browser/components/sessionstore/test/browser_595601-restore_hidden.js
--- a/browser/components/sessionstore/test/browser_595601-restore_hidden.js
+++ b/browser/components/sessionstore/test/browser_595601-restore_hidden.js
@@ -94,17 +94,17 @@ var TabsProgressListener = {
 
     return [needsRestore, isRestoring];
   }
 };
 
 // ----------
 function newWindowWithState(state, callback) {
   let opts = "chrome,all,dialog=no,height=800,width=800";
-  let win = window.openDialog(getBrowserURL(), "_blank", opts);
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank", opts);
 
   registerCleanupFunction(() => BrowserTestUtils.closeWindow(win));
 
   whenWindowLoaded(win, function onWindowLoaded(aWin) {
     TabsProgressListener.init(aWin);
     TabsProgressListener.setCallback(callback);
 
     ss.setWindowState(aWin, JSON.stringify(state), true);
diff --git a/browser/components/sessionstore/test/browser_659591.js b/browser/components/sessionstore/test/browser_659591.js
--- a/browser/components/sessionstore/test/browser_659591.js
+++ b/browser/components/sessionstore/test/browser_659591.js
@@ -18,14 +18,14 @@ function test() {
     BrowserTestUtils.closeWindow(win).then(() => {
       waitForFocus(finish);
     });
   });
 }
 
 function newWindow(callback) {
   let opts = "chrome,all,dialog=no,height=800,width=800";
-  let win = window.openDialog(getBrowserURL(), "_blank", opts);
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank", opts);
 
   win.addEventListener("load", function() {
     executeSoon(() => callback(win));
   }, {once: true});
 }
diff --git a/browser/components/sessionstore/test/browser_701377.js b/browser/components/sessionstore/test/browser_701377.js
--- a/browser/components/sessionstore/test/browser_701377.js
+++ b/browser/components/sessionstore/test/browser_701377.js
@@ -25,17 +25,17 @@ function test() {
 
     finish();
   });
 }
 
 // ----------
 function newWindowWithState(aState, aCallback) {
   let opts = "chrome,all,dialog=no,height=800,width=800";
-  let win = window.openDialog(getBrowserURL(), "_blank", opts);
+  let win = window.openDialog(BrowserUtils.browserURL, "_blank", opts);
 
   registerCleanupFunction(() => BrowserTestUtils.closeWindow(win));
 
   whenWindowLoaded(win, function onWindowLoaded(aWin) {
     ss.setWindowState(aWin, JSON.stringify(aState), true);
     executeSoon(() => aCallback(aWin));
   });
 }
diff --git a/browser/components/sessionstore/test/head.js b/browser/components/sessionstore/test/head.js
--- a/browser/components/sessionstore/test/head.js
+++ b/browser/components/sessionstore/test/head.js
@@ -52,17 +52,17 @@ Cc["@mozilla.org/browser/clh;1"].getServ
 
 function provideWindow(aCallback, aURL, aFeatures) {
   function callbackSoon(aWindow) {
     executeSoon(function executeCallbackSoon() {
       aCallback(aWindow);
     });
   }
 
-  let win = openDialog(getBrowserURL(), "", aFeatures || "chrome,all,dialog=no", aURL || "about:blank");
+  let win = openDialog(BrowserUtils.browserURL, "", aFeatures || "chrome,all,dialog=no", aURL || "about:blank");
   whenWindowLoaded(win, function onWindowLoaded(aWin) {
     if (!aURL) {
       info("Loaded a blank window.");
       callbackSoon(aWin);
       return;
     }
 
     aWin.gBrowser.selectedBrowser.addEventListener("load", function() {
@@ -438,17 +438,17 @@ function whenNewWindowLoaded(aOptions, a
   let features = "";
   let url = "about:blank";
 
   if (aOptions && aOptions.private || false) {
     features = ",private";
     url = "about:privatebrowsing";
   }
 
-  let win = openDialog(getBrowserURL(), "", "chrome,all,dialog=no" + features, url);
+  let win = openDialog(BrowserUtils.browserURL, "", "chrome,all,dialog=no" + features, url);
   let delayedStartup = promiseDelayedStartupFinished(win);
 
   let browserLoaded = new Promise(resolve => {
     if (url == "about:blank") {
       resolve();
       return;
     }
 
diff --git a/browser/components/syncedtabs/TabListComponent.js b/browser/components/syncedtabs/TabListComponent.js
--- a/browser/components/syncedtabs/TabListComponent.js
+++ b/browser/components/syncedtabs/TabListComponent.js
@@ -114,17 +114,17 @@ TabListComponent.prototype = {
     this._window.openTrustedLinkIn(url, where, params);
   },
 
   onOpenTabs(urls, where) {
     if (!OpenInTabsUtils.confirmOpenInTabs(urls.length, this._window)) {
       return;
     }
     if (where == "window") {
-      this._window.openDialog(this._window.getBrowserURL(), "_blank",
+      this._window.openDialog(this._window.BrowserUtils.browserURL, "_blank",
                               "chrome,dialog=no,all", urls.join("|"));
     } else {
       let loadInBackground = where == "tabshifted";
       this._getChromeWindow(this._window).gBrowser.loadTabs(urls, {
         inBackground: loadInBackground,
         replace: false,
         triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
       });
diff --git a/browser/components/syncedtabs/test/xpcshell/test_TabListComponent.js b/browser/components/syncedtabs/test/xpcshell/test_TabListComponent.js
--- a/browser/components/syncedtabs/test/xpcshell/test_TabListComponent.js
+++ b/browser/components/syncedtabs/test/xpcshell/test_TabListComponent.js
@@ -82,17 +82,16 @@ add_task(async function testActions() {
   };
   let windowMock = {
     top: {
       PlacesCommandHook: {
         bookmarkLink() { return Promise.resolve(); }
       },
       PlacesUtils: { bookmarksMenuFolderId: "id" }
     },
-    getBrowserURL() {},
     openDialog() {},
     openTrustedLinkIn() {}
   };
   let component = new TabListComponent({
     window: windowMock, store, View: null, SyncedTabs,
     clipboardHelper: clipboardHelperMock,
     getChromeWindow: getChromeWindowMock });
 
diff --git a/browser/components/tests/browser/browser_default_bookmark_toolbar_visibility.js b/browser/components/tests/browser/browser_default_bookmark_toolbar_visibility.js
--- a/browser/components/tests/browser/browser_default_bookmark_toolbar_visibility.js
+++ b/browser/components/tests/browser/browser_default_bookmark_toolbar_visibility.js
@@ -3,16 +3,16 @@
 
 /**
  * Test _maybeToggleBookmarkToolbarVisibility() code running for new profiles.
  * Ensure that the bookmarks toolbar is hidden in a default configuration.
  * If new default bookmarks are added to the toolbar then the threshold of > 3
  * in NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE may need to be adjusted there.
  */
 add_task(async function test_default_bookmark_toolbar_visibility() {
-  const BROWSER_DOCURL = "chrome://browser/content/browser.xul";
+  const BROWSER_DOCURL = BrowserUtils.browserURL;
   let xulStore = Services.xulStore;
 
   is(xulStore.getValue(BROWSER_DOCURL, "PersonalToolbar", "collapsed"), "",
      "Check that @collapsed isn't persisted");
   ok(document.getElementById("PersonalToolbar").collapsed,
      "The bookmarks toolbar should be collapsed by default");
 });
diff --git a/browser/modules/ContentWebRTC.jsm b/browser/modules/ContentWebRTC.jsm
--- a/browser/modules/ContentWebRTC.jsm
+++ b/browser/modules/ContentWebRTC.jsm
@@ -7,17 +7,19 @@
 var EXPORTED_SYMBOLS = [ "ContentWebRTC" ];
 
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 XPCOMUtils.defineLazyServiceGetter(this, "MediaManagerService",
                                    "@mozilla.org/mediaManagerService;1",
                                    "nsIMediaManagerService");
 
-const kBrowserURL = "chrome://browser/content/browser.xul";
+XPCOMUtils.defineLazyModuleGetters(this, {
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
+});
 
 var ContentWebRTC = {
   // Called only for 'unload' to remove pending gUM prompts in reloaded frames.
   handleEvent(aEvent) {
     let contentWindow = aEvent.target.defaultView;
     let mm = getMessageManagerForWindow(contentWindow);
     for (let key of contentWindow.pendingGetUserMediaRequests.keys()) {
       mm.sendAsyncMessage("webrtc:CancelRequest", key);
@@ -273,17 +275,17 @@ function forgetPendingListsEventually(aC
   }
   aContentWindow.pendingGetUserMediaRequests = null;
   aContentWindow.pendingPeerConnectionRequests = null;
   aContentWindow.removeEventListener("unload", ContentWebRTC);
 }
 
 function updateIndicators(aSubject, aTopic, aData) {
   if (aSubject instanceof Ci.nsIPropertyBag &&
-      aSubject.getProperty("requestURL") == kBrowserURL) {
+      aSubject.getProperty("requestURL") == BrowserUtils.browserURL) {
     // Ignore notifications caused by the browser UI showing previews.
     return;
   }
 
   let contentWindowArray = MediaManagerService.activeMediaCaptureWindows;
   let count = contentWindowArray.length;
 
   let state = {
@@ -299,17 +301,17 @@ function updateIndicators(aSubject, aTop
   // have the same top level window several times. We use a Set to avoid
   // sending duplicate notifications.
   let contentWindows = new Set();
   for (let i = 0; i < count; ++i) {
     contentWindows.add(contentWindowArray.queryElementAt(i, Ci.nsISupports).top);
   }
 
   for (let contentWindow of contentWindows) {
-    if (contentWindow.document.documentURI == kBrowserURL) {
+    if (contentWindow.document.documentURI == BrowserUtils.browserURL) {
       // There may be a preview shown at the same time as other streams.
       continue;
     }
 
     let tabState = getTabStateForContentWindow(contentWindow);
     if (tabState.camera == MediaManagerService.STATE_CAPTURE_ENABLED ||
         tabState.camera == MediaManagerService.STATE_CAPTURE_DISABLED) {
       state.showCameraIndicator = true;
@@ -337,17 +339,17 @@ function updateIndicators(aSubject, aTop
     mm.sendAsyncMessage("webrtc:UpdateBrowserIndicators", tabState);
   }
 
   Services.cpmm.sendAsyncMessage("webrtc:UpdateGlobalIndicators", state);
 }
 
 function removeBrowserSpecificIndicator(aSubject, aTopic, aData) {
   let contentWindow = Services.wm.getOuterWindowWithId(aData).top;
-  if (contentWindow.document.documentURI == kBrowserURL) {
+  if (contentWindow.document.documentURI == BrowserUtils.browserURL) {
     // Ignore notifications caused by the browser UI showing previews.
     return;
   }
 
   let tabState = getTabStateForContentWindow(contentWindow);
   if (tabState.camera == MediaManagerService.STATE_NOCAPTURE &&
       tabState.microphone == MediaManagerService.STATE_NOCAPTURE &&
       !tabState.screen)
diff --git a/browser/modules/Sanitizer.jsm b/browser/modules/Sanitizer.jsm
--- a/browser/modules/Sanitizer.jsm
+++ b/browser/modules/Sanitizer.jsm
@@ -5,16 +5,17 @@
 
 var EXPORTED_SYMBOLS = ["Sanitizer"];
 
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   AppConstants: "resource://gre/modules/AppConstants.jsm",
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
   FormHistory: "resource://gre/modules/FormHistory.jsm",
   TelemetryStopwatch: "resource://gre/modules/TelemetryStopwatch.jsm",
   ContextualIdentityService: "resource://gre/modules/ContextualIdentityService.jsm",
 });
 
 XPCOMUtils.defineLazyServiceGetter(this, "quotaManagerService",
                                    "@mozilla.org/dom/quota-manager-service;1",
@@ -492,17 +493,17 @@ var Sanitizer = {
         let refObj = {};
         TelemetryStopwatch.start("FX_SANITIZE_OPENWINDOWS", refObj);
 
         // First create a new window. We do this first so that on non-mac, we don't
         // accidentally close the app by closing all the windows.
         let handler = Cc["@mozilla.org/browser/clh;1"].getService(Ci.nsIBrowserHandler);
         let defaultArgs = handler.defaultArgs;
         let features = "chrome,all,dialog=no," + privateStateForNewWindow;
-        let newWindow = existingWindow.openDialog("chrome://browser/content/", "_blank",
+        let newWindow = existingWindow.openDialog(BrowserUtils.browserURL, "_blank",
                                                   features, defaultArgs);
 
         let onFullScreen = null;
         if (AppConstants.platform == "macosx") {
           onFullScreen = function(e) {
             newWindow.removeEventListener("fullscreen", onFullScreen);
             let docEl = newWindow.document.documentElement;
             let sizemode = docEl.getAttribute("sizemode");
diff --git a/toolkit/modules/BrowserUtils.jsm b/toolkit/modules/BrowserUtils.jsm
--- a/toolkit/modules/BrowserUtils.jsm
+++ b/toolkit/modules/BrowserUtils.jsm
@@ -703,8 +703,10 @@ var BrowserUtils = {
         }
       } else {
         fragment.appendChild(part);
       }
     }
     return fragment;
   },
 };
+
+XPCOMUtils.defineLazyPreferenceGetter(BrowserUtils, "browserURL", "browser.chromeURL");
