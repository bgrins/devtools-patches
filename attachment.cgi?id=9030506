# HG changeset patch
# User Neil Deakin <neil@mozilla.com>
# Parent  2c5eb9d8b8e2680e7ff3d8fe2714bfd78ef0c7d0

diff --git a/dom/base/CustomElementRegistry.cpp b/dom/base/CustomElementRegistry.cpp
--- a/dom/base/CustomElementRegistry.cpp
+++ b/dom/base/CustomElementRegistry.cpp
@@ -7,25 +7,29 @@
 #include "mozilla/dom/CustomElementRegistry.h"
 
 #include "mozilla/AsyncEventDispatcher.h"
 #include "mozilla/CycleCollectedJSContext.h"
 #include "mozilla/dom/CustomElementRegistryBinding.h"
 #include "mozilla/dom/HTMLElementBinding.h"
 #include "mozilla/dom/ShadowIncludingTreeIterator.h"
 #include "mozilla/dom/XULElementBinding.h"
+#include "mozilla/dom/HTMLTemplateElement.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WebComponentsBinding.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/CustomEvent.h"
 #include "mozilla/dom/ShadowRoot.h"
+#include "nsSyncLoadService.h"
+#include "nsHTMLDocument.h"
 #include "nsHTMLTags.h"
 #include "jsapi.h"
 #include "xpcprivate.h"
 #include "nsGlobalWindow.h"
+#include "nsNetUtil.h"
 
 namespace mozilla {
 namespace dom {
 
 //-----------------------------------------------------
 // CustomElementUpgradeReaction
 
 class CustomElementUpgradeReaction final : public CustomElementReaction {
@@ -315,16 +319,18 @@ CustomElementRegistry::CustomElementRegi
 
   mozilla::HoldJSObjects(this);
 }
 
 CustomElementRegistry::~CustomElementRegistry() {
   mozilla::DropJSObjects(this);
 }
 
+nsInterfaceHashtable<nsURIHashKey, nsIDocument> CustomElementRegistry::sSharedFragmentCache;
+
 NS_IMETHODIMP
 CustomElementRegistry::RunCustomElementCreationCallback::Run() {
   ErrorResult er;
   nsDependentAtomString value(mAtom);
   mCallback->Call(value, er);
   MOZ_ASSERT(NS_SUCCEEDED(er.StealNSResult()),
              "chrome JavaScript error in the callback.");
 
@@ -1044,16 +1050,82 @@ already_AddRefed<Promise> CustomElementR
     promise = entry.Data();
   } else {
     entry.OrInsert([&promise]() { return promise; });
   }
 
   return promise.forget();
 }
 
+already_AddRefed<nsINode> CustomElementRegistry::GetSharedFragment(
+    nsIDocument& aDocument, const nsAString& aUri)
+{
+  nsCOMPtr<nsIURI> inputURI, sourceURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(inputURI), aUri);
+  if (NS_FAILED(rv)) {
+    return nullptr;
+  }
+
+  bool hasRef;
+  inputURI->GetHasRef(&hasRef);
+
+  nsAutoCString ref;
+  inputURI->GetRef(ref);
+  NS_GetURIWithoutRef(inputURI, getter_AddRefs(sourceURI));
+
+  nsCOMPtr<nsIDocument> document;
+  if (!sSharedFragmentCache.Get(sourceURI, getter_AddRefs(document))) {
+    // GetSharedFragment should only be called by chome so using the
+    // system principal should be ok here.
+    nsCOMPtr<nsILoadGroup> loadGroup = aDocument.GetDocumentLoadGroup();
+    rv = nsSyncLoadService::LoadDocument(
+           sourceURI, nsIContentPolicy::TYPE_DOCUMENT,
+           nsContentUtils::GetSystemPrincipal(),
+           nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL,
+           nullptr, false, net::RP_Unset, getter_AddRefs(document));
+    if (NS_SUCCEEDED(rv) && document) {
+      sSharedFragmentCache.Put(sourceURI, document);
+    } else {
+      // Do nothing.
+    }
+  }
+
+  if (document) {
+    RefPtr<Element> templateNode;
+    if (hasRef) {
+      templateNode = document->GetElementById(NS_ConvertUTF8toUTF16(ref));
+    } else {
+      RefPtr<Element> rootElement;
+      nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(document);
+      if (htmlDocument) {
+        rootElement = document->GetBody();
+      } else {
+        rootElement = document->GetDocumentElement();
+      }
+
+      if (rootElement && rootElement->IsHTMLElement(nsGkAtoms::_template)) {
+        templateNode = rootElement->GetFirstElementChild();
+      }
+    }
+
+    RefPtr<HTMLTemplateElement> templateElement = HTMLTemplateElement::FromNode(templateNode);
+    if (templateElement) {
+      RefPtr<DocumentFragment> templateContent = templateElement->Content();
+
+      // XXXndeakin strip whitespace nodes here
+
+      ErrorResult rv;
+      RefPtr<nsINode> resultNode = aDocument.ImportNode(*templateContent, true, rv);
+      return resultNode.forget();
+    }
+  }
+
+  return nullptr;
+}
+
 namespace {
 
 static void DoUpgrade(Element* aElement, CustomElementConstructor* aConstructor,
                       ErrorResult& aRv) {
   // Rethrow the exception since it might actually throw the exception from the
   // upgrade steps back out to the caller of document.createElement.
   RefPtr<Element> constructResult =
       aConstructor->Construct("Custom Element Upgrade", aRv);
diff --git a/dom/base/CustomElementRegistry.h b/dom/base/CustomElementRegistry.h
--- a/dom/base/CustomElementRegistry.h
+++ b/dom/base/CustomElementRegistry.h
@@ -14,16 +14,17 @@
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/dom/CustomElementRegistryBinding.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/WebComponentsBinding.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsGenericHTMLElement.h"
+#include "nsInterfaceHashtable.h"
 #include "nsWrapperCache.h"
 #include "nsContentUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 struct CustomElementData;
 struct ElementDefinitionOptions;
@@ -522,16 +523,18 @@ class CustomElementRegistry final : publ
   // type is created here, and elements will later be upgraded.
   CandidateMap mElementCreationCallbacksUpgradeCandidatesMap;
 
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
 
   // It is used to prevent reentrant invocations of element definition.
   bool mIsCustomDefinitionRunning;
 
+  static nsInterfaceHashtable<nsURIHashKey, nsIDocument> sSharedFragmentCache;
+
  private:
   class MOZ_RAII AutoSetRunningFlag final {
    public:
     explicit AutoSetRunningFlag(CustomElementRegistry* aRegistry)
         : mRegistry(aRegistry) {
       MOZ_ASSERT(!mRegistry->mIsCustomDefinitionRunning,
                  "IsCustomDefinitionRunning flag should be initially false");
       mRegistry->mIsCustomDefinitionRunning = true;
@@ -565,16 +568,19 @@ class CustomElementRegistry final : publ
 
   // Chrome-only method that give JS an opportunity to only load the custom
   // element definition script when needed.
   void SetElementCreationCallback(const nsAString& aName,
                                   CustomElementCreationCallback& aCallback,
                                   ErrorResult& aRv);
 
   void Upgrade(nsINode& aRoot);
+
+  already_AddRefed<nsINode> GetSharedFragment(nsIDocument& aDocument,
+                                              const nsAString& aUri);
 };
 
 class MOZ_RAII AutoCEReaction final {
  public:
   // JSContext is allowed to be a nullptr if we are guaranteeing that we're
   // not doing something that might throw but not finish reporting a JS
   // exception during the lifetime of the AutoCEReaction.
   AutoCEReaction(CustomElementReactionsStack* aReactionsStack, JSContext* aCx)
diff --git a/dom/html/HTMLTemplateElement.h b/dom/html/HTMLTemplateElement.h
--- a/dom/html/HTMLTemplateElement.h
+++ b/dom/html/HTMLTemplateElement.h
@@ -20,16 +20,18 @@ class HTMLTemplateElement final : public
       already_AddRefed<mozilla::dom::NodeInfo>&& aNodeInfo);
 
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(HTMLTemplateElement,
                                            nsGenericHTMLElement)
 
+  NS_IMPL_FROMNODE_HTML_WITH_TAG(HTMLTemplateElement, _template)
+
   virtual nsresult Clone(dom::NodeInfo*, nsINode** aResult) const override;
 
   DocumentFragment* Content() { return mContent; }
 
  protected:
   virtual ~HTMLTemplateElement();
 
   virtual JSObject* WrapNode(JSContext* aCx,
diff --git a/dom/webidl/CustomElementRegistry.webidl b/dom/webidl/CustomElementRegistry.webidl
--- a/dom/webidl/CustomElementRegistry.webidl
+++ b/dom/webidl/CustomElementRegistry.webidl
@@ -8,15 +8,17 @@ interface CustomElementRegistry {
   void define(DOMString name, Function functionConstructor,
               optional ElementDefinitionOptions options);
   [ChromeOnly, Throws]
   void setElementCreationCallback(DOMString name, CustomElementCreationCallback callback);
   any get(DOMString name);
   [Throws]
   Promise<void> whenDefined(DOMString name);
   [CEReactions] void upgrade(Node root);
+
+  [ChromeOnly] Node? getSharedFragment(Document document, DOMString uri);
 };
 
 dictionary ElementDefinitionOptions {
   DOMString extends;
 };
 
 callback CustomElementCreationCallback = void (DOMString name);
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -157,16 +157,20 @@ const MozElementMixin = Base => class Mo
     }
     // We use a range here so that we don't access the inner DOM elements from
     // JavaScript before they are imported and inserted into a document.
     let range = doc.createRange();
     range.selectNodeContents(doc.querySelector("box"));
     return range.extractContents();
   }
 
+  static getFragment(document, uri) {
+    return customElements.getSharedFragment(document, uri);
+  }
+
   /**
    * Insert a localization link to an FTL file. This is used so that
    * a Custom Element can wait to inject the link until it's connected,
    * and so that consuming documents don't require the correct <link>
    * present in the markup.
    *
    * @param path
    *        The path to the FTL file
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -99,13 +99,15 @@ toolkit.jar:
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
    content/global/elements/marquee.js          (widgets/marquee.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
+   content/global/templates/findbar.xml        (templates/findbar.xml)
+   content/global/templates/tree.xml           (templates/tree.xml)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
    content/global/gmp-sources/widevinecdm.json (gmp-sources/widevinecdm.json)
diff --git a/toolkit/content/templates/findbar.xml b/toolkit/content/templates/findbar.xml
new file mode 100644
--- /dev/null
+++ b/toolkit/content/templates/findbar.xml
@@ -0,0 +1,28 @@
+<html>
+<body xmlns="http://www.w3.org/1999/xhtml">
+
+  <template id="findbar">
+    <hbox anonid="findbar-container" class="findbar-container" flex="1" align="center"
+          xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+      <hbox anonid="findbar-textbox-wrapper" align="stretch">
+        <textbox anonid="findbar-textbox" class="findbar-textbox findbar-find-fast" />
+        <toolbarbutton anonid="find-previous" class="findbar-find-previous tabbable" data-l10n-attrs="tooltiptext" data-l10n-id="findbar-previous" oncommand="onFindAgainCommand(true);" disabled="true" />
+        <toolbarbutton anonid="find-next" class="findbar-find-next tabbable" data-l10n-id="findbar-next" oncommand="onFindAgainCommand(false);" disabled="true" />
+      </hbox>
+      <toolbarbutton anonid="highlight" class="findbar-highlight findbar-button tabbable" data-l10n-id="findbar-highlight-all2" oncommand="toggleHighlight(this.checked);" type="checkbox" />
+      <toolbarbutton anonid="find-case-sensitive" class="findbar-case-sensitive findbar-button tabbable" data-l10n-id="findbar-case-sensitive" oncommand="_setCaseSensitivity(this.checked ? 1 : 0);" type="checkbox" />
+      <toolbarbutton anonid="find-entire-word" class="findbar-entire-word findbar-button tabbable" data-l10n-id="findbar-entire-word" oncommand="toggleEntireWord(this.checked);" type="checkbox" />
+      <label anonid="match-case-status" class="findbar-find-fast" /><div></div>
+      <label anonid="entire-word-status" class="findbar-find-fast" />
+      <label anonid="found-matches" class="findbar-find-fast found-matches" hidden="true" />
+      <image anonid="find-status-icon" class="findbar-find-fast find-status-icon" />
+      <description anonid="find-status" control="findbar-textbox" class="findbar-find-fast findbar-find-status" />
+      <description anonid="find-status" control="findbar-textbox" class="findbar-find-fast findbar-find-status">Bacon</description>
+    </hbox>
+    <toolbarbutton anonid="find-closebutton" class="findbar-closebutton close-icon" data-l10n-id="findbar-find-button-close" oncommand="close();"
+                   xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"/>
+  </template>
+
+</body>
+</html>
+
diff --git a/toolkit/content/templates/tree.xml b/toolkit/content/templates/tree.xml
new file mode 100644
--- /dev/null
+++ b/toolkit/content/templates/tree.xml
@@ -0,0 +1,13 @@
+<html>
+<body xmlns="http://www.w3.org/1999/xhtml">
+
+  <template id="treecol">
+    <label class="treecol-text" flex="1" crop="right"
+           xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"></label>
+    <image class="treecol-sortdirection"
+            xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"></image>
+  </template>
+
+</body>
+</html>
+
diff --git a/toolkit/content/widgets/findbar.js b/toolkit/content/widgets/findbar.js
--- a/toolkit/content/widgets/findbar.js
+++ b/toolkit/content/widgets/findbar.js
@@ -22,43 +22,26 @@ class MozFindbar extends XULElement {
     this.addEventListener("keypress", (event) => {
       if (event.keyCode == event.DOM_VK_ESCAPE) {
         if (this.close)
           this.close();
         event.preventDefault();
       }
     }, true);
 
-    this.content = MozXULElement.parseXULToFragment(`
-      <hbox anonid="findbar-container" class="findbar-container" flex="1" align="center">
-        <hbox anonid="findbar-textbox-wrapper" align="stretch">
-          <textbox anonid="findbar-textbox" class="findbar-textbox findbar-find-fast" />
-          <toolbarbutton anonid="find-previous" class="findbar-find-previous tabbable" data-l10n-attrs="tooltiptext" data-l10n-id="findbar-previous" oncommand="onFindAgainCommand(true);" disabled="true" />
-          <toolbarbutton anonid="find-next" class="findbar-find-next tabbable" data-l10n-id="findbar-next" oncommand="onFindAgainCommand(false);" disabled="true" />
-        </hbox>
-        <toolbarbutton anonid="highlight" class="findbar-highlight findbar-button tabbable" data-l10n-id="findbar-highlight-all2" oncommand="toggleHighlight(this.checked);" type="checkbox" />
-        <toolbarbutton anonid="find-case-sensitive" class="findbar-case-sensitive findbar-button tabbable" data-l10n-id="findbar-case-sensitive" oncommand="_setCaseSensitivity(this.checked ? 1 : 0);" type="checkbox" />
-        <toolbarbutton anonid="find-entire-word" class="findbar-entire-word findbar-button tabbable" data-l10n-id="findbar-entire-word" oncommand="toggleEntireWord(this.checked);" type="checkbox" />
-        <label anonid="match-case-status" class="findbar-find-fast" />
-        <label anonid="entire-word-status" class="findbar-find-fast" />
-        <label anonid="found-matches" class="findbar-find-fast found-matches" hidden="true" />
-        <image anonid="find-status-icon" class="findbar-find-fast find-status-icon" />
-        <description anonid="find-status" control="findbar-textbox" class="findbar-find-fast findbar-find-status" />
-      </hbox>
-      <toolbarbutton anonid="find-closebutton" class="findbar-closebutton close-icon" data-l10n-id="findbar-find-button-close" oncommand="close();" />
-    `);
+    this.content = MozXULElement.getFragment(this.ownerDocument, "chrome://global/content/templates/findbar.xml#findbar");
   }
 
   connectedCallback() {
     // Hide the findbar immediately without animation. This prevents a flicker in the case where
     // we'll never be shown (i.e. adopting a tab that has a previously-opened-but-now-closed
     // findbar into a new window).
     this.setAttribute("noanim", "true");
     this.hidden = true;
-    this.appendChild(document.importNode(this.content, true));
+    this.appendChild(this.content);
 
     /**
      * Please keep in sync with toolkit/modules/FindBarChild.jsm
      */
     this.FIND_NORMAL = 0;
 
     this.FIND_TYPEAHEAD = 1;
 
diff --git a/toolkit/content/widgets/tree.js b/toolkit/content/widgets/tree.js
--- a/toolkit/content/widgets/tree.js
+++ b/toolkit/content/widgets/tree.js
@@ -257,20 +257,18 @@
         "label",
         "sortdirection",
         "hideheader",
         "crop",
       ];
     }
 
     get content() {
-      return MozXULElement.parseXULToFragment(`
-        <label class="treecol-text" flex="1" crop="right"></label>
-        <image class="treecol-sortdirection"></image>
-    `);
+      return MozXULElement.getFragment(this.ownerDocument,
+              "chrome://global/content/templates/tree.xml#treecol");
     }
 
     constructor() {
       super();
 
       this.addEventListener("mousedown", (event) => {
         if (event.button != 0) { return; }
         if (this.parentNode.parentNode.enableColumnDrag) {
