# HG changeset patch
# User Matteo Ferretti <mferretti@mozilla.com>
# Date 1435105135 25200
#      Tue Jun 23 17:18:55 2015 -0700
# Node ID dfecc0ac01abfcd5f53e04c7ba77098b9ac681d1
# Parent  8a3519734f64b6b3aca630835ee8a8147e6cbfd7
Bug 1153474 - CMD + G in style editor does not find next if you haven't hit enter first; r=bgrins

diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -31,16 +31,18 @@ const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const events  = require("devtools/toolkit/event-emitter");
 const { PrefObserver } = require("devtools/styleeditor/utils");
 
 Cu.import("resource://gre/modules/Services.jsm");
 const L10N = Services.strings.createBundle(L10N_BUNDLE);
 
+const { OS } = Services.appinfo;
+
 // CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
 // JavaScript and CSS that is injected into an iframe in
 // order to initialize a CodeMirror instance.
 
 const CM_STYLES   = [
   "chrome://browser/skin/devtools/common.css",
   "chrome://browser/content/devtools/codemirror/codemirror.css",
   "chrome://browser/content/devtools/codemirror/dialog.css",
@@ -294,16 +296,69 @@ Editor.prototype = {
         ev.preventDefault();
         if (!this.config.contextMenu) return;
         let popup = this.config.contextMenu;
         if (typeof popup == "string")
           popup = el.ownerDocument.getElementById(this.config.contextMenu);
         popup.openPopupAtScreen(ev.screenX, ev.screenY, true);
       }, false);
 
+      // Intercept the find and find again keystroke on CodeMirror, to avoid
+      // the browser's search
+
+      let findKey = L10N.GetStringFromName("find.commandkey");
+      let findAgainKey = L10N.GetStringFromName("findAgain.commandkey");
+      let [accel, modifier] = OS === "Darwin"
+                                      ? ["metaKey", "altKey"]
+                                      : ["ctrlKey", "shiftKey"];
+
+      cm.getWrapperElement().addEventListener("keydown", (ev) => {
+        let key = ev.key.toUpperCase();
+        let node = ev.originalTarget;
+        let isInput = node.tagName === "INPUT";
+        let isSearch = isInput && node.type === "search";
+        let isDialog = isInput &&
+                       node.parentNode &&
+                       node.parentNode.classList.contains("CodeMirror-dialog");
+
+        if (!ev[accel] || !(isSearch || isDialog)) return;
+
+        if (key === findKey) {
+          ev.preventDefault();
+
+          if (isSearch || ev[modifier]) {
+            node.select();
+          }
+        } else if (key === findAgainKey) {
+          ev.preventDefault();
+
+          if (!isSearch) return;
+
+          let query = node.value;
+
+          // If there isn't a search state, or the text in the input does not
+          // match with the current search state, we need to create a new one
+          if (!cm.state.search || cm.state.search.query !== query) {
+            cm.state.search = {
+              posFrom: null,
+              posTo: null,
+              overlay: null,
+              query
+            };
+          }
+
+          if (ev.shiftKey) {
+            cm.execCommand("findPrev");
+          } else {
+            cm.execCommand("findNext");
+          }
+        }
+      });
+
+
       cm.on("focus", () => this.emit("focus"));
       cm.on("scroll", () => this.emit("scroll"));
       cm.on("change", () => {
         this.emit("change");
         if (!this._lastDirty) {
           this._lastDirty = true;
           this.emit("dirty-change");
         }
diff --git a/browser/devtools/sourceeditor/test/browser.ini b/browser/devtools/sourceeditor/test/browser.ini
--- a/browser/devtools/sourceeditor/test/browser.ini
+++ b/browser/devtools/sourceeditor/test/browser.ini
@@ -23,16 +23,17 @@ support-files =
   head.js
   helper_codemirror_runner.js
 
 [browser_editor_autocomplete_basic.js]
 [browser_editor_autocomplete_events.js]
 [browser_editor_autocomplete_js.js]
 [browser_editor_basic.js]
 [browser_editor_cursor.js]
+[browser_editor_find_again.js]
 [browser_editor_goto_line.js]
 [browser_editor_history.js]
 [browser_editor_markers.js]
 [browser_editor_movelines.js]
 [browser_editor_prefs.js]
 [browser_editor_script_injection.js]
 [browser_editor_addons.js]
 [browser_codemirror.js]
diff --git a/browser/devtools/sourceeditor/test/browser_editor_find_again.js b/browser/devtools/sourceeditor/test/browser_editor_find_again.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_editor_find_again.js
@@ -0,0 +1,229 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const L10N_BUNDLE = "chrome://browser/locale/devtools/sourceeditor.properties";
+const L10N = Services.strings.createBundle(L10N_BUNDLE);
+
+const FIND_KEY = L10N.GetStringFromName("find.commandkey");
+const FINDAGAIN_KEY = L10N.GetStringFromName("findAgain.commandkey");
+
+const { OS } = Services.appinfo;
+
+const waitFor = (target, type) => new Promise((resolve, reject) => {
+  target.addEventListener(type, function listener() {
+    target.removeEventListener(type, listener);
+    resolve(target);
+  });
+});
+
+const dispatchEventAsync = (target, event) => {
+  setTimeout(() => target.dispatchEvent(event, 0));
+}
+
+function openSearchBox(ed) {
+  let edDoc = ed.container.contentDocument;
+  let edWin = edDoc.defaultView;
+
+  let input = edDoc.querySelector("input[type=search]");
+  ok(!input, "search box closed");
+
+  // The editor needs the focus to properly receive the `synthesizeKey`
+  ed.focus();
+
+  EventUtils.synthesizeKey(FINDAGAIN_KEY, { accelKey: true }, edWin);
+
+  input = edDoc.querySelector("input[type=search]");
+  ok(input, "find again command key opens the search box");
+}
+
+function testFindAgain (ed, inputLine, expectCursor, shiftKey=false) {
+  let edDoc = ed.container.contentDocument;
+  let edWin = edDoc.defaultView;
+
+  let input = edDoc.querySelector("input[type=search]");
+  input.value = inputLine;
+
+  // Ensure the input has the focus before send the key – necessary on Linux,
+  // it seems that during the tests can be lost
+  input.focus();
+
+  EventUtils.synthesizeKey(FINDAGAIN_KEY, { accelKey: true, shiftKey }, edWin);
+
+  ch(ed.getCursor(), expectCursor,
+    "find: " + inputLine + " expects cursor: " + expectCursor.toSource());
+}
+
+const testSearchBoxTextIsSelected = Task.async(function*(ed) {
+  let edDoc = ed.container.contentDocument;
+  let edWin = edDoc.defaultView;
+
+  let input = edDoc.querySelector("input[type=search]");
+  ok(input, "search box is opened");
+
+  // Ensure the input has the focus before send the key – necessary on Linux,
+  // it seems that during the tests can be lost
+  input.focus();
+
+  // Close search box
+  EventUtils.synthesizeKey("VK_ESCAPE", {}, edWin);
+
+  input = edDoc.querySelector("input[type=search]");
+  ok(!input, "search box is closed");
+
+  // Re-open the search box
+  EventUtils.synthesizeKey(FIND_KEY, { accelKey: true }, edWin);
+
+  input = edDoc.querySelector("input[type=search]");
+  ok(input, "find command key opens the search box");
+
+  // On linux, getting immediately the selection's range here fails, returning
+  // values like it's not selected – even if the selection is visible.
+  // For the record, setting the selection's range immediately doesn't have
+  // any effect.
+  // It's like the <input> is not ready yet.
+  // Therefore, we trigger asynchronously the UI focus event to the <input>,
+  // waiting for the response.
+  // Using a timeout could also work, but that is more precise, ensuring also
+  // the execution of the listeners added to the <input>'s focus.
+  dispatchEventAsync(input, new UIEvent("focus"));
+
+  yield waitFor(input, "focus");
+
+  let { selectionStart, selectionEnd, value } = input;
+
+  ok(selectionStart === 0 && selectionEnd === value.length,
+    "search box's text is selected when re-opened");
+
+  // Removing selection
+  input.setSelectionRange(0, 0);
+
+  EventUtils.synthesizeKey(FIND_KEY, { accelKey: true }, edWin);
+
+  ({ selectionStart, selectionEnd } = input);
+
+  ok(selectionStart === 0 && selectionEnd === value.length,
+    "search box's text is selected when find key is pressed");
+
+  // Close search box
+  EventUtils.synthesizeKey("VK_ESCAPE", {}, edWin);
+});
+
+const testReplaceBoxTextIsSelected = Task.async(function*(ed) {
+  let edDoc = ed.container.contentDocument;
+  let edWin = edDoc.defaultView;
+
+  let input = edDoc.querySelector(".CodeMirror-dialog > input");
+  ok(!input, "dialog box with replace is closed");
+
+  // The editor needs the focus to properly receive the `synthesizeKey`
+  ed.focus();
+
+  // Send the replace's key with the appropriate modifiers based on OS
+  let [altKey, shiftKey] = OS === "Darwin" ? [true, false] : [false, true];
+
+  EventUtils.synthesizeKey(FIND_KEY,
+    { accelKey: true, altKey, shiftKey }, edWin);
+
+  input = edDoc.querySelector(".CodeMirror-dialog > input");
+  ok(input, "dialog box with replace is opened");
+
+  input.value = "line 5";
+
+  // Ensure the input has the focus before send the key – necessary on Linux,
+  // it seems that during the tests can be lost
+  input.focus();
+
+  // On linux, getting immediately the selection's range here fails, returning
+  // values like it's not selected – even if the selection is visible.
+  // For the record, setting the selection's range immediately doesn't have
+  // any effect.
+  // It's like the <input> is not ready yet.
+  // Therefore, we trigger asynchronously the UI focus event to the <input>,
+  // waiting for the response.
+  // Using a timeout could also work, but that is more precise, ensuring also
+  // the execution of the listeners added to the <input>'s focus.
+  dispatchEventAsync(input, new UIEvent("focus"));
+
+  yield waitFor(input, "focus");
+
+  let { selectionStart, selectionEnd, value } = input;
+
+  ok(!(selectionStart === 0 && selectionEnd === value.length),
+    "Text in dialog box is not selected");
+
+  EventUtils.synthesizeKey(FIND_KEY,
+    { accelKey: true, altKey, shiftKey }, edWin);
+
+  ({ selectionStart, selectionEnd } = input);
+
+  ok(selectionStart === 0 && selectionEnd === value.length,
+    "dialog box's text is selected when replace key is pressed");
+
+  // Close dialog box
+  EventUtils.synthesizeKey("VK_ESCAPE", {}, edWin);
+});
+
+add_task(function*() {
+  let { ed, win } = yield setup();
+
+  ed.setText([
+    "// line 1",
+    "//  line 2",
+    "//   line 3",
+    "//    line 4",
+    "//     line 5"
+  ].join("\n"));
+
+  yield promiseWaitForFocus();
+
+  openSearchBox(ed);
+
+  let testVectors = [
+    // Starting here expect data needs to get updated for length changes to
+    // "textLines" above.
+    ["line",
+     {line: 0, ch: 7}],
+    ["line",
+     {line: 1, ch: 8}],
+    ["line",
+     {line: 2, ch: 9}],
+    ["line",
+     {line: 3, ch: 10}],
+    ["line",
+     {line: 4, ch: 11}],
+    ["ne 3",
+     {line: 2, ch: 11}],
+    ["line 1",
+      {line: 0, ch: 9}],
+    // Testing find prev
+    ["line",
+      {line: 4, ch: 11},
+      true],
+    ["line",
+      {line: 3, ch: 10},
+      true],
+    ["line",
+      {line: 2, ch: 9},
+      true],
+    ["line",
+      {line: 1, ch: 8},
+      true],
+    ["line",
+      {line: 0, ch: 7},
+      true]
+  ];
+
+  for (let v of testVectors) {
+    yield testFindAgain(ed, ...v);
+  }
+
+  yield testSearchBoxTextIsSelected(ed);
+
+  yield testReplaceBoxTextIsSelected(ed);
+
+  teardown(ed, win);
+});
diff --git a/browser/devtools/sourceeditor/test/head.js b/browser/devtools/sourceeditor/test/head.js
--- a/browser/devtools/sourceeditor/test/head.js
+++ b/browser/devtools/sourceeditor/test/head.js
@@ -34,16 +34,21 @@ function addTab(aURL, aCallback) {
   browser.addEventListener("load", onTabLoad, true);
 }
 
 function promiseTab(aURL) {
   return new Promise(resolve =>
     addTab(aURL, resolve));
 }
 
+function promiseWaitForFocus() {
+  return new Promise(resolve =>
+    waitForFocus(resolve));
+}
+
 function setup(cb, additionalOpts = {}) {
   cb = cb || function() {};
   let def = promise.defer();
   const opt = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
   const url = "data:application/vnd.mozilla.xul+xml;charset=UTF-8,<?xml version='1.0'?>" +
     "<?xml-stylesheet href='chrome://global/skin/global.css'?>" +
     "<window xmlns='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul'" +
     " title='Editor' width='600' height='500'><box flex='1'/></window>";
diff --git a/browser/locales/en-US/chrome/browser/devtools/sourceeditor.properties b/browser/locales/en-US/chrome/browser/devtools/sourceeditor.properties
--- a/browser/locales/en-US/chrome/browser/devtools/sourceeditor.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/sourceeditor.properties
@@ -94,8 +94,18 @@ moveLineDown.commandkey=Alt-Down
 
 # LOCALIZATION NOTE  (autocomplete.commandkey): This is the key to use
 # in conjunction with Ctrl for autocompletion.
 autocompletion.commandkey=Space
 
 # LOCALIZATION NOTE  (showInformation2.commandkey): This is the key to use to
 # show more information, like type inference.
 showInformation2.commandkey=Shift-Ctrl-Space
+
+# LOCALIZATION NOTE  (find.commandkey): This is the key to use in
+# conjunction with accel (Command on Mac or Ctrl on other platforms) to find
+# the typed search
+find.commandkey=F
+
+# LOCALIZATION NOTE  (findAgain.commandkey): This is the key to use in
+# conjunction with accel (Command on Mac or Ctrl on other platforms) to find
+# again the typed search
+findAgain.commandkey=G
