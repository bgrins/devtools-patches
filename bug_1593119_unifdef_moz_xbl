# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1572562197 25200
#      Thu Oct 31 15:49:57 2019 -0700
# Node ID 8ce9c4507a500467cab195c8428675708e8801cf
# Parent  06c52ca1bdfcf4f1d3fce9b8b9ca94c757f065d6
Bug 1593119 - unifdef MOZ_XBL

This was generated with:

```
rg -l -g '*.{cpp,h}' MOZ_XBL . | while read FILE ; do
   echo $FILE
   unifdef -m -UMOZ_XBL $FILE
done
```

After this, I manually removed the directive in nsContentUtils.cpp due to:

  unifdef: ./dom/base/nsContentUtils.cpp: 4630: Unterminated string literal
  unifdef: Output may be truncated

Differential Revision: https://phabricator.services.mozilla.com/D51337

diff --git a/dom/base/BindContext.h b/dom/base/BindContext.h
--- a/dom/base/BindContext.h
+++ b/dom/base/BindContext.h
@@ -4,19 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* State that is passed down to BindToTree. */
 
 #ifndef mozilla_dom_BindContext_h__
 #define mozilla_dom_BindContext_h__
 
-#ifdef MOZ_XBL
-#  include "nsXBLBinding.h"
-#endif
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/ShadowRoot.h"
 
 namespace mozilla {
 namespace dom {
@@ -94,28 +91,16 @@ struct MOZ_STACK_CLASS BindContext final
         mInUncomposedDoc(aParentElement.IsInUncomposedDoc()),
         mSubtreeRootChanges(true),
         mCollectingDisplayedNodeDataDuringLoad(
             ShouldCollectDisplayedNodeDataDuringLoad(mInComposedDoc, mDoc,
                                                      aParentElement)) {
     MOZ_ASSERT(mInComposedDoc, "Binding NAC in a disconnected subtree?");
   }
 
-#ifdef MOZ_XBL
-  // This is meant to be used to bind XBL anonymous content.
-  BindContext(nsXBLBinding& aBinding, Element& aParentElement)
-      : mDoc(*aParentElement.OwnerDoc()),
-        mBindingParent(aBinding.GetBoundElement()),
-        mInComposedDoc(aParentElement.IsInComposedDoc()),
-        mInUncomposedDoc(aParentElement.IsInUncomposedDoc()),
-        mSubtreeRootChanges(true),
-        mCollectingDisplayedNodeDataDuringLoad(
-            ShouldCollectDisplayedNodeDataDuringLoad(mInComposedDoc, mDoc,
-                                                     aParentElement)) {}
-#endif
 
   bool CollectingDisplayedNodeDataDuringLoad() const {
     return mCollectingDisplayedNodeDataDuringLoad;
   }
 
  private:
   static bool IsLikelyUndisplayed(const nsINode& aParent) {
     return aParent.IsAnyOfHTMLElements(nsGkAtoms::style, nsGkAtoms::script);
diff --git a/dom/base/CharacterData.cpp b/dom/base/CharacterData.cpp
--- a/dom/base/CharacterData.cpp
+++ b/dom/base/CharacterData.cpp
@@ -24,19 +24,16 @@
 #include "mozilla/InternalMutationEvent.h"
 #include "nsIURI.h"
 #include "nsCOMPtr.h"
 #include "nsDOMString.h"
 #include "nsChangeHint.h"
 #include "nsCOMArray.h"
 #include "nsNodeUtils.h"
 #include "mozilla/dom/DirectionalityUtils.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsCCUncollectableMarker.h"
 #include "mozAutoDocUpdate.h"
 #include "nsTextNode.h"
 #include "nsBidiUtils.h"
 #include "PLDHashTable.h"
 #include "mozilla/Sprintf.h"
 #include "nsWindowSizes.h"
 #include "nsWrapperCacheInlines.h"
@@ -510,19 +507,16 @@ nsresult CharacterData::BindToTree(BindC
 }
 
 void CharacterData::UnbindFromTree(bool aNullParent) {
   // Unset frame flags; if we need them again later, they'll get set again.
   UnsetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE | NS_REFRAME_IF_WHITESPACE);
 
   HandleShadowDOMRelatedRemovalSteps(aNullParent);
 
-#ifdef MOZ_XBL
-  Document* document = GetComposedDoc();
-#endif
 
   if (aNullParent) {
     if (IsRootOfNativeAnonymousSubtree()) {
       nsNodeUtils::NativeAnonymousChildListChange(this, true);
     }
     if (GetParent()) {
       NS_RELEASE(mParent);
     } else {
@@ -535,28 +529,16 @@ void CharacterData::UnbindFromTree(bool 
 
   if (aNullParent || !mParent->IsInShadowTree()) {
     UnsetFlags(NODE_IS_IN_SHADOW_TREE);
 
     // Begin keeping track of our subtree root.
     SetSubtreeRootPointer(aNullParent ? this : mParent->SubtreeRoot());
   }
 
-#ifdef MOZ_XBL
-  if (document && !GetContainingShadow()) {
-    // Notify XBL- & nsIAnonymousContentCreator-generated
-    // anonymous content that the document is changing.
-    // Unlike XBL, bindings for web components shadow DOM
-    // do not get uninstalled.
-    if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
-      nsContentUtils::AddScriptRunner(new RemoveFromBindingManagerRunnable(
-          document->BindingManager(), this, document));
-    }
-  }
-#endif
 
   nsExtendedContentSlots* slots = GetExistingExtendedContentSlots();
   if (slots) {
     slots->mBindingParent = nullptr;
     if (aNullParent || !mParent->IsInShadowTree()) {
       slots->mContainingShadow = nullptr;
     }
   }
diff --git a/dom/base/CharacterData.h b/dom/base/CharacterData.h
--- a/dom/base/CharacterData.h
+++ b/dom/base/CharacterData.h
@@ -164,19 +164,16 @@ class CharacterData : public nsIContent 
   void SaveSubtreeState() final {}
 
 #ifdef DEBUG
   void List(FILE* out, int32_t aIndent) const override {}
 
   void DumpContent(FILE* out, int32_t aIndent, bool aDumpAll) const override {}
 #endif
 
-#ifdef MOZ_XBL
-  nsXBLBinding* DoGetXBLBinding() const final { return nullptr; }
-#endif
 
   bool IsNodeOfType(uint32_t aFlags) const override { return false; }
 
   bool IsLink(nsIURI** aURI) const final {
     *aURI = nullptr;
     return false;
   }
 
diff --git a/dom/base/ChildIterator.cpp b/dom/base/ChildIterator.cpp
--- a/dom/base/ChildIterator.cpp
+++ b/dom/base/ChildIterator.cpp
@@ -3,19 +3,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ChildIterator.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/HTMLSlotElement.h"
-#ifdef MOZ_XBL
-#  include "mozilla/dom/XBLChildrenElement.h"
-#endif
 #include "mozilla/dom/ShadowRoot.h"
 #include "nsIAnonymousContentCreator.h"
 #include "nsIFrame.h"
 #include "nsCSSAnonBoxes.h"
 
 namespace mozilla {
 namespace dom {
 
@@ -43,27 +40,17 @@ nsIContent* ExplicitChildIterator::GetNe
                    ? assignedNodes[mIndexInInserted++]->AsContent()
                    : nullptr;
       if (!mChild) {
         mIndexInInserted = 0;
       }
       return mChild;
     }
 
-#ifdef MOZ_XBL
-    MOZ_ASSERT(mChild->IsActiveChildrenElement());
-    auto* childrenElement = static_cast<XBLChildrenElement*>(mChild);
-    if (mIndexInInserted < childrenElement->InsertedChildrenLength()) {
-      return childrenElement->InsertedChild(mIndexInInserted++);
-    }
-    mIndexInInserted = 0;
-    mChild = mChild->GetNextSibling();
-#else
     MOZ_ASSERT_UNREACHABLE("This needs to be revisited");
-#endif
   } else if (mDefaultChild) {
     // If we're already in default content, check if there are more nodes there
     MOZ_ASSERT(mChild);
     MOZ_ASSERT(mChild->IsActiveChildrenElement());
 
     mDefaultChild = mDefaultChild->GetNextSibling();
     if (mDefaultChild) {
       return mDefaultChild;
@@ -89,40 +76,17 @@ nsIContent* ExplicitChildIterator::GetNe
   } else if (mChild) {  // in the middle of the child list
     mChild = mChild->GetNextSibling();
   }
 
   // Iterate until we find a non-insertion point, or an insertion point with
   // content.
   while (mChild) {
     if (mChild->IsActiveChildrenElement()) {
-#ifdef MOZ_XBL
-      // If the current child being iterated is a content insertion point
-      // then the iterator needs to return the nodes distributed into
-      // the content insertion point.
-      auto* childrenElement = static_cast<XBLChildrenElement*>(mChild);
-      if (childrenElement->HasInsertedChildren()) {
-        // Iterate through elements projected on insertion point.
-        mIndexInInserted = 1;
-        return childrenElement->InsertedChild(0);
-      }
-
-      // Insertion points inside fallback/default content
-      // are considered inactive and do not get assigned nodes.
-      mDefaultChild = mChild->GetFirstChild();
-      if (mDefaultChild) {
-        return mDefaultChild;
-      }
-
-      // If we have an insertion point with no assigned nodes and
-      // no default content, move on to the next node.
-      mChild = mChild->GetNextSibling();
-#else
       MOZ_ASSERT_UNREACHABLE("This needs to be revisited");
-#endif
     } else {
       // mChild is not an insertion point, thus it is the next node to
       // return from this iterator.
       break;
     }
   }
 
   return mChild;
@@ -139,26 +103,16 @@ void FlattenedChildIterator::Init(bool a
   if (mParent->IsElement()) {
     if (ShadowRoot* shadow = mParent->AsElement()->GetShadowRoot()) {
       mParent = shadow;
       mXBLInvolved = Some(true);
       return;
     }
   }
 
-#ifdef MOZ_XBL
-  nsXBLBinding* binding =
-      mParent->OwnerDoc()->BindingManager()->GetBindingWithContent(mParent);
-
-  if (binding) {
-    MOZ_ASSERT(binding->GetAnonymousContent());
-    mParent = binding->GetAnonymousContent();
-    mXBLInvolved = Some(true);
-  }
-#endif
 }
 
 bool FlattenedChildIterator::ComputeWhetherXBLIsInvolved() const {
   MOZ_ASSERT(mXBLInvolved.isNothing());
   // We set mXBLInvolved to true if either the node we're iterating has a
   // binding with content attached to it (in which case it is handled in Init),
   // the node is generated XBL content and has an <xbl:children> child, or the
   // node is a <slot> element.
@@ -206,23 +160,17 @@ nsIContent* ExplicitChildIterator::Get()
 
   // When mParentAsSlot is set, mChild is always set to the current child. It
   // does not matter whether mChild is an assigned node or a fallback content.
   if (mParentAsSlot) {
     return mChild;
   }
 
   if (mIndexInInserted) {
-#ifdef MOZ_XBL
-    MOZ_ASSERT(mChild->IsActiveChildrenElement());
-    auto* childrenElement = static_cast<XBLChildrenElement*>(mChild);
-    return childrenElement->InsertedChild(mIndexInInserted - 1);
-#else
     MOZ_ASSERT_UNREACHABLE("This needs to be revisited");
-#endif
   }
 
   return mDefaultChild ? mDefaultChild : mChild;
 }
 
 nsIContent* ExplicitChildIterator::GetPreviousChild() {
   // If we're already in the inserted-children array, look there first
   if (mIndexInInserted) {
@@ -235,28 +183,17 @@ nsIContent* ExplicitChildIterator::GetPr
                    : nullptr;
 
       if (!mChild) {
         mIsFirst = true;
       }
       return mChild;
     }
 
-#ifdef MOZ_XBL
-    // NB: mIndexInInserted points one past the last returned child so we need
-    // to look *two* indices back in order to return the previous child.
-    MOZ_ASSERT(mChild->IsActiveChildrenElement());
-    auto* childrenElement = static_cast<XBLChildrenElement*>(mChild);
-    if (--mIndexInInserted) {
-      return childrenElement->InsertedChild(mIndexInInserted - 1);
-    }
-    mChild = mChild->GetPreviousSibling();
-#else
     MOZ_ASSERT_UNREACHABLE("This needs to be revisited");
-#endif
   } else if (mDefaultChild) {
     // If we're already in default content, check if there are more nodes there
     mDefaultChild = mDefaultChild->GetPreviousSibling();
     if (mDefaultChild) {
       return mDefaultChild;
     }
 
     mChild = mChild->GetPreviousSibling();
@@ -279,35 +216,17 @@ nsIContent* ExplicitChildIterator::GetPr
 
     mChild = mParent->GetLastChild();
   }
 
   // Iterate until we find a non-insertion point, or an insertion point with
   // content.
   while (mChild) {
     if (mChild->IsActiveChildrenElement()) {
-#ifdef MOZ_XBL
-      // If the current child being iterated is a content insertion point
-      // then the iterator needs to return the nodes distributed into
-      // the content insertion point.
-      auto* childrenElement = static_cast<XBLChildrenElement*>(mChild);
-      if (childrenElement->HasInsertedChildren()) {
-        mIndexInInserted = childrenElement->InsertedChildrenLength();
-        return childrenElement->InsertedChild(mIndexInInserted - 1);
-      }
-
-      mDefaultChild = mChild->GetLastChild();
-      if (mDefaultChild) {
-        return mDefaultChild;
-      }
-
-      mChild = mChild->GetPreviousSibling();
-#else
       MOZ_ASSERT_UNREACHABLE("This needs to be revisited");
-#endif
     } else {
       // mChild is not an insertion point, thus it is the next node to
       // return from this iterator.
       break;
     }
   }
 
   if (!mChild) {
diff --git a/dom/base/Document.cpp b/dom/base/Document.cpp
--- a/dom/base/Document.cpp
+++ b/dom/base/Document.cpp
@@ -174,19 +174,16 @@
 #include "nsICookiePermission.h"
 #include "nsICookieService.h"
 
 #include "nsBidiUtils.h"
 
 #include "nsContentCreatorFunctions.h"
 
 #include "nsIScriptContext.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsHTMLDocument.h"
 #include "nsIRequest.h"
 #include "mozilla/dom/BlobURLProtocolHandler.h"
 
 #include "nsCharsetSource.h"
 #include "nsIParser.h"
 #include "nsIContentSink.h"
 
@@ -1943,24 +1940,16 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   } else {
     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(Document, tmp->mRefCnt.get())
   }
 
   if (!nsINode::Traverse(tmp, cb)) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
-#ifdef MOZ_XBL
-  if (tmp->mMaybeEndOutermostXBLUpdateRunner) {
-    // The cached runnable keeps a reference to the document object..
-    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(
-        cb, "mMaybeEndOutermostXBLUpdateRunner.mObj");
-    cb.NoteXPCOMChild(ToSupports(tmp));
-  }
-#endif
 
   tmp->mExternalResourceMap.Traverse(&cb);
 
   // Traverse all Document pointer members.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSecurityInfo)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDisplayDocument)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFontFaceSet)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mReadyForIdle)
@@ -2080,19 +2069,16 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Do
     tmp->DisconnectChild(child);
     child->UnbindFromTree();
   }
 
   tmp->UnlinkOriginalDocumentIfStatic();
 
   tmp->mCachedRootElement = nullptr;  // Avoid a dangling pointer
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mDisplayDocument)
-#ifdef MOZ_XBL
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mMaybeEndOutermostXBLUpdateRunner)
-#endif
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mDOMImplementation)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mImageMaps)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mCachedEncoder)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mDocumentTimeline)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPendingAnimationTracker)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mTemplateContentsOwner)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mChildrenCollection)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mImages);
@@ -5908,32 +5894,16 @@ void Document::TryChannelCharset(nsIChan
 static inline void AssertNoStaleServoDataIn(nsINode& aSubtreeRoot) {
 #ifdef DEBUG
   for (nsINode* node : ShadowIncludingTreeIterator(aSubtreeRoot)) {
     const Element* element = Element::FromNode(node);
     if (!element) {
       continue;
     }
     MOZ_ASSERT(!element->HasServoData());
-#  ifdef MOZ_XBL
-    if (nsXBLBinding* binding = element->GetXBLBinding()) {
-      if (nsXBLBinding* bindingWithContent = binding->GetBindingWithContent()) {
-        nsIContent* content = bindingWithContent->GetAnonymousContent();
-        // Need to do this instead of just AssertNoStaleServoDataIn(*content),
-        // because the parent of the children of the <content> element isn't the
-        // <content> element, but the bound element, and that confuses
-        // GetNextNode a lot.
-        MOZ_ASSERT(!content->AsElement()->HasServoData());
-        for (nsINode* child = content->GetFirstChild(); child;
-             child = child->GetNextSibling()) {
-          AssertNoStaleServoDataIn(*child);
-        }
-      }
-    }
-#  endif
   }
 #endif
 }
 
 already_AddRefed<PresShell> Document::CreatePresShell(
     nsPresContext* aContext, nsViewManager* aViewManager) {
   MOZ_ASSERT(!mPresShell, "We have a presshell already!");
 
@@ -6919,75 +6889,45 @@ bool Document::RemoveObserver(nsIDocumen
   if (!mInDestructor) {
     RemoveMutationObserver(aObserver);
     return mObservers.RemoveElement(aObserver);
   }
 
   return mObservers.Contains(aObserver);
 }
 
-#ifdef MOZ_XBL
-void Document::MaybeEndOutermostXBLUpdate() {
-  // Only call BindingManager()->EndOutermostUpdate() when
-  // we're not in an update and it is safe to run scripts.
-  if (mUpdateNestLevel == 0 && mInXBLUpdate) {
-    if (nsContentUtils::IsSafeToRunScript()) {
-      mInXBLUpdate = false;
-      BindingManager()->EndOutermostUpdate();
-    } else if (!mInDestructor) {
-      if (!mMaybeEndOutermostXBLUpdateRunner) {
-        mMaybeEndOutermostXBLUpdateRunner =
-            NewRunnableMethod("Document::MaybeEndOutermostXBLUpdate", this,
-                              &Document::MaybeEndOutermostXBLUpdate);
-      }
-      nsContentUtils::AddScriptRunner(mMaybeEndOutermostXBLUpdateRunner);
-    }
-  }
-}
-#endif
 
 void Document::BeginUpdate() {
   // If the document is going away, then it's probably okay to do things to it
   // in the wrong DocGroup. We're unlikely to run JS or do anything else
   // observable at this point. We reach this point when cycle collecting a
   // <link> element and the unlink code removes a style sheet.
   //
   // TODO(emilio): Style updates are gone, can this happen now?
   if (mDocGroup && !mIsGoingAway && !mInUnlinkOrDeletion &&
       !mIgnoreDocGroupMismatches) {
     mDocGroup->ValidateAccess();
   }
 
-#ifdef MOZ_XBL
-  if (mUpdateNestLevel == 0 && !mInXBLUpdate) {
-    mInXBLUpdate = true;
-    BindingManager()->BeginOutermostUpdate();
-  }
-#endif
 
   ++mUpdateNestLevel;
   nsContentUtils::AddScriptBlocker();
   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginUpdate, (this));
 }
 
 void Document::EndUpdate() {
   const bool reset = !mPendingMaybeEditingStateChanged;
   mPendingMaybeEditingStateChanged = true;
 
   NS_DOCUMENT_NOTIFY_OBSERVERS(EndUpdate, (this));
 
   nsContentUtils::RemoveScriptBlocker();
 
   --mUpdateNestLevel;
 
-#ifdef MOZ_XBL
-  // This set of updates may have created XBL bindings.  Let the
-  // binding manager know we're done.
-  MaybeEndOutermostXBLUpdate();
-#endif
 
   MaybeInitializeFinalizeFrameLoaders();
   if (mXULBroadcastManager) {
     mXULBroadcastManager->MaybeBroadcast();
   }
 
   if (reset) {
     mPendingMaybeEditingStateChanged = false;
@@ -7869,87 +7809,31 @@ already_AddRefed<nsINode> Document::Impo
 Element* Document::GetBindingParent(nsINode& aNode) {
   nsCOMPtr<nsIContent> content(do_QueryInterface(&aNode));
   if (!content) return nullptr;
 
   nsIContent* bindingParent = content->GetBindingParent();
   return bindingParent ? bindingParent->AsElement() : nullptr;
 }
 
-#ifdef MOZ_XBL
-static Element* GetElementByAttribute(Element* aElement, nsAtom* aAttrName,
-                                      const nsAString& aAttrValue,
-                                      bool aUniversalMatch) {
-  if (aUniversalMatch ? aElement->HasAttr(kNameSpaceID_None, aAttrName)
-                      : aElement->AttrValueIs(kNameSpaceID_None, aAttrName,
-                                              aAttrValue, eCaseMatters)) {
-    return aElement;
-  }
-
-  for (nsIContent* child = aElement->GetFirstChild(); child;
-       child = child->GetNextSibling()) {
-    if (!child->IsElement()) {
-      continue;
-    }
-
-    Element* matchedElement = GetElementByAttribute(
-        child->AsElement(), aAttrName, aAttrValue, aUniversalMatch);
-    if (matchedElement) return matchedElement;
-  }
-
-  return nullptr;
-}
-#endif
 
 Element* Document::GetAnonymousElementByAttribute(
     nsIContent* aElement, nsAtom* aAttrName,
     const nsAString& aAttrValue) const {
-#ifdef MOZ_XBL
-  nsINodeList* nodeList = BindingManager()->GetAnonymousNodesFor(aElement);
-  if (!nodeList) return nullptr;
-
-  uint32_t length = nodeList->Length();
-
-  bool universalMatch = aAttrValue.EqualsLiteral("*");
-
-  for (uint32_t i = 0; i < length; ++i) {
-    Element* current = Element::FromNode(nodeList->Item(i));
-    if (!current) {
-      continue;
-    }
-
-    Element* matchedElm =
-        GetElementByAttribute(current, aAttrName, aAttrValue, universalMatch);
-    if (matchedElm) return matchedElm;
-  }
-
   return nullptr;
-#else
-  return nullptr;
-#endif
 }
 
 Element* Document::GetAnonymousElementByAttribute(Element& aElement,
                                                   const nsAString& aAttrName,
                                                   const nsAString& aAttrValue) {
-#ifdef MOZ_XBL
-  RefPtr<nsAtom> attribute = NS_Atomize(aAttrName);
-
-  return GetAnonymousElementByAttribute(&aElement, attribute, aAttrValue);
-#else
   return nullptr;
-#endif
 }
 
 nsINodeList* Document::GetAnonymousNodes(Element& aElement) {
-#ifdef MOZ_XBL
-  return BindingManager()->GetAnonymousNodesFor(&aElement);
-#else
   return nullptr;
-#endif
 }
 
 already_AddRefed<nsRange> Document::CreateRange(ErrorResult& rv) {
   RefPtr<nsRange> range = new nsRange(this);
   nsresult res = range->CollapseTo(this, 0);
   if (NS_FAILED(res)) {
     rv.Throw(res);
     return nullptr;
@@ -9298,25 +9182,16 @@ nsINode* Document::AdoptNode(nsINode& aA
 
       // Remove from parent.
       nsCOMPtr<nsINode> parent = adoptedNode->GetParentNode();
       if (parent) {
         parent->RemoveChildNode(adoptedNode->AsContent(), true);
       } else {
         MOZ_ASSERT(!adoptedNode->IsInUncomposedDoc());
 
-#ifdef MOZ_XBL
-        // If we're adopting a node that's not in a document, it might still
-        // have a binding applied. Remove the binding from the element now
-        // that it's getting adopted into a new document.
-        // TODO Fully tear down the binding.
-        if (Element* element = Element::FromNode(adoptedNode)) {
-          element->SetXBLBinding(nullptr);
-        }
-#endif
       }
 
       break;
     }
     case DOCUMENT_NODE: {
       rv.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
       return nullptr;
     }
@@ -14194,24 +14069,16 @@ void Document::AddSizeOfNodeTree(nsINode
       AddSizeOfNodeTree(*anonKid, aWindowSizes);
     }
 
     if (auto* element = Element::FromNode(aNode)) {
       if (ShadowRoot* shadow = element->GetShadowRoot()) {
         AddSizeOfNodeTree(*shadow, aWindowSizes);
       }
 
-#ifdef MOZ_XBL
-      for (nsXBLBinding* binding = element->GetXBLBinding(); binding;
-           binding = binding->GetBaseBinding()) {
-        if (nsIContent* anonContent = binding->GetAnonymousContent()) {
-          AddSizeOfNodeTree(*anonContent, aWindowSizes);
-        }
-      }
-#endif
     }
   }
 
   // NOTE(emilio): If you feel smart and want to change this function to use
   // GetNextNode(), think twice, since you'd need to handle <xbl:content> in a
   // sane way, and kids of <content> won't point to the parent, so we'd never
   // find the root node where we should stop at.
   for (nsIContent* kid = aNode.GetFirstChild(); kid;
diff --git a/dom/base/Document.h b/dom/base/Document.h
--- a/dom/base/Document.h
+++ b/dom/base/Document.h
@@ -80,19 +80,16 @@ namespace mozilla {
 namespace dom {
 class ElementCreationOptionsOrString;
 }  // namespace dom
 }  // namespace mozilla
 #endif  // MOZILLA_INTERNAL_API
 
 class gfxUserFontSet;
 class imgIRequest;
-#ifdef MOZ_XBL
-class nsBindingManager;
-#endif
 class nsCachableElementsByNameNodeList;
 class nsCommandManager;
 class nsContentList;
 class nsIDocShell;
 class nsDocShell;
 class nsDOMNavigationTiming;
 class nsFrameLoader;
 class nsGlobalWindowInner;
@@ -1808,19 +1805,16 @@ class Document : public nsINode,
   nsresult InitFeaturePolicy(nsIChannel* aChannel);
 
   nsresult InitReferrerInfo(nsIChannel* aChannel);
 
   void PostUnblockOnloadEvent();
 
   void DoUnblockOnload();
 
-#ifdef MOZ_XBL
-  void MaybeEndOutermostXBLUpdate();
-#endif
 
   void RetrieveRelevantHeaders(nsIChannel* aChannel);
 
   void TryChannelCharset(nsIChannel* aChannel, int32_t& aCharsetSource,
                          NotNull<const Encoding*>& aEncoding,
                          nsHtml5TreeOpExecutor* aExecutor);
 
   void DispatchContentLoadedEvents();
@@ -2389,21 +2383,16 @@ class Document : public nsINode,
   // Triggers an update of <svg:use> element shadow trees.
   void UpdateSVGUseElementShadowTrees() {
     if (mSVGUseElementsNeedingShadowTreeUpdate.IsEmpty()) {
       return;
     }
     DoUpdateSVGUseElementShadowTrees();
   }
 
-#ifdef MOZ_XBL
-  nsBindingManager* BindingManager() const {
-    return mNodeInfoManager->GetBindingManager();
-  }
-#endif
 
   /**
    * Only to be used inside Gecko, you can't really do anything with the
    * pointer outside Gecko anyway.
    */
   nsNodeInfoManager* NodeInfoManager() const { return mNodeInfoManager; }
 
   /**
@@ -5289,19 +5278,16 @@ class Document : public nsINode,
 
   CSSCoord mMinWidth;
   CSSCoord mMaxWidth;
   CSSCoord mMinHeight;
   CSSCoord mMaxHeight;
 
   RefPtr<EventListenerManager> mListenerManager;
 
-#ifdef MOZ_XBL
-  nsCOMPtr<nsIRunnable> mMaybeEndOutermostXBLUpdateRunner;
-#endif
   nsCOMPtr<nsIRequest> mOnloadBlocker;
 
   nsTArray<RefPtr<StyleSheet>> mAdditionalSheets[AdditionalSheetTypeCount];
 
   // Member to store out last-selected stylesheet set.
   nsString mLastStyleSheetSet;
   nsString mPreferredStyleSheetSet;
 
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -89,22 +89,16 @@
 #  include "nsXULElement.h"
 #endif /* MOZ_XUL */
 #include "SVGElement.h"
 #include "nsFrameSelection.h"
 #ifdef DEBUG
 #  include "nsRange.h"
 #endif
 
-#ifdef MOZ_XBL
-#  include "nsXBLPrototypeBinding.h"
-#  include "nsBindingManager.h"
-#  include "nsXBLBinding.h"
-#  include "nsXBLService.h"
-#endif
 #include "nsPIDOMWindow.h"
 #include "mozilla/dom/DOMRect.h"
 #include "nsSVGUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsGkAtoms.h"
 #include "ChildIterator.h"
 
 #include "nsIDOMEventListener.h"
@@ -262,23 +256,17 @@ Element::QueryInterface(REFNSIID aIID, v
   }
 
   NS_ASSERTION(aInstancePtr, "QueryInterface requires a non-NULL destination!");
   nsresult rv = FragmentOrElement::QueryInterface(aIID, aInstancePtr);
   if (NS_SUCCEEDED(rv)) {
     return NS_OK;
   }
 
-#if MOZ_XBL
-  // Give the binding manager a chance to get an interface for this element.
-  return OwnerDoc()->BindingManager()->GetBindingImplementation(this, aIID,
-                                                                aInstancePtr);
-#else
   return NS_NOINTERFACE;
-#endif
 }
 
 EventStates Element::IntrinsicState() const {
   return IsEditable() ? NS_EVENT_STATE_MOZ_READWRITE
                       : NS_EVENT_STATE_MOZ_READONLY;
 }
 
 void Element::NotifyStateChange(EventStates aStates) {
@@ -377,57 +365,16 @@ void Element::Focus(const FocusOptions& 
 
 void Element::SetTabIndex(int32_t aTabIndex, mozilla::ErrorResult& aError) {
   nsAutoString value;
   value.AppendInt(aTabIndex);
 
   SetAttr(nsGkAtoms::tabindex, value, aError);
 }
 
-#ifdef MOZ_XBL
-void Element::SetXBLBinding(nsXBLBinding* aBinding,
-                            nsBindingManager* aOldBindingManager) {
-  nsBindingManager* bindingManager;
-  if (aOldBindingManager) {
-    MOZ_ASSERT(!aBinding,
-               "aOldBindingManager should only be provided "
-               "when removing a binding.");
-    bindingManager = aOldBindingManager;
-  } else {
-    bindingManager = OwnerDoc()->BindingManager();
-  }
-
-  // After this point, aBinding will be the most-derived binding for aContent.
-  // If we already have a binding for aContent, make sure to
-  // remove it from the attached stack.  Otherwise we might end up firing its
-  // constructor twice (if aBinding inherits from it) or firing its constructor
-  // after aContent has been deleted (if aBinding is null and the content node
-  // dies before we process mAttachedStack).
-  RefPtr<nsXBLBinding> oldBinding = GetXBLBinding();
-  if (oldBinding) {
-    bindingManager->RemoveFromAttachedQueue(oldBinding);
-  }
-
-  if (aBinding) {
-    SetFlags(NODE_MAY_BE_IN_BINDING_MNGR);
-    nsExtendedDOMSlots* slots = ExtendedDOMSlots();
-    slots->mXBLBinding = aBinding;
-    bindingManager->AddBoundContent(this);
-  } else {
-    nsExtendedDOMSlots* slots = GetExistingExtendedDOMSlots();
-    if (slots) {
-      slots->mXBLBinding = nullptr;
-    }
-    bindingManager->RemoveBoundContent(this);
-    if (oldBinding) {
-      oldBinding->SetBoundElement(nullptr);
-    }
-  }
-}
-#endif
 
 void Element::SetShadowRoot(ShadowRoot* aShadowRoot) {
   nsExtendedDOMSlots* slots = ExtendedDOMSlots();
   slots->mShadowRoot = aShadowRoot;
 }
 
 void Element::Blur(mozilla::ErrorResult& aError) {
   if (!ShouldBlur(this)) {
@@ -1061,19 +1008,16 @@ already_AddRefed<ShadowRoot> Element::At
     return nullptr;
   }
 
   /**
    * 3. If context object is a shadow host, then throw
    *    an "InvalidStateError" DOMException.
    */
   if (GetShadowRoot()
-#ifdef MOZ_XBL
-      || GetXBLBinding()
-#endif
   ) {
     aError.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
   if (StaticPrefs::dom_webcomponents_shadowdom_report_usage()) {
     OwnerDoc()->ReportShadowDOMUsage();
   }
@@ -1591,28 +1535,16 @@ nsresult Element::BindToTree(BindContext
   //  because it has to happen after updating the parent pointer, but before
   //  recursively binding the kids.
   if (IsHTMLElement()) {
     SetDirOnBind(this, nsIContent::FromNode(aParent));
   }
 
   UpdateEditableState(false);
 
-#ifdef MOZ_XBL
-  // If we had a pre-existing XBL binding, we might have anonymous children that
-  // also need to be told that they are moving.
-  if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
-    nsXBLBinding* binding =
-        aContext.OwnerDoc().BindingManager()->GetBindingWithContent(this);
-
-    if (binding) {
-      binding->BindAnonymousContent(binding->GetAnonymousContent(), this);
-    }
-  }
-#endif
 
   // Call BindToTree on shadow root children.
   nsresult rv;
   if (ShadowRoot* shadowRoot = GetShadowRoot()) {
     rv = shadowRoot->Bind();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
@@ -1684,43 +1616,16 @@ nsresult Element::BindToTree(BindContext
              "Bound to wrong binding parent");
   MOZ_ASSERT(aParent.IsInUncomposedDoc() == IsInUncomposedDoc());
   MOZ_ASSERT(aParent.IsInComposedDoc() == IsInComposedDoc());
   MOZ_ASSERT(aParent.IsInShadowTree() == IsInShadowTree());
   MOZ_ASSERT(aParent.SubtreeRoot() == SubtreeRoot());
   return NS_OK;
 }
 
-#ifdef MOZ_XBL
-RemoveFromBindingManagerRunnable::RemoveFromBindingManagerRunnable(
-    nsBindingManager* aManager, nsIContent* aContent, Document* aDoc)
-    : mozilla::Runnable("dom::RemoveFromBindingManagerRunnable"),
-      mManager(aManager),
-      mContent(aContent),
-      mDoc(aDoc) {}
-
-RemoveFromBindingManagerRunnable::~RemoveFromBindingManagerRunnable() {}
-
-NS_IMETHODIMP
-RemoveFromBindingManagerRunnable::Run() {
-  // It may be the case that the element was removed from the
-  // DOM, causing this runnable to be created, then inserted back
-  // into the document before the this runnable had a chance to
-  // tear down the binding. Only tear down the binding if the element
-  // is still no longer in the DOM. nsXBLService::LoadBinding tears
-  // down the old binding if the element is inserted back into the
-  // DOM and loads a different binding.
-  if (!mContent->IsInComposedDoc()) {
-    mManager->RemovedFromDocumentInternal(mContent, mDoc,
-                                          nsBindingManager::eRunDtor);
-  }
-
-  return NS_OK;
-}
-#endif
 
 bool WillDetachFromShadowOnUnbind(const Element& aElement, bool aNullParent) {
   // If our parent still is in a shadow tree by now, and we're not removing
   // ourselves from it, then we're still going to be in a shadow tree after
   // this.
   return aElement.IsInShadowTree() &&
          (aNullParent || !aElement.GetParent()->IsInShadowTree());
 }
@@ -1859,31 +1764,16 @@ void Element::UnbindFromTree(bool aNullP
       slots->mBindingParent = nullptr;
     }
     if (aNullParent || !mParent->IsInShadowTree()) {
       slots->mContainingShadow = nullptr;
     }
   }
 
   if (document) {
-#ifdef MOZ_XBL
-    if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
-      // Notify XBL- & nsIAnonymousContentCreator-generated anonymous content
-      // that the document is changing.
-      nsContentUtils::AddScriptRunner(new RemoveFromBindingManagerRunnable(
-          document->BindingManager(), this, document));
-      nsXBLBinding* binding =
-          document->BindingManager()->GetBindingWithContent(this);
-      if (binding) {
-        nsXBLBinding::UnbindAnonymousContent(document,
-                                             binding->GetAnonymousContent(),
-                                             /* aNullParent */ false);
-      }
-    }
-#endif
 
     // Disconnected must be enqueued whenever a connected custom element becomes
     // disconnected.
     CustomElementData* data = GetCustomElementData();
     if (data) {
       if (data->mState == CustomElementData::State::eCustom) {
         nsContentUtils::EnqueueLifecycleCallback(Document::eDisconnected, this);
       } else {
@@ -2400,24 +2290,16 @@ nsresult Element::SetAttrAndNotify(
       oldValue = nullptr;
     }
   } else {
     // No need to conditionally assign null here. If there was no previously
     // set value for the attribute, aOldValue will already be null.
     oldValue = aOldValue;
   }
 
-#ifdef MOZ_XBL
-  if (aComposedDocument) {
-    RefPtr<nsXBLBinding> binding = GetXBLBinding();
-    if (binding) {
-      binding->AttributeChanged(aName, aNamespaceID, false, aNotify);
-    }
-  }
-#endif
 
   if (HasElementCreatedFromPrototypeAndHasUnmodifiedL10n() &&
       aNamespaceID == kNameSpaceID_None &&
       (aName == nsGkAtoms::datal10nid || aName == nsGkAtoms::datal10nargs)) {
     ClearElementCreatedFromPrototypeAndHasUnmodifiedL10n();
     if (aComposedDocument) {
       aComposedDocument->mL10nProtoElements.Remove(this);
     }
@@ -2712,24 +2594,16 @@ nsresult Element::UnsetAttr(int32_t aNam
   }
 
   nsAttrValue oldValue;
   rv = mAttrs.RemoveAttrAt(index, oldValue);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PostIdMaybeChange(aNameSpaceID, aName, nullptr);
 
-#ifdef MOZ_XBL
-  if (document) {
-    RefPtr<nsXBLBinding> binding = GetXBLBinding();
-    if (binding) {
-      binding->AttributeChanged(aName, aNameSpaceID, true, aNotify);
-    }
-  }
-#endif
 
   CustomElementDefinition* definition = GetCustomElementDefinition();
   // Only custom element which is in `custom` state could get the
   // CustomElementDefinition.
   if (definition && definition->IsInObservedAttributeList(aName)) {
     nsAutoString ns;
     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
 
@@ -2841,62 +2715,16 @@ void Element::List(FILE* out, int32_t aI
       child->List(out, aIndent + 1);
     }
 
     for (indent = aIndent; --indent >= 0;) fputs("  ", out);
   }
 
   fputs(">\n", out);
 
-#  ifdef MOZ_XBL
-  Element* nonConstThis = const_cast<Element*>(this);
-
-  // XXX sXBL/XBL2 issue! Owner or current document?
-  Document* document = OwnerDoc();
-
-  // Note: not listing nsIAnonymousContentCreator-created content...
-
-  nsBindingManager* bindingManager = document->BindingManager();
-  nsINodeList* anonymousChildren =
-      bindingManager->GetAnonymousNodesFor(nonConstThis);
-
-  if (anonymousChildren) {
-    uint32_t length = anonymousChildren->Length();
-
-    for (indent = aIndent; --indent >= 0;) fputs("  ", out);
-    fputs("anonymous-children<\n", out);
-
-    for (uint32_t i = 0; i < length; ++i) {
-      nsIContent* child = anonymousChildren->Item(i);
-      child->List(out, aIndent + 1);
-    }
-
-    for (indent = aIndent; --indent >= 0;) fputs("  ", out);
-    fputs(">\n", out);
-
-    bool outHeader = false;
-    ExplicitChildIterator iter(nonConstThis);
-    for (nsIContent* child = iter.GetNextChild(); child;
-         child = iter.GetNextChild()) {
-      if (!outHeader) {
-        outHeader = true;
-
-        for (indent = aIndent; --indent >= 0;) fputs("  ", out);
-        fputs("content-list<\n", out);
-      }
-
-      child->List(out, aIndent + 1);
-    }
-
-    if (outHeader) {
-      for (indent = aIndent; --indent >= 0;) fputs("  ", out);
-      fputs(">\n", out);
-    }
-  }
-#  endif
 }
 
 void Element::DumpContent(FILE* out, int32_t aIndent, bool aDumpAll) const {
   int32_t indent;
   for (indent = aIndent; --indent >= 0;) fputs("  ", out);
 
   const nsString& buf = mNodeInfo->QualifiedName();
   fputs("<", out);
@@ -3907,22 +3735,16 @@ void Element::GetCustomInterface(nsGette
   nsCOMPtr<nsISupports> iface = CustomElementRegistry::CallGetCustomInterface(
       this, NS_GET_TEMPLATE_IID(T));
   if (iface) {
     if (NS_SUCCEEDED(CallQueryInterface(iface, static_cast<T**>(aResult)))) {
       return;
     }
   }
 
-#ifdef MOZ_XBL
-  // Otherwise, check the binding manager to see if it implements the interface
-  // for this element.
-  OwnerDoc()->BindingManager()->GetBindingImplementation(
-      this, NS_GET_TEMPLATE_IID(T), aResult);
-#endif
 }
 
 void Element::ClearServoData(Document* aDoc) {
   MOZ_ASSERT(aDoc);
   if (HasServoData()) {
     Servo_Element_ClearData(this);
   } else {
     UnsetFlags(kAllServoDescendantBits | NODE_NEEDS_FRAME);
diff --git a/dom/base/Element.h b/dom/base/Element.h
--- a/dom/base/Element.h
+++ b/dom/base/Element.h
@@ -220,33 +220,16 @@ class Element : public FragmentOrElement
    */
   int32_t TabIndex();
 
   /**
    * Set tabIndex value to this element.
    */
   void SetTabIndex(int32_t aTabIndex, mozilla::ErrorResult& aError);
 
-#ifdef MOZ_XBL
-  /**
-   * Sets or unsets an XBL binding for this element. Setting a
-   * binding on an element that already has a binding will remove the
-   * old binding.
-   *
-   * @param aBinding The binding to bind to this content. If nullptr is
-   *        provided as the argument, then existing binding will be
-   *        removed.
-   *
-   * @param aOldBindingManager The old binding manager that contains
-   *                           this content if this content was adopted
-   *                           to another document.
-   */
-  void SetXBLBinding(nsXBLBinding* aBinding,
-                     nsBindingManager* aOldBindingManager = nullptr);
-#endif
 
   /**
    * Sets the ShadowRoot binding for this element. The contents of the
    * binding is rendered in place of this node's children.
    *
    * @param aShadowRoot The ShadowRoot to be bound to this element.
    */
   void SetShadowRoot(ShadowRoot* aShadowRoot);
@@ -1971,31 +1954,16 @@ class Element : public FragmentOrElement
   // descendants of display: none elements.
   mozilla::RustCell<ServoNodeData*> mServoData;
 
  protected:
   // Array containing all attributes for this element
   AttrArray mAttrs;
 };
 
-#ifdef MOZ_XBL
-class RemoveFromBindingManagerRunnable : public mozilla::Runnable {
- public:
-  RemoveFromBindingManagerRunnable(nsBindingManager* aManager,
-                                   nsIContent* aContent, Document* aDoc);
-
-  NS_IMETHOD Run() override;
-
- private:
-  virtual ~RemoveFromBindingManagerRunnable();
-  RefPtr<nsBindingManager> mManager;
-  RefPtr<nsIContent> mContent;
-  RefPtr<Document> mDoc;
-};
-#endif
 
 NS_DEFINE_STATIC_IID_ACCESSOR(Element, NS_ELEMENT_IID)
 
 inline bool Element::HasAttr(int32_t aNameSpaceID, const nsAtom* aName) const {
   NS_ASSERTION(nullptr != aName, "must have attribute name");
   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
                "must have a real namespace ID!");
 
diff --git a/dom/base/FragmentOrElement.cpp b/dom/base/FragmentOrElement.cpp
--- a/dom/base/FragmentOrElement.cpp
+++ b/dom/base/FragmentOrElement.cpp
@@ -65,21 +65,16 @@
 #  include "nsXULElement.h"
 #endif /* MOZ_XUL */
 #include "nsFrameSelection.h"
 #ifdef DEBUG
 #  include "nsRange.h"
 #endif
 
 #include "nsFrameLoader.h"
-#ifdef MOZ_XBL
-#  include "nsXBLPrototypeBinding.h"
-#  include "nsBindingManager.h"
-#  include "nsXBLBinding.h"
-#endif
 #include "nsPIDOMWindow.h"
 #include "nsSVGUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsGkAtoms.h"
 #include "nsContentUtils.h"
 #include "nsTextFragment.h"
 #include "nsContentCID.h"
 #include "nsWindowSizes.h"
@@ -680,21 +675,16 @@ void FragmentOrElement::nsExtendedDOMSlo
   aCb.NoteXPCOMChild(mControllers);
 
   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(aCb, "mExtendedSlots->mLabelsList");
   aCb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsINodeList*, mLabelsList));
 
   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(aCb, "mExtendedSlots->mShadowRoot");
   aCb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIContent*, mShadowRoot));
 
-#ifdef MOZ_XBL
-  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(aCb, "mExtendedSlots->mXBLBinding");
-  aCb.NoteNativeChild(mXBLBinding,
-                      NS_CYCLE_COLLECTION_PARTICIPANT(nsXBLBinding));
-#endif
 
   if (mCustomElementData) {
     mCustomElementData->Traverse(aCb);
   }
 }
 
 size_t FragmentOrElement::nsExtendedDOMSlots::SizeOfExcludingThis(
     MallocSizeOf aMallocSizeOf) const {
@@ -719,23 +709,16 @@ size_t FragmentOrElement::nsExtendedDOMS
 
   if (mLabelsList) {
     n += mLabelsList->SizeOfIncludingThis(aMallocSizeOf);
   }
 
   // mShadowRoot should be handled during normal DOM tree memory reporting, just
   // like kids, siblings, etc.
 
-#ifdef MOZ_XBL
-  // We don't seem to have memory reporting for nsXBLBinding.  At least
-  // report the memory it's using directly.
-  if (mXBLBinding) {
-    n += aMallocSizeOf(mXBLBinding);
-  }
-#endif
 
   if (mCustomElementData) {
     n += mCustomElementData->SizeOfIncludingThis(aMallocSizeOf);
   }
 
   return n;
 }
 
@@ -1087,23 +1070,16 @@ bool nsIContent::IsFocusableInternal(int
   return false;
 }
 
 bool FragmentOrElement::IsLink(nsIURI** aURI) const {
   *aURI = nullptr;
   return false;
 }
 
-#ifdef MOZ_XBL
-nsXBLBinding* FragmentOrElement::DoGetXBLBinding() const {
-  MOZ_ASSERT(HasFlag(NODE_MAY_BE_IN_BINDING_MNGR));
-  const nsExtendedDOMSlots* slots = GetExistingExtendedDOMSlots();
-  return slots ? slots->mXBLBinding.get() : nullptr;
-}
-#endif
 
 nsIContent* nsIContent::GetContainingShadowHost() const {
   if (mozilla::dom::ShadowRoot* shadow = GetContainingShadow()) {
     return shadow->GetHost();
   }
   return nullptr;
 }
 
@@ -1165,21 +1141,16 @@ void FragmentOrElement::DestroyContent()
   // around the flattened tree.
   //
   // TODO(emilio): I suspect this can be asserted against instead, with a bit of
   // effort to avoid calling Document::Destroy with a shell...
   if (IsElement()) {
     AsElement()->ClearServoData();
   }
 
-#ifdef MOZ_XBL
-  Document* document = OwnerDoc();
-  document->BindingManager()->RemovedFromDocument(this, document,
-                                                  nsBindingManager::eRunDtor);
-#endif
 
 #ifdef DEBUG
   uint32_t oldChildCount = GetChildCount();
 #endif
 
   for (nsIContent* child = GetFirstChild(); child;
        child = child->GetNextSibling()) {
     child->DestroyContent();
@@ -1376,21 +1347,16 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Fr
     unbind the child nodes.
   } */
 
   if (ShadowRoot* shadowRoot = tmp->GetShadowRoot()) {
     shadowRoot->Unbind();
     tmp->ExtendedDOMSlots()->mShadowRoot = nullptr;
   }
 
-#ifdef MOZ_XBL
-  Document* doc = tmp->OwnerDoc();
-  doc->BindingManager()->RemovedFromDocument(tmp, doc,
-                                             nsBindingManager::eDoNotRunDtor);
-#endif
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE(FragmentOrElement)
 
 void FragmentOrElement::MarkNodeChildren(nsINode* aNode) {
   JSObject* o = GetJSObjectChild(aNode);
   if (o) {
@@ -1606,21 +1572,16 @@ static bool ShouldClearPurple(nsIContent
 // with a frame in a document which has currently active presshell,
 // we can act as if it was optimizable. When the primary frame dies, aNode
 // will end up to the purple buffer because of the refcount change.
 bool NodeHasActiveFrame(Document* aCurrentDoc, nsINode* aNode) {
   return aCurrentDoc->GetPresShell() && aNode->IsElement() &&
          aNode->AsElement()->GetPrimaryFrame();
 }
 
-#ifdef MOZ_XBL
-bool OwnedByBindingManager(Document* aCurrentDoc, nsINode* aNode) {
-  return aNode->IsElement() && aNode->AsElement()->GetXBLBinding();
-}
-#endif
 
 // CanSkip checks if aNode is known-live, and if it is, returns true. If aNode
 // is in a known-live DOM tree, CanSkip may also remove other objects from
 // purple buffer and unmark event listeners and user data.  If the root of the
 // DOM tree is a document, less optimizations are done since checking the
 // liveness of the current document is usually fast and we don't want slow down
 // such common cases.
 bool FragmentOrElement::CanSkip(nsINode* aNode, bool aRemovingAllowed) {
@@ -1628,19 +1589,16 @@ bool FragmentOrElement::CanSkip(nsINode*
   if (nsCCUncollectableMarker::sGeneration == 0) {
     return false;
   }
 
   bool unoptimizable = aNode->UnoptimizableCCNode();
   Document* currentDoc = aNode->GetComposedDoc();
   if (currentDoc && IsCertainlyAliveNode(aNode, currentDoc) &&
       (!unoptimizable || NodeHasActiveFrame(currentDoc, aNode)
-#ifdef MOZ_XBL
-       || OwnedByBindingManager(currentDoc, aNode)
-#endif
            )) {
     MarkNodeChildren(aNode);
     return true;
   }
 
   if (unoptimizable) {
     return false;
   }
@@ -1834,19 +1792,16 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   } else {
     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(FragmentOrElement, tmp->mRefCnt.get())
   }
 
   if (!nsIContent::Traverse(tmp, cb)) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
-#ifdef MOZ_XBL
-  tmp->OwnerDoc()->BindingManager()->Traverse(tmp, cb);
-#endif
 
   // Check that whenever we have effect properties, MayHaveAnimations is set.
 #ifdef DEBUG
   nsAtom** effectProps = EffectSet::GetEffectSetPropertyAtoms();
   for (uint32_t i = 0; effectProps[i]; ++i) {
     MOZ_ASSERT_IF(tmp->GetProperty(effectProps[i]), tmp->MayHaveAnimations());
   }
 #endif
diff --git a/dom/base/FragmentOrElement.h b/dom/base/FragmentOrElement.h
--- a/dom/base/FragmentOrElement.h
+++ b/dom/base/FragmentOrElement.h
@@ -16,19 +16,16 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/UniquePtr.h"
 #include "nsCycleCollectionParticipant.h"  // NS_DECL_CYCLE_*
 #include "nsIContent.h"                    // base class
 #include "nsNodeUtils.h"  // class member nsNodeUtils::CloneNodeImpl
 #include "nsIHTMLCollection.h"
 #include "nsDataHashtable.h"
-#ifdef MOZ_XBL
-#  include "nsXBLBinding.h"
-#endif
 
 class ContentUnbinder;
 class nsContentList;
 class nsLabelsNodeList;
 class nsDOMAttributeMap;
 class nsDOMTokenList;
 class nsIControllers;
 class nsICSSDeclaration;
@@ -97,19 +94,16 @@ class FragmentOrElement : public nsICont
                                       mozilla::ErrorResult& aError) override;
 
   // nsIContent interface methods
   virtual already_AddRefed<nsINodeList> GetChildren(uint32_t aFilter) override;
   virtual const nsTextFragment* GetText() override;
   virtual uint32_t TextLength() const override;
   virtual bool TextIsOnlyWhitespace() override;
   virtual bool ThreadSafeTextIsOnlyWhitespace() const override;
-#ifdef MOZ_XBL
-  virtual nsXBLBinding* DoGetXBLBinding() const override;
-#endif
   virtual bool IsLink(nsIURI** aURI) const override;
 
   virtual void DestroyContent() override;
   virtual void SaveSubtreeState() override;
 
   nsIHTMLCollection* Children();
   uint32_t ChildElementCount() { return Children()->Length(); }
 
@@ -192,22 +186,16 @@ class FragmentOrElement : public nsICont
      */
     RefPtr<nsLabelsNodeList> mLabelsList;
 
     /**
      * ShadowRoot bound to the element.
      */
     RefPtr<ShadowRoot> mShadowRoot;
 
-#ifdef MOZ_XBL
-    /**
-     * XBL binding installed on the element.
-     */
-    RefPtr<nsXBLBinding> mXBLBinding;
-#endif
 
     /**
      * Web components custom element data.
      */
     RefPtr<CustomElementData> mCustomElementData;
   };
 
   class nsDOMSlots : public nsIContent::nsContentSlots {
diff --git a/dom/base/IDTracker.cpp b/dom/base/IDTracker.cpp
--- a/dom/base/IDTracker.cpp
+++ b/dom/base/IDTracker.cpp
@@ -5,20 +5,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "IDTracker.h"
 
 #include "mozilla/Encoding.h"
 #include "nsContentUtils.h"
 #include "nsIURI.h"
 #include "nsIReferrerInfo.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#  include "nsXBLPrototypeBinding.h"
-#endif
 #include "nsEscape.h"
 #include "nsCycleCollectionParticipant.h"
 
 namespace mozilla {
 namespace dom {
 
 static DocumentOrShadowRoot* DocOrShadowFromContent(nsIContent& aContent) {
   ShadowRoot* shadow = aContent.GetContainingShadow();
@@ -60,63 +56,28 @@ void IDTracker::ResetToURIFragmentID(nsI
   nsresult rv = encoding->DecodeWithoutBOMHandling(refPart, ref);
   if (NS_FAILED(rv) || ref.IsEmpty()) {
     return;
   }
   rv = NS_OK;
 
   nsIContent* bindingParent = aFromContent->GetBindingParent();
   if (bindingParent && !aFromContent->IsInShadowTree()) {
-#ifdef MOZ_XBL
-    nsXBLBinding* binding = bindingParent->GetXBLBinding();
-    if (!binding) {
-#endif
       // This happens, for example, if aFromContent is part of the content
       // inserted by a call to Document::InsertAnonymousContent, which we
       // also want to handle.  (It also happens for <use>'s anonymous
       // content etc.)
       Element* anonRoot =
           doc->GetAnonRootIfInAnonymousContentContainer(aFromContent);
       if (anonRoot) {
         mElement = nsContentUtils::MatchElementId(anonRoot, ref);
         // We don't have watching working yet for anonymous content, so bail out
         // here.
         return;
       }
-#ifdef MOZ_XBL
-    } else {
-      bool isEqualExceptRef;
-      rv = aURI->EqualsExceptRef(binding->PrototypeBinding()->DocURI(),
-                                 &isEqualExceptRef);
-      if (NS_SUCCEEDED(rv) && isEqualExceptRef) {
-        // XXX sXBL/XBL2 issue
-        // Our content is an anonymous XBL element from a binding inside the
-        // same document that the referenced URI points to. In order to avoid
-        // the risk of ID collisions we restrict ourselves to anonymous
-        // elements from this binding; specifically, URIs that are relative to
-        // the binding document should resolve to the copy of the target
-        // element that has been inserted into the bound document.
-        // If the URI points to a different document we don't need this
-        // restriction.
-        nsINodeList* anonymousChildren =
-            doc->BindingManager()->GetAnonymousNodesFor(bindingParent);
-
-        if (anonymousChildren) {
-          uint32_t length = anonymousChildren->Length();
-          for (uint32_t i = 0; i < length && !mElement; ++i) {
-            mElement =
-                nsContentUtils::MatchElementId(anonymousChildren->Item(i), ref);
-          }
-        }
-
-        // We don't have watching working yet for XBL, so bail out here.
-        return;
-      }
-    }
-#endif
   }
 
   bool isEqualExceptRef;
   rv = aURI->EqualsExceptRef(doc->GetDocumentURI(), &isEqualExceptRef);
   if (NS_FAILED(rv) || !isEqualExceptRef) {
     RefPtr<Document::ExternalResourceLoad> load;
     doc = doc->RequestExternalResource(aURI, aReferrerInfo, aFromContent,
                                        getter_AddRefs(load));
diff --git a/dom/base/ShadowRoot.cpp b/dom/base/ShadowRoot.cpp
--- a/dom/base/ShadowRoot.cpp
+++ b/dom/base/ShadowRoot.cpp
@@ -7,19 +7,16 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/BindContext.h"
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/DocumentFragment.h"
 #include "ChildIterator.h"
 #include "nsContentUtils.h"
 #include "nsIStyleSheetLinkingElement.h"
 #include "nsWindowSizes.h"
-#ifdef MOZ_XBL
-#  include "nsXBLPrototypeBinding.h"
-#endif
 #include "mozilla/dom/DirectionalityUtils.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/HTMLSlotElement.h"
 #include "mozilla/dom/TreeOrderedArrayInlines.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/IdentifierMapEntry.h"
 #include "mozilla/PresShell.h"
 #include "mozilla/PresShellInlines.h"
diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -109,19 +109,16 @@
 #include "mozilla/TextControlState.h"
 #include "mozilla/TextEditor.h"
 #include "mozilla/TextEvents.h"
 #include "nsArrayUtils.h"
 #include "nsAString.h"
 #include "nsAttrName.h"
 #include "nsAttrValue.h"
 #include "nsAttrValueInlines.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsCanvasFrame.h"
 #include "nsCaret.h"
 #include "nsCCUncollectableMarker.h"
 #include "nsCharSeparatedTokenizer.h"
 #include "nsCOMPtr.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsContentDLF.h"
 #include "nsContentList.h"
@@ -2144,23 +2141,17 @@ bool nsContentUtils::ThreadsafeIsSystemC
 
   return ccjscx->IsSystemCaller();
 }
 
 // static
 bool nsContentUtils::LookupBindingMember(
     JSContext* aCx, nsIContent* aContent, JS::Handle<jsid> aId,
     JS::MutableHandle<JS::PropertyDescriptor> aDesc) {
-#ifdef MOZ_XBL
-  nsXBLBinding* binding = aContent->GetXBLBinding();
-  if (!binding) return true;
-  return binding->LookupMember(aCx, aId, aDesc);
-#else
   return true;
-#endif
 }
 
 // static
 nsINode* nsContentUtils::GetCrossDocParentNode(nsINode* aChild) {
   MOZ_ASSERT(aChild, "The child is null!");
 
   nsINode* parent = aChild->GetParentNode();
   if (parent && parent->IsContent() && aChild->IsContent()) {
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -30,19 +30,16 @@
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/Selection.h"
 #include "nsXULPopupManager.h"
 #include "nsMenuPopupFrame.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIPrincipal.h"
 #include "nsIObserverService.h"
 #include "nsIObjectFrame.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "BrowserChild.h"
 #include "nsFrameLoader.h"
 #include "nsHTMLDocument.h"
 #include "nsNumberControlFrame.h"
 #include "nsNetUtil.h"
 #include "nsRange.h"
 
 #include "mozilla/AccessibleCaretEventHub.h"
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -179,20 +179,16 @@
 #  include "nsIPrintSettingsService.h"
 #  include "nsIWebBrowserPrint.h"
 #endif
 
 #include "nsWindowRoot.h"
 #include "nsNetCID.h"
 #include "nsIArray.h"
 
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#  include "nsXBLService.h"
-#endif
 
 #include "nsIDragService.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Selection.h"
 #include "nsFrameLoader.h"
 #include "nsISupportsPrimitives.h"
 #include "nsXPCOMCID.h"
 #include "mozilla/Logging.h"
@@ -2003,23 +1999,16 @@ nsresult nsGlobalWindowInner::PostHandle
 
         // XXX The WebVR 1.1 spec does not define which of multiple VR
         // presenting VR displays will be chosen during navigation.
         // As the underlying platform VR API's currently only allow a single
         // VR display, it is safe to choose the first VR display for now.
         break;
       }
     }
-#ifdef MOZ_XBL
-    // Execute bindingdetached handlers before we tear ourselves
-    // down.
-    if (mDoc) {
-      mDoc->BindingManager()->ExecuteDetachedHandlers();
-    }
-#endif
     mIsDocumentLoaded = false;
   } else if (aVisitor.mEvent->mMessage == eLoad &&
              aVisitor.mEvent->IsTrusted()) {
     // This is page load event since load events don't propagate to |window|.
     // @see Document::GetEventTargetParent.
     mIsDocumentLoaded = true;
 
     mTimeoutManager->OnDocumentLoaded();
diff --git a/dom/base/nsGlobalWindowOuter.cpp b/dom/base/nsGlobalWindowOuter.cpp
--- a/dom/base/nsGlobalWindowOuter.cpp
+++ b/dom/base/nsGlobalWindowOuter.cpp
@@ -173,20 +173,16 @@
 
 #include "nsWindowRoot.h"
 #include "nsNetCID.h"
 #include "nsIArray.h"
 
 #include "nsIDOMXULCommandDispatcher.h"
 
 #include "mozilla/GlobalKeyListener.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#  include "nsXBLService.h"
-#endif
 
 #include "nsIDragService.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Selection.h"
 #include "nsFrameLoader.h"
 #include "nsISupportsPrimitives.h"
 #include "nsXPCOMCID.h"
 #include "mozilla/Logging.h"
diff --git a/dom/base/nsIContent.h b/dom/base/nsIContent.h
--- a/dom/base/nsIContent.h
+++ b/dom/base/nsIContent.h
@@ -16,19 +16,16 @@
 
 // Forward declarations
 class nsAtom;
 class nsIURI;
 class nsAttrValue;
 class nsAttrName;
 class nsTextFragment;
 class nsIFrame;
-#ifdef MOZ_XBL
-class nsXBLBinding;
-#endif
 class nsITextControlElement;
 
 namespace mozilla {
 class EventChainPreVisitor;
 struct URLExtraData;
 namespace dom {
 struct BindContext;
 class ShadowRoot;
@@ -392,32 +389,16 @@ class nsIContent : public nsINode {
    *
    * @return the binding parent
    */
   virtual mozilla::dom::Element* GetBindingParent() const {
     const nsExtendedContentSlots* slots = GetExistingExtendedContentSlots();
     return slots ? slots->mBindingParent.get() : nullptr;
   }
 
-#ifdef MOZ_XBL
-  /**
-   * Gets the current XBL binding that is bound to this element.
-   *
-   * @return the current binding.
-   */
-  nsXBLBinding* GetXBLBinding() const {
-    if (!HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
-      return nullptr;
-    }
-
-    return DoGetXBLBinding();
-  }
-
-  virtual nsXBLBinding* DoGetXBLBinding() const = 0;
-#endif
 
   /**
    * Gets the ShadowRoot binding for this element.
    *
    * @return The ShadowRoot currently bound to this element.
    */
   inline mozilla::dom::ShadowRoot* GetShadowRoot() const;
 
diff --git a/dom/base/nsIContentInlines.h b/dom/base/nsIContentInlines.h
--- a/dom/base/nsIContentInlines.h
+++ b/dom/base/nsIContentInlines.h
@@ -4,19 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsIContentInlines_h
 #define nsIContentInlines_h
 
 #include "nsIContent.h"
 #include "mozilla/dom/Document.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsContentUtils.h"
 #include "nsAtom.h"
 #include "nsIFrame.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/HTMLSlotElement.h"
 #include "mozilla/dom/ShadowRoot.h"
 
 inline bool nsINode::IsUAWidget() const {
@@ -115,31 +112,16 @@ static inline nsINode* GetFlattenedTreeP
     }
 
     if (auto* shadowRoot =
             mozilla::dom::ShadowRoot::FromNode(parentAsContent)) {
       return shadowRoot->GetHost();
     }
   }
 
-#ifdef MOZ_XBL
-  if (content->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR) ||
-      parent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
-    if (nsIContent* xblInsertionPoint = content->GetXBLInsertionPoint()) {
-      return xblInsertionPoint->GetParent();
-    }
-
-    if (parent->OwnerDoc()->BindingManager()->GetBindingWithContent(
-            parentAsContent)) {
-      // This is an unassigned node child of the bound element, so it isn't part
-      // of the flat tree.
-      return nullptr;
-    }
-  }
-#endif
 
   MOZ_ASSERT(!parentAsContent->IsActiveChildrenElement(),
              "<xbl:children> isn't in the flattened tree");
 
   // Common case.
   return parent;
 }
 
diff --git a/dom/base/nsINode.cpp b/dom/base/nsINode.cpp
--- a/dom/base/nsINode.cpp
+++ b/dom/base/nsINode.cpp
@@ -84,21 +84,16 @@
 #include "nsNodeUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsPresContext.h"
 #include "nsString.h"
 #include "nsStyleConsts.h"
 #include "nsSVGUtils.h"
 #include "nsTextNode.h"
 #include "nsUnicharUtils.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#  include "nsXBLBinding.h"
-#  include "nsXBLPrototypeBinding.h"
-#endif
 #include "nsWindowSizes.h"
 #include "mozilla/Preferences.h"
 #include "xpcpublic.h"
 #include "HTMLLegendElement.h"
 #include "nsWrapperCacheInlines.h"
 #include "WrapperFactory.h"
 #include <algorithm>
 #include "nsGlobalWindow.h"
diff --git a/dom/base/nsJSUtils.cpp b/dom/base/nsJSUtils.cpp
--- a/dom/base/nsJSUtils.cpp
+++ b/dom/base/nsJSUtils.cpp
@@ -25,19 +25,16 @@
 #include "nsCOMPtr.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsPIDOMWindow.h"
 #include "GeckoProfiler.h"
 #include "nsJSPrincipals.h"
 #include "xpcpublic.h"
 #include "nsContentUtils.h"
 #include "nsGlobalWindow.h"
-#ifdef MOZ_XBL
-#  include "nsXBLPrototypeBinding.h"
-#endif
 #include "mozilla/CycleCollectedJSContext.h"
 #include "mozilla/StaticPrefs_browser.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/Date.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/Utf8.h"  // mozilla::Utf8Unit
 
@@ -615,40 +612,16 @@ bool nsJSUtils::GetScopeChainForElement(
     if (!AddScopeChainItem(aCx, cur, aScopeChain)) {
       return false;
     }
   }
 
   return true;
 }
 
-#ifdef MOZ_XBL
-/* static */
-bool nsJSUtils::GetScopeChainForXBL(
-    JSContext* aCx, Element* aElement,
-    const nsXBLPrototypeBinding& aProtoBinding,
-    JS::MutableHandleVector<JSObject*> aScopeChain) {
-  if (!aElement) {
-    return true;
-  }
-
-  if (!aProtoBinding.SimpleScopeChain()) {
-    return GetScopeChainForElement(aCx, aElement, aScopeChain);
-  }
-
-  if (!AddScopeChainItem(aCx, aElement, aScopeChain)) {
-    return false;
-  }
-
-  if (!AddScopeChainItem(aCx, aElement->OwnerDoc(), aScopeChain)) {
-    return false;
-  }
-  return true;
-}
-#endif
 
 /* static */
 void nsJSUtils::ResetTimeZone() { JS::ResetTimeZone(); }
 
 /* static */
 bool nsJSUtils::DumpEnabled() {
 #if defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP)
   return true;
diff --git a/dom/base/nsJSUtils.h b/dom/base/nsJSUtils.h
--- a/dom/base/nsJSUtils.h
+++ b/dom/base/nsJSUtils.h
@@ -236,28 +236,16 @@ class nsJSUtils {
   static nsresult ModuleEvaluate(JSContext* aCx, JS::Handle<JSObject*> aModule);
 
   // Returns false if an exception got thrown on aCx.  Passing a null
   // aElement is allowed; that wil produce an empty aScopeChain.
   static bool GetScopeChainForElement(
       JSContext* aCx, mozilla::dom::Element* aElement,
       JS::MutableHandleVector<JSObject*> aScopeChain);
 
-#ifdef MOZ_XBL
-  // Returns a scope chain suitable for XBL execution.
-  //
-  // This is by default GetScopeChainForElemenet, but will be different if the
-  // <binding> element had the simpleScopeChain attribute.
-  //
-  // This is to prevent footguns like bug 1446342.
-  static bool GetScopeChainForXBL(
-      JSContext* aCx, mozilla::dom::Element* aBoundElement,
-      const nsXBLPrototypeBinding& aProtoBinding,
-      JS::MutableHandleVector<JSObject*> aScopeChain);
-#endif
 
   static void ResetTimeZone();
 
   static bool DumpEnabled();
 };
 
 inline void AssignFromStringBuffer(nsStringBuffer* buffer, size_t len,
                                    nsAString& dest) {
diff --git a/dom/base/nsNameSpaceManager.cpp b/dom/base/nsNameSpaceManager.cpp
--- a/dom/base/nsNameSpaceManager.cpp
+++ b/dom/base/nsNameSpaceManager.cpp
@@ -16,19 +16,16 @@
 #include "nsAtom.h"
 #include "nsCOMArray.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsGkAtoms.h"
 #include "mozilla/dom/Document.h"
 #include "nsString.h"
 #include "mozilla/dom/NodeInfo.h"
 #include "mozilla/ClearOnShutdown.h"
-#ifdef MOZ_XBL
-#  include "mozilla/dom/XBLChildrenElement.h"
-#endif
 #include "mozilla/dom/Element.h"
 #include "mozilla/Preferences.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 static const char* kPrefSVGDisabled = "svg.disabled";
 static const char* kPrefMathMLDisabled = "mathml.disabled";
@@ -200,22 +197,16 @@ nsresult NS_NewElement(Element** aResult
       return NS_NewSVGElement(aResult, ni.forget(), aFromParser);
     }
     RefPtr<mozilla::dom::NodeInfo> genericXMLNI =
         ni->NodeInfoManager()->GetNodeInfo(ni->NameAtom(), ni->GetPrefixAtom(),
                                            kNameSpaceID_disabled_SVG,
                                            ni->NodeType(), ni->GetExtraName());
     return NS_NewXMLElement(aResult, genericXMLNI.forget());
   }
-#ifdef MOZ_XBL
-  if (ns == kNameSpaceID_XBL && ni->Equals(nsGkAtoms::children)) {
-    NS_ADDREF(*aResult = new XBLChildrenElement(ni.forget()));
-    return NS_OK;
-  }
-#endif
 
   return NS_NewXMLElement(aResult, ni.forget());
 }
 
 bool nsNameSpaceManager::HasElementCreator(int32_t aNameSpaceID) {
   return aNameSpaceID == kNameSpaceID_XHTML ||
 #ifdef MOZ_XUL
          aNameSpaceID == kNameSpaceID_XUL ||
diff --git a/dom/base/nsNodeInfoManager.cpp b/dom/base/nsNodeInfoManager.cpp
--- a/dom/base/nsNodeInfoManager.cpp
+++ b/dom/base/nsNodeInfoManager.cpp
@@ -20,19 +20,16 @@
 #include "nsAtom.h"
 #include "nsIPrincipal.h"
 #include "nsIURI.h"
 #include "nsContentUtils.h"
 #include "nsReadableUtils.h"
 #include "nsGkAtoms.h"
 #include "nsComponentManagerUtils.h"
 #include "nsLayoutStatics.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsHashKeys.h"
 #include "nsCCUncollectableMarker.h"
 #include "nsNameSpaceManager.h"
 #include "nsWindowSizes.h"
 
 using namespace mozilla;
 using mozilla::dom::NodeInfo;
 
@@ -55,37 +52,31 @@ nsNodeInfoManager::nsNodeInfoManager()
     MOZ_LOG(gNodeInfoManagerLeakPRLog, LogLevel::Debug,
             ("NODEINFOMANAGER %p created", this));
 }
 
 nsNodeInfoManager::~nsNodeInfoManager() {
   // Note: mPrincipal may be null here if we never got inited correctly
   mPrincipal = nullptr;
 
-#ifdef MOZ_XBL
-  mBindingManager = nullptr;
-#endif
 
   if (gNodeInfoManagerLeakPRLog)
     MOZ_LOG(gNodeInfoManagerLeakPRLog, LogLevel::Debug,
             ("NODEINFOMANAGER %p destroyed", this));
 
   nsLayoutStatics::Release();
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsNodeInfoManager)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsNodeInfoManager)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsNodeInfoManager)
   if (tmp->mNonDocumentNodeInfos) {
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDocument)
   }
-#ifdef MOZ_XBL
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mBindingManager)
-#endif
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsNodeInfoManager, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsNodeInfoManager, Release)
 
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsNodeInfoManager)
   if (tmp->mDocument) {
     return NS_CYCLE_COLLECTION_PARTICIPANT(mozilla::dom::Document)
@@ -107,39 +98,29 @@ NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_B
   }
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 
 nsresult nsNodeInfoManager::Init(mozilla::dom::Document* aDocument) {
   MOZ_ASSERT(!mPrincipal, "Being inited when we already have a principal?");
 
   mPrincipal = NullPrincipal::CreateWithoutOriginAttributes();
 
-#ifdef MOZ_XBL
-  if (aDocument) {
-    mBindingManager = new nsBindingManager(aDocument);
-  }
-#endif
 
   mDefaultPrincipal = mPrincipal;
 
   mDocument = aDocument;
 
   if (gNodeInfoManagerLeakPRLog)
     MOZ_LOG(gNodeInfoManagerLeakPRLog, LogLevel::Debug,
             ("NODEINFOMANAGER %p Init document=%p", this, aDocument));
 
   return NS_OK;
 }
 
 void nsNodeInfoManager::DropDocumentReference() {
-#ifdef MOZ_XBL
-  if (mBindingManager) {
-    mBindingManager->DropDocumentReference();
-  }
-#endif
 
   // This is probably not needed anymore.
   for (auto iter = mNodeInfoHash.Iter(); !iter.Done(); iter.Next()) {
     iter.Data()->mDocument = nullptr;
   }
 
   NS_ASSERTION(!mNonDocumentNodeInfos,
                "Shouldn't have non-document nodeinfos!");
@@ -372,19 +353,13 @@ bool nsNodeInfoManager::InternalMathMLEn
                      nsContentUtils::IsSystemPrincipal(mPrincipal));
   mMathMLEnabled = Some(conclusion);
   return conclusion;
 }
 
 void nsNodeInfoManager::AddSizeOfIncludingThis(nsWindowSizes& aSizes) const {
   aSizes.mDOMOtherSize += aSizes.mState.mMallocSizeOf(this);
 
-#ifdef MOZ_XBL
-  if (mBindingManager) {
-    aSizes.mBindingsSize +=
-        mBindingManager->SizeOfIncludingThis(aSizes.mState.mMallocSizeOf);
-  }
-#endif
 
   // Measurement of the following members may be added later if DMD finds it
   // is worthwhile:
   // - mNodeInfoHash
 }
diff --git a/dom/base/nsNodeInfoManager.h b/dom/base/nsNodeInfoManager.h
--- a/dom/base/nsNodeInfoManager.h
+++ b/dom/base/nsNodeInfoManager.h
@@ -14,19 +14,16 @@
 #include "mozilla/Attributes.h"  // for final
 #include "mozilla/dom/NodeInfo.h"
 #include "mozilla/MruCache.h"
 #include "nsCOMPtr.h"                      // for member
 #include "nsCycleCollectionParticipant.h"  // for NS_DECL_CYCLE_*
 #include "nsDataHashtable.h"
 #include "nsStringFwd.h"
 
-#ifdef MOZ_XBL
-class nsBindingManager;
-#endif
 class nsAtom;
 class nsIPrincipal;
 class nsWindowSizes;
 template <class T>
 struct already_AddRefed;
 
 namespace mozilla {
 namespace dom {
@@ -95,19 +92,16 @@ class nsNodeInfoManager final {
    */
   nsIPrincipal* DocumentPrincipal() const {
     NS_ASSERTION(mPrincipal, "How'd that happen?");
     return mPrincipal;
   }
 
   void RemoveNodeInfo(mozilla::dom::NodeInfo* aNodeInfo);
 
-#ifdef MOZ_XBL
-  nsBindingManager* GetBindingManager() const { return mBindingManager; }
-#endif
 
   /**
    * Returns true if SVG nodes in this document have real SVG semantics.
    */
   bool SVGEnabled() { return mSVGEnabled.valueOr(InternalSVGEnabled()); }
 
   /**
    * Returns true if MathML nodes in this document have real MathML semantics.
@@ -160,17 +154,14 @@ class nsNodeInfoManager final {
   nsCOMPtr<nsIPrincipal> mPrincipal;  // Never null after Init() succeeds.
   nsCOMPtr<nsIPrincipal> mDefaultPrincipal;  // Never null after Init() succeeds
   mozilla::dom::NodeInfo* MOZ_NON_OWNING_REF
       mTextNodeInfo;  // WEAK to avoid circular ownership
   mozilla::dom::NodeInfo* MOZ_NON_OWNING_REF
       mCommentNodeInfo;  // WEAK to avoid circular ownership
   mozilla::dom::NodeInfo* MOZ_NON_OWNING_REF
       mDocumentNodeInfo;  // WEAK to avoid circular ownership
-#ifdef MOZ_XBL
-  RefPtr<nsBindingManager> mBindingManager;
-#endif
   NodeInfoCache mRecentlyUsedNodeInfos;
   mozilla::Maybe<bool> mSVGEnabled;     // Lazily initialized.
   mozilla::Maybe<bool> mMathMLEnabled;  // Lazily initialized.
 };
 
 #endif /* nsNodeInfoManager_h___ */
diff --git a/dom/base/nsNodeUtils.cpp b/dom/base/nsNodeUtils.cpp
--- a/dom/base/nsNodeUtils.cpp
+++ b/dom/base/nsNodeUtils.cpp
@@ -17,19 +17,16 @@
 #include "mozilla/EventListenerManager.h"
 #include "nsIXPConnect.h"
 #include "PLDHashTable.h"
 #include "nsCOMArray.h"
 #include "nsPIDOMWindow.h"
 #ifdef MOZ_XUL
 #  include "nsXULElement.h"
 #endif
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsGenericHTMLElement.h"
 #include "mozilla/AnimationTarget.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/Animation.h"
 #include "mozilla/dom/HTMLImageElement.h"
 #include "mozilla/dom/HTMLMediaElement.h"
 #include "mozilla/dom/KeyframeEffect.h"
@@ -53,24 +50,19 @@ enum class IsRemoveNotification {
 
 #ifdef DEBUG
 #  define COMPOSED_DOC_DECL \
     const bool wasInComposedDoc = !!node->GetComposedDoc();
 #else
 #  define COMPOSED_DOC_DECL
 #endif
 
-#ifdef MOZ_XBL
-#  define CALL_BINDING_MANAGER(func_, params_) \
-    doc->BindingManager()->func_ params_
-#else
 #  define CALL_BINDING_MANAGER(func_, params_) \
     do {                                       \
     } while (0)
-#endif
 
 // This macro expects the ownerDocument of content_ to be in scope as
 // |Document* doc|
 #define IMPL_MUTATION_NOTIFICATION(func_, content_, params_, remove_)         \
   PR_BEGIN_MACRO                                                              \
   bool needsEnterLeave = doc->MayHaveDOMMutationObservers();                  \
   if (needsEnterLeave) {                                                      \
     nsDOMMutationObserver::EnterMutationHandling();                           \
@@ -326,21 +318,16 @@ void nsNodeUtils::LastRelease(nsINode* a
       }
     }
 #endif
 
     nsContentUtils::RemoveListenerManager(aNode);
     aNode->UnsetFlags(NODE_HAS_LISTENERMANAGER);
   }
 
-#ifdef MOZ_XBL
-  NS_ASSERTION(
-      !Element::FromNode(aNode) || !Element::FromNode(aNode)->GetXBLBinding(),
-      "Node has binding on destruction");
-#endif
 
   aNode->ReleaseWrapper(aNode);
 
   FragmentOrElement::RemoveBlackMarkedNode(aNode);
 }
 
 /* static */
 already_AddRefed<nsINode> nsNodeUtils::CloneNodeImpl(nsINode* aNode, bool aDeep,
diff --git a/dom/xul/nsXULElement.cpp b/dom/xul/nsXULElement.cpp
--- a/dom/xul/nsXULElement.cpp
+++ b/dom/xul/nsXULElement.cpp
@@ -60,19 +60,16 @@
 #include "nsIController.h"
 #include "nsQueryObject.h"
 #include <algorithm>
 #include "nsIDOMChromeWindow.h"
 
 #include "nsReadableUtils.h"
 #include "nsIFrame.h"
 #include "nsNodeInfoManager.h"
-#ifdef MOZ_XBL
-#  include "nsXBLBinding.h"
-#endif
 #include "nsXULTooltipListener.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozAutoDocUpdate.h"
 #include "nsCCUncollectableMarker.h"
 #include "nsICSSDeclaration.h"
 #include "nsLayoutUtils.h"
 #include "XULFrameElement.h"
 #include "XULMenuElement.h"
diff --git a/dom/xul/nsXULPrototypeCache.cpp b/dom/xul/nsXULPrototypeCache.cpp
--- a/dom/xul/nsXULPrototypeCache.cpp
+++ b/dom/xul/nsXULPrototypeCache.cpp
@@ -193,41 +193,23 @@ nsresult nsXULPrototypeCache::PutScript(
   }
 #endif
 
   mScriptTable.Put(aURI, aScriptObject);
 
   return NS_OK;
 }
 
-#ifdef MOZ_XBL
-nsXBLDocumentInfo* nsXULPrototypeCache::GetXBLDocumentInfo(nsIURI* aURL) {
-  return mXBLDocTable.GetWeak(aURL);
-}
-
-nsresult nsXULPrototypeCache::PutXBLDocumentInfo(
-    nsXBLDocumentInfo* aDocumentInfo) {
-  nsIURI* uri = aDocumentInfo->DocumentURI();
-  nsXBLDocumentInfo* info = mXBLDocTable.GetWeak(uri);
-  if (!info) {
-    mXBLDocTable.Put(uri, aDocumentInfo);
-  }
-  return NS_OK;
-}
-#endif
 
 void nsXULPrototypeCache::FlushScripts() { mScriptTable.Clear(); }
 
 void nsXULPrototypeCache::Flush() {
   mPrototypeTable.Clear();
   mScriptTable.Clear();
   mStyleSheetTable.Clear();
-#ifdef MOZ_XBL
-  mXBLDocTable.Clear();
-#endif
 }
 
 bool nsXULPrototypeCache::IsEnabled() { return !gDisableXULCache; }
 
 void nsXULPrototypeCache::AbortCaching() {
 #ifdef DEBUG_brendan
   NS_BREAK();
 #endif
@@ -480,21 +462,16 @@ nsresult nsXULPrototypeCache::BeginCachi
       return NS_ERROR_FAILURE;
     }
   }
 
   return NS_OK;
 }
 
 void nsXULPrototypeCache::MarkInCCGeneration(uint32_t aGeneration) {
-#ifdef MOZ_XBL
-  for (auto iter = mXBLDocTable.Iter(); !iter.Done(); iter.Next()) {
-    iter.Data()->MarkInCCGeneration(aGeneration);
-  }
-#endif
   for (auto iter = mPrototypeTable.Iter(); !iter.Done(); iter.Next()) {
     iter.Data()->MarkInCCGeneration(aGeneration);
   }
 }
 
 void nsXULPrototypeCache::MarkInGC(JSTracer* aTrc) {
   for (auto iter = mScriptTable.Iter(); !iter.Done(); iter.Next()) {
     JS::Heap<JSScript*>& script = iter.Data();
@@ -510,26 +487,16 @@ static void ReportSize(const nsCString& 
                        nsISupports* aData) {
   nsAutoCString path("explicit/xul-prototype-cache/");
   path += aPath;
   aHandleReport->Callback(EmptyCString(), path, nsIMemoryReporter::KIND_HEAP,
                           nsIMemoryReporter::UNITS_BYTES, aAmount, aDescription,
                           aData);
 }
 
-#ifdef MOZ_XBL
-static void AppendURIForMemoryReport(nsIURI* aUri, nsACString& aOutput) {
-  nsCString spec = aUri->GetSpecOrDefault();
-  // A hack: replace forward slashes with '\\' so they aren't
-  // treated as path separators.  Users of the reporters
-  // (such as about:memory) have to undo this change.
-  spec.ReplaceChar('/', '\\');
-  aOutput += spec;
-}
-#endif
 
 /* static */
 void nsXULPrototypeCache::CollectMemoryReports(
     nsIHandleReportCallback* aHandleReport, nsISupports* aData) {
   if (!sInstance) {
     return;
   }
 
@@ -543,28 +510,16 @@ void nsXULPrototypeCache::CollectMemoryR
   // TODO Report content in mPrototypeTable?
 
   other += sInstance->mStyleSheetTable.ShallowSizeOfExcludingThis(mallocSizeOf);
   // TODO Report content inside mStyleSheetTable?
 
   other += sInstance->mScriptTable.ShallowSizeOfExcludingThis(mallocSizeOf);
   // TODO Report content inside mScriptTable?
 
-#ifdef MOZ_XBL
-  other += sInstance->mXBLDocTable.ShallowSizeOfExcludingThis(mallocSizeOf);
-  for (auto iter = sInstance->mXBLDocTable.ConstIter(); !iter.Done();
-       iter.Next()) {
-    nsAutoCString path;
-    path += "xbl-docs/(";
-    AppendURIForMemoryReport(iter.Key(), path);
-    path += ")";
-    size_t size = iter.UserData()->SizeOfIncludingThis(mallocSizeOf);
-    REPORT_SIZE(path, size, "Memory used by this XBL document.");
-  }
-#endif
 
   other +=
       sInstance->mStartupCacheURITable.ShallowSizeOfExcludingThis(mallocSizeOf);
 
   other +=
       sInstance->mOutputStreamTable.ShallowSizeOfExcludingThis(mallocSizeOf);
   other +=
       sInstance->mInputStreamTable.ShallowSizeOfExcludingThis(mallocSizeOf);
diff --git a/dom/xul/nsXULPrototypeCache.h b/dom/xul/nsXULPrototypeCache.h
--- a/dom/xul/nsXULPrototypeCache.h
+++ b/dom/xul/nsXULPrototypeCache.h
@@ -3,19 +3,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsXULPrototypeCache_h__
 #define nsXULPrototypeCache_h__
 
 #include "nsCOMPtr.h"
 #include "nsIObserver.h"
-#ifdef MOZ_XBL
-#  include "nsXBLDocumentInfo.h"
-#endif
 #include "nsJSThingHashtable.h"
 #include "nsInterfaceHashtable.h"
 #include "nsRefPtrHashtable.h"
 #include "nsURIHashKey.h"
 #include "nsXULPrototypeDocument.h"
 #include "nsIInputStream.h"
 #include "nsIStorageStream.h"
 
@@ -58,21 +55,16 @@ class nsXULPrototypeCache : public nsIOb
   // from the cache.
 
   nsXULPrototypeDocument* GetPrototype(nsIURI* aURI);
   nsresult PutPrototype(nsXULPrototypeDocument* aDocument);
 
   JSScript* GetScript(nsIURI* aURI);
   nsresult PutScript(nsIURI* aURI, JS::Handle<JSScript*> aScriptObject);
 
-#ifdef MOZ_XBL
-  nsXBLDocumentInfo* GetXBLDocumentInfo(nsIURI* aURL);
-
-  nsresult PutXBLDocumentInfo(nsXBLDocumentInfo* aDocumentInfo);
-#endif
 
   /**
    * Get a style sheet by URI. If the style sheet is not in the cache,
    * returns nullptr.
    */
   mozilla::StyleSheet* GetStyleSheet(nsIURI* aURI);
 
   /**
@@ -114,27 +106,21 @@ class nsXULPrototypeCache : public nsIOb
                                           void** aResult);
 
   nsXULPrototypeCache();
   virtual ~nsXULPrototypeCache();
 
   static nsXULPrototypeCache* sInstance;
 
   using StyleSheetTable = nsRefPtrHashtable<nsURIHashKey, mozilla::StyleSheet>;
-#ifdef MOZ_XBL
-  using XBLDocTable = nsRefPtrHashtable<nsURIHashKey, nsXBLDocumentInfo>;
-#endif
 
   nsRefPtrHashtable<nsURIHashKey, nsXULPrototypeDocument>
       mPrototypeTable;  // owns the prototypes
   StyleSheetTable mStyleSheetTable;
   nsJSThingHashtable<nsURIHashKey, JSScript*> mScriptTable;
-#ifdef MOZ_XBL
-  XBLDocTable mXBLDocTable;
-#endif
 
   // URIs already written to the startup cache, to prevent double-caching.
   nsTHashtable<nsURIHashKey> mStartupCacheURITable;
 
   nsInterfaceHashtable<nsURIHashKey, nsIStorageStream> mOutputStreamTable;
   nsInterfaceHashtable<nsURIHashKey, nsIObjectInputStream> mInputStreamTable;
 
   // Bootstrap caching service
diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -189,19 +189,16 @@
 #include "mozilla/layers/WebRenderUserData.h"
 #include "mozilla/layout/ScrollAnchorContainer.h"
 #include "mozilla/ServoBindings.h"
 #include "mozilla/ServoStyleSet.h"
 #include "mozilla/StyleSheet.h"
 #include "mozilla/StyleSheetInlines.h"
 #include "mozilla/dom/ImageTracker.h"
 #include "nsIDocShellTreeOwner.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsClassHashtable.h"
 #include "nsHashKeys.h"
 #include "VisualViewport.h"
 
 #ifdef MOZ_TASK_TRACER
 #  include "GeckoTaskTracer.h"
 using namespace mozilla::tasktracer;
 #endif
@@ -1665,31 +1662,16 @@ void PresShell::EndObservingDocument() {
   mIsDocumentGone = true;
   mIsObservingDocument = false;
 }
 
 #ifdef DEBUG_kipp
 char* nsPresShell_ReflowStackPointerTop;
 #endif
 
-#ifdef MOZ_XBL
-class XBLConstructorRunner : public Runnable {
- public:
-  explicit XBLConstructorRunner(Document* aDocument)
-      : Runnable("XBLConstructorRunner"), mDocument(aDocument) {}
-
-  NS_IMETHOD Run() override {
-    mDocument->BindingManager()->ProcessAttachedQueue();
-    return NS_OK;
-  }
-
- private:
-  RefPtr<Document> mDocument;
-};
-#endif
 
 nsresult PresShell::Initialize() {
   if (mIsDestroying) {
     return NS_OK;
   }
 
   if (!mDocument) {
     // Nothing to do
@@ -1758,22 +1740,16 @@ nsresult PresShell::Initialize() {
       // Destroy() to get called, bug 337586.
       NS_ENSURE_STATE(!mHaveShutDown);
     }
 
     // nsAutoCauseReflowNotifier (which sets up a script blocker) going out of
     // scope may have killed us too
     NS_ENSURE_STATE(!mHaveShutDown);
 
-#ifdef MOZ_XBL
-    // Run the XBL binding constructors for any new frames we've constructed.
-    // (Do this in a script runner, since our caller might have a script
-    // blocker on the stack.)
-    nsContentUtils::AddScriptRunner(new XBLConstructorRunner(mDocument));
-#endif
 
     // XBLConstructorRunner might destroy us.
     NS_ENSURE_STATE(!mHaveShutDown);
   }
 
   mDocument->TriggerAutoFocus();
 
   NS_ASSERTION(rootFrame, "How did that happen?");
@@ -2877,33 +2853,16 @@ void PresShell::SlotAssignmentWillChange
   }
 }
 
 #ifdef DEBUG
 static void AssertNoFramesInSubtree(nsIContent* aContent) {
   for (nsINode* node : ShadowIncludingTreeIterator(*aContent)) {
     nsIContent* c = nsIContent::FromNode(node);
     MOZ_ASSERT(!c->GetPrimaryFrame());
-#  ifdef MOZ_XBL
-    if (auto* binding = c->GetXBLBinding()) {
-      if (auto* bindingWithContent = binding->GetBindingWithContent()) {
-        nsIContent* anonContent = bindingWithContent->GetAnonymousContent();
-        MOZ_ASSERT(!anonContent->GetPrimaryFrame());
-
-        // Need to do this instead of just AssertNoFramesInSubtree(anonContent),
-        // because the parent of the children of the <content> element isn't the
-        // <content> element, but the bound element, and that confuses
-        // GetNextNode a lot.
-        for (nsIContent* child = anonContent->GetFirstChild(); child;
-             child = child->GetNextSibling()) {
-          AssertNoFramesInSubtree(child);
-        }
-      }
-    }
-#  endif
   }
 }
 #endif
 
 void PresShell::DestroyFramesForAndRestyle(Element* aElement) {
 #ifdef DEBUG
   auto postCondition =
       mozilla::MakeScopeExit([&]() { AssertNoFramesInSubtree(aElement); });
@@ -4112,24 +4071,16 @@ void PresShell::DoFlushPendingNotificati
                                                 innerWindowID);
 #endif
       PerfStats::AutoMetricRecording<PerfStats::Metric::Styling> autoRecording;
       LAYOUT_TELEMETRY_RECORD_BASE(Restyle);
 
       mPresContext->RestyleManager()->ProcessPendingRestyles();
     }
 
-#ifdef MOZ_XBL
-    // Process whatever XBL constructors those restyles queued up.  This
-    // ensures that onload doesn't fire too early and that we won't do extra
-    // reflows after those constructors run.
-    if (MOZ_LIKELY(!mIsDestroying)) {
-      mDocument->BindingManager()->ProcessAttachedQueue();
-    }
-#endif
 
     // Now those constructors or events might have posted restyle
     // events.  At the same time, we still need up-to-date style data.
     // In particular, reflow depends on style being completely up to
     // date.  If it's not, then style reparenting, which can
     // happen during reflow, might suddenly pick up the new rules and
     // we'll end up with frames whose style doesn't match the frame
     // type.
@@ -9893,19 +9844,16 @@ bool PresShell::VerifyIncrementalReflow(
   presShell->SetVerifyReflowEnable(
       false);  // turn off verify reflow while we're
                // reflowing the test frame tree
   vm->SetPresShell(presShell);
   {
     nsAutoCauseReflowNotifier crNotifier(this);
     presShell->Initialize();
   }
-#  ifdef MOZ_XBL
-  mDocument->BindingManager()->ProcessAttachedQueue();
-#  endif
   presShell->FlushPendingNotifications(FlushType::Layout);
   presShell->SetVerifyReflowEnable(
       true);  // turn on verify reflow again now that
               // we're done reflowing the test frame tree
   // Force the non-primary presshell to unsuppress; it doesn't want to normally
   // because it thinks it's hidden
   presShell->mPaintingSuppressed = false;
   if (VerifyReflowFlags::Noisy & gVerifyReflowFlags) {
diff --git a/layout/base/nsGenConList.cpp b/layout/base/nsGenConList.cpp
--- a/layout/base/nsGenConList.cpp
+++ b/layout/base/nsGenConList.cpp
@@ -65,23 +65,16 @@ inline int32_t PseudoCompareType(nsIFram
   if (pseudo == mozilla::PseudoStyleType::after) {
     *aContent = aFrame->GetContent()->GetParent();
     return 1;
   }
   *aContent = aFrame->GetContent();
   return 0;
 }
 
-#if defined(DEBUG) && defined(MOZ_XBL)
-static bool IsXBLInvolved(nsIContent* aContent1, nsIContent* aContent2) {
-  auto* ancestor = nsContentUtils::GetCommonAncestor(aContent1, aContent2);
-  return ancestor && ancestor->IsElement() &&
-         ancestor->AsElement()->GetXBLBinding();
-}
-#endif
 
 /* static */
 bool nsGenConList::NodeAfter(const nsGenConNode* aNode1,
                              const nsGenConNode* aNode2) {
   nsIFrame* frame1 = aNode1->mPseudoFrame;
   nsIFrame* frame2 = aNode2->mPseudoFrame;
   if (frame1 == frame2) {
     NS_ASSERTION(aNode2->mContentIndex != aNode1->mContentIndex, "identical");
@@ -103,19 +96,16 @@ bool nsGenConList::NodeAfter(const nsGen
   // they were normal elements and just use tree order.
   content1 = frame1->GetContent();
   content2 = frame2->GetContent();
 
   int32_t cmp = nsLayoutUtils::CompareTreePosition(content1, content2);
   // DoCompareTreePosition doesn't know about XBL anonymous content, and we
   // probably shouldn't bother teaching it about it.
   MOZ_ASSERT(cmp != 0
-#ifdef MOZ_XBL
-                 || IsXBLInvolved(content1, content2)
-#endif
                  ,
              "same content, different frames");
   return cmp > 0;
 }
 
 void nsGenConList::Insert(nsGenConNode* aNode) {
   // Check for append.
   if (mList.isEmpty() || NodeAfter(aNode, mList.getLast())) {
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -34,19 +34,16 @@
 #include "nsLayoutStylesheetCache.h"
 #include "nsRange.h"
 #include "nsRegion.h"
 #include "nsRepeatService.h"
 #include "nsFloatManager.h"
 #include "nsSprocketLayout.h"
 #include "nsStackLayout.h"
 #include "nsTextControlFrame.h"
-#ifdef MOZ_XBL
-#  include "nsXBLService.h"
-#endif
 #include "txMozillaXSLTProcessor.h"
 #include "nsTreeSanitizer.h"
 #include "nsCellMap.h"
 #include "nsTextFrame.h"
 #include "nsCCUncollectableMarker.h"
 #include "nsTextFragment.h"
 #include "nsMediaFeatures.h"
 #include "nsCORSListenerProxy.h"
@@ -163,19 +160,16 @@ nsresult nsLayoutStatics::Initialize() {
   DebugVerifyFrameStateBits();
 #endif
 
   StartupJSEnvironment();
 
   nsGlobalWindowInner::Init();
   nsGlobalWindowOuter::Init();
   Navigator::Init();
-#ifdef MOZ_XBL
-  nsXBLService::Init();
-#endif
 
   rv = nsContentUtils::Init();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsContentUtils");
     return rv;
   }
 
   rv = nsAttrValue::Init();
@@ -383,19 +377,16 @@ void nsLayoutStatics::Shutdown() {
   nsAttrValue::Shutdown();
   nsContentUtils::Shutdown();
   nsLayoutStylesheetCache::Shutdown();
 
   ShutdownJSEnvironment();
   nsGlobalWindowInner::ShutDown();
   nsGlobalWindowOuter::ShutDown();
   nsListControlFrame::Shutdown();
-#ifdef MOZ_XBL
-  nsXBLService::Shutdown();
-#endif
   FrameLayerBuilder::Shutdown();
 
   CubebUtils::ShutdownLibrary();
   WebAudioUtils::Shutdown();
 
   nsCORSListenerProxy::Shutdown();
 
   PointerEventHandler::ReleaseStatics();
diff --git a/layout/inspector/InspectorUtils.cpp b/layout/inspector/InspectorUtils.cpp
--- a/layout/inspector/InspectorUtils.cpp
+++ b/layout/inspector/InspectorUtils.cpp
@@ -12,21 +12,16 @@
 #include "gfxTextRun.h"
 #include "nsArray.h"
 #include "nsAutoPtr.h"
 #include "nsIServiceManager.h"
 #include "nsString.h"
 #include "nsIStyleSheetLinkingElement.h"
 #include "nsIContentInlines.h"
 #include "mozilla/dom/Document.h"
-#ifdef MOZ_XBL
-#  include "nsXBLBinding.h"
-#  include "nsBindingManager.h"
-#  include "nsXBLPrototypeBinding.h"
-#endif
 #include "nsIMutableArray.h"
 #include "ChildIterator.h"
 #include "nsComputedDOMStyle.h"
 #include "mozilla/EventStateManager.h"
 #include "nsAtom.h"
 #include "nsPresContext.h"
 #include "nsRange.h"
 #include "mozilla/PresShell.h"
@@ -519,28 +514,16 @@ void InspectorUtils::ColorToRGBA(GlobalO
 bool InspectorUtils::IsValidCSSColor(GlobalObject& aGlobalObject,
                                      const nsAString& aColorString) {
   return ServoCSSParser::IsValidCSSColor(aColorString);
 }
 
 void InspectorUtils::GetBindingURLs(GlobalObject& aGlobalObject,
                                     Element& aElement,
                                     nsTArray<nsString>& aResult) {
-#ifdef MOZ_XBL
-  nsXBLBinding* binding = aElement.GetXBLBinding();
-
-  while (binding) {
-    nsCString spec;
-    nsCOMPtr<nsIURI> bindingURI = binding->PrototypeBinding()->BindingURI();
-    bindingURI->GetSpec(spec);
-    nsString* resultURI = aResult.AppendElement();
-    CopyASCIItoUTF16(spec, *resultURI);
-    binding = binding->GetBaseBinding();
-  }
-#endif
 }
 
 /* static */
 bool InspectorUtils::SetContentState(GlobalObject& aGlobalObject,
                                      Element& aElement, uint64_t aState,
                                      ErrorResult& aRv) {
   RefPtr<EventStateManager> esm =
       inLayoutUtils::GetEventStateManagerFor(aElement);
diff --git a/layout/style/ServoBindingTypes.h b/layout/style/ServoBindingTypes.h
--- a/layout/style/ServoBindingTypes.h
+++ b/layout/style/ServoBindingTypes.h
@@ -112,19 +112,16 @@
 #define SERVO_ARC_TYPE(name_, type_) struct type_;
 #include "mozilla/ServoArcTypeList.h"
 #undef SERVO_ARC_TYPE
 
 class nsCSSPropertyIDSet;
 class nsCSSValue;
 class nsINode;
 class nsPresContext;
-#ifdef MOZ_XBL
-class nsXBLBinding;
-#endif
 struct nsFontFaceRuleContainer;
 struct nsTimingFunction;
 
 namespace mozilla {
 class ComputedStyle;
 class ServoElementSnapshot;
 struct AnimationPropertySegment;
 struct ComputedTiming;
diff --git a/layout/svg/SVGObserverUtils.cpp b/layout/svg/SVGObserverUtils.cpp
--- a/layout/svg/SVGObserverUtils.cpp
+++ b/layout/svg/SVGObserverUtils.cpp
@@ -1687,28 +1687,19 @@ already_AddRefed<nsIURI> SVGObserverUtil
   // URL was specified somewhere in the document with the <use> element, and
   // we want the fragment-only URL to resolve to an element in that document.
   if (SVGUseElement* use = content->GetContainingSVGUseShadowHost()) {
     originalURI = use->GetSourceDocURI();
   } else if (content->IsInAnonymousSubtree()) {
     nsIContent* bindingParent = content->GetBindingParent();
 
     if (bindingParent) {
-#ifdef MOZ_XBL
-      nsXBLBinding* binding = bindingParent->GetXBLBinding();
-      if (binding) {
-        originalURI = binding->GetSourceDocURI();
-      } else {
-#endif
         MOZ_ASSERT(content->IsInNativeAnonymousSubtree(),
                    "a non-native anonymous tree which is not from "
                    "an XBL binding?");
-#ifdef MOZ_XBL
-      }
-#endif
     }
   }
 
   if (originalURI) {
     bool isEqualsExceptRef = false;
     aDocURI->EqualsExceptRef(originalURI, &isEqualsExceptRef);
     if (isEqualsExceptRef) {
       return originalURI.forget();
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -15,19 +15,16 @@
 #include "nsCSSRendering.h"
 #include "nsNameSpaceManager.h"
 #include "nsMenuPopupFrame.h"
 #include "nsMenuBarFrame.h"
 #include "mozilla/dom/Document.h"
 #include "nsIComponentManager.h"
 #include "nsBoxLayoutState.h"
 #include "nsIScrollableFrame.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsIServiceManager.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsIStringBundle.h"
 #include "nsContentUtils.h"
 #include "nsDisplayList.h"
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -28,19 +28,16 @@
 #include "nsIDocShell.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsContentUtils.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsPIWindowRoot.h"
 #include "nsIReflowCallback.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsIDocShellTreeOwner.h"
 #include "nsIBaseWindow.h"
 #include "nsISound.h"
 #include "nsIScreenManager.h"
 #include "nsIServiceManager.h"
 #include "nsStyleConsts.h"
 #include "nsTransitionManager.h"
 #include "nsDisplayList.h"
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -31,19 +31,16 @@
 #include "nsDisplayList.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/MouseEvent.h"
 #include "mozilla/MouseEvents.h"
 #include "mozilla/PresShell.h"
 #include "mozilla/UniquePtr.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 
 using namespace mozilla;
 
 using mozilla::dom::Event;
 
 class nsSplitterInfo {
  public:
   nscoord min;
diff --git a/layout/xul/nsXULPopupManager.cpp b/layout/xul/nsXULPopupManager.cpp
--- a/layout/xul/nsXULPopupManager.cpp
+++ b/layout/xul/nsXULPopupManager.cpp
@@ -9,19 +9,16 @@
 #include "nsMenuFrame.h"
 #include "nsMenuPopupFrame.h"
 #include "nsMenuBarFrame.h"
 #include "nsMenuBarListener.h"
 #include "nsContentUtils.h"
 #include "nsXULElement.h"
 #include "nsIDOMXULMenuListElement.h"
 #include "nsIDOMXULCommandDispatcher.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#endif
 #include "nsCSSFrameConstructor.h"
 #include "nsGlobalWindow.h"
 #include "nsIContentInlines.h"
 #include "nsLayoutUtils.h"
 #include "nsViewManager.h"
 #include "nsIComponentManager.h"
 #include "nsITimer.h"
 #include "nsFocusManager.h"
@@ -2237,23 +2234,17 @@ bool nsXULPopupManager::HandleKeyboardEv
 // GetPrimaryFrame() on the items... Do we have anonymous / fallback menu items
 // that could be selectable?
 static nsIContent* FindDefaultInsertionPoint(nsIContent* aParent) {
   if (ShadowRoot* shadow = aParent->GetShadowRoot()) {
     if (HTMLSlotElement* slot = shadow->GetDefaultSlot()) {
       return slot;
     }
   }
-#ifdef MOZ_XBL
-  bool multiple = false;  // Unused
-  return aParent->OwnerDoc()->BindingManager()->FindNestedSingleInsertionPoint(
-      aParent, &multiple);
-#else
   return aParent;
-#endif
 }
 
 nsContainerFrame* nsXULPopupManager::ImmediateParentFrame(
     nsContainerFrame* aFrame) {
   MOZ_ASSERT(aFrame && aFrame->GetContent());
   nsIContent* insertionPoint = FindDefaultInsertionPoint(aFrame->GetContent());
 
   nsCSSFrameConstructor* fc = aFrame->PresContext()->FrameConstructor();
diff --git a/parser/html/nsHtml5TreeOperation.cpp b/parser/html/nsHtml5TreeOperation.cpp
--- a/parser/html/nsHtml5TreeOperation.cpp
+++ b/parser/html/nsHtml5TreeOperation.cpp
@@ -33,20 +33,16 @@
 #include "nsIScriptElement.h"
 #include "nsIServiceManager.h"
 #include "nsIStyleSheetLinkingElement.h"
 #include "nsISupportsImpl.h"
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 #include "nsNodeUtils.h"
 #include "nsTextNode.h"
-#ifdef MOZ_XBL
-#  include "nsBindingManager.h"
-#  include "nsXBLBinding.h"
-#endif
 
 using namespace mozilla;
 using mozilla::dom::Document;
 
 /**
  * Helper class that opens a notification batch if the current doc
  * is different from the executor doc.
  */
diff --git a/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp b/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp
--- a/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp
+++ b/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp
@@ -49,19 +49,16 @@
 #include "nsFocusManager.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/HTMLInputElement.h"
 #include "mozilla/dom/HTMLTextAreaElement.h"
 #include "mozilla/dom/Link.h"
 #include "mozilla/dom/RangeBinding.h"
 #include "mozilla/dom/Selection.h"
 #include "nsRange.h"
-#ifdef MOZ_XBL
-#  include "nsXBLBinding.h"
-#endif
 
 #include "nsTypeAheadFind.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsTypeAheadFind)
   NS_INTERFACE_MAP_ENTRY(nsITypeAheadFind)
@@ -780,30 +777,16 @@ nsresult nsTypeAheadFind::GetSearchConta
     }
   }
 
   if (!mSearchRange) {
     mSearchRange = new nsRange(doc);
   }
   nsCOMPtr<nsINode> searchRootNode(rootContent);
 
-#ifdef MOZ_XBL
-  // Hack for XMLPrettyPrinter. nsFind can't handle complex anonymous content.
-  // If the root node has an XBL binding then there's not much we can do in
-  // in general, but we can try searching the binding's first child, which
-  // in the case of XMLPrettyPrinter contains the visible pretty-printed
-  // content.
-  nsXBLBinding* binding = rootContent->GetXBLBinding();
-  if (binding) {
-    nsIContent* anonContent = binding->GetAnonymousContent();
-    if (anonContent) {
-      searchRootNode = anonContent->GetFirstChild();
-    }
-  }
-#endif
   mSearchRange->SelectNodeContents(*searchRootNode, IgnoreErrors());
 
   if (!mStartPointRange) {
     mStartPointRange = new nsRange(doc);
   }
   mStartPointRange->SetStart(*searchRootNode, 0, IgnoreErrors());
   mStartPointRange->Collapse(true);  // collapse to start
 
