# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1555706466 25200
#      Fri Apr 19 13:41:06 2019 -0700
# Node ID e653ec19b4b4c668f921867baf330f7ac16c0c9a
# Parent  0b1de782bd32ee277ad609c2bbe7e35b8a003ee7
Bug 1545765 - Fix attribute inheritance for empty attribute values

This accidentally got dropped in Bug 1528268.

Differential Revision: https://phabricator.services.mozilla.com/D28251

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -276,17 +276,17 @@ MozElements.MozElementMixin = Base => {
    */
   attributeChangedCallback(name, oldValue, newValue) {
     if (oldValue === newValue || !this.initializedAttributeInheritance) {
       return;
     }
 
     let list = this.constructor.flippedInheritedAttributes[name];
     if (list) {
-      this.inheritAttribute(list, newValue);
+      this.inheritAttribute(list, name);
     }
   }
 
   /*
   * After setting content, calling this will cache the elements from selectors in the
   * static `inheritedAttributes` Object. It'll also do an initial call to `this.inheritAttributes()`,
   * so in the simple case, this is the only function you need to call.
   *
@@ -301,52 +301,54 @@ MozElements.MozElementMixin = Base => {
   initializeAttributeInheritance() {
     let {flippedInheritedAttributes} = this.constructor;
     if (!flippedInheritedAttributes) {
       return;
     }
 
     this.initializedAttributeInheritance = true;
     for (let attr in flippedInheritedAttributes) {
-      let value = this.getAttribute(attr);
-      if (value) {
-        this.inheritAttribute(flippedInheritedAttributes[attr], value);
+      if (this.hasAttribute(attr)) {
+        this.inheritAttribute(flippedInheritedAttributes[attr], attr);
       }
     }
   }
 
   /*
    * Implements attribute value inheritance by child elements.
    *
    * @param {array} list
    *        An array of (to-element-selector, to-attr) pairs.
-   * @param {string} value
-   *        An attribute value to propagate.
+   * @param {string} attr
+   *        An attribute to propagate.
    */
-  inheritAttribute(list, value) {
+  inheritAttribute(list, attr) {
     if (!this._inheritedElements) {
       this._inheritedElements = {};
     }
 
-    for (let [selector, attr] of list) {
+    let hasAttr = this.hasAttribute(attr);
+    let attrValue = this.getAttribute(attr);
+
+    for (let [selector, newAttr] of list) {
       if (!(selector in this._inheritedElements)) {
         let parent = this.shadowRoot || this;
         this._inheritedElements[selector] = parent.querySelector(selector);
       }
       let el = this._inheritedElements[selector];
       if (el) {
-        if (attr == "text") {
-          el.textContent = value;
-        } else if (value) {
-          el.setAttribute(attr, value);
+        if (newAttr == "text") {
+          el.textContent = hasAttr ? attrValue : "";
+        } else if (hasAttr) {
+          el.setAttribute(newAttr, attrValue);
         } else {
-          el.removeAttribute(attr);
+          el.removeAttribute(newAttr);
         }
 
-        if (attr == "accesskey" && el.formatAccessKey) {
+        if (newAttr == "accesskey" && el.formatAccessKey) {
           el.formatAccessKey(false);
         }
       }
     }
   }
 
   /**
    * Sometimes an element may not want to run connectedCallback logic during
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -11,20 +11,20 @@
 
   <!-- test results are displayed in the html:body -->
   <body xmlns="http://www.w3.org/1999/xhtml" style="height: 300px; overflow: auto;"/>
 
   <button id="one"/>
   <simpleelement id="two" style="-moz-user-focus: normal;"/>
   <simpleelement id="three" disabled="true" style="-moz-user-focus: normal;"/>
   <button id="four"/>
-  <inherited-element-declarative foo="fuagra"></inherited-element-declarative>
-  <inherited-element-shadowdom-declarative foo="fuagra"></inherited-element-shadowdom-declarative>
-  <inherited-element-imperative foo="fuagra"></inherited-element-imperative>
-  <inherited-element-beforedomloaded foo="fuagra"></inherited-element-beforedomloaded>
+  <inherited-element-declarative foo="fuagra" empty-string=""></inherited-element-declarative>
+  <inherited-element-shadowdom-declarative foo="fuagra" empty-string=""></inherited-element-shadowdom-declarative>
+  <inherited-element-imperative foo="fuagra" empty-string=""></inherited-element-imperative>
+  <inherited-element-beforedomloaded foo="fuagra" empty-string=""></inherited-element-beforedomloaded>
 
   <!-- test code running before page load goes here -->
   <script type="application/javascript"><![CDATA[
     class InheritAttrsChangeBeforDOMLoaded extends MozXULElement {
       static get inheritedAttributes() {
         return {
           "label": "foo",
         };
@@ -121,17 +121,17 @@
     let boxWithNonWhitespaceText = MozXULElement.parseXULToFragment(`<box>foo</box>`).querySelector("box");
     is(boxWithNonWhitespaceText.textContent, "foo", "Non-whitespace not removed");
   }
 
   function testInheritAttributes() {
     class InheritsElementDeclarative extends MozXULElement {
       static get inheritedAttributes() {
         return {
-          "label": "text=label,foo,boo,bardo=bar",
+          "label": "text=label,foo,empty-string,bardo=bar",
           "unmatched": "foo", // Make sure we don't throw on unmatched selectors
         };
       }
 
       connectedCallback() {
         this.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.querySelector("label");
         this.initializeAttributeInheritance();
@@ -139,17 +139,17 @@
     }
     customElements.define("inherited-element-declarative", InheritsElementDeclarative);
     let declarativeEl = document.querySelector("inherited-element-declarative");
     ok(declarativeEl, "declarative inheritance element exists");
 
     class InheritsElementShadowDOMDeclarative extends MozXULElement {
       static get inheritedAttributes() {
         return {
-          "label": "text=label,foo,boo,bardo=bar",
+          "label": "text=label,foo,empty-string,bardo=bar",
           "unmatched": "foo", // Make sure we don't throw on unmatched selectors
         };
       }
 
       connectedCallback() {
         this.attachShadow({ mode: "open" });
         this.shadowRoot.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.shadowRoot.querySelector("label");
@@ -157,34 +157,34 @@
       }
     }
     customElements.define("inherited-element-shadowdom-declarative", InheritsElementShadowDOMDeclarative);
     let shadowDOMDeclarativeEl = document.querySelector("inherited-element-shadowdom-declarative");
     ok(shadowDOMDeclarativeEl, "declarative inheritance element with shadow DOM exists");
 
     class InheritsElementImperative extends MozXULElement {
       static get observedAttributes() {
-        return [ "label", "foo", "boo", "bar" ];
+        return [ "label", "foo", "empty-string", "bar" ];
       }
 
       attributeChangedCallback(name, oldValue, newValue) {
         if (this.label && oldValue != newValue) {
           this.inherit();
         }
       }
 
       inherit() {
         let map = {
           "label": [[ "label", "text" ]],
           "foo": [[ "label", "foo" ]],
-          "boo": [[ "label", "boo" ]],
+          "empty-string": [[ "label", "empty-string" ]],
           "bar": [[ "label", "bardo" ]],
         };
         for (let attr of InheritsElementImperative.observedAttributes) {
-          this.inheritAttribute(map[attr], this.getAttribute(attr));
+          this.inheritAttribute(map[attr], attr);
         }
       }
 
       connectedCallback() {
         this.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.querySelector("label");
         this.inherit();
       }
@@ -192,23 +192,23 @@
 
     customElements.define("inherited-element-imperative", InheritsElementImperative);
     let imperativeEl = document.querySelector("inherited-element-imperative");
     ok(imperativeEl, "imperative inheritance element exists");
 
     for (let el of [declarativeEl, shadowDOMDeclarativeEl, imperativeEl]) {
       info(`Running checks for ${el.tagName}`);
       is(el.label.getAttribute("foo"), "fuagra", "predefined attribute @foo");
-      ok(!el.label.hasAttribute("boo"), "predefined attribute @boo");
+      ok(el.label.hasAttribute("empty-string"), "predefined attribute @empty-string");
       ok(!el.label.hasAttribute("bardo"), "predefined attribute @bardo");
       ok(!el.label.textContent, "predefined attribute @label");
 
-      el.setAttribute("boo", "boo-test");
-      is(el.label.getAttribute("boo"), "boo-test",
-        "attribute inheritance: boo");
+      el.setAttribute("empty-string", "not-empty-anymore");
+      is(el.label.getAttribute("empty-string"), "not-empty-anymore",
+        "attribute inheritance: empty-string");
 
       el.setAttribute("label", "label-test");
       is(el.label.textContent, "label-test",
         "attribute inheritance: text=label attribute change");
 
       el.setAttribute("bar", "bar-test");
       is(el.label.getAttribute("bardo"), "bar-test",
         "attribute inheritance: `=` mapping");
