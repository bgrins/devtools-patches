# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  73ed6d27ec6d6cc3d6523921aef890ec96b3d6de
Bug 1217591 - Make JS autocompletion in the console work inside of a worker toolbox;r=vporof

diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js b/devtools/client/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
@@ -12,17 +12,17 @@ function test() {
   requestLongerTimeout(6);
 
   loadTab(TEST_URI).then(() => {
     openConsole().then(consoleOpened);
   });
 }
 
 function consoleOpened(HUD) {
-  let {JSPropertyProvider} = require("devtools/shared/webconsole/utils");
+  let {JSPropertyProvider} = require("devtools/shared/webconsole/js-property-provider");
 
   let tmp = Cu.import("resource://gre/modules/jsdebugger.jsm", {});
   tmp.addDebuggerToGlobal(tmp);
   let dbg = new tmp.Debugger();
 
   let jsterm = HUD.jsterm;
   let win = content.wrappedJSObject;
   let dbgWindow = dbg.makeGlobalObjectReference(win);
diff --git a/devtools/client/webconsole/test/browser_webconsole_property_provider.js b/devtools/client/webconsole/test/browser_webconsole_property_provider.js
--- a/devtools/client/webconsole/test/browser_webconsole_property_provider.js
+++ b/devtools/client/webconsole/test/browser_webconsole_property_provider.js
@@ -11,17 +11,17 @@
 const TEST_URI = "data:text/html;charset=utf8,<p>test the JS property provider";
 
 function test() {
   loadTab(TEST_URI).then(testPropertyProvider);
 }
 
 function testPropertyProvider({browser}) {
   browser.removeEventListener("load", testPropertyProvider, true);
-  let {JSPropertyProvider} = require("devtools/shared/webconsole/utils");
+  let {JSPropertyProvider} = require("devtools/shared/webconsole/js-property-provider");
 
   let tmp = Cu.import("resource://gre/modules/jsdebugger.jsm", {});
   tmp.addDebuggerToGlobal(tmp);
   let dbg = new tmp.Debugger();
   let dbgWindow = dbg.makeGlobalObjectReference(content);
 
   let completion = JSPropertyProvider(dbgWindow, null, "thisIsNotDefined");
   is(completion.matches.length, 0, "no match for 'thisIsNotDefined");
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -13,19 +13,20 @@ const { EnvironmentActor, ThreadActor } 
 const { ObjectActor, LongStringActor, createValueGrip, stringIsLong } = require("devtools/server/actors/object");
 const DevToolsUtils = require("devtools/shared/DevToolsUtils");
 
 loader.lazyRequireGetter(this, "NetworkMonitor", "devtools/shared/webconsole/network-monitor", true);
 loader.lazyRequireGetter(this, "NetworkMonitorChild", "devtools/shared/webconsole/network-monitor", true);
 loader.lazyRequireGetter(this, "ConsoleProgressListener", "devtools/shared/webconsole/network-monitor", true);
 loader.lazyRequireGetter(this, "events", "sdk/event/core");
 loader.lazyRequireGetter(this, "ServerLoggingListener", "devtools/shared/webconsole/server-logger", true);
+loader.lazyRequireGetter(this, "JSPropertyProvider", "devtools/shared/webconsole/js-property-provider", true);
 
 for (let name of ["WebConsoleUtils", "ConsoleServiceListener",
-    "ConsoleAPIListener", "addWebConsoleCommands", "JSPropertyProvider",
+    "ConsoleAPIListener", "addWebConsoleCommands",
     "ConsoleReflowListener", "CONSOLE_WORKER_IDS"]) {
   Object.defineProperty(this, name, {
     get: function(prop) {
       if (prop == "WebConsoleUtils") {
         prop = "Utils";
       }
       if (isWorker) {
         return require("devtools/shared/webconsole/worker-utils")[prop];
diff --git a/devtools/shared/webconsole/js-property-provider.js b/devtools/shared/webconsole/js-property-provider.js
new file mode 100644
--- /dev/null
+++ b/devtools/shared/webconsole/js-property-provider.js
@@ -0,0 +1,385 @@
+
+const {Cc, Ci, Cu, components} = require("chrome");
+const DevToolsUtils = require("devtools/shared/DevToolsUtils");
+
+/**
+ * Provides a list of properties, that are possible matches based on the passed
+ * Debugger.Environment/Debugger.Object and inputValue.
+ *
+ * @param object aDbgObject
+ *        When the debugger is not paused this Debugger.Object wraps the scope for autocompletion.
+ *        It is null if the debugger is paused.
+ * @param object anEnvironment
+ *        When the debugger is paused this Debugger.Environment is the scope for autocompletion.
+ *        It is null if the debugger is not paused.
+ * @param string aInputValue
+ *        Value that should be completed.
+ * @param number [aCursor=aInputValue.length]
+ *        Optional offset in the input where the cursor is located. If this is
+ *        omitted then the cursor is assumed to be at the end of the input
+ *        value.
+ * @returns null or object
+ *          If no completion valued could be computed, null is returned,
+ *          otherwise a object with the following form is returned:
+ *            {
+ *              matches: [ string, string, string ],
+ *              matchProp: Last part of the inputValue that was used to find
+ *                         the matches-strings.
+ *            }
+ */
+function JSPropertyProvider(aDbgObject, anEnvironment, aInputValue, aCursor)
+{
+  if (aCursor === undefined) {
+    aCursor = aInputValue.length;
+  }
+
+  let inputValue = aInputValue.substring(0, aCursor);
+
+  // Analyse the inputValue and find the beginning of the last part that
+  // should be completed.
+  let beginning = findCompletionBeginning(inputValue);
+
+  // There was an error analysing the string.
+  if (beginning.err) {
+    return null;
+  }
+
+  // If the current state is not STATE_NORMAL, then we are inside of an string
+  // which means that no completion is possible.
+  if (beginning.state != STATE_NORMAL) {
+    return null;
+  }
+
+  let completionPart = inputValue.substring(beginning.startPos);
+  let lastDot = completionPart.lastIndexOf(".");
+
+  // Don't complete on just an empty string.
+  if (completionPart.trim() == "") {
+    return null;
+  }
+
+  // Catch literals like [1,2,3] or "foo" and return the matches from
+  // their prototypes.
+  if (lastDot > 0) {
+    let parser = new Parser();
+    parser.logExceptions = false;
+    let syntaxTree = parser.get(completionPart.slice(0, lastDot));
+    let lastTree = syntaxTree.getLastSyntaxTree();
+    let lastBody = lastTree && lastTree.AST.body[lastTree.AST.body.length - 1];
+
+    // Finding the last expression since we've sliced up until the dot.
+    // If there were parse errors this won't exist.
+    if (lastBody) {
+      let expression = lastBody.expression;
+      let matchProp = completionPart.slice(lastDot + 1);
+      if (expression.type === "ArrayExpression") {
+        return getMatchedProps(Array.prototype, matchProp);
+      } else if (expression.type === "Literal" &&
+                 (typeof expression.value === "string")) {
+        return getMatchedProps(String.prototype, matchProp);
+      }
+    }
+  }
+
+  // We are completing a variable / a property lookup.
+  let properties = completionPart.split(".");
+  let matchProp = properties.pop().trimLeft();
+  let obj = aDbgObject;
+
+  // The first property must be found in the environment if the debugger is
+  // paused.
+  if (anEnvironment) {
+    if (properties.length == 0) {
+      return getMatchedPropsInEnvironment(anEnvironment, matchProp);
+    }
+    obj = getVariableInEnvironment(anEnvironment, properties.shift());
+  }
+
+  if (!isObjectUsable(obj)) {
+    return null;
+  }
+
+  // We get the rest of the properties recursively starting from the Debugger.Object
+  // that wraps the first property
+  for (let prop of properties) {
+    prop = prop.trim();
+    if (!prop) {
+      return null;
+    }
+
+    if (/\[\d+\]$/.test(prop)) {
+      // The property to autocomplete is a member of array. For example
+      // list[i][j]..[n]. Traverse the array to get the actual element.
+      obj = getArrayMemberProperty(obj, prop);
+    }
+    else {
+      obj = DevToolsUtils.getProperty(obj, prop);
+    }
+
+    if (!isObjectUsable(obj)) {
+      return null;
+    }
+  }
+
+  // If the final property is a primitive
+  if (typeof obj != "object") {
+    return getMatchedProps(obj, matchProp);
+  }
+
+  return getMatchedPropsInDbgObject(obj, matchProp);
+}
+
+/**
+ * Get the array member of aObj for the given aProp. For example, given
+ * aProp='list[0][1]' the element at [0][1] of aObj.list is returned.
+ *
+ * @param object aObj
+ *        The object to operate on.
+ * @param string aProp
+ *        The property to return.
+ * @return null or Object
+ *         Returns null if the property couldn't be located. Otherwise the array
+ *         member identified by aProp.
+ */
+function getArrayMemberProperty(aObj, aProp)
+{
+  // First get the array.
+  let obj = aObj;
+  let propWithoutIndices = aProp.substr(0, aProp.indexOf("["));
+  obj = DevToolsUtils.getProperty(obj, propWithoutIndices);
+  if (!isObjectUsable(obj)) {
+    return null;
+  }
+
+  // Then traverse the list of indices to get the actual element.
+  let result;
+  let arrayIndicesRegex = /\[[^\]]*\]/g;
+  while ((result = arrayIndicesRegex.exec(aProp)) !== null) {
+    let indexWithBrackets = result[0];
+    let indexAsText = indexWithBrackets.substr(1, indexWithBrackets.length - 2);
+    let index = parseInt(indexAsText);
+
+    if (isNaN(index)) {
+      return null;
+    }
+
+    obj = DevToolsUtils.getProperty(obj, index);
+
+    if (!isObjectUsable(obj)) {
+      return null;
+    }
+  }
+
+  return obj;
+}
+
+/**
+ * Check if the given Debugger.Object can be used for autocomplete.
+ *
+ * @param Debugger.Object aObject
+ *        The Debugger.Object to check.
+ * @return boolean
+ *         True if further inspection into the object is possible, or false
+ *         otherwise.
+ */
+function isObjectUsable(aObject)
+{
+  if (aObject == null) {
+    return false;
+  }
+
+  if (typeof aObject == "object" && aObject.class == "DeadObject") {
+    return false;
+  }
+
+  return true;
+}
+
+/**
+ * @see getExactMatch_impl()
+ */
+function getVariableInEnvironment(anEnvironment, aName)
+{
+  return getExactMatch_impl(anEnvironment, aName, DebuggerEnvironmentSupport);
+}
+
+/**
+ * @see getMatchedProps_impl()
+ */
+function getMatchedPropsInEnvironment(anEnvironment, aMatch)
+{
+  return getMatchedProps_impl(anEnvironment, aMatch, DebuggerEnvironmentSupport);
+}
+
+/**
+ * @see getMatchedProps_impl()
+ */
+function getMatchedPropsInDbgObject(aDbgObject, aMatch)
+{
+  return getMatchedProps_impl(aDbgObject, aMatch, DebuggerObjectSupport);
+}
+
+/**
+ * @see getMatchedProps_impl()
+ */
+function getMatchedProps(aObj, aMatch)
+{
+  if (typeof aObj != "object") {
+    aObj = aObj.constructor.prototype;
+  }
+  return getMatchedProps_impl(aObj, aMatch, JSObjectSupport);
+}
+
+/**
+ * Get all properties in the given object (and its parent prototype chain) that
+ * match a given prefix.
+ *
+ * @param mixed aObj
+ *        Object whose properties we want to filter.
+ * @param string aMatch
+ *        Filter for properties that match this string.
+ * @return object
+ *         Object that contains the matchProp and the list of names.
+ */
+function getMatchedProps_impl(aObj, aMatch, {chainIterator, getProperties})
+{
+  let matches = new Set();
+  let numProps = 0;
+
+  // We need to go up the prototype chain.
+  let iter = chainIterator(aObj);
+  for (let obj of iter) {
+    let props = getProperties(obj);
+    numProps += props.length;
+
+    // If there are too many properties to event attempt autocompletion,
+    // or if we have already added the max number, then stop looping
+    // and return the partial set that has already been discovered.
+    if (numProps >= MAX_AUTOCOMPLETE_ATTEMPTS ||
+        matches.size >= MAX_AUTOCOMPLETIONS) {
+      break;
+    }
+
+    for (let i = 0; i < props.length; i++) {
+      let prop = props[i];
+      if (prop.indexOf(aMatch) != 0) {
+        continue;
+      }
+      if (prop.indexOf('-') > -1) {
+        continue;
+      }
+      // If it is an array index, we can't take it.
+      // This uses a trick: converting a string to a number yields NaN if
+      // the operation failed, and NaN is not equal to itself.
+      if (+prop != +prop) {
+        matches.add(prop);
+      }
+
+      if (matches.size >= MAX_AUTOCOMPLETIONS) {
+        break;
+      }
+    }
+  }
+
+  return {
+    matchProp: aMatch,
+    matches: [...matches],
+  };
+}
+
+/**
+ * Returns a property value based on its name from the given object, by
+ * recursively checking the object's prototype.
+ *
+ * @param object aObj
+ *        An object to look the property into.
+ * @param string aName
+ *        The property that is looked up.
+ * @returns object|undefined
+ *        A Debugger.Object if the property exists in the object's prototype
+ *        chain, undefined otherwise.
+ */
+function getExactMatch_impl(aObj, aName, {chainIterator, getProperty})
+{
+  // We need to go up the prototype chain.
+  let iter = chainIterator(aObj);
+  for (let obj of iter) {
+    let prop = getProperty(obj, aName, aObj);
+    if (prop) {
+      return prop.value;
+    }
+  }
+  return undefined;
+}
+
+
+var JSObjectSupport = {
+  chainIterator: function*(aObj)
+  {
+    while (aObj) {
+      yield aObj;
+      aObj = Object.getPrototypeOf(aObj);
+    }
+  },
+
+  getProperties: function(aObj)
+  {
+    return Object.getOwnPropertyNames(aObj);
+  },
+
+  getProperty: function()
+  {
+    // getProperty is unsafe with raw JS objects.
+    throw "Unimplemented!";
+  },
+};
+
+var DebuggerObjectSupport = {
+  chainIterator: function*(aObj)
+  {
+    while (aObj) {
+      yield aObj;
+      aObj = aObj.proto;
+    }
+  },
+
+  getProperties: function(aObj)
+  {
+    return aObj.getOwnPropertyNames();
+  },
+
+  getProperty: function(aObj, aName, aRootObj)
+  {
+    // This is left unimplemented in favor to DevToolsUtils.getProperty().
+    throw "Unimplemented!";
+  },
+};
+
+var DebuggerEnvironmentSupport = {
+  chainIterator: function*(aObj)
+  {
+    while (aObj) {
+      yield aObj;
+      aObj = aObj.parent;
+    }
+  },
+
+  getProperties: function(aObj)
+  {
+    return aObj.names();
+  },
+
+  getProperty: function(aObj, aName)
+  {
+    // TODO: we should use getVariableDescriptor() here - bug 725815.
+    let result = aObj.getVariable(aName);
+    // FIXME: Need actual UI, bug 941287.
+    if (result === undefined || result.optimizedOut || result.missingArguments) {
+      return null;
+    }
+    return { value: result };
+  },
+};
+
+
+exports.JSPropertyProvider = DevToolsUtils.makeInfallible(JSPropertyProvider);
\ No newline at end of file
diff --git a/devtools/shared/webconsole/moz.build b/devtools/shared/webconsole/moz.build
--- a/devtools/shared/webconsole/moz.build
+++ b/devtools/shared/webconsole/moz.build
@@ -5,15 +5,16 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 if CONFIG['OS_TARGET'] != 'Android':
     MOCHITEST_CHROME_MANIFESTS += ['test/chrome.ini']
     XPCSHELL_TESTS_MANIFESTS += ['test/unit/xpcshell.ini']
 
 DevToolsModules(
     'client.js',
+    'js-property-provider.js',
     'network-helper.js',
     'network-monitor.js',
     'server-logger-monitor.js',
     'server-logger.js',
     'utils.js',
     'worker-utils.js',
 )
diff --git a/devtools/shared/webconsole/test/unit/test_js_property_provider.js b/devtools/shared/webconsole/test/unit/test_js_property_provider.js
--- a/devtools/shared/webconsole/test/unit/test_js_property_provider.js
+++ b/devtools/shared/webconsole/test/unit/test_js_property_provider.js
@@ -1,15 +1,15 @@
 /* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
 // Any copyright is dedicated to the Public Domain.
 // http://creativecommons.org/publicdomain/zero/1.0/
 
 "use strict";
 const { require } = Components.utils.import("resource://devtools/shared/Loader.jsm", {});
-const { JSPropertyProvider } = require("devtools/shared/webconsole/utils");
+const { JSPropertyProvider } = require("devtools/shared/webconsole/js-property-provider");
 
 Components.utils.import("resource://gre/modules/jsdebugger.jsm");
 addDebuggerToGlobal(this);
 
 function run_test() {
   const testArray = 'var testArray = [\
     {propA: "A"},\
     {\
diff --git a/devtools/shared/webconsole/utils.js b/devtools/shared/webconsole/utils.js
--- a/devtools/shared/webconsole/utils.js
+++ b/devtools/shared/webconsole/utils.js
@@ -807,398 +807,16 @@ function findCompletionBeginning(aStr)
     }
   }
 
   return {
     state: state,
     startPos: start
   };
 }
-
-/**
- * Provides a list of properties, that are possible matches based on the passed
- * Debugger.Environment/Debugger.Object and inputValue.
- *
- * @param object aDbgObject
- *        When the debugger is not paused this Debugger.Object wraps the scope for autocompletion.
- *        It is null if the debugger is paused.
- * @param object anEnvironment
- *        When the debugger is paused this Debugger.Environment is the scope for autocompletion.
- *        It is null if the debugger is not paused.
- * @param string aInputValue
- *        Value that should be completed.
- * @param number [aCursor=aInputValue.length]
- *        Optional offset in the input where the cursor is located. If this is
- *        omitted then the cursor is assumed to be at the end of the input
- *        value.
- * @returns null or object
- *          If no completion valued could be computed, null is returned,
- *          otherwise a object with the following form is returned:
- *            {
- *              matches: [ string, string, string ],
- *              matchProp: Last part of the inputValue that was used to find
- *                         the matches-strings.
- *            }
- */
-function JSPropertyProvider(aDbgObject, anEnvironment, aInputValue, aCursor)
-{
-  if (aCursor === undefined) {
-    aCursor = aInputValue.length;
-  }
-
-  let inputValue = aInputValue.substring(0, aCursor);
-
-  // Analyse the inputValue and find the beginning of the last part that
-  // should be completed.
-  let beginning = findCompletionBeginning(inputValue);
-
-  // There was an error analysing the string.
-  if (beginning.err) {
-    return null;
-  }
-
-  // If the current state is not STATE_NORMAL, then we are inside of an string
-  // which means that no completion is possible.
-  if (beginning.state != STATE_NORMAL) {
-    return null;
-  }
-
-  let completionPart = inputValue.substring(beginning.startPos);
-  let lastDot = completionPart.lastIndexOf(".");
-
-  // Don't complete on just an empty string.
-  if (completionPart.trim() == "") {
-    return null;
-  }
-
-  // Catch literals like [1,2,3] or "foo" and return the matches from
-  // their prototypes.
-  if (lastDot > 0) {
-    let parser = new Parser();
-    parser.logExceptions = false;
-    let syntaxTree = parser.get(completionPart.slice(0, lastDot));
-    let lastTree = syntaxTree.getLastSyntaxTree();
-    let lastBody = lastTree && lastTree.AST.body[lastTree.AST.body.length - 1];
-
-    // Finding the last expression since we've sliced up until the dot.
-    // If there were parse errors this won't exist.
-    if (lastBody) {
-      let expression = lastBody.expression;
-      let matchProp = completionPart.slice(lastDot + 1);
-      if (expression.type === "ArrayExpression") {
-        return getMatchedProps(Array.prototype, matchProp);
-      } else if (expression.type === "Literal" &&
-                 (typeof expression.value === "string")) {
-        return getMatchedProps(String.prototype, matchProp);
-      }
-    }
-  }
-
-  // We are completing a variable / a property lookup.
-  let properties = completionPart.split(".");
-  let matchProp = properties.pop().trimLeft();
-  let obj = aDbgObject;
-
-  // The first property must be found in the environment if the debugger is
-  // paused.
-  if (anEnvironment) {
-    if (properties.length == 0) {
-      return getMatchedPropsInEnvironment(anEnvironment, matchProp);
-    }
-    obj = getVariableInEnvironment(anEnvironment, properties.shift());
-  }
-
-  if (!isObjectUsable(obj)) {
-    return null;
-  }
-
-  // We get the rest of the properties recursively starting from the Debugger.Object
-  // that wraps the first property
-  for (let prop of properties) {
-    prop = prop.trim();
-    if (!prop) {
-      return null;
-    }
-
-    if (/\[\d+\]$/.test(prop)) {
-      // The property to autocomplete is a member of array. For example
-      // list[i][j]..[n]. Traverse the array to get the actual element.
-      obj = getArrayMemberProperty(obj, prop);
-    }
-    else {
-      obj = DevToolsUtils.getProperty(obj, prop);
-    }
-
-    if (!isObjectUsable(obj)) {
-      return null;
-    }
-  }
-
-  // If the final property is a primitive
-  if (typeof obj != "object") {
-    return getMatchedProps(obj, matchProp);
-  }
-
-  return getMatchedPropsInDbgObject(obj, matchProp);
-}
-
-/**
- * Get the array member of aObj for the given aProp. For example, given
- * aProp='list[0][1]' the element at [0][1] of aObj.list is returned.
- *
- * @param object aObj
- *        The object to operate on.
- * @param string aProp
- *        The property to return.
- * @return null or Object
- *         Returns null if the property couldn't be located. Otherwise the array
- *         member identified by aProp.
- */
-function getArrayMemberProperty(aObj, aProp)
-{
-  // First get the array.
-  let obj = aObj;
-  let propWithoutIndices = aProp.substr(0, aProp.indexOf("["));
-  obj = DevToolsUtils.getProperty(obj, propWithoutIndices);
-  if (!isObjectUsable(obj)) {
-    return null;
-  }
-
-  // Then traverse the list of indices to get the actual element.
-  let result;
-  let arrayIndicesRegex = /\[[^\]]*\]/g;
-  while ((result = arrayIndicesRegex.exec(aProp)) !== null) {
-    let indexWithBrackets = result[0];
-    let indexAsText = indexWithBrackets.substr(1, indexWithBrackets.length - 2);
-    let index = parseInt(indexAsText);
-
-    if (isNaN(index)) {
-      return null;
-    }
-
-    obj = DevToolsUtils.getProperty(obj, index);
-
-    if (!isObjectUsable(obj)) {
-      return null;
-    }
-  }
-
-  return obj;
-}
-
-/**
- * Check if the given Debugger.Object can be used for autocomplete.
- *
- * @param Debugger.Object aObject
- *        The Debugger.Object to check.
- * @return boolean
- *         True if further inspection into the object is possible, or false
- *         otherwise.
- */
-function isObjectUsable(aObject)
-{
-  if (aObject == null) {
-    return false;
-  }
-
-  if (typeof aObject == "object" && aObject.class == "DeadObject") {
-    return false;
-  }
-
-  return true;
-}
-
-/**
- * @see getExactMatch_impl()
- */
-function getVariableInEnvironment(anEnvironment, aName)
-{
-  return getExactMatch_impl(anEnvironment, aName, DebuggerEnvironmentSupport);
-}
-
-/**
- * @see getMatchedProps_impl()
- */
-function getMatchedPropsInEnvironment(anEnvironment, aMatch)
-{
-  return getMatchedProps_impl(anEnvironment, aMatch, DebuggerEnvironmentSupport);
-}
-
-/**
- * @see getMatchedProps_impl()
- */
-function getMatchedPropsInDbgObject(aDbgObject, aMatch)
-{
-  return getMatchedProps_impl(aDbgObject, aMatch, DebuggerObjectSupport);
-}
-
-/**
- * @see getMatchedProps_impl()
- */
-function getMatchedProps(aObj, aMatch)
-{
-  if (typeof aObj != "object") {
-    aObj = aObj.constructor.prototype;
-  }
-  return getMatchedProps_impl(aObj, aMatch, JSObjectSupport);
-}
-
-/**
- * Get all properties in the given object (and its parent prototype chain) that
- * match a given prefix.
- *
- * @param mixed aObj
- *        Object whose properties we want to filter.
- * @param string aMatch
- *        Filter for properties that match this string.
- * @return object
- *         Object that contains the matchProp and the list of names.
- */
-function getMatchedProps_impl(aObj, aMatch, {chainIterator, getProperties})
-{
-  let matches = new Set();
-  let numProps = 0;
-
-  // We need to go up the prototype chain.
-  let iter = chainIterator(aObj);
-  for (let obj of iter) {
-    let props = getProperties(obj);
-    numProps += props.length;
-
-    // If there are too many properties to event attempt autocompletion,
-    // or if we have already added the max number, then stop looping
-    // and return the partial set that has already been discovered.
-    if (numProps >= MAX_AUTOCOMPLETE_ATTEMPTS ||
-        matches.size >= MAX_AUTOCOMPLETIONS) {
-      break;
-    }
-
-    for (let i = 0; i < props.length; i++) {
-      let prop = props[i];
-      if (prop.indexOf(aMatch) != 0) {
-        continue;
-      }
-      if (prop.indexOf('-') > -1) {
-        continue;
-      }
-      // If it is an array index, we can't take it.
-      // This uses a trick: converting a string to a number yields NaN if
-      // the operation failed, and NaN is not equal to itself.
-      if (+prop != +prop) {
-        matches.add(prop);
-      }
-
-      if (matches.size >= MAX_AUTOCOMPLETIONS) {
-        break;
-      }
-    }
-  }
-
-  return {
-    matchProp: aMatch,
-    matches: [...matches],
-  };
-}
-
-/**
- * Returns a property value based on its name from the given object, by
- * recursively checking the object's prototype.
- *
- * @param object aObj
- *        An object to look the property into.
- * @param string aName
- *        The property that is looked up.
- * @returns object|undefined
- *        A Debugger.Object if the property exists in the object's prototype
- *        chain, undefined otherwise.
- */
-function getExactMatch_impl(aObj, aName, {chainIterator, getProperty})
-{
-  // We need to go up the prototype chain.
-  let iter = chainIterator(aObj);
-  for (let obj of iter) {
-    let prop = getProperty(obj, aName, aObj);
-    if (prop) {
-      return prop.value;
-    }
-  }
-  return undefined;
-}
-
-
-var JSObjectSupport = {
-  chainIterator: function*(aObj)
-  {
-    while (aObj) {
-      yield aObj;
-      aObj = Object.getPrototypeOf(aObj);
-    }
-  },
-
-  getProperties: function(aObj)
-  {
-    return Object.getOwnPropertyNames(aObj);
-  },
-
-  getProperty: function()
-  {
-    // getProperty is unsafe with raw JS objects.
-    throw "Unimplemented!";
-  },
-};
-
-var DebuggerObjectSupport = {
-  chainIterator: function*(aObj)
-  {
-    while (aObj) {
-      yield aObj;
-      aObj = aObj.proto;
-    }
-  },
-
-  getProperties: function(aObj)
-  {
-    return aObj.getOwnPropertyNames();
-  },
-
-  getProperty: function(aObj, aName, aRootObj)
-  {
-    // This is left unimplemented in favor to DevToolsUtils.getProperty().
-    throw "Unimplemented!";
-  },
-};
-
-var DebuggerEnvironmentSupport = {
-  chainIterator: function*(aObj)
-  {
-    while (aObj) {
-      yield aObj;
-      aObj = aObj.parent;
-    }
-  },
-
-  getProperties: function(aObj)
-  {
-    return aObj.names();
-  },
-
-  getProperty: function(aObj, aName)
-  {
-    // TODO: we should use getVariableDescriptor() here - bug 725815.
-    let result = aObj.getVariable(aName);
-    // FIXME: Need actual UI, bug 941287.
-    if (result === undefined || result.optimizedOut || result.missingArguments) {
-      return null;
-    }
-    return { value: result };
-  },
-};
-
-
-exports.JSPropertyProvider = DevToolsUtils.makeInfallible(JSPropertyProvider);
 })(WebConsoleUtils);
 
 ///////////////////////////////////////////////////////////////////////////////
 // The page errors listener
 ///////////////////////////////////////////////////////////////////////////////
 
 /**
  * The nsIConsoleService listener. This is used to send all of the console
diff --git a/devtools/shared/webconsole/worker-utils.js b/devtools/shared/webconsole/worker-utils.js
--- a/devtools/shared/webconsole/worker-utils.js
+++ b/devtools/shared/webconsole/worker-utils.js
@@ -3,11 +3,10 @@
 // have access to Services / Components.  This functionality
 // is stubbed out to prevent errors, and will need to implemented
 // for Bug 1209353.
 
 exports.Utils = { l10n: function() {} };
 exports.ConsoleServiceListener = function() {};
 exports.ConsoleAPIListener = function() {};
 exports.addWebConsoleCommands = function() {};
-exports.JSPropertyProvider = function() {};
 exports.ConsoleReflowListener = function() {};
 exports.CONSOLE_WORKER_IDS = [];
