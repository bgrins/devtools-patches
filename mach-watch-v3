# HG changeset patch
# User Nick Alexander <nalexander@mozilla.com>
# Date 1499793856 25200
#      Tue Jul 11 10:24:16 2017 -0700
# Node ID 9e1b90c00ace27d0ab64a1035bf34fb412dbf347
# Parent  60a5308fa987676fa5ed9fd5b3ad6c9938af0539
Add |mach watch|: pywatchman based |mach build faster| daemon.

MozReview-Commit-ID: AdDlEOUcJPr
* * *
Watch the objdir for changed files and refresh them
* * *
Add key shortcut for quickly restarting a local build
* * *
Turn "quick restart" into "quick reload".

MozReview-Commit-ID: LXjoCG6fH6V
* * *
Normalize paths in |mach watch|; use dict, not defaultdict; print compact file changes.

MozReview-Commit-ID: 7aWMO3uLdgs
* * *
Handle "install_dist_bin" manifest.

This addresses a bug reported by bgrins:

? /mozilla-central/toolkit/themes/shared/extensions/extensions.inc.css
! /mozilla-central/toolkit/themes/shared/extensions/extensions.inc.css

? /mozilla-central/toolkit/themes/osx/mozapps/extensions/extensions.css
! /mozilla-central/toolkit/themes/osx/mozapps/extensions/extensions.css

diff --git a/browser/base/content/browser-sets.inc b/browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc
+++ b/browser/base/content/browser-sets.inc
@@ -11,16 +11,18 @@
 
   <stringbundleset id="stringbundleset">
     <stringbundle id="bundle_brand" src="chrome://branding/locale/brand.properties"/>
     <stringbundle id="bundle_shell" src="chrome://browser/locale/shellservice.properties"/>
     <stringbundle id="bundle_preferences" src="chrome://browser/locale/preferences/preferences.properties"/>
   </stringbundleset>
 
   <commandset id="mainCommandSet">
+    <command id="cmd_quickRestart" oncommand="QuickRestart()"/>
+    <command id="cmd_quickReload" oncommand="QuickReload()"/>
     <command id="cmd_newNavigator" oncommand="OpenBrowserWindow()"/>
     <command id="cmd_handleBackspace" oncommand="BrowserHandleBackspace();" />
     <command id="cmd_handleShiftBackspace" oncommand="BrowserHandleShiftBackspace();" />
 
     <command id="cmd_newNavigatorTab" oncommand="BrowserOpenTab(event);"/>
     <command id="cmd_newNavigatorTabNoEvent" oncommand="BrowserOpenTab();"/>
     <command id="Browser:OpenFile"  oncommand="BrowserOpenFileWindow();"/>
     <command id="Browser:SavePage" oncommand="saveBrowser(gBrowser.selectedBrowser);"/>
@@ -190,16 +192,26 @@
                  label="&pageSourceCmd.label;"
                  key="key_viewSource"
                  command="View:PageSource">
       <observes element="canViewSource" attribute="disabled"/>
     </broadcaster>
   </broadcasterset>
 
   <keyset id="mainKeyset">
+    <key id="key_quickRestart"
+         key="R"
+         command="cmd_quickRestart"
+         modifiers="accel,alt"
+    />
+    <key id="key_quickReload"
+         key="R"
+         command="cmd_quickReload"
+         modifiers="accel,alt,shift"
+    />
     <key id="key_newNavigator"
          key="&newNavigatorCmd.key;"
          command="cmd_newNavigator"
          modifiers="accel" reserved="true"/>
     <key id="key_newNavigatorTab" key="&tabCmd.commandkey;" modifiers="accel"
          command="cmd_newNavigatorTabNoEvent" reserved="true"/>
     <key id="focusURLBar" key="&openCmd.commandkey;" command="Browser:OpenLocation"
          modifiers="accel"/>
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -4161,16 +4161,60 @@ function toOpenWindowByType(inType, uri,
   if (topWindow)
     topWindow.focus();
   else if (features)
     window.open(uri, "_blank", features);
   else
     window.open(uri, "_blank", "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar");
 }
 
+function QuickRestart() {
+  Services.obs.notifyObservers(null, "startupcache-invalidate");
+  let canceled = Cc["@mozilla.org/supports-PRBool;1"]
+      .createInstance(Ci.nsISupportsPRBool);
+
+  Services.obs.notifyObservers(canceled, "quit-application-requested", "restart");
+
+  if (canceled.data) return false;
+
+  Cc['@mozilla.org/toolkit/app-startup;1'].getService(Ci.nsIAppStartup)
+      .quit(Ci.nsIAppStartup.eAttemptQuit | Ci.nsIAppStartup.eRestart);
+}
+
+function QuickReload() {
+  // window.location.reload() has problems (on at least Mac OS X) with
+  // the title bar, so instead let's make a new window and transfer
+  // this window's session state into that window.
+
+  const ss = Cc["@mozilla.org/browser/sessionstore;1"].getService(Ci.nsISessionStore);
+  let stateString = ss.getWindowState(window);
+
+  // Replacement window.
+  let next = OpenBrowserWindow({suppressanimation: true});
+
+  // Arrange for replacement window to get this windows session state.
+  let delayedStartupObserver = aSubject => {
+    if (aSubject == next) {
+      Services.obs.removeObserver(delayedStartupObserver, "browser-delayed-startup-finished");
+      ss.setWindowState(next, stateString, /* overwriteTabs */ true);
+
+      // We move by a few pixels so that it's clear that something has
+      // happened.  The window features are restored on the next tick,
+      // so we have to wait in order to move the window.
+      next.setTimeout(() => {
+        next.moveBy(10, 10);
+      }, 0);
+
+      // Fairly abruptly close this window.
+      closeWindow(true);
+    }
+  };
+  Services.obs.addObserver(delayedStartupObserver, "browser-delayed-startup-finished");
+}
+
 function OpenBrowserWindow(options) {
   var telemetryObj = {};
   TelemetryStopwatch.start("FX_NEW_WINDOW_MS", telemetryObj);
 
   function newDocumentShown(doc, topic, data) {
     if (topic == "document-shown" &&
         doc != document &&
         doc.defaultView == win) {
@@ -4213,17 +4257,17 @@ function OpenBrowserWindow(options) {
     extraFeatures += ",remote";
   } else if (options && options.remote === false) {
     extraFeatures += ",non-remote";
   }
 
   // If the window is maximized, we want to skip the animation, since we're
   // going to be taking up most of the screen anyways, and we want to optimize
   // for showing the user a useful window as soon as possible.
-  if (window.windowState == window.STATE_MAXIMIZED) {
+  if (window.windowState == window.STATE_MAXIMIZED || (options && options.suppressanimation)) {
     extraFeatures += ",suppressanimation";
   }
 
   // if and only if the current window is a browser window and it has a document with a character
   // set, then extract the current charset menu setting from the current document and use it to
   // initialize the new browser window...
   var win;
   if (window && (wintype == "navigator:browser") && window.content && window.content.document) {
diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -14,17 +14,17 @@ Cu.import("resource://gre/modules/Servic
 Cu.import("resource://gre/modules/AppConstants.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "WindowsUIUtils", "@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils");
 XPCOMUtils.defineLazyGetter(this, "WeaveService", () =>
   Cc["@mozilla.org/weave/service;1"].getService().wrappedJSObject
 );
 XPCOMUtils.defineLazyModuleGetter(this, "ContextualIdentityService",
                                   "resource://gre/modules/ContextualIdentityService.jsm");
-
+XPCOMUtils.defineLazyModuleGetter(this, "console", "resource://gre/modules/Console.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "SafeBrowsing",
                                   "resource://gre/modules/SafeBrowsing.jsm");
 
 // lazy module getters
 
 /* global AboutHome:false, AboutNewTab:false, AddonManager:false, AppMenuNotifications:false,
           AsyncPrefs: false, AsyncShutdown:false, AutoCompletePopup:false, BookmarkHTMLUtils:false,
           BookmarkJSONUtils:false, BrowserUITelemetry:false, BrowserUsageTelemetry:false,
@@ -615,16 +615,17 @@ BrowserGlue.prototype = {
     this._distributionCustomizer.applyCustomizations();
 
     // handle any UI migration
     this._migrateUI();
 
     listeners.init();
 
     SessionStore.init();
+    DevRefresher.init();
 
     if (AppConstants.INSTALL_COMPACT_THEMES) {
       let vendorShortName = gBrandBundle.GetStringFromName("vendorShortName");
 
       LightweightThemeManager.addBuiltInTheme({
         id: "firefox-compact-light@mozilla.org",
         name: gBrowserBundle.GetStringFromName("compactLightTheme.name"),
         description: gBrowserBundle.GetStringFromName("compactLightTheme.description"),
@@ -2867,8 +2868,220 @@ this.NSGetFactory = XPCOMUtils.generateN
 
 // Listen for UITour messages.
 // Do it here instead of the UITour module itself so that the UITour module is lazy loaded
 // when the first message is received.
 var globalMM = Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
 globalMM.addMessageListener("UITour:onPageEvent", function(aMessage) {
   UITour.onPageEvent(aMessage, aMessage.data);
 });
+
+
+var DevRefresher = {
+  resolveURIToLocalPath(aURI) {
+    let resolved;
+    switch (aURI.scheme) {
+      case "jar":
+      case "file":
+        return aURI;
+
+      case "chrome":
+        resolved = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                   getService(Ci.nsIChromeRegistry).convertChromeURL(aURI);
+        return this.resolveURIToLocalPath(resolved);
+
+      case "resource":
+        resolved = Cc["@mozilla.org/network/protocol;1?name=resource"].
+                   getService(Ci.nsIResProtocolHandler).resolveURI(aURI);
+        aURI = Services.io.newURI(resolved, null, null);
+        return this.resolveURIToLocalPath(aURI);
+
+      default:
+        return null;
+    }
+  },
+  getLocalPath(url) {
+    let uri = null;
+    let ios = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces["nsIIOService"]);
+    try {
+        uri = this.resolveURIToLocalPath(ios.newURI(url, "UTF-8", null));
+    } catch(e){}
+
+    let ret = null;
+    if (uri) {
+      ret = AppConstants.platform == "win" ? uri.spec.replace(/file:\/\/\//, "") : uri.spec.replace(/file:\/\//, "");
+    }
+    return ret;
+  },
+
+  watchFiles(path, onFileChanged) {
+    const watchWorker = new ChromeWorker(
+      "resource://devtools/client/shared/file-watcher-worker.js"
+    );
+
+    watchWorker.onmessage = event => {
+      // We need to turn a local path back into a resource URI (or
+      // chrome). This means that this system will only work when built
+      // files are symlinked, so that these URIs actually read from
+      // local sources. There might be a better way to do this.
+      const { path: newPath } = event.data;
+      onFileChanged(newPath);
+    };
+
+    watchWorker.postMessage({
+      path,
+      fileRegex: /\.(css|js|html|xhtml|xul)$/
+    });
+    return watchWorker;
+  },
+
+
+  iterStyleNodes(window, func) {
+    for (let node of window.document.childNodes) {
+      // Look for ProcessingInstruction nodes.
+      if (node.nodeType === 7) {
+        func(node);
+      }
+    }
+
+    const links = window.document.getElementsByTagNameNS(
+      "http://www.w3.org/1999/xhtml", "link"
+    );
+    for (let node of links) {
+      func(node);
+    }
+  },
+
+  replaceCSS(window, fileURI) {
+    const document = window.document;
+    const appendRandom = (href) => {
+      return href.split("?s")[0] + `?s=${Math.random()}`;
+    };
+    // console.log("Checking for replacement at:", window.location.toString(), "with: ", fileURI);
+
+    // Scan every CSS tag and reload ones that match the file we are
+    // looking for.
+    this.iterStyleNodes(window, node => {
+      if (node.nodeType === 7) {
+        // xml-stylesheet declaration
+        // Convert a string like href="chrome://browser/content/browser.css" type="text/css" to:
+        // chrome://browser/content/browser.css, then convert it to a local path
+        let originalHref = node.data.match(/href=([^\s]*)/)[1].replace(/["']/g, '')
+        const path = this.getLocalPath(originalHref);
+        // console.log("Looking into PI", "\nhref: " + originalHref, "\npath: " + path, "\nfileURI: " + fileURI);
+        if (path && path.includes(fileURI)) {
+          // Special case chrome://browser/skin/ which does a redircet
+          if (originalHref == "chrome://browser/skin/") {
+            originalHref = "chrome://browser/skin/browser.css";
+          }
+          console.log("Replacing the PI at: ", originalHref);
+          const newNode = window.document.createProcessingInstruction(
+            "xml-stylesheet",
+            `href="${appendRandom(originalHref)}" type="text/css"`
+          );
+          document.insertBefore(newNode, node);
+          document.removeChild(node);
+        }
+      } else {
+        const originalHref = node.href;
+        const path = this.getLocalPath(originalHref);
+        // console.log("Looking into stylesheet", path, fileURI);
+        if (path && path.includes(fileURI)) {
+          console.log("Replacing the stylesheet at: ", originalHref);
+          const parentNode = node.parentNode;
+          const newNode = window.document.createElementNS(
+            "http://www.w3.org/1999/xhtml",
+            "link"
+          );
+          newNode.rel = "stylesheet";
+          newNode.type = "text/css";
+          newNode.href = appendRandom(originalHref);
+
+          parentNode.insertBefore(newNode, node);
+          parentNode.removeChild(node);
+        }
+     }
+    });
+  },
+
+  replaceCSSImports(window, fileURI) {
+    const document = window.document;
+    const appendRandom = (href) => {
+      return href.split("?s")[0] + `?s=${Math.random()}`;
+    };
+    // Only match the filename. False positives are much better than
+    // missing updates, as all that would happen is we reload more
+    // resources than we need. We do this because many resources only
+    // use relative paths.
+    const parts = fileURI.split("/");
+    const file = parts[parts.length - 1];
+
+    // Scan every single rule in the entire page for any reference to
+    // this resource, and re-insert the rule to force it to update.
+    for (let sheet of document.styleSheets) {
+      if (sheet.ownerNode.nodeType === 7) { continue; }
+      for (let i = 0; i < sheet.cssRules.length; i++) {
+        const rule = sheet.cssRules[i];
+        if (rule.type === rule.IMPORT_RULE) {
+          // console.log("Found an import", "\n" + rule.href,  "\n" + this.getLocalPath(rule.href.split("?s")[0]), "\n" + fileURI);
+          // TODO (if nested imports are used) - recurse into the imported sheet
+          if (this.getLocalPath(rule.href.split("?s")[0]) === fileURI) {
+              let newRule = `@import url("${appendRandom(rule.href)}");`;
+              sheet.deleteRule(i);
+              sheet.insertRule(newRule, i);
+          }
+        }
+      }
+    }
+  },
+
+  getAllDocuments(win) {
+    let walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].
+                 createInstance(Ci.inIDeepTreeWalker);
+    walker.showAnonymousContent = true;
+    walker.showSubDocuments = true;
+    walker.showDocumentsAsNodes = true;
+    walker.init(win.document.documentElement, Ci.nsIDOMNodeFilter.SHOW_ELEMENT);
+    let documents = [win.document]
+    while (walker.nextNode()) {
+      if (walker.currentNode.nodeType === 9) {
+        documents.push(walker.currentNode)
+      }
+    }
+    return documents;
+  },
+
+  init() {
+    const watchRoot = this.getLocalPath("resource://");
+    this.worker = this.watchFiles(watchRoot, path => {
+      Services.obs.notifyObservers(null, "startupcache-invalidate");
+
+      // Don't traverse stylesheets unless if a css file changed
+      if (!path.endsWith('css')) {
+        return;
+      }
+
+      // XXX: Yuck. We should receive these paths directly from the build system instead
+      // so we don't have so many issues with windows paths (the file watcher worker doesn't
+      // support windows paths)
+      if (AppConstants.platform == "win") {
+        path = path.replace(/\\/g, '/');
+      }
+
+      // XXX: remove double slash that's coming back from worker:
+      path = path.replace(/\/\//g, '/');
+
+      // This covers extra globals like additional browser windows and the browser toolbox
+      var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                     .getService(Components.interfaces.nsIWindowMediator);
+      var enumerator = wm.getEnumerator(null);
+      while(enumerator.hasMoreElements()) {
+        var win = enumerator.getNext();
+        // This covers extra globals within a window, like devtools frames
+        let allDocuments = this.getAllDocuments(win);
+        for (var i = 0; i < allDocuments.length; i++) {
+          this.replaceCSS(allDocuments[i].defaultView, path);
+          this.replaceCSSImports(allDocuments[i].defaultView, path);
+        }
+      }
+    });
+  },
+};
diff --git a/devtools/client/shared/file-watcher-worker.js b/devtools/client/shared/file-watcher-worker.js
--- a/devtools/client/shared/file-watcher-worker.js
+++ b/devtools/client/shared/file-watcher-worker.js
@@ -72,10 +72,10 @@ onmessage = function (event) {
   const files = gatherFiles(path, fileRegex || /.*/);
 
   // Every second, scan for file changes by stat-ing each of them and
   // comparing modification time.
   setInterval(() => {
     scanFiles(files, changedFile => {
       postMessage({ path: changedFile });
     });
-  }, 1000);
+  }, 500);
 };
diff --git a/python/mozbuild/mozbuild/faster_daemon.py b/python/mozbuild/mozbuild/faster_daemon.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/faster_daemon.py
@@ -0,0 +1,263 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+'''
+XXX
+'''
+
+from __future__ import absolute_import, print_function, unicode_literals
+
+import collections
+import os
+import sys
+import time
+
+import mozpack.path as mozpath
+from mozpack.manifests import (
+    InstallManifest,
+)
+from mozpack.copier import (
+    FileCopier,
+    FileRegistrySubtree,
+)
+from mozpack.files import (
+    AbsoluteSymlinkFile,
+    File,
+    PreprocessedFile,
+    FileFinder,
+)
+from mozbuild import shellutil
+
+# Watchman integration cribbed entirely from
+# https://github.com/facebook/watchman/blob/19aebfebb0b5b0b5174b3914a879370ffc5dac37/python/bin/watchman-wait
+import pywatchman
+
+
+def print_copy_result(elapsed, destdir, result, verbose=True):
+    COMPLETE = 'Elapsed: {elapsed:.2f}s; From {dest}: Kept {existing} existing; ' \
+        'Added/updated {updated}; ' \
+        'Removed {rm_files} files and {rm_dirs} directories.'
+
+    print(COMPLETE.format(
+        elapsed=elapsed,
+        dest=destdir,
+        existing=result.existing_files_count,
+        updated=result.updated_files_count,
+        rm_files=result.removed_files_count,
+        rm_dirs=result.removed_directories_count))
+
+    if verbose:
+        if result.updated_files:
+            print("Updated files:")
+            for file in result.updated_files:
+                print("  {}".format(file))
+
+
+class Daemon(object):
+    def __init__(self, config_environment):
+        self.config_environment = config_environment
+        self._file_copier = None
+        self._client = None
+        self._subscriptions = []
+
+    @property
+    def defines(self):
+        defines = dict((name, self.config_environment.defines[name]) \
+                       for name in self.config_environment.defines \
+                       if not name in self.config_environment.non_global_defines)
+        defines.update({
+            'AB_CD': 'en-US',
+            'BUILD_FASTER': 1,
+        })
+        defines.update({
+            'BOOKMARKS_INCLUDE_DIR': mozpath.join(self.config_environment.topsrcdir,
+                                                  'browser', 'locales', 'en-US', 'profile'),
+        })
+        return defines
+
+    @property
+    def file_copier(self):
+        if self._file_copier is None:
+            file_copier = FileCopier()
+
+            finder = FileFinder(mozpath.join(self.config_environment.topobjdir, 'faster'))
+            for path, f in finder.find('*.track'):
+                manifest = InstallManifest(fileobj=f.open())
+
+                # Turn 'install_dist_bin_browser.track' into ['browser'].
+                parts = os.path.basename(os.path.splitext(path)[0]).split('_')
+                parts = parts[3:] # Drop leading install_dist_bin.
+
+                subtree = mozpath.join(*parts) if parts else None
+                manifest.populate_registry(FileRegistrySubtree(subtree, file_copier),
+                                           defines_override=self.defines)
+
+            self._file_copier = file_copier
+
+        return self._file_copier
+
+    def watch_set(self, depth=2):
+        file_copier = self.file_copier
+
+        # We want the set of watches to be "reasonable", so we watch
+        # (by default) $TOPSRCDIR/two/levels or $TOPSRCDIR/onelevel.
+        # Many folks root $TOPOBJDIR in $TOPSRCDIR, so we handle that
+        # situation specially.  We definitely don't want to watch
+        # $TOPOBJDIR by mistake!
+        watches = set()
+        for input in file_copier.input_to_outputs_tree().keys():
+            rel = mozpath.commonprefix((input, self.config_environment.topobjdir))
+            if rel.startswith(self.config_environment.topobjdir):
+                continue
+
+            rel = mozpath.relpath(input, self.config_environment.topsrcdir)
+            if rel:
+                partial_paths = file_copier._partial_paths(rel)
+                if len(partial_paths) >= 2:
+                    watch = partial_paths[-2]
+                elif len(partial_paths) >= 1:
+                    watch = partial_paths[-1]
+                watches.add(watch)
+            else:
+                raise Exception("Refusing to watch input ({}) not rooted in topsrcdir ({})"
+                                .format(input, self.config_environment.topsrcdir))
+
+        return watches
+
+    def subscribe_to_dir(self, name, dir_to_watch):
+        query = {
+            'expression': ['true'],
+            'fields': ['name'],
+        }
+        watch = self.client.query('watch-project', dir_to_watch)
+        if 'warning' in watch:
+            print('WARNING: ', watch['warning'], file=sys.stderr)
+
+        root = watch['watch']
+        if 'relative_path' in watch:
+            query['relative_root'] = watch['relative_path']
+
+        # Get the initial clock value so that we only get updates.
+        query['since'] = self.client.query('clock', root)['clock']
+
+        return self.client.query('subscribe', root, name, query)
+
+    def changed_files(self, verbose=True):
+        # in theory we can parse just the result variable here, but
+        # the client object will accumulate all subscription results
+        # over time, so we ask it to remove and return those values
+        # for each of the subscriptions
+
+        files = set()
+        for sub in self._subscriptions:
+            name = sub['subscribe']
+            data = self.client.getSubscription(name)
+            if data is None:
+                continue
+
+            for dat in data:
+                files |= set([mozpath.join(self.config_environment.topsrcdir, name, f)
+                              for f in dat.get('files', [])])
+
+            files = set([f for f in files if os.path.isfile(f)])
+
+        return files
+
+    def incremental_copy(self, copier, force=False, verbose=True):
+        # Just like the 'repackage' target in browser/app/Makefile.in.
+        if 'cocoa' == self.config_environment.substs['MOZ_WIDGET_TOOLKIT']:
+            bundledir = mozpath.join(self.config_environment.topobjdir, 'dist',
+                                     self.config_environment.substs['MOZ_MACBUNDLE_NAME'],
+                                     'Contents', 'Resources')
+            start = time.time()
+            result = copier.copy(bundledir,
+                                 skip_if_older=not force,
+                                 remove_unaccounted=False,
+                                 remove_all_directory_symlinks=False,
+                                 remove_empty_directories=False)
+            print_copy_result(time.time() - start, bundledir, result, verbose=verbose)
+
+        destdir = mozpath.join(self.config_environment.topobjdir, 'dist', 'bin')
+        start = time.time()
+        result = copier.copy(destdir,
+                             skip_if_older=not force,
+                             remove_unaccounted=False,
+                             remove_all_directory_symlinks=False,
+                             remove_empty_directories=False)
+        print_copy_result(time.time() - start, destdir, result, verbose=verbose)
+
+    def watch(self, verbose=True):
+        self.client = pywatchman.client()
+        try:
+            self.client.capabilityCheck(required=['term-dirname', 'cmd-watch-project', 'wildmatch'])
+
+            for watch in sorted(self.watch_set()):
+                name = watch
+                path = mozpath.join(self.config_environment.topsrcdir, watch)
+                if verbose:
+                    print("Watching srcdir {}".format(path))
+                sub = self.subscribe_to_dir(name, path)
+                self._subscriptions.append(sub)
+
+        except pywatchman.CommandError as ex:
+            print('watchman:', ex.msg, file=sys.stderr)
+            return 1
+
+        input_to_outputs = self.file_copier.input_to_outputs_tree()
+        for input, outputs in input_to_outputs.items():
+            if not outputs:
+                raise Exception("Refusing to watch input ({}) that produces no outputs".format(input))
+
+        while True:
+            try:
+                result = self.client.receive()
+
+                changed = self.changed_files(verbose=verbose)
+                if not changed:
+                    continue
+
+                unrecognized = set()
+                inputs = {}
+                all_outputs = set()
+
+                for change in changed:
+                    change = mozpath.normpath(change)
+                    if verbose:
+                        print("? {}".format(change))
+                    if change in input_to_outputs:
+                        outputs = set(input_to_outputs[change])
+                        inputs[change] = outputs
+                    else:
+                        unrecognized.add(change)
+
+                for dropped in sorted(unrecognized):
+                    print("! {}".format(dropped))
+
+                for input in sorted(inputs):
+                    print("< {}".format(input))
+                    outputs = inputs[input]
+                    for output in sorted(outputs):
+                        print("> {}".format(output))
+                    all_outputs |= outputs
+
+                if all_outputs:
+                    partial_copier = FileCopier()
+                    for output in all_outputs:
+                        partial_copier.add(output, self.file_copier[output])
+
+                    self.incremental_copy(partial_copier, force=True, verbose=verbose)
+
+            except pywatchman.SocketTimeout as ex:
+                # Let's check to see if we're still functional.
+                try:
+                    vers = self.client.query('version')
+                except Exception as ex:
+                    print('watchman:', str(ex), file=sys.stderr)
+                    sys.exit(1)
+
+            except KeyboardInterrupt:
+                # Suppress ugly stack trace when user hits Ctrl-C.
+                sys.exit(3)
+
+        return 0
diff --git a/python/mozbuild/mozbuild/mach_commands.py b/python/mozbuild/mozbuild/mach_commands.py
--- a/python/mozbuild/mozbuild/mach_commands.py
+++ b/python/mozbuild/mozbuild/mach_commands.py
@@ -300,16 +300,31 @@ class BuildOutputManager(OutputManager):
 class StoreDebugParamsAndWarnAction(argparse.Action):
     def __call__(self, parser, namespace, values, option_string=None):
         sys.stderr.write('The --debugparams argument is deprecated. Please ' +
                          'use --debugger-args instead.\n\n')
         setattr(namespace, self.dest, values)
 
 
 @CommandProvider
+class Watch(MachCommandBase):
+    """Interface to watch and re-build the tree."""
+
+    @Command('watch', category='build', description='Watch and re-build the tree.')
+    def watch(self):
+        """Watch and re-build the source tree."""
+        self._activate_virtualenv()
+        self.virtualenv_manager.install_pip_package('pywatchman==1.3.0')
+
+        from mozbuild.faster_daemon import Daemon
+        daemon = Daemon(self.config_environment)
+        return daemon.watch()
+
+
+@CommandProvider
 class Build(MachCommandBase):
     """Interface to build the tree."""
 
     @Command('build', category='build', description='Build the tree.')
     @CommandArgument('--jobs', '-j', default='0', metavar='jobs', type=int,
         help='Number of concurrent jobs to run. Default is the number of CPUs.')
     @CommandArgument('-C', '--directory', default=None,
         help='Change to a subdirectory of the build directory first.')
diff --git a/python/mozbuild/mozpack/copier.py b/python/mozbuild/mozpack/copier.py
--- a/python/mozbuild/mozpack/copier.py
+++ b/python/mozbuild/mozpack/copier.py
@@ -11,16 +11,17 @@ import sys
 from mozpack.errors import errors
 from mozpack.files import (
     BaseFile,
     Dest,
 )
 import mozpack.path as mozpath
 import errno
 from collections import (
+    defaultdict,
     Counter,
     OrderedDict,
 )
 import concurrent.futures as futures
 
 
 class FileRegistry(object):
     '''
@@ -148,16 +149,44 @@ class FileRegistry(object):
         '''
         Return the set of directories required by the paths in the container,
         in no particular order.  The returned directories are relative to an
         unspecified (virtual) root directory (and do not include said root
         directory).
         '''
         return set(k for k, v in self._required_directories.items() if v > 0)
 
+    def output_to_inputs_tree(self):
+        '''
+        Return a dictionary mapping each output path to the set of its
+        required input paths.
+
+        All paths are normalized.
+        '''
+        tree = {}
+        for output, file in self:
+            output = mozpath.normpath(output)
+            tree[output] = set(mozpath.normpath(f) for f in file.inputs())
+        return tree
+
+    def input_to_outputs_tree(self):
+        '''
+        Return a dictionary mapping each input path to the set of
+        impacted output paths.
+
+        All paths are normalized.
+        '''
+        tree = defaultdict(set)
+        for output, file in self:
+            output = mozpath.normpath(output)
+            for input in file.inputs():
+                input = mozpath.normpath(input)
+                tree[input].add(output)
+        return dict(tree.iteritems())
+
 
 class FileRegistrySubtree(object):
     '''A proxy class to give access to a subtree of an existing FileRegistry.
 
     Note this doesn't implement the whole FileRegistry interface.'''
     def __new__(cls, base, registry):
         if not base:
             return registry
diff --git a/python/mozbuild/mozpack/files.py b/python/mozbuild/mozpack/files.py
--- a/python/mozbuild/mozpack/files.py
+++ b/python/mozbuild/mozpack/files.py
@@ -229,16 +229,22 @@ class BaseFile(object):
 
     @property
     def mode(self):
         '''
         Return the file's unix mode, or None if it has no meaning.
         '''
         return None
 
+    def inputs(self):
+        '''
+        Return an iterator of the input file paths that impact this output file.
+        '''
+        raise NotImplementedError('BaseFile.inputs() not implemented. Bug XXX.')
+
 
 class File(BaseFile):
     '''
     File class for plain files.
     '''
     def __init__(self, path):
         self.path = path
 
@@ -256,16 +262,19 @@ class File(BaseFile):
     def read(self):
         '''Return the contents of the file.'''
         with open(self.path, 'rb') as fh:
             return fh.read()
 
     def size(self):
         return os.stat(self.path).st_size
 
+    def inputs(self):
+        yield self.path
+
 
 class ExecutableFile(File):
     '''
     File class for executable and library files on OS/2, OS/X and ELF systems.
     (see mozpack.executables.is_executable documentation).
     '''
     def copy(self, dest, skip_if_older=True):
         real_dest = dest
@@ -418,32 +427,46 @@ class ExistingFile(BaseFile):
 
         if not self.required:
             return
 
         if not dest.exists():
             errors.fatal("Required existing file doesn't exist: %s" %
                 dest.path)
 
+    def inputs(self):
+        return iter(())
+
 
 class PreprocessedFile(BaseFile):
     '''
     File class for a file that is preprocessed. PreprocessedFile.copy() runs
     the preprocessor on the file to create the output.
     '''
     def __init__(self, path, depfile_path, marker, defines, extra_depends=None,
                  silence_missing_directive_warnings=False):
         self.path = path
         self.depfile = depfile_path
         self.marker = marker
         self.defines = defines
         self.extra_depends = list(extra_depends or [])
         self.silence_missing_directive_warnings = \
             silence_missing_directive_warnings
 
+    def inputs(self):
+        pp = Preprocessor(defines=self.defines, marker=self.marker)
+        pp.setSilenceDirectiveWarnings(self.silence_missing_directive_warnings)
+
+        with open(self.path, 'rU') as input:
+            with open(os.devnull, 'w') as output:
+                pp.processFile(input=input, output=output)
+
+        # This always yields at least self.path.
+        return iter(pp.includes)
+
     def copy(self, dest, skip_if_older=True):
         '''
         Invokes the preprocessor to create the destination file.
         '''
         if isinstance(dest, basestring):
             dest = Dest(dest)
         else:
             assert isinstance(dest, Dest)
@@ -509,16 +532,19 @@ class GeneratedFile(BaseFile):
         return BytesIO(self.content)
 
     def read(self):
         return self.content
 
     def size(self):
         return len(self.content)
 
+    def inputs(self):
+        return iter(())
+
 
 class DeflatedFile(BaseFile):
     '''
     File class for members of a jar archive. DeflatedFile.copy() effectively
     extracts the file from the jar archive.
     '''
     def __init__(self, file):
         from mozpack.mozjar import JarFileReader
