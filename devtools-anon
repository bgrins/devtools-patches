# HG changeset patch
# Parent f7bdb78799e0663616be24a97a7d99188691039b
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 777674 - Add support for inspecting anonymous content;r=pbrosset

diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -88,17 +88,17 @@ FontInspector.prototype = {
       return;
     }
 
     let node = this.inspector.selection.node;
     let contentDocument = node.ownerDocument;
 
     // We don't get fonts for a node, but for a range
     let rng = contentDocument.createRange();
-    rng.selectNode(node);
+    rng.selectNodeContents(node);
     let fonts = DOMUtils.getUsedFontFaces(rng);
     let fontsArray = [];
     for (let i = 0; i < fonts.length; i++) {
       fontsArray.push(fonts.item(i));
     }
     fontsArray = fontsArray.sort(function(a, b) {
       return a.srcIndex < b.srcIndex;
     });
diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
--- a/browser/devtools/framework/selection.js
+++ b/browser/devtools/framework/selection.js
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {Cu, Ci} = require("chrome");
 let EventEmitter = require("devtools/toolkit/event-emitter");
+Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 /**
  * API
  *
  *   new Selection(walker=null, node=null, track={attributes,detached});
  *   destroy()
  *   node (readonly)
  *   setNode(node, origin="unknown")
@@ -220,21 +221,28 @@ Selection.prototype = {
     // accessing node.rawNode, this needs to stay.
     let rawNode = null;
     if (node.isLocal_toBeDeprecated()) {
       rawNode = node.rawNode();
     }
     if (rawNode) {
       try {
         let doc = this.document;
-        return (doc && doc.defaultView && doc.documentElement.contains(rawNode));
+        if (doc && doc.defaultView) {
+          let docEl = doc.documentElement;
+          let bindingParent = LayoutHelpers.getRootBindingParent(rawNode);
+
+          if (docEl.contains(bindingParent)) {
+            return true;
+          }
+        }
       } catch (e) {
         // "can't access dead object" error
-        return false;
       }
+      return false;
     }
 
     while(node) {
       if (node === this._walker.rootNode) {
         return true;
       }
       node = node.parentNode();
     };
@@ -247,16 +255,24 @@ Selection.prototype = {
   },
 
   // Node type
 
   isElementNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
   },
 
+  isPseudoElementNode: function() {
+    return this.isNode() && this.nodeFront.isPseudoElement;
+  },
+
+  isAnonymousNode: function() {
+    return this.isNode() && this.nodeFront.isAnonymous;
+  },
+
   isAttributeNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
   },
 
   isTextNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
   },
 
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -577,37 +577,40 @@ InspectorPanel.prototype = {
     }
     return null;
   },
 
   /**
    * Disable the delete item if needed. Update the pseudo classes.
    */
   _setupNodeMenu: function InspectorPanel_setupNodeMenu() {
-    let isSelectionElement = this.selection.isElementNode();
+    let isSelectionElement = this.selection.isElementNode() &&
+                             !this.selection.isPseudoElementNode();
+    let isEditableElement = isSelectionElement &&
+                            !this.selection.isAnonymousNode();
 
     // Set the pseudo classes
     for (let name of ["hover", "active", "focus"]) {
       let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);
 
       if (isSelectionElement) {
         let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
         menu.setAttribute("checked", checked);
         menu.removeAttribute("disabled");
       } else {
         menu.setAttribute("disabled", "true");
       }
     }
 
     // Disable delete item if needed
     let deleteNode = this.panelDoc.getElementById("node-menu-delete");
-    if (this.selection.isRoot() || this.selection.isDocumentTypeNode()) {
+    if (isEditableElement) {
+      deleteNode.removeAttribute("disabled");
+    } else {
       deleteNode.setAttribute("disabled", "true");
-    } else {
-      deleteNode.removeAttribute("disabled");
     }
 
     // Disable / enable "Copy Unique Selector", "Copy inner HTML" &
     // "Copy outer HTML" as appropriate
     let unique = this.panelDoc.getElementById("node-menu-copyuniqueselector");
     let copyInnerHTML = this.panelDoc.getElementById("node-menu-copyinner");
     let copyOuterHTML = this.panelDoc.getElementById("node-menu-copyouter");
     if (isSelectionElement) {
@@ -618,38 +621,38 @@ InspectorPanel.prototype = {
       unique.setAttribute("disabled", "true");
       copyInnerHTML.setAttribute("disabled", "true");
       copyOuterHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "edit HTML" item if the selection is an element and the root
     // actor has the appropriate trait (isOuterHTMLEditable)
     let editHTML = this.panelDoc.getElementById("node-menu-edithtml");
-    if (this.isOuterHTMLEditable && isSelectionElement) {
+    if (isEditableElement && this.isOuterHTMLEditable) {
       editHTML.removeAttribute("disabled");
     } else {
       editHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "paste outer HTML" item if the selection is an element and
     // the root actor has the appropriate trait (isOuterHTMLEditable) and if
     // the clipbard content is appropriate.
     let pasteOuterHTML = this.panelDoc.getElementById("node-menu-pasteouterhtml");
-    if (this.isOuterHTMLEditable && isSelectionElement &&
+    if (isEditableElement && this.isOuterHTMLEditable &&
         this._getClipboardContentForOuterHTML()) {
       pasteOuterHTML.removeAttribute("disabled");
     } else {
       pasteOuterHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "copy image data-uri" item if the selection is previewable
     // which essentially checks if it's an image or canvas tag
     let copyImageData = this.panelDoc.getElementById("node-menu-copyimagedatauri");
     let markupContainer = this.markup.getContainer(this.selection.nodeFront);
-    if (markupContainer && markupContainer.isPreviewable()) {
+    if (isSelectionElement && markupContainer && markupContainer.isPreviewable()) {
       copyImageData.removeAttribute("disabled");
     } else {
       copyImageData.setAttribute("disabled", "true");
     }
   },
 
   _resetNodeMenu: function InspectorPanel_resetNodeMenu() {
     // Remove any extra items
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -272,17 +272,17 @@ MarkupView.prototype = {
     while (parent !== this.doc.body) {
       if (parent.container) {
         container = parent.container;
         break;
       }
       parent = parent.parentNode;
     }
 
-    if (container) {
+    if (container && container._isImagePreviewTarget) {
       // With the newly found container, delegate the tooltip content creation
       // and decision to show or not the tooltip
       return container._isImagePreviewTarget(target, this.tooltip);
     }
   },
 
   /**
    * Given the known reason, should the current selection be briefly highlighted
@@ -525,17 +525,17 @@ MarkupView.prototype = {
     if (!aIgnoreFocus) {
       aContainer.focus();
     }
   },
 
   /**
    * Make sure a node is included in the markup tool.
    *
-   * @param DOMNode aNode
+   * @param NodeFront aNode
    *        The node in the content document.
    * @param boolean aFlashNode
    *        Whether the newly imported node should be flashed
    * @returns MarkupContainer The MarkupContainer object for this element.
    */
   importNode: function(aNode, aFlashNode) {
     if (!aNode) {
       return null;
@@ -914,17 +914,17 @@ MarkupView.prototype = {
   _ensureVisible: function(node) {
     while (node) {
       let container = this.getContainer(node);
       let parent = node.parentNode();
       if (!container.elt.parentNode) {
         let parentContainer = this.getContainer(parent);
         if (parentContainer) {
           parentContainer.childrenDirty = true;
-          this._updateChildren(parentContainer, {expand: node});
+          this._updateChildren(parentContainer, {expand: true});
         }
       }
 
       node = parent;
     }
     return this._waitForChildren();
   },
 
@@ -1266,33 +1266,37 @@ MarkupView.prototype = {
 /**
  * The main structure for storing a document node in the markup
  * tree.  Manages creation of the editor for the node and
  * a <ul> for placing child elements, and expansion/collapsing
  * of the element.
  *
  * @param MarkupView aMarkupView
  *        The markup view that owns this container.
- * @param DOMNode aNode
+ * @param NodeFront aNode
  *        The node to display.
  * @param Inspector aInspector
  *        The inspector tool container the markup-view
  */
+
+
 function MarkupContainer(aMarkupView, aNode, aInspector) {
   this.markup = aMarkupView;
   this.doc = this.markup.doc;
   this.undo = this.markup.undo;
   this.node = aNode;
   this._inspector = aInspector;
 
   if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
     this.editor = new TextEditor(this, aNode, "text");
   } else if (aNode.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
     this.editor = new TextEditor(this, aNode, "comment");
-  } else if (aNode.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
+  } else if (aNode.isPseudoElement) {
+    this.editor = new PseudoElementEditor(this, aNode);
+  }  else if (aNode.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
     this.editor = new ElementEditor(this, aNode);
   } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
     this.editor = new DoctypeEditor(this, aNode);
   } else {
     this.editor = new GenericEditor(this, aNode);
   }
 
   // The template will fill the following properties
@@ -1300,16 +1304,20 @@ function MarkupContainer(aMarkupView, aN
   this.expander = null;
   this.tagState = null;
   this.tagLine = null;
   this.children = null;
   this.markup.template("container", this);
   this.elt.container = this;
   this.children.container = this;
 
+  if (aNode.isPseudoElement) {
+    this.expander.remove();
+  }
+
   // Expanding/collapsing the node on dblclick of the whole tag-line element
   this._onToggle = this._onToggle.bind(this);
   this.elt.addEventListener("dblclick", this._onToggle, false);
   this.expander.addEventListener("click", this._onToggle, false);
 
   // Appending the editor element and attaching event listeners
   this.tagLine.appendChild(this.editor.elt);
 
@@ -1324,17 +1332,17 @@ function MarkupContainer(aMarkupView, aN
 }
 
 MarkupContainer.prototype = {
   toString: function() {
     return "[MarkupContainer for " + this.node + "]";
   },
 
   isPreviewable: function() {
-    if (this.node.tagName) {
+    if (this.node.tagName && !this.node.isPseudoElement) {
       let tagName = this.node.tagName.toLowerCase();
       let srcAttr = this.editor.getAttributeElement("src");
       let isImage = tagName === "img" && srcAttr;
       let isCanvas = tagName === "canvas";
 
       return isImage || isCanvas;
     } else {
       return false;
@@ -1783,16 +1791,38 @@ TextEditor.prototype = {
       }).then(null, console.error);
     }
   },
 
   destroy: function() {}
 };
 
 /**
+ * Creates an editor for a pseudo element node.
+ * A pseudo element just needs to simply be displayed in the markup view,
+ * without any of the editing capabilities a normal element has.
+ *
+ * @param MarkupContainer aContainer The container owning this editor.
+ * @param Element aNode The node being edited.
+ */
+function PseudoElementEditor(aContainer, aNode) {
+  this.template = aContainer.markup.template.bind(aContainer.markup);
+  this.tag = null;
+  this.elt = null;
+  this.template("pseudoelement", this);
+  this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
+}
+
+PseudoElementEditor.prototype = {
+  destroy: function() {
+    this.elt.remove();
+  }
+};
+
+/**
  * Creates an editor for an Element node.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param Element aNode The node being edited.
  */
 function ElementEditor(aContainer, aNode) {
   this.doc = aContainer.doc;
   this.undo = aContainer.undo;
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -25,16 +25,18 @@
       <li id="template-container" save="${elt}" class="child collapsed">
         <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span><span save="${expander}" class="theme-twisty expander"></span></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
       <li id="template-more-nodes" class="more-nodes devtools-class-comment" save="${elt}"><span>${showing}</span> <button href="#" onclick="${allButtonClick}">${showAll}</button></li>
     </ul>
 
+    <span id="template-pseudoelement" save="${elt}" class="editor"><span save="${tag}" class="tag theme-fg-color5" tabindex="0"></span></span>
+
     <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span></span>
 
     <span id="template-attribute" save="${attr}" data-attr="${attrName}" class="attreditor" style="display:none"> <span class="editable" save="${inner}" tabindex="0"><span save="${name}" class="attr-name theme-fg-color2"></span>=&quot;<span save="${val}" class="attr-value theme-fg-color6"></span>&quot;</span></span>
 
     <span id="template-text" save="${elt}" class="editor text">
       <pre save="${value}" style="display:inline-block;" tabindex="0"></pre>
     </span>
 
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -148,17 +148,19 @@ ElementStyle.prototype = {
   dummyElement: null,
 
   init: function()
   {
     // To figure out how shorthand properties are interpreted by the
     // engine, we will set properties on a dummy element and observe
     // how their .style attribute reflects them as computed values.
     return this.dummyElementPromise = createDummyDocument().then(document => {
-      this.dummyElement = document.createElementNS(this.element.namespaceURI,
+      // ::before and ::after do not have a namespaceURI
+      let namespaceURI = this.element.namespaceURI || document.documentElement.namespaceURI;
+      this.dummyElement = document.createElementNS(namespaceURI,
                                                    this.element.tagName);
       document.documentElement.appendChild(this.dummyElement);
       return this.dummyElement;
     }).then(null, promiseWarn);
   },
 
   destroy: function() {
     this.dummyElement = null;
@@ -1196,16 +1198,18 @@ CssRuleView.prototype = {
       label = "ruleView.contextmenu.showCSSSources";
     }
     this.menuitemSources.setAttribute("label",
                                       _strings.GetStringFromName(label));
 
     let accessKey = label + ".accessKey";
     this.menuitemSources.setAttribute("accesskey",
                                       _strings.GetStringFromName(accessKey));
+
+    this.menuitemAddRule.disabled = this.inspector.selection.isAnonymousNode();
   },
 
   /**
    * Get the type of a given node in the rule-view
    * @param {DOMNode} node The node which we want information about
    * @return {Object} The type information object contains the following props:
    * - type {String} One of the VIEW_NODE_XXX_TYPE const in
    *   style-inspector-overlays
@@ -1749,17 +1753,21 @@ function RuleEditor(aRuleView, aRule) {
   this._onSelectorDone = this._onSelectorDone.bind(this);
 
   this._create();
 }
 
 RuleEditor.prototype = {
   get isSelectorEditable() {
     let toolbox = this.ruleView.inspector.toolbox;
-    return toolbox.target.client.traits.selectorEditable;
+    let trait = toolbox.target.client.traits.selectorEditable;
+
+    // Do not allow editing anonymousselectors until we can
+    // detect mutations on  pseudo elements in Bug 1034110.
+    return trait && !this.rule.elementStyle.element.isAnonymous;
   },
 
   _create: function() {
     this.element = this.doc.createElementNS(HTML_NS, "div");
     this.element.className = "ruleview-rule theme-separator";
     this.element.setAttribute("uneditable", !this.isEditable);
     this.element._ruleEditor = this;
     if (this.rule.pseudoElement) {
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -78,17 +78,18 @@ skip-if = os == "win" && debug # bug 963
 [browser_ruleview_multiple-properties-duplicates.js]
 [browser_ruleview_multiple-properties-priority.js]
 [browser_ruleview_multiple-properties-unfinished_01.js]
 [browser_ruleview_multiple-properties-unfinished_02.js]
 [browser_ruleview_multiple_properties_01.js]
 [browser_ruleview_multiple_properties_02.js]
 [browser_ruleview_original-source-link.js]
 [browser_ruleview_override.js]
-[browser_ruleview_pseudo-element.js]
+[browser_ruleview_pseudo-element_01.js]
+[browser_ruleview_pseudo-element_02.js]
 [browser_ruleview_refresh-on-attribute-change_01.js]
 [browser_ruleview_refresh-on-attribute-change_02.js]
 [browser_ruleview_refresh-on-style-change.js]
 [browser_ruleview_select-and-copy-styles.js]
 [browser_ruleview_style-editor-link.js]
 [browser_ruleview_urls-clickable.js]
 [browser_ruleview_user-agent-styles.js]
 [browser_ruleview_user-agent-styles-uneditable.js]
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
@@ -35,21 +35,25 @@ let test = asyncTest(function*() {
   yield selectNode(".testclass", inspector);
   yield testEditSelector(view, "div:nth-child(2)");
 
   info("Selecting the modified element");
   yield selectNode("#testid", inspector);
   yield checkModifiedElement(view, "div:nth-child(2)");
 
   info("Selecting the test element");
-  yield selectNode("#testid3", inspector);
+  let f = inspector.markup.walker.frontForRawNode(getNode("#testid3"));
+  let children = yield inspector.markup.walker.children(f);
+  yield selectNode(children.nodes[children.nodes.length-1], inspector);
   yield testEditSelector(view, ".testclass2:after");
 
   info("Selecting the modified element");
-  yield selectNode(".testclass2", inspector);
+  let f = inspector.markup.walker.frontForRawNode(getNode(".testclass2"));
+  let children = yield inspector.markup.walker.children(f);
+  yield selectNode(children.nodes[children.nodes.length-1], inspector);
   yield checkModifiedElement(view, ".testclass2:after");
 });
 
 function* testEditSelector(view, name) {
   info("Test editing existing selector fields");
 
   let idRuleEditor = getRuleViewRuleEditor(view, 1);
 
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
rename from browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js
rename to browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
@@ -22,20 +22,18 @@ let test = asyncTest(function*() {
 
 function* testTopLeft(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#topleft", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 2,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 
   let gutters = assertGutters(view);
 
   // Make sure that clicking on the twisty hides pseudo elements
   let expander = gutters[0].querySelector(".ruleview-expander");
   ok (view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are expanded");
@@ -44,142 +42,122 @@ function* testTopLeft(inspector, view) {
   expander.click();
   ok (view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are expanded again");
 
   // Make sure that dblclicking on the header container also toggles the pseudo elements
   EventUtils.synthesizeMouseAtCenter(gutters[0], {clickCount: 2}, inspector.sidebar.getWindowForTab("ruleview"));
   ok (!view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are collapsed by dblclicking");
 
   let defaultView = element.ownerDocument.defaultView;
+
   let elementRule = rules.elementRules[0];
   let elementRuleView = [].filter.call(view.element.children, e => {
     return e._ruleEditor && e._ruleEditor.rule === elementRule;
   })[0]._ruleEditor;
 
-  let elementAfterRule = rules.afterRules[0];
-  let elementAfterRuleView = [].filter.call(view.element.children, (e) => {
-    return e._ruleEditor && e._ruleEditor.rule === elementAfterRule;
+  let elementFirstLineRule = rules.firstLineRules[0];
+  let elementFirstLineRuleView = [].filter.call(view.element.children, (e) => {
+    return e._ruleEditor && e._ruleEditor.rule === elementFirstLineRule;
   })[0]._ruleEditor;
 
   is
   (
-    convertTextPropsToString(elementAfterRule.textProps),
-    "background: none repeat scroll 0% 0% red; content: \" \"; position: absolute; " +
-    "border-radius: 50%; height: 32px; width: 32px; top: 50%; left: 50%; margin-top: -16px; margin-left: -16px",
-    "TopLeft after properties are correct"
+    convertTextPropsToString(elementFirstLineRule.textProps),
+    "color: orange",
+    "TopLeft firstLine properties are correct"
   );
 
-  let elementBeforeRule = rules.beforeRules[0];
-  let elementBeforeRuleView = [].filter.call(view.element.children, (e) => {
-    return e._ruleEditor && e._ruleEditor.rule === elementBeforeRule;
-  })[0]._ruleEditor;
+  let firstProp = elementFirstLineRuleView.addProperty("background-color", "rgb(0, 255, 0)", "");
+  let secondProp = elementFirstLineRuleView.addProperty("font-style", "italic", "");
 
-  is
-  (
-    convertTextPropsToString(elementBeforeRule.textProps),
-    "top: 0px; left: 0px",
-    "TopLeft before properties are correct"
-  );
-
-  let firstProp = elementAfterRuleView.addProperty("background-color", "rgb(0, 255, 0)", "");
-  let secondProp = elementAfterRuleView.addProperty("padding", "100px", "");
-
-  is (firstProp, elementAfterRule.textProps[elementAfterRule.textProps.length - 2],
+  is (firstProp, elementFirstLineRule.textProps[elementFirstLineRule.textProps.length - 2],
       "First added property is on back of array");
-  is (secondProp, elementAfterRule.textProps[elementAfterRule.textProps.length - 1],
+  is (secondProp, elementFirstLineRule.textProps[elementFirstLineRule.textProps.length - 1],
       "Second added property is on back of array");
 
-  yield elementAfterRule._applyingModifications;
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("background-color"),
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
     "rgb(0, 255, 0)", "Added property should have been used.");
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"),
-    "100px", "Added property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"),
-    "32px", "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("font-style"),
+    "italic", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("text-decoration"),
+    "none", "Added property should not apply to element");
 
-  secondProp.setEnabled(false);
-  yield elementAfterRule._applyingModifications;
+  firstProp.setEnabled(false);
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"), "0px",
-    "Disabled property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"), "32px",
-    "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(255, 0, 0)", "Disabled property should now have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"),
+    "rgb(221, 221, 221)", "Added property should not apply to element");
 
-  secondProp.setEnabled(true);
-  yield elementAfterRule._applyingModifications;
+  firstProp.setEnabled(true);
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"), "100px",
-    "Enabled property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"), "32px",
-    "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(0, 255, 0)", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("text-decoration"),
+    "none", "Added property should not apply to element");
 
   let firstProp = elementRuleView.addProperty("background-color", "rgb(0, 0, 255)", "");
   yield elementRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"), "rgb(0, 0, 255)",
-    "Added property should have been used.");
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("background-color"), "rgb(0, 255, 0)",
-    "Added prop does not apply to pseudo");
+  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"),
+    "rgb(0, 0, 255)", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(0, 255, 0)", "Added prop does not apply to pseudo");
 }
 
 function* testTopRight(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#topright", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 
   let gutters = assertGutters(view);
 
   let expander = gutters[0].querySelector(".ruleview-expander");
   ok (!view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements remain collapsed after switching element");
   expander.scrollIntoView();
   expander.click();
   ok (view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are shown again after clicking twisty");
 }
 
 function* testBottomRight(inspector, view) {
   yield assertPseudoElementRulesNumbers("#bottomright", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 3,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 }
 
 function* testBottomLeft(inspector, view) {
   yield assertPseudoElementRulesNumbers("#bottomleft", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 }
 
 function* testParagraph(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#bottomleft p", inspector, view, {
     elementRulesNb: 3,
-    afterRulesNb: 0,
-    beforeRulesNb: 0,
     firstLineRulesNb: 1,
     firstLetterRulesNb: 1,
     selectionRulesNb: 1
   });
 
   let gutters = assertGutters(view);
 
   let elementFirstLineRule = rules.firstLineRules[0];
@@ -237,39 +215,34 @@ function* testNode(selector, inspector, 
   return {element: element, elementStyle: elementStyle};
 }
 
 function* assertPseudoElementRulesNumbers(selector, inspector, view, ruleNbs) {
   let {element, elementStyle} = yield testNode(selector, inspector, view);
 
   let rules = {
     elementRules: elementStyle.rules.filter(rule => !rule.pseudoElement),
-    afterRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":after"),
-    beforeRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":before"),
     firstLineRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":first-line"),
     firstLetterRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":first-letter"),
     selectionRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":-moz-selection")
   };
 
   is(rules.elementRules.length, ruleNbs.elementRulesNb, selector +
     " has the correct number of non pseudo element rules");
-  is(rules.afterRules.length, ruleNbs.afterRulesNb, selector +
-    " has the correct number of :after rules");
-  is(rules.beforeRules.length, ruleNbs.beforeRulesNb, selector +
-    " has the correct number of :before rules");
   is(rules.firstLineRules.length, ruleNbs.firstLineRulesNb, selector +
     " has the correct number of :first-line rules");
   is(rules.firstLetterRules.length, ruleNbs.firstLetterRulesNb, selector +
     " has the correct number of :first-letter rules");
   is(rules.selectionRules.length, ruleNbs.selectionRulesNb, selector +
     " has the correct number of :selection rules");
 
   return {rules: rules, element: element, elementStyle: elementStyle};
 }
 
 function assertGutters(view) {
   let gutters = view.element.querySelectorAll(".theme-gutter");
   is (gutters.length, 3, "There are 3 gutter headings");
   is (gutters[0].textContent, "Pseudo-elements", "Gutter heading is correct");
   is (gutters[1].textContent, "This Element", "Gutter heading is correct");
   is (gutters[2].textContent, "Inherited from body", "Gutter heading is correct");
+
   return gutters;
-}
+}
\ No newline at end of file
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js
@@ -0,0 +1,32 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that pseudoelements are displayed correctly in the rule view
+
+const TEST_URI = TEST_URL_ROOT + "doc_pseudoelement.html";
+
+let test = asyncTest(function*() {
+  yield addTab(TEST_URI);
+  let {toolbox, inspector, view} = yield openRuleView();
+
+  yield testTopLeft(inspector, view);
+});
+
+function* testTopLeft(inspector, view) {
+  let node = inspector.markup.walker.frontForRawNode(getNode("#topleft"));
+  let children = yield inspector.markup.walker.children(node);
+
+  is (children.nodes.length, 3, "Element has correct number of children");
+
+  let beforeElement = children.nodes[0];
+  is (beforeElement.tagName, "_moz_generated_content_before", "tag name is correct");
+  yield selectNode(beforeElement, inspector);
+
+  let afterElement = children.nodes[children.nodes.length-1];
+  is (afterElement.tagName, "_moz_generated_content_after", "tag name is correct");
+  yield selectNode(afterElement, inspector);
+}
+
diff --git a/browser/devtools/styleinspector/test/doc_pseudoelement.html b/browser/devtools/styleinspector/test/doc_pseudoelement.html
--- a/browser/devtools/styleinspector/test/doc_pseudoelement.html
+++ b/browser/devtools/styleinspector/test/doc_pseudoelement.html
@@ -13,16 +13,25 @@ body {
     width: 128px;
     height: 128px;
     background: #ddd;
     padding: 32px;
     margin: 32px;
     position:relative;
 }
 
+.box:first-line {
+    color: orange;
+    background: red;
+}
+
+.box:first-letter {
+    color: green;
+}
+
 * {
     cursor: default;
 }
 
 nothing {
     cursor: pointer;
 }
 
@@ -64,16 +73,23 @@ p:first-letter {
     margin-left: -16px;
 }
 
 .topleft:before {
     top:0;
     left:0;
 }
 
+.topleft:first-line {
+    color: orange;
+}
+.topleft::selection {
+    color: orange;
+}
+
 .topright:before {
     top:0;
     right:0;
 }
 
 .bottomright:before {
     bottom:10px;
     right:10px;
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -145,31 +145,36 @@ function selectAndHighlightNode(nodeOrSe
   inspector.selection.setNode(node, "test-highlight");
   return updated;
 
 }
 
 /**
  * Set the inspector's current selection to a node or to the first match of the
  * given css selector.
- * @param {String|DOMNode} nodeOrSelector
- * @param {InspectorPanel} inspector
- *        The instance of InspectorPanel currently loaded in the toolbox
- * @param {String} reason
- *        Defaults to "test" which instructs the inspector not to highlight the
- *        node upon selection
+ * @param {String|DOMNode|NodeFront} data The node to select.  If it is a string
+ * or DOMNode it will not be remote safe - using a NodeFront is safer.
+ * @param {InspectorPanel} inspector The instance of InspectorPanel currently
+ * loaded in the toolbox
+ * @param {String} reason Defaults to "test" which instructs the inspector not
+ * to highlight the node upon selection
+ *
  * @return a promise that resolves when the inspector is updated with the new
  * node
  */
-function selectNode(nodeOrSelector, inspector, reason="test") {
-  info("Selecting the node " + nodeOrSelector);
+function selectNode(data, inspector, reason="test") {
+  info("Selecting the node " + data);
 
-  let node = getNode(nodeOrSelector);
+  let node = getNode(data);
   let updated = inspector.once("inspector-updated");
-  inspector.selection.setNode(node, reason);
+  if (node._form) {
+    inspector.selection.setNodeFront(node, reason);
+  } else {
+    inspector.selection.setNode(node, reason);
+  }
   return updated;
 }
 
 /**
  * Set the inspector's current selection to null so that no node is selected
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return a promise that resolves when the inspector is updated
diff --git a/toolkit/devtools/Console.jsm b/toolkit/devtools/Console.jsm
--- a/toolkit/devtools/Console.jsm
+++ b/toolkit/devtools/Console.jsm
@@ -158,17 +158,17 @@ function stringify(aThing, aAllowNewLine
  * @param {nsIDOMElement} aElement
  *        The element to debug
  * @return {string}
  *        A simple single line representation of aElement
  */
 function debugElement(aElement) {
   return "<" + aElement.tagName +
       (aElement.id ? "#" + aElement.id : "") +
-      (aElement.className ?
+      (aElement.className && aElement.className.split ?
           "." + aElement.className.split(" ").join(" .") :
           "") +
       ">";
 }
 
 /**
  * A multi line stringification of an object, designed for use by humans
  *
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -491,8 +491,43 @@ LayoutHelpers.prototype = {
     return {
       p1: {x: xOffset, y: yOffset},
       p2: {x: xOffset + width, y: yOffset},
       p3: {x: xOffset + width, y: yOffset + height},
       p4: {x: xOffset, y: yOffset + height}
     };
   }
 };
+
+/**
+ * Traverse getBindingParent until arriving upon the bound element
+ * responsible for the generation of the specified node.
+ *
+ * @param {DOMNode} node
+ * @return {DOMNode}
+ *         If node is not anonymous, this will return node. Otherwise,
+ *         it will return the bound element
+ *
+ */
+LayoutHelpers.getRootBindingParent = function(node) {
+  let parent;
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return node;
+  }
+  while ((parent = doc.getBindingParent(node))) {
+    node = parent;
+  }
+  return node;
+};
+
+
+/**
+ * Determine whether a node is anonymous by determining if there
+ * is a bindingParent.
+ *
+ * @param {DOMNode} node
+ * @return {bool}
+ *
+ */
+LayoutHelpers.isAnonymous = function(node) {
+  return LayoutHelpers.getRootBindingParent(node) !== node;
+};
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -6,16 +6,17 @@
 
 const {Cu, Cc, Ci} = require("chrome");
 const Services = require("Services");
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method} = protocol;
 const events = require("sdk/event/core");
 const Heritage = require("sdk/core/heritage");
 
+const {CssLogic} = require("devtools/styleinspector/css-logic");
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const GUIDE_STROKE_WIDTH = 1;
 
 // Make sure the domnode type is known here
 require("devtools/server/actors/inspector");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
@@ -950,40 +951,47 @@ BoxModelHighlighter.prototype = Heritage
   /**
    * Update node information (tagName#id.class)
    */
   _updateInfobar: function() {
     if (!this.currentNode) {
       return;
     }
 
-    let node = this.currentNode;
     let info = this.nodeInfo;
 
+    let {elementToRead: node, pseudoToRead} =
+      CssLogic.getStyleableElementAndPseudo(this.currentNode);
+
     // Update the tag, id, classes, pseudo-classes and dimensions only if they
     // changed to avoid triggering paint events
-
     let tagName = node.tagName;
     if (info.tagNameLabel.textContent !== tagName) {
       info.tagNameLabel.textContent = tagName;
     }
 
     let id = node.id ? "#" + node.id : "";
     if (info.idLabel.textContent !== id) {
       info.idLabel.textContent = id;
     }
 
-    let classList = node.classList.length ? "." + [...node.classList].join(".") : "";
+    let classList = (node.classList || []).length ? "." + [...node.classList].join(".") : "";
     if (info.classesBox.textContent !== classList) {
       info.classesBox.textContent = classList;
     }
 
     let pseudos = PSEUDO_CLASSES.filter(pseudo => {
       return DOMUtils.hasPseudoClassLock(node, pseudo);
     }, this).join("");
+
+    if (pseudoToRead) {
+      // Display :after as ::after
+      pseudos += ":" + pseudoToRead;
+    }
+
     if (info.pseudoClassesBox.textContent !== pseudos) {
       info.pseudoClassesBox.textContent = pseudos;
     }
 
     let rect = node.getBoundingClientRect();
     let dim = Math.ceil(rect.width) + " x " + Math.ceil(rect.height);
     if (info.dimensionBox.textContent !== dim) {
       info.dimensionBox.textContent = dim;
@@ -1304,19 +1312,26 @@ function isNodeValid(node) {
     return false;
   }
 
   // Is it an element node
   if (node.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
     return false;
   }
 
-  // Is it connected to the document?
+  // Is the document inaccessible?
   let doc = node.ownerDocument;
-  if (!doc || !doc.defaultView || !doc.documentElement.contains(node)) {
+  if (!doc || !doc.defaultView) {
+    return false;
+  }
+
+  // Is the node connected to the document? Using getBindingParent adds
+  // support for anonymous elements generated by a node in the document.
+  let bindingParent = LayoutHelpers.getRootBindingParent(node);
+  if (!doc.documentElement.contains(bindingParent)) {
     return false;
   }
 
   return true;
 }
 
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -207,40 +207,34 @@ var NodeActor = exports.NodeActor = prot
   // Returns the JSON representation of this object over the wire.
   form: function(detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
 
-    // Estimate the number of children.
-    let numChildren = this.rawNode.childNodes.length;
-    if (numChildren === 0 &&
-        (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
-      // This might be an iframe with virtual children.
-      numChildren = 1;
-    }
-
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
-      numChildren: numChildren,
+      numChildren: this.numChildren,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
-
+      isBeforePseudoElement: this.rawNode.nodeName === "_moz_generated_content_before",
+      isAfterPseudoElement: this.rawNode.nodeName === "_moz_generated_content_after",
+      isAnonymous: LayoutHelpers.isAnonymous(this.rawNode),
       pseudoClassLocks: this.writePseudoClassLocks(),
 
       isDisplayed: this.isDisplayed,
     };
 
     if (this.isDocumentElement()) {
       form.isDocumentElement = true;
     }
@@ -254,16 +248,36 @@ var NodeActor = exports.NodeActor = prot
       } else {
         form.shortValue = this.rawNode.nodeValue;
       }
     }
 
     return form;
   },
 
+  // Return the number of children that the walker will return with a
+  // children() call without actually making the call.
+  get numChildren() {
+    let numChildren = this.rawNode.childNodes.length;
+    if (numChildren === 0 &&
+        (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
+      // This might be an iframe with virtual children.
+      numChildren = 1;
+    }
+
+    // Count any anonymous children
+    if (this.rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+      let anonChildren = this.rawNode.ownerDocument.getAnonymousNodes(this.rawNode);
+      if (anonChildren) {
+        numChildren += anonChildren.length;
+      }
+    }
+    return numChildren;
+  },
+
   get computedStyle() {
     if (Cu.isDeadWrapper(this.rawNode) ||
         this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE ||
         !this.rawNode.ownerDocument ||
         !this.rawNode.ownerDocument.defaultView) {
       return null;
     }
     return this.rawNode.ownerDocument.defaultView.getComputedStyle(this.rawNode);
@@ -546,16 +560,21 @@ let NodeFront = protocol.FrontClass(Node
 
   get className() {
     return this.getAttribute("class") || '';
   },
 
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
 
+  get isBeforePseudoElement() this._form.isBeforePseudoElement,
+  get isAfterPseudoElement() this._form.isAfterPseudoElement,
+  get isPseudoElement() this.isBeforePseudoElement || this.isAfterPseudoElement,
+  get isAnonymous() this._form.isAnonymous,
+
   get tagName() this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE ? this.nodeName : null,
   get shortValue() this._form.shortValue,
   get incompleteValue() !!this._form.incompleteValue,
 
   get isDocumentElement() !!this._form.isDocumentElement,
 
   // doctype properties
   get name() this._form.name,
@@ -1967,17 +1986,18 @@ var WalkerActor = protocol.ActorClass({
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
       let mutation = {
         type: change.type,
         target: targetActor.actorID,
-      }
+        numChildren: targetActor.numChildren
+      };
 
       if (mutation.type === "attributes") {
         mutation.attributeName = change.attributeName;
         mutation.attributeNamespace = change.attributeNamespace || undefined;
         mutation.newValue = targetNode.getAttribute(mutation.attributeName);
       } else if (mutation.type === "characterData") {
         if (targetNode.nodeValue.length > gValueSummaryLength) {
           mutation.newValue = targetNode.nodeValue.substring(0, gValueSummaryLength);
@@ -2010,17 +2030,17 @@ var WalkerActor = protocol.ActorClass({
             continue;
           }
           // The actor is reconnected to the ownership tree, unorphan
           // it and let the client know so that its ownership tree is up
           // to date.
           this._orphaned.delete(addedActor);
           addedActors.push(addedActor.actorID);
         }
-        mutation.numChildren = change.target.childNodes.length;
+
         mutation.removed = removedActors;
         mutation.added = addedActors;
       }
       this.queueMutation(mutation);
     }
   },
 
   onFrameLoad: function({ window, isTopLevel }) {
@@ -2405,17 +2425,23 @@ var WalkerFront = exports.WalkerFront = 
             // it.
             this._orphaned.delete(addedFront);
             addedFronts.push(addedFront);
           }
           // Before passing to users, replace the added and removed actor
           // ids with front in the mutation record.
           emittedMutation.added = addedFronts;
           emittedMutation.removed = removedFronts;
-          targetFront._form.numChildren = change.numChildren;
+
+          // If this is coming from a DOM mutation, the actor's numChildren
+          // was passed in.  Otherwise, it is simulated from a frame load or
+          // unload, so don't change the _front.
+          if ('numChildren' in change) {
+            targetFront._form.numChildren = change.numChildren;
+          }
         } else if (change.type === "frameLoad") {
           // Nothing we need to do here, except verify that we don't have any
           // document children, because we should have gotten a documentUnload
           // first.
           for (let child of targetFront.treeChildren()) {
             if (child.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE) {
               console.trace("Got an unexpected frameLoad in the inspector, please file a bug on bugzilla.mozilla.org!");
             }
@@ -2768,104 +2794,84 @@ function documentWalker(node, rootWin, w
 // Exported for test purposes.
 exports._documentWalker = documentWalker;
 
 function nodeDocument(node) {
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
- * Similar to a TreeWalker, except will dig in to iframes and it doesn't
- * implement the good methods like previousNode and nextNode.
- *
- * See TreeWalker documentation for explanations of the methods.
+ * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
+ * See inDeepTreeWalker for more information about the methods.
  */
 function DocumentWalker(aNode, aRootWin, aShow, aFilter, aExpandEntityReferences) {
   if (!aRootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
-  let doc = nodeDocument(aNode);
-  this.layoutHelpers = new LayoutHelpers(aRootWin);
-  this.walker = doc.createTreeWalker(doc,
-    aShow, aFilter, aExpandEntityReferences);
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.init(aRootWin.document, aShow);
   this.walker.currentNode = aNode;
   this.filter = aFilter;
 }
 
 DocumentWalker.prototype = {
   get node() this.walker.node,
   get whatToShow() this.walker.whatToShow,
   get expandEntityReferences() this.walker.expandEntityReferences,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
 
-  /**
-   * Called when the new node is in a different document than
-   * the current node, creates a new treewalker for the document we've
-   * run in to.
-   */
-  _reparentWalker: function(aNewNode) {
-    if (!aNewNode) {
-      return null;
-    }
-    let doc = nodeDocument(aNewNode);
-    let walker = doc.createTreeWalker(doc,
-      this.whatToShow, this.filter, this.expandEntityReferences);
-    walker.currentNode = aNewNode;
-    this.walker = walker;
-    return aNewNode;
-  },
-
   parentNode: function() {
-    let currentNode = this.walker.currentNode;
-    let parentNode = this.walker.parentNode();
-
-    if (!parentNode) {
-      if (currentNode && currentNode.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE
-          && currentNode.defaultView) {
-
-        let window = currentNode.defaultView;
-        let frame = this.layoutHelpers.getFrameElement(window);
-        if (frame) {
-          return this._reparentWalker(frame);
-        }
-      }
-      return null;
-    }
-
-    return parentNode;
+    return this.walker.parentNode();
   },
 
   firstChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument) {
-      return this._reparentWalker(node.getSVGDocument());
+
+    let firstChild = this.walker.firstChild();
+    while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      firstChild = this.walker.nextSibling();
     }
-    return this.walker.firstChild();
+
+    return firstChild;
   },
 
   lastChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument) {
-      return this._reparentWalker(node.getSVGDocument());
+
+    let lastChild = this.walker.lastChild();
+    while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      lastChild = this.walker.previousSibling();
     }
-    return this.walker.lastChild();
+
+    return lastChild;
   },
 
-  previousSibling: function DW_previousSibling() this.walker.previousSibling(),
-  nextSibling: function DW_nextSibling() this.walker.nextSibling()
+  previousSibling: function() {
+    let node = this.walker.previousSibling();
+    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      node = this.walker.previousSibling();
+    }
+    return node;
+  },
+
+  nextSibling: function() {
+    let node = this.walker.nextSibling();
+    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      node = this.walker.nextSibling();
+    }
+    return node;
+  }
 };
 
 /**
  * A tree walker filter for avoiding empty whitespace text nodes.
  */
 function whitespaceTextFilter(aNode) {
     if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
         !/[^\s]/.exec(aNode.nodeValue)) {
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -20,16 +20,19 @@ loader.lazyGetter(this, "DOMUtils", () =
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
 const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
+const PSEUDO_ELEMENTS_TO_READ = PSEUDO_ELEMENTS.filter(pseudo => {
+  return pseudo !== ":before" && pseudo !== ":after";
+});
 
 // Predeclare the domnode actor type for use in requests.
 types.addActorType("domnode");
 
 // Predeclare the domstylerule actor type
 types.addActorType("domstylerule");
 
 /**
@@ -297,17 +300,17 @@ var PageStyleActor = protocol.ActorClass
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSeletors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
   getApplied: method(function(node, options) {
     let entries = [];
-    this.addElementRules(node.rawNode, undefined, options, entries);
+    entries = entries.concat(this._getAllElementRules(node, undefined, options));
     return this.getAppliedProps(node, entries, options);
   }, {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
@@ -317,77 +320,127 @@ var PageStyleActor = protocol.ActorClass
   _hasInheritedProps: function(style) {
     return Array.prototype.some.call(style, prop => {
       return DOMUtils.isInheritedProperty(prop);
     });
   },
 
   /**
    * Helper function for getApplied, adds all the rules from a given
-   * element.
+   * element. See getApplied for documentation on parameters.
+   * @param NodeActor node
+   * @param bool inherited
+   * @param object options
+   * @param Array rules (modifies this instead of returning)
    */
-  addElementRules: function(element, inherited, options, rules)
+  _getAllElementRules: function(node, inherited, options)
   {
-    if (!element.style) {
-      return;
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(node.rawNode);
+    let rules = [];
+
+    if (!elementToRead || !elementToRead.style) {
+      return rules;
     }
 
-    let elementStyle = this._styleRef(element);
+    let elementStyle = this._styleRef(elementToRead);
+    let showElementStyles = !inherited && !pseudoToRead;
+    let showInheritedStyles = inherited && this._hasInheritedProps(elementToRead.style);
 
-    if (!inherited || this._hasInheritedProps(element.style)) {
+    // First any inline styles
+    if (showElementStyles) {
       rules.push({
         rule: elementStyle,
-        inherited: inherited,
       });
     }
 
-    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
-    for (let pseudo of pseudoElements) {
+    // Now any inherited styles
+    if (showInheritedStyles) {
+      rules.push({
+        rule: elementStyle,
+        inherited: inherited
+      });
+    }
 
-      // Get the styles that apply to the element.
-      let domRules = DOMUtils.getCSSStyleRules(element, pseudo);
+    // Add normal rules.  Typically this is passing in the node passed into the
+    // function, unless if that node was ::before/::after.  In which case,
+    // it will pass in the parentNode along with "::before"/"::after".
+    this._getElementRules(elementToRead, pseudoToRead, inherited, options).forEach((rule) => {
+      // The only case when there would be a pseudo here is ::before/::after,
+      // and in this case we want to tell the view that it belongs to the
+      // element (which is a _moz_generated_content native anonymous element).
+      rule.pseudoElement = null;
+      rules.push(rule);
+    });
 
-      if (!domRules) {
+    // Now any pseudos (except for ::before / ::after, which was handled as
+    // a 'normal rule' above.
+    if (showElementStyles) {
+      for (let pseudo of PSEUDO_ELEMENTS_TO_READ) {
+        this._getElementRules(elementToRead, pseudo, inherited, options).forEach((rule) => {
+          rules.push(rule);
+        });
+      }
+    }
+
+    return rules;
+  },
+
+  /**
+   * Helper function for _getAllElementRules, returns the rules from a given
+   * element. See getApplied for documentation on parameters.
+   * @param DOMNode elementToRead
+   * @param string pseudoToRead
+   * @param DOMNode inherited
+   * @param object options
+   *
+   * @returns Array rules
+   */
+  _getElementRules: function (elementToRead, pseudoToRead, inherited, options) {
+    let domRules = DOMUtils.getCSSStyleRules(elementToRead, pseudoToRead);
+    if (!domRules) {
+      return [];
+    }
+
+    let rules = [];
+
+    // getCSSStyleRules returns ordered from least-specific to
+    // most-specific.
+    for (let i = domRules.Count() - 1; i >= 0; i--) {
+      let domRule = domRules.GetElementAt(i);
+
+      let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
+
+      if (isSystem && options.filter != CssLogic.FILTER.UA) {
         continue;
       }
 
-      // getCSSStyleRules returns ordered from least-specific to
-      // most-specific.
-      for (let i = domRules.Count() - 1; i >= 0; i--) {
-        let domRule = domRules.GetElementAt(i);
-
-        let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
-
-        if (isSystem && options.filter != CssLogic.FILTER.UA) {
+      if (inherited) {
+        // Don't include inherited rules if none of its properties
+        // are inheritable.
+        let hasInherited = Array.prototype.some.call(domRule.style, prop => {
+          return DOMUtils.isInheritedProperty(prop);
+        });
+        if (!hasInherited) {
           continue;
         }
-
-        if (inherited) {
-          // Don't include inherited rules if none of its properties
-          // are inheritable.
-          let hasInherited = Array.prototype.some.call(domRule.style, prop => {
-            return DOMUtils.isInheritedProperty(prop);
-          });
-          if (!hasInherited) {
-            continue;
-          }
-        }
-
-        let ruleActor = this._styleRef(domRule);
-        rules.push({
-          rule: ruleActor,
-          inherited: inherited,
-          pseudoElement: pseudo,
-          isSystem: isSystem
-        });
       }
 
+      let ruleActor = this._styleRef(domRule);
+      rules.push({
+        rule: ruleActor,
+        inherited: inherited,
+        isSystem: isSystem,
+        pseudoElement: pseudoToRead
+      });
     }
+
+    return rules;
   },
 
+
   /**
    * Helper function for getApplied and addNewRule that fetches a set of
    * style properties that apply to the given node and associated rules
    * @param NodeActor node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
@@ -403,32 +456,36 @@ var PageStyleActor = protocol.ActorClass
    * @returns Object containing the list of rule entries, rule actors and
    *   stylesheet actors that applies to the given node and its associated
    *   rules.
    */
   getAppliedProps: function(node, entries, options) {
     if (options.inherited) {
       let parent = this.walker.parentNode(node);
       while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
-        this.addElementRules(parent.rawNode, parent, options, entries);
+        entries = entries.concat(this._getAllElementRules(parent, parent, options));
         parent = this.walker.parentNode(parent);
       }
     }
 
     if (options.matchedSelectors) {
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
         }
 
         let domRule = entry.rule.rawRule;
         let selectors = CssLogic.getSelectors(domRule);
         let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;
+
+        // XXX: uncomment after bug 1037519 lands
+        // let {pseudoToRead,elementToRead} = CssLogic.getStyleableElementAndPseudo(element);
         entry.matchedSelectors = [];
         for (let i = 0; i < selectors.length; i++) {
+          // if (DOMUtils.selectorMatchesElement(elementToRead, domRule, i, pseudoToRead)) {
           if (DOMUtils.selectorMatchesElement(element, domRule, i)) {
             entry.matchedSelectors.push(selectors[i]);
           }
         }
       }
     }
 
     let rules = new Set;
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -49,16 +49,17 @@ const RX_CONNECTORS = /\s*[\s>+~]\s*/g;
 const RX_ID = /\s*#\w+\s*/g;
 const RX_CLASS_OR_ATTRIBUTE = /\s*(?:\.\w+|\[.+?\])\s*/g;
 const RX_PSEUDO = /\s*:?:([\w-]+)(\(?\)?)\s*/g;
 
 // This should be ok because none of the functions that use this should be used
 // on the worker thread, where Cu is not available.
 if (Cu) {
   Cu.importGlobalProperties(['CSS']);
+  Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 }
 
 function CssLogic()
 {
   // The cache of examined CSS properties.
   _propertyInfos: {};
 }
 
@@ -171,17 +172,22 @@ CssLogic.prototype = {
     } else {
       // Clear cached data in the CssPropertyInfo objects.
       this._propertyInfos = {};
     }
 
     this._matchedRules = null;
     this._matchedSelectors = null;
     let win = this.viewedDocument.defaultView;
-    this._computedStyle = win.getComputedStyle(this.viewedElement, "");
+
+    // Handle computed styles on pseudo by reading style rules
+    // on the parent node with proper pseudo arg to getComputedStyle.
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(this.viewedElement);
+
+    this._computedStyle = win.getComputedStyle(elementToRead, pseudoToRead);
   },
 
   /**
    * Get the source filter.
    * @returns {string} The source filter being used.
    */
   get sourceFilter() {
     return this._sourceFilter;
@@ -582,24 +588,29 @@ CssLogic.prototype = {
       return;
     }
 
     do {
       let status = this.viewedElement === element ?
                    CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
 
       try {
-        domRules = domUtils.getCSSStyleRules(element);
+        // Handle finding rules on pseudo by reading style rules
+        // on the parent node with proper pseudo arg to getCSSStyleRules.
+        let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(element);
+        domRules = domUtils.getCSSStyleRules(elementToRead, pseudoToRead);
       } catch (ex) {
         Services.console.
           logStringMessage("CL__buildMatchedRules error: " + ex);
         continue;
       }
 
-      for (let i = 0, n = domRules.Count(); i < n; i++) {
+      // getCSSStyleRules can return null with a shadow DOM element.
+      let numDomRules = domRules ? domRules.Count() : 0;
+      for (let i = 0; i < numDomRules; i++) {
         let domRule = domRules.GetElementAt(i);
         if (domRule.type !== Ci.nsIDOMCSSRule.STYLE_RULE) {
           continue;
         }
 
         let sheet = this.getSheet(domRule.parentStyleSheet, -1);
         if (sheet._passId !== this._passId) {
           sheet.index = sheetIndex++;
@@ -615,17 +626,16 @@ CssLogic.prototype = {
           continue;
         }
 
         rule._matchId = this._matchId;
         rule._passId = this._passId;
         this._matchedRules.push([rule, status]);
       }
 
-
       // Add element.style information.
       if (element.style && element.style.length > 0) {
         let rule = new CssRule(null, { style: element.style }, element);
         rule._matchId = this._matchId;
         rule._passId = this._passId;
         this._matchedRules.push([rule, status]);
       }
     } while ((element = element.parentNode) &&
@@ -722,16 +732,44 @@ CssLogic.getSelectors = function CssLogi
   let len = domUtils.getSelectorCount(aDOMRule);
   for (let i = 0; i < len; i++) {
     let text = domUtils.getSelectorText(aDOMRule, i);
     selectors.push(text);
   }
   return selectors;
 }
 
+
+
+/**
+ * Given a node, check to see if it is a ::before or ::after element.
+ * If so, return the node that is accessible from within the document
+ * (the parent of the anonymous node), along with which pseudo element
+ * it was.  Otherwise, return the node itself.
+ *
+ * @returns {Object}
+ *            - {DOMNode} elementToRead The non-anonymous node
+ *            - {string} pseudoToRead One of ':before', ':after', or null.
+ */
+CssLogic.getStyleableElementAndPseudo = function(node) {
+  let elementToRead = node;
+  let pseudoToRead = null;
+  if (node.nodeName == "_moz_generated_content_before") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":before";
+  } else if (node.nodeName == "_moz_generated_content_after") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":after";
+  }
+  return {
+    elementToRead: elementToRead,
+    pseudoToRead: pseudoToRead
+  };
+},
+
 /**
  * Memonized lookup of a l10n string from a string bundle.
  * @param {string} aName The key to lookup.
  * @returns A localized version of the given key.
  */
 CssLogic.l10n = function(aName) CssLogic._strings.GetStringFromName(aName);
 
 DevToolsUtils.defineLazyGetter(CssLogic, "_strings", function() Services.strings
@@ -828,18 +866,19 @@ function positionInNodeList(element, nod
 }
 
 /**
  * Find a unique CSS selector for a given element
  * @returns a string such that ele.ownerDocument.querySelector(reply) === ele
  * and ele.ownerDocument.querySelectorAll(reply).length === 1
  */
 CssLogic.findCssSelector = function CssLogic_findCssSelector(ele) {
+  ele = LayoutHelpers.getRootBindingParent(ele);
   var document = ele.ownerDocument;
-  if (!document.contains(ele)) {
+  if (!document || !document.contains(ele)) {
     throw new Error('findCssSelector received element not inside document');
   }
 
   // document.querySelectorAll("#id") returns multiple if elements share an ID
   if (ele.id && document.querySelectorAll('#' + CSS.escape(ele.id)).length === 1) {
     return '#' + CSS.escape(ele.id);
   }
 
