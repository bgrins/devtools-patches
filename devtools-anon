# HG changeset patch
# Parent b04a8dfa0b3b595aa785f90b33ed7739f378fd1b
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 777674 - Add support for inspecting anonymous content;r=pbrosset

diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -88,17 +88,17 @@ FontInspector.prototype = {
       return;
     }
 
     let node = this.inspector.selection.node;
     let contentDocument = node.ownerDocument;
 
     // We don't get fonts for a node, but for a range
     let rng = contentDocument.createRange();
-    rng.selectNode(node);
+    rng.selectNodeContents(node);
     let fonts = DOMUtils.getUsedFontFaces(rng);
     let fontsArray = [];
     for (let i = 0; i < fonts.length; i++) {
       fontsArray.push(fonts.item(i));
     }
     fontsArray = fontsArray.sort(function(a, b) {
       return a.srcIndex < b.srcIndex;
     });
diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
--- a/browser/devtools/framework/selection.js
+++ b/browser/devtools/framework/selection.js
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {Cu, Ci} = require("chrome");
 let EventEmitter = require("devtools/toolkit/event-emitter");
+Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 /**
  * API
  *
  *   new Selection(walker=null, node=null, track={attributes,detached});
  *   destroy()
  *   node (readonly)
  *   setNode(node, origin="unknown")
@@ -220,21 +221,28 @@ Selection.prototype = {
     // accessing node.rawNode, this needs to stay.
     let rawNode = null;
     if (node.isLocal_toBeDeprecated()) {
       rawNode = node.rawNode();
     }
     if (rawNode) {
       try {
         let doc = this.document;
-        return (doc && doc.defaultView && doc.documentElement.contains(rawNode));
+        if (doc && doc.defaultView) {
+          let docEl = doc.documentElement;
+          let bindingParent = LayoutHelpers.getRootBindingParent(rawNode);
+
+          if (docEl.contains(bindingParent)) {
+            return true;
+          }
+        }
       } catch (e) {
         // "can't access dead object" error
-        return false;
       }
+      return false;
     }
 
     while(node) {
       if (node === this._walker.rootNode) {
         return true;
       }
       node = node.parentNode();
     };
@@ -247,16 +255,24 @@ Selection.prototype = {
   },
 
   // Node type
 
   isElementNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
   },
 
+  isPseudoElementNode: function() {
+    return this.isNode() && this.nodeFront.isPseudoElement;
+  },
+
+  isAnonymousNode: function() {
+    return this.isNode() && this.nodeFront.isAnonymous;
+  },
+
   isAttributeNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
   },
 
   isTextNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
   },
 
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -577,37 +577,40 @@ InspectorPanel.prototype = {
     }
     return null;
   },
 
   /**
    * Disable the delete item if needed. Update the pseudo classes.
    */
   _setupNodeMenu: function InspectorPanel_setupNodeMenu() {
-    let isSelectionElement = this.selection.isElementNode();
+    let isSelectionElement = this.selection.isElementNode() &&
+                             !this.selection.isPseudoElementNode();
+    let isEditableElement = isSelectionElement &&
+                            !this.selection.isAnonymousNode();
 
     // Set the pseudo classes
     for (let name of ["hover", "active", "focus"]) {
       let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);
 
       if (isSelectionElement) {
         let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
         menu.setAttribute("checked", checked);
         menu.removeAttribute("disabled");
       } else {
         menu.setAttribute("disabled", "true");
       }
     }
 
     // Disable delete item if needed
     let deleteNode = this.panelDoc.getElementById("node-menu-delete");
-    if (this.selection.isRoot() || this.selection.isDocumentTypeNode()) {
+    if (isEditableElement) {
+      deleteNode.removeAttribute("disabled");
+    } else {
       deleteNode.setAttribute("disabled", "true");
-    } else {
-      deleteNode.removeAttribute("disabled");
     }
 
     // Disable / enable "Copy Unique Selector", "Copy inner HTML" &
     // "Copy outer HTML" as appropriate
     let unique = this.panelDoc.getElementById("node-menu-copyuniqueselector");
     let copyInnerHTML = this.panelDoc.getElementById("node-menu-copyinner");
     let copyOuterHTML = this.panelDoc.getElementById("node-menu-copyouter");
     if (isSelectionElement) {
@@ -618,38 +621,38 @@ InspectorPanel.prototype = {
       unique.setAttribute("disabled", "true");
       copyInnerHTML.setAttribute("disabled", "true");
       copyOuterHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "edit HTML" item if the selection is an element and the root
     // actor has the appropriate trait (isOuterHTMLEditable)
     let editHTML = this.panelDoc.getElementById("node-menu-edithtml");
-    if (this.isOuterHTMLEditable && isSelectionElement) {
+    if (isEditableElement && this.isOuterHTMLEditable) {
       editHTML.removeAttribute("disabled");
     } else {
       editHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "paste outer HTML" item if the selection is an element and
     // the root actor has the appropriate trait (isOuterHTMLEditable) and if
     // the clipbard content is appropriate.
     let pasteOuterHTML = this.panelDoc.getElementById("node-menu-pasteouterhtml");
-    if (this.isOuterHTMLEditable && isSelectionElement &&
+    if (isEditableElement && this.isOuterHTMLEditable &&
         this._getClipboardContentForOuterHTML()) {
       pasteOuterHTML.removeAttribute("disabled");
     } else {
       pasteOuterHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "copy image data-uri" item if the selection is previewable
     // which essentially checks if it's an image or canvas tag
     let copyImageData = this.panelDoc.getElementById("node-menu-copyimagedatauri");
     let markupContainer = this.markup.getContainer(this.selection.nodeFront);
-    if (markupContainer && markupContainer.isPreviewable()) {
+    if (isSelectionElement && markupContainer && markupContainer.isPreviewable()) {
       copyImageData.removeAttribute("disabled");
     } else {
       copyImageData.setAttribute("disabled", "true");
     }
   },
 
   _resetNodeMenu: function InspectorPanel_resetNodeMenu() {
     // Remove any extra items
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -18,16 +18,17 @@ const NEW_SELECTION_HIGHLIGHTER_TIMER = 
 
 const {UndoStack} = require("devtools/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/markupview/html-editor");
 const promise = require("devtools/toolkit/deprecated-sync-thenables");
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const EventEmitter = require("devtools/toolkit/event-emitter");
+const Heritage = require("sdk/core/heritage");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
@@ -177,17 +178,17 @@ MarkupView.prototype = {
     while (parentNode !== this.doc.body) {
       if (parentNode.container) {
         container = parentNode.container;
         break;
       }
       parentNode = parentNode.parentNode;
     }
 
-    if (container) {
+    if (container instanceof MarkupElementContainer) {
       // With the newly found container, delegate the tooltip content creation
       // and decision to show or not the tooltip
       container._buildEventTooltipContent(event.target, this.tooltip);
     }
   },
 
   _hoveredNode: null,
 
@@ -292,34 +293,34 @@ MarkupView.prototype = {
   },
 
   /**
    * Executed when the mouse hovers over a target in the markup-view and is used
    * to decide whether this target should be used to display an image preview
    * tooltip.
    * Delegates the actual decision to the corresponding MarkupContainer instance
    * if one is found.
-   * @return the promise returned by MarkupContainer._isImagePreviewTarget
+   * @return the promise returned by MarkupElementContainer._isImagePreviewTarget
    */
   _isImagePreviewTarget: function(target) {
     // From the target passed here, let's find the parent MarkupContainer
     // and ask it if the tooltip should be shown
     let parent = target, container;
     while (parent !== this.doc.body) {
       if (parent.container) {
         container = parent.container;
         break;
       }
       parent = parent.parentNode;
     }
 
-    if (container) {
+    if (container instanceof MarkupElementContainer) {
       // With the newly found container, delegate the tooltip content creation
       // and decision to show or not the tooltip
-      return container._isImagePreviewTarget(target, this.tooltip);
+      return container.isImagePreviewTarget(target, this.tooltip);
     }
   },
 
   /**
    * Given the known reason, should the current selection be briefly highlighted
    * In a few cases, we don't want to highlight the node:
    * - If the reason is null (used to reset the selection),
    * - if it's "inspector-open" (when the inspector opens up, let's not highlight
@@ -498,17 +499,18 @@ MarkupView.prototype = {
   },
 
   /**
    * Delete a node from the DOM.
    * This is an undoable action.
    */
   deleteNode: function(aNode) {
     if (aNode.isDocumentElement ||
-        aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
+        aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE ||
+        aNode.isAnonymous) {
       return;
     }
 
     let container = this.getContainer(aNode);
 
     // Retain the node so we can undo this...
     this.walker.retainNode(aNode).then(() => {
       let parent = aNode.parentNode();
@@ -559,40 +561,48 @@ MarkupView.prototype = {
     if (!aIgnoreFocus) {
       aContainer.focus();
     }
   },
 
   /**
    * Make sure a node is included in the markup tool.
    *
-   * @param DOMNode aNode
+   * @param NodeFront aNode
    *        The node in the content document.
    * @param boolean aFlashNode
    *        Whether the newly imported node should be flashed
    * @returns MarkupContainer The MarkupContainer object for this element.
    */
   importNode: function(aNode, aFlashNode) {
     if (!aNode) {
       return null;
     }
 
     if (this._containers.has(aNode)) {
       return this.getContainer(aNode);
     }
 
+    let container;
+    let {nodeType, isPseudoElement} = aNode;
     if (aNode === this.walker.rootNode) {
-      var container = new RootContainer(this, aNode);
+      container = new RootContainer(this, aNode);
       this._elt.appendChild(container.elt);
       this._rootNode = aNode;
+    } else if (nodeType == Ci.nsIDOMNode.ELEMENT_NODE && !isPseudoElement) {
+      container = new MarkupElementContainer(this, aNode, this._inspector);
+    } else if (nodeType == Ci.nsIDOMNode.COMMENT_NODE ||
+               nodeType == Ci.nsIDOMNode.TEXT_NODE) {
+      container = new MarkupTextContainer(this, aNode, this._inspector);
     } else {
-      var container = new MarkupContainer(this, aNode, this._inspector);
-      if (aFlashNode) {
-        container.flashMutation();
-      }
+      container = new MarkupReadOnlyContainer(this, aNode, this._inspector);
+    }
+
+    if (aFlashNode) {
+      container.flashMutation();
     }
 
     this._containers.set(aNode, container);
     container.childrenDirty = true;
 
     this._updateChildren(container);
 
     return container;
@@ -948,17 +958,17 @@ MarkupView.prototype = {
   _ensureVisible: function(node) {
     while (node) {
       let container = this.getContainer(node);
       let parent = node.parentNode();
       if (!container.elt.parentNode) {
         let parentContainer = this.getContainer(parent);
         if (parentContainer) {
           parentContainer.childrenDirty = true;
-          this._updateChildren(parentContainer, {expand: node});
+          this._updateChildren(parentContainer, {expand: true});
         }
       }
 
       node = parent;
     }
     return this._waitForChildren();
   },
 
@@ -1293,262 +1303,102 @@ MarkupView.prototype = {
 
     win.setTimeout(() => {
       this._updatePreview();
       this._previewBar.classList.remove("hide");
     }, 1000);
   }
 };
 
-
 /**
  * The main structure for storing a document node in the markup
  * tree.  Manages creation of the editor for the node and
  * a <ul> for placing child elements, and expansion/collapsing
  * of the element.
  *
- * @param MarkupView aMarkupView
- *        The markup view that owns this container.
- * @param DOMNode aNode
- *        The node to display.
- * @param Inspector aInspector
- *        The inspector tool container the markup-view
+ * This should not be instantiated directly, instead use one of:
+ *    MarkupReadOnlyContainer
+ *    MarkupTextContainer
+ *    MarkupElementContainer
  */
-function MarkupContainer(aMarkupView, aNode, aInspector) {
-  this.markup = aMarkupView;
-  this.doc = this.markup.doc;
-  this.undo = this.markup.undo;
-  this.node = aNode;
-  this._inspector = aInspector;
-
-  if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
-    this.editor = new TextEditor(this, aNode, "text");
-  } else if (aNode.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
-    this.editor = new TextEditor(this, aNode, "comment");
-  } else if (aNode.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
-    this.editor = new ElementEditor(this, aNode);
-  } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
-    this.editor = new DoctypeEditor(this, aNode);
-  } else {
-    this.editor = new GenericEditor(this, aNode);
-  }
-
-  // The template will fill the following properties
-  this.elt = null;
-  this.expander = null;
-  this.tagState = null;
-  this.tagLine = null;
-  this.children = null;
-  this.markup.template("container", this);
-  this.elt.container = this;
-  this.children.container = this;
-
-  // Expanding/collapsing the node on dblclick of the whole tag-line element
-  this._onToggle = this._onToggle.bind(this);
-  this.elt.addEventListener("dblclick", this._onToggle, false);
-  this.expander.addEventListener("click", this._onToggle, false);
-
-  // Appending the editor element and attaching event listeners
-  this.tagLine.appendChild(this.editor.elt);
-
-  this._onMouseDown = this._onMouseDown.bind(this);
-  this.elt.addEventListener("mousedown", this._onMouseDown, false);
-
-  // Prepare the image preview tooltip data if any
-  this._prepareImagePreview();
-
-  // Marking the node as shown or hidden
-  this.isDisplayed = this.node.isDisplayed;
-}
+function MarkupContainer() { }
 
 MarkupContainer.prototype = {
+
+  /*
+   * Initialize the MarkupContainer.  Should be called while one
+   * of the other contain classes is instantiated.
+   *
+   * @param MarkupView markupView
+   *        The markup view that owns this container.
+   * @param NodeFront node
+   *        The node to display.
+   * @param string templateID
+   *        Which template to render for this container
+   */
+  initialize: function(markupView, node, templateID) {
+    this.markup = markupView;
+    this.node = node;
+    this.undo = this.markup.undo;
+
+    // The template will fill the following properties
+    this.elt = null;
+    this.expander = null;
+    this.tagState = null;
+    this.tagLine = null;
+    this.children = null;
+    this.markup.template(templateID, this);
+    this.elt.container = this;
+
+    // Binding event listeners
+    this._onMouseDown = this._onMouseDown.bind(this);
+    this.elt.addEventListener("mousedown", this._onMouseDown, false);
+
+    this._onToggle = this._onToggle.bind(this);
+    this.elt.addEventListener("dblclick", this._onToggle, false);
+
+    // Marking the node as shown or hidden
+    this.isDisplayed = this.node.isDisplayed;
+  },
+
   toString: function() {
     return "[MarkupContainer for " + this.node + "]";
   },
 
   isPreviewable: function() {
-    if (this.node.tagName) {
+    if (this.node.tagName && !this.node.isPseudoElement) {
       let tagName = this.node.tagName.toLowerCase();
       let srcAttr = this.editor.getAttributeElement("src");
       let isImage = tagName === "img" && srcAttr;
       let isCanvas = tagName === "canvas";
 
       return isImage || isCanvas;
     } else {
       return false;
     }
   },
 
   /**
-   * If the node is an image or canvas (@see isPreviewable), then get the
-   * image data uri from the server so that it can then later be previewed in
-   * a tooltip if needed.
-   * Stores a promise in this.tooltipData.data that resolves when the data has
-   * been retrieved
-   */
-  _prepareImagePreview: function() {
-    if (this.isPreviewable()) {
-      // Get the image data for later so that when the user actually hovers over
-      // the element, the tooltip does contain the image
-      let def = promise.defer();
-
-      this.tooltipData = {
-        target: this.editor.getAttributeElement("src") || this.editor.tag,
-        data: def.promise
-      };
-
-      let maxDim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");
-      this.node.getImageData(maxDim).then(data => {
-        data.data.string().then(str => {
-          let res = {data: str, size: data.size};
-          // Resolving the data promise and, to always keep tooltipData.data
-          // as a promise, create a new one that resolves immediately
-          def.resolve(res);
-          this.tooltipData.data = promise.resolve(res);
-        });
-      }, () => {
-        this.tooltipData.data = promise.reject();
-      });
-    }
-  },
-
-  /**
-   * Executed by MarkupView._isImagePreviewTarget which is itself called when the
-   * mouse hovers over a target in the markup-view.
-   * Checks if the target is indeed something we want to have an image tooltip
-   * preview over and, if so, inserts content into the tooltip.
-   * @return a promise that resolves when the content has been inserted or
-   * rejects if no preview is required. This promise is then used by Tooltip.js
-   * to decide if/when to show the tooltip
-   */
-  _isImagePreviewTarget: function(target, tooltip) {
-    if (!this.tooltipData || this.tooltipData.target !== target) {
-      return promise.reject();
-    }
-
-    return this.tooltipData.data.then(({data, size}) => {
-      tooltip.setImageContent(data, size);
-    }, () => {
-      tooltip.setBrokenImageContent();
-    });
-  },
-
-  /**
    * Show the element has displayed or not
    */
   set isDisplayed(isDisplayed) {
     this.elt.classList.remove("not-displayed");
     if (!isDisplayed) {
       this.elt.classList.add("not-displayed");
     }
   },
 
-  copyImageDataUri: function() {
-    // We need to send again a request to gettooltipData even if one was sent for
-    // the tooltip, because we want the full-size image
-    this.node.getImageData().then(data => {
-      data.data.string().then(str => {
-        clipboardHelper.copyString(str, this.markup.doc);
-      });
-    });
-  },
-
-  _buildEventTooltipContent: function(target, tooltip) {
-    if (target.hasAttribute("data-event")) {
-      tooltip.hide(target);
-
-      this.node.getEventListenerInfo().then(listenerInfo => {
-        tooltip.setEventContent({
-          eventListenerInfos: listenerInfo,
-          toolbox: this._inspector.toolbox
-        });
-
-        this.markup._makeTooltipPersistent(true);
-        tooltip.once("hidden", () => {
-          this.markup._makeTooltipPersistent(false);
-        });
-
-        tooltip.show(target);
-      });
-      return true;
-    }
-  },
-
-  /**
-   * True if the current node has children.  The MarkupView
-   * will set this attribute for the MarkupContainer.
-   */
-  _hasChildren: false,
-
-  get hasChildren() {
-    return this._hasChildren;
-  },
-
-  set hasChildren(aValue) {
-    this._hasChildren = aValue;
-    if (aValue) {
-      this.expander.style.visibility = "visible";
-    } else {
-      this.expander.style.visibility = "hidden";
-    }
-  },
+  /* Other containers can choose to implement these */
+  hasChildren: false,
+  expanded: false,
 
   parentContainer: function() {
     return this.elt.parentNode ? this.elt.parentNode.container : null;
   },
 
-  /**
-   * True if the node has been visually expanded in the tree.
-   */
-  get expanded() {
-    return !this.elt.classList.contains("collapsed");
-  },
-
-  set expanded(aValue) {
-    if (aValue && this.elt.classList.contains("collapsed")) {
-      // Expanding a node means cloning its "inline" closing tag into a new
-      // tag-line that the user can interact with and showing the children.
-      if (this.editor instanceof ElementEditor) {
-        let closingTag = this.elt.querySelector(".close");
-        if (closingTag) {
-          if (!this.closeTagLine) {
-            let line = this.markup.doc.createElement("div");
-            line.classList.add("tag-line");
-
-            let tagState = this.markup.doc.createElement("div");
-            tagState.classList.add("tag-state");
-            line.appendChild(tagState);
-
-            line.appendChild(closingTag.cloneNode(true));
-
-            this.closeTagLine = line;
-          }
-          this.elt.appendChild(this.closeTagLine);
-        }
-      }
-      this.elt.classList.remove("collapsed");
-      this.expander.setAttribute("open", "");
-      this.hovered = false;
-    } else if (!aValue) {
-      if (this.editor instanceof ElementEditor && this.closeTagLine) {
-        this.elt.removeChild(this.closeTagLine);
-      }
-      this.elt.classList.add("collapsed");
-      this.expander.removeAttribute("open");
-    }
-  },
-
-  _onToggle: function(event) {
-    this.markup.navigate(this);
-    if(this.hasChildren) {
-      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
-    }
-    event.stopPropagation();
-  },
-
   _onMouseDown: function(event) {
     let target = event.target;
 
     // Target may be a resource link (generated by the output-parser)
     if (target.nodeName === "a") {
       event.stopPropagation();
       event.preventDefault();
       let browserWin = this.markup._inspector.target
@@ -1682,42 +1532,275 @@ MarkupContainer.prototype = {
    */
   focus: function() {
     let focusable = this.editor.elt.querySelector("[tabindex]");
     if (focusable) {
       focusable.focus();
     }
   },
 
+  _onToggle: function(event) {
+    this.markup.navigate(this);
+    if (this.hasChildren) {
+      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
+    }
+    event.stopPropagation();
+  },
+
+
   /**
    * Get rid of event listeners and references, when the container is no longer
    * needed
    */
   destroy: function() {
+    // Remove event listeners
+    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
+    this.elt.removeEventListener("dblclick", this._onToggle, false);
+
     // Recursively destroy children containers
     let firstChild;
     while (firstChild = this.children.firstChild) {
       // Not all children of a container are containers themselves
       // ("show more nodes" button is one example)
       if (firstChild.container) {
         firstChild.container.destroy();
       }
       this.children.removeChild(firstChild);
     }
 
-    // Remove event listeners
-    this.elt.removeEventListener("dblclick", this._onToggle, false);
-    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
-    this.expander.removeEventListener("click", this._onToggle, false);
-
-    // Destroy my editor
     this.editor.destroy();
   }
 };
 
+/**
+ * An implementation of MarkupContainer for Pseudo Elements,
+ * Doctype nodes, or any other type generic node that doesn't
+ * fit for other editors.
+ * Does not allow any editing, just viewing / selecting.
+ *
+ * @param MarkupView markupView
+ *        The markup view that owns this container.
+ * @param NodeFront node
+ *        The node to display.
+ */
+function MarkupReadOnlyContainer(markupView, node) {
+  MarkupContainer.prototype.initialize.call(this, markupView, node, "readonlycontainer");
+
+  this.editor = new GenericEditor(this, node);
+  this.tagLine.appendChild(this.editor.elt);
+}
+
+MarkupReadOnlyContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
+
+/**
+ * An implementation of MarkupContainer for text node and comment nodes.
+ * Allows basic text editing in a textarea.
+ *
+ * @param MarkupView aMarkupView
+ *        The markup view that owns this container.
+ * @param NodeFront aNode
+ *        The node to display.
+ * @param Inspector aInspector
+ *        The inspector tool container the markup-view
+ */
+function MarkupTextContainer(markupView, node) {
+  MarkupContainer.prototype.initialize.call(this, markupView, node, "textcontainer");
+
+  if (node.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
+    this.editor = new TextEditor(this, node, "text");
+  } else if (node.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
+    this.editor = new TextEditor(this, node, "comment");
+  } else {
+    throw "Invalid node for MarkupTextContainer";
+  }
+
+  this.tagLine.appendChild(this.editor.elt);
+}
+
+MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
+
+/**
+ * An implementation of MarkupContainer for Elements that can contain
+ * child nodes.
+ * Allows editing of tag name, attributes, expanding / collapsing.
+ *
+ * @param MarkupView markupView
+ *        The markup view that owns this container.
+ * @param NodeFront node
+ *        The node to display.
+ */
+function MarkupElementContainer(markupView, node) {
+  MarkupContainer.prototype.initialize.call(this, markupView, node, "elementcontainer");
+
+  if (node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+    this.editor = new ElementEditor(this, node);
+  } else {
+    throw "Invalid node for MarkupElementContainer";
+  }
+
+  this.tagLine.appendChild(this.editor.elt);
+
+  // Expanding/collapsing the node on dblclick of the whole tag-line element
+  this.expander.addEventListener("click", this._onToggle, false);
+
+  // Prepare the image preview tooltip data if any
+  this._prepareImagePreview();
+}
+
+MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {
+  /**
+   * True if the current node has children.  The MarkupView
+   * will set this attribute for the MarkupContainer.
+   */
+  _hasChildren: false,
+
+  get hasChildren() {
+    return this._hasChildren;
+  },
+
+  set hasChildren(aValue) {
+    this._hasChildren = aValue;
+    if (aValue) {
+      this.expander.style.visibility = "visible";
+    } else {
+      this.expander.style.visibility = "hidden";
+    }
+  },
+
+  /**
+   * True if the node has been visually expanded in the tree.
+   */
+  get expanded() {
+    return !this.elt.classList.contains("collapsed");
+  },
+
+  set expanded(aValue) {
+    if (aValue && this.elt.classList.contains("collapsed")) {
+      // Expanding a node means cloning its "inline" closing tag into a new
+      // tag-line that the user can interact with and showing the children.
+      let closingTag = this.elt.querySelector(".close");
+      if (closingTag) {
+        if (!this.closeTagLine) {
+          let line = this.markup.doc.createElement("div");
+          line.classList.add("tag-line");
+
+          let tagState = this.markup.doc.createElement("div");
+          tagState.classList.add("tag-state");
+          line.appendChild(tagState);
+
+          line.appendChild(closingTag.cloneNode(true));
+
+          this.closeTagLine = line;
+        }
+        this.elt.appendChild(this.closeTagLine);
+      }
+
+      this.elt.classList.remove("collapsed");
+      this.expander.setAttribute("open", "");
+      this.hovered = false;
+    } else if (!aValue) {
+      if (this.closeTagLine) {
+        this.elt.removeChild(this.closeTagLine);
+      }
+      this.elt.classList.add("collapsed");
+      this.expander.removeAttribute("open");
+    }
+  },
+
+  _buildEventTooltipContent: function(target, tooltip) {
+    if (target.hasAttribute("data-event")) {
+      tooltip.hide(target);
+
+      this.node.getEventListenerInfo().then(listenerInfo => {
+        tooltip.setEventContent({
+          eventListenerInfos: listenerInfo,
+          toolbox: this.markup._inspector.toolbox
+        });
+
+        this.markup._makeTooltipPersistent(true);
+        tooltip.once("hidden", () => {
+          this.markup._makeTooltipPersistent(false);
+        });
+        tooltip.show(target);
+      });
+      return true;
+    }
+  },
+
+  /**
+   * If the node is an image or canvas (@see isPreviewable), then get the
+   * image data uri from the server so that it can then later be previewed in
+   * a tooltip if needed.
+   * Stores a promise in this.tooltipData.data that resolves when the data has
+   * been retrieved
+   */
+  _prepareImagePreview: function() {
+    if (this.isPreviewable()) {
+      // Get the image data for later so that when the user actually hovers over
+      // the element, the tooltip does contain the image
+      let def = promise.defer();
+
+      this.tooltipData = {
+        target: this.editor.getAttributeElement("src") || this.editor.tag,
+        data: def.promise
+      };
+
+      let maxDim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");
+      this.node.getImageData(maxDim).then(data => {
+        data.data.string().then(str => {
+          let res = {data: str, size: data.size};
+          // Resolving the data promise and, to always keep tooltipData.data
+          // as a promise, create a new one that resolves immediately
+          def.resolve(res);
+          this.tooltipData.data = promise.resolve(res);
+        });
+      }, () => {
+        this.tooltipData.data = promise.reject();
+      });
+    }
+  },
+
+  /**
+   * Executed by MarkupView._isImagePreviewTarget which is itself called when the
+   * mouse hovers over a target in the markup-view.
+   * Checks if the target is indeed something we want to have an image tooltip
+   * preview over and, if so, inserts content into the tooltip.
+   * @return a promise that resolves when the content has been inserted or
+   * rejects if no preview is required. This promise is then used by Tooltip.js
+   * to decide if/when to show the tooltip
+   */
+  isImagePreviewTarget: function(target, tooltip) {
+    if (!this.tooltipData || this.tooltipData.target !== target) {
+      return promise.reject();
+    }
+
+    return this.tooltipData.data.then(({data, size}) => {
+      tooltip.setImageContent(data, size);
+    }, () => {
+      tooltip.setBrokenImageContent();
+    });
+  },
+
+  copyImageDataUri: function() {
+    // We need to send again a request to gettooltipData even if one was sent for
+    // the tooltip, because we want the full-size image
+    this.node.getImageData().then(data => {
+      data.data.string().then(str => {
+        clipboardHelper.copyString(str, this.markup.doc);
+      });
+    });
+  },
+
+  destroy: function() {
+    // Remove event listeners
+    this.expander.removeEventListener("click", this._onToggle, false);
+
+    MarkupContainer.prototype.destroy.call(this);
+  }
+});
 
 /**
  * Dummy container node used for the root document element.
  */
 function RootContainer(aMarkupView, aNode) {
   this.doc = aMarkupView.doc;
   this.elt = this.doc.createElement("ul");
   this.elt.container = this;
@@ -1729,81 +1812,82 @@ function RootContainer(aMarkupView, aNod
 RootContainer.prototype = {
   hasChildren: true,
   expanded: true,
   update: function() {},
   destroy: function() {}
 };
 
 /**
- * Creates an editor for simple nodes.
+ * Creates an editor for non-editable nodes.
  */
 function GenericEditor(aContainer, aNode) {
-  this.elt = aContainer.doc.createElement("span");
-  this.elt.className = "editor";
-  this.elt.textContent = aNode.nodeName;
+  this.container = aContainer;
+  this.markup = this.container.markup;
+  this.template = this.markup.template.bind(this.markup);
+  this.elt = null;
+  this.template("generic", this);
+
+  if (aNode.isPseudoElement) {
+    this.tag.classList.add("theme-fg-color5");
+    this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
+  } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
+    this.elt.classList.add("comment");
+    this.tag.textContent = '<!DOCTYPE ' + aNode.name +
+       (aNode.publicId ? ' PUBLIC "' +  aNode.publicId + '"': '') +
+       (aNode.systemId ? ' "' + aNode.systemId + '"' : '') +
+       '>';
+  } else {
+    this.tag.textContent = aNode.nodeName;
+  }
 }
 
 GenericEditor.prototype = {
-  destroy: function() {}
-};
-
-/**
- * Creates an editor for a DOCTYPE node.
- *
- * @param MarkupContainer aContainer The container owning this editor.
- * @param DOMNode aNode The node being edited.
- */
-function DoctypeEditor(aContainer, aNode) {
-  this.elt = aContainer.doc.createElement("span");
-  this.elt.className = "editor comment";
-  this.elt.textContent = '<!DOCTYPE ' + aNode.name +
-     (aNode.publicId ? ' PUBLIC "' +  aNode.publicId + '"': '') +
-     (aNode.systemId ? ' "' + aNode.systemId + '"' : '') +
-     '>';
-}
-
-DoctypeEditor.prototype = {
-  destroy: function() {}
+  destroy: function() {
+    this.elt.remove();
+  }
 };
 
 /**
  * Creates a simple text editor node, used for TEXT and COMMENT
  * nodes.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param DOMNode aNode The node being edited.
  * @param string aTemplate The template id to use to build the editor.
  */
 function TextEditor(aContainer, aNode, aTemplate) {
+  this.container = aContainer;
+  this.markup = this.container.markup;
   this.node = aNode;
+  this.template = this.markup.template.bind(aTemplate);
   this._selected = false;
 
-  aContainer.markup.template(aTemplate, this);
+  this.markup.template(aTemplate, this);
 
   editableField({
     element: this.value,
     stopOnReturn: true,
     trigger: "dblclick",
     multiline: true,
     done: (aVal, aCommit) => {
       if (!aCommit) {
         return;
       }
       this.node.getNodeValue().then(longstr => {
         longstr.string().then(oldValue => {
           longstr.release().then(null, console.error);
 
-          aContainer.undo.do(() => {
+          this.container.undo.do(() => {
             this.node.setNodeValue(aVal).then(() => {
-              aContainer.markup.nodeChanged(this.node);
+              this.markup.nodeChanged(this.node);
             });
           }, () => {
             this.node.setNodeValue(oldValue).then(() => {
-              aContainer.markup.nodeChanged(this.node);
+              this.markup.nodeChanged(this.node);
             })
           });
         });
       });
     }
   });
 
   this.update();
@@ -1846,22 +1930,21 @@ TextEditor.prototype = {
 
 /**
  * Creates an editor for an Element node.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param Element aNode The node being edited.
  */
 function ElementEditor(aContainer, aNode) {
-  this.doc = aContainer.doc;
-  this.undo = aContainer.undo;
-  this.template = aContainer.markup.template.bind(aContainer.markup);
   this.container = aContainer;
+  this.node = aNode;
   this.markup = this.container.markup;
-  this.node = aNode;
+  this.template = this.markup.template.bind(this.markup);
+  this.doc = this.markup.doc;
 
   this.attrs = {};
 
   // The templates will fill the following properties
   this.elt = null;
   this.tag = null;
   this.closeTag = null;
   this.attrList = null;
@@ -1898,17 +1981,17 @@ function ElementEditor(aContainer, aNode
       if (!aCommit) {
         return;
       }
 
       try {
         let doMods = this._startModifyingAttributes();
         let undoMods = this._startModifyingAttributes();
         this._applyAttributes(aVal, null, doMods, undoMods);
-        this.undo.do(() => {
+        this.container.undo.do(() => {
           doMods.apply();
         }, function() {
           undoMods.apply();
         });
       } catch(x) {
         console.error(x);
       }
     }
@@ -2026,17 +2109,17 @@ ElementEditor.prototype = {
 
         // Remove the attribute stored in this editor and re-add any attributes
         // parsed out of the input element. Restore original attribute if
         // parsing fails.
         try {
           this._saveAttribute(aAttr.name, undoMods);
           doMods.removeAttribute(aAttr.name);
           this._applyAttributes(aVal, attr, doMods, undoMods);
-          this.undo.do(() => {
+          this.container.undo.do(() => {
             doMods.apply();
           }, () => {
             undoMods.apply();
           })
         } catch(ex) {
           console.error(ex);
         }
       }
@@ -2141,17 +2224,17 @@ ElementEditor.prototype = {
       function swapNodes(aOld, aNew) {
         aOld.parentNode.insertBefore(aNew, aOld);
         while (aOld.firstChild) {
           aNew.appendChild(aOld.firstChild);
         }
         aOld.parentNode.removeChild(aOld);
       }
 
-      this.undo.do(() => {
+      this.container.undo.do(() => {
         swapNodes(this.rawNode, newElt);
         this.markup.setNodeExpanded(newFront, this.container.expanded);
         if (this.container.selected) {
           this.markup.navigate(newContainer);
         }
       }, () => {
         swapNodes(newElt, this.rawNode);
         this.markup.setNodeExpanded(this.node, newContainer.expanded);
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -21,32 +21,44 @@
 <!-- TO MAKE SPANS READABLE WHILST AVOIDING SIGNIFICANT WHITESPACE          -->
 
   <div id="root-wrapper">
     <div id="root"></div>
   </div>
   <div id="templates" style="display:none">
 
     <ul class="children">
-      <li id="template-container" save="${elt}" class="child collapsed">
+      <li id="template-elementcontainer" save="${elt}" class="child collapsed">
         <div save="${tagLine}" class="tag-line"><!--
         --><span save="${tagState}" class="tag-state"></span><!--
         --><span save="${expander}" class="theme-twisty expander"></span><!--
      --></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
+      <li id="template-textcontainer" save="${elt}" class="child collapsed">
+        <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span></div>
+        <ul save="${children}" class="children"></ul>
+      </li>
+
+      <li id="template-readonlycontainer" save="${elt}" class="child collapsed">
+        <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span></div>
+        <ul save="${children}" class="children"></ul>
+      </li>
+
       <li id="template-more-nodes"
           class="more-nodes devtools-class-comment"
           save="${elt}"><!--
       --><span>${showing}</span> <!--
       --><button href="#" onclick="${allButtonClick}">${showAll}</button>
       </li>
     </ul>
 
+    <span id="template-generic" save="${elt}" class="editor"><span save="${tag}" class="tag"></span></span>
+
     <span id="template-element" save="${elt}" class="editor"><!--
    --><span class="open">&lt;<!--
      --><span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><!--
      --><span save="${attrList}"></span><!--
      --><span save="${newAttr}" class="newattr" tabindex="0"></span><!--
      --><span class="closing-bracket">&gt;</span><!--
    --></span><!--
    --><span class="close">&lt;/<!--
diff --git a/browser/devtools/markupview/test/browser.ini b/browser/devtools/markupview/test/browser.ini
--- a/browser/devtools/markupview/test/browser.ini
+++ b/browser/devtools/markupview/test/browser.ini
@@ -1,26 +1,30 @@
 [DEFAULT]
 subsuite = devtools
 support-files =
+  doc_markup_anonymous.html
   doc_markup_edit.html
   doc_markup_events.html
   doc_markup_flashing.html
   doc_markup_mutation.html
   doc_markup_navigation.html
   doc_markup_not_displayed.html
   doc_markup_pagesize_01.html
   doc_markup_pagesize_02.html
   doc_markup_search.html
   doc_markup_toggle.html
   doc_markup_tooltip.png
   head.js
   helper_attributes_test_runner.js
   helper_outerhtml_test_runner.js
 
+[browser_markupview_anonymous_01.js]
+[browser_markupview_anonymous_02.js]
+[browser_markupview_anonymous_03.js]
 [browser_markupview_copy_image_data.js]
 [browser_markupview_css_completion_style_attribute.js]
 [browser_markupview_events.js]
 skip-if = true # Bug 1041284 - Re-enable browser_markupview_events.js when GC issues are fixed
 # ^^^ AND skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_highlight_hover_01.js]
 skip-if = e10s # Bug 985597 - The XUL-based highlighter isn't e10s compatible
 [browser_markupview_highlight_hover_02.js]
diff --git a/browser/devtools/markupview/test/browser_markupview_anonymous_01.js b/browser/devtools/markupview/test/browser_markupview_anonymous_01.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_anonymous_01.js
@@ -0,0 +1,30 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test native anonymous content in the markupview.
+const TEST_URL = TEST_URL_ROOT + "doc_markup_anonymous.html";
+
+let test = asyncTest(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  let pseudo = yield getNodeFront("#pseudo", inspector);
+
+  // Markup looks like: <div><::before /><span /><::after /></div>
+  let children = yield inspector.walker.children(pseudo);
+  is (children.nodes.length, 3, "Children returned from walker");
+
+  info ("Checking the ::before pseudo element");
+  let before = children.nodes[0];
+  yield checkMenuEditingDisabled(before, inspector);
+
+  info ("Checking the normal child element");
+  let span = children.nodes[1];
+  yield checkMenuEditingEnabled(span, inspector);
+
+  info ("Checking the ::after pseudo element");
+  let after = children.nodes[2];
+  yield checkMenuEditingDisabled(after, inspector);
+});
diff --git a/browser/devtools/markupview/test/browser_markupview_anonymous_02.js b/browser/devtools/markupview/test/browser_markupview_anonymous_02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_anonymous_02.js
@@ -0,0 +1,29 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test XBL anonymous content in the markupview
+const TEST_URL = "chrome://browser/content/devtools/scratchpad.xul";
+
+let test = asyncTest(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  let toolbarbutton = yield getNodeFront("toolbarbutton", inspector);
+  let children = yield inspector.walker.children(toolbarbutton);
+
+  is(toolbarbutton.numChildren, 3, "Correct number of children");
+  is (children.nodes.length, 3, "Children returned from walker");
+
+  is(toolbarbutton.isAnonymous, false, "Toolbarbutton is not anonymous");
+  yield checkMenuEditingEnabled(toolbarbutton, inspector);
+
+  for (let node of children.nodes) {
+    ok (node.isAnonymous, "Child is anonymous");
+    ok (node._form.isXBLAnonymous, "Child is XBL anonymous");
+    ok (!node._form.isShadowAnonymous, "Child is not shadow anonymous");
+    ok (!node._form.isNativeAnonymous, "Child is not native anonymous");
+    yield checkMenuEditingDisabled(node, inspector);
+  }
+});
diff --git a/browser/devtools/markupview/test/browser_markupview_anonymous_03.js b/browser/devtools/markupview/test/browser_markupview_anonymous_03.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_anonymous_03.js
@@ -0,0 +1,36 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test shadow DOM content in the markupview.
+// Note that many features are not yet enabled, but basic listing
+// of elements should be working.
+const TEST_URL = TEST_URL_ROOT + "doc_markup_anonymous.html";
+
+let test = asyncTest(function*() {
+  Services.prefs.setBoolPref("dom.webcomponents.enabled", true);
+
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  let shadow = yield getNodeFront("#shadow", inspector);
+  let children = yield inspector.walker.children(shadow);
+
+  is (shadow.numChildren, 3, "Children of the shadow root are counted");
+  is (children.nodes.length, 3, "Children returned from walker");
+
+  info ("Checking the ::before pseudo element");
+  let before = children.nodes[0];
+  yield checkMenuEditingDisabled(before, inspector);
+
+  info ("Checking the <h3> shadow element");
+  let shadowChild1 = children.nodes[1];
+  yield checkMenuEditingDisabled(shadowChild1, inspector);
+
+  info ("Checking the <select> shadow element");
+  let shadowChild2 = children.nodes[2];
+  yield checkMenuEditingDisabled(shadowChild2, inspector);
+
+  Services.prefs.clearUserPref("dom.webcomponents.enabled");
+});
diff --git a/browser/devtools/markupview/test/doc_markup_anonymous.html b/browser/devtools/markupview/test/doc_markup_anonymous.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/doc_markup_anonymous.html
@@ -0,0 +1,31 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <title>Anonymous content test</title>
+  <style type="text/css">
+    #pseudo::before {
+      content: "before";
+    }
+    #pseudo::after {
+      content: "after";
+    }
+    #shadow::before {
+      content: "Testing ::before on a shadow host";
+    }
+  </style>
+</head>
+<body>
+  <div id="pseudo"><span>middle</span></div>
+
+  <div id="shadow">light dom</div>
+
+  <script>
+  var host = document.querySelector('#shadow');
+  if (host.createShadowRoot) {
+    var root = host.createShadowRoot();
+    root.innerHTML = '<h3>Shadow DOM</h3><select multiple></select>';
+  }
+  </script>
+</body>
+</html>
\ No newline at end of file
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -134,22 +134,25 @@ function getNode(nodeOrSelector) {
   info("Getting the node for '" + nodeOrSelector + "'");
   return typeof nodeOrSelector === "string" ?
     content.document.querySelector(nodeOrSelector) :
     nodeOrSelector;
 }
 
 /**
  * Get the NodeFront for a given css selector, via the protocol
- * @param {String} selector
+ * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return {Promise} Resolves to the NodeFront instance
  */
 function getNodeFront(selector, {walker}) {
+  if (selector._form) {
+    return selector;
+  }
   return walker.querySelector(walker.rootNode, selector);
 }
 
 /**
  * Highlight a node and set the inspector's current selection to the node or
  * the first match of the given css selector.
  * @param {String|DOMNode} nodeOrSelector
  * @param {InspectorPanel} inspector
@@ -164,17 +167,17 @@ function selectAndHighlightNode(nodeOrSe
   let updated = inspector.toolbox.once("highlighter-ready");
   inspector.selection.setNode(node, "test-highlight");
   return updated;
 }
 
 /**
  * Set the inspector's current selection to the first match of the given css
  * selector
- * @param {String} selector
+ * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @param {String} reason Defaults to "test" which instructs the inspector not
  * to highlight the node upon selection
  * @return {Promise} Resolves when the inspector is updated with the new node
  */
 let selectNode = Task.async(function*(selector, inspector, reason="test") {
   info("Selecting the node for '" + selector + "'");
@@ -194,17 +197,17 @@ let selectNode = Task.async(function*(se
  */
 function getContainerForNodeFront(nodeFront, {markup}) {
   return markup.getContainer(nodeFront);
 }
 
 /**
  * Get the MarkupContainer object instance that corresponds to the given
  * selector
- * @param {String} selector
+ * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return {MarkupContainer}
  */
 let getContainerForSelector = Task.async(function*(selector, inspector) {
   info("Getting the markup-container for node " + selector);
   let nodeFront = yield getNodeFront(selector, inspector);
   let container = getContainerForNodeFront(nodeFront, inspector);
@@ -227,17 +230,17 @@ function waitForChildrenUpdated({markup}
     executeSoon(def.resolve);
   });
   return def.promise;
 }
 
 /**
  * Simulate a mouse-over on the markup-container (a line in the markup-view)
  * that corresponds to the selector passed.
- * @param {String} selector
+ * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return {Promise} Resolves when the container is hovered and the higlighter
  * is shown on the corresponding node
  */
 let hoverContainer = Task.async(function*(selector, inspector) {
   info("Hovering over the markup-container for node " + selector);
 
@@ -248,17 +251,17 @@ let hoverContainer = Task.async(function
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {type: "mousemove"},
     inspector.markup.doc.defaultView);
   return highlit;
 });
 
 /**
  * Simulate a click on the markup-container (a line in the markup-view)
  * that corresponds to the selector passed.
- * @param {String} selector
+ * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return {Promise} Resolves when the node has been selected.
  */
 let clickContainer = Task.async(function*(selector, inspector) {
   info("Clicking on the markup-container for node " + selector);
 
   let nodeFront = yield getNodeFront(selector, inspector);
@@ -430,8 +433,83 @@ function searchUsingSelectorSearch(selec
  * @param {Number} ms The time to wait
  * @return A promise that resolves when the time is passed
  */
 function wait(ms) {
   let def = promise.defer();
   content.setTimeout(def.resolve, ms);
   return def.promise;
 }
+
+/**
+ * Wait for eventName on target.
+ * @param {Object} target An observable object that either supports on/off or
+ * addEventListener/removeEventListener
+ * @param {String} eventName
+ * @param {Boolean} useCapture Optional, for addEventListener/removeEventListener
+ * @return A promise that resolves when the event has been handled
+ */
+function once(target, eventName, useCapture=false) {
+  info("Waiting for event: '" + eventName + "' on " + target + ".");
+
+  let deferred = promise.defer();
+
+  for (let [add, remove] of [
+    ["addEventListener", "removeEventListener"],
+    ["addListener", "removeListener"],
+    ["on", "off"]
+  ]) {
+    if ((add in target) && (remove in target)) {
+      target[add](eventName, function onEvent(...aArgs) {
+        info("Got event: '" + eventName + "' on " + target + ".");
+        target[remove](eventName, onEvent, useCapture);
+        deferred.resolve.apply(deferred, aArgs);
+      }, useCapture);
+      break;
+    }
+  }
+
+  return deferred.promise;
+}
+
+/**
+ * Check to see if the inspector menu items for editing are disabled.
+ * Things like Edit As HTML, Delete Node, etc.
+ */
+function* checkMenuEditingDisabled(nodefront, inspector) {
+  /// XXX: Check other menu items also
+  let deleteMenuItem = inspector.panelDoc.getElementById("node-menu-delete");
+  let menu = inspector.nodemenu;
+  yield selectNode(nodefront, inspector);
+  yield reopenMenu(menu);
+  ok (deleteMenuItem.hasAttribute("disabled"), "Menu item is disabled");
+}
+
+/**
+ * Check to see if the inspector menu items for editing are enabled.
+ * Things like Edit As HTML, Delete Node, etc.
+ */
+function* checkMenuEditingEnabled(nodefront, inspector) {
+  let deleteMenuItem = inspector.panelDoc.getElementById("node-menu-delete");
+  let menu = inspector.nodemenu;
+  yield selectNode(nodefront, inspector);
+  yield reopenMenu(menu);
+  ok (!deleteMenuItem.hasAttribute("disabled"), "Menu item is enabled");
+}
+
+/**
+ * Open a menu (closing it first if necessary).
+ * @param {DOMNode} menu A menu that implements hidePopup/openPopup
+ * @return a promise that resolves once the menu is opened.
+ */
+function* reopenMenu(menu) {
+  // First close it is if it is already opened.
+  if (menu.state == "closing" || menu.state == "open") {
+    let popuphidden = once(menu, "popuphidden", true);
+    menu.hidePopup();
+    yield popuphidden;
+  }
+
+  // Then open it and return once
+  let popupshown = once(menu, "popupshown", true);
+  menu.openPopup();
+  yield popupshown;
+}
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -148,17 +148,19 @@ ElementStyle.prototype = {
   dummyElement: null,
 
   init: function()
   {
     // To figure out how shorthand properties are interpreted by the
     // engine, we will set properties on a dummy element and observe
     // how their .style attribute reflects them as computed values.
     return this.dummyElementPromise = createDummyDocument().then(document => {
-      this.dummyElement = document.createElementNS(this.element.namespaceURI,
+      // ::before and ::after do not have a namespaceURI
+      let namespaceURI = this.element.namespaceURI || document.documentElement.namespaceURI;
+      this.dummyElement = document.createElementNS(namespaceURI,
                                                    this.element.tagName);
       document.documentElement.appendChild(this.dummyElement);
       return this.dummyElement;
     }).then(null, promiseWarn);
   },
 
   destroy: function() {
     this.dummyElement = null;
@@ -1224,16 +1226,18 @@ CssRuleView.prototype = {
       label = "ruleView.contextmenu.showCSSSources";
     }
     this.menuitemSources.setAttribute("label",
                                       _strings.GetStringFromName(label));
 
     let accessKey = label + ".accessKey";
     this.menuitemSources.setAttribute("accesskey",
                                       _strings.GetStringFromName(accessKey));
+
+    this.menuitemAddRule.disabled = this.inspector.selection.isAnonymousNode();
   },
 
   /**
    * Get the type of a given node in the rule-view
    * @param {DOMNode} node The node which we want information about
    * @return {Object} The type information object contains the following props:
    * - type {String} One of the VIEW_NODE_XXX_TYPE const in
    *   style-inspector-overlays
@@ -1814,20 +1818,24 @@ function RuleEditor(aRuleView, aRule) {
   this._onSelectorDone = this._onSelectorDone.bind(this);
 
   this._create();
 }
 
 RuleEditor.prototype = {
   get isSelectorEditable() {
     let toolbox = this.ruleView.inspector.toolbox;
-    return this.isEditable &&
+    let trait = this.isEditable &&
       toolbox.target.client.traits.selectorEditable &&
       this.rule.domRule.type !== ELEMENT_STYLE &&
       this.rule.domRule.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE
+
+    // Do not allow editing anonymousselectors until we can
+    // detect mutations on  pseudo elements in Bug 1034110.
+    return trait && !this.rule.elementStyle.element.isAnonymous;
   },
 
   _create: function() {
     this.element = this.doc.createElementNS(HTML_NS, "div");
     this.element.className = "ruleview-rule theme-separator";
     this.element.setAttribute("uneditable", !this.isEditable);
     this.element._ruleEditor = this;
 
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -85,17 +85,18 @@ skip-if = os == "win" && debug # bug 963
 [browser_ruleview_multiple-properties-duplicates.js]
 [browser_ruleview_multiple-properties-priority.js]
 [browser_ruleview_multiple-properties-unfinished_01.js]
 [browser_ruleview_multiple-properties-unfinished_02.js]
 [browser_ruleview_multiple_properties_01.js]
 [browser_ruleview_multiple_properties_02.js]
 [browser_ruleview_original-source-link.js]
 [browser_ruleview_override.js]
-[browser_ruleview_pseudo-element.js]
+[browser_ruleview_pseudo-element_01.js]
+[browser_ruleview_pseudo-element_02.js]
 [browser_ruleview_refresh-on-attribute-change_01.js]
 [browser_ruleview_refresh-on-attribute-change_02.js]
 [browser_ruleview_refresh-on-style-change.js]
 [browser_ruleview_select-and-copy-styles.js]
 [browser_ruleview_style-editor-link.js]
 [browser_ruleview_urls-clickable.js]
 [browser_ruleview_user-agent-styles.js]
 [browser_ruleview_user-agent-styles-uneditable.js]
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
@@ -1,24 +1,24 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Testing selector inplace-editor behaviors in the rule-view with pseudo
-// classes and elements
+// classes.
 
 let PAGE_CONTENT = [
   '<style type="text/css">',
   '  .testclass {',
   '    text-align: center;',
   '  }',
-  '  #testid3:after {',
-  '    content: "+"',
+  '  #testid3:first-letter {',
+  '    text-decoration: "italic"',
   '  }',
   '</style>',
   '<div id="testid">Styled Node</div>',
   '<span class="testclass">This is a span</span>',
   '<div class="testclass2">A</div>',
   '<div id="testid3">B</div>'
 ].join("\n");
 
@@ -36,21 +36,21 @@ let test = asyncTest(function*() {
   yield testEditSelector(view, "div:nth-child(2)");
 
   info("Selecting the modified element");
   yield selectNode("#testid", inspector);
   yield checkModifiedElement(view, "div:nth-child(2)");
 
   info("Selecting the test element");
   yield selectNode("#testid3", inspector);
-  yield testEditSelector(view, ".testclass2:after");
+  yield testEditSelector(view, ".testclass2:first-letter");
 
   info("Selecting the modified element");
   yield selectNode(".testclass2", inspector);
-  yield checkModifiedElement(view, ".testclass2:after");
+  yield checkModifiedElement(view, ".testclass2:first-letter");
 });
 
 function* testEditSelector(view, name) {
   info("Test editing existing selector fields");
 
   let idRuleEditor = getRuleViewRuleEditor(view, 1) ||
     getRuleViewRuleEditor(view, 1, 0);
 
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
rename from browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js
rename to browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
@@ -22,20 +22,18 @@ let test = asyncTest(function*() {
 
 function* testTopLeft(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#topleft", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 2,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 
   let gutters = assertGutters(view);
 
   // Make sure that clicking on the twisty hides pseudo elements
   let expander = gutters[0].querySelector(".ruleview-expander");
   ok (view.element.firstChild.classList.contains("show-expandable-container"), "Pseudo Elements are expanded");
@@ -44,140 +42,120 @@ function* testTopLeft(inspector, view) {
   expander.click();
   ok (view.element.firstChild.classList.contains("show-expandable-container"), "Pseudo Elements are expanded again");
 
   // Make sure that dblclicking on the header container also toggles the pseudo elements
   EventUtils.synthesizeMouseAtCenter(gutters[0], {clickCount: 2}, inspector.sidebar.getWindowForTab("ruleview"));
   ok (!view.element.firstChild.classList.contains("show-expandable-container"), "Pseudo Elements are collapsed by dblclicking");
 
   let defaultView = element.ownerDocument.defaultView;
+
   let elementRule = rules.elementRules[0];
   let elementRuleView = getRuleViewRuleEditor(view, 3);
 
-  let elementAfterRule = rules.afterRules[0];
-  let elementAfterRuleView = [].filter.call(view.element.children[1].children, (e) => {
-    return e._ruleEditor && e._ruleEditor.rule === elementAfterRule;
+  let elementFirstLineRule = rules.firstLineRules[0];
+  let elementFirstLineRuleView = [].filter.call(view.element.children[1].children, (e) => {
+    return e._ruleEditor && e._ruleEditor.rule === elementFirstLineRule;
   })[0]._ruleEditor;
 
   is
   (
-    convertTextPropsToString(elementAfterRule.textProps),
-    "background: none repeat scroll 0% 0% red; content: \" \"; position: absolute; " +
-    "border-radius: 50%; height: 32px; width: 32px; top: 50%; left: 50%; margin-top: -16px; margin-left: -16px",
-    "TopLeft after properties are correct"
+    convertTextPropsToString(elementFirstLineRule.textProps),
+    "color: orange",
+    "TopLeft firstLine properties are correct"
   );
 
-  let elementBeforeRule = rules.beforeRules[0];
-  let elementBeforeRuleView = [].filter.call(view.element.children[1].children, (e) => {
-    return e._ruleEditor && e._ruleEditor.rule === elementBeforeRule;
-  })[0]._ruleEditor;
+  let firstProp = elementFirstLineRuleView.addProperty("background-color", "rgb(0, 255, 0)", "");
+  let secondProp = elementFirstLineRuleView.addProperty("font-style", "italic", "");
 
-  is
-  (
-    convertTextPropsToString(elementBeforeRule.textProps),
-    "top: 0px; left: 0px",
-    "TopLeft before properties are correct"
-  );
-
-  let firstProp = elementAfterRuleView.addProperty("background-color", "rgb(0, 255, 0)", "");
-  let secondProp = elementAfterRuleView.addProperty("padding", "100px", "");
-
-  is (firstProp, elementAfterRule.textProps[elementAfterRule.textProps.length - 2],
+  is (firstProp, elementFirstLineRule.textProps[elementFirstLineRule.textProps.length - 2],
       "First added property is on back of array");
-  is (secondProp, elementAfterRule.textProps[elementAfterRule.textProps.length - 1],
+  is (secondProp, elementFirstLineRule.textProps[elementFirstLineRule.textProps.length - 1],
       "Second added property is on back of array");
 
-  yield elementAfterRule._applyingModifications;
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("background-color"),
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
     "rgb(0, 255, 0)", "Added property should have been used.");
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"),
-    "100px", "Added property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"),
-    "32px", "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("font-style"),
+    "italic", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("text-decoration"),
+    "none", "Added property should not apply to element");
 
-  secondProp.setEnabled(false);
-  yield elementAfterRule._applyingModifications;
+  firstProp.setEnabled(false);
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"), "0px",
-    "Disabled property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"), "32px",
-    "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(255, 0, 0)", "Disabled property should now have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"),
+    "rgb(221, 221, 221)", "Added property should not apply to element");
 
-  secondProp.setEnabled(true);
-  yield elementAfterRule._applyingModifications;
+  firstProp.setEnabled(true);
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"), "100px",
-    "Enabled property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"), "32px",
-    "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(0, 255, 0)", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("text-decoration"),
+    "none", "Added property should not apply to element");
 
   let firstProp = elementRuleView.addProperty("background-color", "rgb(0, 0, 255)", "");
   yield elementRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"), "rgb(0, 0, 255)",
-    "Added property should have been used.");
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("background-color"), "rgb(0, 255, 0)",
-    "Added prop does not apply to pseudo");
+  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"),
+    "rgb(0, 0, 255)", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(0, 255, 0)", "Added prop does not apply to pseudo");
 }
 
 function* testTopRight(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#topright", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 
   let gutters = assertGutters(view);
 
   let expander = gutters[0].querySelector(".ruleview-expander");
   ok (!view.element.firstChild.classList.contains("show-expandable-container"), "Pseudo Elements remain collapsed after switching element");
   expander.scrollIntoView();
   expander.click();
   ok (view.element.firstChild.classList.contains("show-expandable-container"), "Pseudo Elements are shown again after clicking twisty");
 }
 
 function* testBottomRight(inspector, view) {
   yield assertPseudoElementRulesNumbers("#bottomright", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 3,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 }
 
 function* testBottomLeft(inspector, view) {
   yield assertPseudoElementRulesNumbers("#bottomleft", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 }
 
 function* testParagraph(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#bottomleft p", inspector, view, {
     elementRulesNb: 3,
-    afterRulesNb: 0,
-    beforeRulesNb: 0,
     firstLineRulesNb: 1,
     firstLetterRulesNb: 1,
     selectionRulesNb: 1
   });
 
   let gutters = assertGutters(view);
 
   let elementFirstLineRule = rules.firstLineRules[0];
@@ -235,39 +213,34 @@ function* testNode(selector, inspector, 
   return {element: element, elementStyle: elementStyle};
 }
 
 function* assertPseudoElementRulesNumbers(selector, inspector, view, ruleNbs) {
   let {element, elementStyle} = yield testNode(selector, inspector, view);
 
   let rules = {
     elementRules: elementStyle.rules.filter(rule => !rule.pseudoElement),
-    afterRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":after"),
-    beforeRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":before"),
     firstLineRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":first-line"),
     firstLetterRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":first-letter"),
     selectionRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":-moz-selection")
   };
 
   is(rules.elementRules.length, ruleNbs.elementRulesNb, selector +
     " has the correct number of non pseudo element rules");
-  is(rules.afterRules.length, ruleNbs.afterRulesNb, selector +
-    " has the correct number of :after rules");
-  is(rules.beforeRules.length, ruleNbs.beforeRulesNb, selector +
-    " has the correct number of :before rules");
   is(rules.firstLineRules.length, ruleNbs.firstLineRulesNb, selector +
     " has the correct number of :first-line rules");
   is(rules.firstLetterRules.length, ruleNbs.firstLetterRulesNb, selector +
     " has the correct number of :first-letter rules");
   is(rules.selectionRules.length, ruleNbs.selectionRulesNb, selector +
     " has the correct number of :selection rules");
 
   return {rules: rules, element: element, elementStyle: elementStyle};
 }
 
 function assertGutters(view) {
   let gutters = view.element.querySelectorAll(".theme-gutter");
   is (gutters.length, 3, "There are 3 gutter headings");
   is (gutters[0].textContent, "Pseudo-elements", "Gutter heading is correct");
   is (gutters[1].textContent, "This Element", "Gutter heading is correct");
   is (gutters[2].textContent, "Inherited from body", "Gutter heading is correct");
+
   return gutters;
-}
+}
\ No newline at end of file
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js
@@ -0,0 +1,32 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that pseudoelements are displayed correctly in the rule view
+
+const TEST_URI = TEST_URL_ROOT + "doc_pseudoelement.html";
+
+let test = asyncTest(function*() {
+  yield addTab(TEST_URI);
+  let {toolbox, inspector, view} = yield openRuleView();
+
+  yield testTopLeft(inspector, view);
+});
+
+function* testTopLeft(inspector, view) {
+  let node = inspector.markup.walker.frontForRawNode(getNode("#topleft"));
+  let children = yield inspector.markup.walker.children(node);
+
+  is (children.nodes.length, 3, "Element has correct number of children");
+
+  let beforeElement = children.nodes[0];
+  is (beforeElement.tagName, "_moz_generated_content_before", "tag name is correct");
+  yield selectNode(beforeElement, inspector);
+
+  let afterElement = children.nodes[children.nodes.length-1];
+  is (afterElement.tagName, "_moz_generated_content_after", "tag name is correct");
+  yield selectNode(afterElement, inspector);
+}
+
diff --git a/browser/devtools/styleinspector/test/doc_pseudoelement.html b/browser/devtools/styleinspector/test/doc_pseudoelement.html
--- a/browser/devtools/styleinspector/test/doc_pseudoelement.html
+++ b/browser/devtools/styleinspector/test/doc_pseudoelement.html
@@ -13,16 +13,25 @@ body {
     width: 128px;
     height: 128px;
     background: #ddd;
     padding: 32px;
     margin: 32px;
     position:relative;
 }
 
+.box:first-line {
+    color: orange;
+    background: red;
+}
+
+.box:first-letter {
+    color: green;
+}
+
 * {
     cursor: default;
 }
 
 nothing {
     cursor: pointer;
 }
 
@@ -64,16 +73,23 @@ p:first-letter {
     margin-left: -16px;
 }
 
 .topleft:before {
     top:0;
     left:0;
 }
 
+.topleft:first-line {
+    color: orange;
+}
+.topleft::selection {
+    color: orange;
+}
+
 .topright:before {
     top:0;
     right:0;
 }
 
 .bottomright:before {
     bottom:10px;
     right:10px;
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -145,31 +145,36 @@ function selectAndHighlightNode(nodeOrSe
   inspector.selection.setNode(node, "test-highlight");
   return updated;
 
 }
 
 /**
  * Set the inspector's current selection to a node or to the first match of the
  * given css selector.
- * @param {String|DOMNode} nodeOrSelector
- * @param {InspectorPanel} inspector
- *        The instance of InspectorPanel currently loaded in the toolbox
- * @param {String} reason
- *        Defaults to "test" which instructs the inspector not to highlight the
- *        node upon selection
+ * @param {String|DOMNode|NodeFront} data The node to select.  If it is a string
+ * or DOMNode it will not be remote safe - using a NodeFront is safer.
+ * @param {InspectorPanel} inspector The instance of InspectorPanel currently
+ * loaded in the toolbox
+ * @param {String} reason Defaults to "test" which instructs the inspector not
+ * to highlight the node upon selection
+ *
  * @return a promise that resolves when the inspector is updated with the new
  * node
  */
-function selectNode(nodeOrSelector, inspector, reason="test") {
-  info("Selecting the node " + nodeOrSelector);
+function selectNode(data, inspector, reason="test") {
+  info("Selecting the node " + data);
 
-  let node = getNode(nodeOrSelector);
+  let node = getNode(data);
   let updated = inspector.once("inspector-updated");
-  inspector.selection.setNode(node, reason);
+  if (node._form) {
+    inspector.selection.setNodeFront(node, reason);
+  } else {
+    inspector.selection.setNode(node, reason);
+  }
   return updated;
 }
 
 /**
  * Set the inspector's current selection to null so that no node is selected
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return a promise that resolves when the inspector is updated
diff --git a/toolkit/devtools/Console.jsm b/toolkit/devtools/Console.jsm
--- a/toolkit/devtools/Console.jsm
+++ b/toolkit/devtools/Console.jsm
@@ -158,17 +158,17 @@ function stringify(aThing, aAllowNewLine
  * @param {nsIDOMElement} aElement
  *        The element to debug
  * @return {string}
  *        A simple single line representation of aElement
  */
 function debugElement(aElement) {
   return "<" + aElement.tagName +
       (aElement.id ? "#" + aElement.id : "") +
-      (aElement.className ?
+      (aElement.className && aElement.className.split ?
           "." + aElement.className.split(" ").join(" .") :
           "") +
       ">";
 }
 
 /**
  * A multi line stringification of an object, designed for use by humans
  *
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -491,8 +491,119 @@ LayoutHelpers.prototype = {
     return {
       p1: {x: xOffset, y: yOffset},
       p2: {x: xOffset + width, y: yOffset},
       p3: {x: xOffset + width, y: yOffset + height},
       p4: {x: xOffset, y: yOffset + height}
     };
   }
 };
+
+/**
+ * Traverse getBindingParent until arriving upon the bound element
+ * responsible for the generation of the specified node.
+ *
+ * @param {DOMNode} node
+ * @return {DOMNode}
+ *         If node is not anonymous, this will return node. Otherwise,
+ *         it will return the bound element
+ *
+ */
+LayoutHelpers.getRootBindingParent = function(node) {
+  let parent;
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return node;
+  }
+  while ((parent = doc.getBindingParent(node))) {
+    node = parent;
+  }
+  return node;
+};
+
+/**
+ * Determine whether a node is anonymous by determining if there
+ * is a bindingParent.
+ *
+ * @param {DOMNode} node
+ * @return {bool}
+ *
+ */
+LayoutHelpers.isAnonymous = function(node) {
+  return LayoutHelpers.getRootBindingParent(node) !== node;
+};
+
+/**
+ * Determine whether a node is native anonymous content (as opposed
+ * to XBL anonymous or shadow DOM).
+ *
+ * @param {DOMNode} node
+ * @return {bool}
+ *
+ */
+LayoutHelpers.isNativeAnonymous = function(node) {
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return false;
+  }
+
+  // If there is no binding parent then it is not anonymous.
+  let parent = doc.getBindingParent(node);
+  if (!parent) {
+    return false;
+  }
+
+  return !LayoutHelpers.isXBLAnonymous(node) &&
+         !LayoutHelpers.isShadowAnonymous(node);
+};
+
+/**
+ * Determine whether a node is XBL anonymous content (as opposed
+ * to native anonymous or shadow DOM).
+ *
+ * @param {DOMNode} node
+ * @return {bool}
+ *
+ */
+LayoutHelpers.isXBLAnonymous = function(node) {
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return false;
+  }
+
+  // If there is no binding parent then it is not anonymous.
+  let parent = doc.getBindingParent(node);
+  if (!parent) {
+    return false;
+  }
+
+  // Shadow nodes also show up in getAnonymousNodes, so return false
+  if (parent.shadowRoot && parent.shadowRoot.contains(node)) {
+    return false;
+  }
+
+  let anonNodes = [...doc.getAnonymousNodes(parent) || []];
+  return anonNodes.indexOf(node) > -1;
+};
+
+/**
+ * Determine whether a node is a child of a shadow root.
+ *
+ * @param {DOMNode} node
+ * @return {bool}
+ *
+ */
+LayoutHelpers.isShadowAnonymous = function(node) {
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return false;
+  }
+
+  // If there is no binding parent then it is not anonymous.
+  let parent = doc.getBindingParent(node);
+  if (!parent) {
+    return false;
+  }
+
+  // If there is a shadowRoot and this is part of it then this
+  // is not native anonymous
+  return parent.shadowRoot && parent.shadowRoot.contains(node);
+};
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -6,16 +6,17 @@
 
 const {Cu, Cc, Ci} = require("chrome");
 const Services = require("Services");
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method} = protocol;
 const events = require("sdk/event/core");
 const Heritage = require("sdk/core/heritage");
 
+const {CssLogic} = require("devtools/styleinspector/css-logic");
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const GUIDE_STROKE_WIDTH = 1;
 
 // Make sure the domnode type is known here
 require("devtools/server/actors/inspector");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
@@ -952,40 +953,47 @@ BoxModelHighlighter.prototype = Heritage
   /**
    * Update node information (tagName#id.class)
    */
   _updateInfobar: function() {
     if (!this.currentNode) {
       return;
     }
 
-    let node = this.currentNode;
     let info = this.nodeInfo;
 
+    let {elementToRead: node, pseudoToRead} =
+      CssLogic.getStyleableElementAndPseudo(this.currentNode);
+
     // Update the tag, id, classes, pseudo-classes and dimensions only if they
     // changed to avoid triggering paint events
-
     let tagName = node.tagName;
     if (info.tagNameLabel.textContent !== tagName) {
       info.tagNameLabel.textContent = tagName;
     }
 
     let id = node.id ? "#" + node.id : "";
     if (info.idLabel.textContent !== id) {
       info.idLabel.textContent = id;
     }
 
-    let classList = node.classList.length ? "." + [...node.classList].join(".") : "";
+    let classList = (node.classList || []).length ? "." + [...node.classList].join(".") : "";
     if (info.classesBox.textContent !== classList) {
       info.classesBox.textContent = classList;
     }
 
     let pseudos = PSEUDO_CLASSES.filter(pseudo => {
       return DOMUtils.hasPseudoClassLock(node, pseudo);
     }, this).join("");
+
+    if (pseudoToRead) {
+      // Display :after as ::after
+      pseudos += ":" + pseudoToRead;
+    }
+
     if (info.pseudoClassesBox.textContent !== pseudos) {
       info.pseudoClassesBox.textContent = pseudos;
     }
 
     let rect = node.getBoundingClientRect();
     let dim = Math.ceil(rect.width) + " x " + Math.ceil(rect.height);
     if (info.dimensionBox.textContent !== dim) {
       info.dimensionBox.textContent = dim;
@@ -1306,19 +1314,26 @@ function isNodeValid(node) {
     return false;
   }
 
   // Is it an element node
   if (node.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
     return false;
   }
 
-  // Is it connected to the document?
+  // Is the document inaccessible?
   let doc = node.ownerDocument;
-  if (!doc || !doc.defaultView || !doc.documentElement.contains(node)) {
+  if (!doc || !doc.defaultView) {
+    return false;
+  }
+
+  // Is the node connected to the document? Using getBindingParent adds
+  // support for anonymous elements generated by a node in the document.
+  let bindingParent = LayoutHelpers.getRootBindingParent(node);
+  if (!doc.documentElement.contains(bindingParent)) {
     return false;
   }
 
   return true;
 }
 
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -221,40 +221,37 @@ var NodeActor = exports.NodeActor = prot
   // Returns the JSON representation of this object over the wire.
   form: function(detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
 
-    // Estimate the number of children.
-    let numChildren = this.rawNode.childNodes.length;
-    if (numChildren === 0 &&
-        (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
-      // This might be an iframe with virtual children.
-      numChildren = 1;
-    }
-
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
-      numChildren: numChildren,
+      numChildren: this.numChildren,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
-
+      isBeforePseudoElement: this.rawNode.nodeName === "_moz_generated_content_before",
+      isAfterPseudoElement: this.rawNode.nodeName === "_moz_generated_content_after",
+      isAnonymous: LayoutHelpers.isAnonymous(this.rawNode),
+      isNativeAnonymous: LayoutHelpers.isNativeAnonymous(this.rawNode),
+      isXBLAnonymous: LayoutHelpers.isXBLAnonymous(this.rawNode),
+      isShadowAnonymous: LayoutHelpers.isShadowAnonymous(this.rawNode),
       pseudoClassLocks: this.writePseudoClassLocks(),
 
       isDisplayed: this.isDisplayed,
 
       hasEventListeners: this._hasEventListeners,
     };
 
     if (this.isDocumentElement()) {
@@ -270,16 +267,43 @@ var NodeActor = exports.NodeActor = prot
       } else {
         form.shortValue = this.rawNode.nodeValue;
       }
     }
 
     return form;
   },
 
+  // Estimate the number of children that the walker will return without making
+  // a call to children() if possible.
+  get numChildren() {
+    let numChildren = this.rawNode.childNodes.length;
+    if (numChildren === 0 &&
+        (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
+      // This might be an iframe with virtual children.
+      numChildren = 1;
+    }
+
+    // Count any anonymous children
+    if (this.rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+      let anonChildren = this.rawNode.ownerDocument.getAnonymousNodes(this.rawNode);
+      if (anonChildren) {
+        numChildren += anonChildren.length;
+      }
+    }
+
+    // Normal counting misses ::before/::after, so we have to check to make sure
+    // we aren't missing anything
+    if (numChildren === 0) {
+      numChildren = this.walker.children(this).nodes.length;
+    }
+
+    return numChildren;
+  },
+
   get computedStyle() {
     if (Cu.isDeadWrapper(this.rawNode) ||
         this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE ||
         !this.rawNode.ownerDocument ||
         !this.rawNode.ownerDocument.defaultView) {
       return null;
     }
     return this.rawNode.ownerDocument.defaultView.getComputedStyle(this.rawNode);
@@ -714,19 +738,23 @@ let NodeFront = protocol.FrontClass(Node
   get baseURI() this._form.baseURI,
 
   get className() {
     return this.getAttribute("class") || '';
   },
 
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
-
   get hasEventListeners() this._form.hasEventListeners,
 
+  get isBeforePseudoElement() this._form.isBeforePseudoElement,
+  get isAfterPseudoElement() this._form.isAfterPseudoElement,
+  get isPseudoElement() this.isBeforePseudoElement || this.isAfterPseudoElement,
+  get isAnonymous() this._form.isAnonymous,
+
   get tagName() this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE ? this.nodeName : null,
   get shortValue() this._form.shortValue,
   get incompleteValue() !!this._form.incompleteValue,
 
   get isDocumentElement() !!this._form.isDocumentElement,
 
   // doctype properties
   get name() this._form.name,
@@ -2138,17 +2166,18 @@ var WalkerActor = protocol.ActorClass({
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
       let mutation = {
         type: change.type,
         target: targetActor.actorID,
-      }
+        numChildren: targetActor.numChildren
+      };
 
       if (mutation.type === "attributes") {
         mutation.attributeName = change.attributeName;
         mutation.attributeNamespace = change.attributeNamespace || undefined;
         mutation.newValue = targetNode.getAttribute(mutation.attributeName);
       } else if (mutation.type === "characterData") {
         if (targetNode.nodeValue.length > gValueSummaryLength) {
           mutation.newValue = targetNode.nodeValue.substring(0, gValueSummaryLength);
@@ -2181,17 +2210,17 @@ var WalkerActor = protocol.ActorClass({
             continue;
           }
           // The actor is reconnected to the ownership tree, unorphan
           // it and let the client know so that its ownership tree is up
           // to date.
           this._orphaned.delete(addedActor);
           addedActors.push(addedActor.actorID);
         }
-        mutation.numChildren = change.target.childNodes.length;
+
         mutation.removed = removedActors;
         mutation.added = addedActors;
       }
       this.queueMutation(mutation);
     }
   },
 
   onFrameLoad: function({ window, isTopLevel }) {
@@ -2576,17 +2605,23 @@ var WalkerFront = exports.WalkerFront = 
             // it.
             this._orphaned.delete(addedFront);
             addedFronts.push(addedFront);
           }
           // Before passing to users, replace the added and removed actor
           // ids with front in the mutation record.
           emittedMutation.added = addedFronts;
           emittedMutation.removed = removedFronts;
-          targetFront._form.numChildren = change.numChildren;
+
+          // If this is coming from a DOM mutation, the actor's numChildren
+          // was passed in.  Otherwise, it is simulated from a frame load or
+          // unload, so don't change the _front.
+          if ('numChildren' in change) {
+            targetFront._form.numChildren = change.numChildren;
+          }
         } else if (change.type === "frameLoad") {
           // Nothing we need to do here, except verify that we don't have any
           // document children, because we should have gotten a documentUnload
           // first.
           for (let child of targetFront.treeChildren()) {
             if (child.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE) {
               console.trace("Got an unexpected frameLoad in the inspector, please file a bug on bugzilla.mozilla.org!");
             }
@@ -2939,116 +2974,106 @@ function documentWalker(node, rootWin, w
 // Exported for test purposes.
 exports._documentWalker = documentWalker;
 
 function nodeDocument(node) {
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
- * Similar to a TreeWalker, except will dig in to iframes and it doesn't
- * implement the good methods like previousNode and nextNode.
- *
- * See TreeWalker documentation for explanations of the methods.
+ * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
+ * See inDeepTreeWalker for more information about the methods.
  */
 function DocumentWalker(aNode, aRootWin, aShow, aFilter, aExpandEntityReferences) {
   if (!aRootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
-  let doc = nodeDocument(aNode);
-  this.layoutHelpers = new LayoutHelpers(aRootWin);
-  this.walker = doc.createTreeWalker(doc,
-    aShow, aFilter, aExpandEntityReferences);
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.init(aRootWin.document, aShow);
   this.walker.currentNode = aNode;
   this.filter = aFilter;
 }
 
 DocumentWalker.prototype = {
   get node() this.walker.node,
   get whatToShow() this.walker.whatToShow,
   get expandEntityReferences() this.walker.expandEntityReferences,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
 
-  /**
-   * Called when the new node is in a different document than
-   * the current node, creates a new treewalker for the document we've
-   * run in to.
-   */
-  _reparentWalker: function(aNewNode) {
-    if (!aNewNode) {
-      return null;
-    }
-    let doc = nodeDocument(aNewNode);
-    let walker = doc.createTreeWalker(doc,
-      this.whatToShow, this.filter, this.expandEntityReferences);
-    walker.currentNode = aNewNode;
-    this.walker = walker;
-    return aNewNode;
-  },
-
   parentNode: function() {
-    let currentNode = this.walker.currentNode;
-    let parentNode = this.walker.parentNode();
-
-    if (!parentNode) {
-      if (currentNode && currentNode.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE
-          && currentNode.defaultView) {
-
-        let window = currentNode.defaultView;
-        let frame = this.layoutHelpers.getFrameElement(window);
-        if (frame) {
-          return this._reparentWalker(frame);
-        }
-      }
-      return null;
-    }
-
-    return parentNode;
+    return this.walker.parentNode();
   },
 
   firstChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument && node.getSVGDocument()) {
-      return this._reparentWalker(node.getSVGDocument());
+
+    let firstChild = this.walker.firstChild();
+    while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      firstChild = this.walker.nextSibling();
     }
-    return this.walker.firstChild();
+
+    return firstChild;
   },
 
   lastChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument && node.getSVGDocument()) {
-      return this._reparentWalker(node.getSVGDocument());
+
+    let lastChild = this.walker.lastChild();
+    while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      lastChild = this.walker.previousSibling();
     }
-    return this.walker.lastChild();
+
+    return lastChild;
   },
 
-  previousSibling: function DW_previousSibling() this.walker.previousSibling(),
-  nextSibling: function DW_nextSibling() this.walker.nextSibling()
+  previousSibling: function() {
+    let node = this.walker.previousSibling();
+    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      node = this.walker.previousSibling();
+    }
+    return node;
+  },
+
+  nextSibling: function() {
+    let node = this.walker.nextSibling();
+    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      node = this.walker.nextSibling();
+    }
+    return node;
+  }
 };
 
 /**
  * A tree walker filter for avoiding empty whitespace text nodes.
  */
 function whitespaceTextFilter(aNode) {
-    if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
-        !/[^\s]/.exec(aNode.nodeValue)) {
-      return Ci.nsIDOMNodeFilter.FILTER_SKIP;
-    } else {
-      return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;
-    }
+  // Ignore empty whitespace text nodes.
+  if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
+      !/[^\s]/.exec(aNode.nodeValue)) {
+    return Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  }
+
+  // Ignore native anonymous content (internals for form controls, for instance).
+  // ::before/::after are native anonymous, but as far as the walker
+  // is concerned it is not.
+  if (LayoutHelpers.isNativeAnonymous(aNode) && (
+      aNode.nodeName !== "_moz_generated_content_before" &&
+      aNode.nodeName !== "_moz_generated_content_after")) {
+    return Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  }
+
+  return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;
 }
 
 /**
  * Given an image DOMNode, return the image data-uri.
  * @param {DOMNode} node The image node
  * @param {Number} maxDim Optionally pass a maximum size you want the longest
  * side of the image to be resized to before getting the image data.
  * @return {Object} An object containing the data-uri and size-related information
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -20,16 +20,19 @@ loader.lazyGetter(this, "DOMUtils", () =
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
 const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
+const PSEUDO_ELEMENTS_TO_READ = PSEUDO_ELEMENTS.filter(pseudo => {
+  return pseudo !== ":before" && pseudo !== ":after";
+});
 
 // Predeclare the domnode actor type for use in requests.
 types.addActorType("domnode");
 
 // Predeclare the domstylerule actor type
 types.addActorType("domstylerule");
 
 /**
@@ -298,17 +301,17 @@ var PageStyleActor = protocol.ActorClass
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSeletors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
   getApplied: method(function(node, options) {
     let entries = [];
-    this.addElementRules(node.rawNode, undefined, options, entries);
+    entries = entries.concat(this._getAllElementRules(node, undefined, options));
     return this.getAppliedProps(node, entries, options);
   }, {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
@@ -318,74 +321,124 @@ var PageStyleActor = protocol.ActorClass
   _hasInheritedProps: function(style) {
     return Array.prototype.some.call(style, prop => {
       return DOMUtils.isInheritedProperty(prop);
     });
   },
 
   /**
    * Helper function for getApplied, adds all the rules from a given
-   * element.
+   * element. See getApplied for documentation on parameters.
+   * @param NodeActor node
+   * @param bool inherited
+   * @param object options
+   * @param Array rules (modifies this instead of returning)
    */
-  addElementRules: function(element, inherited, options, rules) {
-    if (!element.style) {
-      return;
+  _getAllElementRules: function(node, inherited, options) {
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(node.rawNode);
+    let rules = [];
+
+    if (!elementToRead || !elementToRead.style) {
+      return rules;
     }
 
-    let elementStyle = this._styleRef(element);
+    let elementStyle = this._styleRef(elementToRead);
+    let showElementStyles = !inherited && !pseudoToRead;
+    let showInheritedStyles = inherited && this._hasInheritedProps(elementToRead.style);
 
-    if (!inherited || this._hasInheritedProps(element.style)) {
+    // First any inline styles
+    if (showElementStyles) {
       rules.push({
         rule: elementStyle,
-        inherited: inherited,
       });
     }
 
-    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
-    for (let pseudo of pseudoElements) {
+    // Now any inherited styles
+    if (showInheritedStyles) {
+      rules.push({
+        rule: elementStyle,
+        inherited: inherited
+      });
+    }
 
-      // Get the styles that apply to the element.
-      let domRules = DOMUtils.getCSSStyleRules(element, pseudo);
+    // Add normal rules.  Typically this is passing in the node passed into the
+    // function, unless if that node was ::before/::after.  In which case,
+    // it will pass in the parentNode along with "::before"/"::after".
+    this._getElementRules(elementToRead, pseudoToRead, inherited, options).forEach((rule) => {
+      // The only case when there would be a pseudo here is ::before/::after,
+      // and in this case we want to tell the view that it belongs to the
+      // element (which is a _moz_generated_content native anonymous element).
+      rule.pseudoElement = null;
+      rules.push(rule);
+    });
 
-      if (!domRules) {
+    // Now any pseudos (except for ::before / ::after, which was handled as
+    // a 'normal rule' above.
+    if (showElementStyles) {
+      for (let pseudo of PSEUDO_ELEMENTS_TO_READ) {
+        this._getElementRules(elementToRead, pseudo, inherited, options).forEach((rule) => {
+          rules.push(rule);
+        });
+      }
+    }
+
+    return rules;
+  },
+
+  /**
+   * Helper function for _getAllElementRules, returns the rules from a given
+   * element. See getApplied for documentation on parameters.
+   * @param DOMNode elementToRead
+   * @param string pseudoToRead
+   * @param DOMNode inherited
+   * @param object options
+   *
+   * @returns Array rules
+   */
+  _getElementRules: function (elementToRead, pseudoToRead, inherited, options) {
+    let domRules = DOMUtils.getCSSStyleRules(elementToRead, pseudoToRead);
+    if (!domRules) {
+      return [];
+    }
+
+    let rules = [];
+
+    // getCSSStyleRules returns ordered from least-specific to
+    // most-specific.
+    for (let i = domRules.Count() - 1; i >= 0; i--) {
+      let domRule = domRules.GetElementAt(i);
+
+      let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
+
+      if (isSystem && options.filter != CssLogic.FILTER.UA) {
         continue;
       }
 
-      // getCSSStyleRules returns ordered from least-specific to
-      // most-specific.
-      for (let i = domRules.Count() - 1; i >= 0; i--) {
-        let domRule = domRules.GetElementAt(i);
-
-        let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
-
-        if (isSystem && options.filter != CssLogic.FILTER.UA) {
+      if (inherited) {
+        // Don't include inherited rules if none of its properties
+        // are inheritable.
+        let hasInherited = Array.prototype.some.call(domRule.style, prop => {
+          return DOMUtils.isInheritedProperty(prop);
+        });
+        if (!hasInherited) {
           continue;
         }
+      }
 
-        if (inherited) {
-          // Don't include inherited rules if none of its properties
-          // are inheritable.
-          let hasInherited = Array.prototype.some.call(domRule.style, prop => {
-            return DOMUtils.isInheritedProperty(prop);
-          });
-          if (!hasInherited) {
-            continue;
-          }
-        }
+      let ruleActor = this._styleRef(domRule);
+      rules.push({
+        rule: ruleActor,
+        inherited: inherited,
+        isSystem: isSystem,
+        pseudoElement: pseudoToRead
+      });
+    }
+    return rules;
+  },
 
-        let ruleActor = this._styleRef(domRule);
-        rules.push({
-          rule: ruleActor,
-          inherited: inherited,
-          pseudoElement: pseudo,
-          isSystem: isSystem
-        });
-      }
-    }
-  },
 
   /**
    * Helper function for getApplied and addNewRule that fetches a set of
    * style properties that apply to the given node and associated rules
    * @param NodeActor node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
@@ -402,33 +455,35 @@ var PageStyleActor = protocol.ActorClass
    * @returns Object containing the list of rule entries, rule actors and
    *   stylesheet actors that applies to the given node and its associated
    *   rules.
    */
   getAppliedProps: function(node, entries, options) {
     if (options.inherited) {
       let parent = this.walker.parentNode(node);
       while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
-        this.addElementRules(parent.rawNode, parent, options, entries);
+        entries = entries.concat(this._getAllElementRules(parent, parent, options));
         parent = this.walker.parentNode(parent);
       }
     }
 
     if (options.matchedSelectors) {
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
         }
 
         let domRule = entry.rule.rawRule;
         let selectors = CssLogic.getSelectors(domRule);
         let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;
+
+        let {pseudoToRead,elementToRead} = CssLogic.getStyleableElementAndPseudo(element);
         entry.matchedSelectors = [];
         for (let i = 0; i < selectors.length; i++) {
-          if (DOMUtils.selectorMatchesElement(element, domRule, i)) {
+          if (DOMUtils.selectorMatchesElement(elementToRead, domRule, i, pseudoToRead)) {
             entry.matchedSelectors.push(selectors[i]);
           }
         }
       }
     }
 
     // Add all the keyframes rule associated with the element
     let computedStyle = this.cssLogic.computedStyle;
diff --git a/toolkit/devtools/server/tests/mochitest/chrome.ini b/toolkit/devtools/server/tests/mochitest/chrome.ini
--- a/toolkit/devtools/server/tests/mochitest/chrome.ini
+++ b/toolkit/devtools/server/tests/mochitest/chrome.ini
@@ -24,16 +24,17 @@ support-files =
 [test_framerate_03.html]
 [test_framerate_04.html]
 [test_framerate_05.html]
 [test_highlighter-boxmodel_01.html]
 [test_highlighter-boxmodel_02.html]
 [test_highlighter-csstransform_01.html]
 [test_highlighter-csstransform_02.html]
 [test_highlighter-csstransform_03.html]
+[test_inspector-anonymous.html]
 [test_inspector-changeattrs.html]
 [test_inspector-changevalue.html]
 [test_inspector-hide.html]
 [test_inspector-insert.html]
 [test_inspector-mutations-attr.html]
 [test_inspector-mutations-childlist.html]
 [test_inspector-mutations-frameload.html]
 [test_inspector-mutations-value.html]
diff --git a/toolkit/devtools/server/tests/mochitest/inspector-helpers.js b/toolkit/devtools/server/tests/mochitest/inspector-helpers.js
--- a/toolkit/devtools/server/tests/mochitest/inspector-helpers.js
+++ b/toolkit/devtools/server/tests/mochitest/inspector-helpers.js
@@ -1,13 +1,14 @@
 var Cu = Components.utils;
 
 Cu.import("resource://gre/modules/devtools/Loader.jsm");
 Cu.import("resource://gre/modules/devtools/dbg-client.jsm");
 Cu.import("resource://gre/modules/devtools/dbg-server.jsm");
+Cu.import("resource://gre/modules/Task.jsm");
 
 const Services = devtools.require("Services");
 const {_documentWalker} = devtools.require("devtools/server/actors/inspector");
 
 // Always log packets when running tests.
 Services.prefs.setBoolPref("devtools.debugger.log", true);
 SimpleTest.registerCleanupFunction(function() {
   Services.prefs.clearUserPref("devtools.debugger.log");
@@ -285,16 +286,20 @@ function waitForMutation(walker, test, m
 }
 
 
 var _tests = [];
 function addTest(test) {
   _tests.push(test);
 }
 
+function addAsyncTest(generator) {
+  _tests.push(() => Task.spawn(generator).then(null, ok.bind(null, false)));
+}
+
 function runNextTest() {
   if (_tests.length == 0) {
     SimpleTest.finish()
     return;
   }
   var fn = _tests.shift();
   try {
     fn();
diff --git a/toolkit/devtools/server/tests/mochitest/inspector-traversal-data.html b/toolkit/devtools/server/tests/mochitest/inspector-traversal-data.html
--- a/toolkit/devtools/server/tests/mochitest/inspector-traversal-data.html
+++ b/toolkit/devtools/server/tests/mochitest/inspector-traversal-data.html
@@ -1,24 +1,49 @@
 <html>
 <head>
+  <meta charset="UTF-8">
+  <title>Inspector Traversal Test Data</title>
+  <style type="text/css">
+    #pseudo::before {
+      content: "before";
+    }
+    #pseudo::after {
+      content: "after";
+    }
+    #pseudo-empty::before {
+      content: "before an empty element";
+    }
+    #shadow::before {
+      content: "Testing ::before on a shadow host";
+    }
+  </style>
   <script type="text/javascript">
     window.onload = function() {
+
+      // Set up a basic shadow DOM
+      var host = document.querySelector('#shadow');
+      if (host.createShadowRoot) {
+        var root = host.createShadowRoot();
+        root.innerHTML = '<h3>Shadow <em>DOM</em></h3><select multiple></select>';
+      }
+
       // Put a copy of the body in an iframe to test frame traversal.
       var body = document.querySelector("body");
       var data = "data:text/html,<html>" + body.outerHTML + "<html>";
       var iframe = document.createElement("iframe");
       iframe.setAttribute("id", "childFrame");
       iframe.onload = function() {
         window.opener.postMessage('ready', '*')
       };
       iframe.src = data;
       body.appendChild(iframe);
     }
   </script>
+</head>
 <body style="background-color:white">
   <h1>Inspector Actor Tests</h1>
   <span id="longstring">longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong</span>
   <span id="shortstring">short</span>
   <span id="empty"></span>
   <div id="longlist" data-test="exists">
     <div id="a">a</div>
     <div id="b">b</div>
@@ -46,13 +71,20 @@
     <div id="x">x</div>
     <div id="y">y</div>
     <div id="z">z</div>
   </div>
   <div id="longlist-sibling">
     <div id="longlist-sibling-firstchild"></div>
   </div>
   <p id="edit-html"></p>
+
+  <select multiple><option>one</option><option>two</option></select>
+  <div id="pseudo"><span>middle</span></div>
+  <div id="pseudo-empty"></div>
+
+  <div id="shadow">light dom</div>
+
   <object>
       <div id="1"></div>
   </object>
 </body>
 </html>
diff --git a/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html b/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html
@@ -0,0 +1,167 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=777674
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 777674</title>
+
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+  <script type="application/javascript;version=1.8" src="inspector-helpers.js"></script>
+  <script type="application/javascript;version=1.8">
+Components.utils.import("resource://gre/modules/devtools/Loader.jsm");
+const {Promise: promise} = Components.utils.import("resource://gre/modules/Promise.jsm", {});
+
+const inspector = devtools.require("devtools/server/actors/inspector");
+
+window.onload = function() {
+  Services.prefs.setBoolPref("dom.webcomponents.enabled", true);
+  SimpleTest.waitForExplicitFinish();
+  runNextTest();
+};
+
+SimpleTest.registerCleanupFunction(() => {
+  Services.prefs.clearUserPref("dom.webcomponents.enabled");
+});
+
+var gWalker = null;
+var gClient = null;
+
+function assertOwnership() {
+  return assertOwnershipTrees(gWalker);
+}
+
+addTest(function setup() {
+  let url = document.getElementById("inspectorContent").href;
+  attachURL(url, function(err, client, tab, doc) {
+    gInspectee = doc;
+    let {InspectorFront} = devtools.require("devtools/server/actors/inspector");
+    let inspector = InspectorFront(client, tab);
+    promiseDone(inspector.getWalker().then(walker => {
+      ok(walker, "getWalker() should return an actor.");
+      gClient = client;
+      gWalker = walker;
+    }).then(runNextTest));
+  });
+});
+
+addAsyncTest(function* testNativeAnonymous() {
+  let select = yield gWalker.querySelector(gWalker.rootNode, "select");
+  let children = yield gWalker.children(select);
+
+  is (select.numChildren, 2, "No native anon content for form control");
+  is (children.nodes.length, 2, "No native anon content for form control");
+
+  runNextTest();
+});
+
+addAsyncTest(function* testPseudo() {
+
+  // Markup looks like: <div><::before /><span /><::after /></div>
+  let pseudo = yield gWalker.querySelector(gWalker.rootNode, "#pseudo");
+  let children = yield gWalker.children(pseudo);
+
+  is (pseudo.numChildren, 1, "::before/::after are not counted if there is a child");
+  is (children.nodes.length, 3, "Correct number of children");
+
+  let before = children.nodes[0];
+  ok (before.isAnonymous, "Child is anonymous");
+  ok (!before._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (!before._form.isShadowAnonymous, "Child is not shadow anonymous");
+  ok (before._form.isNativeAnonymous, "Child is native anonymous");
+
+  let span = children.nodes[1];
+  ok (!span.isAnonymous, "Child is not anonymous");
+
+  let after = children.nodes[2];
+  ok (after.isAnonymous, "Child is anonymous");
+  ok (!after._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (!after._form.isShadowAnonymous, "Child is not shadow anonymous");
+  ok (after._form.isNativeAnonymous, "Child is native anonymous");
+
+  runNextTest();
+});
+
+
+addAsyncTest(function* testEmptyPseudo() {
+  info ("Checking an element whose only child is a pseudo element");
+  let pseudo = yield gWalker.querySelector(gWalker.rootNode, "#pseudo-empty");
+  let children = yield gWalker.children(pseudo);
+
+  is (pseudo.numChildren, 1, "::before/::after are is counted if there are no other children");
+  is (children.nodes.length, 1, "Correct number of children");
+
+  let before = children.nodes[0];
+  ok (before.isAnonymous, "Child is anonymous");
+  ok (!before._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (!before._form.isShadowAnonymous, "Child is not shadow anonymous");
+  ok (before._form.isNativeAnonymous, "Child is native anonymous");
+
+  runNextTest();
+});
+
+
+addAsyncTest(function* testShadowAnonymous() {
+  let shadow = yield gWalker.querySelector(gWalker.rootNode, "#shadow");
+  let children = yield gWalker.children(shadow);
+
+  is (shadow.numChildren, 3, "Children of the shadow root are counted");
+  is (children.nodes.length, 3, "Children returned from walker");
+
+  let before = children.nodes[0];
+  ok (before.isAnonymous, "Child is anonymous");
+  ok (!before._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (!before._form.isShadowAnonymous, "Child is not shadow anonymous");
+  ok (before._form.isNativeAnonymous, "Child is native anonymous");
+
+  // <h3>Shadow <em>DOM</em></h3>
+  let shadowChild1 = children.nodes[1];
+  ok (shadowChild1.isAnonymous, "Child is anonymous");
+  ok (!shadowChild1._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (shadowChild1._form.isShadowAnonymous, "Child is shadow anonymous");
+  ok (!shadowChild1._form.isNativeAnonymous, "Child is not native anonymous");
+
+  let shadowSubChildren = yield gWalker.children(children.nodes[1]);
+  is (shadowChild1.numChildren, 2, "Subchildren of the shadow root are counted");
+  is (shadowSubChildren.nodes.length, 2, "Subchildren arenreturned from walker");
+
+  // <em>DOM</em>
+  let shadowSubChild = children.nodes[1];
+  ok (shadowSubChild.isAnonymous, "Child is anonymous");
+  ok (!shadowSubChild._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (shadowSubChild._form.isShadowAnonymous, "Child is shadow anonymous");
+  ok (!shadowSubChild._form.isNativeAnonymous, "Child is not native anonymous");
+
+  // <select multiple></select>
+  let shadowChild2 = children.nodes[2];
+  ok (shadowChild2.isAnonymous, "Child is anonymous");
+  ok (!shadowChild2._form.isXBLAnonymous, "Child is not XBL anonymous");
+  ok (shadowChild2._form.isShadowAnonymous, "Child is shadow anonymous");
+  ok (!shadowChild2._form.isNativeAnonymous, "Child is not native anonymous");
+
+  runNextTest();
+});
+
+
+addTest(function cleanup() {
+  delete gWalker;
+  delete gClient;
+  runNextTest();
+});
+
+
+  </script>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=">Mozilla Bug </a>
+<a id="inspectorContent" target="_blank" href="inspector-traversal-data.html">Test Document</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+</body>
+</html>
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -49,16 +49,17 @@ const RX_CONNECTORS = /\s*[\s>+~]\s*/g;
 const RX_ID = /\s*#\w+\s*/g;
 const RX_CLASS_OR_ATTRIBUTE = /\s*(?:\.\w+|\[.+?\])\s*/g;
 const RX_PSEUDO = /\s*:?:([\w-]+)(\(?\)?)\s*/g;
 
 // This should be ok because none of the functions that use this should be used
 // on the worker thread, where Cu is not available.
 if (Cu) {
   Cu.importGlobalProperties(['CSS']);
+  Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 }
 
 function CssLogic()
 {
   // The cache of examined CSS properties.
   _propertyInfos: {};
 }
 
@@ -175,17 +176,22 @@ CssLogic.prototype = {
     } else {
       // Clear cached data in the CssPropertyInfo objects.
       this._propertyInfos = {};
     }
 
     this._matchedRules = null;
     this._matchedSelectors = null;
     let win = this.viewedDocument.defaultView;
-    this._computedStyle = win.getComputedStyle(this.viewedElement, "");
+
+    // Handle computed styles on pseudo by reading style rules
+    // on the parent node with proper pseudo arg to getComputedStyle.
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(this.viewedElement);
+
+    this._computedStyle = win.getComputedStyle(elementToRead, pseudoToRead);
   },
 
   /**
    * Get the values of all the computed CSS properties for the highlighted
    * element.
    * @returns {object} The computed CSS properties for a selected element
    */
   get computedStyle() {
@@ -610,24 +616,29 @@ CssLogic.prototype = {
       return;
     }
 
     do {
       let status = this.viewedElement === element ?
                    CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
 
       try {
-        domRules = domUtils.getCSSStyleRules(element);
+        // Handle finding rules on pseudo by reading style rules
+        // on the parent node with proper pseudo arg to getCSSStyleRules.
+        let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(element);
+        domRules = domUtils.getCSSStyleRules(elementToRead, pseudoToRead);
       } catch (ex) {
         Services.console.
           logStringMessage("CL__buildMatchedRules error: " + ex);
         continue;
       }
 
-      for (let i = 0, n = domRules.Count(); i < n; i++) {
+      // getCSSStyleRules can return null with a shadow DOM element.
+      let numDomRules = domRules ? domRules.Count() : 0;
+      for (let i = 0; i < numDomRules; i++) {
         let domRule = domRules.GetElementAt(i);
         if (domRule.type !== Ci.nsIDOMCSSRule.STYLE_RULE) {
           continue;
         }
 
         let sheet = this.getSheet(domRule.parentStyleSheet, -1);
         if (sheet._passId !== this._passId) {
           sheet.index = sheetIndex++;
@@ -749,16 +760,44 @@ CssLogic.getSelectors = function CssLogi
   let len = domUtils.getSelectorCount(aDOMRule);
   for (let i = 0; i < len; i++) {
     let text = domUtils.getSelectorText(aDOMRule, i);
     selectors.push(text);
   }
   return selectors;
 }
 
+
+
+/**
+ * Given a node, check to see if it is a ::before or ::after element.
+ * If so, return the node that is accessible from within the document
+ * (the parent of the anonymous node), along with which pseudo element
+ * it was.  Otherwise, return the node itself.
+ *
+ * @returns {Object}
+ *            - {DOMNode} elementToRead The non-anonymous node
+ *            - {string} pseudoToRead One of ':before', ':after', or null.
+ */
+CssLogic.getStyleableElementAndPseudo = function(node) {
+  let elementToRead = node;
+  let pseudoToRead = null;
+  if (node.nodeName == "_moz_generated_content_before") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":before";
+  } else if (node.nodeName == "_moz_generated_content_after") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":after";
+  }
+  return {
+    elementToRead: elementToRead,
+    pseudoToRead: pseudoToRead
+  };
+},
+
 /**
  * Memonized lookup of a l10n string from a string bundle.
  * @param {string} aName The key to lookup.
  * @returns A localized version of the given key.
  */
 CssLogic.l10n = function(aName) CssLogic._strings.GetStringFromName(aName);
 
 DevToolsUtils.defineLazyGetter(CssLogic, "_strings", function() Services.strings
@@ -855,18 +894,19 @@ function positionInNodeList(element, nod
 }
 
 /**
  * Find a unique CSS selector for a given element
  * @returns a string such that ele.ownerDocument.querySelector(reply) === ele
  * and ele.ownerDocument.querySelectorAll(reply).length === 1
  */
 CssLogic.findCssSelector = function CssLogic_findCssSelector(ele) {
+  ele = LayoutHelpers.getRootBindingParent(ele);
   var document = ele.ownerDocument;
-  if (!document.contains(ele)) {
+  if (!document || !document.contains(ele)) {
     throw new Error('findCssSelector received element not inside document');
   }
 
   // document.querySelectorAll("#id") returns multiple if elements share an ID
   if (ele.id && document.querySelectorAll('#' + CSS.escape(ele.id)).length === 1) {
     return '#' + CSS.escape(ele.id);
   }
 
