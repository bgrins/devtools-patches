# HG changeset patch
# Parent e2b6bc035256e65911e1348edc9124230447a05b
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 777674 - Add support for inspecting anonymous content

diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -88,17 +88,17 @@ FontInspector.prototype = {
       return;
     }
 
     let node = this.inspector.selection.node;
     let contentDocument = node.ownerDocument;
 
     // We don't get fonts for a node, but for a range
     let rng = contentDocument.createRange();
-    rng.selectNode(node);
+    rng.selectNodeContents(node);
     let fonts = DOMUtils.getUsedFontFaces(rng);
     let fontsArray = [];
     for (let i = 0; i < fonts.length; i++) {
       fontsArray.push(fonts.item(i));
     }
     fontsArray = fontsArray.sort(function(a, b) {
       return a.srcIndex < b.srcIndex;
     });
diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
--- a/browser/devtools/framework/selection.js
+++ b/browser/devtools/framework/selection.js
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {Cu, Ci} = require("chrome");
 let EventEmitter = require("devtools/toolkit/event-emitter");
+Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 /**
  * API
  *
  *   new Selection(walker=null, node=null, track={attributes,detached});
  *   destroy()
  *   node (readonly)
  *   setNode(node, origin="unknown")
@@ -220,21 +221,29 @@ Selection.prototype = {
     // accessing node.rawNode, this needs to stay.
     let rawNode = null;
     if (node.isLocal_toBeDeprecated()) {
       rawNode = node.rawNode();
     }
     if (rawNode) {
       try {
         let doc = this.document;
-        return (doc && doc.defaultView && doc.documentElement.contains(rawNode));
+        if (doc && doc.defaultView) {
+          let docEl = doc.documentElement;
+          let bindingParent =
+            new LayoutHelpers(doc.defaultView).getRootBindingParent(rawNode);
+
+          if (docEl.contains(bindingParent)) {
+            return true;
+          }
+        }
       } catch (e) {
         // "can't access dead object" error
-        return false;
       }
+      return false;
     }
 
     while(node) {
       if (node === this._walker.rootNode) {
         return true;
       }
       node = node.parentNode();
     };
@@ -247,16 +256,20 @@ Selection.prototype = {
   },
 
   // Node type
 
   isElementNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
   },
 
+  isPseudoElementNode: function() {
+    return this.isNode() && this.nodeFront.isPseudoElement;
+  },
+
   isAttributeNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
   },
 
   isTextNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
   },
 
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -401,17 +401,19 @@ InspectorPanel.prototype = {
     // client know.
     let selection = this.selection.nodeFront;
 
     // On any new selection made by the user, store the unique css selector
     // of the selected node so it can be restored after reload of the same page
     if (reason !== "navigateaway" &&
         this.selection.node &&
         this.selection.isElementNode()) {
-      this.selectionCssSelector = CssLogic.findCssSelector(this.selection.node);
+      try { // Anonymous nodes do not have a selector in the document
+        this.selectionCssSelector = CssLogic.findCssSelector(this.selection.node);
+      } catch(e) { }
     }
 
     let selfUpdate = this.updating("inspector-panel");
     Services.tm.mainThread.dispatch(() => {
       try {
         selfUpdate(selection);
       } catch(ex) {
         console.error(ex);
@@ -577,34 +579,36 @@ InspectorPanel.prototype = {
     }
     return null;
   },
 
   /**
    * Disable the delete item if needed. Update the pseudo classes.
    */
   _setupNodeMenu: function InspectorPanel_setupNodeMenu() {
-    let isSelectionElement = this.selection.isElementNode();
+    let isSelectionElement = this.selection.isElementNode() &&
+                             !this.selection.isPseudoElementNode;
 
     // Set the pseudo classes
     for (let name of ["hover", "active", "focus"]) {
       let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);
 
       if (isSelectionElement) {
         let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
         menu.setAttribute("checked", checked);
         menu.removeAttribute("disabled");
       } else {
         menu.setAttribute("disabled", "true");
       }
     }
 
     // Disable delete item if needed
     let deleteNode = this.panelDoc.getElementById("node-menu-delete");
-    if (this.selection.isRoot() || this.selection.isDocumentTypeNode()) {
+    if (this.selection.isRoot() || this.selection.isDocumentTypeNode() ||
+        this.selection.isPseudoElementNode()) {
       deleteNode.setAttribute("disabled", "true");
     } else {
       deleteNode.removeAttribute("disabled");
     }
 
     // Disable / enable "Copy Unique Selector", "Copy inner HTML" &
     // "Copy outer HTML" as appropriate
     let unique = this.panelDoc.getElementById("node-menu-copyuniqueselector");
diff --git a/browser/devtools/markupview/markup-view.css b/browser/devtools/markupview/markup-view.css
--- a/browser/devtools/markupview/markup-view.css
+++ b/browser/devtools/markupview/markup-view.css
@@ -83,16 +83,17 @@
 }
 
 .expander {
   display: inline-block;
   margin-left: -14px;
   vertical-align: middle;
 }
 
+.child.collapsed .children,
 .child.collapsed .child {
   display: none;
 }
 
 .child > .tag-line:first-child .close {
   display: none;
 }
 
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -272,17 +272,17 @@ MarkupView.prototype = {
     while (parent !== this.doc.body) {
       if (parent.container) {
         container = parent.container;
         break;
       }
       parent = parent.parentNode;
     }
 
-    if (container) {
+    if (container && container._isImagePreviewTarget) {
       // With the newly found container, delegate the tooltip content creation
       // and decision to show or not the tooltip
       return container._isImagePreviewTarget(target, this.tooltip);
     }
   },
 
   /**
    * Given the known reason, should the current selection be briefly highlighted
@@ -525,17 +525,17 @@ MarkupView.prototype = {
     if (!aIgnoreFocus) {
       aContainer.focus();
     }
   },
 
   /**
    * Make sure a node is included in the markup tool.
    *
-   * @param DOMNode aNode
+   * @param NodeFront aNode
    *        The node in the content document.
    * @param boolean aFlashNode
    *        Whether the newly imported node should be flashed
    * @returns MarkupContainer The MarkupContainer object for this element.
    */
   importNode: function(aNode, aFlashNode) {
     if (!aNode) {
       return null;
@@ -576,16 +576,18 @@ MarkupView.prototype = {
       let type = mutation.type;
       let target = mutation.target;
 
       if (mutation.type === "documentUnload") {
         // Treat this as a childList change of the child (maybe the protocol
         // should do this).
         type = "childList";
         target = mutation.targetParent;
+        mutation.removed = [];
+        mutation.added = [];
         if (!target) {
           continue;
         }
       }
 
       let container = this.getContainer(target);
       if (!container) {
         // Container might not exist if this came from a load event for a node
@@ -914,17 +916,17 @@ MarkupView.prototype = {
   _ensureVisible: function(node) {
     while (node) {
       let container = this.getContainer(node);
       let parent = node.parentNode();
       if (!container.elt.parentNode) {
         let parentContainer = this.getContainer(parent);
         if (parentContainer) {
           parentContainer.childrenDirty = true;
-          this._updateChildren(parentContainer, {expand: node});
+          this._updateChildren(parentContainer, {expand: true});
         }
       }
 
       node = parent;
     }
     return this._waitForChildren();
   },
 
@@ -1266,33 +1268,35 @@ MarkupView.prototype = {
 /**
  * The main structure for storing a document node in the markup
  * tree.  Manages creation of the editor for the node and
  * a <ul> for placing child elements, and expansion/collapsing
  * of the element.
  *
  * @param MarkupView aMarkupView
  *        The markup view that owns this container.
- * @param DOMNode aNode
+ * @param NodeFront aNode
  *        The node to display.
  * @param Inspector aInspector
  *        The inspector tool container the markup-view
  */
 function MarkupContainer(aMarkupView, aNode, aInspector) {
   this.markup = aMarkupView;
   this.doc = this.markup.doc;
   this.undo = this.markup.undo;
   this.node = aNode;
   this._inspector = aInspector;
 
   if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
     this.editor = new TextEditor(this, aNode, "text");
   } else if (aNode.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
     this.editor = new TextEditor(this, aNode, "comment");
-  } else if (aNode.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
+  } else if (aNode.isPseudoElement) {
+    this.editor = new PseudoElementEditor(this, aNode);
+  }  else if (aNode.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
     this.editor = new ElementEditor(this, aNode);
   } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
     this.editor = new DoctypeEditor(this, aNode);
   } else {
     this.editor = new GenericEditor(this, aNode);
   }
 
   // The template will fill the following properties
@@ -1300,16 +1304,20 @@ function MarkupContainer(aMarkupView, aN
   this.expander = null;
   this.tagState = null;
   this.tagLine = null;
   this.children = null;
   this.markup.template("container", this);
   this.elt.container = this;
   this.children.container = this;
 
+  if (aNode.isPseudoElement) {
+    this.expander.remove();
+  }
+
   // Expanding/collapsing the node on dblclick of the whole tag-line element
   this._onToggle = this._onToggle.bind(this);
   this.elt.addEventListener("dblclick", this._onToggle, false);
   this.expander.addEventListener("click", this._onToggle, false);
 
   // Appending the editor element and attaching event listeners
   this.tagLine.appendChild(this.editor.elt);
 
@@ -1324,17 +1332,17 @@ function MarkupContainer(aMarkupView, aN
 }
 
 MarkupContainer.prototype = {
   toString: function() {
     return "[MarkupContainer for " + this.node + "]";
   },
 
   isPreviewable: function() {
-    if (this.node.tagName) {
+    if (this.node.tagName && !this.node.isPseudoElement) {
       let tagName = this.node.tagName.toLowerCase();
       let srcAttr = this.editor.getAttributeElement("src");
       let isImage = tagName === "img" && srcAttr;
       let isCanvas = tagName === "canvas";
 
       return isImage || isCanvas;
     } else {
       return false;
@@ -1783,16 +1791,38 @@ TextEditor.prototype = {
       }).then(null, console.error);
     }
   },
 
   destroy: function() {}
 };
 
 /**
+ * Creates an editor for a pseudo element node.
+ * A pseudo element just needs to simply be displayed in the markup view,
+ * without any of the editing capabilities a normal element has.
+ *
+ * @param MarkupContainer aContainer The container owning this editor.
+ * @param Element aNode The node being edited.
+ */
+function PseudoElementEditor(aContainer, aNode) {
+  this.template = aContainer.markup.template.bind(aContainer.markup);
+  this.tag = null;
+  this.elt = null;
+  this.template("pseudoelement", this);
+  this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
+}
+
+PseudoElementEditor.prototype = {
+  destroy: function() {
+    this.elt.remove();
+  }
+};
+
+/**
  * Creates an editor for an Element node.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param Element aNode The node being edited.
  */
 function ElementEditor(aContainer, aNode) {
   this.doc = aContainer.doc;
   this.undo = aContainer.undo;
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -25,16 +25,18 @@
       <li id="template-container" save="${elt}" class="child collapsed">
         <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span><span save="${expander}" class="theme-twisty expander"></span></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
       <li id="template-more-nodes" class="more-nodes devtools-class-comment" save="${elt}"><span>${showing}</span> <button href="#" onclick="${allButtonClick}">${showAll}</button></li>
     </ul>
 
+    <span id="template-pseudoelement" save="${elt}" class="editor"><span save="${tag}" class="tag theme-fg-color5" tabindex="0"></span></span>
+
     <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span></span>
 
     <span id="template-attribute" save="${attr}" data-attr="${attrName}" class="attreditor" style="display:none"> <span class="editable" save="${inner}" tabindex="0"><span save="${name}" class="attr-name theme-fg-color2"></span>=&quot;<span save="${val}" class="attr-value theme-fg-color6"></span>&quot;</span></span>
 
     <span id="template-text" save="${elt}" class="editor text">
       <pre save="${value}" style="display:inline-block;" tabindex="0"></pre>
     </span>
 
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -148,17 +148,19 @@ ElementStyle.prototype = {
   dummyElement: null,
 
   init: function()
   {
     // To figure out how shorthand properties are interpreted by the
     // engine, we will set properties on a dummy element and observe
     // how their .style attribute reflects them as computed values.
     return this.dummyElementPromise = createDummyDocument().then(document => {
-      this.dummyElement = document.createElementNS(this.element.namespaceURI,
+      // ::before and ::after do not have a namespaceURI
+      let namespaceURI = this.element.namespaceURI || document.documentElement.namespaceURI;
+      this.dummyElement = document.createElementNS(namespaceURI,
                                                    this.element.tagName);
       document.documentElement.appendChild(this.dummyElement);
       return this.dummyElement;
     }).then(null, promiseWarn);
   },
 
   destroy: function() {
     this.dummyElement = null;
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -78,17 +78,18 @@ skip-if = os == "win" && debug # bug 963
 [browser_ruleview_multiple-properties-duplicates.js]
 [browser_ruleview_multiple-properties-priority.js]
 [browser_ruleview_multiple-properties-unfinished_01.js]
 [browser_ruleview_multiple-properties-unfinished_02.js]
 [browser_ruleview_multiple_properties_01.js]
 [browser_ruleview_multiple_properties_02.js]
 [browser_ruleview_original-source-link.js]
 [browser_ruleview_override.js]
-[browser_ruleview_pseudo-element.js]
+[browser_ruleview_pseudo-element_01.js]
+[browser_ruleview_pseudo-element_02.js]
 [browser_ruleview_refresh-on-attribute-change_01.js]
 [browser_ruleview_refresh-on-attribute-change_02.js]
 [browser_ruleview_refresh-on-style-change.js]
 [browser_ruleview_select-and-copy-styles.js]
 [browser_ruleview_style-editor-link.js]
 [browser_ruleview_urls-clickable.js]
 [browser_ruleview_user-agent-styles.js]
 [browser_ruleview_user-agent-styles-uneditable.js]
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-selector_02.js
@@ -35,21 +35,25 @@ let test = asyncTest(function*() {
   yield selectNode(".testclass", inspector);
   yield testEditSelector(view, "div:nth-child(2)");
 
   info("Selecting the modified element");
   yield selectNode("#testid", inspector);
   yield checkModifiedElement(view, "div:nth-child(2)");
 
   info("Selecting the test element");
-  yield selectNode("#testid3", inspector);
+  let f = inspector.markup.walker.frontForRawNode(getNode("#testid3"));
+  let children = yield inspector.markup.walker.children(f);
+  yield selectNode(children.nodes[children.nodes.length-1], inspector);
   yield testEditSelector(view, ".testclass2:after");
 
   info("Selecting the modified element");
-  yield selectNode(".testclass2", inspector);
+  let f = inspector.markup.walker.frontForRawNode(getNode(".testclass2"));
+  let children = yield inspector.markup.walker.children(f);
+  yield selectNode(children.nodes[children.nodes.length-1], inspector);
   yield checkModifiedElement(view, ".testclass2:after");
 });
 
 function* testEditSelector(view, name) {
   info("Test editing existing selector fields");
 
   let idRuleEditor = getRuleViewRuleEditor(view, 1);
 
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
rename from browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js
rename to browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
@@ -22,20 +22,18 @@ let test = asyncTest(function*() {
 
 function* testTopLeft(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#topleft", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 2,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 
   let gutters = assertGutters(view);
 
   // Make sure that clicking on the twisty hides pseudo elements
   let expander = gutters[0].querySelector(".ruleview-expander");
   ok (view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are expanded");
@@ -44,142 +42,122 @@ function* testTopLeft(inspector, view) {
   expander.click();
   ok (view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are expanded again");
 
   // Make sure that dblclicking on the header container also toggles the pseudo elements
   EventUtils.synthesizeMouseAtCenter(gutters[0], {clickCount: 2}, inspector.sidebar.getWindowForTab("ruleview"));
   ok (!view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are collapsed by dblclicking");
 
   let defaultView = element.ownerDocument.defaultView;
+
   let elementRule = rules.elementRules[0];
   let elementRuleView = [].filter.call(view.element.children, e => {
     return e._ruleEditor && e._ruleEditor.rule === elementRule;
   })[0]._ruleEditor;
 
-  let elementAfterRule = rules.afterRules[0];
-  let elementAfterRuleView = [].filter.call(view.element.children, (e) => {
-    return e._ruleEditor && e._ruleEditor.rule === elementAfterRule;
+  let elementFirstLineRule = rules.firstLineRules[0];
+  let elementFirstLineRuleView = [].filter.call(view.element.children, (e) => {
+    return e._ruleEditor && e._ruleEditor.rule === elementFirstLineRule;
   })[0]._ruleEditor;
 
   is
   (
-    convertTextPropsToString(elementAfterRule.textProps),
-    "background: none repeat scroll 0% 0% red; content: \" \"; position: absolute; " +
-    "border-radius: 50%; height: 32px; width: 32px; top: 50%; left: 50%; margin-top: -16px; margin-left: -16px",
-    "TopLeft after properties are correct"
+    convertTextPropsToString(elementFirstLineRule.textProps),
+    "color: orange",
+    "TopLeft firstLine properties are correct"
   );
 
-  let elementBeforeRule = rules.beforeRules[0];
-  let elementBeforeRuleView = [].filter.call(view.element.children, (e) => {
-    return e._ruleEditor && e._ruleEditor.rule === elementBeforeRule;
-  })[0]._ruleEditor;
+  let firstProp = elementFirstLineRuleView.addProperty("background-color", "rgb(0, 255, 0)", "");
+  let secondProp = elementFirstLineRuleView.addProperty("font-style", "italic", "");
 
-  is
-  (
-    convertTextPropsToString(elementBeforeRule.textProps),
-    "top: 0px; left: 0px",
-    "TopLeft before properties are correct"
-  );
-
-  let firstProp = elementAfterRuleView.addProperty("background-color", "rgb(0, 255, 0)", "");
-  let secondProp = elementAfterRuleView.addProperty("padding", "100px", "");
-
-  is (firstProp, elementAfterRule.textProps[elementAfterRule.textProps.length - 2],
+  is (firstProp, elementFirstLineRule.textProps[elementFirstLineRule.textProps.length - 2],
       "First added property is on back of array");
-  is (secondProp, elementAfterRule.textProps[elementAfterRule.textProps.length - 1],
+  is (secondProp, elementFirstLineRule.textProps[elementFirstLineRule.textProps.length - 1],
       "Second added property is on back of array");
 
-  yield elementAfterRule._applyingModifications;
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("background-color"),
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
     "rgb(0, 255, 0)", "Added property should have been used.");
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"),
-    "100px", "Added property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"),
-    "32px", "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("font-style"),
+    "italic", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("text-decoration"),
+    "none", "Added property should not apply to element");
 
-  secondProp.setEnabled(false);
-  yield elementAfterRule._applyingModifications;
+  firstProp.setEnabled(false);
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"), "0px",
-    "Disabled property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"), "32px",
-    "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(255, 0, 0)", "Disabled property should now have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"),
+    "rgb(221, 221, 221)", "Added property should not apply to element");
 
-  secondProp.setEnabled(true);
-  yield elementAfterRule._applyingModifications;
+  firstProp.setEnabled(true);
+  yield elementFirstLineRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("padding-top"), "100px",
-    "Enabled property should have been used.");
-  is(defaultView.getComputedStyle(element).getPropertyValue("padding-top"), "32px",
-    "Added property should not apply to element");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(0, 255, 0)", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element).getPropertyValue("text-decoration"),
+    "none", "Added property should not apply to element");
 
   let firstProp = elementRuleView.addProperty("background-color", "rgb(0, 0, 255)", "");
   yield elementRule._applyingModifications;
 
-  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"), "rgb(0, 0, 255)",
-    "Added property should have been used.");
-  is(defaultView.getComputedStyle(element, ":after").getPropertyValue("background-color"), "rgb(0, 255, 0)",
-    "Added prop does not apply to pseudo");
+  is(defaultView.getComputedStyle(element).getPropertyValue("background-color"),
+    "rgb(0, 0, 255)", "Added property should have been used.");
+  is(defaultView.getComputedStyle(element, ":first-line").getPropertyValue("background-color"),
+    "rgb(0, 255, 0)", "Added prop does not apply to pseudo");
 }
 
 function* testTopRight(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#topright", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 
   let gutters = assertGutters(view);
 
   let expander = gutters[0].querySelector(".ruleview-expander");
   ok (!view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements remain collapsed after switching element");
   expander.scrollIntoView();
   expander.click();
   ok (view.element.classList.contains("show-pseudo-elements"), "Pseudo Elements are shown again after clicking twisty");
 }
 
 function* testBottomRight(inspector, view) {
   yield assertPseudoElementRulesNumbers("#bottomright", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 3,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 }
 
 function* testBottomLeft(inspector, view) {
   yield assertPseudoElementRulesNumbers("#bottomleft", inspector, view, {
     elementRulesNb: 4,
-    afterRulesNb: 1,
-    beforeRulesNb: 2,
-    firstLineRulesNb: 0,
-    firstLetterRulesNb: 0,
+    firstLineRulesNb: 1,
+    firstLetterRulesNb: 1,
     selectionRulesNb: 0
   });
 }
 
 function* testParagraph(inspector, view) {
   let {
     rules,
     element,
     elementStyle
   } = yield assertPseudoElementRulesNumbers("#bottomleft p", inspector, view, {
     elementRulesNb: 3,
-    afterRulesNb: 0,
-    beforeRulesNb: 0,
     firstLineRulesNb: 1,
     firstLetterRulesNb: 1,
     selectionRulesNb: 1
   });
 
   let gutters = assertGutters(view);
 
   let elementFirstLineRule = rules.firstLineRules[0];
@@ -237,39 +215,34 @@ function* testNode(selector, inspector, 
   return {element: element, elementStyle: elementStyle};
 }
 
 function* assertPseudoElementRulesNumbers(selector, inspector, view, ruleNbs) {
   let {element, elementStyle} = yield testNode(selector, inspector, view);
 
   let rules = {
     elementRules: elementStyle.rules.filter(rule => !rule.pseudoElement),
-    afterRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":after"),
-    beforeRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":before"),
     firstLineRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":first-line"),
     firstLetterRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":first-letter"),
     selectionRules: elementStyle.rules.filter(rule => rule.pseudoElement === ":-moz-selection")
   };
 
   is(rules.elementRules.length, ruleNbs.elementRulesNb, selector +
     " has the correct number of non pseudo element rules");
-  is(rules.afterRules.length, ruleNbs.afterRulesNb, selector +
-    " has the correct number of :after rules");
-  is(rules.beforeRules.length, ruleNbs.beforeRulesNb, selector +
-    " has the correct number of :before rules");
   is(rules.firstLineRules.length, ruleNbs.firstLineRulesNb, selector +
     " has the correct number of :first-line rules");
   is(rules.firstLetterRules.length, ruleNbs.firstLetterRulesNb, selector +
     " has the correct number of :first-letter rules");
   is(rules.selectionRules.length, ruleNbs.selectionRulesNb, selector +
     " has the correct number of :selection rules");
 
   return {rules: rules, element: element, elementStyle: elementStyle};
 }
 
 function assertGutters(view) {
   let gutters = view.element.querySelectorAll(".theme-gutter");
   is (gutters.length, 3, "There are 3 gutter headings");
   is (gutters[0].textContent, "Pseudo-elements", "Gutter heading is correct");
   is (gutters[1].textContent, "This Element", "Gutter heading is correct");
   is (gutters[2].textContent, "Inherited from body", "Gutter heading is correct");
+
   return gutters;
-}
+}
\ No newline at end of file
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_02.js
@@ -0,0 +1,32 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that pseudoelements are displayed correctly in the rule view
+
+const TEST_URI = TEST_URL_ROOT + "doc_pseudoelement.html";
+
+let test = asyncTest(function*() {
+  yield addTab(TEST_URI);
+  let {toolbox, inspector, view} = yield openRuleView();
+
+  yield testTopLeft(inspector, view);
+});
+
+function* testTopLeft(inspector, view) {
+  let node = inspector.markup.walker.frontForRawNode(getNode("#topleft"));
+  let children = yield inspector.markup.walker.children(node);
+
+  is (children.nodes.length, 3, "Element has correct number of children");
+
+  let beforeElement = children.nodes[0];
+  is (beforeElement.tagName, "_moz_generated_content_before", "tag name is correct");
+  yield selectNode(beforeElement, inspector);
+
+  let afterElement = children.nodes[children.nodes.length-1];
+  is (afterElement.tagName, "_moz_generated_content_after", "tag name is correct");
+  yield selectNode(afterElement, inspector);
+}
+
diff --git a/browser/devtools/styleinspector/test/doc_pseudoelement.html b/browser/devtools/styleinspector/test/doc_pseudoelement.html
--- a/browser/devtools/styleinspector/test/doc_pseudoelement.html
+++ b/browser/devtools/styleinspector/test/doc_pseudoelement.html
@@ -13,16 +13,25 @@ body {
     width: 128px;
     height: 128px;
     background: #ddd;
     padding: 32px;
     margin: 32px;
     position:relative;
 }
 
+.box:first-line {
+    color: orange;
+    background: red;
+}
+
+.box:first-letter {
+    color: green;
+}
+
 * {
     cursor: default;
 }
 
 nothing {
     cursor: pointer;
 }
 
@@ -64,16 +73,23 @@ p:first-letter {
     margin-left: -16px;
 }
 
 .topleft:before {
     top:0;
     left:0;
 }
 
+.topleft:first-line {
+    color: orange;
+}
+.topleft::selection {
+    color: orange;
+}
+
 .topright:before {
     top:0;
     right:0;
 }
 
 .bottomright:before {
     bottom:10px;
     right:10px;
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -159,17 +159,21 @@ function selectAndHighlightNode(nodeOrSe
  * @return a promise that resolves when the inspector is updated with the new
  * node
  */
 function selectNode(nodeOrSelector, inspector, reason="test") {
   info("Selecting the node " + nodeOrSelector);
 
   let node = getNode(nodeOrSelector);
   let updated = inspector.once("inspector-updated");
-  inspector.selection.setNode(node, reason);
+  if (node._form) {
+    inspector.selection.setNodeFront(node, reason);
+  } else {
+    inspector.selection.setNode(node, reason);
+  }
   return updated;
 }
 
 /**
  * Set the inspector's current selection to null so that no node is selected
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return a promise that resolves when the inspector is updated
diff --git a/browser/themes/shared/devtools/markup-view.css b/browser/themes/shared/devtools/markup-view.css
--- a/browser/themes/shared/devtools/markup-view.css
+++ b/browser/themes/shared/devtools/markup-view.css
@@ -10,17 +10,16 @@
 .more-nodes {
   padding-left: 16px;
 }
 
 .styleinspector-propertyeditor {
   border: 1px solid #CCC;
 }
 
-
 /* Selected nodes in the tree should have light selected text.
    theme-selected doesn't work in this case since the text is a
    sibling of the class, not a child. */
 .theme-selected ~ .editor,
 .theme-selected ~ .editor .theme-fg-color1,
 .theme-selected ~ .editor .theme-fg-color2,
 .theme-selected ~ .editor .theme-fg-color3,
 .theme-selected ~ .editor .theme-fg-color4,
diff --git a/toolkit/devtools/Console.jsm b/toolkit/devtools/Console.jsm
--- a/toolkit/devtools/Console.jsm
+++ b/toolkit/devtools/Console.jsm
@@ -158,17 +158,17 @@ function stringify(aThing, aAllowNewLine
  * @param {nsIDOMElement} aElement
  *        The element to debug
  * @return {string}
  *        A simple single line representation of aElement
  */
 function debugElement(aElement) {
   return "<" + aElement.tagName +
       (aElement.id ? "#" + aElement.id : "") +
-      (aElement.className ?
+      (aElement.className && aElement.className.split ?
           "." + aElement.className.split(" ").join(" .") :
           "") +
       ">";
 }
 
 /**
  * A multi line stringification of an object, designed for use by humans
  *
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -331,16 +331,35 @@ LayoutHelpers.prototype = {
     let docShell = win.QueryInterface(Ci.nsIInterfaceRequestor)
                    .getInterface(Ci.nsIWebNavigation)
                    .QueryInterface(Ci.nsIDocShell);
 
     return docShell === this._topDocShell;
   },
 
   /**
+   * Traverse getBindingParent until arriving upon the bound element
+   * responsible for the generation of the specified node.
+   *
+   * @param {DOMNode} node
+   * @return {DOMNode}
+   *         If node is not anonymous, this will return node. Otherwise,
+   *         it will return the bound element
+   *
+   */
+  getRootBindingParent: function(node) {
+    let parent;
+    let doc = node.ownerDocument;
+    while ((parent = doc.getBindingParent(node))) {
+      node = parent;
+    }
+    return node;
+  },
+
+  /**
    * Check a window is part of the top level window.
    *
    * @param {DOMWindow} win
    * @return {Boolean}
    */
   isIncludedInTopLevelWindow: function LH_isIncludedInTopLevelWindow(win) {
     if (this.isTopLevelWindow(win)) {
       return true;
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -771,19 +771,21 @@ BoxModelHighlighter.prototype = Heritage
    * @return {boolean}
    *         True if the current node has a box model to be highlighted
    */
   _updateBoxModel: function() {
     this.options.region = this.options.region || "content";
 
     if (this._nodeNeedsHighlighting()) {
       for (let boxType in this._boxModelNodes) {
-        let {p1, p2, p3, p4} =
-          this.layoutHelpers.getAdjustedQuads(this.currentNode, boxType);
-
+        let quads = this.layoutHelpers.getAdjustedQuads(this.currentNode, boxType);
+        if (!quads) {
+          continue;
+        }
+        let {p1, p2, p3, p4} = quads;
         let boxNode = this._boxModelNodes[boxType];
 
         if (this.regionFill[boxType]) {
           boxNode.setAttribute("style", "fill:" + this.regionFill[boxType]);
         } else {
           boxNode.removeAttribute("style");
         }
 
@@ -951,28 +953,32 @@ BoxModelHighlighter.prototype = Heritage
       return;
     }
 
     let node = this.currentNode;
     let info = this.nodeInfo;
 
     // Update the tag, id, classes, pseudo-classes and dimensions only if they
     // changed to avoid triggering paint events
-
     let tagName = node.tagName;
+    if (tagName === "_moz_generated_content_before") {
+      tagName = "::before";
+    } else if (tagName === "_moz_generated_content_after") {
+      tagName = "::after";
+    }
     if (info.tagNameLabel.textContent !== tagName) {
       info.tagNameLabel.textContent = tagName;
     }
 
     let id = node.id ? "#" + node.id : "";
     if (info.idLabel.textContent !== id) {
       info.idLabel.textContent = id;
     }
 
-    let classList = node.classList.length ? "." + [...node.classList].join(".") : "";
+    let classList = (node.classList || []).length ? "." + [...node.classList].join(".") : "";
     if (info.classesBox.textContent !== classList) {
       info.classesBox.textContent = classList;
     }
 
     let pseudos = PSEUDO_CLASSES.filter(pseudo => {
       return DOMUtils.hasPseudoClassLock(node, pseudo);
     }, this).join("");
     if (info.pseudoClassesBox.textContent !== pseudos) {
@@ -1300,19 +1306,26 @@ function isNodeValid(node) {
     return false;
   }
 
   // Is it an element node
   if (node.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
     return false;
   }
 
-  // Is it connected to the document?
+  // Is the document inaccessible?
   let doc = node.ownerDocument;
-  if (!doc || !doc.defaultView || !doc.documentElement.contains(node)) {
+  if (!doc || !doc.defaultView) {
+    return false;
+  }
+
+  // Is the node connected to the document? Using getBindingParent adds
+  // support for anonymous elements generated by a node in the document.
+  let bindingParent = new LayoutHelpers(doc.defaultView).getRootBindingParent(node);
+  if (!doc.documentElement.contains(bindingParent)) {
     return false;
   }
 
   return true;
 }
 
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -207,40 +207,33 @@ var NodeActor = exports.NodeActor = prot
   // Returns the JSON representation of this object over the wire.
   form: function(detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
 
-    // Estimate the number of children.
-    let numChildren = this.rawNode.childNodes.length;
-    if (numChildren === 0 &&
-        (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
-      // This might be an iframe with virtual children.
-      numChildren = 1;
-    }
-
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
-      numChildren: numChildren,
+      numChildren: this.numChildren,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
-
+      isBeforePseudoElement: this.rawNode.nodeName === "_moz_generated_content_before",
+      isAfterPseudoElement: this.rawNode.nodeName === "_moz_generated_content_after",
       pseudoClassLocks: this.writePseudoClassLocks(),
 
       isDisplayed: this.isDisplayed,
     };
 
     if (this.isDocumentElement()) {
       form.isDocumentElement = true;
     }
@@ -254,16 +247,36 @@ var NodeActor = exports.NodeActor = prot
       } else {
         form.shortValue = this.rawNode.nodeValue;
       }
     }
 
     return form;
   },
 
+  // Return the number of children that the walker will return with a
+  // children() call without actually making the call.
+  get numChildren() {
+    let numChildren = this.rawNode.childNodes.length;
+    if (numChildren === 0 &&
+        (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
+      // This might be an iframe with virtual children.
+      numChildren = 1;
+    }
+
+    // Count any anonymous children
+    if (this.rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+      let anonChildren = this.rawNode.ownerDocument.getAnonymousNodes(this.rawNode);
+      if (anonChildren) {
+        numChildren += anonChildren.length;
+      }
+    }
+    return numChildren;
+  },
+
   get computedStyle() {
     if (Cu.isDeadWrapper(this.rawNode) ||
         this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE ||
         !this.rawNode.ownerDocument ||
         !this.rawNode.ownerDocument.defaultView) {
       return null;
     }
     return this.rawNode.ownerDocument.defaultView.getComputedStyle(this.rawNode);
@@ -546,16 +559,20 @@ let NodeFront = protocol.FrontClass(Node
 
   get className() {
     return this.getAttribute("class") || '';
   },
 
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
 
+  get isBeforePseudoElement() this._form.isBeforePseudoElement,
+  get isAfterPseudoElement() this._form.isAfterPseudoElement,
+  get isPseudoElement() this.isBeforePseudoElement || this.isAfterPseudoElement,
+
   get tagName() this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE ? this.nodeName : null,
   get shortValue() this._form.shortValue,
   get incompleteValue() !!this._form.incompleteValue,
 
   get isDocumentElement() !!this._form.isDocumentElement,
 
   // doctype properties
   get name() this._form.name,
@@ -1256,16 +1273,17 @@ var WalkerActor = protocol.ActorClass({
     // We're going to create a few document walkers with the same filter,
     // make it easier.
     let filteredWalker = (node) => {
       return documentWalker(node, this.rootWin, options.whatToShow);
     };
 
     // Need to know the first and last child.
     let rawNode = node.rawNode;
+
     let firstChild = filteredWalker(rawNode).firstChild();
     let lastChild = filteredWalker(rawNode).lastChild();
 
     if (!firstChild) {
       // No children, we're done.
       return { hasFirst: true, hasLast: true, nodes: [] };
     }
 
@@ -1967,16 +1985,17 @@ var WalkerActor = protocol.ActorClass({
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
       let mutation = {
         type: change.type,
         target: targetActor.actorID,
+        numChildren: targetActor.numChildren
       }
 
       if (mutation.type === "attributes") {
         mutation.attributeName = change.attributeName;
         mutation.attributeNamespace = change.attributeNamespace || undefined;
         mutation.newValue = targetNode.getAttribute(mutation.attributeName);
       } else if (mutation.type === "characterData") {
         if (targetNode.nodeValue.length > gValueSummaryLength) {
@@ -2010,17 +2029,17 @@ var WalkerActor = protocol.ActorClass({
             continue;
           }
           // The actor is reconnected to the ownership tree, unorphan
           // it and let the client know so that its ownership tree is up
           // to date.
           this._orphaned.delete(addedActor);
           addedActors.push(addedActor.actorID);
         }
-        mutation.numChildren = change.target.childNodes.length;
+
         mutation.removed = removedActors;
         mutation.added = addedActors;
       }
       this.queueMutation(mutation);
     }
   },
 
   onFrameLoad: function({ window, isTopLevel }) {
@@ -2043,17 +2062,18 @@ var WalkerActor = protocol.ActorClass({
       target: frameActor.actorID,
     });
 
     // Send a childList mutation on the frame.
     this.queueMutation({
       type: "childList",
       target: frameActor.actorID,
       added: [],
-      removed: []
+      removed: [],
+      numChildren: 1
     })
   },
 
   // Returns true if domNode is in window or a subframe.
   _childOfWindow: function(window, domNode) {
     let win = nodeDocument(domNode).defaultView;
     while (win) {
       if (win === window) {
@@ -2107,17 +2127,18 @@ var WalkerActor = protocol.ActorClass({
     let parentNode = walker.parentNode();
     if (parentNode) {
       // Send a childList mutation on the frame so that clients know
       // they should reread the children list.
       this.queueMutation({
         type: "childList",
         target: this._refMap.get(parentNode).actorID,
         added: [],
-        removed: []
+        removed: [],
+        numChildren: 1
       });
     }
 
     // Need to force a release of this node, because those nodes can't
     // be accessed anymore.
     this.releaseNode(documentActor, { force: true });
   },
 
@@ -2768,104 +2789,84 @@ function documentWalker(node, rootWin, w
 // Exported for test purposes.
 exports._documentWalker = documentWalker;
 
 function nodeDocument(node) {
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
- * Similar to a TreeWalker, except will dig in to iframes and it doesn't
- * implement the good methods like previousNode and nextNode.
- *
- * See TreeWalker documentation for explanations of the methods.
+ * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
+ * See inDeepTreeWalker for more information about the methods.
  */
 function DocumentWalker(aNode, aRootWin, aShow, aFilter, aExpandEntityReferences) {
   if (!aRootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
-  let doc = nodeDocument(aNode);
-  this.layoutHelpers = new LayoutHelpers(aRootWin);
-  this.walker = doc.createTreeWalker(doc,
-    aShow, aFilter, aExpandEntityReferences);
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.init(aRootWin.document, aShow);
   this.walker.currentNode = aNode;
   this.filter = aFilter;
 }
 
 DocumentWalker.prototype = {
   get node() this.walker.node,
   get whatToShow() this.walker.whatToShow,
   get expandEntityReferences() this.walker.expandEntityReferences,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
 
-  /**
-   * Called when the new node is in a different document than
-   * the current node, creates a new treewalker for the document we've
-   * run in to.
-   */
-  _reparentWalker: function(aNewNode) {
-    if (!aNewNode) {
-      return null;
-    }
-    let doc = nodeDocument(aNewNode);
-    let walker = doc.createTreeWalker(doc,
-      this.whatToShow, this.filter, this.expandEntityReferences);
-    walker.currentNode = aNewNode;
-    this.walker = walker;
-    return aNewNode;
-  },
-
   parentNode: function() {
-    let currentNode = this.walker.currentNode;
-    let parentNode = this.walker.parentNode();
-
-    if (!parentNode) {
-      if (currentNode && currentNode.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE
-          && currentNode.defaultView) {
-
-        let window = currentNode.defaultView;
-        let frame = this.layoutHelpers.getFrameElement(window);
-        if (frame) {
-          return this._reparentWalker(frame);
-        }
-      }
-      return null;
-    }
-
-    return parentNode;
+    return this.walker.parentNode();
   },
 
   firstChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument) {
-      return this._reparentWalker(node.getSVGDocument());
+
+    let firstChild = this.walker.firstChild();
+    while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      firstChild = this.walker.nextSibling();
     }
-    return this.walker.firstChild();
+
+    return firstChild;
   },
 
   lastChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument) {
-      return this._reparentWalker(node.getSVGDocument());
+
+    let lastChild = this.walker.lastChild();
+    while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      lastChild = this.walker.previousSibling();
     }
-    return this.walker.lastChild();
+
+    return lastChild;
   },
 
-  previousSibling: function DW_previousSibling() this.walker.previousSibling(),
-  nextSibling: function DW_nextSibling() this.walker.nextSibling()
+  previousSibling: function() {
+    let node = this.walker.previousSibling();
+    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      node = this.walker.previousSibling();
+    }
+    return node;
+  },
+
+  nextSibling: function() {
+    let node = this.walker.nextSibling();
+    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      node = this.walker.nextSibling();
+    }
+    return node;
+  }
 };
 
 /**
  * A tree walker filter for avoiding empty whitespace text nodes.
  */
 function whitespaceTextFilter(aNode) {
     if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
         !/[^\s]/.exec(aNode.nodeValue)) {
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -18,17 +18,17 @@ loader.lazyGetter(this, "CssLogic", () =
 loader.lazyGetter(this, "DOMUtils", () => Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils));
 
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
-const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
+const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":-moz-selection"];
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
 
 // Predeclare the domnode actor type for use in requests.
 types.addActorType("domnode");
 
 // Predeclare the domstylerule actor type
 types.addActorType("domstylerule");
 
@@ -297,17 +297,17 @@ var PageStyleActor = protocol.ActorClass
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSeletors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
   getApplied: method(function(node, options) {
     let entries = [];
-    this.addElementRules(node.rawNode, undefined, options, entries);
+    this.addElementRules(node, undefined, options, entries);
     return this.getAppliedProps(node, entries, options);
   }, {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
@@ -317,39 +317,58 @@ var PageStyleActor = protocol.ActorClass
   _hasInheritedProps: function(style) {
     return Array.prototype.some.call(style, prop => {
       return DOMUtils.isInheritedProperty(prop);
     });
   },
 
   /**
    * Helper function for getApplied, adds all the rules from a given
-   * element.
+   * element. See getApplied for documentation on parameters.
+   * @param NodeActor node
+   * @param bool inherited
+   * @param object options
+   * @param Array rules (modifies this instead of returning)
    */
-  addElementRules: function(element, inherited, options, rules)
+  addElementRules: function(node, inherited, options, rules)
   {
-    if (!element.style) {
+    let element = node.rawNode;
+    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
+    let form = node.form();
+    let isBeforeOrAfter = form.isBeforePseudoElement ||
+                          form.isAfterPseudoElement;
+
+    // If it is before or after, then we don't want to get styles for
+    // this element.  Want to get it for the parent with the corresponding
+    // pseudo.  Then we want to lie to the view and tell it that it isn't a pseudo
+    // style so that it shows up normally.
+    if (isBeforeOrAfter) {
+      element = element.parentNode;
+      pseudoElements = [form.isBeforePseudoElement ? ":before" : ":after"];
+    }
+
+    if (!element || !element.style) {
       return;
     }
 
     let elementStyle = this._styleRef(element);
+    let showInlineStyles = !inherited && !isBeforeOrAfter;
+    let showInheritedStyles = inherited && this._hasInheritedProps(element.style);
 
-    if (!inherited || this._hasInheritedProps(element.style)) {
+    if (showInlineStyles || showInheritedStyles) {
       rules.push({
         rule: elementStyle,
         inherited: inherited,
       });
     }
 
-    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
     for (let pseudo of pseudoElements) {
 
       // Get the styles that apply to the element.
       let domRules = DOMUtils.getCSSStyleRules(element, pseudo);
-
       if (!domRules) {
         continue;
       }
 
       // getCSSStyleRules returns ordered from least-specific to
       // most-specific.
       for (let i = domRules.Count() - 1; i >= 0; i--) {
         let domRule = domRules.GetElementAt(i);
@@ -370,17 +389,17 @@ var PageStyleActor = protocol.ActorClass
             continue;
           }
         }
 
         let ruleActor = this._styleRef(domRule);
         rules.push({
           rule: ruleActor,
           inherited: inherited,
-          pseudoElement: pseudo,
+          pseudoElement: isBeforeOrAfter ? null : pseudo,
           isSystem: isSystem
         });
       }
 
     }
   },
 
   /**
@@ -403,17 +422,17 @@ var PageStyleActor = protocol.ActorClass
    * @returns Object containing the list of rule entries, rule actors and
    *   stylesheet actors that applies to the given node and its associated
    *   rules.
    */
   getAppliedProps: function(node, entries, options) {
     if (options.inherited) {
       let parent = this.walker.parentNode(node);
       while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
-        this.addElementRules(parent.rawNode, parent, options, entries);
+        this.addElementRules(parent, parent, options, entries);
         parent = this.walker.parentNode(parent);
       }
     }
 
     if (options.matchedSelectors) {
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -171,17 +171,44 @@ CssLogic.prototype = {
     } else {
       // Clear cached data in the CssPropertyInfo objects.
       this._propertyInfos = {};
     }
 
     this._matchedRules = null;
     this._matchedSelectors = null;
     let win = this.viewedDocument.defaultView;
-    this._computedStyle = win.getComputedStyle(this.viewedElement, "");
+
+    // Handle computed styles on pseudo by reading style rules
+    // on the parent node with proper pseudo arg to getComputedStyle.
+    let {elementToRead, pseudoToRead} = this.getStyleAndPseudoElements(this.viewedElement);
+
+    this._computedStyle = win.getComputedStyle(elementToRead, pseudoToRead);
+  },
+
+  /**
+   * XXX
+   * @returns {Object}
+   *            - elementToRead
+   *            - pseudoToRead
+   */
+  getStyleAndPseudoElements: function(node) {
+    let elementToRead = node;
+    let pseudoToRead = null;
+    if (node.nodeName == "_moz_generated_content_before") {
+      elementToRead = node.parentNode;
+      pseudoToRead = ":before";
+    } else if (node.nodeName == "_moz_generated_content_after") {
+      elementToRead = node.parentNode;
+      pseudoToRead = ":after";
+    }
+    return {
+      elementToRead: elementToRead,
+      pseudoToRead: pseudoToRead
+    };
   },
 
   /**
    * Get the source filter.
    * @returns {string} The source filter being used.
    */
   get sourceFilter() {
     return this._sourceFilter;
@@ -582,24 +609,29 @@ CssLogic.prototype = {
       return;
     }
 
     do {
       let status = this.viewedElement === element ?
                    CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
 
       try {
-        domRules = domUtils.getCSSStyleRules(element);
+        // Handle finding rules on pseudo by reading style rules
+        // on the parent node with proper pseudo arg to getCSSStyleRules.
+        let {elementToRead, pseudoToRead} = this.getStyleAndPseudoElements(element);
+        domRules = domUtils.getCSSStyleRules(elementToRead, pseudoToRead);
       } catch (ex) {
         Services.console.
           logStringMessage("CL__buildMatchedRules error: " + ex);
         continue;
       }
 
-      for (let i = 0, n = domRules.Count(); i < n; i++) {
+      // getCSSStyleRules can return null with a shadow DOM element.
+      let numDomRules = domRules ? domRules.Count() : 0;
+      for (let i = 0; i < numDomRules; i++) {
         let domRule = domRules.GetElementAt(i);
         if (domRule.type !== Ci.nsIDOMCSSRule.STYLE_RULE) {
           continue;
         }
 
         let sheet = this.getSheet(domRule.parentStyleSheet, -1);
         if (sheet._passId !== this._passId) {
           sheet.index = sheetIndex++;
@@ -615,17 +647,16 @@ CssLogic.prototype = {
           continue;
         }
 
         rule._matchId = this._matchId;
         rule._passId = this._passId;
         this._matchedRules.push([rule, status]);
       }
 
-
       // Add element.style information.
       if (element.style && element.style.length > 0) {
         let rule = new CssRule(null, { style: element.style }, element);
         rule._matchId = this._matchId;
         rule._passId = this._passId;
         this._matchedRules.push([rule, status]);
       }
     } while ((element = element.parentNode) &&
