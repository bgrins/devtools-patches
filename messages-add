# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2d20b365eee19434657f6b365d310e8b70904d2b
Bug 1371721 - Create a MESSAGES_ADD action to add batches of messages at once

diff --git a/devtools/client/webconsole/new-console-output/actions/messages.js b/devtools/client/webconsole/new-console-output/actions/messages.js
--- a/devtools/client/webconsole/new-console-output/actions/messages.js
+++ b/devtools/client/webconsole/new-console-output/actions/messages.js
@@ -8,26 +8,40 @@
 
 const {
   prepareMessage
 } = require("devtools/client/webconsole/new-console-output/utils/messages");
 const { IdGenerator } = require("devtools/client/webconsole/new-console-output/utils/id-generator");
 const { batchActions } = require("devtools/client/webconsole/new-console-output/actions/enhancers");
 const {
   MESSAGE_ADD,
+  MESSAGES_ADD,
   NETWORK_MESSAGE_UPDATE,
   MESSAGES_CLEAR,
   MESSAGE_OPEN,
   MESSAGE_CLOSE,
   MESSAGE_TYPE,
   MESSAGE_TABLE_RECEIVE,
 } = require("../constants");
 
 const defaultIdGenerator = new IdGenerator();
 
+function messagesAdd(packets, idGenerator = null) {
+  if (idGenerator == null) {
+    idGenerator = defaultIdGenerator;
+  }
+  let messages = packets.map(packet => prepareMessage(packet, idGenerator));
+  console.log("Got a group", packets.length);
+  // When this is used for non-cached messages, then handle clear message and split up into batches
+  return {
+    type: MESSAGES_ADD,
+    messages
+  };
+}
+
 function messageAdd(packet, idGenerator = null) {
   if (idGenerator == null) {
     idGenerator = defaultIdGenerator;
   }
   let message = prepareMessage(packet, idGenerator);
   const addMessageAction = {
     type: MESSAGE_ADD,
     message
@@ -101,15 +115,16 @@ function networkMessageUpdate(packet, id
   return {
     type: NETWORK_MESSAGE_UPDATE,
     message,
   };
 }
 
 module.exports = {
   messageAdd,
+  messagesAdd,
   messagesClear,
   messageOpen,
   messageClose,
   messageTableDataGet,
   networkMessageUpdate,
 };
 
diff --git a/devtools/client/webconsole/new-console-output/constants.js b/devtools/client/webconsole/new-console-output/constants.js
--- a/devtools/client/webconsole/new-console-output/constants.js
+++ b/devtools/client/webconsole/new-console-output/constants.js
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const actionTypes = {
   BATCH_ACTIONS: "BATCH_ACTIONS",
   MESSAGE_ADD: "MESSAGE_ADD",
+  MESSAGES_ADD: "MESSAGES_ADD",
   MESSAGES_CLEAR: "MESSAGES_CLEAR",
   MESSAGE_OPEN: "MESSAGE_OPEN",
   MESSAGE_CLOSE: "MESSAGE_CLOSE",
   NETWORK_MESSAGE_UPDATE: "NETWORK_MESSAGE_UPDATE",
   MESSAGE_TABLE_RECEIVE: "MESSAGE_TABLE_RECEIVE",
   REMOVED_MESSAGES_CLEAR: "REMOVED_MESSAGES_CLEAR",
   TIMESTAMPS_TOGGLE: "TIMESTAMPS_TOGGLE",
   FILTER_TOGGLE: "FILTER_TOGGLE",
diff --git a/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js b/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js
--- a/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js
+++ b/devtools/client/webconsole/new-console-output/new-console-output-wrapper.js
@@ -12,16 +12,17 @@ const actions = require("devtools/client
 const { createContextMenu } = require("devtools/client/webconsole/new-console-output/utils/context-menu");
 const { configureStore } = require("devtools/client/webconsole/new-console-output/store");
 
 const EventEmitter = require("devtools/shared/event-emitter");
 const ConsoleOutput = React.createFactory(require("devtools/client/webconsole/new-console-output/components/console-output"));
 const FilterBar = React.createFactory(require("devtools/client/webconsole/new-console-output/components/filter-bar"));
 
 let store = null;
+let queuedMessages = [];
 let queuedActions = [];
 let throttledDispatchTimeout = false;
 
 function NewConsoleOutputWrapper(parentNode, jsterm, toolbox, owner, document) {
   EventEmitter.decorate(this);
 
   this.parentNode = parentNode;
   this.jsterm = jsterm;
@@ -139,45 +140,47 @@ NewConsoleOutputWrapper.prototype = {
         filterBar,
         childComponent
     ));
 
     this.body = ReactDOM.render(provider, this.parentNode);
   },
 
   dispatchMessageAdd: function (message, waitForResponse) {
-    let action = actions.messageAdd(message);
-    batchedMessageAdd(action);
+    batchedMessagesAdd(message);
+    // let action = actions.messageAdd(message);
+    // batchedMessageAdd(action);
 
     // Wait for the message to render to resolve with the DOM node.
     // This is just for backwards compatibility with old tests, and should
     // be removed once it's not needed anymore.
     // Can only wait for response if the action contains a valid message.
-    if (waitForResponse && action.message) {
-      let messageId = action.message.get("id");
-      return new Promise(resolve => {
-        let jsterm = this.jsterm;
-        jsterm.hud.on("new-messages", function onThisMessage(e, messages) {
-          for (let m of messages) {
-            if (m.messageId === messageId) {
-              resolve(m.node);
-              jsterm.hud.off("new-messages", onThisMessage);
-              return;
-            }
-          }
-        });
-      });
-    }
+    // if (waitForResponse && action.message) {
+    //   let messageId = action.message.get("id");
+    //   return new Promise(resolve => {
+    //     let jsterm = this.jsterm;
+    //     jsterm.hud.on("new-messages", function onThisMessage(e, messages) {
+    //       for (let m of messages) {
+    //         if (m.messageId === messageId) {
+    //           resolve(m.node);
+    //           jsterm.hud.off("new-messages", onThisMessage);
+    //           return;
+    //         }
+    //       }
+    //     });
+    //   });
+    // }
 
     return Promise.resolve();
   },
 
   dispatchMessagesAdd: function (messages) {
-    const batchedActions = messages.map(message => actions.messageAdd(message));
-    store.dispatch(actions.batchActions(batchedActions));
+    store.dispatch(actions.messagesAdd(messages));
+    // const batchedActions = messages.map(message => actions.messageAdd(message));
+    // store.dispatch(actions.batchActions(batchedActions));
   },
 
   dispatchMessagesClear: function () {
     store.dispatch(actions.messagesClear());
   },
 
   dispatchTimestampsToggle: function (enabled) {
     store.dispatch(actions.timestampsToggle(enabled));
@@ -193,21 +196,32 @@ NewConsoleOutputWrapper.prototype = {
   },
 
   // Should be used for test purpose only.
   getStore: function () {
     return store;
   }
 };
 
-function batchedMessageAdd(action) {
-  queuedActions.push(action);
+function batchedMessagesAdd(message) {
+  queuedMessages.push(message);
   if (!throttledDispatchTimeout) {
     throttledDispatchTimeout = setTimeout(() => {
-      store.dispatch(actions.batchActions(queuedActions));
-      queuedActions = [];
+      store.dispatch(actions.messagesAdd(queuedMessages));
+      queuedMessages = [];
       throttledDispatchTimeout = null;
     }, 50);
   }
 }
 
+function batchedMessageAdd(action) {
+  // queuedActions.push(action);
+  // if (!throttledDispatchTimeout) {
+  //   throttledDispatchTimeout = setTimeout(() => {
+  //     store.dispatch(actions.batchActions(queuedActions));
+  //     queuedActions = [];
+  //     throttledDispatchTimeout = null;
+  //   }, 50);
+  // }
+}
+
 // Exports from this module
 module.exports = NewConsoleOutputWrapper;
diff --git a/devtools/client/webconsole/new-console-output/reducers/messages.js b/devtools/client/webconsole/new-console-output/reducers/messages.js
--- a/devtools/client/webconsole/new-console-output/reducers/messages.js
+++ b/devtools/client/webconsole/new-console-output/reducers/messages.js
@@ -37,94 +37,153 @@ const MessageState = Immutable.Record({
   removedMessages: [],
   // Map of the form {messageId : numberOfRepeat}
   repeatById: {},
   // Map of the form {messageId : networkInformation}
   // `networkInformation` holds request, response, totalTime, ...
   networkMessagesUpdateById: {},
 });
 
+function addMessage(state, filtersState, prefsState, newMessage) {
+  const {
+    messagesById,
+    messagesUiById,
+    messagesTableDataById,
+    networkMessagesUpdateById,
+    groupsById,
+    currentGroup,
+    repeatById,
+    visibleMessages,
+  } = state;
+  const {logLimit} = prefsState;
+  if (newMessage.type === constants.MESSAGE_TYPE.NULL_MESSAGE) {
+    // When the message has a NULL type, we don't add it.
+    return state;
+  }
+
+  if (newMessage.type === constants.MESSAGE_TYPE.END_GROUP) {
+    // Compute the new current group.
+    return state.set("currentGroup", getNewCurrentGroup(currentGroup, groupsById));
+  }
+
+  if (newMessage.allowRepeating && messagesById.size > 0) {
+    let lastMessage = messagesById.last();
+    if (
+      lastMessage.repeatId === newMessage.repeatId
+      && lastMessage.groupId === currentGroup
+    ) {
+      return state.set(
+        "repeatById",
+        Object.assign({}, repeatById, {
+          [lastMessage.id]: (repeatById[lastMessage.id] || 1) + 1
+        })
+      );
+    }
+  }
+
+  return state.withMutations(function (record) {
+    // Add the new message with a reference to the parent group.
+    let parentGroups = getParentGroups(currentGroup, groupsById);
+    const addedMessage = newMessage.withMutations(function (message) {
+      message.set("groupId", currentGroup);
+      message.set("indent", parentGroups.length);
+    });
+    record.set(
+      "messagesById",
+      messagesById.set(newMessage.id, addedMessage)
+    );
+
+    if (newMessage.type === "trace") {
+      // We want the stacktrace to be open by default.
+      record.set("messagesUiById", messagesUiById.push(newMessage.id));
+    } else if (isGroupType(newMessage.type)) {
+      record.set("currentGroup", newMessage.id);
+      record.set("groupsById", groupsById.set(newMessage.id, parentGroups));
+
+      if (newMessage.type === constants.MESSAGE_TYPE.START_GROUP) {
+        // We want the group to be open by default.
+        record.set("messagesUiById", messagesUiById.push(newMessage.id));
+      }
+    }
+
+    if (shouldMessageBeVisible(addedMessage, record, filtersState)) {
+      record.set("visibleMessages", [...visibleMessages, newMessage.id]);
+    }
+  });
+}
+
+var totalTimeInMessagesAdd = 0;
+
 function messages(state = new MessageState(), action, filtersState, prefsState) {
   const {
     messagesById,
     messagesUiById,
     messagesTableDataById,
     networkMessagesUpdateById,
     groupsById,
     currentGroup,
     repeatById,
     visibleMessages,
   } = state;
 
   const {logLimit} = prefsState;
 
   switch (action.type) {
-    case constants.MESSAGE_ADD:
-      let newMessage = action.message;
-
-      if (newMessage.type === constants.MESSAGE_TYPE.NULL_MESSAGE) {
-        // When the message has a NULL type, we don't add it.
-        return state;
-      }
-
-      if (newMessage.type === constants.MESSAGE_TYPE.END_GROUP) {
-        // Compute the new current group.
-        return state.set("currentGroup", getNewCurrentGroup(currentGroup, groupsById));
-      }
+    case constants.MESSAGES_ADD:
+      var newState = state;
 
-      if (newMessage.allowRepeating && messagesById.size > 0) {
-        let lastMessage = messagesById.last();
-        if (
-          lastMessage.repeatId === newMessage.repeatId
-          && lastMessage.groupId === currentGroup
-        ) {
-          return state.set(
-            "repeatById",
-            Object.assign({}, repeatById, {
-              [lastMessage.id]: (repeatById[lastMessage.id] || 1) + 1
-            })
-          );
+      // Preemptively remove messages that will never be rendered
+      let messages = [];
+      let prunableCount = 0;
+      for (var i = action.messages.length - 1; i >= 0; i--) {
+        if (!action.messages[i].groupId && !isGroupType(action.messages[i].type) &&
+            action.messages[i].type !== MESSAGE_TYPE.END_GROUP) {
+          prunableCount++;
+          // Once we've added the max number of messages that can be added stop.
+          // TODO: what about repeats?
+          if (prunableCount <= logLimit) {
+            messages.unshift(action.messages[i]);
+          }
+        } else {
+          messages.unshift(action.messages[i]);
         }
       }
 
-      return state.withMutations(function (record) {
-        // Add the new message with a reference to the parent group.
-        let parentGroups = getParentGroups(currentGroup, groupsById);
-        const addedMessage = newMessage.withMutations(function (message) {
-          message.set("groupId", currentGroup);
-          message.set("indent", parentGroups.length);
-        });
-        record.set(
-          "messagesById",
-          messagesById.set(newMessage.id, addedMessage)
-        );
+      messages.forEach(message => {
+        newState = addMessage(newState, filtersState, prefsState, message);
+      });
 
-        if (newMessage.type === "trace") {
-          // We want the stacktrace to be open by default.
-          record.set("messagesUiById", messagesUiById.push(newMessage.id));
-        } else if (isGroupType(newMessage.type)) {
-          record.set("currentGroup", newMessage.id);
-          record.set("groupsById", groupsById.set(newMessage.id, parentGroups));
-
-          if (newMessage.type === constants.MESSAGE_TYPE.START_GROUP) {
-            // We want the group to be open by default.
-            record.set("messagesUiById", messagesUiById.push(newMessage.id));
-          }
-        }
-
-        if (shouldMessageBeVisible(addedMessage, record, filtersState)) {
-          record.set("visibleMessages", [...visibleMessages, newMessage.id]);
-        }
-
+      console.log("Messages add", action, action.messages.length, messages.length);
+      console.time("Messages add");
+      newState = newState.withMutations(function (record) {
         // Remove top level message if the total count of top level messages
         // exceeds the current limit.
         if (record.messagesById.size > logLimit) {
           limitTopLevelMessageCount(state, record, logLimit);
         }
       });
+      console.timeEnd("Messages add");
+      return newState;
+
+    case constants.MESSAGE_ADD:
+      console.time("Message add");
+      var start = performance.now();
+      var newState = addMessage(state, filtersState, prefsState, action.message);
+
+      newState = newState.withMutations(function (record) {
+        // Remove top level message if the total count of top level messages
+        // exceeds the current limit.
+        if (record.messagesById.size > logLimit) {
+          limitTopLevelMessageCount(state, record, logLimit);
+        }
+      });
+      totalTimeInMessagesAdd += (performance.now() - start);
+      console.timeEnd("Message add");
+      console.log(totalTimeInMessagesAdd);
+      return newState;
 
     case constants.MESSAGES_CLEAR:
       return new MessageState({
         // Store all removed messages associated with some arguments.
         // This array is used by `releaseActorsEnhancer` to release
         // all related backend actors.
         "removedMessages": [...state.messagesById].reduce((res, [id, msg]) => {
           if (msg.parameters) {
