# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a0e47ebc4c06e652b919dabee711fdbd6bfd31b5
Bug 1472161 - WIP - Change tab behavior in console

diff --git a/devtools/client/locales/en-US/webconsole.properties b/devtools/client/locales/en-US/webconsole.properties
--- a/devtools/client/locales/en-US/webconsole.properties
+++ b/devtools/client/locales/en-US/webconsole.properties
@@ -57,20 +57,16 @@ noCounterLabel=<no label>
 # LOCALIZATION NOTE (counterDoesntExist): this string is displayed when
 # console.countReset() is called with a counter that doesn't exist.
 counterDoesntExist=Counter “%S” doesn’t exist.
 
 # LOCALIZATION NOTE (noGroupLabel): this string is used to display
 # console.group messages with no label provided.
 noGroupLabel=<no group label>
 
-# LOCALIZATION NOTE (Autocomplete.blank): this string is used when inputnode
-# string containing anchor doesn't matches to any property in the content.
-Autocomplete.blank=  <- no result
-
 maxTimersExceeded=The maximum allowed number of timers in this page was exceeded.
 timerAlreadyExists=Timer “%S” already exists.
 timerDoesntExist=Timer “%S” doesn’t exist.
 timerJSError=Failed to process the timer name.
 
 # LOCALIZATION NOTE (connectionTimeout): message displayed when the Remote Web
 # Console fails to connect to the server due to a timeout.
 connectionTimeout=Connection timeout. Check the Error Console on both ends for potential error messages. Reopen the Web Console to try again.
diff --git a/devtools/client/webconsole/components/JSTerm.js b/devtools/client/webconsole/components/JSTerm.js
--- a/devtools/client/webconsole/components/JSTerm.js
+++ b/devtools/client/webconsole/components/JSTerm.js
@@ -854,18 +854,20 @@ class JSTerm extends Component {
         break;
 
       case KeyCodes.DOM_VK_TAB:
         // Generate a completion and accept the first proposed value.
         if (this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion &&
             this.acceptProposedCompletion()) {
           event.preventDefault();
-        } else if (this._inputChanged) {
-          this.updateCompleteNode(l10n.getStr("Autocomplete.blank"));
+        } else if (!this.hasEmptyInput()) {
+          if (!event.shiftKey) {
+            this.insertStringAtCursor("\t");
+          }
           event.preventDefault();
         }
         break;
       default:
         break;
     }
   }
   /* eslint-enable complexity */
@@ -906,16 +908,25 @@ class JSTerm extends Component {
       this.setInputValue(newInputValue);
       return true;
     }
 
     return false;
   }
 
   /**
+   * Test for empty input.
+   *
+   * @return boolean
+   */
+  hasEmptyInput() {
+    return this.getInputValue() === "";
+  }
+
+  /**
    * Test for multiline input.
    *
    * @return boolean
    *         True if CR or LF found in node value; else false.
    */
   hasMultilineInput() {
     return /[\r\n]/.test(this.getInputValue());
   }
@@ -1258,32 +1269,35 @@ class JSTerm extends Component {
    *         True if there was a selected completion item and the input value
    *         was updated, false otherwise.
    */
   acceptProposedCompletion() {
     let updated = false;
 
     const currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
-      const suffix =
-        currentItem.label.substring(this.lastCompletion.matchProp.length);
-      const cursor = this.inputNode.selectionStart;
-      const value = this.getInputValue();
-      this.setInputValue(value.substr(0, cursor) +
-        suffix + value.substr(cursor));
-      const newCursor = cursor + suffix.length;
-      this.inputNode.selectionStart = this.inputNode.selectionEnd = newCursor;
+      this.insertStringAtCursor(currentItem.label.substring(this.lastCompletion.matchProp.length));
       updated = true;
     }
 
     this.clearCompletion();
 
     return updated;
   }
 
+  insertStringAtCursor(str) {
+    const suffix = str;
+    const cursor = this.inputNode.selectionStart;
+    const value = this.getInputValue();
+    this.setInputValue(value.substr(0, cursor) +
+      suffix + value.substr(cursor));
+    const newCursor = cursor + suffix.length;
+    this.inputNode.selectionStart = this.inputNode.selectionEnd = newCursor;
+  }
+
   /**
    * Update the node that displays the currently selected autocomplete proposal.
    *
    * @param string suffix
    *        The proposed suffix for the inputNode value.
    */
   updateCompleteNode(suffix) {
     if (!this.completeNode) {
