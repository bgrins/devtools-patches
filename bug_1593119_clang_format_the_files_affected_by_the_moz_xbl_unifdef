# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1573060786 28800
#      Wed Nov 06 09:19:46 2019 -0800
# Node ID 4ed2ad343fc40602bcc11f3fbed2aaee39df92bb
# Parent  04aad8fb9aead6c79738385ba941365ef7f4709a
Bug 1593119 - clang-format the files affected by the MOZ_XBL unifdef

Differential Revision: https://phabricator.services.mozilla.com/D52057

diff --git a/dom/base/BindContext.h b/dom/base/BindContext.h
--- a/dom/base/BindContext.h
+++ b/dom/base/BindContext.h
@@ -91,17 +91,16 @@ struct MOZ_STACK_CLASS BindContext final
         mInUncomposedDoc(aParentElement.IsInUncomposedDoc()),
         mSubtreeRootChanges(true),
         mCollectingDisplayedNodeDataDuringLoad(
             ShouldCollectDisplayedNodeDataDuringLoad(mInComposedDoc, mDoc,
                                                      aParentElement)) {
     MOZ_ASSERT(mInComposedDoc, "Binding NAC in a disconnected subtree?");
   }
 
-
   bool CollectingDisplayedNodeDataDuringLoad() const {
     return mCollectingDisplayedNodeDataDuringLoad;
   }
 
  private:
   static bool IsLikelyUndisplayed(const nsINode& aParent) {
     return aParent.IsAnyOfHTMLElements(nsGkAtoms::style, nsGkAtoms::script);
   }
diff --git a/dom/base/CharacterData.cpp b/dom/base/CharacterData.cpp
--- a/dom/base/CharacterData.cpp
+++ b/dom/base/CharacterData.cpp
@@ -507,17 +507,16 @@ nsresult CharacterData::BindToTree(BindC
 }
 
 void CharacterData::UnbindFromTree(bool aNullParent) {
   // Unset frame flags; if we need them again later, they'll get set again.
   UnsetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE | NS_REFRAME_IF_WHITESPACE);
 
   HandleShadowDOMRelatedRemovalSteps(aNullParent);
 
-
   if (aNullParent) {
     if (IsRootOfNativeAnonymousSubtree()) {
       MutationObservers::NotifyNativeAnonymousChildListChange(this, true);
     }
     if (GetParent()) {
       NS_RELEASE(mParent);
     } else {
       mParent = nullptr;
@@ -529,17 +528,16 @@ void CharacterData::UnbindFromTree(bool 
 
   if (aNullParent || !mParent->IsInShadowTree()) {
     UnsetFlags(NODE_IS_IN_SHADOW_TREE);
 
     // Begin keeping track of our subtree root.
     SetSubtreeRootPointer(aNullParent ? this : mParent->SubtreeRoot());
   }
 
-
   nsExtendedContentSlots* slots = GetExistingExtendedContentSlots();
   if (slots) {
     slots->mBindingParent = nullptr;
     if (aNullParent || !mParent->IsInShadowTree()) {
       slots->mContainingShadow = nullptr;
     }
   }
 
diff --git a/dom/base/CharacterData.h b/dom/base/CharacterData.h
--- a/dom/base/CharacterData.h
+++ b/dom/base/CharacterData.h
@@ -164,17 +164,16 @@ class CharacterData : public nsIContent 
   void SaveSubtreeState() final {}
 
 #ifdef DEBUG
   void List(FILE* out, int32_t aIndent) const override {}
 
   void DumpContent(FILE* out, int32_t aIndent, bool aDumpAll) const override {}
 #endif
 
-
   bool IsNodeOfType(uint32_t aFlags) const override { return false; }
 
   bool IsLink(nsIURI** aURI) const final {
     *aURI = nullptr;
     return false;
   }
 
   nsresult Clone(dom::NodeInfo* aNodeInfo, nsINode** aResult) const override {
diff --git a/dom/base/ChildIterator.cpp b/dom/base/ChildIterator.cpp
--- a/dom/base/ChildIterator.cpp
+++ b/dom/base/ChildIterator.cpp
@@ -102,17 +102,16 @@ void FlattenedChildIterator::Init(bool a
   // FlattenedChildIterators with Element.
   if (mParent->IsElement()) {
     if (ShadowRoot* shadow = mParent->AsElement()->GetShadowRoot()) {
       mParent = shadow;
       mXBLInvolved = Some(true);
       return;
     }
   }
-
 }
 
 bool FlattenedChildIterator::ComputeWhetherXBLIsInvolved() const {
   MOZ_ASSERT(mXBLInvolved.isNothing());
   // We set mXBLInvolved to true if either the node we're iterating has a
   // binding with content attached to it (in which case it is handled in Init),
   // the node is generated XBL content and has an <xbl:children> child, or the
   // node is a <slot> element.
diff --git a/dom/base/Document.cpp b/dom/base/Document.cpp
--- a/dom/base/Document.cpp
+++ b/dom/base/Document.cpp
@@ -1940,17 +1940,16 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   } else {
     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(Document, tmp->mRefCnt.get())
   }
 
   if (!nsINode::Traverse(tmp, cb)) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
-
   tmp->mExternalResourceMap.Traverse(&cb);
 
   // Traverse all Document pointer members.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSecurityInfo)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDisplayDocument)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFontFaceSet)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mReadyForIdle)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDocumentL10n)
@@ -6889,46 +6888,43 @@ bool Document::RemoveObserver(nsIDocumen
   if (!mInDestructor) {
     RemoveMutationObserver(aObserver);
     return mObservers.RemoveElement(aObserver);
   }
 
   return mObservers.Contains(aObserver);
 }
 
-
 void Document::BeginUpdate() {
   // If the document is going away, then it's probably okay to do things to it
   // in the wrong DocGroup. We're unlikely to run JS or do anything else
   // observable at this point. We reach this point when cycle collecting a
   // <link> element and the unlink code removes a style sheet.
   //
   // TODO(emilio): Style updates are gone, can this happen now?
   if (mDocGroup && !mIsGoingAway && !mInUnlinkOrDeletion &&
       !mIgnoreDocGroupMismatches) {
     mDocGroup->ValidateAccess();
   }
 
-
   ++mUpdateNestLevel;
   nsContentUtils::AddScriptBlocker();
   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginUpdate, (this));
 }
 
 void Document::EndUpdate() {
   const bool reset = !mPendingMaybeEditingStateChanged;
   mPendingMaybeEditingStateChanged = true;
 
   NS_DOCUMENT_NOTIFY_OBSERVERS(EndUpdate, (this));
 
   nsContentUtils::RemoveScriptBlocker();
 
   --mUpdateNestLevel;
 
-
   MaybeInitializeFinalizeFrameLoaders();
   if (mXULBroadcastManager) {
     mXULBroadcastManager->MaybeBroadcast();
   }
 
   if (reset) {
     mPendingMaybeEditingStateChanged = false;
   }
@@ -7809,32 +7805,29 @@ already_AddRefed<nsINode> Document::Impo
 Element* Document::GetBindingParent(nsINode& aNode) {
   nsCOMPtr<nsIContent> content(do_QueryInterface(&aNode));
   if (!content) return nullptr;
 
   nsIContent* bindingParent = content->GetBindingParent();
   return bindingParent ? bindingParent->AsElement() : nullptr;
 }
 
-
 Element* Document::GetAnonymousElementByAttribute(
     nsIContent* aElement, nsAtom* aAttrName,
     const nsAString& aAttrValue) const {
   return nullptr;
 }
 
 Element* Document::GetAnonymousElementByAttribute(Element& aElement,
                                                   const nsAString& aAttrName,
                                                   const nsAString& aAttrValue) {
   return nullptr;
 }
 
-nsINodeList* Document::GetAnonymousNodes(Element& aElement) {
-  return nullptr;
-}
+nsINodeList* Document::GetAnonymousNodes(Element& aElement) { return nullptr; }
 
 already_AddRefed<nsRange> Document::CreateRange(ErrorResult& rv) {
   RefPtr<nsRange> range = new nsRange(this);
   nsresult res = range->CollapseTo(this, 0);
   if (NS_FAILED(res)) {
     rv.Throw(res);
     return nullptr;
   }
@@ -9181,17 +9174,16 @@ nsINode* Document::AdoptNode(nsINode& aA
       } while ((doc = doc->GetInProcessParentDocument()));
 
       // Remove from parent.
       nsCOMPtr<nsINode> parent = adoptedNode->GetParentNode();
       if (parent) {
         parent->RemoveChildNode(adoptedNode->AsContent(), true);
       } else {
         MOZ_ASSERT(!adoptedNode->IsInUncomposedDoc());
-
       }
 
       break;
     }
     case DOCUMENT_NODE: {
       rv.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
       return nullptr;
     }
@@ -14068,17 +14060,16 @@ void Document::AddSizeOfNodeTree(nsINode
     for (nsIContent* anonKid : anonKids) {
       AddSizeOfNodeTree(*anonKid, aWindowSizes);
     }
 
     if (auto* element = Element::FromNode(aNode)) {
       if (ShadowRoot* shadow = element->GetShadowRoot()) {
         AddSizeOfNodeTree(*shadow, aWindowSizes);
       }
-
     }
   }
 
   // NOTE(emilio): If you feel smart and want to change this function to use
   // GetNextNode(), think twice, since you'd need to handle <xbl:content> in a
   // sane way, and kids of <content> won't point to the parent, so we'd never
   // find the root node where we should stop at.
   for (nsIContent* kid = aNode.GetFirstChild(); kid;
diff --git a/dom/base/Document.h b/dom/base/Document.h
--- a/dom/base/Document.h
+++ b/dom/base/Document.h
@@ -1805,17 +1805,16 @@ class Document : public nsINode,
   nsresult InitFeaturePolicy(nsIChannel* aChannel);
 
   nsresult InitReferrerInfo(nsIChannel* aChannel);
 
   void PostUnblockOnloadEvent();
 
   void DoUnblockOnload();
 
-
   void RetrieveRelevantHeaders(nsIChannel* aChannel);
 
   void TryChannelCharset(nsIChannel* aChannel, int32_t& aCharsetSource,
                          NotNull<const Encoding*>& aEncoding,
                          nsHtml5TreeOpExecutor* aExecutor);
 
   void DispatchContentLoadedEvents();
 
@@ -2383,17 +2382,16 @@ class Document : public nsINode,
   // Triggers an update of <svg:use> element shadow trees.
   void UpdateSVGUseElementShadowTrees() {
     if (mSVGUseElementsNeedingShadowTreeUpdate.IsEmpty()) {
       return;
     }
     DoUpdateSVGUseElementShadowTrees();
   }
 
-
   /**
    * Only to be used inside Gecko, you can't really do anything with the
    * pointer outside Gecko anyway.
    */
   nsNodeInfoManager* NodeInfoManager() const { return mNodeInfoManager; }
 
   /**
    * Reset the document using the given channel and loadgroup.  This works
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -365,17 +365,16 @@ void Element::Focus(const FocusOptions& 
 
 void Element::SetTabIndex(int32_t aTabIndex, mozilla::ErrorResult& aError) {
   nsAutoString value;
   value.AppendInt(aTabIndex);
 
   SetAttr(nsGkAtoms::tabindex, value, aError);
 }
 
-
 void Element::SetShadowRoot(ShadowRoot* aShadowRoot) {
   nsExtendedDOMSlots* slots = ExtendedDOMSlots();
   slots->mShadowRoot = aShadowRoot;
 }
 
 void Element::Blur(mozilla::ErrorResult& aError) {
   if (!ShouldBlur(this)) {
     return;
@@ -1007,18 +1006,17 @@ already_AddRefed<ShadowRoot> Element::At
     aError.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
     return nullptr;
   }
 
   /**
    * 3. If context object is a shadow host, then throw
    *    an "InvalidStateError" DOMException.
    */
-  if (GetShadowRoot()
-  ) {
+  if (GetShadowRoot()) {
     aError.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
   if (StaticPrefs::dom_webcomponents_shadowdom_report_usage()) {
     OwnerDoc()->ReportShadowDOMUsage();
   }
 
@@ -1535,17 +1533,16 @@ nsresult Element::BindToTree(BindContext
   //  because it has to happen after updating the parent pointer, but before
   //  recursively binding the kids.
   if (IsHTMLElement()) {
     SetDirOnBind(this, nsIContent::FromNode(aParent));
   }
 
   UpdateEditableState(false);
 
-
   // Call BindToTree on shadow root children.
   nsresult rv;
   if (ShadowRoot* shadowRoot = GetShadowRoot()) {
     rv = shadowRoot->Bind();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // Now recurse into our kids. Ensure this happens after binding the shadow
@@ -1616,17 +1613,16 @@ nsresult Element::BindToTree(BindContext
              "Bound to wrong binding parent");
   MOZ_ASSERT(aParent.IsInUncomposedDoc() == IsInUncomposedDoc());
   MOZ_ASSERT(aParent.IsInComposedDoc() == IsInComposedDoc());
   MOZ_ASSERT(aParent.IsInShadowTree() == IsInShadowTree());
   MOZ_ASSERT(aParent.SubtreeRoot() == SubtreeRoot());
   return NS_OK;
 }
 
-
 bool WillDetachFromShadowOnUnbind(const Element& aElement, bool aNullParent) {
   // If our parent still is in a shadow tree by now, and we're not removing
   // ourselves from it, then we're still going to be in a shadow tree after
   // this.
   return aElement.IsInShadowTree() &&
          (aNullParent || !aElement.GetParent()->IsInShadowTree());
 }
 
@@ -1764,17 +1760,16 @@ void Element::UnbindFromTree(bool aNullP
       slots->mBindingParent = nullptr;
     }
     if (aNullParent || !mParent->IsInShadowTree()) {
       slots->mContainingShadow = nullptr;
     }
   }
 
   if (document) {
-
     // Disconnected must be enqueued whenever a connected custom element becomes
     // disconnected.
     CustomElementData* data = GetCustomElementData();
     if (data) {
       if (data->mState == CustomElementData::State::eCustom) {
         nsContentUtils::EnqueueLifecycleCallback(Document::eDisconnected, this);
       } else {
         // Remove an unresolved custom element that is a candidate for upgrade
@@ -2293,17 +2288,16 @@ nsresult Element::SetAttrAndNotify(
       oldValue = nullptr;
     }
   } else {
     // No need to conditionally assign null here. If there was no previously
     // set value for the attribute, aOldValue will already be null.
     oldValue = aOldValue;
   }
 
-
   if (HasElementCreatedFromPrototypeAndHasUnmodifiedL10n() &&
       aNamespaceID == kNameSpaceID_None &&
       (aName == nsGkAtoms::datal10nid || aName == nsGkAtoms::datal10nargs)) {
     ClearElementCreatedFromPrototypeAndHasUnmodifiedL10n();
     if (aComposedDocument) {
       aComposedDocument->mL10nProtoElements.Remove(this);
     }
   }
@@ -2597,17 +2591,16 @@ nsresult Element::UnsetAttr(int32_t aNam
   }
 
   nsAttrValue oldValue;
   rv = mAttrs.RemoveAttrAt(index, oldValue);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PostIdMaybeChange(aNameSpaceID, aName, nullptr);
 
-
   CustomElementDefinition* definition = GetCustomElementDefinition();
   // Only custom element which is in `custom` state could get the
   // CustomElementDefinition.
   if (definition && definition->IsInObservedAttributeList(aName)) {
     nsAutoString ns;
     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
 
     RefPtr<nsAtom> oldValueAtom = oldValue.GetAsAtom();
@@ -2717,17 +2710,16 @@ void Element::List(FILE* out, int32_t aI
     for (; child; child = child->GetNextSibling()) {
       child->List(out, aIndent + 1);
     }
 
     for (indent = aIndent; --indent >= 0;) fputs("  ", out);
   }
 
   fputs(">\n", out);
-
 }
 
 void Element::DumpContent(FILE* out, int32_t aIndent, bool aDumpAll) const {
   int32_t indent;
   for (indent = aIndent; --indent >= 0;) fputs("  ", out);
 
   const nsString& buf = mNodeInfo->QualifiedName();
   fputs("<", out);
@@ -3737,17 +3729,16 @@ template <class T>
 void Element::GetCustomInterface(nsGetterAddRefs<T> aResult) {
   nsCOMPtr<nsISupports> iface = CustomElementRegistry::CallGetCustomInterface(
       this, NS_GET_TEMPLATE_IID(T));
   if (iface) {
     if (NS_SUCCEEDED(CallQueryInterface(iface, static_cast<T**>(aResult)))) {
       return;
     }
   }
-
 }
 
 void Element::ClearServoData(Document* aDoc) {
   MOZ_ASSERT(aDoc);
   if (HasServoData()) {
     Servo_Element_ClearData(this);
   } else {
     UnsetFlags(kAllServoDescendantBits | NODE_NEEDS_FRAME);
diff --git a/dom/base/Element.h b/dom/base/Element.h
--- a/dom/base/Element.h
+++ b/dom/base/Element.h
@@ -219,17 +219,16 @@ class Element : public FragmentOrElement
    */
   int32_t TabIndex();
 
   /**
    * Set tabIndex value to this element.
    */
   void SetTabIndex(int32_t aTabIndex, mozilla::ErrorResult& aError);
 
-
   /**
    * Sets the ShadowRoot binding for this element. The contents of the
    * binding is rendered in place of this node's children.
    *
    * @param aShadowRoot The ShadowRoot to be bound to this element.
    */
   void SetShadowRoot(ShadowRoot* aShadowRoot);
 
@@ -1953,17 +1952,16 @@ class Element : public FragmentOrElement
   // descendants of display: none elements.
   mozilla::RustCell<ServoNodeData*> mServoData;
 
  protected:
   // Array containing all attributes for this element
   AttrArray mAttrs;
 };
 
-
 NS_DEFINE_STATIC_IID_ACCESSOR(Element, NS_ELEMENT_IID)
 
 inline bool Element::HasAttr(int32_t aNameSpaceID, const nsAtom* aName) const {
   NS_ASSERTION(nullptr != aName, "must have attribute name");
   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
                "must have a real namespace ID!");
 
   return mAttrs.IndexOfAttr(aName, aNameSpaceID) >= 0;
diff --git a/dom/base/FragmentOrElement.cpp b/dom/base/FragmentOrElement.cpp
--- a/dom/base/FragmentOrElement.cpp
+++ b/dom/base/FragmentOrElement.cpp
@@ -674,17 +674,16 @@ void FragmentOrElement::nsExtendedDOMSlo
   aCb.NoteXPCOMChild(mControllers);
 
   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(aCb, "mExtendedSlots->mLabelsList");
   aCb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsINodeList*, mLabelsList));
 
   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(aCb, "mExtendedSlots->mShadowRoot");
   aCb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIContent*, mShadowRoot));
 
-
   if (mCustomElementData) {
     mCustomElementData->Traverse(aCb);
   }
 }
 
 size_t FragmentOrElement::nsExtendedDOMSlots::SizeOfExcludingThis(
     MallocSizeOf aMallocSizeOf) const {
   size_t n =
@@ -708,17 +707,16 @@ size_t FragmentOrElement::nsExtendedDOMS
 
   if (mLabelsList) {
     n += mLabelsList->SizeOfIncludingThis(aMallocSizeOf);
   }
 
   // mShadowRoot should be handled during normal DOM tree memory reporting, just
   // like kids, siblings, etc.
 
-
   if (mCustomElementData) {
     n += mCustomElementData->SizeOfIncludingThis(aMallocSizeOf);
   }
 
   return n;
 }
 
 FragmentOrElement::FragmentOrElement(
@@ -1069,17 +1067,16 @@ bool nsIContent::IsFocusableInternal(int
   return false;
 }
 
 bool FragmentOrElement::IsLink(nsIURI** aURI) const {
   *aURI = nullptr;
   return false;
 }
 
-
 nsIContent* nsIContent::GetContainingShadowHost() const {
   if (mozilla::dom::ShadowRoot* shadow = GetContainingShadow()) {
     return shadow->GetHost();
   }
   return nullptr;
 }
 
 void nsIContent::SetAssignedSlot(HTMLSlotElement* aSlot) {
@@ -1140,17 +1137,16 @@ void FragmentOrElement::DestroyContent()
   // around the flattened tree.
   //
   // TODO(emilio): I suspect this can be asserted against instead, with a bit of
   // effort to avoid calling Document::Destroy with a shell...
   if (IsElement()) {
     AsElement()->ClearServoData();
   }
 
-
 #ifdef DEBUG
   uint32_t oldChildCount = GetChildCount();
 #endif
 
   for (nsIContent* child = GetFirstChild(); child;
        child = child->GetNextSibling()) {
     child->DestroyContent();
     MOZ_ASSERT(child->GetParent() == this,
@@ -1346,17 +1342,16 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Fr
     unbind the child nodes.
   } */
 
   if (ShadowRoot* shadowRoot = tmp->GetShadowRoot()) {
     shadowRoot->Unbind();
     tmp->ExtendedDOMSlots()->mShadowRoot = nullptr;
   }
 
-
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE(FragmentOrElement)
 
 void FragmentOrElement::MarkNodeChildren(nsINode* aNode) {
   JSObject* o = GetJSObjectChild(aNode);
   if (o) {
     JS::ExposeObjectToActiveJS(o);
@@ -1571,34 +1566,32 @@ static bool ShouldClearPurple(nsIContent
 // with a frame in a document which has currently active presshell,
 // we can act as if it was optimizable. When the primary frame dies, aNode
 // will end up to the purple buffer because of the refcount change.
 bool NodeHasActiveFrame(Document* aCurrentDoc, nsINode* aNode) {
   return aCurrentDoc->GetPresShell() && aNode->IsElement() &&
          aNode->AsElement()->GetPrimaryFrame();
 }
 
-
 // CanSkip checks if aNode is known-live, and if it is, returns true. If aNode
 // is in a known-live DOM tree, CanSkip may also remove other objects from
 // purple buffer and unmark event listeners and user data.  If the root of the
 // DOM tree is a document, less optimizations are done since checking the
 // liveness of the current document is usually fast and we don't want slow down
 // such common cases.
 bool FragmentOrElement::CanSkip(nsINode* aNode, bool aRemovingAllowed) {
   // Don't try to optimize anything during shutdown.
   if (nsCCUncollectableMarker::sGeneration == 0) {
     return false;
   }
 
   bool unoptimizable = aNode->UnoptimizableCCNode();
   Document* currentDoc = aNode->GetComposedDoc();
   if (currentDoc && IsCertainlyAliveNode(aNode, currentDoc) &&
-      (!unoptimizable || NodeHasActiveFrame(currentDoc, aNode)
-           )) {
+      (!unoptimizable || NodeHasActiveFrame(currentDoc, aNode))) {
     MarkNodeChildren(aNode);
     return true;
   }
 
   if (unoptimizable) {
     return false;
   }
 
@@ -1791,17 +1784,16 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   } else {
     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(FragmentOrElement, tmp->mRefCnt.get())
   }
 
   if (!nsIContent::Traverse(tmp, cb)) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
-
   // Check that whenever we have effect properties, MayHaveAnimations is set.
 #ifdef DEBUG
   nsAtom** effectProps = EffectSet::GetEffectSetPropertyAtoms();
   for (uint32_t i = 0; effectProps[i]; ++i) {
     MOZ_ASSERT_IF(tmp->GetProperty(effectProps[i]), tmp->MayHaveAnimations());
   }
 #endif
 
diff --git a/dom/base/FragmentOrElement.h b/dom/base/FragmentOrElement.h
--- a/dom/base/FragmentOrElement.h
+++ b/dom/base/FragmentOrElement.h
@@ -185,17 +185,16 @@ class FragmentOrElement : public nsICont
      */
     RefPtr<nsLabelsNodeList> mLabelsList;
 
     /**
      * ShadowRoot bound to the element.
      */
     RefPtr<ShadowRoot> mShadowRoot;
 
-
     /**
      * Web components custom element data.
      */
     RefPtr<CustomElementData> mCustomElementData;
   };
 
   class nsDOMSlots : public nsIContent::nsContentSlots {
    public:
diff --git a/dom/base/IDTracker.cpp b/dom/base/IDTracker.cpp
--- a/dom/base/IDTracker.cpp
+++ b/dom/base/IDTracker.cpp
@@ -56,28 +56,28 @@ void IDTracker::ResetToURIFragmentID(nsI
   nsresult rv = encoding->DecodeWithoutBOMHandling(refPart, ref);
   if (NS_FAILED(rv) || ref.IsEmpty()) {
     return;
   }
   rv = NS_OK;
 
   nsIContent* bindingParent = aFromContent->GetBindingParent();
   if (bindingParent && !aFromContent->IsInShadowTree()) {
-      // This happens, for example, if aFromContent is part of the content
-      // inserted by a call to Document::InsertAnonymousContent, which we
-      // also want to handle.  (It also happens for <use>'s anonymous
-      // content etc.)
-      Element* anonRoot =
-          doc->GetAnonRootIfInAnonymousContentContainer(aFromContent);
-      if (anonRoot) {
-        mElement = nsContentUtils::MatchElementId(anonRoot, ref);
-        // We don't have watching working yet for anonymous content, so bail out
-        // here.
-        return;
-      }
+    // This happens, for example, if aFromContent is part of the content
+    // inserted by a call to Document::InsertAnonymousContent, which we
+    // also want to handle.  (It also happens for <use>'s anonymous
+    // content etc.)
+    Element* anonRoot =
+        doc->GetAnonRootIfInAnonymousContentContainer(aFromContent);
+    if (anonRoot) {
+      mElement = nsContentUtils::MatchElementId(anonRoot, ref);
+      // We don't have watching working yet for anonymous content, so bail out
+      // here.
+      return;
+    }
   }
 
   bool isEqualExceptRef;
   rv = aURI->EqualsExceptRef(doc->GetDocumentURI(), &isEqualExceptRef);
   if (NS_FAILED(rv) || !isEqualExceptRef) {
     RefPtr<Document::ExternalResourceLoad> load;
     doc = doc->RequestExternalResource(aURI, aReferrerInfo, aFromContent,
                                        getter_AddRefs(load));
diff --git a/dom/base/MutationObservers.cpp b/dom/base/MutationObservers.cpp
--- a/dom/base/MutationObservers.cpp
+++ b/dom/base/MutationObservers.cpp
@@ -48,19 +48,19 @@ enum class IsRemoveNotification {
 
 #ifdef DEBUG
 #  define COMPOSED_DOC_DECL \
     const bool wasInComposedDoc = !!node->GetComposedDoc();
 #else
 #  define COMPOSED_DOC_DECL
 #endif
 
-#  define CALL_BINDING_MANAGER(func_, params_) \
-    do {                                       \
-    } while (0)
+#define CALL_BINDING_MANAGER(func_, params_) \
+  do {                                       \
+  } while (0)
 
 // This macro expects the ownerDocument of content_ to be in scope as
 // |Document* doc|
 #define IMPL_MUTATION_NOTIFICATION(func_, content_, params_, remove_)         \
   PR_BEGIN_MACRO                                                              \
   bool needsEnterLeave = doc->MayHaveDOMMutationObservers();                  \
   if (needsEnterLeave) {                                                      \
     nsDOMMutationObserver::EnterMutationHandling();                           \
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -179,17 +179,16 @@
 #  include "nsIPrintSettingsService.h"
 #  include "nsIWebBrowserPrint.h"
 #endif
 
 #include "nsWindowRoot.h"
 #include "nsNetCID.h"
 #include "nsIArray.h"
 
-
 #include "nsIDragService.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Selection.h"
 #include "nsFrameLoader.h"
 #include "nsISupportsPrimitives.h"
 #include "nsXPCOMCID.h"
 #include "mozilla/Logging.h"
 #include "prenv.h"
diff --git a/dom/base/nsIContent.h b/dom/base/nsIContent.h
--- a/dom/base/nsIContent.h
+++ b/dom/base/nsIContent.h
@@ -389,17 +389,16 @@ class nsIContent : public nsINode {
    *
    * @return the binding parent
    */
   virtual mozilla::dom::Element* GetBindingParent() const {
     const nsExtendedContentSlots* slots = GetExistingExtendedContentSlots();
     return slots ? slots->mBindingParent.get() : nullptr;
   }
 
-
   /**
    * Gets the ShadowRoot binding for this element.
    *
    * @return The ShadowRoot currently bound to this element.
    */
   inline mozilla::dom::ShadowRoot* GetShadowRoot() const;
 
   /**
diff --git a/dom/base/nsIContentInlines.h b/dom/base/nsIContentInlines.h
--- a/dom/base/nsIContentInlines.h
+++ b/dom/base/nsIContentInlines.h
@@ -112,17 +112,16 @@ static inline nsINode* GetFlattenedTreeP
     }
 
     if (auto* shadowRoot =
             mozilla::dom::ShadowRoot::FromNode(parentAsContent)) {
       return shadowRoot->GetHost();
     }
   }
 
-
   MOZ_ASSERT(!parentAsContent->IsActiveChildrenElement(),
              "<xbl:children> isn't in the flattened tree");
 
   // Common case.
   return parent;
 }
 
 inline nsINode* nsINode::GetFlattenedTreeParentNode() const {
diff --git a/dom/base/nsJSUtils.cpp b/dom/base/nsJSUtils.cpp
--- a/dom/base/nsJSUtils.cpp
+++ b/dom/base/nsJSUtils.cpp
@@ -612,17 +612,16 @@ bool nsJSUtils::GetScopeChainForElement(
     if (!AddScopeChainItem(aCx, cur, aScopeChain)) {
       return false;
     }
   }
 
   return true;
 }
 
-
 /* static */
 void nsJSUtils::ResetTimeZone() { JS::ResetTimeZone(); }
 
 /* static */
 bool nsJSUtils::DumpEnabled() {
 #if defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP)
   return true;
 #else
diff --git a/dom/base/nsJSUtils.h b/dom/base/nsJSUtils.h
--- a/dom/base/nsJSUtils.h
+++ b/dom/base/nsJSUtils.h
@@ -236,17 +236,16 @@ class nsJSUtils {
   static nsresult ModuleEvaluate(JSContext* aCx, JS::Handle<JSObject*> aModule);
 
   // Returns false if an exception got thrown on aCx.  Passing a null
   // aElement is allowed; that wil produce an empty aScopeChain.
   static bool GetScopeChainForElement(
       JSContext* aCx, mozilla::dom::Element* aElement,
       JS::MutableHandleVector<JSObject*> aScopeChain);
 
-
   static void ResetTimeZone();
 
   static bool DumpEnabled();
 };
 
 inline void AssignFromStringBuffer(nsStringBuffer* buffer, size_t len,
                                    nsAString& dest) {
   buffer->ToString(len, dest);
diff --git a/dom/base/nsNodeInfoManager.cpp b/dom/base/nsNodeInfoManager.cpp
--- a/dom/base/nsNodeInfoManager.cpp
+++ b/dom/base/nsNodeInfoManager.cpp
@@ -52,17 +52,16 @@ nsNodeInfoManager::nsNodeInfoManager()
     MOZ_LOG(gNodeInfoManagerLeakPRLog, LogLevel::Debug,
             ("NODEINFOMANAGER %p created", this));
 }
 
 nsNodeInfoManager::~nsNodeInfoManager() {
   // Note: mPrincipal may be null here if we never got inited correctly
   mPrincipal = nullptr;
 
-
   if (gNodeInfoManagerLeakPRLog)
     MOZ_LOG(gNodeInfoManagerLeakPRLog, LogLevel::Debug,
             ("NODEINFOMANAGER %p destroyed", this));
 
   nsLayoutStatics::Release();
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsNodeInfoManager)
@@ -98,30 +97,28 @@ NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_B
   }
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 
 nsresult nsNodeInfoManager::Init(mozilla::dom::Document* aDocument) {
   MOZ_ASSERT(!mPrincipal, "Being inited when we already have a principal?");
 
   mPrincipal = NullPrincipal::CreateWithoutOriginAttributes();
 
-
   mDefaultPrincipal = mPrincipal;
 
   mDocument = aDocument;
 
   if (gNodeInfoManagerLeakPRLog)
     MOZ_LOG(gNodeInfoManagerLeakPRLog, LogLevel::Debug,
             ("NODEINFOMANAGER %p Init document=%p", this, aDocument));
 
   return NS_OK;
 }
 
 void nsNodeInfoManager::DropDocumentReference() {
-
   // This is probably not needed anymore.
   for (auto iter = mNodeInfoHash.Iter(); !iter.Done(); iter.Next()) {
     iter.Data()->mDocument = nullptr;
   }
 
   NS_ASSERTION(!mNonDocumentNodeInfos,
                "Shouldn't have non-document nodeinfos!");
   mDocument = nullptr;
@@ -353,13 +350,12 @@ bool nsNodeInfoManager::InternalMathMLEn
                      nsContentUtils::IsSystemPrincipal(mPrincipal));
   mMathMLEnabled = Some(conclusion);
   return conclusion;
 }
 
 void nsNodeInfoManager::AddSizeOfIncludingThis(nsWindowSizes& aSizes) const {
   aSizes.mDOMOtherSize += aSizes.mState.mMallocSizeOf(this);
 
-
   // Measurement of the following members may be added later if DMD finds it
   // is worthwhile:
   // - mNodeInfoHash
 }
diff --git a/dom/base/nsNodeInfoManager.h b/dom/base/nsNodeInfoManager.h
--- a/dom/base/nsNodeInfoManager.h
+++ b/dom/base/nsNodeInfoManager.h
@@ -92,17 +92,16 @@ class nsNodeInfoManager final {
    */
   nsIPrincipal* DocumentPrincipal() const {
     NS_ASSERTION(mPrincipal, "How'd that happen?");
     return mPrincipal;
   }
 
   void RemoveNodeInfo(mozilla::dom::NodeInfo* aNodeInfo);
 
-
   /**
    * Returns true if SVG nodes in this document have real SVG semantics.
    */
   bool SVGEnabled() { return mSVGEnabled.valueOr(InternalSVGEnabled()); }
 
   /**
    * Returns true if MathML nodes in this document have real MathML semantics.
    */
diff --git a/dom/xul/nsXULPrototypeCache.cpp b/dom/xul/nsXULPrototypeCache.cpp
--- a/dom/xul/nsXULPrototypeCache.cpp
+++ b/dom/xul/nsXULPrototypeCache.cpp
@@ -193,17 +193,16 @@ nsresult nsXULPrototypeCache::PutScript(
   }
 #endif
 
   mScriptTable.Put(aURI, aScriptObject);
 
   return NS_OK;
 }
 
-
 void nsXULPrototypeCache::FlushScripts() { mScriptTable.Clear(); }
 
 void nsXULPrototypeCache::Flush() {
   mPrototypeTable.Clear();
   mScriptTable.Clear();
   mStyleSheetTable.Clear();
 }
 
@@ -487,17 +486,16 @@ static void ReportSize(const nsCString& 
                        nsISupports* aData) {
   nsAutoCString path("explicit/xul-prototype-cache/");
   path += aPath;
   aHandleReport->Callback(EmptyCString(), path, nsIMemoryReporter::KIND_HEAP,
                           nsIMemoryReporter::UNITS_BYTES, aAmount, aDescription,
                           aData);
 }
 
-
 /* static */
 void nsXULPrototypeCache::CollectMemoryReports(
     nsIHandleReportCallback* aHandleReport, nsISupports* aData) {
   if (!sInstance) {
     return;
   }
 
   MallocSizeOf mallocSizeOf = CacheMallocSizeOf;
@@ -510,17 +508,16 @@ void nsXULPrototypeCache::CollectMemoryR
   // TODO Report content in mPrototypeTable?
 
   other += sInstance->mStyleSheetTable.ShallowSizeOfExcludingThis(mallocSizeOf);
   // TODO Report content inside mStyleSheetTable?
 
   other += sInstance->mScriptTable.ShallowSizeOfExcludingThis(mallocSizeOf);
   // TODO Report content inside mScriptTable?
 
-
   other +=
       sInstance->mStartupCacheURITable.ShallowSizeOfExcludingThis(mallocSizeOf);
 
   other +=
       sInstance->mOutputStreamTable.ShallowSizeOfExcludingThis(mallocSizeOf);
   other +=
       sInstance->mInputStreamTable.ShallowSizeOfExcludingThis(mallocSizeOf);
 
diff --git a/dom/xul/nsXULPrototypeCache.h b/dom/xul/nsXULPrototypeCache.h
--- a/dom/xul/nsXULPrototypeCache.h
+++ b/dom/xul/nsXULPrototypeCache.h
@@ -55,17 +55,16 @@ class nsXULPrototypeCache : public nsIOb
   // from the cache.
 
   nsXULPrototypeDocument* GetPrototype(nsIURI* aURI);
   nsresult PutPrototype(nsXULPrototypeDocument* aDocument);
 
   JSScript* GetScript(nsIURI* aURI);
   nsresult PutScript(nsIURI* aURI, JS::Handle<JSScript*> aScriptObject);
 
-
   /**
    * Get a style sheet by URI. If the style sheet is not in the cache,
    * returns nullptr.
    */
   mozilla::StyleSheet* GetStyleSheet(nsIURI* aURI);
 
   /**
    * Store a style sheet in the cache. The key, style sheet's URI is obtained
diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -1662,17 +1662,16 @@ void PresShell::EndObservingDocument() {
   mIsDocumentGone = true;
   mIsObservingDocument = false;
 }
 
 #ifdef DEBUG_kipp
 char* nsPresShell_ReflowStackPointerTop;
 #endif
 
-
 nsresult PresShell::Initialize() {
   if (mIsDestroying) {
     return NS_OK;
   }
 
   if (!mDocument) {
     // Nothing to do
     return NS_OK;
@@ -1740,17 +1739,16 @@ nsresult PresShell::Initialize() {
       // Destroy() to get called, bug 337586.
       NS_ENSURE_STATE(!mHaveShutDown);
     }
 
     // nsAutoCauseReflowNotifier (which sets up a script blocker) going out of
     // scope may have killed us too
     NS_ENSURE_STATE(!mHaveShutDown);
 
-
     // XBLConstructorRunner might destroy us.
     NS_ENSURE_STATE(!mHaveShutDown);
   }
 
   mDocument->TriggerAutoFocus();
 
   NS_ASSERTION(rootFrame, "How did that happen?");
 
@@ -4071,17 +4069,16 @@ void PresShell::DoFlushPendingNotificati
                                                 innerWindowID);
 #endif
       PerfStats::AutoMetricRecording<PerfStats::Metric::Styling> autoRecording;
       LAYOUT_TELEMETRY_RECORD_BASE(Restyle);
 
       mPresContext->RestyleManager()->ProcessPendingRestyles();
     }
 
-
     // Now those constructors or events might have posted restyle
     // events.  At the same time, we still need up-to-date style data.
     // In particular, reflow depends on style being completely up to
     // date.  If it's not, then style reparenting, which can
     // happen during reflow, might suddenly pick up the new rules and
     // we'll end up with frames whose style doesn't match the frame
     // type.
     if (MOZ_LIKELY(!mIsDestroying)) {
diff --git a/layout/base/nsGenConList.cpp b/layout/base/nsGenConList.cpp
--- a/layout/base/nsGenConList.cpp
+++ b/layout/base/nsGenConList.cpp
@@ -65,17 +65,16 @@ inline int32_t PseudoCompareType(nsIFram
   if (pseudo == mozilla::PseudoStyleType::after) {
     *aContent = aFrame->GetContent()->GetParent();
     return 1;
   }
   *aContent = aFrame->GetContent();
   return 0;
 }
 
-
 /* static */
 bool nsGenConList::NodeAfter(const nsGenConNode* aNode1,
                              const nsGenConNode* aNode2) {
   nsIFrame* frame1 = aNode1->mPseudoFrame;
   nsIFrame* frame2 = aNode2->mPseudoFrame;
   if (frame1 == frame2) {
     NS_ASSERTION(aNode2->mContentIndex != aNode1->mContentIndex, "identical");
     return aNode1->mContentIndex > aNode2->mContentIndex;
@@ -95,19 +94,17 @@ bool nsGenConList::NodeAfter(const nsGen
   // Two pseudo-elements of different elements, we want to treat them as if
   // they were normal elements and just use tree order.
   content1 = frame1->GetContent();
   content2 = frame2->GetContent();
 
   int32_t cmp = nsLayoutUtils::CompareTreePosition(content1, content2);
   // DoCompareTreePosition doesn't know about XBL anonymous content, and we
   // probably shouldn't bother teaching it about it.
-  MOZ_ASSERT(cmp != 0
-                 ,
-             "same content, different frames");
+  MOZ_ASSERT(cmp != 0, "same content, different frames");
   return cmp > 0;
 }
 
 void nsGenConList::Insert(nsGenConNode* aNode) {
   // Check for append.
   if (mList.isEmpty() || NodeAfter(aNode, mList.getLast())) {
     mList.insertBack(aNode);
   } else if (mLastInserted && mLastInserted != mList.getLast() &&
diff --git a/layout/inspector/InspectorUtils.cpp b/layout/inspector/InspectorUtils.cpp
--- a/layout/inspector/InspectorUtils.cpp
+++ b/layout/inspector/InspectorUtils.cpp
@@ -513,18 +513,17 @@ void InspectorUtils::ColorToRGBA(GlobalO
 /* static */
 bool InspectorUtils::IsValidCSSColor(GlobalObject& aGlobalObject,
                                      const nsAString& aColorString) {
   return ServoCSSParser::IsValidCSSColor(aColorString);
 }
 
 void InspectorUtils::GetBindingURLs(GlobalObject& aGlobalObject,
                                     Element& aElement,
-                                    nsTArray<nsString>& aResult) {
-}
+                                    nsTArray<nsString>& aResult) {}
 
 /* static */
 bool InspectorUtils::SetContentState(GlobalObject& aGlobalObject,
                                      Element& aElement, uint64_t aState,
                                      ErrorResult& aRv) {
   RefPtr<EventStateManager> esm =
       inLayoutUtils::GetEventStateManagerFor(aElement);
   EventStates state(aState);
diff --git a/layout/svg/SVGObserverUtils.cpp b/layout/svg/SVGObserverUtils.cpp
--- a/layout/svg/SVGObserverUtils.cpp
+++ b/layout/svg/SVGObserverUtils.cpp
@@ -1687,19 +1687,19 @@ already_AddRefed<nsIURI> SVGObserverUtil
   // URL was specified somewhere in the document with the <use> element, and
   // we want the fragment-only URL to resolve to an element in that document.
   if (SVGUseElement* use = content->GetContainingSVGUseShadowHost()) {
     originalURI = use->GetSourceDocURI();
   } else if (content->IsInAnonymousSubtree()) {
     nsIContent* bindingParent = content->GetBindingParent();
 
     if (bindingParent) {
-        MOZ_ASSERT(content->IsInNativeAnonymousSubtree(),
-                   "a non-native anonymous tree which is not from "
-                   "an XBL binding?");
+      MOZ_ASSERT(content->IsInNativeAnonymousSubtree(),
+                 "a non-native anonymous tree which is not from "
+                 "an XBL binding?");
     }
   }
 
   if (originalURI) {
     bool isEqualsExceptRef = false;
     aDocURI->EqualsExceptRef(originalURI, &isEqualsExceptRef);
     if (isEqualsExceptRef) {
       return originalURI.forget();
