# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0f8f17a920afe14e2b3e60b5186eab1b9d76c55e

diff --git a/layout/forms/nsFileControlFrame.cpp b/layout/forms/nsFileControlFrame.cpp
--- a/layout/forms/nsFileControlFrame.cpp
+++ b/layout/forms/nsFileControlFrame.cpp
@@ -135,27 +135,21 @@ nsFileControlFrame::CreateAnonymousConte
   nsAutoString accessKey;
   fileContent->GetAccessKey(accessKey);
 
   mBrowseFilesOrDirs = MakeAnonButton(doc, "Browse", fileContent, accessKey);
   if (!mBrowseFilesOrDirs || !aElements.AppendElement(mBrowseFilesOrDirs)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  // Create and setup the text showing the selected files.
-  RefPtr<NodeInfo> nodeInfo;
-  nodeInfo = doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::label, nullptr,
-                                                 kNameSpaceID_XUL,
-                                                 nsINode::ELEMENT_NODE);
-  NS_TrustedNewXULElement(getter_AddRefs(mTextContent), nodeInfo.forget());
+  mTextContent = doc->CreateHTMLElement(nsGkAtoms::label);
+  mTextContent->AppendChildTo(new nsTextNode(doc->NodeInfoManager()), false);
   // NOTE: SetIsNativeAnonymousRoot() has to be called before setting any
   // attribute.
   mTextContent->SetIsNativeAnonymousRoot();
-  mTextContent->SetAttr(kNameSpaceID_None, nsGkAtoms::crop,
-                        NS_LITERAL_STRING("center"), false);
 
   // Update the displayed text to reflect the current element's value.
   nsAutoString value;
   HTMLInputElement::FromNode(mContent)->GetDisplayFileName(value);
   UpdateDisplayedValue(value, false);
 
   if (!aElements.AppendElement(mTextContent)) {
     return NS_ERROR_OUT_OF_MEMORY;
@@ -470,17 +464,17 @@ nsFileControlFrame::GetFrameName(nsAStri
 {
   return MakeFrameName(NS_LITERAL_STRING("FileControl"), aResult);
 }
 #endif
 
 void
 nsFileControlFrame::UpdateDisplayedValue(const nsAString& aValue, bool aNotify)
 {
-  mTextContent->SetAttr(kNameSpaceID_None, nsGkAtoms::value, aValue, aNotify);
+  mTextContent->GetFirstChild()->AsText()->SetText(aValue, aNotify);
 }
 
 nsresult
 nsFileControlFrame::SetFormProperty(nsAtom* aName,
                                     const nsAString& aValue)
 {
   if (nsGkAtoms::value == aName) {
     UpdateDisplayedValue(aValue, true);
diff --git a/layout/style/res/forms.css b/layout/style/res/forms.css
--- a/layout/style/res/forms.css
+++ b/layout/style/res/forms.css
@@ -3,17 +3,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
   Styles for old GFX form widgets
  **/
 
 
 @namespace url(http://www.w3.org/1999/xhtml); /* set default namespace to HTML */
-@namespace xul url(http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul);
 
 *|*::-moz-fieldset-content {
   display: block; /* nsRuleNode::ComputeDisplayData overrules this in some cases */
   unicode-bidi: inherit;
   text-overflow: inherit;
   overflow: inherit;
   overflow-clip-box: inherit;
   /* Need to inherit border-radius too, so when the fieldset has rounded
@@ -489,20 +488,24 @@ input[type="file"] {
   -moz-binding: none;
   cursor: default;
 
   border: none;
   background-color: transparent;
   padding: 0;
 }
 
-input[type="file"] > xul|label {
+input[type="file"] > label {
   min-inline-size: 12em;
   padding-inline-start: 5px;
   text-align: match-parent;
+  white-space: nowrap;
+  overflow: hidden;
+  text-overflow: ellipsis;
+
 
   color: inherit;
   font-size: inherit;
   letter-spacing: inherit;
 
   /*
    * Force the text to have LTR directionality. Otherwise filenames containing
    * RTL characters will be reordered with chaotic results.
@@ -529,17 +532,17 @@ input[type="color"]::-moz-color-swatch {
   box-sizing: border-box;
   border: 1px solid grey;
   display: block;
 }
 
 /* Try to make RTL <input type='file'> look nicer. */
 /* TODO: find a better solution than forcing direction: ltr on all file
    input labels and remove this override -- bug 1161482 */
-input[type="file"]:dir(rtl) > xul|label {
+input[type="file"]:dir(rtl) > label {
   padding-inline-start: 0px;
   padding-inline-end: 5px;
 }
 
 /* radio buttons */
 input[type="radio"] {
   display: inline-block;
   -moz-appearance: radio;
