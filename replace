# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4494389e577e6529815d43de71268b8837bd79c6

diff --git a/browser/base/content/test/forms/browser_selectpopup.js b/browser/base/content/test/forms/browser_selectpopup.js
--- a/browser/base/content/test/forms/browser_selectpopup.js
+++ b/browser/base/content/test/forms/browser_selectpopup.js
@@ -134,20 +134,20 @@ async function doSelectTests(contentType
   let menulist = document.getElementById("ContentSelectDropdown");
   let selectPopup = menulist.menupopup;
 
   await openSelectPopup(selectPopup);
 
   let isWindows = navigator.platform.includes("Win");
 
   is(menulist.selectedIndex, 1, "Initial selection");
-  is(selectPopup.firstChild.localName, "menucaption", "optgroup is caption");
-  is(selectPopup.firstChild.getAttribute("label"), "First Group", "optgroup label");
-  is(selectPopup.childNodes[1].localName, "menuitem", "option is menuitem");
-  is(selectPopup.childNodes[1].getAttribute("label"), "One", "option label");
+  is(selectPopup.firstElementChild.localName, "menucaption", "optgroup is caption");
+  is(selectPopup.firstElementChild.getAttribute("label"), "First Group", "optgroup label");
+  is(selectPopup.children[1].localName, "menuitem", "option is menuitem");
+  is(selectPopup.children[1].getAttribute("label"), "One", "option label");
 
   EventUtils.synthesizeKey("KEY_ArrowDown");
   is(menulist.menuBoxObject.activeChild, menulist.getItemAtIndex(2), "Select item 2");
   is(menulist.selectedIndex, isWindows ? 2 : 1, "Select item 2 selectedIndex");
 
   EventUtils.synthesizeKey("KEY_ArrowDown");
   is(menulist.menuBoxObject.activeChild, menulist.getItemAtIndex(3), "Select item 3");
   is(menulist.selectedIndex, isWindows ? 3 : 1, "Select item 3 selectedIndex");
@@ -211,18 +211,18 @@ async function doSelectTests(contentType
   is((await getChangeEvents()), isWindows ? 2 : 1, "Open and close with change - number of change events");
   is((await getClickEvents()), 2, "Open and close with change - number of click events");
   EventUtils.synthesizeKey("KEY_Tab");
   EventUtils.synthesizeKey("KEY_Tab", {shiftKey: true});
   is((await getInputEvents()), isWindows ? 2 : 1, "Tab away from select with change - number of input events");
   is((await getChangeEvents()), isWindows ? 2 : 1, "Tab away from select with change - number of change events");
   is((await getClickEvents()), 2, "Tab away from select with change - number of click events");
 
-  is(selectPopup.lastChild.previousSibling.label, "Seven", "Spaces collapsed");
-  is(selectPopup.lastChild.label, "\xA0\xA0Eight\xA0\xA0", "Non-breaking spaces not collapsed");
+  is(selectPopup.lastElementChild.previousElementSibling.label, "Seven", "Spaces collapsed");
+  is(selectPopup.lastElementChild.label, "\xA0\xA0Eight\xA0\xA0", "Non-breaking spaces not collapsed");
 
   BrowserTestUtils.removeTab(tab);
 }
 
 add_task(async function setup() {
   await SpecialPowers.pushPrefEnv({
     "set": [
       ["dom.select_popup_in_parent.enabled", true],
@@ -485,17 +485,17 @@ async function performLargePopupTests(wi
   scrollPos = selectPopup.scrollBox.scrollTop;
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 25, { type: "mouseup" }, win);
   is(selectPopup.scrollBox.scrollTop, scrollPos, "scroll position at mouseup should not change");
 
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" }, win);
   is(selectPopup.scrollBox.scrollTop, scrollPos, "scroll position at mousemove after mouseup should not change");
 
   // Now check dragging with a mousedown on an item
-  let menuRect = selectPopup.childNodes[51].getBoundingClientRect();
+  let menuRect = selectPopup.children[51].getBoundingClientRect();
   EventUtils.synthesizeMouseAtPoint(menuRect.left + 5, menuRect.top + 5, { type: "mousedown" }, win);
 
   // Dragging below the popup scrolls it down.
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" }, win);
   ok(selectPopup.scrollBox.scrollTop > scrollPos + 5, "scroll position at drag down from option");
 
   // Dragging above the popup scrolls it up.
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.top - 20, { type: "mousemove" }, win);
@@ -535,17 +535,17 @@ async function performLargePopupTests(wi
         // 61st child, since the first child is now the search input field.
         selectedOption = 61;
       }
       // Some of the styles applied to the menuitems are percentages, meaning
       // that the final layout calculations returned by getBoundingClientRect()
       // might return floating point values. We don't care about sub-pixel
       // accuracy, and only care about the final pixel value, so we add a
       // fuzz-factor of 1.
-      SimpleTest.isfuzzy(selectPopup.childNodes[selectedOption].getBoundingClientRect().bottom,
+      SimpleTest.isfuzzy(selectPopup.children[selectedOption].getBoundingClientRect().bottom,
                          selectPopup.getBoundingClientRect().bottom - bpBottom,
                          1, "Popup scroll at correct position " + bpBottom);
     }
 
     await hideSelectPopup(selectPopup, "enter", win);
 
     position = positions.shift();
 
@@ -620,45 +620,45 @@ async function performSelectSearchTests(
 
   let selectPopup = win.document.getElementById("ContentSelectDropdown").menupopup;
   await openSelectPopup(selectPopup, false, "select", win);
 
   let searchElement = selectPopup.querySelector("textbox");
   searchElement.focus();
 
   EventUtils.synthesizeKey("O", {}, win);
-  is(selectPopup.childNodes[2].hidden, false, "First option should be visible");
-  is(selectPopup.childNodes[3].hidden, false, "Second option should be visible");
+  is(selectPopup.children[2].hidden, false, "First option should be visible");
+  is(selectPopup.children[3].hidden, false, "Second option should be visible");
 
   EventUtils.synthesizeKey("3", {}, win);
-  is(selectPopup.childNodes[2].hidden, true, "First option should be hidden");
-  is(selectPopup.childNodes[3].hidden, true, "Second option should be hidden");
-  is(selectPopup.childNodes[4].hidden, false, "Third option should be visible");
+  is(selectPopup.children[2].hidden, true, "First option should be hidden");
+  is(selectPopup.children[3].hidden, true, "Second option should be hidden");
+  is(selectPopup.children[4].hidden, false, "Third option should be visible");
 
   EventUtils.synthesizeKey("Z", {}, win);
-  is(selectPopup.childNodes[4].hidden, true, "Third option should be hidden");
-  is(selectPopup.childNodes[1].hidden, true, "First group header should be hidden");
+  is(selectPopup.children[4].hidden, true, "Third option should be hidden");
+  is(selectPopup.children[1].hidden, true, "First group header should be hidden");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[4].hidden, false, "Third option should be visible");
+  is(selectPopup.children[4].hidden, false, "Third option should be visible");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[5].hidden, false, "Second group header should be visible");
+  is(selectPopup.children[5].hidden, false, "Second group header should be visible");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
   EventUtils.synthesizeKey("O", {}, win);
   EventUtils.synthesizeKey("5", {}, win);
-  is(selectPopup.childNodes[5].hidden, false, "Second group header should be visible");
-  is(selectPopup.childNodes[1].hidden, true, "First group header should be hidden");
+  is(selectPopup.children[5].hidden, false, "Second group header should be visible");
+  is(selectPopup.children[1].hidden, true, "First group header should be hidden");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[1].hidden, false, "First group header should be shown");
+  is(selectPopup.children[1].hidden, false, "First group header should be shown");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[8].hidden, true, "Option hidden by content should remain hidden");
+  is(selectPopup.children[8].hidden, true, "Option hidden by content should remain hidden");
 
   await hideSelectPopup(selectPopup, "escape", win);
 }
 
 // This test checks the functionality of search in select elements with groups
 // and a large number of options.
 add_task(async function test_select_search() {
   await SpecialPowers.pushPrefEnv({
@@ -689,17 +689,17 @@ add_task(async function test_mousemove_c
   await popupShownPromise;
 
   await new Promise(resolve => {
     window.addEventListener("mousemove", function(event) {
       is(event.target.localName.indexOf("menu"), 0, "mouse over menu");
       resolve();
     }, {capture: true, once: true});
 
-    EventUtils.synthesizeMouseAtCenter(selectPopup.firstChild, { type: "mousemove" });
+    EventUtils.synthesizeMouseAtCenter(selectPopup.firstElementChild, { type: "mousemove" });
   });
 
   await BrowserTestUtils.synthesizeMouseAtCenter("#one", { type: "mouseup" }, gBrowser.selectedBrowser);
 
   await hideSelectPopup(selectPopup);
 
   // The popup should be closed when fullscreen mode is entered or exited.
   for (let steps = 0; steps < 2; steps++) {
@@ -721,28 +721,28 @@ add_task(async function test_somehidden(
 
   let selectPopup = document.getElementById("ContentSelectDropdown").menupopup;
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(selectPopup, "popupshown");
   await BrowserTestUtils.synthesizeMouseAtCenter("#one", { type: "mousedown" }, gBrowser.selectedBrowser);
   await popupShownPromise;
 
   // The exact number is not needed; just ensure the height is larger than 4 items to accomodate any popup borders.
-  ok(selectPopup.getBoundingClientRect().height >= selectPopup.lastChild.getBoundingClientRect().height * 4, "Height contains at least 4 items");
-  ok(selectPopup.getBoundingClientRect().height < selectPopup.lastChild.getBoundingClientRect().height * 5, "Height doesn't contain 5 items");
+  ok(selectPopup.getBoundingClientRect().height >= selectPopup.lastElementChild.getBoundingClientRect().height * 4, "Height contains at least 4 items");
+  ok(selectPopup.getBoundingClientRect().height < selectPopup.lastElementChild.getBoundingClientRect().height * 5, "Height doesn't contain 5 items");
 
   // The label contains the substring 'Visible' for items that are visible.
   // Otherwise, it is expected to be display: none.
   is(selectPopup.parentNode.itemCount, 9, "Correct number of items");
-  let child = selectPopup.firstChild;
+  let child = selectPopup.firstElementChild;
   let idx = 1;
   while (child) {
     is(getComputedStyle(child).display, child.label.indexOf("Visible") > 0 ? "-moz-box" : "none",
        "Item " + (idx++) + " is visible");
-    child = child.nextSibling;
+    child = child.nextElementSibling;
   }
 
   await hideSelectPopup(selectPopup, "escape");
   BrowserTestUtils.removeTab(tab);
 });
 
 // This test checks that the popup is closed when the select element is blurred.
 add_task(async function test_blur_hides_popup() {
diff --git a/browser/base/content/test/forms/browser_selectpopup_colors.js b/browser/base/content/test/forms/browser_selectpopup_colors.js
--- a/browser/base/content/test/forms/browser_selectpopup_colors.js
+++ b/browser/base/content/test/forms/browser_selectpopup_colors.js
@@ -240,17 +240,17 @@ async function testSelectColors(select, 
     let value = options.waitForComputedStyle.value;
     await BrowserTestUtils.waitForCondition(() => {
       info(`<select> has ${property}: ${getComputedStyle(selectPopup)[property]}`);
       return getComputedStyle(selectPopup)[property] == value;
     }, `Waiting for <select> to have ${property}: ${value}`);
   }
 
   is(selectPopup.parentNode.itemCount, itemCount, "Correct number of items");
-  let child = selectPopup.firstChild;
+  let child = selectPopup.firstElementChild;
   let idx = 1;
 
   if (!options.skipSelectColorTest) {
     is(getComputedStyle(selectPopup).color, options.selectColor,
       "popup has expected foreground color");
 
     if (options.selectTextShadow) {
       is(getComputedStyle(selectPopup).textShadow, options.selectTextShadow,
@@ -284,17 +284,17 @@ async function testSelectColors(select, 
         "popup has expected background color");
     }
   }
 
   ok(!child.selected, "The first child should not be selected");
   while (child) {
     testOptionColors(idx, child, menulist);
     idx++;
-    child = child.nextSibling;
+    child = child.nextElementSibling;
   }
 
   if (!options.leaveOpen) {
     await hideSelectPopup(selectPopup, "escape");
     BrowserTestUtils.removeTab(tab);
   }
 }
 
diff --git a/browser/base/content/test/general/browser_accesskeys.js b/browser/base/content/test/general/browser_accesskeys.js
--- a/browser/base/content/test/general/browser_accesskeys.js
+++ b/browser/base/content/test/general/browser_accesskeys.js
@@ -108,17 +108,17 @@ add_task(async function() {
 
   gBrowser.removeTab(tab4);
 
   newButton.remove();
 });
 
 function childHandleFocus() {
   var sent = false;
-  content.document.body.firstChild.addEventListener("focus", function focused(event) {
+  content.document.body.firstElementChild.addEventListener("focus", function focused(event) {
     sent = true;
     let focusedElement = content.document.activeElement;
     focusedElement.blur();
     sendAsyncMessage("Test:FocusFromAccessKey", { focus: focusedElement.id });
   }, true);
   content.document.body.addEventListener("keydown", function keydown(event) {
     sent = false;
   }, true);
diff --git a/browser/base/content/test/general/browser_bug1299667.js b/browser/base/content/test/general/browser_bug1299667.js
--- a/browser/base/content/test/general/browser_bug1299667.js
+++ b/browser/base/content/test/general/browser_bug1299667.js
@@ -24,22 +24,22 @@ add_task(async function() {
 
   ok(true, "history menu opened");
 
   // Wait for the session data to be flushed before continuing the test
   await new Promise(resolve => SessionStore.getSessionHistory(gBrowser.selectedTab, resolve));
 
   is(event.target.children.length, 2, "Two history items");
 
-  let node = event.target.firstChild;
+  let node = event.target.firstElementChild;
   is(node.getAttribute("uri"), "http://example.com/2.html", "first item uri");
   is(node.getAttribute("index"), "1", "first item index");
   is(node.getAttribute("historyindex"), "0", "first item historyindex");
 
-  node = event.target.lastChild;
+  node = event.target.lastElementChild;
   is(node.getAttribute("uri"), "http://example.com/", "second item uri");
   is(node.getAttribute("index"), "0", "second item index");
   is(node.getAttribute("historyindex"), "-1", "second item historyindex");
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(contextMenu, "popuphidden");
   event.target.hidePopup();
   await popupHiddenPromise;
   info("Hidden popup");
diff --git a/browser/base/content/test/general/browser_bug417483.js b/browser/base/content/test/general/browser_bug417483.js
--- a/browser/base/content/test/general/browser_bug417483.js
+++ b/browser/base/content/test/general/browser_bug417483.js
@@ -3,17 +3,17 @@ add_task(async function() {
   const htmlContent = "data:text/html, <iframe src='data:text/html,text text'></iframe>";
   gBrowser.loadURI(htmlContent);
   await loadedPromise;
 
   await ContentTask.spawn(gBrowser.selectedBrowser, { }, async function(arg) {
     let frame = content.frames[0];
     let sel = frame.getSelection();
     let range = frame.document.createRange();
-    let tn = frame.document.body.childNodes[0];
+    let tn = frame.document.body.children[0];
     range.setStart(tn, 4);
     range.setEnd(tn, 5);
     sel.addRange(range);
     frame.focus();
   });
 
   let contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
 
diff --git a/browser/base/content/test/general/browser_bug423833.js b/browser/base/content/test/general/browser_bug423833.js
--- a/browser/base/content/test/general/browser_bug423833.js
+++ b/browser/base/content/test/general/browser_bug423833.js
@@ -24,17 +24,17 @@ function test1Setup() {
   if (content.frames.length < 2 ||
       content.frames[1].location != invalidPage)
     // The error frame hasn't loaded yet
     return;
 
   gBrowser.selectedBrowser.removeEventListener("load", test1Setup, true);
 
   var badFrame = content.frames[1];
-  document.popupNode = badFrame.document.firstChild;
+  document.popupNode = badFrame.document.firstElementChild;
 
   var contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
   var contextMenu = new nsContextMenu(contentAreaContextMenu);
 
   // We'd like to use another load listener here, but error pages don't fire load events
   contextMenu.showOnlyThisFrame();
   intervalID = setInterval(testShowOnlyThisFrame, 3000);
 }
@@ -61,17 +61,17 @@ function test2Setup() {
     // The error frame hasn't loaded yet
     return;
 
   gBrowser.removeEventListener("load", test2Setup, true);
 
   // Now let's do the whole thing again, but this time for "Open frame in new tab"
   var badFrame = content.frames[1];
 
-  document.popupNode = badFrame.document.firstChild;
+  document.popupNode = badFrame.document.firstElementChild;
 
   var contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
   var contextMenu = new nsContextMenu(contentAreaContextMenu);
 
   gBrowser.tabContainer.addEventListener("TabOpen", function listener(event) {
     test2tab = event.target;
     gBrowser.tabContainer.removeEventListener("TabOpen", listener);
   });
@@ -97,17 +97,17 @@ function testOpenFrameInTab() {
   gBrowser.removeCurrentTab();
 
   test3Setup();
 }
 
 function test3Setup() {
   // One more time, for "Open frame in new window"
   var badFrame = content.frames[1];
-  document.popupNode = badFrame.document.firstChild;
+  document.popupNode = badFrame.document.firstElementChild;
 
   var contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
   var contextMenu = new nsContextMenu(contentAreaContextMenu);
 
   Services.ww.registerNotification(function notification(aSubject, aTopic, aData) {
     if (aTopic == "domwindowopened")
       test3window = aSubject;
     Services.ww.unregisterNotification(notification);
diff --git a/browser/base/content/test/general/browser_bug427559.js b/browser/base/content/test/general/browser_bug427559.js
--- a/browser/base/content/test/general/browser_bug427559.js
+++ b/browser/base/content/test/general/browser_bug427559.js
@@ -4,17 +4,17 @@
  * Test bug 427559 to make sure focused elements that are no longer on the page
  * will have focus transferred to the window when changing tabs back to that
  * tab with the now-gone element.
  */
 
 // Default focus on a button and have it kill itself on blur.
 const URL = "data:text/html;charset=utf-8," +
             '<body><button onblur="this.remove()">' +
-            "<script>document.body.firstChild.focus()</script></body>";
+            "<script>document.body.firstElementChild.focus()</script></body>";
 
 function getFocusedLocalName(browser) {
   return ContentTask.spawn(browser, null, async function() {
     return content.document.activeElement.localName;
   });
 }
 
 add_task(async function() {
diff --git a/browser/base/content/test/general/browser_bug462673.js b/browser/base/content/test/general/browser_bug462673.js
--- a/browser/base/content/test/general/browser_bug462673.js
+++ b/browser/base/content/test/general/browser_bug462673.js
@@ -1,28 +1,28 @@
 add_task(async function() {
   var win = openDialog(AppConstants.BROWSER_CHROME_URL, "_blank", "chrome,all,dialog=no");
   await SimpleTest.promiseFocus(win);
 
-  let tab = win.gBrowser.tabContainer.firstChild;
+  let tab = win.gBrowser.tabContainer.firstElementChild;
   await promiseTabLoadEvent(tab, getRootDirectory(gTestPath) + "test_bug462673.html");
 
   is(win.gBrowser.browsers.length, 2, "test_bug462673.html has opened a second tab");
-  is(win.gBrowser.selectedTab, tab.nextSibling, "dependent tab is selected");
+  is(win.gBrowser.selectedTab, tab.nextElementSibling, "dependent tab is selected");
   win.gBrowser.removeTab(tab);
 
   // Closing a tab will also close its parent chrome window, but async
   await BrowserTestUtils.domWindowClosed(win);
 });
 
 add_task(async function() {
   var win = openDialog(AppConstants.BROWSER_CHROME_URL, "_blank", "chrome,all,dialog=no");
   await SimpleTest.promiseFocus(win);
 
-  let tab = win.gBrowser.tabContainer.firstChild;
+  let tab = win.gBrowser.tabContainer.firstElementChild;
   await promiseTabLoadEvent(tab, getRootDirectory(gTestPath) + "test_bug462673.html");
 
   var newTab = BrowserTestUtils.addTab(win.gBrowser);
   var newBrowser = newTab.linkedBrowser;
   win.gBrowser.removeTab(tab);
   ok(!win.closed, "Window stays open");
   if (!win.closed) {
     is(win.gBrowser.tabContainer.childElementCount, 1, "Window has one tab");
diff --git a/browser/base/content/test/general/browser_bug647886.js b/browser/base/content/test/general/browser_bug647886.js
--- a/browser/base/content/test/general/browser_bug647886.js
+++ b/browser/base/content/test/general/browser_bug647886.js
@@ -20,21 +20,21 @@ add_task(async function() {
 
   ok(true, "history menu opened");
 
   // Wait for the session data to be flushed before continuing the test
   await new Promise(resolve => SessionStore.getSessionHistory(gBrowser.selectedTab, resolve));
 
   is(event.target.children.length, 2, "Two history items");
 
-  let node = event.target.firstChild;
+  let node = event.target.firstElementChild;
   is(node.getAttribute("uri"), "http://example.com/2.html", "first item uri");
   is(node.getAttribute("index"), "1", "first item index");
   is(node.getAttribute("historyindex"), "0", "first item historyindex");
 
-  node = event.target.lastChild;
+  node = event.target.lastElementChild;
   is(node.getAttribute("uri"), "http://example.com/", "second item uri");
   is(node.getAttribute("index"), "0", "second item index");
   is(node.getAttribute("historyindex"), "-1", "second item historyindex");
 
   event.target.hidePopup();
   gBrowser.removeTab(gBrowser.selectedTab);
 });
diff --git a/browser/base/content/test/general/browser_bug734076.js b/browser/base/content/test/general/browser_bug734076.js
--- a/browser/base/content/test/general/browser_bug734076.js
+++ b/browser/base/content/test/general/browser_bug734076.js
@@ -42,17 +42,17 @@ add_task(async function() {
       element: "img",
       go() {
         return ContentTask.spawn(gBrowser.selectedBrowser, { writeDomainURL }, async function(arg) {
           let doc = content.document;
           let img = doc.createElement("img");
           img.height = 100;
           img.width = 100;
           img.setAttribute("src", arg.writeDomainURL);
-          doc.body.insertBefore(img, doc.body.firstChild);
+          doc.body.insertBefore(img, doc.body.firstElementChild);
 
           return "context-viewimage";
         });
       },
       verify() {
         return ContentTask.spawn(gBrowser.selectedBrowser, null, async function(arg) {
           Assert.ok(!content.document.body.textContent,
             "no domain was inherited for view image");
@@ -63,17 +63,17 @@ add_task(async function() {
       name: "show only this frame",
       url: "http://mochi.test:8888/",
       element: "iframe",
       go() {
         return ContentTask.spawn(gBrowser.selectedBrowser, { writeDomainURL }, async function(arg) {
           let doc = content.document;
           let iframe = doc.createElement("iframe");
           iframe.setAttribute("src", arg.writeDomainURL);
-          doc.body.insertBefore(iframe, doc.body.firstChild);
+          doc.body.insertBefore(iframe, doc.body.firstElementChild);
 
           // Wait for the iframe to load.
           return new Promise(resolve => {
             iframe.addEventListener("load", function() {
               resolve("context-showonlythisframe");
             }, {capture: true, once: true});
           });
         });
diff --git a/browser/base/content/test/general/browser_contextmenu_childprocess.js b/browser/base/content/test/general/browser_contextmenu_childprocess.js
--- a/browser/base/content/test/general/browser_contextmenu_childprocess.js
+++ b/browser/base/content/test/general/browser_contextmenu_childprocess.js
@@ -27,17 +27,17 @@ function checkItems(menuitem, arr) {
   for (let i = 0; i < arr.length; i += 2) {
     let str = arr[i];
     let details = arr[i + 1];
     if (str == "---") {
       is(menuitem.localName, "menuseparator", "menuseparator");
     } else if ("children" in details) {
       is(menuitem.localName, "menu", "submenu");
       is(menuitem.getAttribute("label"), str, str + " label");
-      checkItems(menuitem.firstChild.firstChild, details.children);
+      checkItems(menuitem.firstElementChild.firstElementChild, details.children);
     } else {
       is(menuitem.localName, "menuitem", str + " menuitem");
 
       is(menuitem.getAttribute("label"), str, str + " label");
       is(menuitem.getAttribute("type"), details.type, str + " type");
       is(menuitem.getAttribute("image"), details.icon ? gBaseURL + details.icon : "", str + " icon");
 
       if (details.checked)
@@ -46,17 +46,17 @@ function checkItems(menuitem, arr) {
         ok(!menuitem.hasAttribute("checked"), str + " checked");
 
       if (details.disabled)
         is(menuitem.getAttribute("disabled"), "true", str + " disabled");
       else
         ok(!menuitem.hasAttribute("disabled"), str + " disabled");
     }
 
-    menuitem = menuitem.nextSibling;
+    menuitem = menuitem.nextElementSibling;
   }
 }
 
 function checkMenu(contextMenu) {
   let items = [ "Plain item",          {type: "", icon: "", checked: false, disabled: false},
                 "Disabled item",       {type: "", icon: "", checked: false, disabled: true},
                 "Item w/ textContent", {type: "", icon: "", checked: false, disabled: false},
                 "---",                  null,
@@ -71,10 +71,10 @@ function checkMenu(contextMenu) {
                 "---",                  null,
                 "Submenu",  { children:
                   ["Radio1",             {type: "checkbox", icon: "", checked: false, disabled: false},
                    "Radio2",             {type: "checkbox", icon: "", checked: true, disabled: false},
                    "Radio3",             {type: "checkbox", icon: "", checked: false, disabled: false},
                    "---",                 null,
                    "Checkbox",           {type: "checkbox", icon: "", checked: false, disabled: false}] }
                ];
-  checkItems(contextMenu.childNodes[2], items);
+  checkItems(contextMenu.children[2], items);
 }
diff --git a/browser/base/content/test/general/browser_ctrlTab.js b/browser/base/content/test/general/browser_ctrlTab.js
--- a/browser/base/content/test/general/browser_ctrlTab.js
+++ b/browser/base/content/test/general/browser_ctrlTab.js
@@ -86,22 +86,22 @@ add_task(async function() {
        "Ctrl+Tab*2 -> Ctrl+W removes the second most recently selected tab");
 
     await pressCtrlTab(true);
     await pressCtrlTab(true);
     await releaseCtrl();
     ok(selectedTab.selected,
        "Ctrl+Tab*2 -> Ctrl+W -> Ctrl+Shift+Tab*2 keeps the selected tab");
   }
-  gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+  gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
   checkTabs(2);
 
   await ctrlTabTest([1], 1, 0);
 
-  gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+  gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
   checkTabs(1);
 
   { // test for bug 445768
     let focusedWindow = document.commandDispatcher.focusedWindow;
     let eventConsumed = true;
     let detectKeyEvent = function(event) {
       eventConsumed = event.defaultPrevented;
     };
diff --git a/browser/base/content/test/general/browser_decoderDoctor.js b/browser/base/content/test/general/browser_decoderDoctor.js
--- a/browser/base/content/test/general/browser_decoderDoctor.js
+++ b/browser/base/content/test/general/browser_decoderDoctor.js
@@ -45,17 +45,17 @@ async function test_decoder_doctor_notif
       ok(false, ex);
       return;
     }
     ok(notification, "Got decoder-doctor-notification notification");
 
     is(notification.getAttribute("label"), notificationMessage,
        "notification message should match expectation");
 
-    let button = notification.childNodes[0];
+    let button = notification.children[0];
     if (!label) {
       ok(!button, "There should not be button");
       return;
     }
 
     is(button.getAttribute("label"),
        label,
        `notification button should be '${label}'`);
diff --git a/browser/base/content/test/general/browser_page_style_menu.js b/browser/base/content/test/general/browser_page_style_menu.js
--- a/browser/base/content/test/general/browser_page_style_menu.js
+++ b/browser/base/content/test/general/browser_page_style_menu.js
@@ -35,18 +35,18 @@ add_task(async function() {
   await BrowserTestUtils.loadURI(browser, PAGE);
   await promiseStylesheetsUpdated(browser);
 
   let menupopup = document.getElementById("pageStyleMenu").menupopup;
   gPageStyleMenu.fillPopup(menupopup);
 
   var items = [];
   var current = menupopup.getElementsByTagName("menuseparator")[0];
-  while (current.nextSibling) {
-    current = current.nextSibling;
+  while (current.nextElementSibling) {
+    current = current.nextElementSibling;
     items.push(current);
   }
 
   items = items.map(el => ({
     label: el.getAttribute("label"),
     checked: el.getAttribute("checked") == "true",
   }));
 
diff --git a/browser/base/content/test/general/browser_plainTextLinks.js b/browser/base/content/test/general/browser_plainTextLinks.js
--- a/browser/base/content/test/general/browser_plainTextLinks.js
+++ b/browser/base/content/test/general/browser_plainTextLinks.js
@@ -44,41 +44,41 @@ add_task(async function() {
     p3.textContent = "main.example.com";
     div2.appendChild(p3);
     mainDiv.appendChild(div);
     mainDiv.appendChild(div2);
     doc.body.appendChild(mainDiv);
 
     function setSelection(el1, el2, index1, index2) {
       while (el1.nodeType != el1.TEXT_NODE)
-        el1 = el1.firstChild;
+        el1 = el1.firstElementChild;
       while (el2.nodeType != el1.TEXT_NODE)
-        el2 = el2.firstChild;
+        el2 = el2.firstElementChild;
 
       selection.removeAllRanges();
       range.setStart(el1, index1);
       range.setEnd(el2, index2);
       selection.addRange(range);
 
       return range;
     }
 
     // Each of these tests creates a selection and returns a range within it.
     content.tests = [
-      () => setSelection(span1.firstChild, span2.firstChild, 0, 11),
-      () => setSelection(span1.firstChild, span2.firstChild, 7, 11),
-      () => setSelection(span1.firstChild, span2.firstChild, 8, 11),
-      () => setSelection(span2.firstChild, span2.firstChild, 0, 11),
-      () => setSelection(span2.firstChild, span2.firstChild, 11, 23),
-      () => setSelection(span2.firstChild, span2.firstChild, 0, 10),
-      () => setSelection(span2.firstChild, span3.firstChild, 12, 7),
-      () => setSelection(span2.firstChild, span2.firstChild, 12, 19),
-      () => setSelection(p1.firstChild, p1.firstChild, 0, 15),
-      () => setSelection(p1.firstChild, p1.firstChild, 16, 31),
-      () => setSelection(p2.firstChild, p2.firstChild, 0, 14),
+      () => setSelection(span1.firstElementChild, span2.firstElementChild, 0, 11),
+      () => setSelection(span1.firstElementChild, span2.firstElementChild, 7, 11),
+      () => setSelection(span1.firstElementChild, span2.firstElementChild, 8, 11),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 0, 11),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 11, 23),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 0, 10),
+      () => setSelection(span2.firstElementChild, span3.firstElementChild, 12, 7),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 12, 19),
+      () => setSelection(p1.firstElementChild, p1.firstElementChild, 0, 15),
+      () => setSelection(p1.firstElementChild, p1.firstElementChild, 16, 31),
+      () => setSelection(p2.firstElementChild, p2.firstElementChild, 0, 14),
       () => {
         selection.selectAllChildren(div2);
         return selection.getRangeAt(0);
       },
       () => {
         selection.selectAllChildren(span4);
         return selection.getRangeAt(0);
       },
diff --git a/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js b/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
--- a/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
+++ b/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
@@ -100,17 +100,17 @@ add_task(async function() {
 
   // First, we'll check that the first tab is actually scrolled
   // at least partially out of view.
   Assert.ok(arrowScrollbox.scrollPosition > 0,
             "First tab should be partially scrolled out of view.");
 
   // Now switch to the first tab. We shouldn't flush layout at all.
   await withPerfObserver(async function() {
-    let firstTab = gBrowser.tabContainer.firstChild;
+    let firstTab = gBrowser.tabContainer.firstElementChild;
     await BrowserTestUtils.switchTab(gBrowser, firstTab);
     await BrowserTestUtils.waitForCondition(() => {
       return gBrowser.tabContainer.arrowScrollbox.hasAttribute("scrolledtostart");
     });
   }, {expectedReflows: [], frames: ignoreTabstripRects});
 
   // Okay, now close the last tab. The tabstrip should stay overflowed, but removing
   // one more after that should underflow it.
diff --git a/browser/base/content/test/performance/browser_urlbar_search.js b/browser/base/content/test/performance/browser_urlbar_search.js
--- a/browser/base/content/test/performance/browser_urlbar_search.js
+++ b/browser/base/content/test/performance/browser_urlbar_search.js
@@ -138,17 +138,17 @@ add_task(async function() {
     URLBar.controller.startSearch(URLBar.value);
     await BrowserTestUtils.waitForEvent(URLBar.popup, "popupshown");
     await BrowserTestUtils.waitForCondition(() => {
       return URLBar.controller.searchStatus >=
         Ci.nsIAutoCompleteController.STATUS_COMPLETE_NO_MATCH;
     });
     let matchCount = URLBar.popup.matchCount;
     await BrowserTestUtils.waitForCondition(() => {
-      return URLBar.popup.richlistbox.childNodes.length == matchCount;
+      return URLBar.popup.richlistbox.children.length == matchCount;
     });
 
     URLBar.controller.stopSearch();
     // There are several setTimeout(fn, 0); calls inside autocomplete.xml
     // that we need to wait for. Since those have higher priority than
     // idle callbacks, we can be sure they will have run once this
     // idle callback is called. The timeout seems to be required in
     // automation - presumably because the machines can be pretty busy
diff --git a/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js b/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js
--- a/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js
+++ b/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js
@@ -75,17 +75,17 @@ function extractCanvasData(grantPermissi
         "privacy.resistFingerprinting = true, permission denied, canvas data == placeholderdata");
   } else {
     is(canvasData, contentWindow.kPlaceholderData,
         "privacy.resistFingerprinting = true, requesting permission, canvas data == placeholderdata");
   }
 }
 
 function triggerCommand(button) {
-  let notifications = PopupNotifications.panel.childNodes;
+  let notifications = PopupNotifications.panel.children;
   let notification = notifications[0];
   EventUtils.synthesizeMouseAtCenter(notification[button], {});
 }
 
 function triggerMainCommand() {
   triggerCommand("button");
 }
 
diff --git a/browser/base/content/test/permissions/browser_permissions.js b/browser/base/content/test/permissions/browser_permissions.js
--- a/browser/base/content/test/permissions/browser_permissions.js
+++ b/browser/base/content/test/permissions/browser_permissions.js
@@ -16,17 +16,17 @@ function closeIdentityPopup() {
   let promise = BrowserTestUtils.waitForEvent(gIdentityHandler._identityPopup, "popuphidden");
   gIdentityHandler._identityPopup.hidePopup();
   return promise;
 }
 
 add_task(async function testMainViewVisible() {
   await BrowserTestUtils.withNewTab(PERMISSIONS_PAGE, async function() {
     let permissionsList = document.getElementById("identity-popup-permission-list");
-    let emptyLabel = permissionsList.nextSibling.nextSibling;
+    let emptyLabel = permissionsList.nextElementSibling.nextElementSibling;
 
     await openIdentityPopup();
 
     ok(!BrowserTestUtils.is_hidden(emptyLabel), "List of permissions is empty");
 
     await closeIdentityPopup();
 
     SitePermissions.set(gBrowser.currentURI, "camera", SitePermissions.ALLOW);
@@ -82,17 +82,17 @@ add_task(async function testIdentityIcon
     SitePermissions.remove(gBrowser.currentURI, "camera");
     SitePermissions.remove(gBrowser.currentURI, "cookie");
   });
 });
 
 add_task(async function testCancelPermission() {
   await BrowserTestUtils.withNewTab(PERMISSIONS_PAGE, async function() {
     let permissionsList = document.getElementById("identity-popup-permission-list");
-    let emptyLabel = permissionsList.nextSibling.nextSibling;
+    let emptyLabel = permissionsList.nextElementSibling.nextElementSibling;
 
     SitePermissions.set(gBrowser.currentURI, "geo", SitePermissions.ALLOW);
     SitePermissions.set(gBrowser.currentURI, "camera", SitePermissions.BLOCK);
 
     await openIdentityPopup();
 
     ok(BrowserTestUtils.is_hidden(emptyLabel), "List of permissions is not empty");
 
diff --git a/browser/base/content/test/permissions/browser_reservedkey.js b/browser/base/content/test/permissions/browser_reservedkey.js
--- a/browser/base/content/test/permissions/browser_reservedkey.js
+++ b/browser/base/content/test/permissions/browser_reservedkey.js
@@ -40,17 +40,17 @@ add_task(async function test_reserved_sh
 
   keyset.appendChild(key1);
   keyset.appendChild(key2);
   keyset.appendChild(key3);
   let container = document.createElement("box");
   container.appendChild(keyset);
   document.documentElement.appendChild(container);
 
-  const pageUrl = "data:text/html,<body onload='document.body.firstChild.focus();'><div onkeydown='event.preventDefault();' tabindex=0>Test</div></body>";
+  const pageUrl = "data:text/html,<body onload='document.body.firstElementChild.focus();'><div onkeydown='event.preventDefault();' tabindex=0>Test</div></body>";
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, pageUrl);
 
   EventUtils.sendString("OPQ");
 
   is(document.getElementById("kt_reserved").getAttribute("count"), "1", "reserved='true' with preference off");
   is(document.getElementById("kt_notreserved").getAttribute("count"), "0", "reserved='false' with preference off");
   is(document.getElementById("kt_reserveddefault").getAttribute("count"), "0", "default reserved with preference off");
 
diff --git a/browser/base/content/test/permissions/browser_temporary_permissions.js b/browser/base/content/test/permissions/browser_temporary_permissions.js
--- a/browser/base/content/test/permissions/browser_temporary_permissions.js
+++ b/browser/base/content/test/permissions/browser_temporary_permissions.js
@@ -52,17 +52,17 @@ add_task(async function testTempPermissi
         frameDoc.getElementById("geo").click();
       });
     });
 
     await popupshown;
 
     let popuphidden = BrowserTestUtils.waitForEvent(PopupNotifications.panel, "popuphidden");
 
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     EventUtils.synthesizeMouseAtCenter(notification.secondaryButton, {});
 
     await popuphidden;
 
     Assert.deepEqual(SitePermissions.get(uri, id, browser), {
       state: SitePermissions.BLOCK,
       scope: SitePermissions.SCOPE_TEMPORARY,
     });
diff --git a/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js b/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js
--- a/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js
+++ b/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js
@@ -52,17 +52,17 @@ add_task(async function testTempPermissi
       await BrowserTestUtils.synthesizeMouseAtCenter(`#${id}`, {}, browser);
 
       await popupshown;
 
       ok(!blockedIcon.hasAttribute("showing"), "blocked permission icon is not shown");
 
       let popuphidden = BrowserTestUtils.waitForEvent(PopupNotifications.panel, "popuphidden");
 
-      let notification = PopupNotifications.panel.firstChild;
+      let notification = PopupNotifications.panel.firstElementChild;
       EventUtils.synthesizeMouseAtCenter(notification.secondaryButton, {});
 
       await popuphidden;
 
       SitePermissions.remove(uri, id, browser);
     });
   }
 });
diff --git a/browser/base/content/test/plugins/browser_CTP_context_menu.js b/browser/base/content/test/plugins/browser_CTP_context_menu.js
--- a/browser/base/content/test/plugins/browser_CTP_context_menu.js
+++ b/browser/base/content/test/plugins/browser_CTP_context_menu.js
@@ -52,17 +52,17 @@ add_task(async function() {
   await promiseForCondition(() => document.getElementById("context-ctp-play"));
 
   let actMenuItem = document.getElementById("context-ctp-play");
   ok(actMenuItem, "Should have a context menu entry for activating the plugin");
 
   // Activate the plugin via the context menu
   EventUtils.synthesizeMouseAtCenter(actMenuItem, {});
 
-  await promiseForCondition(() => !PopupNotifications.panel.dismissed && PopupNotifications.panel.firstChild);
+  await promiseForCondition(() => !PopupNotifications.panel.dismissed && PopupNotifications.panel.firstElementChild);
 
   // Activate the plugin
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   // check plugin state
   pluginInfo = await promiseForPluginInfo("test", gBrowser.selectedBrowser);
   ok(pluginInfo.activated, "plugin should not be activated");
 });
diff --git a/browser/base/content/test/plugins/browser_CTP_crashreporting.js b/browser/base/content/test/plugins/browser_CTP_crashreporting.js
--- a/browser/base/content/test/plugins/browser_CTP_crashreporting.js
+++ b/browser/base/content/test/plugins/browser_CTP_crashreporting.js
@@ -70,17 +70,17 @@ add_task(async function() {
     await promiseUpdatePluginBindings(browser);
 
     let pluginInfo = await promiseForPluginInfo("test", browser);
     ok(!pluginInfo.activated, "Plugin should not be activated");
 
     // Simulate clicking the "Allow Always" button.
     let notification = PopupNotifications.getNotification("click-to-play-plugins", browser);
     await promiseForNotificationShown(notification, browser);
-    PopupNotifications.panel.firstChild.button.click();
+    PopupNotifications.panel.firstElementChild.button.click();
 
     // Prepare a crash report topic observer that only returns when
     // the crash report has been successfully sent.
     let crashReportChecker = (subject, data) => {
       return (data == "success");
     };
     let crashReportPromise = TestUtils.topicObserved("crash-report-status",
                                                      crashReportChecker);
diff --git a/browser/base/content/test/plugins/browser_CTP_drag_drop.js b/browser/base/content/test/plugins/browser_CTP_drag_drop.js
--- a/browser/base/content/test/plugins/browser_CTP_drag_drop.js
+++ b/browser/base/content/test/plugins/browser_CTP_drag_drop.js
@@ -77,19 +77,19 @@ add_task(async function() {
     let bounds = plugin.getBoundingClientRect();
     let left = (bounds.left + bounds.right) / 2;
     let top = (bounds.top + bounds.bottom) / 2;
     let utils = content.windowUtils;
     utils.sendMouseEvent("mousedown", left, top, 0, 1, 0, false, 0, 0);
     utils.sendMouseEvent("mouseup", left, top, 0, 1, 0, false, 0, 0);
   });
 
-  let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gNewWindow.gBrowser.selectedBrowser).dismissed && gNewWindow.PopupNotifications.panel.firstChild;
+  let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gNewWindow.gBrowser.selectedBrowser).dismissed && gNewWindow.PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
 });
 
 add_task(async function() {
   // Click the activate button on doorhanger to make sure it works
-  gNewWindow.PopupNotifications.panel.firstChild.button.click();
+  gNewWindow.PopupNotifications.panel.firstElementChild.button.click();
 
   let pluginInfo = await promiseForPluginInfo("test", gNewWindow.gBrowser.selectedBrowser);
   ok(pluginInfo.activated, "plugin should be activated");
 });
diff --git a/browser/base/content/test/plugins/browser_CTP_notificationBar.js b/browser/base/content/test/plugins/browser_CTP_notificationBar.js
--- a/browser/base/content/test/plugins/browser_CTP_notificationBar.js
+++ b/browser/base/content/test/plugins/browser_CTP_notificationBar.js
@@ -137,16 +137,16 @@ add_task(async function() {
   await promisePopupNotification("click-to-play-plugins");
 
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
   ok(notification, "Test 6, Should have a click-to-play notification");
 
   // simulate "always allow"
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   let notificationBox = gBrowser.getNotificationBox(gTestBrowser);
   await promiseForCondition(() => notificationBox.getNotificationWithValue("plugin-hidden") === null);
 
   let pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 7, plugin should be activated");
 });
diff --git a/browser/base/content/test/plugins/browser_blocking.js b/browser/base/content/test/plugins/browser_blocking.js
--- a/browser/base/content/test/plugins/browser_blocking.js
+++ b/browser/base/content/test/plugins/browser_blocking.js
@@ -129,17 +129,17 @@ add_task(async function() {
     let updateLink = doc.getAnonymousElementByAttribute(plugin, "anonid", "checkForUpdatesLink");
     Assert.ok(updateLink && updateLink.style.display != "block",
       "Test 18c, Plugin should not have an update link");
   });
 
   // check that click "Allow" works with blocked plugins
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   is(pluginInfo.pluginFallbackType, Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_NO_UPDATE,
      "Test 18c, plugin fallback type should be PLUGIN_VULNERABLE_NO_UPDATE");
   ok(pluginInfo.activated, "Test 18c, Plugin should be activated");
   let enabledState = getTestPluginEnabledState();
   ok(enabledState, "Test 18c, Plugin enabled state should be STATE_CLICKTOPLAY");
 });
@@ -219,17 +219,17 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   is(pluginInfo.pluginFallbackType, Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY,
      "Test 24a, plugin fallback type should be PLUGIN_CLICK_TO_PLAY");
   ok(!pluginInfo.activated, "Test 24a, Plugin should not be active.");
 
   // simulate "allow"
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 24a, Plugin should be active.");
 
   await asyncSetAndUpdateBlocklist(gTestRoot + "blockPluginVulnerableUpdatable.xml", gTestBrowser);
 });
 
 // the plugin is now blocklisted, so it should not automatically load
@@ -245,17 +245,17 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   is(pluginInfo.pluginFallbackType, Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE,
      "Test 24b, plugin fallback type should be PLUGIN_VULNERABLE_UPDATABLE");
   ok(!pluginInfo.activated, "Test 24b, Plugin should not be active.");
 
   // simulate "allow"
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 24b, Plugin should be active.");
 
   clearAllPluginPermissions();
 
   await asyncSetAndUpdateBlocklist(gTestRoot + "blockNoPlugins.xml", gTestBrowser);
 });
diff --git a/browser/base/content/test/plugins/browser_bug743421.js b/browser/base/content/test/plugins/browser_bug743421.js
--- a/browser/base/content/test/plugins/browser_bug743421.js
+++ b/browser/base/content/test/plugins/browser_bug743421.js
@@ -53,17 +53,17 @@ add_task(async function() {
     Assert.ok(!objLoadingContent.activated, "Test 1b, Plugin should not be activated");
   });
 
   // Click the activate button on doorhanger to make sure it works
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
 
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   await ContentTask.spawn(gTestBrowser, {}, async function() {
     let plugin = content.document.getElementsByTagName("embed")[0];
     let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
     Assert.ok(objLoadingContent.activated, "Test 1b, Plugin should be activated");
   });
 });
 
diff --git a/browser/base/content/test/plugins/browser_bug787619.js b/browser/base/content/test/plugins/browser_bug787619.js
--- a/browser/base/content/test/plugins/browser_bug787619.js
+++ b/browser/base/content/test/plugins/browser_bug787619.js
@@ -47,18 +47,18 @@ add_task(async function() {
   });
   await promise;
 
   // check plugin state
   pluginInfo = await promiseForPluginInfo("plugin");
   ok(!pluginInfo.activated, "1b plugin should not be activated");
 
   let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser).dismissed &&
-    PopupNotifications.panel.firstChild;
+    PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   // check plugin state
   pluginInfo = await promiseForPluginInfo("plugin");
   ok(pluginInfo.activated, "plugin should be activated");
 
   is(gWrapperClickCount, 0, "wrapper should not have received any clicks");
 });
diff --git a/browser/base/content/test/plugins/browser_pluginnotification.js b/browser/base/content/test/plugins/browser_pluginnotification.js
--- a/browser/base/content/test/plugins/browser_pluginnotification.js
+++ b/browser/base/content/test/plugins/browser_pluginnotification.js
@@ -63,25 +63,25 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   ok(!pluginInfo.activated, "Plugin should not be activated");
 
   // Simulate clicking the "Allow" button.
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
 
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Plugin should be activated");
 
   // Simulate clicking the "Block" button.
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.secondaryButton.click();
+  PopupNotifications.panel.firstElementChild.secondaryButton.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(!pluginInfo.activated, "Plugin should not be activated");
 
   let browserLoaded = BrowserTestUtils.browserLoaded(gTestBrowser);
   gTestBrowser.reload();
   await browserLoaded;
   notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
@@ -139,17 +139,17 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   ok(!pluginInfo.activated, "Test 12a, Plugin should not be activated");
 
   // Simulate clicking the "Allow" button.
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
 
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 12a, Plugin should be activated");
 });
 
 // Test that the "Always" permission, when set for just the Test plugin,
 // does not also allow the Second Test plugin.
 add_task(async function() {
@@ -288,19 +288,19 @@ add_task(async function() {
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let utils = content.windowUtils;
     utils.sendMouseEvent("mousedown", 50, 50, 0, 1, 0, false, 0, 0);
     utils.sendMouseEvent("mouseup", 50, 50, 0, 1, 0, false, 0, 0);
   });
 
   let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser).dismissed &&
-    PopupNotifications.panel.firstChild;
+    PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 19e, Plugin should not be activated");
 
   clearAllPluginPermissions();
 });
 
 // Tests that a plugin in a div that goes from style="display: none" to
@@ -368,19 +368,19 @@ add_task(async function() {
     let bounds = plugin.getBoundingClientRect();
     let left = (bounds.left + bounds.right) / 2;
     let top = (bounds.top + bounds.bottom) / 2;
     let utils = content.windowUtils;
     utils.sendMouseEvent("mousedown", left, top, 0, 1, 0, false, 0, 0);
     utils.sendMouseEvent("mouseup", left, top, 0, 1, 0, false, 0, 0);
   });
 
-  let condition = () => !notification.dismissed && !!PopupNotifications.panel.firstChild;
+  let condition = () => !notification.dismissed && !!PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 20c, plugin should be activated");
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let doc = content.document;
     let plugin = doc.getElementById("test");
     let overlayRect = doc.getAnonymousElementByAttribute(plugin, "anonid", "main").getBoundingClientRect();
diff --git a/browser/base/content/test/plugins/browser_private_clicktoplay.js b/browser/base/content/test/plugins/browser_private_clicktoplay.js
--- a/browser/base/content/test/plugins/browser_private_clicktoplay.js
+++ b/browser/base/content/test/plugins/browser_private_clicktoplay.js
@@ -62,17 +62,17 @@ add_task(async function test1b() {
   });
 
   // Check the button status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
 
   await promiseShown;
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.checkbox.hidden, true, "'Remember' checkbox should be hidden in private windows");
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.checkbox.hidden, true, "'Remember' checkbox should be hidden in private windows");
 
   gPrivateWindow.close();
   BrowserTestUtils.loadURI(gTestBrowser, gHttpTestRoot + "plugin_test.html");
   await BrowserTestUtils.browserLoaded(gTestBrowser);
 });
 
 add_task(async function test2a() {
   // enable test plugin on this site
@@ -86,17 +86,17 @@ add_task(async function test2a() {
   });
 
   // Simulate clicking the "Allow Now" button.
   let promiseShown = BrowserTestUtils.waitForEvent(PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let plugin = content.document.getElementById("test");
     let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
     let condition = () => objLoadingContent.activated;
     await ContentTaskUtils.waitForCondition(condition, "Test 2a, Waited too long for plugin to activate");
   });
 });
@@ -115,19 +115,19 @@ add_task(async function test2c() {
     ok(objLoadingContent.activated, "Test 2c, Plugin should be activated");
   });
 
   // Check the button status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.secondaryButton.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.secondaryButton.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Block' button.");
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.checkbox.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.checkbox.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Remember' checkbox.");
 
   clearAllPluginPermissions();
   gPrivateWindow.close();
 
   BrowserTestUtils.loadURI(gTestBrowser, gHttpTestRoot + "plugin_test.html");
   await BrowserTestUtils.browserLoaded(gTestBrowser);
 });
@@ -143,17 +143,17 @@ add_task(async function test3a() {
     ok(!objLoadingContent.activated, "Test 3a, Plugin should not be activated");
   });
 
   // Simulate clicking the "Allow" button.
   let promiseShown = BrowserTestUtils.waitForEvent(PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let plugin = content.document.getElementById("test");
     let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
     let condition = () => objLoadingContent.activated;
     await ContentTaskUtils.waitForCondition(condition, "Test 3a, Waited too long for plugin to activate");
   });
 });
@@ -166,36 +166,36 @@ add_task(async function test3c() {
   let popupNotification = gPrivateWindow.PopupNotifications.getNotification("click-to-play-plugins", gPrivateBrowser);
   ok(popupNotification, "Test 3c, Should have a click-to-play notification");
 
   // Check the button status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.secondaryButton.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.secondaryButton.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Block' button.");
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.checkbox.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.checkbox.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Remember' checkbox.");
 
   BrowserTestUtils.loadURI(gPrivateBrowser, gHttpTestRoot + "plugin_two_types.html");
   await BrowserTestUtils.browserLoaded(gPrivateBrowser);
 });
 
 add_task(async function test3d() {
   let popupNotification = gPrivateWindow.PopupNotifications.getNotification("click-to-play-plugins", gPrivateBrowser);
   ok(popupNotification, "Test 3d, Should have a click-to-play notification");
 
   // Check the list item status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
   let doc = gPrivateWindow.document;
-  for (let item of gPrivateWindow.PopupNotifications.panel.firstChild.childNodes) {
+  for (let item of gPrivateWindow.PopupNotifications.panel.firstElementChild.children) {
     let allowalways = doc.getAnonymousElementByAttribute(item, "anonid", "allowalways");
     ok(allowalways, "Test 3d, should have list item for allow always");
     let allownow = doc.getAnonymousElementByAttribute(item, "anonid", "allownow");
     ok(allownow, "Test 3d, should have list item for allow now");
     let block = doc.getAnonymousElementByAttribute(item, "anonid", "block");
     ok(block, "Test 3d, should have list item for block");
 
     if (item.action.pluginName === "Test") {
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification.js b/browser/base/content/test/popupNotifications/browser_popupNotification.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification.js
@@ -184,22 +184,22 @@ var tests = [
       this.testNotif1.message += " 1";
       showNotification(this.testNotif1);
       this.testNotif2 = new BasicNotification(this.id);
       this.testNotif2.message += " 2";
       this.testNotif2.id += "-2";
       showNotification(this.testNotif2);
     },
     onShown(popup) {
-      is(popup.childNodes.length, 2, "two notifications are shown");
+      is(popup.children.length, 2, "two notifications are shown");
       // Trigger the main command for the first notification, and the secondary
       // for the second. Need to do mainCommand first since the secondaryCommand
       // triggering is async.
       triggerMainCommand(popup);
-      is(popup.childNodes.length, 1, "only one notification left");
+      is(popup.children.length, 1, "only one notification left");
       triggerSecondaryCommand(popup, 0);
     },
     onHidden(popup) {
       ok(this.testNotif1.mainActionClicked, "main action #1 was clicked");
       ok(!this.testNotif1.secondaryActionClicked, "secondary action #1 wasn't clicked");
       ok(!this.testNotif1.dismissalCallbackTriggered, "dismissal callback #1 wasn't called");
 
       ok(!this.testNotif2.mainActionClicked, "main action #2 wasn't clicked");
@@ -212,17 +212,17 @@ var tests = [
   { id: "Test#9",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.mainAction = null;
       this.notifyObj.secondaryActions = null;
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       is(notification.getAttribute("buttonhighlight"), "true", "default action is highlighted");
       triggerMainCommand(popup);
     },
     onHidden(popup) {
       ok(!this.notifyObj.mainActionClicked, "mainAction was not clicked");
       ok(!this.notifyObj.dismissalCallbackTriggered, "dismissal callback wasn't triggered");
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
     }
@@ -232,17 +232,17 @@ var tests = [
   // and ignore the passed secondaryActions.
   { id: "Test#10",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.mainAction = null;
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       is(notification.getAttribute("secondarybuttonhidden"), "true", "secondary button is hidden");
       is(notification.getAttribute("buttonhighlight"), "true", "default action is highlighted");
       triggerMainCommand(popup);
     },
     onHidden(popup) {
       ok(!this.notifyObj.mainActionClicked, "mainAction was not clicked");
       ok(!this.notifyObj.dismissalCallbackTriggered, "dismissal callback wasn't triggered");
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_2.js b/browser/base/content/test/popupNotifications/browser_popupNotification_2.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_2.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_2.js
@@ -200,17 +200,17 @@ var tests = [
   // Test notification close button
   { id: "Test#9",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       EventUtils.synthesizeMouseAtCenter(notification.closebutton, {});
     },
     onHidden(popup) {
       ok(this.notifyObj.dismissalCallbackTriggered, "dismissal callback triggered");
       this.notification.remove();
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
       ok(!this.notifyObj.secondaryActionClicked, "secondary action not clicked");
     }
@@ -220,17 +220,17 @@ var tests = [
   { id: "Test#10",
     run() {
       Services.prefs.setBoolPref("privacy.permissionPrompts.showCloseButton", true);
       this.notifyObj = new BasicNotification(this.id);
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       EventUtils.synthesizeMouseAtCenter(notification.closebutton, {});
     },
     onHidden(popup) {
       ok(!this.notifyObj.dismissalCallbackTriggered, "dismissal callback not triggered");
       ok(this.notifyObj.secondaryActionClicked, "secondary action clicked");
       Services.prefs.clearUserPref("privacy.permissionPrompts.showCloseButton");
       this.notification.remove();
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_3.js b/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
@@ -284,17 +284,17 @@ var tests = [
         info("notifyObj2.options.eventCallback: " + eventName);
         if (eventName == "dismissed") {
           throw new Error("Oops 2!");
         }
       };
       this.notification2 = showNotification(this.testNotif2);
     },
     onShown(popup) {
-      is(popup.childNodes.length, 2, "two notifications are shown");
+      is(popup.children.length, 2, "two notifications are shown");
       dismissNotification(popup);
     },
     onHidden() {
       this.notification1.remove();
       this.notification2.remove();
     }
   }
 ];
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_4.js b/browser/base/content/test/popupNotifications/browser_popupNotification_4.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_4.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_4.js
@@ -106,17 +106,17 @@ var tests = [
       await shown;
 
       let promiseWin = BrowserTestUtils.waitForNewWindow();
       gBrowser.replaceTabWithWindow(gBrowser.selectedTab);
       let win = await promiseWin;
 
       let anchor = win.document.getElementById("default-notification-icon");
       win.PopupNotifications._reshowNotifications(anchor);
-      ok(win.PopupNotifications.panel.childNodes.length == 0,
+      ok(win.PopupNotifications.panel.children.length == 0,
          "no notification displayed in new window");
       ok(notifyObj.swappingCallbackTriggered, "the swapping callback was triggered");
       ok(notifyObj.removedCallbackTriggered, "the removed callback was triggered");
 
       await BrowserTestUtils.closeWindow(win);
       await waitForWindowReadyForPopupNotifications(window);
 
       goNext();
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_5.js b/browser/base/content/test/popupNotifications/browser_popupNotification_5.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_5.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_5.js
@@ -161,17 +161,17 @@ var tests = [
       gBrowser.removeTab(gBrowser.selectedTab);
       gBrowser.selectedTab = this.oldSelectedTab;
     }
   },
   // Second part of the previous test that compensates for the limitation in
   // runNextTest that expects a single onShown/onHidden invocation per test.
   { id: "Test#6b",
     run() {
-      let id = PopupNotifications.panel.firstChild.getAttribute("popupid");
+      let id = PopupNotifications.panel.firstElementChild.getAttribute("popupid");
       ok(id.endsWith("Test#6a"), "Should have found the notification from Test6a");
       ok(PopupNotifications.isPanelOpen, "Should have shown the popup again after getting back to the tab");
       gNotification.remove();
       gNotification = null;
       goNext();
     }
   },
   // Test that persistent panels are still open after switching to another
@@ -198,23 +198,23 @@ var tests = [
       let timeShown = this.notification.timeShown;
 
       let promiseWin = BrowserTestUtils.waitForNewWindow();
       gBrowser.replaceTabWithWindow(firstTab);
       let win = await promiseWin;
 
       let anchor = win.document.getElementById("default-notification-icon");
       win.PopupNotifications._reshowNotifications(anchor);
-      ok(win.PopupNotifications.panel.childNodes.length == 0,
+      ok(win.PopupNotifications.panel.children.length == 0,
          "no notification displayed in new window");
 
       await BrowserTestUtils.closeWindow(win);
       await waitForWindowReadyForPopupNotifications(window);
 
-      let id = PopupNotifications.panel.firstChild.getAttribute("popupid");
+      let id = PopupNotifications.panel.firstElementChild.getAttribute("popupid");
       ok(id.endsWith("Test#7"), "Should have found the notification from Test7");
       ok(PopupNotifications.isPanelOpen,
          "Should have kept the popup on the first window");
       ok(!notifyObj.dismissalCallbackTriggered,
          "Should not have triggered a dismissed event");
       ok(!notifyObj.shownCallbackTriggered,
          "Should not have triggered a second shown event");
       ok(!notifyObj.showingCallbackTriggered,
@@ -272,17 +272,17 @@ var tests = [
       this.notifyObj3.id += "_3";
       this.notifyObj3.anchorID = "default-notification-icon";
       this.notifyObj3.options.persistent = true;
       this.notification3 = showNotification(this.notifyObj3);
 
       PopupNotifications._update();
     },
     onShown(popup) {
-      let notifications = popup.childNodes;
+      let notifications = popup.children;
       is(notifications.length, 2, "two notifications displayed");
       let [notification1, notification2] = notifications;
       is(notification1.id, this.notifyObj1.id + "-notification", "id 1 matches");
       is(notification2.id, this.notifyObj3.id + "-notification", "id 2 matches");
 
       this.notification1.remove();
       this.notification2.remove();
       this.notification3.remove();
@@ -312,22 +312,22 @@ var tests = [
       this.notifyObj3.anchorID = "geo-notification-icon";
       this.notifyObj3.options.persistent = true;
       this.notifyObj3.options.hideClose = false;
       this.notification3 = showNotification(this.notifyObj3);
 
       PopupNotifications._update();
     },
     onShown(popup) {
-      let notifications = popup.childNodes;
+      let notifications = popup.children;
       is(notifications.length, 3, "three notifications displayed");
       EventUtils.synthesizeMouseAtCenter(notifications[1].closebutton, {});
     },
     onHidden(popup) {
-      let notifications = popup.childNodes;
+      let notifications = popup.children;
       is(notifications.length, 2, "two notifications displayed");
 
       ok(this.notification1.options.persistent, "notification 1 is persistent");
       ok(!this.notification2.options.persistent, "notification 2 is not persistent");
       ok(this.notification3.options.persistent, "notification 3 is persistent");
 
       this.notification1.remove();
       this.notification2.remove();
@@ -363,17 +363,17 @@ var tests = [
          "Should not have dismissed the notification");
       notifyObj1.shownCallbackTriggered = false;
       notifyObj1.showingCallbackTriggered = false;
 
       // Click the anchor. This should focus the closebutton
       // (because it's the first focusable element), but not
       // call event callbacks on the notification object.
       clickAnchor(notifyObj1);
-      is(document.activeElement, popup.childNodes[0].closebutton);
+      is(document.activeElement, popup.children[0].closebutton);
       ok(!notifyObj1.dismissalCallbackTriggered,
          "Should not have dismissed the notification");
       ok(!notifyObj1.shownCallbackTriggered,
          "Should have triggered the shown event again");
       ok(!notifyObj1.showingCallbackTriggered,
          "Should have triggered the showing event again");
 
       // Add another notification.
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js b/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
@@ -41,17 +41,17 @@ var tests = [
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       checkCheckbox(notification.checkbox, "This is a checkbox");
       triggerMainCommand(popup);
     },
     onHidden() { }
   },
 
   // Test checkbox being checked by default
   { id: "checkbox_checked",
@@ -60,17 +60,17 @@ var tests = [
       this.notifyObj.options.checkbox = {
         label: "Check this",
         checked: true,
       };
       gNotification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       checkCheckbox(notification.checkbox, "Check this", true);
       triggerMainCommand(popup);
     },
     onHidden() { }
   },
 
   // Test checkbox passing the checkbox state on mainAction
   { id: "checkbox_passCheckboxChecked_mainAction",
@@ -79,17 +79,17 @@ var tests = [
       this.notifyObj.mainAction.callback = ({checkboxChecked}) => this.mainActionChecked = checkboxChecked;
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox");
       await promiseElementVisible(checkbox);
       EventUtils.synthesizeMouseAtCenter(checkbox, {});
       checkCheckbox(checkbox, "This is a checkbox", true);
       triggerMainCommand(popup);
     },
     onHidden() {
@@ -108,17 +108,17 @@ var tests = [
       }];
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox");
       await promiseElementVisible(checkbox);
       EventUtils.synthesizeMouseAtCenter(checkbox, {});
       checkCheckbox(checkbox, "This is a checkbox", true);
       triggerSecondaryCommand(popup, 0);
     },
     onHidden() {
@@ -136,46 +136,46 @@ var tests = [
           disableMainAction: true,
           warningLabel: "Testing disable",
         },
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox");
       await promiseElementVisible(checkbox);
       EventUtils.synthesizeMouseAtCenter(checkbox, {});
       dismissNotification(popup);
     },
     async onHidden(popup) {
       let icon = document.getElementById("default-notification-icon");
       let shown = waitForNotificationPanel();
       EventUtils.synthesizeMouseAtCenter(icon, {});
       await shown;
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox", true);
       checkMainAction(notification, true);
       gNotification.remove();
     }
   },
 
   // Test no checkbox hides warning label
   { id: "no_checkbox",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.options.checkbox = null;
       gNotification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       checkCheckbox(notification.checkbox, "", false, true);
       checkMainAction(notification);
       triggerMainCommand(popup);
     },
     onHidden() { },
   },
 ];
 
@@ -193,17 +193,17 @@ var tests = [
               disableMainAction: true,
               warningLabel: "Testing disable",
             },
           };
           gNotification = showNotification(this.notifyObj);
         },
         async onShown(popup) {
           checkPopup(popup, this.notifyObj);
-          let notification = popup.childNodes[0];
+          let notification = popup.children[0];
           let checkbox = notification.checkbox;
           let disabled = (state === "checkedState" && checked) ||
                          (state === "uncheckedState" && !checked);
 
           checkCheckbox(checkbox, "This is a checkbox", checked);
           checkMainAction(notification, disabled);
           await promiseElementVisible(checkbox);
           EventUtils.synthesizeMouseAtCenter(checkbox, {});
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js b/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js
@@ -66,17 +66,17 @@ var tests = [
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
       let anchor = document.getElementById(this.notifyObj.anchorID);
       anchor.focus();
       is(document.activeElement, anchor);
       EventUtils.sendString(" ");
-      is(document.activeElement, popup.childNodes[0].closebutton);
+      is(document.activeElement, popup.children[0].closebutton);
       this.notification.remove();
     },
     onHidden(popup) { }
   },
   // Test that you can switch between active notifications with the space key
   // and that the notification is focused on selection.
   { id: "Test#4",
     async run() {
@@ -111,28 +111,28 @@ var tests = [
       let anchor = document.getElementById(notifyObj1.anchorID);
       anchor.focus();
       is(document.activeElement, anchor);
       opened = waitForNotificationPanel();
       EventUtils.sendString(" ");
       popup = await opened;
       checkPopup(popup, notifyObj1);
 
-      is(document.activeElement, popup.childNodes[0].checkbox);
+      is(document.activeElement, popup.children[0].checkbox);
 
       // Activate the anchor for notification 2 and wait until it's shown.
       anchor = document.getElementById(notifyObj2.anchorID);
       anchor.focus();
       is(document.activeElement, anchor);
       opened = waitForNotificationPanel();
       EventUtils.sendString(" ");
       popup = await opened;
       checkPopup(popup, notifyObj2);
 
-      is(document.activeElement, popup.childNodes[0].closebutton);
+      is(document.activeElement, popup.children[0].closebutton);
 
       notification1.remove();
       notification2.remove();
       goNext();
     },
   },
   // Test that passing the autofocus option will focus an opened notification.
   { id: "Test#5",
@@ -147,17 +147,17 @@ var tests = [
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
 
       // Initial focus on open is null because a panel itself
       // can not be focused, next tab focus will be inside the panel.
       is(Services.focus.focusedElement, null);
 
       EventUtils.synthesizeKey("KEY_Tab");
-      is(Services.focus.focusedElement, popup.childNodes[0].closebutton);
+      is(Services.focus.focusedElement, popup.children[0].closebutton);
       dismissNotification(popup);
     },
     async onHidden() {
       // Focus the urlbar to check that it stays focused.
       gURLBar.focus();
 
       // Show another notification and make sure it's not autofocused.
       let notifyObj = new BasicNotification(this.id);
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js b/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js
@@ -28,17 +28,17 @@ var tests = [
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       notification.setAttribute("invalidselection", true);
       await promiseElementVisible(notification.checkbox);
       EventUtils.synthesizeMouseAtCenter(notification.checkbox, {});
       ok(notification.button.disabled, "should be disabled when invalidselection");
       notification.removeAttribute("invalidselection");
       EventUtils.synthesizeMouseAtCenter(notification.checkbox, {});
       ok(!notification.button.disabled, "should not be disabled when invalidselection is not present");
       triggerMainCommand(popup);
diff --git a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js
--- a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js
+++ b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js
@@ -22,19 +22,19 @@ function startNewTabTestCase(aTestNumber
                                     startNewTabTestCase);
     });
 
     let menu = gTestWindow.document.getElementById("context-openlinkinusercontext-menu");
 
     let menupopup = menu.menupopup;
     menu.addEventListener("popupshown", function() {
       is(menupopup.nodeType, Node.ELEMENT_NODE, "We have a menupopup.");
-      ok(menupopup.firstChild, "We have a first container entry.");
+      ok(menupopup.firstElementChild, "We have a first container entry.");
 
-      let firstContext = menupopup.firstChild;
+      let firstContext = menupopup.firstElementChild;
       is(firstContext.nodeType, Node.ELEMENT_NODE, "We have a first container entry.");
       ok(firstContext.hasAttribute("data-usercontextid"), "We have a usercontextid value.");
 
       aContextMenu.addEventListener("popuphidden", function() {
         firstContext.doCommand();
       }, {once: true});
 
       aContextMenu.hidePopup();
diff --git a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js
--- a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js
+++ b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js
@@ -17,19 +17,19 @@ function startNewTabTestCase(aTestNumber
                                     startNewTabTestCase, { userContextId: 2 });
     });
 
     let menu = gTestWindow.document.getElementById("context-openlinkinusercontext-menu");
 
     let menupopup = menu.menupopup;
     menu.addEventListener("popupshown", function() {
       is(menupopup.nodeType, Node.ELEMENT_NODE, "We have a menupopup.");
-      ok(menupopup.firstChild, "We have a first container entry.");
+      ok(menupopup.firstElementChild, "We have a first container entry.");
 
-      let firstContext = menupopup.firstChild;
+      let firstContext = menupopup.firstElementChild;
       is(firstContext.nodeType, Node.ELEMENT_NODE, "We have a first container entry.");
       ok(firstContext.hasAttribute("data-usercontextid"), "We have a usercontextid value.");
       is("0", firstContext.getAttribute("data-usercontextid"), "We have the right usercontextid value.");
 
       aContextMenu.addEventListener("popuphidden", function() {
         firstContext.doCommand();
       }, {once: true});
 
diff --git a/browser/base/content/test/sidebar/browser_sidebar_move.js b/browser/base/content/test/sidebar/browser_sidebar_move.js
--- a/browser/base/content/test/sidebar/browser_sidebar_move.js
+++ b/browser/base/content/test/sidebar/browser_sidebar_move.js
@@ -17,17 +17,17 @@ const EXPECTED_END_ORDINALS = [
   ["sidebar-box", 4],
   ["sidebar-splitter", 3],
   ["appcontent", 2],
   ["browser-border-end", 5],
 ];
 
 function getBrowserChildrenWithOrdinals() {
   let browser = document.getElementById("browser");
-  return [...browser.childNodes].map(node => {
+  return [...browser.children].map(node => {
     return [node.id, node.ordinal];
   });
 }
 
 add_task(async function() {
   await SidebarUI.show("viewBookmarksSidebar");
   SidebarUI.showSwitcherPanel();
 
diff --git a/browser/base/content/test/tabs/browser_overflowScroll.js b/browser/base/content/test/tabs/browser_overflowScroll.js
--- a/browser/base/content/test/tabs/browser_overflowScroll.js
+++ b/browser/base/content/test/tabs/browser_overflowScroll.js
@@ -69,17 +69,17 @@ add_task(async function() {
 
   element = nextLeftElement();
   EventUtils.synthesizeMouseAtCenter(upButton, {});
   await waitForNextFrame();
   isLeft(element, "Scrolled one tab to the left with a single click");
 
   let elementPoint = left(scrollbox) - width(scrollbox);
   element = elementFromPoint(elementPoint);
-  element = element.nextSibling;
+  element = element.nextElementSibling;
 
   EventUtils.synthesizeMouseAtCenter(upButton, {clickCount: 2});
   await waitForNextFrame();
   await BrowserTestUtils.waitForCondition(() =>
     !gBrowser.tabContainer.arrowScrollbox._isScrolling);
   isLeft(element, "Scrolled one page of tabs with a double click");
 
   EventUtils.synthesizeMouseAtCenter(upButton, {clickCount: 3});
diff --git a/browser/base/content/test/urlbar/browser_action_keyword.js b/browser/base/content/test/urlbar/browser_action_keyword.js
--- a/browser/base/content/test/urlbar/browser_action_keyword.js
+++ b/browser/base/content/test/urlbar/browser_action_keyword.js
@@ -1,12 +1,12 @@
 async function promise_first_result(inputText) {
   await promiseAutocompleteResultPopup(inputText);
 
-  let firstResult = gURLBar.popup.richlistbox.firstChild;
+  let firstResult = gURLBar.popup.richlistbox.firstElementChild;
   return firstResult;
 }
 
 const TEST_URL = "http://mochi.test:8888/browser/browser/base/content/test/urlbar/print_postdata.sjs";
 
 add_task(async function setup() {
   await PlacesUtils.keywords.insert({ keyword: "get",
                                       url: TEST_URL + "?q=%s" });
diff --git a/browser/base/content/test/urlbar/browser_locationBarCommand.js b/browser/base/content/test/urlbar/browser_locationBarCommand.js
--- a/browser/base/content/test/urlbar/browser_locationBarCommand.js
+++ b/browser/base/content/test/urlbar/browser_locationBarCommand.js
@@ -83,17 +83,17 @@ add_task(async function shift_accel_left
 
   // Check the load occurred in a new background tab.
   info("URL should be loaded in a new background tab");
   is(gURLBar.value, "", "Urlbar reverted to original value");
   ok(!gURLBar.focused, "Urlbar is no longer focused after urlbar command");
   is(gBrowser.selectedTab, tab, "Focus did not change to the new tab");
 
   // Select the new background tab
-  gBrowser.selectedTab = gBrowser.selectedTab.nextSibling;
+  gBrowser.selectedTab = gBrowser.selectedTab.nextElementSibling;
   is(gURLBar.value, TEST_VALUE, "New URL is loaded in new tab");
 
   // Cleanup.
   gBrowser.removeCurrentTab();
   gBrowser.removeCurrentTab();
 });
 
 add_task(async function load_in_current_tab_test() {
diff --git a/browser/base/content/test/urlbar/browser_page_action_menu.js b/browser/base/content/test/urlbar/browser_page_action_menu.js
--- a/browser/base/content/test/urlbar/browser_page_action_menu.js
+++ b/browser/base/content/test/urlbar/browser_page_action_menu.js
@@ -750,20 +750,20 @@ function promiseSyncReady() {
   });
 }
 
 function checkSendToDeviceItems(expectedItems, forUrlbar = false) {
   let bodyID =
     BrowserPageActions._panelViewNodeIDForActionID("sendToDevice", forUrlbar) +
     "-body";
   let body = document.getElementById(bodyID);
-  Assert.equal(body.childNodes.length, expectedItems.length);
+  Assert.equal(body.children.length, expectedItems.length);
   for (let i = 0; i < expectedItems.length; i++) {
     let expected = expectedItems[i];
-    let actual = body.childNodes[i];
+    let actual = body.children[i];
     if (!expected) {
       Assert.equal(actual.localName, "toolbarseparator");
       continue;
     }
     if ("id" in expected) {
       Assert.equal(actual.id, expected.id);
     }
     if ("className" in expected) {
@@ -787,12 +787,12 @@ function checkSendToDeviceItems(expected
         Assert.equal(attrVal, expected.attrs[name]);
       }
     }
   }
 }
 
 function collectContextMenuItems() {
   let contextMenu = document.getElementById("pageActionContextMenu");
-  return Array.filter(contextMenu.childNodes, node => {
+  return Array.filter(contextMenu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 }
diff --git a/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js b/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js
--- a/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js
+++ b/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js
@@ -113,59 +113,59 @@ add_task(async function many() {
     EventUtils.synthesizeMouseAtCenter(button, {});
     let view = await viewPromise;
     let viewID =
        BrowserPageActions._panelViewNodeIDForActionID("addSearchEngine", false);
     Assert.equal(view.id, viewID, "View ID");
     let bodyID = viewID + "-body";
     let body = document.getElementById(bodyID);
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the first engine to install it.
     let enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_0");
     let hiddenPromise = promisePageActionPanelHidden();
     let feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     let engines = [];
     let engine = await enginePromise;
     engines.push(engine);
     let feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Open the panel and show the subview again.  The installed engine should
     // be gone.
     await promisePageActionPanelOpen();
     viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(button, {});
     await viewPromise;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the next engine to install it.
     enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_1");
     hiddenPromise = promisePageActionPanelHidden();
     feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     engine = await enginePromise;
     engines.push(engine);
     feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Open the panel again.  This time the action button should show the one
     // remaining engine.
@@ -245,17 +245,17 @@ add_task(async function many() {
     Assert.equal(button.label, expectedTitle, "Button label");
     Assert.equal(button.classList.contains("subviewbutton-nav"), true,
                  "Button should expand into a subview");
     viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(button, {});
     await viewPromise;
     body = document.getElementById(bodyID);
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
       ],
       "Subview children"
     );
     EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
     await promisePageActionPanelHidden();
@@ -267,17 +267,17 @@ add_task(async function many() {
     await enginePromise;
 
     // Open the panel again and check the subview.
     await promisePageActionPanelOpen();
     viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(button, {});
     await viewPromise;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
     EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
@@ -361,61 +361,61 @@ add_task(async function urlbarMany() {
 
     // Click the action's button.  The activated-action panel should open, and
     // it should contain the addSearchEngine subview.
     EventUtils.synthesizeMouseAtCenter(button, {});
     let view = await waitForActivatedActionPanel();
     let viewID =
        BrowserPageActions._panelViewNodeIDForActionID("addSearchEngine", true);
     Assert.equal(view.id, viewID, "View ID");
-    let body = view.firstChild;
+    let body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the first engine to install it.
     let enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_0");
     let hiddenPromise =
       promisePanelHidden(BrowserPageActions.activatedActionPanelNode);
     let feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     let engines = [];
     let engine = await enginePromise;
     engines.push(engine);
     let feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Open the panel again.  The installed engine should be gone.
     EventUtils.synthesizeMouseAtCenter(button, {});
     view = await waitForActivatedActionPanel();
-    body = view.firstChild;
+    body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the next engine to install it.
     enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_1");
     hiddenPromise =
       promisePanelHidden(BrowserPageActions.activatedActionPanelNode);
     feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     engine = await enginePromise;
     engines.push(engine);
     feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Now there's only one engine left, so clicking the button should simply
     // install it instead of opening the activated-action panel.
@@ -454,19 +454,19 @@ add_task(async function urlbarMany() {
       promiseEngine("engine-removed", "page_action_menu_add_search_engine_1");
     Services.search.removeEngine(engines.shift());
     await enginePromise;
 
     // Open the panel again and check the subview.  The subview should be
     // present now that there are two offered engines again.
     EventUtils.synthesizeMouseAtCenter(button, {});
     view = await waitForActivatedActionPanel();
-    body = view.firstChild;
+    body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
       ],
       "Subview children"
     );
 
     // Hide the panel.
@@ -479,19 +479,19 @@ add_task(async function urlbarMany() {
     enginePromise =
       promiseEngine("engine-removed", "page_action_menu_add_search_engine_2");
     Services.search.removeEngine(engines.shift());
     await enginePromise;
 
     // Open the panel again and check the subview.
     EventUtils.synthesizeMouseAtCenter(button, {});
     view = await waitForActivatedActionPanel();
-    body = view.firstChild;
+    body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
diff --git a/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js b/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js
--- a/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js
+++ b/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js
@@ -52,18 +52,18 @@ add_task(async function shareURL() {
     let shareURLButton = document.getElementById("pageAction-panel-shareURL");
     let viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(shareURLButton, {});
 
     let view = await viewPromise;
     let body = document.getElementById(view.id + "-body");
 
     // We should see 1 receiver and one extra node for the "More..." button
-    Assert.equal(body.childNodes.length, 2, "Has correct share receivers");
-    let shareButton = body.childNodes[0];
+    Assert.equal(body.children.length, 2, "Has correct share receivers");
+    let shareButton = body.children[0];
     Assert.equal(shareButton.label, mockShareData[0].menuItemTitle);
     let hiddenPromise = promisePageActionPanelHidden();
     // Click on share, panel should hide and sharingService should be
     // given the title of service to share with
     EventUtils.synthesizeMouseAtCenter(shareButton, {});
     await hiddenPromise;
 
     Assert.equal(serviceName, mockShareData[0].name,
@@ -106,17 +106,17 @@ add_task(async function shareURLAddressB
     let shareButton = document.getElementById("pageAction-urlbar-shareURL");
     let viewPromise = promisePageActionPanelShown();
     EventUtils.synthesizeMouseAtCenter(shareButton, {});
     await viewPromise;
 
     // Ensure we have share providers
     let panel = document.getElementById("pageAction-urlbar-shareURL-subview-body");
     // We should see 1 receiver and one extra node for the "More..." button
-    Assert.equal(panel.childNodes.length, 2, "Has correct share receivers");
+    Assert.equal(panel.children.length, 2, "Has correct share receivers");
 
     // Remove the Share URL button from the Address bar so we dont interfere
     // with future tests
     contextMenuPromise = promisePanelShown("pageActionContextMenu");
     EventUtils.synthesizeMouseAtCenter(shareButton, {
       type: "contextmenu",
       button: 2,
     });
@@ -139,18 +139,18 @@ add_task(async function openSharingPrefe
     let shareURLButton = document.getElementById("pageAction-panel-shareURL");
     let viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(shareURLButton, {});
 
     let view = await viewPromise;
     let body = document.getElementById(view.id + "-body");
 
     // We should see 1 receiver and one extra node for the "More..." button
-    Assert.equal(body.childNodes.length, 2, "Has correct share receivers");
-    let moreButton = body.childNodes[1];
+    Assert.equal(body.children.length, 2, "Has correct share receivers");
+    let moreButton = body.children[1];
     let hiddenPromise = promisePageActionPanelHidden();
     // Click on the "more" button,  panel should hide and we should call
     // the sharingService function to open preferences
     EventUtils.synthesizeMouseAtCenter(moreButton, {});
     await hiddenPromise;
 
     Assert.equal(sharingPreferencesCalled, true,
                  "We called openSharingPreferences");
diff --git a/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js b/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js
--- a/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js
+++ b/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js
@@ -96,17 +96,17 @@ add_task(async function dontTemporarilyS
       is(win.gURLBar.value, "", "URL bar value should stay empty.");
     },
   };
   win.gBrowser.addProgressListener(wpl);
 
   if (win.gBrowser.visibleTabs.length < 2) {
     await BrowserTestUtils.waitForEvent(gBrowser.tabContainer, "TabOpen");
   }
-  let otherTab = win.gBrowser.selectedTab.previousSibling;
+  let otherTab = win.gBrowser.selectedTab.previousElementSibling;
   let tabLoaded = BrowserTestUtils.browserLoaded(otherTab.linkedBrowser, false, "about:home");
   await BrowserTestUtils.switchTab(win.gBrowser, otherTab);
   await tabLoaded;
   win.gBrowser.removeProgressListener(wpl);
   is(win.gURLBar.value, "", "URL bar value should be empty.");
 
   await BrowserTestUtils.closeWindow(win);
 });
diff --git a/browser/base/content/test/urlbar/browser_urlbarDecode.js b/browser/base/content/test/urlbar/browser_urlbarDecode.js
--- a/browser/base/content/test/urlbar/browser_urlbarDecode.js
+++ b/browser/base/content/test/urlbar/browser_urlbarDecode.js
@@ -60,17 +60,17 @@ add_task(async function actionURILossles
   gURLBar.value = "";
   gURLBar.handleRevert();
   gURLBar.blur();
 });
 
 async function checkInput(inputStr) {
   await promiseAutocompleteResultPopup(inputStr);
 
-  let item = gURLBar.popup.richlistbox.firstChild;
+  let item = gURLBar.popup.richlistbox.firstElementChild;
   Assert.ok(item, "Should have a result");
 
   // visiturl matches have their param.urls fixed up.
   let fixupInfo = Services.uriFixup.getFixupURIInfo(inputStr,
     Ci.nsIURIFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS |
     Ci.nsIURIFixup.FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
   );
   let expectedVisitURL = fixupInfo.fixedURI.spec;
diff --git a/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js b/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js
--- a/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js
+++ b/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js
@@ -12,17 +12,17 @@ add_task(async function() {
   // load events fire.
   await BrowserTestUtils.waitForCondition(() => browser.contentDocumentAsCPOW && !browser.contentDocumentAsCPOW.hidden);
   let errorPageLoaded = BrowserTestUtils.waitForErrorPage(tab.linkedBrowser);
   gURLBar.value = input;
   gURLBar.select();
   EventUtils.sendKey("return");
   await errorPageLoaded;
   is(gURLBar.textValue, input, "Text is still in URL bar");
-  await BrowserTestUtils.switchTab(gBrowser, tab.previousSibling);
+  await BrowserTestUtils.switchTab(gBrowser, tab.previousElementSibling);
   await BrowserTestUtils.switchTab(gBrowser, tab);
   is(gURLBar.textValue, input, "Text is still in URL bar after tab switch");
   BrowserTestUtils.removeTab(tab);
 });
 
 /**
  * Invalid URIs fail differently (that is, immediately, in the loadURI call)
  * if keyword searches are turned off. Test that this works, too.
@@ -37,15 +37,15 @@ add_task(async function() {
   await BrowserTestUtils.waitForCondition(() => browser.contentDocumentAsCPOW && !browser.contentDocumentAsCPOW.hidden);
   let errorPageLoaded = BrowserTestUtils.waitForErrorPage(tab.linkedBrowser);
   gURLBar.value = input;
   gURLBar.select();
   EventUtils.sendKey("return");
   await errorPageLoaded;
   is(gURLBar.textValue, input, "Text is still in URL bar");
   is(tab.linkedBrowser.userTypedValue, input, "Text still stored on browser");
-  await BrowserTestUtils.switchTab(gBrowser, tab.previousSibling);
+  await BrowserTestUtils.switchTab(gBrowser, tab.previousElementSibling);
   await BrowserTestUtils.switchTab(gBrowser, tab);
   is(gURLBar.textValue, input, "Text is still in URL bar after tab switch");
   is(tab.linkedBrowser.userTypedValue, input, "Text still stored on browser");
   BrowserTestUtils.removeTab(tab);
 });
 
diff --git a/browser/base/content/test/urlbar/browser_urlbarOneOffs.js b/browser/base/content/test/urlbar/browser_urlbarOneOffs.js
--- a/browser/base/content/test/urlbar/browser_urlbarOneOffs.js
+++ b/browser/base/content/test/urlbar/browser_urlbarOneOffs.js
@@ -158,17 +158,17 @@ add_task(async function() {
 // Checks that "Search with Current Search Engine" items are updated to "Search
 // with One-Off Engine" when a one-off is selected.
 add_task(async function searchWith() {
   let typedValue = "foo";
   await promiseAutocompleteResultPopup(typedValue);
   await waitForAutocompleteResultAt(0);
   assertState(0, -1, typedValue);
 
-  let item = gURLBar.popup.richlistbox.firstChild;
+  let item = gURLBar.popup.richlistbox.firstElementChild;
   Assert.equal(item._actionText.textContent,
                "Search with " + Services.search.currentEngine.name,
                "Sanity check: first result's action text");
 
   // Alt+Down to the first one-off.  Now the first result and the first one-off
   // should both be selected.
   EventUtils.synthesizeKey("KEY_ArrowDown", { altKey: true });
   assertState(0, 0, typedValue);
diff --git a/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js b/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js
--- a/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js
+++ b/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js
@@ -56,18 +56,18 @@ add_task(async function popup_mousedown_
   // Check if the first result is with type "searchengine"
   let controller = gURLBar.popup.input.controller;
   // The first item should be 'Search with ...' thus we wan the second.
   let value = controller.getFinalCompleteValueAt(1);
   info(`The value of the second item is ${value}`);
   is(value, test.completeValue, "The second item has the url we visited.");
 
   await BrowserTestUtils.waitForCondition(() => {
-    return !!gURLBar.popup.richlistbox.childNodes[1] &&
-           BrowserTestUtils.is_visible(gURLBar.popup.richlistbox.childNodes[1]);
+    return !!gURLBar.popup.richlistbox.children[1] &&
+           BrowserTestUtils.is_visible(gURLBar.popup.richlistbox.children[1]);
   }, "the node is there.");
 
-  let listitem = gURLBar.popup.richlistbox.childNodes[1];
+  let listitem = gURLBar.popup.richlistbox.children[1];
   EventUtils.synthesizeMouse(listitem, 10, 10, {type: "mousedown"}, window);
   is(gURLBar.popup.richlistbox.selectedIndex, 1, "The second item is selected");
   await promiseSpeculativeConnection(gHttpServer);
   is(gHttpServer.connectionNumber, 1, `${gHttpServer.connectionNumber} speculative connection has been setup.`);
 });
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media.js b/browser/base/content/test/webrtc/browser_devices_get_user_media.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media.js
@@ -16,22 +16,22 @@ var gTests = [
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(true, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("camera-icon"), "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true, video: true});
@@ -46,22 +46,22 @@ var gTests = [
     await promiseRequestDevice(true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareMicrophone-notification-icon", "anchored to mic icon");
     checkDeviceSelectors(true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("microphone-icon"), "panel using microphone icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true});
@@ -76,22 +76,22 @@ var gTests = [
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("camera-icon"), "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
@@ -152,17 +152,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -198,17 +198,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -491,17 +491,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
@@ -544,17 +544,17 @@ var gTests = [
     // because the connection isn't secure.
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     // Ensure that checking the 'Remember this decision' checkbox disables
     // 'Allow'.
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let checkbox = notification.checkbox;
     ok(!!checkbox, "checkbox is present");
     ok(!checkbox.checked, "checkbox is not checked");
     checkbox.click();
     ok(checkbox.checked, "checkbox now checked");
     ok(notification.button.disabled, "Allow button is disabled");
     ok(!notification.hasAttribute("warninghidden"), "warning message is shown");
 
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js
@@ -9,17 +9,17 @@ var gTests = [
     async function getStreamAndCheckBackgroundAnim(aAudio, aVideo, aSharing) {
       // Get a stream
       let popupPromise = promisePopupNotificationShown("webRTC-shareDevices");
       await promiseRequestDevice(aAudio, aVideo);
       await popupPromise;
       await expectObserverCalled("getUserMedia:request");
 
       await promiseMessage("ok", () => {
-        PopupNotifications.panel.firstChild.button.click();
+        PopupNotifications.panel.firstElementChild.button.click();
       });
       await expectObserverCalled("getUserMedia:response:allow");
       await expectObserverCalled("recording-device-events");
       let expected = {};
       if (aVideo)
         expected.video = true;
       if (aAudio)
         expected.audio = true;
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js
@@ -34,22 +34,22 @@ var gTests = [
     await promiseRequestDevice(true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareMicrophone-notification-icon", "anchored to mic icon");
     checkDeviceSelectors(true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("microphone-icon"), "panel using microphone icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true});
@@ -108,22 +108,22 @@ var gTests = [
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("camera-icon"), "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js
@@ -10,22 +10,22 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(true, true);
-    is(PopupNotifications.panel.firstChild.getAttribute("popupid"),
+    is(PopupNotifications.panel.firstElementChild.getAttribute("popupid"),
        "webRTC-shareDevices", "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true, video: true});
@@ -80,17 +80,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -138,17 +138,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -158,17 +158,17 @@ var gTests = [
     // doesn't override sharing UI.
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, "frame2");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await checkSharingUI({video: true, audio: true});
 
@@ -198,17 +198,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: false});
@@ -216,17 +216,17 @@ var gTests = [
 
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame2");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await checkSharingUI({video: true, audio: true});
     await expectNoObserverCalled();
@@ -252,17 +252,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js
@@ -17,17 +17,17 @@ var gTests = [
     await promiseRequestDevice(true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true});
@@ -63,17 +63,17 @@ var gTests = [
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(false, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
 
     await checkSharingUI({video: true}, window, {audio: true, video: true});
 
     ok(webrtcUI.showGlobalIndicator, "webrtcUI wants the global indicator shown");
     ok(webrtcUI.showCameraIndicator, "webrtcUI wants the camera indicator shown");
@@ -122,17 +122,17 @@ var gTests = [
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(false, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
@@ -168,17 +168,17 @@ var gTests = [
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(false, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
 
     await checkSharingUI({video: true}, window, {video: true});
 
     ok(webrtcUI.showGlobalIndicator, "webrtcUI wants the global indicator shown");
     ok(webrtcUI.showCameraIndicator, "webrtcUI wants the camera indicator shown");
@@ -229,17 +229,17 @@ var gTests = [
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
 
     // Select the first screen so that we can have a stream.
     document.getElementById("webRTC-selectWindow-menulist").getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
@@ -281,17 +281,17 @@ var gTests = [
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
 
     // Select the first screen so that we can have a stream.
     document.getElementById("webRTC-selectWindow-menulist").getItemAtIndex(2).doCommand();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
 
     await checkSharingUI({screen: "Screen"}, window, {screen: "Screen"});
 
     ok(webrtcUI.showGlobalIndicator, "webrtcUI wants the global indicator shown");
     ok(webrtcUI.showScreenSharingIndicator, "webrtcUI wants the screen sharing indicator shown");
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js
@@ -56,17 +56,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
     await indicator;
     await checkSharingUI({
       video: STATE_CAPTURE_ENABLED,
@@ -132,17 +132,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
     await indicator;
     await checkSharingUI({
       video: STATE_CAPTURE_ENABLED,
@@ -217,27 +217,27 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     menulist.getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js
@@ -17,17 +17,17 @@ var gTests = [
     await promiseRequestDevice(true, false);
     await promise;
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     checkDeviceSelectors(false, true);
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await indicator;
     await checkSharingUI({audio: false, video: true});
@@ -67,17 +67,17 @@ var gTests = [
 
     await promise;
     checkDeviceSelectors(false, true);
     await expectObserverCalled("getUserMedia:request");
 
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await indicator;
     await checkSharingUI({audio: false, video: true});
@@ -98,28 +98,28 @@ var gTests = [
     await promise;
     promise = promisePopupNotificationShown("webRTC-shareDevices");
 
     checkDeviceSelectors(false, true);
 
     await expectObserverCalled("getUserMedia:request");
 
     await promiseMessage(badDeviceError, () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
 
     await promise;
     checkDeviceSelectors(true, false);
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
     await indicator;
     await checkSharingUI({audio: true, video: false});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js
@@ -25,17 +25,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Screen' item, a separator and at least one screen");
@@ -81,17 +81,17 @@ var gTests = [
     ok(document.getElementById("webRTC-preview").hidden,
        "the preview area is hidden");
 
     // Select the first screen again so that we can have a stream.
     menulist.getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
@@ -122,17 +122,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "window");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Window' item, a separator and at least one window");
@@ -195,17 +195,17 @@ var gTests = [
       info("no non-scary window available on this test slave");
 
       // Select the first window again so that we can have a stream.
       menulist.getItemAtIndex(scaryIndex).doCommand();
     }
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Window"},
                      "expected window to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Window"});
@@ -231,17 +231,17 @@ var gTests = [
       return;
     }
 
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Application' item, a separator and at least one application");
@@ -280,17 +280,17 @@ var gTests = [
     await TestUtils.waitForCondition(() => !document.getElementById("webRTC-preview").hidden);
     ok(!document.getElementById("webRTC-preview").hidden,
        "the preview area is visible");
     ok(document.getElementById("webRTC-previewWarning").hidden,
        "the scary warning is hidden");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Application"},
                      "expected application to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Application"});
@@ -310,17 +310,17 @@ var gTests = [
     await promiseRequestDevice(true, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(true, false, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Screen' item, a separator and at least one screen");
 
@@ -331,17 +331,17 @@ var gTests = [
     await TestUtils.waitForCondition(() => !document.getElementById("webRTC-preview").hidden);
     ok(!document.getElementById("webRTC-preview").hidden,
        "the preview area is visible");
     ok(!document.getElementById("webRTC-previewWarning").hidden,
        "the scary warning is visible");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()),
                      {audio: true, screen: "Screen"},
                      "expected screen and microphone to be shared");
 
     await indicator;
@@ -386,17 +386,17 @@ var gTests = [
       await promise;
       await expectObserverCalled("getUserMedia:request");
       checkDeviceSelectors(audio, video, screen);
       if (screen) {
         document.getElementById("webRTC-selectWindow-menulist")
                 .getItemAtIndex(2).doCommand();
       }
       await promiseMessage("ok", () => {
-        PopupNotifications.panel.firstChild.button.click();
+        PopupNotifications.panel.firstElementChild.button.click();
       });
       await expectObserverCalled("getUserMedia:response:allow");
       await expectObserverCalled("recording-device-events");
     }
 
     async function check(expected = {}) {
       let shared = Object.keys(expected).join(" and ");
       if (shared) {
@@ -448,17 +448,17 @@ var gTests = [
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, false, true);
     document.getElementById("webRTC-selectWindow-menulist")
             .getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
@@ -475,17 +475,17 @@ var gTests = [
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, false, true);
     document.getElementById("webRTC-selectWindow-menulist")
             .getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
     await indicator;
     await checkSharingUI({screen: "Screen"});
 
@@ -523,17 +523,17 @@ var gTests = [
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, false, true);
     document.getElementById("webRTC-selectWindow-menulist")
             .getItemAtIndex(2).doCommand();
 
     // Ensure that checking the 'Remember this decision' checkbox disables
     // 'Allow'.
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     ok(notification.hasAttribute("warninghidden"), "warning message is hidden");
     let checkbox = notification.checkbox;
     ok(!!checkbox, "checkbox is present");
     ok(!checkbox.checked, "checkbox is not checked");
     checkbox.click();
     ok(checkbox.checked, "checkbox now checked");
     ok(notification.button.disabled, "Allow button is disabled");
     ok(!notification.hasAttribute("warninghidden"), "warning message is shown");
@@ -563,17 +563,17 @@ var gTests = [
 
     // Request devices and expect a prompt despite the saved 'Allow' permission.
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     // The 'remember' checkbox shouldn't be checked anymore.
-    notification = PopupNotifications.panel.firstChild;
+    notification = PopupNotifications.panel.firstElementChild;
     ok(notification.hasAttribute("warninghidden"), "warning message is hidden");
     checkbox = notification.checkbox;
     ok(!!checkbox, "checkbox is present");
     ok(!checkbox.checked, "checkbox is not checked");
 
     // Deny the request to cleanup...
     await promiseMessage(permissionError, () => {
       activateSecondaryAction(kActionDeny);
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js
@@ -10,17 +10,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js
@@ -12,17 +12,17 @@ var gTests = [
   run: async function checkAudioVideoWhileLiveTracksExist_audio_camera() {
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
     await indicator;
     await checkSharingUI({audio: true, video: true});
@@ -87,17 +87,17 @@ var gTests = [
   run: async function checkAudioVideoWhileLiveTracksExist_camera() {
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await indicator;
     await checkSharingUI({audio: false, video: true});
@@ -178,17 +178,17 @@ var gTests = [
   run: async function checkAudioVideoWhileLiveTracksExist_audio() {
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, false);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
     await indicator;
     await checkSharingUI({audio: true, video: false});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js
@@ -13,17 +13,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -67,17 +67,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -112,17 +112,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -165,17 +165,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js
@@ -9,17 +9,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promiseRequestDevice(false, true);
     await promise;
     checkDeviceSelectors(false, true);
     await expectObserverCalled("getUserMedia:request");
 
     let promiseOK = promiseSpecificMessageReceived("ok", 2);
-    PopupNotifications.panel.firstChild.button.click();
+    PopupNotifications.panel.firstElementChild.button.click();
     await promiseOK;
 
     await promiseNoPopupNotification("webRTC-shareDevices");
     await expectObserverCalled("getUserMedia:request");
     await expectObserverCalled("getUserMedia:response:allow", 2);
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await expectObserverCalled("recording-device-events", 2);
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js
@@ -10,17 +10,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
diff --git a/browser/components/contextualidentity/test/browser/browser_windowName.js b/browser/components/contextualidentity/test/browser/browser_windowName.js
--- a/browser/components/contextualidentity/test/browser/browser_windowName.js
+++ b/browser/components/contextualidentity/test/browser/browser_windowName.js
@@ -47,18 +47,18 @@ add_task(async function test() {
 
   is(browser1.contentTitle, "?old", "Tab1 title must be 'old'");
   is(browser1.contentPrincipal.userContextId, 1, "Tab1 UCI must be 1");
 
   is(browser2.contentTitle, "?old", "Tab2 title must be 'old'");
   is(browser2.contentPrincipal.userContextId, 2, "Tab2 UCI must be 2");
 
   let found = false;
-  for (let i = 0; i < gBrowser.tabContainer.childNodes.length; ++i) {
-    let tab = gBrowser.tabContainer.childNodes[i];
+  for (let i = 0; i < gBrowser.tabContainer.children.length; ++i) {
+    let tab = gBrowser.tabContainer.children[i];
     let browser = gBrowser.getBrowserForTab(tab);
     if (browser.contentTitle == "?new") {
       is(browser.contentPrincipal.userContextId, 1, "Tab3 UCI must be 1");
       isnot(browser, browser1, "Tab3 is not browser 1");
       isnot(browser, browser2, "Tab3 is not browser 2");
       gBrowser.removeTab(tab);
       found = true;
       break;
diff --git a/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js b/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js
--- a/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js
+++ b/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js
@@ -31,42 +31,42 @@ add_task(async function() {
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a second time");
   await popupShownPromise;
 
   let header = document.getElementById("customization-lwtheme-menu-header");
   let recommendedHeader = document.getElementById("customization-lwtheme-menu-recommended");
 
-  is(header.nextSibling.nextSibling.nextSibling.nextSibling, recommendedHeader,
+  is(header.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling, recommendedHeader,
      "There should only be three themes (default, light, dark) in the 'My Themes' section by default");
-  is(header.nextSibling.theme.id, DEFAULT_THEME_ID,
+  is(header.nextElementSibling.theme.id, DEFAULT_THEME_ID,
      "The first theme should be the default theme");
-  is(header.nextSibling.nextSibling.theme.id, LIGHT_THEME_ID,
+  is(header.nextElementSibling.nextElementSibling.theme.id, LIGHT_THEME_ID,
      "The second theme should be the light theme");
-  is(header.nextSibling.nextSibling.nextSibling.theme.id, DARK_THEME_ID,
+  is(header.nextElementSibling.nextElementSibling.nextElementSibling.theme.id, DARK_THEME_ID,
      "The third theme should be the dark theme");
 
   let themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
-  header.nextSibling.nextSibling.doCommand(); // Select light theme
+  header.nextElementSibling.nextElementSibling.doCommand(); // Select light theme
   info("Clicked on light theme");
   await themeChangedPromise;
 
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a third time");
   await popupShownPromise;
 
   let activeThemes = popup.querySelectorAll("toolbarbutton.customization-lwtheme-menu-theme[active]");
   is(activeThemes.length, 1, "Exactly 1 theme should be selected");
   if (activeThemes.length > 0) {
     is(activeThemes[0].theme.id, LIGHT_THEME_ID, "Light theme should be selected");
   }
 
-  let firstLWTheme = recommendedHeader.nextSibling;
+  let firstLWTheme = recommendedHeader.nextElementSibling;
   let firstLWThemeId = firstLWTheme.theme.id;
   themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
   firstLWTheme.doCommand();
   info("Clicked on first theme");
   await themeChangedPromise;
 
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
@@ -74,43 +74,43 @@ add_task(async function() {
   await popupShownPromise;
 
   activeThemes = popup.querySelectorAll("toolbarbutton.customization-lwtheme-menu-theme[active]");
   is(activeThemes.length, 1, "Exactly 1 theme should be selected");
   if (activeThemes.length > 0) {
     is(activeThemes[0].theme.id, firstLWThemeId, "First theme should be selected");
   }
 
-  is(header.nextSibling.theme.id, DEFAULT_THEME_ID, "The first theme should be the Default theme");
-  let installedThemeId = header.nextSibling.nextSibling.nextSibling.nextSibling.theme.id;
+  is(header.nextElementSibling.theme.id, DEFAULT_THEME_ID, "The first theme should be the Default theme");
+  let installedThemeId = header.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.theme.id;
   ok(installedThemeId.startsWith(firstLWThemeId),
      "The second theme in the 'My Themes' section should be the newly installed theme: " +
      "Installed theme id: " + installedThemeId + "; First theme ID: " + firstLWThemeId);
   let themeCount = 0;
   let iterNode = header;
-  while (iterNode.nextSibling && iterNode.nextSibling.theme) {
+  while (iterNode.nextElementSibling && iterNode.nextElementSibling.theme) {
     themeCount++;
-    iterNode = iterNode.nextSibling;
+    iterNode = iterNode.nextElementSibling;
   }
   is(themeCount, 4,
      "There should be four themes in the 'My Themes' section");
 
-  let defaultTheme = header.nextSibling;
+  let defaultTheme = header.nextElementSibling;
   defaultTheme.doCommand();
   await new Promise(SimpleTest.executeSoon);
   is(Services.prefs.getCharPref("lightweightThemes.selectedThemeID"),
      DEFAULT_THEME_ID, "Default theme should be selected");
 
   // ensure current theme isn't set to "Default"
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a fourth time");
   await popupShownPromise;
 
-  firstLWTheme = recommendedHeader.nextSibling;
+  firstLWTheme = recommendedHeader.nextElementSibling;
   themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
   firstLWTheme.doCommand();
   info("Clicked on first theme again");
   await themeChangedPromise;
 
   // check that "Restore Defaults" button resets theme
   await gCustomizeMode.reset();
   is(LightweightThemeManager.currentTheme.id, DEFAULT_THEME_ID, "Current theme reset to default");
@@ -121,33 +121,33 @@ add_task(async function() {
   info("Removed all recommended themes");
   await startCustomizing();
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a fifth time");
   await popupShownPromise;
   header = document.getElementById("customization-lwtheme-menu-header");
   is(header.hidden, false, "Header should never be hidden");
-  let themeNode = header.nextSibling;
+  let themeNode = header.nextElementSibling;
   is(themeNode.theme.id, DEFAULT_THEME_ID, "The first theme should be the Default theme");
   is(themeNode.hidden, false, "The default theme should never be hidden");
 
-  themeNode = themeNode.nextSibling;
+  themeNode = themeNode.nextElementSibling;
   is(themeNode.theme.id, LIGHT_THEME_ID, "The second theme should be the Light theme");
   is(themeNode.hidden, false, "The light theme should never be hidden");
 
-  themeNode = themeNode.nextSibling;
+  themeNode = themeNode.nextElementSibling;
   is(themeNode.theme.id, DARK_THEME_ID, "The third theme should be the Dark theme");
   is(themeNode.hidden, false, "The dark theme should never be hidden");
 
   recommendedHeader = document.getElementById("customization-lwtheme-menu-recommended");
-  is(themeNode.nextSibling, recommendedHeader,
+  is(themeNode.nextElementSibling, recommendedHeader,
      "There should only be three themes (default, light, dark) in the 'My Themes' section now");
   let footer = document.getElementById("customization-lwtheme-menu-footer");
-  is(recommendedHeader.nextSibling.id, footer.id, "There should be no recommended themes in the menu");
+  is(recommendedHeader.nextElementSibling.id, footer.id, "There should be no recommended themes in the menu");
   is(recommendedHeader.hidden, true, "The recommendedHeader should be hidden since there are no recommended themes");
 });
 
 add_task(async function asyncCleanup() {
   await endCustomizing();
 
   Services.prefs.clearUserPref("lightweightThemes.usedThemes");
   Services.prefs.clearUserPref("lightweightThemes.recommendedThemes");
diff --git a/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js b/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js
--- a/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js
+++ b/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js
@@ -63,27 +63,27 @@ var move = {
       return CustomizableUI.removeWidgetFromArea(id);
     }
     return CustomizableUI.addWidgetToArea(id, target, null);
   }
 };
 
 function isLast(containerId, defaultPlacements, id) {
   assertAreaPlacements(containerId, defaultPlacements.concat([id]));
-  is(document.getElementById(containerId).customizationTarget.lastChild.firstChild.id, id,
+  is(document.getElementById(containerId).customizationTarget.lastElementChild.firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in customizing window.");
-  is(otherWin.document.getElementById(containerId).customizationTarget.lastChild.id, id,
+  is(otherWin.document.getElementById(containerId).customizationTarget.lastElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in other window.");
 }
 
 function getLastVisibleNodeInToolbar(containerId, win = window) {
   let container = win.document.getElementById(containerId).customizationTarget;
-  let rv = container.lastChild;
-  while (rv && (rv.getAttribute("hidden") == "true" || (rv.firstChild && rv.firstChild.getAttribute("hidden") == "true"))) {
-    rv = rv.previousSibling;
+  let rv = container.lastElementChild;
+  while (rv && (rv.getAttribute("hidden") == "true" || (rv.firstElementChild && rv.firstElementChild.getAttribute("hidden") == "true"))) {
+    rv = rv.previousElementSibling;
   }
   return rv;
 }
 
 function isLastVisibleInToolbar(containerId, defaultPlacements, id) {
   let newPlacements;
   for (let i = defaultPlacements.length - 1; i >= 0; i--) {
     let el = document.getElementById(defaultPlacements[i]);
@@ -93,27 +93,27 @@ function isLastVisibleInToolbar(containe
       break;
     }
   }
   if (!newPlacements) {
     assertAreaPlacements(containerId, defaultPlacements.concat([id]));
   } else {
     assertAreaPlacements(containerId, newPlacements);
   }
-  is(getLastVisibleNodeInToolbar(containerId).firstChild.id, id,
+  is(getLastVisibleNodeInToolbar(containerId).firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in customizing window.");
   is(getLastVisibleNodeInToolbar(containerId, otherWin).id, id,
      "Widget " + id + " should be in " + containerId + " in other window.");
 }
 
 function isFirst(containerId, defaultPlacements, id) {
   assertAreaPlacements(containerId, [id].concat(defaultPlacements));
-  is(document.getElementById(containerId).customizationTarget.firstChild.firstChild.id, id,
+  is(document.getElementById(containerId).customizationTarget.firstElementChild.firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in customizing window.");
-  is(otherWin.document.getElementById(containerId).customizationTarget.firstChild.id, id,
+  is(otherWin.document.getElementById(containerId).customizationTarget.firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in other window.");
 }
 
 async function checkToolbar(id, method) {
   // Place at start of the toolbar:
   let toolbarPlacements = getAreaWidgetIds(kToolbar);
   await move[method](id, kToolbar);
   if (method == "dragToItem") {
@@ -138,17 +138,17 @@ async function checkPanel(id, method) {
   // penultimate item. We can't well use the first item because the panel has complicated
   // rules about rearranging wide items (which, by default, the first two items are).
   if (method == "dragToItem") {
     newPlacements.pop();
     newPlacements.splice(panelPlacements.length - 1, 0, id);
     position = -2;
   }
   assertAreaPlacements(kPanel, newPlacements);
-  is(children[children.length + position].firstChild.id, id,
+  is(children[children.length + position].firstElementChild.id, id,
      "Widget " + id + " should be in " + kPanel + " in customizing window.");
   is(otherChildren[otherChildren.length + position].id, id,
      "Widget " + id + " should be in " + kPanel + " in other window.");
   checkWrapper(id);
 }
 
 async function checkPalette(id, method) {
   // Move back to palette:
@@ -156,17 +156,17 @@ async function checkPalette(id, method) 
   ok(CustomizableUI.inDefaultState, "Should end in default state");
   let visibleChildren = gCustomizeMode.visiblePalette.children;
   let expectedChild = method == "dragToItem" ? visibleChildren[0] : visibleChildren[visibleChildren.length - 1];
   // Items dragged to the end of the palette should be the final item. That they're the penultimate
   // item when dragged is tracked in bug 1395950. Once that's fixed, this hack can be removed.
   if (method == "drag") {
     expectedChild = expectedChild.previousElementSibling;
   }
-  is(expectedChild.firstChild.id, id, "Widget " + id + " was moved using " + method + " and should now be wrapped in palette in customizing window.");
+  is(expectedChild.firstElementChild.id, id, "Widget " + id + " was moved using " + method + " and should now be wrapped in palette in customizing window.");
   if (id == kXULWidgetId) {
     ok(otherWin.gNavToolbox.palette.querySelector("#" + id), "Widget " + id + " should be in invisible palette in other window.");
   }
   checkWrapper(id);
 }
 
 // This test needs a XUL button that's in the palette by default. No such
 // button currently exists, so we create a simple one.
diff --git a/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js b/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js
--- a/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js
+++ b/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js
@@ -9,17 +9,17 @@ const kTestWidget1 = "test-customize-mod
 // Creating and destroying a widget should correctly wrap/unwrap stuff
 add_task(async function testWrapUnwrap() {
   await startCustomizing();
   CustomizableUI.createWidget({id: kTestWidget1, label: "Pretty label", tooltiptext: "Pretty tooltip"});
   let elem = document.getElementById(kTestWidget1);
   let wrapper = document.getElementById("wrapper-" + kTestWidget1);
   ok(elem, "There should be an item");
   ok(wrapper, "There should be a wrapper");
-  is(wrapper.firstChild.id, kTestWidget1, "Wrapper should have test widget");
+  is(wrapper.firstElementChild.id, kTestWidget1, "Wrapper should have test widget");
   is(wrapper.parentNode.id, "customization-palette", "Wrapper should be in palette");
   CustomizableUI.destroyWidget(kTestWidget1);
   wrapper = document.getElementById("wrapper-" + kTestWidget1);
   ok(!wrapper, "There should be a wrapper");
   let item = document.getElementById(kTestWidget1);
   ok(!item, "There should no longer be an item");
 });
 
diff --git a/browser/components/customizableui/test/browser_887438_currentset_shim.js b/browser/components/customizableui/test/browser_887438_currentset_shim.js
--- a/browser/components/customizableui/test/browser_887438_currentset_shim.js
+++ b/browser/components/customizableui/test/browser_887438_currentset_shim.js
@@ -6,22 +6,22 @@
 
 var navbar = document.getElementById("nav-bar");
 var navbarCT = navbar.customizationTarget;
 var overflowPanelList = document.getElementById("widget-overflow-list");
 
 // Reading currentset
 add_task(function() {
   let nodeIds = [];
-  for (let node of navbarCT.childNodes) {
+  for (let node of navbarCT.children) {
     if (node.getAttribute("skipintoolbarset") != "true") {
       nodeIds.push(node.id);
     }
   }
-  for (let node of overflowPanelList.childNodes) {
+  for (let node of overflowPanelList.children) {
     if (node.getAttribute("skipintoolbarset") != "true") {
       nodeIds.push(node.id);
     }
   }
   let currentSet = navbar.currentSet;
   is(currentSet.split(",").length, nodeIds.length, "Should be just as many nodes as there are.");
   is(currentSet, nodeIds.join(","), "Current set and node IDs should match.");
 });
diff --git a/browser/components/customizableui/test/browser_913972_currentset_overflow.js b/browser/components/customizableui/test/browser_913972_currentset_overflow.js
--- a/browser/components/customizableui/test/browser_913972_currentset_overflow.js
+++ b/browser/components/customizableui/test/browser_913972_currentset_overflow.js
@@ -23,17 +23,17 @@ add_task(async function() {
   await waitForCondition(() => !navbar.hasAttribute("overflowing"));
   ok(!navbar.hasAttribute("overflowing"), "Should no longer have an overflowing toolbar.");
   is(navbar.currentSet, oldCurrentSet, "Currentset should still be the same now we're no longer overflowing.");
   ok(CustomizableUI.inDefaultState, "Should still be in default state now we're no longer overflowing.");
 
   // Verify actual physical placements match those of the placement array:
   let placementCounter = 0;
   let placements = CustomizableUI.getWidgetIdsInArea(CustomizableUI.AREA_NAVBAR);
-  for (let node of navbar.customizationTarget.childNodes) {
+  for (let node of navbar.customizationTarget.children) {
     if (node.getAttribute("skipintoolbarset") == "true") {
       continue;
     }
     is(placements[placementCounter++], node.id, "Nodes should match after overflow");
   }
   is(placements.length, placementCounter, "Should have as many nodes as expected");
   is(navbar.customizationTarget.childElementCount, oldChildCount, "Number of nodes should match");
 });
diff --git a/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js b/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js
--- a/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js
+++ b/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js
@@ -32,17 +32,17 @@ add_task(async function() {
   ok(sidebarBtnNode && sidebarBtnNode.getAttribute("overflowedItem") == "true", "Sidebar button should have overflowedItem attribute");
 
   let placementOfSidebarButton = CustomizableUI.getWidgetIdsInArea(navbar.id).indexOf(kSidebarBtn);
   CustomizableUI.addWidgetToArea(kTestBtn1, navbar.id, placementOfSidebarButton);
   ok(!navbar.querySelector("#" + kTestBtn1), "New button should not be in the navbar");
   let newButtonNode = overflowList.querySelector("#" + kTestBtn1);
   ok(newButtonNode, "New button should be overflowing");
   ok(newButtonNode && newButtonNode.getAttribute("overflowedItem") == "true", "New button should have overflowedItem attribute");
-  let nextEl = newButtonNode && newButtonNode.nextSibling;
+  let nextEl = newButtonNode && newButtonNode.nextElementSibling;
   is(nextEl && nextEl.id, kSidebarBtn, "Test button should be next to sidebar button.");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
   await waitForCondition(() => !navbar.hasAttribute("overflowing"));
   ok(!navbar.hasAttribute("overflowing"), "Should not have an overflowing toolbar.");
   ok(navbar.querySelector("#" + kSidebarBtn), "Sidebar button should be in the navbar");
   ok(sidebarBtnNode && (sidebarBtnNode.getAttribute("overflowedItem") != "true"), "Sidebar button should no longer have overflowedItem attribute");
   ok(!overflowList.querySelector("#" + kSidebarBtn), "Sidebar button should no longer be overflowing");
diff --git a/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js b/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js
--- a/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js
+++ b/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js
@@ -18,21 +18,21 @@ add_task(async function() {
   navbar.customizationTarget.appendChild(skippedItem);
   let libraryButton = document.getElementById("library-button");
   await startCustomizing();
   await waitForElementShown(skippedItem);
   ok(CustomizableUI.inDefaultState, "Should still be in default state");
   simulateItemDrag(skippedItem, libraryButton, "start");
   ok(CustomizableUI.inDefaultState, "Should still be in default state");
   let skippedItemWrapper = skippedItem.parentNode;
-  is(skippedItemWrapper.nextSibling && skippedItemWrapper.nextSibling.id,
+  is(skippedItemWrapper.nextElementSibling && skippedItemWrapper.nextElementSibling.id,
      libraryButton.parentNode.id, "Should be next to library button");
   simulateItemDrag(libraryButton, skippedItem, "start");
   let libraryWrapper = libraryButton.parentNode;
-  is(libraryWrapper.nextSibling && libraryWrapper.nextSibling.id,
+  is(libraryWrapper.nextElementSibling && libraryWrapper.nextElementSibling.id,
      skippedItem.parentNode.id, "Should be next to skipintoolbarset item");
   ok(CustomizableUI.inDefaultState, "Should still be in default state");
 });
 
 add_task(async function asyncCleanup() {
   await endCustomizing();
   skippedItem.remove();
   await resetCustomization();
diff --git a/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js b/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js
--- a/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js
+++ b/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js
@@ -81,17 +81,17 @@ add_task(async function() {
     } else {
       CustomizableUI.destroyWidget(widget);
     }
   }
 });
 
 function checkAbstractAndRealPlacements(aNode, aExpectedPlacements) {
   assertAreaPlacements(kToolbarName, aExpectedPlacements);
-  let physicalWidgetIds = Array.from(aNode.childNodes, (node) => node.id);
+  let physicalWidgetIds = Array.from(aNode.children, (node) => node.id);
   placementArraysEqual(aNode.id, physicalWidgetIds, aExpectedPlacements);
 }
 
 function checkWidgetFates(aWidgetIds) {
   for (let widget of aWidgetIds) {
     ok(!CustomizableUI.getPlacementOfWidget(widget), "Widget should be in palette");
     ok(!document.getElementById(widget), "Widget should not be in the DOM");
     let widgetInPalette = !!gNavToolbox.palette.querySelector("#" + widget);
diff --git a/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js b/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js
--- a/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js
+++ b/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js
@@ -44,13 +44,13 @@ add_task(async function() {
   // Drag an item and drop it onto the nav-bar customization target, but
   // not over a particular item.
   await startCustomizing();
   let homeButton = document.getElementById("home-button");
   simulateItemDrag(homeButton, navbar.customizationTarget, "end");
 
   await endCustomizing();
 
-  is(homeButton.previousSibling.id, lastVisible.id,
+  is(homeButton.previousElementSibling.id, lastVisible.id,
      "The downloads button should be placed after the last visible item.");
 
   await resetCustomization();
 });
diff --git a/browser/components/customizableui/test/browser_970511_undo_restore_default.js b/browser/components/customizableui/test/browser_970511_undo_restore_default.js
--- a/browser/components/customizableui/test/browser_970511_undo_restore_default.js
+++ b/browser/components/customizableui/test/browser_970511_undo_restore_default.js
@@ -19,17 +19,17 @@ add_task(async function() {
   let themesButton = document.getElementById("customization-lwtheme-button");
   let popup = document.getElementById("customization-lwtheme-menu");
   let popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button");
   await popupShownPromise;
 
   let recommendedHeader = document.getElementById("customization-lwtheme-menu-recommended");
-  let firstLWTheme = recommendedHeader.nextSibling;
+  let firstLWTheme = recommendedHeader.nextElementSibling;
   let firstLWThemeId = firstLWTheme.theme.id;
   let themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
   firstLWTheme.doCommand();
   info("Clicked on first theme");
   await themeChangedPromise;
 
   is(LightweightThemeManager.currentTheme.id, firstLWThemeId, "Theme changed to first option");
 
diff --git a/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js b/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js
--- a/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js
+++ b/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js
@@ -29,17 +29,17 @@ add_task(async function() {
   assertAreaPlacements(kToolbarName, widgetIds);
 
   let btnId = kTestWidgetPrefix + 1;
   let btn = createDummyXULButton(btnId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(btnId, window);
 
   is(btn.parentNode.id, kToolbarName, "New XUL widget should be placed inside new toolbar");
 
-  is(btn.previousSibling.id, toolbarNode.firstChild.id,
+  is(btn.previousElementSibling.id, toolbarNode.firstElementChild.id,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   btn.remove();
   removeCustomToolbars();
   await resetCustomization();
 });
 
@@ -73,19 +73,19 @@ add_task(async function() {
   let testWidgetId = kTestWidgetPrefix + 3;
 
   CustomizableUI.destroyWidget(testWidgetId);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 2,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 2,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 4,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 4,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -123,19 +123,19 @@ add_task(async function() {
 
   CustomizableUI.destroyWidget(kTestWidgetPrefix + 2);
   CustomizableUI.destroyWidget(testWidgetId);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 1,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 1,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 4,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 4,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -174,19 +174,19 @@ add_task(async function() {
   CustomizableUI.destroyWidget(kTestWidgetPrefix + 2);
   CustomizableUI.destroyWidget(testWidgetId);
   CustomizableUI.destroyWidget(kTestWidgetPrefix + 4);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 1,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 1,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling, null,
+  is(btn.nextElementSibling, null,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -227,32 +227,32 @@ add_task(async function() {
   let originalWindowWidth = window.outerWidth;
   window.resizeTo(kForceOverflowWidthPx, window.outerHeight);
   // Wait for all the widgets to overflow. We can't just wait for the
   // `overflowing` attribute because we leave time for layout flushes
   // inbetween, so it's possible for the timeout to run before the
   // navbar has "settled"
   await waitForCondition(() => {
     return navbar.hasAttribute("overflowing") &&
-      navbar.customizationTarget.lastChild.getAttribute("overflows") == "false";
+      navbar.customizationTarget.lastElementChild.getAttribute("overflows") == "false";
   });
 
   // Find last widget that doesn't allow overflowing
-  let nonOverflowing = navbar.customizationTarget.lastChild;
+  let nonOverflowing = navbar.customizationTarget.lastElementChild;
   is(nonOverflowing.getAttribute("overflows"), "false", "Last child is expected to not allow overflowing");
   isnot(nonOverflowing.getAttribute("skipintoolbarset"), "true", "Last child is expected to not be skipintoolbarset");
 
   let testWidgetId = kTestWidgetPrefix + 10;
   CustomizableUI.destroyWidget(testWidgetId);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 11,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 11,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -297,19 +297,19 @@ add_task(async function() {
   await waitForCondition(() => toolbarNode.hasAttribute("overflowing") && !toolbarNode.querySelector("#" + widgetIds[1]));
   ok(toolbarNode.hasAttribute("overflowing"), "Should have an overflowing toolbar.");
 
   let btnId = kTestWidgetPrefix + missingId;
   let btn = createDummyXULButton(btnId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(btnId, window);
 
   is(btn.parentNode.id, kToolbarName + "-overflow-list", "New XUL widget should be placed inside new toolbar's overflow");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 1,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 1,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 4,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 4,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
   await waitForCondition(() => !toolbarNode.hasAttribute("overflowing"));
 
   btn.remove();
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   removeCustomToolbars();
@@ -398,17 +398,17 @@ add_task(async function() {
   ok(toolbarNode.hasAttribute("overflowing"), "Should have an overflowing toolbar.");
 
   let btnId = kTestWidgetPrefix + missingId;
   let btn = createDummyXULButton(btnId, "test");
   btn.setAttribute("overflows", false);
   CustomizableUI.ensureWidgetPlacedInWindow(btnId, window);
 
   is(btn.parentNode.id, kToolbarName + "-target", "New XUL widget should be placed inside new toolbar");
-  is(btn.nextSibling, null,
+  is(btn.nextElementSibling, null,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
   await waitForCondition(() => !toolbarNode.hasAttribute("overflowing"));
 
   btn.remove();
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   removeCustomToolbars();
diff --git a/browser/components/customizableui/test/browser_981305_separator_insertion.js b/browser/components/customizableui/test/browser_981305_separator_insertion.js
--- a/browser/components/customizableui/test/browser_981305_separator_insertion.js
+++ b/browser/components/customizableui/test/browser_981305_separator_insertion.js
@@ -3,17 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 var tempElements = [];
 
 function insertTempItemsIntoMenu(parentMenu) {
   // Last element is null to insert at the end:
-  let beforeEls = [parentMenu.firstChild, parentMenu.lastChild, null];
+  let beforeEls = [parentMenu.firstElementChild, parentMenu.lastElementChild, null];
   for (let i = 0; i < beforeEls.length; i++) {
     let sep = document.createElement("menuseparator");
     tempElements.push(sep);
     parentMenu.insertBefore(sep, beforeEls[i]);
     let menu = document.createElement("menu");
     tempElements.push(menu);
     parentMenu.insertBefore(menu, beforeEls[i]);
     // And another separator for good measure:
@@ -35,23 +35,23 @@ function checkSeparatorInsertion(menuId,
 
     await document.getElementById("nav-bar").overflowable.show();
 
     let subview = document.getElementById(subviewId);
     let button = document.getElementById(buttonId);
     button.click();
     await BrowserTestUtils.waitForEvent(subview, "ViewShown");
 
-    let subviewBody = subview.firstChild;
-    ok(subviewBody.firstChild, "Subview should have a kid");
-    is(subviewBody.firstChild.localName, "toolbarbutton", "There should be no separators to start with");
+    let subviewBody = subview.firstElementChild;
+    ok(subviewBody.firstElementChild, "Subview should have a kid");
+    is(subviewBody.firstElementChild.localName, "toolbarbutton", "There should be no separators to start with");
 
     for (let kid of subviewBody.children) {
       if (kid.localName == "menuseparator") {
-        ok(kid.previousSibling && kid.previousSibling.localName != "menuseparator",
+        ok(kid.previousElementSibling && kid.previousElementSibling.localName != "menuseparator",
            "Separators should never have another separator next to them, and should never be the first node.");
       }
     }
 
     let panelHiddenPromise = promiseOverflowHidden(window);
     PanelUI.overflowPanel.hidePopup();
     await panelHiddenPromise;
 
diff --git a/browser/components/customizableui/test/browser_989751_subviewbutton_class.js b/browser/components/customizableui/test/browser_989751_subviewbutton_class.js
--- a/browser/components/customizableui/test/browser_989751_subviewbutton_class.js
+++ b/browser/components/customizableui/test/browser_989751_subviewbutton_class.js
@@ -31,17 +31,17 @@ function checkSubviewButtonClass(menuId,
 
     await document.getElementById("nav-bar").overflowable.show();
 
     let button = document.getElementById(buttonId);
     button.click();
 
     await BrowserTestUtils.waitForEvent(PanelUI.overflowPanel, "ViewShown");
     let subview = document.getElementById(subviewId);
-    ok(subview.firstChild, "Subview should have a kid");
+    ok(subview.firstElementChild, "Subview should have a kid");
     let subviewchildren = subview.querySelectorAll("toolbarbutton");
     for (let i = 0; i < subviewchildren.length; i++) {
       let item = subviewchildren[i];
       let itemReadable = "Item '" + item.label + "' (classes: " + item.className + ")";
       ok(item.classList.contains("subviewbutton"), itemReadable + " should have the subviewbutton class.");
       if (i == 0) {
         ok(item.classList.contains(kCustomClass), itemReadable + " should still have its own class, too.");
       }
diff --git a/browser/components/customizableui/test/browser_synced_tabs_menu.js b/browser/components/customizableui/test/browser_synced_tabs_menu.js
--- a/browser/components/customizableui/test/browser_synced_tabs_menu.js
+++ b/browser/components/customizableui/test/browser_synced_tabs_menu.js
@@ -254,62 +254,62 @@ add_task(async function() {
       },
     ]);
   };
   await updateTabsPanel();
 
   // The UI should be showing tabs!
   is(deck.selectedIndex, DECKINDEX_TABS, "no-clients deck entry is visible");
   let tabList = document.getElementById("PanelUI-remotetabs-tabslist");
-  let node = tabList.firstChild;
+  let node = tabList.firstElementChild;
   // First entry should be the client with the most-recent tab.
   is(node.getAttribute("itemtype"), "client", "node is a client entry");
   is(node.textContent, "My Desktop", "correct client");
   // Next entry is the most-recent tab
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/10");
 
   // Next entry is the next-most-recent tab
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/5");
 
   // Next entry is the least-recent tab from the first client.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/1");
 
   // Next is a menuseparator between the clients.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.nodeName, "menuseparator");
 
   // Next is the client with 1 tab.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "client", "node is a client entry");
   is(node.textContent, "My Other Desktop", "correct client");
   // Its single tab
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/6");
 
   // Next is a menuseparator between the clients.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.nodeName, "menuseparator");
 
   // Next is the client with no tab.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "client", "node is a client entry");
   is(node.textContent, "My Phone", "correct client");
   // There is a single node saying there's no tabs for the client.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.nodeName, "label", "node is a label");
   is(node.getAttribute("itemtype"), "", "node is neither a tab nor a client");
 
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node, null, "no more entries");
 
   let didSync = false;
   let oldDoSync = gSync.doSync;
   gSync.doSync = function() {
     didSync = true;
     gSync.doSync = oldDoSync;
   };
@@ -361,40 +361,40 @@ add_task(async function() {
   ok(syncPanel.getAttribute("visible"), "Sync Panel is in view");
   let subpanel = document.getElementById("PanelUI-remotetabs-main");
   ok(!subpanel.hidden, "main pane is visible");
   let deck = document.getElementById("PanelUI-remotetabs-deck");
   is(deck.selectedIndex, DECKINDEX_TABS, "we should be showing tabs");
 
   function checkTabsPage(tabsShownCount, showMoreLabel) {
     let tabList = document.getElementById("PanelUI-remotetabs-tabslist");
-    let node = tabList.firstChild;
+    let node = tabList.firstElementChild;
     is(node.getAttribute("itemtype"), "client", "node is a client entry");
     is(node.textContent, "My Desktop", "correct client");
     for (let i = 0; i < tabsShownCount; i++) {
-      node = node.nextSibling;
+      node = node.nextElementSibling;
       is(node.getAttribute("itemtype"), "tab", "node is a tab");
       is(node.getAttribute("label"), "Tab #" + (i + 1), "the tab is the correct one");
       is(node.getAttribute("targetURI"), SAMPLE_TAB_URL, "url is the correct one");
     }
     let showMoreButton;
     if (showMoreLabel) {
-      node = showMoreButton = node.nextSibling;
+      node = showMoreButton = node.nextElementSibling;
       is(node.getAttribute("itemtype"), "showmorebutton", "node is a show more button");
       is(node.getAttribute("label"), showMoreLabel);
     }
-    node = node.nextSibling;
+    node = node.nextElementSibling;
     is(node, null, "no more entries");
 
     return showMoreButton;
   }
 
   async function checkCanOpenURL() {
     let tabList = document.getElementById("PanelUI-remotetabs-tabslist");
-    let node = tabList.firstChild.nextSibling;
+    let node = tabList.firstElementChild.nextElementSibling;
     let promiseTabOpened = BrowserTestUtils.waitForLocationChange(gBrowser, SAMPLE_TAB_URL);
     node.click();
     await promiseTabOpened;
   }
 
   let showMoreButton;
   function clickShowMoreButton() {
     let promise = promiseObserverNotified("synced-tabs-menu:test:tabs-updated");
diff --git a/browser/components/downloads/test/browser/browser_downloads_panel_block.js b/browser/components/downloads/test/browser/browser_downloads_panel_block.js
--- a/browser/components/downloads/test/browser/browser_downloads_panel_block.js
+++ b/browser/components/downloads/test/browser/browser_downloads_panel_block.js
@@ -12,17 +12,17 @@ add_task(async function mainTest() {
   await task_addDownloads(verdicts.map(v => makeDownload(v)));
 
   // Check that the richlistitem for each download is correct.
   for (let i = 0; i < verdicts.length; i++) {
     await openPanel();
 
     // The current item is always the first one in the listbox since each
     // iteration of this loop removes the item at the end.
-    let item = DownloadsView.richListBox.firstChild;
+    let item = DownloadsView.richListBox.firstElementChild;
 
     // Open the panel and click the item to show the subview.
     let viewPromise = promiseViewShown(DownloadsBlockedSubview.subview);
     EventUtils.sendMouseEvent({ type: "click" }, item);
     await viewPromise;
 
     // Items are listed in newest-to-oldest order, so e.g. the first item's
     // verdict is the last element in the verdicts array.
diff --git a/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js b/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js
--- a/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js
+++ b/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js
@@ -33,22 +33,22 @@ async function test_opensearch(shouldWor
   await promiseSearchPopupShown;
   let oneOffsContainer = document.getAnonymousElementByAttribute(searchPopup,
                                                                  "anonid",
                                                                  "search-one-off-buttons");
   let engineListElement = document.getAnonymousElementByAttribute(oneOffsContainer,
                                                                   "anonid",
                                                                   "add-engines");
   if (shouldWork) {
-    ok(engineListElement.firstChild,
+    ok(engineListElement.firstElementChild,
        "There should be search engines available to add");
     ok(searchBar.getAttribute("addengines"),
        "Search bar should have addengines attribute");
   } else {
-    is(engineListElement.firstChild, null,
+    is(engineListElement.firstElementChild, null,
        "There should be no search engines available to add");
     ok(!searchBar.getAttribute("addengines"),
        "Search bar should not have addengines attribute");
   }
   await BrowserTestUtils.removeTab(tab);
 }
 
 add_task(async function test_install_and_set_default() {
diff --git a/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js b/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js
--- a/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js
+++ b/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js
@@ -148,17 +148,17 @@ async function testPopupSize(standardsMo
   }
 
 
   // Test the PanelUI panel for a menu panel button.
   let widget = getBrowserActionWidget(extension);
   CustomizableUI.addWidgetToArea(widget.id, getCustomizableUIPanelID());
 
   let panel = browserWin.PanelUI.overflowPanel;
-  let panelMultiView = panel.firstChild;
+  let panelMultiView = panel.firstElementChild;
   let widgetId = makeWidgetId(extension.id);
   // The 'ViewShown' event is the only way to correctly determine when the extensions'
   // panelview has finished transitioning and is fully in view.
   let shownPromise = BrowserTestUtils.waitForEvent(panelMultiView, "ViewShown",
                                                    e => (e.originalTarget.id || "").includes(widgetId));
   let browser = await openPanel(extension, browserWin);
   let origPanelRect = panel.getBoundingClientRect();
 
diff --git a/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js b/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js
--- a/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js
+++ b/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js
@@ -256,21 +256,21 @@ add_task(async function test_user_define
 
   let totalTestCommands = Object.keys(testCommands).length;
   let expectedCommandsRegistered = isMac ? totalTestCommands : totalTestCommands - totalMacOnlyCommands;
 
   // Confirm the keysets have been added to both windows.
   let keysetID = `ext-keyset-id-${makeWidgetId(extension.id)}`;
   let keyset = win1.document.getElementById(keysetID);
   ok(keyset != null, "Expected keyset to exist");
-  is(keyset.childNodes.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
+  is(keyset.children.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
 
   keyset = win2.document.getElementById(keysetID);
   ok(keyset != null, "Expected keyset to exist");
-  is(keyset.childNodes.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
+  is(keyset.children.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
 
   // Confirm that the commands are registered to both windows.
   await focusWindow(win1);
   await runTest(win1);
 
   await focusWindow(win2);
   await runTest(win2);
 
diff --git a/browser/components/extensions/test/browser/browser_ext_contextMenus.js b/browser/components/extensions/test/browser/browser_ext_contextMenus.js
--- a/browser/components/extensions/test/browser/browser_ext_contextMenus.js
+++ b/browser/components/extensions/test/browser/browser_ext_contextMenus.js
@@ -171,17 +171,17 @@ add_task(async function() {
   is(items.length, 0, "contextMenu item for selection was not found (context=image)");
 
   items = extensionMenuRoot.getElementsByAttribute("label", "parentToDel");
   is(items.length, 0, "contextMenu item for removed parent was not found (context=image)");
 
   items = extensionMenuRoot.getElementsByAttribute("label", "parent");
   is(items.length, 1, "contextMenu item for parent was found (context=image)");
 
-  is(items[0].childNodes[0].childNodes.length, 2, "child items for parent were found (context=image)");
+  is(items[0].children[0].children.length, 2, "child items for parent were found (context=image)");
 
   // Click on ext-image item and check the click results
   await closeExtensionContextMenu(image);
 
   let result = await extension.awaitMessage("onclick");
   checkClickInfo(result);
   result = await extension.awaitMessage("browser.contextMenus.onClicked");
   checkClickInfo(result);
@@ -313,17 +313,17 @@ add_task(async function() {
   checkClickInfo(result);
 
   // Select some text
   await ContentTask.spawn(gBrowser.selectedBrowser, { }, async function(arg) {
     let doc = content.document;
     let range = doc.createRange();
     let selection = content.getSelection();
     selection.removeAllRanges();
-    let textNode = doc.getElementById("img1").previousSibling;
+    let textNode = doc.getElementById("img1").previousElementSibling;
     range.setStart(textNode, 0);
     range.setEnd(textNode, 100);
     selection.addRange(range);
   });
 
   // Bring up context menu again
   extensionMenuRoot = await openExtensionContextMenu();
 
@@ -366,17 +366,17 @@ add_task(async function() {
   checkClickInfo(result);
 
   // Select a lot of text
   await ContentTask.spawn(gBrowser.selectedBrowser, { }, function* (arg) {
     let doc = content.document;
     let range = doc.createRange();
     let selection = content.getSelection();
     selection.removeAllRanges();
-    let textNode = doc.getElementById("longtext").firstChild;
+    let textNode = doc.getElementById("longtext").firstElementChild;
     range.setStart(textNode, 0);
     range.setEnd(textNode, textNode.length);
     selection.addRange(range);
   });
 
   // Bring up context menu again
   extensionMenuRoot = await openExtensionContextMenu("#longtext");
 
diff --git a/browser/components/extensions/test/browser/browser_ext_menus.js b/browser/components/extensions/test/browser/browser_ext_menus.js
--- a/browser/components/extensions/test/browser/browser_ext_menus.js
+++ b/browser/components/extensions/test/browser/browser_ext_menus.js
@@ -82,30 +82,30 @@ add_task(async function test_actionConte
   for (const kind of ["page", "browser"]) {
     const menu = await openActionContextMenu(extension, kind);
     const [submenu, second, , , , last, separator] = menu.children;
 
     is(submenu.tagName, "menu", "Correct submenu type");
     is(submenu.label, "parent", "Correct submenu title");
 
     const popup = await openSubmenu(submenu);
-    is(popup, submenu.firstChild, "Correct submenu opened");
+    is(popup, submenu.firstElementChild, "Correct submenu opened");
     is(popup.children.length, 2, "Correct number of submenu items");
 
     let idPrefix = `${makeWidgetId(extension.id)}-menuitem-_`;
 
     is(second.tagName, "menuitem", "Second menu item type is correct");
     is(second.label, "click 1", "Second menu item title is correct");
     is(second.id, `${idPrefix}1`, "Second menu item id is correct");
 
     is(last.label, "click 5", "Last menu item title is correct");
     is(last.id, `${idPrefix}5`, "Last menu item id is correct");
     is(separator.tagName, "menuseparator", "Separator after last menu item");
 
-    await closeActionContextMenu(popup.firstChild, kind);
+    await closeActionContextMenu(popup.firstElementChild, kind);
     const {info, tab} = await extension.awaitMessage("click");
     is(info.pageUrl, "http://example.com/", "Click info pageUrl is correct");
     is(tab.id, tabId, "Click event tab ID is correct");
   }
 
   BrowserTestUtils.removeTab(tab);
   await extension.unload();
 });
@@ -134,17 +134,17 @@ add_task(async function test_hiddenPageA
 
   const extension = ExtensionTestUtils.loadExtension({manifest, background});
   const tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, "http://example.com/");
 
   await extension.startup();
   await extension.awaitMessage("ready");
 
   const menu = await openContextMenuInPageActionPanel(extension);
-  const menuItems = Array.filter(menu.childNodes, node => {
+  const menuItems = Array.filter(menu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 
   is(menuItems.length, 3, "Correct number of children");
   const [dontShowItem, separator, manageItem] = menuItems;
 
   is(dontShowItem.label, "Don\u2019t Show in Address Bar", "Correct first child");
   is(separator.tagName, "menuseparator", "Correct second child");
@@ -247,17 +247,17 @@ add_task(async function test_tabContextM
   is(submenu.label, "alpha-beta parent", "Correct submenu title");
 
   isnot(gamma.label, "dummy", "`page` context menu item should not appear here");
 
   is(gamma.tagName, "menuitem", "Third menu item type is correct");
   is(gamma.label, "gamma", "Third menu item label is correct");
 
   const popup = await openSubmenu(submenu);
-  is(popup, submenu.firstChild, "Correct submenu opened");
+  is(popup, submenu.firstElementChild, "Correct submenu opened");
   is(popup.children.length, 2, "Correct number of submenu items");
 
   const [alpha, beta] = popup.children;
   is(alpha.tagName, "menuitem", "First menu item type is correct");
   is(alpha.label, "alpha", "First menu item label is correct");
   is(beta.tagName, "menuitem", "Second menu item type is correct");
   is(beta.label, "beta", "Second menu item label is correct");
 
@@ -341,18 +341,18 @@ add_task(async function test_multiple_co
 
   const menu = await openContextMenu();
   const items = menu.getElementsByAttribute("label", "parent");
 
   is(items.length, 1, "Found parent menu item");
   is(items[0].tagName, "menu", "And it has children");
 
   const popup = await openSubmenu(items[0]);
-  is(popup.firstChild.label, "child", "Correct child menu item");
-  await closeExtensionContextMenu(popup.firstChild);
+  is(popup.firstElementChild.label, "child", "Correct child menu item");
+  await closeExtensionContextMenu(popup.firstElementChild);
 
   const info = await extension.awaitMessage("click");
   is(info.menuItemId, "child", "onClicked the correct item");
 
   BrowserTestUtils.removeTab(tab);
   await extension.unload();
 });
 
@@ -392,17 +392,17 @@ add_task(async function test_tools_menu(
   const tabId = await second.awaitMessage("ready");
   const menu = await openToolsMenu();
 
   const [separator, submenu, gamma] = Array.from(menu.children).slice(-3);
   is(separator.tagName, "menuseparator", "Separator before first extension item");
 
   is(submenu.tagName, "menu", "Correct submenu type");
   is(submenu.getAttribute("label"), "Generated extension", "Correct submenu title");
-  is(submenu.firstChild.children.length, 2, "Correct number of submenu items");
+  is(submenu.firstElementChild.children.length, 2, "Correct number of submenu items");
 
   is(gamma.tagName, "menuitem", "Third menu item type is correct");
   is(gamma.getAttribute("label"), "gamma", "Third menu item label is correct");
 
   closeToolsMenu(gamma);
 
   const click = await second.awaitMessage("click");
   is(click.info.pageUrl, "http://example.com/", "Click info pageUrl is correct");
diff --git a/browser/components/extensions/test/browser/browser_ext_menus_targetElement_shadow.js b/browser/components/extensions/test/browser/browser_ext_menus_targetElement_shadow.js
--- a/browser/components/extensions/test/browser/browser_ext_menus_targetElement_shadow.js
+++ b/browser/components/extensions/test/browser/browser_ext_menus_targetElement_shadow.js
@@ -51,41 +51,41 @@ add_task(async function menuInShadowDOM(
     await extension.awaitMessage("onShownMenuAndCheckedInfo");
     await closeContextMenu();
   }
 
   info("Clicking in open shadow root");
   await testShadowMenu(() => {
     let doc = content.document;
     doc.body.innerHTML = `<div></div>`;
-    let host = doc.body.firstChild.attachShadow({mode: "open"});
+    let host = doc.body.firstElementChild.attachShadow({mode: "open"});
     host.innerHTML = `<a href="http://example.com/?shadowlink">Test open</a>`;
-    content.testTarget = host.firstChild;
+    content.testTarget = host.firstElementChild;
     return content.testTarget;
   });
 
   info("Clicking in closed shadow root");
   await testShadowMenu(() => {
     let doc = content.document;
     doc.body.innerHTML = `<div></div>`;
-    let host = doc.body.firstChild.attachShadow({mode: "closed"});
+    let host = doc.body.firstElementChild.attachShadow({mode: "closed"});
     host.innerHTML = `<a href="http://example.com/?shadowlink">Test closed</a>`;
-    content.testTarget = host.firstChild;
+    content.testTarget = host.firstElementChild;
     return content.testTarget;
   });
 
   info("Clicking in nested shadow DOM");
   await testShadowMenu(() => {
     let doc = content.document;
     let host;
     for (let container = doc.body, i = 0; i < 10; ++i) {
       container.innerHTML = `<div id="level"></div>`;
-      host = container.firstChild.attachShadow({mode: "open"});
+      host = container.firstElementChild.attachShadow({mode: "open"});
       container = host;
     }
     host.innerHTML = `<a href="http://example.com/?shadowlink">Test nested</a>`;
-    content.testTarget = host.firstChild;
+    content.testTarget = host.firstElementChild;
     return content.testTarget;
   });
 
   await extension.unload();
   BrowserTestUtils.removeTab(tab);
 });
diff --git a/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js b/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js
--- a/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js
+++ b/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js
@@ -47,17 +47,17 @@ add_task(async function testPageActionPo
 
     // Tolerate if it is 1px too wide, as that may happen with the current resizing method.
     ok(Math.abs(dims.window.innerWidth - expected) <= 1, `Panel window should be ${expected}px wide`);
     is(body.clientWidth, body.scrollWidth,
        "Panel body should be wide enough to fit its contents");
   }
 
   function setSize(size) {
-    let elem = content.document.body.firstChild;
+    let elem = content.document.body.firstElementChild;
     elem.style.height = `${size}px`;
     elem.style.width = `${size}px`;
   }
 
   let sizes = [
     200,
     400,
     300,
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_select.js b/browser/components/extensions/test/browser/browser_ext_popup_select.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_select.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_select.js
@@ -36,17 +36,17 @@ add_task(async function testPopupSelectP
             </div>
           </body>
         </html>`,
     },
   });
 
   await extension.startup();
 
-  let selectPopup = document.getElementById("ContentSelectDropdown").firstChild;
+  let selectPopup = document.getElementById("ContentSelectDropdown").firstElementChild;
 
   async function testPanel(browser) {
     let popupPromise = promisePopupShown(selectPopup);
 
     BrowserTestUtils.synthesizeMouseAtCenter("#select", {}, browser);
 
     await popupPromise;
 
diff --git a/browser/components/extensions/test/browser/browser_ext_user_events.js b/browser/components/extensions/test/browser/browser_ext_user_events.js
--- a/browser/components/extensions/test/browser/browser_ext_user_events.js
+++ b/browser/components/extensions/test/browser/browser_ext_user_events.js
@@ -14,17 +14,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 // Test that different types of events are all considered
 // "handling user input".
diff --git a/browser/components/originattributes/test/browser/browser_favicon_firstParty.js b/browser/components/originattributes/test/browser/browser_favicon_firstParty.js
--- a/browser/components/originattributes/test/browser/browser_favicon_firstParty.js
+++ b/browser/components/originattributes/test/browser/browser_favicon_firstParty.js
@@ -271,17 +271,17 @@ async function doTestForAllTabsFavicon(a
   assertIconIsData(tabInfo.tab);
 
   // Make the popup of allTabs showing up and trigger the loading of the favicon.
   let allTabsView = document.getElementById("allTabsMenu-allTabsView");
   let allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   let allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
@@ -300,17 +300,17 @@ async function doTestForAllTabsFavicon(a
 
   assertIconIsData(tabInfo.tab);
 
   // Make the popup of allTabs showing up again.
   allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
diff --git a/browser/components/originattributes/test/browser/browser_favicon_userContextId.js b/browser/components/originattributes/test/browser/browser_favicon_userContextId.js
--- a/browser/components/originattributes/test/browser/browser_favicon_userContextId.js
+++ b/browser/components/originattributes/test/browser/browser_favicon_userContextId.js
@@ -223,17 +223,17 @@ async function doTestForAllTabsFavicon(a
   clearAllImageCaches();
 
   // Make the popup of allTabs showing up and trigger the loading of the favicon.
   let allTabsView = document.getElementById("allTabsMenu-allTabsView");
   let allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   let allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
@@ -249,17 +249,17 @@ async function doTestForAllTabsFavicon(a
   // Clear the image cache again.
   clearAllImageCaches();
 
   // Make the popup of allTabs showing up again.
   allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
diff --git a/browser/components/places/tests/browser/browser_bookmarks_change_title.js b/browser/components/places/tests/browser/browser_bookmarks_change_title.js
--- a/browser/components/places/tests/browser/browser_bookmarks_change_title.js
+++ b/browser/components/places/tests/browser/browser_bookmarks_change_title.js
@@ -2,17 +2,17 @@
  * Tests that the title of a bookmark can be changed from the bookmark star, toolbar, and sidebar.
  */
 "use strict";
 
 const TEST_URL = "about:buildconfig";
 const titleAfterFirstUpdate = "BookmarkStar title";
 
 function getToolbarNodeForItemGuid(aItemGuid) {
-  var children = document.getElementById("PlacesToolbarItems").childNodes;
+  var children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (aItemGuid == child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js b/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
--- a/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
+++ b/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
@@ -75,30 +75,30 @@ add_task(async function() {
     let scrollTop = tagsSelector.scrollTop;
 
     ok(listItem.hasAttribute("checked"), "Item is checked " + i);
     let selectedTag = listItem.label;
 
     // Uncheck the tag.
     let promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                                 "BookmarkTagsSelectorUpdated");
-    EventUtils.synthesizeMouseAtCenter(listItem.firstChild, {});
+    EventUtils.synthesizeMouseAtCenter(listItem.firstElementChild, {});
     await promise;
     is(scrollTop, tagsSelector.scrollTop, "Scroll position did not change");
 
     // The listbox is rebuilt, so we have to get the new element.
     let newItem = tagsSelector.selectedItem;
     isnot(newItem, null, "Valid new listItem found");
     ok(!newItem.hasAttribute("checked"), "New listItem is unchecked " + i);
     is(newItem.label, selectedTag, "Correct tag is still selected");
 
     // Check the tag.
     promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                             "BookmarkTagsSelectorUpdated");
-    EventUtils.synthesizeMouseAtCenter(newItem.firstChild, {});
+    EventUtils.synthesizeMouseAtCenter(newItem.firstElementChild, {});
     await promise;
     is(scrollTop, tagsSelector.scrollTop, "Scroll position did not change");
   }
 
   // Remove the second bookmark, then nuke some of the tags.
   await PlacesUtils.bookmarks.remove(bm2);
 
   // Doing this backwords tests more interesting paths.
@@ -111,17 +111,17 @@ add_task(async function() {
     let items = [...tagsSelector.children];
     let topTag = items.find(e => scrolledIntoView(e, tagsSelector)).label;
 
     ok(listItem.hasAttribute("checked"), "Item is checked " + i);
 
     // Uncheck the tag.
     let promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                                 "BookmarkTagsSelectorUpdated");
-    EventUtils.synthesizeMouseAtCenter(listItem.firstChild, {});
+    EventUtils.synthesizeMouseAtCenter(listItem.firstElementChild, {});
     await promise;
 
     // The listbox is rebuilt, so we have to get the new element.
     let topItem = [...tagsSelector.children].find(e => e.label == topTag);
     ok(scrolledIntoView(topItem, tagsSelector), "Scroll position is correct");
 
     let newItem = tagsSelector.selectedItem;
     isnot(newItem, null, "Valid new listItem found");
diff --git a/browser/components/places/tests/browser/browser_check_correct_controllers.js b/browser/components/places/tests/browser/browser_check_correct_controllers.js
--- a/browser/components/places/tests/browser/browser_check_correct_controllers.js
+++ b/browser/components/places/tests/browser/browser_check_correct_controllers.js
@@ -37,17 +37,17 @@ add_task(async function test() {
   let controller = PlacesUIUtils.getControllerForCommand(window, "placesCmd_copy");
   let treeController = tree.controllers
                            .getControllerForCommand("placesCmd_copy");
   ok(controller == treeController, "tree controller was returned");
 
   // Open the context menu for a toolbar item, and check if the toolbar's
   // controller is returned.
   let toolbarItems = document.getElementById("PlacesToolbarItems");
-  EventUtils.synthesizeMouse(toolbarItems.childNodes[0],
+  EventUtils.synthesizeMouse(toolbarItems.children[0],
                              4, 4, { type: "contextmenu", button: 2 },
                              window);
   controller = PlacesUIUtils.getControllerForCommand(window, "placesCmd_copy");
   let toolbarController = document.getElementById("PlacesToolbar")
                                   .controllers
                                   .getControllerForCommand("placesCmd_copy");
   ok(controller == toolbarController, "the toolbar controller was returned");
 
diff --git a/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js b/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js
--- a/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js
+++ b/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js
@@ -3,17 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const PREF_LOAD_BOOKMARKS_IN_TABS = "browser.tabs.loadBookmarksInTabs";
 const TEST_PAGES = ["about:mozilla", "about:robots"];
 
 var gBookmarkElements = [];
 
 function getToolbarNodeForItemGuid(aItemGuid) {
-  var children = document.getElementById("PlacesToolbarItems").childNodes;
+  var children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (aItemGuid == child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js b/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js
--- a/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js
+++ b/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js
@@ -110,17 +110,17 @@ function synthesizeDragWithDirection(aEl
                              startingPoint.x + xIncrement * 9,
                              startingPoint.y + yIncrement * 9,
                              { type: "mousemove" });
 
   return promise;
 }
 
 function getToolbarNodeForItemId(itemGuid) {
-  var children = document.getElementById("PlacesToolbarItems").childNodes;
+  var children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (itemGuid == child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js b/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js
--- a/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js
+++ b/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js
@@ -1,15 +1,15 @@
 "use strict";
 
 async function checkTagsSelector(aAvailableTags, aCheckedTags) {
   let tags = await PlacesUtils.bookmarks.fetchTags();
   is(tags.length, aAvailableTags.length, "Check tags list");
   let tagsSelector = document.getElementById("editBMPanel_tagsSelector");
-  let children = tagsSelector.childNodes;
+  let children = tagsSelector.children;
   is(children.length, aAvailableTags.length,
       "Found expected number of tags in the tags selector");
 
   Array.prototype.forEach.call(children, function(aChild) {
     let tag = aChild.querySelector("label").getAttribute("value");
     ok(true, "Found tag '" + tag + "' in the selector");
     ok(aAvailableTags.includes(tag), "Found expected tag");
     let checked = aChild.getAttribute("checked") == "true";
diff --git a/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js b/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js
--- a/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js
+++ b/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js
@@ -26,17 +26,17 @@ add_task(async function test_panelview_b
   await promise;
 
   let bookmarksView = document.getElementById("PanelUI-bookmarks");
   promise = BrowserTestUtils.waitForEvent(bookmarksView, "ViewShown");
   document.getElementById("appMenu-library-bookmarks-button").click();
   await promise;
 
   let list = document.getElementById("panelMenu_bookmarksMenu");
-  let listItem = [...list.childNodes].find(node => node.label == TEST_URL);
+  let listItem = [...list.children].find(node => node.label == TEST_URL);
 
   let placesContext = document.getElementById("placesContext");
   promise = BrowserTestUtils.waitForEvent(placesContext, "popupshown");
   EventUtils.synthesizeMouseAtCenter(listItem, {
     button: 2,
     type: "contextmenu"
   });
   await promise;
diff --git a/browser/components/places/tests/browser/browser_sidebarpanels_click.js b/browser/components/places/tests/browser/browser_sidebarpanels_click.js
--- a/browser/components/places/tests/browser/browser_sidebarpanels_click.js
+++ b/browser/components/places/tests/browser/browser_sidebarpanels_click.js
@@ -86,17 +86,17 @@ add_task(async function test_sidebarpane
 
     await testPlacesPanel(test, () => {
       changeSidebarDirection("rtl");
       info("Running " + test.desc + " in RTL mode");
     });
 
     // Remove tabs created by sub-tests.
     while (gBrowser.tabs.length > 1) {
-      gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+      gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
     }
   }
 });
 
 async function testPlacesPanel(testInfo, preFunc) {
   await testInfo.init();
 
   let promise = new Promise(resolve => {
diff --git a/browser/components/places/tests/browser/browser_stayopenmenu.js b/browser/components/places/tests/browser/browser_stayopenmenu.js
--- a/browser/components/places/tests/browser/browser_stayopenmenu.js
+++ b/browser/components/places/tests/browser/browser_stayopenmenu.js
@@ -1,16 +1,16 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Menus should stay open (if pref is set) after ctrl-click, middle-click,
 // and contextmenu's "Open in a new tab" click.
 
 async function locateBookmarkAndTestCtrlClick(menupopup) {
-  let testMenuitem = [...menupopup.childNodes].find(node => node.label == "Test1");
+  let testMenuitem = [...menupopup.children].find(node => node.label == "Test1");
   ok(testMenuitem, "Found test bookmark.");
   let promiseTabOpened = BrowserTestUtils.waitForNewTab(gBrowser, null);
   EventUtils.synthesizeMouseAtCenter(testMenuitem, {accelKey: true});
   let newTab = await promiseTabOpened;
   ok(true, "Bookmark ctrl-click opened new tab.");
   BrowserTestUtils.removeTab(newTab);
   return testMenuitem;
 }
@@ -183,25 +183,25 @@ add_task(async function testStayopenBook
   BrowserTestUtils.removeTab(newTab);
   ok(BM.open, "Bookmarks Menu's Popup should still be open.");
   promiseEvent = BrowserTestUtils.waitForEvent(BMpopup, "popuphidden");
   BM.open = false;
   await promiseEvent;
 
   // Test Bookmarks Toolbar stayopen clicks - Ctrl-click.
   let BT = document.getElementById("PlacesToolbarItems");
-  let toolbarbutton = BT.firstChild;
+  let toolbarbutton = BT.firstElementChild;
   ok(toolbarbutton, "Folder should be first item on Bookmarks Toolbar.");
-  let buttonMenupopup = toolbarbutton.firstChild;
+  let buttonMenupopup = toolbarbutton.firstElementChild;
   ok(buttonMenupopup.tagName == "menupopup", "Found toolbar button's menupopup.");
   promiseEvent = BrowserTestUtils.waitForEvent(buttonMenupopup, "popupshown");
   EventUtils.synthesizeMouseAtCenter(toolbarbutton, {});
   await promiseEvent;
   ok(true, "Bookmarks toolbar folder's popup is open.");
-  menuitem = buttonMenupopup.firstChild.nextSibling;
+  menuitem = buttonMenupopup.firstElementChild.nextElementSibling;
   promiseTabOpened = BrowserTestUtils.waitForNewTab(gBrowser, null);
   EventUtils.synthesizeMouseAtCenter(menuitem, {ctrlKey: true});
   newTab = await promiseTabOpened;
   ok(true, "Bookmark in folder on bookmark's toolbar ctrl-click opened new tab.");
   ok(toolbarbutton.open, "Popup of folder on bookmark's toolbar should still be open.");
   promiseEvent = BrowserTestUtils.waitForEvent(buttonMenupopup, "popuphidden");
   toolbarbutton.open = false;
   await promiseEvent;
diff --git a/browser/components/places/tests/browser/browser_toolbar_overflow.js b/browser/components/places/tests/browser/browser_toolbar_overflow.js
--- a/browser/components/places/tests/browser/browser_toolbar_overflow.js
+++ b/browser/components/places/tests/browser/browser_toolbar_overflow.js
@@ -37,39 +37,39 @@ add_task(async function setup() {
     await PlacesUtils.bookmarks.eraseEverything();
     await PlacesUtils.history.clear();
   });
 });
 
 add_task(async function test_overflow() {
   // Check that the overflow chevron is visible.
   Assert.ok(!gChevron.collapsed, "The overflow chevron should be visible");
-  Assert.ok(gToolbarContent.childNodes.length < BOOKMARKS_COUNT,
+  Assert.ok(gToolbarContent.children.length < BOOKMARKS_COUNT,
             "Not all the nodes should be built by default");
   let visibleNodes = [];
-  for (let node of gToolbarContent.childNodes) {
+  for (let node of gToolbarContent.children) {
     if (node.style.visibility == "visible")
       visibleNodes.push(node);
   }
-  Assert.ok(visibleNodes.length < gToolbarContent.childNodes.length,
-            `The number of visible nodes (${visibleNodes.length}) should be smaller than the number of built nodes (${gToolbarContent.childNodes.length})`);
+  Assert.ok(visibleNodes.length < gToolbarContent.children.length,
+            `The number of visible nodes (${visibleNodes.length}) should be smaller than the number of built nodes (${gToolbarContent.children.length})`);
 
   await test_index("Node at the last visible index", visibleNodes.length - 1, "visible");
   await test_index("Node at the first invisible index", visibleNodes.length, "hidden");
-  await test_index("First non-built node", gToolbarContent.childNodes.length, undefined);
-  await test_index("Later non-built node", gToolbarContent.childNodes.length + 1, undefined);
+  await test_index("First non-built node", gToolbarContent.children.length, undefined);
+  await test_index("Later non-built node", gToolbarContent.children.length + 1, undefined);
 
   await test_move_index("Move node from last visible to first hidden",
                         visibleNodes.length - 1, visibleNodes.length,
                         "visible", "hidden");
   await test_move_index("Move node from fist visible to last built",
-                        0, gToolbarContent.childNodes.length - 1,
+                        0, gToolbarContent.children.length - 1,
                         "visible", "hidden");
   await test_move_index("Move node from fist visible to first non built",
-                        0, gToolbarContent.childNodes.length,
+                        0, gToolbarContent.children.length,
                         "visible", undefined);
 });
 
 add_task(async function test_separator_first() {
   // Check that if a separator is the first node, we still calculate overflow
   // properly.
   let bm = await PlacesUtils.bookmarks.insert({
     parentGuid: PlacesUtils.bookmarks.toolbarGuid,
@@ -79,17 +79,17 @@ add_task(async function test_separator_f
   // Hide and show the toolbar to cause a rebuild.
   let promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, false);
   await promiseReady;
   promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, true);
   await promiseReady;
 
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   Assert.ok(children.length > 2, "Multiple elements are visible");
   Assert.equal(children[1]._placesNode.uri, "http://test.places.0/", "Found the first bookmark");
   Assert.equal(children[1].style.visibility, "visible", "The first bookmark is visible");
 
   await PlacesUtils.bookmarks.remove(bm);
 });
 
 add_task(async function test_newWindow_noOverflow() {
@@ -107,29 +107,29 @@ add_task(async function test_newWindow_n
   await PlacesTestUtils.addFavicons(new Map([["http://toolbar.overflow/", favicon]]));
 
   let win = await BrowserTestUtils.openNewBrowserWindow();
   try {
     let toolbar = win.document.getElementById("PersonalToolbar");
     Assert.ok(!toolbar.collapsed, "The toolbar is not collapsed");
     let content = win.document.getElementById("PlacesToolbarItems");
     await BrowserTestUtils.waitForCondition(() => {
-      return content.childNodes.length == 1 &&
-             content.childNodes[0].hasAttribute("image");
+      return content.children.length == 1 &&
+             content.children[0].hasAttribute("image");
     });
     let chevron = win.document.getElementById("PlacesChevron");
     Assert.ok(chevron.collapsed, "The chevron should be collapsed");
   } finally {
     await BrowserTestUtils.closeWindow(win);
   }
 });
 
 async function test_index(desc, index, expected) {
   info(desc);
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   let originalLen = children.length;
   let nodeExisted = children.length > index;
   let previousNodeIsVisible = nodeExisted &&
                               children[index - 1].style.visibility == "visible";
   let promiseUpdateVisibility = expected == "visible" || previousNodeIsVisible
     ? BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated")
     : Promise.resolve();
   let bm = await PlacesUtils.bookmarks.insert({
@@ -167,17 +167,17 @@ async function test_index(desc, index, e
                  `The bookmark node should be ${expected}`);
   }
   Assert.equal(children.length, originalLen,
                "Number of built nodes should stay the same");
 }
 
 async function test_move_index(desc, fromIndex, toIndex, original, expected) {
   info(desc);
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   let originalLen = children.length;
   let movedGuid = children[fromIndex]._placesNode.bookmarkGuid;
   let existingGuid = children[toIndex] ?
     children[toIndex]._placesNode.bookmarkGuid : null;
   let existingIndex = fromIndex < toIndex ? toIndex - 1 : toIndex + 1;
 
   Assert.equal(children[fromIndex].style.visibility, original,
                `The bookmark node should be ${original}`);
@@ -253,15 +253,15 @@ add_task(async function test_separator_f
   // Hide and show the toolbar to cause a rebuild.
   let promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, false);
   await promiseReady;
   promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, true);
   await promiseReady;
 
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   Assert.equal(children.length, 2, "The expected elements are visible");
   Assert.equal(children[0].style.visibility, "visible", "The first bookmark is visible");
   Assert.equal(children[1].style.visibility, "visible", "The second bookmark is visible");
 
   await PlacesUtils.bookmarks.eraseEverything();
 });
diff --git a/browser/components/places/tests/browser/browser_views_iconsupdate.js b/browser/components/places/tests/browser/browser_views_iconsupdate.js
--- a/browser/components/places/tests/browser/browser_views_iconsupdate.js
+++ b/browser/components/places/tests/browser/browser_views_iconsupdate.js
@@ -88,17 +88,17 @@ add_task(async function() {
 /**
  * Get Element for a bookmark in the bookmarks toolbar.
  *
  * @param guid
  *        GUID of the item to search.
  * @returns DOM Node of the element.
  */
 function getNodeForToolbarItem(guid) {
-  return Array.from(document.getElementById("PlacesToolbarItems").childNodes)
+  return Array.from(document.getElementById("PlacesToolbarItems").children)
               .find(child => child._placesNode && child._placesNode.bookmarkGuid == guid);
 }
 
 /**
  * Get a rect for a bookmark in the bookmarks sidebar
  *
  * @param guid
  *        GUID of the item to search.
diff --git a/browser/components/places/tests/browser/browser_views_liveupdate.js b/browser/components/places/tests/browser/browser_views_liveupdate.js
--- a/browser/components/places/tests/browser/browser_views_liveupdate.js
+++ b/browser/components/places/tests/browser/browser_views_liveupdate.js
@@ -263,17 +263,17 @@ function searchItemInView(itemGuid, view
  * @param itemGuid
  *        item guid of the item to search.
  * @returns [node, index] or [null, null] if not found.
  */
 function getNodeForToolbarItem(itemGuid, validator) {
   var placesToolbarItems = document.getElementById("PlacesToolbarItems");
 
   function findNode(aContainer) {
-    var children = aContainer.childNodes;
+    var children = aContainer.children;
     for (var i = 0, staticNodes = 0; i < children.length; i++) {
       var child = children[i];
 
       // Is this a Places node?
       if (!child._placesNode) {
         staticNodes++;
         continue;
       }
@@ -281,17 +281,17 @@ function getNodeForToolbarItem(itemGuid,
       if (child._placesNode.bookmarkGuid == itemGuid) {
         let valid = validator ? validator(child) : true;
         return [child._placesNode, i - staticNodes, valid];
       }
 
       // Don't search in queries, they could contain our item in a
       // different position.  Search only folders
       if (PlacesUtils.nodeIsFolder(child._placesNode)) {
-        var popup = child.lastChild;
+        var popup = child.lastElementChild;
         popup.openPopup();
         var foundNode = findNode(popup);
         popup.hidePopup();
         if (foundNode[0] != null)
           return foundNode;
       }
     }
     return [null, null];
@@ -306,17 +306,17 @@ function getNodeForToolbarItem(itemGuid,
  * @param itemGuid
  *        item guid of the item to search.
  * @returns [node, index] or [null, null] if not found.
  */
 function getNodeForMenuItem(itemGuid, validator) {
   var menu = document.getElementById("bookmarksMenu");
 
   function findNode(aContainer) {
-    var children = aContainer.childNodes;
+    var children = aContainer.children;
     for (var i = 0, staticNodes = 0; i < children.length; i++) {
       var child = children[i];
 
       // Is this a Places node?
       if (!child._placesNode) {
         staticNodes++;
         continue;
       }
@@ -324,29 +324,29 @@ function getNodeForMenuItem(itemGuid, va
       if (child._placesNode.bookmarkGuid == itemGuid) {
         let valid = validator ? validator(child) : true;
         return [child._placesNode, i - staticNodes, valid];
       }
 
       // Don't search in queries, they could contain our item in a
       // different position.  Search only folders
       if (PlacesUtils.nodeIsFolder(child._placesNode)) {
-        var popup = child.lastChild;
+        var popup = child.lastElementChild;
         fakeOpenPopup(popup);
         var foundNode = findNode(popup);
 
         child.open = false;
         if (foundNode[0] != null)
           return foundNode;
       }
     }
     return [null, null, false];
   }
 
-  return findNode(menu.lastChild);
+  return findNode(menu.lastElementChild);
 }
 
 /**
  * Get places node and index for an itemGuid in sidebar tree view.
  *
  * @param itemGuid
  *        item guid of the item to search.
  * @returns [node, index] or [null, null] if not found.
diff --git a/browser/components/preferences/in-content/tests/browser_change_app_handler.js b/browser/components/preferences/in-content/tests/browser_change_app_handler.js
--- a/browser/components/preferences/in-content/tests/browser_change_app_handler.js
+++ b/browser/components/preferences/in-content/tests/browser_change_app_handler.js
@@ -25,45 +25,45 @@ add_task(async function() {
   let ourItem = container.querySelector("richlistitem[type='text/x-test-handler']");
   ok(ourItem, "handlersView is present");
   ourItem.scrollIntoView();
   container.selectItem(ourItem);
   ok(ourItem.selected, "Should be able to select our item.");
 
   let list = ourItem.querySelector(".actionsMenu");
 
-  let chooseItem = list.firstChild.querySelector(".choose-app-item");
+  let chooseItem = list.firstElementChild.querySelector(".choose-app-item");
   let dialogLoadedPromise = promiseLoadSubDialog("chrome://global/content/appPicker.xul");
   let cmdEvent = win.document.createEvent("xulcommandevent");
   cmdEvent.initCommandEvent("command", true, true, win, 0, false, false, false, false, null, 0);
   chooseItem.dispatchEvent(cmdEvent);
 
   let dialog = await dialogLoadedPromise;
   info("Dialog loaded");
 
   let dialogDoc = dialog.document;
   let dialogList = dialogDoc.getElementById("app-picker-listbox");
-  dialogList.selectItem(dialogList.firstChild);
-  let selectedApp = dialogList.firstChild.handlerApp;
+  dialogList.selectItem(dialogList.firstElementChild);
+  let selectedApp = dialogList.firstElementChild.handlerApp;
   dialogDoc.documentElement.acceptDialog();
 
   // Verify results are correct in mime service:
   let mimeInfo = gMimeSvc.getFromTypeAndExtension("text/x-test-handler", null);
   ok(mimeInfo.preferredApplicationHandler.equals(selectedApp), "App should be set as preferred.");
 
   // Check that we display this result:
   ok(list.selectedItem, "Should have a selected item");
   ok(mimeInfo.preferredApplicationHandler.equals(list.selectedItem.handlerApp),
      "App should be visible as preferred item.");
 
 
   // Now try to 'manage' this list:
   dialogLoadedPromise = promiseLoadSubDialog("chrome://browser/content/preferences/applicationManager.xul");
 
-  let manageItem = list.firstChild.querySelector(".manage-app-item");
+  let manageItem = list.firstElementChild.querySelector(".manage-app-item");
   cmdEvent = win.document.createEvent("xulcommandevent");
   cmdEvent.initCommandEvent("command", true, true, win, 0, false, false, false, false, null, 0);
   manageItem.dispatchEvent(cmdEvent);
 
   dialog = await dialogLoadedPromise;
   info("Dialog loaded the second time");
 
   dialogDoc = dialog.document;
diff --git a/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js b/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js
--- a/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js
+++ b/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js
@@ -17,17 +17,17 @@ add_task(async function() {
  */
 add_task(async function() {
   await openPreferencesViaOpenPreferencesAPI("paneGeneral", {leaveOpen: true});
 
   // Ensure the "Sign Up" button in the hidden child of the <xul:deck>
   // is selected and displayed on the screen.
   let weavePrefsDeck = gBrowser.contentDocument.getElementById("weavePrefsDeck");
   is(weavePrefsDeck.selectedIndex, 0, "Should select the #noFxaAccount child node");
-  let noFxaSignUp = weavePrefsDeck.childNodes[0].querySelector("#noFxaSignUp");
+  let noFxaSignUp = weavePrefsDeck.children[0].querySelector("#noFxaSignUp");
   is(noFxaSignUp.textContent, "Don\u2019t have an account? Get started", "The Sign Up button should exist");
 
   // Performs search.
   let searchInput = gBrowser.contentDocument.getElementById("searchInput");
 
   is(searchInput, gBrowser.contentDocument.activeElement.closest("#searchInput"),
     "Search input should be focused when visiting preferences");
 
@@ -44,17 +44,17 @@ add_task(async function() {
         child.id == "weavePrefsDeck") {
       is_element_visible(child, "Should be in search results");
     } else if (child.id) {
       is_element_hidden(child, "Should not be in search results");
     }
   }
 
   // Ensure the "Remove Account" button exists in the hidden child of the <xul:deck>.
-  let unlinkFxaAccount = weavePrefsDeck.childNodes[1].querySelector("#unverifiedUnlinkFxaAccount");
+  let unlinkFxaAccount = weavePrefsDeck.children[1].querySelector("#unverifiedUnlinkFxaAccount");
   is(unlinkFxaAccount.label, "Remove Account", "The Remove Account button should exist");
 
   // Performs search.
   searchInput.focus();
   query = "Remove Account";
   searchCompletedPromise = BrowserTestUtils.waitForEvent(
       gBrowser.contentWindow, "PreferencesSearchCompleted", evt => evt.detail == query);
   EventUtils.sendString(query);
diff --git a/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js b/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js
--- a/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js
+++ b/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js
@@ -44,17 +44,17 @@ add_task(async function ensureMenuHidden
 add_task(async function enableBlockingAutoplay() {
 
   Services.prefs.setBoolPref(GESTURES_NEEDED_KEY, true);
 
   await ContentTask.spawn(gBrowser.selectedBrowser, null, function() {
     let doc = content.document;
     let autoplayMenu = doc.getElementById("autoplayMediaPolicyMenu");
     autoplayMenu.click();
-    let askMenuItem = autoplayMenu.childNodes[0].childNodes[1];
+    let askMenuItem = autoplayMenu.children[0].children[1];
     askMenuItem.click();
   });
 
   Assert.equal(Services.prefs.getIntPref(AUTOPLAY_ENABLED_KEY),
                Ci.nsIAutoplay.PROMPT,
                "Ensure we have set autoplay to false");
 });
 
diff --git a/browser/components/search/test/browser_oneOffContextMenu.js b/browser/components/search/test/browser_oneOffContextMenu.js
--- a/browser/components/search/test/browser_oneOffContextMenu.js
+++ b/browser/components/search/test/browser_oneOffContextMenu.js
@@ -38,17 +38,17 @@ add_task(async function telemetry() {
   // Open the popup.
   let promise = promiseEvent(searchPopup, "popupshown");
   info("Opening search panel");
   EventUtils.synthesizeMouseAtCenter(searchIcon, {});
   await promise;
 
   // Get the one-off button for the test engine.
   let oneOffButton;
-  for (let node of oneOffButtons.childNodes) {
+  for (let node of oneOffButtons.children) {
     if (node.engine && node.engine.name == TEST_ENGINE_NAME) {
       oneOffButton = node;
       break;
     }
   }
   Assert.notEqual(oneOffButton, undefined,
                   "One-off for test engine should exist");
 
diff --git a/browser/components/search/test/browser_oneOffContextMenu_setDefault.js b/browser/components/search/test/browser_oneOffContextMenu_setDefault.js
--- a/browser/components/search/test/browser_oneOffContextMenu_setDefault.js
+++ b/browser/components/search/test/browser_oneOffContextMenu_setDefault.js
@@ -156,17 +156,17 @@ async function openPopupAndGetEngineButt
     oneOffBinding, "anonid", "search-one-offs-context-menu"
   );
   const oneOffButtons = document.getAnonymousElementByAttribute(
     oneOffBinding, "anonid", "search-panel-one-offs"
   );
 
   // Get the one-off button for the test engine.
   let oneOffButton;
-  for (let node of oneOffButtons.childNodes) {
+  for (let node of oneOffButtons.children) {
     if (node.engine && node.engine.name == TEST_ENGINE_NAME) {
       oneOffButton = node;
       break;
     }
   }
   Assert.notEqual(oneOffButton, undefined,
                   "One-off for test engine should exist");
   Assert.equal(oneOffButton.getAttribute("tooltiptext"), TEST_ENGINE_NAME,
diff --git a/browser/components/search/test/browser_oneOffHeader.js b/browser/components/search/test/browser_oneOffHeader.js
--- a/browser/components/search/test/browser_oneOffHeader.js
+++ b/browser/components/search/test/browser_oneOffHeader.js
@@ -14,20 +14,20 @@ const searchSettings =
   document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                           "search-settings");
 var header =
   document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                           "search-panel-one-offs-header");
 function getHeaderText() {
   let headerChild = header.selectedPanel;
   while (headerChild.hasChildNodes()) {
-    headerChild = headerChild.firstChild;
+    headerChild = headerChild.firstElementChild;
   }
   let headerStrings = [];
-  for (let label = headerChild; label; label = label.nextSibling) {
+  for (let label = headerChild; label; label = label.nextElementSibling) {
     headerStrings.push(label.value);
   }
   return headerStrings.join("");
 }
 
 const msg = isMac ? 5 : 1;
 const utils = window.windowUtils;
 const scale = utils.screenPixelsPerCSSPixel;
diff --git a/browser/components/search/test/browser_searchbar_keyboard_navigation.js b/browser/components/search/test/browser_searchbar_keyboard_navigation.js
--- a/browser/components/search/test/browser_searchbar_keyboard_navigation.js
+++ b/browser/components/search/test/browser_searchbar_keyboard_navigation.js
@@ -9,17 +9,17 @@ const kValues = ["foo1", "foo2", "foo3"]
 const kUserValue = "foo";
 
 function getOpenSearchItems() {
   let os = [];
 
   let addEngineList =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "add-engines");
-  for (let item = addEngineList.firstChild; item; item = item.nextSibling)
+  for (let item = addEngineList.firstElementChild; item; item = item.nextElementSibling)
     os.push(item);
 
   return os;
 }
 
 let searchbar;
 let textbox;
 
diff --git a/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js b/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js
--- a/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js
+++ b/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js
@@ -8,17 +8,17 @@ const oneOffsContainer =
 const kValues = ["foo1", "foo2", "foo3"];
 
 function getOpenSearchItems() {
   let os = [];
 
   let addEngineList =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "add-engines");
-  for (let item = addEngineList.firstChild; item; item = item.nextSibling)
+  for (let item = addEngineList.firstElementChild; item; item = item.nextElementSibling)
     os.push(item);
 
   return os;
 }
 
 let searchbar;
 let textbox;
 let searchIcon;
diff --git a/browser/components/search/test/browser_tooManyEnginesOffered.js b/browser/components/search/test/browser_tooManyEnginesOffered.js
--- a/browser/components/search/test/browser_tooManyEnginesOffered.js
+++ b/browser/components/search/test/browser_tooManyEnginesOffered.js
@@ -32,27 +32,27 @@ add_task(async function test() {
 
   // Make sure it has only one add-engine menu button item.
   let items = getOpenSearchItems();
   Assert.equal(items.length, 1, "A single button");
   let menuButton = items[0];
   Assert.equal(menuButton.type, "menu", "A menu button");
 
   // Mouse over the menu button to open it.
-  let buttonPopup = menuButton.firstChild;
+  let buttonPopup = menuButton.firstElementChild;
   promise = promiseEvent(buttonPopup, "popupshown");
   EventUtils.synthesizeMouse(menuButton, 5, 5, { type: "mousemove" });
   await promise;
 
   Assert.ok(menuButton.open, "Submenu should be open");
 
   // Check the engines inside the submenu.
-  Assert.equal(buttonPopup.childNodes.length, 6, "Expected number of engines");
-  for (let i = 0; i < buttonPopup.childNodes.length; i++) {
-    let item = buttonPopup.childNodes[i];
+  Assert.equal(buttonPopup.children.length, 6, "Expected number of engines");
+  for (let i = 0; i < buttonPopup.children.length; i++) {
+    let item = buttonPopup.children[i];
     Assert.equal(item.getAttribute("title"), "engine" + (i + 1),
                  "Expected engine title");
   }
 
   // Mouse out of the menu button to close it.
   promise = promiseEvent(buttonPopup, "popuphidden");
   EventUtils.synthesizeMouse(searchbar, 5, 5, { type: "mousemove" });
   await promise;
@@ -84,13 +84,13 @@ add_task(async function test() {
 });
 
 function getOpenSearchItems() {
   let os = [];
 
   let addEngineList =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "add-engines");
-  for (let item = addEngineList.firstChild; item; item = item.nextSibling)
+  for (let item = addEngineList.firstElementChild; item; item = item.nextElementSibling)
     os.push(item);
 
   return os;
 }
diff --git a/browser/components/uitour/test/browser_UITour3.js b/browser/components/uitour/test/browser_UITour3.js
--- a/browser/components/uitour/test/browser_UITour3.js
+++ b/browser/components/uitour/test/browser_UITour3.js
@@ -47,38 +47,38 @@ add_UITour_task(async function test_info
 
   let imageURL = getRootDirectory(gTestPath) + "image.png";
   imageURL = imageURL.replace("chrome://mochitests/content/", "https://example.org/");
   is(icon.src, imageURL, "Popup should have correct icon shown");
 
   let buttons = document.getElementById("UITourTooltipButtons");
   is(buttons.childElementCount, 4, "Popup should have four buttons");
 
-  is(buttons.childNodes[0].nodeName, "label", "Text label should be a <label>");
-  is(buttons.childNodes[0].getAttribute("value"), "Regular text", "Text label should have correct value");
-  is(buttons.childNodes[0].getAttribute("image"), "", "Text should have no image");
-  is(buttons.childNodes[0].className, "", "Text should have no class");
+  is(buttons.children[0].nodeName, "label", "Text label should be a <label>");
+  is(buttons.children[0].getAttribute("value"), "Regular text", "Text label should have correct value");
+  is(buttons.children[0].getAttribute("image"), "", "Text should have no image");
+  is(buttons.children[0].className, "", "Text should have no class");
 
-  is(buttons.childNodes[1].nodeName, "button", "Link should be a <button>");
-  is(buttons.childNodes[1].getAttribute("label"), "Link", "Link should have correct label");
-  is(buttons.childNodes[1].getAttribute("image"), "", "Link should have no image");
-  is(buttons.childNodes[1].className, "button-link", "Check link class");
+  is(buttons.children[1].nodeName, "button", "Link should be a <button>");
+  is(buttons.children[1].getAttribute("label"), "Link", "Link should have correct label");
+  is(buttons.children[1].getAttribute("image"), "", "Link should have no image");
+  is(buttons.children[1].className, "button-link", "Check link class");
 
-  is(buttons.childNodes[2].nodeName, "button", "Button 1 should be a <button>");
-  is(buttons.childNodes[2].getAttribute("label"), "Button 1", "First button should have correct label");
-  is(buttons.childNodes[2].getAttribute("image"), "", "First button should have no image");
-  is(buttons.childNodes[2].className, "", "Button 1 should have no class");
+  is(buttons.children[2].nodeName, "button", "Button 1 should be a <button>");
+  is(buttons.children[2].getAttribute("label"), "Button 1", "First button should have correct label");
+  is(buttons.children[2].getAttribute("image"), "", "First button should have no image");
+  is(buttons.children[2].className, "", "Button 1 should have no class");
 
-  is(buttons.childNodes[3].nodeName, "button", "Button 2 should be a <button>");
-  is(buttons.childNodes[3].getAttribute("label"), "Button 2", "Second button should have correct label");
-  is(buttons.childNodes[3].getAttribute("image"), imageURL, "Second button should have correct image");
-  is(buttons.childNodes[3].className, "button-primary", "Check button 2 class");
+  is(buttons.children[3].nodeName, "button", "Button 2 should be a <button>");
+  is(buttons.children[3].getAttribute("label"), "Button 2", "Second button should have correct label");
+  is(buttons.children[3].getAttribute("image"), imageURL, "Second button should have correct image");
+  is(buttons.children[3].className, "button-primary", "Check button 2 class");
 
   let promiseHidden = promisePanelElementHidden(window, popup);
-  EventUtils.synthesizeMouseAtCenter(buttons.childNodes[2], {}, window);
+  EventUtils.synthesizeMouseAtCenter(buttons.children[2], {}, window);
   await promiseHidden;
 
   ok(true, "Popup should close automatically");
 
   let returnValue = await waitForCallbackResultPromise();
   is(returnValue.result, "button1", "Correct callback should have been called");
 });
 
@@ -95,28 +95,28 @@ add_UITour_task(async function test_info
 
   let imageURL = getRootDirectory(gTestPath) + "image.png";
   imageURL = imageURL.replace("chrome://mochitests/content/", "https://example.org/");
   is(icon.src, imageURL, "Popup should have correct icon shown");
 
   let buttons = document.getElementById("UITourTooltipButtons");
   is(buttons.childElementCount, 4, "Popup should have four buttons");
 
-  is(buttons.childNodes[1].getAttribute("label"), "Link", "Link should have correct label");
-  is(buttons.childNodes[1].getAttribute("image"), "", "Link should have no image");
-  ok(buttons.childNodes[1].classList.contains("button-link"), "Link should have button-link class");
+  is(buttons.children[1].getAttribute("label"), "Link", "Link should have correct label");
+  is(buttons.children[1].getAttribute("image"), "", "Link should have no image");
+  ok(buttons.children[1].classList.contains("button-link"), "Link should have button-link class");
 
-  is(buttons.childNodes[2].getAttribute("label"), "Button 1", "First button should have correct label");
-  is(buttons.childNodes[2].getAttribute("image"), "", "First button should have no image");
+  is(buttons.children[2].getAttribute("label"), "Button 1", "First button should have correct label");
+  is(buttons.children[2].getAttribute("image"), "", "First button should have no image");
 
-  is(buttons.childNodes[3].getAttribute("label"), "Button 2", "Second button should have correct label");
-  is(buttons.childNodes[3].getAttribute("image"), imageURL, "Second button should have correct image");
+  is(buttons.children[3].getAttribute("label"), "Button 2", "Second button should have correct label");
+  is(buttons.children[3].getAttribute("image"), imageURL, "Second button should have correct image");
 
   let promiseHidden = promisePanelElementHidden(window, popup);
-  EventUtils.synthesizeMouseAtCenter(buttons.childNodes[3], {}, window);
+  EventUtils.synthesizeMouseAtCenter(buttons.children[3], {}, window);
   await promiseHidden;
 
   ok(true, "Popup should close automatically");
 
   let returnValue = await waitForCallbackResultPromise();
 
   is(returnValue.result, "button2", "Correct callback should have been called");
 }),
diff --git a/browser/components/uitour/test/browser_trackingProtection_tour.js b/browser/components/uitour/test/browser_trackingProtection_tour.js
--- a/browser/components/uitour/test/browser_trackingProtection_tour.js
+++ b/browser/components/uitour/test/browser_trackingProtection_tour.js
@@ -51,17 +51,17 @@ async function checkToggleTarget(targetI
     }, "http-on-opening-request");
   });
 
   await ContentTask.spawn(gBrowser.selectedBrowser, {}, function() {
     let doc = content.document;
     let iframe = doc.createElement("iframe");
     iframe.setAttribute("id", "tracking-element");
     iframe.setAttribute("src", "https://tracking.example.com/");
-    doc.body.insertBefore(iframe, doc.body.firstChild);
+    doc.body.insertBefore(iframe, doc.body.firstElementChild);
   });
 
   await trackerOpened;
 
   let testTargetAvailability = async function(expectedAvailable) {
     let data = await getConfigurationPromise("availableTargets");
     let available = (data.targets.includes(targetID));
     is(available, expectedAvailable, "Target has expected availability.");
diff --git a/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js b/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js
--- a/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js
+++ b/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js
@@ -9,26 +9,26 @@ add_task(async function test_onboarding_
 
   info("Wait for onboarding overlay loaded");
   let tab = await openTab(ABOUT_HOME_URL);
   await promiseOnboardingOverlayLoaded(tab.linkedBrowser);
 
   info("Test accessibility and semantics of the overlay button");
   await ContentTask.spawn(tab.linkedBrowser, {}, function() {
     let doc = content.document;
-    let button = doc.body.firstChild;
+    let button = doc.body.firstElementChild;
     is(button.id, "onboarding-overlay-button",
       "First child is an overlay button");
     ok(button.getAttribute("aria-label"),
       "Onboarding button has an accessible label");
     is(button.getAttribute("aria-haspopup"), "true",
       "Onboarding button should indicate that it triggers a popup");
     is(button.getAttribute("aria-controls"), "onboarding-overlay-dialog",
       "Onboarding button semantically controls an overlay dialog");
-    is(button.firstChild.getAttribute("role"), "presentation",
+    is(button.firstElementChild.getAttribute("role"), "presentation",
       "Onboarding button icon should have presentation only semantics");
   });
 
   BrowserTestUtils.removeTab(tab);
 });
 
 add_task(async function test_onboarding_notification_bar() {
   resetOnboardingDefaultState();
diff --git a/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js b/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js
--- a/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js
+++ b/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js
@@ -51,18 +51,18 @@ function promisePageActionPanelEvent(eve
     }, { once: true });
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   const dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    const bodyNode = panelViewNode.firstChild;
-    for (const childNode of bodyNode.childNodes) {
+    const bodyNode = panelViewNode.firstElementChild;
+    for (const childNode of bodyNode.children) {
       const bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
diff --git a/browser/modules/test/browser/browser_PageActions.js b/browser/modules/test/browser/browser_PageActions.js
--- a/browser/modules/test/browser/browser_PageActions.js
+++ b/browser/modules/test/browser/browser_PageActions.js
@@ -167,25 +167,25 @@ add_task(async function simple() {
   Assert.deepEqual(PageActions.actionForID(action.id), action,
                    "actionForID should be action");
 
   Assert.ok(PageActions._persistedActions.ids.includes(action.id),
             "PageActions should record action in its list of seen actions");
 
   // The action's panel button should have been created.
   let panelButtonNode =
-    BrowserPageActions.mainViewBodyNode.childNodes[indexInPanel];
+    BrowserPageActions.mainViewBodyNode.children[indexInPanel];
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
   Assert.equal(panelButtonNode.id, panelButtonID, "panelButtonID");
   Assert.equal(panelButtonNode.getAttribute("label"), action.getTitle(),
                "label");
 
   // The separator between the built-ins and non-built-ins should exist.
   let sepNode =
-    BrowserPageActions.mainViewBodyNode.childNodes[sepIndex];
+    BrowserPageActions.mainViewBodyNode.children[sepIndex];
   Assert.notEqual(sepNode, null, "sepNode");
   Assert.equal(
     sepNode.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     ),
     "sepNode.id"
   );
@@ -206,19 +206,19 @@ add_task(async function simple() {
   // Show the action's button in the urlbar.
   action.pinnedToUrlbar = true;
   Assert.equal(onPlacedInUrlbarCallCount, 1,
                "onPlacedInUrlbarCallCount should be inc'ed");
   urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Disable the action.  The button in the urlbar should be removed, and the
   // button in the panel should be disabled.
   action.setDisabled(true);
   urlbarButtonNode = document.getElementById(urlbarButtonID);
@@ -281,17 +281,17 @@ add_task(async function simple() {
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     )
   );
   if (initialSepIndex < 0) {
     // The separator between the built-in actions and non-built-in actions
     // should be gone now, too.
     Assert.equal(separatorNode, null, "No separator");
     Assert.ok(!BrowserPageActions.mainViewBodyNode
-              .lastChild.localName.includes("separator"),
+              .lastElementChild.localName.includes("separator"),
               "Last child should not be separator");
   } else {
     // The separator should still be present.
     Assert.notEqual(separatorNode, null, "Separator should still exist");
   }
 
   Assert.deepEqual(PageActions.actionsInPanel(window), initialActionsInPanel,
                    "Actions in panel should go back to initial");
@@ -392,19 +392,19 @@ add_task(async function withSubview() {
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The action's urlbar button should have been created.
   let urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Click the action's button in the panel.  The subview should be shown.
   Assert.equal(onSubviewShowingCount, 0,
                "onSubviewShowingCount should remain 0");
   let subviewShownPromise = promisePageActionViewShown();
@@ -505,19 +505,19 @@ add_task(async function withIframe() {
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The action's urlbar button should have been created.
   let urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Open the panel, click the action's button.
   await promiseOpenPageActionPanel();
   Assert.equal(onIframeShowingCount, 0, "onIframeShowingCount should remain 0");
   EventUtils.synthesizeMouseAtCenter(panelButtonNode, {});
@@ -626,24 +626,24 @@ add_task(async function insertBeforeActi
   Assert.equal(newBookmarkSeparatorIndex, initialBookmarkSeparatorIndex + 1,
                "newBookmarkSeparatorIndex");
 
   // The action's panel button should have been created.
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The button's next sibling should be the bookmark separator.
-  Assert.notEqual(panelButtonNode.nextSibling, null,
-                  "panelButtonNode.nextSibling");
+  Assert.notEqual(panelButtonNode.nextElementSibling, null,
+                  "panelButtonNode.nextElementSibling");
   Assert.equal(
-    panelButtonNode.nextSibling.id,
+    panelButtonNode.nextElementSibling.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BOOKMARK_SEPARATOR
     ),
-    "panelButtonNode.nextSibling.id"
+    "panelButtonNode.nextElementSibling.id"
   );
 
   // The separator between the built-in and non-built-in actions should not have
   // been created.
   Assert.equal(
     document.getElementById(
       BrowserPageActions.panelButtonNodeIDForActionID(
         PageActions.ACTION_ID_BUILT_IN_SEPARATOR
@@ -701,33 +701,33 @@ add_task(async function multipleNonBuilt
   await promisePageActionPanelHidden();
 
   // Check the button nodes in the panel.
   let expectedIndex = 1;
   let buttonNode = document.getElementById(
     BrowserPageActions.panelButtonNodeIDForActionID(idPrefix + expectedIndex)
   );
   Assert.notEqual(buttonNode, null, "buttonNode");
-  Assert.notEqual(buttonNode.previousSibling, null,
-                  "buttonNode.previousSibling");
+  Assert.notEqual(buttonNode.previousElementSibling, null,
+                  "buttonNode.previousElementSibling");
   Assert.equal(
-    buttonNode.previousSibling.id,
+    buttonNode.previousElementSibling.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     ),
-    "buttonNode.previousSibling.id"
+    "buttonNode.previousElementSibling.id"
   );
   for (let i = 0; i < actions.length; i++) {
     Assert.notEqual(buttonNode, null, "buttonNode at index: " + i);
     Assert.equal(
       buttonNode.id,
       BrowserPageActions.panelButtonNodeIDForActionID(idPrefix + expectedIndex),
       "buttonNode.id at index: " + i
     );
-    buttonNode = buttonNode.nextSibling;
+    buttonNode = buttonNode.nextElementSibling;
     expectedIndex++;
   }
   Assert.equal(buttonNode, null, "Nothing should come after the last button");
 
   for (let action of actions) {
     action.remove();
   }
 
@@ -760,17 +760,17 @@ add_task(async function nonBuiltFirst() 
   Assert.deepEqual(PageActions.actions.map(a => a.id), [],
                    "PageActions.actions should be empty");
   Assert.deepEqual(PageActions._builtInActions.map(a => a.id), [],
                    "PageActions._builtInActions should be empty");
   Assert.deepEqual(PageActions._nonBuiltInActions.map(a => a.id), [],
                    "PageActions._nonBuiltInActions should be empty");
 
   // Check the panel.
-  Assert.equal(BrowserPageActions.mainViewBodyNode.childNodes.length, 0,
+  Assert.equal(BrowserPageActions.mainViewBodyNode.children.length, 0,
                "All nodes should be gone");
 
   // Add a non-built-in action.
   let action = PageActions.addAction(new PageActions.Action({
     id: "test-nonBuiltFirst",
     title: "Test nonBuiltFirst",
   }));
 
@@ -782,17 +782,17 @@ add_task(async function nonBuiltFirst() 
   Assert.deepEqual(PageActions._nonBuiltInActions.map(a => a.id), [action.id],
                    "Action should be in PageActions._nonBuiltInActions");
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     [BrowserPageActions.panelButtonNodeIDForActionID(action.id)],
     "Action should be in panel"
   );
 
   // Now add back all the actions.
   for (let a of initialActions) {
     PageActions.addAction(a);
   }
@@ -824,17 +824,17 @@ add_task(async function nonBuiltFirst() 
     PageActions.actionsInPanel(window).map(a => a.id),
     initialActionsInPanel.map(a => a.id).concat(
       [PageActions.ACTION_ID_BUILT_IN_SEPARATOR],
       [action.id]
     ),
     "All actions should be in PageActions.actionsInPanel()"
   );
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat(
       [PageActions.ACTION_ID_BUILT_IN_SEPARATOR],
       [action.id]
     ).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Panel should contain all actions"
   );
 
   // Remove the test action.
@@ -862,17 +862,17 @@ add_task(async function nonBuiltFirst() 
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
     PageActions.actionsInPanel(window).map(a => a.id),
     initialActionsInPanel.map(a => a.id),
     "Action should no longer be in PageActions.actionsInPanel()"
   );
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => BrowserPageActions.panelButtonNodeIDForActionID(a.id)),
     "Action should no longer be in panel"
   );
 });
 
 
 // Makes sure that urlbar nodes appear in the correct order in a new window.
 add_task(async function urlbarOrderNewWindow() {
@@ -932,19 +932,19 @@ add_task(async function urlbarOrderNewWi
   // not appear in the new window (or any window at this point).
   ids = ids.filter(id => PageActions.actionForID(id));
 
   // Open the new window.
   let win = await BrowserTestUtils.openNewBrowserWindow();
 
   // Collect its urlbar nodes.
   let actualUrlbarNodeIDs = [];
-  for (let node = win.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = win.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
 
   // Now check that they're in the right order.
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     ids.map(id => win.BrowserPageActions.urlbarButtonNodeIDForActionID(id)),
     "Expected actions in new window's urlbar"
@@ -1012,19 +1012,19 @@ add_task(async function migrate1() {
   let win = await BrowserTestUtils.openNewBrowserWindow();
   await BrowserTestUtils.openNewForegroundTab({
     gBrowser: win.gBrowser,
     url: "http://example.com/",
   });
 
   // Collect its urlbar nodes.
   let actualUrlbarNodeIDs = [];
-  for (let node = win.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = win.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
 
   // Now check that they're in the right order.
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     orderedIDs.map(id => win.BrowserPageActions.urlbarButtonNodeIDForActionID(id)),
     "Expected actions in new window's urlbar"
@@ -1115,32 +1115,32 @@ add_task(async function perWindowState()
   Assert.deepEqual(
     PageActions.actionsInUrlbar(newWindow).map(a => a.id),
     actionsInUrlbar.map(a => a.id).filter(id => id != action.id),
     "PageActions.actionsInUrlbar: new window should have all actions in urlbar except the test action"
   );
 
   // Check the urlbar nodes for the old window.
   let actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     actionsInUrlbar.map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "Old window should have all nodes in urlbar"
   );
 
   // Check the urlbar nodes for the new window.
   actualUrlbarNodeIDs = [];
-  for (let node = newWindow.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = newWindow.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     actionsInUrlbar.filter(a => a.id != action.id).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "New window should have all nodes in urlbar except for the test action's"
   );
 
@@ -1182,19 +1182,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     [testAction].concat(initialActionsInUrlbar).map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order: testAction followed by all initial actions"
   );
 
   // Check the nodes in the urlbar.
   let actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     [testAction].concat(initialActionsInUrlbar).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order: testAction followed by all initial actions"
   );
 
@@ -1205,19 +1205,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     initialActionsInUrlbar.map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order after removing test action: all initial actions"
   );
 
   // Check the nodes in the urlbar.
   actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     initialActionsInUrlbar.map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order after removing test action: all initial actions"
   );
 
@@ -1234,19 +1234,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     [testAction].concat(initialActionsInUrlbar).map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order after re-adding test action: testAction followed by all initial actions"
   );
 
   // Check the nodes in the urlbar.
   actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     [testAction].concat(initialActionsInUrlbar).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order after re-adding test action: testAction followed by all initial actions"
   );
 
@@ -1484,17 +1484,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   Assert.equal(onPlacedInPanelCount, 1,
@@ -1511,17 +1511,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should revert to initial"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel
       .map(a => BrowserPageActions.panelButtonNodeIDForActionID(a.id)),
     "Actions in panel should be correct"
   );
 
   // Enable the action.  It should be added back to the panel.
   action.setDisabled(false, window);
 
@@ -1534,17 +1534,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   Assert.equal(onPlacedInPanelCount, 2,
@@ -1569,17 +1569,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
@@ -1601,17 +1601,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   // Enable the action again.  It should be added back to the panel.
@@ -1628,17 +1628,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
@@ -1726,25 +1726,25 @@ function promisePageActionViewShown() {
     return panelViewNode;
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    let bodyNode = panelViewNode.firstChild;
-    for (let childNode of bodyNode.childNodes) {
+    let bodyNode = panelViewNode.firstElementChild;
+    for (let childNode of bodyNode.children) {
       let bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
 
 function collectContextMenuItems() {
   let contextMenu = document.getElementById("pageActionContextMenu");
-  return Array.filter(contextMenu.childNodes, node => {
+  return Array.filter(contextMenu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 }
diff --git a/browser/modules/test/browser/browser_UsageTelemetry_domains.js b/browser/modules/test/browser/browser_UsageTelemetry_domains.js
--- a/browser/modules/test/browser/browser_UsageTelemetry_domains.js
+++ b/browser/modules/test/browser/browser_UsageTelemetry_domains.js
@@ -109,17 +109,17 @@ add_task(async function test_URIAndDomai
 
   // Check that we only account for top level loads (e.g. we don't count URIs from
   // embedded iframes).
   await ContentTask.spawn(newWin.gBrowser.selectedBrowser, null, async function() {
     let doc = content.document;
     let iframe = doc.createElement("iframe");
     let promiseIframeLoaded = ContentTaskUtils.waitForEvent(iframe, "load", false);
     iframe.src = "https://example.org/test";
-    doc.body.insertBefore(iframe, doc.body.firstChild);
+    doc.body.insertBefore(iframe, doc.body.firstElementChild);
     await promiseIframeLoaded;
   });
   checkCounts({totalURIs: 5, domainCount: 2, totalUnfilteredURIs: 5});
 
   // Check that uncommon protocols get counted in the unfiltered URI probe.
   const TEST_PAGE =
     "data:text/html,<a id='target' href='%23par1'>Click me</a><a name='par1'>The paragraph.</a>";
   await BrowserTestUtils.loadURI(newWin.gBrowser.selectedBrowser, TEST_PAGE);
diff --git a/browser/modules/test/browser/browser_taskbar_preview.js b/browser/modules/test/browser/browser_taskbar_preview.js
--- a/browser/modules/test/browser/browser_taskbar_preview.js
+++ b/browser/modules/test/browser/browser_taskbar_preview.js
@@ -53,21 +53,21 @@ function test() {
   ok(gBrowser.tabs.length == 3, "Successfully closed a tab");
 
   // Select #1
   ok(getPreviewForTab(gBrowser.tabs[0]).controller.onActivate(), "Activation was accepted");
   ok(gBrowser.tabs[0].selected, "Correct tab was selected");
   checkSelectedTab();
 
   // Remove #3 (non active)
-  gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+  gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
   checkPreviews(2, "Expected number of previews after closing unselected via browser");
 
   // Remove #1 (active)
-  gBrowser.removeTab(gBrowser.tabContainer.firstChild);
+  gBrowser.removeTab(gBrowser.tabContainer.firstElementChild);
   checkPreviews(1, "Expected number of previews after closing selected tab via browser");
 
   // Add a new tab
   BrowserTestUtils.addTab(gBrowser);
   checkPreviews(2);
   // Check default selection
   checkSelectedTab();
 
diff --git a/browser/modules/test/browser/formValidation/browser_form_validation.js b/browser/modules/test/browser/formValidation/browser_form_validation.js
--- a/browser/modules/test/browser/formValidation/browser_form_validation.js
+++ b/browser/modules/test/browser/formValidation/browser_form_validation.js
@@ -142,17 +142,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input required id='i'><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   gBrowser.removeCurrentTab();
 });
 
 /**
  * In this test, we check that, when an invalid form is submitted,
  * the first invalid element is focused and a popup appears.
  */
@@ -161,17 +161,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input><input id='i' required><input required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   gBrowser.removeCurrentTab();
 });
 
 /**
  * In this test, we check that, we hide the popup by interacting with the
  * invalid element if the element becomes valid.
  */
@@ -180,17 +180,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   EventUtils.sendString("a");
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
 });
 
@@ -203,17 +203,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input type='email' id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   await new Promise((resolve, reject) => {
     EventUtils.sendString("a");
     executeSoon(function() {
       checkPopupShow();
       resolve();
     });
   });
@@ -230,17 +230,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   await blurChildElement(browser);
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
 });
 
@@ -252,17 +252,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   EventUtils.synthesizeKey("KEY_Tab");
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
 });
 
@@ -274,17 +274,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser1 = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser1);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser1, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser1, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
 
   let browser2 = await openNewTab("data:text/html,<html></html>");
   await popupHiddenPromise;
 
   gBrowser.removeTab(gBrowser.getTabForBrowser(browser1));
   gBrowser.removeTab(gBrowser.getTabForBrowser(browser2));
@@ -299,17 +299,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   await BrowserTestUtils.loadURI(browser, "data:text/html,<div>hello!</div>");
   await BrowserTestUtils.browserLoaded(browser);
 
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
@@ -363,19 +363,19 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input x-moz-errormessage='foo' required id='i'><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
-  is(gInvalidFormPopup.firstChild.textContent, "foo",
+  is(gInvalidFormPopup.firstElementChild.textContent, "foo",
      "The panel should show the author defined error message");
 
   gBrowser.removeCurrentTab();
 });
 
 /**
  * In this test, we check that the message is correctly updated when it changes.
  */
@@ -384,26 +384,26 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input type='email' required id='i'><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let inputPromise = BrowserTestUtils.waitForEvent(gBrowser.contentDocument.getElementById("i"), "input");
   EventUtils.sendString("f");
   await inputPromise;
 
   // Now, the element suffers from another error, the message should have
   // been updated.
   await new Promise((resolve, reject) => {
     // XXXndeakin This isn't really going to work when the content is another process
     executeSoon(function() {
-      checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+      checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
       resolve();
     });
   });
 
   gBrowser.removeCurrentTab();
 });
