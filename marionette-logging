# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4d96b4be200cbf1dc7a2b241fbd12a83a29d656d
Logging marionette startup failure

diff --git a/testing/marionette/browser.js b/testing/marionette/browser.js
--- a/testing/marionette/browser.js
+++ b/testing/marionette/browser.js
@@ -54,16 +54,17 @@ browser.getBrowserForTab = function(tab)
  */
 browser.getTabBrowser = function(win) {
   // Fennec
   if ("BrowserApp" in win) {
     return win.BrowserApp;
 
   // Firefox
   } else if ("gBrowser" in win) {
+    dump("Returing gBrowser: " + win.gBrowser + "\n");
     return win.gBrowser;
   }
 
   return null;
 };
 
 /**
  * Creates a browsing context wrapper.
@@ -86,16 +87,17 @@ browser.Context = class {
    */
   constructor(win, driver) {
     this.window = win;
     this.driver = driver;
 
     // In Firefox this is <xul:tabbrowser> (not <xul:browser>!)
     // and BrowserApp in Fennec
     this.tabBrowser = browser.getTabBrowser(win);
+    dump("Constructor: " + this.tabBrowser);
 
     this.knownFrames = [];
 
     // Used to set curFrameId upon new session
     this.newSession = true;
 
     this.seenEls = new element.Store();
 
@@ -127,16 +129,17 @@ browser.Context = class {
     this.updateIdForBrowser = driver.updateIdForBrowser.bind(driver);
   }
 
   /**
    * Returns the content browser for the currently selected tab.
    * If there is no tab selected, null will be returned.
    */
   get contentBrowser() {
+    dump("contentBrowser\n")
     if (this.tab) {
       return browser.getBrowserForTab(this.tab);
     } else if (this.tabBrowser &&
         this.driver.isReftestBrowser(this.tabBrowser)) {
       return this.tabBrowser;
     }
 
     return null;
@@ -144,16 +147,17 @@ browser.Context = class {
 
   /**
    * The current frame ID is managed per browser element on desktop in
    * case the ID needs to be refreshed. The currently selected window is
    * identified by a tab.
    */
   get curFrameId() {
     let rv = null;
+    dump("curFrameId: " + this.tab + "\n");
     if (this.tab || this.driver.isReftestBrowser(this.contentBrowser)) {
       rv = this.getIdForBrowser(this.contentBrowser);
     }
     return rv;
   }
 
   /**
    * Returns the current title of the content browser.
@@ -307,21 +311,21 @@ browser.Context = class {
    * @throws UnsupportedOperationError
    *     If tab handling for the current application isn't supported.
    */
   switchToTab(index, win, focus = true) {
     if (win) {
       this.window = win;
       this.tabBrowser = browser.getTabBrowser(win);
     }
+    dump("switchToTab: " + this.tabBrowser + " " + win + " " + "\n");
 
     if (!this.tabBrowser) {
       return;
     }
-
     if (typeof index == "undefined") {
       this.tab = this.tabBrowser.selectedTab;
     } else {
       this.tab = this.tabBrowser.tabs[index];
 
       if (focus) {
         if (this.tabBrowser.selectTab) {
           // Fennec
@@ -344,16 +348,17 @@ browser.Context = class {
    * or b) we're starting a new session and it is the right start frame.
    *
    * @param {string} uid
    *     Frame uid for use by Marionette.
    * @param {xul:browser} target
    *     The <xul:browser> that was the target of the originating message.
    */
   register(uid, target) {
+    dump("REGISTER? " + this.tabBrowser + "\n");
     if (this.tabBrowser) {
       // If we're setting up a new session on Firefox, we only process the
       // registration for this frame if it belongs to the current tab.
       if (!this.tab) {
         this.switchToTab();
       }
 
       if (target === this.contentBrowser) {
diff --git a/testing/marionette/driver.js b/testing/marionette/driver.js
--- a/testing/marionette/driver.js
+++ b/testing/marionette/driver.js
@@ -465,17 +465,17 @@ GeckoDriver.prototype.addFrameCloseListe
  *     Window for which we will create a browsing context.
  *
  * @return {string}
  *     Returns the unique server-assigned ID of the window.
  */
 GeckoDriver.prototype.addBrowser = function(win) {
   let bc = new browser.Context(win, this);
   let winId = getOuterWindowId(win);
-
+  dump("Add browser\n");
   this.browsers[winId] = bc;
   this.curBrowser = this.browsers[winId];
   if (!this.wins.has(winId)) {
     // add this to seenItems so we can guarantee
     // the user will get winId as this window's id
     this.wins.set(winId, win);
   }
 };
@@ -491,31 +491,33 @@ GeckoDriver.prototype.addBrowser = funct
  *     Window whose browser we need to access.
  * @param {boolean=} [false] isNewSession
  *     True if this is the first time we're talking to this browser.
  */
 GeckoDriver.prototype.startBrowser = function(win, isNewSession = false) {
   this.mainFrame = win;
   this.curFrame = null;
   this.addBrowser(win);
+  dump("startBrowser\n");
   this.curBrowser.isNewSession = isNewSession;
   this.whenBrowserStarted(win, isNewSession);
 };
 
 /**
  * Callback invoked after a new session has been started in a browser.
  * Loads the Marionette frame script into the browser if needed.
  *
  * @param {nsIDOMWindow} win
  *     Window whose browser we need to access.
  * @param {boolean} isNewSession
  *     True if this is the first time we're talking to this browser.
  */
 GeckoDriver.prototype.whenBrowserStarted = function(win, isNewSession) {
   let mm = win.window.messageManager;
+  dump("whenBrowserStarted " + mm + " - " + isNewSession + "\n");
   if (mm) {
     if (!isNewSession) {
       // Loading the frame script corresponds to a situation we need to
       // return to the server. If the messageManager is a message broadcaster
       // with no children, we don't have a hope of coming back from this
       // call, so send the ack here. Otherwise, make a note of how many
       // child scripts will be loaded so we known when it's safe to return.
       // Child managers may not have child scripts yet (e.g. socialapi),
@@ -571,17 +573,17 @@ GeckoDriver.prototype.getVisibleText = f
 
 /**
  * Handles registration of new content listener browsers.  Depending on
  * their type they are either accepted or ignored.
  */
 GeckoDriver.prototype.registerBrowser = function(id, be) {
   let nullPrevious = this.curBrowser.curFrameId === null;
   let listenerWindow = Services.wm.getOuterWindowWithId(id);
-
+  dump("registerBrowser\n")
   // go in here if we're already in a remote frame
   if (this.curBrowser.frameManager.currentRemoteFrame !== null &&
       (!listenerWindow || this.mm == this.curBrowser.frameManager
           .currentRemoteFrame.messageManager.get())) {
     // The outerWindowID from an OOP frame will not be meaningful to
     // the parent process here, since each process maintains its own
     // independent window list.  So, it will either be null (!listenerWindow)
     // if we're already in a remote frame, or it will point to some
@@ -645,16 +647,17 @@ GeckoDriver.prototype.registerPromise = 
   });
 };
 
 GeckoDriver.prototype.listeningPromise = function() {
   const li = "Marionette:listenersAttached";
 
   return new Promise(resolve => {
     let cb = msg => {
+      dump("RECV MSG: " + msg.json.listenerId + " " + this.curBrowser.curFrameId + "\n");
       if (msg.json.listenerId === this.curBrowser.curFrameId) {
         this.mm.removeMessageListener(li, cb);
         resolve();
       }
     };
     this.mm.addMessageListener(li, cb);
   });
 };
@@ -837,17 +840,17 @@ GeckoDriver.prototype.newSession = async
     this.mm.broadcastAsyncMessage("Marionette:restart", {});
   } else {
     throw new WebDriverError("Session already running");
   }
   this.switchToGlobalMessageManager();
 
   await registerBrowsers;
   await browserListening;
-
+dump("READY\n");
   if (this.curBrowser.tab) {
     this.curBrowser.contentBrowser.focus();
   }
 
   // Setup global listener for modal dialogs, and check if there is already
   // one open for the currently selected browser window.
   modal.addHandler(this.dialogHandler);
   this.dialog = modal.findModalDialogs(this.curBrowser);
diff --git a/testing/mochitest/browser-test.js b/testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js
+++ b/testing/mochitest/browser-test.js
@@ -58,16 +58,17 @@ var TabDestroyObserver = {
     return new Promise((resolve) => {
       this.promiseResolver = resolve;
     });
   },
 };
 
 function testInit() {
   gConfig = readConfig();
+
   if (gConfig.testRoot == "browser") {
     // Make sure to launch the test harness for the first opened window only
     var prefs = Services.prefs;
     if (prefs.prefHasUserValue("testing.browserTestHarness.running"))
       return;
 
     prefs.setBoolPref("testing.browserTestHarness.running", true);
 
@@ -116,16 +117,17 @@ function testInit() {
   }
 
   let gmm = Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
   gmm.loadFrameScript("chrome://mochikit/content/tests/SimpleTest/AsyncUtilsContent.js", true);
 }
 
 function Tester(aTests, structuredLogger, aCallback) {
   this.structuredLogger = structuredLogger;
+  this.structuredLogger.info("Tester init")
   this.tests = aTests;
   this.callback = aCallback;
 
   this._scriptLoader = Services.scriptloader;
   this.EventUtils = {};
   this._scriptLoader.loadSubScript("chrome://mochikit/content/tests/SimpleTest/EventUtils.js", this.EventUtils);
   var simpleTestScope = {};
   this._scriptLoader.loadSubScript("chrome://mochikit/content/tests/SimpleTest/specialpowersAPI.js", simpleTestScope);
