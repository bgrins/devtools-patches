# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4e2ea1a75e878ae392e4775f2eddd9f83d1b008e
Use type="content" for devtools host

diff --git a/devtools/client/framework/toolbox-host-manager.js b/devtools/client/framework/toolbox-host-manager.js
--- a/devtools/client/framework/toolbox-host-manager.js
+++ b/devtools/client/framework/toolbox-host-manager.js
@@ -69,17 +69,17 @@ ToolboxHostManager.prototype = {
 
     this.host.frame.setAttribute("aria-label", L10N.getStr("toolbox.label"));
     this.host.frame.ownerDocument.defaultView.addEventListener("message", this);
     // We have to listen on capture as no event fires on bubble
     this.host.frame.addEventListener("unload", this, true);
 
     const msSinceProcessStart = parseInt(this.telemetry.msSinceProcessStart(), 10);
     const toolbox = new Toolbox(this.target, toolId, this.host.type,
-                                this.host.frame.contentWindow, this.frameId,
+                                this.host.frame, this.frameId,
                                 msSinceProcessStart);
 
     // Prevent reloading the toolbox when loading the tools in a tab
     // (e.g. from about:debugging)
     const location = this.host.frame.contentWindow.location;
     if (!location.href.startsWith("about:devtools-toolbox")) {
       this.host.frame.setAttribute("src", "about:devtools-toolbox");
     }
@@ -130,16 +130,17 @@ ToolboxHostManager.prototype = {
         DevToolsUtils.executeSoon(() => {
           this.destroy();
         });
         break;
     }
   },
 
   onMessage(event) {
+    console.log(event);
     if (!event.data) {
       return;
     }
     const msg = event.data;
     // Toolbox document is still chrome and disallow identifying message
     // origin via event.source as it is null. So use a custom id.
     if (msg.frameId != this.frameId) {
       return;
@@ -188,16 +189,17 @@ ToolboxHostManager.prototype = {
       throw new Error("Unknown hostType: " + hostType);
     }
 
     const newHost = new Hosts[hostType](this.target.tab, options);
     return newHost;
   },
 
   async switchHost(hostType) {
+    console.trace("switchHost");
     if (hostType == "previous") {
       // Switch to the last used host for the toolbox UI.
       // This is determined by the devtools.toolbox.previousHost pref.
       hostType = Services.prefs.getCharPref(PREVIOUS_HOST);
 
       // Handle the case where the previous host happens to match the current
       // host. If so, switch to bottom if it's not already used, and right side if not.
       if (hostType === this.hostType) {
@@ -207,28 +209,30 @@ ToolboxHostManager.prototype = {
           hostType = Toolbox.HostType.BOTTOM;
         }
       }
     }
     const iframe = this.host.frame;
     const newHost = this.createHost(hostType);
     const newIframe = await newHost.create();
     // change toolbox document's parent to the new host
+    console.log("About to swap", iframe, iframe.getAttribute("type"));
     newIframe.swapFrameLoaders(iframe);
 
     this.destroyHost();
 
     if (this.hostType !== Toolbox.HostType.CUSTOM &&
         this.hostType !== Toolbox.HostType.PAGE) {
       Services.prefs.setCharPref(PREVIOUS_HOST, this.hostType);
     }
 
     this.host = newHost;
     this.hostType = hostType;
     this.host.setTitle(this.host.frame.contentWindow.document.title);
+    console.log("Adding listener for ", this.host.frame.ownerDocument.documentURI);
     this.host.frame.ownerDocument.defaultView.addEventListener("message", this);
     this.host.frame.addEventListener("unload", this, true);
 
     this.setMinWidthWithZoom();
 
     if (hostType !== Toolbox.HostType.CUSTOM &&
         hostType !== Toolbox.HostType.PAGE) {
       Services.prefs.setCharPref(LAST_HOST, hostType);
diff --git a/devtools/client/framework/toolbox-hosts.js b/devtools/client/framework/toolbox-hosts.js
--- a/devtools/client/framework/toolbox-hosts.js
+++ b/devtools/client/framework/toolbox-hosts.js
@@ -54,16 +54,17 @@ BottomHost.prototype = {
       gBrowser.getBrowserContainer(this.hostTab.linkedBrowser);
 
     this._splitter = ownerDocument.createXULElement("splitter");
     this._splitter.setAttribute("class", "devtools-horizontal-splitter");
     // Avoid resizing notification containers
     this._splitter.setAttribute("resizebefore", "flex");
 
     this.frame = ownerDocument.createXULElement("iframe");
+    this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-bottom-iframe";
     this.frame.height = Math.min(
       Services.prefs.getIntPref(this.heightPref),
       this._browserContainer.clientHeight - MIN_PAGE_SIZE
     );
 
     this._browserContainer.appendChild(this._splitter);
@@ -140,16 +141,17 @@ class SidebarHost {
     const ownerDocument = gBrowser.ownerDocument;
     this._browserContainer = gBrowser.getBrowserContainer(this.hostTab.linkedBrowser);
     this._browserPanel = gBrowser.getPanel(this.hostTab.linkedBrowser);
 
     this._splitter = ownerDocument.createXULElement("splitter");
     this._splitter.setAttribute("class", "devtools-side-splitter");
 
     this.frame = ownerDocument.createXULElement("iframe");
+    this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-side-iframe";
 
     this.frame.width = Math.min(
       Services.prefs.getIntPref(this.widthPref),
       this._browserPanel.clientWidth - MIN_PAGE_SIZE
     );
 
diff --git a/devtools/client/framework/toolbox-window.xul b/devtools/client/framework/toolbox-window.xul
--- a/devtools/client/framework/toolbox-window.xul
+++ b/devtools/client/framework/toolbox-window.xul
@@ -9,10 +9,10 @@
 <window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         id="devtools-toolbox-window"
         macanimationtype="document"
         fullscreenbutton="true"
         windowtype="devtools:toolbox"
         width="900" height="320"
         persist="screenX screenY width height sizemode">
   <tooltip id="aHTMLTooltip" page="true"/>
-  <iframe id="toolbox-iframe" flex="1" forceOwnRefreshDriver="" tooltip="aHTMLTooltip"></iframe>
+  <iframe id="toolbox-iframe" type="content" flex="1" forceOwnRefreshDriver="" tooltip="aHTMLTooltip"></iframe>
 </window>
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -84,29 +84,30 @@ loader.lazyGetter(this, "reloadAndStopRe
  * the iframes where the tool panels will be living in.
  *
  * @param {object} target
  *        The object the toolbox is debugging.
  * @param {string} selectedTool
  *        Tool to select initially
  * @param {Toolbox.HostType} hostType
  *        Type of host that will host the toolbox (e.g. sidebar, window)
- * @param {DOMWindow} contentWindow
- *        The window object of the toolbox document
+ * @param {DOMWindow} hostFrame
+ *        The frame that holds the toolbox document
  * @param {string} frameId
  *        A unique identifier to differentiate toolbox documents from the
  *        chrome codebase when passing DOM messages
  * @param {Number} msSinceProcessStart
  *        the number of milliseconds since process start using monotonic
  *        timestamps (unaffected by system clock changes).
  */
-function Toolbox(target, selectedTool, hostType, contentWindow, frameId,
+function Toolbox(target, selectedTool, hostType, hostFrame, frameId,
                  msSinceProcessStart) {
   this._target = target;
-  this._win = contentWindow;
+  this._hostFrame = hostFrame;
+  this._win = hostFrame.contentWindow;
   this.frameId = frameId;
   this.telemetry = new Telemetry();
 
   // The session ID is used to determine which telemetry events belong to which
   // toolbox session. Because we use Amplitude to analyse the telemetry data we
   // must use the time since the system wide epoch as the session ID.
   this.sessionId = msSinceProcessStart;
 
@@ -205,17 +206,17 @@ function Toolbox(target, selectedTool, h
   /**
    * Get text direction for the current locale direction.
    *
    * `getComputedStyle` forces a synchronous reflow, so use a lazy getter in order to
    * call it only once.
    */
   loader.lazyGetter(this, "direction", () => {
     // Get the direction from browser.xul document
-    const top = this.win.top;
+    const top = this.topWindow;
     const topDocEl = top.document.documentElement;
     const isRtl = top.getComputedStyle(topDocEl).direction === "rtl";
     return isRtl ? "rtl" : "ltr";
   });
 }
 exports.Toolbox = Toolbox;
 
 /**
@@ -236,16 +237,20 @@ Toolbox.HostType = {
 Toolbox.prototype = {
   _URL: "about:devtools-toolbox",
 
   _prefs: {
     LAST_TOOL: "devtools.toolbox.selectedTool",
     SIDE_ENABLED: "devtools.toolbox.sideEnabled",
   },
 
+  get topWindow() {
+    return this._hostFrame.ownerGlobal.top;
+  },
+
   get currentToolId() {
     return this._currentToolId;
   },
 
   set currentToolId(id) {
     this._currentToolId = id;
     this.component.setCurrentToolId(id);
   },
@@ -562,17 +567,17 @@ Toolbox.prototype = {
       this.win.requestIdleCallback(() => {
         this.component.setCanRender();
       }, {timeout: 16});
 
       await this.selectTool(this._defaultToolId, "initial_panel");
 
       // Wait until the original tool is selected so that the split
       // console input will receive focus.
-      const browserWin = this.win.top;
+      const browserWin = this.topWindow;
       let splitConsolePromise = promise.resolve();
       if (Services.prefs.getBoolPref(SPLITCONSOLE_ENABLED_PREF)) {
         splitConsolePromise = this.openSplitConsole();
         this.telemetry.addEventProperty(
           browserWin, "open", "tools", null, "splitconsole", true);
       } else {
         this.telemetry.addEventProperty(
           browserWin, "open", "tools", null, "splitconsole", false);
@@ -763,17 +768,17 @@ Toolbox.prototype = {
 
     this.telemetry.getHistogramById(HOST_HISTOGRAM).add(this._getTelemetryHostId());
 
     // Log current theme. The question we want to answer is:
     // "What proportion of users use which themes?"
     const currentTheme = Services.prefs.getCharPref("devtools.theme");
     this.telemetry.keyedScalarAdd(CURRENT_THEME_SCALAR, currentTheme, 1);
 
-    const browserWin = this.win.top;
+    const browserWin = this.topWindow;
     this.telemetry.preparePendingEvent(browserWin, "open", "tools", null, [
       "entrypoint", "first_panel", "host", "shortcut",
       "splitconsole", "width", "session_id",
     ]);
     this.telemetry.addEventProperty(
       browserWin, "open", "tools", null, "host", this._getTelemetryHostString()
     );
   },
@@ -1143,21 +1148,22 @@ Toolbox.prototype = {
 
     this.component.setCurrentHostType(this.hostType);
     this.component.setHostTypes(hostTypes);
   },
 
   postMessage: function(msg) {
     // We sometime try to send messages in middle of destroy(), where the
     // toolbox iframe may already be detached and no longer have a parent.
-    if (this.win.parent) {
+    if (this.topWindow) {
+      console.log("Posting message to top window", msg, this.frameId);
       // Toolbox document is still chrome and disallow identifying message
       // origin via event.source as it is null. So use a custom id.
       msg.frameId = this.frameId;
-      this.win.parent.postMessage(msg, "*");
+      this.topWindow.postMessage(msg, "*");
     }
   },
 
   /**
    * Initiate ToolboxTabs React component and all it's properties. Do the initial render.
    */
   _buildTabs: async function() {
     // Get the initial list of tab definitions. This list can be amended at a later time
@@ -2068,17 +2074,17 @@ Toolbox.prototype = {
         "width": width,
         "panel_name": prevPanelName,
         "next_panel": panelName,
         "reason": reason,
         "session_id": this.sessionId,
       });
     }
 
-    const browserWin = this.win.top;
+    const browserWin = this.topWindow;
     this.telemetry.addEventProperties(browserWin, "open", "tools", null, {
       "width": width,
       "session_id": this.sessionId,
     });
 
     if (id === "webconsole") {
       pending.push("message_count");
     }
