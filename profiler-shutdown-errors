# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  cd5b4e44e260a2f8bdbd7f1f4505443702e48ff9
Bug xxx: tracking down errors caused by not waiting for toolbox cleanup

diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -378,25 +378,25 @@ Toolbox.prototype = {
       yield promise.all([
         splitConsolePromise,
         buttonsPromise,
         framesPromise
       ]);
 
       // Lazily connect to the profiler here and don't wait for it to complete,
       // used to intercept console.profile calls before the performance tools are open.
-      let profilerReady = this._connectProfiler();
+      this.profilerReady = this._connectProfiler();
 
       // However, while testing, we must wait for the performance connection to finish,
       // as most tests shut down without waiting for a toolbox destruction event,
       // resulting in the shared profiler connection being opened and closed
       // outside of the test that originally opened the toolbox.
-      if (gDevTools.testing) {
-        yield profilerReady;
-      }
+      // if (gDevTools.testing) {
+      //   yield profilerReady;
+      // }
 
       this.emit("ready");
     }.bind(this)).then(null, console.error.bind(console));
   },
 
   _pingTelemetry: function() {
     this._telemetry.toolOpened("toolbox");
 
@@ -1767,16 +1767,18 @@ Toolbox.prototype = {
 
     // Finish all outstanding tasks (which means finish destroying panels and
     // then destroying the host, successfully or not) before destroying the
     // target.
     this._destroyer = DevToolsUtils.settleAll(outstanding)
                                    .catch(console.error)
                                    .then(() => this.destroyHost())
                                    .catch(console.error)
+                                   .then(() => this.profilerReady)
+                                   .catch(console.error)
                                    .then(() => {
       // Targets need to be notified that the toolbox is being torn down.
       // This is done after other destruction tasks since it may tear down
       // fronts and the debugger transport which earlier destroy methods may
       // require to complete.
       if (!this._target) {
         return null;
       }
diff --git a/devtools/client/netmonitor/test/head.js b/devtools/client/netmonitor/test/head.js
--- a/devtools/client/netmonitor/test/head.js
+++ b/devtools/client/netmonitor/test/head.js
@@ -92,19 +92,24 @@ function addTab(aUrl, aWindow) {
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     deferred.resolve(tab);
   }, true);
 
   return deferred.promise;
 }
 
-function removeTab(aTab, aWindow) {
+let removeTab = Task.async(function*(aTab, aWindow) {
   info("Removing tab.");
 
+  let target = TargetFactory.forTab(aTab);
+  if (target) {
+    yield gDevTools.closeToolbox(target);
+  }
+
   let targetWindow = aWindow || window;
   let targetBrowser = targetWindow.gBrowser;
 
   targetBrowser.removeTab(aTab);
 }
 
 function waitForNavigation(aTarget) {
   let deferred = promise.defer();
