# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  1c2c044db3ef02ac69decfee03c40aa14b12fe96
Bug 1112599 - Enable webconsole tests on e10s

diff --git a/devtools/client/webconsole/test/browser.ini b/devtools/client/webconsole/test/browser.ini
--- a/devtools/client/webconsole/test/browser.ini
+++ b/devtools/client/webconsole/test/browser.ini
@@ -158,43 +158,37 @@ skip-if = e10s # Bug 1042253 - webconsol
 [browser_console_clear_on_reload.js]
 [browser_console_click_focus.js]
 [browser_console_consolejsm_output.js]
 [browser_console_copy_command.js]
 [browser_console_dead_objects.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_copy_entire_message_context_menu.js]
 [browser_console_error_source_click.js]
-skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole e10s tests
 [browser_console_filters.js]
 [browser_console_iframe_messages.js]
-skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole e10s tests
 [browser_console_keyboard_accessibility.js]
 [browser_console_log_inspectable_object.js]
 [browser_console_native_getters.js]
 [browser_console_navigation_marker.js]
 [browser_console_netlogging.js]
 [browser_console_nsiconsolemessage.js]
 skip-if = buildapp == 'mulet'
 [browser_console_optimized_out_vars.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_private_browsing.js]
 skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole e10s tests
 [browser_console_server_logging.js]
 [browser_console_variables_view.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_variables_view_filter.js]
 [browser_console_variables_view_dom_nodes.js]
 [browser_console_variables_view_dont_sort_non_sortable_classes_properties.js]
 skip-if = buildapp == 'mulet'
 [browser_console_variables_view_special_names.js]
 [browser_console_variables_view_while_debugging.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_variables_view_while_debugging_and_inspecting.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_eval_in_debugger_stackframe.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_eval_in_debugger_stackframe2.js]
 [browser_jsterm_inspect.js]
 skip-if = e10s && debug && os == 'win'
 [browser_longstring_hang.js]
 [browser_output_breaks_after_console_dir_uninspectable.js]
 [browser_output_longstring_expand.js]
@@ -214,36 +208,33 @@ skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_580001_closing_after_completion.js]
 [browser_webconsole_bug_580030_errors_after_page_reload.js]
 [browser_webconsole_bug_580454_timestamp_l10n.js]
 [browser_webconsole_bug_582201_duplicate_errors.js]
 [browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js]
 [browser_webconsole_bug_585237_line_limit.js]
 [browser_webconsole_bug_585956_console_trace.js]
 [browser_webconsole_bug_585991_autocomplete_keys.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_585991_autocomplete_popup.js]
 [browser_webconsole_bug_586388_select_all.js]
 [browser_webconsole_bug_587617_output_copy.js]
 [browser_webconsole_bug_588342_document_focus.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
+skip-if = e10s # Bug 1241707 - Focus not restored properly in e10s
 [browser_webconsole_bug_588730_text_node_insertion.js]
 [browser_webconsole_bug_588967_input_expansion.js]
 [browser_webconsole_bug_589162_css_filter.js]
 [browser_webconsole_bug_592442_closing_brackets.js]
 [browser_webconsole_bug_593003_iframe_wrong_hud.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_594497_history_arrow_keys.js]
 [browser_webconsole_bug_595223_file_uri.js]
 [browser_webconsole_bug_595350_multiple_windows_and_tabs.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_595934_message_categories.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_597136_external_script_errors.js]
 [browser_webconsole_bug_597136_network_requests_from_chrome.js]
 [browser_webconsole_bug_597460_filter_scroll.js]
 [browser_webconsole_bug_597756_reopen_closed_tab.js]
 [browser_webconsole_bug_599725_response_headers.js]
 [browser_webconsole_bug_600183_charset.js]
 [browser_webconsole_bug_601177_log_levels.js]
 [browser_webconsole_bug_601352_scroll.js]
@@ -356,17 +347,16 @@ skip-if = e10s # Bug 1042253 - webconsol
 skip-if = e10s # Bug 1042253 - webconsole e10s tests (Linux debug timeout)
 [browser_webconsole_trackingprotection_errors.js]
 tags = trackingprotection
 [browser_webconsole_view_source.js]
 [browser_webconsole_reflow.js]
 [browser_webconsole_log_file_filter.js]
 [browser_webconsole_expandable_timestamps.js]
 [browser_webconsole_autocomplete_in_debugger_stackframe.js]
-skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_autocomplete_popup_close_on_tab_switch.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js]
 [browser_console_hide_jsterm_when_devtools_chrome_enabled_false.js]
 [browser_console_history_persist.js]
 [browser_webconsole_output_01.js]
 skip-if = e10s # Bug 1042253 - webconsole e10s tests
 [browser_webconsole_output_02.js]
diff --git a/devtools/client/webconsole/test/browser_console_error_source_click.js b/devtools/client/webconsole/test/browser_console_error_source_click.js
--- a/devtools/client/webconsole/test/browser_console_error_source_click.js
+++ b/devtools/client/webconsole/test/browser_console_error_source_click.js
@@ -18,22 +18,25 @@ function test() {
   loadTab(TEST_URI).then(() => {
     HUDService.toggleBrowserConsole().then(browserConsoleOpened);
   });
 
   function browserConsoleOpened(hudConsole) {
     hud = hudConsole;
     ok(hud, "browser console opened");
 
-    let button = content.document.querySelector("button");
-    ok(button, "button element found");
+    // On e10s, the exception is triggered in child process
+    // and is ignored by test harness
+    if (!Services.appinfo.browserTabsRemoteAutostart) {
+      expectUncaughtException();
+    }
 
     info("generate exception and wait for the message");
-    executeSoon(() => {
-      expectUncaughtException();
+    ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+      let button = content.document.querySelector("button");
       button.click();
     });
 
     waitForMessages({
       webconsole: hud,
       messages: [
         {
           text: "ReferenceError: foobar is not defined",
diff --git a/devtools/client/webconsole/test/browser_console_iframe_messages.js b/devtools/client/webconsole/test/browser_console_iframe_messages.js
--- a/devtools/client/webconsole/test/browser_console_iframe_messages.js
+++ b/devtools/client/webconsole/test/browser_console_iframe_messages.js
@@ -51,54 +51,62 @@ const expectedMessagesAny = [
     name: "iframe 1 (repeats: 2)",
     text: "iframe 1",
     category: CATEGORY_WEBDEV,
     severity: SEVERITY_LOG,
     repeats: 2
   },
 ];
 
-function test() {
-  expectUncaughtException();
-  loadTab(TEST_URI).then(() => {
-    openConsole().then(consoleOpened);
+add_task(function*() {
+  // On e10s, the exception is triggered in child process
+  // and is ignored by test harness
+  if (!Services.appinfo.browserTabsRemoteAutostart) {
+    expectUncaughtException();
+  }
+
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  yield testWebConsole(hud);
+  yield closeConsole();
+  info("web console closed");
+
+  // The browser console doesn't show page's console.log statements in
+  // e10s windows. See Bug 1241289.
+  if (!Services.appinfo.browserTabsRemoteAutostart) {
+    hud = yield HUDService.toggleBrowserConsole();
+    yield testBrowserConsole(hud);
+    yield closeConsole();
+  }
+});
+
+function* testWebConsole(hud) {
+  ok(hud, "web console opened");
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: expectedMessages,
+  });
+
+  info("first messages matched");
+
+  yield waitForMessages({
+      webconsole: hud,
+      messages: expectedMessagesAny,
+      matchCondition: "any",
   });
 }
 
-function consoleOpened(hud) {
-  ok(hud, "web console opened");
-
-  waitForMessages({
+function* testBrowserConsole(hud) {
+  ok(hud, "browser console opened");
+  yield waitForMessages({
     webconsole: hud,
     messages: expectedMessages,
-  }).then(() => {
-    info("first messages matched");
-    waitForMessages({
-      webconsole: hud,
-      messages: expectedMessagesAny,
-      matchCondition: "any",
-    }).then(() => {
-      closeConsole().then(onWebConsoleClose);
-    });
+  });
+
+  info("first messages matched");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: expectedMessagesAny,
+    matchCondition: "any",
   });
 }
-
-function onWebConsoleClose() {
-  info("web console closed");
-  HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
-}
-
-function onBrowserConsoleOpen(hud) {
-  ok(hud, "browser console opened");
-  waitForMessages({
-    webconsole: hud,
-    messages: expectedMessages,
-  }).then(() => {
-    info("first messages matched");
-    waitForMessages({
-      webconsole: hud,
-      messages: expectedMessagesAny,
-      matchCondition: "any",
-    }).then(() => {
-      closeConsole().then(finishTest);
-    });
-  });
-}
diff --git a/devtools/client/webconsole/test/browser_console_optimized_out_vars.js b/devtools/client/webconsole/test/browser_console_optimized_out_vars.js
--- a/devtools/client/webconsole/test/browser_console_optimized_out_vars.js
+++ b/devtools/client/webconsole/test/browser_console_optimized_out_vars.js
@@ -17,21 +17,22 @@ function test() {
     let hud = yield openConsole(tab);
     let { toolbox, panel, panelWin } = yield openDebugger();
 
     let sources = panelWin.DebuggerView.Sources;
     yield panel.addBreakpoint({ actor: sources.values[0], line: 18 });
     yield ensureThreadClientState(panel, "resumed");
 
     let fetchedScopes = panelWin.once(panelWin.EVENTS.FETCHED_SCOPES);
-    let button = content.document.querySelector("button");
-    ok(button, "Button element found");
-    // Spin the event loop before causing the debuggee to pause, to allow
-    // this function to return first.
-    executeSoon(() => button.click());
+
+    // Cause the debuggee to pause
+    ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+      let button = content.document.querySelector("button");
+      button.click();
+    });
 
     yield fetchedScopes;
     ok(true, "Scopes were fetched");
 
     yield toolbox.selectTool("webconsole");
 
     // This is the meat of the test: evaluate the optimized out variable.
     hud.jsterm.execute("upvar");
diff --git a/devtools/client/webconsole/test/browser_console_variables_view.js b/devtools/client/webconsole/test/browser_console_variables_view.js
--- a/devtools/client/webconsole/test/browser_console_variables_view.js
+++ b/devtools/client/webconsole/test/browser_console_variables_view.js
@@ -104,21 +104,23 @@ function onUpdatedTestPropFound(aResults
   return updateVariablesViewProperty({
     property: prop,
     field: "name",
     string: "testUpdatedProp",
     webconsole: gWebConsole
   });
 }
 
-function onFooObjFetchAfterPropRename(aVar) {
+function* onFooObjFetchAfterPropRename(aVar) {
   info("onFooObjFetchAfterPropRename");
 
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expectedValue = content.document.title + content.location + para;
+  let expectedValue = yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
+    let para = content.wrappedJSObject.document.querySelector("p");
+    return content.document.title + content.location + para;
+  });
 
   // Check that the new value is in the variables view.
   return findVariableViewProperties(aVar, [
     { name: "testUpdatedProp", value: expectedValue },
   ], { webconsole: gWebConsole });
 }
 
 function onRenamedTestPropFound(aResults) {
@@ -135,21 +137,23 @@ function onRenamedTestPropFound(aResults
   return updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "foobarzFailure()",
     webconsole: gWebConsole
   });
 }
 
-function onPropUpdateError(aVar) {
+function* onPropUpdateError(aVar) {
   info("onPropUpdateError");
 
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expectedValue = content.document.title + content.location + para;
+  let expectedValue = yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
+    let para = content.wrappedJSObject.document.querySelector("p");
+    return content.document.title + content.location + para;
+  });
 
   // Make sure the property did not change.
   return findVariableViewProperties(aVar, [
     { name: "testUpdatedProp", value: expectedValue },
   ], { webconsole: gWebConsole });
 }
 
 function onRenamedTestPropFoundAgain(aResults) {
diff --git a/devtools/client/webconsole/test/browser_console_variables_view_while_debugging.js b/devtools/client/webconsole/test/browser_console_variables_view_while_debugging.js
--- a/devtools/client/webconsole/test/browser_console_variables_view_while_debugging.js
+++ b/devtools/client/webconsole/test/browser_console_variables_view_while_debugging.js
@@ -8,120 +8,96 @@
 // from the js debugger, when changing the value of a property in the variables
 // view.
 
 "use strict";
 
 const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
                  "test/test-eval-in-stackframe.html";
 
-var gWebConsole, gJSTerm, gDebuggerWin, gThread, gDebuggerController,
-    gStackframes, gVariablesView;
+add_task(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function test() {
-  loadTab(TEST_URI).then(() => {
-    openConsole().then(consoleOpened);
+  let dbgPanel = yield openDebugger();
+  yield waitForFrameAdded(dbgPanel);
+  yield openConsole();
+  yield testVariablesView(hud);
+});
+
+function* waitForFrameAdded(dbgPanel) {
+  let thread = dbgPanel.panelWin.DebuggerController.activeThread;
+
+  info("Waiting for onFramesAdded");
+  yield new Promise(resolve => {
+    thread.addOneTimeListener("framesadded", resolve);
+    info("firstCall()");
+    ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+      content.wrappedJSObject.firstCall();
+    });
   });
 }
 
-function consoleOpened(hud) {
-  gWebConsole = hud;
-  gJSTerm = hud.jsterm;
-
-  executeSoon(() => {
-    info("openDebugger");
-    openDebugger().then(debuggerOpened);
-  });
-}
-
-function debuggerOpened(aResult) {
-  gDebuggerWin = aResult.panelWin;
-  gDebuggerController = gDebuggerWin.DebuggerController;
-  gThread = gDebuggerController.activeThread;
-  gStackframes = gDebuggerController.StackFrames;
-
-  executeSoon(() => {
-    gThread.addOneTimeListener("framesadded", onFramesAdded);
-
-    info("firstCall()");
-    content.wrappedJSObject.firstCall();
-  });
-}
-
-function onFramesAdded() {
-  info("onFramesAdded");
-
-  executeSoon(() =>
-    openConsole().then(() =>
-      gJSTerm.execute("fooObj").then(onExecuteFooObj)
-    )
-  );
-}
-
-function onExecuteFooObj(msg) {
+function* testVariablesView(hud) {
+  let jsterm = hud.jsterm;
+  let msg = yield jsterm.execute("fooObj");
   ok(msg, "output message found");
   ok(msg.textContent.includes('{ testProp2: "testValue2" }'),
                               "message text check");
 
   let anchor = msg.querySelector("a");
   ok(anchor, "object link found");
 
-  gJSTerm.once("variablesview-fetched", onFooObjFetch);
+  info("Waiting for variable view to appear");
+  let variable = yield new Promise(resolve => {
+    jsterm.once("variablesview-fetched", (e, variable) => {
+      resolve(variable);
+    });
+    executeSoon(() => EventUtils.synthesizeMouse(anchor, 2, 2, {},
+                                                 hud.iframeWindow));
+  });
 
-  executeSoon(() => EventUtils.synthesizeMouse(anchor, 2, 2, {},
-                                               gWebConsole.iframeWindow));
-}
-
-function onFooObjFetch(aEvent, aVar) {
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
-
-  findVariableViewProperties(aVar, [
+  info("Waiting for findVariableViewProperties");
+  let results = yield findVariableViewProperties(variable, [
     { name: "testProp2", value: "testValue2" },
     { name: "testProp", value: "testValue", dontMatch: true },
-  ], { webconsole: gWebConsole }).then(onTestPropFound);
-}
+  ], { webconsole: hud });
 
-function onTestPropFound(aResults) {
-  let prop = aResults[0].matchedProp;
+  let prop = results[0].matchedProp;
   ok(prop, "matched the |testProp2| property in the variables view");
 
   // Check that property value updates work and that jsterm functions can be
   // used.
-  updateVariablesViewProperty({
+  variable = yield updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "document.title + foo2 + $('p')",
-    webconsole: gWebConsole
-  }).then(onFooObjFetchAfterUpdate);
-}
+    webconsole: hud
+  });
 
-function onFooObjFetchAfterUpdate(aVar) {
   info("onFooObjFetchAfterUpdate");
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expectedValue = content.document.title + "foo2SecondCall" + para;
+  let expectedValue = yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
+    let para = content.wrappedJSObject.document.querySelector("p");
+    return content.document.title + "foo2SecondCall" + para;
+  });
 
-  findVariableViewProperties(aVar, [
+  results = yield findVariableViewProperties(variable, [
     { name: "testProp2", value: expectedValue },
-  ], { webconsole: gWebConsole }).then(onUpdatedTestPropFound);
-}
+  ], { webconsole: hud });
 
-function onUpdatedTestPropFound(aResults) {
-  let prop = aResults[0].matchedProp;
+  prop = results[0].matchedProp;
   ok(prop, "matched the updated |testProp2| property value");
 
   // Check that testProp2 was updated.
-  executeSoon(() => {
-    gJSTerm.execute("fooObj.testProp2").then(onExecuteFooObjTestProp2);
+  yield new Promise(resolve => {
+    executeSoon(() => {
+      jsterm.execute("fooObj.testProp2").then(resolve);
+    });
   });
+
+  expectedValue = yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
+    let para = content.wrappedJSObject.document.querySelector("p");
+    return content.document.title + "foo2SecondCall" + para;
+  });
+
+  isnot(hud.outputNode.textContent.indexOf(expectedValue), -1,
+        "fooObj.testProp2 is correct");
 }
-
-function onExecuteFooObjTestProp2() {
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expected = content.document.title + "foo2SecondCall" + para;
-
-  isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
-        "fooObj.testProp2 is correct");
-
-  gWebConsole = gJSTerm = gDebuggerWin = gThread = gDebuggerController =
-    gStackframes = gVariablesView = null;
-  executeSoon(finishTest);
-}
diff --git a/devtools/client/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js b/devtools/client/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js
--- a/devtools/client/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js
+++ b/devtools/client/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js
@@ -7,116 +7,100 @@
 // Test that makes sure web console eval works while the js debugger paused the
 // page, and while the inspector is active. See bug 886137.
 
 "use strict";
 
 const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
                  "test/test-eval-in-stackframe.html";
 
-var gWebConsole, gJSTerm, gDebuggerWin, gThread, gDebuggerController,
-    gStackframes, gVariablesView;
+add_task(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function test() {
-  loadTab(TEST_URI).then(() => {
-    openConsole().then(consoleOpened);
-  }, true);
+  let dbgPanel = yield openDebugger();
+  yield openInspector();
+  yield waitForFrameAdded(dbgPanel);
+
+  yield openConsole();
+  yield testVariablesView(hud);
+});
+
+function* waitForFrameAdded(dbgPanel) {
+  let thread = dbgPanel.panelWin.DebuggerController.activeThread;
+
+  info("Waiting for onFramesAdded");
+  yield new Promise(resolve => {
+    thread.addOneTimeListener("framesadded", resolve);
+    info("firstCall()");
+    ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+      content.wrappedJSObject.firstCall();
+    });
+  });
 }
 
-function consoleOpened(hud) {
-  gWebConsole = hud;
-  gJSTerm = hud.jsterm;
+function* testVariablesView(hud) {
+  info("testVariablesView");
+  let jsterm = hud.jsterm;
 
-  info("openDebugger");
-  openDebugger().then(debuggerOpened);
-}
-
-function debuggerOpened(result) {
-  info("debugger opened");
-  gDebuggerWin = result.panelWin;
-  gDebuggerController = gDebuggerWin.DebuggerController;
-  gThread = gDebuggerController.activeThread;
-  gStackframes = gDebuggerController.StackFrames;
-
-  openInspector().then(inspectorOpened);
-}
-
-function inspectorOpened() {
-  info("inspector opened");
-  gThread.addOneTimeListener("framesadded", onFramesAdded);
-
-  info("firstCall()");
-  content.wrappedJSObject.firstCall();
-}
-
-function onFramesAdded() {
-  info("onFramesAdded");
-
-  openConsole().then(() => gJSTerm.execute("fooObj").then(onExecuteFooObj));
-}
-
-function onExecuteFooObj(msg) {
+  let msg = yield jsterm.execute("fooObj");
   ok(msg, "output message found");
   ok(msg.textContent.includes('{ testProp2: "testValue2" }'),
                               "message text check");
 
   let anchor = msg.querySelector("a");
   ok(anchor, "object link found");
 
-  gJSTerm.once("variablesview-fetched", onFooObjFetch);
+  info("Waiting for variable view to appear");
+  let variable = yield new Promise(resolve => {
+    jsterm.once("variablesview-fetched", (e, variable) => {
+      resolve(variable);
+    });
+    executeSoon(() => EventUtils.synthesizeMouse(anchor, 2, 2, {},
+                                                 hud.iframeWindow));
+  });
 
-  EventUtils.synthesizeMouse(anchor, 2, 2, {}, gWebConsole.iframeWindow);
-}
-
-function onFooObjFetch(aEvent, aVar) {
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
-
-  findVariableViewProperties(aVar, [
+  info("Waiting for findVariableViewProperties");
+  let results = yield findVariableViewProperties(variable, [
     { name: "testProp2", value: "testValue2" },
     { name: "testProp", value: "testValue", dontMatch: true },
-  ], { webconsole: gWebConsole }).then(onTestPropFound);
-}
+  ], { webconsole: hud });
 
-function onTestPropFound(aResults) {
-  let prop = aResults[0].matchedProp;
+  let prop = results[0].matchedProp;
   ok(prop, "matched the |testProp2| property in the variables view");
 
   // Check that property value updates work and that jsterm functions can be
   // used.
-  updateVariablesViewProperty({
+  variable = yield updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "document.title + foo2 + $('p')",
-    webconsole: gWebConsole
-  }).then(onFooObjFetchAfterUpdate);
-}
+    webconsole: hud
+  });
 
-function onFooObjFetchAfterUpdate(aVar) {
   info("onFooObjFetchAfterUpdate");
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expectedValue = content.document.title + "foo2SecondCall" + para;
+  let expectedValue = yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
+    let para = content.wrappedJSObject.document.querySelector("p");
+    return content.document.title + "foo2SecondCall" + para;
+  });
 
-  findVariableViewProperties(aVar, [
+  results = yield findVariableViewProperties(variable, [
     { name: "testProp2", value: expectedValue },
-  ], { webconsole: gWebConsole }).then(onUpdatedTestPropFound);
-}
+  ], { webconsole: hud });
 
-function onUpdatedTestPropFound(aResults) {
-  let prop = aResults[0].matchedProp;
+  prop = results[0].matchedProp;
   ok(prop, "matched the updated |testProp2| property value");
 
   // Check that testProp2 was updated.
-  gJSTerm.execute("fooObj.testProp2").then(onExecuteFooObjTestProp2);
+  yield new Promise(resolve => {
+    executeSoon(() => {
+      jsterm.execute("fooObj.testProp2").then(resolve);
+    });
+  });
+
+  expectedValue = yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
+    let para = content.wrappedJSObject.document.querySelector("p");
+    return content.document.title + "foo2SecondCall" + para;
+  });
+
+  isnot(hud.outputNode.textContent.indexOf(expectedValue), -1,
+        "fooObj.testProp2 is correct");
 }
-
-function onExecuteFooObjTestProp2() {
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expected = content.document.title + "foo2SecondCall" + para;
-
-  isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
-        "fooObj.testProp2 is correct");
-
-  gWebConsole = gJSTerm = gDebuggerWin = gThread = gDebuggerController =
-    gStackframes = gVariablesView = null;
-
-  finishTest();
-}
diff --git a/devtools/client/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js b/devtools/client/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js
--- a/devtools/client/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js
+++ b/devtools/client/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js
@@ -7,62 +7,56 @@
 // Test that makes sure web console autocomplete happens in the user-selected
 // stackframe from the js debugger.
 
 "use strict";
 
 const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
                  "test/test-autocomplete-in-stackframe.html";
 
-var testDriver, gStackframes;
+var gStackframes;
 
-function test() {
-  requestLongerTimeout(2);
-  loadTab(TEST_URI).then(() => {
-    openConsole().then((hud) => {
-      testDriver = testCompletion(hud);
-      testDriver.next();
-    });
-  });
-}
-
-function testNext() {
-  executeSoon(function() {
-    testDriver.next();
-  });
-}
+requestLongerTimeout(2);
+add_task(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  yield testCompletion(hud);
+  gStackframes = null;
+});
 
 function* testCompletion(hud) {
   let jsterm = hud.jsterm;
   let input = jsterm.inputNode;
   let popup = jsterm.autocompletePopup;
 
   // Test that document.title gives string methods. Native getters must execute.
   input.value = "document.title.";
   input.setSelectionRange(input.value.length, input.value.length);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   let newItems = popup.getItems();
   ok(newItems.length > 0, "'document.title.' gave a list of suggestions");
   ok(newItems.some(function(item) {
        return item.label == "substr";
      }), "autocomplete results do contain substr");
   ok(newItems.some(function(item) {
        return item.label == "toLowerCase";
      }), "autocomplete results do contain toLowerCase");
   ok(newItems.some(function(item) {
        return item.label == "strike";
      }), "autocomplete results do contain strike");
 
   // Test if 'f' gives 'foo1' but not 'foo2' or 'foo3'
   input.value = "f";
   input.setSelectionRange(1, 1);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(newItems.length > 0, "'f' gave a list of suggestions");
   ok(!newItems.every(function(item) {
        return item.label != "foo1";
      }), "autocomplete results do contain foo1");
   ok(!newItems.every(function(item) {
        return item.label != "foo1Obj";
@@ -78,48 +72,56 @@ function* testCompletion(hud) {
      }), "autocomplete results do not contain foo3");
   ok(newItems.every(function(item) {
        return item.label != "foo3Obj";
      }), "autocomplete results do not contain foo3Obj");
 
   // Test if 'foo1Obj.' gives 'prop1' and 'prop2'
   input.value = "foo1Obj.";
   input.setSelectionRange(8, 8);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(!newItems.every(function(item) {
        return item.label != "prop1";
      }), "autocomplete results do contain prop1");
   ok(!newItems.every(function(item) {
        return item.label != "prop2";
      }), "autocomplete results do contain prop2");
 
   // Test if 'foo1Obj.prop2.' gives 'prop21'
   input.value = "foo1Obj.prop2.";
   input.setSelectionRange(14, 14);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(!newItems.every(function(item) {
        return item.label != "prop21";
      }), "autocomplete results do contain prop21");
 
-  info("openDebugger");
-  executeSoon(() => openDebugger().then(debuggerOpened));
-  yield undefined;
+  info("Opening Debugger");
+  let dbg = yield openDebugger();
+
+  info("Waiting for pause");
+  yield pauseDebugger(dbg);
+
+  info("Opening Console again");
+  yield openConsole();
 
   // From this point on the
   // Test if 'f' gives 'foo3' and 'foo1' but not 'foo2'
   input.value = "f";
   input.setSelectionRange(1, 1);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(newItems.length > 0, "'f' gave a list of suggestions");
   ok(!newItems.every(function(item) {
        return item.label != "foo3";
      }), "autocomplete results do contain foo3");
   ok(!newItems.every(function(item) {
        return item.label != "foo3Obj";
@@ -132,29 +134,29 @@ function* testCompletion(hud) {
      }), "autocomplete results do contain foo1Obj");
   ok(newItems.every(function(item) {
        return item.label != "foo2";
      }), "autocomplete results do not contain foo2");
   ok(newItems.every(function(item) {
        return item.label != "foo2Obj";
      }), "autocomplete results do not contain foo2Obj");
 
-  openDebugger().then(() => {
-    gStackframes.selectFrame(1);
+  yield openDebugger();
 
-    info("openConsole");
-    executeSoon(() => openConsole().then(() => testDriver.next()));
-  });
-  yield undefined;
+  gStackframes.selectFrame(1);
+
+  info("openConsole");
+  yield openConsole();
 
   // Test if 'f' gives 'foo2' and 'foo1' but not 'foo3'
   input.value = "f";
   input.setSelectionRange(1, 1);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(newItems.length > 0, "'f' gave a list of suggestions");
   ok(!newItems.every(function(item) {
        return item.label != "foo2";
      }), "autocomplete results do contain foo2");
   ok(!newItems.every(function(item) {
        return item.label != "foo2Obj";
@@ -170,75 +172,67 @@ function* testCompletion(hud) {
      }), "autocomplete results do not contain foo3");
   ok(newItems.every(function(item) {
        return item.label != "foo3Obj";
      }), "autocomplete results do not contain foo3Obj");
 
   // Test if 'foo2Obj.' gives 'prop1'
   input.value = "foo2Obj.";
   input.setSelectionRange(8, 8);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(!newItems.every(function(item) {
        return item.label != "prop1";
      }), "autocomplete results do contain prop1");
 
   // Test if 'foo2Obj.prop1.' gives 'prop11'
   input.value = "foo2Obj.prop1.";
   input.setSelectionRange(14, 14);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(!newItems.every(function(item) {
        return item.label != "prop11";
      }), "autocomplete results do contain prop11");
 
   // Test if 'foo2Obj.prop1.prop11.' gives suggestions for a string
   // i.e. 'length'
   input.value = "foo2Obj.prop1.prop11.";
   input.setSelectionRange(21, 21);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   ok(!newItems.every(function(item) {
        return item.label != "length";
      }), "autocomplete results do contain length");
 
   // Test if 'foo1Obj[0].' throws no errors.
   input.value = "foo2Obj[0].";
   input.setSelectionRange(11, 11);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield new Promise(resolve => {
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, resolve);
+  });
 
   newItems = popup.getItems();
   is(newItems.length, 0, "no items for foo2Obj[0]");
-
-  testDriver = null;
-  executeSoon(finishUp);
-  yield undefined;
 }
 
-function debuggerOpened(aResult) {
+function pauseDebugger(aResult) {
   let debuggerWin = aResult.panelWin;
   let debuggerController = debuggerWin.DebuggerController;
   let thread = debuggerController.activeThread;
   gStackframes = debuggerController.StackFrames;
+  return new Promise(resolve => {
+    thread.addOneTimeListener("framesadded", resolve);
 
-  executeSoon(() => {
-    thread.addOneTimeListener("framesadded", onFramesAdded);
     info("firstCall()");
-    content.wrappedJSObject.firstCall();
+    ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+      content.wrappedJSObject.firstCall();
+    });
   });
 }
-
-function onFramesAdded() {
-  info("onFramesAdded, openConsole() now");
-  executeSoon(() => openConsole().then(testNext));
-}
-
-function finishUp() {
-  testDriver = gStackframes = null;
-  finishTest();
-}
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -251,21 +251,23 @@ function testReturnKey() {
     jsterm.setInputValue("window.foobarBug58599");
     EventUtils.synthesizeKey("1", {});
     EventUtils.synthesizeKey(".", {});
   });
 
   return deferred.promise;
 }
 
-function dontShowArrayNumbers() {
+function* dontShowArrayNumbers() {
   let deferred = promise.defer();
 
   info("dontShowArrayNumbers");
-  content.wrappedJSObject.foobarBug585991 = ["Sherlock Holmes"];
+  yield ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+    content.wrappedJSObject.foobarBug585991 = ["Sherlock Holmes"];
+  });
 
   jsterm = HUD.jsterm;
   popup = jsterm.autocompletePopup;
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     let sameItems = popup.getItems().map(function(e) {
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_588342_document_focus.js b/devtools/client/webconsole/test/browser_webconsole_bug_588342_document_focus.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_588342_document_focus.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_588342_document_focus.js
@@ -3,33 +3,38 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 588342";
 
-var fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
 
 add_task(function* () {
   let { browser } = yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-  let hud = yield openConsole();
-  yield consoleOpened(hud);
+  yield checkConsoleFocus(hud);
 
-  is(fm.focusedWindow, browser.contentWindow,
-     "content document has focus");
+  // This is skipped in e10s due to Bug 1241707 not properly restoring
+  // focus.
+  let isFocused = yield ContentTask.spawn(browser, { }, function* () {
+    var fm = Components.classes["@mozilla.org/focus-manager;1"].
+                         getService(Components.interfaces.nsIFocusManager);
+    return fm.focusedWindow == content;
+  });
 
-  fm = null;
+  ok(isFocused, "content document has focus");
 });
 
-function consoleOpened(hud) {
-  let deferred = promise.defer();
-  waitForFocus(function() {
-    is(hud.jsterm.inputNode.getAttribute("focused"), "true",
-       "jsterm input is focused on web console open");
-    isnot(fm.focusedWindow, content, "content document has no focus");
-    closeConsole(null).then(deferred.resolve);
-  }, hud.iframeWindow);
+function* checkConsoleFocus(hud) {
+  let fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
 
-  return deferred.promise;
+  yield new Promise(resolve => {
+    waitForFocus(resolve);
+  });
+
+  is(hud.jsterm.inputNode.getAttribute("focused"), "true",
+     "jsterm input is focused on web console open");
+  is(fm.focusedWindow, hud.iframeWindow, "hud window is focused");
+  yield closeConsole(null);
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js b/devtools/client/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
@@ -11,62 +11,57 @@ const TEST_URI = "http://example.com/bro
 
 const TEST_IFRAME_URI = "http://example.com/browser/devtools/client/" +
                         "webconsole/test/test-bug-593003-iframe-wrong-" +
                         "hud-iframe.html";
 
 const TEST_DUMMY_URI = "http://example.com/browser/devtools/client/" +
                        "webconsole/test/test-console.html";
 
-var tab1, tab2;
+add_task(function*() {
 
-function test() {
-  loadTab(TEST_URI).then(({tab}) => {
-    tab1 = tab;
+  let tab1 = (yield loadTab(TEST_URI)).tab;
+  content.console.log("FOO");
+  yield openConsole();
 
-    content.console.log("FOO");
-    openConsole().then(() => {
-      tab2 = gBrowser.addTab(TEST_DUMMY_URI);
-      gBrowser.selectedTab = tab2;
-      gBrowser.selectedBrowser.addEventListener("load", tab2Loaded, true);
-    });
-  });
+  let tab2 = (yield loadTab(TEST_DUMMY_URI)).tab;
+  yield openConsole(gBrowser.selectedTab);
+
+  info("Reloading tab 1");
+  yield reloadTab(tab1);
+
+  info("Checking for messages");
+  yield checkMessages(tab1, tab2);
+
+  info("Cleaning up");
+  yield closeConsole(tab1);
+  yield closeConsole(tab2);
+});
+
+function* reloadTab(tab) {
+  let loaded = BrowserTestUtils.browserLoaded(tab.linkedBrowser);
+  tab.linkedBrowser.reload();
+  yield loaded;
 }
 
-function tab2Loaded(aEvent) {
-  tab2.linkedBrowser.removeEventListener(aEvent.type, tab2Loaded, true);
-
-  openConsole(gBrowser.selectedTab).then(() => {
-    tab1.linkedBrowser.addEventListener("load", tab1Reloaded, true);
-    tab1.linkedBrowser.contentWindow.location.reload();
-  });
-}
-
-function tab1Reloaded(aEvent) {
-  tab1.linkedBrowser.removeEventListener(aEvent.type, tab1Reloaded, true);
-
-  let hud1 = HUDService.getHudByWindow(tab1.linkedBrowser.contentWindow);
+function* checkMessages(tab1, tab2) {
+  let hud1 = yield openConsole(tab1);
   let outputNode1 = hud1.outputNode;
 
-  waitForMessages({
+  info("Waiting for messages");
+  yield waitForMessages({
     webconsole: hud1,
     messages: [{
       text: TEST_IFRAME_URI,
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
-    }],
-  }).then(() => {
-    let hud2 = HUDService.getHudByWindow(tab2.linkedBrowser.contentWindow);
-    let outputNode2 = hud2.outputNode;
+    }]
+  });
 
-    isnot(outputNode1, outputNode2,
-      "the two HUD outputNodes must be different");
+  let hud2 = yield openConsole(tab2);
+  let outputNode2 = hud2.outputNode;
 
-    let msg = "Didn't find the iframe network request in tab2";
-    testLogEntry(outputNode2, TEST_IFRAME_URI, msg, true, true);
+  isnot(outputNode1, outputNode2,
+    "the two HUD outputNodes must be different");
 
-    closeConsole(tab2).then(() => {
-      gBrowser.removeTab(tab2);
-      tab1 = tab2 = null;
-      executeSoon(finishTest);
-    });
-  });
+  let msg = "Didn't find the iframe network request in tab2";
+  testLogEntry(outputNode2, TEST_IFRAME_URI, msg, true, true);
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js b/devtools/client/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js
@@ -81,17 +81,17 @@ function tab2Loaded(aEvent) {
 
     executeSoon(function() {
       win2.close();
       tab1 = tab2 = win1 = win2 = null;
       finishTest();
     });
   }
 
-  waitForFocus(openConsoles, tab2.linkedBrowser.contentWindow);
+  openConsoles();
 }
 
 function test() {
   loadTab(TEST_URI).then(() => {
     tab1 = gBrowser.selectedTab;
     win1 = window;
     tab1Loaded();
   });
