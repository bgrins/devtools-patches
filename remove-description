# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0acc123cf48988cb4ab13839eca9b4c975c23683
Bug 1448213

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -121,16 +121,17 @@ function getInterfaceProxy(obj) {
 }
 
 // Attach the base class to the window so other scripts can use it:
 window.MozXULElement = MozXULElement;
 
 for (let script of [
   "chrome://global/content/elements/stringbundle.js",
   "chrome://global/content/elements/general.js",
+  "chrome://global/content/elements/text.js",
   "chrome://global/content/elements/textbox.js",
   "chrome://global/content/elements/tabbox.js",
 ]) {
   Services.scriptloader.loadSubScript(script, window);
 }
 
 customElements.setElementCreationCallback("printpreview-toolbar", type => {
   Services.scriptloader.loadSubScript(
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -98,15 +98,16 @@ toolkit.jar:
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
+   content/global/elements/text.js             (widgets/text.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
    content/global/gmp-sources/widevinecdm.json (gmp-sources/widevinecdm.json)
diff --git a/toolkit/content/minimal-xul.css b/toolkit/content/minimal-xul.css
--- a/toolkit/content/minimal-xul.css
+++ b/toolkit/content/minimal-xul.css
@@ -45,20 +45,16 @@
 /* hide the content, but don't destroy the frames */
 [collapsed="true"],
 [moz-collapsed="true"] {
   visibility: collapse;
 }
 
 /********** label **********/
 
-description {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#text-base");
-}
-
 label {
   -moz-binding: url("chrome://global/content/bindings/text.xml#text-label");
 }
 
 label.text-link, label[onclick] {
   -moz-binding: url("chrome://global/content/bindings/text.xml#text-link");
   -moz-user-focus: normal;
 }
diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/text.js
@@ -0,0 +1,613 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+class MozTextBase extends MozXULElement {
+  set disabled(val) {
+    if (val) this.setAttribute("disabled", "true");
+    else this.removeAttribute("disabled");
+    return val;
+  }
+
+  get disabled() {
+    return this.getAttribute("disabled") == "true";
+  }
+
+  set value(val) {
+    this.setAttribute("value", val);
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+
+  set crop(val) {
+    this.setAttribute("crop", val);
+    return val;
+  }
+
+  get crop() {
+    return this.getAttribute("crop");
+  }
+}
+
+customElements.define("description", MozTextBase);
+
+// class MozLabelControl extends MozTextLabel {
+//   connectedCallback() {
+//     super.connectedCallback()
+//     this.appendChild(MozXULElement.parseXULToFragment(`
+//       <children></children>
+//       <html:span anonid="accessKeyParens"></html:span>
+//     `));
+//     this.mUnderlineAccesskey = !/Mac/.test(navigator.platform);
+
+//     this.mInsertSeparator = "";
+
+//     this.mAlwaysAppendAccessKey = false;
+
+//     this.formatAccessKey(true);
+
+//     this._setupEventListeners();
+//   }
+
+//   set accessKey(val) {
+//     // If this label already has an accesskey attribute store it here as well
+//     if (this.hasAttribute("accesskey")) {
+//       this.setAttribute("accesskey", val);
+//     }
+//     var control = this.labeledControlElement;
+//     if (control) {
+//       control.setAttribute("accesskey", val);
+//     }
+//     this.formatAccessKey(false);
+//     return val;
+//   }
+
+//   get accessKey() {
+//     var accessKey = null;
+//     var labeledEl = this.labeledControlElement;
+//     if (labeledEl) {
+//       accessKey = labeledEl.getAttribute("accesskey");
+//     }
+//     if (!accessKey) {
+//       accessKey = this.getAttribute("accesskey");
+//     }
+//     return accessKey ? accessKey[0] : null;
+//   }
+
+//   get labeledControlElement() {
+//     var control = this.control;
+//     return control ? document.getElementById(control) : null;
+//   }
+
+//   set control(val) {
+//     var control = this.labeledControlElement;
+//     if (control) {
+//       control.labelElement = null; // No longer pointed to be this label
+//     }
+//     this.setAttribute("control", val);
+//     this.formatAccessKey(false);
+//     return val;
+//   }
+
+//   get control() {
+//     return this.getAttribute('control');
+//   }
+
+//   formatAccessKey(firstTime) {
+//     var control = this.labeledControlElement;
+//     if (!control) {
+//       var bindingParent = document.getBindingParent(this);
+//       if (bindingParent instanceof Ci.nsIDOMXULLabeledControlElement) {
+//         control = bindingParent; // For controls that make the <label> an anon child
+//       }
+//     }
+//     if (control) {
+//       control.labelElement = this;
+//     }
+
+//     var accessKey = this.accessKey;
+//     // No need to remove existing formatting the first time.
+//     if (firstTime && !accessKey)
+//       return;
+
+//     if (this.mInsertSeparator === undefined) {
+//       try {
+//         var prefs = Cc["@mozilla.org/preferences-service;1"].
+//         getService(Ci.nsIPrefBranch);
+//         this.mUnderlineAccesskey = (prefs.getIntPref("ui.key.menuAccessKey") != 0);
+
+//         const nsIPrefLocalizedString =
+//           Ci.nsIPrefLocalizedString;
+
+//         const prefNameInsertSeparator =
+//           "intl.menuitems.insertseparatorbeforeaccesskeys";
+//         const prefNameAlwaysAppendAccessKey =
+//           "intl.menuitems.alwaysappendaccesskeys";
+
+//         var val = prefs.getComplexValue(prefNameInsertSeparator,
+//           nsIPrefLocalizedString).data;
+//         this.mInsertSeparator = (val == "true");
+
+//         val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+//           nsIPrefLocalizedString).data;
+//         this.mAlwaysAppendAccessKey = (val == "true");
+//       } catch (e) {
+//         this.mInsertSeparator = true;
+//       }
+//     }
+
+//     if (!this.mUnderlineAccesskey)
+//       return;
+
+//     var afterLabel = document.getAnonymousElementByAttribute(this, "anonid", "accessKeyParens");
+//     afterLabel.textContent = "";
+
+//     var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
+//     if (oldAccessKey) { // Clear old accesskey
+//       this.mergeElement(oldAccessKey);
+//     }
+
+//     var oldHiddenSpan =
+//       this.getElementsByAttribute("class", "hiddenColon").item(0);
+//     if (oldHiddenSpan) {
+//       this.mergeElement(oldHiddenSpan);
+//     }
+
+//     var labelText = this.textContent;
+//     if (!accessKey || !labelText || !control) {
+//       return;
+//     }
+//     var accessKeyIndex = -1;
+//     if (!this.mAlwaysAppendAccessKey) {
+//       accessKeyIndex = labelText.indexOf(accessKey);
+//       if (accessKeyIndex < 0) { // Try again in upper case
+//         accessKeyIndex =
+//           labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+//       }
+//     } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+//       accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+//     }
+
+//     const HTML_NS = "http://www.w3.org/1999/xhtml";
+//     var span = document.createElementNS(HTML_NS, "span");
+//     span.className = "accesskey";
+
+//     // Note that if you change the following code, see the comment of
+//     // nsTextBoxFrame::UpdateAccessTitle.
+
+//     // If accesskey is not in string, append in parentheses
+//     if (accessKeyIndex < 0) {
+//       // If end is colon, we should insert before colon.
+//       // i.e., "label:" -> "label(X):"
+//       var colonHidden = false;
+//       if (/:$/.test(labelText)) {
+//         labelText = labelText.slice(0, -1);
+//         var hiddenSpan = document.createElementNS(HTML_NS, "span");
+//         hiddenSpan.className = "hiddenColon";
+//         hiddenSpan.style.display = "none";
+//         // Hide the last colon by using span element.
+//         // I.e., label<span style="display:none;">:</span>
+//         this.wrapChar(hiddenSpan, labelText.length);
+//         colonHidden = true;
+//       }
+//       // If end is space(U+20),
+//       // we should not add space before parentheses.
+//       var endIsSpace = false;
+//       if (/ $/.test(labelText)) {
+//         endIsSpace = true;
+//       }
+//       if (this.mInsertSeparator && !endIsSpace)
+//         afterLabel.textContent = " (";
+//       else
+//         afterLabel.textContent = "(";
+//       span.textContent = accessKey.toUpperCase();
+//       afterLabel.appendChild(span);
+//       if (!colonHidden)
+//         afterLabel.appendChild(document.createTextNode(")"));
+//       else
+//         afterLabel.appendChild(document.createTextNode("):"));
+//       return;
+//     }
+//     this.wrapChar(span, accessKeyIndex);
+//   }
+
+//   wrapChar(element, index) {
+//     var treeWalker = document.createTreeWalker(this,
+//       NodeFilter.SHOW_TEXT,
+//       null);
+//     var node = treeWalker.nextNode();
+//     while (index >= node.length) {
+//       index -= node.length;
+//       node = treeWalker.nextNode();
+//     }
+//     if (index) {
+//       node = node.splitText(index);
+//     }
+//     node.parentNode.insertBefore(element, node);
+//     if (node.length > 1) {
+//       node.splitText(1);
+//     }
+//     element.appendChild(node);
+//   }
+
+//   mergeElement(element) {
+//     if (element.previousSibling instanceof Text) {
+//       element.previousSibling.appendData(element.textContent);
+//     } else {
+//       element.parentNode.insertBefore(element.firstChild, element);
+//     }
+//     element.remove();
+//   }
+
+//   _setupEventListeners() {
+//     this.addEventListener("click", (event) => {
+//       if (this.disabled) {
+//         return;
+//       }
+//       var controlElement = this.labeledControlElement;
+//       if (!controlElement) {
+//         return;
+//       }
+//       controlElement.focus();
+//       const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+//       if (controlElement.namespaceURI != XUL_NS) {
+//         return;
+//       }
+//       if (controlElement.localName == "checkbox") {
+//         controlElement.checked = !controlElement.checked;
+//       } else if (controlElement.localName == "radio") {
+//         controlElement.control.selectedItem = controlElement;
+//       }
+//     });
+
+//   }
+// }
+
+// customElements.define("label-control", MozLabelControl);
+
+// class MozLabelControl extends MozTextLabel {
+//   connectedCallback() {
+//     super.connectedCallback()
+//     this.appendChild(MozXULElement.parseXULToFragment(`
+//       <children></children>
+//       <html:span anonid="accessKeyParens"></html:span>
+//     `));
+//     this.mUnderlineAccesskey = !/Mac/.test(navigator.platform);
+
+//     this.mInsertSeparator = "";
+
+//     this.mAlwaysAppendAccessKey = false;
+
+//     this.formatAccessKey(true);
+
+//     this._setupEventListeners();
+//   }
+
+//   set accessKey(val) {
+//     // If this label already has an accesskey attribute store it here as well
+//     if (this.hasAttribute("accesskey")) {
+//       this.setAttribute("accesskey", val);
+//     }
+//     var control = this.labeledControlElement;
+//     if (control) {
+//       control.setAttribute("accesskey", val);
+//     }
+//     this.formatAccessKey(false);
+//     return val;
+//   }
+
+//   get accessKey() {
+//     var accessKey = null;
+//     var labeledEl = this.labeledControlElement;
+//     if (labeledEl) {
+//       accessKey = labeledEl.getAttribute("accesskey");
+//     }
+//     if (!accessKey) {
+//       accessKey = this.getAttribute("accesskey");
+//     }
+//     return accessKey ? accessKey[0] : null;
+//   }
+
+//   get labeledControlElement() {
+//     var control = this.control;
+//     return control ? document.getElementById(control) : null;
+//   }
+
+//   set control(val) {
+//     var control = this.labeledControlElement;
+//     if (control) {
+//       control.labelElement = null; // No longer pointed to be this label
+//     }
+//     this.setAttribute("control", val);
+//     this.formatAccessKey(false);
+//     return val;
+//   }
+
+//   get control() {
+//     return this.getAttribute('control');
+//   }
+
+//   formatAccessKey(firstTime) {
+//     var control = this.labeledControlElement;
+//     if (!control) {
+//       var bindingParent = document.getBindingParent(this);
+//       if (bindingParent instanceof Ci.nsIDOMXULLabeledControlElement) {
+//         control = bindingParent; // For controls that make the <label> an anon child
+//       }
+//     }
+//     if (control) {
+//       control.labelElement = this;
+//     }
+
+//     var accessKey = this.accessKey;
+//     // No need to remove existing formatting the first time.
+//     if (firstTime && !accessKey)
+//       return;
+
+//     if (this.mInsertSeparator === undefined) {
+//       try {
+//         var prefs = Cc["@mozilla.org/preferences-service;1"].
+//         getService(Ci.nsIPrefBranch);
+//         this.mUnderlineAccesskey = (prefs.getIntPref("ui.key.menuAccessKey") != 0);
+
+//         const nsIPrefLocalizedString =
+//           Ci.nsIPrefLocalizedString;
+
+//         const prefNameInsertSeparator =
+//           "intl.menuitems.insertseparatorbeforeaccesskeys";
+//         const prefNameAlwaysAppendAccessKey =
+//           "intl.menuitems.alwaysappendaccesskeys";
+
+//         var val = prefs.getComplexValue(prefNameInsertSeparator,
+//           nsIPrefLocalizedString).data;
+//         this.mInsertSeparator = (val == "true");
+
+//         val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+//           nsIPrefLocalizedString).data;
+//         this.mAlwaysAppendAccessKey = (val == "true");
+//       } catch (e) {
+//         this.mInsertSeparator = true;
+//       }
+//     }
+
+//     if (!this.mUnderlineAccesskey)
+//       return;
+
+//     var afterLabel = document.getAnonymousElementByAttribute(this, "anonid", "accessKeyParens");
+//     afterLabel.textContent = "";
+
+//     var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
+//     if (oldAccessKey) { // Clear old accesskey
+//       this.mergeElement(oldAccessKey);
+//     }
+
+//     var oldHiddenSpan =
+//       this.getElementsByAttribute("class", "hiddenColon").item(0);
+//     if (oldHiddenSpan) {
+//       this.mergeElement(oldHiddenSpan);
+//     }
+
+//     var labelText = this.textContent;
+//     if (!accessKey || !labelText || !control) {
+//       return;
+//     }
+//     var accessKeyIndex = -1;
+//     if (!this.mAlwaysAppendAccessKey) {
+//       accessKeyIndex = labelText.indexOf(accessKey);
+//       if (accessKeyIndex < 0) { // Try again in upper case
+//         accessKeyIndex =
+//           labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+//       }
+//     } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+//       accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+//     }
+
+//     const HTML_NS = "http://www.w3.org/1999/xhtml";
+//     var span = document.createElementNS(HTML_NS, "span");
+//     span.className = "accesskey";
+
+//     // Note that if you change the following code, see the comment of
+//     // nsTextBoxFrame::UpdateAccessTitle.
+
+//     // If accesskey is not in string, append in parentheses
+//     if (accessKeyIndex < 0) {
+//       // If end is colon, we should insert before colon.
+//       // i.e., "label:" -> "label(X):"
+//       var colonHidden = false;
+//       if (/:$/.test(labelText)) {
+//         labelText = labelText.slice(0, -1);
+//         var hiddenSpan = document.createElementNS(HTML_NS, "span");
+//         hiddenSpan.className = "hiddenColon";
+//         hiddenSpan.style.display = "none";
+//         // Hide the last colon by using span element.
+//         // I.e., label<span style="display:none;">:</span>
+//         this.wrapChar(hiddenSpan, labelText.length);
+//         colonHidden = true;
+//       }
+//       // If end is space(U+20),
+//       // we should not add space before parentheses.
+//       var endIsSpace = false;
+//       if (/ $/.test(labelText)) {
+//         endIsSpace = true;
+//       }
+//       if (this.mInsertSeparator && !endIsSpace)
+//         afterLabel.textContent = " (";
+//       else
+//         afterLabel.textContent = "(";
+//       span.textContent = accessKey.toUpperCase();
+//       afterLabel.appendChild(span);
+//       if (!colonHidden)
+//         afterLabel.appendChild(document.createTextNode(")"));
+//       else
+//         afterLabel.appendChild(document.createTextNode("):"));
+//       return;
+//     }
+//     this.wrapChar(span, accessKeyIndex);
+//   }
+
+//   wrapChar(element, index) {
+//     var treeWalker = document.createTreeWalker(this,
+//       NodeFilter.SHOW_TEXT,
+//       null);
+//     var node = treeWalker.nextNode();
+//     while (index >= node.length) {
+//       index -= node.length;
+//       node = treeWalker.nextNode();
+//     }
+//     if (index) {
+//       node = node.splitText(index);
+//     }
+//     node.parentNode.insertBefore(element, node);
+//     if (node.length > 1) {
+//       node.splitText(1);
+//     }
+//     element.appendChild(node);
+//   }
+
+//   mergeElement(element) {
+//     if (element.previousSibling instanceof Text) {
+//       element.previousSibling.appendData(element.textContent);
+//     } else {
+//       element.parentNode.insertBefore(element.firstChild, element);
+//     }
+//     element.remove();
+//   }
+
+//   _setupEventListeners() {
+//     this.addEventListener("click", (event) => {
+//       if (this.disabled) {
+//         return;
+//       }
+//       var controlElement = this.labeledControlElement;
+//       if (!controlElement) {
+//         return;
+//       }
+//       controlElement.focus();
+//       const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+//       if (controlElement.namespaceURI != XUL_NS) {
+//         return;
+//       }
+//       if (controlElement.localName == "checkbox") {
+//         controlElement.checked = !controlElement.checked;
+//       } else if (controlElement.localName == "radio") {
+//         controlElement.control.selectedItem = controlElement;
+//       }
+//     });
+
+//   }
+// }
+
+
+// class MozTextLink extends MozTextLabel {
+//   connectedCallback() {
+//     super.connectedCallback()
+
+//     this._setupEventListeners();
+//   }
+
+//   set href(val) {
+//     this.setAttribute('href', val);
+//     return val;
+//   }
+
+//   get href() {
+//     return this.getAttribute('href');
+//   }
+
+//   open(aEvent) {
+//     var href = this.href;
+//     if (!href || this.disabled || aEvent.defaultPrevented)
+//       return;
+
+//     var uri = null;
+//     try {
+//       const nsISSM = Ci.nsIScriptSecurityManager;
+//       const secMan =
+//         Cc["@mozilla.org/scriptsecuritymanager;1"]
+//         .getService(nsISSM);
+
+//       const ioService =
+//         Cc["@mozilla.org/network/io-service;1"]
+//         .getService(Ci.nsIIOService);
+
+//       uri = ioService.newURI(href);
+
+//       let principal;
+//       if (this.getAttribute("useoriginprincipal") == "true") {
+//         principal = this.nodePrincipal;
+//       } else {
+//         principal = secMan.createNullPrincipal({});
+//       }
+//       try {
+//         secMan.checkLoadURIWithPrincipal(principal, uri,
+//           nsISSM.DISALLOW_INHERIT_PRINCIPAL);
+//       } catch (ex) {
+//         var msg = "Error: Cannot open a " + uri.scheme + ": link using \
+//                          the text-link binding.";
+//         Cu.reportError(msg);
+//         return;
+//       }
+
+//       const cID = "@mozilla.org/uriloader/external-protocol-service;1";
+//       const nsIEPS = Ci.nsIExternalProtocolService;
+//       var protocolSvc = Cc[cID].getService(nsIEPS);
+
+//       // if the scheme is not an exposed protocol, then opening this link
+//       // should be deferred to the system's external protocol handler
+//       if (!protocolSvc.isExposedProtocol(uri.scheme)) {
+//         protocolSvc.loadURI(uri);
+//         aEvent.preventDefault();
+//         return;
+//       }
+
+//     } catch (ex) {
+//       Cu.reportError(ex);
+//     }
+
+//     aEvent.preventDefault();
+//     href = uri ? uri.spec : href;
+
+//     // Try handing off the link to the host application, e.g. for
+//     // opening it in a tabbed browser.
+//     var linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
+//       .createInstance(Ci.nsISupportsPRBool);
+//     linkHandled.data = false;
+//     let { shiftKey, ctrlKey, metaKey, altKey, button } = aEvent;
+//     let data = { shiftKey, ctrlKey, metaKey, altKey, button, href };
+//     Cc["@mozilla.org/observer-service;1"]
+//       .getService(Ci.nsIObserverService)
+//       .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
+//     if (linkHandled.data)
+//       return;
+
+//     // otherwise, fall back to opening the anchor directly
+//     var win = window;
+//     if (window.isChromeWindow) {
+//       while (win.opener && !win.opener.closed)
+//         win = win.opener;
+//     }
+//     win.open(href);
+//   }
+
+//   _setupEventListeners() {
+//     this.addEventListener("click", (event) => { this.open(event) }, true);
+
+//     this.addEventListener("click", (event) => { this.open(event) }, true);
+
+//     this.addEventListener("keypress", (event) => { if (event.keyCode != KeyEvent.DOM_VK_RETURN) { return; } this.click() });
+
+//   }
+// }
+
+}
