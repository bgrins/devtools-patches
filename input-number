# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f4c8daa7653d4d77687cc5fac1bb9648342d85f2
Bug 1172164 - Don't allow the walker to start with a node that it doesn't recognize due to a filter;r=pbrosset

diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1290,17 +1290,19 @@ var WalkerActor = protocol.ActorClass({
   },
 
   toString: function() {
     return "[WalkerActor " + this.actorID + "]";
   },
 
   getDocumentWalker: function(node, whatToShow) {
     // Allow native anon content (like <video> controls) if preffed on
-    let nodeFilter = this.showAllAnonymousContent ? allAnonymousContentTreeWalkerFilter : standardTreeWalkerFilter;
+    let nodeFilter = this.showAllAnonymousContent ?
+                        allAnonymousContentTreeWalkerFilter :
+                        standardTreeWalkerFilter;
     return new DocumentWalker(node, this.rootWin, whatToShow, nodeFilter);
   },
 
   destroy: function() {
     try {
       this._destroyed = true;
 
       this.clearPseudoClassLocks();
@@ -1413,24 +1415,26 @@ var WalkerActor = protocol.ActorClass({
    *
    * @param {(Node[]|NodeActor[])} nodes The nodes
    * @return {Object} An object compatible with the disconnectedNodeArray type.
    */
   attachElements: function(nodes) {
     let nodeActors = [];
     let newParents = new Set();
     for (let node of nodes) {
-      // Be sure we deal with NodeActor only.
-      if (!(node instanceof NodeActor))
-        node = this._ref(node);
-
-      this.ensurePathToRoot(node, newParents);
-      // If nodes may be an array of raw nodes, we're sure to only have
-      // NodeActors with the following array.
-      nodeActors.push(node);
+      let rawNode = node;
+      if (node instanceof NodeActor) {
+        rawNode = node.rawNode;
+      }
+      rawNode = this.getDocumentWalker(rawNode).currentNode;
+      let actor = this._ref(rawNode);
+      this.ensurePathToRoot(actor, newParents);
+      // We are sure to only have an array of NodeActors here, even though
+      // raw nodes could have been passed into the function.
+      nodeActors.push(actor);
     }
 
     return {
       nodes: nodeActors,
       newParents: [...newParents]
     };
   },
 
@@ -3777,18 +3781,25 @@ function DocumentWalker(node, rootWin, w
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
   this.walker.init(rootWin.document, whatToShow);
+  this.filter = filter;
+
+  // Make sure that the walker knows about the initial node (which could
+  // be skipped due to a filter).
   this.walker.currentNode = node;
-  this.filter = filter;
+  while (node &&
+         this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+    node = this.walker.parentNode();
+  }
 }
 
 DocumentWalker.prototype = {
   get node() {
     return this.walker.node;
   },
   get whatToShow() {
     return this.walker.whatToShow;
