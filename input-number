# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  67db850294e49c0ac66c6e923d5de2442d5b173c
Bug 1172164 - Don't allow the walker to start with a node that it doesn't recognize due to a filter;r=pbrosset

diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1290,17 +1290,19 @@ var WalkerActor = protocol.ActorClass({
   },
 
   toString: function() {
     return "[WalkerActor " + this.actorID + "]";
   },
 
   getDocumentWalker: function(node, whatToShow) {
     // Allow native anon content (like <video> controls) if preffed on
-    let nodeFilter = this.showAllAnonymousContent ? allAnonymousContentTreeWalkerFilter : standardTreeWalkerFilter;
+    let nodeFilter = this.showAllAnonymousContent
+                        ? allAnonymousContentTreeWalkerFilter
+                        : standardTreeWalkerFilter;
     return new DocumentWalker(node, this.rootWin, whatToShow, nodeFilter);
   },
 
   destroy: function() {
     try {
       this._destroyed = true;
 
       this.clearPseudoClassLocks();
@@ -1413,19 +1415,26 @@ var WalkerActor = protocol.ActorClass({
    *
    * @param {(Node[]|NodeActor[])} nodes The nodes
    * @return {Object} An object compatible with the disconnectedNodeArray type.
    */
   attachElements: function(nodes) {
     let nodeActors = [];
     let newParents = new Set();
     for (let node of nodes) {
-      // Be sure we deal with NodeActor only.
-      if (!(node instanceof NodeActor))
+      if (!(node instanceof NodeActor)) {
+        // If an anonymous node was passed in and we aren't supposed to know
+        // about it, then consult with the document walker as the source of
+        // truth about which elements exist.
+        if (!this.showAllAnonymousContent && LayoutHelpers.isAnonymous(node)) {
+          node = this.getDocumentWalker(node).currentNode;
+        }
+
         node = this._ref(node);
+      }
 
       this.ensurePathToRoot(node, newParents);
       // If nodes may be an array of raw nodes, we're sure to only have
       // NodeActors with the following array.
       nodeActors.push(node);
     }
 
     return {
@@ -3777,18 +3786,26 @@ function DocumentWalker(node, rootWin, w
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
   this.walker.init(rootWin.document, whatToShow);
+  this.filter = filter;
+
+  // Make sure that the walker knows about the initial node (which could
+  // be skipped due to a filter).  Note that simply calling parentNode()
+  // causes currentNode to be updated.
   this.walker.currentNode = node;
-  this.filter = filter;
+  while (node &&
+         this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+    node = this.walker.parentNode();
+  }
 }
 
 DocumentWalker.prototype = {
   get node() {
     return this.walker.node;
   },
   get whatToShow() {
     return this.walker.whatToShow;
diff --git a/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html b/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html
--- a/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html
+++ b/toolkit/devtools/server/tests/mochitest/test_inspector-anonymous.html
@@ -8,20 +8,23 @@ https://bugzilla.mozilla.org/show_bug.cg
   <title>Test for Bug 777674</title>
 
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
   <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
   <script type="application/javascript;version=1.8" src="inspector-helpers.js"></script>
   <script type="application/javascript;version=1.8">
 window.onload = function() {
   Components.utils.import("resource://gre/modules/devtools/Loader.jsm");
+  const Ci = Components.interfaces;
   const {Promise: promise} =
     Components.utils.import("resource://gre/modules/Promise.jsm", {});
   const {InspectorFront} =
     devtools.require("devtools/server/actors/inspector");
+  const {_documentWalker} =
+    devtools.require("devtools/server/actors/inspector");
   const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
   Services.prefs.setBoolPref("dom.webcomponents.enabled", true);
   SimpleTest.waitForExplicitFinish();
   SimpleTest.registerCleanupFunction(() => {
     Services.prefs.clearUserPref("dom.webcomponents.enabled");
   });
 
@@ -64,16 +67,42 @@ window.onload = function() {
     let children = yield gWalker.children(select);
 
     is (select.numChildren, 2, "No native anon content for form control");
     is (children.nodes.length, 2, "No native anon content for form control");
 
     runNextTest();
   });
 
+  addAsyncTest(function* testNativeAnonymousStartingNode() {
+    info ("Tests attaching an element that a walker can't see.");
+
+    let serverConnection = gWalker.conn._transport._serverConnection;
+    let serverWalker = serverConnection.getActor(gWalker.actorID);
+    let docwalker = new _documentWalker(
+      gInspectee.querySelector("select"),
+      gInspectee.defaultView,
+      Ci.nsIDOMNodeFilter.SHOW_ALL,
+      () => {
+        return Ci.nsIDOMNodeFilter.FILTER_ACCEPT
+      }
+    );
+    let scrollbar = docwalker.lastChild();
+    is (scrollbar.tagName, "scrollbar", "An anonymous child has been fetched");
+
+    let node = yield serverWalker.attachElement(scrollbar);
+
+    ok (node, "A response has arrived");
+    ok (node.node, "A node is in the response");
+    is (node.node.rawNode.tagName, "SELECT",
+      "The node has changed to a parent that the walker recognizes");
+
+    runNextTest();
+  });
+
   addAsyncTest(function* testPseudoElements() {
     info ("Testing pseudo elements with walker.");
 
     // Markup looks like: <div><::before /><span /><::after /></div>
     let pseudo = yield gWalker.querySelector(gWalker.rootNode, "#pseudo");
     let children = yield gWalker.children(pseudo);
 
     is (pseudo.numChildren, 1, "::before/::after are not counted if there is a child");
