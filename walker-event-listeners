# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7ab30495aaa276d43dc22205b550791f10dc22d5
Bug 1157469 - Event listeners bubble doesn't get updated when a listener is added after it's loaded in the markup view

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -730,17 +730,19 @@ MarkupView.prototype = {
       }
 
       let container = this.getContainer(target);
       if (!container) {
         // Container might not exist if this came from a load event for a node
         // we're not viewing.
         continue;
       }
-      if (type === "attributes" || type === "characterData") {
+      if (type === "events") {
+        container.update();
+      } else if (type === "attributes" || type === "characterData") {
         container.update();
 
         // Auto refresh style properties on selected node when they change.
         if (type === "attributes" && container.selected) {
           requiresLayoutChange = true;
         }
       } else if (type === "childList") {
         container.childrenDirty = true;
@@ -2387,17 +2389,16 @@ function ElementEditor(aContainer, aNode
         console.error(x);
       }
     }
   });
 
   let tagName = this.node.nodeName.toLowerCase();
   this.tag.textContent = tagName;
   this.closeTag.textContent = tagName;
-  this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";
 
   this.update();
   this.initialized = true;
 }
 
 ElementEditor.prototype = {
 
   flashAttribute: function(attrName) {
@@ -2413,16 +2414,18 @@ ElementEditor.prototype = {
   },
 
   /**
    * Update the state of the editor from the node.
    */
   update: function() {
     let nodeAttributes = this.node.attributes || [];
 
+    this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";
+
     // Keep the data model in sync with attributes on the node.
     let currentAttributes = new Set(nodeAttributes.map(a=>a.name));
     for (let name of this.attrElements.keys()) {
       if (!currentAttributes.has(name)) {
         this.removeAttribute(name);
       }
     }
 
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -796,16 +796,18 @@ let NodeFront = protocol.FrontClass(Node
           value: change.newValue
         });
       }
     } else if (change.type === "characterData") {
       this._form.shortValue = change.newValue;
       this._form.incompleteValue = change.incompleteValue;
     } else if (change.type === "pseudoClassLock") {
       this._form.pseudoClassLocks = change.pseudoClassLocks;
+    } else if (change.type === "events") {
+      this._form.hasEventListeners = change.hasEventListeners;
     }
   },
 
   // Some accessors to make NodeFront feel more like an nsIDOMNode
 
   get id() this.getAttribute("id"),
 
   get nodeType() this._form.nodeType,
@@ -1166,16 +1168,19 @@ var WalkerActor = protocol.ActorClass({
     this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
     this.showAllAnonymousContent = options.showAllAnonymousContent;
 
+    this._onEventListenerChange = this._onEventListenerChange.bind(this);
+    eventListenerService.addListenerChangeListener(this._onEventListenerChange);
+
     this.layoutHelpers = new LayoutHelpers(this.rootWin);
 
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
     this._orphaned = new Set();
 
     // The client can tell the walker that it is interested in a node
@@ -1194,16 +1199,33 @@ var WalkerActor = protocol.ActorClass({
     // managed.
     this.rootNode = this.document();
 
     this.reflowObserver = getLayoutChangesObserver(this.tabActor);
     this._onReflows = this._onReflows.bind(this);
     this.reflowObserver.on("reflows", this._onReflows);
   },
 
+  // Callback for eventListenerService.addListenerChangeListener
+  _onEventListenerChange: function(array) {
+    var e = array.enumerate();
+    while (e.hasMoreElements()) {
+      var current = e.getNext();
+      if (this._refMap.has(current)) {
+        let actor = this._refMap.get(current);
+        let mutation = {
+          type: "events",
+          target: actor.actorID,
+          hasEventListeners: actor._hasEventListeners
+        };
+        this.queueMutation(mutation);
+      }
+    }
+  },
+
   // Returns the JSON representation of this object over the wire.
   form: function() {
     return {
       actor: this.actorID,
       root: this.rootNode.form()
     }
   },
 
@@ -1216,16 +1238,18 @@ var WalkerActor = protocol.ActorClass({
     let nodeFilter = this.showAllAnonymousContent ? allAnonymousContentTreeWalkerFilter : standardTreeWalkerFilter;
     return new DocumentWalker(node, this.rootWin, whatToShow, nodeFilter);
   },
 
   destroy: function() {
     try {
       this._destroyed = true;
 
+      eventListenerService.removeListenerChangeListener(this._onEventListenerChange);
+
       this.clearPseudoClassLocks();
       this._activePseudoClassLocks = null;
 
       this._hoveredNode = null;
       this.rootDoc = null;
 
       this.reflowObserver.off("reflows", this._onReflows);
       this.reflowObserver = null;
