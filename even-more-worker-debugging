# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  85abf398b57b5841a4cf6af0ccaed015aab8fb7b

diff --git a/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js b/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js
--- a/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js
+++ b/devtools/client/debugger/test/mochitest/browser_dbg_worker-console.js
@@ -5,17 +5,16 @@
 
 var TAB_URL = EXAMPLE_URL + "doc_WorkerActor.attachThread-tab.html";
 var WORKER_URL = "code_WorkerActor.attachThread-worker.js";
 
 DebuggerServer.init();
 DebuggerServer.addBrowserActors();
 
 function* initDebuggerForTab(TAB_URL, WORKER_URL) {
-
   let client = new DebuggerClient(DebuggerServer.connectPipe());
   yield connect(client);
 
   let tab = yield addTab(TAB_URL);
   let { tabs } = yield listTabs(client);
   let [, tabClient] = yield attachTab(client, findTab(tabs, TAB_URL));
 
   yield listWorkers(tabClient);
@@ -78,17 +77,17 @@ add_task(function* testPaused() {
   info ("Trying to get the result of command3")
   executed = yield command3;
   ok(executed.textContent.includes("ReferenceError: foobar is not defined"),
       "command3 executed successfully");
 
   // We shouldn't have to do this..
   EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
 
-  // yield new Promise(() => {});
+  yield new Promise(() => {});
 
   yield gDevTools.closeToolbox(TargetFactory.forWorker(workerClient));
   terminateWorkerInTab(tab, WORKER_URL);
   yield waitForWorkerClose(workerClient);
   yield close(client);
 });
 
 // Test to see if creating the pause from the console works.
diff --git a/devtools/client/webconsole/console-output.js b/devtools/client/webconsole/console-output.js
--- a/devtools/client/webconsole/console-output.js
+++ b/devtools/client/webconsole/console-output.js
@@ -1342,16 +1342,18 @@ Messages.Extended.prototype = Heritage.e
 Messages.JavaScriptEvalOutput = function(evalResponse, errorMessage)
 {
   let severity = "log", msg, quoteStrings = true;
 
   // Store also the response packet from the back end. It might
   // be useful to extensions customizing the console output.
   this.response = evalResponse;
 
+  console.log("JavaScriptEvalOutput", errorMessage);
+  console.trace();
   if (errorMessage) {
     severity = "error";
     msg = errorMessage;
     quoteStrings = false;
   } else {
     msg = evalResponse.result;
   }
 
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -3248,16 +3248,17 @@ JSTerm.prototype = {
       return;
     }
     if (aResponse.error) {
       Cu.reportError("Evaluation error " + aResponse.error + ": " +
                      aResponse.message);
       return;
     }
     let errorMessage = aResponse.exceptionMessage;
+    console.log("HERE", aResponse.exceptionMessage)
     let result = aResponse.result;
     let helperResult = aResponse.helperResult;
     let helperHasRawOutput = !!(helperResult || {}).rawOutput;
 
     if (helperResult && helperResult.type) {
       switch (helperResult.type) {
         case "clearOutput":
           this.clearOutput();
@@ -3273,16 +3274,17 @@ JSTerm.prototype = {
             aAfterMessage._objectActors.add(helperResult.object.actor);
           }
           this.openVariablesView({
             label: VariablesView.getString(helperResult.object, { concise: true }),
             objectActor: helperResult.object,
           });
           break;
         case "error":
+          console.log("bb",helperResult.message);
           try {
             errorMessage = l10n.getStr(helperResult.message);
           }
           catch (ex) {
             errorMessage = helperResult.message;
           }
           break;
         case "help":
@@ -3317,16 +3319,20 @@ JSTerm.prototype = {
 
         return false;
       };
     }
 
     msg._afterMessage = aAfterMessage;
     msg._objectActors = new Set();
 
+    console.log("CLIENT SIDE _executeResultCallback",
+        aResponse.exception && aResponse.exception.actor,
+        JSON.stringify(aResponse)
+    );
     if (WebConsoleUtils.isActorGrip(aResponse.exception)) {
       msg._objectActors.add(aResponse.exception.actor);
     }
 
     if (WebConsoleUtils.isActorGrip(result)) {
       msg._objectActors.add(result.actor);
     }
   },
diff --git a/devtools/server/actors/object.js b/devtools/server/actors/object.js
--- a/devtools/server/actors/object.js
+++ b/devtools/server/actors/object.js
@@ -49,16 +49,17 @@ function ObjectActor(obj, {
   createValueGrip,
   sources,
   createEnvironmentActor,
   getGripDepth,
   incrementGripDepth,
   decrementGripDepth,
   getGlobalDebugObject
 }) {
+  dump("ObjectActor(obj" + obj + "\n");
   dbg_assert(!obj.optimizedOut,
     "Should not create object actors for optimized out values!");
   this.obj = obj;
   this.hooks = {
     createValueGrip,
     sources,
     createEnvironmentActor,
     getGripDepth,
@@ -99,16 +100,26 @@ ObjectActor.prototype = {
         // Bug 1163520: Assert on internal functions
         if (this.obj.class != "Function") {
           g.ownPropertyLength = this.obj.getOwnPropertyNames().length;
         }
       } catch(e) {}
 
       let raw = this.obj.unsafeDereference();
 
+      // dump("IN WORKER HERE IS RAW... " + this.obj.toString() + " " + this.obj.unsafeDereference().toString() + " " + DevToolsUtils.isSafeJSObject(raw) + "\n");
+      // dump("IN WORKER HERE IS RAW2... " + ("" + this.obj.unsafeDereference()) + "\n");
+      dump("IN WORKER HERE IS RAW3... " + DevToolsUtils.getProperty(this.obj, "name") + "\n");
+      dump("IN WORKER HERE IS RAW4... " + (typeof this.obj.unsafeDereference()) + "\n");
+      dump("IN WORKER HERE IS RAW5... " + (typeof this.obj) + "\n");
+      // dump("IN WORKER HERE IS RAW6... " + this.obj.global.executeInGlobalWithBindings("x.toString()", {x: this.obj.unsafeDereference()}).return.toString() + "\n");
+      // dump("IN WORKER HERE IS RAW7... " + this.obj.global.unsafeDereference().location.toString() + "\n");
+      dump("IN WORKER HERE IS RAW7... " + this.obj.global.makeDebuggeeValue(this.obj) + "\n");
+      // dump("IN WORKER HERE IS RAW6... " + (this.obj.call()) + "\n");
+      debugger;
       // If Cu is not defined, we are running on a worker thread, where xrays
       // don't exist.
       if (Cu) {
         raw = Cu.unwaiveXrays(raw);
       }
 
       if (!DevToolsUtils.isSafeJSObject(raw)) {
         raw = null;
@@ -1233,16 +1244,17 @@ DebuggerServer.ObjectActorPreviewers.Obj
           kind: "Error",
           name: hooks.createValueGrip(name),
           message: hooks.createValueGrip(msg),
           stack: hooks.createValueGrip(stack),
           fileName: hooks.createValueGrip(fileName),
           lineNumber: hooks.createValueGrip(lineNumber),
           columnNumber: hooks.createValueGrip(columnNumber),
         };
+        grip.fullString = obj.toString()
         return true;
       default:
         return false;
     }
   },
 
   function CSSMediaRule({obj, hooks}, grip, rawObj) {
     if (isWorker || !rawObj || !(rawObj instanceof Ci.nsIDOMCSSMediaRule)) {
diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -796,16 +796,17 @@ ThreadActor.prototype = {
         aPacket.why.frameFinished = {};
         if (!aCompletion) {
           aPacket.why.frameFinished.terminated = true;
         } else if (aCompletion.hasOwnProperty("return")) {
           aPacket.why.frameFinished.return = createValueGrip(aCompletion.return);
         } else if (aCompletion.hasOwnProperty("yield")) {
           aPacket.why.frameFinished.return = createValueGrip(aCompletion.yield);
         } else {
+          dump("aPacket.why.frameFinished.throw" + aCompletion.throw + "\n")
           aPacket.why.frameFinished.throw = createValueGrip(aCompletion.throw);
         }
         return aPacket;
       });
     };
   },
 
   _makeOnStep: function ({ thread, pauseAndRespond, startFrame,
@@ -1655,16 +1656,17 @@ ThreadActor.prototype = {
   createProtocolCompletionValue: function (aCompletion) {
     let protoValue = {};
     if (aCompletion == null) {
       protoValue.terminated = true;
     } else if ("return" in aCompletion) {
       protoValue.return = createValueGrip(aCompletion.return,
         this._pausePool, this.objectGrip);
     } else if ("throw" in aCompletion) {
+      dump("createProtocolCompletionValue " + aCompletion.throw);
       protoValue.throw = createValueGrip(aCompletion.throw,
         this._pausePool, this.objectGrip);
     } else {
       protoValue.return = createValueGrip(aCompletion.yield,
         this._pausePool, this.objectGrip);
     }
     return protoValue;
   },
@@ -1841,16 +1843,17 @@ ThreadActor.prototype = {
     const { sourceActor } = this.unsafeSynchronize(this.sources.getOriginalLocation(
       generatedLocation));
     const url = sourceActor ? sourceActor.url : null;
 
     if (this.sources.isBlackBoxed(url)) {
       return undefined;
     }
 
+    dump("onExceptionUnwind " + aValue + "\n");
     try {
       let packet = this._paused(aFrame);
       if (!packet) {
         return undefined;
       }
 
       packet.why = { type: "exception",
                      exception: createValueGrip(aValue, this._pausePool,
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -417,16 +417,17 @@ WebConsoleActor.prototype =
    * @param boolean aUseObjectGlobal
    *        If |true| the object global is determined and added as a debuggee,
    *        otherwise |this.window| is used when makeDebuggeeValue() is invoked.
    * @return object
    *         Debuggee value for |aValue|.
    */
   makeDebuggeeValue: function WCA_makeDebuggeeValue(aValue, aUseObjectGlobal)
   {
+    dump("makeDebuggeeValue " + this.window.location.toString() + "\n")
     let global = this.window;
     if (aUseObjectGlobal && typeof aValue == "object") {
       try {
         global = Cu.getGlobalForObject(aValue);
       }
       catch (ex) {
         // The above can throw an exception if aValue is not an actual object.
       }
@@ -442,16 +443,17 @@ WebConsoleActor.prototype =
    *        The object you want.
    * @param object aPool
    *        An ActorPool where the new actor instance is added.
    * @param object
    *        The object grip.
    */
   objectGrip: function WCA_objectGrip(aObject, aPool)
   {
+    dump("objectGrip called " + aObject + "\n");
     let actor = new ObjectActor(aObject, {
       getGripDepth: () => this._gripDepth,
       incrementGripDepth: () => this._gripDepth++,
       decrementGripDepth: () => this._gripDepth--,
       createValueGrip: v => this.createValueGrip(v),
       sources: () => DevToolsUtils.reportException("WebConsoleActor",
         Error("sources not yet implemented")),
       createEnvironmentActor: (env) => this.createEnvironmentActor(env),
@@ -835,37 +837,52 @@ WebConsoleActor.prototype =
     let result, errorMessage, errorGrip = null;
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
         let error = evalResult.throw;
-        errorGrip = this.createValueGrip(error);
-        // XXX: This error seems like an empty object in a worker.
-        // Can test by running '1_1' in a normal console and worker console
-        let unsafeDereference = error && (typeof error === "object") &&
-                                error.unsafeDereference();
-        errorMessage = unsafeDereference && unsafeDereference.toString
-          ? unsafeDereference.toString()
-          : "" + error;
+        dump("EVAL RESULT " + JSON.stringify(evalResult) + "\n")
+        let error2 = this.createValueGrip(error);
+        dump("EVAL RESULT2 " + JSON.stringify(error2) + "\n")
+        errorMessage = DevToolsUtils.getProperty(error, "message") || ("" + error);
+        // dump("BRIAN!!" + DevToolsUtils.getProperty(error, "message") + "\n");
+        // dump("BRIAN2!!" + DevToolsUtils.safeErrorString(error) + "\n");
+        // dump("evalResult " +(error.toString && error.toString()) + " " +
+        //                     (error.unsafeDereference().toString && error.unsafeDereference().toString()) + " " +
+        //                      (error.unwrap().toString && error.unwrap().toString()) + "\n\n");
+        // errorGrip = this.createValueGrip(error);
+        // // XXX: This error seems like an empty object in a worker.
+        // // Can test by running '1_1' in a normal console and worker console
+        // // let unsafeDereference = error && (typeof error === "object") &&
+        // //                         error.unsafeDereference();
+        // // errorMessage = unsafeDereference && unsafeDereference.toString
+        // //   ? unsafeDereference.toString()
+        // //   : "" + error;
+        // dump("errorMessage " + JSON.stringify(error) + " " + (typeof error) + "\n");
+        // errorMessage = "" + error;//error.unsafeDereference().toString();
       }
     }
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
     let resultGrip;
     try {
+    dump("WebConsoleActor - RESULT " + JSON.stringify(result) + "\n");
       resultGrip = this.createValueGrip(result);
     } catch (e) {
-      errorMessage = e;
+    dump("WebConsoleActor - EXCEPTION " + e + "\n");
+
+      // errorMessage = e;
     }
 
     this._lastConsoleInputEvaluation = result;
+    dump("WebConsoleActor - onEvaluateJS done.. exceptionMessage " + errorMessage + "\n");
 
     return {
       from: this.actorID,
       input: input,
       result: resultGrip,
       timestamp: timestamp,
       exception: errorGrip,
       exceptionMessage: this._createStringGrip(errorMessage),
diff --git a/devtools/shared/DevToolsUtils.js b/devtools/shared/DevToolsUtils.js
--- a/devtools/shared/DevToolsUtils.js
+++ b/devtools/shared/DevToolsUtils.js
@@ -340,17 +340,17 @@ exports.hasSafeGetter = function hasSafe
  *       The object to check.
  * @return Boolean
  *         True if it is safe to read properties from aObj, or false otherwise.
  */
 exports.isSafeJSObject = function isSafeJSObject(aObj) {
   // If we are running on a worker thread, Cu is not available. In this case,
   // we always return false, just to be on the safe side.
   if (isWorker) {
-    return false;
+    return true;
   }
 
   if (Cu.getGlobalForObject(aObj) ==
       Cu.getGlobalForObject(exports.isSafeJSObject)) {
     return true; // aObj is not a cross-compartment wrapper.
   }
 
   let principal = Cu.getObjectPrincipal(aObj);
