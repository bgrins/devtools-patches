diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -94,7 +94,10 @@
       return;
     }
 
-    this.inheritAttributes();
+    let list = this.inheritedAttributesCache.get(name);
+    if (list) {
+      this.inheritAttribute(list, newValue);
+    }
   }
 
   /*
@@ -115,109 +118,65 @@
     if (!inheritedAttributes) {
       return;
     }
-    this._inheritedAttributesValuesCache = null;
+
+    this._selectors = {};
     this.inheritedAttributesCache = new Map();
     for (let selector in inheritedAttributes) {
-      let parent = this.shadowRoot || this;
-      let el = parent.querySelector(selector);
-      // Skip unmatched selectors in case an element omits some elements in certain cases:
-      if (!el) {
-        continue;
-      }
-      if (this.inheritedAttributesCache.has(el)) {
-        console.error(`Error: duplicate element encountered with ${selector}`);
-      }
+      let attrRules = inheritedAttributes[selector].split(",");
+      for (let attrRule of attrRules) {
+        let attrName = attrRule;
+        let attrNewName = attrRule;
+        let split = attrName.split("=");
+        if (split.length == 2) {
+          attrName = split[1];
+          attrNewName = split[0];
+        }
 
-      this.inheritedAttributesCache.set(el, inheritedAttributes[selector]);
-    }
-    this.inheritAttributes();
-  }
-
-  /*
-   * Loop through the static `inheritedAttributes` Map and inherit attributes to child elements.
-   *
-   * This usually won't need to be called directly - `this.initializeAttributeInheritance()` and
-   * `this.attributeChangedCallback` will call it for you when appropriate.
-   */
-  inheritAttributes() {
-    let {inheritedAttributes} = this.constructor;
-    if (!inheritedAttributes) {
-      return;
+        let list = this.inheritedAttributesCache.get(attrName);
+        if (!list) {
+          list = [];
+          this.inheritedAttributesCache.set(attrName, list);
+        }
+        list.push([selector, attrNewName]);
+      }
     }
 
-    if (!this.inheritedAttributesCache) {
-     console.error(`You must call this.initializeAttributeInheritance() for ${this.tagName}`);
-     return;
-    }
-
-    for (let [ el, attrs ] of this.inheritedAttributesCache.entries()) {
-      for (let attr of attrs.split(",")) {
-        this.inheritAttribute(el, attr);
+    for (let [attr, list] of this.inheritedAttributesCache.entries()) {
+      let value = this.getAttribute(attr);
+      if (value) {
+        this.inheritAttribute(list, value);
       }
     }
   }
 
   /*
-   * Implements attribute inheritance by a child element. Uses XBL @inherit
-   * syntax of |to=from|. This can be used directly, but for simple cases
-   * you should use the inheritedAttributes getter and let the base class
-   * handle this for you.
+   * Implements attribute value inheritance by child elements.
    *
-   * @param {element} child
-   *        A child element that inherits an attribute.
-   * @param {string} attr
-   *        An attribute to inherit. Optionally in the form of |to=from|, where
-   *        |to| is an attribute defined on custom element, whose value will be
-   *        inherited to |from| attribute, defined a child element. Note |from| may
-   *        take a special value of "text" to propogate attribute value as
-   *        a child's text.
+   * @param {array} list
+   *        An array of (to-element-selector, to-attr) pairs.
+   * @param {string} value
+   *        An attribute value to propagate.
    */
-  inheritAttribute(child, attr) {
-    let attrName = attr;
-    let attrNewName = attr;
-    let split = attrName.split("=");
-    if (split.length == 2) {
-      attrName = split[1];
-      attrNewName = split[0];
-    }
-    let hasAttr = this.hasAttribute(attrName);
-    let attrValue = this.getAttribute(attrName);
+  inheritAttribute(list, value) {
+    for (let [selector, attr] of list) {
+      if (!(selector in this._selectors)) {
+        let parent = this.shadowRoot || this;
+        this._selectors[selector] = parent.querySelector(selector);
+      }
+      let el = this._selectors[selector];
+      if (el) {
+        if (attr == "text") {
+          el.textContent = value;
+        } else if (value) {
+          el.setAttribute(attr, value);
+        } else {
+          el.removeAttribute(attr);
+        }
 
-    // If our attribute hasn't changed since we last inherited, we don't want to
-    // propagate it down to the child. This prevents overriding an attribute that's
-    // been changed on the child (for instance, [checked]).
-    if (!this._inheritedAttributesValuesCache) {
-      this._inheritedAttributesValuesCache = new WeakMap();
-    }
-    if (!this._inheritedAttributesValuesCache.has(child)) {
-      this._inheritedAttributesValuesCache.set(child, {});
-    }
-    let lastInheritedAttributes = this._inheritedAttributesValuesCache.get(child);
-
-    if ((hasAttr && attrValue === lastInheritedAttributes[attrName]) ||
-        (!hasAttr && !lastInheritedAttributes.hasOwnProperty(attrName))) {
-      // We got a request to inherit an unchanged attribute - bail.
-      return;
-    }
-
-    // Store the value we're about to pass down to the child.
-    if (hasAttr) {
-      lastInheritedAttributes[attrName] = attrValue;
-    } else {
-      delete lastInheritedAttributes[attrName];
-    }
-
-    // Actually set the attribute.
-    if (attrNewName === "text") {
-      child.textContent = hasAttr ? attrValue : "";
-    } else if (hasAttr) {
-      child.setAttribute(attrNewName, attrValue);
-    } else {
-      child.removeAttribute(attrNewName);
-    }
-
-    if (attrNewName == "accesskey" && child.formatAccessKey) {
-      child.formatAccessKey(false);
+        if (attr == "accesskey" && el.formatAccessKey) {
+          el.formatAccessKey(false);
+        }
+      }
     }
   }
 
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -126,12 +126,19 @@
       }
 
       inherit() {
-        for (let attr of [ "text=label", "foo", "boo", "bardo=bar" ]) {
-          this.inheritAttribute(this.label, attr);
+        let map = {
+          "label": [[ "label", "text" ]],
+          "foo": [[ "label", "foo" ]],
+          "boo": [[ "label", "boo" ]],
+          "bar": [[ "label", "bardo" ]],
+        };
+        for (let attr of InheritsElementImperative.observedAttributes) {
+          this.inheritAttribute(map[attr], this.getAttribute(attr));
         }
       }
 
       connectedCallback() {
+        this._selectors = {};
         this.append(MozXULElement.parseXULToFragment(`<label />`));
         this.label = this.querySelector("label");
         this.inherit();

