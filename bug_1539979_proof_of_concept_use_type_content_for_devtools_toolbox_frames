# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1553811654 25200
#      Thu Mar 28 15:20:54 2019 -0700
# Node ID a3f97563ae43082307c14159cb2e1971368c4ef2
# Parent  e8b3c73b4e328be88aa90f31e1fa9772b537507d
Bug 1539979 - Proof of concept - Use type="content" for devtools toolbox frames

Differential Revision: https://phabricator.services.mozilla.com/D25306

diff --git a/devtools/client/framework/toolbox-hosts.js b/devtools/client/framework/toolbox-hosts.js
--- a/devtools/client/framework/toolbox-hosts.js
+++ b/devtools/client/framework/toolbox-hosts.js
@@ -54,16 +54,17 @@ BottomHost.prototype = {
       gBrowser.getBrowserContainer(this.hostTab.linkedBrowser);
 
     this._splitter = ownerDocument.createXULElement("splitter");
     this._splitter.setAttribute("class", "devtools-horizontal-splitter");
     // Avoid resizing notification containers
     this._splitter.setAttribute("resizebefore", "flex");
 
     this.frame = ownerDocument.createXULElement("iframe");
+    this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-bottom-iframe";
     this.frame.height = Math.min(
       Services.prefs.getIntPref(this.heightPref),
       this._browserContainer.clientHeight - MIN_PAGE_SIZE
     );
 
     this._browserContainer.appendChild(this._splitter);
@@ -140,16 +141,17 @@ class SidebarHost {
     const ownerDocument = gBrowser.ownerDocument;
     this._browserContainer = gBrowser.getBrowserContainer(this.hostTab.linkedBrowser);
     this._browserPanel = gBrowser.getPanel(this.hostTab.linkedBrowser);
 
     this._splitter = ownerDocument.createXULElement("splitter");
     this._splitter.setAttribute("class", "devtools-side-splitter");
 
     this.frame = ownerDocument.createXULElement("iframe");
+    this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-side-iframe";
 
     this.frame.width = Math.min(
       Services.prefs.getIntPref(this.widthPref),
       this._browserPanel.clientWidth - MIN_PAGE_SIZE
     );
 
diff --git a/devtools/client/framework/toolbox-window.xul b/devtools/client/framework/toolbox-window.xul
--- a/devtools/client/framework/toolbox-window.xul
+++ b/devtools/client/framework/toolbox-window.xul
@@ -9,10 +9,10 @@
 <window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         id="devtools-toolbox-window"
         macanimationtype="document"
         fullscreenbutton="true"
         windowtype="devtools:toolbox"
         width="900" height="320"
         persist="screenX screenY width height sizemode">
   <tooltip id="aHTMLTooltip" page="true"/>
-  <iframe id="toolbox-iframe" flex="1" forceOwnRefreshDriver="" tooltip="aHTMLTooltip"></iframe>
+  <iframe id="toolbox-iframe" type="content" flex="1" forceOwnRefreshDriver="" tooltip="aHTMLTooltip"></iframe>
 </window>
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -207,17 +207,17 @@ function Toolbox(target, selectedTool, h
   /**
    * Get text direction for the current locale direction.
    *
    * `getComputedStyle` forces a synchronous reflow, so use a lazy getter in order to
    * call it only once.
    */
   loader.lazyGetter(this, "direction", () => {
     // Get the direction from browser.xul document
-    const top = this.win.top;
+    const top = this.topWindow;
     const topDocEl = top.document.documentElement;
     const isRtl = top.getComputedStyle(topDocEl).direction === "rtl";
     return isRtl ? "rtl" : "ltr";
   });
 }
 exports.Toolbox = Toolbox;
 
 /**
@@ -238,16 +238,20 @@ Toolbox.HostType = {
 Toolbox.prototype = {
   _URL: "about:devtools-toolbox",
 
   _prefs: {
     LAST_TOOL: "devtools.toolbox.selectedTool",
     SIDE_ENABLED: "devtools.toolbox.sideEnabled",
   },
 
+  get topWindow() {
+    return this.win.docShell.QueryInterface(Ci.nsIDocShellTreeItem).rootTreeItem.domWindow;
+  },
+
   get currentToolId() {
     return this._currentToolId;
   },
 
   set currentToolId(id) {
     this._currentToolId = id;
     this.component.setCurrentToolId(id);
   },
@@ -434,21 +438,16 @@ Toolbox.prototype = {
       this.doc.querySelector("#toolbox-panel-iframe-webconsole").contentWindow;
   },
 
   /**
    * Open the toolbox
    */
   open: function() {
     return (async function() {
-      this.browserRequire = BrowserLoader({
-        window: this.doc.defaultView,
-        useOnlyShared: true,
-      }).require;
-
       const isToolboxURL = this.win.location.href.startsWith(this._URL);
       if (isToolboxURL) {
         // Update the URL so that onceDOMReady watch for the right url.
         this._URL = this.win.location.href;
       }
 
       if (this.hostType === Toolbox.HostType.PAGE) {
         // Displays DebugTargetInfo which shows the basic information of debug target,
@@ -478,16 +477,21 @@ Toolbox.prototype = {
           "NetworkActivity",
         ]);
       }
 
       // Attach the thread
       this._threadClient = await attachThread(this);
       await domReady;
 
+      this.browserRequire = BrowserLoader({
+        window: this._win,
+        useOnlyShared: true,
+      }).require;
+
       // The web console is immediately loaded when replaying, so that the
       // timeline will always be populated with generated messages.
       if (this.target.isReplayEnabled()) {
         await this.loadTool("webconsole");
       }
 
       this.isReady = true;
 
@@ -564,17 +568,17 @@ Toolbox.prototype = {
       this.win.requestIdleCallback(() => {
         this.component.setCanRender();
       }, {timeout: 16});
 
       await this.selectTool(this._defaultToolId, "initial_panel");
 
       // Wait until the original tool is selected so that the split
       // console input will receive focus.
-      const browserWin = this.win.top;
+      const browserWin = this.topWindow;
       let splitConsolePromise = promise.resolve();
       if (Services.prefs.getBoolPref(SPLITCONSOLE_ENABLED_PREF)) {
         splitConsolePromise = this.openSplitConsole();
         this.telemetry.addEventProperty(
           browserWin, "open", "tools", null, "splitconsole", true);
       } else {
         this.telemetry.addEventProperty(
           browserWin, "open", "tools", null, "splitconsole", false);
@@ -765,17 +769,17 @@ Toolbox.prototype = {
 
     this.telemetry.getHistogramById(HOST_HISTOGRAM).add(this._getTelemetryHostId());
 
     // Log current theme. The question we want to answer is:
     // "What proportion of users use which themes?"
     const currentTheme = Services.prefs.getCharPref("devtools.theme");
     this.telemetry.keyedScalarAdd(CURRENT_THEME_SCALAR, currentTheme, 1);
 
-    const browserWin = this.win.top;
+    const browserWin = this.topWindow;
     this.telemetry.preparePendingEvent(browserWin, "open", "tools", null, [
       "entrypoint", "first_panel", "host", "shortcut",
       "splitconsole", "width", "session_id",
     ]);
     this.telemetry.addEventProperty(
       browserWin, "open", "tools", null, "host", this._getTelemetryHostString()
     );
   },
@@ -1145,22 +1149,23 @@ Toolbox.prototype = {
 
     this.component.setCurrentHostType(this.hostType);
     this.component.setHostTypes(hostTypes);
   },
 
   postMessage: function(msg) {
     // We sometime try to send messages in middle of destroy(), where the
     // toolbox iframe may already be detached and no longer have a parent.
-    if (this.win.parent) {
-      // Toolbox document is still chrome and disallow identifying message
-      // origin via event.source as it is null. So use a custom id.
-      msg.frameId = this.frameId;
-      this.win.parent.postMessage(msg, "*");
+    if (this._destroyer) {
+      return;
     }
+    // Toolbox document is still chrome and disallow identifying message
+    // origin via event.source as it is null. So use a custom id.
+    msg.frameId = this.frameId;
+    this.topWindow.postMessage(msg, "*");
   },
 
   /**
    * Initiate ToolboxTabs React component and all it's properties. Do the initial render.
    */
   _buildTabs: async function() {
     // Get the initial list of tab definitions. This list can be amended at a later time
     // by tools registering themselves.
@@ -2091,17 +2096,17 @@ Toolbox.prototype = {
         "width": width,
         "panel_name": prevPanelName,
         "next_panel": panelName,
         "reason": reason,
         "session_id": this.sessionId,
       });
     }
 
-    const browserWin = this.win.top;
+    const browserWin = this.topWindow;
     this.telemetry.addEventProperties(browserWin, "open", "tools", null, {
       "width": width,
       "session_id": this.sessionId,
     });
 
     if (id === "webconsole") {
       pending.push("message_count");
     }
