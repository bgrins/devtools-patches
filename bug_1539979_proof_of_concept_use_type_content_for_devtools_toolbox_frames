# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1553811654 25200
#      Thu Mar 28 15:20:54 2019 -0700
# Node ID ff9f4f69af830298f3010bb7b2bc32274d515ac0
# Parent  4e2ea1a75e878ae392e4775f2eddd9f83d1b008e
Bug 1539979 - Proof of concept - Use type="content" for devtools toolbox frames

Differential Revision: https://phabricator.services.mozilla.com/D25306

diff --git a/devtools/client/framework/toolbox-hosts.js b/devtools/client/framework/toolbox-hosts.js
--- a/devtools/client/framework/toolbox-hosts.js
+++ b/devtools/client/framework/toolbox-hosts.js
@@ -54,16 +54,17 @@ BottomHost.prototype = {
       gBrowser.getBrowserContainer(this.hostTab.linkedBrowser);
 
     this._splitter = ownerDocument.createXULElement("splitter");
     this._splitter.setAttribute("class", "devtools-horizontal-splitter");
     // Avoid resizing notification containers
     this._splitter.setAttribute("resizebefore", "flex");
 
     this.frame = ownerDocument.createXULElement("iframe");
+    this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-bottom-iframe";
     this.frame.height = Math.min(
       Services.prefs.getIntPref(this.heightPref),
       this._browserContainer.clientHeight - MIN_PAGE_SIZE
     );
 
     this._browserContainer.appendChild(this._splitter);
@@ -140,16 +141,17 @@ class SidebarHost {
     const ownerDocument = gBrowser.ownerDocument;
     this._browserContainer = gBrowser.getBrowserContainer(this.hostTab.linkedBrowser);
     this._browserPanel = gBrowser.getPanel(this.hostTab.linkedBrowser);
 
     this._splitter = ownerDocument.createXULElement("splitter");
     this._splitter.setAttribute("class", "devtools-side-splitter");
 
     this.frame = ownerDocument.createXULElement("iframe");
+    this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-side-iframe";
 
     this.frame.width = Math.min(
       Services.prefs.getIntPref(this.widthPref),
       this._browserPanel.clientWidth - MIN_PAGE_SIZE
     );
 
diff --git a/devtools/client/framework/toolbox-window.xul b/devtools/client/framework/toolbox-window.xul
--- a/devtools/client/framework/toolbox-window.xul
+++ b/devtools/client/framework/toolbox-window.xul
@@ -9,10 +9,10 @@
 <window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         id="devtools-toolbox-window"
         macanimationtype="document"
         fullscreenbutton="true"
         windowtype="devtools:toolbox"
         width="900" height="320"
         persist="screenX screenY width height sizemode">
   <tooltip id="aHTMLTooltip" page="true"/>
-  <iframe id="toolbox-iframe" flex="1" forceOwnRefreshDriver="" tooltip="aHTMLTooltip"></iframe>
+  <iframe id="toolbox-iframe" type="content" flex="1" forceOwnRefreshDriver="" tooltip="aHTMLTooltip"></iframe>
 </window>
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -205,17 +205,17 @@ function Toolbox(target, selectedTool, h
   /**
    * Get text direction for the current locale direction.
    *
    * `getComputedStyle` forces a synchronous reflow, so use a lazy getter in order to
    * call it only once.
    */
   loader.lazyGetter(this, "direction", () => {
     // Get the direction from browser.xul document
-    const top = this.win.top;
+    const top = this.topWindow;
     const topDocEl = top.document.documentElement;
     const isRtl = top.getComputedStyle(topDocEl).direction === "rtl";
     return isRtl ? "rtl" : "ltr";
   });
 }
 exports.Toolbox = Toolbox;
 
 /**
@@ -236,16 +236,20 @@ Toolbox.HostType = {
 Toolbox.prototype = {
   _URL: "about:devtools-toolbox",
 
   _prefs: {
     LAST_TOOL: "devtools.toolbox.selectedTool",
     SIDE_ENABLED: "devtools.toolbox.sideEnabled",
   },
 
+  get topWindow() {
+    return this.win.docShell.QueryInterface(Ci.nsIDocShellTreeItem).rootTreeItem.domWindow;
+  },
+
   get currentToolId() {
     return this._currentToolId;
   },
 
   set currentToolId(id) {
     this._currentToolId = id;
     this.component.setCurrentToolId(id);
   },
@@ -562,17 +566,17 @@ Toolbox.prototype = {
       this.win.requestIdleCallback(() => {
         this.component.setCanRender();
       }, {timeout: 16});
 
       await this.selectTool(this._defaultToolId, "initial_panel");
 
       // Wait until the original tool is selected so that the split
       // console input will receive focus.
-      const browserWin = this.win.top;
+      const browserWin = this.topWindow;
       let splitConsolePromise = promise.resolve();
       if (Services.prefs.getBoolPref(SPLITCONSOLE_ENABLED_PREF)) {
         splitConsolePromise = this.openSplitConsole();
         this.telemetry.addEventProperty(
           browserWin, "open", "tools", null, "splitconsole", true);
       } else {
         this.telemetry.addEventProperty(
           browserWin, "open", "tools", null, "splitconsole", false);
@@ -763,17 +767,17 @@ Toolbox.prototype = {
 
     this.telemetry.getHistogramById(HOST_HISTOGRAM).add(this._getTelemetryHostId());
 
     // Log current theme. The question we want to answer is:
     // "What proportion of users use which themes?"
     const currentTheme = Services.prefs.getCharPref("devtools.theme");
     this.telemetry.keyedScalarAdd(CURRENT_THEME_SCALAR, currentTheme, 1);
 
-    const browserWin = this.win.top;
+    const browserWin = this.topWindow;
     this.telemetry.preparePendingEvent(browserWin, "open", "tools", null, [
       "entrypoint", "first_panel", "host", "shortcut",
       "splitconsole", "width", "session_id",
     ]);
     this.telemetry.addEventProperty(
       browserWin, "open", "tools", null, "host", this._getTelemetryHostString()
     );
   },
@@ -1143,21 +1147,21 @@ Toolbox.prototype = {
 
     this.component.setCurrentHostType(this.hostType);
     this.component.setHostTypes(hostTypes);
   },
 
   postMessage: function(msg) {
     // We sometime try to send messages in middle of destroy(), where the
     // toolbox iframe may already be detached and no longer have a parent.
-    if (this.win.parent) {
+    if (this.topWindow) {
       // Toolbox document is still chrome and disallow identifying message
       // origin via event.source as it is null. So use a custom id.
       msg.frameId = this.frameId;
-      this.win.parent.postMessage(msg, "*");
+      this.topWindow.postMessage(msg, "*");
     }
   },
 
   /**
    * Initiate ToolboxTabs React component and all it's properties. Do the initial render.
    */
   _buildTabs: async function() {
     // Get the initial list of tab definitions. This list can be amended at a later time
@@ -2068,17 +2072,17 @@ Toolbox.prototype = {
         "width": width,
         "panel_name": prevPanelName,
         "next_panel": panelName,
         "reason": reason,
         "session_id": this.sessionId,
       });
     }
 
-    const browserWin = this.win.top;
+    const browserWin = this.topWindow;
     this.telemetry.addEventProperties(browserWin, "open", "tools", null, {
       "width": width,
       "session_id": this.sessionId,
     });
 
     if (id === "webconsole") {
       pending.push("message_count");
     }
