# HG changeset patch
# User Jennifer Fong <jen@ednapiranha.com>
Bug 163183 - Show HTML5 Forms pseudo elements in the rule view. r=bgrins


diff --git a/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles.js b/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles.js
index e414256..8cd5501 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_user-agent-styles.js
@@ -4,22 +4,83 @@
 
 "use strict";
 
 // Check that user agent styles are inspectable via rule view if
 // it is preffed on.
 
 let PREF_UA_STYLES = "devtools.inspector.showUserAgentStyles";
 const { PrefObserver } = devtools.require("devtools/styleeditor/utils");
-const TEST_URI = "data:text/html;charset=utf-8," +
-  "<blockquote type=cite>" +
-  " <pre _moz_quote=true>" +
-  "   inspect <a href='foo' style='color:orange'>user agent</a> styles" +
-  " </pre>" +
-  "</blockquote>";
+
+const TEST_DOC = '<html>                                              \
+                    <head>                                            \
+                      <style>                                         \
+                        pre a {                                       \
+                          color: orange;                              \
+                        }                                             \
+                      </style>                                        \
+                    </head>                                           \
+                    <body>                                            \
+                      <input type=text placeholder=test></input>      \
+                      <input type=color></input>                      \
+                      <input type=range></input>                      \
+                      <input type=number></input>                     \
+                      <progress></progress>                           \
+                      <blockquote type=cite>                          \
+                        <pre _moz_quote=true>                         \
+                          inspect <a href="foo">user agent</a> styles \
+                        </pre>                                        \
+                      </blockquote>                                   \
+                    </body>                                           \
+                  </html>';
+
+const TEST_URI = "data:text/html;charset=utf-8," + encodeURIComponent(TEST_DOC);
+
+const TEST_DATA = [
+  {
+    selector: "blockquote",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "pre",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "input[type=range]",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "input[type=number]",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "input[type=color]",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "input[type=text]",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "progress",
+    numUserRules: 1,
+    numUARules: 0
+  },
+  {
+    selector: "a",
+    numUserRules: 2,
+    numUARules: 0
+  }
+];
 
 add_task(function*() {
   info ("Starting the test with the pref set to true before toolbox is opened");
   yield setUserAgentStylesPref(true);
 
   info ("Opening the testcase and toolbox")
   yield addTab(TEST_URI);
   let {toolbox, inspector, view} = yield openRuleView();
@@ -50,89 +111,72 @@ function* setUserAgentStylesPref(val) {
   Services.prefs.setBoolPref(PREF_UA_STYLES, val);
   yield oncePrefChanged.promise;
   prefObserver.off(PREF_UA_STYLES, oncePrefChanged.resolve);
 }
 
 function* userAgentStylesVisible(inspector, view) {
   info ("Making sure that user agent styles are currently visible");
 
-  yield selectNode("blockquote", inspector);
-  yield compareAppliedStylesWithUI(inspector, view, "ua");
-
-  let userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
-  let uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
-  is (userRules.length, 1, "Correct number of user rules");
-  ok (uaRules.length > 0, "Has UA rules");
-
-  yield selectNode("pre", inspector);
-  yield compareAppliedStylesWithUI(inspector, view, "ua");
+  let userRules;
+  let uaRules;
 
-  userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
-  uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
-  is (userRules.length, 1, "Correct number of user rules");
-  ok (uaRules.length > 0, "Has UA rules");
+  for (let data of TEST_DATA) {
+    yield selectNode(data.selector, inspector);
+    yield compareAppliedStylesWithUI(inspector, view, "ua");
 
-  yield selectNode("a", inspector);
-  yield compareAppliedStylesWithUI(inspector, view, "ua");
+    userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
+    uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
+    is (userRules.length, data.numUserRules, "Correct number of user rules");
+    ok (uaRules.length > data.numUARules, "Has UA rules");
+  }
 
-  userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
-  uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
-  is (userRules.length, 1, "Correct number of user rules");
-
-  ok (userRules.some(rule=> rule.matchedSelectors.length === 0),
+  ok (userRules.some(rule=> rule.matchedSelectors.length === 1),
     "There is an inline style for element in user styles");
 
   ok (uaRules.some(rule=> rule.matchedSelectors.indexOf(":-moz-any-link")),
     "There is a rule for :-moz-any-link");
   ok (uaRules.some(rule=> rule.matchedSelectors.indexOf("*|*:link")),
     "There is a rule for *|*:link");
-  ok (!uaRules.some(rule=> rule.matchedSelectors.length === 0),
-    "No inline styles for ua styles");
+  ok (uaRules.some(rule=> rule.matchedSelectors.length === 1),
+    "Inline styles for ua styles");
 }
 
 function* userAgentStylesNotVisible(inspector, view) {
   info ("Making sure that user agent styles are not currently visible");
 
-  yield selectNode("blockquote", inspector);
-  yield compareAppliedStylesWithUI(inspector, view);
-
-  let userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
-  let uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
-  is (userRules.length, 1, "Correct number of user rules");
-  is (uaRules.length, 0, "No UA rules");
+  let userRules;
+  let uaRules;
 
-  yield selectNode("pre", inspector);
-  yield compareAppliedStylesWithUI(inspector, view);
+  for (let data of TEST_DATA) {
+    yield selectNode(data.selector, inspector);
+    yield compareAppliedStylesWithUI(inspector, view);
 
-  userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
-  uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
-  is (userRules.length, 1, "Correct number of user rules");
-  is (uaRules.length, 0, "No UA rules");
-
-  yield selectNode("a", inspector);
-  yield compareAppliedStylesWithUI(inspector, view);
-
-  userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
-  uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
-  is (userRules.length, 1, "Correct number of user rules");
-  is (uaRules.length, 0, "No UA rules");
+    userRules = view._elementStyle.rules.filter(rule=>rule.editor.isEditable);
+    uaRules = view._elementStyle.rules.filter(rule=>!rule.editor.isEditable);
+    is (userRules.length, data.numUserRules, "Correct number of user rules");
+    is (uaRules.length, data.numUARules, "No UA rules");
+  }
 }
 
 function* compareAppliedStylesWithUI(inspector, view, filter) {
   info ("Making sure that UI is consistent with pageStyle.getApplied");
 
   let entries = yield inspector.pageStyle.getApplied(inspector.selection.nodeFront, {
     inherited: true,
     matchedSelectors: true,
     filter: filter
   });
 
   let elementStyle = view._elementStyle;
   is(elementStyle.rules.length, entries.length, "Should have correct number of rules (" +  entries.length + ")");
 
+  entries = entries.sort((a, b) => {
+    return (a.pseudoElement || "z") > (b.pseudoElement || "z");
+  });
+
   entries.forEach((entry, i) => {
     let elementStyleRule = elementStyle.rules[i];
     is (elementStyleRule.inherited, entry.inherited, "Same inherited (" +entry.inherited+ ")" );
     is (elementStyleRule.isSystem, entry.isSystem, "Same isSystem (" +entry.isSystem+ ")");
     is (elementStyleRule.editor.isEditable, !entry.isSystem, "Editor isEditable opposite of UA (" +entry.isSystem+ ")");
   });
 }
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
index 49a024b..25086aa 100644
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -8,31 +8,42 @@ const {Cc, Ci, Cu} = require("chrome");
 const Services = require("Services");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method, RetVal, types} = protocol;
 const events = require("sdk/event/core");
 const object = require("sdk/util/object");
 const {Class} = require("sdk/core/heritage");
 const {LongStringActor} = require("devtools/server/actors/string");
-
+const {PSEUDO_ELEMENT_SET} = require("devtools/styleinspector/css-logic");
 
 // This will add the "stylesheet" actor type for protocol.js to recognize
 require("devtools/server/actors/stylesheets");
 
 loader.lazyGetter(this, "CssLogic", () => require("devtools/styleinspector/css-logic").CssLogic);
 loader.lazyGetter(this, "DOMUtils", () => Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils));
 
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
-const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
+// Not included since these are uneditable by the user.
+// See https://hg.mozilla.org/mozilla-central/file/696a4ad5d011/layout/style/nsCSSPseudoElementList.h#l74
+PSEUDO_ELEMENT_SET.delete(":-moz-meter-bar");
+PSEUDO_ELEMENT_SET.delete(":-moz-list-bullet");
+PSEUDO_ELEMENT_SET.delete(":-moz-list-number");
+PSEUDO_ELEMENT_SET.delete(":-moz-focus-inner");
+PSEUDO_ELEMENT_SET.delete(":-moz-focus-outer");
+PSEUDO_ELEMENT_SET.delete(":-moz-math-anonymous");
+PSEUDO_ELEMENT_SET.delete(":-moz-math-stretchy");
+
+const PSEUDO_ELEMENTS = Array.from(PSEUDO_ELEMENT_SET);
+
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
 
 // When gathering rules to read for pseudo elements, we will skip
 // :before and :after, which are handled as a special case.
 const PSEUDO_ELEMENTS_TO_READ = PSEUDO_ELEMENTS.filter(pseudo => {
   return pseudo !== ":before" && pseudo !== ":after";
 });
 
@@ -489,17 +500,17 @@ var PageStyleActor = protocol.ActorClass({
    * Get the set of styles that apply to a given node.
    * @param NodeActor node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
-   *   `matchedSeletors`: Include an array of specific selectors that
+   *   `matchedSelectors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
   getApplied: method(function(node, options) {
     if (!node) {
       return {entries: [], rules: [], sheets: []};
     }
 
     this.cssLogic.highlight(node.rawNode);
@@ -543,29 +554,32 @@ var PageStyleActor = protocol.ActorClass({
     if (!bindingElement || !bindingElement.style) {
       return rules;
     }
 
     let elementStyle = this._styleRef(bindingElement);
     let showElementStyles = !inherited && !pseudo;
     let showInheritedStyles = inherited && this._hasInheritedProps(bindingElement.style);
 
+    let rule = {
+      rule: elementStyle,
+      pseudoElement: null,
+      isSystem: false,
+      inherited: false
+    };
+
     // First any inline styles
     if (showElementStyles) {
-      rules.push({
-        rule: elementStyle,
-      });
+      rules.push(rule);
     }
 
     // Now any inherited styles
     if (showInheritedStyles) {
-      rules.push({
-        rule: elementStyle,
-        inherited: inherited
-      });
+      rule.inherited = inherited;
+      rules.push(rule);
     }
 
     // Add normal rules.  Typically this is passing in the node passed into the
     // function, unless if that node was ::before/::after.  In which case,
     // it will pass in the parentNode along with "::before"/"::after".
     this._getElementRules(bindingElement, pseudo, inherited, options).forEach((rule) => {
       // The only case when there would be a pseudo here is ::before/::after,
       // and in this case we want to tell the view that it belongs to the
diff --git a/toolkit/devtools/server/tests/mochitest/test_styles-applied.html b/toolkit/devtools/server/tests/mochitest/test_styles-applied.html
index 45b2ac0..c5f25d8 100644
--- a/toolkit/devtools/server/tests/mochitest/test_styles-applied.html
+++ b/toolkit/devtools/server/tests/mochitest/test_styles-applied.html
@@ -83,17 +83,17 @@ addTest(function inheritedSystemStyles() {
     // If our system stylesheets are prone to churn, this might be a fragile
     // test.  If you're here because of that I apologize, file a bug
     // and we can find a different way to test.
 
     ok(!applied[1].inherited, "Entry 1 should not be inherited");
     ok(!applied[1].rule.parentStyleSheet.system, "Entry 1 should be a system style");
     is(applied[1].rule.type, 1, "Entry 1 should be a rule style");
 
-    is(applied.length, 7, "Should have 7 rules.");
+    is(applied.length, 8, "Should have 8 rules.");
   }).then(runNextTest));
 });
 
 addTest(function noInheritedStyles() {
   promiseDone(gWalker.querySelector(gWalker.rootNode, "#test-node").then(node => {
     return gStyles.getApplied(node, { inherited: false, filter: "user" });
   }).then(applied => {
     ok(!applied[0].inherited, "Entry 0 should be uninherited");
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
index 001ae8c..16df7fa 100644
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -37,16 +37,46 @@
  * - how browsers process CSS
  * @constructor
  */
 
 const { Cc, Ci, Cu } = require("chrome");
 const Services = require("Services");
 const DevToolsUtils = require("devtools/toolkit/DevToolsUtils");
 
+let pseudos = new Set([
+  ":after",
+  ":before",
+  ":first-letter",
+  ":first-line",
+  ":selection",
+  ":-moz-color-swatch",
+  ":-moz-focus-inner",
+  ":-moz-focus-outer",
+  ":-moz-list-bullet",
+  ":-moz-list-number",
+  ":-moz-math-anonymous",
+  ":-moz-math-stretchy",
+  ":-moz-meter-bar",
+  ":-moz-number-spin-box",
+  ":-moz-number-spin-down",
+  ":-moz-number-spin-up",
+  ":-moz-number-text",
+  ":-moz-number-wrapper",
+  ":-moz-placeholder",
+  ":-moz-progress-bar",
+  ":-moz-range-progress",
+  ":-moz-range-thumb",
+  ":-moz-range-track",
+  ":-moz-selection"
+]);
+
+const PSEUDO_ELEMENT_SET = pseudos;
+exports.PSEUDO_ELEMENT_SET = PSEUDO_ELEMENT_SET;
+
 // This should be ok because none of the functions that use this should be used
 // on the worker thread, where Cu is not available.
 if (Cu) {
   Cu.importGlobalProperties(['CSS']);
   Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 }
 
 function CssLogic()
@@ -1650,31 +1680,17 @@ CssSelector.prototype = {
 
   /**
    * Retrieve the pseudo-elements that we support. This list should match the
    * elements specified in layout/style/nsCSSPseudoElementList.h
    */
   get pseudoElements()
   {
     if (!CssSelector._pseudoElements) {
-      let pseudos = CssSelector._pseudoElements = new Set();
-      pseudos.add("after");
-      pseudos.add("before");
-      pseudos.add("first-letter");
-      pseudos.add("first-line");
-      pseudos.add("selection");
-      pseudos.add("-moz-color-swatch");
-      pseudos.add("-moz-focus-inner");
-      pseudos.add("-moz-focus-outer");
-      pseudos.add("-moz-list-bullet");
-      pseudos.add("-moz-list-number");
-      pseudos.add("-moz-math-anonymous");
-      pseudos.add("-moz-math-stretchy");
-      pseudos.add("-moz-progress-bar");
-      pseudos.add("-moz-selection");
+      CssSelector._pseudoElements = PSEUDO_ELEMENT_SET;
     }
     return CssSelector._pseudoElements;
   },
 
   /**
    * Retrieve specificity information for the current selector.
    *
    * @see http://www.w3.org/TR/css3-selectors/#specificity
