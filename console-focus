# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  bf4cd21ba2fb1e61bf81ba13db1f3aeec5900ae5
Bug XXX - Use jsterm.focus instead of inputNode.focus everywhere

diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -548,39 +548,39 @@ WebConsoleFrame.prototype = {
     /*
      * Focus input line whenever the output area is clicked.
      * Reusing _addMEssageLinkCallback since it correctly filters
      * drag and select events.
      */
     this._addFocusCallback(this.outputNode, (evt) => {
       if ((evt.target.nodeName.toLowerCase() != "a") &&
           (evt.target.parentNode.nodeName.toLowerCase() != "a")) {
-        this.jsterm.inputNode.focus();
+        this.jsterm.focus();
       }
     });
 
     // Toggle the timestamp on preference change
     gDevTools.on("pref-changed", this._onToolboxPrefChanged);
     this._onToolboxPrefChanged("pref-changed", {
       pref: PREF_MESSAGE_TIMESTAMP,
       newValue: Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP),
     });
 
     // focus input node
-    this.jsterm.inputNode.focus();
+    this.jsterm.focus();
   },
 
   /**
    * Sets the focus to JavaScript input field when the web console tab is
    * selected or when there is a split console present.
    * @private
    */
   _onPanelSelected: function WCF__onPanelSelected(evt, id)
   {
-    this.jsterm.inputNode.focus();
+    this.jsterm.focus();
   },
 
   /**
    * Initialize the default filter preferences.
    * @private
    */
   _initDefaultFilterPrefs: function WCF__initDefaultFilterPrefs()
   {
@@ -3143,19 +3143,18 @@ JSTerm.prototype = {
       this.inputNode.addEventListener("focus", this._focusEventHandler, false);
     }
 
     this.hud.window.addEventListener("blur", this._blurEventHandler, false);
     this.lastInputValue && this.setInputValue(this.lastInputValue);
   },
 
   focus: function() {
-    let inputNode = this.inputNode;
-    if (!inputNode.getAttribute("focused")) {
-      inputNode.focus();
+    if (!this.inputNode.getAttribute("focused")) {
+      this.inputNode.focus();
     }
   },
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
    * @param function [callback]
@@ -3527,17 +3526,17 @@ JSTerm.prototype = {
     let tag = event.target.nodeName;
     if (event.keyCode != Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE || event.shiftKey ||
         event.altKey || event.ctrlKey || event.metaKey ||
         ["input", "textarea", "select", "textbox"].indexOf(tag) > -1) {
         return;
     }
 
     this._sidebarDestroy();
-    this.inputNode.focus();
+    this.focus();
     event.stopPropagation();
   },
 
   /**
    * Create a variables view instance.
    *
    * @private
    * @param object options
@@ -3937,33 +3936,33 @@ JSTerm.prototype = {
           // multiline text.
           if (Services.appinfo.OS == "Darwin" &&
               this.canCaretGoNext() &&
               this.historyPeruse(HISTORY_FORWARD)) {
             event.preventDefault();
             // Ctrl-N is also used to focus the Network category button on MacOSX.
             // The preventDefault() call doesn't prevent the focus from moving
             // away from the input.
-            inputNode.focus();
+            this.focus();
           }
           this.clearCompletion();
           break;
 
         case 112:
           // Control-P differs from up arrow: it ignores autocomplete state.
           // Note that we preserve the default 'up' navigation within
           // multiline text.
           if (Services.appinfo.OS == "Darwin" &&
               this.canCaretGoPrevious() &&
               this.historyPeruse(HISTORY_BACK)) {
             event.preventDefault();
             // Ctrl-P may also be used to focus some category button on MacOSX.
             // The preventDefault() call doesn't prevent the focus from moving
             // away from the input.
-            inputNode.focus();
+            this.focus();
           }
           this.clearCompletion();
           break;
         default:
           break;
       }
       return;
     }
