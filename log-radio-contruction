# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2d2acac907fbbf5d9c4bcda9f4866e3f75f101fc

diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -10,18 +10,16 @@
 // Prevent re-entry since we could get loaded twice as a result of setElementCreationCallback
 if (customElements.get("radio")) {
   return;
 }
 
 class MozRadiogroup extends MozElements.BaseControl {
   constructor() {
     super();
-    // console.log("<radiogroup> constructed", this);
-
     this.addEventListener("mousedown", (event) => {
       if (this.disabled)
         event.preventDefault();
     });
 
     /**
      * keyboard navigation  Here's how keyboard navigation works in radio groups on Windows:
      * The group takes 'focus'
@@ -123,49 +121,48 @@ class MozRadiogroup extends MozElements.
 
     this.init();
     if (!this.value) {
       this.selectedIndex = 0;
     }
   }
 
   init() {
-    // console.log("<radiogroup> init", this);
-
     this._radioChildren = null;
 
     if (this.getAttribute("disabled") == "true")
       this.disabled = true;
 
     var children = this._getRadioChildren();
-    // console.log("_getRadioChildren from init", this.id, children);
     var length = children.length;
     for (var i = 0; i < length; i++) {
       if (children[i].getAttribute("selected") == "true") {
         this.selectedIndex = i;
         return;
       }
     }
 
     var value = this.value;
-    // console.log("Got value", value, this);
     if (value)
       this.value = value;
   }
 
   /**
    * Called when a new <radio> gets added to an already connected radiogroup.
    * This can happen due to DOM getting appended after the <radiogroup> is created.
    * When this happens, reinitialize the UI if necessary to make sure the state is
    * consistent.
    *
    * @param {DOMNode} child
    *                  The <radio> element that got added
    */
   radioChildConstructed(child) {
+    if (this.ignoreRadioChildConstruction) {
+      return;
+    }
     if (!this._radioChildren || !this._radioChildren.includes(child)) {
       this.init();
     }
   }
 
   set value(val) {
     this.setAttribute("value", val);
     var children = this._getRadioChildren();
@@ -354,18 +351,30 @@ class MozRadiogroup extends MozElements.
 
   _getRadioChildren() {
     if (this._radioChildren)
       return this._radioChildren;
 
     var radioChildren = [];
 
     if (this.hasChildNodes()) {
-      return this._radioChildren = [...this.querySelectorAll("radio")]
-        .filter(r => r.control == this);
+      // In the case where we are processing nodes inside markup, the <radiogroup>
+      // connnectedCallback will fire first, but the <radio> will still be upgraded.
+      // This means the call to r.control will work. However, when we are appending
+      // a DocumentFragement, the <radio> won't be upgraded yet. To avoid churn where
+      // we keep reinitializing the list, ignore radioChildConstructed that gets fired
+      // as a result of this.
+      this.ignoreRadioChildConstruction = true;
+      this._radioChildren = [...this.querySelectorAll("radio")]
+        .filter(r => {
+          customElements.upgrade(r);
+          return r.control == this;
+        });
+      this.ignoreRadioChildConstruction = false;
+      return this._radioChildren;
     }
 
     // We don't have child nodes.
     const XUL_NS = "http://www.mozilla.org/keymaster/" +
       "gatekeeper/there.is.only.xul";
 
     var elems = this.ownerDocument.getElementsByAttribute("group", this.id);
     for (var i = 0; i < elems.length; i++) {
@@ -421,18 +430,16 @@ class MozRadio extends MozElements.BaseT
       ".radio-check": "disabled,selected",
       ".radio-label": "text=label,accesskey,crop",
       ".radio-icon": "src",
     };
   }
 
   constructor() {
     super();
-    // console.log("<radio> constructed", this);
-
     this.addEventListener("click", (event) => {
       if (!this.disabled)
         this.control.selectedItem = this;
     });
 
     this.addEventListener("mousedown", (event) => {
       if (!this.disabled)
         this.control.focusedItem = this;
@@ -455,17 +462,16 @@ class MozRadio extends MozElements.BaseT
 
     var control = this.control;
     if (control) {
       control.radioChildConstructed(this);
     }
   }
 
   disconnectedCallback() {
-    // console.log("<radio> disconnected", this, this.control);
     if (!this.control)
       return;
 
     var radioList = this.control._radioChildren;
     if (!radioList)
       return;
     for (var i = 0; i < radioList.length; ++i) {
       if (radioList[i] == this) {
