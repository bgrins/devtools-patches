# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a4a4365468fc8dcba33a29762a1f17f0d9190e15

diff --git a/browser/components/places/content/places-menupopup.js b/browser/components/places/content/places-menupopup.js
--- a/browser/components/places/content/places-menupopup.js
+++ b/browser/components/places/content/places-menupopup.js
@@ -25,23 +25,28 @@
         "drop",
         "dragover",
         "dragexit",
         "dragend",
       ];
       for (let event_name of event_names) {
         this.addEventListener(event_name, ev => this[`on_${event_name}`](ev));
       }
+    }
 
-      this._indicatorBar = this.shadowRoot.querySelector(
+    get _indicatorBar() {
+      return this.shadowRoot.querySelector(
         "[part=drop-indicator-bar]"
       );
-      this._scrollBox = this.shadowRoot.querySelector(".popup-internal-box");
     }
 
+    get _scrollBox() {
+      return this.shadowRoot.querySelector(".popup-internal-box");
+
+    }
     get fragment() {
       if (!this.constructor.hasOwnProperty("_fragment")) {
         this.constructor._fragment = MozXULElement.parseXULToFragment(
           this.markup
         );
       }
       return document.importNode(this.constructor._fragment, true);
     }
diff --git a/toolkit/content/widgets/menupopup.js b/toolkit/content/widgets/menupopup.js
--- a/toolkit/content/widgets/menupopup.js
+++ b/toolkit/content/widgets/menupopup.js
@@ -18,16 +18,35 @@
       this.AUTOSCROLL_INTERVAL = 25;
       this.NOT_DRAGGING = 0;
       this.DRAG_OVER_BUTTON = -1;
       this.DRAG_OVER_POPUP = 1;
       this._draggingState = this.NOT_DRAGGING;
       this._scrollTimer = 0;
 
       this.addEventListener("popupshowing", event => {
+        // XXX: Do this in a timeout to demonstrate the issue. If this happens
+        // inline it just never opens.
+        setTimeout(() => {
+          if (!this.shadowRoot) {
+            this.attachShadow({ mode: "open" });
+            this.shadowRoot.appendChild(this.fragment);
+            // Retarget events from shadow DOM scrolbox to the popup itself.
+            this.scrollBox.addEventListener("scroll", ev =>
+              this.dispatchEvent(new Event("scroll"))
+            );
+            this.scrollBox.addEventListener("overflow", ev =>
+              this.dispatchEvent(new Event("overflow"))
+            );
+            this.scrollBox.addEventListener("underflow", ev =>
+              this.dispatchEvent(new Event("underflow"))
+            );
+          }
+        }, 1000);
+
         let array = [];
         let width = 0;
         for (
           let menuitem = this.firstElementChild;
           menuitem;
           menuitem = menuitem.nextElementSibling
         ) {
           if (
@@ -40,32 +59,20 @@
               if (accel.boxObject.width > width) {
                 width = accel.boxObject.width;
               }
             }
           }
         }
         array.forEach(accel => (accel.width = width));
       });
-
-      this.attachShadow({ mode: "open" });
-      this.shadowRoot.appendChild(this.fragment);
-
-      this.scrollBox = this.shadowRoot.querySelector(".popup-internal-box");
+    }
 
-      // Retarget events from shadow DOM scrolbox to the popup itself.
-      this.scrollBox.addEventListener("scroll", ev =>
-        this.dispatchEvent(new Event("scroll"))
-      );
-      this.scrollBox.addEventListener("overflow", ev =>
-        this.dispatchEvent(new Event("overflow"))
-      );
-      this.scrollBox.addEventListener("underflow", ev =>
-        this.dispatchEvent(new Event("underflow"))
-      );
+    get scrollBox() {
+      return this.shadowRoot.querySelector(".popup-internal-box");
     }
 
     connectedCallback() {
       if (this.delayConnectedCallback() || this.hasConnected) {
         return;
       }
 
       this.hasConnected = true;
