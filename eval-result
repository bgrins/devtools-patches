# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7e6ca87a61bbfa4d0e907a0272f0ef3db81360ee
Bug 1044365 - Do not force eval result to show up immediately after the input;r=vporof

diff --git a/devtools/client/webconsole/console-output.js b/devtools/client/webconsole/console-output.js
--- a/devtools/client/webconsole/console-output.js
+++ b/devtools/client/webconsole/console-output.js
@@ -774,17 +774,16 @@ Messages.Simple.prototype = Heritage.ext
    * The raw message displayed by this Message object. This can be a function,
    * DOM node or a string.
    *
    * @private
    * @type mixed
    */
   _message: null,
 
-  _afterMessage: null,
   _objectActors: null,
   _groupDepthCompat: 0,
 
   /**
    * Message timestamp.
    *
    * @type number
    *       Milliseconds elapsed since 1 January 1970 00:00:00 UTC.
@@ -938,21 +937,16 @@ Messages.Simple.prototype = Heritage.ext
     this.element.appendChild(this.document.createTextNode("\n"));
 
     this.element.clipboardText = this.element.textContent;
 
     if (this.private) {
       this.element.setAttribute("private", true);
     }
 
-    if (this._afterMessage) {
-      this.element._outputAfterNode = this._afterMessage.element;
-      this._afterMessage = null;
-    }
-
     // TODO: handle object releasing in a more elegant way once all console
     // messages use the new API - bug 778766.
     this.element._objectActors = this._objectActors;
     this._objectActors = null;
 
     return this;
   },
 
diff --git a/devtools/client/webconsole/test/browser_console.js b/devtools/client/webconsole/test/browser_console.js
--- a/devtools/client/webconsole/test/browser_console.js
+++ b/devtools/client/webconsole/test/browser_console.js
@@ -10,96 +10,71 @@
 const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
                  "test/test-console.html?" + Date.now();
 
 const TEST_XHR_ERROR_URI = `http://example.com/404.html?${Date.now()}`;
 
 const TEST_IMAGE = "http://example.com/browser/devtools/client/webconsole/" +
                    "test/test-image.png";
 
-"use strict";
-
-var test = asyncTest(function*() {
+add_task(function*() {
   yield loadTab(TEST_URI);
 
   let opened = waitForConsole();
 
   let hud = HUDService.getBrowserConsole();
   ok(!hud, "browser console is not open");
   info("wait for the browser console to open with ctrl-shift-j");
   EventUtils.synthesizeKey("j", { accelKey: true, shiftKey: true }, window);
 
   hud = yield opened;
   ok(hud, "browser console opened");
 
   yield consoleOpened(hud);
+  yield finishTest();
 });
 
-function consoleOpened(hud) {
+function* consoleOpened(hud) {
   hud.jsterm.clearOutput(true);
 
-  expectUncaughtException();
-  executeSoon(() => {
-    foobarExceptionBug587757();
-  });
-
-  // Add a message from a chrome window.
-  hud.iframeWindow.console.log("bug587757a");
-
-  // Add a message from a content window.
-  content.console.log("bug587757b");
-
-  // Test eval.
-  hud.jsterm.execute("document.location.href");
-
-  // Check for network requests.
-  let xhr = new XMLHttpRequest();
-  xhr.onload = () => console.log("xhr loaded, status is: " + xhr.status);
-  xhr.open("get", TEST_URI, true);
-  xhr.send();
-
-  // Check for xhr error.
-  let xhrErr = new XMLHttpRequest();
-  xhrErr.onload = () => {
-    console.log("xhr error loaded, status is: " + xhrErr.status);
-  };
-  xhrErr.open("get", TEST_XHR_ERROR_URI, true);
-  xhrErr.send();
-
-  // Check that Fetch requests are categorized as "XHR".
-  fetch(TEST_IMAGE).then(() => { console.log("fetch loaded"); });
-
-  return waitForMessages({
+  let waiting = waitForMessages({
+    enforceOrder: true,
     webconsole: hud,
     messages: [
       {
         name: "chrome window console.log() is displayed",
         text: "bug587757a",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
       },
       {
         name: "content window console.log() is displayed",
         text: "bug587757b",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
       },
       {
+        name: "exception message",
+        text: "foobarExceptionBug587757",
+        category: CATEGORY_JS,
+        severity: SEVERITY_ERROR,
+      },
+      {
+        name: "log statement in eval",
+        text: "Log statement in eval",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_LOG,
+      },
+      {
         name: "jsterm eval result",
         text: "browser.xul",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_LOG,
       },
       {
-        name: "exception message",
-        text: "foobarExceptionBug587757",
-        category: CATEGORY_JS,
-        severity: SEVERITY_ERROR,
-      },
-      {
         name: "network message",
         text: "test-console.html",
         category: CATEGORY_NETWORK,
         severity: SEVERITY_INFO,
         isXhr: true,
       },
       {
         name: "xhr error message",
@@ -112,16 +87,65 @@ function consoleOpened(hud) {
         name: "network message",
         text: "test-image.png",
         category: CATEGORY_NETWORK,
         severity: SEVERITY_INFO,
         isXhr: true,
       },
     ],
   });
+
+  // Add a message from a chrome window.
+  hud.iframeWindow.console.log("bug587757a");
+
+  // Add a message from a content window.
+  content.console.log("bug587757b");
+
+  expectUncaughtException();
+  yield new Promise(resolve => {
+    executeSoon(() => {
+      executeSoon(resolve);
+      foobarExceptionBug587757();
+    });
+  });
+
+  // Test eval.
+  yield hud.jsterm.execute(`
+    console.log("Log statement in eval");
+    document.location.href;
+  `);
+
+  // Check for network requests.
+  yield new Promise(resolve => {
+    let xhr = new XMLHttpRequest();
+    xhr.onload = () => {
+      console.log("xhr loaded, status is: " + xhr.status);
+      resolve();
+    };
+    xhr.open("get", TEST_URI, true);
+    xhr.send();
+  })
+
+  // Check for xhr error.
+  yield new Promise(resolve => {
+    let xhrErr = new XMLHttpRequest();
+    xhrErr.onload = () => {
+      console.log("xhr error loaded, status is: " + xhrErr.status);
+      resolve();
+    };
+    xhrErr.open("get", TEST_XHR_ERROR_URI, true);
+    xhrErr.send();
+  });
+
+  // Check that Fetch requests are categorized as "XHR".
+  yield fetch(TEST_IMAGE).then(() => {
+    console.log("fetch loaded");
+  });
+
+  yield waiting;
 }
 
 function waitForConsole() {
   let deferred = promise.defer();
 
   Services.obs.addObserver(function observer(aSubject) {
     Services.obs.removeObserver(observer, "web-console-created");
     aSubject.QueryInterface(Ci.nsISupportsString);
diff --git a/devtools/client/webconsole/test/browser_webconsole_output_order.js b/devtools/client/webconsole/test/browser_webconsole_output_order.js
--- a/devtools/client/webconsole/test/browser_webconsole_output_order.js
+++ b/devtools/client/webconsole/test/browser_webconsole_output_order.js
@@ -1,47 +1,47 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-// Tests that any output created from calls to the console API comes after the
+// Tests that any output created from calls to the console API comes before the
 // echoed JavaScript.
 
 "use strict";
 
 const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
                  "test/test-console.html";
 
 var test = asyncTest(function*() {
   yield loadTab(TEST_URI);
   let hud = yield openConsole();
 
   let jsterm = hud.jsterm;
 
   jsterm.clearOutput();
   jsterm.execute("console.log('foo', 'bar');");
 
-  let [functionCall, result, consoleMessage] = yield waitForMessages({
+  let [functionCall, consoleMessage, result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "console.log('foo', 'bar');",
       category: CATEGORY_INPUT,
     },
     {
-      text: "undefined",
-      category: CATEGORY_OUTPUT,
-    },
-    {
       text: "foo bar",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
-    }],
+    },
+    {
+      text: "undefined",
+      category: CATEGORY_OUTPUT,
+    }]
   });
 
   let fncallNode = [...functionCall.matched][0];
+  let consoleMessageNode = [...consoleMessage.matched][0];
   let resultNode = [...result.matched][0];
-  let consoleMessageNode = [...consoleMessage.matched][0];
-  is(fncallNode.nextElementSibling, resultNode,
-     "console.log() is followed by undefined");
-  is(resultNode.nextElementSibling, consoleMessageNode,
-     "undefined is followed by 'foo' 'bar'");
+  is(fncallNode.nextElementSibling, consoleMessageNode,
+     "console.log() is followed by 'foo' 'bar'");
+  is(consoleMessageNode.nextElementSibling, resultNode,
+     "'foo' 'bar' is followed by undefined");
 });
diff --git a/devtools/client/webconsole/test/head.js b/devtools/client/webconsole/test/head.js
--- a/devtools/client/webconsole/test/head.js
+++ b/devtools/client/webconsole/test/head.js
@@ -842,16 +842,18 @@ function isDebuggerCaretPos(panel, line,
 }
 
 /**
  * Wait for messages in the Web Console output.
  *
  * @param object options
  *        Options for what you want to wait for:
  *        - webconsole: the webconsole instance you work with.
+ *        - enforceOrder: fail if the messages don't come in the same order
+ *                        as the messages array.
  *        - matchCondition: "any" or "all". Default: "all". The promise
  *        returned by this function resolves when all of the messages are
  *        matched, if the |matchCondition| is "all". If you set the condition to
  *        "any" then the promise is resolved by any message rule that matches,
  *        irrespective of order - waiting for messages stops whenever any rule
  *        matches.
  *        - messages: an array of objects that tells which messages to wait for.
  *        Properties:
@@ -911,16 +913,17 @@ function isDebuggerCaretPos(panel, line,
  *         in the message element, to expand a long string. This is available
  *         only if |longString| is present in the matching rule.
  */
 function waitForMessages(options) {
   info("Waiting for messages...");
 
   gPendingOutputTest++;
   let webconsole = options.webconsole;
+  let enforceOrder = !!options.enforceOrder;
   let rules = WebConsoleUtils.cloneObject(options.messages, true);
   let rulesMatched = 0;
   let listenerAdded = false;
   let deferred = promise.defer();
   options.matchCondition = options.matchCondition || "all";
 
   function checkText(rule, text) {
     let result = false;
@@ -1284,39 +1287,54 @@ function waitForMessages(options) {
         let url = location.title;
         // Prevent recursion with the browser console and any potential
         // messages coming from head.js.
         if (url.indexOf("devtools/client/webconsole/test/head.js") != -1) {
           continue;
         }
       }
 
+      let outOfOrder = false;
       for (let rule of rules) {
         if (rule._ruleMatched) {
           continue;
         }
 
         let matched = checkMessage(rule, elem);
         if (matched) {
+          if (outOfOrder && enforceOrder) {
+            ok(false, "Failed due to out of order " + displayRule(rule));
+            failImmediately();
+            return;
+          }
           rule._ruleMatched = true;
           rulesMatched++;
           ok(1, "matched rule: " + displayRule(rule));
           if (maybeDone()) {
             return;
           }
+        } else {
+          outOfOrder = true;
         }
       }
     }
   }
 
   function allRulesMatched() {
     return options.matchCondition == "all" && rulesMatched == rules.length ||
            options.matchCondition == "any" && rulesMatched > 0;
   }
 
+  function failImmediately() {
+    if (listenerAdded) {
+      webconsole.ui.off("new-messages", onMessagesAdded);
+    }
+    deferred.resolve(rules);
+  }
+
   function maybeDone() {
     if (allRulesMatched()) {
       if (listenerAdded) {
         webconsole.ui.off("new-messages", onMessagesAdded);
       }
       gPendingOutputTest--;
       deferred.resolve(rules);
       return true;
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -2233,29 +2233,23 @@ WebConsoleFrame.prototype = {
 
     let node = typeof methodOrNode == "function" ?
                methodOrNode.apply(this, args || []) :
                methodOrNode;
     if (!node) {
       return null;
     }
 
-    let afterNode = node._outputAfterNode;
-    if (afterNode) {
-      delete node._outputAfterNode;
-    }
-
     let isFiltered = this.filterMessageNode(node);
 
     let isRepeated = this._filterRepeatedMessage(node);
 
     let visible = !isRepeated && !isFiltered;
     if (!isRepeated) {
-      this.outputNode.insertBefore(node,
-                                   afterNode ? afterNode.nextSibling : null);
+      this.outputNode.appendChild(node);
       this._pruneCategoriesQueue[node.category] = true;
 
       let nodeID = node.getAttribute("id");
       Services.obs.notifyObservers(aHudIdSupportsString,
                                    "web-console-message-created", nodeID);
 
     }
 
@@ -3236,27 +3230,24 @@ JSTerm.prototype = {
       inputNode.focus();
     }
   },
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
-   * @param object [aAfterMessage]
-   *        Optional message after which the evaluation result will be
-   *        inserted.
    * @param function [aCallback]
    *        Optional function to invoke when the evaluation result is added to
    *        the output.
    * @param object aResponse
    *        The message received from the server.
    */
   _executeResultCallback:
-  function JST__executeResultCallback(aAfterMessage, aCallback, aResponse)
+  function JST__executeResultCallback(aCallback, aResponse)
   {
     if (!this.hud) {
       return;
     }
     if (aResponse.error) {
       Cu.reportError("Evaluation error " + aResponse.error + ": " +
                      aResponse.message);
       return;
@@ -3270,22 +3261,16 @@ JSTerm.prototype = {
       switch (helperResult.type) {
         case "clearOutput":
           this.clearOutput();
           break;
         case "clearHistory":
           this.clearHistory();
           break;
         case "inspectObject":
-          if (aAfterMessage) {
-            if (!aAfterMessage._objectActors) {
-              aAfterMessage._objectActors = new Set();
-            }
-            aAfterMessage._objectActors.add(helperResult.object.actor);
-          }
           this.openVariablesView({
             label: VariablesView.getString(helperResult.object, { concise: true }),
             objectActor: helperResult.object,
           });
           break;
         case "error":
           try {
             errorMessage = l10n.getStr(helperResult.message);
@@ -3323,17 +3308,16 @@ JSTerm.prototype = {
           this.hud._flushCallback = oldFlushCallback;
           return true;
         }
 
         return false;
       };
     }
 
-    msg._afterMessage = aAfterMessage;
     msg._objectActors = new Set();
 
     if (WebConsoleUtils.isActorGrip(aResponse.exception)) {
       msg._objectActors.add(aResponse.exception.actor);
     }
 
     if (WebConsoleUtils.isActorGrip(result)) {
       msg._objectActors.add(result.actor);
@@ -3374,17 +3358,17 @@ JSTerm.prototype = {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
     }
 
     let message = new Messages.Simple(aExecuteString, {
       category: "input",
       severity: "log",
     });
     this.hud.output.addMessage(message);
-    let onResult = this._executeResultCallback.bind(this, message, callback);
+    let onResult = this._executeResultCallback.bind(this, callback);
 
     let options = {
       frame: this.SELECTED_FRAME,
       selectedNodeActor: selectedNodeActor,
     };
 
     this.requestEvaluation(aExecuteString, options).then(onResult, onResult);
 
