# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  871d92a1b0701ad79780989bf2ae335d4a19f138
Bug 1044365 - wait to append the evalled message until after it finsihes

diff --git a/devtools/client/webconsole/console-output.js b/devtools/client/webconsole/console-output.js
--- a/devtools/client/webconsole/console-output.js
+++ b/devtools/client/webconsole/console-output.js
@@ -774,17 +774,16 @@ Messages.Simple.prototype = Heritage.ext
    * The raw message displayed by this Message object. This can be a function,
    * DOM node or a string.
    *
    * @private
    * @type mixed
    */
   _message: null,
 
-  _afterMessage: null,
   _objectActors: null,
   _groupDepthCompat: 0,
 
   /**
    * Message timestamp.
    *
    * @type number
    *       Milliseconds elapsed since 1 January 1970 00:00:00 UTC.
@@ -938,21 +937,16 @@ Messages.Simple.prototype = Heritage.ext
     this.element.appendChild(this.document.createTextNode("\n"));
 
     this.element.clipboardText = this.element.textContent;
 
     if (this.private) {
       this.element.setAttribute("private", true);
     }
 
-    if (this._afterMessage) {
-      this.element._outputAfterNode = this._afterMessage.element;
-      this._afterMessage = null;
-    }
-
     // TODO: handle object releasing in a more elegant way once all console
     // messages use the new API - bug 778766.
     this.element._objectActors = this._objectActors;
     this._objectActors = null;
 
     return this;
   },
 
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -2233,29 +2233,23 @@ WebConsoleFrame.prototype = {
 
     let node = typeof methodOrNode == "function" ?
                methodOrNode.apply(this, args || []) :
                methodOrNode;
     if (!node) {
       return null;
     }
 
-    let afterNode = node._outputAfterNode;
-    if (afterNode) {
-      delete node._outputAfterNode;
-    }
-
     let isFiltered = this.filterMessageNode(node);
 
     let isRepeated = this._filterRepeatedMessage(node);
 
     let visible = !isRepeated && !isFiltered;
     if (!isRepeated) {
-      this.outputNode.insertBefore(node,
-                                   afterNode ? afterNode.nextSibling : null);
+      this.outputNode.appendChild(node);
       this._pruneCategoriesQueue[node.category] = true;
 
       let nodeID = node.getAttribute("id");
       Services.obs.notifyObservers(aHudIdSupportsString,
                                    "web-console-message-created", nodeID);
 
     }
 
@@ -3236,27 +3230,24 @@ JSTerm.prototype = {
       inputNode.focus();
     }
   },
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
-   * @param object [aAfterMessage]
-   *        Optional message after which the evaluation result will be
-   *        inserted.
    * @param function [aCallback]
    *        Optional function to invoke when the evaluation result is added to
    *        the output.
    * @param object aResponse
    *        The message received from the server.
    */
   _executeResultCallback:
-  function JST__executeResultCallback(aAfterMessage, aCallback, aResponse)
+  function JST__executeResultCallback(aCallback, aResponse)
   {
     if (!this.hud) {
       return;
     }
     if (aResponse.error) {
       Cu.reportError("Evaluation error " + aResponse.error + ": " +
                      aResponse.message);
       return;
@@ -3270,22 +3261,16 @@ JSTerm.prototype = {
       switch (helperResult.type) {
         case "clearOutput":
           this.clearOutput();
           break;
         case "clearHistory":
           this.clearHistory();
           break;
         case "inspectObject":
-          if (aAfterMessage) {
-            if (!aAfterMessage._objectActors) {
-              aAfterMessage._objectActors = new Set();
-            }
-            aAfterMessage._objectActors.add(helperResult.object.actor);
-          }
           this.openVariablesView({
             label: VariablesView.getString(helperResult.object, { concise: true }),
             objectActor: helperResult.object,
           });
           break;
         case "error":
           try {
             errorMessage = l10n.getStr(helperResult.message);
@@ -3323,17 +3308,16 @@ JSTerm.prototype = {
           this.hud._flushCallback = oldFlushCallback;
           return true;
         }
 
         return false;
       };
     }
 
-    msg._afterMessage = aAfterMessage;
     msg._objectActors = new Set();
 
     if (WebConsoleUtils.isActorGrip(aResponse.exception)) {
       msg._objectActors.add(aResponse.exception.actor);
     }
 
     if (WebConsoleUtils.isActorGrip(result)) {
       msg._objectActors.add(result.actor);
@@ -3349,16 +3333,20 @@ JSTerm.prototype = {
    * @param function [aCallback]
    *        Optional function to invoke when the result is displayed.
    *        This is deprecated - please use the promise return value instead.
    * @returns Promise
    *          Resolves with the message once the result is displayed.
    */
   execute: function JST_execute(aExecuteString, aCallback)
   {
+    let message = new Messages.Simple(aExecuteString, {
+      category: "input",
+      severity: "log",
+    });
     let deferred = promise.defer();
     let callback = function(msg) {
       deferred.resolve(msg);
       if (aCallback) {
         aCallback(msg);
       }
     }
 
@@ -3369,22 +3357,18 @@ JSTerm.prototype = {
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
     if (inspectorSelection && inspectorSelection.nodeFront) {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
     }
 
-    let message = new Messages.Simple(aExecuteString, {
-      category: "input",
-      severity: "log",
-    });
     this.hud.output.addMessage(message);
-    let onResult = this._executeResultCallback.bind(this, message, callback);
+    let onResult = this._executeResultCallback.bind(this, callback);
 
     let options = {
       frame: this.SELECTED_FRAME,
       selectedNodeActor: selectedNodeActor,
     };
 
     this.requestEvaluation(aExecuteString, options).then(onResult, onResult);
 
