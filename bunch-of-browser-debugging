# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8cd6d019656ffe56b7385fada04dc9fa192390b1

diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -1603,17 +1603,17 @@ window._gBrowser = {
     listener.destroy();
 
     let oldDroppedLinkHandler = aBrowser.droppedLinkHandler;
     let oldSameProcessAsFrameLoader = aBrowser.sameProcessAsFrameLoader;
     let oldUserTypedValue = aBrowser.userTypedValue;
     let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
 
     // Make sure the browser is destroyed so it unregisters from observer notifications
-    aBrowser.destroy();
+    // aBrowser.destroy();
 
     // Change the "remote" attribute.
     let parent = aBrowser.parentNode;
     aBrowser.remove();
     if (aShouldBeRemote) {
       aBrowser.setAttribute("remote", "true");
       aBrowser.setAttribute("remoteType", remoteType);
     } else {
@@ -3001,17 +3001,17 @@ window._gBrowser = {
       // Because of the way XBL works (fields just set JS
       // properties on the element) and the code we have in place
       // to preserve the JS objects for any elements that have
       // JS properties set on them, the browser element won't be
       // destroyed until the document goes away.  So we force a
       // cleanup ourselves.
       // This has to happen before we remove the child so that the
       // XBL implementation of nsIObserver still works.
-      browser.destroy();
+      // browser.destroy();
     }
 
     var wasPinned = aTab.pinned;
 
     // Remove the tab ...
     aTab.remove();
 
     // Update hashiddentabs if this tab was hidden.
diff --git a/browser/components/places/tests/browser/browser_library_middleclick.js b/browser/components/places/tests/browser/browser_library_middleclick.js
--- a/browser/components/places/tests/browser/browser_library_middleclick.js
+++ b/browser/components/places/tests/browser/browser_library_middleclick.js
@@ -105,69 +105,69 @@ gTests.push({
   async cleanup() {
     await PlacesUtils.bookmarks.remove(this._bookmarks[0]);
   },
 });
 
 // ------------------------------------------------------------------------------
 // Open a query in tabs.
 
-gTests.push({
-  desc: "Open a query in tabs.",
-  URIs: ["about:buildconfig", "about:mozilla"],
-  _bookmarks: null,
-  _query: null,
+// gTests.push({
+//   desc: "Open a query in tabs.",
+//   URIs: ["about:buildconfig", "about:mozilla"],
+//   _bookmarks: null,
+//   _query: null,
 
-  async setup() {
-    let children = this.URIs.map(url => {
-      return {
-        title: "Title",
-        url,
-      };
-    });
+//   async setup() {
+//     let children = this.URIs.map(url => {
+//       return {
+//         title: "Title",
+//         url,
+//       };
+//     });
 
-    this._bookmarks = await PlacesUtils.bookmarks.insertTree({
-      guid: PlacesUtils.bookmarks.unfiledGuid,
-      children: [{
-        title: "Folder",
-        type: PlacesUtils.bookmarks.TYPE_FOLDER,
-        children,
-      }],
-    });
+//     this._bookmarks = await PlacesUtils.bookmarks.insertTree({
+//       guid: PlacesUtils.bookmarks.unfiledGuid,
+//       children: [{
+//         title: "Folder",
+//         type: PlacesUtils.bookmarks.TYPE_FOLDER,
+//         children,
+//       }],
+//     });
 
-    // Create a bookmarks query containing our bookmarks.
-    var hs = PlacesUtils.history;
-    var options = hs.getNewQueryOptions();
-    options.queryType = Ci.nsINavHistoryQueryOptions.QUERY_TYPE_BOOKMARKS;
-    var query = hs.getNewQuery();
-    // The colon included in the terms selects only about: URIs. If not included
-    // we also may get pages like about.html included in the query result.
-    query.searchTerms = "about:";
-    var queryString = hs.queryToQueryString(query, options);
-    this._query = await PlacesUtils.bookmarks.insert({
-      index: 0, // it must be the first
-      parentGuid: PlacesUtils.bookmarks.unfiledGuid,
-      title: "Query",
-      url: queryString,
-    });
+//     // Create a bookmarks query containing our bookmarks.
+//     var hs = PlacesUtils.history;
+//     var options = hs.getNewQueryOptions();
+//     options.queryType = Ci.nsINavHistoryQueryOptions.QUERY_TYPE_BOOKMARKS;
+//     var query = hs.getNewQuery();
+//     // The colon included in the terms selects only about: URIs. If not included
+//     // we also may get pages like about.html included in the query result.
+//     query.searchTerms = "about:";
+//     var queryString = hs.queryToQueryString(query, options);
+//     this._query = await PlacesUtils.bookmarks.insert({
+//       index: 0, // it must be the first
+//       parentGuid: PlacesUtils.bookmarks.unfiledGuid,
+//       title: "Query",
+//       url: queryString,
+//     });
 
-    // Select unsorted bookmarks root in the left pane.
-    gLibrary.PlacesOrganizer.selectLeftPaneBuiltIn("UnfiledBookmarks");
-    isnot(gLibrary.PlacesOrganizer._places.selectedNode, null,
-          "We correctly have selection in the Library left pane");
-    // Get our bookmark in the right pane.
-    var folderNode = gLibrary.ContentTree.view.view.nodeForTreeIndex(0);
-    is(folderNode.title, "Query", "Found query in the right pane");
-  },
+//     // Select unsorted bookmarks root in the left pane.
+//     gLibrary.PlacesOrganizer.selectLeftPaneBuiltIn("UnfiledBookmarks");
+//     isnot(gLibrary.PlacesOrganizer._places.selectedNode, null,
+//           "We correctly have selection in the Library left pane");
+//     // Get our bookmark in the right pane.
+//     var folderNode = gLibrary.ContentTree.view.view.nodeForTreeIndex(0);
+//     is(folderNode.title, "Query", "Found query in the right pane");
+//   },
 
-  async cleanup() {
-    await PlacesUtils.bookmarks.remove(this._bookmarks[0]);
-    await PlacesUtils.bookmarks.remove(this._query);
-  },
-});
+//   async cleanup() {
+//     await PlacesUtils.bookmarks.remove(this._bookmarks[0]);
+//     await PlacesUtils.bookmarks.remove(this._query);
+//   },
+// });
 
 async function runTest(test) {
   info("Start of test: " + test.desc);
   // Test setup will set Library so that the bookmark to be opened is the
   // first node in the content (right pane) tree.
   await test.setup();
 
   // Middle click on first node in the content tree of the Library.
diff --git a/toolkit/content/widgets/browser.js b/toolkit/content/widgets/browser.js
--- a/toolkit/content/widgets/browser.js
+++ b/toolkit/content/widgets/browser.js
@@ -3,176 +3,304 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
-let LOG = () => { };// console.log.bind(null, "browser logging:");
+let LOG = console.log.bind(null, "browser logging:");
 let browserNumber = 0;
 const WINDOW_ID = window.windowUtils.currentInnerWindowID;
 /* globals XULFrameElement */
 
+let trackedBrowsers = new Set();
+window.addEventListener("beforeunload", (e) => {
+  if (e.originalTarget == document) {
+    console.log("beforeunload", document.documentURI, trackedBrowsers.size)
+    for (let browser of trackedBrowsers) {
+      // browser.destroy();
+      browser.remove();
+    }
+    trackedBrowsers.clear();
+  }
+}, { mozSystemGroup: true, capture: true });
+
 class MozBrowser extends XULFrameElement {
 
   static get observedAttributes() {
     return ["remote"];
   }
 
   get logString() {
-    return `<browser remote='${this.isRemoteBrowser ? "true" : "false"}'> #${this.browserNumber} in window: ${WINDOW_ID}`;
+    return `<browser remote='${this.isRemoteBrowser ? "true" : "false"}'> #${this.browserNumber} in window: ${WINDOW_ID}. Docshell ? ${this.docShell}`;
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     // When we have already been set up via connectedCallback and the
     // and the [remote] value changes, we need to start over. This used
     // to happen due to a XBL binding change.
     if (this.isConnected && name === "remote") {
-      this.destroy();
-      this.construct();
+      // this.destroy();
+      // this.construct();
     }
   }
 
   constructor() {
     super();
 
+    this._documentURI = null;
+
+    this._documentContentType = null;
+
+    /**
+     * Weak reference to an optional frame loader that can be used to influence
+     * process selection for this browser.
+     * See nsIBrowser.sameProcessAsFrameLoader.
+     */
+    this._sameProcessAsFrameLoader = null;
+
+    this._loadContext = null;
+
+    this._imageDocument = null;
+
+    this._webBrowserFind = null;
+
+    this._finder = null;
+
+    this._remoteFinder = null;
+
+    this._fastFind = null;
+
+    this._outerWindowID = null;
+
+    this._innerWindowID = null;
+
+    this._lastSearchString = null;
+
+    this._controller = null;
+
+    this._selectParentHelper = null;
+
+    this._remoteWebNavigation = null;
+
+    this._remoteWebProgress = null;
+
+    this._contentWindow = null;
+
+    this._contentDocument = null;
+
+    this._contentTitle = "";
+
+    this._characterSet = "";
+
+    this._mayEnableCharacterEncodingMenu = null;
+
+    this._contentPrincipal = null;
+
+    this._contentRequestContextID = null;
+
+    this._fullZoom = 1;
+
+    this._textZoom = 1;
+
+    this._isSyntheticDocument = false;
+
+    this.mPrefs = Services.prefs;
+
+    this._mStrBundle = null;
+
+    this.blockedPopups = null;
+
+    this._audioMuted = false;
+
+    this._hasAnyPlayingMediaBeenBlocked = false;
+
+    /**
+     * Only send the message "Browser:UnselectedTabHover" when someone requests
+     * for the message, which can reduce non-necessary communication.
+     */
+    this._shouldSendUnselectedTabHover = false;
+
+    this._unselectedTabHoverMessageListenerCount = 0;
+
+    this._securityUI = null;
+
+    this.urlbarChangeTracker = {
+      _startedLoadSinceLastUserTyping: false,
+
+      startedLoad() {
+        this._startedLoadSinceLastUserTyping = true;
+      },
+      finishedLoad() {
+        this._startedLoadSinceLastUserTyping = false;
+      },
+      userTyped() {
+        this._startedLoadSinceLastUserTyping = false;
+      },
+    };
+
+
     this.browserNumber = browserNumber++;
     LOG("constructor() called", this.logString);
 
     this.destroyOnUnload = this.destroyOnUnload.bind(this);
 
+    this._userTypedValue = null;
+
+    this._AUTOSCROLL_SNAP = 10;
+
+    this._scrolling = false;
+
+    this._startX = null;
+
+    this._startY = null;
+
+    this._autoScrollPopup = null;
+
+    this._autoScrollNeedsCleanup = false;
+
+    /**
+     * These IDs identify the scroll frame being autoscrolled.
+     */
+    this._autoScrollScrollId = null;
+
+    this._autoScrollPresShellId = null;
+
+    this._permitUnloadId = 0;
 
     /**
      * These are managed by the tabbrowser
      */
     this.droppedLinkHandler = null;
 
     this.mIconURL = null;
 
     this.lastURI = null;
 
-    this.addEventListener("keypress", (event) => {
-      if (event.keyCode != KeyEvent.DOM_VK_F7) { return; }
-      if (event.defaultPrevented || !event.isTrusted)
-        return;
+    // this.addEventListener("keypress", (event) => {
+    //   if (event.keyCode != KeyEvent.DOM_VK_F7) { return; }
+    //   if (event.defaultPrevented || !event.isTrusted)
+    //     return;
 
-      const kPrefShortcutEnabled = "accessibility.browsewithcaret_shortcut.enabled";
-      const kPrefWarnOnEnable = "accessibility.warn_on_browsewithcaret";
-      const kPrefCaretBrowsingOn = "accessibility.browsewithcaret";
+    //   const kPrefShortcutEnabled = "accessibility.browsewithcaret_shortcut.enabled";
+    //   const kPrefWarnOnEnable = "accessibility.warn_on_browsewithcaret";
+    //   const kPrefCaretBrowsingOn = "accessibility.browsewithcaret";
 
-      var isEnabled = this.mPrefs.getBoolPref(kPrefShortcutEnabled);
-      if (!isEnabled)
-        return;
+    //   var isEnabled = this.mPrefs.getBoolPref(kPrefShortcutEnabled);
+    //   if (!isEnabled)
+    //     return;
 
-      // Toggle browse with caret mode
-      var browseWithCaretOn = this.mPrefs.getBoolPref(kPrefCaretBrowsingOn, false);
-      var warn = this.mPrefs.getBoolPref(kPrefWarnOnEnable, true);
-      if (warn && !browseWithCaretOn) {
-        var checkValue = { value: false };
-        var promptService = Services.prompt;
+    //   // Toggle browse with caret mode
+    //   var browseWithCaretOn = this.mPrefs.getBoolPref(kPrefCaretBrowsingOn, false);
+    //   var warn = this.mPrefs.getBoolPref(kPrefWarnOnEnable, true);
+    //   if (warn && !browseWithCaretOn) {
+    //     var checkValue = { value: false };
+    //     var promptService = Services.prompt;
 
-        var buttonPressed = promptService.confirmEx(window,
-          this.mStrBundle.GetStringFromName("browsewithcaret.checkWindowTitle"),
-          this.mStrBundle.GetStringFromName("browsewithcaret.checkLabel"),
-          // Make "No" the default:
-          promptService.STD_YES_NO_BUTTONS | promptService.BUTTON_POS_1_DEFAULT,
-          null, null, null, this.mStrBundle.GetStringFromName("browsewithcaret.checkMsg"),
-          checkValue);
-        if (buttonPressed != 0) {
-          if (checkValue.value) {
-            try {
-              this.mPrefs.setBoolPref(kPrefShortcutEnabled, false);
-            } catch (ex) {}
-          }
-          return;
-        }
-        if (checkValue.value) {
-          try {
-            this.mPrefs.setBoolPref(kPrefWarnOnEnable, false);
-          } catch (ex) {}
-        }
-      }
+    //     var buttonPressed = promptService.confirmEx(window,
+    //       this.mStrBundle.GetStringFromName("browsewithcaret.checkWindowTitle"),
+    //       this.mStrBundle.GetStringFromName("browsewithcaret.checkLabel"),
+    //       // Make "No" the default:
+    //       promptService.STD_YES_NO_BUTTONS | promptService.BUTTON_POS_1_DEFAULT,
+    //       null, null, null, this.mStrBundle.GetStringFromName("browsewithcaret.checkMsg"),
+    //       checkValue);
+    //     if (buttonPressed != 0) {
+    //       if (checkValue.value) {
+    //         try {
+    //           this.mPrefs.setBoolPref(kPrefShortcutEnabled, false);
+    //         } catch (ex) {}
+    //       }
+    //       return;
+    //     }
+    //     if (checkValue.value) {
+    //       try {
+    //         this.mPrefs.setBoolPref(kPrefWarnOnEnable, false);
+    //       } catch (ex) {}
+    //     }
+    //   }
 
-      // Toggle the pref
-      try {
-        this.mPrefs.setBoolPref(kPrefCaretBrowsingOn, !browseWithCaretOn);
-      } catch (ex) {}
-    }, { mozSystemGroup: true });
+    //   // Toggle the pref
+    //   try {
+    //     this.mPrefs.setBoolPref(kPrefCaretBrowsingOn, !browseWithCaretOn);
+    //   } catch (ex) {}
+    // }, { mozSystemGroup: true });
 
-    this.addEventListener("dragover", (event) => {
-      if (!this.droppedLinkHandler || event.defaultPrevented)
-        return;
+    // this.addEventListener("dragover", (event) => {
+    //   if (!this.droppedLinkHandler || event.defaultPrevented)
+    //     return;
 
-      // For drags that appear to be internal text (for example, tab drags),
-      // set the dropEffect to 'none'. This prevents the drop even if some
-      // other listener cancelled the event.
-      var types = event.dataTransfer.types;
-      if (types.includes("text/x-moz-text-internal") && !types.includes("text/plain")) {
-        event.dataTransfer.dropEffect = "none";
-        event.stopPropagation();
-        event.preventDefault();
-      }
+    //   // For drags that appear to be internal text (for example, tab drags),
+    //   // set the dropEffect to 'none'. This prevents the drop even if some
+    //   // other listener cancelled the event.
+    //   var types = event.dataTransfer.types;
+    //   if (types.includes("text/x-moz-text-internal") && !types.includes("text/plain")) {
+    //     event.dataTransfer.dropEffect = "none";
+    //     event.stopPropagation();
+    //     event.preventDefault();
+    //   }
 
-      // No need to handle "dragover" in e10s, since nsDocShellTreeOwner.cpp in the child process
-      // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
-      if (this.isRemoteBrowser)
-        return;
+    //   // No need to handle "dragover" in e10s, since nsDocShellTreeOwner.cpp in the child process
+    //   // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
+    //   if (this.isRemoteBrowser)
+    //     return;
 
-      if (Services.droppedLinkHandler.canDropLink(event, false))
-        event.preventDefault();
-    }, { mozSystemGroup: true });
+    //   if (Services.droppedLinkHandler.canDropLink(event, false))
+    //     event.preventDefault();
+    // }, { mozSystemGroup: true });
 
-    this.addEventListener("drop", (event) => {
-      // No need to handle "drop" in e10s, since nsDocShellTreeOwner.cpp in the child process
-      // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
-      if (!this.droppedLinkHandler || event.defaultPrevented || this.isRemoteBrowser)
-        return;
+    // this.addEventListener("drop", (event) => {
+    //   // No need to handle "drop" in e10s, since nsDocShellTreeOwner.cpp in the child process
+    //   // handles that case using "@mozilla.org/content/dropped-link-handler;1" service.
+    //   if (!this.droppedLinkHandler || event.defaultPrevented || this.isRemoteBrowser)
+    //     return;
 
-      let linkHandler = Services.droppedLinkHandler;
-      try {
-        // Pass true to prevent the dropping of javascript:/data: URIs
-        var links = linkHandler.dropLinks(event, true);
-      } catch (ex) {
-        return;
-      }
+    //   let linkHandler = Services.droppedLinkHandler;
+    //   try {
+    //     // Pass true to prevent the dropping of javascript:/data: URIs
+    //     var links = linkHandler.dropLinks(event, true);
+    //   } catch (ex) {
+    //     return;
+    //   }
 
-      if (links.length) {
-        let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
-        this.droppedLinkHandler(event, links, triggeringPrincipal);
-      }
-    }, { mozSystemGroup: true });
+    //   if (links.length) {
+    //     let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
+    //     this.droppedLinkHandler(event, links, triggeringPrincipal);
+    //   }
+    // }, { mozSystemGroup: true });
 
-    this.addEventListener("dragstart", (event) => {
-      // If we're a remote browser dealing with a dragstart, stop it
-      // from propagating up, since our content process should be dealing
-      // with the mouse movement.
-      if (this.isRemoteBrowser) {
-        event.stopPropagation();
-      }
-    });
+    // this.addEventListener("dragstart", (event) => {
+    //   // If we're a remote browser dealing with a dragstart, stop it
+    //   // from propagating up, since our content process should be dealing
+    //   // with the mouse movement.
+    //   if (this.isRemoteBrowser) {
+    //     event.stopPropagation();
+    //   }
+    // });
 
   }
 
   destroyOnUnload(e) {
     if (e.originalTarget == document) {
-      window.removeEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
-      LOG("Destroying due to unload", this.logString);
-      this.destroy();
+      // window.removeEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
+      LOG("Destroying due to unload", this.isConnected, this.logString);
+      this.remove();
     }
   }
 
   disconnectedCallback() {
-    window.removeEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
+    trackedBrowsers.delete(this);
+    // window.removeEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
     this.destroy();
   }
 
   connectedCallback() {
-    window.addEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
+    trackedBrowsers.add(this);
+    // window.addEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
     this.construct();
   }
 
   get autoscrollEnabled() {
     if (this.getAttribute("autoscroll") == "false")
       return false;
 
     return this.mPrefs.getBoolPref("general.autoScroll", true);
@@ -848,133 +976,23 @@ class MozBrowser extends XULFrameElement
   didStartLoadSinceLastUserTyping() {
     return !this.inLoadURI &&
       this.urlbarChangeTracker._startedLoadSinceLastUserTyping;
   }
 
   construct() {
     LOG("construct() called", this.logString);
 
-    this._documentURI = null;
-
-    this._documentContentType = null;
-
-    /**
-     * Weak reference to an optional frame loader that can be used to influence
-     * process selection for this browser.
-     * See nsIBrowser.sameProcessAsFrameLoader.
-     */
-    this._sameProcessAsFrameLoader = null;
-
-    this._loadContext = null;
-
-    this._imageDocument = null;
-
-    this._webBrowserFind = null;
-
-    this._finder = null;
-
-    this._remoteFinder = null;
-
-    this._fastFind = null;
-
-    this._outerWindowID = null;
-
-    this._innerWindowID = null;
-
-    this._lastSearchString = null;
-
-    this._controller = null;
-
-    this._selectParentHelper = null;
-
-    this._remoteWebNavigation = null;
-
-    this._remoteWebProgress = null;
-
-    this._contentWindow = null;
-
-    this._contentDocument = null;
-
-    this._contentTitle = "";
-
-    this._characterSet = "";
-
-    this._mayEnableCharacterEncodingMenu = null;
-
-    this._contentPrincipal = null;
-
-    this._contentRequestContextID = null;
-
-    this._fullZoom = 1;
-
-    this._textZoom = 1;
-
-    this._isSyntheticDocument = false;
-
-    this.mPrefs = Services.prefs;
-
-    this._mStrBundle = null;
-
-    this.blockedPopups = null;
-
-    this._audioMuted = false;
-
-    this._hasAnyPlayingMediaBeenBlocked = false;
-
-    /**
-     * Only send the message "Browser:UnselectedTabHover" when someone requests
-     * for the message, which can reduce non-necessary communication.
-     */
-    this._shouldSendUnselectedTabHover = false;
-
-    this._unselectedTabHoverMessageListenerCount = 0;
-
-    this._securityUI = null;
-
-    this.urlbarChangeTracker = {
-      _startedLoadSinceLastUserTyping: false,
-
-      startedLoad() {
-        this._startedLoadSinceLastUserTyping = true;
-      },
-      finishedLoad() {
-        this._startedLoadSinceLastUserTyping = false;
-      },
-      userTyped() {
-        this._startedLoadSinceLastUserTyping = false;
-      },
-    };
-
-    this._userTypedValue = null;
-
     this.mDestroyed = false;
 
-    this._AUTOSCROLL_SNAP = 10;
-
-    this._scrolling = false;
-
-    this._startX = null;
-
-    this._startY = null;
-
-    this._autoScrollPopup = null;
-
-    this._autoScrollNeedsCleanup = false;
-
-    /**
-     * These IDs identify the scroll frame being autoscrolled.
-     */
-    this._autoScrollScrollId = null;
-
-    this._autoScrollPresShellId = null;
-
-    this._permitUnloadId = 0;
 
     if (this.isRemoteBrowser) {
+      if (this.docShell) {
+        throw "WHAT";
+      }
       /*
        * Don't try to send messages from this function. The message manager for
        * the <browser> element may not be initialized yet.
        */
 
       this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
         .createInstance(Ci.nsIWebNavigation);
       this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
@@ -1003,33 +1021,33 @@ class MozBrowser extends XULFrameElement
       this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
 
       if (this.hasAttribute("selectmenulist")) {
         this.messageManager.addMessageListener("Forms:ShowDropDown", this);
         this.messageManager.addMessageListener("Forms:HideDropDown", this);
       }
 
       if (!this.hasAttribute("disablehistory")) {
-        Services.obs.addObserver(this, "browser:purge-session-history", true);
+        // Services.obs.addObserver(this, "browser:purge-session-history", true);
       }
 
       let rc_js = "resource://gre/modules/RemoteController.js";
       let scope = {};
       Services.scriptloader.loadSubScript(rc_js, scope);
       let RemoteController = scope.RemoteController;
       this._controller = new RemoteController(this);
       this.controllers.appendController(this._controller);
     }
 
     try {
       // |webNavigation.sessionHistory| will have been set by the frame
       // loader when creating the docShell as long as this xul:browser
       // doesn't have the 'disablehistory' attribute set.
       if (this.docShell && this.webNavigation.sessionHistory) {
-        Services.obs.addObserver(this, "browser:purge-session-history", true);
+        // Services.obs.addObserver(this, "browser:purge-session-history", true);
 
         // enable global history if we weren't told otherwise
         if (!this.hasAttribute("disableglobalhistory") && !this.isRemoteBrowser) {
           try {
             this.docShell.useGlobalHistory = true;
           } catch (ex) {
             // This can occur if the Places database is locked
             Cu.reportError("Error enabling browser global history: " + ex);
@@ -1078,16 +1096,17 @@ class MozBrowser extends XULFrameElement
   }
 
   /**
    * This is necessary because the destructor doesn't always get called when
    * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
    */
   destroy() {
     LOG("destroy() called", this.logString);
+    console.trace();
     // Make sure that any open select is closed.
     if (this._selectParentHelper) {
       let menulist = document.getElementById(this.getAttribute("selectmenulist"));
       this._selectParentHelper.hide(menulist, this);
     }
     if (this.mDestroyed)
       return;
     this.mDestroyed = true;
@@ -1097,29 +1116,31 @@ class MozBrowser extends XULFrameElement
         this.controllers.removeController(this._controller);
       } catch (ex) {
         // This can fail when this browser element is not attached to a
         // BrowserDOMWindow.
       }
 
       if (!this.hasAttribute("disablehistory")) {
         try {
-          Services.obs.removeObserver(this, "browser:purge-session-history");
+          // Services.obs.removeObserver(this, "browser:purge-session-history");
         } catch (ex) {
+          LOG("Caught error removing observer", this.logString, this.isRemote);
           // It's not clear why this sometimes throws an exception.
         }
       }
 
-      return;
+      // return;
     }
 
     if (this.docShell && this.webNavigation.sessionHistory) {
       try {
-        Services.obs.removeObserver(this, "browser:purge-session-history");
+        // Services.obs.removeObserver(this, "browser:purge-session-history");
       } catch (ex) {
+        LOG("Caught error removing observer", this.logString, this.isRemote);
         // It's not clear why this sometimes throws an exception.
       }
     }
 
     this._fastFind = null;
     this._webBrowserFind = null;
 
     this.lastURI = null;
@@ -1694,17 +1715,17 @@ class MozBrowser extends XULFrameElement
     }
     aCallback(this.docShell.contentViewer.inPermitUnload);
   }
 
   permitUnload(aPermitUnloadFlags) {
     if (this.isRemoteBrowser) {
       let { tabParent } = this.frameLoader;
 
-      if (!tabParent.hasBeforeUnload) {
+      if (true) {
         return { permitUnload: true, timedOut: false };
       }
 
       const kTimeout = 1000;
 
       let finished = false;
       let responded = false;
       let permitUnload;
