# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  ca4acb214ef7f747898764c60b8cd3aaeae0bb5d

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -3,394 +3,15 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
-function mergeElement(element) {
-  if (element.previousSibling instanceof Text) {
-    element.previousSibling.appendData(element.textContent);
-  } else {
-    element.parentNode.insertBefore(element.firstChild, element);
-  }
-  element.remove();
-}
-
-function wrapChar(parent, element, index) {
-  var treeWalker = document.createTreeWalker(parent,
-    NodeFilter.SHOW_TEXT,
-    null);
-  var node = treeWalker.nextNode();
-  while (index >= node.length) {
-    index -= node.length;
-    node = treeWalker.nextNode();
-  }
-  if (index) {
-    node = node.splitText(index);
-  }
-  node.parentNode.insertBefore(element, node);
-  if (node.length > 1) {
-    node.splitText(1);
-  }
-  element.appendChild(node);
-}
-
-let gInsertSeparator;
-let gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
-let gAlwaysAppendAccessKey = false;
-function setGlobalAccessKeyFormattingState() {
-  if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
-    return;
-  }
-  try {
-    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
-
-    const prefNameInsertSeparator =
-      "intl.menuitems.insertseparatorbeforeaccesskeys";
-    const prefNameAlwaysAppendAccessKey =
-      "intl.menuitems.alwaysappendaccesskeys";
-
-    var val = Services.prefs.getComplexValue(prefNameInsertSeparator,
-      nsIPrefLocalizedString).data;
-    gInsertSeparator = (val == "true");
-
-    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
-      nsIPrefLocalizedString).data;
-    gAlwaysAppendAccessKey = (val == "true");
-  } catch (e) {
-    gInsertSeparator = true;
-  }
-  // console.log("setGlobalAccessKeyFormattingState", gInsertSeparator, gUnderlineAccesskey, gAlwaysAppendAccessKey);
-}
-
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
-  constructor() {
-    super();
-
-    setGlobalAccessKeyFormattingState();
-
-    this.addEventListener("click", event => {
-      if (!this.isTextLink || (event.button != 0 && event.button != 1)) {
-        return;
-      }
-      this.open(event);
-    }, true);
-
-    this.addEventListener("keypress", event => {
-      if (!this.isTextLink || event.keyCode != 13) {
-        return;
-      }
-      this.click();
-    });
-
-    this.addEventListener("click", (event) => {
-      if (this.disabled || !this.isLabelControl) {
-        return;
-      }
-      var controlElement = this.labeledControlElement;
-      if (!controlElement) {
-        return;
-      }
-      controlElement.focus();
-      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
-      if (controlElement.namespaceURI != XUL_NS) {
-        return;
-      }
-      if (controlElement.localName == "checkbox") {
-        controlElement.checked = !controlElement.checked;
-      } else if (controlElement.localName == "radio") {
-        controlElement.control.selectedItem = controlElement;
-      }
-    });
-  }
-
-  static get observedAttributes() {
-    return ["control", "class"];
-  }
-
-  attributeChangedCallback(name, oldValue, newValue) {
-    if (oldValue == newValue) {
-      return;
-    }
-    this.setupAsControlIfNeeded();
-  }
-
-  connectedCallback() {
-    if (this.delayConnectedCallback()) {
-      return;
-    }
-    this.setupAsControlIfNeeded();
-  }
-
-  get isTextLink() {
-    return this.classList.contains("text-link") || this.hasAttribute("onClick");
-  }
-
-  setupAsControlIfNeeded() {
-    if (!this.isConnectedAndReady) {
-      return;
-    }
-
-    let wasLabelControl = this.isLabelControl;
-    this.isLabelControl = this.hasAttribute("control") ||
-                          this.classList.contains("radio-label") ||
-                          this.classList.contains("checkbox-label") ||
-                          this.classList.contains("toolbarbutton-multiline-text");
-    if (!wasLabelControl && this.isLabelControl) {
-      if (gUnderlineAccesskey) {
-        this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
-        this.appendChild(this.accessKeyParens);
-      }
-      this.formatAccessKey(true);
-    }
-
-    if (wasLabelControl && !this.isLabelControl) {
-      this.accessKeyParens.remove();
-    }
-  }
-
-  set accessKey(val) {
-    if (!this.isLabelControl) {
-      this.setAttribute("accesskey", val);
-      return val;
-    }
-
-    // If this label already has an accesskey attribute store it here as well
-    if (this.hasAttribute("accesskey")) {
-      this.setAttribute("accesskey", val);
-    }
-    var control = this.labeledControlElement;
-    if (control) {
-      control.setAttribute("accesskey", val);
-    }
-    this.formatAccessKey(false);
-    return val;
-  }
-
-  get accessKey() {
-    var accessKey = this.getAttribute("accesskey");
-    return accessKey ? accessKey[0] : null;
-  }
-
-  get labeledControlElement() {
-    if (!this.isLabelControl) {
-      return null;
-    }
-
-    var control = this.control;
-    return control ? document.getElementById(control) : null;
-  }
-
-  set control(val) {
-    if (!this.isLabelControl) {
-      // After this gets set, the label will switch to `isLabelControl`
-      this.setAttribute("control", val);
-      return val;
-    }
-
-    var control = this.labeledControlElement;
-    if (control) {
-      control.labelElement = null; // No longer pointed to be this label
-    }
-    this.setAttribute("control", val);
-    this.formatAccessKey(false);
-    return val;
-  }
-
-  get control() {
-    return this.getAttribute("control");
-  }
-
-  set href(val) {
-    this.setAttribute("href", val);
-    return val;
-  }
-
-  get href() {
-    return this.getAttribute("href");
-  }
-
-  open(aEvent) {
-    if (!this.isTextLink) {
-      return;
-    }
-
-    var href = this.href;
-    if (!href || this.disabled || aEvent.defaultPrevented)
-      return;
-
-    var uri = null;
-    try {
-      const nsISSM = Ci.nsIScriptSecurityManager;
-      const secMan =
-        Cc["@mozilla.org/scriptsecuritymanager;1"]
-        .getService(nsISSM);
-
-      uri = Services.io.newURI(href);
-
-      let principal;
-      if (this.getAttribute("useoriginprincipal") == "true") {
-        principal = this.nodePrincipal;
-      } else {
-        principal = secMan.createNullPrincipal({});
-      }
-      try {
-        secMan.checkLoadURIWithPrincipal(principal, uri,
-          nsISSM.DISALLOW_INHERIT_PRINCIPAL);
-      } catch (ex) {
-        var msg = "Error: Cannot open a " + uri.scheme + ": link using \
-                         the text-link binding.";
-        Cu.reportError(msg);
-        return;
-      }
-
-      const cID = "@mozilla.org/uriloader/external-protocol-service;1";
-      const nsIEPS = Ci.nsIExternalProtocolService;
-      var protocolSvc = Cc[cID].getService(nsIEPS);
-
-      // if the scheme is not an exposed protocol, then opening this link
-      // should be deferred to the system's external protocol handler
-      if (!protocolSvc.isExposedProtocol(uri.scheme)) {
-        protocolSvc.loadURI(uri);
-        aEvent.preventDefault();
-        return;
-      }
-
-    } catch (ex) {
-      Cu.reportError(ex);
-    }
-
-    aEvent.preventDefault();
-    href = uri ? uri.spec : href;
-
-    // Try handing off the link to the host application, e.g. for
-    // opening it in a tabbed browser.
-    var linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
-      .createInstance(Ci.nsISupportsPRBool);
-    linkHandled.data = false;
-    let { shiftKey, ctrlKey, metaKey, altKey, button } = aEvent;
-    let data = { shiftKey, ctrlKey, metaKey, altKey, button, href };
-    Services.obs
-      .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
-    if (linkHandled.data)
-      return;
-
-    // otherwise, fall back to opening the anchor directly
-    var win = window;
-    if (window.isChromeWindow) {
-      while (win.opener && !win.opener.closed)
-        win = win.opener;
-    }
-    win.open(href);
-  }
-
-  formatAccessKey(firstTime) {
-    if (!this.isLabelControl) {
-      return;
-    }
-
-    var control = this.labeledControlElement;
-    if (!control) {
-      var bindingParent = document.getBindingParent(this);
-      if (!bindingParent) {
-        throw new Error("Label created without control or binding parent");
-      }
-      if ("accessKey" in bindingParent) {
-        control = bindingParent; // For controls that make the <label> an anon child
-      }
-    }
-    if (control) {
-      control.labelElement = this;
-      var controlAccessKey = control.getAttribute("accesskey");
-      if (controlAccessKey) {
-        this.setAttribute("accesskey", controlAccessKey);
-      }
-    }
-
-    if (!gUnderlineAccesskey)
-      return;
-
-    var accessKey = this.accessKey;
-    // No need to remove existing formatting the first time.
-    if (firstTime && !accessKey)
-      return;
-
-    var afterLabel = this.accessKeyParens;
-    afterLabel.textContent = "";
-
-    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
-    if (oldAccessKey) { // Clear old accesskey
-      mergeElement(oldAccessKey);
-    }
-
-    var oldHiddenSpan =
-      this.getElementsByAttribute("class", "hiddenColon").item(0);
-    if (oldHiddenSpan) {
-      mergeElement(oldHiddenSpan);
-    }
-
-    var labelText = this.textContent;
-    if (!accessKey || !labelText || !control) {
-      return;
-    }
-    var accessKeyIndex = -1;
-    if (!gAlwaysAppendAccessKey) {
-      accessKeyIndex = labelText.indexOf(accessKey);
-      if (accessKeyIndex < 0) { // Try again in upper case
-        accessKeyIndex =
-          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
-      }
-    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
-      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
-    }
-
-    const HTML_NS = "http://www.w3.org/1999/xhtml";
-    var span = document.createElementNS(HTML_NS, "span");
-    span.className = "accesskey";
-
-    // Note that if you change the following code, see the comment of
-    // nsTextBoxFrame::UpdateAccessTitle.
-
-    // If accesskey is not in string, append in parentheses
-    if (accessKeyIndex < 0) {
-      // If end is colon, we should insert before colon.
-      // i.e., "label:" -> "label(X):"
-      var colonHidden = false;
-      if (/:$/.test(labelText)) {
-        labelText = labelText.slice(0, -1);
-        var hiddenSpan = document.createElementNS(HTML_NS, "span");
-        hiddenSpan.className = "hiddenColon";
-        hiddenSpan.style.display = "none";
-        // Hide the last colon by using span element.
-        // I.e., label<span style="display:none;">:</span>
-        wrapChar(this, hiddenSpan, labelText.length);
-        colonHidden = true;
-      }
-      // If end is space(U+20),
-      // we should not add space before parentheses.
-      var endIsSpace = false;
-      if (/ $/.test(labelText)) {
-        endIsSpace = true;
-      }
-      if (gInsertSeparator && !endIsSpace)
-        afterLabel.textContent = " (";
-      else
-        afterLabel.textContent = "(";
-      span.textContent = accessKey.toUpperCase();
-      afterLabel.appendChild(span);
-      if (!colonHidden)
-        afterLabel.appendChild(document.createTextNode(")"));
-      else
-        afterLabel.appendChild(document.createTextNode("):"));
-      return;
-    }
-    wrapChar(this, span, accessKeyIndex);
-  }
 }
 
 customElements.define("label", MozTextLabel);
 
 }
