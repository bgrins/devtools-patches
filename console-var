# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5d9a9f5ca4d4a9d29e46873ab0a84fea3013a9f4
Bug 1025778 - Save value as global variable in console;r=jlongster

diff --git a/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd b/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
@@ -97,8 +97,10 @@
 <!ENTITY copyURLCmd.label     "Copy Link Location">
 <!ENTITY copyURLCmd.accesskey "a">
 
 <!ENTITY closeCmd.key         "W">
 <!ENTITY findCmd.key          "F">
 <!ENTITY clearOutputCtrl.key  "L">
 <!ENTITY openInVarViewCmd.label "Open in Variables View">
 <!ENTITY openInVarViewCmd.accesskey "V">
+<!ENTITY storeAsGlobalVar.label "Store as global variable">
+<!ENTITY storeAsGlobalVar.accesskey "S">
diff --git a/devtools/client/inspector/test/browser_inspector_menu-04-use-in-console.js b/devtools/client/inspector/test/browser_inspector_menu-04-use-in-console.js
--- a/devtools/client/inspector/test/browser_inspector_menu-04-use-in-console.js
+++ b/devtools/client/inspector/test/browser_inspector_menu-04-use-in-console.js
@@ -23,25 +23,25 @@ add_task(function* () {
     yield selectNode("#console-var", inspector);
     dispatchCommandEvent(useInConsoleNode);
     yield inspector.once("console-var-ready");
 
     let hud = toolbox.getPanel("webconsole").hud;
     let jsterm = hud.jsterm;
 
     let jstermInput = jsterm.hud.document.querySelector(".jsterm-input-node");
-    ok(jstermInput.value === "temp0", "first console variable is named temp0");
+    is(jstermInput.value, "temp0", "first console variable is named temp0");
 
     let result = yield jsterm.execute();
     isnot(result.textContent.indexOf('<p id="console-var">'), -1, "variable temp0 references correct node");
 
     yield selectNode("#console-var-multi", inspector);
     dispatchCommandEvent(useInConsoleNode);
     yield inspector.once("console-var-ready");
 
-    ok(jstermInput.value === "temp1", "second console variable is named temp1");
+    is(jstermInput.value, "temp1", "second console variable is named temp1");
 
     result = yield jsterm.execute();
     isnot(result.textContent.indexOf('<p id="console-var-multi">'), -1, "variable temp1 references correct node");
 
     jsterm.clearHistory();
   }
 });
diff --git a/devtools/client/webconsole/console-output.js b/devtools/client/webconsole/console-output.js
--- a/devtools/client/webconsole/console-output.js
+++ b/devtools/client/webconsole/console-output.js
@@ -2529,40 +2529,70 @@ Widgets.JSObject.prototype = Heritage.ex
   {
     this.output.openVariablesView({
       label: VariablesView.getString(this.objectActor, { concise: true }),
       objectActor: this.objectActor,
       autofocus: true,
     });
   },
 
+  storeObjectInWindow: function()
+  {
+    let evalString = `{ let i = 0;
+      while (this.hasOwnProperty("temp" + i) && i < 1000) {
+        i++;
+      }
+      this["temp" + i] = _self;
+      "temp" + i;
+    }`;
+    let options = {
+      selectedObjectActor: this.objectActor.actor,
+    };
+
+    this.output.owner.jsterm.requestEvaluation(evalString, options).then((res) => {
+      this.output.owner.jsterm.focus();
+      this.output.owner.jsterm.setInputValue(res.result);
+    });
+  },
+
   /**
    * The click event handler for objects shown inline.
    * @private
    */
   _onClick: function()
   {
     this.openObjectInVariablesView();
   },
 
   _onContextMenu: function(ev) {
     // TODO offer a nice API for the context menu.
     // Probably worth to take a look at Firebug's way
     // https://github.com/firebug/firebug/blob/master/extension/content/firebug/chrome/menu.js
     let doc = ev.target.ownerDocument;
     let cmPopup = doc.getElementById("output-contextmenu");
+
     let openInVarViewCmd = doc.getElementById("menu_openInVarView");
     let openVarView = this.openObjectInVariablesView.bind(this);
     openInVarViewCmd.addEventListener("command", openVarView);
     openInVarViewCmd.removeAttribute("disabled");
     cmPopup.addEventListener("popuphiding", function onPopupHiding() {
       cmPopup.removeEventListener("popuphiding", onPopupHiding);
       openInVarViewCmd.removeEventListener("command", openVarView);
       openInVarViewCmd.setAttribute("disabled", "true");
     });
+
+    let storeObjectInWindow = this.storeObjectInWindow.bind(this);
+    let storeInGlobalCmd = doc.getElementById("menu_storeAsGlobal");
+    storeInGlobalCmd.addEventListener("command", storeObjectInWindow);
+    storeInGlobalCmd.removeAttribute("disabled");
+    cmPopup.addEventListener("popuphiding", function onPopupHiding() {
+      cmPopup.removeEventListener("popuphiding", onPopupHiding);
+      storeInGlobalCmd.removeEventListener("command", storeObjectInWindow);
+      storeInGlobalCmd.setAttribute("disabled", "true");
+    });
   },
 
   /**
    * Add a string to the message.
    *
    * @private
    * @param string str
    *        String to add.
diff --git a/devtools/client/webconsole/panel.js b/devtools/client/webconsole/panel.js
--- a/devtools/client/webconsole/panel.js
+++ b/devtools/client/webconsole/panel.js
@@ -27,22 +27,17 @@ WebConsolePanel.prototype = {
 
   /**
    * Called by the WebConsole's onkey command handler.
    * If the WebConsole is opened, check if the JSTerm's input line has focus.
    * If not, focus it.
    */
   focusInput: function WCP_focusInput()
   {
-    let inputNode = this.hud.jsterm.inputNode;
-
-    if (!inputNode.getAttribute("focused"))
-    {
-      inputNode.focus();
-    }
+    this.hud.jsterm.focus();
   },
 
   /**
    * Open is effectively an asynchronous constructor.
    *
    * @return object
    *         A promise that is resolved when the Web Console completes opening.
    */
diff --git a/devtools/client/webconsole/test/browser.ini b/devtools/client/webconsole/test/browser.ini
--- a/devtools/client/webconsole/test/browser.ini
+++ b/devtools/client/webconsole/test/browser.ini
@@ -381,8 +381,9 @@ skip-if = e10s # Bug 1042253 - webconsol
 [browser_webconsole_exception_stackframe.js]
 [browser_webconsole_column_numbers.js]
 [browser_console_open_or_focus.js]
 [browser_webconsole_bug_922212_console_dirxml.js]
 [browser_webconsole_shows_reqs_in_netmonitor.js]
 [browser_netmonitor_shows_reqs_in_webconsole.js]
 [browser_webconsole_bug_1050691_click_function_to_source.js]
 [browser_webconsole_context_menu_open_in_var_view.js]
+[browser_webconsole_context_menu_store_as_global.js]
diff --git a/devtools/client/webconsole/test/browser_webconsole_context_menu_open_in_var_view.js b/devtools/client/webconsole/test/browser_webconsole_context_menu_open_in_var_view.js
--- a/devtools/client/webconsole/test/browser_webconsole_context_menu_open_in_var_view.js
+++ b/devtools/client/webconsole/test/browser_webconsole_context_menu_open_in_var_view.js
@@ -8,17 +8,17 @@
 
 "use strict";
 
 const TEST_URI = `data:text/html,<script>
   console.log("foo");
   console.log("foo", window);
 </script>`;
 
-var test = asyncTest(function*() {
+add_task(function*() {
   yield loadTab(TEST_URI);
   let hud = yield openConsole();
 
   let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
diff --git a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
@@ -0,0 +1,66 @@
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Tests the "Store as global variable" context menu item feature.
+// It should be work, and be enabled only for objects
+
+"use strict";
+
+const TEST_URI = `data:text/html,<script>
+  window.bar = { baz: 1 };
+  console.log("foo");
+  console.log("foo", window.bar);
+</script>`;
+
+add_task(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  let [result] = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+      count: 2,
+      text: /foo/
+    }],
+  });
+
+  let [msgWithText, msgWithObj] = [...result.matched];
+  ok(msgWithText && msgWithObj, "Two messages should have appeared");
+
+  let contextMenu = hud.iframeWindow.document
+                                    .getElementById("output-contextmenu");
+  let storeAsGlobalItem = contextMenu.querySelector("#menu_storeAsGlobal");
+  let obj = msgWithObj.querySelector(".cm-variable");
+  let text = msgWithText.querySelector(".console-string");
+  let onceInputSet = hud.jsterm.once("set-input-value");
+
+  info("Waiting for context menu on the object");
+  yield waitForContextMenu(contextMenu, obj, () => {
+    ok(storeAsGlobalItem.disabled === false, "The \"Store as global\" " +
+      "context menu item should be available for objects");
+    storeAsGlobalItem.click();
+  }, () => {
+    ok(storeAsGlobalItem.disabled === true, "The \"Store as global\" " +
+      "context menu item should be disabled on popup hiding");
+  });
+
+  info("Waiting for context menu on the text node");
+  yield waitForContextMenu(contextMenu, text, () => {
+    ok(storeAsGlobalItem.disabled === true, "The \"Store as global\" " +
+      "context menu item should be disabled for texts");
+  });
+
+  info("Waiting for input to be set");
+  yield onceInputSet;
+
+  is(hud.jsterm.inputNode.value, "temp0", "Input was set");
+  let executedResult = yield hud.jsterm.execute();
+
+  ok(executedResult.textContent.includes("{ baz: 1 }"),
+     "Correct variable assigned into console");
+
+});
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -3223,16 +3223,23 @@ JSTerm.prototype = {
       this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
       this.inputNode.addEventListener("focus", this._focusEventHandler, false);
     }
 
     this.hud.window.addEventListener("blur", this._blurEventHandler, false);
     this.lastInputValue && this.setInputValue(this.lastInputValue);
   },
 
+  focus: function() {
+    let inputNode = this.inputNode;
+    if (!inputNode.getAttribute("focused")) {
+      inputNode.focus();
+    }
+  },
+
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
    * @param object [aAfterMessage]
    *        Optional message after which the evaluation result will be
    *        inserted.
    * @param function [aCallback]
@@ -3437,16 +3444,17 @@ JSTerm.prototype = {
     if ("frame" in aOptions) {
       frameActor = this.getFrameActor(aOptions.frame);
     }
 
     let evalOptions = {
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: frameActor,
       selectedNodeActor: aOptions.selectedNodeActor,
+      selectedObjectActor: aOptions.selectedObjectActor,
     };
 
     this.webConsoleClient.evaluateJSAsync(aString, onResult, evalOptions);
     return deferred.promise;
   },
 
   /**
    * Retrieve the FrameActor ID given a frame depth.
@@ -3938,16 +3946,17 @@ JSTerm.prototype = {
    */
   setInputValue: function JST_setInputValue(aNewValue)
   {
     this.inputNode.value = aNewValue;
     this.lastInputValue = aNewValue;
     this.completeNode.value = "";
     this.resizeInput();
     this._inputChanged = true;
+    this.emit("set-input-value");
   },
 
   /**
    * The inputNode "input" and "keyup" event handler.
    * @private
    */
   _inputEventHandler: function JST__inputEventHandler()
   {
diff --git a/devtools/client/webconsole/webconsole.xul b/devtools/client/webconsole/webconsole.xul
--- a/devtools/client/webconsole/webconsole.xul
+++ b/devtools/client/webconsole/webconsole.xul
@@ -73,16 +73,18 @@ function goUpdateConsoleCommands() {
       <menuitem id="menu_openURL" label="&openURL.label;"
                 accesskey="&openURL.accesskey;" command="consoleCmd_openURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_copyURL" label="&copyURLCmd.label;"
                 accesskey="&copyURLCmd.accesskey;" command="consoleCmd_copyURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_openInVarView" label="&openInVarViewCmd.label;"
         accesskey="&openInVarViewCmd.accesskey;" disabled="true"/>
+      <menuitem id="menu_storeAsGlobal" label="&storeAsGlobalVar.label;"
+        accesskey="&storeAsGlobalVar.accesskey;"/>
       <menuitem id="cMenu_copy"/>
       <menuitem id="cMenu_selectAll"/>
     </menupopup>
   </popupset>
 
   <tooltip id="aHTMLTooltip" page="true"/>
 
   <box class="hud-outer-wrapper devtools-responsive-container theme-body" flex="1">
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -827,16 +827,17 @@ WebConsoleActor.prototype =
     let input = aRequest.text;
     let timestamp = Date.now();
 
     let evalOptions = {
       bindObjectActor: aRequest.bindObjectActor,
       frameActor: aRequest.frameActor,
       url: aRequest.url,
       selectedNodeActor: aRequest.selectedNodeActor,
+      selectedObjectActor: aRequest.selectedObjectActor,
     };
 
     let evalInfo = this.evalWithDebugger(input, evalOptions);
     let evalResult = evalInfo.result;
     let helperResult = evalInfo.helperResult;
 
     let result, errorMessage, errorGrip = null;
     if (evalResult) {
@@ -1090,16 +1091,18 @@ WebConsoleActor.prototype =
    * @param string aString
    *        String to evaluate.
    * @param object [aOptions]
    *        Options for evaluation:
    *        - bindObjectActor: the ObjectActor ID to use for evaluation.
    *          |evalWithBindings()| will be called with one additional binding:
    *          |_self| which will point to the Debugger.Object of the given
    *          ObjectActor.
+   *        - selectedObjectActor: Like bindObjectActor, but executes with the
+   *          top level window as the global.
    *        - frameActor: the FrameActor ID to use for evaluation. The given
    *        debugger frame is used for evaluation, instead of the global window.
    *        - selectedNodeActor: the NodeActor ID of the currently selected node
    *        in the Inspector (or null, if there is no selection). This is used
    *        for helper functions that make reference to the currently selected
    *        node, like $0.
    * @return object
    *         An object that holds the following properties:
@@ -1146,27 +1149,32 @@ WebConsoleActor.prototype =
     // as ordinary objects, not as references to be followed, so mixing
     // debuggers causes strange behaviors.)
     let dbg = frame ? frameActor.threadActor.dbg : this.dbg;
     let dbgWindow = dbg.makeGlobalObjectReference(this.evalWindow);
 
     // If we have an object to bind to |_self|, create a Debugger.Object
     // referring to that object, belonging to dbg.
     let bindSelf = null;
-    if (aOptions.bindObjectActor) {
-      let objActor = this.getActorByID(aOptions.bindObjectActor);
+    if (aOptions.bindObjectActor || aOptions.selectedObjectActor) {
+      let objActor = this.getActorByID(aOptions.bindObjectActor ||
+                                       aOptions.selectedObjectActor);
       if (objActor) {
         let jsObj = objActor.obj.unsafeDereference();
         // If we use the makeDebuggeeValue method of jsObj's own global, then
         // we'll get a D.O that sees jsObj as viewed from its own compartment -
         // that is, without wrappers. The evalWithBindings call will then wrap
         // jsObj appropriately for the evaluation compartment.
         let global = Cu.getGlobalForObject(jsObj);
-        dbgWindow = dbg.makeGlobalObjectReference(global);
+        let _dbgWindow = dbg.makeGlobalObjectReference(global);
         bindSelf = dbgWindow.makeDebuggeeValue(jsObj);
+
+        if (aOptions.bindObjectActor) {
+          dbgWindow = _dbgWindow;
+        }
       }
     }
 
     // Get the Web Console commands for the given debugger window.
     let helpers = this._getWebConsoleCommands(dbgWindow);
     let bindings = helpers.sandbox;
     if (bindSelf) {
       bindings._self = bindSelf;
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -250,16 +250,17 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "evaluateJS",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
+      selectedObjectActor: aOptions.selectedObjectActor,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Evaluate a JavaScript expression asynchronously.
    * See evaluateJS for parameter and response information.
    */
@@ -274,16 +275,17 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "evaluateJSAsync",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
+      selectedObjectActor: aOptions.selectedObjectActor,
     };
 
     this._client.request(packet, response => {
       // Null check this in case the client has been detached while waiting
       // for a response.
       if (this.pendingEvaluationResults) {
         this.pendingEvaluationResults.set(response.resultID, aOnResponse);
       }
diff --git a/devtools/shared/webconsole/test/test_jsterm.html b/devtools/shared/webconsole/test/test_jsterm.html
--- a/devtools/shared/webconsole/test/test_jsterm.html
+++ b/devtools/shared/webconsole/test/test_jsterm.html
@@ -6,32 +6,36 @@
   <script type="text/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
   <script type="text/javascript;version=1.8" src="common.js"></script>
   <!-- Any copyright is dedicated to the Public Domain.
      - http://creativecommons.org/publicdomain/zero/1.0/ -->
 </head>
 <body>
 <p>Test for JavaScript terminal functionality</p>
 
+<iframe id="content-iframe" src="http://example.com/chrome/devtools/shared/webconsole/test/sandboxed_iframe.html"></iframe>
+
 <script class="testbody" type="text/javascript;version=1.8">
 SimpleTest.waitForExplicitFinish();
 
 let gState;
 
 let {MAX_AUTOCOMPLETE_ATTEMPTS,MAX_AUTOCOMPLETIONS} = require("devtools/shared/webconsole/utils");
 
 // This test runs all of its assertions twice - once with
 // evaluateJS and once with evaluateJSAsync.
 let evaluatingSync = true;
-function evaluateJS(input, callback) {
-  if (evaluatingSync) {
-    gState.client.evaluateJS(input, callback);
-  } else {
-    gState.client.evaluateJSAsync(input, callback);
-  }
+function evaluateJS(input, options = {}) {
+  return new Promise((resolve, reject) => {
+    if (evaluatingSync) {
+      gState.client.evaluateJS(input, resolve, options);
+    } else {
+      gState.client.evaluateJSAsync(input, resolve, options);
+    }
+  });
 }
 
 function startTest()
 {
   removeEventListener("load", startTest);
 
   attachConsole(["PageError"], onAttach, true);
 }
@@ -58,250 +62,264 @@ function onAttach(aState, aResponse)
     top.largeObject2['a' + i] = i;
   }
 
   gState = aState;
 
   let tests = [doAutocomplete1, doAutocomplete2, doAutocomplete3,
                doAutocomplete4, doAutocompleteLarge1, doAutocompleteLarge2,
                doSimpleEval, doWindowEval, doEvalWithException,
-               doEvalWithHelper, doEvalString, doEvalLongString];
+               doEvalWithHelper, doEvalString, doEvalLongString,
+               doEvalWithBinding, doEvalWithBindingFrame].map(t => {
+                 return Task.async(t);
+               });
+
   runTests(tests, testEnd);
 }
 
-function doAutocomplete1()
-{
+function doAutocomplete1() {
   info("test autocomplete for 'window.foo'");
   gState.client.autocomplete("window.foo", 10, onAutocomplete1);
 }
 
-function onAutocomplete1(aResponse)
-{
+function onAutocomplete1(aResponse) {
   let matches = aResponse.matches;
 
   is(aResponse.matchProp, "foo", "matchProp");
   is(matches.length, 1, "matches.length");
   is(matches[0], "foobarObject", "matches[0]");
 
   nextTest();
 }
 
-function doAutocomplete2()
-{
+function doAutocomplete2() {
   info("test autocomplete for 'window.foobarObject.'");
   gState.client.autocomplete("window.foobarObject.", 20, onAutocomplete2);
 }
 
-function onAutocomplete2(aResponse)
-{
+function onAutocomplete2(aResponse) {
   let matches = aResponse.matches;
 
   ok(!aResponse.matchProp, "matchProp");
   is(matches.length, 7, "matches.length");
   checkObject(matches,
     ["foo", "foobar", "foobaz", "omg", "omgfoo", "omgstr", "strfoo"]);
 
   nextTest();
 }
 
-function doAutocomplete3()
-{
+function doAutocomplete3() {
   // Check that completion suggestions are offered inside the string.
   info("test autocomplete for 'dump(window.foobarObject.)'");
   gState.client.autocomplete("dump(window.foobarObject.)", 25, onAutocomplete3);
 }
 
-function onAutocomplete3(aResponse)
-{
+function onAutocomplete3(aResponse) {
   let matches = aResponse.matches;
 
   ok(!aResponse.matchProp, "matchProp");
   is(matches.length, 7, "matches.length");
   checkObject(matches,
     ["foo", "foobar", "foobaz", "omg", "omgfoo", "omgstr", "strfoo"]);
 
   nextTest();
 }
 
-function doAutocomplete4()
-{
+function doAutocomplete4() {
   // Check that completion requests can have no suggestions.
   info("test autocomplete for 'dump(window.foobarObject.)'");
   gState.client.autocomplete("dump(window.foobarObject.)", 26, onAutocomplete4);
 }
 
-function onAutocomplete4(aResponse)
-{
+function onAutocomplete4(aResponse) {
   ok(!aResponse.matchProp, "matchProp");
   is(aResponse.matches.length, 0, "matches.length");
 
   nextTest();
 }
 
-function doAutocompleteLarge1()
-{
+function doAutocompleteLarge1() {
   // Check that completion requests with too large objects will
   // have no suggestions.
   info("test autocomplete for 'window.largeObject1.'");
   gState.client.autocomplete("window.largeObject1.", 20, onAutocompleteLarge1);
 }
 
-function onAutocompleteLarge1(aResponse)
-{
+function onAutocompleteLarge1(aResponse) {
   ok(!aResponse.matchProp, "matchProp");
   info (aResponse.matches.join("|"));
   is(aResponse.matches.length, 0, "Bailed out with too many properties");
 
   nextTest();
 }
 
-function doAutocompleteLarge2()
-{
+function doAutocompleteLarge2() {
   // Check that completion requests with pretty large objects will
   // have MAX_AUTOCOMPLETIONS suggestions
   info("test autocomplete for 'window.largeObject2.'");
   gState.client.autocomplete("window.largeObject2.", 20, onAutocompleteLarge2);
 }
 
-function onAutocompleteLarge2(aResponse)
-{
+function onAutocompleteLarge2(aResponse) {
   ok(!aResponse.matchProp, "matchProp");
   is(aResponse.matches.length, MAX_AUTOCOMPLETIONS, "matches.length is MAX_AUTOCOMPLETIONS");
 
   nextTest();
 }
 
-function doSimpleEval()
-{
+function* doSimpleEval() {
   info("test eval '2+2'");
-  evaluateJS("2+2", onSimpleEval);
-}
-
-function onSimpleEval(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("2+2");
+  checkObject(response, {
     from: gState.actor,
     input: "2+2",
     result: 4,
   });
 
-  ok(!aResponse.exception, "no eval exception");
-  ok(!aResponse.helperResult, "no helper result");
+  ok(!response.exception, "no eval exception");
+  ok(!response.helperResult, "no helper result");
 
   nextTest();
 }
 
-function doWindowEval()
-{
+function* doWindowEval() {
   info("test eval 'document'");
-  evaluateJS("document", onWindowEval);
-}
-
-function onWindowEval(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("document");
+  checkObject(response, {
     from: gState.actor,
     input: "document",
     result: {
       type: "object",
       class: "XULDocument",
       actor: /[a-z]/,
     },
   });
 
-  ok(!aResponse.exception, "no eval exception");
-  ok(!aResponse.helperResult, "no helper result");
+  ok(!response.exception, "no eval exception");
+  ok(!response.helperResult, "no helper result");
 
   nextTest();
 }
 
-function doEvalWithException()
-{
+function* doEvalWithException() {
   info("test eval with exception");
-  evaluateJS("window.doTheImpossible()", onEvalWithException);
-}
-
-function onEvalWithException(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("window.doTheImpossible()");
+  checkObject(response, {
     from: gState.actor,
     input: "window.doTheImpossible()",
     result: {
       type: "undefined",
     },
     exceptionMessage: /doTheImpossible/,
   });
 
-  ok(aResponse.exception, "js eval exception");
-  ok(!aResponse.helperResult, "no helper result");
+  ok(response.exception, "js eval exception");
+  ok(!response.helperResult, "no helper result");
 
   nextTest();
 }
 
-function doEvalWithHelper()
-{
+function* doEvalWithHelper() {
   info("test eval with helper");
-  evaluateJS("clear()", onEvalWithHelper);
-}
-
-function onEvalWithHelper(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("clear()");
+  checkObject(response, {
     from: gState.actor,
     input: "clear()",
     result: {
       type: "undefined",
     },
     helperResult: { type: "clearOutput" },
   });
 
-  ok(!aResponse.exception, "no eval exception");
+  ok(!response.exception, "no eval exception");
 
   nextTest();
 }
 
-function doEvalString()
-{
-  evaluateJS("window.foobarObject.strfoo", onEvalString);
-}
-
-function onEvalString(aResponse)
-{
-  checkObject(aResponse, {
+function* doEvalString() {
+  let response = yield evaluateJS("window.foobarObject.strfoo");
+  checkObject(response, {
     from: gState.actor,
     input: "window.foobarObject.strfoo",
     result: "foobarz",
   });
 
   nextTest();
 }
 
-function doEvalLongString()
-{
-  evaluateJS("window.foobarObject.omgstr", onEvalLongString);
-}
-
-function onEvalLongString(aResponse)
-{
+function* doEvalLongString() {
+  let response = yield evaluateJS("window.foobarObject.omgstr");
   let str = top.foobarObject.omgstr;
   let initial = str.substring(0, DebuggerServer.LONG_STRING_INITIAL_LENGTH);
 
-  checkObject(aResponse, {
+  checkObject(response, {
     from: gState.actor,
     input: "window.foobarObject.omgstr",
     result: {
       type: "longString",
       initial: initial,
       length: str.length,
     },
   });
 
   nextTest();
 }
 
+function* doEvalWithBinding() {
+  let response = yield evaluateJS("document;");
+  let documentActor = response.result.actor;
+
+  info("running a command with _self as document using bindObjectActor");
+  let bindObjectSame = yield evaluateJS("_self === document", {
+    bindObjectActor: documentActor
+  });
+  checkObject(bindObjectSame, {
+    result: true
+  });
+
+  info("running a command with _self as document using selectedObjectActor");
+  let selectedObjectSame = yield evaluateJS("_self === document", {
+    selectedObjectActor: documentActor
+  });
+  checkObject(selectedObjectSame, {
+    result: true
+  });
+
+  nextTest();
+}
+
+function* doEvalWithBindingFrame() {
+  let frameWin = top.document.querySelector("iframe").contentWindow;
+  frameWin.fooFrame = { bar: 1 };
+
+  let response = yield evaluateJS(
+    "document.querySelector('iframe').contentWindow.fooFrame"
+  );
+  let iframeObjectActor = response.result.actor;
+  ok(iframeObjectActor, "There is an actor associated with the response");
+
+  let bindObjectGlobal = yield evaluateJS("this.temp0 = _self;", {
+    bindObjectActor: iframeObjectActor
+  });
+  ok(!top.temp0,
+    "Global doesn't match the top global with bindObjectActor");
+  ok(frameWin.temp0 && frameWin.temp0.bar === 1,
+    "Global matches the object's global with bindObjectActor");
+
+  let selectedObjectGlobal = yield evaluateJS("this.temp1 = _self;", {
+    selectedObjectActor: iframeObjectActor
+  });
+  ok(top.temp1 && top.temp1.bar === 1,
+    "Global matches the top global with bindObjectActor");
+  ok(!frameWin.temp1,
+    "Global doesn't match the object's global with bindObjectActor");
+
+  nextTest()
+}
+
 function testEnd()
 {
   // If this is the first run, reload the page and do it again.
   // Otherwise, end the test.
   closeDebugger(gState, function() {
     gState = null;
     if (evaluatingSync) {
       evaluatingSync = false;
