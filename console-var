# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  46457432906da83d11a15ce0beed90548bff0111
Bug 1025778 - Save value as global variable in console

diff --git a/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd b/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
@@ -97,8 +97,10 @@
 <!ENTITY copyURLCmd.label     "Copy Link Location">
 <!ENTITY copyURLCmd.accesskey "a">
 
 <!ENTITY closeCmd.key         "W">
 <!ENTITY findCmd.key          "F">
 <!ENTITY clearOutputCtrl.key  "L">
 <!ENTITY openInVarViewCmd.label "Open in Variables View">
 <!ENTITY openInVarViewCmd.accesskey "V">
+<!ENTITY storeAsGlobalVar.label "Store as global variable">
+<!ENTITY storeAsGlobalVar.accesskey "S">
diff --git a/devtools/client/webconsole/console-output.js b/devtools/client/webconsole/console-output.js
--- a/devtools/client/webconsole/console-output.js
+++ b/devtools/client/webconsole/console-output.js
@@ -2529,40 +2529,70 @@ Widgets.JSObject.prototype = Heritage.ex
   {
     this.output.openVariablesView({
       label: VariablesView.getString(this.objectActor, { concise: true }),
       objectActor: this.objectActor,
       autofocus: true,
     });
   },
 
+  storeObjectInWindow: function()
+  {
+    let evalString = `{ let i = 0;
+      while (this.hasOwnProperty("temp" + i) && i < 1000) {
+        i++;
+      }
+      this["temp" + i] = _self;
+      "temp" + i;
+    }`;
+    let options = {
+      selectedObjectActor: this.objectActor.actor,
+    };
+
+    this.output.owner.jsterm.requestEvaluation(evalString, options).then((res) => {
+      this.output.owner.jsterm.focus();
+      this.output.owner.jsterm.setInputValue(res.result);
+    });
+  },
+
   /**
    * The click event handler for objects shown inline.
    * @private
    */
   _onClick: function()
   {
     this.openObjectInVariablesView();
   },
 
   _onContextMenu: function(ev) {
     // TODO offer a nice API for the context menu.
     // Probably worth to take a look at Firebug's way
     // https://github.com/firebug/firebug/blob/master/extension/content/firebug/chrome/menu.js
     let doc = ev.target.ownerDocument;
     let cmPopup = doc.getElementById("output-contextmenu");
+
     let openInVarViewCmd = doc.getElementById("menu_openInVarView");
     let openVarView = this.openObjectInVariablesView.bind(this);
     openInVarViewCmd.addEventListener("command", openVarView);
     openInVarViewCmd.removeAttribute("disabled");
     cmPopup.addEventListener("popuphiding", function onPopupHiding() {
       cmPopup.removeEventListener("popuphiding", onPopupHiding);
       openInVarViewCmd.removeEventListener("command", openVarView);
       openInVarViewCmd.setAttribute("disabled", "true");
     });
+
+    let storeObjectInWindow = this.storeObjectInWindow.bind(this);
+    let storeInGlobalCmd = doc.getElementById("menu_storeAsGlobal");
+    storeInGlobalCmd.addEventListener("command", storeObjectInWindow);
+    storeInGlobalCmd.removeAttribute("disabled");
+    cmPopup.addEventListener("popuphiding", function onPopupHiding() {
+      cmPopup.removeEventListener("popuphiding", onPopupHiding);
+      storeInGlobalCmd.removeEventListener("command", storeObjectInWindow);
+      storeInGlobalCmd.setAttribute("disabled", "true");
+    });
   },
 
   /**
    * Add a string to the message.
    *
    * @private
    * @param string str
    *        String to add.
diff --git a/devtools/client/webconsole/panel.js b/devtools/client/webconsole/panel.js
--- a/devtools/client/webconsole/panel.js
+++ b/devtools/client/webconsole/panel.js
@@ -27,22 +27,17 @@ WebConsolePanel.prototype = {
 
   /**
    * Called by the WebConsole's onkey command handler.
    * If the WebConsole is opened, check if the JSTerm's input line has focus.
    * If not, focus it.
    */
   focusInput: function WCP_focusInput()
   {
-    let inputNode = this.hud.jsterm.inputNode;
-
-    if (!inputNode.getAttribute("focused"))
-    {
-      inputNode.focus();
-    }
+    this.hud.jsterm.focus();
   },
 
   /**
    * Open is effectively an asynchronous constructor.
    *
    * @return object
    *         A promise that is resolved when the Web Console completes opening.
    */
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -3223,16 +3223,23 @@ JSTerm.prototype = {
       this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
       this.inputNode.addEventListener("focus", this._focusEventHandler, false);
     }
 
     this.hud.window.addEventListener("blur", this._blurEventHandler, false);
     this.lastInputValue && this.setInputValue(this.lastInputValue);
   },
 
+  focus: function() {
+    let inputNode = this.inputNode;
+    if (!inputNode.getAttribute("focused")) {
+      inputNode.focus();
+    }
+  },
+
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
    * @param object [aAfterMessage]
    *        Optional message after which the evaluation result will be
    *        inserted.
    * @param function [aCallback]
@@ -3437,16 +3444,17 @@ JSTerm.prototype = {
     if ("frame" in aOptions) {
       frameActor = this.getFrameActor(aOptions.frame);
     }
 
     let evalOptions = {
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: frameActor,
       selectedNodeActor: aOptions.selectedNodeActor,
+      selectedObjectActor: aOptions.selectedObjectActor,
     };
 
     this.webConsoleClient.evaluateJSAsync(aString, onResult, evalOptions);
     return deferred.promise;
   },
 
   /**
    * Retrieve the FrameActor ID given a frame depth.
diff --git a/devtools/client/webconsole/webconsole.xul b/devtools/client/webconsole/webconsole.xul
--- a/devtools/client/webconsole/webconsole.xul
+++ b/devtools/client/webconsole/webconsole.xul
@@ -73,16 +73,18 @@ function goUpdateConsoleCommands() {
       <menuitem id="menu_openURL" label="&openURL.label;"
                 accesskey="&openURL.accesskey;" command="consoleCmd_openURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_copyURL" label="&copyURLCmd.label;"
                 accesskey="&copyURLCmd.accesskey;" command="consoleCmd_copyURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_openInVarView" label="&openInVarViewCmd.label;"
         accesskey="&openInVarViewCmd.accesskey;" disabled="true"/>
+      <menuitem id="menu_storeAsGlobal" label="&storeAsGlobalVar.label;"
+        accesskey="&storeAsGlobalVar.accesskey;"/>
       <menuitem id="cMenu_copy"/>
       <menuitem id="cMenu_selectAll"/>
     </menupopup>
   </popupset>
 
   <tooltip id="aHTMLTooltip" page="true"/>
 
   <box class="hud-outer-wrapper devtools-responsive-container theme-body" flex="1">
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -827,16 +827,17 @@ WebConsoleActor.prototype =
     let input = aRequest.text;
     let timestamp = Date.now();
 
     let evalOptions = {
       bindObjectActor: aRequest.bindObjectActor,
       frameActor: aRequest.frameActor,
       url: aRequest.url,
       selectedNodeActor: aRequest.selectedNodeActor,
+      selectedObjectActor: aRequest.selectedObjectActor,
     };
 
     let evalInfo = this.evalWithDebugger(input, evalOptions);
     let evalResult = evalInfo.result;
     let helperResult = evalInfo.helperResult;
 
     let result, errorMessage, errorGrip = null;
     if (evalResult) {
@@ -1090,16 +1091,17 @@ WebConsoleActor.prototype =
    * @param string aString
    *        String to evaluate.
    * @param object [aOptions]
    *        Options for evaluation:
    *        - bindObjectActor: the ObjectActor ID to use for evaluation.
    *          |evalWithBindings()| will be called with one additional binding:
    *          |_self| which will point to the Debugger.Object of the given
    *          ObjectActor.
+   *        - selectedObjectActor: Like bindObjectActor, but XXX.
    *        - frameActor: the FrameActor ID to use for evaluation. The given
    *        debugger frame is used for evaluation, instead of the global window.
    *        - selectedNodeActor: the NodeActor ID of the currently selected node
    *        in the Inspector (or null, if there is no selection). This is used
    *        for helper functions that make reference to the currently selected
    *        node, like $0.
    * @return object
    *         An object that holds the following properties:
@@ -1146,27 +1148,32 @@ WebConsoleActor.prototype =
     // as ordinary objects, not as references to be followed, so mixing
     // debuggers causes strange behaviors.)
     let dbg = frame ? frameActor.threadActor.dbg : this.dbg;
     let dbgWindow = dbg.makeGlobalObjectReference(this.evalWindow);
 
     // If we have an object to bind to |_self|, create a Debugger.Object
     // referring to that object, belonging to dbg.
     let bindSelf = null;
-    if (aOptions.bindObjectActor) {
-      let objActor = this.getActorByID(aOptions.bindObjectActor);
+    if (aOptions.bindObjectActor || aOptions.selectedObjectActor) {
+      let objActor = this.getActorByID(aOptions.bindObjectActor ||
+                                       aOptions.selectedObjectActor);
       if (objActor) {
         let jsObj = objActor.obj.unsafeDereference();
         // If we use the makeDebuggeeValue method of jsObj's own global, then
         // we'll get a D.O that sees jsObj as viewed from its own compartment -
         // that is, without wrappers. The evalWithBindings call will then wrap
         // jsObj appropriately for the evaluation compartment.
         let global = Cu.getGlobalForObject(jsObj);
-        dbgWindow = dbg.makeGlobalObjectReference(global);
+        let _dbgWindow = dbg.makeGlobalObjectReference(global);
         bindSelf = dbgWindow.makeDebuggeeValue(jsObj);
+
+        if (aOptions.bindObjectActor) {
+          dbgWindow = _dbgWindow;
+        }
       }
     }
 
     // Get the Web Console commands for the given debugger window.
     let helpers = this._getWebConsoleCommands(dbgWindow);
     let bindings = helpers.sandbox;
     if (bindSelf) {
       bindings._self = bindSelf;
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -250,16 +250,17 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "evaluateJS",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
+      selectedObjectActor: aOptions.selectedObjectActor,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Evaluate a JavaScript expression asynchronously.
    * See evaluateJS for parameter and response information.
    */
@@ -274,16 +275,17 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "evaluateJSAsync",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
+      selectedObjectActor: aOptions.selectedObjectActor,
     };
 
     this._client.request(packet, response => {
       // Null check this in case the client has been detached while waiting
       // for a response.
       if (this.pendingEvaluationResults) {
         this.pendingEvaluationResults.set(response.resultID, aOnResponse);
       }
diff --git a/devtools/shared/webconsole/test/test_jsterm.html b/devtools/shared/webconsole/test/test_jsterm.html
--- a/devtools/shared/webconsole/test/test_jsterm.html
+++ b/devtools/shared/webconsole/test/test_jsterm.html
@@ -16,22 +16,24 @@ SimpleTest.waitForExplicitFinish();
 
 let gState;
 
 let {MAX_AUTOCOMPLETE_ATTEMPTS,MAX_AUTOCOMPLETIONS} = require("devtools/shared/webconsole/utils");
 
 // This test runs all of its assertions twice - once with
 // evaluateJS and once with evaluateJSAsync.
 let evaluatingSync = true;
-function evaluateJS(input, callback) {
-  if (evaluatingSync) {
-    gState.client.evaluateJS(input, callback);
-  } else {
-    gState.client.evaluateJSAsync(input, callback);
-  }
+function evaluateJS(input, options = {}) {
+  return new Promise((resolve, reject) => {
+    if (evaluatingSync) {
+      gState.client.evaluateJS(input, resolve, options);
+    } else {
+      gState.client.evaluateJSAsync(input, resolve, options);
+    }
+  });
 }
 
 function startTest()
 {
   removeEventListener("load", startTest);
 
   attachConsole(["PageError"], onAttach, true);
 }
@@ -58,17 +60,21 @@ function onAttach(aState, aResponse)
     top.largeObject2['a' + i] = i;
   }
 
   gState = aState;
 
   let tests = [doAutocomplete1, doAutocomplete2, doAutocomplete3,
                doAutocomplete4, doAutocompleteLarge1, doAutocompleteLarge2,
                doSimpleEval, doWindowEval, doEvalWithException,
-               doEvalWithHelper, doEvalString, doEvalLongString];
+               doEvalWithHelper, doEvalString, doEvalLongString,
+               doEvalWithBinding].map(t => {
+                 return Task.async(t);
+               });
+
   runTests(tests, testEnd);
 }
 
 function doAutocomplete1()
 {
   info("test autocomplete for 'window.foo'");
   gState.client.autocomplete("window.foo", 10, onAutocomplete1);
 }
@@ -164,144 +170,142 @@ function doAutocompleteLarge2()
 function onAutocompleteLarge2(aResponse)
 {
   ok(!aResponse.matchProp, "matchProp");
   is(aResponse.matches.length, MAX_AUTOCOMPLETIONS, "matches.length is MAX_AUTOCOMPLETIONS");
 
   nextTest();
 }
 
-function doSimpleEval()
+function* doSimpleEval()
 {
   info("test eval '2+2'");
-  evaluateJS("2+2", onSimpleEval);
-}
-
-function onSimpleEval(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("2+2");
+  checkObject(response, {
     from: gState.actor,
     input: "2+2",
     result: 4,
   });
 
-  ok(!aResponse.exception, "no eval exception");
-  ok(!aResponse.helperResult, "no helper result");
+  ok(!response.exception, "no eval exception");
+  ok(!response.helperResult, "no helper result");
 
   nextTest();
 }
 
-function doWindowEval()
+function* doWindowEval()
 {
   info("test eval 'document'");
-  evaluateJS("document", onWindowEval);
-}
-
-function onWindowEval(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("document");
+  checkObject(response, {
     from: gState.actor,
     input: "document",
     result: {
       type: "object",
       class: "XULDocument",
       actor: /[a-z]/,
     },
   });
 
-  ok(!aResponse.exception, "no eval exception");
-  ok(!aResponse.helperResult, "no helper result");
+  ok(!response.exception, "no eval exception");
+  ok(!response.helperResult, "no helper result");
 
   nextTest();
 }
 
-function doEvalWithException()
+function* doEvalWithException()
 {
   info("test eval with exception");
-  evaluateJS("window.doTheImpossible()", onEvalWithException);
-}
-
-function onEvalWithException(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("window.doTheImpossible()");
+  checkObject(response, {
     from: gState.actor,
     input: "window.doTheImpossible()",
     result: {
       type: "undefined",
     },
     exceptionMessage: /doTheImpossible/,
   });
 
-  ok(aResponse.exception, "js eval exception");
-  ok(!aResponse.helperResult, "no helper result");
+  ok(response.exception, "js eval exception");
+  ok(!response.helperResult, "no helper result");
 
   nextTest();
 }
 
-function doEvalWithHelper()
+function* doEvalWithHelper()
 {
   info("test eval with helper");
-  evaluateJS("clear()", onEvalWithHelper);
-}
-
-function onEvalWithHelper(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("clear()");
+  checkObject(response, {
     from: gState.actor,
     input: "clear()",
     result: {
       type: "undefined",
     },
     helperResult: { type: "clearOutput" },
   });
 
-  ok(!aResponse.exception, "no eval exception");
+  ok(!response.exception, "no eval exception");
 
   nextTest();
 }
 
-function doEvalString()
+function* doEvalString()
 {
-  evaluateJS("window.foobarObject.strfoo", onEvalString);
-}
-
-function onEvalString(aResponse)
-{
-  checkObject(aResponse, {
+  let response = yield evaluateJS("window.foobarObject.strfoo");
+  checkObject(response, {
     from: gState.actor,
     input: "window.foobarObject.strfoo",
     result: "foobarz",
   });
 
   nextTest();
 }
 
 function doEvalLongString()
 {
-  evaluateJS("window.foobarObject.omgstr", onEvalLongString);
-}
-
-function onEvalLongString(aResponse)
-{
+  let response = yield evaluateJS("window.foobarObject.omgstr");
   let str = top.foobarObject.omgstr;
   let initial = str.substring(0, DebuggerServer.LONG_STRING_INITIAL_LENGTH);
 
-  checkObject(aResponse, {
+  checkObject(response, {
     from: gState.actor,
     input: "window.foobarObject.omgstr",
     result: {
       type: "longString",
       initial: initial,
       length: str.length,
     },
   });
 
   nextTest();
 }
 
+function* doEvalWithBinding()
+{
+  let response = yield evaluateJS("document;");
+
+  info("running a command with _self as document using bindObjectActor");
+  let currentLocation = yield evaluateJS("_self.defaultView.location.toString()", {
+    bindObjectActor: response.result.actor
+  });
+  checkObject(currentLocation, {
+    result: "chrome://mochikit/content/harness.xul"
+  });
+
+  let bindObjectSame = yield evaluateJS("_self === document", {
+    bindObjectActor: response.result.actor
+  });
+  checkObject(bindObjectSame, {
+    result: true
+  });
+
+  nextTest();
+}
+
 function testEnd()
 {
   // If this is the first run, reload the page and do it again.
   // Otherwise, end the test.
   closeDebugger(gState, function() {
     gState = null;
     if (evaluatingSync) {
       evaluatingSync = false;
