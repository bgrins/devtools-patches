# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  3dd2a0df8082edea325a30fdf999b15147ba4139
Bug 1139569 - Animation slowed down when element is expanded in markup view

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -773,25 +773,32 @@ MarkupView.prototype = {
   },
 
   /**
    * Given a list of mutations returned by the mutation observer, flash the
    * corresponding containers to attract attention.
    */
   _flashMutatedNodes: function(aMutations) {
     let addedOrEditedContainers = new Set();
+    let addedOrEditedAttributes = new Map();
     let removedContainers = new Set();
 
-    for (let {type, target, added, removed} of aMutations) {
+    for (let {type, target, added, removed, attributeName}  of aMutations) {
       let container = this.getContainer(target);
 
       if (container) {
-        if (type === "attributes" || type === "characterData") {
+        if (type === "attributes") {
+          let arr = addedOrEditedAttributes.get(container) || new Set();
+          arr.add(attributeName);
+          console.log("Attribute change", attributeName, arr);
+          addedOrEditedAttributes.set(container, arr);
+          // addedOrEditedAttributes.add(container);
+        }  else if (type === "characterData") {
           addedOrEditedContainers.add(container);
-        } else if (type === "childList") {
+        }else if (type === "childList") {
           // If there has been removals, flash the parent
           if (removed.length) {
             removedContainers.add(container);
           }
 
           // If there has been additions, flash the nodes if their associated
           // container exist (so if their parent is expanded in the inspector).
           added.forEach(added => {
@@ -811,16 +818,20 @@ MarkupView.prototype = {
     }
 
     for (let container of removedContainers) {
       container.flashMutation();
     }
     for (let container of addedOrEditedContainers) {
       container.flashMutation();
     }
+    for (let [container, attributes] of addedOrEditedAttributes) {
+      console.log("GOING TO FLASH FOR ATTR", attributes);
+      container.flashMutation(attributes);
+    }
   },
 
   /**
    * Make sure the given node's parents are expanded and the
    * node is scrolled on to screen.
    */
   showNode: function(aNode, centered) {
     let parent = aNode;
@@ -1875,17 +1886,22 @@ MarkupContainer.prototype = {
 
     this.markup.indicateDropTarget(el);
   },
 
   /**
    * Temporarily flash the container to attract attention.
    * Used for markup mutations.
    */
-  flashMutation: function() {
+  flashMutation: function(attributes) {
+    if (attributes) {
+      console.log(this.editor, this.editor.attrList);
+      return;
+    }
+
     if (!this.selected) {
       let contentWin = this.win;
       this.flashed = true;
       if (this._flashMutationTimer) {
         contentWin.clearTimeout(this._flashMutationTimer);
         this._flashMutationTimer = null;
       }
       this._flashMutationTimer = contentWin.setTimeout(() => {
@@ -2354,16 +2370,18 @@ function ElementEditor(aContainer, aNode
   // The templates will fill the following properties
   this.elt = null;
   this.tag = null;
   this.closeTag = null;
   this.attrList = null;
   this.newAttr = null;
   this.closeElt = null;
 
+  this.savedAttrs = new Set(this.node.attributes);
+
   // Create the main editor
   this.template("element", this);
 
   // Make the tag name editable (unless this is a remote node or
   // a document element)
   if (!aNode.isDocumentElement) {
     this.tag.setAttribute("tabindex", "0");
     editableField({
@@ -2409,16 +2427,17 @@ function ElementEditor(aContainer, aNode
   this.update();
 }
 
 ElementEditor.prototype = {
   /**
    * Update the state of the editor from the node.
    */
   update: function() {
+    console.log(this.savedAttrs);
     let attrs = this.node.attributes;
     if (!attrs) {
       return;
     }
 
     // Hide all the attribute editors, they'll be re-shown if they're
     // still applicable.  Don't update attributes that are being
     // actively edited.
@@ -2455,16 +2474,17 @@ ElementEditor.prototype = {
 
   _createAttribute: function(aAttr, aBefore = null) {
     // Create the template editor, which will save some variables here.
     let data = {
       attrName: aAttr.name,
     };
     this.template("attribute", data);
     var {attr, inner, name, val} = data;
+    // console.log("templating done", attr, aAttr.name);
 
     // Double quotes need to be handled specially to prevent DOMParser failing.
     // name="v"a"l"u"e" when editing -> name='v"a"l"u"e"'
     // name="v'a"l'u"e" when editing -> name="v'a&quot;l'u&quot;e"
     let editValueDisplayed = aAttr.value || "";
     let hasDoubleQuote = editValueDisplayed.contains('"');
     let hasSingleQuote = editValueDisplayed.contains("'");
     let initial = aAttr.name + '="' + editValueDisplayed + '"';
