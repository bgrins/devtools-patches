# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f078882f6e3a5d28e003aded2f589ddcf35b95a2
Bug 1139569 - Animation slowed down when element is expanded in markup view

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -773,25 +773,30 @@ MarkupView.prototype = {
   },
 
   /**
    * Given a list of mutations returned by the mutation observer, flash the
    * corresponding containers to attract attention.
    */
   _flashMutatedNodes: function(aMutations) {
     let addedOrEditedContainers = new Set();
+    let addedOrEditedAttributes = new Map();
     let removedContainers = new Set();
 
-    for (let {type, target, added, removed} of aMutations) {
+    for (let {type, target, added, removed, attributeName}  of aMutations) {
       let container = this.getContainer(target);
 
       if (container) {
-        if (type === "attributes" || type === "characterData") {
+        if (type === "attributes") {
+          let arr = addedOrEditedAttributes.get(container) || new Set();
+          arr.add(attributeName);
+          addedOrEditedAttributes.set(container, arr);
+        }  else if (type === "characterData") {
           addedOrEditedContainers.add(container);
-        } else if (type === "childList") {
+        }else if (type === "childList") {
           // If there has been removals, flash the parent
           if (removed.length) {
             removedContainers.add(container);
           }
 
           // If there has been additions, flash the nodes if their associated
           // container exist (so if their parent is expanded in the inspector).
           added.forEach(added => {
@@ -811,16 +816,19 @@ MarkupView.prototype = {
     }
 
     for (let container of removedContainers) {
       container.flashMutation();
     }
     for (let container of addedOrEditedContainers) {
       container.flashMutation();
     }
+    for (let [container, attributes] of addedOrEditedAttributes) {
+      container.flashMutation(attributes);
+    }
   },
 
   /**
    * Make sure the given node's parents are expanded and the
    * node is scrolled on to screen.
    */
   showNode: function(aNode, centered) {
     let parent = aNode;
@@ -1875,17 +1883,22 @@ MarkupContainer.prototype = {
 
     this.markup.indicateDropTarget(el);
   },
 
   /**
    * Temporarily flash the container to attract attention.
    * Used for markup mutations.
    */
-  flashMutation: function() {
+  flashMutation: function(attributes) {
+    if (attributes) {
+      // console.log(this.editor, this.editor.attrList);
+      return;
+    }
+
     if (!this.selected) {
       let contentWin = this.win;
       this.flashed = true;
       if (this._flashMutationTimer) {
         contentWin.clearTimeout(this._flashMutationTimer);
         this._flashMutationTimer = null;
       }
       this._flashMutationTimer = contentWin.setTimeout(() => {
@@ -2357,16 +2370,18 @@ function ElementEditor(aContainer, aNode
   this.closeTag = null;
   this.attrList = null;
   this.newAttr = null;
   this.closeElt = null;
 
   // Create the main editor
   this.template("element", this);
 
+  this.animationTimers = new WeakMap();
+
   // Make the tag name editable (unless this is a remote node or
   // a document element)
   if (!aNode.isDocumentElement) {
     this.tag.setAttribute("tabindex", "0");
     editableField({
       element: this.tag,
       trigger: "dblclick",
       stopOnReturn: true,
@@ -2405,43 +2420,72 @@ function ElementEditor(aContainer, aNode
   this.tag.textContent = tagName;
   this.closeTag.textContent = tagName;
   this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";
 
   this.update();
 }
 
 ElementEditor.prototype = {
+
+  flashElement: function(el) {
+    // Make sure the animation class is not here
+    el.classList.remove("flash-out");
+    
+    // Change the background
+    el.classList.add("theme-bg-contrast");
+
+    let timer = this.animationTimers.get(el);
+    if (timer) {
+      this.markup.win.clearTimeout(timer);
+    }
+
+    this.animationTimers.set(el, this.markup.win.setTimeout(() => {
+      // Add the animation class to smoothly remove the background
+      el.classList.add("flash-out");
+      
+      // Remove the background
+      el.classList.remove("theme-bg-contrast");
+    }, this.markup.CONTAINER_FLASHING_DURATION));
+  },
+
   /**
    * Update the state of the editor from the node.
    */
   update: function() {
-    let attrs = this.node.attributes;
-    if (!attrs) {
-      return;
-    }
-
-    // Hide all the attribute editors, they'll be re-shown if they're
-    // still applicable.  Don't update attributes that are being
-    // actively edited.
-    let attrEditors = this.attrList.querySelectorAll(".attreditor");
-    for (let i = 0; i < attrEditors.length; i++) {
-      if (!attrEditors[i].inplaceEditor) {
-        attrEditors[i].style.display = "none";
+    let attrs = this.node.attributes || [];
+    let attrsToRemove = new Set(this.attrList.querySelectorAll(".attreditor"));
+
+    // Don't do work for attributes that haven't changed
+    for (let attr of attrs) {
+      let {name, value} = attr;
+      let el = this.attrs[name];
+      let valueChanged = el && el.querySelector(".attr-value").innerHTML !== value;
+      let isEditing = el && el.querySelector(".editable").inplaceEditor;
+
+      if (el && (!valueChanged || isEditing)) {
+        // Element already exists and doesn't need any more work, except
+        // to make it visible.
+        el.style.removeProperty("display");
+        attrsToRemove.delete(el);
+      } else {
+        // Create a new editor if we aren't currently editing the attribute.
+        let attribute = this._createAttribute(attr);
+        attribute.style.removeProperty("display");
+        if (valueChanged) {
+          let val = attribute.querySelector(".attr-value");
+          this.flashElement(val);
+        }
       }
     }
 
-    // Get the attribute editor for each attribute that exists on
-    // the node and show it.
-    for (let attr of attrs) {
-      let attribute = this._createAttribute(attr);
-      if (!attribute.inplaceEditor) {
-        attribute.style.removeProperty("display");
-      }
+    for (let el of attrsToRemove) {
+      el.remove();
     }
+
   },
 
   _startModifyingAttributes: function() {
     return this.node.startModifyingAttributes();
   },
 
   /**
    * Get the element used for one of the attributes of this element
