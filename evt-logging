# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4572f6055a6a9377d213afe14a26556e6c410344

diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -48,16 +48,17 @@
 
         for (let tab of Array.from(gBrowser._removingTabs)) {
           gBrowser.removeTab(tab);
         }
 
         tabs._positionPinnedTabs();
       ]]></handler>
       <handler event="overflow"><![CDATA[
+        console.log("child", event.target, event.originalTarget, window.eventNum++);
         // Ignore overflow events:
         // - from nested scrollable elements
         // - for vertical orientation
         if (event.originalTarget != this.scrollbox ||
             event.detail == 0) {
           return;
         }
 
diff --git a/browser/base/content/test/tabs/browser_overflowScroll.js b/browser/base/content/test/tabs/browser_overflowScroll.js
--- a/browser/base/content/test/tabs/browser_overflowScroll.js
+++ b/browser/base/content/test/tabs/browser_overflowScroll.js
@@ -69,16 +69,20 @@ add_task(async function() {
 
   element = nextLeftElement();
   EventUtils.synthesizeMouseAtCenter(upButton, {});
   await waitForNextFrame();
   isLeft(element, "Scrolled one tab to the left with a single click");
 
   let elementPoint = left(scrollbox) - width(scrollbox);
   element = elementFromPoint(elementPoint);
+  // if (!element) {
+  console.log(elementPoint, element, scrollbox, left(scrollbox), width(scrollbox));
+  await new Promise(r => r);
+  // }
   element = element.nextElementSibling;
 
   EventUtils.synthesizeMouseAtCenter(upButton, {clickCount: 2});
   await waitForNextFrame();
   await BrowserTestUtils.waitForCondition(() =>
     !gBrowser.tabContainer.arrowScrollbox._isScrolling);
   isLeft(element, "Scrolled one page of tabs with a double click");
 
diff --git a/toolkit/content/widgets/scrollbox.xml b/toolkit/content/widgets/scrollbox.xml
--- a/toolkit/content/widgets/scrollbox.xml
+++ b/toolkit/content/widgets/scrollbox.xml
@@ -36,16 +36,18 @@
                          onmousedown="_onButtonMouseDown(event, 1);"
                          onmouseup="_onButtonMouseUp(event);"
                          onmouseover="_onButtonMouseOver(1);"
                          onmouseout="_onButtonMouseOut();"/>
     </content>
 
     <implementation>
       <constructor><![CDATA[
+      console.log("Constructor called for", this.className);
+      window.eventNum = window.eventNum || 0;
         if (!this.hasAttribute("smoothscroll")) {
           this.smoothScroll = this._prefBranch
                                   .getBoolPref("toolkit.scrollbox.smoothScroll", true);
         }
 
         this.setAttribute("notoverflowing", "true");
         this._updateScrollButtonsDisabledState();
       ]]></constructor>
@@ -704,16 +706,17 @@
         }
       ]]></handler>
 
       <handler event="touchend"><![CDATA[
         this._touchStart = -1;
       ]]></handler>
 
       <handler event="underflow" phase="capturing"><![CDATA[
+        console.log("underflow", this.smoothScroll, event.target == this, event.originalTarget == this.scrollbox, this.hasAttribute("notoverflowing"));
         // Ignore underflow events:
         // - from nested scrollable elements
         // - corresponding to an overflow event that we ignored
         if (event.target != this ||
             this.hasAttribute("notoverflowing")) {
           return;
         }
 
@@ -730,16 +733,19 @@
           return;
         }
 
         this.setAttribute("notoverflowing", "true");
         this._updateScrollButtonsDisabledState();
       ]]></handler>
 
       <handler event="overflow" phase="capturing"><![CDATA[
+        console.log("parent", event.target, event.originalTarget, window.eventNum++);
+        console.log("overflow", this.smoothScroll, event.target == this, event.originalTarget == this.scrollbox, this.hasAttribute("notoverflowing"));
+
         // Ignore overflow events:
         // - from nested scrollable elements
         if (event.target != this) {
           return;
         }
 
         // Ignore events that doesn't match our orientation.
         // Scrollport event orientation:
