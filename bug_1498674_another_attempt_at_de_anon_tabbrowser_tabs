# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1556915550 25200
#      Fri May 03 13:32:30 2019 -0700
# Node ID 6f121aa1ac9305e62ee2a73136f350e3857b54a4
# Parent  c68ff92fe54c75338c3a937bc6c4e615d9b1d45a
Bug 1498674 - Another attempt at de-anon tabbrowser-tabs

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -141,25 +141,25 @@ panelview[mainview] > .panel-header {
   }
   .tab-stack {
     /* Without this, pinned tabs get a bit too tall when the tabstrip overflows. */
     vertical-align: top;
   }
 }
 
 
-#tabbrowser-tabs:not([overflow="true"]):not([hashiddentabs]) ~ #alltabs-button,
-#tabbrowser-tabs[hasadjacentnewtabbutton]:not([overflow="true"]) ~ #new-tab-button,
-#tabbrowser-tabs[overflow="true"] > .tabbrowser-arrowscrollbox > .tabs-newtab-button,
-#tabbrowser-tabs:not([hasadjacentnewtabbutton]) > .tabbrowser-arrowscrollbox > .tabs-newtab-button,
-#TabsToolbar[customizing="true"] #tabbrowser-tabs > .tabbrowser-arrowscrollbox > .tabs-newtab-button {
+:root:not([overflow="true"]):not([hashiddentabs]) #alltabs-button,
+:root[hasadjacentnewtabbutton]:not([overflow="true"]) #new-tab-button,
+:root[overflow="true"] #tabs-newtab-button,
+:root:not([hasadjacentnewtabbutton]) #tabs-newtab-button,
+#TabsToolbar[customizing="true"] #tabs-newtab-button {
   visibility: collapse;
 }
 
-#tabbrowser-tabs:not([overflow="true"])[using-closing-tabs-spacer] ~ #alltabs-button {
+:root:not([overflow="true"])[using-closing-tabs-spacer] #alltabs-button {
   visibility: hidden; /* temporary space to keep a tab's close button under the cursor */
 }
 
 .tabbrowser-tab {
   -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-tab");
 }
 
 .tabbrowser-tab:not([pinned]) {
diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -712,43 +712,57 @@
                aria-label="&tabsToolbar.label;"
                context="toolbar-context-menu"
                flex="1">
 
         <hbox class="titlebar-spacer" type="pre-tabs"/>
 
         <hbox flex="1" align="end" class="toolbar-items">
           <hbox id="TabsToolbar-customization-target" flex="1">
-            <tabs id="tabbrowser-tabs"
-                  flex="1"
-                  setfocus="false"
-                  tooltip="tabbrowser-tab-tooltip"
-                  stopwatchid="FX_TAB_CLICK_MS">
-              <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
-            </tabs>
-
+            <hbox class="tab-drop-indicator-box">
+              <image class="tab-drop-indicator" id="tab-drop-indicator" collapsed="true"/>
+            </hbox>
+            <arrowscrollbox id="tabbrowser-arrowscrollbox" orient="horizontal" flex="1"
+                                style="min-width: 1px;"
+                                clicktoscroll="true"
+                                class="tabbrowser-arrowscrollbox">
+              <tabs id="tabbrowser-tabs"
+                    flex="1"
+                    setfocus="false"
+                    tooltip="tabbrowser-tab-tooltip"
+                    stopwatchid="FX_TAB_CLICK_MS">
+                <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
+              </tabs>
+              <toolbarbutton class="tabs-newtab-button toolbarbutton-1"
+                                id="tabs-newtab-button"
+                                command="cmd_newNavigatorTab"
+                                onclick="checkForMiddleClick(this, event);"
+                                />
+              <spacer class="closing-tabs-spacer" id="closing-tabs-spacer"
+                          style="width: 0;"/>
+            </arrowscrollbox>
             <toolbarbutton id="new-tab-button"
-                           class="toolbarbutton-1 chromeclass-toolbar-additional"
-                           label="&tabCmd.label;"
-                           command="cmd_newNavigatorTab"
-                           onclick="checkForMiddleClick(this, event);"
-                           tooltip="dynamic-shortcut-tooltip"
-                           ondrop="newTabButtonObserver.onDrop(event)"
-                           ondragover="newTabButtonObserver.onDragOver(event)"
-                           ondragenter="newTabButtonObserver.onDragOver(event)"
-                           ondragexit="newTabButtonObserver.onDragExit(event)"
-                           cui-areatype="toolbar"
-                           removable="true"/>
+                            class="toolbarbutton-1 chromeclass-toolbar-additional"
+                            label="&tabCmd.label;"
+                            command="cmd_newNavigatorTab"
+                            onclick="checkForMiddleClick(this, event);"
+                            tooltip="dynamic-shortcut-tooltip"
+                            ondrop="newTabButtonObserver.onDrop(event)"
+                            ondragover="newTabButtonObserver.onDragOver(event)"
+                            ondragenter="newTabButtonObserver.onDragOver(event)"
+                            ondragexit="newTabButtonObserver.onDragExit(event)"
+                            cui-areatype="toolbar"
+                            removable="true"/>
 
             <toolbarbutton id="alltabs-button"
-                           class="toolbarbutton-1 chromeclass-toolbar-additional tabs-alltabs-button badged-button"
-                           oncommand="gTabsPanel.showAllTabsPanel();"
-                           label="&listAllTabs.label;"
-                           tooltiptext="&listAllTabs.label;"
-                           removable="false"/>
+                            class="toolbarbutton-1 chromeclass-toolbar-additional tabs-alltabs-button badged-button"
+                            oncommand="gTabsPanel.showAllTabsPanel();"
+                            label="&listAllTabs.label;"
+                            tooltiptext="&listAllTabs.label;"
+                            removable="false"/>
           </hbox>
         </hbox>
 
         <hbox class="titlebar-spacer" type="post-tabs"/>
 
 #ifndef XP_MACOSX
         <button class="accessibility-indicator" tooltiptext="&accessibilityIndicator.tooltip;"
                 aria-live="polite"/>
diff --git a/browser/base/content/tabbrowser.css b/browser/base/content/tabbrowser.css
--- a/browser/base/content/tabbrowser.css
+++ b/browser/base/content/tabbrowser.css
@@ -69,20 +69,25 @@ tabpanels {
     image-rendering: -moz-crisp-edges;
   }
 }
 
 .closing-tabs-spacer {
   pointer-events: none;
 }
 
-#tabbrowser-tabs:not(:hover) > .tabbrowser-arrowscrollbox > .closing-tabs-spacer {
+.tabbrowser-arrowscrollbox:not(:hover) > .closing-tabs-spacer {
   transition: width .15s ease-out;
 }
 
+#tabbrowser-tabs > .tabs-left,
+#tabbrowser-tabs > .tabs-right {
+  -moz-box-flex: 0;
+}
+
 browser[blank],
 browser[pendingpaint] {
   opacity: 0;
 }
 
 #tabbrowser-tabpanels[pendingpaint] {
   background-image: url(chrome://browser/skin/tabbrowser/pendingpaint.png);
   background-repeat: no-repeat;
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -5,59 +5,30 @@
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <bindings id="tabBrowserBindings"
           xmlns="http://www.mozilla.org/xbl"
           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
           xmlns:xbl="http://www.mozilla.org/xbl">
   <binding id="tabbrowser-tabs"
            extends="chrome://global/content/bindings/tabbox.xml#tabs">
-    <content>
-      <xul:hbox class="tab-drop-indicator-box">
-        <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
-      </xul:hbox>
-      <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
-                          style="min-width: 1px;"
-                          clicktoscroll="true"
-                          class="tabbrowser-arrowscrollbox">
-<!--
- This is a hack to circumvent bug 472020, otherwise the tabs show up on the
- right of the newtab button.
--->
-        <children includes="tab"/>
-<!--
-  This is to ensure anything extensions put here will go before the newtab
-  button, necessary due to the previous hack.
--->
-        <children/>
-        <xul:toolbarbutton class="tabs-newtab-button toolbarbutton-1"
-                           anonid="tabs-newtab-button"
-                           command="cmd_newNavigatorTab"
-                           onclick="checkForMiddleClick(this, event);"
-                           />
-        <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
-                    style="width: 0;"/>
-      </xul:arrowscrollbox>
-    </content>
-
     <implementation implements="nsIObserver">
       <constructor>
         <![CDATA[
           this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
           this._hiddenSoundPlayingTabs = new Set();
 
           let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
               "emptyPrivateTabTitle" : "emptyTabTitle";
           this.emptyTabTitle = gTabBrowserBundle.GetStringFromName("tabs." + strId);
 
           var tab = this.firstElementChild;
           tab.label = this.emptyTabTitle;
 
-          let newTabButton = document.getAnonymousElementByAttribute(
-            this, "anonid", "tabs-newtab-button");
+          let newTabButton = document.getElementById("tabs-newtab-button");
           newTabButton.setAttribute("tooltiptext", GetDynamicShortcutTooltipText("tabs-newtab-button"));
 
           window.addEventListener("resize", this);
 
           Services.prefs.addObserver("privacy.userContext", this);
           this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
 
           XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
@@ -103,17 +74,17 @@
         document.getElementById("tabbrowser-tabbox");
       </field>
 
       <field name="contextMenu" readonly="true">
         document.getElementById("tabContextMenu");
       </field>
 
       <field name="arrowScrollbox">
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
+        document.getElementById("tabbrowser-arrowscrollbox");
       </field>
 
       <field name="_firstTab">null</field>
       <field name="_lastTab">null</field>
       <field name="_beforeSelectedTab">null</field>
       <field name="_beforeHoveredTab">null</field>
       <field name="_afterHoveredTab">null</field>
       <field name="_hoveredTab">null</field>
@@ -141,21 +112,21 @@
           let arrowScrollbox = this.arrowScrollbox;
           arrowScrollbox.addEventListener("underflow", event => {
             // Ignore underflow events:
             // - from nested scrollable elements
             // - for vertical orientation
             // - corresponding to an overflow event that we ignored
             if (event.originalTarget != arrowScrollbox.scrollbox ||
                 event.detail == 0 ||
-                !this.hasAttribute("overflow")) {
+                !document.documentElement.hasAttribute("overflow")) {
               return;
             }
 
-            this.removeAttribute("overflow");
+            document.documentElement.removeAttribute("overflow");
 
             if (this._lastTabClosedByMouse) {
               this._expandSpacerBy(this.arrowScrollbox._scrollButtonDown.clientWidth);
             }
 
             for (let tab of Array.from(gBrowser._removingTabs)) {
               gBrowser.removeTab(tab);
             }
@@ -167,17 +138,17 @@
             // Ignore overflow events:
             // - from nested scrollable elements
             // - for vertical orientation
             if (event.originalTarget != arrowScrollbox.scrollbox ||
                 event.detail == 0) {
               return;
             }
 
-            this.setAttribute("overflow", "true");
+            document.documentElement.setAttribute("overflow", "true");
             this._positionPinnedTabs();
             this._handleTabSelect(true);
           });
 
           // Override scrollbox.xml method, since our scrollbox's children are
           // inherited from the scrollbox binding parent (this).
           arrowScrollbox._getScrollableElements = () => {
             return Array.prototype.filter.call(this.children, arrowScrollbox._canScrollToElement);
@@ -206,17 +177,17 @@
 
               // If longPressBehavior pref is set to 0 (or any invalid value)
               // long press menu is disabled.
               if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
                 containersEnabled = false;
               }
 
               const newTab = document.getElementById("new-tab-button");
-              const newTab2 = document.getAnonymousElementByAttribute(this, "anonid", "tabs-newtab-button");
+              const newTab2 = document.getElementById("tabs-newtab-button");
 
               for (let parent of [newTab, newTab2]) {
                 if (!parent)
                   continue;
 
                 gClickAndHoldListenersOnElement.remove(parent);
                 parent.removeAttribute("type");
                 if (parent.firstElementChild) {
@@ -285,17 +256,17 @@
           if (this._beforeSelectedTab) {
             this._beforeSelectedTab.removeAttribute("beforeselected-visible");
           }
 
           if (selectedTab.closing || selectedIndex <= 0) {
             this._beforeSelectedTab = null;
           } else {
             let beforeSelectedTab = visibleTabs[selectedIndex - 1];
-            let separatedByScrollButton = this.getAttribute("overflow") == "true" &&
+            let separatedByScrollButton = document.documentElement.getAttribute("overflow") == "true" &&
               beforeSelectedTab.pinned && !selectedTab.pinned;
             if (!separatedByScrollButton) {
               this._beforeSelectedTab = beforeSelectedTab;
               this._beforeSelectedTab.setAttribute("beforeselected-visible",
                                                    "true");
             }
           }
 
@@ -328,27 +299,27 @@
             }
           }
         ]]></body>
       </method>
 
       <field name="_blockDblClick">false</field>
 
       <field name="_tabDropIndicator">
-        document.getAnonymousElementByAttribute(this, "anonid", "tab-drop-indicator");
+        document.getElementById("tab-drop-indicator");
       </field>
 
       <field name="_dragOverDelay">350</field>
       <field name="_dragTime">0</field>
 
       <field name="_closeButtonsUpdatePending">false</field>
       <method name="_updateCloseButtons">
         <body><![CDATA[
           // If we're overflowing, tabs are at their minimum widths.
-          if (this.getAttribute("overflow") == "true") {
+          if (document.documentElement.getAttribute("overflow") == "true") {
             this.setAttribute("closebuttons", "activetab");
             return;
           }
 
           if (this._closeButtonsUpdatePending) {
             return;
           }
           this._closeButtonsUpdatePending = true;
@@ -356,17 +327,17 @@
           // Wait until after the next paint to get current layout data from
           // getBoundsWithoutFlushing.
           window.requestAnimationFrame(() => {
             window.requestAnimationFrame(() => {
               this._closeButtonsUpdatePending = false;
 
               // The scrollbox may have started overflowing since we checked
               // overflow earlier, so check again.
-              if (this.getAttribute("overflow") == "true") {
+              if (document.documentElement.getAttribute("overflow") == "true") {
                 this.setAttribute("closebuttons", "activetab");
                 return;
               }
 
               // Check if tab widths are below the threshold where we want to
               // remove close buttons from background tabs so that people don't
               // accidentally close tabs by selecting them.
               let rect = ele => {
@@ -381,36 +352,36 @@
             });
           });
         ]]></body>
       </method>
 
       <method name="_updateHiddenTabsStatus">
         <body><![CDATA[
           if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {
-            this.setAttribute("hashiddentabs", "true");
+            document.documentElement.setAttribute("hashiddentabs", "true");
           } else {
-            this.removeAttribute("hashiddentabs");
+            document.documentElement.removeAttribute("hashiddentabs");
           }
         ]]></body>
       </method>
 
       <method name="_handleTabSelect">
         <parameter name="aInstant"/>
         <body><![CDATA[
           let selectedTab = this.selectedItem;
-          if (this.getAttribute("overflow") == "true")
+          if (document.documentElement.getAttribute("overflow") == "true")
             this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);
 
           selectedTab._notselectedsinceload = false;
         ]]></body>
       </method>
 
       <field name="_closingTabsSpacer">
-        document.getAnonymousElementByAttribute(this, "anonid", "closing-tabs-spacer");
+        document.getElementById("closing-tabs-spacer");
       </field>
 
       <field name="_tabDefaultMaxWidth">NaN</field>
       <field name="_lastTabClosedByMouse">false</field>
       <field name="_hasTabTempMaxWidth">false</field>
 
       <!-- Try to keep the active tab's close button under the mouse cursor -->
       <method name="_lockTabSizing">
@@ -425,17 +396,17 @@
           var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);
 
           if (!this._tabDefaultMaxWidth) {
             this._tabDefaultMaxWidth =
               parseFloat(window.getComputedStyle(aTab).maxWidth);
           }
           this._lastTabClosedByMouse = true;
 
-          if (this.getAttribute("overflow") == "true") {
+          if (document.documentElement.getAttribute("overflow") == "true") {
             // Don't need to do anything if we're in overflow mode and aren't scrolled
             // all the way to the right, or if we're closing the last tab.
             if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {
               return;
             }
             // If the tab has an owner that will become the active tab, the owner will
             // be to the left of it, so we actually want the left tab to slide over.
             // This can't be done as easily in non-overflow mode, so we don't bother.
@@ -487,17 +458,17 @@
         ]]></body>
       </method>
 
       <method name="_expandSpacerBy">
         <parameter name="pixels"/>
         <body><![CDATA[
           let spacer = this._closingTabsSpacer;
           spacer.style.width = parseFloat(spacer.style.width) + pixels + "px";
-          this.setAttribute("using-closing-tabs-spacer", "true");
+          document.documentElement.setAttribute("using-closing-tabs-spacer", "true");
           gBrowser.addEventListener("mousemove", this);
           window.addEventListener("mouseout", this);
         ]]></body>
       </method>
 
       <method name="_unlockTabSizing">
         <body><![CDATA[
           gBrowser.removeEventListener("mousemove", this);
@@ -506,18 +477,18 @@
           if (this._hasTabTempMaxWidth) {
             this._hasTabTempMaxWidth = false;
             let tabs = this._getVisibleTabs();
             for (let i = 0; i < tabs.length; i++) {
               tabs[i].style.maxWidth = "";
             }
           }
 
-          if (this.hasAttribute("using-closing-tabs-spacer")) {
-            this.removeAttribute("using-closing-tabs-spacer");
+          if (document.documentElement.hasAttribute("using-closing-tabs-spacer")) {
+            document.documentElement.removeAttribute("using-closing-tabs-spacer");
             this._closingTabsSpacer.style.width = 0;
           }
         ]]></body>
       </method>
 
       <method name="uiDensityChanged">
         <body><![CDATA[
           this._positionPinnedTabs();
@@ -526,17 +497,17 @@
         ]]></body>
       </method>
 
       <field name="_lastNumPinned">0</field>
       <field name="_pinnedTabsLayoutCache">null</field>
       <method name="_positionPinnedTabs">
         <body><![CDATA[
           let numPinned = gBrowser._numPinnedTabs;
-          let doPosition = this.getAttribute("overflow") == "true" &&
+          let doPosition = document.documentElement.getAttribute("overflow") == "true" &&
                            this._getVisibleTabs().length > numPinned &&
                            numPinned > 0;
 
           if (doPosition) {
             this.setAttribute("positionpinnedtabs", "true");
 
             let layoutData = this._pinnedTabsLayoutCache;
             let uiDensity = document.documentElement.getAttribute("uidensity");
@@ -917,17 +888,17 @@
 
       <field name="_animateElement">
         this.arrowScrollbox._scrollButtonDown;
       </field>
 
       <method name="_notifyBackgroundTab">
         <parameter name="aTab"/>
         <body><![CDATA[
-          if (aTab.pinned || aTab.hidden || this.getAttribute("overflow") != "true")
+          if (aTab.pinned || aTab.hidden || document.documentElement.getAttribute("overflow") != "true")
             return;
 
           this._lastTabToScrollIntoView = aTab;
           if (!this._backgroundTabScrollPromise) {
             this._backgroundTabScrollPromise = window.promiseDocumentFlushed(() => {
               let lastTabRect = this._lastTabToScrollIntoView.getBoundingClientRect();
               let selectedTab = this.selectedItem;
               if (selectedTab.pinned) {
@@ -1120,39 +1091,42 @@
           gBrowser._insertBrowser(aTab);
           return document.getElementById(aTab.linkedPanel);
         ]]>
         </body>
       </method>
 
       <method name="_updateNewTabVisibility">
         <body><![CDATA[
+          // XXXX:
+          document.documentElement.setAttribute("hasadjacentnewtabbutton", "true");
+          return;
           // Helper functions to help deal with customize mode wrapping some items
           let wrap = n => n.parentNode.localName == "toolbarpaletteitem" ? n.parentNode : n;
           let unwrap = n => n && n.localName == "toolbarpaletteitem" ? n.firstElementChild : n;
 
           // Starting from the tabs element, find the next sibling that:
           // - isn't hidden; and
           // - isn't the all-tabs button.
           // If it's the new tab button, consider the new tab button adjacent to the tabs.
           // If the new tab button is marked as adjacent and the tabstrip doesn't
           // overflow, we'll display the 'new tab' button inline in the tabstrip.
           // In all other cases, the separate new tab button is displayed in its
           // customized location.
-          let sib = this;
+          let sib = this.arrowScrollbox;
           do {
             sib = unwrap(wrap(sib).nextElementSibling);
           } while (sib && (sib.hidden ||
                            sib.id == "alltabs-button"));
 
           const kAttr = "hasadjacentnewtabbutton";
           if (sib && sib.id == "new-tab-button") {
-            this.setAttribute(kAttr, "true");
+            document.documentElement.setAttribute(kAttr, "true");
           } else {
-            this.removeAttribute(kAttr);
+            document.documentElement.removeAttribute(kAttr);
           }
         ]]></body>
       </method>
 
       <method name="onWidgetAfterDOMChange">
         <parameter name="aNode"/>
         <parameter name="aNextNode"/>
         <parameter name="aContainer"/>
@@ -1566,17 +1540,17 @@
         event.stopPropagation();
 
         var arrowScrollbox = this.arrowScrollbox;
 
         // autoscroll the tab strip if we drag over the scroll
         // buttons, even if we aren't dragging a tab, but then
         // return to avoid drawing the drop indicator
         var pixelsToScroll = 0;
-        if (this.getAttribute("overflow") == "true") {
+        if (document.documentElement.getAttribute("overflow") == "true") {
           var targetAnonid = event.originalTarget.getAttribute("anonid");
           switch (targetAnonid) {
             case "scrollbutton-up":
               pixelsToScroll = arrowScrollbox.scrollIncrement * -1;
               break;
             case "scrollbutton-down":
               pixelsToScroll = arrowScrollbox.scrollIncrement;
               break;
@@ -2137,17 +2111,17 @@
           if (this.selected)
             tabContainer._handleTabSelect();
 
           if (tabIndex == 0) {
             tabContainer._beforeHoveredTab = null;
           } else {
             let candidate = visibleTabs[tabIndex - 1];
             let separatedByScrollButton =
-              tabContainer.getAttribute("overflow") == "true" &&
+              document.documentElement.getAttribute("overflow") == "true" &&
               candidate.pinned && !this.pinned;
             if (!candidate.selected && !separatedByScrollButton) {
               tabContainer._beforeHoveredTab = candidate;
               candidate.setAttribute("beforehovered", "true");
             }
           }
 
           if (tabIndex == visibleTabs.length - 1) {
