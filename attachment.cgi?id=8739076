# HG changeset patch
# User Lin Clark <lclark@mozilla.com>
Bug 1262865 - Add docs for testing React/Redux.


diff --git a/devtools/docs/react-guidelines.md b/devtools/docs/react-guidelines.md
index b6fe32f..3b3a8e4 100644
--- a/devtools/docs/react-guidelines.md
+++ b/devtools/docs/react-guidelines.md
@@ -5,46 +5,46 @@ These are soft rules for writing react devtools code. Try to stick to
 these for consistency, and if you disagree, file a bug to change these
 docs and we can talk about it.
 
 **Please also read** the [coding
  standards](https://wiki.mozilla.org/DevTools/CodingStandards#React_.26_Redux)
 for react and redux code. The guidelines here are more general
 patterns not specific to code style.
 
-### Why no JSX?
+## Why no JSX?
 
 You probably already noticed we don't use JSX. The answer isn't
 complicated: we don't build our JS code, and we write directly for our
 JS engine, SpiderMonkey. It already supports much of ES6, but it does
 not support JSX (which is not a standard).
 
 This may change if we ever adopt a build step. Even so, the author is
 not convinced that JSX helps enough to warrant all the syntax. It is
 clearer sometimes, but it can be noisy switching between JSX and JS a
 lot.
 
 It's not as bad as you may think! If you are used to JSX it may be an
 adjustment, but you won't miss it too much.
 
-### One component per file
+## One component per file
 
 Try to only put one component in a file. This helps avoid large files
 full of components, but it's also technically required for how we wrap
 components with factories. See the next rule.
 
 It also makes it easier to write tests because you might not export
 some components, so tests can't access them.
 
 You can include small helper components in the same file if you really
 want to, but note that they won't be directly tested and you will have
 to use `React.createElement` or immediately wrap them in factories to
 use them.
 
-### Export the component directly and create factory on import
+## Export the component directly and create factory on import
 
 Modules are the way components interact. Ideally every component lives
 in a separate file and they require whatever they need. This allows
 tests to access all components and use module boundaries to wrap
 components.
 
 For example, we don't use JSX, so we need to create factories for
 components to use them as functions. A simple way to do this is on
@@ -63,11 +63,66 @@ Additionally, make sure to export the component class directly:
 ```js
 const Thing1 = React.createClass({ ... });
 module.exports = Thing1;
 ```
 
 Do not export `{ Thing1 }` or anything like that. This is required for
 the factory wrapping as well as hot reloading.
 
-### More to Come
+## Testing
+
+There are three kinds of tests that you can write:
+
+- Unit tests make sure a single unit (like a function) returns what it's supposed to
+- Integration tests make sure that multiple units work together
+- End-to-end tests fire up the full application and test everything together
+
+As much as possible, we want to write unit and integration tests. End-to-end tests should be used sparingly.
+
+### Action creator tests (unit)
+
+Test that action creator functions create the expected action.
+
+### Store tests (integration)
+
+Get a store instance and dispatch actions against it. Test that the store contains the data expected.
+
+This tests the integration between middleware, reducers, and selector functions.
+
+Some strategies for these tests:
+
+- Use a module to instantiate the store for the app. Also export the store factory that can create new store instances for tests.
+- In the test, use the action creators (which have already been tested) to create actions and dispatch on stores.
+- If components pull values directly from the state object during connect, then test the state object shape.
+- On the other hand, if components use selector functions (either on the reducers or using reselect), then test that calling those selectors gets the expected state.
+
+In addition to store integration tests, you may want to unit test reducers and selectors.
+
+Examples:
+- [Web console](https://github.com/bgrins/gecko-dev/blob/console-frontend/devtools/client/webconsole/new-console-output/test/store/test_messages.js)
+
+### Component tests (integration, unit)
+
+Test the HTML structure created by components.
+
+For presentational components, test that given the expected props they produce the expected DOM. To do this, render the component using `TestUtils.renderIntoDocument()`. Then you can use methods like `querySelectorAll` and `textContent` to test the rendered output.
+
+Examples:
+- [Web console](https://github.com/bgrins/gecko-dev/blob/console-frontend/devtools/client/webconsole/new-console-output/test/components/test_date-preview.html)
+
+For container components, make sure that they assemble the correct child components. You can do this with shallow rendering.
+
+Examples:
+- [Web console](https://github.com/bgrins/gecko-dev/blob/console-frontend/devtools/client/webconsole/new-console-output/test/components/test_message-container.html)
+
+You may also want to test how the store, container component, and presentational component interact. You can do this by mocking a [Provider](https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md#connected-components).
+
+### End-to-end tests (functional)
+
+These should use a browser chrome mochitest to test browser interactions. These ensure that all parts are hooked up as expected, or that specific mouse interactions are working.
+
+These should not test all possible code paths. Comprehensive testing of different inputs should be covered in the tests described above.
+
+
+## More to Come
 
 This is just a start. We will add more to this document.
\ No newline at end of file
