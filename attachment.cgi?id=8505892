# HG changeset patch
# Parent e655fbbc6e9fab9fa942d5d5769f7dba8f53592b
# User Mats Palmgren <mats@mozilla.com>
Bug 1055085 - Make an ESC key press in an <input type=search> clear the value.  r=smaug

diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -87,17 +87,17 @@ function Toolbox(target, selectedTool, h
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
 
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
-  this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
+  this._splitConsoleOnKeydown = this._splitConsoleOnKeydown.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
   this._highlighterReady = this._highlighterReady.bind(this);
   this._highlighterHidden = this._highlighterHidden.bind(this);
   this._prefChanged = this._prefChanged.bind(this);
   this._saveSplitConsoleHeight = this._saveSplitConsoleHeight.bind(this);
   this._onFocus = this._onFocus.bind(this);
 
@@ -349,19 +349,31 @@ Toolbox.prototype = {
 
   _buildOptions: function() {
     let key = this.doc.getElementById("toolbox-options-key");
     key.addEventListener("command", () => {
       this.selectTool("options");
     }, true);
   },
 
-  _splitConsoleOnKeypress: function(e) {
+  _splitConsoleOnKeydown: function(e) {
     if (e.keyCode === e.DOM_VK_ESCAPE) {
-      this.toggleSplitConsole();
+      let shouldToggle = true;
+
+      // If this is an input[type=search] and ESC is going to clear the
+      // value, then don't toggle.
+      if (e.originalTarget.getAttribute("type") === "search" &&
+         (e.originalTarget.value || "").trim().length > 0) {
+        shouldToggle = false;
+      }
+
+      if (shouldToggle) {
+        this.toggleSplitConsole();
+      }
+
       // If the debugger is paused, don't let the ESC key stop any pending
       // navigation.
       let jsdebugger = this.getPanel("jsdebugger");
       if (jsdebugger && jsdebugger.panelWin.gThreadClient.state == "paused") {
         e.preventDefault();
       }
     }
   },
@@ -382,17 +394,17 @@ Toolbox.prototype = {
   _addHostListeners: function() {
     let nextKey = this.doc.getElementById("toolbox-next-tool-key");
     nextKey.addEventListener("command", this.selectNextTool.bind(this), true);
     let prevKey = this.doc.getElementById("toolbox-previous-tool-key");
     prevKey.addEventListener("command", this.selectPreviousTool.bind(this), true);
 
     // Split console uses keypress instead of command so the event can be
     // cancelled with stopPropagation on the keypress, and not preventDefault.
-    this.doc.addEventListener("keypress", this._splitConsoleOnKeypress, false);
+    this.doc.addEventListener("keydown", this._splitConsoleOnKeydown, false);
 
     this.doc.addEventListener("focus", this._onFocus, true);
   },
 
   _saveSplitConsoleHeight: function() {
     Services.prefs.setIntPref(SPLITCONSOLE_HEIGHT_PREF,
       this.webconsolePanel.height);
   },
@@ -1495,18 +1507,18 @@ Toolbox.prototype = {
   },
 
   /**
    * Destroy the current host, and remove event listeners from its frame.
    *
    * @return {promise} to be resolved when the host is destroyed.
    */
   destroyHost: function() {
-    this.doc.removeEventListener("keypress",
-      this._splitConsoleOnKeypress, false);
+    this.doc.removeEventListener("keydown",
+      this._splitConsoleOnKeydown, false);
     this.doc.removeEventListener("focus", this._onFocus, true);
     return this._host.destroy();
   },
 
   /**
    * Remove all UI elements, detach from target and clear up
    */
   destroy: function() {
diff --git a/content/html/content/src/HTMLInputElement.cpp b/content/html/content/src/HTMLInputElement.cpp
--- a/content/html/content/src/HTMLInputElement.cpp
+++ b/content/html/content/src/HTMLInputElement.cpp
@@ -3993,16 +3993,29 @@ HTMLInputElement::PostHandleEvent(EventC
                   SelectAll(presContext);
                 }
               }
             }
           }
           break;
         }
 
+        case NS_KEY_DOWN:
+        {
+          WidgetKeyboardEvent* keyEvent = aVisitor.mEvent->AsKeyboardEvent();
+          if (keyEvent->keyCode == NS_VK_ESCAPE &&
+              mType == NS_FORM_INPUT_SEARCH &&
+              !keyEvent->IsAlt() &&
+              !keyEvent->IsControl() &&
+              !keyEvent->IsMeta()) {
+            SetValueInternal(EmptyString(), true, true);
+          }
+          break;
+        }
+
         case NS_KEY_PRESS:
         case NS_KEY_UP:
         {
           // For backwards compat, trigger checks/radios/buttons with
           // space or enter (bug 25300)
           WidgetKeyboardEvent* keyEvent = aVisitor.mEvent->AsKeyboardEvent();
           if ((aVisitor.mEvent->message == NS_KEY_PRESS &&
                keyEvent->keyCode == NS_VK_RETURN) ||
diff --git a/content/html/content/test/mochitest.ini b/content/html/content/test/mochitest.ini
--- a/content/html/content/test/mochitest.ini
+++ b/content/html/content/test/mochitest.ini
@@ -418,16 +418,18 @@ skip-if = (toolkit == 'gonk' && debug) |
 [test_bug879319.html]
 [test_bug885024.html]
 [test_bug893537.html]
 [test_bug95530.html]
 [test_bug969346.html]
 [test_bug982039.html]
 [test_bug1003539.html]
 [test_bug1045270.html]
+[test_bug1055085.html]
+skip-if = buildapp == 'b2g'
 [test_change_crossorigin.html]
 [test_checked.html]
 [test_dir_attributes_reflection.html]
 [test_dl_attributes_reflection.html]
 [test_element_prototype.html]
 [test_embed_attributes_reflection.html]
 [test_formData.html]
 [test_formSubmission.html]
diff --git a/content/html/content/test/test_bug1055085.html b/content/html/content/test/test_bug1055085.html
new file mode 100644
--- /dev/null
+++ b/content/html/content/test/test_bug1055085.html
@@ -0,0 +1,70 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1055085
+-->
+<head>
+  <title>Test for Bug 1055085</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/EventUtils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1055085">Mozilla Bug 1055085</a>
+<p id="display"></p>
+<div id="content">
+  <input type="search" value="default">
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 1055085 **/
+
+SimpleTest.waitForExplicitFinish();
+
+// Turn off Spatial Navigation so that the 'keypress' event fires.
+SpecialPowers.setBoolPref('snav.enabled', false);
+
+SimpleTest.waitForFocus(function() {
+  var changeEvents = 0;
+  var keyDownEvents = 0;
+  var input = document.getElementsByTagName('input')[0];
+
+  input.addEventListener('keydown', function(event) {
+    keyDownEvents++;
+    if (keyDownEvents == 1)
+      event.preventDefault();
+    else if (keyDownEvents == 2)
+      is(event.target.value, 'default', 'preventDefault() works');
+  }, false);
+
+  input.addEventListener('change', function() {
+    changeEvents++;
+    is(input.value, '', 'ESC cleared the value');
+  }, false);
+
+  input.addEventListener('blur', function() {
+    is(changeEvents, 1, "got exactly one change event");
+    is(keyDownEvents, 2, "got two keydown events");
+    is(input.value, '', 'ESC cleared the value');
+    SimpleTest.finish();
+  }, false);
+
+  input.addEventListener('focus', function() {
+    input.removeEventListener('focus', arguments.callee, false);
+    // We must ESC outside this focus handler since HTMLInputElement::PostHandleEvent
+    // assigns mFocusedValue to the current value and thus we won't get a change event.
+    SimpleTest.executeSoon(function() {
+      synthesizeKey('VK_ESCAPE', {}); // preventDefault'ed in keypress handler above
+      synthesizeKey('VK_ESCAPE', {});
+      SimpleTest.executeSoon(function() { input.blur(); });
+    });
+  }, false);
+
+  input.focus();
+});
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/toolkit/components/autocomplete/nsAutoCompleteController.cpp b/toolkit/components/autocomplete/nsAutoCompleteController.cpp
--- a/toolkit/components/autocomplete/nsAutoCompleteController.cpp
+++ b/toolkit/components/autocomplete/nsAutoCompleteController.cpp
@@ -281,34 +281,47 @@ nsAutoCompleteController::HandleEnter(bo
   // Stop the search, and handle the enter.
   StopSearch();
   EnterMatch(aIsPopupSelection);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsAutoCompleteController::CancelTextValueChange(bool *_retval)
+{
+  if (mInput) {
+    nsCOMPtr<nsIAutoCompleteInput> input(mInput);
+    input->GetPopupOpen(_retval);
+    StopSearch();
+    ClearResults();
+    RevertTextValue();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsAutoCompleteController::CancelPopup(bool *_retval)
+{
+  *_retval = false;
+  if (mInput) {
+    nsCOMPtr<nsIAutoCompleteInput> input(mInput);
+    // allow the event through if the popup is closed
+    input->GetPopupOpen(_retval);
+    ClosePopup();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsAutoCompleteController::HandleEscape(bool *_retval)
 {
-  *_retval = false;
-  if (!mInput)
-    return NS_OK;
-
-  nsCOMPtr<nsIAutoCompleteInput> input(mInput);
-
-  // allow the event through if the popup is closed
-  input->GetPopupOpen(_retval);
-
-  // Stop all searches in case they are async.
-  StopSearch();
-  ClearResults();
-  RevertTextValue();
-  ClosePopup();
-
-  return NS_OK;
+  CancelTextValueChange(_retval);
+  bool dummy;
+  return CancelPopup(&dummy);
 }
 
 NS_IMETHODIMP
 nsAutoCompleteController::HandleStartComposition()
 {
   NS_ENSURE_TRUE(mCompositionState != eCompositionState_Composing, NS_OK);
 
   mPopupClosedByCompositionStart = false;
diff --git a/toolkit/components/autocomplete/nsIAutoCompleteController.idl b/toolkit/components/autocomplete/nsIAutoCompleteController.idl
--- a/toolkit/components/autocomplete/nsIAutoCompleteController.idl
+++ b/toolkit/components/autocomplete/nsIAutoCompleteController.idl
@@ -1,17 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 
 interface nsIAutoCompleteInput;
 
-[scriptable, uuid(ff9f8465-204a-47a6-b3c9-0628b3856684)]
+[scriptable, uuid(7679e4a0-2f6b-11e4-9e69-e71c321800d1)]
 interface nsIAutoCompleteController : nsISupports
 {
   /*
    * Possible values for the searchStatus attribute
    */
   const unsigned short STATUS_NONE = 1;
   const unsigned short STATUS_SEARCHING = 2;
   const unsigned short STATUS_COMPLETE_NO_MATCH = 3;
@@ -136,12 +136,26 @@ interface nsIAutoCompleteController : ns
 
   /*
    * For the last completed search, get the final value that should be completed
    * when the user confirms the match at the given index
    */
   AString getFinalCompleteValueAt(in long index);
 
   /*
+   * Cancel any searches and reset the text value.
+   * For handling an ESCAPE keydown event.
+   * @return True if the popup was open.
+   */
+  [noscript] bool cancelTextValueChange();
+
+  /*
+   * Close the popup.
+   * For handling an ESCAPE keypress event.
+   * @return True if the popup was open.
+   */
+  [noscript] bool cancelPopup();
+
+  /*
    * Get / set the current search string.  Note, setting will not start searching
    */
   attribute AString searchString;
 };
diff --git a/toolkit/components/satchel/nsFormFillController.cpp b/toolkit/components/satchel/nsFormFillController.cpp
--- a/toolkit/components/satchel/nsFormFillController.cpp
+++ b/toolkit/components/satchel/nsFormFillController.cpp
@@ -892,16 +892,44 @@ nsFormFillController::Focus(nsIDOMEvent*
   if (isPwmgrInput || hasList || autocomplete) {
     StartControllingInput(input);
   }
 
   return NS_OK;
 }
 
 nsresult
+nsFormFillController::KeyDown(nsIDOMEvent* aEvent)
+{
+  NS_ASSERTION(mController, "should have a controller!");
+  if (!mFocusedInput || !mController)
+    return NS_OK;
+
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
+  if (!keyEvent)
+    return NS_ERROR_FAILURE;
+
+  bool cancel = false;
+
+  uint32_t k;
+  keyEvent->GetKeyCode(&k);
+  switch (k) {
+    case nsIDOMKeyEvent::DOM_VK_ESCAPE:
+      mController->CancelTextValueChange(&cancel);
+      break;
+  }
+
+  if (cancel) {
+    aEvent->PreventDefault();
+  }
+
+  return NS_OK;
+}
+
+nsresult
 nsFormFillController::KeyPress(nsIDOMEvent* aEvent)
 {
   NS_ASSERTION(mController, "should have a controller!");
   if (!mFocusedInput || !mController)
     return NS_OK;
 
   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
   if (!keyEvent)
@@ -946,17 +974,17 @@ nsFormFillController::KeyPress(nsIDOMEve
     /* fall through */
   case nsIDOMKeyEvent::DOM_VK_UP:
   case nsIDOMKeyEvent::DOM_VK_DOWN:
   case nsIDOMKeyEvent::DOM_VK_LEFT:
   case nsIDOMKeyEvent::DOM_VK_RIGHT:
     mController->HandleKeyNavigation(k, &cancel);
     break;
   case nsIDOMKeyEvent::DOM_VK_ESCAPE:
-    mController->HandleEscape(&cancel);
+    mController->CancelPopup(&cancel);
     break;
   case nsIDOMKeyEvent::DOM_VK_TAB:
     mController->HandleTab();
     cancel = false;
     break;
   case nsIDOMKeyEvent::DOM_VK_RETURN:
     mController->HandleEnter(false, &cancel);
     break;
diff --git a/toolkit/components/satchel/nsFormFillController.h b/toolkit/components/satchel/nsFormFillController.h
--- a/toolkit/components/satchel/nsFormFillController.h
+++ b/toolkit/components/satchel/nsFormFillController.h
@@ -45,16 +45,17 @@ public:
   NS_DECL_NSIAUTOCOMPLETEINPUT
   NS_DECL_NSIFORMAUTOCOMPLETEOBSERVER
   NS_DECL_NSIDOMEVENTLISTENER
   NS_DECL_NSIMUTATIONOBSERVER
 
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsFormFillController, nsIFormFillController)
 
   nsresult Focus(nsIDOMEvent* aEvent);
+  nsresult KeyDown(nsIDOMEvent* aKeyEvent);
   nsresult KeyPress(nsIDOMEvent* aKeyEvent);
   nsresult MouseDown(nsIDOMEvent* aMouseEvent);
 
   nsFormFillController();
 
 protected:
   virtual ~nsFormFillController();
 
diff --git a/toolkit/content/tests/chrome/test_textbox_search.xul b/toolkit/content/tests/chrome/test_textbox_search.xul
--- a/toolkit/content/tests/chrome/test_textbox_search.xul
+++ b/toolkit/content/tests/chrome/test_textbox_search.xul
@@ -70,20 +70,20 @@ function doTests() {
 
   textbox.value = "foo";
   gExpectedValue = "";
   iconClick(clearIcon);
   is(textbox.value, "", "clicking the clear icon clears the textbox");
   ok(gExpectedValue == null, "search triggered when clearing the textbox with the clear icon");
 
   textbox.value = "foo";
-  gExpectedValue = "";
+  gExpectedValue = "foo";
   synthesizeKey("VK_ESCAPE", {});
   is(textbox.value, "", "escape key clears the textbox");
-  ok(gExpectedValue == null, "search triggered when clearing the textbox with the escape key");
+  ok(gExpectedValue == "foo", "search NOT triggered when clearing the textbox with the escape key");
 
   textbox.value = "bar";
   gExpectedValue = "bar";
   textbox.doCommand();
   ok(gExpectedValue == null, "search triggered with doCommand");
 
   gExpectedValue = "bar";
   synthesizeKey("VK_RETURN", {});
