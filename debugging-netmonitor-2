# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  181d06e8c7df7530d52ddf3f6a07cdf5c4f65e6c
Bug 1143224 - Try to queue up requests in netmonitor

diff --git a/browser/devtools/netmonitor/netmonitor-controller.js b/browser/devtools/netmonitor/netmonitor-controller.js
--- a/browser/devtools/netmonitor/netmonitor-controller.js
+++ b/browser/devtools/netmonitor/netmonitor-controller.js
@@ -553,31 +553,52 @@ NetworkEventsHandler.prototype = {
    *        The message received from the server.
    */
   _onNetworkEvent: function(aType, aPacket) {
     if (aPacket.from != this.webConsoleClient.actor) {
       // Skip events from different console actors.
       return;
     }
 
+    if (!this.events) {
+      this.events = new Map();
+    }
+
+
     let { actor, startedDateTime, method, url, isXHR } = aPacket.eventActor;
-    NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
-    window.emit(EVENTS.NETWORK_EVENT, actor);
+
+    this.events.set(actor, new Promise((resolve, reject) => {
+      console.log("FOOOO", actor);
+    }));
+
+    // this.events.set(actor, {startedDateTime, method, url, isXHR }})
+    // console.log(actor);
+    window.setTimeout(() => {
+      NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
+    }, 10000);
+  },
+
+  updateRequest: function(from, opts) {
+
   },
 
   /**
    * The "networkEventUpdate" message type handler.
    *
    * @param string aType
    *        Message type.
    * @param object aPacket
    *        The message received from the server.
    */
   _onNetworkEventUpdate: function(aType, aPacket) {
+    return;
     let actor = aPacket.from;
+
+    window.setTimeout(() => {
+
     if (!NetMonitorView.RequestsMenu.getItemByValue(actor)) {
       // Skip events from unknown actors.
       return;
     }
 
     switch (aPacket.updateType) {
       case "requestHeaders":
         this.webConsoleClient.getRequestHeaders(actor, this._onRequestHeaders);
@@ -629,25 +650,28 @@ NetworkEventsHandler.prototype = {
       case "eventTimings":
         NetMonitorView.RequestsMenu.updateRequest(aPacket.from, {
           totalTime: aPacket.totalTime
         });
         this.webConsoleClient.getEventTimings(actor, this._onEventTimings);
         window.emit(EVENTS.UPDATING_EVENT_TIMINGS, actor);
         break;
     }
+
+    }, 1040);
   },
 
   /**
    * Handles additional information received for a "requestHeaders" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestHeaders: function(aResponse) {
+    console.log("On request headers");
     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
       requestHeaders: aResponse
     });
     window.emit(EVENTS.RECEIVED_REQUEST_HEADERS, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "requestCookies" packet.
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -101,33 +101,33 @@ SideMenuWidget.prototype = {
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
     // needlessly expensive operations that may cause reflows):
-    let maintainScrollAtBottom =
-      // 1. The behavior should be enabled,
-      this.autoscrollWithAppendedItems &&
-      // 2. There shouldn't currently be any selected item in the list.
-      !this._selectedItem &&
-      // 3. The new item should be appended at the end of the list.
-      (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
-      // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+    // let maintainScrollAtBottom =
+    //   // 1. The behavior should be enabled,
+    //   this.autoscrollWithAppendedItems &&
+    //   // 2. There shouldn't currently be any selected item in the list.
+    //   !this._selectedItem &&
+    //   // 3. The new item should be appended at the end of the list.
+    //   (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
+    //   // 4. The list should already be scrolled at the bottom.
+    //   (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
-    if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
-    }
+    // if (maintainScrollAtBottom) {
+    //   this._list.scrollTop = this._list.scrollHeight;
+    // }
 
     return element;
   },
 
   /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
