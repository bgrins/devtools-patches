exporting patch:
# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1395870540 18000
#      Wed Mar 26 16:49:00 2014 -0500
# Node ID 75b34024bfa9d4ca509ce09cdd0eb8b1771c9894
# Parent ef7581951eb10e2b5505afbe2d64a2f92f465e3a
Pull itchpad into m-c - WIP

diff --git a/browser/devtools/itchpad/Makefile.in b/browser/devtools/itchpad/Makefile.in
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/Makefile.in
@@ -0,0 +1,9 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+itchpad_lib_FILES = $(wildcard $(srcdir)/lib/*)
+itchpad_lib_DEST = $(FINAL_TARGET)/modules/devtools/itchpad
+INSTALL_TARGETS += itchpad_lib
+
+include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/itchpad/chrome/content/file-icons-sheet@2x.png b/browser/devtools/itchpad/chrome/content/file-icons-sheet@2x.png
new file mode 100644
index 0000000000000000000000000000000000000000..39672e1fbefd907a0b3cf46be241487a3f1ce95d
GIT binary patch
literal 4138
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

diff --git a/browser/devtools/itchpad/chrome/content/icon-sample.png b/browser/devtools/itchpad/chrome/content/icon-sample.png
new file mode 100644
index 0000000000000000000000000000000000000000..3b0026eedbdf089e1d5a8b031ccebff5156dcfe2
GIT binary patch
literal 3659
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
L)*e%9K}h^RUkX;G

diff --git a/browser/devtools/itchpad/chrome/content/itchpad-loader.js b/browser/devtools/itchpad/chrome/content/itchpad-loader.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/chrome/content/itchpad-loader.js
@@ -0,0 +1,13 @@
+const Cu = Components.utils;
+const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+const require = devtools.require;
+const Itchpad = require("itchpad/itchpad");
+const { Projects } = require("itchpad/project");
+
+window.addEventListener("DOMContentLoaded", function onDOMReady() {
+  window.removeEventListener("DOMContentLoaded", onDOMReady, true);
+  Projects.defaultProject().then(project => {
+    let iframe = document.getElementById("itchpad-iframe");
+    let itchpad = Itchpad.Itchpad(iframe, project);
+  }).then(null, console.error);
+}, true);
diff --git a/browser/devtools/itchpad/chrome/content/itchpad-loader.xul b/browser/devtools/itchpad/chrome/content/itchpad-loader.xul
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/chrome/content/itchpad-loader.xul
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<!DOCTYPE window [
+<!ENTITY % toolboxDTD SYSTEM "chrome://browser/locale/devtools/toolbox.dtd" >
+ %toolboxDTD;
+]>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        id="devtools-itchpad-window"
+        macanimationtype="document"
+        fullscreenbutton="true"
+        windowtype="devtools:itchpad"
+        width="900" height="320"
+        persist="screenX screenY width height sizemode"
+        windowtitle="itchpad window">
+
+<script type="application/javascript;version=1.8" src="chrome://browser/content/devtools/itchpad-loader.js"></script>
+
+  <commandset id="toolbox-commandset">
+    <command id="itchpad-cmd-close" oncommand="window.close();"/>
+  </commandset>
+
+  <keyset id="itchpad-keyset">
+    <key id="itchpad-key-close"
+         key="&closeCmd.key;"
+         command="itchpad-cmd-close"
+         modifiers="accel"/>
+  </keyset>
+
+  <iframe id="itchpad-iframe" flex="1" forceOwnRefreshDriver=""></iframe>
+</window>
diff --git a/browser/devtools/itchpad/chrome/content/itchpad.css b/browser/devtools/itchpad/chrome/content/itchpad.css
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/chrome/content/itchpad.css
@@ -0,0 +1,231 @@
+:root {
+  color: #18191a;
+}
+
+.plugin-hidden {
+  display: none;
+}
+
+/* XXX: Show menubar inline for easier debugging */
+#itchpad-menubar {
+  -moz-appearance: none;
+  border-bottom: solid 1px #ccc;
+}
+.sources-tree {
+  overflow:auto;
+  -moz-user-focus: true;
+}
+
+.sources-tree input {
+  margin: 2px;
+  border: 1px solid gray;
+}
+
+#itchpad-toolbar {
+  min-height: 22px;
+  height: 22px;
+  background: rgb(237, 237, 237);
+}
+#main-deck .sources-tree {
+  background: rgb(225, 225, 225);
+}
+
+#main-deck .sources-tree .side-menu-widget-item {
+  color: #18191A;
+}
+
+#main-deck .sources-tree .side-menu-widget-item .file-label {
+  vertical-align: middle;
+  display: inline-block;
+}
+#main-deck .sources-tree .side-menu-widget-item .file-icon {
+  content: "";
+  display: inline-block;
+  background: url(file-icons-sheet@2x.png);
+  background-size: 140px 15px;
+  background-repeat: no-repeat;
+  width: 20px;
+  height: 15px;
+  vertical-align: middle;
+  background-position: -40px 0;
+}
+
+#main-deck .sources-tree .side-menu-widget-item .file-icon.icon-none {
+  display: none;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-css {
+  background-position: 0 0;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-js {
+  background-position: -20px 0;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-html {
+  background-position: -40px 0;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-file {
+  background-position: -60px 0;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-folder {
+  background-position: -80px 0;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-img {
+  background-position: -100px 0;
+}
+#main-deck .sources-tree .side-menu-widget-item .icon-manifest {
+  background-position: -120px 0;
+}
+
+#main-deck .sources-tree .side-menu-widget-item:hover {
+  background: rgba(0, 0, 0, .05);
+  cursor: pointer;
+}
+
+#main-deck .sources-tree .side-menu-widget-item {
+  border: none;
+  box-shadow: none;
+  line-height: 24px;
+  vertical-align: middle;
+}
+
+#main-deck .sources-tree .side-menu-widget-item.selected {
+  background: #509FD7;
+  color: #F5F7FA;
+  outline: none;
+}
+
+#main-deck .sources-tree .side-menu-widget-group-title,
+#main-deck .sources-tree .side-menu-widget-group-title.selected,
+#main-deck .sources-tree .side-menu-widget-group-title:hover {
+  background: #B4D7EB;
+  color: #222;
+  font-weight: bold;
+  font-size: 1.05em;
+  cursor: default;
+  line-height: 35px;
+}
+
+.project-name-label {
+  font-weight: bold;
+  padding-left: 10px;
+}
+.project-version-label {
+  color: #666;
+  padding-left: 5px;
+  font-size: .9em;
+}
+.project-image {
+  max-height: 28px;
+  margin-left: -.5em;
+  vertical-align: middle;
+}
+
+#main-deck .sources-tree li.child:only-child .side-menu-widget-group-title .expander {
+  display: none;
+}
+#main-deck .sources-tree .side-menu-widget-item .expander {
+  width: 16px;
+  padding: 0;
+}
+
+#sources-tabs > tabs > tab > image {
+  padding-right: 4px;
+}
+
+.editor-image {
+  padding: 10px;
+}
+.tree-collapsed .children {
+  display: none;
+}
+
+#itchpad-toolbar textbox {
+  margin: 0;
+}
+
+#pair-choice > toolbarbutton {
+  text-shadow: none;
+  min-height: 24px;
+  padding: 0px 4px;
+}
+
+.itchpad-file-label {
+  font-weight: bold;
+  padding-left: 29px;
+  vertical-align: middle;
+}
+
+.results-panel-item-match {
+  font-weight: bold;
+  background: #ddf;
+}
+
+.refresh-button {
+  list-style-image: url("chrome://browser/skin/sync-16.png");
+}
+
+.settings-button {
+  list-style-image: url("chrome://browser/skin/devtools/option-icon.png");
+  -moz-image-region: rect(0px 16px 16px 0px);
+}
+
+.source-live {
+  list-style-image: url("chrome://browser/skin/devtools/command-responsivemode.png");
+  -moz-image-region: rect(0px, 16px, 16px, 0px);
+}
+.source-live:hover {
+  -moz-image-region: rect(0px, 32px, 16px, 16px);
+}
+.source-live:hover:active {
+  -moz-image-region: rect(0px, 48px, 16px, 32px);
+}
+.source-live[selected=true] {
+  -moz-image-region: rect(0px, 64px, 16px, 48px);
+}
+
+.source-project {
+  list-style-image: url("chrome://browser/skin/devtools/command-tilt.png");
+  -moz-image-region: rect(0px, 16px, 16px, 0px);
+}
+.source-project:hover {
+  -moz-image-region: rect(0px, 32px, 16px, 16px);
+}
+
+.source-project:hover:active {
+  -moz-image-region: rect(0px, 48px, 16px, 32px);
+}
+
+.source-project[checked=true] {
+  -moz-image-region: rect(0px, 64px, 16px, 48px);
+}
+
+#pair-choice:not([aspects~="project"]) > #pair-project {
+  display: none;
+}
+
+#pair-choice:not([aspects~="live"]) > #pair-live {
+  display: none;
+}
+
+.pane-toggle {
+  background: none;
+  box-shadow: none;
+  border: none;
+  list-style-image: url("chrome://browser/skin/devtools/debugger-collapse.png");
+  -moz-image-region: rect(0px,16px,16px,0px);
+}
+
+.pane-toggle[pane-collapsed] {
+  list-style-image: url("chrome://browser/skin/devtools/debugger-expand.png");
+}
+
+.pane-toggle:active {
+  -moz-image-region: rect(0px,32px,16px,16px);
+}
+
+
+/* Plugins */
+
+.itchpad-basic-display {
+  padding: 0 3px;
+}
+
diff --git a/browser/devtools/itchpad/chrome/content/itchpad.xul b/browser/devtools/itchpad/chrome/content/itchpad.xul
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/chrome/content/itchpad.xul
@@ -0,0 +1,108 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="itchpad.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/devtools/widgets.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/devtools/debugger.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/devtools/common.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/devtools/widgets.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/devtools/debugger.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/devtools/markup-view.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/devtools/markup-view.css" type="text/css"?>
+
+<?xul-overlay href="chrome://global/content/editMenuOverlay.xul"?>
+
+<!DOCTYPE window [
+<!ENTITY % scratchpadDTD SYSTEM "chrome://browser/locale/devtools/scratchpad.dtd" >
+ %scratchpadDTD;
+<!ENTITY % editMenuStrings SYSTEM "chrome://global/locale/editMenuOverlay.dtd">
+%editMenuStrings;
+<!ENTITY % sourceEditorStrings SYSTEM "chrome://browser/locale/devtools/sourceeditor.dtd">
+%sourceEditorStrings;
+]>
+
+<window id="itchpad-window"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" class="theme-body"
+        title="Itchpad"
+        windowtype="devtools:itchpad"
+        macanimcationtype="document"
+        fullscreenbutton="true"
+        screenX="4" screenY="4"
+        width="640" height="480"
+        persist="screenX screenY width height sizemode">
+
+  <commandset id="itchpad-commandset" />
+  <commandset id="editMenuCommands"/>
+  <keyset id="itchpad-keyset" />
+  <keyset id="editMenuKeys"/>
+
+  <!-- XXX: Let plugins declare their own menu items -->
+  <menubar id="itchpad-menubar">
+    <menu id="file-menu" label="&fileMenu.label;" accesskey="&fileMenu.accesskey;">
+      <menupopup id="file-menu-popup" />
+    </menu>
+
+    <menu id="edit-menu" label="&editMenu.label;"
+          accesskey="&editMenu.accesskey;">
+      <menupopup id="edit-menu-popup">
+        <menuitem id="menu_undo"/>
+        <menuitem id="menu_redo"/>
+        <menuseparator/>
+        <menuitem id="menu_cut"/>
+        <menuitem id="menu_copy"/>
+        <menuitem id="menu_paste"/>
+        <menuseparator/>
+        <menuitem id="menu_selectAll"/>
+        <menuseparator/>
+        <menuitem id="menu_find"/>
+        <menuitem id="menu_findAgain"/>
+      </menupopup>
+    </menu>
+  </menubar>
+
+
+  <popupset>
+    <menupopup id="directory-menu-popup">
+    </menupopup>
+  </popupset>
+
+  <script type="application/javascript" src="chrome://global/content/globalOverlay.js"/>
+  <script type="application/javascript;version=1.8" src="chrome://browser/content/devtools/theme-switching.js"></script>
+
+  <deck id="main-deck" flex="1">
+    <vbox flex="1" id="source-deckitem">
+      <hbox id="sources-body" flex="1">
+        <vbox width="250">
+          <vbox id="sources" flex="1">
+          </vbox>
+          <toolbar id="project-toolbar" class="devtools-toolbar" hidden="true"></toolbar>
+        </vbox>
+        <splitter id="source-editor-splitter" class="devtools-side-splitter"/>
+        <vbox id="shells" flex="4">
+          <toolbar id="itchpad-toolbar" class="devtools-toolbar">
+            <hbox id="plugin-toolbar-left"/>
+            <spacer flex="1"/>
+            <hbox id="plugin-toolbar-right"/>
+          </toolbar>
+          <box id="shells-deck-container" flex="4"></box>
+          <toolbar id="itchpad-toolbar-bottom" class="devtools-toolbar">
+          </toolbar>
+        </vbox>
+        <splitter id="sidebar-splitter" class="devtools-side-splitter"/>
+        <vbox id="sidebar-box" class="generic-toggled-side-pane" width="250" hidden="true">
+          <tabbox id="sidebar" class="devtools-sidebar-tabs"
+                  flex="1">
+            <tabs hidden="true"/>
+            <tabpanels flex="1"/>
+          </tabbox>
+        </vbox>
+      </hbox>
+    </vbox>
+    <vbox flex="1" id="project-settings" class="theme-body">
+      <toolbar id="project-settings-toolbar" class="devtools-toolbar">
+        <toolbarbutton id="project-settings-close" class="devtools-closebutton"></toolbarbutton>
+        <h1>Project Settings: <span id="project-settings-name"></span></h1>
+      </toolbar>
+      <hbox id="settings-hbox" flex="1" class="theme-body">
+      </hbox>
+    </vbox>
+  </deck>
+</window>
diff --git a/browser/devtools/itchpad/chrome/content/readdir.js b/browser/devtools/itchpad/chrome/content/readdir.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/chrome/content/readdir.js
@@ -0,0 +1,68 @@
+importScripts("resource://gre/modules/osfile.jsm");
+
+function readDir(path, ignore, maxDepth = Infinity) {
+  let ret = {};
+
+  let set = new Set();
+
+  let info = OS.File.stat(path);
+  set.add({
+    path: path,
+    name: info.name,
+    isDir: info.isDir,
+    isSymLink: info.isSymLink,
+    depth: 0
+  });
+
+  for (let info of set) {
+    let children = [];
+
+    if (info.isDir && !info.isSymLink) {
+      if (info.depth > maxDepth) {
+        continue;
+      }
+
+      let iterator = new OS.File.DirectoryIterator(info.path);
+      try {
+        for (let child in iterator) {
+          if (ignore && child.name.match(ignore)) {
+            continue;
+          }
+
+          children.push(child.path);
+          set.add({
+            path: child.path,
+            name: child.name,
+            isDir: child.isDir,
+            isSymLink: child.isSymLink,
+            depth: info.depth + 1
+          });
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    ret[info.path] = {
+      name: info.name,
+      isDir: info.isDir,
+      isSymLink: info.isSymLink,
+      depth: info.depth,
+      children: children,
+    };
+  }
+
+  return ret;
+};
+
+onmessage = function (event) {
+  try {
+    let {path, ignore, depth} = event.data;
+    let message = readDir(path, ignore, depth);
+    postMessage(message);
+  } catch(ex) {
+    console.log(ex);
+  }
+};
+
+
diff --git a/browser/devtools/itchpad/lib/appmanager.js b/browser/devtools/itchpad/lib/appmanager.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/appmanager.js
@@ -0,0 +1,15 @@
+const tabs = require("sdk/tabs");
+const data = require("sdk/self").data;
+
+exports.modifyAppManager = function() {
+  tabs.on("ready", (tab) => {
+    if (tab.url == "about:app-manager") {
+      tab.attach({
+        contentScriptFile: data.url("app-manager-mod.js"),
+        onMessage: (msg) => {
+          
+        }
+      });
+    }
+  });
+}
diff --git a/browser/devtools/itchpad/lib/editors.js b/browser/devtools/itchpad/lib/editors.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/editors.js
@@ -0,0 +1,143 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const promise = require("itchpad/helpers/promise");
+
+const Editor  = require("devtools/sourceeditor/editor");
+
+
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+var ItchEditor = Class({
+  extends: EventTarget,
+
+  toString: function() {
+    return this.label || "";
+  },
+
+  initialize: function(document) {
+    this.doc = document;
+    this.label = "";
+    this.elt = this.doc.createElement("vbox");
+    this.elt.setAttribute("flex", "1");
+    this.elt.editor = this;
+    this.toolbar = this.doc.querySelector("#itchpad-toolbar");
+  },
+
+  setToolbarVisibility: function() {
+    if (this.hidesToolbar) {
+      this.toolbar.setAttribute("hidden", "true");
+    } else {
+      this.toolbar.removeAttribute("hidden");
+    }
+  },
+
+  load: function(resource) {
+    return promise.resolve();
+  },
+
+  focus: function() {
+    return promise.resolve();
+  }
+});
+exports.ItchEditor = ItchEditor;
+
+var MODE_CATEGORIES = {};
+
+MODE_CATEGORIES[Editor.modes.text.name] = "txt";
+MODE_CATEGORIES[Editor.modes.js.name] = "js";
+MODE_CATEGORIES[Editor.modes.html.name] = "html";
+MODE_CATEGORIES[Editor.modes.css.name] = "css";
+
+var TextEditor = Class({
+  extends: ItchEditor,
+
+  get extraKeys() {
+    let extraKeys = {};
+
+
+    // Copy all of the registered keys into extraKeys object, to notify CodeMirror
+    // that it should be ignoring these keys
+    [...this.doc.querySelectorAll("#itchpad-keyset key")].forEach((key) => {
+      let keyUpper = key.getAttribute("key").toUpperCase();
+      let toolModifiers = key.getAttribute("modifiers");
+      let modifiers = {
+        alt: toolModifiers.contains("alt"),
+        shift: toolModifiers.contains("shift"),
+      };
+      extraKeys[Editor.accel(keyUpper, modifiers)] = () => {
+        let event = this.doc.createEvent('Event');
+        event.initEvent('command', true, true);
+        let command = this.doc.querySelector("#" + key.getAttribute("command"));
+        command.dispatchEvent(event);
+      };
+    });
+    return extraKeys;
+  },
+
+  get category() {
+    return MODE_CATEGORIES[this.editor.getMode().name];
+  },
+
+  initialize: function(document, mode=Editor.modes.text) {
+    ItchEditor.prototype.initialize.call(this, document);
+    this.label = mode.name;
+    this.editor = new Editor({
+      mode: mode,
+      lineNumbers: true,
+      extraKeys: this.extraKeys
+    });
+
+    this.appended = this.editor.appendTo(this.elt);
+  },
+
+  load: function(resource) {
+    return this.appended.then(() => {
+      return resource.load();
+    }).then(text => {
+      this.editor.setText(text);
+      this.editor.setClean();
+      emit(this, "load");
+    }).then(null, console.error);
+  },
+
+  save: function(resource) {
+    return resource.save(this.editor.getText()).then(() => {
+      this.editor.setClean();
+      emit(this, "save", resource);
+    });
+  },
+
+  focus: function(resource) {
+    return this.appended.then(() => {
+      this.editor.focus();
+    });
+  }
+});
+
+
+function textMode(mode) {
+  return function(document) { return TextEditor(document, mode); }
+}
+
+exports.TextEditor = TextEditor;
+exports.JSEditor = textMode(Editor.modes.js);
+exports.CSSEditor = textMode(Editor.modes.css);
+exports.HTMLEditor = textMode(Editor.modes.html);
+
+const categoryMap = {
+  "txt": exports.TextEditor,
+  "html": exports.HTMLEditor,
+  "xml": exports.HTMLEditor,
+  "css": exports.CSSEditor,
+  "js": exports.JSEditor,
+  "json": exports.JSEditor
+};
+
+function EditorTypeForResource(resource) {
+  return categoryMap[resource.contentCategory] || TextEditor;
+}
+
+exports.EditorTypeForResource = EditorTypeForResource;
diff --git a/browser/devtools/itchpad/lib/event/scope.js b/browser/devtools/itchpad/lib/event/scope.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/event/scope.js
@@ -0,0 +1,76 @@
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+
+var Scope = Class({
+  initialize: function(owner) {
+    this.owner = owner;
+  },
+
+  on: function(target, event, handler) {
+    this.listeners = this.listeners || [];
+    this.listeners.push({
+      target: target,
+      event: event,
+      handler: handler
+    });
+    target.on(event, handler);
+  },
+
+  off: function(t, e, h) {
+    if (!this.listeners) return;
+    this.listeners = this.listeners.filter(({ target, event, handler }) => {
+      return !(target === t && event === e && handler === h);
+    });
+    target.off(event, handler);
+  },
+
+  clear: function(clearTarget) {
+    if (!this.listeners) return;
+    this.listeners = this.listeners.filter(({ target, event, handler }) => {
+      if (target === clearTarget) {
+        target.off(event, handler);
+        return false;
+      }
+      return true;
+    });
+  },
+  destroy: function() {
+    this.owner = undefined;
+    if (!this.listeners) return;
+    this.listeners.forEach(({ target, event, handler }) => {
+      target.off(event, handler);
+    });
+    this.listeners = undefined;
+  }
+});
+
+var scopes = new WeakMap();
+function scope(owner) {
+  if (!scopes.has(owner)) {
+    let scope = new Scope(owner);
+    scopes.set(owner, scope);
+    return scope;
+  }
+  return scopes.get(owner);
+}
+exports.scope = scope;
+
+exports.on = function(owner, target, event, handler) {
+  if (!target) return;
+  scope(owner).on(target, event, handler);
+}
+
+exports.off = function(owner, target, event, handler) {
+  if (!target) return;
+  scope(owner).off(target, event, handler);
+}
+
+exports.forget = function(owner, target) {
+  scope(owner).clear(target);
+}
+
+exports.done = function(owner) {
+  scope(owner).destroy();
+  scopes.delete(owner);
+}
+
diff --git a/browser/devtools/itchpad/lib/helpers/file-picker.js b/browser/devtools/itchpad/lib/helpers/file-picker.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/file-picker.js
@@ -0,0 +1,57 @@
+const { Cu, Cc, Ci } = require("chrome");
+const { FileUtils } = Cu.import("resource://gre/modules/FileUtils.jsm", {});
+const promise = require("itchpad/helpers/promise");
+const { merge } = require("sdk/util/object");
+
+function showPicker(options) {
+  let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
+  if (options.directory) {
+    try {
+      fp.displayDirectory = FileUtils.File(options.directory);
+    } catch(ex) {
+      console.warn(ex);
+    }
+  }
+
+  if (options.defaultName) {
+    fp.defaultString = options.defaultName;
+  }
+
+  fp.init(options.window, options.title, options.mode);
+  let deferred = promise.defer();
+  fp.open({
+    done: function(res) {
+      if (res === Ci.nsIFilePicker.returnOK || res === Ci.nsIFilePicker.returnReplace) {
+        deferred.resolve(fp.file.path);
+      } else {
+        deferred.reject();
+      }
+    }
+  });
+  return deferred.promise;
+}
+exports.showPicker = showPicker;
+
+function showSave(options) {
+  return showPicker(merge({
+    title: "Select a File",
+    mode: Ci.nsIFilePicker.modeSave
+  }, options));
+}
+exports.showSave = showSave;
+
+function showOpen(options) {
+  return showPicker(merge({
+    title: "Open a File",
+    mode: Ci.nsIFilePicker.modeOpen
+  }, options));
+}
+exports.showOpen = showOpen;
+
+function showOpenFolder(options) {
+  return showPicker(merge({
+    title: "Select a Folder",
+    mode: Ci.nsIFilePicker.modeGetFolder
+  }, options));
+}
+exports.showOpenFolder = showOpenFolder;
diff --git a/browser/devtools/itchpad/lib/helpers/osfile.js b/browser/devtools/itchpad/lib/helpers/osfile.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/osfile.js
@@ -0,0 +1,3 @@
+const { Cu } = require("chrome");
+const { OS } = Cu.import("resource://gre/modules/osfile.jsm", {});
+module.exports = OS;
diff --git a/browser/devtools/itchpad/lib/helpers/promise.js b/browser/devtools/itchpad/lib/helpers/promise.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/promise.js
@@ -0,0 +1,5 @@
+// ... until sdk/core/promise uses Promise.jsm...
+
+const { Cu } = require("chrome");
+const { Promise } = Cu.import("resource://gre/modules/Promise.jsm", {});
+module.exports = Promise;
diff --git a/browser/devtools/itchpad/lib/helpers/task.js b/browser/devtools/itchpad/lib/helpers/task.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/helpers/task.js
@@ -0,0 +1,5 @@
+const { Cu } = require("chrome");
+
+const { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
+
+module.exports = Task;
diff --git a/browser/devtools/itchpad/lib/itchpad.js b/browser/devtools/itchpad/lib/itchpad.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/itchpad.js
@@ -0,0 +1,556 @@
+const { Class } = require("sdk/core/heritage");
+
+const { Project } = require("itchpad/project");
+const { PageCollection } = require("itchpad/page");
+const { TreeView } = require("itchpad/tree");
+const { ShellDeck } = require("itchpad/shells");
+const { Resource } = require("itchpad/stores/base");
+const { ResourceMap, Pair } = require("itchpad/resource-map");
+const { registeredPlugins } = require("itchpad/plugins/core");
+const { EventTarget } = require("sdk/event/target");
+const { on, forget } = require("itchpad/event/scope");
+const { emit } = require("sdk/event/core");
+const { merge } = require("sdk/util/object");
+const promise = require("itchpad/helpers/promise");
+const { ToolSidebar } = require("devtools/framework/sidebar");
+
+const { Cc, Ci, Cu } = require("chrome");
+const { ViewHelpers } = Cu.import("resource:///modules/devtools/ViewHelpers.jsm", {});
+Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
+
+const ITCHPAD_URL = "chrome://browser/content/devtools/itchpad.xul"
+
+
+
+// Uncomment to get logging of addon events.
+require("itchpad/plugins/logging/lib/logging");
+
+require("itchpad/plugins/apply/lib/apply");
+require("itchpad/plugins/dirty/lib/dirty");
+require("itchpad/plugins/delete/lib/delete");
+require("itchpad/plugins/new/lib/new");
+require("itchpad/plugins/save/lib/save");
+require("itchpad/plugins/open/lib/open");
+require("itchpad/plugins/style/lib/style");
+// require("itchpad/plugins/target-chooser/lib/target-chooser");
+// require("itchpad/plugins/variable-sidebar/lib/variable-sidebar");
+require("itchpad/plugins/notify/lib/notify");
+require("itchpad/plugins/fuzzy-search/lib/plugin");
+require("itchpad/plugins/image-view/lib/plugin");
+require("itchpad/plugins/manifest-save/lib/manifest-save");
+require("itchpad/plugins/project-dirs/lib/project-dirs");
+require("itchpad/plugins/project-refresh/lib/project-refresh");
+// require("itchpad/plugins/project-live-preview/lib/project-live-preview");
+require("itchpad/plugins/project-settings/lib/project-settings");
+require("itchpad/plugins/drag-drop-new/lib/drag-drop-new");
+require("itchpad/plugins/find-and-replace/lib/plugin");
+require("itchpad/plugins/app-manager/lib/plugin");
+require("itchpad/plugins/status-bar/lib/plugin");
+
+/**
+ * This is the main class tying together an instance of the pad.  It is
+ * created in itchpad.xul.
+ *
+ * It mediates access to a few resources:
+ * - The list of plugins for this instance.
+ * - The tree view that views file trees.
+ * - The ShellDeck that contains all editors for this instance.
+ * - The Project that includes local resources for the instance.
+ * - The list of Live Stores for the instance.
+ * - The ResourceMap that ties Live resources to Project resources.
+ * - The Target associated with this instance, if any.
+ * - The toolbox associated with this instance, if any.
+ */
+var Itchpad = Class({
+  extends: EventTarget,
+
+  initialize: function(iframe, project) {
+    this.iframe = iframe;
+    this.project = project;
+
+    this.stores = new Set();
+    this.onNodeSelection = this.onNodeSelection.bind(this);
+    this.onEditorCreated = this.onEditorCreated.bind(this);
+    this.onEditorActivated = this.onEditorActivated.bind(this);
+    this.updateEditorMenuItems = this.updateEditorMenuItems.bind(this);
+
+    return this.load();
+  },
+
+  load: function() {
+    let deferred = promise.defer();
+
+    let domReady = () => {
+      this.onLoad();
+      deferred.resolve();
+    };
+
+    let domHelper = new DOMHelpers(this.iframe.contentWindow);
+    domHelper.onceDOMReady(domReady);
+
+    this.iframe.setAttribute("src", ITCHPAD_URL);
+
+    return deferred.promise;
+  },
+
+  onLoad: function() {
+    this.document = this.iframe.contentDocument;
+    this.window = this.iframe.contentWindow;
+
+    this.buildSidebar();
+
+    this.window.addEventListener("unload", this.destroy.bind(this));
+
+    // Editor management
+    this.shells = new ShellDeck(this.document, this);
+    this.shells.on("editor-created", this.onEditorCreated);
+    this.shells.on("editor-activated", this.onEditorActivated);
+
+    let shellContainer = this.document.querySelector("#shells-deck-container");
+    shellContainer.appendChild(this.shells.elt);
+
+    let popup = this.document.querySelector("#edit-menu-popup");
+    popup.addEventListener("popupshowing", this.updateEditorMenuItems);
+
+    // Store/Resource management
+    this.resourceMap = new ResourceMap();
+
+    if (!this.project) {
+      this.project = new Project({
+        id: "Test",
+        name: "App",
+        directories: [],
+        openFiles: []
+      });
+    }
+    this.setProject(this.project);
+    this.setPage(new PageCollection());
+
+    this.initPlugins();
+  },
+
+  buildSidebar: function() {
+    // Create the sources sidebar
+    this.projectTree = new CollectionTree(this.document, {
+      nodeVisible: this.nodeVisible.bind(this),
+      nodeFormatter: this.formatNode.bind(this)
+    });
+    this.projectTree.on("selection", this.onNodeSelection);
+
+    let sourcesBox = this.document.querySelector("#sources");
+    sourcesBox.appendChild(this.projectTree.elt);
+
+    // Plugin/inspection sidebar
+    let tabbox = this.document.querySelector("#sidebar");
+    this.sidebar = new ToolSidebar(tabbox, this, "itchpad");
+    ViewHelpers.togglePane({
+      visible: false,
+      delayed: false,
+      animated: false
+    }, this.document.querySelector("#sidebar-box"));
+  },
+
+  initPlugins: function() {
+    this.commands = this.document.querySelector("#itchpad-commandset");
+    this.commands.addEventListener("command", (evt) => {
+      evt.stopPropagation();
+      evt.preventDefault();
+      this.pluginDispatch("onCommand", evt.target.id, evt.target);
+    });
+    this.pluginMethods = {};
+    this.loadPlugins();
+  },
+
+  updateEditorMenuItems: function() {
+    this.window.goUpdateGlobalEditMenuItems();
+    this.window.goUpdateGlobalEditMenuItems();
+    let commands = ['cmd_undo', 'cmd_redo', 'cmd_delete', 'cmd_findAgain'];
+    commands.forEach(this.window.goUpdateCommand);
+  },
+
+  destroy: function() {
+    this._plugins.forEach(plugin => { plugin.destroy(); });
+  },
+
+  // Set the current project viewed by the itchpad.
+  setProject: function(project) {
+    this.project = project;
+    this.resourceMap.setProject(project);
+    this.projectTree.setCollection(project);
+  },
+
+  setProjectToSinglePath: function(path, opts) {
+    let existingPaths = [...this.projectTree.models].map(model=>model.path);
+    console.log(
+      "Setting project to single path: " + path,
+      "Existing paths: ", existingPaths.join(", ")
+    );
+    this.project.customOpts = opts;
+    this.project.projectType = "APP_MANAGER";
+    this.project.removePaths(existingPaths);
+    this.project.addPath(path);
+    this.project.save();
+  },
+
+  setPage: function(page) {
+    this.page = page;
+    this.resourceMap.setPage(page);
+  },
+
+  openResource: function(resource) {
+    let pair = this.resourceMap.pair(resource);
+    let shell = this.shells.open(pair, resource);
+
+    this.projectTree.select(resource);
+  },
+
+  // When a node is selected in the tree, open its associated editor.
+  onNodeSelection: function(resource) {
+    // XXX: Should check to see if there is a suitable editor rather
+    // than blacklisting these types
+    if (resource.isDir && resource.parent) {
+      return;
+    }
+    this.openResource(resource);
+  },
+
+  /**
+   * Plugin UI commands.  These aren't really great, we should rethink these.
+   */
+
+  createElement: function(type, options) {
+    let elt = this.document.createElement(type);
+
+    let parent;
+
+    for (let opt in options) {
+      if (opt === "command") {
+        let command = typeof(options.command) === "string" ? options.command : options.command.id;
+        elt.setAttribute("command", command);
+      } else if (opt === "parent") {
+        continue;
+      } else {
+        elt.setAttribute(opt, options[opt]);
+      }
+    }
+
+    if (options.parent) {
+      let parent = options.parent;
+      if (typeof(parent) === "string") {
+        parent = this.document.querySelector(parent);
+      }
+      parent.appendChild(elt);
+    }
+
+    return elt;
+  },
+
+  addCommand: function(definition) {
+    let command = this.document.createElement("command");
+    command.setAttribute("id", definition.id);
+    if (definition.key) {
+      let key = this.document.createElement("key");
+      key.id = "key_" + definition.id;
+
+      let keyName = definition.key;
+      if (keyName.startsWith("VK_")) {
+        key.setAttribute("keycode", keyName);
+      } else {
+        key.setAttribute("key", keyName);
+      }
+      key.setAttribute("modifiers", definition.modifiers);
+      key.setAttribute("command", definition.id);
+      this.document.getElementById("itchpad-keyset").appendChild(key);
+    }
+    command.setAttribute("oncommand", "void(0);"); // needed. See bug 371900
+    this.document.getElementById("itchpad-commandset").appendChild(command);
+    return command;
+  },
+
+
+  createMenuItem: function(options) {
+    return this.createElement("menuitem", options);
+  },
+
+  createToolbarGroup: function(options) {
+    return this.createElement("hbox", merge({
+      class: "devtools-toolbarbutton-group"
+    }, options));
+  },
+
+  createToolbarButton: function(options) {
+    return this.createElement("toolbarbutton", merge({
+      class: "devtools-toolbarbutton"
+    }, options));
+  },
+
+  addSidebar: function(name, url) {
+    let deferred = promise.defer();
+
+    this.sidebar.once(name + "-ready", () => {
+      deferred.resolve(this.sidebar.getWindowForTab(name));
+    });
+    this.sidebar.addTab(name, url, false);
+
+    return deferred.promise;
+  },
+
+  showSidebar: function(name) {
+    this.sidebar.select(name);
+    let sidebar = this.document.getElementById("sidebar-box");
+    ViewHelpers.togglePane({ visible: true, animated: true, delayed: true }, sidebar);
+  },
+
+  hideSidebar: function() {
+    let sidebar = this.document.getElementById("sidebar-box");
+    ViewHelpers.togglePane({ visible: false, animated: true, delayed: true }, sidebar);
+  },
+
+  loadPlugins: function() {
+    this._plugins = [];
+
+    for (let plugin of registeredPlugins) {
+      try {
+        this._plugins.push(plugin(this));
+      } catch(ex) {
+        console.exception(ex);
+      }
+    }
+
+    this.pluginDispatch("lateInit");
+  },
+
+  getPlugin: function(pluginType) {
+    for (let plugin of this.plugins) {
+      if (plugin.constructor === pluginType) {
+        return plugin;
+      }
+    }
+    return null;
+  },
+
+  get plugins() {
+    if (!this._plugins) {
+      console.log("plugins requested before _plugins was set");
+      return [];
+    }
+    return this._plugins.filter(plugin => {
+      return !this.project.projectType ||
+             !plugin.projectType ||
+             this.project.projectType === plugin.projectType;
+    });
+  },
+
+  onEditorCreated: function(editor) {
+    this.plugins.forEach(plugin => plugin.onEditorCreated(editor));
+    this._editorListen(editor, "change", "onEditorChange");
+    this._editorListen(editor, "cursorActivity", "onEditorCursorActivity");
+    this._containerListen(editor, "load", "onEditorLoad");
+    this._containerListen(editor, "save", "onEditorSave");
+  },
+
+  onEditorActivated: function(editor) {
+    editor.setToolbarVisibility();
+    this.plugins.forEach(plugin => plugin.onEditorActivated(editor));
+  },
+
+  /**
+   * Call a method on all plugins that implement the method.
+   */
+  pluginDispatch: function(handler, ...args) {
+    this.plugins.forEach(plugin => {
+      try {
+        if (handler in plugin) plugin[handler](...args);
+      } catch(ex) {
+        console.error(ex);
+      }
+    })
+  },
+
+  _containerListen: function(editor, event, handler) {
+    editor.on(event, (...args) => {
+      this.pluginDispatch(handler, editor, ...args);
+    });
+  },
+
+  _editorListen: function(editor, event, handler) {
+    if (!editor.editor) {
+      return;
+    }
+    editor.editor.on(event, (...args) => {
+      this.pluginDispatch(handler, editor, ...args);
+    });
+  },
+
+  /**
+   * Set the current devtools target for the pad.
+   */
+  setTarget: function(target, own=false) {
+    if (target === this.target) {
+      return promise.resolve();
+    }
+
+    if (this.ownsTarget && this.target) {
+      this.target.destroy();
+    }
+
+    this._webConsolePromise = null;
+    this.ownsTarget = own;
+    this.target = target;
+
+    let remote = target ? target.makeRemote() : promise.resolve();
+
+    return remote.then(() => {
+      this.page.setTarget(target);
+      emit(this, "target-changed");
+    }).then(null, console.error);
+  },
+
+  /**
+   * Get a WebConsoleClient for communicating with the current target.
+   */
+  getWebConsoleClient: function() {
+    if (this._webConsolePromise) {
+      return this._webConsolePromise;
+    }
+    let deferred = promise.defer();
+    this.target.client.attachConsole(this.target.form.consoleActor, [], (response, consoleClient) => {
+      try {
+        if (response.error) {
+          deferred.reject(response.error);
+          return;
+        }
+        deferred.resolve(consoleClient);
+      } catch(ex) {
+        console.error(ex);
+      }
+    });
+    this._webConsolePromise = deferred.promise;
+    return deferred.promise
+  },
+
+  /**
+   * Find a shell for an editor, pair, or resource.
+   */
+  shellFor: function(resource) {
+    let pair = this.pairFor(resource);
+    return this.shells.shellFor(pair);
+  },
+
+  /**
+   * Returns the Editor for a given resource.
+   */
+  editorFor: function(resource) {
+    let shell = this.shellFor(resource);
+    return shell ? shell.editor : shell;
+  },
+
+  /**
+   * Returns the Pair that matches a given editor, pair, or resource.
+   */
+  pairFor: function(thing) {
+    if (thing instanceof Pair) {
+      return thing;
+    }
+    if (thing instanceof Resource) {
+      return this.resourceMap.pair(thing);
+    }
+    if (thing.pair) {
+      return thing.pair;
+    }
+    throw new Error("Don't know how to get a pair associated with: " + thing);
+  },
+
+  /**
+   * Returns a live resource for the given editor, pair, or resource.
+   */
+  liveFor: function(thing) {
+    let pair = this.pairFor(thing);
+    return pair ? pair.live : null;
+  },
+
+  /**
+   * Returns a project resource for the given editor, pair, or resource.
+   */
+  projectFor: function(thing) {
+    let pair = this.pairFor(thing);
+    return pair ? pair.project : null;
+  },
+
+  /**
+   * Decide whether a given node should be hidden in the tree.
+   */
+  nodeVisible: function(node) {
+    // if (node === this.project.openStore.root) {
+    //   return node.hasChildren;
+    // }
+    return true;
+  },
+
+  /**
+   * Format the given node for display in the resource tree.
+   */
+  formatNode: function(node, elt) {
+    let editor = this.editorFor(node);
+    let renderedByPlugin = false;
+
+    if (this.plugins) {
+      this.plugins.forEach(plugin => {
+        if (!plugin.onAnnotate) {
+          return;
+        }
+        if (plugin.onAnnotate(node, editor, elt)) {
+          renderedByPlugin = true;
+        }
+      });
+    }
+
+    if (!renderedByPlugin) {
+      elt.textContent = node.displayName;
+    }
+  },
+
+  get sourcesVisible() {
+    return this.sourceToggle.hasAttribute("pane-collapsed");
+  },
+
+  get currentShell() {
+    return this.shells.currentShell;
+  },
+
+  get currentEditor() {
+    return this.shells.currentEditor;
+  },
+});
+
+var CollectionTree = Class({
+  extends: TreeView,
+
+  initialize: function(document, options) {
+    TreeView.prototype.initialize.call(this, document, options);
+  },
+
+  setCollection: function(coll) {
+    if (this.coll) {
+      forget(this, this.coll);
+      for (let store of this.coll.allStores()) {
+        this.removeModel(store);
+      }
+    }
+    this.coll = coll;
+    if (this.coll) {
+      on(this, coll, "store-added", this.addModel.bind(this));
+      on(this, coll, "store-removed", this.removeModel.bind(this));
+      on(this, coll, "project-saved", this.refresh.bind(this));
+      this.refresh();
+    }
+  },
+
+  refresh: function() {
+    for (let store of this.coll.allStores()) {
+      this.addModel(store);
+    }
+  }
+});
+
+exports.Itchpad = Itchpad;
diff --git a/browser/devtools/itchpad/lib/menuitems.js b/browser/devtools/itchpad/lib/menuitems.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/menuitems.js
@@ -0,0 +1,218 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+'use strict';
+
+const windowUtils = require("sdk/deprecated/window-utils");
+const { Class } = require("sdk/core/heritage");
+const { validateOptions } = require("sdk/deprecated/api-utils");
+const { on, emit, once, off } = require("sdk/event/core");
+const { isBrowser } = require("sdk/window/utils");
+const { EventTarget } = require('sdk/event/target');
+const menuitemNS = require("sdk/core/namespace").ns();
+
+const { unload } = require('unloader');
+
+const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+function MenuitemOptions(options) {
+  return validateOptions(options, {
+    id: { is: ['string'] },
+    menuid: { is: ['undefined', 'string'] },
+    insertbefore: { is: ['undefined', 'string', 'object', 'number'] },
+    label: { is: ["string"] },
+    include: { is: ['string', 'undefined'] },
+    disabled: { is: ["undefined", "boolean"], map: function(v) !!v},
+    accesskey: { is: ["undefined", "string"] },
+    key: { is: ["undefined", "string"] },
+    checked: { is: ['undefined', 'boolean'] },
+    className: { is: ["undefined", "string"] },
+    onCommand: { is: ['undefined', 'function'] },
+    useChrome: { map: function(v) !!v }
+  });
+}
+
+let Menuitem = Class({
+  extends: EventTarget,
+  initialize: function(options) {
+    options = menuitemNS(this).options = MenuitemOptions(options);
+    EventTarget.prototype.initialize.call(this, options);
+
+    menuitemNS(this).destroyed = false;
+    menuitemNS(this).unloaders = [];
+    menuitemNS(this).menuitems = addMenuitems(this, options).menuitems;
+  },
+  get id() menuitemNS(this).options.id,
+  get label() menuitemNS(this).options.label,
+  set label(val) updateProperty(this, 'label', val),
+  get checked() menuitemNS(this).options.checked,
+  set checked(val) updateProperty(this, 'checked', !!val),
+  get disabled() menuitemNS(this).options.disabled,
+  set disabled(val) updateProperty(this, 'disabled', !!val),
+  get key() menuitemNS(this).options.key,
+  set key(val) updateProperty(this, 'key', val),
+  clone: function (overwrites) {
+    let opts = Object.clone(menuitemNS(this).options);
+    for (let key in overwrites) {
+      opts[key] = ovrewrites[key];
+    }
+    return Menuitem(opts);
+  },
+  get menuid() menuitemNS(this).options.menuid,
+  set menuid(val) {
+    let options = menuitemNS(this).options;
+    options.menuid = val;
+
+    forEachMI(function(menuitem, i, $) {
+      updateMenuitemParent(menuitem, options, $);
+    });
+  },
+  destroy: function() {
+    if (!menuitemNS(this).destroyed) {
+      menuitemNS(this).destroyed = true;
+      menuitemNS(this).unloaders.forEach(function(u) u());
+      menuitemNS(this).unloaders = null;
+      menuitemNS(this).menuitems = null;
+    }
+    return true;
+  }
+});
+
+function addMenuitems(self, options) {
+  let menuitems = [];
+
+  // setup window tracker
+  windowUtils.WindowTracker({
+    onTrack: function (window) {
+      if (menuitemNS(self).destroyed) return;
+      if (options.include) {
+        if (options.include != window.location) return;
+      }
+      else if (!isBrowser(window)) {
+        return;
+      }
+
+      // add the new menuitem to a menu
+      var menuitem = updateMenuitemAttributes(
+          window.document.createElementNS(NS_XUL, "menuitem"), options);
+      var menuitems_i = menuitems.push(menuitem) - 1;
+
+      // add the menutiem to the ui
+      let added = updateMenuitemParent(menuitem, options, function(id) window.document.getElementById(id));
+
+      menuitem.addEventListener("command", function() {
+        if (!self.disabled)
+          emit(self, 'command', options.useChrome ? window : null);
+      }, true);
+
+      // add unloader
+      let unloader = function unloader() {
+        menuitem.parentNode && menuitem.parentNode.removeChild(menuitem);
+        menuitems[menuitems_i] = null;
+      };
+
+      menuitemNS(self).unloaders.push(function() {
+        remover();
+        unloader();
+      });
+
+      let remover = unload(unloader, window);
+    }
+
+  });
+
+  return { menuitems: menuitems };
+}
+
+function updateMenuitemParent(menuitem, options, $) {
+  // add the menutiem to the ui
+  if (Array.isArray(options.menuid)) {
+      let ids = options.menuid;
+      for (var len = ids.length, i = 0; i < len; i++) {
+        if (tryParent($(ids[i]), menuitem, options.insertbefore))
+          return true;
+      }
+  }
+  else {
+    return tryParent($(options.menuid), menuitem, options.insertbefore);
+  }
+
+  return false;
+}
+
+function updateMenuitemAttributes(menuitem, options) {
+  menuitem.setAttribute("id", options.id);
+  menuitem.setAttribute("label", options.label);
+
+  if (options.accesskey)
+    menuitem.setAttribute("accesskey", options.accesskey);
+
+  if (options.key)
+    menuitem.setAttribute("key", options.key);
+
+  menuitem.setAttribute("disabled", !!options.disabled);
+
+  if (options.image) {
+    menuitem.classList.add("menuitem-iconic");
+    menuitem.style.listStyleImage = "url('" + options.image + "')";
+  }
+
+  if (options.checked)
+    menuitem.setAttribute('checked', options.checked);
+
+  if (options.className)
+    options.className.split(/\s+/).forEach(function(name) menuitem.classList.add(name));
+
+  return menuitem;
+}
+
+function updateProperty(menuitem, key, val) {
+  menuitemNS(menuitem).options[key] = val;
+
+  forEachMI(function(menuitem) {
+    menuitem.setAttribute(key, val);
+  }, menuitem);
+  return val;
+}
+
+function forEachMI(callback, menuitem) {
+  menuitemNS(menuitem).menuitems.forEach(function(mi, i) {
+    if (!mi) return;
+    callback(mi, i, function(id) mi.ownerDocument.getElementById(id));
+  });
+}
+
+function tryParent(parent, menuitem, before) {
+  if (parent) {
+    if (!before) {
+      parent.appendChild(menuitem);
+      return true;
+    }
+
+    parent.insertBefore(menuitem, insertBefore(parent, before));
+    return true;
+  }
+
+  return false;
+}
+
+function insertBefore(parent, insertBefore) {
+  if (typeof insertBefore == "number") {
+    switch (insertBefore) {
+      case MenuitemExport.FIRST_CHILD:
+        return parent.firstChild;
+    }
+    return null;
+  }
+  else if (typeof insertBefore == "string") {
+    return parent.querySelector("#" + insertBefore);
+  }
+  return insertBefore;
+}
+
+function MenuitemExport(options) {
+  return Menuitem(options);
+}
+MenuitemExport.FIRST_CHILD = 1;
+
+exports.Menuitem = MenuitemExport;
diff --git a/browser/devtools/itchpad/lib/page.js b/browser/devtools/itchpad/lib/page.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/page.js
@@ -0,0 +1,25 @@
+const { Class } = require("sdk/core/heritage");
+const { StoreCollection } = require("itchpad/store-collection");
+const { StylesStore } = require("itchpad/stores/styles");
+
+// This is a bad name for the collection of stores tied to the live target.
+// Target was already taken, Live didn't sound right.  A rename would be
+// welcome.
+var PageCollection = Class({
+  extends: StoreCollection,
+
+  initialize: function() {
+    StoreCollection.prototype.initialize.call(this);
+
+    this.styles = new StylesStore();
+    this.addStore(this.styles);
+  },
+
+  setTarget: function(target) {
+    for (let store of this.stores) {
+      store.setTarget(target);
+    }
+  }
+});
+
+exports.PageCollection = PageCollection;
diff --git a/browser/devtools/itchpad/lib/path-match.js b/browser/devtools/itchpad/lib/path-match.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/path-match.js
@@ -0,0 +1,115 @@
+/**
+ * A quick check that the characters in 'search' appear in 'path'.
+ * Used for quick trimming of search space.
+ */
+exports.quickMatch = function(search, path) {
+  let index = -1;
+  for (let i = 0; i < search.length; i++) {
+    index = path.indexOf(search[i], index + 1);
+    if (index === -1) {
+      break;
+    }
+  }
+  return (index !== -1);
+}
+
+/**
+ * A slower check that makes sure search terms can be found on word
+ * boundaries.
+ */
+
+const BOUNDARY_RE = /\W/;
+
+function charTest(ch) {
+  if (BOUNDARY_RE.test(ch)) {
+    return "(?:(\\" + ch + ")|(.*)(\\" + ch + "))";
+  } else {
+    return "(?:(" + ch + ")|(.*)\\b(" + ch + "))";
+  }
+}
+
+exports.pathMatchExpression = function(search) {
+  let ch = search[0];
+  let ch = BOUNDARY_RE.test(ch) ? "\\" + ch : ch;
+  let expr = "(.*)(?:(^" + ch + ")|(.*)\\b(" + ch + "))";
+  for (let i = 1; i < search.length; i++) {
+    expr += charTest(search[i]);
+  }
+  expr += "(.*)";
+  return new RegExp(expr);
+}
+
+exports.annotate = function(re, path) {
+  // The regular expression is constructed such that each character in the
+  // search has three matches:
+  // First will match for an immediate match
+  // Second will match any interstitial path
+  // Third will match if second matches.
+
+  let matches = re.exec(path);
+  if (!matches) {
+    return null;
+  }
+
+  let open = null;
+  let fragments = [];
+
+  // 0 unused by exec, 3 matches expected per char, leading and trailing text
+  if (matches.length % 3 != 0) {
+    throw new Error("Unexpected match length!");
+  }
+
+  if (matches[1]) {
+    fragments.push({ fragment: matches[1], matched: false });
+  }
+
+  for (let i = 2; i < matches.length - 1; i += 3) {
+    let immediate = matches[i];
+    let interstitial = matches[i + 1];
+    let newWord = matches[i + 2];
+
+    if (immediate) {
+      if (!open) {
+        open = { fragment: immediate, matched: true };
+        fragments.push(open);
+      } else {
+        open.fragment += immediate;
+      }
+    } else {
+      if (interstitial) {
+        fragments.push({ fragment: interstitial, matched: false });
+      }
+
+      open = { fragment: newWord, matched: true };
+      fragments.push(open);
+    }
+  }
+
+  // ... and one trailing match for remaining stuff.
+  let last = matches[matches.length - 1];
+  if (last) {
+    fragments.push({ fragment: last, matched: false });
+  }
+
+  return fragments;
+}
+
+exports.score = function(re, path) {
+  let annotated = exports.annotate(re, path);
+  if (!annotated) {
+    return 0;
+  }
+
+  let score = 0;
+  for (let item of annotated) {
+    if (item.matched && item.fragment.length > score) {
+      score = item.fragment.length;
+    }
+  }
+
+  // Among items with the same score, prefer matches later
+  // in the string.
+  score = (score << 16) + (annotated[0].matched ? 0 : annotated[0].fragment.length & 0xffff);
+
+  return score;
+}
diff --git a/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js b/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/app-manager/lib/app-project-editor.js
@@ -0,0 +1,27 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const promise = require("itchpad/helpers/promise");
+const { ItchEditor } = require("itchpad/editors");
+
+var AppProjectEditor = Class({
+  extends: ItchEditor,
+
+  hidesToolbar: true,
+
+  initialize: function(document, host) {
+    ItchEditor.prototype.initialize.call(this, document);
+    this.appended = promise.resolve();
+    this.host = host;
+  },
+
+  load: function(resource) {
+    this.elt.textContent = "";
+    let {customOpts} = this.host.project;
+    let iframe = this.elt.ownerDocument.createElement("iframe");
+    iframe.setAttribute("flex", "1");
+    iframe.setAttribute("src", customOpts.iframeSrc);
+    this.elt.appendChild(iframe);
+  }
+});
+
+exports.AppProjectEditor = AppProjectEditor;
diff --git a/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/app-manager/lib/plugin.js
@@ -0,0 +1,69 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const promise = require("itchpad/helpers/promise");
+var { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { AppProjectEditor } = require("./app-project-editor");
+
+
+var AppManagerRenderer = Class({
+  extends: Plugin,
+
+  projectType: "APP_MANAGER",
+
+  isAppManagerProject: function() {
+    return this.host.project.projectType === "APP_MANAGER";
+  },
+  editorForResource: function(node) {
+    if (!node.parent && this.isAppManagerProject()) {
+      return AppProjectEditor;
+    }
+  },
+  onAnnotate: function(node, editor, elt) {
+    if (node.parent || !this.isAppManagerProject()) {
+      return;
+    }
+
+    let {customOpts} = this.host.project;
+    let doc = elt.ownerDocument;
+    let image = doc.createElement("image");
+    let label = doc.createElement("label");
+    let versionLabel = doc.createElement("label");
+
+    label.className = "project-name-label";
+    versionLabel.className = "project-version-label";
+    image.className = "project-image";
+
+    let name = customOpts.name || node.basename;
+    let version = customOpts.version || "v0.0.1";
+    let url = customOpts.iconUrl || "icon-sample.png";
+
+    label.textContent = name;
+    versionLabel.textContent = version;
+    image.setAttribute("src", url);
+
+    elt.innerHTML = "";
+    elt.appendChild(image);
+    elt.appendChild(label);
+    elt.appendChild(versionLabel);
+    return true;
+  },
+
+  // onEditorCreated: function(editor) { console.log("APP MANAGER editor created: " + editor) },
+  // onEditorDestroyed: function(editor) { console.log("APP MANAGER editor destroyed: " + editor )},
+
+  // onEditorSave: function(editor) { console.log("APP MANAGER editor saved: " + editor) },
+  // onEditorLoad: function(editor) { console.log("APP MANAGER editor loaded: " + editor) },
+
+  // onEditorActivated: function(editor) { console.log("APP MANAGER editor focused: " + editor )},
+  // onEditorDeactivated: function(editor) { console.log("APP MANAGER editor blur: " + editor )},
+
+  // onEditorChange: function(editor) { console.log("APP MANAGER editor changed: " + editor )},
+
+  // onCommand: function(cmd) { console.log("APP MANAGER command: " + cmd); }
+
+});
+
+exports.AppManagerRenderer = AppManagerRenderer;
+registerPlugin(AppManagerRenderer);
diff --git a/browser/devtools/itchpad/lib/plugins/apply/lib/apply.js b/browser/devtools/itchpad/lib/plugins/apply/lib/apply.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/apply/lib/apply.js
@@ -0,0 +1,66 @@
+var { Class } = require("sdk/core/heritage");
+var { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const timers = require("sdk/timers");
+
+const DEFAULT_THROTTLE_DELAY = 500;
+
+var ApplyPlugin = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.needsUpdate = new Set();
+  },
+
+  onEditorChange: function(editor) {
+    this.scheduleAutoUpdate(editor);
+  },
+
+  onCommand: function(cmd) {
+    // If we haven't been auto-applying, at least apply on save (not
+    // sure this is great behavior, but I'm gonna try it)
+    if (cmd === "cmd-save") {
+      let editor = this.host.currentEditor;
+      this.apply(editor);
+    }
+  },
+
+  scheduleAutoUpdate: function(editor) {
+    let live = this.host.liveFor(editor);
+    if (!live || !live.canAutoApply) {
+      return;
+    }
+
+    this.needsUpdate.add(editor);
+    if (this._updateTask) {
+      timers.clearTimeout(this._updateTask);
+    }
+
+    this._updateTask = timers.setTimeout(this.applyUpdates.bind(this), DEFAULT_THROTTLE_DELAY);
+  },
+
+  applyUpdates: function() {
+    if (this._updateTask) {
+      timers.clearTimeout(this._updateTask);
+      this._updateTask = null;
+    }
+
+    for (let editor of this.needsUpdate) {
+      console.log("applying auto update of " + editor);
+
+      this.apply(editor);
+    }
+    this.needsUpdate = new Set();
+  },
+
+  apply: function(editor) {
+    let live = this.host.liveFor(editor);
+    if (!live || !live.apply) {
+      return;
+    }
+
+    let text = editor.editor.getText();
+    live.apply(text);
+  }
+});
+exports.ApplyPlugin = ApplyPlugin;
+registerPlugin(ApplyPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/core.js b/browser/devtools/itchpad/lib/plugins/core.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/core.js
@@ -0,0 +1,75 @@
+// This is the core plugin API.
+
+const { Class } = require("sdk/core/heritage");
+
+var Plugin = Class({
+  initialize: function(host) {
+    this.host = host;
+    this.init(host);
+  },
+
+  destroy: function(host) { },
+
+  init: function(host) {},
+
+  showForCategories: function(elt, categories) {
+    this._showFor = this._showFor || [];
+    let set = new Set(categories);
+    this._showFor.push({
+      elt: elt,
+      categories: new Set(categories)
+    });
+    if (this.host.currentEditor) {
+      this.onEditorActivated(this.host.currentEditor);
+    } else {
+      elt.classList.add("plugin-hidden");
+    }
+  },
+
+  priv: function(item) {
+    if (!this._privData) {
+      this._privData = new WeakMap();
+    }
+    if (!this._privData.has(item)) {
+       this._privData.set(item, {});
+    }
+    return this._privData.get(item);
+  },
+
+  // Editor state lifetime...
+  onEditorCreated: function(editor) {},
+  onEditorDestroyed: function(editor) {},
+
+  onEditorActivated: function(editor) {
+    if (this._showFor) {
+      let category = editor.category;
+      for (let item of this._showFor) {
+        if (item.categories.has(category)) {
+          item.elt.classList.remove("plugin-hidden");
+        } else {
+          item.elt.classList.add("plugin-hidden");
+        }
+      }
+    }
+  },
+  onEditorDeactivated: function(editor) {
+    if (this._showFor) {
+      for (let item of this._showFor) {
+        item.elt.classList.add("plugin-hidden");
+      }
+    }
+  },
+
+  onEditorLoad: function(editor) {},
+  onEditorSave: function(editor) {},
+  onEditorChange: function(editor) {},
+  onEditorCursorActivity: function(editor) {},
+});
+exports.Plugin = Plugin;
+
+function registerPlugin(constr) {
+  exports.registeredPlugins.push(constr);
+}
+exports.registerPlugin = registerPlugin;
+
+exports.registeredPlugins = [];
diff --git a/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js b/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/delete/lib/delete.js
@@ -0,0 +1,31 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var DeletePlugin = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.host.addCommand({
+      id: "cmd-delete"
+    });
+    this.host.createMenuItem({
+      parent: "#directory-menu-popup",
+      label: "Delete",
+      command: "cmd-delete"
+    });
+  },
+
+  onCommand: function(cmd) {
+    if (cmd === "cmd-delete") {
+      let tree = this.host.projectTree;
+      let resource = tree.getSelected();
+      let parent = resource.parent;
+      tree.deleteNode(resource).then(() => {
+        this.host.project.refresh();
+      })
+    }
+  }
+});
+
+exports.DeletePlugin = DeletePlugin;
+registerPlugin(DeletePlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js b/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
@@ -0,0 +1,36 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { emit } = require("sdk/event/core");
+
+var DirtyPlugin = Class({
+  extends: Plugin,
+
+  onEditorSave: function(editor) { this.onEditorChange(editor); },
+  onEditorLoad: function(editor) { this.onEditorChange(editor); },
+
+  onEditorChange: function(editor) {
+    if (!editor || !editor.editor) {
+      return;
+    }
+    let tree = this.host.tree;
+
+    // Dont' force a refresh unless the dirty state has changed...
+    let priv = this.priv(editor);
+    let clean = editor.editor.isClean();
+    if (priv.isClean !== clean) {
+      let resource = editor.shell.project;
+      emit(resource, "label-change", resource);
+      priv.isClean = clean;
+    }
+  },
+
+  onAnnotate: function(resource, editor, elt) {
+    if (editor && editor.editor && !editor.editor.isClean()) {
+      elt.textContent = '*' + resource.displayName;
+      return true;
+    }
+  }
+});
+exports.DirtyPlugin = DirtyPlugin;
+
+registerPlugin(DirtyPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js b/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/drag-drop-new/lib/drag-drop-new.js
@@ -0,0 +1,51 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const promise = require("itchpad/helpers/promise");
+const Editor  = require("devtools/sourceeditor/editor");
+const { Cu } = require("chrome");
+const { VariablesView } = Cu.import("resource:///modules/devtools/VariablesView.jsm", {});
+const { ObjectClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
+const { EnvironmentClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
+const OS = require("itchpad/helpers/osfile");
+
+var DragDropNew = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.onDrop = this.onDrop.bind(this);
+    this.onDragOver = this.onDragOver.bind(this);
+    this.dropzone = host.document.querySelector("#main-deck");
+    this.dropzone.addEventListener("dragover", this.onDragOver, true);
+    this.dropzone.addEventListener("drop", this.onDrop, true);
+  },
+
+  onDragOver: function(event) {
+    event.preventDefault();
+
+  },
+  onDrop: function(event) {
+    event.preventDefault();
+
+    // Ready to do something with the dropped object
+    var allTheFiles = event.dataTransfer.files || [];
+
+    [...allTheFiles].forEach((file) => {
+      let path = file.mozFullPath;
+      if (file.type === "") {
+        this.host.project.addPath(path);
+      }
+    });
+
+    this.host.project.save();
+  },
+
+  destroy: function() {
+    this.dropzone.removeEventListener("dragover", this.onDragOver, true);
+    this.dropzone.removeEventListener("drop", this.onDrop, true);
+  }
+
+});
+
+exports.DragDropNew = DragDropNew;
+
+registerPlugin(DragDropNew);
diff --git a/browser/devtools/itchpad/lib/plugins/find-and-replace/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/find-and-replace/lib/plugin.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/find-and-replace/lib/plugin.js
@@ -0,0 +1,73 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var FindAndReplace = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.command = this.host.addCommand({
+      id: "find",
+      key: "f",
+      modifiers: "accel"
+    });
+
+    this.searchBox = this.host.createElement("textbox", {
+      parent: "#plugin-toolbar-right",
+      type: "search",
+      timeout: "50",
+      hidden: true,
+      class: "devtools-searchinput",
+    });
+
+    this.onSearchFocus = this.onSearchFocus.bind(this);
+    this.onSearchInput = this.onSearchInput.bind(this);
+    this.onSearchKey = this.onSearchKey.bind(this);
+
+    this.searchBox.addEventListener("focus", this.onSearchFocus, true);
+    this.searchBox.addEventListener("input", this.onSearchInput, true);
+    this.searchBox.addEventListener("keypress", this.onSearchKey, true);
+  },
+
+  onSearchFocus: function() {
+
+  },
+
+  onSearchInput: function() {
+
+  },
+
+  onSearchKey: function(e) {
+    switch (e.keyCode) {
+      case e.DOM_VK_RETURN:
+      case e.DOM_VK_ENTER: {
+        break;
+      }
+      case e.DOM_VK_DOWN: {
+        break;
+      }
+      case e.DOM_VK_UP: {
+        break;
+      }
+      case e.DOM_VK_ESCAPE: {
+        this.finish();
+        break;
+      }
+    }
+  },
+
+  finish: function() {
+    this.searchBox.value = "";
+    this.searchBox.setAttribute("hidden", "true");
+  },
+
+  onCommand: function(cmd, target) {
+    if (cmd === "find") {
+      this.searchBox.removeAttribute("hidden");
+      this.searchBox.focus();
+      this.searchBox.select();
+    }
+  }
+});
+
+exports.FindAndReplace = FindAndReplace;
+registerPlugin(FindAndReplace);
diff --git a/browser/devtools/itchpad/lib/plugins/fuzzy-search/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/fuzzy-search/lib/plugin.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/fuzzy-search/lib/plugin.js
@@ -0,0 +1,213 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const match = require("itchpad/path-match");
+
+const VISIBLE_RESULTS = 10;
+
+var Search = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.command = this.host.addCommand({
+      id: "search-files",
+      key: "p",
+      modifiers: "accel"
+    });
+
+    this.searchBox = this.host.createElement("textbox", {
+      parent: "#plugin-toolbar-right",
+      type: "search",
+      timeout: "50",
+      hidden: true,
+      class: "devtools-searchinput",
+    });
+
+    this.panel = this.host.createElement("panel", {
+      parent: "window",
+      class: "results-panel",
+      level: "top",
+      noautofocus: "true",
+      consumeoutsideclicks: "false",
+      hidden: "true"
+    });
+
+    this.onSearchFocus = this.onSearchFocus.bind(this);
+    this.onSearchInput = this.onSearchInput.bind(this);
+    this.onSearchKey = this.onSearchKey.bind(this);
+
+    this.searchBox.addEventListener("focus", this.onSearchFocus, true);
+    this.searchBox.addEventListener("input", this.onSearchInput, true);
+    this.searchBox.addEventListener("keypress", this.onSearchKey, true);
+  },
+
+  populateHistory: function() {
+    let history = this.host.shells.history || { items: [] };
+    let results = [];
+
+    for (let i = history.items.length - 2; i >= 0; i--) {
+      let shell = history.items[i];
+      let project = shell.pair.project;
+      if (project) {
+        results.push({ score: 1, resource: project });
+      }
+    }
+    this.populate(results);
+  },
+
+  populate: function(searchResults, search) {
+    this.results = searchResults;
+    this.cards = [];
+
+    while (this.panel.firstChild) {
+      this.panel.removeChild(this.panel.firstChild);
+    }
+
+    let searchExpression = search ? match.pathMatchExpression(search) : null;
+
+    for (let i = 0; i < VISIBLE_RESULTS && i < searchResults.length; i++) {
+      let result = searchResults[i];
+      let card = this.cardFor(result.resource, searchExpression);
+      this.panel.appendChild(card);
+      this.cards.push(card);
+      let selectIndex = i;
+      card.addEventListener("click", () => {
+        this.select(selectIndex);
+        this.finish();
+      }, true);
+    }
+  },
+
+  onSearchFocus: function() {
+    this.selectedIndex = undefined;
+  },
+
+  onSearchInput: function() {
+    let index = this.host.project.index;
+
+    let search = this.searchBox.value;
+    let results = index.fuzzyMatchPath(this.searchBox.value);
+
+    results = results.sort((a, b) => {
+      let diff = b.score - a.score;
+      if (diff !== 0) return diff;
+      // Prefer longer URI matches
+      diff = b.resource.path.length - a.resource.path.length;
+      if (diff !== 0) return diff;
+      return a.resource.path.localeCompare(b.resource.path);
+    });
+
+    this.populate(results, search);
+    this.showPanel();
+    this.select(0);
+  },
+
+  onSearchKey: function(e) {
+    switch (e.keyCode) {
+      case e.DOM_VK_RETURN:
+      case e.DOM_VK_ENTER: {
+        this.finish();
+        break;
+      }
+      case e.DOM_VK_DOWN: {
+        let index = this.selectedIndex === undefined ? 0 : this.selectedIndex + 1;
+        this.select(index);
+        break;
+      }
+      case e.DOM_VK_UP: {
+        let index = this.selectedIndex === undefined ? 0 : this.selectedIndex - 1;
+        this.select(index);
+        break;
+      }
+      case e.DOM_VK_ESCAPE: {
+        this.finish();
+        break;
+      }
+    }
+  },
+
+  select: function(index) {
+    if (this.results.length < 1) {
+      return;
+    }
+
+    if (index < 0) {
+      index = 0;
+    }
+    if (index >= this.results.length) {
+      index = this.results.length - 1;
+    }
+
+    if (this.selectedIndex !== undefined) {
+      this.cards[this.selectedIndex].classList.remove("selected");
+    }
+    this.selectedIndex = index;
+    this.cards[index].classList.add("selected");
+    this.host.openResource(this.results[index].resource);
+  },
+
+  finish: function() {
+    if (this.selectedIndex === undefined && this.results && this.results.length > 0) {
+      this.selectedIndex = 0;
+    }
+    if (this.results[this.selectedIndex]) {
+      this.host.openResource(this.results[this.selectedIndex].resource);
+    }
+    this.panel.hidePopup();
+    this.searchBox.value = "";
+    this.searchBox.setAttribute("hidden", "true");
+    this.host.currentEditor.editor.focus();
+  },
+
+  cardFor: function(resource, search) {
+    let card = this.host.createElement("vbox", {
+      class: "light results-panel-item list-widget-item"
+    });
+
+    let name = this.host.createElement("label", {
+      parent: card,
+      class: "plain results-panel-item-name",
+      value: resource.basename
+    });
+
+    let details = this.host.createElement("label", {
+      parent: card,
+      class: "plain results-panel-item-details",
+    });
+
+    let displayPath = resource.relativePath();
+    let annotated = search ? match.annotate(search, displayPath) : null;
+    if (annotated) {
+      for (let fragment of annotated) {
+        let span = this.host.createElement("span", {
+          parent: details,
+          class: fragment.matched ? "results-panel-item-match" : "",
+        });
+        span.textContent = fragment.fragment;
+      }
+    } else {
+      details.setAttribute("value", resource.relativePath());
+    }
+
+    return card;
+  },
+
+  showPanel: function() {
+    this.panel.hidden = false;
+    this.panel.openPopup(this.searchBox, "after_start", 0, 0);
+  },
+
+  onCommand: function(cmd, target) {
+    if (cmd === "search-files") {
+      this.searchBox.removeAttribute("hidden");
+      this.searchBox.focus();
+      this.searchBox.select();
+      this.populateHistory();
+      if (this.results.length > 0) {
+        this.showPanel();
+      }
+    }
+  }
+});
+
+exports.Search = Search;
+registerPlugin(Search);
diff --git a/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js b/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/image-view/lib/image-editor.js
@@ -0,0 +1,31 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const promise = require("itchpad/helpers/promise");
+const { ItchEditor } = require("itchpad/editors");
+
+var ImageEditor = Class({
+  extends: ItchEditor,
+
+  initialize: function(document) {
+    ItchEditor.prototype.initialize.call(this, document);
+    this.label = "image";
+    this.appended = promise.resolve();
+  },
+
+  load: function(resource) {
+    let image = this.doc.createElement("image");
+    image.className = "editor-image";
+    image.setAttribute("src", resource.uri);
+
+    let box1 = this.doc.createElement("box");
+    box1.appendChild(image);
+
+    let box2 = this.doc.createElement("box");
+    box2.setAttribute("flex", 1);
+
+    this.elt.appendChild(box1);
+    this.elt.appendChild(box2);
+  }
+});
+
+exports.ImageEditor = ImageEditor;
diff --git a/browser/devtools/itchpad/lib/plugins/image-view/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/image-view/lib/plugin.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/image-view/lib/plugin.js
@@ -0,0 +1,22 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const promise = require("itchpad/helpers/promise");
+const { ImageEditor } = require("./image-editor");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var ImageEditorPlugin = Class({
+  extends: Plugin,
+
+  editorForResource: function(node) {
+    if (node.contentCategory === "image") {
+      return ImageEditor;
+    }
+  },
+
+  init: function(host) {
+
+  }
+});
+
+exports.ImageEditorPlugin = ImageEditorPlugin;
+registerPlugin(ImageEditorPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/logging/lib/logging.js b/browser/devtools/itchpad/lib/plugins/logging/lib/logging.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/logging/lib/logging.js
@@ -0,0 +1,23 @@
+var { Class } = require("sdk/core/heritage");
+var { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var LoggingPlugin = Class({
+  extends: Plugin,
+
+  // Editor state lifetime...
+  onEditorCreated: function(editor) { console.log("editor created: " + editor) },
+  onEditorDestroyed: function(editor) { console.log("editor destroyed: " + editor )},
+
+  onEditorSave: function(editor) { console.log("editor saved: " + editor) },
+  onEditorLoad: function(editor) { console.log("editor loaded: " + editor) },
+
+  onEditorActivated: function(editor) { console.log("editor focused: " + editor )},
+  onEditorDeactivated: function(editor) { console.log("editor blur: " + editor )},
+
+  onEditorChange: function(editor) { console.log("editor changed: " + editor )},
+
+  onCommand: function(cmd) { console.log("Command: " + cmd); }
+});
+exports.LoggingPlugin = LoggingPlugin;
+
+registerPlugin(LoggingPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/manifest-save/lib/manifest-save.js b/browser/devtools/itchpad/lib/plugins/manifest-save/lib/manifest-save.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/manifest-save/lib/manifest-save.js
@@ -0,0 +1,25 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const tabs = require("sdk/tabs");
+const { viewFor } = require('sdk/view/core');
+
+// When a manifest.webapp file is updated, update the manifest on any app
+// managers viewing the manifest.
+
+var ManifestSave = Class({
+  extends: Plugin,
+
+  onEditorSave: function(editor) {
+    let project = this.host.projectFor(editor);
+    if (project.basename === "manifest.webapp") {
+      // Trigger a reload in the app manager.
+      for (let tab of tabs) {
+        if (tab.url === "about:app-manager") {
+          viewFor(tab).linkedBrowser.contentWindow.UI.refreshManifest(project.path);
+        }
+      }
+    }
+  }
+});
+exports.ManifestSave = ManifestSave;
+registerPlugin(ManifestSave);
diff --git a/browser/devtools/itchpad/lib/plugins/new/lib/new.js b/browser/devtools/itchpad/lib/plugins/new/lib/new.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/new/lib/new.js
@@ -0,0 +1,83 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+// Handles the save command.
+var NewFile = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.host.createMenuItem({
+      parent: "#file-menu-popup",
+      label: "New",
+      command: "cmd-new",
+      key: "key-new"
+    });
+    this.host.createMenuItem({
+      parent: "#directory-menu-popup",
+      label: "New...",
+      command: "cmd-new"
+    });
+
+    this.command = this.host.addCommand({
+      id: "cmd-new",
+      key: "n",
+      modifiers: "accel"
+    });
+  },
+
+  onCommand: function(cmd) {
+    if (cmd === "cmd-new") {
+      let tree = this.host.projectTree;
+      let resource = tree.getSelected();
+      parent = resource.isDir ? resource : resource.parent;
+      sibling = resource.isDir ? null : resource;
+
+      if (!("createChild" in parent)) {
+        return;
+      }
+
+      let extension = sibling ? sibling.contentCategory : parent.store.defaultCategory;
+      let template = "untitled{1}." + extension;
+      let name = this.suggestName(parent, template);
+
+      tree.promptNew(name, parent, sibling).then(name => {
+
+        // XXX: do something about bad names.
+
+        // If the name is already taken, just add/increment a number.
+        if (this.hasChild(parent, name)) {
+          let matches = name.match(/([^\d.]*)(\d*)([^.]*)(.*)/);
+          template = matches[1] + "{1}" + matches[3] + matches[4];
+          name = this.suggestName(parent, template, parseInt(matches[2]) || 2);
+        }
+
+        return parent.createChild(name);
+      }).then(resource => {
+        tree.select(resource);
+        this.host.currentEditor.focus();
+      }).then(null, console.error);
+    }
+  },
+
+  suggestName: function(parent, template, start=1) {
+    let i = start;
+    let name;
+    do {
+      name = template.replace("\{1\}", i === 1 ? "" : i);
+      i++;
+    } while (this.hasChild(parent, name));
+
+    return name;
+  },
+
+  hasChild: function(resource, name) {
+    for (let child of resource.children) {
+      if (child.basename === name) {
+        return true;
+      }
+    }
+    return false;
+  }
+})
+exports.NewFile = NewFile;
+registerPlugin(NewFile);
diff --git a/browser/devtools/itchpad/lib/plugins/notify/lib/notify.js b/browser/devtools/itchpad/lib/plugins/notify/lib/notify.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/notify/lib/notify.js
@@ -0,0 +1,173 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const promise = require("itchpad/helpers/promise");
+
+const Editor  = require("devtools/sourceeditor/editor");
+
+const { Cu } = require("chrome");
+const { VariablesView } = Cu.import("resource:///modules/devtools/VariablesView.jsm", {});
+const { ObjectClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
+const { EnvironmentClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
+
+var Notify = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.host.addCommand({
+      id: "cmd-hide-sidebar",
+      key: "VK_ESCAPE"
+    });
+    this.host.pluginMethods.notify = this;
+    this.host.createElement("splitter", {
+      parent: "#shells",
+      class: "devtools-horizontal-splitter",
+    });
+    this.div = this.host.createElement("div", {
+      parent: "#shells",
+      class: "output-pane",
+      flex: 1,
+      hidden: "true",
+    });
+
+  },
+
+  get client() { return this.host.target.client },
+
+  showPane: function() {
+    this.div.removeAttribute("hidden");
+    if (!this.editor) {
+      this.editor = new Editor({
+        mode: Editor.modes.text,
+        lineWrapping: true,
+        readOnly: true
+      });
+      this.appended = this.editor.appendTo(this.div);
+    }
+    return this.appended;
+  },
+
+  hidePane: function() {
+    this.div.setAttribute("hidden", "true");
+  },
+
+  onCommand: function(cmd) {
+    if (cmd === "cmd-hide-sidebar") {
+      this.host.hideSidebar();
+      this.hidePane();
+    }
+  },
+
+  info: function(item) {
+    this.showPane();
+    return this._writePrimitive(item).then(this._append.bind(this));
+  },
+
+  error: function(item) {
+    this.showPane();
+    return this._writeError(item).then(this._append.bind(this));
+  },
+
+  _append: function(value) {
+    return this.appended.then(() => {
+      let editor = this.editor;
+      let line = editor.lineCount();
+      editor.replaceText(value + "\n", { line: line, col: 0 });
+      editor.setFirstVisibleLine(line);
+    });
+  },
+
+  _writePrimitive: function(value) {
+    let deferred = promise.defer();
+    if (value.type == "longString") {
+      this.host.getWebConsoleClient().then(client => {
+        client.longString(value).substring(0, value.length, response => {
+          if (response.error) {
+            console.error("Display failed: " + response.error + " " + response.message);
+            deferred.reject(response);
+          } else {
+            deferred.resolve(response.substring);
+          }
+        });
+      });
+    } else {
+      deferred.resolve(value.type || value);
+    }
+
+    return deferred.promise;
+  },
+
+
+  _writeError: function(error) {
+    let deferred = promise.defer();
+
+    if (VariablesView.isPrimitive({ value: error })) {
+      let type = error.type;
+      if (type == "undefined" ||
+          type == "null" ||
+          type == "Infinity" ||
+          type == "-Infinity" ||
+          type == "NaN" ||
+          type == "-0") {
+        deferred.resolve(type);
+      } else if (type == "longString") {
+        deferred.resolve(error.initial + "\u2026");
+      } else {
+        deferred.resolve(error);
+      }
+    } else {
+      let objectClient = new ObjectClient(this.client, error);
+      objectClient.getPrototypeAndProperties(response => {
+        if (response.error) {
+          deferred.reject(response);
+          return;
+        }
+
+        let { ownProperties, safeGetterValues } = response;
+        let error = Object.create(null);
+
+        // Combine all the property descriptor/getter values into one object.
+        for (let key of Object.keys(safeGetterValues)) {
+          error[key] = safeGetterValues[key].getterValue;
+        }
+
+        for (let key of Object.keys(ownProperties)) {
+          error[key] = ownProperties[key].value;
+        }
+
+        // Assemble the best possible stack we can given the properties we have.
+        let stack;
+        if (typeof error.stack == "string") {
+          stack = error.stack;
+        } else if (typeof error.fileName == "number") {
+          stack = "@" + error.fileName;
+          if (typeof error.lineNumber == "number") {
+            stack += ":" + error.lineNumber;
+          }
+        } else if (typeof error.lineNumber == "number") {
+          stack = "@" + error.lineNumber;
+        }
+
+        stack = stack ? "\n" + stack.replace(/\n$/, "") : "";
+
+        if (typeof error.message == "string") {
+          deferred.resolve(error.message + stack);
+        } else {
+          objectClient.getDisplayString(response => {
+            if (response.error) {
+              deferred.reject(response);
+            } else if (typeof response.displayString == "string") {
+              deferred.resolve(response.displayString + stack);
+            } else {
+              deferred.resolve(stack);
+            }
+          });
+        }
+      });
+    }
+
+    return deferred.promise.then(value => "Exception: " + value);
+  },
+});
+exports.Notify = Notify;
+
+registerPlugin(Notify);
diff --git a/browser/devtools/itchpad/lib/plugins/open/lib/open.js b/browser/devtools/itchpad/lib/plugins/open/lib/open.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/open/lib/open.js
@@ -0,0 +1,54 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const picker = require("itchpad/helpers/file-picker");
+
+var OpenPlugin = Class({
+  extends: Plugin,
+
+  init: function(host) {
+
+    this.command = this.host.addCommand({
+      id: "cmd-open",
+      key: "o",
+      modifiers: "accel"
+    });
+
+    this.fileLabel = this.host.createElement("label", {
+      parent: "#plugin-toolbar-left",
+      class: "itchpad-file-label"
+    });
+    this.onTreeSelection = this.onTreeSelection.bind(this);
+    this.host.projectTree.on("selection", this.onTreeSelection);
+  },
+
+  destroy: function() {
+    this.host.projectTree.off("selection", this.onTreeSelection);
+  },
+
+  onCommand: function(cmd) {
+    if (cmd === "cmd-open") {
+      picker.showOpen({
+        window: this.host.window
+      }).then(path => {
+        this.open(path);
+      });
+    }
+  },
+
+  onTreeSelection: function(node) {
+    if (!node.isDir) {
+      this.fileLabel.textContent = node.basename;
+    } else if (!node.parent) {
+      this.fileLabel.textContent = "";
+    }
+  },
+
+  open: function(path) {
+    this.host.project.resourceFor(path).then(resource => {
+      this.host.openResource(resource);
+    });
+  }
+});
+
+exports.OpenPlugin = OpenPlugin;
+registerPlugin(OpenPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/project-dirs/lib/project-dirs.js b/browser/devtools/itchpad/lib/plugins/project-dirs/lib/project-dirs.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/project-dirs/lib/project-dirs.js
@@ -0,0 +1,93 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const prefs = require("sdk/preferences/service");
+const picker = require("itchpad/helpers/file-picker");
+
+var ProjectDirs = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    let doc = host.document;
+    let toolbar = doc.getElementById("project-toolbar");
+
+    this.addCommand = host.addCommand({
+      id: "add-project-dir",
+    });
+
+    this.removeCommand = host.addCommand({
+      id: "remove-project-dir"
+    });
+
+    this.host.createMenuItem({
+      parent: "#directory-menu-popup",
+      id: "remove-project",
+      label: "Remove this folder from project",
+      command: "remove-project-dir"
+    });
+
+    this.addButton = host.createToolbarButton({
+      parent: "#project-toolbar",
+      class: "devtools-toolbarbutton add-dir-button",
+      label: "+",
+      command: this.addCommand,
+      tooltiptext: "Add a directory to this project",
+    });
+
+    this.removeButton = host.createToolbarButton({
+      parent: "#project-toolbar",
+      class: "devtools-toolbarbutton remove-dir-button",
+      label: "-",
+      command: this.removeCommand,
+      hidden: true,
+      tooltiptext: "Remove directory to this project",
+    });
+
+    this.onTreeSelection = this.onTreeSelection.bind(this);
+    this.host.projectTree.on("selection", this.onTreeSelection);
+  },
+
+  destroy: function() {
+    this.host.projectTree.off("selection", this.onTreeSelection);
+  },
+
+  onTreeSelection: function(node) {
+    let store = node.store;
+
+    if (store.path &&
+        this.host.project.stores.has(store.path) &&
+        node.store.root === node) {
+      this.removeButton.removeAttribute("hidden")
+    } else {
+      this.removeButton.setAttribute("hidden", "true");
+    }
+  },
+
+  onCommand: function(id, cmd) {
+    if (cmd === this.addCommand) {
+      this.promptDir();
+    } else if (cmd === this.removeCommand) {
+      this.removeCurrentDir();
+    }
+  },
+
+  promptDir: function() {
+    picker.showOpenFolder({
+      window: this.host.window
+    }).then(path => {
+      this.addDir(path);
+    });
+  },
+
+  removeCurrentDir: function() {
+    let path = this.host.projectTree.getSelected().store.path;
+    this.host.project.removePath(path);
+    this.host.project.save();
+  },
+
+  addDir: function(path) {
+    this.host.project.addPath(path);
+    this.host.project.save();
+  }
+});
+exports.ProjectDirs = ProjectDirs;
+registerPlugin(ProjectDirs);
diff --git a/browser/devtools/itchpad/lib/plugins/project-live-preview/lib/project-live-preview.js b/browser/devtools/itchpad/lib/plugins/project-live-preview/lib/project-live-preview.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/project-live-preview/lib/project-live-preview.js
@@ -0,0 +1,74 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { emit } = require("sdk/event/core");
+const tabs = require("sdk/tabs");
+
+// XXX: Experimenting with hooking a tab up with a live view of a project
+
+var LivePreviewProject = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    let doc = host.document;
+    let toolbar = doc.getElementById("project-toolbar");
+
+    this.host.createMenuItem({
+      parent: "#directory-menu-popup",
+      label: "Live Preview Project",
+      command: "live-preview-project"
+    });
+    this.command = host.addCommand({
+      id: "live-preview-project",
+    });
+  },
+
+  getActiveTabUrl: function() {
+    let paths = [store.path for ([id, store] of this.host.project.localStores)];
+    if (!paths[0]) {
+      return;
+    }
+
+    return "file://" + encodeURI(paths[0] + "/index.html");
+  },
+
+  onCommand: function(id, cmd) {
+    if (cmd !== this.command) {
+      return;
+    }
+
+    let activeTabUrl = this.getActiveTabUrl();
+    if (activeTabUrl) {
+      openTab(activeTabUrl);
+    }
+  },
+
+  onEditorSave: function(editor, resource) {
+    if (resource.basename === "index.html") {
+      let activeTabUrl = this.getActiveTabUrl();
+      if (activeTabUrl) {
+        openTab(activeTabUrl);
+      }
+    }
+  }
+});
+
+function getTab(url) {
+  for (let tab of tabs) {
+    if (tab.url === url) {
+      return tab;
+    }
+  }
+}
+
+function openTab(url) {
+  let tab = getTab(url);
+  if (tab) {
+    tab.reload();
+    return tab; //.activate();
+  } else {
+    return tabs.open(url);
+  }
+}
+
+exports.LivePreviewProject = LivePreviewProject;
+registerPlugin(LivePreviewProject);
diff --git a/browser/devtools/itchpad/lib/plugins/project-refresh/lib/project-refresh.js b/browser/devtools/itchpad/lib/plugins/project-refresh/lib/project-refresh.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/project-refresh/lib/project-refresh.js
@@ -0,0 +1,30 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { emit } = require("sdk/event/core");
+
+var RefreshProject = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    let doc = host.document;
+
+    this.command = host.addCommand({
+      id: "refresh-project",
+    });
+
+    // this.button = host.createToolbarButton({
+    //   parent: "#project-toolbar",
+    //   class: "devtools-toolbarbutton refresh-button",
+    //   command: this.command,
+    //   tooltiptext: "Refresh project changes from disk",
+    // });
+  },
+
+  onCommand: function(id, cmd) {
+    if (cmd === this.command) {
+      this.host.projectTree.refresh();
+    }
+  }
+});
+exports.RefreshProject = RefreshProject;
+registerPlugin(RefreshProject);
diff --git a/browser/devtools/itchpad/lib/plugins/project-settings/lib/project-settings.js b/browser/devtools/itchpad/lib/plugins/project-settings/lib/project-settings.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/project-settings/lib/project-settings.js
@@ -0,0 +1,121 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var ProjectSettings = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.groups = {};
+
+    this.command = host.addCommand({
+      id: "project-settings"
+    });
+
+    this.button = host.createToolbarButton({
+      parent: "#project-toolbar",
+      class: "devtools-toolbarbutton settings-button",
+      command: this.command,
+      tooltiptext: "Project settings"
+    });
+
+    this.updaters = [];
+
+    this.addGroup("settings", "Settings");
+
+    this.addTextField({
+      group: "settings",
+      id: "name",
+      title: "Name",
+      populate: (editor) => {
+        return this.host.project.name;
+      },
+      onApply: (value) => {
+        this.host.project.setName(value);
+      }
+    });
+
+    this.refresh = this.refresh.bind(this);
+    this.host.project.on("name-change", this.refresh);
+
+    this.host.document.querySelector("#project-settings-close").addEventListener("click", () => {
+      this.host.document.querySelector("#main-deck").selectedIndex = 0;
+    });
+  },
+
+  onCommand: function(id, cmd) {
+    if (cmd === this.command) {
+      this.showSettings();
+    }
+  },
+
+  refresh: function() {
+    let project = this.host.project;
+
+    this.host.document.querySelector("#project-settings-name").textContent = project.name;
+
+    for (let updater of this.updaters) {
+      updater();
+    }
+  },
+
+  showSettings: function() {
+    let deck = this.host.document.querySelector("#main-deck");
+    deck.selectedIndex = 1;
+
+    this.refresh();
+  },
+
+  addGroup: function(id, title) {
+    let group = this.host.createElement("vbox", {
+      parent: "#settings-hbox",
+      class:"options-vertical-pane"
+    });
+    let header = this.host.createElement("label", {
+      parent: group,
+      value: title
+    });
+    let ul = this.host.createElement("vbox", {
+      parent: group,
+      class: "options-groupbox",
+      id: "project-settings-group-" + id
+    });
+  },
+
+  addTextField: function(options) {
+
+    let line = this.host.createElement("hbox", {
+      parent: "#project-settings-group-" + options.group
+    });
+
+    let label = this.host.createElement("label", {
+      parent: line,
+      value: options.title + ":"
+    });
+
+    let text = this.host.createElement("textbox", {
+      parent: line
+    });
+
+    if (options.onApply) {
+      text.addEventListener("keypress", (e) => {
+        if ((e.keyCode === e.DOM_VK_RETURN) || (e.keyCode === e.DOM_VK_ENTER)) {
+          options.onApply(text.value);
+        }
+      }, false);
+    }
+
+    if (options.populate) {
+      this.updaters.push(() => {
+        let str = options.populate(text);
+        if (str !== undefined) {
+          text.value = str;
+        }
+      });
+    }
+
+    return text;
+  }
+});
+
+exports.ProjectSettings = ProjectSettings;
+registerPlugin(ProjectSettings);
diff --git a/browser/devtools/itchpad/lib/plugins/save/lib/save.js b/browser/devtools/itchpad/lib/plugins/save/lib/save.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/save/lib/save.js
@@ -0,0 +1,93 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const picker = require("itchpad/helpers/file-picker");
+
+// Handles the save command.
+var SavePlugin = Class({
+  extends: Plugin,
+
+  init: function(host) {
+
+    this.host.addCommand({
+      id: "cmd-saveas",
+      key: "s",
+      modifiers: "accel shift"
+    });
+    this.host.addCommand({
+      id: "cmd-save",
+      key: "s",
+      modifiers: "accel"
+    });
+
+    this.host.createMenuItem({
+      parent: "#file-menu-popup",
+      label: "Save",
+      command: "cmd-save",
+      key: "key-save"
+    });
+    this.host.createMenuItem({
+      parent: "#file-menu-popup",
+      label: "Save As",
+      command: "cmd-saveas",
+    });
+  },
+
+  onCommand: function(cmd) {
+    if (cmd === "cmd-save") {
+      this.save();
+    } else if (cmd === "cmd-saveas") {
+      this.saveAs();
+    }
+  },
+
+  saveAs: function() {
+    let editor = this.host.currentEditor;
+    let project = this.host.projectFor(editor);
+
+    let resource;
+    picker.showSave({
+      window: this.host.window,
+      directory: project && project.parent ? project.parent.path : null,
+      defaultName: project ? project.basename : null,
+    }).then(path => {
+      return this.createResource(path);
+    }).then(res => {
+      resource = res;
+      return this.saveResource(editor, resource);
+    }).then(() => {
+      this.host.openResource(resource);
+    }).then(null, console.error);
+  },
+
+  save: function() {
+    let editor = this.host.currentEditor;
+    let project = this.host.projectFor(editor);
+    if (!project) {
+      return this.saveAs();
+    }
+
+    return this.saveResource(editor, project);
+  },
+
+  createResource: function(path) {
+    return this.host.project.resourceFor(path, { create: true })
+  },
+
+  saveResource: function(editor, resource) {
+    // If this wasn't a project editor, update the project
+    // editor.
+    let shell = this.host.shellFor(resource);
+    let projectEditor = shell ? shell.editor.project : null;
+    let text = -1;
+    if (projectEditor && projectEditor !== editor) {
+      text = editor.editor.getText();
+    }
+    return editor.save(resource).then(() => {
+      if (text != -1) {
+        projectEditor.editor.setText(text);
+      }
+    });
+  }
+})
+exports.SavePlugin = SavePlugin;
+registerPlugin(SavePlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js b/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/status-bar/lib/plugin.js
@@ -0,0 +1,56 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const promise = require("itchpad/helpers/promise");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var StatusBarPlugin = Class({
+  extends: Plugin,
+
+  init: function() {
+    this.box = this.host.createElement("hbox", {
+      parent: "#itchpad-toolbar-bottom"
+    });
+
+    this.activeMode = this.host.createElement("label", {
+      parent: this.box,
+      class: "itchpad-basic-display"
+    });
+
+    this.cursorPosition = this.host.createElement("label", {
+      parent: this.box,
+      class: "itchpad-basic-display"
+    });
+  },
+
+  render: function(editor) {
+    this.activeMode.value = editor.toString();
+    if (editor.editor) {
+      let cursorStart = editor.editor.getCursor("start");
+      let cursorEnd = editor.editor.getCursor("end");
+      if (cursorStart.line === cursorEnd.line && cursorStart.ch === cursorEnd.ch) {
+        this.cursorPosition.value = cursorStart.line + " " + cursorStart.ch;
+      } else {
+        this.cursorPosition.value = cursorStart.line + " " + cursorStart.ch + " | " +
+                                    cursorEnd.line + " " + cursorEnd.ch;
+      }
+    } else {
+      this.cursorPosition.value = "";
+    }
+  },
+
+  onEditorChange: function(editor) {
+    this.render(editor);
+  },
+
+  onEditorCursorActivity: function(editor) {
+    this.render(editor);
+  },
+
+  onEditorActivated: function(editor) {
+    this.render(editor);
+  },
+
+});
+
+exports.StatusBarPlugin = StatusBarPlugin;
+registerPlugin(StatusBarPlugin);
diff --git a/browser/devtools/itchpad/lib/plugins/style/lib/style.js b/browser/devtools/itchpad/lib/plugins/style/lib/style.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/style/lib/style.js
@@ -0,0 +1,16 @@
+var { Class } = require("sdk/core/heritage");
+var { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+var StyleAnnotation = Class({
+  extends: Plugin,
+  onAnnotate: function(resource, editor) {
+    if (!resource.sheet) {
+      return;
+    }
+
+    return " (" + resource.sheet.ruleCount + " rules)";
+  }
+});
+exports.StyleAnnotation = StyleAnnotation;
+
+registerPlugin(StyleAnnotation);
diff --git a/browser/devtools/itchpad/lib/plugins/target-chooser/lib/target-chooser.js b/browser/devtools/itchpad/lib/plugins/target-chooser/lib/target-chooser.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/target-chooser/lib/target-chooser.js
@@ -0,0 +1,111 @@
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+const { emit } = require("sdk/event/core");
+const tabs = require("sdk/tabs");
+const { viewFor } = require('sdk/view/core')
+const { TargetFactory } = require("devtools/framework/target");
+const { MatchPattern } = require("sdk/util/match-pattern");
+
+var TargetChooser = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    this.updateTarget = this.updateTarget.bind(this);
+    this.unsetTarget = this.unsetTarget.bind(this);
+
+    host.on("toolbox-changed", this.checkToolbox.bind(this));
+    this.locked = true;
+    this.checkToolbox();
+  },
+
+  lateInit: function() {
+    const { ProjectSettings } = require("itchpad/plugins/project-settings");
+    let settings = this.host.getPlugin(ProjectSettings);
+    settings.addTextField({
+      group: "settings",
+      id: "url-pattern",
+      title: "URL Pattern",
+      populate: (editor) => {
+        return this.host.project.pattern;
+      },
+      onApply: (value) => {
+        return this.host.project.setPattern(value);
+      }
+    });
+  },
+
+  // If the pad has been associated with a toolbox, lock the
+  // target to that toolbox's target.
+  checkToolbox: function() {
+    if (this.host.toolbox) {
+      this.lock(this.host.toolbox.target);
+      return;
+    }
+
+    this.unlock();
+  },
+
+  // Lock the pad to a given target
+  lock: function(target) {
+    this.host.setTarget(this.host.toolbox.target);
+    if (!this.locked) {
+      tabs.removeListener("activate", this.updateTarget);
+      tabs.removeListener("ready", this.updateTarget);
+    }
+    this.locked = true;
+  },
+
+  // Follow the currently-active window and use it as the pad's
+  // target.
+  unlock: function() {
+    if (this.locked) {
+      tabs.on("activate", this.updateTarget);
+      tabs.on("ready", this.updateTarget);
+    }
+    this.locked = false;
+    this.updateTarget();
+  },
+
+  // Get a target for the currently-active tab.
+  updateTarget: function() {
+    let tab = tabs.activeTab;
+    let project = this.host.project;
+
+    if (tab.url === "about:app-manager" && project.manifestPath) {
+      let win = viewFor(tab).linkedBrowser.contentWindow.wrappedJSObject;
+      let doc = viewFor(tab).linkedBrowser.contentDocument;
+      if (!doc._targetChooserWatching) {
+        doc.addEventListener("NewTarget", this.updateTarget);
+      }
+
+      let target = null;
+      if (win.UI.targetsForManifest.has(project.manifestPath)) {
+        target = win.UI.targetsForManifest.get(project.manifestPath);
+      }
+      this.setTarget(target, false);
+    } else {
+      let pattern = new MatchPattern(project.pattern);
+      if (pattern.test(tab.url)) {
+        this.setTarget(TargetFactory.forTab(viewFor(tab)), true);
+      } else {
+        this.setTarget(null);
+      }
+    }
+  },
+
+  setTarget: function(target, owned) {
+    if (this.host.target) {
+      this.host.target.off("close", this.unsetTarget);
+    }
+    this.host.setTarget(target, owned);
+    if (target) {
+      target.on("close", this.unsetTarget);
+    }
+  },
+
+  unsetTarget: function() {
+    this.host.setTarget(null);
+  },
+});
+exports.TargetChooser = TargetChooser;
+registerPlugin(TargetChooser);
diff --git a/browser/devtools/itchpad/lib/plugins/variable-sidebar/lib/variable-sidebar.js b/browser/devtools/itchpad/lib/plugins/variable-sidebar/lib/variable-sidebar.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/plugins/variable-sidebar/lib/variable-sidebar.js
@@ -0,0 +1,70 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("itchpad/plugins/core");
+
+const { VariablesViewController } = Cu.import("resource:///modules/devtools/VariablesViewController.jsm", {});
+const { VariablesView } = Cu.import("resource:///modules/devtools/VariablesView.jsm", {});
+const { ObjectClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
+const { EnvironmentClient } = Cu.import("resource://gre/modules/devtools/dbg-client.jsm", {});
+
+const VARIABLES_VIEW_URL = "chrome://browser/content/devtools/widgets/VariablesView.xul";
+
+var VariableSidebar = Class({
+  extends: Plugin,
+
+  init: function(host) {
+    console.log("ADDING VARIABLE SIDEBAR");
+    this.sidebarTab = this.host.addSidebar("variables", VARIABLES_VIEW_URL, true);
+    this.sidebarTab.then(window => {
+      dump("GOT THE SIDEBAR\n");
+      let container = window.document.querySelector("#variables");
+
+      this.host.sidebar.show();
+      this.variablesView = new VariablesView(container, {
+        searchEnabled: true,
+        searchPlaceholder: "Search" // XXX
+      });
+      this.variablesView.emptyText = "No variable selected.";
+
+      VariablesViewController.attach(this.variablesView, {
+        getEnvironmentClient: grip => {
+          return new EnvironmentClient(this.client, grip);
+        },
+        getObjectClient: grip => {
+          return new ObjectClient(this.client, grip);
+        },
+        getLongStringClient: actor => {
+          return this.webConsoleClient.longString(actor);
+        },
+        releaseActor: actor => {
+          this.client.release(actor);
+        }
+      });
+      console.log("DONE SETTING UP VARIABLES VIEW");
+    }).then(null, console.error);
+
+    this.viewVariable = this.viewVariable.bind(this);
+    this.host.pluginMethods.viewVariable = this.viewVariable;
+  },
+
+  get client() { return this.host.target.client; },
+
+  viewVariable: function(obj) {
+
+    dump("Viewing variable!\n");
+    this.host.showSidebar("variables");
+
+    return this.host.getWebConsoleClient().then(client => {
+      this.webConsoleClient = client;
+      console.log("got a client");
+      return this.sidebarTab;
+    }).then(() => {
+      console.log("got a sidebar");
+      this.variablesView.empty();
+      this.variablesView.controller.setSingleVariable({ objectActor: obj }).expanded;
+      console.log("Done setting controller");
+    });
+  }
+});
+exports.VariableSidebar = VariableSidebar;
+registerPlugin(VariableSidebar);
diff --git a/browser/devtools/itchpad/lib/project-index.js b/browser/devtools/itchpad/lib/project-index.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/project-index.js
@@ -0,0 +1,90 @@
+const { Class } = require("sdk/core/heritage");
+const match = require("itchpad/path-match");
+
+var IndexMap = Class({
+  initialize: function() {
+    this.map = new Map();
+  },
+
+  add: function(key, item) {
+    let set = this.map.get(key)
+    if (!set) {
+      set = new Set();
+      this.map.set(key, set);
+    }
+    set.add(item);
+  },
+
+  remove: function(key, item) {
+    let set = this.map.get(key);
+    if (!set) {
+      return;
+    }
+    set.delete(item);
+  },
+
+  get: function(key) {
+    return this.map.get(key) || new Set();
+  },
+
+  keys: function() {
+    let keys = new Set();
+    for (let [key, value] of this.map) {
+      keys.add(key);
+    }
+    return keys;
+  }
+});
+
+var ProjectIndex = Class({
+  initialize: function() {
+    this.basenames = new IndexMap();
+    this.relativePaths = new IndexMap();
+  },
+
+  add: function(resource) {
+    this.basenames.add(resource.basename, resource);
+    let path = resource.relativePath();
+    this.relativePaths.add(path, resource);
+  },
+
+  remove: function(resource) {
+    this.basenames.remove(resource.basename, resource);
+  },
+
+  findBasename: function(basename) {
+    return this.basenames.get(basename);
+  },
+
+  fuzzyMatchPath: function(search) {
+    let start = Date.now();
+
+    let candidates = [];
+    for (let path of this.relativePaths.keys()) {
+      if (match.quickMatch(search, path)) {
+        candidates.push(path);
+      }
+    }
+
+    let matches = [];
+    let candidateMisses = [];
+    let re = match.pathMatchExpression(search);
+    for (let candidate of candidates) {
+      let score = match.score(re, candidate);
+      if (score > 0) {
+        for (let resource of this.relativePaths.get(candidate)) {
+          if (!resource.isDir) {
+            matches.push({ score: score, resource: resource });
+          }
+        }
+      }
+    }
+
+    console.log("Search took " + (Date.now() - start) + " and returned " + matches.length + " results.");
+
+    return matches;
+  }
+});
+exports.ProjectIndex = ProjectIndex;
+
+
diff --git a/browser/devtools/itchpad/lib/project.js b/browser/devtools/itchpad/lib/project.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/project.js
@@ -0,0 +1,392 @@
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const { scope } = require("itchpad/event/scope");
+const prefs = require("sdk/preferences/service");
+const { LocalStore, ScratchStore, OpenStore } = require("itchpad/stores/local");
+const OS = require("itchpad/helpers/osfile");
+const task = require("itchpad/helpers/task");
+const { ProjectIndex } = require("itchpad/project-index");
+const promise = require("itchpad/helpers/promise");
+const { TextEncoder, TextDecoder } = require('sdk/io/buffer');
+const { indexedDB } = require('sdk/indexed-db');
+const url = require('sdk/url');
+const { StoreCollection } = require("itchpad/store-collection");
+
+const gDecoder = new TextDecoder();
+const gEncoder = new TextEncoder();
+
+// I'm fairly certain this could be merged with the app-manager project
+// store with a bit of work on the app-manager side.
+var IDBProjectStore = {
+  _db: null,
+
+  _request: function(request) {
+    let deferred = promise.defer();
+    request.onerror = function(event) {
+      deferred.reject(event.target.errorCode);
+    };
+    request.onsuccess = function(event) {
+      deferred.resolve(event.target.result);
+    }
+    return deferred.promise;
+  },
+
+  _open: function() {
+    if (this._openPromise) {
+      return this._openPromise;
+    }
+
+    let deferred = promise.defer();
+    this._openPromise = deferred.promise;
+
+    let request = indexedDB.open("DevtoolsEditorProjects", 1);
+    request.onerror = (event) => {
+      deferred.reject("Unable to open DevtoolsEdtiorProjects indexedDB. " +
+                       "Error code: " + event.target.errorCode);
+    };
+    request.onupgradeneeded = (event) => {
+      let db = event.target.result;
+      db.createObjectStore("projects", { keyPath: "id" });
+    };
+    request.onsuccess = () => {
+      deferred.resolve(request.result);
+    };
+
+    return this._openPromise;
+  },
+
+  all: function() {
+    if (this._cachedProjects) {
+      return this._cachedProjects;
+    }
+
+    this._cachedProjects = this._open().then(db => {
+      let objectStore = db.transaction("projects").objectStore("projects");
+
+      let projects = [];
+      let deferred = promise.defer();
+      objectStore.openCursor().onsuccess = (event) => {
+        let cursor = event.target.result;
+        if (cursor) {
+          projects.push(cursor.value);
+          cursor.continue();
+        } else {
+          deferred.resolve(projects);
+        }
+      };
+      return deferred.promise;
+    });
+
+    return this._cachedProjects;
+  },
+
+  get: function(id) {
+    return this.all().then(projects => {
+      for (let project of projects) {
+        if (project.id === id) {
+          return project;
+        }
+      }
+      return null;
+    });
+  },
+
+  add: function(project) {
+    return this._open().then(db => {
+      if (!project.id) {
+        return promise.reject("Project must have an id field");
+      }
+
+      return this._request(db.transaction(["projects"], "readwrite")
+        .objectStore("projects")
+        .add(project)).then(() => {
+          this._cachedProjects = null;
+          return project;
+        });
+    });
+  },
+
+  update: function(project) {
+    return this._open().then(db => {
+      return this._request(db.transaction(["projects"], "readwrite")
+        .objectStore("projects")
+        .put(project)).then(() => {
+          this._cachedProjects = null;
+          return project;
+        });
+    });
+  },
+
+  remove: function(id) {
+    return this._open().then(db => {
+      return this._request(this._db.transaction(["projects"], "readwrite")
+        .objectStore("projects")
+        .delete(id)).then(() => { this._cachedProjects = null; });
+    });
+  }
+};
+
+var Projects = Class({
+  initialize: function() {
+    this.store = IDBProjectStore;
+    this._projectsById = new Map();
+  },
+
+  projectForID: function(id, create=false) {
+    if (this._projectsById.has(id)) {
+      return promise.resolve(this._projectsById.get(id));
+    }
+
+    return this.store.get(id).then(obj => {
+      if (!obj && !create) {
+        throw new Error("Project doesn't exist with id: " + id);
+      }
+
+      if (obj) {
+        return obj;
+      }
+
+      obj = emptyProject();
+      obj.id = id;
+      return this.store.add(obj);
+    }).then(obj => {
+      let proj = new Project(obj);
+      this._projectsById.set(id, proj);
+      return proj;
+    });
+  },
+
+  // Return the default project.
+  defaultProject: function() {
+    return this.projectForID("default", true);
+  },
+
+  forManifest: function(path) {
+    let id = "app:" + OS.Path.normalize(path);
+    let dir = OS.Path.dirname(path);
+
+    return this.projectForID(id, true).then(project => {
+      project.setManifest(path);
+      project.addPath(dir);
+      return project;
+    });
+  },
+});
+exports.Projects = new Projects();
+
+function emptyProject() {
+  return {
+    directories: [],
+    openFiles: []
+  };
+}
+
+// A project holds a list of local folders and maintains LocalStore objects
+// representing them.
+var Project = Class({
+  extends: StoreCollection,
+
+  initialize: function(info) {
+    StoreCollection.prototype.initialize.call(this);
+
+    this.index = new ProjectIndex();
+    this.localStores = new Map();
+
+    this.on("resource-added", this.onResourceAdded.bind(this));
+    this.on("resource-removed", this.onResourceRemoved.bind(this));
+
+    // this.addScratchStore();
+    // this.addOpenStore();
+
+    this.load(info);
+  },
+
+  toString: function() { return "[Project] " + this.name; },
+
+  load: function(data) {
+    this.id = data.id;
+    this.name = data.name || "Untitled";
+    if (data.pattern) {
+      this.pattern = data.pattern;
+      this.manualPattern = true;
+    } else {
+      this.pattern = "*";
+    }
+
+    let paths = new Set(data.directories.map(name => OS.Path.normalize(name)));
+
+    for (let [path, store] of this.localStores) {
+      if (!paths.has(path)) {
+        this.removePath(path);
+      }
+    }
+
+    for (let path of paths) {
+      this.addPath(path);
+    }
+
+    this.setManifest(data.manifestPath);
+  },
+
+  save: function() {
+    let data = emptyProject();
+
+    data.id = this.id;
+    data.name = this.name;
+    if (this.manualPattern) {
+      data.pattern = this.pattern;
+    }
+    data.manifest = this.manifestPath;
+    data.directories = [store.path for ([id, store] of this.localStores)];
+    // data.openFiles = [resource.path for (resource of this.openStore.root.children)];
+    // console.log("Saving project with the following directories: ", this, data.directories.join(", "))
+    return IDBProjectStore.update(data).then(() => {
+      emit(this, "project-saved");
+    });
+  },
+
+  setManifest: function(path, json=null) {
+    this.manifestPath = path;
+
+    let promise = json ? promise.resolve(json) : (OS.File.read(path).then(bytes => {
+      return JSON.parse(gDecoder.decode(bytes));
+    }));
+
+    return promise.then(json => {
+      this.manifest = json;
+      this.name = this.manifest.name || this.name;
+      if (!this.manualPattern) {
+        let dir = url.fromFilename(OS.Path.dirname(this.manifestPath));
+        this.pattern = dir + "*";
+      }
+    });
+  },
+
+  setName: function(name) {
+    this.name = name;
+    return this.save().then(() => {
+      emit(this, "name-change");
+    });
+  },
+
+  setPattern: function(pattern) {
+    this.manualPattern = true;
+    this.pattern = pattern;
+    return this.save().then(() => {
+      emit(this, "pattern-change");
+    });
+  },
+
+  refresh: function() {
+    return task.spawn(function*() {
+      // yield this.scratchStore.refresh();
+      for (let [path, store] of this.localStores) {
+        yield store.refresh();
+      }
+    }.bind(this));
+  },
+
+  resourceFor: function(path, options) {
+    let store = this.storeContaining(path);
+    // if (!store) {
+    //   store = this.openStore;
+    // }
+    return store.resourceFor(path, options);
+  },
+
+  allStores: function*() {
+    // yield this.scratchStore;
+    // yield this.openStore;
+    for (let [path, store] of this.localStores) {
+      yield store;
+    }
+  },
+
+  storeContaining: function(path) {
+    let ret = null;
+    for (let [id, store] of this.localStores) {
+      if (store.contains(path)) {
+        if (ret) {
+          // XXX
+          console.warning("Nested projects are going to cause pain.");
+        }
+        ret = store;
+      }
+    }
+    return ret;
+  },
+
+  addPath: function(path) {
+    if (!this.localStores.has(path)) {
+      this.addLocalStore(new LocalStore(path));
+    }
+  },
+
+  removePaths: function(paths) {
+    for (let path of paths) {
+      this.removePath(path);
+    }
+  },
+
+  removePath: function(path) {
+    this.removeLocalStore(this.localStores.get(path));
+    this.localStores.delete(path);
+  },
+
+  addLocalStore: function(store) {
+    store.canPair = true;
+    this.localStores.set(store.path, store);
+    this.addStore(store);
+  },
+
+  removeLocalStore: function(store) {
+    if (store) {
+      this.localStores.delete(store.path);
+      this.removeStore(store);
+    }
+  },
+
+  // addScratchStore: function() {
+  //   this.scratchStore = new ScratchStore();
+  //   this.scratchStore.canPair = false;
+  //   this.addStore(this.scratchStore);
+  // },
+
+  // isScratchStore: function(store) {
+  //   return store === this.scratchStore;
+  // },
+
+  // addOpenStore: function() {
+  //   this.openStore = new OpenStore();
+  //   this.openStore.canPair = false;
+  //   this.addStore(this.openStore);
+  // },
+
+  // isOpenStore: function(store) {
+  //   return store === this.openStore;
+  // },
+
+  onResourceAdded: function(resource) {
+    // Automatically use a manifest for this project if we find
+    // one in the only store that exists in the project.
+    if (!this.manifest
+        && resource.basename === "manifest.webapp"
+        && resource.parent === resource.store.root
+        && this.localStores.size === 1) {
+      this.setManifest(resource.path);
+    }
+
+    try {
+      this.index.add(resource);
+    } catch(ex) {
+      console.error(ex);
+    }
+  },
+
+  onResourceRemoved: function(resource) {
+    this.index.remove(resource);
+  }
+});
+exports.Project = Project;
+
diff --git a/browser/devtools/itchpad/lib/resource-map.js b/browser/devtools/itchpad/lib/resource-map.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/resource-map.js
@@ -0,0 +1,288 @@
+const { Class } = require("sdk/core/heritage");
+const { emit } = require("sdk/event/core");
+const { EventTarget } = require("sdk/event/target");
+const timers = require("sdk/timers");
+const { on, off, forget } = require("itchpad/event/scope");
+
+var Pair = Class({
+  extends: EventTarget,
+
+  initialize: function(map, project=null, live=null) {
+    this.map = map;
+    this._updateSource("project", project, false);
+    this._updateSource("live", live, false);
+  },
+
+  toString: function() {
+    return "[Pair " + this._project + ":" + this._live + "]";
+  },
+
+  get project() { return this._project },
+  set project(resource) {
+    this._updateSource("project", resource, true);
+  },
+
+  get live() { return this._live },
+  set live(resource) {
+    this._updateSource("live", resource, true);
+  },
+
+  _updateSource: function(aspect, resource, notify) {
+    let val = "_" + aspect;
+    let map = this.map;
+
+    if (resource === this[val]) {
+      return;
+    }
+
+    if (resource) {
+      // No other pair can own this.
+      let other = map.pairs.get(resource);
+      if (other) {
+        other[aspect] = null;
+      }
+    }
+
+    if (this[val]) {
+      map.pairs.delete(this[val]);
+    }
+
+    this[val] = resource;
+
+    if (resource) {
+      map.pairs.set(resource, this);
+    }
+
+    if (notify) {
+      emit(this, "changed", aspect);
+    }
+  }
+});
+
+exports.Pair = Pair;
+
+// Maintains the list of pairs.
+var ResourceMap = Class({
+  initialize: function() {
+    this.liveStores = new Set();
+    this.pairs = new Map();
+    this.manualPairs = new Map();
+
+    this.scheduleRebuild = this.scheduleRebuild.bind(this);
+  },
+
+  setProject: function(project) {
+    this.unwatchCollection(this.project);
+    this.project = project;
+    this.watchCollection(this.project);
+    this.scheduleRebuild();
+  },
+
+  setPage: function(page) {
+    this.unwatchCollection(this.page);
+    this.page = page;
+    this.watchCollection(this.page);
+    this.scheduleRebuild();
+  },
+
+  watchCollection: function(collection) {
+    on(this, collection, "resource-added", this.scheduleRebuild);
+    on(this, collection, "resource-removed", this.scheduleRebuild);
+  },
+
+  unwatchCollection: function(collection) {
+    forget(this, collection);
+  },
+
+  scheduleRebuild: function() {
+    if (this._scheduledRebuild) {
+      timers.clearTimeout(this._scheduledRebuild);
+    }
+    this._scheduledRebuild = timers.setTimeout(this.rebuild.bind(this), 100);
+  },
+
+  manualPair: function(project, live) {
+    let pair;
+
+    let pair = this.pairs.get(project);
+    if (!pair) {
+      pair = this.pairs.get(live);
+    }
+    if (!pair) {
+      pair = new Pair(this, project, live);
+    }
+    pair.project = project;
+    pair.live = live;
+
+    // XXX: Manual pairs should probably be by path, otherwise
+    // they won't last through a refresh.  Will fix that later.
+    this.manualPairs.set(live, pair);
+    this.rebuild();
+  },
+
+  /**
+   * Rebuild the project pairings.
+   */
+  rebuild: function() {
+    if (this._scheduledRebuild) {
+      timers.clearTimeout(this._scheduledRebuild);
+      this._scheduledRebuild = null;
+    }
+    let start = Date.now();
+    // Rules:
+    // - Pairs stay with the local resource if they change.
+
+    let newPairs = new Map();
+
+    // Walk through all live resources...
+    for (let live of this.page.allResources()) {
+      if (live.isDir) {
+        continue;
+      }
+
+      // If there's a manual pair, just trust it.
+      if (this.manualPairs.has(live)) {
+        let manual = this.manualPairs.get(live);
+        newPairs.set(manual.project, manual);
+        newPairs.set(manual.live, manual);
+        continue;
+      }
+
+      // Find a project resource for this resource...
+      let project = this._findPair(live);
+
+      if (!project) {
+        // No paired resource, no need to save a pair, but do
+        // keep the one-sided pair around if there is one.
+        let oldPair = this.pairs.get(live);
+        if (oldPair) {
+          // Just in case.
+          oldPair.project = null;
+
+          newPairs.set(live, oldPair);
+        }
+        continue;
+      }
+
+      // We have a real pair.  Update it if it already exists.
+      // XXX: This could leave us with an empty pair, make
+      // sure editors close properly...
+      let pair = this.pairs.get(project);
+      if (pair) {
+        pair.live = live;
+      } else {
+        pair = new Pair(this, project, live);
+      }
+      newPairs.set(live, pair);
+      newPairs.set(project, pair);
+
+      // Remove the project link from the map so the next pass
+      // doesn't pick it up.
+      this.pairs.delete(project);
+    }
+
+    // Now newPairs has pairs for all live resources that
+    // need them (either because they already had a single-sided pair
+    // in the wild or because they found a real pair)
+    // Now make sure that any project resources with an outstanding pair
+    // are included.
+    for (let project of this.project.allResources()) {
+      let newPair = newPairs.get(project);
+      if (newPair) {
+        // Already taken care of.
+        continue;
+      }
+      let oldPair = this.pairs.get(project);
+      if (oldPair) {
+        oldPair.live = null;
+        newPairs.set(project, oldPair);
+      }
+    }
+
+    this.pairs = newPairs;
+    let end = Date.now();
+    console.log("Rebuilt project map in " + (end - start) + "ms");
+  },
+
+  pair: function(resource) {
+    if (this.pairs.has(resource)) {
+      return this.pairs.get(resource);
+    }
+
+    // Didn't find a pair in the project map, go ahead and create
+    // a one-sided pair.
+    let pair;
+    if (resource.isProject) {
+      pair = new Pair(this, resource, null);
+    } else {
+      pair = new Pair(this, null, resource);
+    }
+    this.pairs.set(resource, pair);
+    return pair;
+  },
+
+  /**
+   * Find the best project pair for a given live resource.
+   *
+   * Right now we only have one strategy, but new strategies
+   * can be added here.
+   */
+  _findPair: function(live) {
+    return this._fuzzyStrategy(live);
+  },
+
+  /**
+   * The default fuzzy match strategy for finding a live pairing.
+   * Finds a project resources with the same basename, and chooses
+   * the one with the most path component matches.
+   */
+  _fuzzyStrategy: function(resource) {
+    let matches = this._findBasenameMatches(resource.basename);
+    if (matches.length < 1) {
+      return null;
+    }
+
+    let searchPath = resource.uri.path.split('/').filter(item => !!item);
+    searchPath.reverse();
+
+    let bestMatch = null;
+    let bestMatchComponents = 0;
+    let bestMatchExtra = 1000;
+    for (let match of matches) {
+      let matchPath = match.uri.path.split('/').filter(item => !!item);
+      matchPath.reverse();
+      let i;
+      for (i = 0; i < matchPath.length && i < searchPath.length; i++) {
+        if (matchPath[i] != searchPath[i]) {
+          break;
+        }
+      }
+
+      // In case of a tie in matched components, arbitrarily assume that
+      // resources closer to the project root are correct.
+      let remaining = matchPath.length - i;
+      if (i > bestMatchComponents ||
+          (i === bestMatchComponents && remaining < bestMatchExtra)) {
+        bestMatch = match;
+        bestMatchComponents = i;
+        bestMatchExtra = remaining;
+      }
+    }
+
+    return bestMatch;
+  },
+
+  _findBasenameMatches: function(basename) {
+    let matches = [];
+    for (let resource of this.project.index.findBasename(basename)) {
+      if (!resource.store.canPair) {
+        continue;
+      }
+      matches.push(resource);
+    }
+    return matches;
+  }
+});
+exports.ResourceMap = ResourceMap;
+
+
diff --git a/browser/devtools/itchpad/lib/shells.js b/browser/devtools/itchpad/lib/shells.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/shells.js
@@ -0,0 +1,133 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const { EditorTypeForResource } = require("itchpad/editors");
+const NetworkHelper = require("devtools/toolkit/webconsole/network-helper");
+
+var Shell = Class({
+  extends: EventTarget,
+
+  initialize: function(host, pair, selectedResource) {
+    this.host = host;
+    this.doc = host.document;
+    this.pair = pair;
+    this.project = pair.project;
+    this.live = pair.live;
+    this.elt = this.doc.createElement("vbox");
+    this.elt.shell = this;
+
+    this.editor = null;
+
+    this._ensureEditor();
+  },
+
+  _ensureEditor: function() {
+    if (this.editor) {
+      let editor = this.editor;
+      editor.appended.then(() => {
+        emit(this, "editor-activated", editor);
+      });
+      return;
+    }
+
+    let project = this.project;
+    let constructor = EditorTypeForResource(project);
+
+    if (this.host.plugins) {
+      this.host.plugins.forEach(plugin => {
+        if (plugin.editorForResource) {
+          let pluginEditor = plugin.editorForResource(project);
+          if (pluginEditor) {
+            constructor = pluginEditor;
+          }
+        }
+      });
+    }
+
+    let editor = constructor(this.doc, this.host);
+    editor.appended.then(() => {
+      emit(this, "editor-created", editor);
+    });
+
+    this.editor = editor;
+    editor.shell = this;
+    editor.pair = this.pair;
+
+    this.elt.appendChild(editor.elt);
+    editor.appended.then(() => {
+      emit(this, "editor-activated", editor);
+    });
+    editor.load(project);
+  }
+});
+
+var ShellDeck = Class({
+  extends: EventTarget,
+
+  initialize: function(document, host) {
+    this.doc = document;
+    this.host = host;
+    this.deck = this.doc.createElement("deck");
+    this.deck.setAttribute("flex", "1");
+    this.elt = this.deck;
+
+    this.shells = new Map();
+
+    this._deactivateEditor = null;
+  },
+
+  open: function(pair, defaultResource) {
+    // XXX: This doesn't work if pairing changes...
+    let shell = this.shells.get(pair);
+    if (!shell) {
+      shell = this.createShell(pair, defaultResource);
+      this.shells.set(pair, shell);
+    }
+    this.selectShell(shell);
+    return shell;
+  },
+
+  shellFor: function(resource) {
+    return this.shells.get(resource);
+  },
+
+  selectShell: function(shell) {
+    if (this.deck.selectedPanel.shell != shell) {
+      this.deck.selectedPanel = shell.elt;
+    }
+    if (this._deactivateEditor != shell.editor) {
+      emit(this, "editor-deactivated", this._deactivateEditor);
+      shell.editor.appended.then(() => {
+        emit(this, "editor-activated", shell.editor);
+      });
+      this._deactivateEditor = shell.editor;
+    }
+  },
+
+  get currentShell() {
+    return this.deck.selectedPanel ? this.deck.selectedPanel.shell : null;
+  },
+
+  get currentEditor() {
+    let shell = this.currentShell;
+    return shell ? shell.editor : shell;
+  },
+
+  createShell: function(pair, defaultResource) {
+    let shell = Shell(this.host, pair, defaultResource);
+    shell.on("editor-created", (editor) => {
+      this.shells.set(shell.project, editor);
+      emit(this, "editor-created", editor);
+    });
+    shell.on("editor-activated", (editor) => {
+      if (this.currentShell === shell) {
+        emit(this, "editor-activated", editor);
+      }
+    });
+
+    this.deck.appendChild(shell.elt);
+    return shell;
+  },
+});
+exports.ShellDeck = ShellDeck;
diff --git a/browser/devtools/itchpad/lib/store-collection.js b/browser/devtools/itchpad/lib/store-collection.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/store-collection.js
@@ -0,0 +1,53 @@
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const { on, forget } = require("itchpad/event/scope");
+
+var StoreCollection = Class({
+  extends: EventTarget,
+
+  initialize: function() {
+    this.stores = new Set();
+  },
+
+  allStores: function*() {
+    for (let store of this.stores) {
+      yield store;
+    }
+  },
+
+  allResources: function*() {
+    for (let store of this.stores) {
+      for (let [key, resource] of store.resources) {
+        yield resource;
+      }
+    }
+  },
+
+  addStore: function(store) {
+    this.stores.add(store);
+    for (let resource of store.allResources()) {
+      this.onResourceAdded(resource);
+    }
+    on(this, store, "resource-added", (resource) => {
+      emit(this, "resource-added", resource);
+    });
+    on(this, store, "resource-removed", (resource) => {
+      emit(this, "resource-removed", resource);
+    })
+
+    emit(this, "store-added", store);
+  },
+
+  removeStore: function(store) {
+    store.destroy();
+    this.stores.delete(store);
+    for (let resource of store.allResources()) {
+      this.onResourceRemoved(resource);
+    }
+    forget(this, store);
+    emit(this, "store-removed", store);
+  }
+});
+
+exports.StoreCollection = StoreCollection;
diff --git a/browser/devtools/itchpad/lib/stores/base.js b/browser/devtools/itchpad/lib/stores/base.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/stores/base.js
@@ -0,0 +1,164 @@
+const { Cc, Ci, Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const URL = require("sdk/url");
+const promise = require("itchpad/helpers/promise");
+
+/**
+ * A Store object maintains a collection of Resource objects stored in a tree.
+ * A given store is either a Project store or a Live store.
+ */
+var Store = Class({
+  extends: EventTarget,
+
+  // Should be called during initialize() of a subclass.
+  initStore: function() {
+    this.resources = new Map();
+  },
+
+  // Set the root resource.
+  setRoot: function(resource) {
+    this.root = resource;
+    this.notifyAdd(resource);
+  },
+
+  refresh: function() {
+    return promise.resolve();
+  },
+
+  allResources: function*() {
+    for (let [key, resource] of this.resources) {
+      yield resource;
+    }
+  },
+
+  notifyAdd: function(resource) {
+    emit(this, "resource-added", resource);
+  },
+
+  notifyRemove: function(resource) {
+    emit(this, "resource-removed", resource);
+  },
+
+  notifyMissing: function(oldChildren, newChildren) {
+    for (let item of oldChildren) {
+      if (!newChildren.has(item)) {
+        this.notifyRemove(item);
+      }
+    }
+  }
+});
+
+ProjectStore = Class({
+  extends: Store,
+  isProject: true,
+  isLive: false,
+  aspect: "project"
+});
+exports.ProjectStore = ProjectStore;
+
+LiveStore = Class({
+  extends: Store,
+  isProject: false,
+  isLive: true,
+  aspect: "live"
+});
+exports.LiveStore = LiveStore;
+
+var Resource = Class({
+  extends: EventTarget,
+
+  get isProject() { return this.store.isProject },
+  get aspect() { return this.store.aspect },
+
+  refresh: function() { return promise.resolve(this) },
+
+  setURI: function(uri) {
+    if (typeof(uri) === "string") {
+      uri = URL.URL(uri);
+    }
+    this._uriBasename = uriBasename(uri);
+    this.uri = uri;
+  },
+
+  get basename() { return this._uriBasename },
+  get displayName() { return this.basename },
+
+  get isDir() { return this.children !== undefined; },
+  get hasChildren() { return this.children && this.children.size > 0; },
+
+  setChildren: function(newChildren) {
+    let oldChildren = this.children || new Set();
+    let change = false;
+
+    for (let child of oldChildren) {
+      if (!newChildren.has(child)) {
+        change = true;
+        child.parent = null;
+        this.store.notifyRemove(child);
+      }
+    }
+
+    for (let child of newChildren) {
+      if (!oldChildren.has(child)) {
+        change = true;
+        child.parent = this;
+        this.store.notifyAdd(child);
+      }
+    }
+
+    this.children = newChildren;
+    if (change) {
+      emit(this, "children-changed", this);
+    }
+  },
+
+  addChild: function(resource) {
+    this.children = this.children || new Set();
+
+    resource.parent = this;
+    this.children.add(resource);
+    this.store.notifyAdd(resource);
+    emit(this, "children-changed", this);
+    return resource;
+  },
+
+  removeChild: function(resource) {
+    resource.parent = null;
+    this.children.remove(resource);
+    this.store.notifyRemove(resource);
+    emit(this, "children-changed", this);
+    return resource;
+  },
+
+  get contentType() { return "text/plain" },
+  get contentCategory() {
+    const NetworkHelper = require("devtools/toolkit/webconsole/network-helper");
+    let category = NetworkHelper.mimeCategoryMap[this.contentType];
+    // Boo hard-coding.
+    if (!category && this.basename === "manifest.webapp") {
+      return "json";
+    }
+    return category || "txt";
+  }
+});
+
+exports.Resource = Resource;
+
+// Surely there's a better way to do this.
+function uriBasename(uri) {
+  var basename = uri.path;
+
+  let idx = uri.path.lastIndexOf("/", basename.length - 2);
+  if (idx > -1) {
+    basename = uri.path.substring(idx + 1);
+  }
+
+  if (basename[basename.length - 1] === "/") {
+    basename = basename.substring(0, basename.length - 1);
+  }
+
+  return basename;
+}
+
diff --git a/browser/devtools/itchpad/lib/stores/local.js b/browser/devtools/itchpad/lib/stores/local.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/stores/local.js
@@ -0,0 +1,388 @@
+/**
+ * Hastily-written local file backend for ItchPad
+ */
+
+const { Cc, Ci, Cu, ChromeWorker } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { TextEncoder, TextDecoder } = require('sdk/io/buffer')
+const { emit } = require("sdk/event/core");
+const { ProjectStore, Resource } = require("itchpad/stores/base");
+const task = require("itchpad/helpers/task");
+const data = require("sdk/self").data;
+const promise = require("itchpad/helpers/promise");
+const Task = require("itchpad/helpers/task");
+const URL = require("sdk/url");
+const OS = require("itchpad/helpers/osfile");
+const { FileUtils } = Cu.import("resource://gre/modules/FileUtils.jsm", {});
+const mimeService = Cc["@mozilla.org/mime;1"].getService(Ci.nsIMIMEService);
+
+
+const CHECK_LINKED_DIRECTORY_DELAY = 5000;
+const SHOULD_LIVE_REFRESH = true;
+const spawn = Task.spawn;
+
+const gDecoder = new TextDecoder();
+const gEncoder = new TextEncoder();
+
+// XXX: Ignores should probably be handled differently.
+const IGNORE_REGEX = /(^\.)|(\~$)|(^node_modules$)/;
+
+var LocalStore = Class({
+  extends: ProjectStore,
+
+  defaultCategory: "js",
+
+  initialize: function(path) {
+    this.initStore();
+    this.window = Cc["@mozilla.org/appshell/appShellService;1"].getService(Ci.nsIAppShellService).hiddenDOMWindow;
+    this.path = OS.Path.normalize(path);
+    this.rootPath = this.path;
+    this.displayName = this.path;
+    this.setRoot(this._forPath(this.path));
+    this.refreshLoop = this.refreshLoop.bind(this);
+    this.refreshLoop();
+  },
+
+  destroy: function() {
+    this.window.clearTimeout(this._refreshTimeout);
+    this._refreshTimeout = null;
+    this.window = null;
+  },
+
+  toString: function() { return "[LocalStore:" + this.path + "]" },
+
+  /**
+   * Return a FileResource object for the given path.  If a FileInfo
+   * is provided, the resource will use it, otherwise the FileResource
+   * might not have full information until the next refresh.
+   */
+  _forPath: function(path, info=null) {
+    if (this.resources.has(path)) {
+      return this.resources.get(path);
+    }
+
+    let resource = FileResource(this, path, info);
+    this.resources.set(path, resource);
+    return resource;
+  },
+
+  /**
+   * Return a promise that resolves to a fully-functional FileResource
+   * within this project.  This will hit the disk for stat info.
+   * options:
+   *   create: If true, a resource will be created even if the underlying
+   *     file doesn't exist.
+   */
+  resourceFor: function(path, options) {
+    path = OS.Path.normalize(path);
+
+    if (this.resources.has(path)) {
+      return promise.resolve(this.resources.get(path));
+    }
+
+    if (!this.contains(path)) {
+      return promise.reject(new Error(path + " does not belong to " + this.path));
+    }
+
+    return spawn(function() {
+      let parent = yield this.resourceFor(OS.Path.dirname(path));
+
+      let info;
+      try {
+        info = yield OS.File.stat(path);
+      } catch (ex if ex instanceof OS.File.Error && ex.becauseNoSuchFile) {
+        if (!options.create) {
+          throw ex;
+        }
+      }
+
+      let resource = this._forPath(path, info);
+      parent.addChild(resource);
+      throw new Task.Result(resource);
+    }.bind(this));
+  },
+
+  refreshLoop: function() {
+    // XXX: Once Bug 958280 adds a watch function, will not need to forever loop here.
+    this.refresh().then(() => {
+      if (SHOULD_LIVE_REFRESH) {
+        this._refreshTimeout = this.window.setTimeout(this.refreshLoop,
+          CHECK_LINKED_DIRECTORY_DELAY);
+      }
+    });
+  },
+
+  _refreshTimeout: null,
+  _refreshPromise: null,
+
+  /**
+   * Refresh the directory structure.
+   */
+  refresh: function(path=this.rootPath) {
+    if (this._refreshPromise) {
+      return this._refreshPromise.promise;
+    }
+
+    this._refreshPromise = promise.defer();
+
+    let worker = new ChromeWorker("chrome://browser/content/devtools/readdir.js");
+    let start = Date.now();
+
+    worker.onmessage = evt => {
+      // console.log("Directory read finished in " + ( Date.now() - start ) +"ms", evt);
+      for (path in evt.data) {
+        let info = evt.data[path];
+        info.path = path;
+
+        let resource = this._forPath(path, info);
+        resource.info = info;
+        if (info.isDir) {
+          let newChildren = new Set();
+          for (let childPath of info.children) {
+            childInfo = evt.data[childPath];
+            newChildren.add(this._forPath(childPath, childInfo));
+          }
+          resource.setChildren(newChildren);
+        }
+        resource.info.children = null;
+      }
+
+      worker = null;
+      this._refreshPromise.resolve();
+      this._refreshPromise = null;
+    };
+    worker.onerror = ex => {
+      console.error(ex);
+      worker = null;
+      this._refreshPromise.reject(ex);
+      this._refreshPromise = null;
+    }
+    worker.postMessage({ path: this.rootPath, ignore: IGNORE_REGEX });
+    return this._refreshPromise.promise;
+  },
+
+  /**
+   * Returns true if the given path would be a child of the store's
+   * root directory.
+   */
+  contains: function(path) {
+    path = OS.Path.normalize(path);
+    let thisPath = OS.Path.split(this.rootPath);
+    let thatPath = OS.Path.split(path)
+
+    if (!(thisPath.absolute && thatPath.absolute)) {
+      throw new Error("Contains only works with absolute paths.");
+    }
+
+    if (thisPath.winDrive && (thisPath.winDrive != thatPath.winDrive)) {
+      return false;
+    }
+
+    if (thatPath.components.length <= thisPath.components.length) {
+      return false;
+    }
+
+    for (let i = 0; i < thisPath.components.length; i++) {
+      if (thisPath.components[i] != thatPath.components[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+});
+exports.LocalStore = LocalStore;
+
+var FileResource = Class({
+  extends: Resource,
+
+  initialize: function(store, path, info) {
+    this.store = store;
+    this.path = path;
+
+    this.setURI(URL.URL(URL.fromFilename(path)));
+    this._lastReadModification = undefined;
+
+    this.info = info;
+    this.parent = null;
+  },
+
+  toString: function() {
+    return "[FileResource:" + this.path + "]";
+  },
+
+  refresh: function() {
+    console.log("Starting refresh");
+    return OS.File.stat(this.path).then(info => {
+      console.log("refresh complete!");
+      this.info = info;
+      return this;
+    });
+  },
+
+  get displayName() { return this.basename + (this.isDir ? "/" : "") },
+
+  get isDir() {
+    if (!this.info) { return false; }
+    return this.info.isDir && !this.info.isSymLink;
+  },
+
+  /**
+   * Returns the path relative to the store.  This is used for
+   * project search, there might be a better approach.
+   */
+  relativePath: function() {
+    if (!this._relativePath) {
+      if (this.path.startsWith(this.store.path)) {
+        this._relativePath = OS.Path.basename(this.store.path) + this.path.substring(this.store.path.length);
+      } else {
+        this._relativePath = this.path;
+      }
+    }
+    return this._relativePath;
+  },
+
+  /**
+   * Returns the text of the file as a promise.
+   */
+  load: function() {
+    return OS.File.read(this.path).then(bytes => {
+      return gDecoder.decode(bytes);
+    });
+  },
+
+  createChild: function(name, initial="") {
+    console.log("CREATING " + name);
+    if (!this.isDir) {
+      return promise.reject(new Error("Cannot add child to a regular file"));
+    }
+
+    let newPath = OS.Path.join(this.path, name);
+
+    let buffer = initial ? gEncoder.encode(initial) : "";
+    return OS.File.writeAtomic(newPath, buffer, {
+      noOverwrite: true
+    }).then(() => {
+      return this.store.refresh();
+    }).then(() => {
+      let resource = this.store.resources.get(newPath);
+      if (!resource) {
+        throw new Error("Error creating " + newPath);
+      }
+      return resource;
+    });
+  },
+
+  /**
+   * Write a string to the file.
+   */
+  save: function(str) {
+    let buffer = gEncoder.encode(str);
+    let path = this.path;
+
+    // XXX: This was losing permissions on save
+    // return OS.File.writeAtomic(this.path, buffer, { tmpPath: this.path + ".tmp" });
+
+    return task.spawn(function*() {
+        let pfh = yield OS.File.open(path, {truncate: true});
+        yield pfh.write(buffer);
+        yield pfh.close();
+    });
+  },
+
+  get contentType() {
+    if (this._contentType) {
+      return this._contentType;
+    }
+    if (this.isDir) {
+      return "x-directory/normal";
+    }
+    try {
+      this._contentType = mimeService.getTypeFromFile(new FileUtils.File(this.path));
+    } catch(ex) {
+      console.error(ex);
+      this._contentType = null;
+    }
+    return this._contentType;
+  }
+});
+
+var ScratchStore = Class({
+  extends: LocalStore,
+
+  initialize: function() {
+    let path = OS.Path.join(OS.Constants.Path.profileDir, "Scratch");
+    this.path = path;
+    this.initStore();
+    this.rootPath = path;
+    this.displayName = "Scratch";
+    this.setRoot(ScratchRoot(this, this.rootPath));
+    this.resources.set(path, this.root);
+
+    OS.File.makeDir(path, {
+      ignoreExisting: true
+    }).then(() => {
+      this.refresh();
+    });
+  }
+});
+exports.ScratchStore = ScratchStore;
+
+var ScratchRoot = Class({
+  extends: FileResource,
+
+  initialize: function(store, path, info) {
+    FileResource.prototype.initialize.call(this, store, path, info);
+  },
+
+  get displayName() { return "Scratch" }
+});
+
+var OpenStore = Class({
+  extends: LocalStore,
+
+  initialize: function() {
+    this.initStore();
+    this.displayName = "Open";
+    this.setRoot(OpenRoot(this));
+  },
+
+  toString: function() { return "[OpenStore]"; },
+
+  resourceFor: function(path, options) {
+    path = OS.Path.normalize(path);
+
+    if (this.resources.has(path)) {
+      return promise.resolve(this.resources.get(path));
+    }
+
+    return spawn(function() {
+      let info;
+      try {
+        info = yield OS.File.stat(path);
+      } catch (ex if ex instanceof OS.File.Error && ex.becauseNoSuchFile) {
+        if (!options.create) {
+          throw ex;
+        }
+      }
+      let resource = this._forPath(path, info);
+      this.root.addChild(resource);
+      throw new Task.Result(resource);
+    }.bind(this));
+  }
+});
+exports.OpenStore = OpenStore;
+
+var OpenRoot = Class({
+  extends: FileResource,
+
+  initialize: function(store) {
+    this.store = store;
+    this.children = new Set();
+  },
+
+  toString: function() { return "[OpenStore Root]"; },
+
+  get displayName() { return "Open Files" },
+  get isDir() { return true; },
+});
+
diff --git a/browser/devtools/itchpad/lib/stores/styles.js b/browser/devtools/itchpad/lib/stores/styles.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/stores/styles.js
@@ -0,0 +1,182 @@
+const { Cu } = require("chrome");
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const promise = require("itchpad/helpers/promise");
+const URL = require("sdk/url");
+
+const { StyleSheetsFront } = require("devtools/server/actors/stylesheets");
+const { StyleEditorFront } = require("devtools/server/actors/styleeditor");
+const {CssLogic} = require("devtools/styleinspector/css-logic");
+
+const { LiveStore, Resource } = require("itchpad/stores/base");
+
+
+var StylesStore = Class({
+  extends: LiveStore,
+
+  defaultCategory: "css",
+
+  initialize: function(target) {
+    this.initStore();
+
+    this._onStyleSheetsCleared = this._onStyleSheetsCleared.bind(this);
+    this._onNavigate = this._onNavigate.bind(this);
+
+    this.setRoot(FolderResource(this));
+
+    this.setTarget(target);
+  },
+
+  setTarget: function(target) {
+    if (this.debuggee) {
+      this.resources.clear();
+      this.debuggee.destroy();
+      this.target.off("will-navigate", this._onStyleSheetsCleared);
+      this.target.off("navigate", this._onNavigate);
+    }
+
+    this.target = target;
+
+    if (!target) {
+      return;
+    }
+
+    // XXX: Need to share style editor fronts with the style editor.
+    if (this.target.form.styleSheetsActor) {
+      this.debuggee = StyleSheetsFront(this.target.client, this.target.form);
+    } else {
+      // We're talking to a pre-firefox 29 server-side
+      this.debuggee = StyleEditorFront(this.target.client, this.target.form);
+    }
+
+    this.debuggee.getStyleSheets().then(styleSheets => {
+      if (this.target !== target) {
+        return;
+      }
+      this.root.setSheets(styleSheets);
+      this.target.on("will-navigate", this._onStyleSheetsCleared);
+      this.target.on("navigate", this._onNavigate);
+    }).then(null, console.error);
+  },
+
+  _onNavigate: function() {
+    this.debuggee.getStyleSheets().then(styleSheets => {
+      this.root.setSheets(styleSheets);
+    });
+  },
+
+  _onStyleSheetsCleared: function() {
+    this.resources.clear();
+    this.root.setSheets();
+  },
+
+  refresh: function() {
+    // This is a live source, no explicit refresh needed.
+    return promise.resolve();
+  },
+
+  forSheet: function(sheet) {
+    if (this.resources.has(sheet.actorID)) {
+      return this.resources.get(sheet.actorID);
+    }
+
+    let resource = SheetResource(this, sheet);
+    this.resources.set(sheet.actorID, resource);
+    this.notifyAdd(resource);
+    return resource;
+  }
+});
+exports.StylesStore = StylesStore;
+
+var FolderResource = Class({
+  extends: Resource,
+
+  initialize: function(store) {
+    this.store = store;
+    this.children = new Set();
+  },
+
+  get displayName() { return "Styles"; },
+  get isDir() { return true; },
+  get hasChildren() { return this.children.size > 0 },
+
+  setSheets: function(sheets=[]) {
+    let newChildren = new Set();
+    for (let sheet of sheets) {
+      newChildren.add(this.store.forSheet(sheet));
+    }
+    this.setChildren(newChildren);
+  },
+
+  createChild: function(name) {
+    if (!this.store.debuggee) {
+      console.error("Tried to create a child without a debuggee.");
+      deferred.reject(new Error("Can't create child without a target."));
+    }
+    return this.store.debuggee.addStyleSheet("").then(sheet => {
+      let resource = this.store.forSheet(sheet);
+      resource._title = name;
+      this.addChild(resource);
+      return resource;
+    }).then(null, console.error);
+  }
+});
+
+var SheetResource = Class({
+  extends: Resource,
+
+  initialize: function(store, sheet) {
+    this.store = store;
+    this.sheet = sheet;
+    this.children = new Set();
+    if (sheet.href) {
+      this.setURI(new URL.URL(sheet.href));
+    } else {
+      this.setURI(new URL.URL("#sheet-" + sheet.styleSheetIndex, sheet.nodeHref));
+    }
+  },
+
+  toString: function() {
+    return "[SheetResource:" + this.uri + "]";
+  },
+
+  get displayName() {
+    if (this._title) {
+      return this._title;
+    }
+
+    if (!this.sheet.href) {
+      this._title = "<inline style sheet " + this.sheet.styleSheetIndex + ">";
+      return this._title;
+    }
+
+    this._title = CssLogic.shortSource({ href: this.sheet.href });
+    try {
+      this._title = decodeURI(this._title);
+    } catch(ex) {
+    }
+
+    return this._title;
+  },
+
+  get isDir() { return false; },
+  get hasChildren() { return false; },
+
+  get contentType() {
+    // Good enough.
+    return "text/css";
+  },
+
+  canAutoApply: true,
+
+  load: function() {
+    return this.sheet.getText().then(longstr => {
+      return longstr.string();
+    });
+  },
+
+  apply: function(text) {
+    return this.sheet.update(text, true);
+  }
+});
diff --git a/browser/devtools/itchpad/lib/tree.js b/browser/devtools/itchpad/lib/tree.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/tree.js
@@ -0,0 +1,395 @@
+const { Class } = require("sdk/core/heritage");
+const { emit } = require("sdk/event/core");
+const { EventTarget } = require("sdk/event/target");
+const { merge } = require("sdk/util/object");
+const promise = require("itchpad/helpers/promise");
+const { InplaceEditor } = require("devtools/shared/inplace-editor");
+const { on, forget } = require("itchpad/event/scope");
+const OS = require("itchpad/helpers/osfile");
+
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+var Container = Class({
+  initialize: function(tree, node) {
+    this.tree = tree;
+    this.node = node;
+    this.elt = null;
+    this.expander = null;
+    this.children = null;
+
+    let doc = tree.doc;
+
+    this.elt = doc.createElementNS(HTML_NS, "li");
+    this.elt.classList.add("child");
+
+    this.line = doc.createElementNS(HTML_NS, "div");
+    this.line.classList.add("child");
+    this.line.classList.add("side-menu-widget-item");
+    this.line.setAttribute("theme", "dark");
+    this.line.setAttribute("tabindex", "0");
+
+    this.elt.appendChild(this.line);
+
+    this.highlighter = doc.createElementNS(HTML_NS, "span");
+    this.highlighter.classList.add("highlighter");
+    this.line.appendChild(this.highlighter);
+
+    this.expander = doc.createElementNS(HTML_NS, "span");
+    this.expander.className = "arrow expander";
+    this.expander.setAttribute("open", "");
+    this.line.appendChild(this.expander);
+
+    this.icon = doc.createElementNS(HTML_NS, "span");
+    this.line.appendChild(this.icon);
+
+    this.label = doc.createElementNS(HTML_NS, "span");
+    this.label.className = "file-label";
+    this.line.appendChild(this.label);
+
+    this.line.addEventListener("contextmenu", (ev) => {
+      this.select();
+      this.openContextMenu(ev);
+    }, false);
+
+    this.children = doc.createElementNS(HTML_NS, "ul");
+    this.children.classList.add("children");
+
+    this.elt.appendChild(this.children);
+
+    this.line.addEventListener("click", (evt) => {
+      if (!this.selected) {
+        this.select();
+        this.expanded = true;
+        evt.stopPropagation();
+      }
+    }, false);
+    this.expander.addEventListener("click", (evt) => {
+      this.expanded = !this.expanded;
+      this.select();
+      evt.stopPropagation();
+    }, true);
+
+    this.update();
+  },
+
+  openContextMenu: function(ev) {
+    ev.preventDefault();
+    let popup = this.tree.doc.getElementById("directory-menu-popup");
+    // XXX: Pass this method onto plugins to allow them to remove themselves from context menu.
+    let popupRemoveProject = popup.querySelector("#remove-project");
+    let isContainer = !this.node.parent;
+
+    // Disable certain items for context menu
+    if (this.node.isDir) {
+      if (isContainer) {
+        popupRemoveProject.removeAttribute("hidden");
+      } else {
+        popupRemoveProject.setAttribute("hidden", "true");
+      }
+    } else {
+      popupRemoveProject.setAttribute("hidden", "true");
+    }
+
+    popup.openPopupAtScreen(ev.screenX, ev.screenY, true);
+  },
+
+  remove: function() {
+    if (this.elt.parentNode) {
+      this.elt.parentNode.removeChild(this.elt);
+    }
+  },
+
+  destroy: function() {
+
+  },
+
+  update: function() {
+    let visible = this.tree.options.nodeVisible ?
+      this.tree.options.nodeVisible(this.node) :
+      true;
+
+    this.elt.hidden = !visible;
+
+    this.tree.options.nodeFormatter(this.node, this.label);
+    this.icon.className = "file-icon";
+
+    let contentCategory = this.node.contentCategory;
+    let baseName = this.node.basename || "";
+
+    if (!this.node.parent) {
+      this.icon.classList.add("icon-none");
+    } else if (this.node.isDir) {
+      this.icon.classList.add("icon-folder");
+    } else if (baseName.endsWith(".manifest") || baseName.endsWith(".webapp")) {
+      this.icon.classList.add("icon-manifest");
+    } else if (contentCategory === "js") {
+      this.icon.classList.add("icon-js");
+    } else if (contentCategory === "css") {
+      this.icon.classList.add("icon-css");
+    } else if (contentCategory === "html") {
+      this.icon.classList.add("icon-html");
+    } else if (contentCategory === "image") {
+      this.icon.classList.add("icon-img");
+    } else {
+      this.icon.classList.add("icon-file");
+    }
+
+    this.expander.style.visibility = this.node.hasChildren ? "visible" : "hidden";
+
+  },
+
+  select: function() {
+    this.tree.selectContainer(this);
+  },
+
+  get selected() {
+    return this.line.classList.contains("selected");
+  },
+  set selected(v) {
+    if (v) {
+      this.line.classList.add("selected");
+    } else {
+      this.line.classList.remove("selected");
+    }
+  },
+
+  get expanded() {
+    return !this.elt.classList.contains("tree-collapsed");
+  },
+
+  set expanded(v) {
+    if (v) {
+      this.elt.classList.remove("tree-collapsed");
+      this.expander.setAttribute("open", "");
+    } else {
+      this.expander.removeAttribute("open");
+      this.elt.classList.add("tree-collapsed");
+    }
+  }
+});
+
+var TreeView = Class({
+  extends: EventTarget,
+
+  initialize: function(document, options) {
+    this.doc = document;
+    this.options = merge({
+      nodeFormatter: function(node, elt) {
+        elt.textContent = node.toString();
+      }
+    }, options);
+    this.models = new Set();
+    this.roots = new Set();
+    this._containers = new Map();
+    this.elt = document.createElement("vbox");
+    this.elt.tree = this;
+    this.elt.className = "side-menu-widget-container sources-tree";
+    this.elt.setAttribute("with-arrows", "true");
+    this.elt.setAttribute("theme", "dark");
+    this.elt.setAttribute("flex", "1");
+
+    this.children = document.createElementNS(HTML_NS, "ul");
+    this.children.setAttribute("flex", "1");
+    this.elt.appendChild(this.children);
+
+    this.nodeChildrenChanged = this.nodeChildrenChanged.bind(this);
+    this.updateNode = this.updateNode.bind(this);
+  },
+
+  promptNew: function(initial, parent, sibling=null) {
+    let deferred = promise.defer();
+
+    let parentContainer = this._containers.get(parent);
+    // Give child updates something to wait on...
+    parentContainer.prompting = deferred.promise;
+
+    let item = this.doc.createElement("li");
+    item.className = "child";
+    let placeholder = this.doc.createElementNS(HTML_NS, "div");
+    placeholder.className = "child";
+    item.appendChild(placeholder);
+
+    let children = parentContainer.children;
+    sibling = sibling ? this._containers.get(sibling).elt : null;
+    parentContainer.children.insertBefore(item, sibling ? sibling.nextSibling : children.firstChild);
+
+    new InplaceEditor({
+      element: placeholder,
+      initial: initial,
+      start: editor => {
+        editor.input.select();
+      },
+      done: function(val, commit) {
+        if (commit) {
+          deferred.resolve(val);
+        } else {
+          deferred.reject(val);
+        }
+        parentContainer.line.focus();
+      },
+      destroy: () => {
+        item.parentNode.removeChild(item);
+      },
+    });
+
+    return deferred.promise;
+  },
+
+  addModel: function(model) {
+
+    if (this.models.has(model)) {
+      // Requesting to add a model that already exists
+      return;
+    }
+    this.models.add(model);
+    let placeholder = this.doc.createElementNS(HTML_NS, "li");
+    placeholder.style.display = "none";
+    this.children.appendChild(placeholder);
+    this.roots.add(model.root);
+    model.root.refresh().then(root => {
+      if (!this.models.has(model)) {
+        // model may have been removed during the initial refresh.
+        // In this case, do not import the node or add to DOM, just leave it be.
+        return;
+      }
+      let container = this.importNode(root);
+      container.line.classList.add("side-menu-widget-group-title");
+      container.line.setAttribute("theme", "dark");
+      this.selectContainer(container);
+
+      this.children.insertBefore(container.elt, placeholder);
+      this.children.removeChild(placeholder);
+    });
+  },
+
+  removeModel: function(model) {
+    this.models.delete(model);
+    this.removeNode(model.root);
+  },
+
+  select: function(node) {
+    this.selectContainer(this._containers.get(node));
+  },
+
+  selectContainer: function(container) {
+    if (this.selectedContainer === container) {
+      return;
+    }
+    if (this.selectedContainer) {
+      this.selectedContainer.selected = false;
+    }
+    this.selectedContainer = container;
+    container.selected = true;
+    emit(this, "selection", container.node);
+  },
+
+  getSelected: function() {
+    return this.selectedContainer.node;
+  },
+
+  importNode: function(node) {
+    if (!node) {
+      return null;
+    }
+
+    if (this._containers.has(node)) {
+      return this._containers.get(node);
+    }
+    var container = Container(this, node);
+    this._containers.set(node, container);
+    this._updateChildren(container);
+
+    on(this, node, "children-changed", this.nodeChildrenChanged);
+    on(this, node, "label-change", this.updateNode);
+
+    return container;
+  },
+
+  deleteNode: function(resource) {
+    if (resource.isDir) {
+      return OS.File.removeDir(resource.path);
+    } else {
+      return OS.File.remove(resource.path);
+    }
+  },
+
+  removeNode: function(node) {
+    let container = this._containers.get(node);
+    // May be requesting a removal before the import happens.
+    // In this case, container will not be set.
+    if (container) {
+      container.remove();
+    }
+    forget(this, node);
+
+    let toRemove = this.descendants(node);
+    toRemove.add(node);
+    for (let remove of toRemove) {
+      this._removeNode(remove);
+    }
+  },
+
+  _removeNode: function(node) {
+    node.off("children-changed", this.nodeChildrenChanged);
+    node.off("label-change", this.updateNode);
+    if (this._containers.get(node)) {
+      this._containers.get(node).destroy();
+      this._containers.delete(node);
+    }
+  },
+
+  nodeChildrenChanged: function(node) {
+    this.updateNode(node);
+    this._updateChildren(this._containers.get(node));
+  },
+
+  updateNode: function(node) {
+    let container = this._containers.get(node);
+    container.update();
+  },
+
+  _updateChildren: function(container) {
+    let node = container.node;
+
+    let fragment = this.doc.createDocumentFragment();
+
+
+    if (node.children) {
+      for (let child of node.children) {
+        let childContainer = this.importNode(child);
+        fragment.appendChild(childContainer.elt);
+      }
+    }
+
+    while (container.children.firstChild) {
+      container.children.removeChild(container.children.firstChild);
+    }
+
+    container.children.appendChild(fragment);
+  },
+
+  // Return a set with all descendants of the node
+  descendants: function(node) {
+    let set = new Set();
+
+    function addChildren(item) {
+      if (!item.children) {
+        return;
+      }
+
+      for (let child of item.children) {
+        set.add(child);
+      }
+    }
+
+    addChildren(node);
+    for (let item of set) {
+      addChildren(item);
+    }
+
+    return set;
+  }
+});
+
+exports.TreeView = TreeView;
diff --git a/browser/devtools/itchpad/lib/unloader.js b/browser/devtools/itchpad/lib/unloader.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/lib/unloader.js
@@ -0,0 +1,92 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+'use strict';
+
+const { Class } = require("sdk/core/heritage");
+const unloadNS = require("sdk/core/namespace").ns();
+const { when: unload } = require("sdk/system/unload");
+
+var Unloader = exports.Unloader = Class({
+  initialize: function Unloader() {
+    unloadNS(this).unloaders = [];
+    unloadNS(this).unloadersUnload = unloadersUnload.bind(null, unloadNS(this).unloaders);
+
+    // run the unloaders on unload
+    unload(unloadNS(this).unloadersUnload);
+  },
+  unload: function unload(callback, container) {
+    // Calling with no arguments runs all the unloader callbacks
+    if (callback == null) {
+      unloadNS(this).unloadersUnload();
+      return null;
+    }
+  
+    let windowRemover = windowUnloader.bind(null, unloader, unloadNS(this).unloaders);
+  
+    // The callback is bound to the lifetime of the container if we have one
+    if (container != null) {
+      // Remove the unloader when the container unloads
+      container.addEventListener("unload", windowRemover, false);
+  
+      // Wrap the callback to additionally remove the unload listener
+      let origCallback = callback;
+      callback = function() {
+        container.removeEventListener("unload", windowRemover, false);
+        origCallback();
+      }
+    }
+  
+    // Wrap the callback in a function that ignores failures
+    function unloader() {
+      try {
+        callback();
+      }
+      catch(e) {
+        console.error(e);
+      }
+    }
+    unloadNS(this).unloaders.push(unloader);
+  
+    // Provide a way to remove the unloader
+    return removeUnloader.bind(null, unloader, unloadNS(this).unloaders);
+  }
+});
+
+function sliceUnloader(unloader, unloaders) {
+  let index = unloaders.indexOf(unloader);
+  if (index < 0)
+    return [];
+  return unloaders.splice(index, 1);
+}
+// wraps sliceUnloader and doesn't return anything
+function removeUnloader(unloader, unloaders) {
+  sliceUnloader.apply(null, arguments);
+}
+function windowUnloader(unloader, unloaders) {
+  sliceUnloader.apply(null, arguments).forEach(function(u) u());
+}
+function unloadersUnload(unloaders) {
+  // run all the pending unloaders
+  unloaders.slice().forEach(function(u) u());
+  // clear the unload array
+  unloaders.length = 0;
+}
+
+/**
+ * Save callbacks to run when unloading. Optionally scope the callback to a
+ * container, e.g., window. Provide a way to run all the callbacks.
+ *
+ * @usage unload(): Run all callbacks and release them.
+ *
+ * @usage unload(callback): Add a callback to run on unload.
+ * @param [function] callback: 0-parameter function to call on unload.
+ * @return [function]: A 0-parameter function that undoes adding the callback.
+ *
+ * @usage unload(callback, container) Add a scoped callback to run on unload.
+ * @param [function] callback: 0-parameter function to call on unload.
+ * @param [node] container: Remove the callback when this container unloads.
+ * @return [function]: A 0-parameter function that undoes adding the callback.
+ */
+const gUnload = Unloader();
+exports.unload = gUnload.unload.bind(gUnload);
diff --git a/browser/devtools/itchpad/moz.build b/browser/devtools/itchpad/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/moz.build
@@ -0,0 +1,6 @@
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+TEST_DIRS += ['test']
\ No newline at end of file
diff --git a/browser/devtools/itchpad/test/browser.ini b/browser/devtools/itchpad/test/browser.ini
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/browser.ini
@@ -0,0 +1,5 @@
+[DEFAULT]
+support-files =
+  helper_itchpad.html
+
+[browser_itchpad_init.js]
diff --git a/browser/devtools/itchpad/test/browser_itchpad_init.js b/browser/devtools/itchpad/test/browser_itchpad_init.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/browser_itchpad_init.js
@@ -0,0 +1,8 @@
+
+function test() {
+  waitForExplicitFinish();
+
+  ok (true, "test has run");
+  finish();
+}
+
diff --git a/browser/devtools/itchpad/test/helper_itchpad.html b/browser/devtools/itchpad/test/helper_itchpad.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/helper_itchpad.html
@@ -0,0 +1,7 @@
+<!DOCTYPE html>
+
+<style>
+</style>
+
+<body>
+</body>
diff --git a/browser/devtools/itchpad/test/moz.build b/browser/devtools/itchpad/test/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/devtools/itchpad/test/moz.build
@@ -0,0 +1,8 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+BROWSER_CHROME_MANIFESTS += ['browser.ini']
+
diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -2,16 +2,23 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 browser.jar:
     content/browser/devtools/widgets.css                               (shared/widgets/widgets.css)
     content/browser/devtools/widgets/VariablesView.xul                 (shared/widgets/VariablesView.xul)
     content/browser/devtools/markup-view.xhtml                         (markupview/markup-view.xhtml)
     content/browser/devtools/markup-view.css                           (markupview/markup-view.css)
+    content/browser/devtools/itchpad.css                               (itchpad/chrome/content/itchpad.css)
+    content/browser/devtools/itchpad.xul                               (itchpad/chrome/content/itchpad.xul)
+    content/browser/devtools/readdir.js                                (itchpad/chrome/content/readdir.js)
+    content/browser/devtools/itchpad-loader.xul                        (itchpad/chrome/content/itchpad-loader.xul)
+    content/browser/devtools/itchpad-loader.js                         (itchpad/chrome/content/itchpad-loader.js)
+    content/browser/devtools/icon-sample.png                           (itchpad/chrome/content/icon-sample.png)
+    content/browser/devtools/file-icons-sheet@2x.png                   (itchpad/chrome/content/file-icons-sheet@2x.png)
     content/browser/devtools/netmonitor.xul                            (netmonitor/netmonitor.xul)
     content/browser/devtools/netmonitor.css                            (netmonitor/netmonitor.css)
     content/browser/devtools/netmonitor-controller.js                  (netmonitor/netmonitor-controller.js)
     content/browser/devtools/netmonitor-view.js                        (netmonitor/netmonitor-view.js)
     content/browser/devtools/NetworkPanel.xhtml                        (webconsole/NetworkPanel.xhtml)
     content/browser/devtools/webconsole.xul                            (webconsole/webconsole.xul)
 *   content/browser/devtools/scratchpad.xul                            (scratchpad/scratchpad.xul)
     content/browser/devtools/scratchpad.js                             (scratchpad/scratchpad.js)
diff --git a/browser/devtools/moz.build b/browser/devtools/moz.build
--- a/browser/devtools/moz.build
+++ b/browser/devtools/moz.build
@@ -6,16 +6,17 @@
 
 DIRS += [
     'app-manager',
     'commandline',
     'debugger',
     'fontinspector',
     'framework',
     'inspector',
+    'itchpad',
     'layoutview',
     'markupview',
     'netmonitor',
     'profiler',
     'responsivedesign',
     'scratchpad',
     'shadereditor',
     'shared',
diff --git a/toolkit/devtools/Loader.jsm b/toolkit/devtools/Loader.jsm
--- a/toolkit/devtools/Loader.jsm
+++ b/toolkit/devtools/Loader.jsm
@@ -44,16 +44,17 @@ let loaderGlobals = {
   }
 };
 
 // Used when the tools should be loaded from the Firefox package itself (the default)
 function BuiltinProvider() {}
 BuiltinProvider.prototype = {
   load: function() {
     this.loader = new loader.Loader({
+      id: "fx-devtools",
       modules: {
         "Services": Object.create(Services),
         "toolkit/loader": loader,
         "source-map": SourceMap,
       },
       paths: {
         // When you add a line to this mapping, don't forget to make a
         // corresponding addition to the SrcdirProvider mapping below as well.
@@ -67,16 +68,17 @@ BuiltinProvider.prototype = {
         "devtools/styleinspector/css-logic": "resource://gre/modules/devtools/styleinspector/css-logic",
         "devtools/css-color": "resource://gre/modules/devtools/css-color",
         "devtools/output-parser": "resource://gre/modules/devtools/output-parser",
         "devtools/touch-events": "resource://gre/modules/devtools/touch-events",
         "devtools/client": "resource://gre/modules/devtools/client",
         "devtools/pretty-fast": "resource://gre/modules/devtools/pretty-fast.js",
         "devtools/async-utils": "resource://gre/modules/devtools/async-utils",
         "gcli": "resource://gre/modules/devtools/gcli",
+        "itchpad": "resource://gre/browser/modules/devtools/itchpad",
         "acorn": "resource://gre/modules/devtools/acorn",
         "acorn/util/walk": "resource://gre/modules/devtools/acorn/walk.js",
 
         // Allow access to xpcshell test items from the loader.
         "xpcshell-test": "resource://test"
       },
       globals: loaderGlobals,
       invisibleToDebugger: this.invisibleToDebugger
@@ -116,19 +118,21 @@ SrcdirProvider.prototype = {
     let cssLogicURI = this.fileURI(OS.Path.join(toolkitDir, "styleinspector", "css-logic"));
     let cssColorURI = this.fileURI(OS.Path.join(toolkitDir, "css-color"));
     let outputParserURI = this.fileURI(OS.Path.join(toolkitDir, "output-parser"));
     let touchEventsURI = this.fileURI(OS.Path.join(toolkitDir, "touch-events"));
     let clientURI = this.fileURI(OS.Path.join(toolkitDir, "client"));
     let prettyFastURI = this.fileURI(OS.Path.join(toolkitDir), "pretty-fast.js");
     let asyncUtilsURI = this.fileURI(OS.Path.join(toolkitDir), "async-utils.js");
     let gcliURI = this.fileURI(OS.Path.join(toolkitDir, "gcli", "source", "lib", "gcli"));
+    let itchpadURI = this.fileURI(OS.Path.join(devtoolsDir, "itchpad"));
     let acornURI = this.fileURI(OS.Path.join(toolkitDir, "acorn"));
     let acornWalkURI = OS.Path.join(acornURI, "walk.js");
     this.loader = new loader.Loader({
+      id: "fx-devtools",
       modules: {
         "Services": Object.create(Services),
         "toolkit/loader": loader,
         "source-map": SourceMap,
       },
       paths: {
         "": "resource://gre/modules/commonjs/",
         "main": mainURI,
@@ -140,16 +144,17 @@ SrcdirProvider.prototype = {
         "devtools/styleinspector/css-logic": cssLogicURI,
         "devtools/css-color": cssColorURI,
         "devtools/output-parser": outputParserURI,
         "devtools/touch-events": touchEventsURI,
         "devtools/client": clientURI,
         "devtools/pretty-fast": prettyFastURI,
         "devtools/async-utils": asyncUtilsURI,
         "gcli": gcliURI,
+        "itchpad": itchpadURI,
         "acorn": acornURI,
         "acorn/util/walk": acornWalkURI
       },
       globals: loaderGlobals,
       invisibleToDebugger: this.invisibleToDebugger
     });
 
     return this._writeManifest(devtoolsDir).then(null, Cu.reportError);
