# HG changeset patch
# User Tooru Fujisawa <arai_a@mac.com>
# Date 1478632231 -32400
#      Wed Nov 09 04:10:31 2016 +0900
# Node ID 7e121a656e6b1453a11a2ce9052514fc7ad1e2f1
# Parent  8532e50e0fadd8cd33310c1a731b97bfbcc30ccb
Bug 1315242 - Part 2: Display line number and column number in error message for console input.

diff --git a/devtools/client/shared/components/frame.js b/devtools/client/shared/components/frame.js
--- a/devtools/client/shared/components/frame.js
+++ b/devtools/client/shared/components/frame.js
@@ -32,25 +32,28 @@ module.exports = createClass({
     // Option to display a host name after the source link.
     showHost: PropTypes.bool,
     // Option to display a host name if the filename is empty or just '/'
     showEmptyPathAsHost: PropTypes.bool,
     // Option to display a full source instead of just the filename.
     showFullSourceUrl: PropTypes.bool,
     // Service to enable the source map feature for console.
     sourceMapService: PropTypes.object,
+    // Frame is console input
+    isConsoleInput: PropTypes.bool,
   },
 
   getDefaultProps() {
     return {
       showFunctionName: false,
       showAnonymousFunctionName: false,
       showHost: false,
       showEmptyPathAsHost: false,
       showFullSourceUrl: false,
+      isConsoleInput: false,
     };
   },
 
   componentWillMount() {
     const sourceMapService = this.props.sourceMapService;
     if (sourceMapService) {
       const source = this.getSource();
       sourceMapService.subscribe(source, this.onSourceUpdated);
@@ -113,27 +116,29 @@ module.exports = createClass({
   render() {
     let frame, isSourceMapped;
     let {
       onClick,
       showFunctionName,
       showAnonymousFunctionName,
       showHost,
       showEmptyPathAsHost,
-      showFullSourceUrl
+      showFullSourceUrl,
+      isConsoleInput
     } = this.props;
 
     if (this.state && this.state.isSourceMapped) {
       frame = this.state.frame;
       isSourceMapped = this.state.isSourceMapped;
     } else {
       frame = this.props.frame;
     }
 
-    let source = frame.source ? String(frame.source) : "";
+    let source = isConsoleInput ? "console-input"
+                                : frame.source ? String(frame.source) : "";
     let line = frame.line != void 0 ? Number(frame.line) : null;
     let column = frame.column != void 0 ? Number(frame.column) : null;
 
     const { short, long, host } = getSourceNames(source);
     // Reparse the URL to determine if we should link this; `getSourceNames`
     // has already cached this indirectly. We don't want to attempt to
     // link to "self-hosted" and "(unknown)". However, we do want to link
     // to Scratchpad URIs.
@@ -143,17 +148,17 @@ module.exports = createClass({
       || isSourceMapped;
     const elements = [];
     const sourceElements = [];
     let sourceEl;
 
     let tooltip = long;
 
     // If the source is linkable and line > 0
-    const shouldDisplayLine = isLinkable && line;
+    const shouldDisplayLine = (isConsoleInput || isLinkable) && line;
 
     // Exclude all falsy values, including `0`, as even
     // a number 0 for line doesn't make sense, and should not be displayed.
     // If source isn't linkable, don't attempt to append line and column
     // info, as this probably doesn't make sense.
     if (shouldDisplayLine) {
       tooltip += `:${line}`;
       // Intentionally exclude 0
diff --git a/devtools/client/webconsole/new-console-output/components/message-types/evaluation-result.js b/devtools/client/webconsole/new-console-output/components/message-types/evaluation-result.js
--- a/devtools/client/webconsole/new-console-output/components/message-types/evaluation-result.js
+++ b/devtools/client/webconsole/new-console-output/components/message-types/evaluation-result.js
@@ -28,16 +28,17 @@ EvaluationResult.defaultProps = {
 function EvaluationResult(props) {
   const { message, serviceContainer, indent } = props;
   const {
     source,
     type,
     level,
     id: messageId,
     exceptionDocURL,
+    frame,
   } = message;
 
   let messageBody;
   if (message.messageText) {
     messageBody = message.messageText;
   } else {
     messageBody = GripMessageBody({grip: message.parameters});
   }
@@ -50,13 +51,14 @@ function EvaluationResult(props) {
     level,
     indent,
     topLevelClasses,
     messageBody,
     messageId,
     scrollToMessage: props.autoscroll,
     serviceContainer,
     exceptionDocURL,
+    frame,
   };
   return Message(childProps);
 }
 
 module.exports = EvaluationResult;
diff --git a/devtools/client/webconsole/new-console-output/components/message.js b/devtools/client/webconsole/new-console-output/components/message.js
--- a/devtools/client/webconsole/new-console-output/components/message.js
+++ b/devtools/client/webconsole/new-console-output/components/message.js
@@ -125,19 +125,22 @@ const Message = createClass({
           }
         },
       });
     }
 
     const repeat = this.props.repeat ? MessageRepeat({repeat: this.props.repeat}) : null;
 
     // Configure the location.
-    const shouldRenderFrame = frame && frame.source !== "debugger eval code";
+    const isConsoleInput = frame && frame.source === "debugger eval code";
     const location = dom.span({ className: "message-location devtools-monospace" },
-      shouldRenderFrame ? FrameView({
+      isConsoleInput ? FrameView({
+        frame,
+        isConsoleInput,
+      }) : frame ? FrameView({
         frame,
         onClick: serviceContainer.onViewSourceInDebugger,
         showEmptyPathAsHost: true,
         sourceMapService: serviceContainer.sourceMapService
       }) : null
     );
 
     let learnMore;
diff --git a/devtools/client/webconsole/new-console-output/utils/messages.js b/devtools/client/webconsole/new-console-output/utils/messages.js
--- a/devtools/client/webconsole/new-console-output/utils/messages.js
+++ b/devtools/client/webconsole/new-console-output/utils/messages.js
@@ -179,27 +179,29 @@ function transformPacket(packet) {
       });
     }
 
     case "evaluationResult":
     default: {
       let {
         exceptionMessage: messageText,
         exceptionDocURL,
+        frame,
         result: parameters
       } = packet;
 
       const level = messageText ? MESSAGE_LEVEL.ERROR : MESSAGE_LEVEL.LOG;
       return new ConsoleMessage({
         source: MESSAGE_SOURCE.JAVASCRIPT,
         type: MESSAGE_TYPE.RESULT,
         level,
         messageText,
         parameters,
         exceptionDocURL,
+        frame,
       });
     }
   }
 }
 
 // Helpers
 function getRepeatId(message) {
   message = message.toJS();
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -883,17 +883,17 @@ WebConsoleActor.prototype =
       selectedNodeActor: aRequest.selectedNodeActor,
       selectedObjectActor: aRequest.selectedObjectActor,
     };
 
     let evalInfo = this.evalWithDebugger(input, evalOptions);
     let evalResult = evalInfo.result;
     let helperResult = evalInfo.helperResult;
 
-    let result, errorDocURL, errorMessage, errorGrip = null;
+    let result, errorDocURL, errorMessage, errorGrip = null, frame = null;
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
         let error = evalResult.throw;
 
@@ -924,16 +924,30 @@ WebConsoleActor.prototype =
           }
         }
 
         // It is possible that we won't have permission to unwrap an
         // object and retrieve its errorMessageName.
         try {
           errorDocURL = ErrorDocs.GetURL(error);
         } catch (ex) {}
+
+        try {
+          let line = error.errorLineNumber;
+          let column = error.errorColumnNumber;
+
+          if (typeof line === "number" && typeof column === "number") {
+            // Set frame only if we have line/column numbers.
+            frame = {
+              source : "debugger eval code",
+              line,
+              column
+            };
+          }
+        } catch (ex) {}
       }
     }
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
     let resultGrip;
     try {
       resultGrip = this.createValueGrip(result);
@@ -946,16 +960,17 @@ WebConsoleActor.prototype =
     return {
       from: this.actorID,
       input: input,
       result: resultGrip,
       timestamp: timestamp,
       exception: errorGrip,
       exceptionMessage: this._createStringGrip(errorMessage),
       exceptionDocURL: errorDocURL,
+      frame,
       helperResult: helperResult,
     };
   },
 
   /**
    * The Autocomplete request handler.
    *
    * @param object aRequest
@@ -1198,27 +1213,27 @@ WebConsoleActor.prototype =
    *        - selectedObjectActor: Like bindObjectActor, but executes with the
    *          top level window as the global.
    *        - frameActor: the FrameActor ID to use for evaluation. The given
    *        debugger frame is used for evaluation, instead of the global window.
    *        - selectedNodeActor: the NodeActor ID of the currently selected node
    *        in the Inspector (or null, if there is no selection). This is used
    *        for helper functions that make reference to the currently selected
    *        node, like $0.
+   *         - url: the url to evaluate the script as. Defaults to
+   *         "debugger eval code".
    * @return object
    *         An object that holds the following properties:
    *         - dbg: the debugger where the string was evaluated.
    *         - frame: (optional) the frame where the string was evaluated.
    *         - window: the Debugger.Object for the global where the string was
    *         evaluated.
    *         - result: the result of the evaluation.
    *         - helperResult: any result coming from a Web Console commands
    *         function.
-   *         - url: the url to evaluate the script as. Defaults to
-   *         "debugger eval code".
    */
   evalWithDebugger: function WCA_evalWithDebugger(aString, aOptions = {})
   {
     let trimmedString = aString.trim();
     // The help function needs to be easy to guess, so we make the () optional.
     if (trimmedString == "help" || trimmedString == "?") {
       aString = "help()";
     }
