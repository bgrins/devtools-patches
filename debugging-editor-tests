# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  ba6b2df32a6a63a9f124f9341d27dd978910760f
Bug 964939 -

diff --git a/browser/devtools/shared/autocomplete-popup.js b/browser/devtools/shared/autocomplete-popup.js
--- a/browser/devtools/shared/autocomplete-popup.js
+++ b/browser/devtools/shared/autocomplete-popup.js
@@ -5,16 +5,17 @@
 
 "use strict";
 
 const {Cc, Ci, Cu} = require("chrome");
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 loader.lazyImporter(this, "Services", "resource://gre/modules/Services.jsm");
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
+const events  = require("devtools/toolkit/event-emitter");
 
 /**
  * Autocomplete popup UI implementation.
  *
  * @constructor
  * @param nsIDOMDocument aDocument
  *        The document you want the popup attached to.
  * @param Object aOptions
@@ -104,16 +105,18 @@ function AutocompletePopup(aDocument, aO
   if (this.onClick) {
     this._list.addEventListener("click", this.onClick, false);
   }
 
   if (this.onKeypress) {
     this._list.addEventListener("keypress", this.onKeypress, false);
   }
   this._itemIdCounter = 0;
+
+  events.decorate(this);
 }
 exports.AutocompletePopup = AutocompletePopup;
 
 AutocompletePopup.prototype = {
   _document: null,
   _panel: null,
   _list: null,
   __scrollbarWidth: null,
@@ -139,16 +142,18 @@ AutocompletePopup.prototype = {
   {
     this.__maxLabelLength = -1;
     this._updateSize();
     this._panel.openPopup(aAnchor, this.position, aXOffset, aYOffset);
 
     if (this.autoSelect) {
       this.selectFirstItem();
     }
+
+    this.emit("popup-opened");
   },
 
   /**
    * Hide the autocomplete popup panel.
    */
   hidePopup: function AP_hidePopup()
   {
     // Return accessibility focus to the input.
diff --git a/browser/devtools/shared/test/doc_options-view.xul b/browser/devtools/shared/test/doc_options-view.xul
--- a/browser/devtools/shared/test/doc_options-view.xul
+++ b/browser/devtools/shared/test/doc_options-view.xul
@@ -19,9 +19,11 @@
             <menuitem id="option-autoblackbox"
                       type="checkbox"
                       data-pref="auto-black-box"
                       label="black box"/>
         </menupopup>
     </popupset>
     <button id="options-button"
             popup="options-menupopup"/>
+    <hbox id="container">hi</hbox>
+    <iframe id="foo"></iframe>
 </window>
diff --git a/browser/devtools/sourceeditor/test/browser.ini b/browser/devtools/sourceeditor/test/browser.ini
--- a/browser/devtools/sourceeditor/test/browser.ini
+++ b/browser/devtools/sourceeditor/test/browser.ini
@@ -16,16 +16,17 @@ support-files =
   css_statemachine_testcases.css
   css_statemachine_tests.json
   css_autocompletion_tests.json
   vimemacs.html
   head.js
   helper_codemirror_runner.js
 
 [browser_editor_autocomplete_basic.js]
+[browser_editor_autocomplete_events.js]
 [browser_editor_autocomplete_js.js]
 [browser_editor_basic.js]
 [browser_editor_cursor.js]
 [browser_editor_goto_line.js]
 [browser_editor_history.js]
 [browser_editor_markers.js]
 [browser_editor_movelines.js]
 [browser_editor_prefs.js]
diff --git a/browser/devtools/sourceeditor/test/browser_css_autocompletion.js b/browser/devtools/sourceeditor/test/browser_css_autocompletion.js
--- a/browser/devtools/sourceeditor/test/browser_css_autocompletion.js
+++ b/browser/devtools/sourceeditor/test/browser_css_autocompletion.js
@@ -95,19 +95,24 @@ function runTests() {
     inspector = InspectorFront(target.client, target.form);
     inspector.getWalker().then(walker => {
       completer = new cssAutoCompleter({walker: walker});
       checkStateAndMoveOn();
     });
   });
 }
 
+function testMouse() {
+  ok(false, "what");
+  finishUp();
+}
+
 function checkStateAndMoveOn() {
   if (index == tests.length) {
-    finishUp();
+    testMouse();
     return;
   }
 
   let test = tests[index];
   progress.dataset.progress = ++index;
   progressDiv.style.width = 100*index/tests.length + "%";
   completer.complete(limit(source, test[0]),
                      {line: test[0][0], ch: test[0][1]}).then(suggestions => {
diff --git a/browser/devtools/sourceeditor/test/browser_editor_autocomplete_events.js b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_events.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_events.js
@@ -0,0 +1,81 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const {InspectorFront} = require("devtools/server/actors/inspector");
+const AUTOCOMPLETION_PREF = "devtools.editor.autocomplete";
+const TEST_URI = "data:text/html;charset=UTF-8," + encodeURIComponent(
+  ["<!DOCTYPE html>",
+   "<html>",
+   " <body>",
+   " </body>",
+   " </html>"
+  ].join("\n"));
+
+function test() {
+  waitForExplicitFinish();
+  promiseTab(TEST_URI).then(runTests);
+}
+
+function runTests() {
+  let target = devtools.TargetFactory.forTab(gBrowser.selectedTab);
+  target.makeRemote().then(() => {
+    let inspector = InspectorFront(target.client, target.form);
+    inspector.getWalker().then(walker => {
+      setup((ed, win) => {
+        let edWin = ed.container.contentWindow.wrappedJSObject;
+        ed.setMode(Editor.modes.css);
+        ed.setOption("autocomplete", true);
+        testMouse(ed, edWin).then(() => {
+          testKeyboard(ed, edWin).then(() => {
+            teardown(ed, win);
+          });
+        });
+      }, {autocompleteOpts: {walker: walker}});
+    });
+  });
+}
+
+function testKeyboard(ed, win) {
+  ed.setMode(Editor.modes.css);
+  ed.setOption("autocomplete", true);
+  ed.focus();
+  ed.setText("b");
+  ed.setCursor({line: 1, ch: 1});
+
+  let waitForSuggestion = promise.defer();
+
+  ed.getAutocompletionPopup().once("popup-opened", () => {
+    info("before-suggest has been triggered");
+    EventUtils.synthesizeKey("VK_RETURN", { }, win);
+    is (ed.getText(), "body", "Editor text has been updated");
+    waitForSuggestion.resolve();
+  });
+
+  let autocompleteKey = Editor.keyFor("autocompletion", { noaccel: true }).toUpperCase();
+  EventUtils.synthesizeKey("VK_" + autocompleteKey, { ctrlKey: true }, win);
+
+  return waitForSuggestion.promise;
+}
+
+function testMouse(ed, win) {
+  ed.focus();
+  ed.setText("b");
+  ed.setCursor({line: 1, ch: 1});
+
+  let waitForSuggestion = promise.defer();
+
+  ed.getAutocompletionPopup().once("popup-opened", () => {
+    info("before-suggest has been triggered");
+    ed.getAutocompletionPopup()._list.firstChild.click();
+    is (ed.getText(), "body", "Editor text has been updated");
+    waitForSuggestion.resolve();
+  });
+
+  let autocompleteKey = Editor.keyFor("autocompletion", { noaccel: true }).toUpperCase();
+  EventUtils.synthesizeKey("VK_" + autocompleteKey, { ctrlKey: true }, win);
+
+  return waitForSuggestion.promise;
+}
diff --git a/browser/devtools/sourceeditor/test/head.js b/browser/devtools/sourceeditor/test/head.js
--- a/browser/devtools/sourceeditor/test/head.js
+++ b/browser/devtools/sourceeditor/test/head.js
@@ -4,57 +4,92 @@
 
 "use strict";
 
 const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 const { require } = devtools;
 const Editor  = require("devtools/sourceeditor/editor");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 
+
 gDevTools.testing = true;
 SimpleTest.registerCleanupFunction(() => {
   gDevTools.testing = false;
 });
 
-function setup(cb) {
+/**
+ * Open a new tab at a URL and call a callback on load
+ */
+function addTab(aURL, aCallback)
+{
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  content.location = aURL;
+
+  let tab = gBrowser.selectedTab;
+  let browser = gBrowser.getBrowserForTab(tab);
+
+  function onTabLoad() {
+    browser.removeEventListener("load", onTabLoad, true);
+    aCallback(browser, tab, browser.contentDocument);
+  }
+
+  browser.addEventListener("load", onTabLoad, true);
+}
+
+function promiseTab(aURL) {
+  return new Promise(resolve =>
+    addTab(aURL, resolve));
+}
+
+function setup(cb, additionalOpts = {}) {
   const opt = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
   const url = "data:text/xml;charset=UTF-8,<?xml version='1.0'?>" +
     "<?xml-stylesheet href='chrome://global/skin/global.css'?>" +
     "<window xmlns='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul'" +
     " title='Editor' width='600' height='500'><box flex='1'/></window>";
 
   let win = Services.ww.openWindow(null, url, "_blank", opt, null);
+  let opts = {
+    value: "Hello.",
+    lineNumbers: true,
+    foldGutter: true,
+    gutters: [ "CodeMirror-linenumbers", "breakpoints", "CodeMirror-foldgutter" ]
+  }
+  for (let o in additionalOpts) {
+    opts[o] = additionalOpts[o];
+  }
 
   win.addEventListener("load", function onLoad() {
     win.removeEventListener("load", onLoad, false);
 
     waitForFocus(function () {
       let box = win.document.querySelector("box");
-      let editor = new Editor({
-        value: "Hello.",
-        lineNumbers: true,
-        foldGutter: true,
-        gutters: [ "CodeMirror-linenumbers", "breakpoints", "CodeMirror-foldgutter" ]
-      });
+      let editor = new Editor(opts);
 
       editor.appendTo(box)
         .then(() => cb(editor, win))
         .then(null, (err) => ok(false, err.message));
     }, win);
   }, false);
 }
 
 function ch(exp, act, label) {
   is(exp.line, act.line, label + " (line)");
   is(exp.ch, act.ch, label + " (ch)");
 }
 
 function teardown(ed, win) {
   ed.destroy();
   win.close();
+
+  while (gBrowser.tabs.length > 1) {
+    gBrowser.removeCurrentTab();
+  }
   finish();
 }
 
 /**
  * Some tests may need to import one or more of the test helper scripts.
  * A test helper script is simply a js file that contains common test code that
  * is either not common-enough to be in head.js, or that is located in a separate
  * directory.
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -71,18 +71,20 @@
             // preserve the index just in case no IDs are available
             if (this.currentIndex > -1)
               this._currentIndex = this.currentIndex + 1;
 
             var event = document.createEvent("Events");
             event.initEvent("select", true, true);
             this.dispatchEvent(event);
 
-            // always call this (allows a commandupdater without controller)
-            document.commandDispatcher.updateCommands("richlistbox-select");
+            if (document.commandDispatcher) {
+              // always call this (allows a commandupdater without controller)
+              document.commandDispatcher.updateCommands("richlistbox-select");
+            }
           ]]>
         </body>
       </method>
 
       <!-- We override base-listbox here because those methods don't take dir
            into account on listbox (which doesn't support dir yet) -->
       <method name="getNextItem">
         <parameter name="aStartItem"/>
