# HG changeset patch
# Parent dfe3a1df68e730cc44c848c2a635cf4e44351e2c
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1031472 - Automatically reload all preferences in source editor;r=vporof

diff --git a/browser/devtools/markupview/html-editor.js b/browser/devtools/markupview/html-editor.js
--- a/browser/devtools/markupview/html-editor.js
+++ b/browser/devtools/markupview/html-editor.js
@@ -176,11 +176,12 @@ HTMLEditor.prototype = {
   destroy: function()
   {
     this.doc.defaultView.removeEventListener("resize",
       this.refresh, true);
     this.container.removeEventListener("click", this.hide, false);
     this.editorInner.removeEventListener("click", stopPropagation, false);
 
     this.hide(false);
-    this.container.parentNode.removeChild(this.container);
+    this.container.remove();
+    this.editor.destroy();
   }
 };
diff --git a/browser/devtools/sourceeditor/autocomplete.js b/browser/devtools/sourceeditor/autocomplete.js
--- a/browser/devtools/sourceeditor/autocomplete.js
+++ b/browser/devtools/sourceeditor/autocomplete.js
@@ -6,24 +6,24 @@
 const cssAutoCompleter = require("devtools/sourceeditor/css-autocompleter");
 const { AutocompletePopup } = require("devtools/shared/autocomplete-popup");
 
 const CM_TERN_SCRIPTS = [
   "chrome://browser/content/devtools/codemirror/tern.js",
   "chrome://browser/content/devtools/codemirror/show-hint.js"
 ];
 
-const privates = new WeakMap();
+const autocompleteMap = new WeakMap();
 
 /**
  * Prepares an editor instance for autocompletion.
  */
 function initializeAutoCompletion(ctx, options = {}) {
   let { cm, ed, Editor } = ctx;
-  if (privates.has(ed)) {
+  if (autocompleteMap.has(ed)) {
     return;
   }
 
   let win = ed.container.contentWindow.wrappedJSObject;
   let { CodeMirror, document } = win;
 
   let completer = null;
   let autocompleteKey = "Ctrl-" +
@@ -83,22 +83,22 @@ function initializeAutoCompletion(ctx, o
     };
     cm.addKeyMap(keyMap);
 
     let destroyTern = function() {
       ed.off("destroy", destroyTern);
       cm.off("cursorActivity", updateArgHintsCallback);
       cm.removeKeyMap(keyMap);
       win.tern = cm.tern = null;
-      privates.delete(ed);
+      autocompleteMap.delete(ed);
     };
 
     ed.on("destroy", destroyTern);
 
-    privates.set(ed, {
+    autocompleteMap.set(ed, {
       destroy: destroyTern
     });
 
     // TODO: Integrate tern autocompletion with this autocomplete API.
     return;
   } else if (ed.config.mode == Editor.modes.css) {
     completer = new cssAutoCompleter({walker: options.walker});
   }
@@ -121,18 +121,18 @@ function initializeAutoCompletion(ctx, o
 
   let keyMap = {
     "Tab": cycle,
     "Down": cycle,
     "Shift-Tab": cycle.bind(null, true),
     "Up": cycle.bind(null, true),
     "Enter": () => {
       if (popup && popup.isOpen) {
-        if (!privates.get(ed).suggestionInsertedOnce) {
-          privates.get(ed).insertingSuggestion = true;
+        if (!autocompleteMap.get(ed).suggestionInsertedOnce) {
+          autocompleteMap.get(ed).insertingSuggestion = true;
           let {label, preLabel, text} = popup.getItemAtIndex(0);
           let cur = ed.getCursor();
           ed.replaceText(text.slice(preLabel.length), cur, cur);
         }
         popup.hidePopup();
         // This event is used in tests
         ed.emit("popup-hidden");
         return;
@@ -152,47 +152,47 @@ function initializeAutoCompletion(ctx, o
 
   function destroy() {
     ed.off("destroy", destroy);
     cm.off("keydown", keypressCallback);
     ed.off("change", autoCompleteCallback);
     cm.removeKeyMap(keyMap);
     popup.destroy();
     keyMap = popup = completer = null;
-    privates.delete(ed);
+    autocompleteMap.delete(ed);
   }
 
-  privates.set(ed, {
+  autocompleteMap.set(ed, {
     popup: popup,
     completer: completer,
     keyMap: keyMap,
     destroy: destroy,
     insertingSuggestion: false,
     suggestionInsertedOnce: false
   });
 }
 
 /**
  * Destroy autocompletion on an editor instance.
  */
 function destroyAutoCompletion(ctx) {
   let { ed } = ctx;
-  if (!privates.has(ed)) {
+  if (!autocompleteMap.has(ed)) {
     return;
   }
 
-  let {destroy} = privates.get(ed);
+  let {destroy} = autocompleteMap.get(ed);
   destroy();
 }
 
 /**
  * Provides suggestions to autocomplete the current token/word being typed.
  */
 function autoComplete({ ed, cm }) {
-  let private = privates.get(ed);
+  let private = autocompleteMap.get(ed);
   let { completer, popup } = private;
   if (!completer || private.insertingSuggestion || private.doNotAutocomplete) {
     private.insertingSuggestion = false;
     return;
   }
   let cur = ed.getCursor();
   completer.complete(cm.getRange({line: 0, ch: 0}, cur), cur)
     .then(suggestions => {
@@ -218,17 +218,17 @@ function autoComplete({ ed, cm }) {
   });
 }
 
 /**
  * Cycles through provided suggestions by the popup in a top to bottom manner
  * when `reverse` is not true. Opposite otherwise.
  */
 function cycleSuggestions(ed, reverse) {
-  let private = privates.get(ed);
+  let private = autocompleteMap.get(ed);
   let { popup, completer } = private;
   let cur = ed.getCursor();
   private.insertingSuggestion = true;
   if (!private.suggestionInsertedOnce) {
     private.suggestionInsertedOnce = true;
     let firstItem;
     if (reverse) {
       firstItem = popup.getItemAtIndex(popup.itemCount - 1);
@@ -258,17 +258,17 @@ function cycleSuggestions(ed, reverse) {
   ed.emit("suggestion-entered");
 }
 
 /**
  * onkeydown handler for the editor instance to prevent autocompleting on some
  * keypresses.
  */
 function onEditorKeypress({ ed, Editor }, cm, event) {
-  let private = privates.get(ed);
+  let private = autocompleteMap.get(ed);
 
   // Do not try to autocomplete with multiple selections.
   if (ed.hasMultipleSelections()) {
     private.doNotAutocomplete = true;
     private.popup.hidePopup();
     return;
   }
 
@@ -314,32 +314,41 @@ function onEditorKeypress({ ed, Editor }
       private.doNotAutocomplete = false;
   }
 }
 
 /**
  * Returns the private popup. This method is used by tests to test the feature.
  */
 function getPopup({ ed }) {
-  if (privates.has(ed))
-    return privates.get(ed).popup;
+  if (autocompleteMap.has(ed))
+    return autocompleteMap.get(ed).popup;
 
   return null;
 }
 
 /**
  * Returns contextual information about the token covered by the caret if the
  * implementation of completer supports it.
  */
 function getInfoAt({ ed }, caret) {
-  let completer = privates.get(ed).completer;
+  let completer = autocompleteMap.get(ed).completer;
   if (completer && completer.getInfoAt)
     return completer.getInfoAt(ed.getText(), caret);
 
   return null;
 }
 
+/**
+ * Returns whether autocompletion is enabled for this editor.
+ * Used for testing
+ */
+function isAutocompletionEnabled({ ed }) {
+  return autocompleteMap.has(ed);
+}
+
 // Export functions
 
 module.exports.initializeAutoCompletion = initializeAutoCompletion;
 module.exports.destroyAutoCompletion = destroyAutoCompletion;
 module.exports.getAutocompletionPopup = getPopup;
 module.exports.getInfoAt = getInfoAt;
+module.exports.isAutocompletionEnabled = isAutocompletionEnabled;
diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -12,28 +12,30 @@ const TAB_SIZE    = "devtools.editor.tab
 const EXPAND_TAB  = "devtools.editor.expandtab";
 const KEYMAP      = "devtools.editor.keymap";
 const AUTO_CLOSE  = "devtools.editor.autoclosebrackets";
 const AUTOCOMPLETE  = "devtools.editor.autocomplete";
 const DETECT_INDENT = "devtools.editor.detectindentation";
 const DETECT_INDENT_MAX_LINES = 500;
 const L10N_BUNDLE = "chrome://browser/locale/devtools/sourceeditor.properties";
 const XUL_NS      = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const VALID_KEYMAPS = new Set(["emacs", "vim", "sublime"]);
 
 // Maximum allowed margin (in number of lines) from top or bottom of the editor
 // while shifting to a line which was initially out of view.
 const MAX_VERTICAL_OFFSET = 3;
 
 // Match @Scratchpad/N:LINE[:COLUMN] or (LINE[:COLUMN]) anywhere at an end of
 // line in text selection.
 const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
 const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const events  = require("devtools/toolkit/event-emitter");
+const { PrefObserver } = require("devtools/styleeditor/utils");
 
 Cu.import("resource://gre/modules/Services.jsm");
 const L10N = Services.strings.createBundle(L10N_BUNDLE);
 
 // CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
 // JavaScript and CSS that is injected into an iframe in
 // order to initialize a CodeMirror instance.
 
@@ -134,17 +136,16 @@ Editor.modes = {
  *
  * This object is also an event emitter.
  *
  * CodeMirror docs: http://codemirror.net/doc/manual.html
  */
 function Editor(config) {
   const tabSize = Services.prefs.getIntPref(TAB_SIZE);
   const useTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
-  const keyMap = Services.prefs.getCharPref(KEYMAP);
   const useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
 
   this.version = null;
   this.config = {
     value:             "",
     mode:              Editor.modes.text,
     indentUnit:        tabSize,
     tabSize:           tabSize,
@@ -165,19 +166,16 @@ function Editor(config) {
   this.config.extraKeys[Editor.keyFor("moveLineUp", { noaccel: true })] = () => this.moveLineUp();
   this.config.extraKeys[Editor.keyFor("moveLineDown", { noaccel: true })] = () => this.moveLineDown();
   this.config.extraKeys[Editor.keyFor("toggleComment")] = "toggleComment";
 
   // Disable ctrl-[ and ctrl-] because toolbox uses those shortcuts.
   this.config.extraKeys[Editor.keyFor("indentLess")] = false;
   this.config.extraKeys[Editor.keyFor("indentMore")] = false;
 
-  // If alternative keymap is provided, use it.
-  if (keyMap === "emacs" || keyMap === "vim" || keyMap === "sublime")
-    this.config.keyMap = keyMap;
 
   // Overwrite default config with user-provided, if needed.
   Object.keys(config).forEach((k) => {
     if (k != "extraKeys") {
       this.config[k] = config[k];
       return;
     }
 
@@ -194,19 +192,18 @@ function Editor(config) {
     this.config.foldGutter = true;
 
     if (!this.config.gutters) {
       this.config.gutters = this.config.lineNumbers ? ["CodeMirror-linenumbers"] : [];
       this.config.gutters.push("CodeMirror-foldgutter");
     }
   }
 
-  // Configure automatic bracket closing.
-  if (!this.config.autoCloseEnabled)
-    this.config.autoCloseBrackets = false;
+  // Remember the initial value of autoCloseBrackets.
+  this.config.autoCloseBracketsSaved = this.config.autoCloseBrackets;
 
   // Overwrite default tab behavior. If something is selected,
   // indent those lines. If nothing is selected and we're
   // indenting with tabs, insert one tab. Otherwise insert N
   // whitespaces where N == indentUnit option.
   this.config.extraKeys.Tab = (cm) => {
     if (cm.somethingSelected()) {
       cm.indentSelection("add");
@@ -320,18 +317,26 @@ Editor.prototype = {
         return L10N.GetStringFromName(name);
       });
 
       cm.getInputField().controllers.insertControllerAt(0, controller(this));
 
       this.container = env;
       editors.set(this, cm);
 
-      this.resetIndentUnit();
+      this.reloadPreferences = this.reloadPreferences.bind(this);
+      this._prefObserver = new PrefObserver("devtools.editor.");
+      this._prefObserver.on(TAB_SIZE, this.reloadPreferences);
+      this._prefObserver.on(EXPAND_TAB, this.reloadPreferences);
+      this._prefObserver.on(KEYMAP, this.reloadPreferences);
+      this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
+      this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
+      this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
 
+      this.reloadPreferences();
       def.resolve();
     };
 
     env.addEventListener("load", onLoad, true);
     env.setAttribute("src", CM_IFRAME);
     el.appendChild(env);
 
     this.once("destroy", () => el.removeChild(env));
@@ -393,16 +398,38 @@ Editor.prototype = {
   setText: function (value) {
     let cm = editors.get(this);
     cm.setValue(value);
 
     this.resetIndentUnit();
   },
 
   /**
+   * Reload the state of the editor based on all current preferences.
+   * This is called automatically when any of the relevant preferences
+   * change.
+   */
+  reloadPreferences: function() {
+    // Restore the saved autoCloseBrackets value if it is preffed on.
+    let useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
+    this.setOption("autoCloseBrackets",
+      useAutoClose ? this.config.autoCloseBracketsSaved : false);
+
+    // If alternative keymap is provided, use it.
+    const keyMap = Services.prefs.getCharPref(KEYMAP);
+    if (VALID_KEYMAPS.has(keyMap))
+      this.setOption("keyMap", keyMap)
+    else
+      this.setOption("keyMap", "default");
+
+    this.resetIndentUnit();
+    this.setupAutoCompletion();
+  },
+
+  /**
    * Set the editor's indentation based on the current prefs and
    * re-detect indentation if we should.
    */
   resetIndentUnit: function() {
     let cm = editors.get(this);
 
     let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
     let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
@@ -873,16 +900,23 @@ Editor.prototype = {
 
   /**
    * Sets an option for the editor.  For most options it just defers to
    * CodeMirror.setOption, but certain ones are maintained within the editor
    * instance.
    */
   setOption: function(o, v) {
     let cm = editors.get(this);
+
+    // Save the state of a valid autoCloseBrackets string, so we can reset
+    // it if it gets preffed off and back on.
+    if (o === "autoCloseBrackets" && v) {
+      this.config.autoCloseBracketsSaved = v;
+    }
+
     if (o === "autocomplete") {
       this.config.autocomplete = v;
       this.setupAutoCompletion();
     } else {
       cm.setOption(o, v);
     }
   },
 
@@ -952,16 +986,25 @@ Editor.prototype = {
       this[name] = funcs[name].bind(null, ctx);
     });
   },
 
   destroy: function () {
     this.container = null;
     this.config = null;
     this.version = null;
+
+    this._prefObserver.off(TAB_SIZE, this.reloadPreferences);
+    this._prefObserver.off(EXPAND_TAB, this.reloadPreferences);
+    this._prefObserver.off(KEYMAP, this.reloadPreferences);
+    this._prefObserver.off(AUTO_CLOSE, this.reloadPreferences);
+    this._prefObserver.off(AUTOCOMPLETE, this.reloadPreferences);
+    this._prefObserver.off(DETECT_INDENT, this.reloadPreferences);
+    this._prefObserver.destroy();
+
     this.emit("destroy");
   }
 };
 
 // Since Editor is a thin layer over CodeMirror some methods
 // are mapped directly—without any changes.
 
 CM_MAPPING.forEach(function (name) {
diff --git a/browser/devtools/sourceeditor/test/browser.ini b/browser/devtools/sourceeditor/test/browser.ini
--- a/browser/devtools/sourceeditor/test/browser.ini
+++ b/browser/devtools/sourceeditor/test/browser.ini
@@ -23,16 +23,17 @@ support-files =
 [browser_editor_autocomplete_basic.js]
 [browser_editor_autocomplete_js.js]
 [browser_editor_basic.js]
 [browser_editor_cursor.js]
 [browser_editor_goto_line.js]
 [browser_editor_history.js]
 [browser_editor_markers.js]
 [browser_editor_movelines.js]
+[browser_editor_prefs.js]
 [browser_editor_addons.js]
 [browser_codemirror.js]
 [browser_css_autocompletion.js]
 [browser_css_getInfo.js]
 [browser_css_statemachine.js]
 [browser_detectindent.js]
 [browser_vimemacs.js]
 skip-if = os == 'linux'&&debug # bug 981707
diff --git a/browser/devtools/sourceeditor/test/browser_editor_prefs.js b/browser/devtools/sourceeditor/test/browser_editor_prefs.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_editor_prefs.js
@@ -0,0 +1,78 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test to make sure that the editor reacts to preference changes
+
+const TAB_SIZE    = "devtools.editor.tabsize";
+const EXPAND_TAB  = "devtools.editor.expandtab";
+const KEYMAP      = "devtools.editor.keymap";
+const AUTO_CLOSE  = "devtools.editor.autoclosebrackets";
+const AUTOCOMPLETE  = "devtools.editor.autocomplete";
+const DETECT_INDENT = "devtools.editor.detectindentation";
+
+function test() {
+  waitForExplicitFinish();
+  setup((ed, win) => {
+
+    ed.setText("Checking preferences.");
+
+    info ("Turning prefs off");
+
+    ed.setOption("autocomplete", true);
+
+    Services.prefs.setIntPref(TAB_SIZE, 2);
+    Services.prefs.setBoolPref(EXPAND_TAB, false);
+    Services.prefs.setCharPref(KEYMAP, "default");
+    Services.prefs.setBoolPref(AUTO_CLOSE, false);
+    Services.prefs.setBoolPref(AUTOCOMPLETE, false);
+    Services.prefs.setBoolPref(DETECT_INDENT, false);
+
+    is(ed.getOption("tabSize"), 2, "tabSize is correct");
+    is(ed.getOption("indentUnit"), 2, "indentUnit is correct");
+    is(ed.getOption("indentWithTabs"), true, "indentWithTabs is correct");
+    is(ed.getOption("keyMap"), "default", "keyMap is correct");
+    is(ed.getOption("autoCloseBrackets"), "", "autoCloseBrackets is correct");
+    is(ed.getOption("autocomplete"), true, "autocomplete is correct");
+    ok(!ed.isAutocompletionEnabled(), "Autocompletion is not enabled");
+
+    info ("Turning prefs on");
+
+    Services.prefs.setIntPref(TAB_SIZE, 4);
+    Services.prefs.setBoolPref(EXPAND_TAB, true);
+    Services.prefs.setCharPref(KEYMAP, "sublime");
+    Services.prefs.setBoolPref(AUTO_CLOSE, true);
+    Services.prefs.setBoolPref(AUTOCOMPLETE, true);
+
+    is(ed.getOption("tabSize"), 4, "tabSize is correct");
+    is(ed.getOption("indentUnit"), 4, "indentUnit is correct");
+    is(ed.getOption("indentWithTabs"), false, "indentWithTabs is correct");
+    is(ed.getOption("keyMap"), "sublime", "keyMap is correct");
+    is(ed.getOption("autoCloseBrackets"), "()[]{}''\"\"", "autoCloseBrackets is correct");
+    is(ed.getOption("autocomplete"), true, "autocomplete is correct");
+    ok(ed.isAutocompletionEnabled(), "Autocompletion is enabled");
+
+    info ("Checking indentation detection");
+
+    Services.prefs.setBoolPref(DETECT_INDENT, true);
+
+    ed.setText("Detecting\n\tTabs");
+    is(ed.getOption("indentWithTabs"), true, "indentWithTabs is correct");
+    is(ed.getOption("indentUnit"), 4, "indentUnit is correct");
+
+    ed.setText("body {\n  color:red;\n  a:b;\n}");
+    is(ed.getOption("indentWithTabs"), false, "indentWithTabs is correct");
+    is(ed.getOption("indentUnit"), 2, "indentUnit is correct");
+
+    Services.prefs.clearUserPref(TAB_SIZE);
+    Services.prefs.clearUserPref(EXPAND_TAB);
+    Services.prefs.clearUserPref(KEYMAP);
+    Services.prefs.clearUserPref(AUTO_CLOSE);
+    Services.prefs.clearUserPref(AUTOCOMPLETE);
+    Services.prefs.clearUserPref(DETECT_INDENT);
+
+    teardown(ed, win);
+  });
+}
