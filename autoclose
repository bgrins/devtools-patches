# HG changeset patch
# Parent b7bab8b058cb4c3ace56b9b06a231e8845680326
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1031472 - Automatically reload all preferences in source editor;r=vporof

diff --git a/browser/devtools/markupview/html-editor.js b/browser/devtools/markupview/html-editor.js
--- a/browser/devtools/markupview/html-editor.js
+++ b/browser/devtools/markupview/html-editor.js
@@ -176,11 +176,12 @@ HTMLEditor.prototype = {
   destroy: function()
   {
     this.doc.defaultView.removeEventListener("resize",
       this.refresh, true);
     this.container.removeEventListener("click", this.hide, false);
     this.editorInner.removeEventListener("click", stopPropagation, false);
 
     this.hide(false);
-    this.container.parentNode.removeChild(this.container);
+    this.container.remove();
+    this.editor.destroy();
   }
 };
diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -113,25 +113,30 @@ let NetMonitorView = {
       $("#requests-menu-network-summary-button").hidden = true;
       $("#requests-menu-network-summary-label").hidden = true;
     }
   },
 
   /**
    * Destroys the UI for all the displayed panes.
    */
-  _destroyPanes: function() {
+  _destroyPanes: Task.async(function*() {
     dumpn("Destroying the NetMonitorView panes");
 
     Prefs.networkDetailsWidth = this._detailsPane.getAttribute("width");
     Prefs.networkDetailsHeight = this._detailsPane.getAttribute("height");
 
     this._detailsPane = null;
     this._detailsPaneToggleButton = null;
-  },
+
+    for (let p of this._editorPromises.values()) {
+      let editor = yield p;
+      editor.destroy();
+    }
+  }),
 
   /**
    * Gets the visibility state of the network details pane.
    * @return boolean
    */
   get detailsPaneHidden() {
     return this._detailsPane.hasAttribute("pane-collapsed");
   },
diff --git a/browser/devtools/projecteditor/lib/editors.js b/browser/devtools/projecteditor/lib/editors.js
--- a/browser/devtools/projecteditor/lib/editors.js
+++ b/browser/devtools/projecteditor/lib/editors.js
@@ -160,21 +160,16 @@ var TextEditor = Class({
     this.editor.on("change", (...args) => {
       this.emit("change", ...args);
     });
     this.editor.on("cursorActivity", (...args) => {
       this.emit("cursorActivity", ...args);
     });
 
     this.appended = this.editor.appendTo(this.elt);
-    this.appended.then(() => {
-      if (this.editor) {
-        this.editor.setupAutoCompletion();
-      }
-    });
   },
 
   /**
    * Clean up the editor.  This can have different meanings
    * depending on the type of editor.
    */
   destroy: function() {
     this.editor.destroy();
diff --git a/browser/devtools/scratchpad/scratchpad.js b/browser/devtools/scratchpad/scratchpad.js
--- a/browser/devtools/scratchpad/scratchpad.js
+++ b/browser/devtools/scratchpad/scratchpad.js
@@ -1608,17 +1608,16 @@ var Scratchpad = {
       autocomplete: Services.prefs.getBoolPref(ENABLE_AUTOCOMPLETION),
     };
 
     this.editor = new Editor(config);
     let editorElement = document.querySelector("#scratchpad-editor");
     this.editor.appendTo(editorElement).then(() => {
       var lines = initialText.split("\n");
 
-      this.editor.setupAutoCompletion();
       this.editor.on("change", this._onChanged);
       this._onPaste = WebConsoleUtils.pasteHandlerGen(this.editor.container.contentDocument.body,
                                                       document.querySelector('#scratchpad-notificationbox'));
       editorElement.addEventListener("paste", this._onPaste);
       editorElement.addEventListener("drop", this._onPaste);
       this.editor.on("save", () => this.saveFile());
       this.editor.focus();
       this.editor.setCursor({ line: lines.length, ch: lines.pop().length });
@@ -2318,16 +2317,22 @@ var CloseObserver = {
     else {
       aSubject.QueryInterface(Ci.nsISupportsPRBool);
       aSubject.data = true;
     }
   },
 
   uninit: function CO_uninit()
   {
+    // Will throw exception if removeObserver is called twice.
+    if (this._uninited) {
+      return;
+    }
+
+    this._uninited = true;
     Services.obs.removeObserver(this, "browser-lastwindow-close-requested",
                                 false);
   },
 };
 
 XPCOMUtils.defineLazyGetter(Scratchpad, "strings", function () {
   return Services.strings.createBundle(SCRATCHPAD_L10N);
 });
diff --git a/browser/devtools/shadereditor/shadereditor.js b/browser/devtools/shadereditor/shadereditor.js
--- a/browser/devtools/shadereditor/shadereditor.js
+++ b/browser/devtools/shadereditor/shadereditor.js
@@ -354,19 +354,24 @@ let ShadersEditorsView = {
     this._fsFocused = this._onFocused.bind(this, "fs", "vs");
     this._vsChanged = this._onChanged.bind(this, "vs");
     this._fsChanged = this._onChanged.bind(this, "fs");
   },
 
   /**
    * Destruction function, called when the tool is closed.
    */
-  destroy: function() {
-    this._toggleListeners("off");
-  },
+  destroy: Task.async(function*() {
+    this._destroyed = true;
+    yield this._toggleListeners("off");
+    for (let p of this._editorPromises.values()) {
+      let editor = yield p;
+      editor.destroy();
+    }
+  }),
 
   /**
    * Sets the text displayed in the vertex and fragment shader editors.
    *
    * @param object sources
    *        An object containing the following properties
    *          - vs: the vertex shader source code
    *          - fs: the fragment shader source code
@@ -410,17 +415,22 @@ let ShadersEditorsView = {
     let deferred = promise.defer();
     this._editorPromises.set(type, deferred.promise);
 
     // Initialize the source editor and store the newly created instance
     // in the ether of a resolved promise's value.
     let parent = $("#" + type +"-editor");
     let editor = new Editor(DEFAULT_EDITOR_CONFIG);
     editor.config.mode = Editor.modes[type];
-    editor.appendTo(parent).then(() => deferred.resolve(editor));
+
+    if (this._destroyed) {
+      deferred.resolve(editor);
+    } else {
+      editor.appendTo(parent).then(() => deferred.resolve(editor));
+    }
 
     return deferred.promise;
   },
 
   /**
    * Toggles all the event listeners for the editors either on or off.
    *
    * @param string flag
diff --git a/browser/devtools/sourceeditor/autocomplete.js b/browser/devtools/sourceeditor/autocomplete.js
--- a/browser/devtools/sourceeditor/autocomplete.js
+++ b/browser/devtools/sourceeditor/autocomplete.js
@@ -6,24 +6,24 @@
 const cssAutoCompleter = require("devtools/sourceeditor/css-autocompleter");
 const { AutocompletePopup } = require("devtools/shared/autocomplete-popup");
 
 const CM_TERN_SCRIPTS = [
   "chrome://browser/content/devtools/codemirror/tern.js",
   "chrome://browser/content/devtools/codemirror/show-hint.js"
 ];
 
-const privates = new WeakMap();
+const autocompleteMap = new WeakMap();
 
 /**
  * Prepares an editor instance for autocompletion.
  */
 function initializeAutoCompletion(ctx, options = {}) {
   let { cm, ed, Editor } = ctx;
-  if (privates.has(ed)) {
+  if (autocompleteMap.has(ed)) {
     return;
   }
 
   let win = ed.container.contentWindow.wrappedJSObject;
   let { CodeMirror, document } = win;
 
   let completer = null;
   let autocompleteKey = "Ctrl-" +
@@ -83,22 +83,22 @@ function initializeAutoCompletion(ctx, o
     };
     cm.addKeyMap(keyMap);
 
     let destroyTern = function() {
       ed.off("destroy", destroyTern);
       cm.off("cursorActivity", updateArgHintsCallback);
       cm.removeKeyMap(keyMap);
       win.tern = cm.tern = null;
-      privates.delete(ed);
+      autocompleteMap.delete(ed);
     };
 
     ed.on("destroy", destroyTern);
 
-    privates.set(ed, {
+    autocompleteMap.set(ed, {
       destroy: destroyTern
     });
 
     // TODO: Integrate tern autocompletion with this autocomplete API.
     return;
   } else if (ed.config.mode == Editor.modes.css) {
     completer = new cssAutoCompleter({walker: options.walker});
   }
@@ -121,18 +121,18 @@ function initializeAutoCompletion(ctx, o
 
   let keyMap = {
     "Tab": cycle,
     "Down": cycle,
     "Shift-Tab": cycle.bind(null, true),
     "Up": cycle.bind(null, true),
     "Enter": () => {
       if (popup && popup.isOpen) {
-        if (!privates.get(ed).suggestionInsertedOnce) {
-          privates.get(ed).insertingSuggestion = true;
+        if (!autocompleteMap.get(ed).suggestionInsertedOnce) {
+          autocompleteMap.get(ed).insertingSuggestion = true;
           let {label, preLabel, text} = popup.getItemAtIndex(0);
           let cur = ed.getCursor();
           ed.replaceText(text.slice(preLabel.length), cur, cur);
         }
         popup.hidePopup();
         // This event is used in tests
         ed.emit("popup-hidden");
         return;
@@ -152,47 +152,47 @@ function initializeAutoCompletion(ctx, o
 
   function destroy() {
     ed.off("destroy", destroy);
     cm.off("keydown", keypressCallback);
     ed.off("change", autoCompleteCallback);
     cm.removeKeyMap(keyMap);
     popup.destroy();
     keyMap = popup = completer = null;
-    privates.delete(ed);
+    autocompleteMap.delete(ed);
   }
 
-  privates.set(ed, {
+  autocompleteMap.set(ed, {
     popup: popup,
     completer: completer,
     keyMap: keyMap,
     destroy: destroy,
     insertingSuggestion: false,
     suggestionInsertedOnce: false
   });
 }
 
 /**
  * Destroy autocompletion on an editor instance.
  */
 function destroyAutoCompletion(ctx) {
   let { ed } = ctx;
-  if (!privates.has(ed)) {
+  if (!autocompleteMap.has(ed)) {
     return;
   }
 
-  let {destroy} = privates.get(ed);
+  let {destroy} = autocompleteMap.get(ed);
   destroy();
 }
 
 /**
  * Provides suggestions to autocomplete the current token/word being typed.
  */
 function autoComplete({ ed, cm }) {
-  let private = privates.get(ed);
+  let private = autocompleteMap.get(ed);
   let { completer, popup } = private;
   if (!completer || private.insertingSuggestion || private.doNotAutocomplete) {
     private.insertingSuggestion = false;
     return;
   }
   let cur = ed.getCursor();
   completer.complete(cm.getRange({line: 0, ch: 0}, cur), cur)
     .then(suggestions => {
@@ -218,17 +218,17 @@ function autoComplete({ ed, cm }) {
   });
 }
 
 /**
  * Cycles through provided suggestions by the popup in a top to bottom manner
  * when `reverse` is not true. Opposite otherwise.
  */
 function cycleSuggestions(ed, reverse) {
-  let private = privates.get(ed);
+  let private = autocompleteMap.get(ed);
   let { popup, completer } = private;
   let cur = ed.getCursor();
   private.insertingSuggestion = true;
   if (!private.suggestionInsertedOnce) {
     private.suggestionInsertedOnce = true;
     let firstItem;
     if (reverse) {
       firstItem = popup.getItemAtIndex(popup.itemCount - 1);
@@ -258,17 +258,17 @@ function cycleSuggestions(ed, reverse) {
   ed.emit("suggestion-entered");
 }
 
 /**
  * onkeydown handler for the editor instance to prevent autocompleting on some
  * keypresses.
  */
 function onEditorKeypress({ ed, Editor }, cm, event) {
-  let private = privates.get(ed);
+  let private = autocompleteMap.get(ed);
 
   // Do not try to autocomplete with multiple selections.
   if (ed.hasMultipleSelections()) {
     private.doNotAutocomplete = true;
     private.popup.hidePopup();
     return;
   }
 
@@ -314,32 +314,41 @@ function onEditorKeypress({ ed, Editor }
       private.doNotAutocomplete = false;
   }
 }
 
 /**
  * Returns the private popup. This method is used by tests to test the feature.
  */
 function getPopup({ ed }) {
-  if (privates.has(ed))
-    return privates.get(ed).popup;
+  if (autocompleteMap.has(ed))
+    return autocompleteMap.get(ed).popup;
 
   return null;
 }
 
 /**
  * Returns contextual information about the token covered by the caret if the
  * implementation of completer supports it.
  */
 function getInfoAt({ ed }, caret) {
-  let completer = privates.get(ed).completer;
+  let completer = autocompleteMap.get(ed).completer;
   if (completer && completer.getInfoAt)
     return completer.getInfoAt(ed.getText(), caret);
 
   return null;
 }
 
+/**
+ * Returns whether autocompletion is enabled for this editor.
+ * Used for testing
+ */
+function isAutocompletionEnabled({ ed }) {
+  return autocompleteMap.has(ed);
+}
+
 // Export functions
 
 module.exports.initializeAutoCompletion = initializeAutoCompletion;
 module.exports.destroyAutoCompletion = destroyAutoCompletion;
 module.exports.getAutocompletionPopup = getPopup;
 module.exports.getInfoAt = getInfoAt;
+module.exports.isAutocompletionEnabled = isAutocompletionEnabled;
diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -12,28 +12,30 @@ const TAB_SIZE    = "devtools.editor.tab
 const EXPAND_TAB  = "devtools.editor.expandtab";
 const KEYMAP      = "devtools.editor.keymap";
 const AUTO_CLOSE  = "devtools.editor.autoclosebrackets";
 const AUTOCOMPLETE  = "devtools.editor.autocomplete";
 const DETECT_INDENT = "devtools.editor.detectindentation";
 const DETECT_INDENT_MAX_LINES = 500;
 const L10N_BUNDLE = "chrome://browser/locale/devtools/sourceeditor.properties";
 const XUL_NS      = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const VALID_KEYMAPS = new Set(["emacs", "vim", "sublime"]);
 
 // Maximum allowed margin (in number of lines) from top or bottom of the editor
 // while shifting to a line which was initially out of view.
 const MAX_VERTICAL_OFFSET = 3;
 
 // Match @Scratchpad/N:LINE[:COLUMN] or (LINE[:COLUMN]) anywhere at an end of
 // line in text selection.
 const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
 const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const events  = require("devtools/toolkit/event-emitter");
+const { PrefObserver } = require("devtools/styleeditor/utils");
 
 Cu.import("resource://gre/modules/Services.jsm");
 const L10N = Services.strings.createBundle(L10N_BUNDLE);
 
 // CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
 // JavaScript and CSS that is injected into an iframe in
 // order to initialize a CodeMirror instance.
 
@@ -134,17 +136,16 @@ Editor.modes = {
  *
  * This object is also an event emitter.
  *
  * CodeMirror docs: http://codemirror.net/doc/manual.html
  */
 function Editor(config) {
   const tabSize = Services.prefs.getIntPref(TAB_SIZE);
   const useTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
-  const keyMap = Services.prefs.getCharPref(KEYMAP);
   const useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
 
   this.version = null;
   this.config = {
     value:             "",
     mode:              Editor.modes.text,
     indentUnit:        tabSize,
     tabSize:           tabSize,
@@ -152,32 +153,30 @@ function Editor(config) {
     matchBrackets:     true,
     extraKeys:         {},
     indentWithTabs:    useTabs,
     styleActiveLine:   true,
     autoCloseBrackets: "()[]{}''\"\"",
     autoCloseEnabled:  useAutoClose,
     theme:             "mozilla",
     themeSwitching:    true,
-    autocomplete:      false
+    autocomplete:      false,
+    autocompleteOpts:  {}
   };
 
   // Additional shortcuts.
   this.config.extraKeys[Editor.keyFor("jumpToLine")] = () => this.jumpToLine();
   this.config.extraKeys[Editor.keyFor("moveLineUp", { noaccel: true })] = () => this.moveLineUp();
   this.config.extraKeys[Editor.keyFor("moveLineDown", { noaccel: true })] = () => this.moveLineDown();
   this.config.extraKeys[Editor.keyFor("toggleComment")] = "toggleComment";
 
   // Disable ctrl-[ and ctrl-] because toolbox uses those shortcuts.
   this.config.extraKeys[Editor.keyFor("indentLess")] = false;
   this.config.extraKeys[Editor.keyFor("indentMore")] = false;
 
-  // If alternative keymap is provided, use it.
-  if (keyMap === "emacs" || keyMap === "vim" || keyMap === "sublime")
-    this.config.keyMap = keyMap;
 
   // Overwrite default config with user-provided, if needed.
   Object.keys(config).forEach((k) => {
     if (k != "extraKeys") {
       this.config[k] = config[k];
       return;
     }
 
@@ -194,19 +193,18 @@ function Editor(config) {
     this.config.foldGutter = true;
 
     if (!this.config.gutters) {
       this.config.gutters = this.config.lineNumbers ? ["CodeMirror-linenumbers"] : [];
       this.config.gutters.push("CodeMirror-foldgutter");
     }
   }
 
-  // Configure automatic bracket closing.
-  if (!this.config.autoCloseEnabled)
-    this.config.autoCloseBrackets = false;
+  // Remember the initial value of autoCloseBrackets.
+  this.config.autoCloseBracketsSaved = this.config.autoCloseBrackets;
 
   // Overwrite default tab behavior. If something is selected,
   // indent those lines. If nothing is selected and we're
   // indenting with tabs, insert one tab. Otherwise insert N
   // whitespaces where N == indentUnit option.
   this.config.extraKeys.Tab = (cm) => {
     if (cm.somethingSelected()) {
       cm.indentSelection("add");
@@ -320,18 +318,26 @@ Editor.prototype = {
         return L10N.GetStringFromName(name);
       });
 
       cm.getInputField().controllers.insertControllerAt(0, controller(this));
 
       this.container = env;
       editors.set(this, cm);
 
-      this.resetIndentUnit();
+      this.reloadPreferences = this.reloadPreferences.bind(this);
+      this._prefObserver = new PrefObserver("devtools.editor.");
+      this._prefObserver.on(TAB_SIZE, this.reloadPreferences);
+      this._prefObserver.on(EXPAND_TAB, this.reloadPreferences);
+      this._prefObserver.on(KEYMAP, this.reloadPreferences);
+      this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
+      this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
+      this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
 
+      this.reloadPreferences();
       def.resolve();
     };
 
     env.addEventListener("load", onLoad, true);
     env.setAttribute("src", CM_IFRAME);
     el.appendChild(env);
 
     this.once("destroy", () => el.removeChild(env));
@@ -393,16 +399,38 @@ Editor.prototype = {
   setText: function (value) {
     let cm = editors.get(this);
     cm.setValue(value);
 
     this.resetIndentUnit();
   },
 
   /**
+   * Reload the state of the editor based on all current preferences.
+   * This is called automatically when any of the relevant preferences
+   * change.
+   */
+  reloadPreferences: function() {
+    // Restore the saved autoCloseBrackets value if it is preffed on.
+    let useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
+    this.setOption("autoCloseBrackets",
+      useAutoClose ? this.config.autoCloseBracketsSaved : false);
+
+    // If alternative keymap is provided, use it.
+    const keyMap = Services.prefs.getCharPref(KEYMAP);
+    if (VALID_KEYMAPS.has(keyMap))
+      this.setOption("keyMap", keyMap)
+    else
+      this.setOption("keyMap", "default");
+
+    this.resetIndentUnit();
+    this.setupAutoCompletion();
+  },
+
+  /**
    * Set the editor's indentation based on the current prefs and
    * re-detect indentation if we should.
    */
   resetIndentUnit: function() {
     let cm = editors.get(this);
 
     let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
     let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
@@ -873,16 +901,23 @@ Editor.prototype = {
 
   /**
    * Sets an option for the editor.  For most options it just defers to
    * CodeMirror.setOption, but certain ones are maintained within the editor
    * instance.
    */
   setOption: function(o, v) {
     let cm = editors.get(this);
+
+    // Save the state of a valid autoCloseBrackets string, so we can reset
+    // it if it gets preffed off and back on.
+    if (o === "autoCloseBrackets" && v) {
+      this.config.autoCloseBracketsSaved = v;
+    }
+
     if (o === "autocomplete") {
       this.config.autocomplete = v;
       this.setupAutoCompletion();
     } else {
       cm.setOption(o, v);
     }
   },
 
@@ -903,25 +938,25 @@ Editor.prototype = {
   /**
    * Sets up autocompletion for the editor. Lazily imports the required
    * dependencies because they vary by editor mode.
    *
    * Autocompletion is special, because we don't want to automatically use
    * it just because it is preffed on (it still needs to be requested by the
    * editor), but we do want to always disable it if it is preffed off.
    */
-  setupAutoCompletion: function (options = {}) {
+  setupAutoCompletion: function () {
     // The autocomplete module will overwrite this.initializeAutoCompletion
     // with a mode specific autocompletion handler.
     if (!this.initializeAutoCompletion) {
       this.extend(require("./autocomplete"));
     }
 
     if (this.config.autocomplete && Services.prefs.getBoolPref(AUTOCOMPLETE)) {
-      this.initializeAutoCompletion(options);
+      this.initializeAutoCompletion(this.config.autocompleteOpts);
     } else {
       this.destroyAutoCompletion();
     }
   },
 
   /**
    * Extends an instance of the Editor object with additional
    * functions. Each function will be called with context as
@@ -952,16 +987,27 @@ Editor.prototype = {
       this[name] = funcs[name].bind(null, ctx);
     });
   },
 
   destroy: function () {
     this.container = null;
     this.config = null;
     this.version = null;
+
+    if (this._prefObserver) {
+      this._prefObserver.off(TAB_SIZE, this.reloadPreferences);
+      this._prefObserver.off(EXPAND_TAB, this.reloadPreferences);
+      this._prefObserver.off(KEYMAP, this.reloadPreferences);
+      this._prefObserver.off(AUTO_CLOSE, this.reloadPreferences);
+      this._prefObserver.off(AUTOCOMPLETE, this.reloadPreferences);
+      this._prefObserver.off(DETECT_INDENT, this.reloadPreferences);
+      this._prefObserver.destroy();
+    }
+
     this.emit("destroy");
   }
 };
 
 // Since Editor is a thin layer over CodeMirror some methods
 // are mapped directly—without any changes.
 
 CM_MAPPING.forEach(function (name) {
diff --git a/browser/devtools/sourceeditor/test/browser.ini b/browser/devtools/sourceeditor/test/browser.ini
--- a/browser/devtools/sourceeditor/test/browser.ini
+++ b/browser/devtools/sourceeditor/test/browser.ini
@@ -23,16 +23,17 @@ support-files =
 [browser_editor_autocomplete_basic.js]
 [browser_editor_autocomplete_js.js]
 [browser_editor_basic.js]
 [browser_editor_cursor.js]
 [browser_editor_goto_line.js]
 [browser_editor_history.js]
 [browser_editor_markers.js]
 [browser_editor_movelines.js]
+[browser_editor_prefs.js]
 [browser_editor_addons.js]
 [browser_codemirror.js]
 [browser_css_autocompletion.js]
 [browser_css_getInfo.js]
 [browser_css_statemachine.js]
 [browser_detectindent.js]
 [browser_vimemacs.js]
 skip-if = os == 'linux'&&debug # bug 981707
diff --git a/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js
--- a/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js
+++ b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js
@@ -48,15 +48,13 @@ function testPref(ed, win) {
   ed.setOption("autocomplete", true);
 
   ok (ed.getOption("autocomplete"), "Autocompletion is set");
   ok (win.tern, "Tern is defined on the window");
 
   info ("Preffing autocompletion off");
   Services.prefs.setBoolPref(AUTOCOMPLETION_PREF, false);
 
-  ed.setupAutoCompletion();
-
   ok (ed.getOption("autocomplete"), "Autocompletion is still set");
   ok (!win.tern, "Tern is no longer defined on the window");
 
   Services.prefs.clearUserPref(AUTOCOMPLETION_PREF);
 }
diff --git a/browser/devtools/sourceeditor/test/browser_editor_prefs.js b/browser/devtools/sourceeditor/test/browser_editor_prefs.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_editor_prefs.js
@@ -0,0 +1,78 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test to make sure that the editor reacts to preference changes
+
+const TAB_SIZE    = "devtools.editor.tabsize";
+const EXPAND_TAB  = "devtools.editor.expandtab";
+const KEYMAP      = "devtools.editor.keymap";
+const AUTO_CLOSE  = "devtools.editor.autoclosebrackets";
+const AUTOCOMPLETE  = "devtools.editor.autocomplete";
+const DETECT_INDENT = "devtools.editor.detectindentation";
+
+function test() {
+  waitForExplicitFinish();
+  setup((ed, win) => {
+
+    ed.setText("Checking preferences.");
+
+    info ("Turning prefs off");
+
+    ed.setOption("autocomplete", true);
+
+    Services.prefs.setIntPref(TAB_SIZE, 2);
+    Services.prefs.setBoolPref(EXPAND_TAB, false);
+    Services.prefs.setCharPref(KEYMAP, "default");
+    Services.prefs.setBoolPref(AUTO_CLOSE, false);
+    Services.prefs.setBoolPref(AUTOCOMPLETE, false);
+    Services.prefs.setBoolPref(DETECT_INDENT, false);
+
+    is(ed.getOption("tabSize"), 2, "tabSize is correct");
+    is(ed.getOption("indentUnit"), 2, "indentUnit is correct");
+    is(ed.getOption("indentWithTabs"), true, "indentWithTabs is correct");
+    is(ed.getOption("keyMap"), "default", "keyMap is correct");
+    is(ed.getOption("autoCloseBrackets"), "", "autoCloseBrackets is correct");
+    is(ed.getOption("autocomplete"), true, "autocomplete is correct");
+    ok(!ed.isAutocompletionEnabled(), "Autocompletion is not enabled");
+
+    info ("Turning prefs on");
+
+    Services.prefs.setIntPref(TAB_SIZE, 4);
+    Services.prefs.setBoolPref(EXPAND_TAB, true);
+    Services.prefs.setCharPref(KEYMAP, "sublime");
+    Services.prefs.setBoolPref(AUTO_CLOSE, true);
+    Services.prefs.setBoolPref(AUTOCOMPLETE, true);
+
+    is(ed.getOption("tabSize"), 4, "tabSize is correct");
+    is(ed.getOption("indentUnit"), 4, "indentUnit is correct");
+    is(ed.getOption("indentWithTabs"), false, "indentWithTabs is correct");
+    is(ed.getOption("keyMap"), "sublime", "keyMap is correct");
+    is(ed.getOption("autoCloseBrackets"), "()[]{}''\"\"", "autoCloseBrackets is correct");
+    is(ed.getOption("autocomplete"), true, "autocomplete is correct");
+    ok(ed.isAutocompletionEnabled(), "Autocompletion is enabled");
+
+    info ("Checking indentation detection");
+
+    Services.prefs.setBoolPref(DETECT_INDENT, true);
+
+    ed.setText("Detecting\n\tTabs");
+    is(ed.getOption("indentWithTabs"), true, "indentWithTabs is correct");
+    is(ed.getOption("indentUnit"), 4, "indentUnit is correct");
+
+    ed.setText("body {\n  color:red;\n  a:b;\n}");
+    is(ed.getOption("indentWithTabs"), false, "indentWithTabs is correct");
+    is(ed.getOption("indentUnit"), 2, "indentUnit is correct");
+
+    Services.prefs.clearUserPref(TAB_SIZE);
+    Services.prefs.clearUserPref(EXPAND_TAB);
+    Services.prefs.clearUserPref(KEYMAP);
+    Services.prefs.clearUserPref(AUTO_CLOSE);
+    Services.prefs.clearUserPref(AUTOCOMPLETE);
+    Services.prefs.clearUserPref(DETECT_INDENT);
+
+    teardown(ed, win);
+  });
+}
diff --git a/browser/devtools/styleeditor/StyleSheetEditor.jsm b/browser/devtools/styleeditor/StyleSheetEditor.jsm
--- a/browser/devtools/styleeditor/StyleSheetEditor.jsm
+++ b/browser/devtools/styleeditor/StyleSheetEditor.jsm
@@ -89,16 +89,18 @@ function StyleSheetEditor(styleSheet, wi
   }
 
   this._onPropertyChange = this._onPropertyChange.bind(this);
   this._onError = this._onError.bind(this);
   this._onMediaRuleMatchesChange = this._onMediaRuleMatchesChange.bind(this);
   this._onMediaRulesChanged = this._onMediaRulesChanged.bind(this)
   this.checkLinkedFileForChanges = this.checkLinkedFileForChanges.bind(this);
   this.markLinkedFileBroken = this.markLinkedFileBroken.bind(this);
+  this.saveToFile = this.saveToFile.bind(this);
+  this.updateStyleSheet = this.updateStyleSheet.bind(this);
 
   this._focusOnSourceEditorReady = false;
   this.cssSheet.on("property-change", this._onPropertyChange);
   this.styleSheet.on("error", this._onError);
   this.mediaRules = [];
   if (this.cssSheet.getMediaRules) {
     this.cssSheet.getMediaRules().then(this._onMediaRulesChanged);
   }
@@ -342,33 +344,28 @@ StyleSheetEditor.prototype = {
     let config = {
       value: this._state.text,
       lineNumbers: true,
       mode: Editor.modes.css,
       readOnly: false,
       autoCloseBrackets: "{}()[]",
       extraKeys: this._getKeyBindings(),
       contextMenu: "sourceEditorContextMenu",
-      autocomplete: Services.prefs.getBoolPref(AUTOCOMPLETION_PREF)
+      autocomplete: Services.prefs.getBoolPref(AUTOCOMPLETION_PREF),
+      autocompleteOpts: { walker: this.walker }
     };
-    let sourceEditor = new Editor(config);
+    let sourceEditor = this._sourceEditor = new Editor(config);
 
     sourceEditor.on("dirty-change", this._onPropertyChange);
 
     return sourceEditor.appendTo(inputElement).then(() => {
-      sourceEditor.setupAutoCompletion({ walker: this.walker });
-
-      sourceEditor.on("save", () => {
-        this.saveToFile();
-      });
+      sourceEditor.on("save", this.saveToFile);
 
       if (this.styleSheet.update) {
-        sourceEditor.on("change", () => {
-          this.updateStyleSheet();
-        });
+        sourceEditor.on("change", this.updateStyleSheet);
       }
 
       this.sourceEditor = sourceEditor;
 
       if (this._focusOnSourceEditorReady) {
         this._focusOnSourceEditorReady = false;
         sourceEditor.focus();
       }
@@ -626,18 +623,21 @@ StyleSheetEditor.prototype = {
 
     return bindings;
   },
 
   /**
    * Clean up for this editor.
    */
   destroy: function() {
-    if (this.sourceEditor) {
-      this.sourceEditor.destroy();
+    if (this._sourceEditor) {
+      this._sourceEditor.off("dirty-change", this._onPropertyChange);
+      this._sourceEditor.off("save", this.saveToFile);
+      this._sourceEditor.off("change", this.updateStyleSheet);
+      this._sourceEditor.destroy();
     }
     this.cssSheet.off("property-change", this._onPropertyChange);
     this.cssSheet.off("media-rules-changed", this._onMediaRulesChanged);
     this.styleSheet.off("error", this._onError);
   }
 }
 
 /**
