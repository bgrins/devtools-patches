# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  cf997da83953056d14aaf8d429bff2249dd635f5

diff --git a/embedder.c b/embedder.c
new file mode 100644
--- /dev/null
+++ b/embedder.c
@@ -0,0 +1,15 @@
+// nm -gU XUL
+// clang -std=gnu99 dumb.c XUL -o GeckoView && ./GeckoView
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+
+extern void GeckoViewStart2(int argc, char *[]);
+
+int main(int argc, char *argv[]) {
+  printf("Started\n");
+  GeckoViewStart2(argc, argv);
+}
+
diff --git a/modules/libpref/Preferences.cpp b/modules/libpref/Preferences.cpp
--- a/modules/libpref/Preferences.cpp
+++ b/modules/libpref/Preferences.cpp
@@ -4546,16 +4546,19 @@ nsresult Preferences::InitInitialObjects
     // Load $gre/greprefs.js.
     nsCOMPtr<nsIFile> greprefsFile;
     rv = NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(greprefsFile));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = greprefsFile->AppendNative(NS_LITERAL_CSTRING("greprefs.js"));
     NS_ENSURE_SUCCESS(rv, rv);
 
+  nsAutoString tempPath;
+  rv = greprefsFile->GetPath(tempPath);
+    printf("prefs: %s\n", NS_LossyConvertUTF16toASCII(tempPath).get());
     rv = openPrefFile(greprefsFile, PrefValueKind::Default);
     if (NS_FAILED(rv)) {
       NS_WARNING(
           "Error parsing GRE default preferences. Is this an old-style "
           "embedding app?");
     }
   }
 
diff --git a/mozglue/geckoview/GeckoViewDesktop.cpp b/mozglue/geckoview/GeckoViewDesktop.cpp
new file mode 100644
--- /dev/null
+++ b/mozglue/geckoview/GeckoViewDesktop.cpp
@@ -0,0 +1,126 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include "nsTArray.h"
+#include "application.ini.h"
+//#include "nsString.h"
+//#include "nsAppRunner.h"
+//#include "nsExceptionHandler.h"
+#include "mozilla/XREAppData.h"
+
+#include "BinaryPath.h"
+#include "mozilla/arm.h"
+#include "mozilla/Bootstrap.h"
+#include "mozilla/Sprintf.h"
+#include "mozilla/TimeStamp.h"
+#include "mozilla/UniquePtr.h"
+#include "XREChildData.h"
+
+using namespace mozilla;
+
+// Copied from objdir-full-opt.noindex/build/application.ini.h:
+// static const mozilla::StaticXREAppData sAppData = {
+//     "Mozilla",
+//     "Firefox",
+//     "firefox",
+//     "79.0a1",
+//     "20200710090655",
+//     "{ec8030f7-c20a-464f-9b0e-13a3a9e97384}",
+//     NULL, // copyright
+//     NULL,
+//     "79.0a1",
+//     "79.0a1",
+//     "https://crash-reports.mozilla.com/submit?id={ec8030f7-c20a-464f-9b0e-13a3a9e97384}&version=79.0a1&buildid=20200710090655",
+//     NULL,
+//     NULL, // UAName
+//     NULL,
+//     "https://aus5.mozilla.org/update/6/%PRODUCT%/%VERSION%/%BUILD_ID%/%BUILD_TARGET%/%LOCALE%/%CHANNEL%/%OS_VERSION%/%SYSTEM_CAPABILITIES%/%DISTRIBUTION%/%DISTRIBUTION_VERSION%/update.xml"
+// };
+
+Bootstrap::UniquePtr gBootstrap;
+
+// NS_NewNativeLocalFile(sComponentDirs[i], true,
+//                       getter_AddRefs(f));
+// XRE_AddManifestLocation(NS_COMPONENT_LOCATION, f);
+
+static nsresult InitXPCOMGlue(LibLoadingStrategy aLibLoadingStrategy) {
+  if (gBootstrap) {
+    return NS_OK;
+  }
+
+  UniqueFreePtr<char> exePath = BinaryPath::Get();
+  if (!exePath) {
+    printf("Couldn't find the application directory.\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  printf("EXE PATH %s\n", exePath.get());
+
+  gBootstrap = GetBootstrap(exePath.get(), aLibLoadingStrategy);
+  if (!gBootstrap) {
+    printf("Couldn't load XPCOM.\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  // This will set this thread as the main thread.
+  gBootstrap->NS_LogInit();
+
+  return NS_OK;
+}
+
+
+// extern "C" NS_EXPORT void GeckoViewStart(char** argv, int argc)
+extern "C" NS_EXPORT void GeckoViewStart2(int argc, char *argv[]) {
+  // const struct mapping_info* info = getLibraryMapping();
+  // while (info->name) {
+  //   CrashReporter::AddLibraryMapping(info->name, info->base, info->len,
+  //                                    info->offset);
+  //   info++;
+  // }
+
+  if (!argv) {
+    printf("Failed to get arguments for GeckoStart\n");
+    return;
+  }
+
+  // nsCOMPtr<nsIFile> greDir;
+  // nsAutoString workingDir;
+  // if (!GetCurrentWorkingDirectory(workingDir)) {
+  //   printf("GetCurrentWorkingDirectory failed.\n");
+  //   return 1;
+  // }
+  // rv = NS_NewLocalFile(workingDir, true, getter_AddRefs(greDir));
+  // if (NS_FAILED(rv)) {
+  //   printf("NS_NewLocalFile failed.\n");
+  //   return 1;
+  // }
+
+  // Need to set the gredir appropriately.
+  // It's currently at /mozilla-central/objdir-full.noindex/dist/Resources/greprefs.js
+
+  // gBootstrap = mozilla::GetBootstrap(exePath.get(), aLibLoadingStrategy);
+  // gBootstrap = GetBootstrap(libxul, LibLoadingStrategy::ReadAhead);
+  printf("\n\nRunning alternate ui\n\n");
+  nsresult rv = InitXPCOMGlue(LibLoadingStrategy::ReadAhead); //LibLoadingStrategy::NoReadAhead);
+  if (NS_FAILED(rv)) {
+    printf("InitXPCOMGlue failed.\n");
+    return;
+  }
+
+  BootstrapConfig config;
+  config.appData = &sAppData;
+  config.appDataPath = nullptr;
+  // XRE_RunAppShell();
+
+
+  // int result = XRE_main(argc, argv, config);
+  // gBootstrap->XRE_EnableSameExecutableForContentProc();
+  int result = gBootstrap->XRE_main(argc, argv, config);
+
+  if (result) printf("XRE_main returned %d", result);
+
+
+    // InitXPCOMGlue calls NS_LogInit, so we need to balance it here.
+    gBootstrap->NS_LogTerm();
+}
diff --git a/mozglue/geckoview/moz.build b/mozglue/geckoview/moz.build
new file mode 100644
--- /dev/null
+++ b/mozglue/geckoview/moz.build
@@ -0,0 +1,55 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+
+#UNIFIED_SOURCES += [
+SOURCES += [
+    'GeckoViewDesktop.cpp',
+]
+
+EXPORTS += [
+    'GeckoViewDesktop.cpp',
+]
+
+
+FINAL_LIBRARY = 'mozglue'
+
+if CONFIG['MOZ_FOLD_LIBS']:
+    DEFINES['MOZ_FOLD_LIBS'] = True
+
+LOCAL_INCLUDES += [
+    '!/build',
+    '../linker',
+    '/ipc/chromium/src',
+    '/nsprpub/lib/ds',
+    '/nsprpub/lib/libc/include',
+    '/nsprpub/pr/include',
+    '/security/nss/lib/base',
+    '/security/nss/lib/certdb',
+    '/security/nss/lib/cryptohi',
+    '/security/nss/lib/dev',
+    '/security/nss/lib/freebl',
+    '/security/nss/lib/nss',
+    '/security/nss/lib/pk11wrap',
+    '/security/nss/lib/pkcs7',
+    '/security/nss/lib/pki',
+    '/security/nss/lib/smime',
+    '/security/nss/lib/softoken',
+    '/security/nss/lib/ssl',
+    '/security/nss/lib/util',
+    '/third_party/sqlite3/src',
+    '/toolkit/components/startup',
+    '/xpcom/build',
+]
+
+if CONFIG['CC_TYPE'] in ('clang', 'gcc'):
+    CXXFLAGS += ['-Wno-error=shadow']
+
+DEFINES['XPCOM_GLUE'] = True
+
+USE_LIBS += [
+    'xpcomglue',
+]
diff --git a/mozglue/moz.build b/mozglue/moz.build
--- a/mozglue/moz.build
+++ b/mozglue/moz.build
@@ -14,13 +14,14 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'andr
     DIRS += ['android']
 
 if CONFIG['OS_TARGET'] == 'WINNT':
     DIRS += ['dllservices']
 
 DIRS += [
   'baseprofiler',
   'build',
+  'geckoview',
   'misc',
 ]
 
 if CONFIG['MOZ_WIDGET_TOOLKIT']:
     TEST_DIRS += ['tests']
diff --git a/toolkit/xre/Bootstrap.cpp b/toolkit/xre/Bootstrap.cpp
--- a/toolkit/xre/Bootstrap.cpp
+++ b/toolkit/xre/Bootstrap.cpp
@@ -72,16 +72,21 @@ class BootstrapImpl final : public Boots
   }
 
 #ifdef MOZ_WIDGET_ANDROID
   virtual void GeckoStart(JNIEnv* aEnv, char** argv, int argc,
                           const StaticXREAppData& aAppData) override {
     ::GeckoStart(aEnv, argv, argc, aAppData);
   }
 
+  // virtual void GeckoViewStart(char** argv, int argc) override {
+  //   ::GeckoViewStart(argv, argc);
+  // }
+
+
   virtual void XRE_SetAndroidChildFds(
       JNIEnv* aEnv, const XRE_AndroidChildFds& aFds) override {
     ::XRE_SetAndroidChildFds(aEnv, aFds);
   }
 
 #  ifdef MOZ_PROFILE_GENERATE
   virtual void XRE_WriteLLVMProfData() override {
     __android_log_print(ANDROID_LOG_INFO, "GeckoLibLoad",
diff --git a/toolkit/xre/moz.build b/toolkit/xre/moz.build
--- a/toolkit/xre/moz.build
+++ b/toolkit/xre/moz.build
@@ -118,16 +118,20 @@ if CONFIG['MOZ_X11']:
     ]
 
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
     UNIFIED_SOURCES += [
         'nsAndroidStartup.cpp',
     ]
 
 UNIFIED_SOURCES += [
+    'nsGVStartup.cpp',
+]
+
+UNIFIED_SOURCES += [
     '/toolkit/mozapps/update/common/commonupdatedir.cpp',
     'AutoSQLiteLifetime.cpp',
     'Bootstrap.cpp',
     'CmdLineAndEnvUtils.cpp',
     'CreateAppData.cpp',
     'nsAppStartupNotifier.cpp',
     'nsConsoleWriter.cpp',
     'nsEmbeddingModule.cpp',
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -4691,18 +4691,20 @@ int XREMain::XRE_main(int argc, char* ar
 
   AUTO_BASE_PROFILER_LABEL("XREMain::XRE_main (around Gecko Profiler)", OTHER);
   AUTO_PROFILER_INIT;
   AUTO_PROFILER_LABEL("XREMain::XRE_main", OTHER);
 
   nsresult rv = NS_OK;
 
   if (aConfig.appData) {
+    printf("AppData\n");
     mAppData = MakeUnique<XREAppData>(*aConfig.appData);
   } else {
+    printf("AppDataPath\n");
     MOZ_RELEASE_ASSERT(aConfig.appDataPath);
     nsCOMPtr<nsIFile> appini;
     rv = XRE_GetFileFromPath(aConfig.appDataPath, getter_AddRefs(appini));
     if (NS_FAILED(rv)) {
       Output(true, "Error: unrecognized path: %s\n", aConfig.appDataPath);
       return 1;
     }
 
@@ -4712,51 +4714,69 @@ int XREMain::XRE_main(int argc, char* ar
       Output(true, "Couldn't read application.ini");
       return 1;
     }
 
     appini->GetParent(getter_AddRefs(mAppData->directory));
   }
 
   if (!mAppData->remotingName) {
+    printf("No remoting name\n");
     mAppData->remotingName = mAppData->name;
   }
   // used throughout this file
   gAppData = mAppData.get();
 
   nsCOMPtr<nsIFile> binFile;
   rv = XRE_GetBinaryPath(getter_AddRefs(binFile));
   NS_ENSURE_SUCCESS(rv, 1);
 
   rv = binFile->GetPath(gAbsoluteArgv0Path);
   NS_ENSURE_SUCCESS(rv, 1);
 
   if (!mAppData->xreDirectory) {
+    printf("No xreDirectory\n");
     nsCOMPtr<nsIFile> greDir;
     rv = binFile->GetParent(getter_AddRefs(greDir));
     if (NS_FAILED(rv)) return 2;
 
 #ifdef XP_MACOSX
     nsCOMPtr<nsIFile> parent;
     greDir->GetParent(getter_AddRefs(parent));
     greDir = parent.forget();
     greDir->AppendNative(NS_LITERAL_CSTRING("Resources"));
+    printf("appended resources\n");
 #endif
 
     mAppData->xreDirectory = greDir;
   }
 
+  printf("%s - %s\n", aConfig.appData, aConfig.appDataPath);
   if (aConfig.appData && aConfig.appDataPath) {
+
     mAppData->xreDirectory->Clone(getter_AddRefs(mAppData->directory));
     mAppData->directory->AppendNative(nsDependentCString(aConfig.appDataPath));
   }
 
+  nsAutoString tempPath;
   if (!mAppData->directory) {
-    mAppData->directory = mAppData->xreDirectory;
-  }
+    printf("mAppData missing\n");
+
+    // mAppData->directory = mAppData->xreDirectory;
+    // XXX: This is missing for some reason.
+    mAppData->xreDirectory->Clone(getter_AddRefs(mAppData->directory));
+    mAppData->directory->AppendNative(nsLiteralCString("browser"));
+  }
+
+  rv = mAppData->directory->GetPath(tempPath);
+  printf("mAppData: %s\n", NS_LossyConvertUTF16toASCII(tempPath).get());
+
+  rv = mAppData->xreDirectory->GetPath(tempPath);
+    printf("xreDirectory: %s\n", NS_LossyConvertUTF16toASCII(tempPath).get());
+
 
 #if defined(XP_WIN) && defined(MOZ_SANDBOX)
   mAppData->sandboxBrokerServices = aConfig.sandboxBrokerServices;
   mAppData->sandboxPermissionsService = aConfig.sandboxPermissionsService;
 #endif
 
   mozilla::IOInterposerInit ioInterposerGuard;
 
diff --git a/toolkit/xre/nsGVStartup.cpp b/toolkit/xre/nsGVStartup.cpp
new file mode 100644
--- /dev/null
+++ b/toolkit/xre/nsGVStartup.cpp
@@ -0,0 +1,103 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "nsTArray.h"
+#include "nsString.h"
+#include "nsAppRunner.h"
+#include "nsExceptionHandler.h"
+#include "mozilla/Bootstrap.h"
+#include "mozilla/XREAppData.h"
+#include "BinaryPath.h"
+
+using namespace mozilla;
+
+// Copied from objdir-full-opt.noindex/build/application.ini.h:
+static const mozilla::StaticXREAppData sAppData = {
+    "Mozilla",
+    "Firefox",
+    "firefox",
+    "79.0a1",
+    "20200710090655",
+    "{ec8030f7-c20a-464f-9b0e-13a3a9e97384}",
+    NULL, // copyright
+    NULL,
+    "79.0a1",
+    "79.0a1",
+    "https://crash-reports.mozilla.com/submit?id={ec8030f7-c20a-464f-9b0e-13a3a9e97384}&version=79.0a1&buildid=20200710090655",
+    NULL,
+    NULL, // UAName
+    NULL,
+    "https://aus5.mozilla.org/update/6/%PRODUCT%/%VERSION%/%BUILD_ID%/%BUILD_TARGET%/%LOCALE%/%CHANNEL%/%OS_VERSION%/%SYSTEM_CAPABILITIES%/%DISTRIBUTION%/%DISTRIBUTION_VERSION%/update.xml"
+};
+
+
+Bootstrap::UniquePtr gBootstrap;
+
+static nsresult InitXPCOMGlue(LibLoadingStrategy aLibLoadingStrategy) {
+  if (gBootstrap) {
+    return NS_OK;
+  }
+
+  UniqueFreePtr<char> exePath = BinaryPath::Get();
+  if (!exePath) {
+    printf("Couldn't find the application directory.\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  gBootstrap = GetBootstrap(exePath.get());//, aLibLoadingStrategy);
+  if (!gBootstrap) {
+    printf("Couldn't load XPCOM.\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  // This will set this thread as the main thread.
+  gBootstrap->NS_LogInit();
+
+  return NS_OK;
+}
+
+
+// extern "C" NS_EXPORT void GeckoViewStart(char** argv, int argc)
+extern "C" NS_EXPORT void GeckoViewStart(int argc, char *argv[]) {
+  // const struct mapping_info* info = getLibraryMapping();
+  // while (info->name) {
+  //   CrashReporter::AddLibraryMapping(info->name, info->base, info->len,
+  //                                    info->offset);
+  //   info++;
+  // }
+
+  if (!argv) {
+    printf("Failed to get arguments for GeckoStart\n");
+    return;
+  }
+
+  // nsCOMPtr<nsIFile> greDir;
+  // nsAutoString workingDir;
+  // if (!GetCurrentWorkingDirectory(workingDir)) {
+  //   printf("GetCurrentWorkingDirectory failed.\n");
+  //   return 1;
+  // }
+  // rv = NS_NewLocalFile(workingDir, true, getter_AddRefs(greDir));
+  // if (NS_FAILED(rv)) {
+  //   printf("NS_NewLocalFile failed.\n");
+  //   return 1;
+  // }
+
+  // Need to set the gredir appropriately.
+  // It's currently at /mozilla-central/objdir-full.noindex/dist/Resources/greprefs.js
+
+  // gBootstrap = mozilla::GetBootstrap(exePath.get(), aLibLoadingStrategy);
+  // gBootstrap = GetBootstrap(libxul, LibLoadingStrategy::ReadAhead);
+
+  nsresult rv = InitXPCOMGlue(LibLoadingStrategy::NoReadAhead);
+  BootstrapConfig config;
+  config.appData = &sAppData;
+  config.appDataPath = nullptr;
+  // XRE_RunAppShell();
+
+  int result = gBootstrap->XRE_main(argc, argv, config);
+
+  if (result) printf("XRE_main returned %d", result);
+}
diff --git a/toolkit/xre/nsXREDirProvider.cpp b/toolkit/xre/nsXREDirProvider.cpp
--- a/toolkit/xre/nsXREDirProvider.cpp
+++ b/toolkit/xre/nsXREDirProvider.cpp
@@ -1153,16 +1153,21 @@ nsresult nsXREDirProvider::GetInstallHas
   nsCOMPtr<nsIFile> installDir;
   nsCOMPtr<nsIFile> appFile;
   bool per = false;
   nsresult rv = GetFile(XRE_EXECUTABLE_FILE, &per, getter_AddRefs(appFile));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = appFile->GetParent(getter_AddRefs(installDir));
   NS_ENSURE_SUCCESS(rv, rv);
 
+
+  nsAutoString tempPath;
+  rv = installDir->GetPath(tempPath);
+  printf("installDir: %s\n", NS_LossyConvertUTF16toASCII(tempPath).get());
+
   // It is possible that the path we have is on a case insensitive
   // filesystem in which case the path may vary depending on how the
   // application is called. We want to normalize the case somehow.
 #ifdef XP_WIN
   // Windows provides a way to get the correct case.
   if (!mozilla::widget::WinUtils::ResolveJunctionPointsAndSymLinks(
           installDir)) {
     NS_WARNING("Failed to resolve install directory.");
diff --git a/webview-consumer.c b/webview-consumer.c
new file mode 100644
--- /dev/null
+++ b/webview-consumer.c
@@ -0,0 +1,18 @@
+// g++ webview-consumer.c -std=c++11 -framework WebKit -o webview-example
+
+// webview.c
+#include "webview-firefox.h"
+#ifdef WIN32
+int WINAPI WinMain(HINSTANCE hInt, HINSTANCE hPrevInst, LPSTR lpCmdLine,
+                   int nCmdShow) {
+#else
+int main() {
+#endif
+	webview_t w = webview_create(0, NULL);
+	webview_set_title(w, "Webview Example");
+	webview_set_size(w, 480, 320, WEBVIEW_HINT_NONE);
+	webview_navigate(w, "https://en.m.wikipedia.org/wiki/Main_Page");
+	webview_run(w);
+	webview_destroy(w);
+	return 0;
+}
\ No newline at end of file
diff --git a/webview-firefox.h b/webview-firefox.h
new file mode 100644
--- /dev/null
+++ b/webview-firefox.h
@@ -0,0 +1,738 @@
+/*
+ * MIT License
+ *
+ * Copyright (c) 2017 Serge Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef WEBVIEW_H
+#define WEBVIEW_H
+
+#ifndef WEBVIEW_API
+#define WEBVIEW_API extern
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *webview_t;
+
+// Creates a new webview instance. If debug is non-zero - developer tools will
+// be enabled (if the platform supports them). Window parameter can be a
+// pointer to the native window handle. If it's non-null - then child WebView
+// is embedded into the given parent window. Otherwise a new window is created.
+// Depending on the platform, a GtkWindow, NSWindow or HWND pointer can be
+// passed here.
+WEBVIEW_API webview_t webview_create(int debug, void *window);
+
+// Destroys a webview and closes the native window.
+WEBVIEW_API void webview_destroy(webview_t w);
+
+// Runs the main loop until it's terminated. After this function exits - you
+// must destroy the webview.
+WEBVIEW_API void webview_run(webview_t w);
+
+// Stops the main loop. It is safe to call this function from another other
+// background thread.
+WEBVIEW_API void webview_terminate(webview_t w);
+
+// Posts a function to be executed on the main thread. You normally do not need
+// to call this function, unless you want to tweak the native window.
+WEBVIEW_API void
+webview_dispatch(webview_t w, void (*fn)(webview_t w, void *arg), void *arg);
+
+// Returns a native window handle pointer. When using GTK backend the pointer
+// is GtkWindow pointer, when using Cocoa backend the pointer is NSWindow
+// pointer, when using Win32 backend the pointer is HWND pointer.
+WEBVIEW_API void *webview_get_window(webview_t w);
+
+// Updates the title of the native window. Must be called from the UI thread.
+WEBVIEW_API void webview_set_title(webview_t w, const char *title);
+
+// Window size hints
+#define WEBVIEW_HINT_NONE 0  // Width and height are default size
+#define WEBVIEW_HINT_MIN 1   // Width and height are minimum bounds
+#define WEBVIEW_HINT_MAX 2   // Width and height are maximum bounds
+#define WEBVIEW_HINT_FIXED 3 // Window size can not be changed by a user
+// Updates native window size. See WEBVIEW_HINT constants.
+WEBVIEW_API void webview_set_size(webview_t w, int width, int height,
+                                  int hints);
+
+// Navigates webview to the given URL. URL may be a data URI, i.e.
+// "data:text/text,<html>...</html>". It is often ok not to url-encode it
+// properly, webview will re-encode it for you.
+WEBVIEW_API void webview_navigate(webview_t w, const char *url);
+
+// Injects JavaScript code at the initialization of the new page. Every time
+// the webview will open a the new page - this initialization code will be
+// executed. It is guaranteed that code is executed before window.onload.
+WEBVIEW_API void webview_init(webview_t w, const char *js);
+
+// Evaluates arbitrary JavaScript code. Evaluation happens asynchronously, also
+// the result of the expression is ignored. Use RPC bindings if you want to
+// receive notifications about the results of the evaluation.
+WEBVIEW_API void webview_eval(webview_t w, const char *js);
+
+// Binds a native C callback so that it will appear under the given name as a
+// global JavaScript function. Internally it uses webview_init(). Callback
+// receives a request string and a user-provided argument pointer. Request
+// string is a JSON array of all the arguments passed to the JavaScript
+// function.
+WEBVIEW_API void webview_bind(webview_t w, const char *name,
+                              void (*fn)(const char *seq, const char *req,
+                                         void *arg),
+                              void *arg);
+
+// Allows to return a value from the native binding. Original request pointer
+// must be provided to help internal RPC engine match requests with responses.
+// If status is zero - result is expected to be a valid JSON result value.
+// If status is not zero - result is an error JSON object.
+WEBVIEW_API void webview_return(webview_t w, const char *seq, int status,
+                                const char *result);
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifndef WEBVIEW_HEADER
+
+#if !defined(WEBVIEW_GTK) && !defined(WEBVIEW_COCOA) && !defined(WEBVIEW_EDGE)
+#if defined(__linux__)
+#define WEBVIEW_GTK
+#elif defined(__APPLE__)
+#define WEBVIEW_COCOA
+#elif defined(_WIN32)
+#define WEBVIEW_EDGE
+#else
+#error "please, specify webview backend"
+#endif
+#endif
+
+#include <atomic>
+#include <functional>
+#include <future>
+#include <map>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <cstring>
+
+namespace webview {
+using dispatch_fn_t = std::function<void()>;
+
+inline std::string url_encode(const std::string s) {
+  std::string encoded;
+  for (unsigned int i = 0; i < s.length(); i++) {
+    auto c = s[i];
+    if (isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
+      encoded = encoded + c;
+    } else {
+      char hex[4];
+      snprintf(hex, sizeof(hex), "%%%02x", c);
+      encoded = encoded + hex;
+    }
+  }
+  return encoded;
+}
+
+inline std::string url_decode(const std::string s) {
+  std::string decoded;
+  for (unsigned int i = 0; i < s.length(); i++) {
+    if (s[i] == '%') {
+      int n;
+      n = std::stoul(s.substr(i + 1, 2), nullptr, 16);
+      decoded = decoded + static_cast<char>(n);
+      i = i + 2;
+    } else if (s[i] == '+') {
+      decoded = decoded + ' ';
+    } else {
+      decoded = decoded + s[i];
+    }
+  }
+  return decoded;
+}
+
+inline std::string html_from_uri(const std::string s) {
+  if (s.substr(0, 15) == "data:text/html,") {
+    return url_decode(s.substr(15));
+  }
+  return "";
+}
+
+inline int json_parse_c(const char *s, size_t sz, const char *key, size_t keysz,
+                        const char **value, size_t *valuesz) {
+  enum {
+    JSON_STATE_VALUE,
+    JSON_STATE_LITERAL,
+    JSON_STATE_STRING,
+    JSON_STATE_ESCAPE,
+    JSON_STATE_UTF8
+  } state = JSON_STATE_VALUE;
+  const char *k = NULL;
+  int index = 1;
+  int depth = 0;
+  int utf8_bytes = 0;
+
+  if (key == NULL) {
+    index = keysz;
+    keysz = 0;
+  }
+
+  *value = NULL;
+  *valuesz = 0;
+
+  for (; sz > 0; s++, sz--) {
+    enum {
+      JSON_ACTION_NONE,
+      JSON_ACTION_START,
+      JSON_ACTION_END,
+      JSON_ACTION_START_STRUCT,
+      JSON_ACTION_END_STRUCT
+    } action = JSON_ACTION_NONE;
+    unsigned char c = *s;
+    switch (state) {
+    case JSON_STATE_VALUE:
+      if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == ',' ||
+          c == ':') {
+        continue;
+      } else if (c == '"') {
+        action = JSON_ACTION_START;
+        state = JSON_STATE_STRING;
+      } else if (c == '{' || c == '[') {
+        action = JSON_ACTION_START_STRUCT;
+      } else if (c == '}' || c == ']') {
+        action = JSON_ACTION_END_STRUCT;
+      } else if (c == 't' || c == 'f' || c == 'n' || c == '-' ||
+                 (c >= '0' && c <= '9')) {
+        action = JSON_ACTION_START;
+        state = JSON_STATE_LITERAL;
+      } else {
+        return -1;
+      }
+      break;
+    case JSON_STATE_LITERAL:
+      if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == ',' ||
+          c == ']' || c == '}' || c == ':') {
+        state = JSON_STATE_VALUE;
+        s--;
+        sz++;
+        action = JSON_ACTION_END;
+      } else if (c < 32 || c > 126) {
+        return -1;
+      } // fallthrough
+    case JSON_STATE_STRING:
+      if (c < 32 || (c > 126 && c < 192)) {
+        return -1;
+      } else if (c == '"') {
+        action = JSON_ACTION_END;
+        state = JSON_STATE_VALUE;
+      } else if (c == '\\') {
+        state = JSON_STATE_ESCAPE;
+      } else if (c >= 192 && c < 224) {
+        utf8_bytes = 1;
+        state = JSON_STATE_UTF8;
+      } else if (c >= 224 && c < 240) {
+        utf8_bytes = 2;
+        state = JSON_STATE_UTF8;
+      } else if (c >= 240 && c < 247) {
+        utf8_bytes = 3;
+        state = JSON_STATE_UTF8;
+      } else if (c >= 128 && c < 192) {
+        return -1;
+      }
+      break;
+    case JSON_STATE_ESCAPE:
+      if (c == '"' || c == '\\' || c == '/' || c == 'b' || c == 'f' ||
+          c == 'n' || c == 'r' || c == 't' || c == 'u') {
+        state = JSON_STATE_STRING;
+      } else {
+        return -1;
+      }
+      break;
+    case JSON_STATE_UTF8:
+      if (c < 128 || c > 191) {
+        return -1;
+      }
+      utf8_bytes--;
+      if (utf8_bytes == 0) {
+        state = JSON_STATE_STRING;
+      }
+      break;
+    default:
+      return -1;
+    }
+
+    if (action == JSON_ACTION_END_STRUCT) {
+      depth--;
+    }
+
+    if (depth == 1) {
+      if (action == JSON_ACTION_START || action == JSON_ACTION_START_STRUCT) {
+        if (index == 0) {
+          *value = s;
+        } else if (keysz > 0 && index == 1) {
+          k = s;
+        } else {
+          index--;
+        }
+      } else if (action == JSON_ACTION_END ||
+                 action == JSON_ACTION_END_STRUCT) {
+        if (*value != NULL && index == 0) {
+          *valuesz = (size_t)(s + 1 - *value);
+          return 0;
+        } else if (keysz > 0 && k != NULL) {
+          if (keysz == (size_t)(s - k - 1) && memcmp(key, k + 1, keysz) == 0) {
+            index = 0;
+          } else {
+            index = 2;
+          }
+          k = NULL;
+        }
+      }
+    }
+
+    if (action == JSON_ACTION_START_STRUCT) {
+      depth++;
+    }
+  }
+  return -1;
+}
+
+inline std::string json_escape(std::string s) {
+  // TODO: implement
+  return '"' + s + '"';
+}
+
+inline int json_unescape(const char *s, size_t n, char *out) {
+  int r = 0;
+  if (*s++ != '"') {
+    return -1;
+  }
+  while (n > 2) {
+    char c = *s;
+    if (c == '\\') {
+      s++;
+      n--;
+      switch (*s) {
+      case 'b':
+        c = '\b';
+        break;
+      case 'f':
+        c = '\f';
+        break;
+      case 'n':
+        c = '\n';
+        break;
+      case 'r':
+        c = '\r';
+        break;
+      case 't':
+        c = '\t';
+        break;
+      case '\\':
+        c = '\\';
+        break;
+      case '/':
+        c = '/';
+        break;
+      case '\"':
+        c = '\"';
+        break;
+      default: // TODO: support unicode decoding
+        return -1;
+      }
+    }
+    if (out != NULL) {
+      *out++ = c;
+    }
+    s++;
+    n--;
+    r++;
+  }
+  if (*s != '"') {
+    return -1;
+  }
+  if (out != NULL) {
+    *out = '\0';
+  }
+  return r;
+}
+
+inline std::string json_parse(const std::string s, const std::string key,
+                              const int index) {
+  const char *value;
+  size_t value_sz;
+  if (key == "") {
+    json_parse_c(s.c_str(), s.length(), nullptr, index, &value, &value_sz);
+  } else {
+    json_parse_c(s.c_str(), s.length(), key.c_str(), key.length(), &value,
+                 &value_sz);
+  }
+  if (value != nullptr) {
+    if (value[0] != '"') {
+      return std::string(value, value_sz);
+    }
+    int n = json_unescape(value, value_sz, nullptr);
+    if (n > 0) {
+      char *decoded = new char[n + 1];
+      json_unescape(value, value_sz, decoded);
+      std::string result(decoded, n);
+      delete[] decoded;
+      return result;
+    }
+  }
+  return "";
+}
+
+} // namespace webview
+
+//
+// ====================================================================
+//
+// This implementation uses Cocoa WKWebView backend on macOS. It is
+// written using ObjC runtime and uses WKWebView class as a browser runtime.
+// You should pass "-framework Webkit" flag to the compiler.
+//
+// ====================================================================
+//
+
+#define OBJC_OLD_DISPATCH_PROTOTYPES 1
+#include <CoreGraphics/CoreGraphics.h>
+#include <objc/objc-runtime.h>
+
+#define NSBackingStoreBuffered 2
+
+#define NSWindowStyleMaskResizable 8
+#define NSWindowStyleMaskMiniaturizable 4
+#define NSWindowStyleMaskTitled 1
+#define NSWindowStyleMaskClosable 2
+
+#define NSApplicationActivationPolicyRegular 0
+
+#define WKUserScriptInjectionTimeAtDocumentStart 0
+
+namespace webview {
+
+// Helpers to avoid too much typing
+id operator"" _cls(const char *s, std::size_t) { return (id)objc_getClass(s); }
+SEL operator"" _sel(const char *s, std::size_t) { return sel_registerName(s); }
+id operator"" _str(const char *s, std::size_t) {
+  return objc_msgSend("NSString"_cls, "stringWithUTF8String:"_sel, s);
+}
+
+class cocoa_wkwebview_engine {
+public:
+  cocoa_wkwebview_engine(bool debug, void *window) {
+    // Application
+    id app = objc_msgSend("NSApplication"_cls, "sharedApplication"_sel);
+    objc_msgSend(app, "setActivationPolicy:"_sel,
+                 NSApplicationActivationPolicyRegular);
+
+    // Delegate
+    auto cls =
+        objc_allocateClassPair((Class) "NSResponder"_cls, "AppDelegate", 0);
+    class_addProtocol(cls, objc_getProtocol("NSTouchBarProvider"));
+    class_addMethod(cls, "applicationShouldTerminateAfterLastWindowClosed:"_sel,
+                    (IMP)(+[](id, SEL, id) -> BOOL { return 1; }), "c@:@");
+    class_addMethod(cls, "userContentController:didReceiveScriptMessage:"_sel,
+                    (IMP)(+[](id self, SEL, id, id msg) {
+                      auto w =
+                          (cocoa_wkwebview_engine *)objc_getAssociatedObject(
+                              self, "webview");
+                      assert(w);
+                      w->on_message((const char *)objc_msgSend(
+                          objc_msgSend(msg, "body"_sel), "UTF8String"_sel));
+                    }),
+                    "v@:@@");
+    objc_registerClassPair(cls);
+
+    auto delegate = objc_msgSend((id)cls, "new"_sel);
+    objc_setAssociatedObject(delegate, "webview", (id)this,
+                             OBJC_ASSOCIATION_ASSIGN);
+    objc_msgSend(app, sel_registerName("setDelegate:"), delegate);
+
+    // Main window
+    if (window == nullptr) {
+      m_window = objc_msgSend("NSWindow"_cls, "alloc"_sel);
+      m_window = objc_msgSend(
+          m_window, "initWithContentRect:styleMask:backing:defer:"_sel,
+          CGRectMake(0, 0, 0, 0), 0, NSBackingStoreBuffered, 0);
+    } else {
+      m_window = (id)window;
+    }
+
+    // Webview
+    auto config = objc_msgSend("WKWebViewConfiguration"_cls, "new"_sel);
+    m_manager = objc_msgSend(config, "userContentController"_sel);
+    m_webview = objc_msgSend("WKWebView"_cls, "alloc"_sel);
+    if (debug) {
+      objc_msgSend(objc_msgSend(config, "preferences"_sel),
+                   "setValue:forKey:"_sel,
+                   objc_msgSend("NSNumber"_cls, "numberWithBool:"_sel, 1),
+                   "developerExtrasEnabled"_str);
+    }
+    objc_msgSend(m_webview, "initWithFrame:configuration:"_sel,
+                 CGRectMake(0, 0, 0, 0), config);
+    objc_msgSend(m_manager, "addScriptMessageHandler:name:"_sel, delegate,
+                 "external"_str);
+    init(R"script(
+                      window.external = {
+                        invoke: function(s) {
+                          window.webkit.messageHandlers.external.postMessage(s);
+                        },
+                      };
+                     )script");
+    objc_msgSend(m_window, "setContentView:"_sel, m_webview);
+    objc_msgSend(m_window, "makeKeyAndOrderFront:"_sel, nullptr);
+  }
+  ~cocoa_wkwebview_engine() { close(); }
+  void *window() { return (void *)m_window; }
+  void terminate() {
+    close();
+    objc_msgSend("NSApp"_cls, "terminate:"_sel, nullptr);
+  }
+  void run() {
+    id app = objc_msgSend("NSApplication"_cls, "sharedApplication"_sel);
+    dispatch([&]() { objc_msgSend(app, "activateIgnoringOtherApps:"_sel, 1); });
+    objc_msgSend(app, "run"_sel);
+  }
+  void dispatch(std::function<void()> f) {
+    dispatch_async_f(dispatch_get_main_queue(), new dispatch_fn_t(f),
+                     (dispatch_function_t)([](void *arg) {
+                       auto f = static_cast<dispatch_fn_t *>(arg);
+                       (*f)();
+                       delete f;
+                     }));
+  }
+  void set_title(const std::string title) {
+    objc_msgSend(m_window, "setTitle:"_sel,
+                 objc_msgSend("NSString"_cls, "stringWithUTF8String:"_sel,
+                              title.c_str()));
+  }
+  void set_size(int width, int height, int hints) {
+    auto style = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
+                 NSWindowStyleMaskMiniaturizable;
+    if (hints != WEBVIEW_HINT_FIXED) {
+      style = style | NSWindowStyleMaskResizable;
+    }
+    objc_msgSend(m_window, "setStyleMask:"_sel, style);
+
+    if (hints == WEBVIEW_HINT_MIN) {
+      objc_msgSend(m_window, "setContentMinSize:"_sel,
+                   CGSizeMake(width, height));
+    } else if (hints == WEBVIEW_HINT_MAX) {
+      objc_msgSend(m_window, "setContentMaxSize:"_sel,
+                   CGSizeMake(width, height));
+    } else {
+      objc_msgSend(m_window, "setFrame:display:animate:"_sel,
+                   CGRectMake(0, 0, width, height), 1, 0);
+    }
+  }
+  void navigate(const std::string url) {
+    auto nsurl = objc_msgSend(
+        "NSURL"_cls, "URLWithString:"_sel,
+        objc_msgSend("NSString"_cls, "stringWithUTF8String:"_sel, url.c_str()));
+    objc_msgSend(
+        m_webview, "loadRequest:"_sel,
+        objc_msgSend("NSURLRequest"_cls, "requestWithURL:"_sel, nsurl));
+  }
+  void init(const std::string js) {
+    objc_msgSend(
+        m_manager, "addUserScript:"_sel,
+        objc_msgSend(objc_msgSend("WKUserScript"_cls, "alloc"_sel),
+                     "initWithSource:injectionTime:forMainFrameOnly:"_sel,
+                     objc_msgSend("NSString"_cls, "stringWithUTF8String:"_sel,
+                                  js.c_str()),
+                     WKUserScriptInjectionTimeAtDocumentStart, 1));
+  }
+  void eval(const std::string js) {
+    objc_msgSend(
+        m_webview, "evaluateJavaScript:completionHandler:"_sel,
+        objc_msgSend("NSString"_cls, "stringWithUTF8String:"_sel, js.c_str()),
+        nullptr);
+  }
+
+private:
+  virtual void on_message(const std::string msg) = 0;
+  void close() { objc_msgSend(m_window, "close"_sel); }
+  id m_window;
+  id m_webview;
+  id m_manager;
+};
+
+using browser_engine = cocoa_wkwebview_engine;
+
+} // namespace webview
+
+
+namespace webview {
+
+class webview : public browser_engine {
+public:
+  webview(bool debug = false, void *wnd = nullptr)
+      : browser_engine(debug, wnd) {}
+
+  void navigate(const std::string url) {
+    if (url == "") {
+      browser_engine::navigate("data:text/html," +
+                               url_encode("<html><body>Hello</body></html>"));
+      return;
+    }
+    std::string html = html_from_uri(url);
+    if (html != "") {
+      browser_engine::navigate("data:text/html," + url_encode(html));
+    } else {
+      browser_engine::navigate(url);
+    }
+  }
+
+  using binding_t = std::function<void(std::string, std::string, void *)>;
+  using binding_ctx_t = std::pair<binding_t *, void *>;
+
+  using sync_binding_t = std::function<std::string(std::string)>;
+  using sync_binding_ctx_t = std::pair<webview *, sync_binding_t>;
+
+  void bind(const std::string name, sync_binding_t fn) {
+    bind(
+        name,
+        [](std::string seq, std::string req, void *arg) {
+          auto pair = static_cast<sync_binding_ctx_t *>(arg);
+          pair->first->resolve(seq, 0, pair->second(req));
+        },
+        new sync_binding_ctx_t(this, fn));
+  }
+
+  void bind(const std::string name, binding_t f, void *arg) {
+    auto js = "(function() { var name = '" + name + "';" + R"(
+      var RPC = window._rpc = (window._rpc || {nextSeq: 1});
+      window[name] = function() {
+        var seq = RPC.nextSeq++;
+        var promise = new Promise(function(resolve, reject) {
+          RPC[seq] = {
+            resolve: resolve,
+            reject: reject,
+          };
+        });
+        window.external.invoke(JSON.stringify({
+          id: seq,
+          method: name,
+          params: Array.prototype.slice.call(arguments),
+        }));
+        return promise;
+      }
+    })())";
+    init(js);
+    bindings[name] = new binding_ctx_t(new binding_t(f), arg);
+  }
+
+  void resolve(const std::string seq, int status, const std::string result) {
+    dispatch([=]() {
+      if (status == 0) {
+        eval("window._rpc[" + seq + "].resolve(" + result + "); window._rpc[" +
+             seq + "] = undefined");
+      } else {
+        eval("window._rpc[" + seq + "].reject(" + result + "); window._rpc[" +
+             seq + "] = undefined");
+      }
+    });
+  }
+
+private:
+  void on_message(const std::string msg) {
+    auto seq = json_parse(msg, "id", 0);
+    auto name = json_parse(msg, "method", 0);
+    auto args = json_parse(msg, "params", 0);
+    if (bindings.find(name) == bindings.end()) {
+      return;
+    }
+    auto fn = bindings[name];
+    (*fn->first)(seq, args, fn->second);
+  }
+  std::map<std::string, binding_ctx_t *> bindings;
+};
+} // namespace webview
+
+WEBVIEW_API webview_t webview_create(int debug, void *wnd) {
+  return new webview::webview(debug, wnd);
+}
+
+WEBVIEW_API void webview_destroy(webview_t w) {
+  delete static_cast<webview::webview *>(w);
+}
+
+WEBVIEW_API void webview_run(webview_t w) {
+  static_cast<webview::webview *>(w)->run();
+}
+
+WEBVIEW_API void webview_terminate(webview_t w) {
+  static_cast<webview::webview *>(w)->terminate();
+}
+
+WEBVIEW_API void webview_dispatch(webview_t w, void (*fn)(webview_t, void *),
+                                  void *arg) {
+  static_cast<webview::webview *>(w)->dispatch([=]() { fn(w, arg); });
+}
+
+WEBVIEW_API void *webview_get_window(webview_t w) {
+  return static_cast<webview::webview *>(w)->window();
+}
+
+WEBVIEW_API void webview_set_title(webview_t w, const char *title) {
+  static_cast<webview::webview *>(w)->set_title(title);
+}
+
+WEBVIEW_API void webview_set_size(webview_t w, int width, int height,
+                                  int hints) {
+  static_cast<webview::webview *>(w)->set_size(width, height, hints);
+}
+
+WEBVIEW_API void webview_navigate(webview_t w, const char *url) {
+  static_cast<webview::webview *>(w)->navigate(url);
+}
+
+WEBVIEW_API void webview_init(webview_t w, const char *js) {
+  static_cast<webview::webview *>(w)->init(js);
+}
+
+WEBVIEW_API void webview_eval(webview_t w, const char *js) {
+  static_cast<webview::webview *>(w)->eval(js);
+}
+
+WEBVIEW_API void webview_bind(webview_t w, const char *name,
+                              void (*fn)(const char *seq, const char *req,
+                                         void *arg),
+                              void *arg) {
+  static_cast<webview::webview *>(w)->bind(
+      name,
+      [=](std::string seq, std::string req, void *arg) {
+        fn(seq.c_str(), req.c_str(), arg);
+      },
+      arg);
+}
+
+WEBVIEW_API void webview_return(webview_t w, const char *seq, int status,
+                                const char *result) {
+  static_cast<webview::webview *>(w)->resolve(seq, status, result);
+}
+
+#endif /* WEBVIEW_HEADER */
+
+#endif /* WEBVIEW_H */
diff --git a/xpcom/glue/standalone/nsXPCOMGlue.cpp b/xpcom/glue/standalone/nsXPCOMGlue.cpp
--- a/xpcom/glue/standalone/nsXPCOMGlue.cpp
+++ b/xpcom/glue/standalone/nsXPCOMGlue.cpp
@@ -258,16 +258,17 @@ static nsresult XPCOMGlueLoad(const char
   if (getenv("MOZ_RUN_GTEST")
 #  ifdef FUZZING
       || getenv("FUZZER")
 #  endif
   ) {
     strcat(xpcomDir, ".gtest");
   }
 
+  printf("\nXPCOM Glue load %s\n", xpcomDir);
   ScopedCloseFile flist;
   flist = TS_tfopen(xpcomDir, READ_TEXTMODE);
   if (!flist) {
     return NS_ERROR_FAILURE;
   }
 
 #  ifdef XP_MACOSX
   tempLen = size_t(cursor - xpcomDir);
