# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  ea27094291fe39adf934fe5bd0303646aad34dfc
Bug 1036324 or 924899 -  Markup view load events

diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
--- a/browser/devtools/framework/selection.js
+++ b/browser/devtools/framework/selection.js
@@ -161,17 +161,17 @@ Selection.prototype = {
 
   setNodeFront: function(value, reason="unknown") {
     this.reason = reason;
 
     // We used to return here if the node had not changed but we now need to
     // set the node even if it is already set otherwise it is not possible to
     // e.g. highlight the same node twice.
     let rawValue = null;
-    if (value && value.isLocal_toBeDeprecated()) {
+    if (value && value.isLocal_toBeDeprecated && value.isLocal_toBeDeprecated()) {
       rawValue = value.rawNode();
     }
     this.emit("before-new-node", rawValue, reason);
     this.emit("before-new-node-front", value, reason);
     let previousNode = this._node;
     let previousFront = this._nodeFront;
     this._node = rawValue;
     this._nodeFront = value;
diff --git a/browser/devtools/inspector/test/doc_frame_script.js b/browser/devtools/inspector/test/doc_frame_script.js
--- a/browser/devtools/inspector/test/doc_frame_script.js
+++ b/browser/devtools/inspector/test/doc_frame_script.js
@@ -10,20 +10,16 @@
 // then execute code upon receiving, and immediately send back a message.
 // This is so that chrome test code can execute code in content and wait for a
 // response.
 // Some listeners do not send a response message back.
 
 let {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
 let {LayoutHelpers} = Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm", {});
 let DOMUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
-let loader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
-            .getService(Ci.mozIJSSubScriptLoader);
-let EventUtils = {};
-loader.loadSubScript("chrome://marionette/content/EventUtils.js", EventUtils);
 
 /**
  * If the test page creates and triggeres the custom event
  * "test-page-processing-done", then the Test:TestPageProcessingDone message
  * will be sent to the parent process for tests to wait for this event if needed.
  */
 addEventListener("DOMWindowCreated", () => {
   content.addEventListener("test-page-processing-done", () => {
@@ -228,65 +224,16 @@ addMessageListener("Test:GetAllAdjustedQ
   for (let boxType of ["content", "padding", "border", "margin"]) {
     regions[boxType] = helper.getAdjustedQuads(node, boxType);
   }
 
   sendAsyncMessage("Test:GetAllAdjustedQuads", regions);
 });
 
 /**
- * Synthesize a mouse event on an element. This handler doesn't send a message
- * back. Consumers should listen to specific events on the inspector/highlighter
- * to know when the event got synthesized.
- * @param {Object} msg The msg.data part expects the following properties:
- * - {Number} x
- * - {Number} y
- * - {Boolean} center If set to true, x/y will be ignored and
- *             synthesizeMouseAtCenter will be used instead
- * - {Object} options Other event options
- * - {String} selector An optional selector that will be used to find the node to
- *            synthesize the event on, if msg.objects doesn't contain the CPOW.
- * The msg.objects part should be the element.
- * @param {Object} data Event detail properties:
- */
-addMessageListener("Test:SynthesizeMouse", function(msg) {
-  let {x, y, center, options, selector} = msg.data;
-  let {node} = msg.objects;
-
-  if (!node && selector) {
-    node = superQuerySelector(selector);
-  }
-
-  if (center) {
-    EventUtils.synthesizeMouseAtCenter(node, options, node.ownerDocument.defaultView);
-  } else {
-    EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
-  }
-
-  // Most consumers won't need to listen to this message, unless they want to
-  // wait for the mouse event to be synthesized and don't have another event
-  // to listen to instead.
-  sendAsyncMessage("Test:SynthesizeMouse");
-});
-
-/**
- * Synthesize a key event for an element. This handler doesn't send a message
- * back. Consumers should listen to specific events on the inspector/highlighter
- * to know when the event got synthesized.
- * @param  {Object} msg The msg.data part expects the following properties:
- * - {String} key
- * - {Object} options
- */
-addMessageListener("Test:SynthesizeKey", function(msg) {
-  let {key, options} = msg.data;
-
-  EventUtils.synthesizeKey(key, options, content);
-});
-
-/**
  * Check that an element currently has a pseudo-class lock.
  * @param {Object} msg The msg.data part expects the following properties:
  * - {String} pseudo The pseudoclass to check for
  * The msg.objects part should be the element.
  * @param {Object}
  * @return {Boolean}
  */
 addMessageListener("Test:HasPseudoClassLock", function(msg) {
diff --git a/browser/devtools/markupview/test/browser.ini b/browser/devtools/markupview/test/browser.ini
--- a/browser/devtools/markupview/test/browser.ini
+++ b/browser/devtools/markupview/test/browser.ini
@@ -62,16 +62,17 @@ skip-if = e10s # Bug 1040751 - CodeMirro
 [browser_markupview_events_jquery_1.6.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_1.7.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_1.11.1.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_2.1.1.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
+[browser_markupview_load_01.js]
 [browser_markupview_html_edit_01.js]
 [browser_markupview_html_edit_02.js]
 [browser_markupview_html_edit_03.js]
 [browser_markupview_image_tooltip.js]
 [browser_markupview_keybindings_01.js]
 [browser_markupview_mutation_01.js]
 [browser_markupview_mutation_02.js]
 [browser_markupview_navigation.js]
diff --git a/browser/devtools/markupview/test/browser_markupview_load_01.js b/browser/devtools/markupview/test/browser_markupview_load_01.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_load_01.js
@@ -0,0 +1,144 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+Cu.import("resource://gre/modules/Services.jsm");
+
+
+function createTestServer() {
+  const {HttpServer} = Cu.import("resource://testing-common/httpd.js", {});
+  let server = new HttpServer();
+  server.registerContentType("js", "text/javascript");
+  server.registerPathHandler("/slow.js", function (metadata, response) {
+    info ("Sript has been requested");
+    response.processAsync();
+    setTimeout(() => {
+      info ("Image is responding");
+      response.finish();
+    }, 5000);
+  });
+
+  server.start(-1);
+  registerCleanupFunction(function* cleanup() {
+    ok (false, "cleanuP");
+    yield promise.defer().promise;
+    let destroyed = promise.defer();
+    server.stop(() => {
+      destroyed.resolve();
+    });
+    yield destroyed.promise;
+  });
+
+  return server;
+}
+requestLongerTimeout(5);
+
+
+// Test page load events.
+const TEST_URL = "data:text/html," +
+  "<!DOCTYPE html>" +
+  "<head><meta charset='utf-8' /></head>" +
+  "<body>" +
+  "<p>Slow script</p>" +
+  "<script src='http://localhost:" + server.identity.primaryPort + "/slow.js'></script>" +
+  "</body>" +
+  "</html>";
+
+let server = createTestServer();
+
+add_task(function*() {
+  let tabAdded = addTab(TEST_URL);
+  let {inspector} = yield openInspector();
+
+  ok(true);
+  yield tabAdded;
+  return;
+
+  // yield promise.defer().proimse;
+
+  // let node = getNode("p");
+  // let tabReloading = yield reloadTab();
+  // content.location.reload();
+  gBrowser.reload();
+
+  setTimeout(() => {
+
+    EventUtils.synthesizeMouse(gBrowser.selectedBrowser, 10, 10, {type: "contextmenu", button: 2})
+    let contentAreaContextMenu = document.querySelector("#contentAreaContextMenu");
+    let contextMenu = new nsContextMenu(contentAreaContextMenu);
+    info("Triggering inspect action and hiding the menu.");
+  }, 500);
+  // yield contextMenu.inspectNode();
+
+yield promise.defer().promise;
+//   yield executeInContent("Test:SynthesizeMouse", {
+//     center: true,
+//     // selector: "img",
+//     options: {type: "contextmenu", button: 2}
+//   }, {node: content.document.body});
+
+//   try {
+//     document.popupNode = node;
+//   } catch (e) {}
+
+//   let contentAreaContextMenu = document.querySelector("#contentAreaContextMenu");
+//   let contextMenu = new nsContextMenu(contentAreaContextMenu);
+
+
+//   info("Triggering inspect action and hiding the menu.");
+//   yield contextMenu.inspectNode();
+//   contentAreaContextMenu.hidden = true;
+//   contentAreaContextMenu.hidePopup();
+//   contextMenu.hiding();
+
+//   yield tabReloading;
+// yield promise.defer().promise;
+  // info("Opening the inspector using the content context-menu");
+  // let onInspectorReady = gDevTools.once("inspector-ready");
+
+  // document.popupNode = element;
+  // let contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
+
+  // console.log(element, contentAreaContextMenu)
+  // let contextMenu = new nsContextMenu(contentAreaContextMenu);
+  // yield contextMenu.inspectNode();
+
+  // // Clean up context menu:
+  // contextMenu.hiding();
+
+  // yield onInspectorReady;
+
+  // let target = TargetFactory.forTab(gBrowser.selectedTab);
+  // let toolbox = gDevTools.getToolbox(target);
+
+  // info("Getting the inspector and making sure it is fully updated");
+  // let inspector = toolbox.getPanel("inspector");
+
+});
+
+// add_task(function*() {
+//   let tabAdded = addTab(TEST_URL);
+//   let {inspector} = yield openInspector();
+
+//   // Purposely not yielding since we want to select a front during the reload.
+
+//   let node = yield getNodeFront("img", inspector);
+//   let node2 = getNode("img");
+//   ok(node, "There is a node front");
+//   ok(node2, "There is a raw node");
+// console.log(node);
+//   // yield promise.defer().promise;
+//   inspector.selection.setNodeFront(node);
+//   // inspector.selection.setNode(node2, "browser-context-menu");
+
+//   // let tabReloading = reloadTab();
+//   // yield tabReloading;
+//   // XX: Right click context menu item
+
+//   // XX: check if markup view has content
+
+//   yield tabAdded;
+//   yield promise.defer().promise;
+// });
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -50,33 +50,33 @@ const TEST_URL_ROOT = "http://mochi.test
 const CHROME_BASE = "chrome://mochitests/content/browser/browser/devtools/markupview/test/";
 const COMMON_FRAME_SCRIPT_URL = "chrome://browser/content/devtools/frame-script-utils.js";
 
 /**
  * Add a new test tab in the browser and load the given url.
  * @param {String} url The url to be loaded in the new tab
  * @return a promise that resolves to the tab object when the url is loaded
  */
-function addTab(url) {
+function addTab(url, loadEvent = "load") {
   info("Adding a new tab with URL: '" + url + "'");
   let def = promise.defer();
 
   // Bug 921935 should bring waitForFocus() support to e10s, which would
   // probably cover the case of the test losing focus when the page is loading.
   // For now, we just make sure the window is focused.
   window.focus();
 
   let tab = window.gBrowser.selectedTab = window.gBrowser.addTab(url);
   let linkedBrowser = tab.linkedBrowser;
 
   info("Loading the helper frame script " + COMMON_FRAME_SCRIPT_URL);
   linkedBrowser.messageManager.loadFrameScript(COMMON_FRAME_SCRIPT_URL, false);
 
-  linkedBrowser.addEventListener("load", function onload() {
-    linkedBrowser.removeEventListener("load", onload, true);
+  linkedBrowser.addEventListener(loadEvent, function onload() {
+    linkedBrowser.removeEventListener(loadEvent, onload, true);
     info("URL '" + url + "' loading complete");
     def.resolve(tab);
   }, true);
 
   return def.promise;
 }
 
 /**
@@ -168,16 +168,23 @@ function executeInContent(name, data={},
   if (expectResponse) {
     return waitForContentMessage(name);
   } else {
     return promise.resolve();
   }
 }
 
 /**
+ * Reload the current tab location.
+ */
+function reloadTab() {
+  return executeInContent("devtools:test:reload", {}, {}, false);
+}
+
+/**
  * Simple DOM node accesor function that takes either a node or a string css
  * selector as argument and returns the corresponding node
  * @param {String|DOMNode} nodeOrSelector
  * @return {DOMNode|CPOW} Note that in e10s mode a CPOW object is returned which
  * doesn't implement *all* of the DOMNode's properties
  */
 function getNode(nodeOrSelector) {
   info("Getting the node for '" + nodeOrSelector + "'");
diff --git a/browser/devtools/shared/frame-script-utils.js b/browser/devtools/shared/frame-script-utils.js
--- a/browser/devtools/shared/frame-script-utils.js
+++ b/browser/devtools/shared/frame-script-utils.js
@@ -1,18 +1,22 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
-const Cu = Components.utils;
-
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
 const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 devtools.lazyImporter(this, "promise", "resource://gre/modules/Promise.jsm", "Promise");
 devtools.lazyImporter(this, "Task", "resource://gre/modules/Task.jsm", "Task");
+const loader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
+            .getService(Ci.mozIJSSubScriptLoader);
+let EventUtils = {};
+loader.loadSubScript("chrome://marionette/content/EventUtils.js", EventUtils);
+{type: "contextmenu", button: 2}
 
 addMessageListener("devtools:test:history", function ({ data }) {
   content.history[data.direction]();
 });
 
 addMessageListener("devtools:test:navigate", function ({ data }) {
   content.location = data.location;
 });
@@ -185,16 +189,65 @@ addMessageListener("devtools:test:setAtt
   }
 
   node.setAttribute(attributeName, attributeValue);
 
   sendAsyncMessage("devtools:test:setAttribute");
 });
 
 /**
+ * Synthesize a mouse event on an element. This handler doesn't send a message
+ * back. Consumers should listen to specific events on the inspector/highlighter
+ * to know when the event got synthesized.
+ * @param {Object} msg The msg.data part expects the following properties:
+ * - {Number} x
+ * - {Number} y
+ * - {Boolean} center If set to true, x/y will be ignored and
+ *             synthesizeMouseAtCenter will be used instead
+ * - {Object} options Other event options
+ * - {String} selector An optional selector that will be used to find the node to
+ *            synthesize the event on, if msg.objects doesn't contain the CPOW.
+ * The msg.objects part should be the element.
+ * @param {Object} data Event detail properties:
+ */
+addMessageListener("Test:SynthesizeMouse", function(msg) {
+  let {x, y, center, options, selector} = msg.data;
+  let {node} = msg.objects;
+
+  if (!node && selector) {
+    node = superQuerySelector(selector);
+  }
+
+  if (center) {
+    EventUtils.synthesizeMouseAtCenter(node, options, node.ownerDocument.defaultView);
+  } else {
+    EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
+  }
+
+  // Most consumers won't need to listen to this message, unless they want to
+  // wait for the mouse event to be synthesized and don't have another event
+  // to listen to instead.
+  sendAsyncMessage("Test:SynthesizeMouse");
+});
+
+/**
+ * Synthesize a key event for an element. This handler doesn't send a message
+ * back. Consumers should listen to specific events on the inspector/highlighter
+ * to know when the event got synthesized.
+ * @param  {Object} msg The msg.data part expects the following properties:
+ * - {String} key
+ * - {Object} options
+ */
+addMessageListener("Test:SynthesizeKey", function(msg) {
+  let {key, options} = msg.data;
+
+  EventUtils.synthesizeKey(key, options, content);
+});
+
+/**
  * Like document.querySelector but can go into iframes too.
  * ".container iframe || .sub-container div" will first try to find the node
  * matched by ".container iframe" in the root document, then try to get the
  * content document inside it, and then try to match ".sub-container div" inside
  * this document.
  * Any selector coming before the || separator *MUST* match a frame node.
  * @param {String} superSelector.
  * @return {DOMNode} The node, or null if not found.
