# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  30d5aaf48c420840a2aeaa6bccc42d66375c6f3c
Test updates

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -2,16 +2,17 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 ///////////////////
 //
 // Whitelisting this test.
 // As part of bug 1077403, the leaking uncaught rejection should be fixed.
 //
 thisTestLeaksUncaughtRejectionsAndShouldBeFixed("TypeError: aValue.content is undefined");
+SimpleTest.requestCompleteLog();
 
 /**
  * Bug 863102 - Automatically scroll down upon new network requests.
  */
 add_task(function*() {
   requestLongerTimeout(2);
   let monitor, debuggee, requestsContainer, scrollTop;
 
@@ -22,16 +23,17 @@ add_task(function*() {
   let topNode = win.document.getElementById("requests-menu-contents");
   requestsContainer = topNode.getElementsByTagName("scrollbox")[0];
   ok(!!requestsContainer, "Container element exists as expected.");
 
   win.NetMonitorView.RequestsMenu.lazyUpdate = false;
 
   // (1) Check that the scroll position is maintained at the bottom
   // when the requests overflow the vertical size of the container.
+  info ("Waiting for requests to overflow container");
   yield waitForRequestsToOverflowContainer(monitor, requestsContainer);
   yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
 
   // (2) Now set the scroll position somewhere in the middle and check
   // that additional requests do not change the scroll position.
   let children = requestsContainer.childNodes;
   let middleNode = children.item(children.length / 2);
@@ -68,21 +70,27 @@ add_task(function*() {
         return promise.resolve();
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
       }
     });
   }
 
   function scrolledToBottom(aElement) {
+    info ("Checking scroll to bottom -" +
+            " scrollTop: " + aElement.scrollTop +
+            " clientHeight: " + aElement.clientHeight +
+            " scrollHeight: " + aElement.scrollHeight);
     return aElement.scrollTop + aElement.clientHeight >= aElement.scrollHeight;
   }
 
   function waitSomeTime() {
+    info ("Waiting some time");
     let waitSomeTime = promise.defer();
     setTimeout(waitSomeTime.resolve, 50); // Wait to make sure no scrolls happen
     return waitSomeTime.promise;
   }
 
   function waitForScroll(aMonitor) {
+    info ("Waiting for scroll");
     return aMonitor._view.RequestsMenu.widget.once("scroll-to-bottom");
   }
 });
diff --git a/browser/devtools/netmonitor/test/head.js b/browser/devtools/netmonitor/test/head.js
--- a/browser/devtools/netmonitor/test/head.js
+++ b/browser/devtools/netmonitor/test/head.js
@@ -243,17 +243,17 @@ function waitForNetworkEvents(aMonitor, 
       postEvents + "/" + (aPostRequests * 2) + ", " +
       "got " + event + " for " + actor);
 
     let networkInfo =
       panel.NetMonitorController.webConsoleClient.getNetworkRequest(actor)
     let url = networkInfo.request.url;
     updateProgressForURL(url, event);
 
-    info("> Current state: " + JSON.stringify(progress, null, 2));
+    // info("> Current state: " + JSON.stringify(progress, null, 2));
 
     // There are 15 updates which need to be fired for a request to be
     // considered finished. The "requestPostData" packet isn't fired for
     // non-POST requests.
     if (genericEvents >= (aGetRequests + aPostRequests) * 13 &&
         postEvents >= aPostRequests * 2) {
 
       awaitedEventsToListeners.forEach(([e, l]) => panel.off(events[e], l));
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -120,72 +120,84 @@ SideMenuWidget.prototype = {
       (!this._scrollToBottomTask || !this._scrollToBottomTask.isArmed) &&
       // 5. The list should already be scrolled at the bottom.
       this.isScrolledToBottom();
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
+
+    let {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+    console.log("Planning to maintain scoll at bottom?", maintainScrollAtBottom);
     if (maintainScrollAtBottom) {
       this.scrollToBottom();
     }
 
     return element;
   },
 
   /**
    * Checks to see if the list is scrolled all the way to the bottom.
    * Uses getBoundsWithoutFlushing to limit the performance impact
    * of this function.
    *
    * @return bool
    */
   isScrolledToBottom: function() {
+
+    let {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
+    console.log("Is scroled to bottom");
     if (this._list.lastElementChild) {
       let utils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
                              .getInterface(Ci.nsIDOMWindowUtils);
       let childRect = utils.getBoundsWithoutFlushing(this._list.lastElementChild);
       let listRect = utils.getBoundsWithoutFlushing(this._list);
 
+      console.log("Is scroled to bottom", (childRect.height + childRect.top) <= listRect.bottom,
+        childRect.height, childRect.top, listRect.bottom);
       // Cheap way to check if it's scrolled all the way to the bottom.
       return (childRect.height + childRect.top) <= listRect.bottom;
     }
 
     return false;
   },
 
   /**
    * Scroll the list to the bottom after a timeout.
    * If the user scrolls in the meantime, cancel this operation.
    */
   scrollToBottom: function() {
+    let {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
     // Lazily attach this functionality to the object, so it won't get
     // created unless if this scrollToBottom behavior is needed.
     if (!this._scrollToBottomTask) {
       // The scroll event fires asynchronously, so we need to keep a bit to
       // distinguish between user-initiated events and scrollTop assignment.
       let ignoreNextScroll = false;
-
+      console.log("Adding task");
       this._scrollToBottomTask = new DeferredTask(() => {
         ignoreNextScroll = true;
         this._list.scrollTop = this._list.scrollHeight;
         this.emit("scroll-to-bottom");
       }, SCROLL_FREQUENCY);
 
       // On a user scroll, cancel any pending calls to the scroll function.
       this._list.addEventListener("scroll", () => {
+      console.log("Scroll event receieved", !ignoreNextScroll , this._scrollToBottomTask.isArmed ,
+            !this.isScrolledToBottom());
         if (!ignoreNextScroll && this._scrollToBottomTask.isArmed &&
             !this.isScrolledToBottom()) {
           this._scrollToBottomTask.disarm();
         }
         ignoreNextScroll = false;
       }, true);
     }
 
+    console.log("Arming timer");
     this._scrollToBottomTask.arm();
   },
 
   /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
