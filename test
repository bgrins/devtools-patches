# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  db6a6012c8725ad0aa9b51958d2dacd68b5f0964
Bug 1163775 - Skip the scroll event fired due to setting scrollTop in browser_net_autoscroll.js;r=vporof

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -8,24 +8,23 @@
 //
 thisTestLeaksUncaughtRejectionsAndShouldBeFixed("TypeError: aValue.content is undefined");
 
 /**
  * Bug 863102 - Automatically scroll down upon new network requests.
  */
 add_task(function*() {
   requestLongerTimeout(2);
-  let monitor, debuggee, requestsContainer, scrollTop;
 
-  let [aTab, aDebuggee, aMonitor] = yield initNetMonitor(INFINITE_GET_URL);
-  monitor = aMonitor;
-  debuggee = aDebuggee;
+  let scrollTop;
+  let [aTab, debuggee, monitor] = yield initNetMonitor(INFINITE_GET_URL);
   let win = monitor.panelWin;
   let topNode = win.document.getElementById("requests-menu-contents");
-  requestsContainer = topNode.getElementsByTagName("scrollbox")[0];
+  let requestsContainer = topNode.getElementsByTagName("scrollbox")[0];
+  let requestsMenu = win.NetMonitorView.RequestsMenu
   ok(!!requestsContainer, "Container element exists as expected.");
 
   // (1) Check that the scroll position is maintained at the bottom
   // when the requests overflow the vertical size of the container.
   yield waitForRequestsToOverflowContainer(monitor, requestsContainer);
   yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
 
@@ -35,16 +34,20 @@ add_task(function*() {
   let middleNode = children.item(children.length / 2);
   middleNode.scrollIntoView();
   ok(!scrolledToBottom(requestsContainer), "Not scrolled to bottom.");
   scrollTop = requestsContainer.scrollTop; // save for comparison later
   yield waitForNetworkEvents(monitor, 8);
   yield waitSomeTime();
   is(requestsContainer.scrollTop, scrollTop, "Did not scroll.");
 
+  // Tell the frontend to not worry about the async scroll event that's
+  // going to fire after we programmatically set it in the next step.
+  requestsMenu.ignoreNextScroll = true;
+
   // (3) Now set the scroll position back at the bottom and check that
   // additional requests *do* cause the container to scroll down.
   requestsContainer.scrollTop = requestsContainer.scrollHeight;
   ok(scrolledToBottom(requestsContainer), "Set scroll position to bottom.");
   yield waitForNetworkEvents(monitor, 8);
   yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Still scrolled to bottom.");
 
@@ -66,21 +69,27 @@ add_task(function*() {
         return promise.resolve();
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
       }
     });
   }
 
   function scrolledToBottom(aElement) {
+    info ("scrolledToBottom called -" +
+          " scrollTop: " + aElement.scrollTop +
+          " clientHeight: " + aElement.clientHeight +
+          " scrollHeight: " + aElement.scrollHeight);
     return aElement.scrollTop + aElement.clientHeight >= aElement.scrollHeight;
   }
 
   function waitSomeTime() {
+    info ("waitSomeTime called");
     let waitSomeTime = promise.defer();
     setTimeout(waitSomeTime.resolve, 50); // Wait to make sure no scrolls happen
     return waitSomeTime.promise;
   }
 
   function waitForScroll(aMonitor) {
+    info ("waitForScroll called");
     return aMonitor._view.RequestsMenu.widget.once("scroll-to-bottom");
   }
 });
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -158,31 +158,31 @@ SideMenuWidget.prototype = {
    * If the user scrolls in the meantime, cancel this operation.
    */
   scrollToBottom: function() {
     // Lazily attach this functionality to the object, so it won't get
     // created unless if this scrollToBottom behavior is needed.
     if (!this._scrollToBottomTask) {
       // The scroll event fires asynchronously, so we need to keep a bit to
       // distinguish between user-initiated events and scrollTop assignment.
-      let ignoreNextScroll = false;
+      this.ignoreNextScroll = false;
 
       this._scrollToBottomTask = new DeferredTask(() => {
-        ignoreNextScroll = true;
+        this.ignoreNextScroll = true;
         this._list.scrollTop = this._list.scrollHeight;
         this.emit("scroll-to-bottom");
       }, SCROLL_FREQUENCY);
 
       // On a user scroll, cancel any pending calls to the scroll function.
       this._list.addEventListener("scroll", () => {
-        if (!ignoreNextScroll && this._scrollToBottomTask.isArmed &&
+        if (!this.ignoreNextScroll && this._scrollToBottomTask.isArmed &&
             !this.isScrolledToBottom()) {
           this._scrollToBottomTask.disarm();
         }
-        ignoreNextScroll = false;
+        this.ignoreNextScroll = false;
       }, true);
     }
 
     this._scrollToBottomTask.arm();
   },
 
   /**
    * Returns the child node in this container situated at the specified index.
