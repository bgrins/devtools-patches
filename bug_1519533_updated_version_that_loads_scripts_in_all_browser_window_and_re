# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1549563613 28800
#      Thu Feb 07 10:20:13 2019 -0800
# Node ID 2b9f92866e506a8782c55f872cb5f6762ca4e3a1
# Parent  00432a450b3af67c4d5711810691b27093880c62
Bug 1519533 - Updated version that loads scripts in all browser window and restores stylesheet loading

Differential Revision: https://phabricator.services.mozilla.com/D19027

diff --git a/browser/extensions/formautofill/FormAutofillParent.jsm b/browser/extensions/formautofill/FormAutofillParent.jsm
--- a/browser/extensions/formautofill/FormAutofillParent.jsm
+++ b/browser/extensions/formautofill/FormAutofillParent.jsm
@@ -26,16 +26,17 @@
  */
 
 "use strict";
 
 // We expose a singleton from this module. Some tests may import the
 // constructor via a backstage pass.
 var EXPORTED_SYMBOLS = ["formAutofillParent"];
 
+const {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const {XPCOMUtils} = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const {FormAutofill} = ChromeUtils.import("resource://formautofill/FormAutofill.jsm");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   CreditCard: "resource://gre/modules/CreditCard.jsm",
@@ -102,16 +103,17 @@ FormAutofillParent.prototype = {
    */
   async init() {
     if (this._initialized) {
       return;
     }
     this._initialized = true;
 
     Services.obs.addObserver(this, "privacy-pane-loaded");
+    Services.obs.addObserver(this, "document-element-inserted");
     Services.ppmm.addMessageListener("FormAutofill:InitStorage", this);
     Services.ppmm.addMessageListener("FormAutofill:GetRecords", this);
     Services.ppmm.addMessageListener("FormAutofill:SaveAddress", this);
     Services.ppmm.addMessageListener("FormAutofill:RemoveAddresses", this);
     Services.ppmm.addMessageListener("FormAutofill:OpenPreferences", this);
     Services.mm.addMessageListener("FormAutofill:OnFormSubmit", this);
 
     // Observing the pref and storage changes
@@ -120,30 +122,47 @@ FormAutofillParent.prototype = {
 
     // Only listen to credit card related messages if it is available
     if (FormAutofill.isAutofillCreditCardsAvailable) {
       Services.ppmm.addMessageListener("FormAutofill:SaveCreditCard", this);
       Services.ppmm.addMessageListener("FormAutofill:RemoveCreditCards", this);
       Services.ppmm.addMessageListener("FormAutofill:GetDecryptedString", this);
       Services.prefs.addObserver(ENABLED_AUTOFILL_CREDITCARDS_PREF, this);
     }
+
+    for (let win of BrowserWindowTracker.orderedWindows) {
+      this.injectElements(win.document);
+    }
+  },
+
+  injectElements(doc) {
+    Services.scriptloader.loadSubScript(
+      "chrome://formautofill/content/formautofill.js", doc.ownerGlobal
+    );
   },
 
   observe(subject, topic, data) {
     log.debug("observe:", topic, "with data:", data);
     switch (topic) {
       case "privacy-pane-loaded": {
         let formAutofillPreferences = new FormAutofillPreferences();
         let document = subject.document;
         let prefFragment = formAutofillPreferences.init(document);
         let formAutofillGroupBox = document.getElementById("formAutofillGroupBox");
         formAutofillGroupBox.appendChild(prefFragment);
         break;
       }
 
+      case "document-element-inserted": {
+        if (subject.documentURI == AppConstants.BROWSER_CHROME_URL) {
+          this.injectElements(subject);
+        }
+        break;
+      }
+
       case "nsPref:changed": {
         // Observe pref changes and update _active cache if status is changed.
         this._updateStatus();
         break;
       }
 
       case "formautofill-storage-changed": {
         // Early exit if only metadata is changed
diff --git a/browser/extensions/formautofill/content/formautofill.css b/browser/extensions/formautofill/content/formautofill.css
--- a/browser/extensions/formautofill/content/formautofill.css
+++ b/browser/extensions/formautofill/content/formautofill.css
@@ -6,33 +6,19 @@
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-footer"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-insecureWarning"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-clear-button"] {
   display: block;
   margin: 0;
   padding: 0;
   height: auto;
   min-height: auto;
-}
-
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-profile"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem");
+  -moz-binding: none;
 }
 
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-footer"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-footer");
-}
-
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-insecureWarning"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-creditcard-insecure-field");
-}
-
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-clear-button"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-clear-button");
-}
 /* Treat @collpased="true" as display: none similar to how it is for XUL elements.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#Values */
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-profile"][collapsed="true"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-footer"][collapsed="true"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-insecureWarning"][collapsed="true"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-clear-button"][collapsed="true"] {
   display: none;
 }
@@ -55,8 +41,26 @@
   width: 16px;
   height: 16px;
   list-style-image: url(chrome://formautofill/content/icon-credit-card-generic.svg);
 }
 #autofill-address-notification > popupnotificationcontent > .desc-message-box > description,
 #autofill-credit-card-notification > popupnotificationcontent > .desc-message-box > description {
   font-style: italic;
 }
+
+.autofill-item-box {
+  --item-padding-vertical: 7px;
+  --item-padding-horizontal: 10px;
+  --col-spacer: 7px;
+  --item-width: calc(50% - (var(--col-spacer) / 2));
+  --label-text-color: #262626;
+  --comment-text-color: #646464;
+  --warning-text-color: #646464;
+  --btn-text-color: -moz-FieldText;
+
+  --default-font-size: 12;
+  --label-affix-font-size: 10;
+  --label-font-size: 12;
+  --comment-font-size: 10;
+  --warning-font-size: 10;
+  --btn-font-size: 11;
+}
diff --git a/browser/extensions/formautofill/content/formautofill.js b/browser/extensions/formautofill/content/formautofill.js
new file mode 100644
--- /dev/null
+++ b/browser/extensions/formautofill/content/formautofill.js
@@ -0,0 +1,371 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This file is loaded into the browser window scope.
+/* eslint-env mozilla/browser-window */
+
+"use strict";
+
+// Wrap in a block to prevent leaking to window scope.
+(() => {
+  const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
+
+  class MozAutocompleteProfileListitemBase extends MozElements.MozRichlistitem {
+    constructor() {
+      super();
+
+      console.log("MozAutocompleteProfileListitemBase constructed");
+
+    /**
+     * For form autofill, we want to unify the selection no matter by
+     * keyboard navigation or mouseover in order not to confuse user which
+     * profile preview is being shown. This field is set to true to indicate
+     * that selectedIndex of popup should be changed while mouseover item
+     */
+      this.selectedByMouseOver = true;
+    }
+
+    get _stringBundle() {
+      if (!this.__stringBundle) {
+        this.__stringBundle = Services.strings.createBundle(
+        "chrome://formautofill/locale/formautofill.properties"
+      );
+      }
+      return this.__stringBundle;
+    }
+
+    _cleanup() {
+      this.removeAttribute("formautofillattached");
+      if (this._itemBox) {
+        this._itemBox.removeAttribute("size");
+      }
+    }
+
+    _onOverflow() {}
+
+    _onUnderflow() {}
+
+    handleOverUnderflow() {}
+
+    _adjustAutofillItemLayout() {
+      let outerBoxRect = this.parentNode.getBoundingClientRect();
+
+    // Make item fit in popup as XUL box could not constrain
+    // item's width
+      this._itemBox.style.width = outerBoxRect.width + "px";
+    // Use two-lines layout when width is smaller than 150px or
+    // 185px if an image precedes the label.
+      let oneLineMinRequiredWidth = this.getAttribute("ac-image") ? 185 : 150;
+
+      if (outerBoxRect.width <= oneLineMinRequiredWidth) {
+        this._itemBox.setAttribute("size", "small");
+      } else {
+        this._itemBox.removeAttribute("size");
+      }
+    }
+}
+
+  MozElements.MozAutocompleteProfileListitem = class MozAutocompleteProfileListitem extends MozAutocompleteProfileListitemBase {
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      console.log("MozAutocompleteProfileListitem connectedCallback");
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+      <div class="autofill-item-box">
+        <div class="profile-label-col profile-item-col">
+          <span class="profile-label-affix"></span>
+          <span class="profile-label"></span>
+        </div>
+        <div class="profile-comment-col profile-item-col">
+          <span class="profile-comment"></span>
+        </div>
+      </div>
+    `));
+
+      this._itemBox = this.querySelector(".autofill-item-box");
+      this._labelAffix = this.querySelector(".profile-label-affix");
+      this._label = this.querySelector(".profile-label");
+      this._comment = this.querySelector(".profile-comment");
+
+      this._updateAttributes();
+      this._adjustAcItem();
+    }
+
+    static get observedAttributes() {
+      return [
+        "ac-image",
+      ];
+    }
+
+    attributeChangedCallback() {
+      if (this.isConnectedAndReady) {
+        this._updateAttributes();
+      }
+    }
+
+    _updateAttributes() {
+      const map = new Map([
+      [this._itemBox, ["ac-image"]],
+      ]);
+
+      for (let [el, attrs] of map.entries()) {
+        for (let attr of attrs) {
+          this.inheritAttribute(el, attr);
+        }
+      }
+    }
+
+    set selected(val) {
+      if (val) {
+        this.setAttribute("selected", "true");
+      } else {
+        this.removeAttribute("selected");
+      }
+
+      let {AutoCompletePopup} =
+      ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
+      AutoCompletePopup.sendMessageToBrowser("FormAutofill:PreviewProfile");
+
+      return val;
+    }
+
+    get selected() {
+      return this.getAttribute("selected") == "true";
+    }
+
+    _adjustAcItem() {
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
+      this._itemBox.style.setProperty("--primary-icon", `url(${this.getAttribute("ac-image")})`);
+
+      let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute("ac-value"));
+
+      this._labelAffix.textContent = primaryAffix;
+      this._label.textContent = primary;
+      this._comment.textContent = secondary;
+    }
+};
+
+  customElements.define(
+  "autocomplete-profile-listitem",
+  MozElements.MozAutocompleteProfileListitem,
+  {extends: "richlistitem"}
+);
+
+  class MozAutocompleteProfileListitemFooter extends MozAutocompleteProfileListitemBase {
+    constructor() {
+      super();
+
+      this.addEventListener("click", (event) => {
+        if (event.button != 0) {
+          return;
+        }
+
+        if (this._warningTextBox.contains(event.originalTarget)) {
+          return;
+        }
+
+        window.openPreferences("privacy-form-autofill", {origin: "autofillFooter"});
+      });
+    }
+
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+      <div class="autofill-item-box autofill-footer">
+        <div class="autofill-footer-row autofill-warning"></div>
+        <div class="autofill-footer-row autofill-button"></div>
+      </div>
+    `));
+
+      this._itemBox = this.querySelector(".autofill-footer");
+      this._optionButton = this.querySelector(".autofill-button");
+      this._warningTextBox = this.querySelector(".autofill-warning");
+
+    /**
+     * A handler for updating warning message once selectedIndex has been changed.
+     *
+     * There're three different states of warning message:
+     * 1. None of addresses were selected: We show all the categories intersection of fields in the
+     *    form and fields in the results.
+     * 2. An address was selested: Show the additional categories that will also be filled.
+     * 3. An address was selected, but the focused category is the same as the only one category: Only show
+     * the exact category that we're going to fill in.
+     *
+     * @private
+     * @param {string[]} data.categories
+     *        The categories of all the fields contained in the selected address.
+     */
+      this._updateWarningNote = ({data} = {}) => {
+        let categories = (data && data.categories) ? data.categories : this._allFieldCategories;
+      // If the length of categories is 1, that means all the fillable fields are in the same
+      // category. We will change the way to inform user according to this flag. When the value
+      // is true, we show "Also autofills ...", otherwise, show "Autofills ..." only.
+        let hasExtraCategories = categories.length > 1;
+      // Show the categories in certain order to conform with the spec.
+        let orderedCategoryList = [{id: "address", l10nId: "category.address"},
+        {id: "name", l10nId: "category.name"},
+        {id: "organization", l10nId: "category.organization2"},
+        {id: "tel", l10nId: "category.tel"},
+        {id: "email", l10nId: "category.email"},
+        ];
+        let showCategories = hasExtraCategories ?
+            orderedCategoryList.filter(category => categories.includes(category.id) && category.id != this._focusedCategory) :
+            [orderedCategoryList.find(category => category.id == this._focusedCategory)];
+
+        let separator = this._stringBundle.GetStringFromName("fieldNameSeparator");
+        let warningTextTmplKey = hasExtraCategories ? "phishingWarningMessage" : "phishingWarningMessage2";
+        let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(category.l10nId)).join(separator);
+
+        this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey, [categoriesText], 1);
+        this.parentNode.parentNode.adjustHeight();
+      };
+
+      this._adjustAcItem();
+    }
+
+    _onCollapse() {
+    /* global messageManager */
+
+      if (this.showWarningText) {
+        messageManager.removeMessageListener(
+        "FormAutofill:UpdateWarningMessage", this._updateWarningNote
+      );
+      }
+
+      this._itemBox.removeAttribute("no-warning");
+    }
+
+    _adjustAcItem() {
+    /* global Cu */
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
+
+      let {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm", {});
+    // TODO: The "Short" suffix is pointless now as normal version string is no longer needed,
+    // we should consider removing the suffix if possible when the next time locale change.
+      let buttonTextBundleKey = AppConstants.platform == "macosx" ?
+      "autocompleteFooterOptionOSXShort" : "autocompleteFooterOptionShort";
+      let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);
+      this._optionButton.textContent = buttonText;
+
+      let value = JSON.parse(this.getAttribute("ac-value"));
+
+      this._allFieldCategories = value.categories;
+      this._focusedCategory = value.focusedCategory;
+      this.showWarningText = this._allFieldCategories && this._focusedCategory;
+
+      if (this.showWarningText) {
+        messageManager.addMessageListener("FormAutofill:UpdateWarningMessage", this._updateWarningNote);
+
+        this._updateWarningNote();
+      } else {
+        this._itemBox.setAttribute("no-warning", "true");
+      }
+    }
+}
+
+  customElements.define(
+  "autocomplete-profile-listitem-footer",
+  MozAutocompleteProfileListitemFooter,
+  {extends: "richlistitem"}
+);
+
+  class MozAutocompleteCreditcardInsecureField extends MozAutocompleteProfileListitemBase {
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+      <div class="autofill-insecure-item"></div>
+    `));
+
+      this._itemBox = this.querySelector(".autofill-insecure-item");
+
+      this._adjustAcItem();
+    }
+
+    set selected(val) {
+    // Make this item unselectable since we see this item as a pure message.
+      return false;
+    }
+
+    get selected() {
+      return this.getAttribute("selected") == "true";
+    }
+
+    _adjustAcItem() {
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
+
+      let value = this.getAttribute("ac-value");
+      this._itemBox.textContent = value;
+    }
+}
+
+  customElements.define(
+  "autocomplete-creditcard-insecure-field",
+  MozAutocompleteCreditcardInsecureField,
+  {extends: "richlistitem"}
+);
+
+  class MozAutocompleteProfileListitemClearButton extends MozAutocompleteProfileListitemBase {
+    constructor() {
+      super();
+
+      this.addEventListener("click", (event) => {
+        if (event.button != 0) {
+          return;
+        }
+
+        let {AutoCompletePopup} =
+        ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
+        AutoCompletePopup.sendMessageToBrowser("FormAutofill:ClearForm");
+      });
+    }
+
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+      <div class="autofill-item-box autofill-footer">
+        <div class="autofill-footer-row autofill-button"></div>
+      </div>
+    `));
+
+      this._itemBox = this.querySelector(".autofill-item-box");
+      this._clearBtn = this.querySelector(".autofill-button");
+
+      this._adjustAcItem();
+    }
+
+    _adjustAcItem() {
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
+
+      let clearFormBtnLabel =
+      this._stringBundle.GetStringFromName("clearFormBtnLabel2");
+      this._clearBtn.textContent = clearFormBtnLabel;
+    }
+}
+
+  customElements.define(
+  "autocomplete-profile-listitem-clear-button",
+  MozAutocompleteProfileListitemClearButton,
+  {extends: "richlistitem"}
+);
+
+  console.log("formautofill no problems found");
+})();
diff --git a/browser/extensions/formautofill/content/formautofill.xml b/browser/extensions/formautofill/content/formautofill.xml
deleted file mode 100644
--- a/browser/extensions/formautofill/content/formautofill.xml
+++ /dev/null
@@ -1,354 +0,0 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<bindings id="formautofillBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:html="http://www.w3.org/1999/xhtml"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:xbl="http://www.mozilla.org/xbl">
-
-  <binding id="autocomplete-profile-listitem-base" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-      </constructor>
-      <!-- For form autofill, we want to unify the selection no matter by
-      keyboard navigation or mouseover in order not to confuse user which
-      profile preview is being shown. This field is set to true to indicate
-      that selectedIndex of popup should be changed while mouseover item -->
-      <field name="selectedByMouseOver">true</field>
-
-      <property name="_stringBundle">
-        <getter><![CDATA[
-          /* global Services */
-          if (!this.__stringBundle) {
-            this.__stringBundle = Services.strings.createBundle("chrome://formautofill/locale/formautofill.properties");
-          }
-          return this.__stringBundle;
-        ]]></getter>
-      </property>
-
-      <method name="_cleanup">
-        <body>
-        <![CDATA[
-          this.removeAttribute("formautofillattached");
-          if (this._itemBox) {
-            this._itemBox.removeAttribute("size");
-          }
-        ]]>
-        </body>
-      </method>
-
-      <method name="_onOverflow">
-        <body></body>
-      </method>
-
-      <method name="_onUnderflow">
-        <body></body>
-      </method>
-
-      <method name="handleOverUnderflow">
-        <body></body>
-      </method>
-
-      <method name="_adjustAutofillItemLayout">
-        <body>
-        <![CDATA[
-          let outerBoxRect = this.parentNode.getBoundingClientRect();
-
-          // Make item fit in popup as XUL box could not constrain
-          // item's width
-          this._itemBox.style.width = outerBoxRect.width + "px";
-          // Use two-lines layout when width is smaller than 150px or
-          // 185px if an image precedes the label.
-          let oneLineMinRequiredWidth = this.getAttribute("ac-image") ? 185 : 150;
-
-          if (outerBoxRect.width <= oneLineMinRequiredWidth) {
-            this._itemBox.setAttribute("size", "small");
-          } else {
-            this._itemBox.removeAttribute("size");
-          }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-  </binding>
-
-  <binding id="autocomplete-profile-listitem" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-item-box" class="autofill-item-box" xbl:inherits="ac-image">
-        <div class="profile-label-col profile-item-col">
-          <span anonid="profile-label-affix" class="profile-label-affix"></span>
-          <span anonid="profile-label" class="profile-label"></span>
-        </div>
-        <div class="profile-comment-col profile-item-col">
-          <span anonid="profile-comment" class="profile-comment"></span>
-        </div>
-      </div>
-    </xbl:content>
-
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-        <![CDATA[
-          this._itemBox = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-item-box"
-          );
-          this._labelAffix = document.getAnonymousElementByAttribute(
-            this, "anonid", "profile-label-affix"
-          );
-          this._label = document.getAnonymousElementByAttribute(
-            this, "anonid", "profile-label"
-          );
-          this._comment = document.getAnonymousElementByAttribute(
-            this, "anonid", "profile-comment"
-          );
-
-          this._adjustAcItem();
-        ]]>
-      </constructor>
-
-      <property name="selected" onget="return this.getAttribute('selected') == 'true';">
-        <setter><![CDATA[
-          /* global Cu */
-          if (val) {
-            this.setAttribute("selected", "true");
-          } else {
-            this.removeAttribute("selected");
-          }
-
-          let {AutoCompletePopup} = ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
-
-          AutoCompletePopup.sendMessageToBrowser("FormAutofill:PreviewProfile");
-
-          return val;
-        ]]></setter>
-      </property>
-
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
-          this._itemBox.style.setProperty("--primary-icon", `url(${this.getAttribute("ac-image")})`);
-
-          let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute("ac-value"));
-
-          this._labelAffix.textContent = primaryAffix;
-          this._label.textContent = primary;
-          this._comment.textContent = secondary;
-        ]]>
-        </body>
-      </method>
-    </implementation>
-  </binding>
-
-  <binding id="autocomplete-profile-listitem-footer" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-footer" class="autofill-item-box autofill-footer">
-        <div anonid="autofill-warning" class="autofill-footer-row autofill-warning">
-        </div>
-        <div anonid="autofill-option-button" class="autofill-footer-row autofill-button">
-        </div>
-      </div>
-    </xbl:content>
-
-    <handlers>
-      <handler event="click" button="0"><![CDATA[
-        if (this._warningTextBox.contains(event.originalTarget)) {
-          return;
-        }
-
-        window.openPreferences("privacy-form-autofill", {origin: "autofillFooter"});
-      ]]></handler>
-    </handlers>
-
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-        <![CDATA[
-          this._itemBox = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-footer"
-          );
-          this._optionButton = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-option-button"
-          );
-          this._warningTextBox = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-warning"
-          );
-
-          /**
-           * A handler for updating warning message once selectedIndex has been changed.
-           *
-           * There're three different states of warning message:
-           * 1. None of addresses were selected: We show all the categories intersection of fields in the
-           *    form and fields in the results.
-           * 2. An address was selested: Show the additional categories that will also be filled.
-           * 3. An address was selected, but the focused category is the same as the only one category: Only show
-           * the exact category that we're going to fill in.
-           *
-           * @private
-           * @param {string[]} data.categories
-           *        The categories of all the fields contained in the selected address.
-           */
-          this._updateWarningNote = ({data} = {}) => {
-            let categories = (data && data.categories) ? data.categories : this._allFieldCategories;
-            // If the length of categories is 1, that means all the fillable fields are in the same
-            // category. We will change the way to inform user according to this flag. When the value
-            // is true, we show "Also autofills ...", otherwise, show "Autofills ..." only.
-            let hasExtraCategories = categories.length > 1;
-            // Show the categories in certain order to conform with the spec.
-            let orderedCategoryList = [{id: "address", l10nId: "category.address"},
-                                       {id: "name", l10nId: "category.name"},
-                                       {id: "organization", l10nId: "category.organization2"},
-                                       {id: "tel", l10nId: "category.tel"},
-                                       {id: "email", l10nId: "category.email"}];
-            let showCategories = hasExtraCategories ?
-              orderedCategoryList.filter(category => categories.includes(category.id) && category.id != this._focusedCategory) :
-              [orderedCategoryList.find(category => category.id == this._focusedCategory)];
-
-            let separator = this._stringBundle.GetStringFromName("fieldNameSeparator");
-            let warningTextTmplKey = hasExtraCategories ? "phishingWarningMessage" : "phishingWarningMessage2";
-            let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(category.l10nId)).join(separator);
-
-            this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey,
-              [categoriesText], 1);
-            this.parentNode.parentNode.adjustHeight();
-          };
-
-          this._adjustAcItem();
-        ]]>
-      </constructor>
-
-      <method name="_onCollapse">
-        <body>
-        <![CDATA[
-          /* global messageManager */
-
-          if (this.showWarningText) {
-            messageManager.removeMessageListener("FormAutofill:UpdateWarningMessage", this._updateWarningNote);
-          }
-
-          this._itemBox.removeAttribute("no-warning");
-        ]]>
-        </body>
-      </method>
-
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          /* global Cu */
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
-
-          let {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
-          // TODO: The "Short" suffix is pointless now as normal version string is no longer needed,
-          // we should consider removing the suffix if possible when the next time locale change.
-          let buttonTextBundleKey = AppConstants.platform == "macosx" ?
-            "autocompleteFooterOptionOSXShort" : "autocompleteFooterOptionShort";
-          let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);
-          this._optionButton.textContent = buttonText;
-
-          let value = JSON.parse(this.getAttribute("ac-value"));
-
-          this._allFieldCategories = value.categories;
-          this._focusedCategory = value.focusedCategory;
-          this.showWarningText = this._allFieldCategories && this._focusedCategory;
-
-          if (this.showWarningText) {
-            messageManager.addMessageListener("FormAutofill:UpdateWarningMessage", this._updateWarningNote);
-
-            this._updateWarningNote();
-          } else {
-            this._itemBox.setAttribute("no-warning", "true");
-          }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-  </binding>
-
-  <binding id="autocomplete-creditcard-insecure-field" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-item-box" class="autofill-insecure-item">
-      </div>
-    </xbl:content>
-
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-      <![CDATA[
-        this._itemBox = document.getAnonymousElementByAttribute(
-          this, "anonid", "autofill-item-box"
-        );
-
-        this._adjustAcItem();
-      ]]>
-      </constructor>
-
-      <property name="selected" onget="return this.getAttribute('selected') == 'true';">
-        <setter><![CDATA[
-          // Make this item unselectable since we see this item as a pure message.
-          return false;
-        ]]></setter>
-      </property>
-
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
-
-          let value = this.getAttribute("ac-value");
-          this._itemBox.textContent = value;
-        ]]>
-        </body>
-      </method>
-
-    </implementation>
-  </binding>
-
-  <binding id="autocomplete-profile-listitem-clear-button" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-item-box" class="autofill-item-box autofill-footer">
-        <div anonid="autofill-clear-button" class="autofill-footer-row autofill-button"></div>
-      </div>
-    </xbl:content>
-
-    <handlers>
-      <handler event="click" button="0"><![CDATA[
-        /* global Cu */
-        let {AutoCompletePopup} = ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
-
-        AutoCompletePopup.sendMessageToBrowser("FormAutofill:ClearForm");
-      ]]></handler>
-    </handlers>
-
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-      <![CDATA[
-        this._itemBox = document.getAnonymousElementByAttribute(
-          this, "anonid", "autofill-item-box"
-        );
-        this._clearBtn = document.getAnonymousElementByAttribute(
-          this, "anonid", "autofill-clear-button"
-        );
-
-        this._adjustAcItem();
-      ]]>
-      </constructor>
-
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
-
-          let clearFormBtnLabel = this._stringBundle.GetStringFromName("clearFormBtnLabel2");
-          this._clearBtn.textContent = clearFormBtnLabel;
-        ]]>
-        </body>
-      </method>
-
-    </implementation>
-  </binding>
-
-</bindings>
diff --git a/browser/extensions/formautofill/skin/shared/autocomplete-item-shared.css b/browser/extensions/formautofill/skin/shared/autocomplete-item-shared.css
--- a/browser/extensions/formautofill/skin/shared/autocomplete-item-shared.css
+++ b/browser/extensions/formautofill/skin/shared/autocomplete-item-shared.css
@@ -1,16 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 @namespace url("http://www.w3.org/1999/xhtml");
 @namespace xul url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 
 
+xul|richlistitem {
+  background-color: red;
+}
 xul|richlistitem[originaltype="autofill-profile"][selected="true"] > .autofill-item-box {
   background-color: #F2F2F2;
 }
 
 xul|richlistitem[originaltype="autofill-footer"][selected="true"] > .autofill-item-box > .autofill-button,
 xul|richlistitem[originaltype="autofill-clear-button"][selected="true"] > .autofill-item-box > .autofill-button {
   background-color: #DCDCDE;
 }
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -1051,27 +1051,34 @@
                 !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
             }
 
             // If no reusable item available, then create a new item.
             if (!reusable) {
               let options = null;
               switch (style) {
                 case "autofill-profile":
+                  options = { is: "autocomplete-profile-listitem" };
+                  break;
                 case "autofill-footer":
+                  options = { is: "autocomplete-profile-listitem-footer" };
+                  break;
                 case "autofill-clear-button":
+                  options = { is: "autocomplete-profile-listitem-clear-button" };
+                  break;
                 case "autofill-insecureWarning":
-                  // implemented via XBL bindings, no CE for them
+                  options = { is: "autocomplete-creditcard-insecure-field" };
                   break;
                 case "insecureWarning":
                   options = { is: "autocomplete-richlistitem-insecure-warning" };
                   break;
                 default:
                   options = { is: "autocomplete-richlistitem" };
               }
+              console.log(`options to create: ${options.is}`);
               item = document.createXULElement("richlistitem", options);
               item.className = "autocomplete-richlistitem";
             }
 
             item.setAttribute("dir", this.style.direction);
             item.setAttribute("ac-image", image);
             item.setAttribute("ac-value", value);
             item.setAttribute("ac-label", label);
