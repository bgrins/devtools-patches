# HG changeset patch
# Parent 99966b150ebb9d8aee5bc228cd314ab4343d5c75
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1088861 - Add evaluateJSAsync method on the web console actor;r=past

diff --git a/browser/devtools/scratchpad/scratchpad.js b/browser/devtools/scratchpad/scratchpad.js
--- a/browser/devtools/scratchpad/scratchpad.js
+++ b/browser/devtools/scratchpad/scratchpad.js
@@ -463,17 +463,17 @@ var Scratchpad = {
       connection = ScratchpadWindow.consoleFor(this.browserWindow);
     }
 
     let evalOptions = { url: this.uniqueName };
 
     return connection.then(({ debuggerClient, webConsoleClient }) => {
       let deferred = promise.defer();
 
-      webConsoleClient.evaluateJS(aString, aResponse => {
+      webConsoleClient.evaluateJSAsync(aString, aResponse => {
         this.debuggerClient = debuggerClient;
         this.webConsoleClient = webConsoleClient;
         if (aResponse.error) {
           deferred.reject(aResponse);
         }
         else if (aResponse.exception !== null) {
           deferred.resolve([aString, aResponse]);
         }
diff --git a/browser/devtools/webconsole/test/browser.ini b/browser/devtools/webconsole/test/browser.ini
--- a/browser/devtools/webconsole/test/browser.ini
+++ b/browser/devtools/webconsole/test/browser.ini
@@ -166,16 +166,17 @@ skip-if = e10s # Bug 1042253 - webconsol
 [browser_console_variables_view_dont_sort_non_sortable_classes_properties.js]
 skip-if = buildapp == 'mulet'
 [browser_console_variables_view_while_debugging.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_variables_view_while_debugging_and_inspecting.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_eval_in_debugger_stackframe.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
+[browser_eval_in_debugger_stackframe2.js]
 [browser_jsterm_inspect.js]
 [browser_longstring_hang.js]
 [browser_netpanel_longstring_expand.js]
 skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_output_breaks_after_console_dir_uninspectable.js]
 [browser_output_longstring_expand.js]
 [browser_repeated_messages_accuracy.js]
 skip-if = buildapp == 'mulet'
diff --git a/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe2.js b/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe2.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe2.js
@@ -0,0 +1,63 @@
+/*
+ * Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+// Test to make sure that web console commands can fire while paused at a breakpoint
+// that was triggered from a JS call.  Relies on asynchronous js evaluation over the
+// protocol - see Bug 1088861.
+
+"use strict";
+
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-eval-in-stackframe.html";
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+
+  info("open the web console");
+  let hud = yield openConsole();
+  let {jsterm} = hud;
+
+  info("open the debugger");
+  let {panel,panelWin} = yield openDebugger();
+  let {DebuggerController} = panelWin;
+  let {activeThread,StackFrames} = DebuggerController;
+
+  let firstCall = promise.defer();
+  let frameAdded = promise.defer();
+  executeSoon(() => {
+    info ("Executing firstCall");
+    activeThread.addOneTimeListener("framesadded", () => {
+      executeSoon(frameAdded.resolve);
+    });
+    jsterm.execute("firstCall()").then(firstCall.resolve);
+  });
+
+  info ("Waiting for a frame to be added");
+  yield frameAdded.promise;
+
+  info ("Executing basic command while paused");
+  yield executeAndConfirm(jsterm, "1 + 2", "3");
+
+  info ("Executing command using scoped variables while paused");
+  yield executeAndConfirm(jsterm, "foo + foo2", '"globalFooBug783499foo2SecondCall"');
+
+  info ("Resuming the thread");
+  activeThread.resume();
+
+  info ("Checking the first command (which is the last to resolve since it paused");
+  let node = yield firstCall.promise;
+  is (node.querySelector(".message-body").textContent,
+      "undefined",
+      "firstCall() returned correct value");
+});
+
+function* executeAndConfirm(jsterm, input, output) {
+  info ("Executing command `"+input+"`");
+
+  let node = yield jsterm.execute(input);
+
+  is (node.querySelector(".message-body").textContent,
+      output,
+      "Expected result from call to " + input);
+}
+
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -3412,17 +3412,17 @@ JSTerm.prototype = {
     }
 
     let evalOptions = {
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: frameActor,
       selectedNodeActor: aOptions.selectedNodeActor,
     };
 
-    this.webConsoleClient.evaluateJS(aString, onResult, evalOptions);
+    this.webConsoleClient.evaluateJSAsync(aString, onResult, evalOptions);
     return deferred.promise;
   },
 
   /**
    * Retrieve the FrameActor ID given a frame depth.
    *
    * @param number aFrame
    *        Frame depth.
diff --git a/toolkit/devtools/client/dbg-client.jsm b/toolkit/devtools/client/dbg-client.jsm
--- a/toolkit/devtools/client/dbg-client.jsm
+++ b/toolkit/devtools/client/dbg-client.jsm
@@ -229,17 +229,18 @@ const UnsolicitedNotifications = {
   "frameUpdate": "frameUpdate",
   "pageError": "pageError",
   "documentLoad": "documentLoad",
   "enteredFrame": "enteredFrame",
   "exitedFrame": "exitedFrame",
   "appOpen": "appOpen",
   "appClose": "appClose",
   "appInstall": "appInstall",
-  "appUninstall": "appUninstall"
+  "appUninstall": "appUninstall",
+  "evaluationResult": "evaluationResult",
 };
 
 /**
  * Set of pause types that are sent by the server and not as an immediate
  * response to a client request.
  */
 const UnsolicitedPauses = {
   "resumeLimit": "resumeLimit",
diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -724,16 +724,49 @@ WebConsoleActor.prototype =
 
     return {
       from: this.actorID,
       messages: messages,
     };
   },
 
   /**
+   * Handler for the "evaluateJSAsync" request. This method evaluates the given
+   * JavaScript string and sends back a packet with a unique ID.
+   * The result will be returned later as an unsolicited `evaluationResult`,
+   * that can be associated back to this request via the `resultID` field.
+   *
+   * @param object aRequest
+   *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The response packet to send to with the unique id in the
+   *         `resultID` field.
+   */
+  onEvaluateJSAsync: function WCA_onEvaluateJSAsync(aRequest)
+  {
+    // We want to be able to run console commands without waiting
+    // for the first to return (see Bug 1088861).
+
+    // First, send a response packet with the id only.
+    let resultID = Date.now();
+    this.conn.send({
+      from: this.actorID,
+      resultID: resultID
+    });
+
+    // Then, execute the script that may pause.
+    let response = this.onEvaluateJS(aRequest);
+    response.resultID = resultID;
+
+    // Finally, send an unsolicited evaluationResult packet with
+    // the normal return value
+    this.conn.sendActorEvent(this.actorID, "evaluationResult", response);
+  },
+
+  /**
    * Handler for the "evaluateJS" request. This method evaluates the given
    * JavaScript string and sends back the result.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The evaluation response packet.
    */
@@ -1466,16 +1499,17 @@ WebConsoleActor.prototype =
 };
 
 WebConsoleActor.prototype.requestTypes =
 {
   startListeners: WebConsoleActor.prototype.onStartListeners,
   stopListeners: WebConsoleActor.prototype.onStopListeners,
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   evaluateJS: WebConsoleActor.prototype.onEvaluateJS,
+  evaluateJSAsync: WebConsoleActor.prototype.onEvaluateJSAsync,
   autocomplete: WebConsoleActor.prototype.onAutocomplete,
   clearMessagesCache: WebConsoleActor.prototype.onClearMessagesCache,
   getPreferences: WebConsoleActor.prototype.onGetPreferences,
   setPreferences: WebConsoleActor.prototype.onSetPreferences,
   sendHTTPRequest: WebConsoleActor.prototype.onSendHTTPRequest
 };
 
 exports.WebConsoleActor = WebConsoleActor;
diff --git a/toolkit/devtools/webconsole/client.js b/toolkit/devtools/webconsole/client.js
--- a/toolkit/devtools/webconsole/client.js
+++ b/toolkit/devtools/webconsole/client.js
@@ -2,16 +2,17 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {Cc, Ci, Cu} = require("chrome");
+const DevToolsUtils = require("devtools/toolkit/DevToolsUtils");
 
 loader.lazyImporter(this, "LongStringClient", "resource://gre/modules/devtools/dbg-client.jsm");
 
 /**
  * A WebConsoleClient is used as a front end for the WebConsoleActor that is
  * created on the server, hiding implementation details.
  *
  * @param object aDebuggerClient
@@ -22,17 +23,23 @@ loader.lazyImporter(this, "LongStringCli
  */
 function WebConsoleClient(aDebuggerClient, aResponse)
 {
   this._actor = aResponse.from;
   this._client = aDebuggerClient;
   this._longStrings = {};
   this.traits = aResponse.traits || {};
   this.events = [];
+
+  this.pendingEvaluationResults = new Map();
+  this.onEvaluationResult = this.onEvaluationResult.bind(this);
+
+  this._client.addListener("evaluationResult", this.onEvaluationResult);
 }
+
 exports.WebConsoleClient = WebConsoleClient;
 
 WebConsoleClient.prototype = {
   _longStrings: null,
   traits: null,
 
   get actor() { return this._actor; },
 
@@ -120,16 +127,54 @@ WebConsoleClient.prototype = {
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
+   * Evaluate a JavaScript expression asynchronously.
+   * See evaluateJS for parameter and response information.
+   */
+  evaluateJSAsync: function(aString, aOnResponse, aOptions = {})
+  {
+    let packet = {
+      to: this._actor,
+      type: "evaluateJSAsync",
+      text: aString,
+      bindObjectActor: aOptions.bindObjectActor,
+      frameActor: aOptions.frameActor,
+      url: aOptions.url,
+      selectedNodeActor: aOptions.selectedNodeActor,
+    };
+
+    this._client.request(packet, response => {
+      this.pendingEvaluationResults.set(response.resultID, aOnResponse);
+    });
+  },
+
+  /**
+   * Handler for the actors's unsolicited evaluationResult packet.
+   */
+  onEvaluationResult: function(aNotification, aPacket) {
+    // Find the associated callback based on this ID, and fire it.
+    // In a sync evaluation, this would have already been called in
+    // direct response to the client.request function.
+    let onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
+    if (onResponse) {
+      onResponse(aPacket);
+      this.pendingEvaluationResults.delete(aPacket.resultID);
+    } else {
+      DevToolsUtils.reportException("onEvaluationResult",
+        "No response handler for an evaluateJSAsync result (resultID: " + aPacket.resultID + ")");
+    }
+  },
+
+  /**
    * Autocomplete a JavaScript expression.
    *
    * @param string aString
    *        The code you want to autocomplete.
    * @param number aCursor
    *        Cursor location inside the string. Index starts from 0.
    * @param function aOnResponse
    *        The function invoked when the response is received.
@@ -395,13 +440,16 @@ WebConsoleClient.prototype = {
    * Close the WebConsoleClient. This stops all the listeners on the server and
    * detaches from the console actor.
    *
    * @param function aOnResponse
    *        Function to invoke when the server response is received.
    */
   detach: function WCC_detach(aOnResponse)
   {
+    this._client.removeListener("evaluationResult", this.onEvaluationResult);
     this.stopListeners(null, aOnResponse);
     this._longStrings = null;
     this._client = null;
+    this.pendingEvaluationResults.clear();
+    this.pendingEvaluationResults = null;
   },
 };
diff --git a/toolkit/devtools/webconsole/test/test_jsterm.html b/toolkit/devtools/webconsole/test/test_jsterm.html
--- a/toolkit/devtools/webconsole/test/test_jsterm.html
+++ b/toolkit/devtools/webconsole/test/test_jsterm.html
@@ -14,16 +14,27 @@
 <script class="testbody" type="text/javascript;version=1.8">
 SimpleTest.waitForExplicitFinish();
 
 let gState;
 
 let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 let {MAX_AUTOCOMPLETE_ATTEMPTS,MAX_AUTOCOMPLETIONS} = devtools.require("devtools/toolkit/webconsole/utils");
 
+// This test runs all of its assertions twice - once with
+// evaluateJS and once with evaluateJSAsync.
+let evaluatingSync = true;
+function evaluateJS(input, callback) {
+  if (evaluatingSync) {
+    gState.client.evaluateJS(input, callback);
+  } else {
+    gState.client.evaluateJSAsync(input, callback);
+  }
+}
+
 function startTest()
 {
   removeEventListener("load", startTest);
 
   attachConsole(["PageError"], onAttach, true);
 }
 
 function onAttach(aState, aResponse)
@@ -157,17 +168,17 @@ function onAutocompleteLarge2(aResponse)
   is(aResponse.matches.length, MAX_AUTOCOMPLETIONS, "matches.length is MAX_AUTOCOMPLETIONS");
 
   nextTest();
 }
 
 function doSimpleEval()
 {
   info("test eval '2+2'");
-  gState.client.evaluateJS("2+2", onSimpleEval);
+  evaluateJS("2+2", onSimpleEval);
 }
 
 function onSimpleEval(aResponse)
 {
   checkObject(aResponse, {
     from: gState.actor,
     input: "2+2",
     result: 4,
@@ -177,17 +188,17 @@ function onSimpleEval(aResponse)
   ok(!aResponse.helperResult, "no helper result");
 
   nextTest();
 }
 
 function doWindowEval()
 {
   info("test eval 'document'");
-  gState.client.evaluateJS("document", onWindowEval);
+  evaluateJS("document", onWindowEval);
 }
 
 function onWindowEval(aResponse)
 {
   checkObject(aResponse, {
     from: gState.actor,
     input: "document",
     result: {
@@ -201,17 +212,17 @@ function onWindowEval(aResponse)
   ok(!aResponse.helperResult, "no helper result");
 
   nextTest();
 }
 
 function doEvalWithException()
 {
   info("test eval with exception");
-  gState.client.evaluateJS("window.doTheImpossible()", onEvalWithException);
+  evaluateJS("window.doTheImpossible()", onEvalWithException);
 }
 
 function onEvalWithException(aResponse)
 {
   checkObject(aResponse, {
     from: gState.actor,
     input: "window.doTheImpossible()",
     result: {
@@ -224,17 +235,17 @@ function onEvalWithException(aResponse)
   ok(!aResponse.helperResult, "no helper result");
 
   nextTest();
 }
 
 function doEvalWithHelper()
 {
   info("test eval with helper");
-  gState.client.evaluateJS("clear()", onEvalWithHelper);
+  evaluateJS("clear()", onEvalWithHelper);
 }
 
 function onEvalWithHelper(aResponse)
 {
   checkObject(aResponse, {
     from: gState.actor,
     input: "clear()",
     result: {
@@ -245,33 +256,33 @@ function onEvalWithHelper(aResponse)
 
   ok(!aResponse.exception, "no eval exception");
 
   nextTest();
 }
 
 function doEvalString()
 {
-  gState.client.evaluateJS("window.foobarObject.strfoo", onEvalString);
+  evaluateJS("window.foobarObject.strfoo", onEvalString);
 }
 
 function onEvalString(aResponse)
 {
   checkObject(aResponse, {
     from: gState.actor,
     input: "window.foobarObject.strfoo",
     result: "foobarz",
   });
 
   nextTest();
 }
 
 function doEvalLongString()
 {
-  gState.client.evaluateJS("window.foobarObject.omgstr", onEvalLongString);
+  evaluateJS("window.foobarObject.omgstr", onEvalLongString);
 }
 
 function onEvalLongString(aResponse)
 {
   let str = top.foobarObject.omgstr;
   let initial = str.substring(0, DebuggerServer.LONG_STRING_INITIAL_LENGTH);
 
   checkObject(aResponse, {
@@ -284,18 +295,25 @@ function onEvalLongString(aResponse)
     },
   });
 
   nextTest();
 }
 
 function testEnd()
 {
+  // If this is the first run, reload the page and do it again.
+  // Otherwise, end the test.
   closeDebugger(gState, function() {
     gState = null;
-    SimpleTest.finish();
+    if (evaluatingSync) {
+      evaluatingSync = false;
+      startTest();
+    } else {
+      SimpleTest.finish();
+    }
   });
 }
 
 addEventListener("load", startTest);
 </script>
 </body>
 </html>
