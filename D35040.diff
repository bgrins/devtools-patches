diff --git a/browser/base/content/test/performance/browser_appmenu.js b/browser/base/content/test/performance/browser_appmenu.js
--- a/browser/base/content/test/performance/browser_appmenu.js
+++ b/browser/base/content/test/performance/browser_appmenu.js
@@ -25,8 +25,8 @@
 
   {
     stack: [
-      "adjustArrowPosition@chrome://global/content/bindings/popup.xml",
-      "onxblpopuppositioned@chrome://global/content/bindings/popup.xml",
+      "adjustArrowPosition@chrome://global/content/elements/panel.js",
+      "on_popuppositioned@chrome://global/content/elements/panel.js",
     ],
 
     maxCount: 22, // This number should only ever go down - never up.
diff --git a/browser/base/content/test/sync/browser_sync.js b/browser/base/content/test/sync/browser_sync.js
--- a/browser/base/content/test/sync/browser_sync.js
+++ b/browser/base/content/test/sync/browser_sync.js
@@ -388,6 +388,9 @@
 
 // fxaStatus is one of 'not_configured', 'unverified', 'login-failed', or 'signedin'.
 function checkFxAAvatar(fxaStatus) {
+  // Unhide the panel so computed styles can be read
+  document.querySelector("#appMenu-popup").hidden = false;
+
   const avatarContainers = [
     document.getElementById("fxa-menu-avatar"),
     document.getElementById("fxa-avatar-image"),
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_background.js b/browser/components/extensions/test/browser/browser_ext_popup_background.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_background.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_background.js
@@ -5,12 +5,8 @@
 
 async function testPanel(browser, standAlone, initial_background) {
   let panel = getPanelForNode(browser);
-  let arrowContent = document.getAnonymousElementByAttribute(
-    panel,
-    "class",
-    "panel-arrowcontent"
-  );
-  let arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
+  let arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   let checkArrow = (background = null) => {
     if (background == null || !standAlone) {
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_corners.js b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_corners.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
@@ -35,13 +35,14 @@
 
   async function testPanel(browser, standAlone = true) {
     let panel = getPanelForNode(browser);
-    let arrowContent = document.getAnonymousElementByAttribute(
-      panel,
-      "class",
-      "panel-arrowcontent"
-    );
+    let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
 
     let panelStyle = getComputedStyle(arrowContent);
+    is(
+      panelStyle.overflow,
+      "hidden",
+      "overflow is not hidden, thus it doesn't clip"
+    );
 
     let stack = browser.parentNode;
     let viewNode = stack.parentNode === panel ? browser : stack.parentNode;
diff --git a/browser/components/places/content/places-menupopup.js b/browser/components/places/content/places-menupopup.js
--- a/browser/components/places/content/places-menupopup.js
+++ b/browser/components/places/content/places-menupopup.js
@@ -584,27 +584,25 @@
 
     static get inheritedAttributes() {
       return {
-        ".panel-arrowcontainer": "side,panelopen",
-        ".panel-arrow": "side",
-        ".panel-arrowcontent": "side,align,dir,orient,pack",
+        ".panel-arrowcontent": "align,dir,orient,pack",
       };
     }
 
     get markup() {
       return `
-      <html:link rel="stylesheet" href="chrome://global/skin/global.css" />
+      <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
       <vbox class="panel-arrowcontainer" flex="1">
-        <box class="panel-arrowbox">
-          <image class="panel-arrow"></image>
+        <box class="panel-arrowbox" part="arrowbox">
+          <image class="panel-arrow" part="arrow"/>
         </box>
         <box class="panel-arrowcontent" part="arrowcontent" flex="1">
           <vbox part="drop-indicator-bar" hidden="true">
-            <image part="drop-indicator" mousethrough="always"></image>
+            <image part="drop-indicator" mousethrough="always"/>
           </vbox>
           <arrowscrollbox class="popup-internal-box" flex="1"
                           orient="vertical" smoothscroll="false"
                           part="popupbox">
-            <html:slot></html:slot>
+            <html:slot/>
           </arrowscrollbox>
         </box>
       </vbox>
diff --git a/browser/themes/linux/customizableui/panelUI.css b/browser/themes/linux/customizableui/panelUI.css
--- a/browser/themes/linux/customizableui/panelUI.css
+++ b/browser/themes/linux/customizableui/panelUI.css
@@ -27,7 +27,6 @@
  * overflow:hidden wasn't applied. Disabling the box-shadow for this panel on
  * Linux works around this issue. This bug is on file as 1394575.
  */
-#pageActionFeedback > .panel-arrowcontainer > .panel-arrowcontent {
+#pageActionFeedback::part(arrowcontent) {
   box-shadow: none;
 }
-
diff --git a/browser/themes/shared/controlcenter/panel.inc.css b/browser/themes/shared/controlcenter/panel.inc.css
--- a/browser/themes/shared/controlcenter/panel.inc.css
+++ b/browser/themes/shared/controlcenter/panel.inc.css
@@ -248,17 +248,17 @@
   padding: var(--vertical-section-padding) var(--horizontal-padding);
 }
 
-#protections-popup > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+#protections-popup::part(arrow) {
   transition-property: fill;
   transition-timing-function: var(--animation-easing-function);
   transition-duration: var(--panelui-subview-transition-duration);
 }
 
-#protections-popup[mainviewshowing] > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow[side=top] {
+#protections-popup[mainviewshowing][side=top]::part(arrow) {
   fill: #0A51BF;
 }
 
-:root[lwt-popup-brighttext] #protections-popup[mainviewshowing] > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow[side=top] {
+:root[lwt-popup-brighttext] #protections-popup[mainviewshowing][side=top]::part(arrow) {
   fill: #0CB0F5;
 }
 
diff --git a/browser/themes/shared/customizableui/panelUI.inc.css b/browser/themes/shared/customizableui/panelUI.inc.css
--- a/browser/themes/shared/customizableui/panelUI.inc.css
+++ b/browser/themes/shared/customizableui/panelUI.inc.css
@@ -255,11 +255,11 @@
   font-size: 1.1rem;
 }
 
-#confirmation-hint > .panel-arrowcontainer > .panel-arrowcontent {
+#confirmation-hint::part(arrowcontent) {
   -moz-box-align: center;
 }
 
-#confirmation-hint[hidearrow] > .panel-arrowcontainer > .panel-arrowbox {
+#confirmation-hint[hidearrow]::part(arrowbox) {
   /* Don't display the arrow but keep the popup at the same vertical
      offset as other arrow panels. */
   visibility: hidden;
@@ -372,8 +372,7 @@
   min-width: calc(@menuPanelWidth@ + 32px);
 }
 
-.cui-widget-panel.cui-widget-panelWithFooter::part(arrowcontent),
-.cui-widget-panel.cui-widget-panelWithFooter > .panel-arrowcontainer > .panel-arrowcontent {
+.cui-widget-panel.cui-widget-panelWithFooter::part(arrowcontent) {
   padding-bottom: 0;
 }
 
diff --git a/devtools/client/themes/tooltips.css b/devtools/client/themes/tooltips.css
--- a/devtools/client/themes/tooltips.css
+++ b/devtools/client/themes/tooltips.css
@@ -178,8 +178,8 @@
 
 /* The arrow image is hidden because the panel is opened using openPopupAtScreen(). */
 
-/* Remove all decorations on .panel-arrowcontent is the tooltip content container. */
-.tooltip-xul-wrapper[type="arrow"] .panel-arrowcontent {
+/* The arrow content is styled on the HTML, so we don't need the styling on the XUL element */
+.tooltip-xul-wrapper[type="arrow"]::part(arrowcontent) {
   margin: 0;
   padding: 0;
   background: transparent;
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -518,7 +518,7 @@
 }
 
 static bool MayNeedToLoadXBLBinding(const Element& aElement) {
-  if (!aElement.IsAnyOfXULElements(nsGkAtoms::panel, nsGkAtoms::textbox)) {
+  if (!aElement.IsAnyOfXULElements(nsGkAtoms::textbox)) {
     // Other elements no longer have XBL bindings. Please don't add to the list
     // above unless completely necessary.
     return false;
diff --git a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
--- a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
+++ b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
@@ -54,10 +54,8 @@
       // Open the information arrow panel
       await openIdentityPopup();
 
-      let arrowContent = document.getAnonymousElementByAttribute(
-        gIdentityHandler._identityPopup,
-        "class",
-        "panel-arrowcontent"
+      let arrowContent = gIdentityHandler._identityPopup.shadowRoot.querySelector(
+        ".panel-arrowcontent"
       );
       let arrowContentComputedStyle = window.getComputedStyle(arrowContent);
       // Ensure popup background color was set properly
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -460,6 +460,18 @@
       }
 
       /**
+       * Passes DOM events to the on_<event type> methods.
+       */
+      handleEvent(event) {
+        let methodName = "on_" + event.type;
+        if (methodName in this) {
+          this[methodName](event);
+        } else {
+          throw new Error("Unrecognized event: " + event.type);
+        }
+      }
+
+      /**
        * Allows eager deterministic construction of XUL elements with XBL attached, by
        * parsing an element tree and returning a DOM fragment to be inserted in the
        * document before any of the inner elements is referenced by JavaScript.
@@ -761,6 +773,7 @@
       "chrome://global/content/elements/menu.js",
       "chrome://global/content/elements/menupopup.js",
       "chrome://global/content/elements/notificationbox.js",
+      "chrome://global/content/elements/panel.js",
       "chrome://global/content/elements/popupnotification.js",
       "chrome://global/content/elements/radio.js",
       "chrome://global/content/elements/richlistbox.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -65,7 +65,6 @@
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
-   content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
    content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
@@ -84,6 +83,7 @@
    content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/menupopup.js        (widgets/menupopup.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
+   content/global/elements/panel.js            (widgets/panel.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
diff --git a/toolkit/content/tests/chrome/test_arrowpanel.xul b/toolkit/content/tests/chrome/test_arrowpanel.xul
--- a/toolkit/content/tests/chrome/test_arrowpanel.xul
+++ b/toolkit/content/tests/chrome/test_arrowpanel.xul
@@ -286,8 +286,8 @@
 
   is(anchor, expectedAnchor, "anchor");
 
-  var arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
-  is(arrow.getAttribute("side"), expectedSide, "panel arrow side");
+  var arrow = panel.shadowRoot.querySelector(".panel-arrow");
+  is(panel.getAttribute("side"), expectedSide, "panel arrow side");
   is(arrow.hidden, false, "panel hidden");
   is(arrow.parentNode.pack, expectedPack, "panel arrow pack");
   is(panel.alignmentPosition, expectedAlignment, "panel alignmentPosition");
diff --git a/toolkit/content/tests/widgets/test_popupanchor.xul b/toolkit/content/tests/widgets/test_popupanchor.xul
--- a/toolkit/content/tests/widgets/test_popupanchor.xul
+++ b/toolkit/content/tests/widgets/test_popupanchor.xul
@@ -433,7 +433,7 @@
   // anchor is set by the test runner above
   panel = document.getElementById("testPanel");
 
-  arrow = SpecialPowers.wrap(document).getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
   runTests();
 });
 
diff --git a/toolkit/content/tests/widgets/test_popupreflows.xul b/toolkit/content/tests/widgets/test_popupreflows.xul
--- a/toolkit/content/tests/widgets/test_popupreflows.xul
+++ b/toolkit/content/tests/widgets/test_popupreflows.xul
@@ -87,7 +87,7 @@
 addEventListener("load", function() {
   anchor = document.getElementById("anchor");
   panel = document.getElementById("testPanel");
-  arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   // Cancel the arrow panel slide-in transition (bug 767133) - we are only
   // testing reflows in the core panel implementation and not reflows that may
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/panel.js
rename from toolkit/content/widgets/popup.xml
rename to toolkit/content/widgets/panel.js
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/panel.js
@@ -1,174 +1,177 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
 
-<bindings id="popupBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+  class MozPanel extends MozElements.MozElementMixin(XULPopupElement) {
+    constructor() {
+      super();
 
-  <binding id="panel">
-    <implementation>
-      <field name="_prevFocus">0</field>
-    </implementation>
+      this.attachShadow({ mode: "open" });
+
+      this._prevFocus = 0;
+      this._fadeTimer = null;
 
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // Capture the previous focus before has a chance to get set inside the panel
-        try {
-          this._prevFocus = Cu
-                            .getWeakReference(document.commandDispatcher.focusedElement);
-          if (this._prevFocus.get())
-            return;
-        } catch (ex) { }
+      this.addEventListener("popupshowing", this);
+      this.addEventListener("popupshown", this);
+      this.addEventListener("popuphiding", this);
+      this.addEventListener("popuphidden", this);
+      this.addEventListener("popuppositioned", this);
+    }
 
-        this._prevFocus = Cu.getWeakReference(document.activeElement);
-      ]]></handler>
-      <handler event="popupshown"><![CDATA[
-        // Fire event for accessibility APIs
-        var alertEvent = document.createEvent("Events");
-        alertEvent.initEvent("AlertActive", true, true);
-        this.dispatchEvent(alertEvent);
-       ]]></handler>
-      <handler event="popuphiding"><![CDATA[
-        try {
-          this._currentFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          this._currentFocus = document.activeElement;
+    connectedCallback() {
+      // Create shadow DOM lazily if a panel is hidden. It helps to reduce
+      // cycles on startup.
+      if (!this.hidden) {
+        this.initialize();
+      }
+
+      if (this.isArrowPanel) {
+        if (!this.hasAttribute("flip")) {
+          this.setAttribute("flip", "both");
+        }
+        if (!this.hasAttribute("side")) {
+          this.setAttribute("side", "top");
+        }
+        if (!this.hasAttribute("position")) {
+          this.setAttribute("position", "bottomcenter topleft");
+        }
+        if (!this.hasAttribute("consumeoutsideclicks")) {
+          this.setAttribute("consumeoutsideclicks", "false");
         }
-      ]]></handler>
-      <handler event="popuphidden"><![CDATA[
-        function doFocus() {
-          // Focus was set on an element inside this panel,
-          // so we need to move it back to where it was previously
-          try {
-            let fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
-          } catch (e) {
-            prevFocus.focus();
-          }
-        }
-        var currentFocus = this._currentFocus;
-        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
-        this._currentFocus = null;
-        this._prevFocus = null;
+      }
+    }
+
+    initialize() {
+      // As an optimization, we don't slot contents if the panel is [hidden] in
+      // connecetedCallack this means we can avoid running this code at startup
+      // and only need to do it when a panel is about to be shown.
+      // We then override the `hidden` setter and `removeAttribute` and call this
+      // function if the node is about to be shown.
+      if (this.shadowRoot.firstChild) {
+        return;
+      }
+
+      if (!this.isArrowPanel) {
+        this.shadowRoot.appendChild(document.createElement("slot"));
+      } else {
+        this.shadowRoot.appendChild(this.fragment);
+      }
+    }
 
-        // Avoid changing focus if focus changed while we hide the popup
-        // (This can happen e.g. if the popup is hiding as a result of a
-        // click/keypress that focused something)
-        let nowFocus;
-        try {
-          nowFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          nowFocus = document.activeElement;
-        }
-        if (nowFocus && nowFocus != currentFocus)
-          return;
+    get hidden() {
+      return super.hidden;
+    }
+    set hidden(v) {
+      if (!v) {
+        this.initialize();
+      }
+      return (super.hidden = v);
+    }
 
-        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
-          // Try to restore focus
-          try {
-            if (document.commandDispatcher.focusedWindow != window)
-              return; // Focus has already been set to a window outside of this panel
-          } catch (ex) {}
+    removeAttribute(name) {
+      if (name == "hidden") {
+        this.initialize();
+      }
+      super.removeAttribute(name);
+    }
 
-          if (!currentFocus) {
-            doFocus();
-            return;
+    get fragment() {
+      if (!this.constructor.hasOwnProperty("_fragment")) {
+        this.constructor._fragment = MozXULElement.parseXULToFragment(`
+        <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
+        <html:style>
+          :host([orient=vertical]) .panel-arrowcontent {
+            -moz-box-orient: vertical;
           }
-          while (currentFocus) {
-            if (currentFocus == this) {
-              doFocus();
-              return;
-            }
-            currentFocus = currentFocus.parentNode;
-          }
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
+        </html:style>
+        <vbox class="panel-arrowcontainer" flex="1">
+          <box class="panel-arrowbox" part="arrowbox">
+            <image class="panel-arrow" part="arrow"/>
+          </box>
+          <box class="panel-arrowcontent" flex="1" part="arrowcontent"><html:slot/></box>
+        </vbox>
+      `);
+      }
+      return document.importNode(this.constructor._fragment, true);
+    }
+
+    get isArrowPanel() {
+      return this.getAttribute("type") == "arrow";
+    }
 
-  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
-    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
-      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
-               xbl:inherits="side,panelopen">
-        <xul:box anonid="arrowbox" class="panel-arrowbox">
-          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
-        </xul:box>
-        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
-          <children/>
-        </xul:box>
-      </xul:vbox>
-    </content>
-    <implementation>
-      <field name="_fadeTimer">null</field>
-      <method name="adjustArrowPosition">
-        <body>
-        <![CDATA[
-        var anchor = this.anchorNode;
-        if (!anchor) {
-          return;
-        }
+    adjustArrowPosition() {
+      if (!this.isArrowPanel) {
+        return;
+      }
 
-        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
-        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
+      var anchor = this.anchorNode;
+      if (!anchor) {
+        return;
+      }
 
-        var position = this.alignmentPosition;
-        var offset = this.alignmentOffset;
+      var container = this.shadowRoot.querySelector(".panel-arrowcontainer");
+      var arrowbox = this.shadowRoot.querySelector(".panel-arrowbox");
 
-        this.setAttribute("arrowposition", position);
+      var position = this.alignmentPosition;
+      var offset = this.alignmentOffset;
+
+      this.setAttribute("arrowposition", position);
 
-        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
-          container.orient = "horizontal";
-          arrowbox.orient = "vertical";
-          if (position.indexOf("_after") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(0, " + -offset + "px)";
+      if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
+        container.orient = "horizontal";
+        arrowbox.orient = "vertical";
+        if (position.indexOf("_after") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
+        }
+        arrowbox.style.transform = "translate(0, " + -offset + "px)";
 
-          // The assigned side stays the same regardless of direction.
-          var isRTL = (window.getComputedStyle(this).direction == "rtl");
+        // The assigned side stays the same regardless of direction.
+        var isRTL = window.getComputedStyle(this).direction == "rtl";
 
-          if (position.indexOf("start_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", isRTL ? "left" : "right");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", isRTL ? "right" : "left");
-          }
-        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
-          container.orient = "";
-          arrowbox.orient = "";
-          if (position.indexOf("_end") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(" + -offset + "px, 0)";
+        if (position.indexOf("start_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", isRTL ? "left" : "right");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", isRTL ? "right" : "left");
+        }
+      } else if (
+        position.indexOf("before_") == 0 ||
+        position.indexOf("after_") == 0
+      ) {
+        container.orient = "";
+        arrowbox.orient = "";
+        if (position.indexOf("_end") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
+        }
+        arrowbox.style.transform = "translate(" + -offset + "px, 0)";
 
-          if (position.indexOf("before_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", "bottom");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", "top");
-          }
+        if (position.indexOf("before_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", "bottom");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", "top");
         }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="popupshowing" phase="target">
-      <![CDATA[
-        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
+      }
+    }
+
+    on_popupshowing(event) {
+      if (this.isArrowPanel && event.target == this) {
+        var arrow = this.shadowRoot.querySelector(".panel-arrow");
         arrow.hidden = this.anchorNode == null;
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
-                .style.removeProperty("transform");
+        this.shadowRoot
+          .querySelector(".panel-arrowbox")
+          .style.removeProperty("transform");
 
         if (this.getAttribute("animate") != "false") {
           this.setAttribute("animate", "open");
@@ -184,15 +187,46 @@
           fadeDelay = 1;
         } else if (fade == "slow") {
           fadeDelay = 4000;
-        } else {
-          return;
         }
 
-        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
-      ]]>
-      </handler>
-      <handler event="popuphiding" phase="target">
-        let animate = (this.getAttribute("animate") != "false");
+        if (fadeDelay != 0) {
+          this._fadeTimer = setTimeout(
+            () => this.hidePopup(true),
+            fadeDelay,
+            this
+          );
+        }
+      }
+
+      // Capture the previous focus before has a chance to get set inside the panel
+      try {
+        this._prevFocus = Cu.getWeakReference(
+          document.commandDispatcher.focusedElement
+        );
+        if (!this._prevFocus.get()) {
+          this._prevFocus = Cu.getWeakReference(document.activeElement);
+          return;
+        }
+      } catch (ex) {
+        this._prevFocus = Cu.getWeakReference(document.activeElement);
+      }
+    }
+
+    on_popupshown(event) {
+      if (this.isArrowPanel && event.target == this) {
+        this.removeAttribute("animating");
+        this.setAttribute("panelopen", "true");
+      }
+
+      // Fire event for accessibility APIs
+      let alertEvent = document.createEvent("Events");
+      alertEvent.initEvent("AlertActive", true, true);
+      this.dispatchEvent(alertEvent);
+    }
+
+    on_popuphiding(event) {
+      if (this.isArrowPanel && event.target == this) {
+        let animate = this.getAttribute("animate") != "false";
 
         if (this._fadeTimer) {
           clearTimeout(this._fadeTimer);
@@ -202,20 +236,80 @@
         } else if (animate) {
           this.setAttribute("animate", "cancel");
         }
-      </handler>
-      <handler event="popupshown" phase="target">
-        this.removeAttribute("animating");
-        this.setAttribute("panelopen", "true");
-      </handler>
-      <handler event="popuphidden" phase="target">
+      }
+
+      try {
+        this._currentFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        this._currentFocus = document.activeElement;
+      }
+    }
+
+    on_popuphidden(event) {
+      if (this.isArrowPanel && event.target == this) {
         this.removeAttribute("panelopen");
         if (this.getAttribute("animate") != "false") {
           this.removeAttribute("animate");
         }
-      </handler>
-      <handler event="popuppositioned" phase="target">
+      }
+
+      function doFocus() {
+        // Focus was set on an element inside this panel,
+        // so we need to move it back to where it was previously
+        try {
+          let fm = Services.focus;
+          fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
+        } catch (e) {
+          prevFocus.focus();
+        }
+      }
+      var currentFocus = this._currentFocus;
+      var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
+      this._currentFocus = null;
+      this._prevFocus = null;
+
+      // Avoid changing focus if focus changed while we hide the popup
+      // (This can happen e.g. if the popup is hiding as a result of a
+      // click/keypress that focused something)
+      let nowFocus;
+      try {
+        nowFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        nowFocus = document.activeElement;
+      }
+      if (nowFocus && nowFocus != currentFocus) {
+        return;
+      }
+
+      if (prevFocus && this.getAttribute("norestorefocus") != "true") {
+        // Try to restore focus
+        try {
+          if (document.commandDispatcher.focusedWindow != window) {
+            // Focus has already been set to a window outside of this panel
+            return;
+          }
+        } catch (ex) {}
+
+        if (!currentFocus) {
+          doFocus();
+          return;
+        }
+        while (currentFocus) {
+          if (currentFocus == this) {
+            doFocus();
+            return;
+          }
+          currentFocus = currentFocus.parentNode;
+        }
+      }
+    }
+
+    on_popuppositioned(event) {
+      if (event.target == this) {
         this.adjustArrowPosition();
-      </handler>
-    </handlers>
-  </binding>
-</bindings>
+      }
+    }
+  }
+
+  customElements.define("panel", MozPanel);
+}
diff --git a/toolkit/content/widgets/tabbox.js b/toolkit/content/widgets/tabbox.js
--- a/toolkit/content/widgets/tabbox.js
+++ b/toolkit/content/widgets/tabbox.js
@@ -321,18 +321,6 @@
       }
     }
 
-    /**
-     * Passes DOM events to the on_<event type> methods.
-     */
-    handleEvent(event) {
-      let methodName = "on_" + event.type;
-      if (methodName in this) {
-        this[methodName](event);
-      } else {
-        throw new Error("Unrecognized event: " + event.type);
-      }
-    }
-
     on_mousedown(event) {
       if (event.button != 0 || this.disabled) {
         return;
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -231,7 +231,6 @@
 }
 
 panel {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#panel");
   -moz-box-orient: vertical;
 }
 
@@ -249,10 +248,6 @@
   margin-top: 21px;
 }
 
-panel[type="arrow"] {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
-}
-
 @supports -moz-bool-pref("xul.panel-animations.enabled") {
 %ifdef MOZ_WIDGET_COCOA
   /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"
diff --git a/toolkit/themes/linux/global/popup.css b/toolkit/themes/linux/global/popup.css
--- a/toolkit/themes/linux/global/popup.css
+++ b/toolkit/themes/linux/global/popup.css
@@ -3,6 +3,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
+@namespace html url("http://www.w3.org/1999/xhtml");
 
 /* ::::: menupopup ::::: */
 
@@ -40,47 +41,52 @@
   margin: 4px;
 }
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+.panel-arrowcontent > html|slot {
+  /* propagate border-radius from arrowcontent to slotted children */
+  border-radius: inherit;
+}
+
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border */
 }
 
-.panel-arrow {
+:-moz-any(panel, menupopup)::part(arrow) {
   -moz-context-properties: fill, stroke;
   fill: var(--arrowpanel-background);
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"],
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow),
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   position: relative;
   margin-left: 10px;
   margin-right: 10px;
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   margin-bottom: -5px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   transform: scaleY(-1);
   margin-top: -5px;
 }
 
-.panel-arrow[side="left"],
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow),
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   position: relative;
   margin-top: 10px;
   margin-bottom: 10px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   margin-right: -5px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   transform: scaleX(-1);
   margin-left: -5px;
 }
diff --git a/toolkit/themes/osx/global/popup.css b/toolkit/themes/osx/global/popup.css
--- a/toolkit/themes/osx/global/popup.css
+++ b/toolkit/themes/osx/global/popup.css
@@ -3,6 +3,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
+@namespace html url("http://www.w3.org/1999/xhtml");
 
 menupopup,
 panel {
@@ -53,25 +54,30 @@
   margin: 1px;
 }
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+.panel-arrowcontent > html|slot {
+  /* propagate border-radius from arrowcontent to slotted children */
+  border-radius: inherit;
+}
+
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border-radius */
 }
 
-.panel-arrow {
+:-moz-any(panel, menupopup)::part(arrow) {
   -moz-context-properties: fill, stroke;
   fill: var(--arrowpanel-background);
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   margin-left: 16px;
   margin-right: 16px;
   margin-bottom: -1px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   -moz-transform: scaleY(-1);
   margin-left: 16px;
@@ -79,14 +85,14 @@
   margin-top: -1px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   margin-top: 16px;
   margin-bottom: 16px;
   margin-right: -1px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   transform: scaleX(-1);
   margin-top: 16px;
diff --git a/toolkit/themes/shared/notification-popup.inc.css b/toolkit/themes/shared/notification-popup.inc.css
--- a/toolkit/themes/shared/notification-popup.inc.css
+++ b/toolkit/themes/shared/notification-popup.inc.css
@@ -1,4 +1,4 @@
-.popup-notification-panel > .panel-arrowcontainer > .panel-arrowcontent {
+.popup-notification-panel::part(arrowcontent) {
   /* To keep the rounded borders of the panel, we use overflow: hidden; from the
    * panel-no-padding class to ensure the contents are clipped to the border box.
    * That causes us to override the "display" property so that the height of the
diff --git a/toolkit/themes/windows/global/popup.css b/toolkit/themes/windows/global/popup.css
--- a/toolkit/themes/windows/global/popup.css
+++ b/toolkit/themes/windows/global/popup.css
@@ -3,6 +3,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
+@namespace html url("http://www.w3.org/1999/xhtml");
 
 /* ::::: menupopup ::::: */
 
@@ -53,6 +54,11 @@
   margin: 4px;
 }
 
+.panel-arrowcontent > html|slot {
+  /* propagate border-radius from arrowcontent to slotted children */
+  border-radius: inherit;
+}
+
 %ifdef XP_WIN
 @media (-moz-os-version: windows-win7) {
 %endif
@@ -63,47 +69,47 @@
 }
 %endif
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border-radius */
 }
 
-.panel-arrow {
+:-moz-any(panel, menupopup)::part(arrow) {
   -moz-context-properties: fill, stroke;
   fill: var(--arrowpanel-background);
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"],
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow),
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   position: relative;
   margin-left: 10px;
   margin-right: 10px;
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   margin-bottom: -5px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   transform: scaleY(-1);
   margin-top: -5px;
 }
 
-.panel-arrow[side="left"],
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow),
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   position: relative;
   margin-top: 10px;
   margin-bottom: 10px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   margin-right: -5px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   transform: scaleX(-1);
   margin-left: -5px;
 }

