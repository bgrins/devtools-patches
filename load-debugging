# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  03e6f67bb102afd418d6aa318fbbe5fea3ea9fa4
Loading markup debuging

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -202,16 +202,17 @@ InspectorPanel.prototype = {
     return deferred.promise;
   },
 
   _onBeforeNavigate: function() {
     this._defaultNode = null;
     this.selection.setNodeFront(null);
     this._destroyMarkup();
     this.isDirty = false;
+    console.log("Clearing pending selectoin _onBeforeNavigate");
     this._pendingSelection = null;
   },
 
   _getPageStyle: function() {
     return this._toolbox.inspector.getPageStyle().then(pageStyle => {
       this.pageStyle = pageStyle;
     });
   },
@@ -226,16 +227,17 @@ InspectorPanel.prototype = {
     let walker = this.walker;
     let rootNode = null;
     let pendingSelection = this._pendingSelection;
 
     // A helper to tell if the target has or is about to navigate.
     // this._pendingSelection changes on "will-navigate" and "new-root" events.
     let hasNavigated = () => pendingSelection !== this._pendingSelection;
 
+    return this.walker.documentElement();
     // If available, set either the previously selected node or the body
     // as default selected, else set documentElement
     return walker.getRootNode().then(aRootNode => {
       if (hasNavigated()) {
         return promise.reject("navigated; resolution of _defaultNode aborted");
       }
 
       rootNode = aRootNode;
@@ -254,20 +256,23 @@ InspectorPanel.prototype = {
     }).then(front => {
       if (hasNavigated()) {
         return promise.reject("navigated; resolution of _defaultNode aborted");
       }
 
       if (front) {
         return front;
       }
-      return this.walker.documentElement(this.walker.rootNode);
+      // return this.walker.documentElement(this.walker.rootNode);
+      return this.walker.documentElement();
     }).then(node => {
-      if (!node || walker !== this.walker) {
-        return promise.reject("navigated; resolution of _defaultNode aborted");
+      console.log("RECEIVED NODE", (!node || walker !== this.walker), hasNavigated());
+      if (!node) {
+        // return promise.reject("dddnavigated; resolution of _defaultNode aborted");
+        return this.walker.documentElement();
       }
       this._defaultNode = node;
       return node;
     });
   },
 
   /**
    * Target getter.
@@ -368,40 +373,47 @@ InspectorPanel.prototype = {
       this.onPaneToggleButtonClicked);
     this.updatePaneToggleButton();
   },
 
   /**
    * Reset the inspector on new root mutation.
    */
   onNewRoot: function InspectorPanel_onNewRoot() {
+    console.log("On new root!", arguments);
+    console.trace();
     this._defaultNode = null;
     this.selection.setNodeFront(null);
     this._destroyMarkup();
     this.isDirty = false;
 
     let onNodeSelected = defaultNode => {
       // Cancel this promise resolution as a new one had
       // been queued up.
+      console.log("ON NODE SELECTED!!", defaultNode._form, this._pendingSelection != onNodeSelected);
       if (this._pendingSelection != onNodeSelected) {
         return;
       }
       this._pendingSelection = null;
       this.selection.setNodeFront(defaultNode, "navigateaway");
 
+      console.log("navigateaway", defaultNode);
       this._initMarkup();
       this.once("markuploaded", () => {
+        console.log("markuploaded", this.markup);
         if (!this.markup) {
           return;
         }
-        this.markup.expandNode(this.selection.nodeFront);
+        // this.markup.expandNode(this.selection.nodeFront);
         this.setupSearchBox();
+        console.log("emitting new root");
         this.emit("new-root");
       });
     };
+    console.log("Setting pending selection!!", this.walker.rootNode);
     this._pendingSelection = onNodeSelected;
     this._getDefaultNodeForSelection().then(onNodeSelected, console.error);
   },
 
   _selectionCssSelector: null,
 
   /**
    * Set the currently selected node unique css selector.
@@ -770,16 +782,20 @@ InspectorPanel.prototype = {
     this._markupFrame.removeEventListener("load", this._boundMarkupFrameLoad, true);
     delete this._boundMarkupFrameLoad;
 
     this._markupFrame.contentWindow.focus();
 
     this._markupBox.removeAttribute("collapsed");
 
     let controllerWindow = this._toolbox.doc.defaultView;
+
+    this.once("inspector-updated", (e, type) => {
+      console.log("INSPECTOR UPDATED!!!!", type);
+    });
     this.markup = new MarkupView(this, this._markupFrame, controllerWindow);
 
     this.emit("markuploaded");
   },
 
   _destroyMarkup: function InspectorPanel__destroyMarkup() {
     let destroyPromise;
 
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -60,17 +60,16 @@ loader.lazyGetter(this, "AutocompletePop
  *
  * @param Inspector aInspector
  *        The inspector we're watching.
  * @param iframe aFrame
  *        An iframe in which the caller has kindly loaded markup-view.xhtml.
  */
 function MarkupView(aInspector, aFrame, aControllerWindow) {
   this._inspector = aInspector;
-  this.walker = this._inspector.walker;
   this._frame = aFrame;
   this.win = this._frame.contentWindow;
   this.doc = this._frame.contentDocument;
   this._elt = this.doc.querySelector("#root");
   this.htmlEditor = new HTMLEditor(this.doc);
 
   this.layoutHelpers = new LayoutHelpers(this.doc.defaultView);
 
@@ -127,16 +126,20 @@ exports.MarkupView = MarkupView;
 MarkupView.prototype = {
   /**
    * How long does a node flash when it mutates (in ms).
    */
   CONTAINER_FLASHING_DURATION: 500,
 
   _selectedContainer: null,
 
+  get walker() {
+    return this._inspector.walker;
+  },
+
   _initTooltips: function() {
     this.tooltip = new Tooltip(this._inspector.panelDoc);
     this._makeTooltipPersistent(false);
 
     this._elt.addEventListener("click", this._onMouseClick, false);
   },
 
   _initHighlighter: function() {
@@ -429,18 +432,18 @@ MarkupView.prototype = {
       this._hoveredNode = null;
     }
 
     let done = this._inspector.updating("markup-view");
     if (selection.isNode()) {
       if (this._shouldNewSelectionBeHighlighted()) {
         this._brieflyShowBoxModel(selection.nodeFront);
       }
-
-      this.showNode(selection.nodeFront, true).then(() => {
+      console.log("SHOWING SELECTION", selection.nodeFront, selection.nodeFront._form);
+      this.showNode(this.walker.rootNode, true).then(() => {
         if (this._destroyer) {
           return promise.reject("markupview destroyed");
         }
         if (selection.reason !== "treepanel") {
           this.markNodeAsSelected(selection.nodeFront);
         }
         done();
       }).then(null, e => {
@@ -669,16 +672,18 @@ MarkupView.prototype = {
    *
    * @param NodeFront aNode
    *        The node in the content document.
    * @param boolean aFlashNode
    *        Whether the newly imported node should be flashed
    * @returns MarkupContainer The MarkupContainer object for this element.
    */
   importNode: function(aNode, aFlashNode) {
+    console.log("IMPORTING NODE!!", aNode._form, this._inspector.walker.rootNode._form);
+    console.trace();
     if (!aNode) {
       return null;
     }
 
     if (this._containers.has(aNode)) {
       return this.getContainer(aNode);
     }
 
diff --git a/browser/devtools/markupview/test/browser_markupview_load_01.js b/browser/devtools/markupview/test/browser_markupview_load_01.js
--- a/browser/devtools/markupview/test/browser_markupview_load_01.js
+++ b/browser/devtools/markupview/test/browser_markupview_load_01.js
@@ -34,16 +34,20 @@ add_task(function*() {
   // XXX: Test passes if this is commented out.
   yield chooseWithInspectElementContextMenu("img");
 
   yield pageLoaded;
   yield inspector.once("markuploaded");
 
   ok (inspector.markup, "There is a markup view");
   is (inspector.markup._elt.children.length, 1, "The markup view is rendering");
+
+  console.log("Test done!!!");
+  console.log(inspector.markup._elt.innerHTML);
+  yield promise.defer().promise;
 });
 
 function* chooseWithInspectElementContextMenu(selector) {
   yield executeInContent("Test:SynthesizeMouse", {
     center: true,
     selector: selector,
     options: {type: "contextmenu", button: 2}
   });
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1362,40 +1362,37 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Return the document node that contains the given node,
    * or the root node if no node is specified.
    * @param NodeActor node
    *        The node whose document is needed, or null to
    *        return the root.
    */
   document: method(function(node) {
-    if (node && node.isDead()) {
-      return null;
-    }
-
-    let doc = node ? nodeDocument(node.rawNode) : this.rootDoc;
+    let deadNode = !node || node.isDead();
+    let doc = deadNode ? this.rootDoc : nodeDocument(node.rawNode);
     return this._ref(doc);
   }, {
     request: { node: Arg(0, "nullable:domnode") },
     response: { node: RetVal("nullable:domnode") },
   }),
 
   /**
    * Return the documentElement for the document containing the
    * given node.
    * @param NodeActor node
    *        The node whose documentElement is requested, or null
    *        to use the root document.
    */
   documentElement: method(function(node) {
-    if (node.isDead()) {
-      return null;
-    }
-
-    let elt = node ? nodeDocument(node.rawNode).documentElement : this.rootDoc.documentElement;
+    let deadNode = !node || node.isDead();
+    // if (deadNode) {
+    //   return null;
+    // }
+    let elt = deadNode ? this.rootDoc.documentElement : nodeDocument(node.rawNode).documentElement;
     return this._ref(elt);
   }, {
     request: { node: Arg(0, "nullable:domnode") },
     response: { node: RetVal("nullable:domnode") },
   }),
 
   /**
    * Return all parents of the given node, ordered from immediate parent
@@ -1403,17 +1400,17 @@ var WalkerActor = protocol.ActorClass({
    * @param NodeActor node
    *    The node whose parents are requested.
    * @param object options
    *    Named options, including:
    *    `sameDocument`: If true, parents will be restricted to the same
    *      document as the node.
    */
   parents: method(function(node, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return [];
     }
 
     let walker = this.getDocumentWalker(node.rawNode);
     let parents = [];
     let cur;
     while((cur = walker.parentNode())) {
       if (options.sameDocument && cur.ownerDocument != node.rawNode.ownerDocument) {
@@ -1479,17 +1476,17 @@ var WalkerActor = protocol.ActorClass({
     request: { node: Arg(0, "domnode") },
     response: {},
   }),
 
   /**
    * Release actors for a node and all child nodes.
    */
   releaseNode: method(function(node, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     if (node.retained && !options.force) {
       this._retainedOrphans.add(node);
       return;
     }
 
@@ -1658,17 +1655,17 @@ var WalkerActor = protocol.ActorClass({
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    *
    * @returns an object with three items:
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   siblings: method(function(node, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return { hasFirst: true, hasLast: true, nodes: [] };
     }
 
     let parentNode = this.getDocumentWalker(node.rawNode, options.whatToShow).parentNode();
     if (!parentNode) {
       return {
         hasFirst: true,
         hasLast: true,
@@ -1688,17 +1685,17 @@ var WalkerActor = protocol.ActorClass({
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   nextSibling: method(function(node, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return null;
     }
 
     let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.nextSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
@@ -1707,17 +1704,17 @@ var WalkerActor = protocol.ActorClass({
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   previousSibling: method(function(node, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return null;
     }
 
     let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.previousSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
@@ -1962,17 +1959,17 @@ var WalkerActor = protocol.ActorClass({
    *    Options object:
    *    `parents`: True if the pseudo-class should be added
    *      to parent nodes.
    *
    * @returns An empty packet.  A "pseudoClassLock" mutation will
    *    be queued for any changed nodes.
    */
   addPseudoClassLock: method(function(node, pseudo, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     this._addPseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
@@ -2020,28 +2017,28 @@ var WalkerActor = protocol.ActorClass({
       let { attach } = require("sdk/content/mod");
       let style = Style({source: HELPER_SHEET, type: "agent" });
       attach(style, win);
       this.installedHelpers.set(win, style);
     }
   },
 
   hideNode: method(function(node) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     this._installHelperSheet(node);
     node.rawNode.classList.add(HIDDEN_CLASS);
   }, {
     request: { node: Arg(0, "domnode") }
   }),
 
   unhideNode: method(function(node) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     node.rawNode.classList.remove(HIDDEN_CLASS);
   }, {
     request: { node: Arg(0, "domnode") }
   }),
 
@@ -2055,17 +2052,17 @@ var WalkerActor = protocol.ActorClass({
    *    Options object:
    *    `parents`: True if the pseudo-class should be removed
    *      from parent nodes.
    *
    * @returns An empty response.  "pseudoClassLock" mutations
    *    will be emitted for any changed nodes.
    */
   removePseudoClassLock: method(function(node, pseudo, options={}) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     this._removePseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
@@ -2124,17 +2121,17 @@ var WalkerActor = protocol.ActorClass({
     },
     response: {}
   }),
 
   /**
    * Get a node's innerHTML property.
    */
   innerHTML: method(function(node) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return "";
     }
 
     return LongStringActor(this.conn, node.rawNode.innerHTML);
   }, {
     request: {
       node: Arg(0, "domnode")
     },
@@ -2145,17 +2142,17 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Set a node's innerHTML property.
    *
    * @param {NodeActor} node The node.
    * @param {string} value The piece of HTML content.
    */
   setInnerHTML: method(function(node, value) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     let rawNode = node.rawNode;
     if (rawNode.nodeType !== rawNode.ownerDocument.ELEMENT_NODE)
       throw new Error("Can only change innerHTML to element nodes");
     rawNode.innerHTML = value;
   }, {
@@ -2167,17 +2164,17 @@ var WalkerActor = protocol.ActorClass({
   }),
 
   /**
    * Get a node's outerHTML property.
    *
    * @param {NodeActor} node The node.
    */
   outerHTML: method(function(node) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return "";
     }
 
     return LongStringActor(this.conn, node.rawNode.outerHTML);
   }, {
     request: {
       node: Arg(0, "domnode")
     },
@@ -2188,17 +2185,17 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Set a node's outerHTML property.
    *
    * @param {NodeActor} node The node.
    * @param {string} value The piece of HTML content.
    */
   setOuterHTML: method(function(node, value) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     let parsedDOM = DOMParser.parseFromString(value, "text/html");
     let rawNode = node.rawNode;
     let parentNode = rawNode.parentNode;
 
     // Special case for head and body.  Setting document.body.outerHTML
@@ -2252,17 +2249,17 @@ var WalkerActor = protocol.ActorClass({
    * Insert adjacent HTML to a node.
    *
    * @param {Node} node
    * @param {string} position One of "beforeBegin", "afterBegin", "beforeEnd",
    *                          "afterEnd" (see Element.insertAdjacentHTML).
    * @param {string} value The HTML content.
    */
   insertAdjacentHTML: method(function(node, position, value) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return {node: [], newParents: []}
     }
 
     let rawNode = node.rawNode;
     // Don't insert anything adjacent to the document element,
     // the head or the body.
     if (node.isDocumentElement()) {
       throw new Error("Can't insert adjacent element to the root.");
@@ -2335,17 +2332,17 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Removes a node from its parent node.
    *
    * @param {NodeActor} node The node to remove.
    * @returns The node's nextSibling before it was removed.
    */
   removeNode: method(function(node) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return null;
     }
 
     if (this.isDocumentOrDocumentElementNode(node)) {
       throw Error("Cannot remove document or document elements.");
     }
 
     let nextSibling = this.nextSibling(node);
@@ -2405,17 +2402,17 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Editing a node's tagname actually means creating a new node with the same
    * attributes, removing the node and inserting the new one instead.
    * This method does not return anything as mutation events are taking care of
    * informing the consumers about changes.
    */
   editTagName: method(function(node, tagName) {
-    if (node.isDead()) {
+    if (!node || node.isDead()) {
       return;
     }
 
     let oldNode = node.rawNode;
 
     // Create a new element with the same attributes as the current element and
     // prepare to replace the current node with it.
     let newNode;
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -1011,17 +1011,18 @@ var StyleRuleActor = protocol.ActorClass
       case Ci.nsIDOMCSSRule.STYLE_RULE:
         form.selectors = CssLogic.getSelectors(this.rawRule);
         form.cssText = this.rawStyle.cssText || "";
         break;
       case ELEMENT_STYLE:
         // Elements don't have a parent stylesheet, and therefore
         // don't have an associated URI.  Provide a URI for
         // those.
-        form.href = this.rawNode.ownerDocument.location.href;
+        let location = this.rawNode.ownerDocument.location;
+        form.href = location && location.href;
         form.cssText = this.rawStyle.cssText || "";
         break;
       case Ci.nsIDOMCSSRule.CHARSET_RULE:
         form.encoding = this.rawRule.encoding;
         break;
       case Ci.nsIDOMCSSRule.IMPORT_RULE:
         form.href = this.rawRule.href;
         break;
