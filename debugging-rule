# HG changeset patch
# Parent fa7cb9ac50212ca4950276c6fd812934a4d2a7c7
# User Brian Grinstead <bgrinstead@mozilla.com>
asdf

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -12,16 +12,17 @@ const {CssLogic} = require("devtools/sty
 const {InplaceEditor, editableField, editableItem} = require("devtools/shared/inplace-editor");
 const {ELEMENT_STYLE, PSEUDO_ELEMENTS} = require("devtools/server/actors/styles");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {OutputParser} = require("devtools/output-parser");
 const {PrefObserver, PREF_ORIG_SOURCES} = require("devtools/styleeditor/utils");
 const {parseSingleValue, parseDeclarations} = require("devtools/styleinspector/css-parsing-utils");
 const overlays = require("devtools/styleinspector/style-inspector-overlays");
 
+let EventEmitter = require("devtools/toolkit/event-emitter");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const PREF_UA_STYLES = "devtools.inspector.showUserAgentStyles";
 const PREF_DEFAULT_COLOR_UNIT = "devtools.defaultColorUnit";
 
@@ -202,16 +203,17 @@ ElementStyle.prototype = {
 
         // Store the current list of rules (if any) during the population
         // process.  They will be reused if possible.
         this._refreshRules = this.rules;
 
         this.rules = [];
 
         for (let entry of entries) {
+          console.log("Maybe adding rule", entry, entry.rule);
           this._maybeAddRule(entry);
         }
 
         // Mark overridden computed styles.
         this.markOverriddenAll();
 
         this._sortRulesForPseudoElement();
 
@@ -254,25 +256,25 @@ ElementStyle.prototype = {
     if (aOptions.system) {
       return false;
     }
 
     let rule = null;
 
     // If we're refreshing and the rule previously existed, reuse the
     // Rule object.
-    if (this._refreshRules) {
-      for (let r of this._refreshRules) {
-        if (r.matches(aOptions)) {
-          rule = r;
-          rule.refresh(aOptions);
-          break;
-        }
-      }
-    }
+    // if (this._refreshRules) {
+    //   for (let r of this._refreshRules) {
+    //     if (r.matches(aOptions)) {
+    //       rule = r;
+    //       rule.refresh(aOptions);
+    //       break;
+    //     }
+    //   }
+    // }
 
     // If this is a new rule, create its Rule object.
     if (!rule) {
       rule = new Rule(this, aOptions);
     }
 
     // Ignore inherited rules with no properties.
     if (aOptions.inherited && rule.textProps.length == 0) {
@@ -431,16 +433,17 @@ function Rule(aElementStyle, aOptions) {
       this.mediaText = parentRule.mediaText;
     }
   }
 
   // Populate the text properties with the style's current cssText
   // value, and add in any disabled properties from the store.
   this.textProps = this._getTextProperties();
   this.textProps = this.textProps.concat(this._getDisabledProperties());
+  EventEmitter.decorate(this);
 }
 
 Rule.prototype = {
   mediaText: "",
 
   get title() {
     if (this._title) {
       return this._title;
@@ -563,16 +566,18 @@ Rule.prototype = {
     else {
       this.textProps.push(prop);
     }
 
     this.applyProperties();
     return prop;
   },
 
+  i: 0,
+
   /**
    * Reapply all the properties in this rule, and update their
    * computed styles. Store disabled properties in the element
    * style's store. Will re-mark overridden properties.
    *
    * @param {string} [aName]
    *        A text property name (such as "background" or "border-top") used
    *        when calling from setPropertyValue & setPropertyName to signify
@@ -581,44 +586,53 @@ Rule.prototype = {
   applyProperties: function(aModifications, aName) {
     this.elementStyle.markOverriddenAll();
 
     if (!aModifications) {
       aModifications = this.style.startModifyingProperties();
     }
     let disabledProps = [];
     let store = this.elementStyle.store;
-
+console.log("Applying properties", this.textProps.map(p=>p.name + " " + p.value + " " + p.enabled));
     for (let prop of this.textProps) {
       if (!prop.enabled) {
+console.log("Adding disabled properties", prop.name, prop.value);
         disabledProps.push({
           name: prop.name,
           value: prop.value,
           priority: prop.priority
         });
         continue;
       }
       if (prop.value.trim() === "") {
         continue;
       }
 
+console.log("Setting properties", prop.name, prop.value);
       aModifications.setProperty(prop.name, prop.value, prop.priority);
 
       prop.updateComputed();
     }
 
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
+
+    // this._applyingModifications = promise.defer();
+
+    this.i++;
+    let i = this.i;
+    console.log("Starting applying", i);
     let promise = aModifications.apply().then(() => {
+      console.log("Finsihed applying", i);
       let cssProps = {};
       for (let cssProp of parseDeclarations(this.style.cssText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
         if (!textProp.enabled) {
           continue;
@@ -638,16 +652,17 @@ Rule.prototype = {
 
       this.elementStyle.markOverriddenAll();
 
       if (promise === this._applyingModifications) {
         this._applyingModifications = null;
       }
 
       this.elementStyle._changed();
+      this.emit("modifications-applied");
     }).then(null, promiseWarn);
 
     this._applyingModifications = promise;
     return promise;
   },
 
   /**
    * Renames a property.
@@ -710,16 +725,17 @@ Rule.prototype = {
    * Disables or enables given TextProperty.
    *
    * @param {TextProperty} aProperty
    *        The property to enable/disable
    * @param {Boolean} aValue
    */
   setPropertyEnabled: function(aProperty, aValue) {
     aProperty.enabled = !!aValue;
+    console.log("Setting enabled directly", aProperty.enabled, aProperty.name, aProperty.value);
     let modifications = this.style.startModifyingProperties();
     if (!aProperty.enabled) {
       modifications.removeProperty(aProperty.name);
     }
     this.applyProperties(modifications);
   },
 
   /**
@@ -759,17 +775,17 @@ Rule.prototype = {
     return textProps;
   },
 
   /**
    * Return the list of disabled properties from the store for this rule.
    */
   _getDisabledProperties: function() {
     let store = this.elementStyle.store;
-
+console.log("GETTING DISABLED!!", store.disabled.get(this.style));
     // Include properties from the disabled property store, if any.
     let disabledProps = store.disabled.get(this.style);
     if (!disabledProps) {
       return [];
     }
 
     let textProps = [];
 
@@ -794,28 +810,30 @@ Rule.prototype = {
     // Update current properties for each property present on the style.
     // This will mark any touched properties with _visited so we
     // can detect properties that weren't touched (because they were
     // removed from the style).
     // Also keep track of properties that didn't exist in the current set
     // of properties.
     let brandNewProps = [];
     for (let newProp of newTextProps) {
+      console.log("_updateTextProperty", newProp.name, newProp.value, newProp.enabled);
       if (!this._updateTextProperty(newProp)) {
         brandNewProps.push(newProp);
       }
     }
 
     // Refresh editors and disabled state for all the properties that
     // were updated.
     for (let prop of this.textProps) {
       // Properties that weren't touched during the update
       // process must no longer exist on the node.  Mark them disabled.
       if (!prop._visited) {
         prop.enabled = false;
+        console.log("Disabling prop", prop.name, prop.value);
         prop.updateEditor();
       } else {
         delete prop._visited;
       }
     }
 
     // Add brand new properties.
     this.textProps = this.textProps.concat(brandNewProps);
@@ -1547,19 +1565,20 @@ CssRuleView.prototype = {
     this._viewedElement = aElement;
     if (!this._viewedElement) {
       this._showEmpty();
       return promise.resolve(undefined);
     }
 
     this._elementStyle = new ElementStyle(aElement, this.store,
       this.pageStyle, this.showUserAgentStyles);
-
+console.log("SELECTING ELEMENT");
     return this._elementStyle.init().then(() => {
       if (this._viewedElement === aElement) {
+console.log("CALLING POPULATE 1");
         return this._populate();
       }
     }).then(() => {
       if (this._viewedElement === aElement) {
         this._elementStyle.onChanged = () => {
           this._changed();
         };
       }
@@ -1569,18 +1588,21 @@ CssRuleView.prototype = {
   /**
    * Update the rules for the currently highlighted element.
    */
   refreshPanel: function() {
     // Ignore refreshes during editing or when no element is selected.
     if (this.isEditing || !this._elementStyle) {
       return;
     }
-
+console.trace();
     // Repopulate the element style.
+console.log("REFRESH PANEL");;
+    // Repopulate the element style.
+console.log("CALLING POPULATE 2");
     this._populate(true);
   },
 
   _populate: function(clearRules = false) {
     let elementStyle = this._elementStyle;
     return this._elementStyle.populate().then(() => {
       if (this._elementStyle != elementStyle) {
         return;
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
@@ -36,23 +36,33 @@ add_task(function*() {
   secondProp = elementRule.createProperty("background-color", "blue", "");
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "blue", "New property should be used.");
   is(elementRule.textProps[0], firstProp, "Rules shouldn't have switched places.");
   is(elementRule.textProps[1], secondProp, "Rules shouldn't have switched places.");
 
   info("Disabling the second property and checking the applied style");
   secondProp.setEnabled(false);
+  // var timeoutPromise = promise.defer();
+  // setTimeout(timeoutPromise.resolve, 1000);
+  // yield timeoutPromise.promise;
+  // yield elementRule.once("modifications-applied");
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "green", "After disabling second property, first value should be used");
 
   info("Disabling the first property too and checking the applied style");
   firstProp.setEnabled(false);
+  // var timeoutPromise = promise.defer();
+  // setTimeout(timeoutPromise.resolve, 1000);
+  // yield timeoutPromise.promise;
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "", "After disabling both properties, value should be empty.");
+  
+  yield promise.defer().promise;
+  is(element.style.getPropertyValue("background-color"), "", "After disabling both properties, value should be empty.");
 
   info("Re-enabling the second propertyt and checking the applied style");
   secondProp.setEnabled(true);
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "blue", "Value should be set correctly after re-enabling");
 
   info("Re-enabling the first property and checking the insertion order is still respected");
   firstProp.setEnabled(true);
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -1046,16 +1046,17 @@ var StyleRuleActor = protocol.ActorClass
    *   type: "remove",
    *   name: <string>,
    * }
    *
    * @returns the rule with updated properties
    */
   modifyProperties: method(function(modifications) {
     let validProps = new Map();
+    console.log("Modify properties", modifications);
 
     // Use a fresh element for each call to this function to prevent side effects
     // that pop up based on property values that were already set on the element.
 
     let document;
     if (this.rawNode) {
       document = this.rawNode.ownerDocument;
     } else {
