# HG changeset patch
# Parent  369a5ee3a2880a4a98df3a00bf3db8d8f36b181b
Bug 1269915: Remove right click menu from breadcrumbs;r=bgrins

diff --git a/devtools/client/inspector/breadcrumbs.js b/devtools/client/inspector/breadcrumbs.js
--- a/devtools/client/inspector/breadcrumbs.js
+++ b/devtools/client/inspector/breadcrumbs.js
@@ -8,18 +8,20 @@
 
 const {Cu, Ci} = require("chrome");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 const Services = require("Services");
 const promise = require("promise");
 const FocusManager = Services.focus;
 const {waitForTick} = require("devtools/shared/DevToolsUtils");
 
-const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
-const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
+const ENSURE_SELECTION_VISIBLE_DELAY_MS = 50;
+const ELLIPSIS = Services.prefs.getComplexValue(
+    "intl.ellipsis",
+    Ci.nsIPrefLocalizedString).data;
 const MAX_LABEL_LENGTH = 40;
 const LOW_PRIORITY_ELEMENTS = {
   "HEAD": true,
   "BASE": true,
   "BASEFONT": true,
   "ISINDEX": true,
   "LINK": true,
   "META": true,
@@ -52,30 +54,30 @@ function HTMLBreadcrumbs(inspector) {
 
 exports.HTMLBreadcrumbs = HTMLBreadcrumbs;
 
 HTMLBreadcrumbs.prototype = {
   get walker() {
     return this.inspector.walker;
   },
 
-  _init: function() {
+  _init: function () {
     this.container = this.chromeDoc.getElementById("inspector-breadcrumbs");
 
     // These separators are used for CSS purposes only, and are positioned
     // off screen, but displayed with -moz-element.
     this.separators = this.chromeDoc.createElement("box");
     this.separators.className = "breadcrumb-separator-container";
     this.separators.innerHTML =
                       "<box id='breadcrumb-separator-before'></box>" +
                       "<box id='breadcrumb-separator-after'></box>" +
                       "<box id='breadcrumb-separator-normal'></box>";
     this.container.parentNode.appendChild(this.separators);
 
-    this.container.addEventListener("mousedown", this, true);
+    this.container.addEventListener("click", this, true);
     this.container.addEventListener("keypress", this, true);
     this.container.addEventListener("mouseover", this, true);
     this.container.addEventListener("mouseleave", this, true);
     this.container.addEventListener("focus", this, true);
 
     // We will save a list of already displayed nodes in this array.
     this.nodeHierarchy = [];
 
@@ -108,45 +110,45 @@ HTMLBreadcrumbs.prototype = {
     this.update();
   },
 
   /**
    * Include in a promise's then() chain to reject the chain
    * when the breadcrumbs' selection has changed while the promise
    * was outstanding.
    */
-  selectionGuard: function() {
+  selectionGuard: function () {
     let selection = this.selection.nodeFront;
     return result => {
       if (selection != this.selection.nodeFront) {
         return promise.reject("selection-changed");
       }
       return result;
     };
   },
 
   /**
    * Warn if rejection was caused by selection change, print an error otherwise.
    * @param {Error} err
    */
-  selectionGuardEnd: function(err) {
+  selectionGuardEnd: function (err) {
     // If the error is selection-changed, this is expected, the selection
     // changed while we were waiting for a promise to resolve, so there's no
     // need to proceed with the current update, and we should be silent.
     if (err !== "selection-changed") {
       console.error(err);
     }
   },
 
   /**
    * Build a string that represents the node: tagName#id.class1.class2.
    * @param {NodeFront} node The node to pretty-print
    * @return {String}
    */
-  prettyPrintNodeAsText: function(node) {
+  prettyPrintNodeAsText: function (node) {
     let text = node.tagName.toLowerCase();
     if (node.isPseudoElement) {
       text = node.isBeforePseudoElement ? "::before" : "::after";
     }
 
     if (node.id) {
       text += "#" + node.id;
     }
@@ -168,17 +170,17 @@ HTMLBreadcrumbs.prototype = {
   /**
    * Build <label>s that represent the node:
    *   <label class="breadcrumbs-widget-item-tag">tagName</label>
    *   <label class="breadcrumbs-widget-item-id">#id</label>
    *   <label class="breadcrumbs-widget-item-classes">.class1.class2</label>
    * @param {NodeFront} node The node to pretty-print
    * @returns {DocumentFragment}
    */
-  prettyPrintNodeAsXUL: function(node) {
+  prettyPrintNodeAsXUL: function (node) {
     let fragment = this.chromeDoc.createDocumentFragment();
 
     let tagLabel = this.chromeDoc.createElement("label");
     tagLabel.className = "breadcrumbs-widget-item-tag plain";
 
     let idLabel = this.chromeDoc.createElement("label");
     idLabel.className = "breadcrumbs-widget-item-id plain";
 
@@ -228,158 +230,84 @@ HTMLBreadcrumbs.prototype = {
     fragment.appendChild(idLabel);
     fragment.appendChild(classesLabel);
     fragment.appendChild(pseudosLabel);
 
     return fragment;
   },
 
   /**
-   * Open the sibling menu.
-   * @param {DOMNode} button the button representing the node.
-   * @param {NodeFront} node the node we want the siblings from.
-   */
-  openSiblingMenu: function(button, node) {
-    // We make sure that the targeted node is selected
-    // because we want to use the nodemenu that only works
-    // for inspector.selection
-    this.navigateTo(node);
-
-    // Build a list of extra menu items that will be appended at the end of the
-    // inspector node context menu.
-    let items = [this.chromeDoc.createElement("menuseparator")];
-
-    this.walker.siblings(node, {
-      whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-    }).then(siblings => {
-      let nodes = siblings.nodes;
-      for (let i = 0; i < nodes.length; i++) {
-        // Skip siblings of the documentElement node.
-        if (nodes[i].nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
-          continue;
-        }
-
-        let item = this.chromeDoc.createElement("menuitem");
-        if (nodes[i] === node) {
-          item.setAttribute("disabled", "true");
-          item.setAttribute("checked", "true");
-        }
-
-        item.setAttribute("type", "radio");
-        item.setAttribute("label", this.prettyPrintNodeAsText(nodes[i]));
-
-        let self = this;
-        item.onmouseup = (function(node) {
-          return function() {
-            self.navigateTo(node);
-          };
-        })(nodes[i]);
-
-        items.push(item);
-      }
-
-      // Append the items to the inspector node context menu and show the menu.
-      this.inspector.showNodeMenu(button, "before_start", items);
-    });
-  },
-
-  /**
    * Generic event handler.
    * @param {DOMEvent} event.
    */
-  handleEvent: function(event) {
-    if (event.type == "mousedown" && event.button == 0) {
-      this.handleMouseDown(event);
+  handleEvent: function (event) {
+    if (event.type == "click" && event.button == 0) {
+      this.handleClick(event);
     } else if (event.type == "keypress" && this.selection.isElementNode()) {
       this.handleKeyPress(event);
     } else if (event.type == "mouseover") {
       this.handleMouseOver(event);
     } else if (event.type == "mouseleave") {
       this.handleMouseLeave(event);
     } else if (event.type == "focus") {
       this.handleFocus(event);
     }
   },
 
   /**
    * Focus event handler. When breadcrumbs container gets focus, if there is an
    * already selected breadcrumb, move focus to it.
    * @param {DOMEvent} event.
    */
-  handleFocus: function(event) {
+  handleFocus: function (event) {
     let control = this.container.querySelector(
       ".breadcrumbs-widget-item[checked]");
     if (control && control !== event.target) {
       // If we already have a selected breadcrumb and focus target is not it,
       // move focus to selected breadcrumb.
       event.preventDefault();
       control.focus();
     }
   },
 
   /**
-   * On click and hold, open the siblings menu.
+   * On click navigate to the correct node.
    * @param {DOMEvent} event.
    */
-  handleMouseDown: function(event) {
-    let timer;
-    let container = this.container;
-
-    function openMenu(event) {
-      cancelHold();
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsHold();
-      }
+  handleClick: function (event) {
+    let target = event.originalTarget;
+    if (target.tagName == "button") {
+      target.onBreadcrumbsClick();
     }
-
-    function handleClick(event) {
-      cancelHold();
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsClick();
-      }
-    }
-
-    let window = this.chromeWin;
-    function cancelHold(event) {
-      window.clearTimeout(timer);
-      container.removeEventListener("mouseout", cancelHold, false);
-      container.removeEventListener("mouseup", handleClick, false);
-    }
-
-    container.addEventListener("mouseout", cancelHold, false);
-    container.addEventListener("mouseup", handleClick, false);
-    timer = window.setTimeout(openMenu, 500, event);
   },
 
   /**
    * On mouse over, highlight the corresponding content DOM Node.
    * @param {DOMEvent} event.
    */
-  handleMouseOver: function(event) {
+  handleMouseOver: function (event) {
     let target = event.originalTarget;
     if (target.tagName == "button") {
       target.onBreadcrumbsHover();
     }
   },
 
   /**
    * On mouse leave, make sure to unhighlight.
    * @param {DOMEvent} event.
    */
-  handleMouseLeave: function(event) {
+  handleMouseLeave: function (event) {
     this.inspector.toolbox.highlighterUtils.unhighlight();
   },
 
   /**
    * On key press, navigate the node hierarchy.
    * @param {DOMEvent} event.
    */
-  handleKeyPress: function(event) {
+  handleKeyPress: function (event) {
     let navigate = promise.resolve(null);
 
     this._keyPromise = (this._keyPromise || promise.resolve(null)).then(() => {
       switch (event.keyCode) {
         case this.chromeWin.KeyEvent.DOM_VK_LEFT:
           if (this.currentIndex != 0) {
             navigate = promise.resolve(
               this.nodeHierarchy[this.currentIndex - 1].node);
@@ -428,25 +356,27 @@ HTMLBreadcrumbs.prototype = {
 
     event.preventDefault();
     event.stopPropagation();
   },
 
   /**
    * Remove nodes and clean up.
    */
-  destroy: function() {
+  destroy: function () {
     this.selection.off("new-node-front", this.update);
     this.selection.off("pseudoclass", this.updateSelectors);
     this.selection.off("attribute-changed", this.updateSelectors);
     this.inspector.off("markupmutation", this.update);
 
-    this.container.removeEventListener("underflow", this.onscrollboxreflow, false);
-    this.container.removeEventListener("overflow", this.onscrollboxreflow, false);
-    this.container.removeEventListener("mousedown", this, true);
+    this.container.removeEventListener("underflow",
+        this.onscrollboxreflow, false);
+    this.container.removeEventListener("overflow",
+        this.onscrollboxreflow, false);
+    this.container.removeEventListener("click", this, true);
     this.container.removeEventListener("keypress", this, true);
     this.container.removeEventListener("mouseover", this, true);
     this.container.removeEventListener("mouseleave", this, true);
     this.container.removeEventListener("focus", this, true);
 
     this.empty();
     this.separators.remove();
 
@@ -456,119 +386,114 @@ HTMLBreadcrumbs.prototype = {
     this.nodeHierarchy = null;
 
     this.isDestroyed = true;
   },
 
   /**
    * Empty the breadcrumbs container.
    */
-  empty: function() {
+  empty: function () {
     while (this.container.hasChildNodes()) {
       this.container.firstChild.remove();
     }
   },
 
   /**
    * Set which button represent the selected node.
    * @param {Number} index Index of the displayed-button to select.
    */
-  setCursor: function(index) {
+  setCursor: function (index) {
     // Unselect the previously selected button
-    if (this.currentIndex > -1 && this.currentIndex < this.nodeHierarchy.length) {
+    if (this.currentIndex > -1
+        && this.currentIndex < this.nodeHierarchy.length) {
       this.nodeHierarchy[this.currentIndex].button.removeAttribute("checked");
     }
     if (index > -1) {
       this.nodeHierarchy[index].button.setAttribute("checked", "true");
       if (this.hadFocus) {
         this.nodeHierarchy[index].button.focus();
       }
     }
     this.currentIndex = index;
   },
 
   /**
    * Get the index of the node in the cache.
    * @param {NodeFront} node.
    * @returns {Number} The index for this node or -1 if not found.
    */
-  indexOf: function(node) {
+  indexOf: function (node) {
     for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
       if (this.nodeHierarchy[i].node === node) {
         return i;
       }
     }
     return -1;
   },
 
   /**
    * Remove all the buttons and their references in the cache after a given
    * index.
    * @param {Number} index.
    */
-  cutAfter: function(index) {
+  cutAfter: function (index) {
     while (this.nodeHierarchy.length > (index + 1)) {
       let toRemove = this.nodeHierarchy.pop();
       this.container.removeChild(toRemove.button);
     }
   },
 
-  navigateTo: function(node) {
+  navigateTo: function (node) {
     if (node) {
       this.selection.setNodeFront(node, "breadcrumbs");
     } else {
       this.inspector.emit("breadcrumbs-navigation-cancelled");
     }
   },
 
   /**
    * Build a button representing the node.
    * @param {NodeFront} node The node from the page.
    * @return {DOMNode} The <button> for this node.
    */
-  buildButton: function(node) {
+  buildButton: function (node) {
     let button = this.chromeDoc.createElement("button");
     button.appendChild(this.prettyPrintNodeAsXUL(node));
     button.className = "breadcrumbs-widget-item";
 
     button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(node));
 
     button.onkeypress = function onBreadcrumbsKeypress(e) {
       if (e.charCode == Ci.nsIDOMKeyEvent.DOM_VK_SPACE ||
           e.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
         button.click();
       }
     };
 
+    button.onclick = () => {
+      button.focus();
+    };
+
     button.onBreadcrumbsClick = () => {
       this.navigateTo(node);
     };
 
     button.onBreadcrumbsHover = () => {
       this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
     };
 
-    button.onclick = (function _onBreadcrumbsRightClick(event) {
-      button.focus();
-      if (event.button == 2) {
-        this.openSiblingMenu(button, node);
-      }
-    }).bind(this);
-
-    button.onBreadcrumbsHold = (function _onBreadcrumbsHold() {
-      this.openSiblingMenu(button, node);
-    }).bind(this);
     return button;
   },
 
   /**
    * Connecting the end of the breadcrumbs to a node.
    * @param {NodeFront} node The node to reach.
    */
-  expand: function(node) {
+  expand: function (node) {
     let fragment = this.chromeDoc.createDocumentFragment();
     let lastButtonInserted = null;
     let originalLength = this.nodeHierarchy.length;
     let stopNode = null;
     if (originalLength > 0) {
       stopNode = this.nodeHierarchy[originalLength - 1].node;
     }
     while (node && node != stopNode) {
@@ -588,37 +513,37 @@ HTMLBreadcrumbs.prototype = {
   },
 
   /**
    * Get a child of a node that can be displayed in the breadcrumbs and that is
    * probably visible. See LOW_PRIORITY_ELEMENTS.
    * @param {NodeFront} node The parent node.
    * @return {Promise} Resolves to the NodeFront.
    */
-  getInterestingFirstNode: function(node) {
+  getInterestingFirstNode: function (node) {
     let deferred = promise.defer();
 
     let fallback = null;
     let lastNode = null;
 
     let moreChildren = () => {
       this.walker.children(node, {
         start: lastNode,
         maxNodes: 10,
         whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
       }).then(this.selectionGuard()).then(response => {
-        for (let node of response.nodes) {
-          if (!(node.tagName in LOW_PRIORITY_ELEMENTS)) {
-            deferred.resolve(node);
+        for (let childNode of response.nodes) {
+          if (!(childNode.tagName in LOW_PRIORITY_ELEMENTS)) {
+            deferred.resolve(childNode);
             return;
           }
           if (!fallback) {
-            fallback = node;
+            fallback = childNode;
           }
-          lastNode = node;
+          lastNode = childNode;
         }
         if (response.hasLast) {
           deferred.resolve(fallback);
           return;
         }
         moreChildren();
       }).catch(this.selectionGuardEnd);
     };
@@ -627,33 +552,33 @@ HTMLBreadcrumbs.prototype = {
     return deferred.promise;
   },
 
   /**
    * Find the "youngest" ancestor of a node which is already in the breadcrumbs.
    * @param {NodeFront} node.
    * @return {Number} Index of the ancestor in the cache, or -1 if not found.
    */
-  getCommonAncestor: function(node) {
+  getCommonAncestor: function (node) {
     while (node) {
       let idx = this.indexOf(node);
       if (idx > -1) {
         return idx;
       }
       node = node.parentNode();
     }
     return -1;
   },
 
   /**
    * Make sure that the latest node in the breadcrumbs is not the selected node
    * if the selected node still has children.
    * @return {Promise}
    */
-  ensureFirstChild: function() {
+  ensureFirstChild: function () {
     // If the last displayed node is the selected node
     if (this.currentIndex == this.nodeHierarchy.length - 1) {
       let node = this.nodeHierarchy[this.currentIndex].node;
       return this.getInterestingFirstNode(node).then(child => {
         // If the node has a child and we've not been destroyed in the meantime
         if (child && !this.isDestroyed) {
           // Show this child
           this.expand(child);
@@ -662,34 +587,34 @@ HTMLBreadcrumbs.prototype = {
     }
 
     return waitForTick().then(() => true);
   },
 
   /**
    * Ensure the selected node is visible.
    */
-  scroll: function() {
+  scroll: function () {
     // FIXME bug 684352: make sure its immediate neighbors are visible too.
 
     let scrollbox = this.container;
     let element = this.nodeHierarchy[this.currentIndex].button;
 
     // Repeated calls to ensureElementIsVisible would interfere with each other
     // and may sometimes result in incorrect scroll positions.
     this.chromeWin.clearTimeout(this._ensureVisibleTimeout);
-    this._ensureVisibleTimeout = this.chromeWin.setTimeout(function() {
+    this._ensureVisibleTimeout = this.chromeWin.setTimeout(function () {
       scrollbox.ensureElementIsVisible(element);
-    }, ENSURE_SELECTION_VISIBLE_DELAY);
+    }, ENSURE_SELECTION_VISIBLE_DELAY_MS);
   },
 
   /**
    * Update all button outputs.
    */
-  updateSelectors: function() {
+  updateSelectors: function () {
     if (this.isDestroyed) {
       return;
     }
 
     for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
       let {node, button, currentPrettyPrintText} = this.nodeHierarchy[i];
 
       // If the output of the node doesn't change, skip the update.
@@ -712,17 +637,17 @@ HTMLBreadcrumbs.prototype = {
   /**
    * Given a list of mutation changes (passed by the markupmutation event),
    * decide whether or not they are "interesting" to the current state of the
    * breadcrumbs widget, i.e. at least one of them should cause part of the
    * widget to be updated.
    * @param {Array} mutations The mutations array.
    * @return {Boolean}
    */
-  _hasInterestingMutations: function(mutations) {
+  _hasInterestingMutations: function (mutations) {
     if (!mutations || !mutations.length) {
       return false;
     }
 
     for (let {type, added, removed, target, attributeName} of mutations) {
       if (type === "childList") {
         // Only interested in childList mutations if the added or removed
         // nodes are currently displayed, or if it impacts the last element in
@@ -743,17 +668,17 @@ HTMLBreadcrumbs.prototype = {
   },
 
   /**
    * Update the breadcrumbs display when a new node is selected.
    * @param {String} reason The reason for the update, if any.
    * @param {Array} mutations An array of mutations in case this was called as
    * the "markupmutation" event listener.
    */
-  update: function(reason, mutations) {
+  update: function (reason, mutations) {
     if (this.isDestroyed) {
       return;
     }
 
     if (reason !== "markupmutation") {
       this.inspector.hideNodeMenu();
     }
 
@@ -786,33 +711,33 @@ HTMLBreadcrumbs.prototype = {
       // Yes. We select it.
       this.setCursor(idx);
     } else {
       // No. Is the breadcrumbs display empty?
       if (this.nodeHierarchy.length > 0) {
         // No. We drop all the element that are not direct ancestors
         // of the selection
         let parent = this.selection.nodeFront.parentNode();
-        let idx = this.getCommonAncestor(parent);
-        this.cutAfter(idx);
+        let ancestorIdx = this.getCommonAncestor(parent);
+        this.cutAfter(ancestorIdx);
       }
       // we append the missing button between the end of the breadcrumbs display
       // and the current node.
       this.expand(this.selection.nodeFront);
 
       // we select the current node button
       idx = this.indexOf(this.selection.nodeFront);
       this.setCursor(idx);
     }
 
     let doneUpdating = this.inspector.updating("breadcrumbs");
     // Add the first child of the very last node of the breadcrumbs if possible.
     this.ensureFirstChild().then(this.selectionGuard()).then(() => {
       if (this.isDestroyed) {
-        return;
+        return null;
       }
 
       this.updateSelectors();
 
       // Make sure the selected node and its neighbours are visible.
       this.scroll();
       return waitForTick().then(() => {
         this.inspector.emit("breadcrumbs-updated", this.selection.nodeFront);
diff --git a/devtools/client/inspector/inspector.xul b/devtools/client/inspector/inspector.xul
--- a/devtools/client/inspector/inspector.xul
+++ b/devtools/client/inspector/inspector.xul
@@ -33,17 +33,17 @@
   <keyset>
     <key id="nodeSearchKey"
       key="&inspectorSearchHTML.key;"
       modifiers="accel"
       command="nodeSearchCommand"/>
   </keyset>
 
   <popupset id="inspectorPopupSet">
-    <!-- Used by the Markup Panel, the Highlighter and the Breadcrumbs -->
+    <!-- Used by the Markup Panel and the Highlighter -->
     <menupopup id="inspector-node-popup">
       <menuitem id="node-menu-edithtml"
         label="&inspectorHTMLEdit.label;"
         accesskey="&inspectorHTMLEdit.accesskey;"
         oncommand="inspector.editHTML()"/>
       <menuitem id="node-menu-add"
         label="&inspectorAddNode.label;"
         accesskey="&inspectorAddNode.accesskey;"
diff --git a/devtools/client/inspector/test/browser.ini b/devtools/client/inspector/test/browser.ini
--- a/devtools/client/inspector/test/browser.ini
+++ b/devtools/client/inspector/test/browser.ini
@@ -40,17 +40,16 @@ support-files =
 [browser_inspector_addNode_01.js]
 [browser_inspector_addNode_02.js]
 [browser_inspector_addNode_03.js]
 [browser_inspector_breadcrumbs.js]
 [browser_inspector_breadcrumbs_highlight_hover.js]
 [browser_inspector_breadcrumbs_keybinding.js]
 [browser_inspector_breadcrumbs_keyboard_trap.js]
 skip-if = os == "mac" # Full keyboard navigation on OSX only works if Full Keyboard Access setting is set to All Control in System Keyboard Preferences
-[browser_inspector_breadcrumbs_menu.js]
 [browser_inspector_breadcrumbs_mutations.js]
 [browser_inspector_delete-selected-node-01.js]
 [browser_inspector_delete-selected-node-02.js]
 [browser_inspector_delete-selected-node-03.js]
 [browser_inspector_destroy-after-navigation.js]
 [browser_inspector_destroy-before-ready.js]
 [browser_inspector_expand-collapse.js]
 [browser_inspector_gcli-inspect-command.js]
diff --git a/devtools/client/inspector/test/browser_inspector_breadcrumbs_menu.js b/devtools/client/inspector/test/browser_inspector_breadcrumbs_menu.js
deleted file mode 100644
--- a/devtools/client/inspector/test/browser_inspector_breadcrumbs_menu.js
+++ /dev/null
@@ -1,51 +0,0 @@
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-// Test that the inspector node context menu appears when right-clicking on the
-// breadcrumbs nodes.
-
-const TEST_URI = URL_ROOT + "doc_inspector_breadcrumbs.html";
-
-add_task(function*() {
-  let {inspector} = yield openInspectorForURL(TEST_URI);
-  let container = inspector.panelDoc.getElementById("inspector-breadcrumbs");
-
-  info("Select a test node and try to right-click on the selected breadcrumb");
-  yield selectNode("#i1", inspector);
-  let button = container.querySelector("button[checked]");
-
-  let onMenuShown = once(inspector.nodemenu, "popupshown");
-  button.onclick({button: 2});
-  yield onMenuShown;
-
-  ok(true, "The context menu appeared on right-click");
-
-  info("Right-click on a non selected crumb (the body node)");
-  button = button.previousSibling;
-  onMenuShown = once(inspector.nodemenu, "popupshown");
-  let onInspectorUpdated = inspector.once("inspector-updated");
-  button.onclick({button: 2});
-
-  yield onMenuShown;
-  ok(true, "The context menu appeared on right-click");
-
-  yield onInspectorUpdated;
-  is(inspector.selection.nodeFront.tagName.toLowerCase(), "body",
-     "The body node was selected when right-clicking in the breadcrumbs");
-
-  info("Right-click on the html node");
-  button = button.previousSibling;
-  onMenuShown = once(inspector.nodemenu, "popupshown");
-  onInspectorUpdated = inspector.once("inspector-updated");
-  button.onclick({button: 2});
-
-  yield onMenuShown;
-  ok(true, "The context menu appeared on right-click");
-
-  yield onInspectorUpdated;
-  is(inspector.selection.nodeFront.tagName.toLowerCase(), "html",
-     "The html node was selected when right-clicking in the breadcrumbs");
-});
