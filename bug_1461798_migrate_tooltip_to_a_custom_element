# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1533844070 25200
#      Thu Aug 09 12:47:50 2018 -0700
# Node ID 46edf5c00c3604c686074c5dc6e032cd4c70d50c
# Parent  f650c0df72f9f1dc616bb1510a36f894400e8b84
Bug 1461798 - Migrate <tooltip> to a Custom Element

MozReview-Commit-ID: 7dtkC0XO0JQ

diff --git a/toolkit/content/widgets/general.js b/toolkit/content/widgets/general.js
--- a/toolkit/content/widgets/general.js
+++ b/toolkit/content/widgets/general.js
@@ -61,9 +61,141 @@ class MozCommandSet extends MozXULElemen
     if (this.getAttribute("commandupdater") === "true") {
       document.commandDispatcher.removeCommandUpdater(this);
     }
   }
 }
 
 customElements.define("commandset", MozCommandSet);
 
+/* globals XULPopupElement */
+
+class MozTooltip extends XULPopupElement {
+
+  static get observedAttributes() { return ["label"]; }
+
+  connectedCallback() {
+    if (!this.firstElementChild) {
+      this.appendChild(MozXULElement.parseXULToFragment(`
+        <label class="tooltip-label" flex="1"></label>
+      `));
+      this._labelElement = this.querySelector(".tooltip-label");
+    }
+
+    this._mouseOutCount = 0;
+    this._isMouseOver = false;
+    this._setupEventListeners();
+  }
+
+  attributeChangedCallback() {
+    if (this._labelElement) {
+      this._labelElement.textContent = this.label;
+    }
+
+  }
+
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set page(val) {
+    if (val) this.setAttribute("page", "true");
+    else this.removeAttribute("page");
+    return val;
+  }
+
+  get page() {
+    return this.getAttribute("page") == "true";
+  }
+
+  get textProvider() {
+    if (!this._textProvider) {
+      this._textProvider = Cc["@mozilla.org/embedcomp/default-tooltiptextprovider;1"]
+        .getService(Ci.nsITooltipTextProvider);
+    }
+    return this._textProvider;
+  }
+
+  /**
+   * Given the supplied element within a page, set the tooltip's text to the text
+   * for that element. Returns true if text was assigned, and false if the no text
+   * is set, which normally would be used to cancel tooltip display.
+   */
+  fillInPageTooltip(tipElement) {
+    let tttp = this.textProvider;
+    let textObj = {},
+      dirObj = {};
+    let shouldChangeText = tttp.getNodeText(tipElement, textObj, dirObj);
+    if (shouldChangeText) {
+      this.style.direction = dirObj.value;
+      this.label = textObj.value;
+    }
+    return shouldChangeText;
+  }
+
+  _setupEventListeners() {
+    this.addEventListener("mouseover", (event) => {
+      var rel = event.relatedTarget;
+      if (!rel)
+        return;
+
+      // find out if the node we entered from is one of our anonymous children
+      while (rel) {
+        if (rel == this)
+          break;
+        rel = rel.parentNode;
+      }
+
+      // if the exited node is not a descendant of ours, we are entering for the first time
+      if (rel != this)
+        this._isMouseOver = true;
+    });
+
+    this.addEventListener("mouseout", (event) => {
+      var rel = event.relatedTarget;
+
+      // relatedTarget is null when the titletip is first shown: a mouseout event fires
+      // because the mouse is exiting the main window and entering the titletip "window".
+      // relatedTarget is also null when the mouse exits the main window completely,
+      // so count how many times relatedTarget was null after titletip is first shown
+      // and hide popup the 2nd time
+      if (!rel) {
+        ++this._mouseOutCount;
+        if (this._mouseOutCount > 1)
+          this.hidePopup();
+        return;
+      }
+
+      // find out if the node we are entering is one of our anonymous children
+      while (rel) {
+        if (rel == this)
+          break;
+        rel = rel.parentNode;
+      }
+
+      // if the entered node is not a descendant of ours, hide the tooltip
+      if (rel != this && this._isMouseOver) {
+        this.hidePopup();
+      }
+    });
+
+    this.addEventListener("popupshowing", (event) => {
+      if (this.page && !this.fillInPageTooltip(this.triggerNode)) {
+        event.preventDefault();
+      }
+    });
+
+    this.addEventListener("popuphiding", (event) => {
+      this._isMouseOver = false;
+      this._mouseOutCount = 0;
+    });
+
+  }
 }
+
+customElements.define("tooltip", MozTooltip);
+
+}
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -258,128 +258,16 @@
         }
       </handler>
       <handler event="popuppositioned" phase="target">
         this.adjustArrowPosition();
       </handler>
     </handlers>
   </binding>
 
-  <binding id="tooltip">
-    <content>
-      <children>
-        <xul:label class="tooltip-label" xbl:inherits="xbl:text=label" flex="1"/>
-      </children>
-    </content>
-
-    <implementation>
-      <field name="_mouseOutCount">0</field>
-      <field name="_isMouseOver">false</field>
-
-      <property name="label"
-                onget="return this.getAttribute('label');"
-                onset="this.setAttribute('label', val); return val;"/>
-
-      <property name="page" onset="if (val) this.setAttribute('page', 'true');
-                                   else this.removeAttribute('page');
-                                   return val;"
-                            onget="return this.getAttribute('page') == 'true';"/>
-      <property name="textProvider"
-                readonly="true">
-        <getter>
-        <![CDATA[
-          if (!this._textProvider) {
-            this._textProvider = Cc["@mozilla.org/embedcomp/default-tooltiptextprovider;1"]
-                                 .getService(Ci.nsITooltipTextProvider);
-          }
-          return this._textProvider;
-        ]]>
-        </getter>
-      </property>
-
-      <!-- Given the supplied element within a page, set the tooltip's text to the text
-           for that element. Returns true if text was assigned, and false if the no text
-           is set, which normally would be used to cancel tooltip display.
-        -->
-      <method name="fillInPageTooltip">
-        <parameter name="tipElement"/>
-        <body>
-        <![CDATA[
-          let tttp = this.textProvider;
-          let textObj = {}, dirObj = {};
-          let shouldChangeText = tttp.getNodeText(tipElement, textObj, dirObj);
-          if (shouldChangeText) {
-            this.style.direction = dirObj.value;
-            this.label = textObj.value;
-          }
-          return shouldChangeText;
-        ]]>
-        </body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <handler event="mouseover"><![CDATA[
-        var rel = event.relatedTarget;
-        if (!rel)
-          return;
-
-        // find out if the node we entered from is one of our anonymous children
-        while (rel) {
-          if (rel == this)
-            break;
-          rel = rel.parentNode;
-        }
-
-        // if the exited node is not a descendant of ours, we are entering for the first time
-        if (rel != this)
-          this._isMouseOver = true;
-      ]]></handler>
-
-      <handler event="mouseout"><![CDATA[
-        var rel = event.relatedTarget;
-
-        // relatedTarget is null when the titletip is first shown: a mouseout event fires
-        // because the mouse is exiting the main window and entering the titletip "window".
-        // relatedTarget is also null when the mouse exits the main window completely,
-        // so count how many times relatedTarget was null after titletip is first shown
-        // and hide popup the 2nd time
-        if (!rel) {
-          ++this._mouseOutCount;
-          if (this._mouseOutCount > 1)
-            this.hidePopup();
-          return;
-        }
-
-        // find out if the node we are entering is one of our anonymous children
-        while (rel) {
-          if (rel == this)
-            break;
-          rel = rel.parentNode;
-        }
-
-        // if the entered node is not a descendant of ours, hide the tooltip
-        if (rel != this && this._isMouseOver) {
-          this.hidePopup();
-        }
-      ]]></handler>
-
-      <handler event="popupshowing"><![CDATA[
-        if (this.page && !this.fillInPageTooltip(this.triggerNode)) {
-          event.preventDefault();
-        }
-      ]]></handler>
-
-      <handler event="popuphiding"><![CDATA[
-        this._isMouseOver = false;
-        this._mouseOutCount = 0;
-      ]]></handler>
-    </handlers>
-  </binding>
-
   <binding id="popup-scrollbars" extends="chrome://global/content/bindings/popup.xml#popup">
     <content>
       <xul:scrollbox class="popup-internal-box" flex="1" orient="vertical" style="overflow: auto;">
         <children/>
       </xul:scrollbox>
     </content>
     <implementation>
       <field name="AUTOSCROLL_INTERVAL">25</field>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -364,17 +364,16 @@ menupopup,
 panel,
 tooltip {
   display: -moz-popup;
   z-index: 2147483647;
   text-shadow: none;
 }
 
 tooltip {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#tooltip");
   -moz-box-orient: vertical;
   white-space: pre-wrap;
   margin-top: 21px;
 }
 
 panel[type="arrow"] {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
 }
