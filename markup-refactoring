# HG changeset patch
# Parent 6d3a2bbf10ba8911e215c3dac72644e275ddf290
# User Brian Grinstead <bgrinstead@mozilla.com>
more refactoring

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -18,16 +18,17 @@ const NEW_SELECTION_HIGHLIGHTER_TIMER = 
 
 const {UndoStack} = require("devtools/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/markupview/html-editor");
 const promise = require("devtools/toolkit/deprecated-sync-thenables");
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const EventEmitter = require("devtools/toolkit/event-emitter");
+const Heritage = require("sdk/core/heritage");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
@@ -258,34 +259,34 @@ MarkupView.prototype = {
   },
 
   /**
    * Executed when the mouse hovers over a target in the markup-view and is used
    * to decide whether this target should be used to display an image preview
    * tooltip.
    * Delegates the actual decision to the corresponding MarkupContainer instance
    * if one is found.
-   * @return the promise returned by MarkupContainer._isImagePreviewTarget
+   * @return the promise returned by MarkupElementContainer._isImagePreviewTarget
    */
   _isImagePreviewTarget: function(target) {
     // From the target passed here, let's find the parent MarkupContainer
     // and ask it if the tooltip should be shown
     let parent = target, container;
     while (parent !== this.doc.body) {
       if (parent.container) {
         container = parent.container;
         break;
       }
       parent = parent.parentNode;
     }
 
-    if (container && container._isImagePreviewTarget) {
+    if (container instanceof MarkupElementContainer) {
       // With the newly found container, delegate the tooltip content creation
       // and decision to show or not the tooltip
-      return container._isImagePreviewTarget(target, this.tooltip);
+      return container.isImagePreviewTarget(target, this.tooltip);
     }
   },
 
   /**
    * Given the known reason, should the current selection be briefly highlighted
    * In a few cases, we don't want to highlight the node:
    * - If the reason is null (used to reset the selection),
    * - if it's "inspector-open" (when the inspector opens up, let's not highlight
@@ -540,25 +541,33 @@ MarkupView.prototype = {
     if (!aNode) {
       return null;
     }
 
     if (this._containers.has(aNode)) {
       return this.getContainer(aNode);
     }
 
+    let container;
+    let {nodeType, isPseudoElement} = aNode;
     if (aNode === this.walker.rootNode) {
-      var container = new RootContainer(this, aNode);
+      container = new RootContainer(this, aNode);
       this._elt.appendChild(container.elt);
       this._rootNode = aNode;
+    } else if (nodeType == Ci.nsIDOMNode.ELEMENT_NODE && !isPseudoElement) {
+      container = new MarkupElementContainer(this, aNode, this._inspector);
+    } else if (nodeType == Ci.nsIDOMNode.COMMENT_NODE ||
+               nodeType == Ci.nsIDOMNode.TEXT_NODE) {
+      container = new MarkupTextContainer(this, aNode, this._inspector);
     } else {
-      var container = new MarkupContainer(this, aNode, this._inspector);
-      if (aFlashNode) {
-        container.flashMutation();
-      }
+      container = new MarkupReadOnlyContainer(this, aNode, this._inspector);
+    }
+
+    if (aFlashNode) {
+      container.flashMutation();
     }
 
     this._containers.set(aNode, container);
     container.childrenDirty = true;
 
     this._updateChildren(container);
 
     return container;
@@ -1259,86 +1268,66 @@ MarkupView.prototype = {
 
     win.setTimeout(() => {
       this._updatePreview();
       this._previewBar.classList.remove("hide");
     }, 1000);
   }
 };
 
-
 /**
  * The main structure for storing a document node in the markup
  * tree.  Manages creation of the editor for the node and
  * a <ul> for placing child elements, and expansion/collapsing
  * of the element.
  *
- * @param MarkupView aMarkupView
- *        The markup view that owns this container.
- * @param NodeFront aNode
- *        The node to display.
- * @param Inspector aInspector
- *        The inspector tool container the markup-view
+ * This should not be instantiated directly, instead use one of:
+ *    MarkupReadOnlyContainer
+ *    MarkupTextContainer
+ *    MarkupElementContainer
  */
-
-
-function MarkupContainer(aMarkupView, aNode, aInspector) {
-  this.markup = aMarkupView;
-  this.doc = this.markup.doc;
-  this.undo = this.markup.undo;
-  this.node = aNode;
-  this._inspector = aInspector;
-
-  if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
-    this.editor = new TextEditor(this, aNode, "text");
-  } else if (aNode.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
-    this.editor = new TextEditor(this, aNode, "comment");
-  } else if (aNode.isPseudoElement) {
-    this.editor = new PseudoElementEditor(this, aNode);
-  }  else if (aNode.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
-    this.editor = new ElementEditor(this, aNode);
-  } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
-    this.editor = new DoctypeEditor(this, aNode);
-  } else {
-    this.editor = new GenericEditor(this, aNode);
-  }
-
-  // The template will fill the following properties
-  this.elt = null;
-  this.expander = null;
-  this.tagState = null;
-  this.tagLine = null;
-  this.children = null;
-  this.markup.template("container", this);
-  this.elt.container = this;
-  this.children.container = this;
-
-  if (aNode.isPseudoElement) {
-    this.expander.remove();
-  }
-
-  // Expanding/collapsing the node on dblclick of the whole tag-line element
-  this._onToggle = this._onToggle.bind(this);
-  this.elt.addEventListener("dblclick", this._onToggle, false);
-  this.expander.addEventListener("click", this._onToggle, false);
-
-  // Appending the editor element and attaching event listeners
-  this.tagLine.appendChild(this.editor.elt);
-
-  this._onMouseDown = this._onMouseDown.bind(this);
-  this.elt.addEventListener("mousedown", this._onMouseDown, false);
-
-  // Prepare the image preview tooltip data if any
-  this._prepareImagePreview();
-
-  // Marking the node as shown or hidden
-  this.isDisplayed = this.node.isDisplayed;
-}
+function MarkupContainer() { }
 
 MarkupContainer.prototype = {
+
+  /*
+   * Initialize the MarkupContainer.  Should be called while one
+   * of the other contain classes is instantiated.
+   *
+   * @param MarkupView markupView
+   *        The markup view that owns this container.
+   * @param NodeFront node
+   *        The node to display.
+   * @param string templateID
+   *        Which template to render for this container
+   */
+  initialize: function(markupView, node, templateID) {
+    this.markup = markupView;
+    this.node = node;
+
+    // The template will fill the following properties
+    this.elt = null;
+    this.expander = null;
+    this.tagState = null;
+    this.tagLine = null;
+    this.children = null;
+    this.markup.template(templateID, this);
+    this.elt.container = this;
+
+    // Binding event listeners
+    this._onMouseDown = this._onMouseDown.bind(this);
+    this.elt.addEventListener("mousedown", this._onMouseDown, false);
+
+    this._onToggle = this._onToggle.bind(this);
+    this.elt.addEventListener("dblclick", this._onToggle, false);
+
+    // Marking the node as shown or hidden
+    this.isDisplayed = this.node.isDisplayed;
+  },
+
   toString: function() {
     return "[MarkupContainer for " + this.node + "]";
   },
 
   isPreviewable: function() {
     if (this.node.tagName && !this.node.isPseudoElement) {
       let tagName = this.node.tagName.toLowerCase();
       let srcAttr = this.editor.getAttributeElement("src");
@@ -1347,161 +1336,33 @@ MarkupContainer.prototype = {
 
       return isImage || isCanvas;
     } else {
       return false;
     }
   },
 
   /**
-   * If the node is an image or canvas (@see isPreviewable), then get the
-   * image data uri from the server so that it can then later be previewed in
-   * a tooltip if needed.
-   * Stores a promise in this.tooltipData.data that resolves when the data has
-   * been retrieved
-   */
-  _prepareImagePreview: function() {
-    if (this.isPreviewable()) {
-      // Get the image data for later so that when the user actually hovers over
-      // the element, the tooltip does contain the image
-      let def = promise.defer();
-
-      this.tooltipData = {
-        target: this.editor.getAttributeElement("src") || this.editor.tag,
-        data: def.promise
-      };
-
-      let maxDim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");
-      this.node.getImageData(maxDim).then(data => {
-        data.data.string().then(str => {
-          let res = {data: str, size: data.size};
-          // Resolving the data promise and, to always keep tooltipData.data
-          // as a promise, create a new one that resolves immediately
-          def.resolve(res);
-          this.tooltipData.data = promise.resolve(res);
-        });
-      }, () => {
-        this.tooltipData.data = promise.reject();
-      });
-    }
-  },
-
-  /**
-   * Executed by MarkupView._isImagePreviewTarget which is itself called when the
-   * mouse hovers over a target in the markup-view.
-   * Checks if the target is indeed something we want to have an image tooltip
-   * preview over and, if so, inserts content into the tooltip.
-   * @return a promise that resolves when the content has been inserted or
-   * rejects if no preview is required. This promise is then used by Tooltip.js
-   * to decide if/when to show the tooltip
-   */
-  _isImagePreviewTarget: function(target, tooltip) {
-    if (!this.tooltipData || this.tooltipData.target !== target) {
-      return promise.reject();
-    }
-
-    return this.tooltipData.data.then(({data, size}) => {
-      tooltip.setImageContent(data, size);
-    }, () => {
-      tooltip.setBrokenImageContent();
-    });
-  },
-
-  /**
    * Show the element has displayed or not
    */
   set isDisplayed(isDisplayed) {
     this.elt.classList.remove("not-displayed");
     if (!isDisplayed) {
       this.elt.classList.add("not-displayed");
     }
   },
 
-  copyImageDataUri: function() {
-    // We need to send again a request to gettooltipData even if one was sent for
-    // the tooltip, because we want the full-size image
-    this.node.getImageData().then(data => {
-      data.data.string().then(str => {
-        clipboardHelper.copyString(str, this.markup.doc);
-      });
-    });
-  },
-
-  /**
-   * True if the current node has children.  The MarkupView
-   * will set this attribute for the MarkupContainer.
-   */
-  _hasChildren: false,
-
-  get hasChildren() {
-    return this._hasChildren;
-  },
-
-  set hasChildren(aValue) {
-    this._hasChildren = aValue;
-    if (aValue) {
-      this.expander.style.visibility = "visible";
-    } else {
-      this.expander.style.visibility = "hidden";
-    }
-  },
+  /* Other containers can choose to implement these */
+  hasChildren: false,
+  expanded: false,
 
   parentContainer: function() {
     return this.elt.parentNode ? this.elt.parentNode.container : null;
   },
 
-  /**
-   * True if the node has been visually expanded in the tree.
-   */
-  get expanded() {
-    return !this.elt.classList.contains("collapsed");
-  },
-
-  set expanded(aValue) {
-    if (aValue && this.elt.classList.contains("collapsed")) {
-      // Expanding a node means cloning its "inline" closing tag into a new
-      // tag-line that the user can interact with and showing the children.
-      if (this.editor instanceof ElementEditor) {
-        let closingTag = this.elt.querySelector(".close");
-        if (closingTag) {
-          if (!this.closeTagLine) {
-            let line = this.markup.doc.createElement("div");
-            line.classList.add("tag-line");
-
-            let tagState = this.markup.doc.createElement("div");
-            tagState.classList.add("tag-state");
-            line.appendChild(tagState);
-
-            line.appendChild(closingTag.cloneNode(true));
-
-            this.closeTagLine = line;
-          }
-          this.elt.appendChild(this.closeTagLine);
-        }
-      }
-      this.elt.classList.remove("collapsed");
-      this.expander.setAttribute("open", "");
-      this.hovered = false;
-    } else if (!aValue) {
-      if (this.editor instanceof ElementEditor && this.closeTagLine) {
-        this.elt.removeChild(this.closeTagLine);
-      }
-      this.elt.classList.add("collapsed");
-      this.expander.removeAttribute("open");
-    }
-  },
-
-  _onToggle: function(event) {
-    this.markup.navigate(this);
-    if(this.hasChildren) {
-      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
-    }
-    event.stopPropagation();
-  },
-
   _onMouseDown: function(event) {
     let target = event.target;
 
     // Target may be a resource link (generated by the output-parser)
     if (target.nodeName === "a") {
       event.stopPropagation();
       event.preventDefault();
       let browserWin = this.markup._inspector.target
@@ -1635,42 +1496,256 @@ MarkupContainer.prototype = {
    */
   focus: function() {
     let focusable = this.editor.elt.querySelector("[tabindex]");
     if (focusable) {
       focusable.focus();
     }
   },
 
+  _onToggle: function(event) {
+    this.markup.navigate(this);
+    if (this.hasChildren) {
+      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
+    }
+    event.stopPropagation();
+  },
+
+
   /**
    * Get rid of event listeners and references, when the container is no longer
    * needed
    */
   destroy: function() {
+    // Remove event listeners
+    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
+    this.elt.removeEventListener("dblclick", this._onToggle, false);
+
     // Recursively destroy children containers
     let firstChild;
     while (firstChild = this.children.firstChild) {
       // Not all children of a container are containers themselves
       // ("show more nodes" button is one example)
       if (firstChild.container) {
         firstChild.container.destroy();
       }
       this.children.removeChild(firstChild);
     }
 
-    // Remove event listeners
-    this.elt.removeEventListener("dblclick", this._onToggle, false);
-    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
-    this.expander.removeEventListener("click", this._onToggle, false);
-
-    // Destroy my editor
     this.editor.destroy();
   }
 };
 
+/**
+ * An implementation of MarkupContainer for Pseudo Elements,
+ * Doctype nodes, or any other type generic node that doesn't
+ * fit for other editors.
+ * Does not allow any editing, just viewing / selecting.
+ *
+ * @param MarkupView markupView
+ *        The markup view that owns this container.
+ * @param NodeFront node
+ *        The node to display.
+ */
+function MarkupReadOnlyContainer(markupView, node) {
+  MarkupContainer.prototype.initialize.call(this, markupView, node, "readonlycontainer");
+
+  this.editor = new GenericEditor(this, node);
+  this.tagLine.appendChild(this.editor.elt);
+}
+
+MarkupReadOnlyContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
+
+/**
+ * An implementation of MarkupContainer for text node and comment nodes.
+ * Allows basic text editing in a textarea.
+ *
+ * @param MarkupView aMarkupView
+ *        The markup view that owns this container.
+ * @param NodeFront aNode
+ *        The node to display.
+ * @param Inspector aInspector
+ *        The inspector tool container the markup-view
+ */
+function MarkupTextContainer(markupView, node) {
+  MarkupContainer.prototype.initialize.call(this, markupView, node, "textcontainer");
+
+  if (node.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
+    this.editor = new TextEditor(this, node, "text");
+  } else if (node.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
+    this.editor = new TextEditor(this, node, "comment");
+  } else {
+    throw "Invalid node for MarkupTextContainer";
+  }
+
+  this.tagLine.appendChild(this.editor.elt);
+}
+
+MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
+
+/**
+ * An implementation of MarkupContainer for Elements that can contain
+ * child nodes.
+ * Allows editing of tag name, attributes, expanding / collapsing.
+ *
+ * @param MarkupView markupView
+ *        The markup view that owns this container.
+ * @param NodeFront node
+ *        The node to display.
+ */
+function MarkupElementContainer(markupView, node) {
+  MarkupContainer.prototype.initialize.call(this, markupView, node, "elementcontainer");
+
+  if (node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+    this.editor = new ElementEditor(this, node);
+  } else {
+    throw "Invalid node for MarkupElementContainer";
+  }
+
+  this.tagLine.appendChild(this.editor.elt);
+
+  // Expanding/collapsing the node on dblclick of the whole tag-line element
+  this.expander.addEventListener("click", this._onToggle, false);
+
+  // Prepare the image preview tooltip data if any
+  this._prepareImagePreview();
+}
+
+MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {
+  /**
+   * True if the current node has children.  The MarkupView
+   * will set this attribute for the MarkupContainer.
+   */
+  _hasChildren: false,
+
+  get hasChildren() {
+    return this._hasChildren;
+  },
+
+  set hasChildren(aValue) {
+    this._hasChildren = aValue;
+    if (aValue) {
+      this.expander.style.visibility = "visible";
+    } else {
+      this.expander.style.visibility = "hidden";
+    }
+  },
+
+  /**
+   * True if the node has been visually expanded in the tree.
+   */
+  get expanded() {
+    return !this.elt.classList.contains("collapsed");
+  },
+
+  set expanded(aValue) {
+    if (aValue && this.elt.classList.contains("collapsed")) {
+      // Expanding a node means cloning its "inline" closing tag into a new
+      // tag-line that the user can interact with and showing the children.
+      if (this.editor instanceof ElementEditor) {
+        let closingTag = this.elt.querySelector(".close");
+        if (closingTag) {
+          if (!this.closeTagLine) {
+            let line = this.markup.doc.createElement("div");
+            line.classList.add("tag-line");
+
+            let tagState = this.markup.doc.createElement("div");
+            tagState.classList.add("tag-state");
+            line.appendChild(tagState);
+
+            line.appendChild(closingTag.cloneNode(true));
+
+            this.closeTagLine = line;
+          }
+          this.elt.appendChild(this.closeTagLine);
+        }
+      }
+      this.elt.classList.remove("collapsed");
+      this.expander.setAttribute("open", "");
+      this.hovered = false;
+    } else if (!aValue) {
+      if (this.editor instanceof ElementEditor && this.closeTagLine) {
+        this.elt.removeChild(this.closeTagLine);
+      }
+      this.elt.classList.add("collapsed");
+      this.expander.removeAttribute("open");
+    }
+  },
+
+  /**
+   * If the node is an image or canvas (@see isPreviewable), then get the
+   * image data uri from the server so that it can then later be previewed in
+   * a tooltip if needed.
+   * Stores a promise in this.tooltipData.data that resolves when the data has
+   * been retrieved
+   */
+  _prepareImagePreview: function() {
+    if (this.isPreviewable()) {
+      // Get the image data for later so that when the user actually hovers over
+      // the element, the tooltip does contain the image
+      let def = promise.defer();
+
+      this.tooltipData = {
+        target: this.editor.getAttributeElement("src") || this.editor.tag,
+        data: def.promise
+      };
+
+      let maxDim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");
+      this.node.getImageData(maxDim).then(data => {
+        data.data.string().then(str => {
+          let res = {data: str, size: data.size};
+          // Resolving the data promise and, to always keep tooltipData.data
+          // as a promise, create a new one that resolves immediately
+          def.resolve(res);
+          this.tooltipData.data = promise.resolve(res);
+        });
+      }, () => {
+        this.tooltipData.data = promise.reject();
+      });
+    }
+  },
+
+  /**
+   * Executed by MarkupView._isImagePreviewTarget which is itself called when the
+   * mouse hovers over a target in the markup-view.
+   * Checks if the target is indeed something we want to have an image tooltip
+   * preview over and, if so, inserts content into the tooltip.
+   * @return a promise that resolves when the content has been inserted or
+   * rejects if no preview is required. This promise is then used by Tooltip.js
+   * to decide if/when to show the tooltip
+   */
+  isImagePreviewTarget: function(target, tooltip) {
+    if (!this.tooltipData || this.tooltipData.target !== target) {
+      return promise.reject();
+    }
+
+    return this.tooltipData.data.then(({data, size}) => {
+      tooltip.setImageContent(data, size);
+    }, () => {
+      tooltip.setBrokenImageContent();
+    });
+  },
+
+  copyImageDataUri: function() {
+    // We need to send again a request to gettooltipData even if one was sent for
+    // the tooltip, because we want the full-size image
+    this.node.getImageData().then(data => {
+      data.data.string().then(str => {
+        clipboardHelper.copyString(str, this.markup.doc);
+      });
+    });
+  },
+
+  destroy: function() {
+    // Remove event listeners
+    this.expander.removeEventListener("click", this._onToggle, false);
+
+    MarkupContainer.prototype.destroy.call(this);
+  }
+});
 
 /**
  * Dummy container node used for the root document element.
  */
 function RootContainer(aMarkupView, aNode) {
   this.doc = aMarkupView.doc;
   this.elt = this.doc.createElement("ul");
   this.elt.container = this;
@@ -1682,81 +1757,83 @@ function RootContainer(aMarkupView, aNod
 RootContainer.prototype = {
   hasChildren: true,
   expanded: true,
   update: function() {},
   destroy: function() {}
 };
 
 /**
- * Creates an editor for simple nodes.
+ * Creates an editor for non-editable nodes.
  */
 function GenericEditor(aContainer, aNode) {
-  this.elt = aContainer.doc.createElement("span");
-  this.elt.className = "editor";
-  this.elt.textContent = aNode.nodeName;
+  this.container = aContainer;
+  this.markup = this.container.markup;
+  this.template = this.markup.template.bind(this.markup);
+  this.elt = null;
+  this.template("generic", this);
+
+  if (aNode.isPseudoElement) {
+    this.tag.classList.add("theme-fg-color5");
+    this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
+  } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
+    this.elt.classList.add("comment");
+    this.tag.textContent = '<!DOCTYPE ' + aNode.name +
+       (aNode.publicId ? ' PUBLIC "' +  aNode.publicId + '"': '') +
+       (aNode.systemId ? ' "' + aNode.systemId + '"' : '') +
+       '>';
+  } else {
+    this.tag.textContent = aNode.nodeName;
+  }
 }
 
 GenericEditor.prototype = {
-  destroy: function() {}
-};
-
-/**
- * Creates an editor for a DOCTYPE node.
- *
- * @param MarkupContainer aContainer The container owning this editor.
- * @param DOMNode aNode The node being edited.
- */
-function DoctypeEditor(aContainer, aNode) {
-  this.elt = aContainer.doc.createElement("span");
-  this.elt.className = "editor comment";
-  this.elt.textContent = '<!DOCTYPE ' + aNode.name +
-     (aNode.publicId ? ' PUBLIC "' +  aNode.publicId + '"': '') +
-     (aNode.systemId ? ' "' + aNode.systemId + '"' : '') +
-     '>';
-}
-
-DoctypeEditor.prototype = {
-  destroy: function() {}
+  destroy: function() {
+    this.elt.remove();
+  }
 };
 
 /**
  * Creates a simple text editor node, used for TEXT and COMMENT
  * nodes.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param DOMNode aNode The node being edited.
  * @param string aTemplate The template id to use to build the editor.
  */
 function TextEditor(aContainer, aNode, aTemplate) {
+  this.container = aContainer;
+  this.markup = this.container.markup;
   this.node = aNode;
+  this.template = this.markup.template.bind(aTemplate);
+  this.undo = this.markup.undo;
   this._selected = false;
 
-  aContainer.markup.template(aTemplate, this);
+  this.markup.template(aTemplate, this);
 
   editableField({
     element: this.value,
     stopOnReturn: true,
     trigger: "dblclick",
     multiline: true,
     done: (aVal, aCommit) => {
       if (!aCommit) {
         return;
       }
       this.node.getNodeValue().then(longstr => {
         longstr.string().then(oldValue => {
           longstr.release().then(null, console.error);
 
-          aContainer.undo.do(() => {
+          this.undo.do(() => {
             this.node.setNodeValue(aVal).then(() => {
-              aContainer.markup.nodeChanged(this.node);
+              this.markup.nodeChanged(this.node);
             });
           }, () => {
             this.node.setNodeValue(oldValue).then(() => {
-              aContainer.markup.nodeChanged(this.node);
+              this.markup.nodeChanged(this.node);
             })
           });
         });
       });
     }
   });
 
   this.update();
@@ -1793,50 +1870,28 @@ TextEditor.prototype = {
       }).then(null, console.error);
     }
   },
 
   destroy: function() {}
 };
 
 /**
- * Creates an editor for a pseudo element node.
- * A pseudo element just needs to simply be displayed in the markup view,
- * without any of the editing capabilities a normal element has.
- *
- * @param MarkupContainer aContainer The container owning this editor.
- * @param Element aNode The node being edited.
- */
-function PseudoElementEditor(aContainer, aNode) {
-  this.template = aContainer.markup.template.bind(aContainer.markup);
-  this.tag = null;
-  this.elt = null;
-  this.template("pseudoelement", this);
-  this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
-}
-
-PseudoElementEditor.prototype = {
-  destroy: function() {
-    this.elt.remove();
-  }
-};
-
-/**
  * Creates an editor for an Element node.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param Element aNode The node being edited.
  */
 function ElementEditor(aContainer, aNode) {
-  this.doc = aContainer.doc;
-  this.undo = aContainer.undo;
-  this.template = aContainer.markup.template.bind(aContainer.markup);
   this.container = aContainer;
+  this.node = aNode;
   this.markup = this.container.markup;
-  this.node = aNode;
+  this.template = this.markup.template.bind(this.markup);
+  this.doc = this.markup.doc;
+  this.undo = this.markup.undo;
 
   this.attrs = {};
 
   // The templates will fill the following properties
   this.elt = null;
   this.tag = null;
   this.closeTag = null;
   this.attrList = null;
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -17,25 +17,35 @@
 </head>
 <body class="theme-body devtools-monospace" role="application">
   <div id="root-wrapper">
     <div id="root"></div>
   </div>
   <div id="templates" style="display:none">
 
     <ul class="children">
-      <li id="template-container" save="${elt}" class="child collapsed">
+      <li id="template-elementcontainer" save="${elt}" class="child collapsed">
         <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span><span save="${expander}" class="theme-twisty expander"></span></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
+      <li id="template-textcontainer" save="${elt}" class="child collapsed">
+        <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span></div>
+        <ul save="${children}" class="children"></ul>
+      </li>
+
+      <li id="template-readonlycontainer" save="${elt}" class="child collapsed">
+        <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span></div>
+        <ul save="${children}" class="children"></ul>
+      </li>
+
       <li id="template-more-nodes" class="more-nodes devtools-class-comment" save="${elt}"><span>${showing}</span> <button href="#" onclick="${allButtonClick}">${showAll}</button></li>
     </ul>
 
-    <span id="template-pseudoelement" save="${elt}" class="editor"><span save="${tag}" class="tag theme-fg-color5" tabindex="0"></span></span>
+    <span id="template-generic" save="${elt}" class="editor"><span save="${tag}" class="tag"></span></span>
 
     <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span></span>
 
     <span id="template-attribute" save="${attr}" data-attr="${attrName}" class="attreditor" style="display:none"> <span class="editable" save="${inner}" tabindex="0"><span save="${name}" class="attr-name theme-fg-color2"></span>=&quot;<span save="${val}" class="attr-value theme-fg-color6"></span>&quot;</span></span>
 
     <span id="template-text" save="${elt}" class="editor text">
       <pre save="${value}" style="display:inline-block;" tabindex="0"></pre>
     </span>
