
# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1504814281 25200
# Node ID 5acb5aac04e01366c15c53c7a9930ec4e6a92da5
# Parent  5f52c2488a831edbc33fa0bc6003ed4df9a62732
Bug 1397876 - Import Custom Elements polyfill and stub out the panel and arrowpanel bindings

The hamburger menu seems to work, but other panels don't (customize popup, awesomebar).

Steps I took to build this:
* Pull down polyfill from https://github.com/bgrins/custom-elements/tree/firefox-browser-chrome (includes fixes for XUL docs)
* Elements are pseudo generated from https://github.com/bgrins/xbl-analysis/tree/gh-pages/elements

MozReview-Commit-ID: iZTULEIwYY

diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -6,16 +6,17 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <?xml-stylesheet href="chrome://browser/content/browser.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/content/places/places.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/content/usercontext/usercontext.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/controlcenter/panel.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/customizableui/panelUI.css" type="text/css"?>
+<?xml-stylesheet href="chrome://global/skin/popup.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/" type="text/css"?>
 
 <?xul-overlay href="chrome://global/content/editMenuOverlay.xul"?>
 <?xul-overlay href="chrome://browser/content/baseMenuOverlay.xul"?>
 <?xul-overlay href="chrome://browser/content/places/placesOverlay.xul"?>
 
 # All DTD information is stored in a separate file so that it can be shared by
 # hiddenWindow.xul.
@@ -69,17 +70,16 @@
   Services.scriptloader.loadSubScript("chrome://global/content/contentAreaUtils.js", this);
 </script>
 
 # All sets except for popupsets (commands, keys, stringbundles and broadcasters) *must* go into the
 # browser-sets.inc file for sharing with hiddenWindow.xul.
 #define FULL_BROWSER_WINDOW
 #include browser-sets.inc
 #undef FULL_BROWSER_WINDOW
-
   <popupset id="mainPopupSet">
     <menupopup id="tabContextMenu"
                onpopupshowing="if (event.target == this) TabContextMenu.updateContextMenu(this);"
                onpopuphidden="if (event.target == this) TabContextMenu.contextTab = null;">
       <menuitem id="context_reloadTab" label="&reloadTab.label;" accesskey="&reloadTab.accesskey;"
                 oncommand="gBrowser.reloadTab(TabContextMenu.contextTab);"/>
       <menuitem id="context_toggleMuteTab" oncommand="TabContextMenu.contextTab.toggleMuteAudio();"/>
       <menuseparator/>
@@ -713,17 +713,16 @@
              fullscreentoolbar="true" mode="icons" customizable="true"
              iconsize="small"
              customizationtarget="nav-bar-customization-target"
              overflowable="true"
              overflowbutton="nav-bar-overflow-button"
              overflowtarget="widget-overflow-list"
              overflowpanel="widget-overflow"
              context="toolbar-context-menu">
-
       <hbox id="nav-bar-customization-target" flex="1">
         <toolbarbutton id="back-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
                        label="&backCmd.label;"
                        removable="false" overflows="false"
                        keepbroadcastattributeswhencustomizing="true"
                        command="Browser:BackOrBackDuplicate"
                        onclick="checkForMiddleClick(this, event);"
                        tooltip="back-button-tooltip"
@@ -1241,9 +1240,10 @@
   </vbox>
 
 </vbox>
 # <iframe id="tab-view"> is dynamically appended as the 2nd child of #tab-view-deck.
 #     Introducing the iframe dynamically, as needed, was found to be better than
 #     starting with an empty iframe here in browser.xul from a Ts standpoint.
 </deck>
 
+<script src="chrome://browser/content/customelements/custom-elements.js"></script>
 </window>
diff --git a/browser/base/content/customelements/base-element.js b/browser/base/content/customelements/base-element.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/base-element.js
@@ -0,0 +1,154 @@
+
+
+// https://html.spec.whatwg.org/multipage/scripting.html#custom-elements-autonomous-example
+
+class BaseElement extends XULElement {
+  constructor() {
+    super();
+    this.observerConnector = new ObserverConnector(this);
+    this.inheritsConnector = new InheritsConnector(this);
+  }
+
+  connectedCallback() {
+
+  }
+
+  disconnectedCallback() {
+
+  }
+
+  static get observedAttributes() { return ["observes"]; }
+
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (name === "observes") {
+      this.observerConnector.watch(newValue);
+    }
+  }
+}
+
+function InheritsConnector(host) {
+  this._host = host;
+  this._nodesToAttributes = new Map();
+  this.watch();
+}
+InheritsConnector.prototype.destroy = function() {
+
+}
+InheritsConnector.prototype.setInherits = function(node) {
+  let inherits = node.getAttribute("inherits");
+  if (inherits) {
+    this._nodesToAttributes.set(node, inherits.split(','));
+  }
+}
+InheritsConnector.prototype.copyAttribute = function(attributeName) {
+  if (attributeName === "id") {
+    return;
+  }
+
+  for (let [node, list] of this._nodesToAttributes.entries()) {
+    // Handle both inherits="accesskey" and inherits="text=label"
+    list.forEach(a => {
+      if (a === attributeName) {
+        if (a === "checked") {
+          node.checked = this._host.hasAttribute(a) && this._host.getAttribute(a) != "false";
+        } else {
+          node.setAttribute(a, this._host.getAttribute(a));
+        }
+      } else if (a.endsWith('=' + attributeName)) {
+        let mapFrom = a.split('=')[1];
+        let mapTo = a.split('=')[0];
+        if (mapTo === "text") {
+          node.textContent = this._host.getAttribute(mapFrom);
+        } else {
+          node.setAttribute(mapTo, this._host.getAttribute(mapFrom));
+        }
+      }
+    });
+  }
+};
+
+InheritsConnector.prototype.watch = function() {
+  if (this._observer) {
+    this._observer.disconnect();
+    this._observer = null;
+  }
+
+  this._observer = new MutationObserver(mutations => {
+    mutations.forEach(mutation => {
+      if (mutation.type === "childList") {
+        mutation.addedNodes.forEach(added => {
+          if (added.nodeType !== 1) {
+            return;
+          }
+          this.setInherits(added);
+          [...added.querySelectorAll("[inherits]")].forEach(child => this.setInherits(child));
+          for (var i = 0; i < this._host.attributes.length; i++) {
+            var attrib = this._host.attributes[i];
+            this.copyAttribute(attrib.name);
+          }
+        });
+      }
+
+      if (mutation.type === "attributes" && mutation.target === this._host) {
+        this.copyAttribute(mutation.attributeName);
+      }
+    });
+
+    // this.copyAttributes();
+  });
+  this._observer.observe(this._host, {
+    attributes: true,
+    subtree: true,
+    childList: true,
+  });
+
+}
+
+function ObserverConnector(host) {
+  this._host = host;
+}
+ObserverConnector.prototype.destroy = function() {
+
+}
+
+ObserverConnector.prototype.copyAttributes = function() {
+  if (!this._observeTarget) {
+    return;
+  }
+
+  for (var i = 0; i < this._observeTarget.attributes.length; i++) {
+    var attrib = this._observeTarget.attributes[i];
+    if (attrib.name !== "id") {
+      this._host.setAttribute(attrib.name, attrib.value);
+    }
+  }
+}
+
+ObserverConnector.prototype.watch = function(targetID) {
+  if (this._observer) {
+    this._observer.disconnect();
+    this._observer = null;
+  }
+
+  // XXX: What is hitting this case?
+  if (!targetID) {
+    return;
+  }
+
+  this._observeTarget = document.getElementById(targetID);
+  if (this._observeTarget) {
+    this._observer = new MutationObserver(mutations => {
+      mutations.forEach(mutation => {
+        if (!this._observeTarget.hasAttribute(mutation.attributeName)) {
+          this.removeAttribute(mutation.attributeName);
+        }
+      });
+
+      this.copyAttributes();
+    });
+    this._observer.observe(this._observeTarget, {
+      attributes: true,
+    });
+    this.copyAttributes();
+  }
+}
diff --git a/browser/base/content/customelements/custom-elements.js b/browser/base/content/customelements/custom-elements.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/custom-elements.js
@@ -0,0 +1,3 @@
+#include custom-elements-polyfill.js
+#include base-element.js
+#include firefox-panel.js
diff --git a/browser/base/content/customelements/firefox-panel.js b/browser/base/content/customelements/firefox-panel.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/customelements/firefox-panel.js
@@ -0,0 +1,540 @@
+// XXX: "downloadsPanel" doesn't get recognized by CE polyfill (xul overlay?)
+
+
+
+class FirefoxPopupBase extends BaseElement {
+
+  // XXX: Do we need to generateQI for nsIDOMXULPopupElement? The hamburger menu
+  // seems to open without this.
+  // get QueryInterface() {
+  //   return XPCOMUtils.generateQI([Ci.nsIDOMXULPopupElement]);
+  // }
+
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    console.log(this, "connected");
+
+    let comment = document.createComment("Creating firefox-popup-base");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set position(val) {
+    this.setAttribute("position", val);
+    return val;
+  }
+
+  get position() {
+    return this.getAttribute("position");
+  }
+
+  get popupBoxObject() {
+    return this.boxObject;
+  }
+
+  get state() {
+    return this.popupBoxObject.popupState;
+  }
+
+  get triggerNode() {
+    return this.popupBoxObject.triggerNode;
+  }
+
+  get anchorNode() {
+    return this.popupBoxObject.anchorNode;
+  }
+
+  set autoPosition(val) {
+    return (this.popupBoxObject.autoPosition = val);
+  }
+
+  get autoPosition() {
+    return this.popupBoxObject.autoPosition;
+  }
+
+  get alignmentPosition() {
+    return this.popupBoxObject.alignmentPosition;
+  }
+
+  get alignmentOffset() {
+    return this.popupBoxObject.alignmentOffset;
+  }
+  openPopup(
+    aAnchorElement,
+    aPosition,
+    aX,
+    aY,
+    aIsContextMenu,
+    aAttributesOverride,
+    aTriggerEvent
+  ) {
+    // Allow for passing an options object as the second argument.
+    if (
+      arguments.length == 2 &&
+      arguments[1] != null &&
+      typeof arguments[1] == "object"
+    ) {
+      let params = arguments[1];
+      aPosition = params.position;
+      aX = params.x;
+      aY = params.y;
+      aIsContextMenu = params.isContextMenu;
+      aAttributesOverride = params.attributesOverride;
+      aTriggerEvent = params.triggerEvent;
+    }
+
+    dump(`openPopup ${aX} ${aY} ${this.popupBoxObject.openPopup}\n`);
+    try {
+      var popupBox = this.popupBoxObject;
+      if (popupBox)
+        popupBox.openPopup(
+          aAnchorElement,
+          aPosition,
+          aX,
+          aY,
+          aIsContextMenu,
+          aAttributesOverride,
+          aTriggerEvent
+        );
+    } catch (e) {
+      dump(`Caught ${e} \n`);
+    }
+  }
+  openPopupAtScreen(aX, aY, aIsContextMenu, aTriggerEvent) {
+    try {
+      var popupBox = this.popupBoxObject;
+      if (popupBox)
+        popupBox.openPopupAtScreen(aX, aY, aIsContextMenu, aTriggerEvent);
+    } catch (e) {}
+  }
+  openPopupAtScreenRect(
+    aPosition,
+    aX,
+    aY,
+    aWidth,
+    aHeight,
+    aIsContextMenu,
+    aAttributesOverride,
+    aTriggerEvent
+  ) {
+    try {
+      var popupBox = this.popupBoxObject;
+      if (popupBox)
+        popupBox.openPopupAtScreenRect(
+          aPosition,
+          aX,
+          aY,
+          aWidth,
+          aHeight,
+          aIsContextMenu,
+          aAttributesOverride,
+          aTriggerEvent
+        );
+    } catch (e) {}
+  }
+  showPopup(element, xpos, ypos, popuptype, anchoralignment, popupalignment) {
+    var popupBox = null;
+    var menuBox = null;
+    try {
+      popupBox = this.popupBoxObject;
+    } catch (e) {}
+    try {
+      menuBox = this.parentNode.boxObject;
+    } catch (e) {}
+    if (menuBox instanceof MenuBoxObject) menuBox.openMenu(true);
+    else if (popupBox)
+      popupBox.showPopup(
+        element,
+        this,
+        xpos,
+        ypos,
+        popuptype,
+        anchoralignment,
+        popupalignment
+      );
+  }
+  hidePopup(cancel) {
+    var popupBox = null;
+    var menuBox = null;
+    try {
+      popupBox = this.popupBoxObject;
+    } catch (e) {}
+    try {
+      menuBox = this.parentNode.boxObject;
+    } catch (e) {}
+    if (menuBox instanceof MenuBoxObject) menuBox.openMenu(false);
+    else if (popupBox instanceof PopupBoxObject) popupBox.hidePopup(cancel);
+  }
+  enableKeyboardNavigator(aEnableKeyboardNavigator) {
+    this.popupBoxObject.enableKeyboardNavigator(aEnableKeyboardNavigator);
+  }
+  enableRollup(aEnableRollup) {
+    this.popupBoxObject.enableRollup(aEnableRollup);
+  }
+  sizeTo(aWidth, aHeight) {
+    this.popupBoxObject.sizeTo(aWidth, aHeight);
+  }
+  moveTo(aLeft, aTop) {
+    this.popupBoxObject.moveTo(aLeft, aTop);
+  }
+  moveToAnchor(aAnchorElement, aPosition, aX, aY, aAttributesOverride) {
+    this.popupBoxObject.moveToAnchor(
+      aAnchorElement,
+      aPosition,
+      aX,
+      aY,
+      aAttributesOverride
+    );
+  }
+  getOuterScreenRect() {
+    return this.popupBoxObject.getOuterScreenRect();
+  }
+  setConstraintRect(aRect) {
+    this.popupBoxObject.setConstraintRect(aRect);
+  }
+}
+customElements.define("firefox-popup-base", FirefoxPopupBase);
+
+
+class FirefoxPanel extends FirefoxPopupBase {
+
+
+  // XXX: Do we need to generateQI for nsIDOMXULPopupElement? The hamburger menu
+  // seems to open without this.
+  // get QueryInterface() {
+  //   return XPCOMUtils.generateQI([Ci.nsIDOMXULPopupElement]);
+  // }
+
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    dump(`connectedCallback FirefoxPanel ${this.id}\n`);
+
+    let comment = document.createComment("Creating firefox-panel");
+    this.prepend(comment);
+
+    Object.defineProperty(this, "_prevFocus", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._prevFocus;
+        return (this._prevFocus = 0);
+      },
+      set(val) {
+        delete this._prevFocus;
+        return (this._prevFocus = val);
+      }
+    });
+    Object.defineProperty(this, "_dragBindingAlive", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._dragBindingAlive;
+        return (this._dragBindingAlive = true);
+      },
+      set(val) {
+        delete this._dragBindingAlive;
+        return (this._dragBindingAlive = val);
+      }
+    });
+
+    if (this.getAttribute("backdrag") == "true" && !this._draggableStarted) {
+      this._draggableStarted = true;
+      try {
+        let tmp = {};
+        Components.utils.import(
+          "resource://gre/modules/WindowDraggingUtils.jsm",
+          tmp
+        );
+        let draghandle = new tmp.WindowDraggingElement(this);
+        draghandle.mouseDownCheck = function() {
+          return this._dragBindingAlive;
+        };
+      } catch (e) {}
+    }
+
+    this.addEventListener("popupshowing", event => {
+      // Capture the previous focus before has a chance to get set inside the panel
+      try {
+        this._prevFocus = Components.utils.getWeakReference(
+          document.commandDispatcher.focusedElement
+        );
+        if (this._prevFocus.get()) return;
+      } catch (ex) {}
+
+      this._prevFocus = Components.utils.getWeakReference(
+        document.activeElement
+      );
+    });
+
+    this.addEventListener("popupshown", event => {
+      // Fire event for accessibility APIs
+      var alertEvent = document.createEvent("Events");
+      alertEvent.initEvent("AlertActive", true, true);
+      this.dispatchEvent(alertEvent);
+    });
+
+    this.addEventListener("popuphiding", event => {
+      try {
+        this._currentFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        this._currentFocus = document.activeElement;
+      }
+    });
+
+    this.addEventListener("popuphidden", event => {
+      function doFocus() {
+        // Focus was set on an element inside this panel,
+        // so we need to move it back to where it was previously
+        try {
+          let fm = Components.classes[
+            "@mozilla.org/focus-manager;1"
+          ].getService(Components.interfaces.nsIFocusManager);
+          fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
+        } catch (e) {
+          prevFocus.focus();
+        }
+      }
+      var currentFocus = this._currentFocus;
+      var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
+      this._currentFocus = null;
+      this._prevFocus = null;
+
+      // Avoid changing focus if focus changed while we hide the popup
+      // (This can happen e.g. if the popup is hiding as a result of a
+      // click/keypress that focused something)
+      let nowFocus;
+      try {
+        nowFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        nowFocus = document.activeElement;
+      }
+      if (nowFocus && nowFocus != currentFocus) return;
+
+      if (prevFocus && this.getAttribute("norestorefocus") != "true") {
+        // Try to restore focus
+        try {
+          if (document.commandDispatcher.focusedWindow != window) return; // Focus has already been set to a window outside of this panel
+        } catch (ex) {}
+
+        if (!currentFocus) {
+          doFocus();
+          return;
+        }
+        while (currentFocus) {
+          if (currentFocus == this) {
+            doFocus();
+            return;
+          }
+          currentFocus = currentFocus.parentNode;
+        }
+      }
+    });
+
+    // Special case for other bindings like arrowpanel, because platform has code
+    // looking for the 'panel' tag but custom elements don't let us register an element
+    // based on an attribute value. So we need to fold in the arrow functionality in that case.
+    if (this.getAttribute("type") === "arrow") {
+      dump(`Got an arrow popup ${this.id}\n`);
+      ArrowPanelConnectedCallback.call(this);
+    }
+  }
+  disconnectedCallback() {}
+}
+
+customElements.define("panel", FirefoxPanel);
+
+
+function ArrowPanelConnectedCallback() {
+  console.log(this, "connected");
+
+  // XXX: This simulates the <children> tag inside the panel-arrowcontent
+  let frag = document.createElement("box");
+  frag.innerHTML = `<vbox anonid="container" class="panel-arrowcontainer" flex="1" inherits="side,panelopen">
+<box anonid="arrowbox" class="panel-arrowbox">
+<image anonid="arrow" class="panel-arrow" inherits="side">
+</image>
+</box>
+<box class="panel-arrowcontent" inherits="side,align,dir,orient,pack" flex="1">
+</box>
+</vbox>`
+
+  let nodes = [...this.childNodes];
+  for (var i = 0; i < nodes.length; i++) {
+    dump("Adding " + i + " " + nodes[i].localName + "\n");
+    frag.querySelector(".panel-arrowcontent").appendChild(nodes[i]);
+  }
+
+  this.innerHTML = '';
+
+  nodes = [...frag.childNodes];
+  for (var i = 0; i < nodes.length; i++) {
+    this.appendChild(nodes[i]);
+  }
+
+  let comment = document.createComment("Creating firefox-arrowpanel");
+  this.prepend(comment);
+
+  Object.defineProperty(this, "_fadeTimer", {
+    configurable: true,
+    enumerable: true,
+    get() {
+      delete this._fadeTimer;
+      return (this._fadeTimer = null);
+    },
+    set(val) {
+      delete this._fadeTimer;
+      return (this._fadeTimer = val);
+    }
+  });
+
+  this.addEventListener("popupshowing", event => {
+    dump("popupshowing\n");
+    var arrow = this.querySelector("[anonid=arrow]");
+    arrow.hidden = this.anchorNode == null;
+    this.querySelector("[anonid=arrowbox]").style.removeProperty("transform");
+
+    this.adjustArrowPosition();
+
+    if (this.getAttribute("animate") != "false") {
+      this.setAttribute("animate", "open");
+      // the animating attribute prevents user interaction during transition
+      // it is removed when popupshown fires
+      this.setAttribute("animating", "true");
+    }
+
+    // set fading
+    var fade = this.getAttribute("fade");
+    var fadeDelay = 0;
+    if (fade == "fast") {
+      fadeDelay = 1;
+    } else if (fade == "slow") {
+      fadeDelay = 4000;
+    } else {
+      return;
+    }
+
+    this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
+  });
+
+  this.addEventListener("popuphiding", event => {
+    dump("popuphiding\n");
+    let animate = this.getAttribute("animate") != "false";
+
+    if (this._fadeTimer) {
+      clearTimeout(this._fadeTimer);
+      if (animate) {
+        this.setAttribute("animate", "fade");
+      }
+    } else if (animate) {
+      this.setAttribute("animate", "cancel");
+    }
+  });
+
+  this.addEventListener("popupshown", event => {
+    dump("popupshown\n");
+    this.removeAttribute("animating");
+    this.setAttribute("panelopen", "true");
+  });
+
+  this.addEventListener("popuphidden", event => {
+    dump("popuphidden\n");
+    this.removeAttribute("panelopen");
+    if (this.getAttribute("animate") != "false") {
+      this.removeAttribute("animate");
+    }
+  });
+
+  this.addEventListener("popuppositioned", event => {
+    dump("popuppositioned\n");
+    this.adjustArrowPosition();
+  });
+
+  this.sizeTo = (aWidth, aHeight) => {
+    this.popupBoxObject.sizeTo(aWidth, aHeight);
+    if (this.state == "open") {
+      this.adjustArrowPosition();
+    }
+  }
+
+  this.moveToAnchor = (aAnchorElement, aPosition, aX, aY, aAttributesOverride) => {
+    this.popupBoxObject.moveToAnchor(
+      aAnchorElement,
+      aPosition,
+      aX,
+      aY,
+      aAttributesOverride
+    );
+  }
+
+
+  this.adjustArrowPosition = () => {
+    var anchor = this.anchorNode;
+    if (!anchor) {
+      return;
+    }
+
+    var container = this.querySelector("[anonid=container]");
+    var arrowbox = this.querySelector("[anonid=arrowbox]");
+
+    var position = this.alignmentPosition;
+    var offset = this.alignmentOffset;
+
+    this.setAttribute("arrowposition", position);
+
+    if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
+      container.orient = "horizontal";
+      arrowbox.orient = "vertical";
+      if (position.indexOf("_after") > 0) {
+        arrowbox.pack = "end";
+      } else {
+        arrowbox.pack = "start";
+      }
+      arrowbox.style.transform = "translate(0, " + -offset + "px)";
+
+      // The assigned side stays the same regardless of direction.
+      var isRTL = window.getComputedStyle(this).direction == "rtl";
+
+      if (position.indexOf("start_") == 0) {
+        container.dir = "reverse";
+        this.setAttribute("side", isRTL ? "left" : "right");
+      } else {
+        container.dir = "";
+        this.setAttribute("side", isRTL ? "right" : "left");
+      }
+    } else if (
+      position.indexOf("before_") == 0 ||
+      position.indexOf("after_") == 0
+    ) {
+      container.orient = "";
+      arrowbox.orient = "";
+      if (position.indexOf("_end") > 0) {
+        arrowbox.pack = "end";
+      } else {
+        arrowbox.pack = "start";
+      }
+      arrowbox.style.transform = "translate(" + -offset + "px, 0)";
+
+      if (position.indexOf("before_") == 0) {
+        container.dir = "reverse";
+        this.setAttribute("side", "bottom");
+      } else {
+        container.dir = "";
+        this.setAttribute("side", "top");
+      }
+    }
+  }
+}
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -75,16 +75,17 @@ browser.jar:
         content/browser/browser-tabsintitlebar.js       (content/browser-tabsintitlebar.js)
 #else
         content/browser/browser-tabsintitlebar.js       (content/browser-tabsintitlebar-stub.js)
 #endif
         content/browser/browser-thumbnails.js         (content/browser-thumbnails.js)
         content/browser/browser-trackingprotection.js (content/browser-trackingprotection.js)
         content/browser/tab-content.js                (content/tab-content.js)
         content/browser/content.js                    (content/content.js)
+*       content/browser/customelements/custom-elements.js (content/customelements/custom-elements.js)
         content/browser/default-theme-icon.svg        (content/default-theme-icon.svg)
         content/browser/defaultthemes/1.header.jpg    (content/defaultthemes/1.header.jpg)
         content/browser/defaultthemes/1.icon.jpg      (content/defaultthemes/1.icon.jpg)
         content/browser/defaultthemes/1.preview.jpg   (content/defaultthemes/1.preview.jpg)
         content/browser/defaultthemes/2.header.jpg    (content/defaultthemes/2.header.jpg)
         content/browser/defaultthemes/2.icon.jpg      (content/defaultthemes/2.icon.jpg)
         content/browser/defaultthemes/2.preview.jpg   (content/defaultthemes/2.preview.jpg)
         content/browser/defaultthemes/3.header.png    (content/defaultthemes/3.header.png)
diff --git a/browser/themes/shared/browser.inc.css b/browser/themes/shared/browser.inc.css
--- a/browser/themes/shared/browser.inc.css
+++ b/browser/themes/shared/browser.inc.css
@@ -10,16 +10,17 @@
 :root {
   /* Note: Setting this to 0 (without px) breaks CSS calculations for OSX. */
   --space-above-tabbar: 0px;
 }
 
 :root[extradragspace][tabsintitlebar]:not([inFullscreen]) {
   --space-above-tabbar: 8px;
 }
+%include customelements/custom-elements.inc.css
 
 /* Toolbar / content area border */
 
 #navigator-toolbox::after {
   content: "";
   display: -moz-box;
   border-bottom: 1px solid var(--toolbox-border-bottom-color);
 }
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -399,40 +399,42 @@ menucaption {
 /* <popup> is deprecated.  Only <menupopup> and <tooltip> are still valid. */
 
 popup,
 menupopup {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#popup");
   -moz-box-orient: vertical;
 }
 
+/*
 panel {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#panel");
   -moz-box-orient: vertical;
 }
-
+*/
 popup,
 menupopup,
 panel,
 tooltip {
   display: -moz-popup;
   z-index: 2147483647;
   text-shadow: none;
 }
 
 tooltip {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#tooltip");
   -moz-box-orient: vertical;
   white-space: pre-wrap;
   margin-top: 21px;
 }
 
+/*
 panel[type="arrow"] {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
-}
+}*/
 
 %ifdef MOZ_WIDGET_COCOA
 
 /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"
    instead of "transform" and "opacity" for these animations.
    The -moz-window* properties apply to the whole window including the window's
    shadow, and they don't affect the window's "shape", so the system doesn't
    have to recompute the shadow shape during the animation. This makes them a
