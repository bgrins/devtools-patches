
# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1504814281 25200
# Node ID 5acb5aac04e01366c15c53c7a9930ec4e6a92da5
# Parent  5f52c2488a831edbc33fa0bc6003ed4df9a62732
Bug 1397876 - Import Custom Elements polyfill and stub out the panel and arrowpanel bindings

The hamburger menu seems to work, but other panels don't (customize popup, awesomebar).

Steps I took to build this:
* Pull down polyfill from https://github.com/bgrins/custom-elements/tree/firefox-browser-chrome (includes fixes for XUL docs)
* Elements are pseudo generated from https://github.com/bgrins/xbl-analysis/tree/gh-pages/elements

MozReview-Commit-ID: iZTULEIwYY
* * *
Bug 1411707 - Migrate <stringbundle> from a XBL binding to a Custom Element

MozReview-Commit-ID: 2XxU8K5e7oF

diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -332,16 +332,20 @@ BrowserGlue.prototype = {
         this._openPreferences("privacy", { origin: "notifOpenSettings" });
         break;
       case "prefservice:after-app-defaults":
         this._onAppDefaults();
         break;
       case "final-ui-startup":
         this._beforeUIStartup();
         break;
+      case "chrome-document-global-created":
+        Services.scriptloader.loadSubScript("chrome://global/content/customelements.js",
+          subject.QueryInterface(Components.interfaces.nsIDOMWindow));
+        break;
       case "browser-delayed-startup-finished":
         this._onFirstWindowLoaded(subject);
         Services.obs.removeObserver(this, "browser-delayed-startup-finished");
         break;
       case "sessionstore-windows-restored":
         this._onWindowsRestored();
         break;
       case "browser:purge-session-history":
@@ -528,16 +532,17 @@ BrowserGlue.prototype = {
   },
 
   // initialization (called on application startup)
   _init: function BG__init() {
     let os = Services.obs;
     os.addObserver(this, "notifications-open-settings");
     os.addObserver(this, "prefservice:after-app-defaults");
     os.addObserver(this, "final-ui-startup");
+    os.addObserver(this, "chrome-document-global-created");
     os.addObserver(this, "browser-delayed-startup-finished");
     os.addObserver(this, "sessionstore-windows-restored");
     os.addObserver(this, "browser:purge-session-history");
     os.addObserver(this, "quit-application-requested");
     os.addObserver(this, "quit-application-granted");
     if (OBSERVE_LASTWINDOW_CLOSE_TOPICS) {
       os.addObserver(this, "browser-lastwindow-close-requested");
       os.addObserver(this, "browser-lastwindow-close-granted");
@@ -570,16 +575,17 @@ BrowserGlue.prototype = {
   },
 
   // cleanup (called on application shutdown)
   _dispose: function BG__dispose() {
     let os = Services.obs;
     os.removeObserver(this, "notifications-open-settings");
     os.removeObserver(this, "prefservice:after-app-defaults");
     os.removeObserver(this, "final-ui-startup");
+    os.removeObserver(this, "chrome-document-global-created");
     os.removeObserver(this, "sessionstore-windows-restored");
     os.removeObserver(this, "browser:purge-session-history");
     os.removeObserver(this, "quit-application-requested");
     os.removeObserver(this, "quit-application-granted");
     os.removeObserver(this, "restart-in-safe-mode");
     if (OBSERVE_LASTWINDOW_CLOSE_TOPICS) {
       os.removeObserver(this, "browser-lastwindow-close-requested");
       os.removeObserver(this, "browser-lastwindow-close-granted");
diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -3291,16 +3291,21 @@ nsContentUtils::NewURIWithDocumentCharse
   }
   return NS_NewURI(aResult, aSpec, nullptr, aBaseURI, sIOService);
 }
 
 // static
 bool
 nsContentUtils::IsCustomElementName(nsAtom* aName)
 {
+  // XXX: Only allow this in XUL docs (or change the tag name to be dashed and find/replace in the project)
+  if (aName == nsGkAtoms::stringbundle) {
+    return true;
+  }
+
   // A valid custom element name is a sequence of characters name which
   // must match the PotentialCustomElementName production:
   // PotentialCustomElementName ::= [a-z] (PCENChar)* '-' (PCENChar)*
   const char16_t* name = aName->GetUTF16String();
   uint32_t len = aName->GetLength();
   bool hasDash = false;
 
   if (!len || name[0] < 'a' || name[0] > 'z') {
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -1385,17 +1385,17 @@ pref("dom.event.clipboardevents.enabled"
 pref("dom.event.highrestimestamp.enabled",  true);
 #ifdef NIGHTLY_BUILD
 pref("dom.event.coalesce_mouse_move",       true);
 #else
 pref("dom.event.coalesce_mouse_move",       false);
 #endif
 
 pref("dom.webcomponents.enabled",           false);
-pref("dom.webcomponents.customelements.enabled", false);
+pref("dom.webcomponents.customelements.enabled", true);
 
 pref("javascript.enabled",                  true);
 pref("javascript.options.strict",           false);
 #ifdef DEBUG
 pref("javascript.options.strict.debug",     false);
 #endif
 pref("javascript.options.baselinejit",      true);
 pref("javascript.options.ion",              true);
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -40,16 +40,17 @@ toolkit.jar:
    content/global/browser-content.js
 *   content/global/buildconfig.html
    content/global/contentAreaUtils.js
 #ifndef MOZ_FENNEC
    content/global/customizeToolbar.css
    content/global/customizeToolbar.js
    content/global/customizeToolbar.xul
 #endif
+*  content/global/customelements.js   (widgets/customelements.js)
    content/global/datepicker.xhtml
 #ifndef MOZ_FENNEC
    content/global/editMenuOverlay.js
 *  content/global/editMenuOverlay.xul
    content/global/finddialog.js
 *  content/global/finddialog.xul
    content/global/findUtils.js
 #endif
diff --git a/toolkit/content/widgets/customelements.js b/toolkit/content/widgets/customelements.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/customelements.js
@@ -0,0 +1,3 @@
+
+#include panel.js
+
diff --git a/toolkit/content/widgets/panel.js b/toolkit/content/widgets/panel.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/panel.js
@@ -0,0 +1,540 @@
+// XXX: "downloadsPanel" doesn't get recognized by CE polyfill (xul overlay?)
+
+
+
+class FirefoxPopupBase extends BaseElement {
+
+  // XXX: Do we need to generateQI for nsIDOMXULPopupElement? The hamburger menu
+  // seems to open without this.
+  // get QueryInterface() {
+  //   return XPCOMUtils.generateQI([Ci.nsIDOMXULPopupElement]);
+  // }
+
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    console.log(this, "connected");
+
+    let comment = document.createComment("Creating firefox-popup-base");
+    this.prepend(comment);
+  }
+  disconnectedCallback() {}
+
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set position(val) {
+    this.setAttribute("position", val);
+    return val;
+  }
+
+  get position() {
+    return this.getAttribute("position");
+  }
+
+  get popupBoxObject() {
+    return this.boxObject;
+  }
+
+  get state() {
+    return this.popupBoxObject.popupState;
+  }
+
+  get triggerNode() {
+    return this.popupBoxObject.triggerNode;
+  }
+
+  get anchorNode() {
+    return this.popupBoxObject.anchorNode;
+  }
+
+  set autoPosition(val) {
+    return (this.popupBoxObject.autoPosition = val);
+  }
+
+  get autoPosition() {
+    return this.popupBoxObject.autoPosition;
+  }
+
+  get alignmentPosition() {
+    return this.popupBoxObject.alignmentPosition;
+  }
+
+  get alignmentOffset() {
+    return this.popupBoxObject.alignmentOffset;
+  }
+  openPopup(
+    aAnchorElement,
+    aPosition,
+    aX,
+    aY,
+    aIsContextMenu,
+    aAttributesOverride,
+    aTriggerEvent
+  ) {
+    // Allow for passing an options object as the second argument.
+    if (
+      arguments.length == 2 &&
+      arguments[1] != null &&
+      typeof arguments[1] == "object"
+    ) {
+      let params = arguments[1];
+      aPosition = params.position;
+      aX = params.x;
+      aY = params.y;
+      aIsContextMenu = params.isContextMenu;
+      aAttributesOverride = params.attributesOverride;
+      aTriggerEvent = params.triggerEvent;
+    }
+
+    dump(`openPopup ${aX} ${aY} ${this.popupBoxObject.openPopup}\n`);
+    try {
+      var popupBox = this.popupBoxObject;
+      if (popupBox)
+        popupBox.openPopup(
+          aAnchorElement,
+          aPosition,
+          aX,
+          aY,
+          aIsContextMenu,
+          aAttributesOverride,
+          aTriggerEvent
+        );
+    } catch (e) {
+      dump(`Caught ${e} \n`);
+    }
+  }
+  openPopupAtScreen(aX, aY, aIsContextMenu, aTriggerEvent) {
+    try {
+      var popupBox = this.popupBoxObject;
+      if (popupBox)
+        popupBox.openPopupAtScreen(aX, aY, aIsContextMenu, aTriggerEvent);
+    } catch (e) {}
+  }
+  openPopupAtScreenRect(
+    aPosition,
+    aX,
+    aY,
+    aWidth,
+    aHeight,
+    aIsContextMenu,
+    aAttributesOverride,
+    aTriggerEvent
+  ) {
+    try {
+      var popupBox = this.popupBoxObject;
+      if (popupBox)
+        popupBox.openPopupAtScreenRect(
+          aPosition,
+          aX,
+          aY,
+          aWidth,
+          aHeight,
+          aIsContextMenu,
+          aAttributesOverride,
+          aTriggerEvent
+        );
+    } catch (e) {}
+  }
+  showPopup(element, xpos, ypos, popuptype, anchoralignment, popupalignment) {
+    var popupBox = null;
+    var menuBox = null;
+    try {
+      popupBox = this.popupBoxObject;
+    } catch (e) {}
+    try {
+      menuBox = this.parentNode.boxObject;
+    } catch (e) {}
+    if (menuBox instanceof MenuBoxObject) menuBox.openMenu(true);
+    else if (popupBox)
+      popupBox.showPopup(
+        element,
+        this,
+        xpos,
+        ypos,
+        popuptype,
+        anchoralignment,
+        popupalignment
+      );
+  }
+  hidePopup(cancel) {
+    var popupBox = null;
+    var menuBox = null;
+    try {
+      popupBox = this.popupBoxObject;
+    } catch (e) {}
+    try {
+      menuBox = this.parentNode.boxObject;
+    } catch (e) {}
+    if (menuBox instanceof MenuBoxObject) menuBox.openMenu(false);
+    else if (popupBox instanceof PopupBoxObject) popupBox.hidePopup(cancel);
+  }
+  enableKeyboardNavigator(aEnableKeyboardNavigator) {
+    this.popupBoxObject.enableKeyboardNavigator(aEnableKeyboardNavigator);
+  }
+  enableRollup(aEnableRollup) {
+    this.popupBoxObject.enableRollup(aEnableRollup);
+  }
+  sizeTo(aWidth, aHeight) {
+    this.popupBoxObject.sizeTo(aWidth, aHeight);
+  }
+  moveTo(aLeft, aTop) {
+    this.popupBoxObject.moveTo(aLeft, aTop);
+  }
+  moveToAnchor(aAnchorElement, aPosition, aX, aY, aAttributesOverride) {
+    this.popupBoxObject.moveToAnchor(
+      aAnchorElement,
+      aPosition,
+      aX,
+      aY,
+      aAttributesOverride
+    );
+  }
+  getOuterScreenRect() {
+    return this.popupBoxObject.getOuterScreenRect();
+  }
+  setConstraintRect(aRect) {
+    this.popupBoxObject.setConstraintRect(aRect);
+  }
+}
+customElements.define("firefox-popup-base", FirefoxPopupBase);
+
+
+class FirefoxPanel extends FirefoxPopupBase {
+
+
+  // XXX: Do we need to generateQI for nsIDOMXULPopupElement? The hamburger menu
+  // seems to open without this.
+  // get QueryInterface() {
+  //   return XPCOMUtils.generateQI([Ci.nsIDOMXULPopupElement]);
+  // }
+
+  constructor() {
+    super();
+  }
+  connectedCallback() {
+    super.connectedCallback();
+    dump(`connectedCallback FirefoxPanel ${this.id}\n`);
+
+    let comment = document.createComment("Creating firefox-panel");
+    this.prepend(comment);
+
+    Object.defineProperty(this, "_prevFocus", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._prevFocus;
+        return (this._prevFocus = 0);
+      },
+      set(val) {
+        delete this._prevFocus;
+        return (this._prevFocus = val);
+      }
+    });
+    Object.defineProperty(this, "_dragBindingAlive", {
+      configurable: true,
+      enumerable: true,
+      get() {
+        delete this._dragBindingAlive;
+        return (this._dragBindingAlive = true);
+      },
+      set(val) {
+        delete this._dragBindingAlive;
+        return (this._dragBindingAlive = val);
+      }
+    });
+
+    if (this.getAttribute("backdrag") == "true" && !this._draggableStarted) {
+      this._draggableStarted = true;
+      try {
+        let tmp = {};
+        Components.utils.import(
+          "resource://gre/modules/WindowDraggingUtils.jsm",
+          tmp
+        );
+        let draghandle = new tmp.WindowDraggingElement(this);
+        draghandle.mouseDownCheck = function() {
+          return this._dragBindingAlive;
+        };
+      } catch (e) {}
+    }
+
+    this.addEventListener("popupshowing", event => {
+      // Capture the previous focus before has a chance to get set inside the panel
+      try {
+        this._prevFocus = Components.utils.getWeakReference(
+          document.commandDispatcher.focusedElement
+        );
+        if (this._prevFocus.get()) return;
+      } catch (ex) {}
+
+      this._prevFocus = Components.utils.getWeakReference(
+        document.activeElement
+      );
+    });
+
+    this.addEventListener("popupshown", event => {
+      // Fire event for accessibility APIs
+      var alertEvent = document.createEvent("Events");
+      alertEvent.initEvent("AlertActive", true, true);
+      this.dispatchEvent(alertEvent);
+    });
+
+    this.addEventListener("popuphiding", event => {
+      try {
+        this._currentFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        this._currentFocus = document.activeElement;
+      }
+    });
+
+    this.addEventListener("popuphidden", event => {
+      function doFocus() {
+        // Focus was set on an element inside this panel,
+        // so we need to move it back to where it was previously
+        try {
+          let fm = Components.classes[
+            "@mozilla.org/focus-manager;1"
+          ].getService(Components.interfaces.nsIFocusManager);
+          fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
+        } catch (e) {
+          prevFocus.focus();
+        }
+      }
+      var currentFocus = this._currentFocus;
+      var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
+      this._currentFocus = null;
+      this._prevFocus = null;
+
+      // Avoid changing focus if focus changed while we hide the popup
+      // (This can happen e.g. if the popup is hiding as a result of a
+      // click/keypress that focused something)
+      let nowFocus;
+      try {
+        nowFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        nowFocus = document.activeElement;
+      }
+      if (nowFocus && nowFocus != currentFocus) return;
+
+      if (prevFocus && this.getAttribute("norestorefocus") != "true") {
+        // Try to restore focus
+        try {
+          if (document.commandDispatcher.focusedWindow != window) return; // Focus has already been set to a window outside of this panel
+        } catch (ex) {}
+
+        if (!currentFocus) {
+          doFocus();
+          return;
+        }
+        while (currentFocus) {
+          if (currentFocus == this) {
+            doFocus();
+            return;
+          }
+          currentFocus = currentFocus.parentNode;
+        }
+      }
+    });
+
+    // Special case for other bindings like arrowpanel, because platform has code
+    // looking for the 'panel' tag but custom elements don't let us register an element
+    // based on an attribute value. So we need to fold in the arrow functionality in that case.
+    if (this.getAttribute("type") === "arrow") {
+      dump(`Got an arrow popup ${this.id}\n`);
+      ArrowPanelConnectedCallback.call(this);
+    }
+  }
+  disconnectedCallback() {}
+}
+
+customElements.define("panel", FirefoxPanel);
+
+
+function ArrowPanelConnectedCallback() {
+  console.log(this, "connected");
+
+  // XXX: This simulates the <children> tag inside the panel-arrowcontent
+  let frag = document.createElement("box");
+  frag.innerHTML = `<vbox anonid="container" class="panel-arrowcontainer" flex="1" inherits="side,panelopen">
+<box anonid="arrowbox" class="panel-arrowbox">
+<image anonid="arrow" class="panel-arrow" inherits="side">
+</image>
+</box>
+<box class="panel-arrowcontent" inherits="side,align,dir,orient,pack" flex="1">
+</box>
+</vbox>`
+
+  let nodes = [...this.childNodes];
+  for (var i = 0; i < nodes.length; i++) {
+    dump("Adding " + i + " " + nodes[i].localName + "\n");
+    frag.querySelector(".panel-arrowcontent").appendChild(nodes[i]);
+  }
+
+  this.innerHTML = '';
+
+  nodes = [...frag.childNodes];
+  for (var i = 0; i < nodes.length; i++) {
+    this.appendChild(nodes[i]);
+  }
+
+  let comment = document.createComment("Creating firefox-arrowpanel");
+  this.prepend(comment);
+
+  Object.defineProperty(this, "_fadeTimer", {
+    configurable: true,
+    enumerable: true,
+    get() {
+      delete this._fadeTimer;
+      return (this._fadeTimer = null);
+    },
+    set(val) {
+      delete this._fadeTimer;
+      return (this._fadeTimer = val);
+    }
+  });
+
+  this.addEventListener("popupshowing", event => {
+    dump("popupshowing\n");
+    var arrow = this.querySelector("[anonid=arrow]");
+    arrow.hidden = this.anchorNode == null;
+    this.querySelector("[anonid=arrowbox]").style.removeProperty("transform");
+
+    this.adjustArrowPosition();
+
+    if (this.getAttribute("animate") != "false") {
+      this.setAttribute("animate", "open");
+      // the animating attribute prevents user interaction during transition
+      // it is removed when popupshown fires
+      this.setAttribute("animating", "true");
+    }
+
+    // set fading
+    var fade = this.getAttribute("fade");
+    var fadeDelay = 0;
+    if (fade == "fast") {
+      fadeDelay = 1;
+    } else if (fade == "slow") {
+      fadeDelay = 4000;
+    } else {
+      return;
+    }
+
+    this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
+  });
+
+  this.addEventListener("popuphiding", event => {
+    dump("popuphiding\n");
+    let animate = this.getAttribute("animate") != "false";
+
+    if (this._fadeTimer) {
+      clearTimeout(this._fadeTimer);
+      if (animate) {
+        this.setAttribute("animate", "fade");
+      }
+    } else if (animate) {
+      this.setAttribute("animate", "cancel");
+    }
+  });
+
+  this.addEventListener("popupshown", event => {
+    dump("popupshown\n");
+    this.removeAttribute("animating");
+    this.setAttribute("panelopen", "true");
+  });
+
+  this.addEventListener("popuphidden", event => {
+    dump("popuphidden\n");
+    this.removeAttribute("panelopen");
+    if (this.getAttribute("animate") != "false") {
+      this.removeAttribute("animate");
+    }
+  });
+
+  this.addEventListener("popuppositioned", event => {
+    dump("popuppositioned\n");
+    this.adjustArrowPosition();
+  });
+
+  this.sizeTo = (aWidth, aHeight) => {
+    this.popupBoxObject.sizeTo(aWidth, aHeight);
+    if (this.state == "open") {
+      this.adjustArrowPosition();
+    }
+  }
+
+  this.moveToAnchor = (aAnchorElement, aPosition, aX, aY, aAttributesOverride) => {
+    this.popupBoxObject.moveToAnchor(
+      aAnchorElement,
+      aPosition,
+      aX,
+      aY,
+      aAttributesOverride
+    );
+  }
+
+
+  this.adjustArrowPosition = () => {
+    var anchor = this.anchorNode;
+    if (!anchor) {
+      return;
+    }
+
+    var container = this.querySelector("[anonid=container]");
+    var arrowbox = this.querySelector("[anonid=arrowbox]");
+
+    var position = this.alignmentPosition;
+    var offset = this.alignmentOffset;
+
+    this.setAttribute("arrowposition", position);
+
+    if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
+      container.orient = "horizontal";
+      arrowbox.orient = "vertical";
+      if (position.indexOf("_after") > 0) {
+        arrowbox.pack = "end";
+      } else {
+        arrowbox.pack = "start";
+      }
+      arrowbox.style.transform = "translate(0, " + -offset + "px)";
+
+      // The assigned side stays the same regardless of direction.
+      var isRTL = window.getComputedStyle(this).direction == "rtl";
+
+      if (position.indexOf("start_") == 0) {
+        container.dir = "reverse";
+        this.setAttribute("side", isRTL ? "left" : "right");
+      } else {
+        container.dir = "";
+        this.setAttribute("side", isRTL ? "right" : "left");
+      }
+    } else if (
+      position.indexOf("before_") == 0 ||
+      position.indexOf("after_") == 0
+    ) {
+      container.orient = "";
+      arrowbox.orient = "";
+      if (position.indexOf("_end") > 0) {
+        arrowbox.pack = "end";
+      } else {
+        arrowbox.pack = "start";
+      }
+      arrowbox.style.transform = "translate(" + -offset + "px, 0)";
+
+      if (position.indexOf("before_") == 0) {
+        container.dir = "reverse";
+        this.setAttribute("side", "bottom");
+      } else {
+        container.dir = "";
+        this.setAttribute("side", "top");
+      }
+    }
+  }
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -400,17 +400,16 @@ menucaption {
 
 popup,
 menupopup {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#popup");
   -moz-box-orient: vertical;
 }
 
 panel {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#panel");
   -moz-box-orient: vertical;
 }
 
 popup,
 menupopup,
 panel,
 tooltip {
   display: -moz-popup;
@@ -420,20 +419,16 @@ tooltip {
 
 tooltip {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#tooltip");
   -moz-box-orient: vertical;
   white-space: pre-wrap;
   margin-top: 21px;
 }
 
-panel[type="arrow"] {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
-}
-
 %ifdef MOZ_WIDGET_COCOA
 
 /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"
    instead of "transform" and "opacity" for these animations.
    The -moz-window* properties apply to the whole window including the window's
    shadow, and they don't affect the window's "shape", so the system doesn't
    have to recompute the shadow shape during the animation. This makes them a
    lot faster. In fact, Gecko no longer triggers shadow shape recomputations
