# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  bac9e28a8d6cec21a699c8ed3e54aff2e2204554

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1902,16 +1902,47 @@ RuleEditor.prototype = {
     this.selectorContainer = createChild(header, "span", {
       class: "ruleview-selectorcontainer"
     });
 
     this.selectorText = createChild(this.selectorContainer, "span", {
       class: "ruleview-selector theme-fg-color3"
     });
 
+
+    // JUST FOR TESTING FOR NOW
+    // Element transformer tool
+    this.ruleView.inspector.toolbox
+        .highlighterUtils.getHighlighterByType("PositionedElementTransformer")
+        .then(highlighter => {
+
+      let button = this.doc.createElement("button");
+      button.textContent = "transform";
+      this.selectorContainer.appendChild(button);
+      let isTransforming = false;
+      button.addEventListener("click", () => {
+        if (isTransforming) {
+          // hide
+          isTransforming = false;
+          highlighter.hide();
+        } else {
+          isTransforming = true;
+          highlighter.show(this.ruleView.inspector.selection.nodeFront, {
+            cssRuleActorId: this.rule.domRule.actorID
+          });
+        }
+      });
+      this.ruleView.inspector.selection.once("new-node-front", () => {
+        isTransforming = false;
+        highlighter.hide();
+      });
+
+    });
+
+
     if (this.isSelectorEditable) {
       this.selectorContainer.addEventListener("click", aEvent => {
         // Clicks within the selector shouldn't propagate any further.
         aEvent.stopPropagation();
       }, false);
 
       editableField({
         element: this.selectorText,
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -173,8 +173,32 @@
 
 /* Rect highlighter */
 
 :-moz-native-anonymous .highlighted-rect {
   position: absolute;
   background: #80d4ff;
   opacity: 0.8;
 }
+
+/* Element transformer */
+
+:-moz-native-anonymous .element-transformer-handle {
+  position: absolute;
+}
+
+:-moz-native-anonymous .element-transformer-handle::before {
+  content: "";
+
+  display: block;
+  width: 20px;
+  height: 20px;
+  position: relative;
+  left: -10px;
+  top: -10px;
+  background: #ccc;
+  box-shadow: 1px 1px 0 0 #aaa;
+  cursor: move;
+}
+
+:-moz-native-anonymous .element-transformer-handle.active::before {
+  background: yellow;
+}
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -39,23 +39,26 @@ const MAX_HIGHLIGHTED_ELEMENTS = 100;
 const HIGHLIGHTED_PSEUDO_CLASS = ":-moz-devtools-highlighted";
 const SIMPLE_OUTLINE_SHEET = ".__fx-devtools-hide-shortcut__ {" +
                              "  visibility: hidden !important" +
                              "}" +
                              HIGHLIGHTED_PSEUDO_CLASS + " {" +
                              "  outline: 2px dashed #F06!important;" +
                              "  outline-offset: -2px!important;" +
                              "}";
+// Hit area for the handles of the transformer highlighter
+const HANDLE_HIT_AREA_SIZE = 40;
 
 // All possible highlighter classes
 let HIGHLIGHTER_CLASSES = exports.HIGHLIGHTER_CLASSES = {
   "BoxModelHighlighter": BoxModelHighlighter,
   "CssTransformHighlighter": CssTransformHighlighter,
   "SelectorHighlighter": SelectorHighlighter,
-  "RectHighlighter": RectHighlighter
+  "RectHighlighter": RectHighlighter,
+  "PositionedElementTransformer": PositionedElementTransformer
 };
 
 /**
  * The Highlighter is the server-side entry points for any tool that wishes to
  * highlight elements in some way in the content document.
  *
  * A little bit of vocabulary:
  * - <something>HighlighterActor classes are the actors that can be used from
@@ -242,44 +245,27 @@ let HighlighterActor = exports.Highlight
 
     let x = event.clientX;
     let y = event.clientY;
 
     let node = doc.elementFromPoint(x, y);
     return this._walker.attachElement(node);
   },
 
-  /**
-   * Get the right target for listening to mouse events while in pick mode.
-   * - On a firefox desktop content page: tabActor is a BrowserTabActor from
-   *   which the browser property will give us a target we can use to listen to
-   *   events, even in nested iframes.
-   * - On B2G: tabActor is a ContentActor which doesn't have a browser but
-   *   since it overrides BrowserTabActor, it does get a browser property
-   *   anyway, which points to its window object.
-   * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
-   *   the RootActor, in which case, the window property can be used to listen
-   *   to events
-   */
-  _getPickerListenerTarget: function() {
-    let actor = this._tabActor;
-    return actor.isRootActor ? actor.window : actor.chromeEventHandler;
-  },
-
   _startPickerListeners: function() {
-    let target = this._getPickerListenerTarget();
+    let target = getPageListenerTarget(this._tabActor);
     target.addEventListener("mousemove", this._onHovered, true);
     target.addEventListener("click", this._onPick, true);
     target.addEventListener("mousedown", this._preventContentEvent, true);
     target.addEventListener("mouseup", this._preventContentEvent, true);
     target.addEventListener("dblclick", this._preventContentEvent, true);
   },
 
   _stopPickerListeners: function() {
-    let target = this._getPickerListenerTarget();
+    let target = getPageListenerTarget(this._tabActor);
     target.removeEventListener("mousemove", this._onHovered, true);
     target.removeEventListener("click", this._onPick, true);
     target.removeEventListener("mousedown", this._preventContentEvent, true);
     target.removeEventListener("mouseup", this._preventContentEvent, true);
     target.removeEventListener("dblclick", this._preventContentEvent, true);
   },
 
   _highlighterReady: function() {
@@ -1683,16 +1669,315 @@ RectHighlighter.prototype = {
     this.markup.removeAttributeForElement("highlighted-rect", "hidden");
   },
 
   hide: function() {
     this.markup.setAttributeForElement("highlighted-rect", "hidden", "true");
   }
 };
 
+function Handle(tabActor, position={x: 0, y: 0}, fixX, fixY) {
+  EventEmitter.decorate(this);
+
+  this.currentPosition = {
+    x: position.x,
+    y: position.y
+  };
+
+  this.tabActor = tabActor;
+
+  this.fixX = fixX;
+  this.fixY = fixY;
+
+  this.onMouseDown = this.onMouseDown.bind(this);
+  this.onMouseUp = this.onMouseUp.bind(this);
+  this.onMouseMove = this.onMouseMove.bind(this);
+
+  this.startListeners();
+}
+
+Handle.prototype = {
+  startListeners: function() {
+    let target = getPageListenerTarget(this.tabActor);
+    target.addEventListener("mousedown", this.onMouseDown);
+  },
+
+  stopListeners: function() {
+    let target = getPageListenerTarget(this.tabActor);
+    target.removeEventListener("mousedown", this.onMouseDown);
+  },
+
+  destroy: function() {
+    this.stopListeners();
+    this.tabActor = null;
+  },
+
+  onMouseDown: function(event) {
+    // Check if the mouse down occured in the handle.
+    let x = event.clientX;
+    let y = event.clientY;
+
+    if (x > this.currentPosition.x + HANDLE_HIT_AREA_SIZE/2 ||
+        x < this.currentPosition.x - HANDLE_HIT_AREA_SIZE/2 ||
+        y > this.currentPosition.y + HANDLE_HIT_AREA_SIZE/2 ||
+        y < this.currentPosition.y - HANDLE_HIT_AREA_SIZE/2) {
+      return;
+    }
+
+    // Prevent the event from having any effect on the page.
+    event.stopPropagation();
+    event.preventDefault();
+
+    let target = getPageListenerTarget(this.tabActor);
+    target.addEventListener("mousemove", this.onMouseMove);
+    target.addEventListener("mouseup", this.onMouseUp);
+  },
+
+  onMouseUp: function(event) {
+    // Prevent the event from having any effect on the page.
+    event.stopPropagation();
+    event.preventDefault();
+
+    let target = getPageListenerTarget(this.tabActor);
+    target.removeEventListener("mousemove", this.onMouseMove);
+    target.removeEventListener("mouseup", this.onMouseUp);
+  },
+
+  onMouseMove: function(event) {
+    // Prevent the event from having any effect on the page.
+    event.stopPropagation();
+    event.preventDefault();
+
+    this.currentPosition = {
+      x: this.fixX ? this.currentPosition.x : event.clientX,
+      y: this.fixY ? this.currentPosition.y : event.clientY
+    };
+
+    this.emit("drag-move");
+  }
+};
+
+// TODO:
+// - jsdoc
+// - constrain dragging to when element is 0 width/height
+// - constrain dragging to the edge of the viewport
+// - add handles for width/height if defined
+// - add labels for top/left/...
+// - bottom/right don't work well in all situations
+// - front-end code is shit
+// - the style rule doesn't update live
+function PositionedElementTransformer(tabActor) {
+  AutoRefreshHighlighter.call(this, tabActor);
+
+  this.onDragMove = this.onDragMove.bind(this);
+
+  this.markup = new CanvasFrameAnonymousContentHelper(tabActor,
+    this._buildMarkup.bind(this));
+}
+
+PositionedElementTransformer.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
+  ID_CLASS_PREFIX: "element-transformer-",
+
+  _buildMarkup: function() {
+    let doc = this.win.document;
+
+    let container = doc.createElement("div");
+    container.className = "highlighter-container";
+
+    let topLeftHandle = createNode(this.win, {
+      parent: container,
+      attributes: {
+        "id": "top-left-handle",
+        "class": "handle top-left",
+        "hidden": "true"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
+    let bottomRightHandle = createNode(this.win, {
+      parent: container,
+      attributes: {
+        "id": "bottom-right-handle",
+        "class": "handle bottom-right",
+        "hidden": "true"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
+    return container;
+  },
+
+  destroy: function() {
+    AutoRefreshHighlighter.prototype.destroy.call(this);
+    this.markup.destroy();
+  },
+
+  isPositioned: function(style) {
+    let pos = style.getPropertyValue("position");
+    return pos === "absolute" || pos === "relative" || pos === "fixed";
+  },
+
+  _show: function() {
+    if (!this.options.cssRuleActorId ||
+        !this.tabActor.conn.getActor(this.options.cssRuleActorId)) {
+      this.hide();
+      throw new Error("Missing CSS rule ActorID to manipulate a positioned element");
+    }
+
+    // Access the css rule that we want to update with this transformer.
+    this.cssRule = this.tabActor.conn.getActor(this.options.cssRuleActorId).rawRule;
+    if (!this.isPositioned(this.cssRule.style)) {
+      this.hide();
+      throw new Error("The element isn't positioned");
+    }
+
+    let bounds = this.currentQuads.content.bounds;
+
+    for (let side of ["top", "left", "bottom", "right"]) {
+      // Get the coordinate from the property value. This will be a string
+      // with unit, or an empty string if not set.
+      let propertyValue = this.cssRule.style.getPropertyValue(side);
+
+      let computedSize = bounds[side];
+      // Invert bottom and right positions.
+      if (side === "bottom") {
+        let offsetParentHeight = this.currentNode.offsetParent.offsetHeight ||
+                                 this.currentNode.ownerDocument.documentElement.clientHeight;
+        computedSize = offsetParentHeight - computedSize;
+      }
+      if (side === "right") {
+        let offsetParentWidth = this.currentNode.offsetParent.offsetWidth ||
+                                 this.currentNode.ownerDocument.documentElement.clientWidth;
+        computedSize = offsetParentWidth - computedSize;
+      }
+
+      this[side] = {
+        propertyValue: propertyValue,
+        // Positions might be expressed in any units. It's important to know
+        // the unit in order to change the rule style appropriately when handles
+        // are moved.
+        unit: this.getDistanceUnit(propertyValue),
+        ratio: parseFloat(propertyValue) / parseFloat(computedSize)
+      };
+    }
+
+    if (!this.top.propertyValue && !this.left.propertyValue &&
+        !this.bottom.propertyValue && !this.right.propertyValue) {
+      this.hide();
+      throw new Error("The element isn't positioned");
+    }
+
+    // Create the handles.
+    this.topLeftHandle = new Handle(this.tabActor, {
+      x: bounds.left,
+      y: bounds.top
+    }, !this.left.propertyValue, !this.top.propertyValue);
+
+    this.bottomRightHandle = new Handle(this.tabActor, {
+      x: bounds.right,
+      y: bounds.bottom
+    }, !this.right.propertyValue, !this.bottom.propertyValue);
+
+    this._showHandles();
+    this._update();
+
+    this.topLeftHandle.on("drag-move", this.onDragMove);
+    this.bottomRightHandle.on("drag-move", this.onDragMove);
+  },
+
+  getDistanceUnit: function(propertyValue) {
+    let [unitStr] = /[^\d.]+/g.exec(propertyValue) || [""];
+    return unitStr;
+  },
+
+  _update: function() {
+    // _update is called when the current node's geometry changes, so that's
+    // when we need to move the handles accordingly.
+    this._moveHandles({
+      x: this.currentQuads.content.bounds.left,
+      y: this.currentQuads.content.bounds.top
+    }, {
+      x: this.currentQuads.content.bounds.right,
+      y: this.currentQuads.content.bounds.bottom
+    });
+  },
+
+  onDragMove: function() {
+    // When the handles move, set the corresponding css rule properties.
+    for (let [handle, side] of [[this.topLeftHandle, "top"],
+                                [this.topLeftHandle, "left"],
+                                [this.bottomRightHandle, "bottom"],
+                                [this.bottomRightHandle, "right"]]) {
+      if (this[side].propertyValue) {
+        let axis = side === "top" || side === "bottom" ? "y" : "x";
+        let handlePos = handle.currentPosition[axis];
+        // Invert bottom and right positions.
+        if (side === "bottom") {
+          let offsetParentHeight = this.currentNode.offsetParent.offsetHeight ||
+                                   this.currentNode.ownerDocument.documentElement.clientHeight;
+          handlePos = offsetParentHeight - handlePos;
+        }
+        if (side === "right") {
+          let offsetParentWidth = this.currentNode.offsetParent.offsetWidth ||
+                                   this.currentNode.ownerDocument.documentElement.clientWidth;
+          handlePos = offsetParentWidth - handlePos;
+        }
+        let newPos = handlePos * this[side].ratio
+        this.cssRule.style.setProperty(side, newPos + this[side].unit);
+      }
+    }
+  },
+
+  _hide: function() {
+    this._hideHandles();
+
+    if (this.topLeftHandle && this.bottomRightHandle) {
+      this.topLeftHandle.off("drag-move", this.onDragMove);
+      this.bottomRightHandle.off("drag-move", this.onDragMove);
+      this.topLeftHandle.destroy();
+      this.bottomRightHandle.destroy();
+    }
+
+    this.cssRule = null;
+  },
+
+  _showHandles: function() {
+    setIgnoreLayoutChanges(true);
+    if (this.left.propertyValue || this.top.propertyValue) {
+      this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX +
+        "top-left-handle", "hidden");
+    }
+    if (this.right.propertyValue || this.bottom.propertyValue) {
+      this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX +
+        "bottom-right-handle", "hidden");
+    }
+    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+  },
+
+  _hideHandles: function() {
+    setIgnoreLayoutChanges(true);
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX +
+      "top-left-handle", "hidden", "true");
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX +
+      "bottom-right-handle", "hidden", "true");
+    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+  },
+
+  _moveHandles: function(topLeftPos, bottomRightPos) {
+    setIgnoreLayoutChanges(true);
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX +
+      "top-left-handle", "style",
+      "top:" + topLeftPos.y + "px;left:" + topLeftPos.x + "px;");
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX +
+      "bottom-right-handle", "style",
+      "top:" + bottomRightPos.y + "px;left:" + bottomRightPos.x + "px;");
+    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+  }
+});
+
 /**
  * The SimpleOutlineHighlighter is a class that has the same API than the
  * BoxModelHighlighter, but adds a pseudo-class on the target element itself
  * to draw a simple css outline around the element.
  * It is used by the HighlighterActor when canvasframe-based highlighters can't
  * be used. This is the case for XUL windows.
  */
 function SimpleOutlineHighlighter(tabActor) {
@@ -1833,11 +2118,28 @@ function createNode(win, options) {
 
   if (options.parent) {
     options.parent.appendChild(node);
   }
 
   return node;
 }
 
+/**
+ * Get the right target for listening to events on the page (while picking an
+ * element for instance).
+ * - On a firefox desktop content page: tabActor is a BrowserTabActor from
+ *   which the browser property will give us a target we can use to listen to
+ *   events, even in nested iframes.
+ * - On B2G: tabActor is a ContentActor which doesn't have a browser but
+ *   since it overrides BrowserTabActor, it does get a browser property
+ *   anyway, which points to its window object.
+ * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
+ *   the RootActor, in which case, the window property can be used to listen
+ *   to events
+ */
+function getPageListenerTarget(tabActor) {
+  return tabActor.isRootActor ? tabActor.window : tabActor.chromeEventHandler;
+}
+
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
 });
diff --git a/toolkit/devtools/server/actors/root.js b/toolkit/devtools/server/actors/root.js
--- a/toolkit/devtools/server/actors/root.js
+++ b/toolkit/devtools/server/actors/root.js
@@ -124,17 +124,18 @@ RootActor.prototype = {
     // remotely highlight nodes (see server/actors/highlighter.js)
     highlightable: true,
     // Which custom highlighter does the server-side highlighter actor supports?
     // (see server/actors/highlighter.js)
     customHighlighters: [
       "BoxModelHighlighter",
       "CssTransformHighlighter",
       "SelectorHighlighter",
-      "RectHighlighter"
+      "RectHighlighter",
+      "PositionedElementTransformer"
     ],
     // Whether the inspector actor implements the getImageDataFromURL
     // method that returns data-uris for image URLs. This is used for image
     // tooltips for instance
     urlToImageDataResolver: true,
     networkMonitor: true,
     // Whether the storage inspector actor to inspect cookies, etc.
     storageInspector: true,
