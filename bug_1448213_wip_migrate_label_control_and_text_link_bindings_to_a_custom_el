# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1536773841 25200
#      Wed Sep 12 10:37:21 2018 -0700
# Node ID 40a6dd53015b3ec69f1be2b79f21a71ff4cee066
# Parent  a4d59073254789540cc9547a4233ff2ecd70a19b
Bug 1448213 - WIP - Migrate label-control and text-link bindings to a Custom Element;

Differential Revision: https://phabricator.services.mozilla.com/D5686

diff --git a/dom/tests/mochitest/chrome/test_elements_proto.xul b/dom/tests/mochitest/chrome/test_elements_proto.xul
--- a/dom/tests/mochitest/chrome/test_elements_proto.xul
+++ b/dom/tests/mochitest/chrome/test_elements_proto.xul
@@ -12,21 +12,19 @@
 
   <script type="application/javascript">
   <![CDATA[
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     SimpleTest.waitForExplicitFinish();
 
     addLoadEvent(() => {
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "label")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "label") instanceof XULTextElement,
         `<label> should be of XULTextElement type`);
 
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "description")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "description") instanceof XULTextElement,
         `<description> should be of XULTextElement type`);
 
       SimpleTest.finish();
     });
   ]]>
   </script>
 </window>
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -863,17 +863,17 @@ nsTextBoxFrame::CalculateTitleForWidth(g
 // but the mTitle doesn't have the character
 void
 nsTextBoxFrame::UpdateAccessTitle()
 {
     /*
      * Note that if you change appending access key label spec,
      * you need to maintain same logic in following methods. See bug 324159.
      * toolkit/components/prompts/src/CommonDialog.jsm (setLabelForNode)
-     * toolkit/content/widgets/text.xml (formatAccessKey)
+     * toolkit/content/widgets/text.js (formatAccessKey)
      */
     int32_t menuAccessKey;
     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
     if (!menuAccessKey || mAccessKey.IsEmpty())
         return;
 
     if (!AlwaysAppendAccessKey() &&
         FindInReadable(mAccessKey, mTitle, nsCaseInsensitiveStringComparator()))
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -289,16 +289,17 @@ window.MozBaseControl = MozBaseControl;
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/progressmeter.js",
     "chrome://global/content/elements/radio.js",
+    "chrome://global/content/elements/text.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
     "chrome://global/content/elements/tree.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
   for (let [tag, script] of [
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -79,32 +79,32 @@ toolkit.jar:
    content/global/bindings/notification.xml    (widgets/notification.xml)
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
 *  content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
-   content/global/bindings/text.xml            (widgets/text.xml)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js          (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/progressmeter.js    (widgets/progressmeter.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
+   content/global/elements/text.js             (widgets/text.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
    content/global/gmp-sources/widevinecdm.json (gmp-sources/widevinecdm.json)
diff --git a/toolkit/content/tests/chrome/test_labelcontrol.xul b/toolkit/content/tests/chrome/test_labelcontrol.xul
--- a/toolkit/content/tests/chrome/test_labelcontrol.xul
+++ b/toolkit/content/tests/chrome/test_labelcontrol.xul
@@ -6,38 +6,36 @@
   -->
 <window title="tabindex" width="500" height="600"
         onload="runTests()"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>  
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>  
 
 <label id="lab" control="ctl"/>
-<textbox id="ctl" value="Test"/>
-<checkbox id="chk" value="Checkbox"/>
+<checkbox id="ctl" value="Checkbox"/>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
 <p id="display"></p>
 <div id="content" style="display: none">
 </div>
 <pre id="test">
 </pre>
 </body>
 
 <script>
 <![CDATA[
 
 SimpleTest.waitForExplicitFinish();
- 
+
 function runTests()
 {
   is($("lab").control, "ctl", "control");
   is($("lab").labeledControlElement, $("ctl"), "labeledControlElement");
   is($("ctl").labelElement, $("lab"), "labelElement");
-  is($("chk").labelElement.className, "checkbox-label", "labelElement");
 
   SimpleTest.finish();
 }
 
 ]]>
 
 </script>
 
diff --git a/toolkit/content/widgets/general.xml b/toolkit/content/widgets/general.xml
--- a/toolkit/content/widgets/general.xml
+++ b/toolkit/content/widgets/general.xml
@@ -28,33 +28,40 @@
       <property name="label"      onset="this.setAttribute('label',val); return val;"
                                   onget="return this.getAttribute('label');"/>
       <property name="crop"       onset="this.setAttribute('crop',val); return val;"
                                   onget="return this.getAttribute('crop');"/>
       <property name="image"      onset="this.setAttribute('image',val); return val;"
                                   onget="return this.getAttribute('image');"/>
       <property name="command"    onset="this.setAttribute('command',val); return val;"
                                   onget="return this.getAttribute('command');"/>
+      <property name="labelElement">
+        <getter>
+          <![CDATA[
+            return document.getElementsByAttribute("control", this.id)[0];
+          ]]>
+        </getter>
+      </property>
       <property name="accessKey">
         <getter>
           <![CDATA[
-            return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+            let labelElement = this.labelElement;
+            return labelElement ? labelElement.accessKey : this.getAttribute("accesskey");
           ]]>
         </getter>
         <setter>
           <![CDATA[
             // Always store on the control
             this.setAttribute("accesskey", val);
             // If there is a label, change the accesskey on the labelElement
             // if it's also set there
-            if (this.labelElement) {
-              this.labelElement.accessKey = val;
+            let labelElement = this.labelElement;
+            if (labelElement) {
+              labelElement.accessKey = val;
             }
             return val;
           ]]>
         </setter>
       </property>
-
-      <field name="labelElement"/>
     </implementation>
   </binding>
 
 </bindings>
diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/text.js
@@ -0,0 +1,355 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+/* globals MozElementMixin,XULTextElement */
+class MozTextLabel extends MozElementMixin(XULTextElement) {
+  static get observedAttributes() {
+    return ["accesskey", "text"];
+  }
+
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady || oldValue == newValue) {
+      return;
+    }
+    this.formatAccessKey();
+  }
+
+  get needsFormatting() {
+    return this.hasAttribute("control") ||
+           this.classList.contains("radio-label") ||
+           this.classList.contains("checkbox-label") ||
+           this.classList.contains("toolbarbutton-multiline-text");
+  }
+
+  _onClick(event) {
+    if (this.isTextLink) {
+      if (event.button == 0 || event.button == 1) {
+        this.openLink(event);
+      }
+      return;
+    }
+
+    var controlElement = this.labeledControlElement;
+    if (!controlElement || this.disabled) {
+      return;
+    }
+    controlElement.focus();
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+    if (controlElement.namespaceURI != XUL_NS) {
+      return;
+    }
+    if (controlElement.localName == "checkbox") {
+      controlElement.checked = !controlElement.checked;
+    } else if (controlElement.localName == "radio") {
+      controlElement.control.selectedItem = controlElement;
+    }
+  }
+
+  _onKeyPress(event) {
+    if (event.keyCode == 13) {
+      this.click();
+    }
+  }
+
+  handleEvent(event) {
+    if (event.type == "click") {
+      this._onClick(event);
+    } else if (event.type == "keypress") {
+      this._onKeyPress(event);
+    }
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    if (!this.connectedOnce) {
+      this.connectedOnce = true;
+      this._lastFormattedAccessKey = null;
+      this.addEventListener("click", this, true);
+      if (this.isTextLink) {
+        this.addEventListener("keypress", this);
+      }
+    }
+
+    setGlobalAccessKeyFormattingState();
+    this.formatAccessKey();
+  }
+
+  get isTextLink() {
+    return this.classList.contains("text-link") || this.hasAttribute("onClick");
+  }
+
+  set accessKey(val) {
+    this.setAttribute("accesskey", val);
+  }
+
+  get accessKey() {
+    var accessKey = this.getAttribute("accesskey");
+    return accessKey ? accessKey[0] : null;
+  }
+
+  get labeledControlElement() {
+    var control = this.control;
+    return control ? document.getElementById(control) : null;
+  }
+
+  set control(val) {
+    this.setAttribute("control", val);
+  }
+
+  get control() {
+    return this.getAttribute("control");
+  }
+
+  set href(val) {
+    this.setAttribute("href", val);
+  }
+
+  get href() {
+    return this.getAttribute("href");
+  }
+
+  // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
+  // label uses [value]). So this is just for when we have textContent.
+  formatAccessKey() {
+    // Skip doing any DOM manipulation whenever possible:
+    let accessKey = this.accessKey;
+    if (!gUnderlineAccesskey ||
+        this._lastFormattedAccessKey == accessKey ||
+        !this.textContent ||
+        !this.needsFormatting) {
+      return;
+    }
+    this._lastFormattedAccessKey = accessKey;
+
+    if (this.accessKeySpan) { // Clear old accesskey
+      mergeElement(this.accessKeySpan);
+      this.accessKeySpan = null;
+    }
+
+    if (this.hiddenColon) {
+      mergeElement(this.hiddenColon);
+      this.hiddenColon = null;
+    }
+
+    if (this.accessKeyParens) {
+      this.accessKeyParens.remove();
+      this.accessKeyParens = null;
+    }
+
+    // If we used to have an accessKey but not anymore, we're done here
+    if (!accessKey) {
+      return;
+    }
+
+    var labelText = this.textContent;
+    var accessKeyIndex = -1;
+    if (!gAlwaysAppendAccessKey) {
+      accessKeyIndex = labelText.indexOf(accessKey);
+      if (accessKeyIndex < 0) { // Try again in upper case
+        accessKeyIndex =
+          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+      }
+    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+    }
+
+    const HTML_NS = "http://www.w3.org/1999/xhtml";
+    this.accessKeySpan = document.createElementNS(HTML_NS, "span");
+    this.accessKeySpan.className = "accesskey";
+
+    // Note that if you change the following code, see the comment of
+    // nsTextBoxFrame::UpdateAccessTitle.
+
+    // If accesskey is in the string, underline it:
+    if (accessKeyIndex >= 0) {
+      wrapChar(this, this.accessKeySpan, accessKeyIndex);
+      return;
+    }
+
+    // If accesskey is not in string, append in parentheses
+    // If end is colon, we should insert before colon.
+    // i.e., "label:" -> "label(X):"
+    var colonHidden = false;
+    if (/:$/.test(labelText)) {
+      labelText = labelText.slice(0, -1);
+      this.hiddenColon = document.createElementNS(HTML_NS, "span");
+      this.hiddenColon.className = "hiddenColon";
+      this.hiddenColon.style.display = "none";
+      // Hide the last colon by using span element.
+      // I.e., label<span style="display:none;">:</span>
+      wrapChar(this, this.hiddenColon, labelText.length);
+      colonHidden = true;
+    }
+    // If end is space(U+20),
+    // we should not add space before parentheses.
+    var endIsSpace = false;
+    if (/ $/.test(labelText)) {
+      endIsSpace = true;
+    }
+
+    this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+    this.appendChild(this.accessKeyParens);
+    if (gInsertSeparator && !endIsSpace)
+      this.accessKeyParens.textContent = " (";
+    else
+      this.accessKeyParens.textContent = "(";
+    this.accessKeySpan.textContent = accessKey.toUpperCase();
+    this.accessKeyParens.appendChild(this.accessKeySpan);
+    if (!colonHidden) {
+      this.accessKeyParens.appendChild(document.createTextNode(")"));
+    } else {
+      this.accessKeyParens.appendChild(document.createTextNode("):"));
+    }
+  }
+
+  openLink(aEvent) {
+    if (!this.isTextLink) {
+      return;
+    }
+
+    var href = this.href;
+    if (!href || this.disabled || aEvent.defaultPrevented)
+      return;
+
+    var uri = null;
+    try {
+      const nsISSM = Ci.nsIScriptSecurityManager;
+      const secMan =
+        Cc["@mozilla.org/scriptsecuritymanager;1"]
+        .getService(nsISSM);
+
+      uri = Services.io.newURI(href);
+
+      let principal;
+      if (this.getAttribute("useoriginprincipal") == "true") {
+        principal = this.nodePrincipal;
+      } else {
+        principal = secMan.createNullPrincipal({});
+      }
+      try {
+        secMan.checkLoadURIWithPrincipal(principal, uri,
+          nsISSM.DISALLOW_INHERIT_PRINCIPAL);
+      } catch (ex) {
+        var msg = "Error: Cannot open a " + uri.scheme + ": link using \
+                         the text-link binding.";
+        Cu.reportError(msg);
+        return;
+      }
+
+      const cID = "@mozilla.org/uriloader/external-protocol-service;1";
+      const nsIEPS = Ci.nsIExternalProtocolService;
+      var protocolSvc = Cc[cID].getService(nsIEPS);
+
+      // if the scheme is not an exposed protocol, then opening this link
+      // should be deferred to the system's external protocol handler
+      if (!protocolSvc.isExposedProtocol(uri.scheme)) {
+        protocolSvc.loadURI(uri);
+        aEvent.preventDefault();
+        return;
+      }
+
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+
+    aEvent.preventDefault();
+    href = uri ? uri.spec : href;
+
+    // Try handing off the link to the host application, e.g. for
+    // opening it in a tabbed browser.
+    var linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
+      .createInstance(Ci.nsISupportsPRBool);
+    linkHandled.data = false;
+    let { shiftKey, ctrlKey, metaKey, altKey, button } = aEvent;
+    let data = { shiftKey, ctrlKey, metaKey, altKey, button, href };
+    Services.obs
+      .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
+    if (linkHandled.data)
+      return;
+
+    // otherwise, fall back to opening the anchor directly
+    var win = window;
+    if (window.isChromeWindow) {
+      while (win.opener && !win.opener.closed)
+        win = win.opener;
+    }
+    win.open(href);
+  }
+}
+
+customElements.define("label", MozTextLabel);
+
+function mergeElement(element) {
+  // If the element has been removed already, return:
+  if (!element.isConnected) {
+    return;
+  }
+  if (element.previousSibling instanceof Text) {
+    element.previousSibling.appendData(element.textContent);
+  } else {
+    element.parentNode.insertBefore(element.firstChild, element);
+  }
+  element.remove();
+}
+
+function wrapChar(parent, element, index) {
+  var treeWalker = document.createNodeIterator(parent,
+    NodeFilter.SHOW_TEXT,
+    null);
+  var node = treeWalker.nextNode();
+  while (index >= node.length) {
+    index -= node.length;
+    node = treeWalker.nextNode();
+  }
+  if (index) {
+    node = node.splitText(index);
+  }
+
+  node.parentNode.insertBefore(element, node);
+  if (node.length > 1) {
+    node.splitText(1);
+  }
+  element.appendChild(node);
+}
+
+let gInsertSeparator;
+let gUnderlineAccesskey;
+let gAlwaysAppendAccessKey = false;
+function setGlobalAccessKeyFormattingState() {
+  if (gUnderlineAccesskey === undefined) {
+    gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+  }
+  if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
+    return;
+  }
+  try {
+    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
+    const prefNameInsertSeparator =
+      "intl.menuitems.insertseparatorbeforeaccesskeys";
+    const prefNameAlwaysAppendAccessKey =
+      "intl.menuitems.alwaysappendaccesskeys";
+
+    var val = Services.prefs.getComplexValue(prefNameInsertSeparator,
+      nsIPrefLocalizedString).data;
+    gInsertSeparator = val == "true";
+
+    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+      nsIPrefLocalizedString).data;
+    gAlwaysAppendAccessKey = val == "true";
+  } catch (e) {
+    gInsertSeparator = gAlwaysAppendAccessKey = true;
+  }
+}
+
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -93,26 +93,20 @@ page {
 
 /******** box *******/
 
 vbox {
   -moz-box-orient: vertical;
 }
 
 /********** label **********/
-
 label.text-link, label[onclick] {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#text-link");
   -moz-user-focus: normal;
 }
 
-label[control], label.radio-label, label.checkbox-label, label.toolbarbutton-multiline-text {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#label-control");
-}
-
 label html|span.accesskey {
   text-decoration: underline;
 }
 
 /********** button **********/
 
 button {
   -moz-binding: url("chrome://global/content/bindings/button.xml#button");
