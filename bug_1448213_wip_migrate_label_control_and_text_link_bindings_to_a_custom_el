# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1536773841 25200
#      Wed Sep 12 10:37:21 2018 -0700
# Node ID 40a6dd53015b3ec69f1be2b79f21a71ff4cee066
# Parent  05331fb8f5338974b913217bc67815df25a32e86
Bug 1448213 - WIP - Migrate label-control and text-link bindings to a Custom Element;

Differential Revision: https://phabricator.services.mozilla.com/D5686

diff --git a/dom/tests/mochitest/chrome/test_elements_proto.xul b/dom/tests/mochitest/chrome/test_elements_proto.xul
--- a/dom/tests/mochitest/chrome/test_elements_proto.xul
+++ b/dom/tests/mochitest/chrome/test_elements_proto.xul
@@ -12,21 +12,19 @@
 
   <script type="application/javascript">
   <![CDATA[
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     SimpleTest.waitForExplicitFinish();
 
     addLoadEvent(() => {
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "label")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "label") instanceof XULTextElement,
         `<label> should be of XULTextElement type`);
 
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "description")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "description") instanceof XULTextElement,
         `<description> should be of XULTextElement type`);
 
       SimpleTest.finish();
     });
   ]]>
   </script>
 </window>
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -863,17 +863,17 @@ nsTextBoxFrame::CalculateTitleForWidth(g
 // but the mTitle doesn't have the character
 void
 nsTextBoxFrame::UpdateAccessTitle()
 {
     /*
      * Note that if you change appending access key label spec,
      * you need to maintain same logic in following methods. See bug 324159.
      * toolkit/components/prompts/src/CommonDialog.jsm (setLabelForNode)
-     * toolkit/content/widgets/text.xml (formatAccessKey)
+     * toolkit/content/widgets/text.js (formatAccessKey)
      */
     int32_t menuAccessKey;
     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
     if (!menuAccessKey || mAccessKey.IsEmpty())
         return;
 
     if (!AlwaysAppendAccessKey() &&
         FindInReadable(mAccessKey, mTitle, nsCaseInsensitiveStringComparator()))
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -293,16 +293,17 @@ window.MozElements = MozElements;
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/progressmeter.js",
     "chrome://global/content/elements/radio.js",
+    "chrome://global/content/elements/text.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
     "chrome://global/content/elements/tree.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
   for (let [tag, script] of [
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -79,17 +79,16 @@ toolkit.jar:
    content/global/bindings/notification.xml    (widgets/notification.xml)
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
 *  content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
-   content/global/bindings/text.xml            (widgets/text.xml)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
@@ -97,16 +96,17 @@ toolkit.jar:
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js          (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/progressmeter.js    (widgets/progressmeter.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
+   content/global/elements/text.js             (widgets/text.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
    content/global/gmp-sources/widevinecdm.json (gmp-sources/widevinecdm.json)
diff --git a/toolkit/content/tests/chrome/test_labelcontrol.xul b/toolkit/content/tests/chrome/test_labelcontrol.xul
--- a/toolkit/content/tests/chrome/test_labelcontrol.xul
+++ b/toolkit/content/tests/chrome/test_labelcontrol.xul
@@ -6,38 +6,36 @@
   -->
 <window title="tabindex" width="500" height="600"
         onload="runTests()"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>  
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>  
 
 <label id="lab" control="ctl"/>
-<textbox id="ctl" value="Test"/>
-<checkbox id="chk" value="Checkbox"/>
+<checkbox id="ctl" value="Checkbox"/>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
 <p id="display"></p>
 <div id="content" style="display: none">
 </div>
 <pre id="test">
 </pre>
 </body>
 
 <script>
 <![CDATA[
 
 SimpleTest.waitForExplicitFinish();
- 
+
 function runTests()
 {
   is($("lab").control, "ctl", "control");
   is($("lab").labeledControlElement, $("ctl"), "labeledControlElement");
   is($("ctl").labelElement, $("lab"), "labelElement");
-  is($("chk").labelElement.className, "checkbox-label", "labelElement");
 
   SimpleTest.finish();
 }
 
 ]]>
 
 </script>
 
diff --git a/toolkit/content/widgets/general.xml b/toolkit/content/widgets/general.xml
--- a/toolkit/content/widgets/general.xml
+++ b/toolkit/content/widgets/general.xml
@@ -28,33 +28,40 @@
       <property name="label"      onset="this.setAttribute('label',val); return val;"
                                   onget="return this.getAttribute('label');"/>
       <property name="crop"       onset="this.setAttribute('crop',val); return val;"
                                   onget="return this.getAttribute('crop');"/>
       <property name="image"      onset="this.setAttribute('image',val); return val;"
                                   onget="return this.getAttribute('image');"/>
       <property name="command"    onset="this.setAttribute('command',val); return val;"
                                   onget="return this.getAttribute('command');"/>
+      <property name="labelElement">
+        <getter>
+          <![CDATA[
+            return document.getElementsByAttribute("control", this.id)[0];
+          ]]>
+        </getter>
+      </property>
       <property name="accessKey">
         <getter>
           <![CDATA[
-            return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+            let labelElement = this.labelElement;
+            return labelElement ? labelElement.accessKey : this.getAttribute("accesskey");
           ]]>
         </getter>
         <setter>
           <![CDATA[
             // Always store on the control
             this.setAttribute("accesskey", val);
             // If there is a label, change the accesskey on the labelElement
             // if it's also set there
-            if (this.labelElement) {
-              this.labelElement.accessKey = val;
+            let labelElement = this.labelElement;
+            if (labelElement) {
+              labelElement.accessKey = val;
             }
             return val;
           ]]>
         </setter>
       </property>
-
-      <field name="labelElement"/>
     </implementation>
   </binding>
 
 </bindings>
diff --git a/toolkit/content/widgets/text.xml b/toolkit/content/widgets/text.js
rename from toolkit/content/widgets/text.xml
rename to toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.xml
+++ b/toolkit/content/widgets/text.js
@@ -1,352 +1,357 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
 
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
 
-<bindings id="textBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:html="http://www.w3.org/1999/xhtml">
+/* globals MozElementMixin,XULTextElement */
+class MozTextLabel extends MozElementMixin(XULTextElement) {
+  static get observedAttributes() {
+    return ["accesskey", "text"];
+  }
 
-  <binding id="label-control">
-    <content>
-      <children/><html:span anonid="accessKeyParens"></html:span>
-    </content>
-    <implementation>
-      <constructor>
-        <![CDATA[
-          this.formatAccessKey(true);
-        ]]>
-      </constructor>
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady || oldValue == newValue) {
+      return;
+    }
+    this.formatAccessKey();
+  }
 
-      <method name="formatAccessKey">
-        <parameter name="firstTime"/>
-        <body>
-          <![CDATA[
-            var control = this.labeledControlElement;
-            if (!control) {
-              var bindingParent = document.getBindingParent(this);
-              if ("accessKey" in bindingParent) {
-                control = bindingParent; // For controls that make the <label> an anon child
-              }
-            }
-            if (control) {
-              control.labelElement = this;
-              var controlAccessKey = control.getAttribute("accesskey");
-              if (controlAccessKey) {
-                this.setAttribute("accesskey", controlAccessKey);
-              }
-            }
+  get needsFormatting() {
+    return true;
+    // return !this.closest("groupbox[hidden]");
+    // return this.hasAttribute("control") ||
+    //        this.classList.contains("radio-label") ||
+    //        this.classList.contains("checkbox-label") ||
+    //        this.classList.contains("toolbarbutton-multiline-text");
+  }
+
+  _onClick(event) {
+    if (this.isTextLink) {
+      if (event.button == 0 || event.button == 1) {
+        this.openLink(event);
+      }
+      return;
+    }
 
-            var accessKey = this.accessKey;
-            // No need to remove existing formatting the first time.
-            if (firstTime && !accessKey)
-              return;
+    let controlElement = this.labeledControlElement;
+    if (!controlElement || this.disabled) {
+      return;
+    }
+    controlElement.focus();
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
-            if (this.mInsertSeparator === undefined) {
-              try {
-                var prefs = Cc["@mozilla.org/preferences-service;1"].
-                                       getService(Ci.nsIPrefBranch);
-                this.mUnderlineAccesskey = (prefs.getIntPref("ui.key.menuAccessKey") != 0);
-
-                const nsIPrefLocalizedString =
-                  Ci.nsIPrefLocalizedString;
-
-                const prefNameInsertSeparator =
-                  "intl.menuitems.insertseparatorbeforeaccesskeys";
-                const prefNameAlwaysAppendAccessKey =
-                  "intl.menuitems.alwaysappendaccesskeys";
+    if (controlElement.namespaceURI != XUL_NS) {
+      return;
+    }
+    if (controlElement.localName == "checkbox") {
+      controlElement.checked = !controlElement.checked;
+    } else if (controlElement.localName == "radio") {
+      controlElement.control.selectedItem = controlElement;
+    }
+  }
 
-                var val = prefs.getComplexValue(prefNameInsertSeparator,
-                                                nsIPrefLocalizedString).data;
-                this.mInsertSeparator = (val == "true");
+  _onKeyPress(event) {
+    if (event.keyCode == 13) {
+      this.click();
+    }
+  }
+
+  handleEvent(event) {
+    if (event.type == "click") {
+      this._onClick(event);
+    } else if (event.type == "keypress") {
+      this._onKeyPress(event);
+    }
+  }
 
-                val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
-                                            nsIPrefLocalizedString).data;
-                this.mAlwaysAppendAccessKey = (val == "true");
-              } catch (e) {
-                this.mInsertSeparator = true;
-              }
-            }
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
 
-            if (!this.mUnderlineAccesskey)
-              return;
-
-            var afterLabel = document.getAnonymousElementByAttribute(this, "anonid", "accessKeyParens");
-            afterLabel.textContent = "";
-
-            var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
-            if (oldAccessKey) { // Clear old accesskey
-              this.mergeElement(oldAccessKey);
-            }
+    if (!this.connectedOnce) {
+      this.connectedOnce = true;
+      this._lastFormattedAccessKey = null;
+      this.addEventListener("click", this, true);
+      if (this.isTextLink) {
+        this.addEventListener("keypress", this);
+      }
+    }
 
-            var oldHiddenSpan =
-              this.getElementsByAttribute("class", "hiddenColon").item(0);
-            if (oldHiddenSpan) {
-              this.mergeElement(oldHiddenSpan);
-            }
+    setGlobalAccessKeyFormattingState();
+    this.formatAccessKey();
+  }
+
+  get isTextLink() {
+    return this.classList.contains("text-link") || this.hasAttribute("onClick");
+  }
+
+  set accessKey(val) {
+    this.setAttribute("accesskey", val);
+  }
+
+  get accessKey() {
+    let accessKey = this.getAttribute("accesskey");
+    return accessKey ? accessKey[0] : null;
+  }
 
-            var labelText = this.textContent;
-            if (!accessKey || !labelText || !control) {
-              return;
-            }
-            var accessKeyIndex = -1;
-            if (!this.mAlwaysAppendAccessKey) {
-              accessKeyIndex = labelText.indexOf(accessKey);
-              if (accessKeyIndex < 0) { // Try again in upper case
-                accessKeyIndex =
-                  labelText.toUpperCase().indexOf(accessKey.toUpperCase());
-              }
-            } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
-              accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
-            }
+  get labeledControlElement() {
+    let control = this.control;
+    return control ? document.getElementById(control) : null;
+  }
+
+  set control(val) {
+    this.setAttribute("control", val);
+  }
 
-            const HTML_NS = "http://www.w3.org/1999/xhtml";
-            var span = document.createElementNS(HTML_NS, "span");
-            span.className = "accesskey";
+  get control() {
+    return this.getAttribute("control");
+  }
 
-            // Note that if you change the following code, see the comment of
-            // nsTextBoxFrame::UpdateAccessTitle.
+  set href(val) {
+    this.setAttribute("href", val);
+  }
+
+  get href() {
+    return this.getAttribute("href");
+  }
 
-            // If accesskey is not in string, append in parentheses
-            if (accessKeyIndex < 0) {
-              // If end is colon, we should insert before colon.
-              // i.e., "label:" -> "label(X):"
-              var colonHidden = false;
-              if (/:$/.test(labelText)) {
-                labelText = labelText.slice(0, -1);
-                var hiddenSpan = document.createElementNS(HTML_NS, "span");
-                hiddenSpan.className = "hiddenColon";
-                hiddenSpan.style.display = "none";
-                // Hide the last colon by using span element.
-                // I.e., label<span style="display:none;">:</span>
-                this.wrapChar(hiddenSpan, labelText.length);
-                colonHidden = true;
-              }
-              // If end is space(U+20),
-              // we should not add space before parentheses.
-              var endIsSpace = false;
-              if (/ $/.test(labelText)) {
-                endIsSpace = true;
-              }
-              if (this.mInsertSeparator && !endIsSpace)
-                afterLabel.textContent = " (";
-              else
-                afterLabel.textContent = "(";
-              span.textContent = accessKey.toUpperCase();
-              afterLabel.appendChild(span);
-              if (!colonHidden)
-                afterLabel.appendChild(document.createTextNode(")"));
-              else
-                afterLabel.appendChild(document.createTextNode("):"));
-              return;
-            }
-            this.wrapChar(span, accessKeyIndex);
-          ]]>
-        </body>
-      </method>
+  // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
+  // label uses [value]). So this is just for when we have textContent.
+  formatAccessKey() {
+    // Skip doing any DOM manipulation whenever possible:
+    let accessKey = this.accessKey;
+    if (!gUnderlineAccesskey ||
+        this._lastFormattedAccessKey == accessKey ||
+        !this.textContent ||
+        !this.needsFormatting) {
+      return;
+    }
+    this._lastFormattedAccessKey = accessKey;
+
+    if (this.accessKeySpan) { // Clear old accesskey
+      mergeElement(this.accessKeySpan);
+      this.accessKeySpan = null;
+    }
+
+    if (this.hiddenColon) {
+      mergeElement(this.hiddenColon);
+      this.hiddenColon = null;
+    }
 
-      <method name="wrapChar">
-        <parameter name="element"/>
-        <parameter name="index"/>
-        <body>
-          <![CDATA[
-             var treeWalker = document.createTreeWalker(this,
-                                                        NodeFilter.SHOW_TEXT,
-                                                        null);
-             var node = treeWalker.nextNode();
-             while (index >= node.length) {
-               index -= node.length;
-               node = treeWalker.nextNode();
-             }
-             if (index) {
-               node = node.splitText(index);
-             }
-             node.parentNode.insertBefore(element, node);
-             if (node.length > 1) {
-               node.splitText(1);
-             }
-             element.appendChild(node);
-          ]]>
-        </body>
-      </method>
+    if (this.accessKeyParens) {
+      this.accessKeyParens.remove();
+      this.accessKeyParens = null;
+    }
+
+    // If we used to have an accessKey but not anymore, we're done here
+    if (!accessKey) {
+      return;
+    }
+
+    let labelText = this.textContent;
+    let accessKeyIndex = -1;
+    if (!gAlwaysAppendAccessKey) {
+      accessKeyIndex = labelText.indexOf(accessKey);
+      if (accessKeyIndex < 0) { // Try again in upper case
+        accessKeyIndex =
+          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+      }
+    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+    }
+
+    const HTML_NS = "http://www.w3.org/1999/xhtml";
+    this.accessKeySpan = document.createElementNS(HTML_NS, "span");
+    this.accessKeySpan.className = "accesskey";
+
+    // Note that if you change the following code, see the comment of
+    // nsTextBoxFrame::UpdateAccessTitle.
 
-      <method name="mergeElement">
-        <parameter name="element"/>
-        <body>
-          <![CDATA[
-            if (element.previousSibling instanceof Text) {
-              element.previousSibling.appendData(element.textContent);
-            } else {
-              element.parentNode.insertBefore(element.firstChild, element);
-            }
-            element.remove();
-          ]]>
-        </body>
-      </method>
+    // If accesskey is in the string, underline it:
+    if (accessKeyIndex >= 0) {
+      wrapChar(this, this.accessKeySpan, accessKeyIndex);
+      return;
+    }
 
-      <field name="mUnderlineAccesskey">
-        !/Mac/.test(navigator.platform)
-      </field>
-      <field name="mInsertSeparator"/>
-      <field name="mAlwaysAppendAccessKey">false</field>
+    // If accesskey is not in string, append in parentheses
+    // If end is colon, we should insert before colon.
+    // i.e., "label:" -> "label(X):"
+    let colonHidden = false;
+    if (/:$/.test(labelText)) {
+      labelText = labelText.slice(0, -1);
+      this.hiddenColon = document.createElementNS(HTML_NS, "span");
+      this.hiddenColon.className = "hiddenColon";
+      this.hiddenColon.style.display = "none";
+      // Hide the last colon by using span element.
+      // I.e., label<span style="display:none;">:</span>
+      wrapChar(this, this.hiddenColon, labelText.length);
+      colonHidden = true;
+    }
+    // If end is space(U+20),
+    // we should not add space before parentheses.
+    let endIsSpace = false;
+    if (/ $/.test(labelText)) {
+      endIsSpace = true;
+    }
+
+    this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+    this.appendChild(this.accessKeyParens);
+    if (gInsertSeparator && !endIsSpace)
+      this.accessKeyParens.textContent = " (";
+    else
+      this.accessKeyParens.textContent = "(";
+    this.accessKeySpan.textContent = accessKey.toUpperCase();
+    this.accessKeyParens.appendChild(this.accessKeySpan);
+    if (!colonHidden) {
+      this.accessKeyParens.appendChild(document.createTextNode(")"));
+    } else {
+      this.accessKeyParens.appendChild(document.createTextNode("):"));
+    }
+  }
 
-      <property name="accessKey">
-        <getter>
-          <![CDATA[
-            var accessKey = this.getAttribute("accesskey");
-            return accessKey ? accessKey[0] : null;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            // If this label already has an accesskey attribute store it here as well
-            if (this.hasAttribute("accesskey")) {
-              this.setAttribute("accesskey", val);
-            }
-            var control = this.labeledControlElement;
-            if (control) {
-              control.setAttribute("accesskey", val);
-            }
-            this.formatAccessKey(false);
-            return val;
-          ]]>
-        </setter>
-      </property>
+  openLink(aEvent) {
+    if (!this.isTextLink) {
+      return;
+    }
+
+    let href = this.href;
+    if (!href || this.disabled || aEvent.defaultPrevented)
+      return;
 
-      <property name="labeledControlElement" readonly="true"
-                onget="var control = this.control; return control ? document.getElementById(control) : null;" />
+    let uri = null;
+    try {
+      const nsISSM = Ci.nsIScriptSecurityManager;
+      const secMan =
+        Cc["@mozilla.org/scriptsecuritymanager;1"]
+        .getService(nsISSM);
+
+      uri = Services.io.newURI(href);
 
-      <property name="control" onget="return this.getAttribute('control');">
-        <setter>
-          <![CDATA[
-            var control = this.labeledControlElement;
-            if (control) {
-              control.labelElement = null; // No longer pointed to be this label
-            }
-            this.setAttribute("control", val);
-            this.formatAccessKey(false);
-            return val;
-          ]]>
-        </setter>
-      </property>
-    </implementation>
+      let principal;
+      if (this.getAttribute("useoriginprincipal") == "true") {
+        principal = this.nodePrincipal;
+      } else {
+        principal = secMan.createNullPrincipal({});
+      }
+      try {
+        secMan.checkLoadURIWithPrincipal(principal, uri,
+          nsISSM.DISALLOW_INHERIT_PRINCIPAL);
+      } catch (ex) {
+        let msg = "Error: Cannot open a " + uri.scheme + ": link using \
+                         the text-link binding.";
+        Cu.reportError(msg);
+        return;
+      }
 
-    <handlers>
-      <handler event="click"><![CDATA[
-        if (this.disabled) {
-          return;
-        }
-        var controlElement = this.labeledControlElement;
-        if (!controlElement) {
-          return;
-        }
-        controlElement.focus();
-        const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+      const cID = "@mozilla.org/uriloader/external-protocol-service;1";
+      const nsIEPS = Ci.nsIExternalProtocolService;
+      let protocolSvc = Cc[cID].getService(nsIEPS);
 
-        if (controlElement.namespaceURI != XUL_NS) {
-          return;
-        }
-        if (controlElement.localName == "checkbox") {
-          controlElement.checked = !controlElement.checked;
-        } else if (controlElement.localName == "radio") {
-          controlElement.control.selectedItem = controlElement;
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
+      // if the scheme is not an exposed protocol, then opening this link
+      // should be deferred to the system's external protocol handler
+      if (!protocolSvc.isExposedProtocol(uri.scheme)) {
+        protocolSvc.loadURI(uri);
+        aEvent.preventDefault();
+        return;
+      }
 
-  <binding id="text-link">
-    <implementation>
-      <property name="href" onget="return this.getAttribute('href');"
-                            onset="this.setAttribute('href', val); return val;" />
-      <method name="open">
-        <parameter name="aEvent"/>
-        <body>
-        <![CDATA[
-          var href = this.href;
-          if (!href || this.disabled || aEvent.defaultPrevented)
-            return;
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+
+    aEvent.preventDefault();
+    href = uri ? uri.spec : href;
 
-          var uri = null;
-          try {
-            const nsISSM = Ci.nsIScriptSecurityManager;
-            const secMan =
-                     Cc["@mozilla.org/scriptsecuritymanager;1"]
-                       .getService(nsISSM);
+    // Try handing off the link to the host application, e.g. for
+    // opening it in a tabbed browser.
+    let linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
+      .createInstance(Ci.nsISupportsPRBool);
+    linkHandled.data = false;
+    let { shiftKey, ctrlKey, metaKey, altKey, button } = aEvent;
+    let data = { shiftKey, ctrlKey, metaKey, altKey, button, href };
+    Services.obs
+      .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
+    if (linkHandled.data)
+      return;
 
-            const ioService =
-                     Cc["@mozilla.org/network/io-service;1"]
-                       .getService(Ci.nsIIOService);
+    // otherwise, fall back to opening the anchor directly
+    let win = window;
+    if (window.isChromeWindow) {
+      while (win.opener && !win.opener.closed)
+        win = win.opener;
+    }
+    win.open(href);
+  }
+}
 
-            uri = ioService.newURI(href);
+customElements.define("label", MozTextLabel);
 
-            let principal;
-            if (this.getAttribute("useoriginprincipal") == "true") {
-              principal = this.nodePrincipal;
-            } else {
-              principal = secMan.createNullPrincipal({});
-            }
-            try {
-              secMan.checkLoadURIWithPrincipal(principal, uri,
-                                               nsISSM.DISALLOW_INHERIT_PRINCIPAL);
-            } catch (ex) {
-              var msg = "Error: Cannot open a " + uri.scheme + ": link using \
-                         the text-link binding.";
-              Cu.reportError(msg);
-              return;
-            }
-
-            const cID = "@mozilla.org/uriloader/external-protocol-service;1";
-            const nsIEPS = Ci.nsIExternalProtocolService;
-            var protocolSvc = Cc[cID].getService(nsIEPS);
+function mergeElement(element) {
+  // If the element has been removed already, return:
+  if (!element.isConnected) {
+    return;
+  }
+  if (element.previousSibling instanceof Text) {
+    element.previousSibling.appendData(element.textContent);
+  } else {
+    element.parentNode.insertBefore(element.firstChild, element);
+  }
+  element.remove();
+}
 
-            // if the scheme is not an exposed protocol, then opening this link
-            // should be deferred to the system's external protocol handler
-            if (!protocolSvc.isExposedProtocol(uri.scheme)) {
-              protocolSvc.loadURI(uri);
-              aEvent.preventDefault();
-              return;
-            }
+function wrapChar(parent, element, index) {
+  let treeWalker = document.createNodeIterator(parent,
+    NodeFilter.SHOW_TEXT,
+    null);
+  let node = treeWalker.nextNode();
+  while (index >= node.length) {
+    index -= node.length;
+    node = treeWalker.nextNode();
+  }
+  if (index) {
+    node = node.splitText(index);
+  }
 
-          } catch (ex) {
-            Cu.reportError(ex);
-          }
-
-          aEvent.preventDefault();
-          href = uri ? uri.spec : href;
+  node.parentNode.insertBefore(element, node);
+  if (node.length > 1) {
+    node.splitText(1);
+  }
+  element.appendChild(node);
+}
 
-          // Try handing off the link to the host application, e.g. for
-          // opening it in a tabbed browser.
-          var linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
-                              .createInstance(Ci.nsISupportsPRBool);
-          linkHandled.data = false;
-          let {shiftKey, ctrlKey, metaKey, altKey, button} = aEvent;
-          let data = {shiftKey, ctrlKey, metaKey, altKey, button, href};
-          Cc["@mozilla.org/observer-service;1"]
-            .getService(Ci.nsIObserverService)
-            .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
-          if (linkHandled.data)
-            return;
+let gInsertSeparator;
+let gUnderlineAccesskey;
+let gAlwaysAppendAccessKey = false;
+function setGlobalAccessKeyFormattingState() {
+  if (gUnderlineAccesskey === undefined) {
+    gUnderlineAccesskey = true; // Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+  }
+  if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
+    return;
+  }
+  try {
+    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
+    const prefNameInsertSeparator =
+      "intl.menuitems.insertseparatorbeforeaccesskeys";
+    const prefNameAlwaysAppendAccessKey =
+      "intl.menuitems.alwaysappendaccesskeys";
 
-          // otherwise, fall back to opening the anchor directly
-          var win = window;
-          if (window.isChromeWindow) {
-            while (win.opener && !win.opener.closed)
-              win = win.opener;
-          }
-          win.open(href);
-        ]]>
-        </body>
-      </method>
-    </implementation>
+    let val = Services.prefs.getComplexValue(prefNameInsertSeparator,
+      nsIPrefLocalizedString).data;
+    gInsertSeparator = val == "true";
 
-    <handlers>
-      <handler event="click" phase="capturing" button="0" action="this.open(event)"/>
-      <handler event="click" phase="capturing" button="1" action="this.open(event)"/>
-      <handler event="keypress" preventdefault="true" keycode="VK_RETURN" action="this.click()" />
-    </handlers>
-  </binding>
+    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+      nsIPrefLocalizedString).data;
+    gAlwaysAppendAccessKey = val == "true";
+  } catch (e) {
+    gInsertSeparator = gAlwaysAppendAccessKey = true;
+  }
+}
 
-</bindings>
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -93,26 +93,20 @@ page {
 
 /******** box *******/
 
 vbox {
   -moz-box-orient: vertical;
 }
 
 /********** label **********/
-
 label.text-link, label[onclick] {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#text-link");
   -moz-user-focus: normal;
 }
 
-label[control], label.radio-label, label.checkbox-label, label.toolbarbutton-multiline-text {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#label-control");
-}
-
 label html|span.accesskey {
   text-decoration: underline;
 }
 
 /********** button **********/
 
 button {
   -moz-binding: url("chrome://global/content/bindings/button.xml#button");
