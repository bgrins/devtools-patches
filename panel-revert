# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  67ba5406ce3954311b41ea6bb5564118a5699244

diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -3,16 +3,181 @@
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <bindings id="popupBindings"
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl">
 
+  <binding id="popup">
+    <content>
+      <xul:arrowscrollbox class="popup-internal-box" flex="1" orient="vertical"
+                          smoothscroll="false">
+        <children/>
+      </xul:arrowscrollbox>
+    </content>
+
+    <implementation>
+      <field name="scrollBox" readonly="true">
+        document.getAnonymousElementByAttribute(this, "class", "popup-internal-box");
+      </field>
+
+      <field name="AUTOSCROLL_INTERVAL">25</field>
+      <field name="NOT_DRAGGING">0</field>
+      <field name="DRAG_OVER_BUTTON">-1</field>
+      <field name="DRAG_OVER_POPUP">1</field>
+
+      <field name="_draggingState">this.NOT_DRAGGING</field>
+      <field name="_scrollTimer">0</field>
+
+      <method name="_enableDragScrolling">
+        <!-- when overItem is true, drag started over menuitem; when false, drag
+             started while the popup was opening.
+          -->
+        <parameter name="overItem"/>
+        <body>
+        <![CDATA[
+          if (!this._draggingState) {
+            this.setCaptureAlways();
+            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="_clearScrollTimer">
+        <body>
+        <![CDATA[
+          if (this._scrollTimer) {
+            this.ownerGlobal.clearInterval(this._scrollTimer);
+            this._scrollTimer = 0;
+          }
+        ]]>
+        </body>
+      </method>
+
+      <constructor><![CDATA[
+        // Enable the drag-to-scroll events only in menulist popups.
+        if (!this.parentNode || this.parentNode.localName != "menulist") {
+          return;
+        }
+
+        // XBL bindings might be constructed more than once.
+        if (this.eventListenersAdded) {
+          return;
+        }
+        this.eventListenersAdded = true;
+
+        this.addEventListener("popupshown", () => {
+          // Enable drag scrolling even when the mouse wasn't used. The
+          // mousemove handler will remove it if the mouse isn't down.
+          this._enableDragScrolling(false);
+        });
+
+        this.addEventListener("popuphidden", () => {
+          this._draggingState = this.NOT_DRAGGING;
+          this._clearScrollTimer();
+          this.releaseCapture();
+        });
+
+        this.addEventListener("mousedown", event => {
+          if (event.button != 0) {
+            return;
+          }
+
+          if (this.state == "open" &&
+            (event.target.localName == "menuitem" ||
+              event.target.localName == "menu" ||
+              event.target.localName == "menucaption")) {
+            this._enableDragScrolling(true);
+          }
+        });
+
+        this.addEventListener("mouseup", event => {
+          if (event.button != 0) {
+            return;
+          }
+
+          this._draggingState = this.NOT_DRAGGING;
+          this._clearScrollTimer();
+        });
+
+        this.addEventListener("mousemove", event => {
+          if (!this._draggingState) {
+            return;
+          }
+
+          this._clearScrollTimer();
+
+          // If the user released the mouse before the popup opens, we will
+          // still be capturing, so check that the button is still pressed. If
+          // not, release the capture and do nothing else. This also handles if
+          // the dropdown was opened via the keyboard.
+          if (!(event.buttons & 1)) {
+            this._draggingState = this.NOT_DRAGGING;
+            this.releaseCapture();
+            return;
+          }
+
+          // If dragging outside the top or bottom edge of the popup, but within
+          // the popup area horizontally, scroll the list in that direction. The
+          // _draggingState flag is used to ensure that scrolling does not start
+          // until the mouse has moved over the popup first, preventing
+          // scrolling while over the dropdown button.
+          let popupRect = this.getOuterScreenRect();
+          if (event.screenX >= popupRect.left &&
+              event.screenX <= popupRect.right) {
+            if (this._draggingState == this.DRAG_OVER_BUTTON) {
+              if (event.screenY > popupRect.top &&
+                  event.screenY < popupRect.bottom) {
+                this._draggingState = this.DRAG_OVER_POPUP;
+              }
+            }
+
+            if (this._draggingState == this.DRAG_OVER_POPUP &&
+                (event.screenY <= popupRect.top ||
+                 event.screenY >= popupRect.bottom)) {
+              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;
+              this.scrollBox.scrollByIndex(scrollAmount, true);
+
+              let win = this.ownerGlobal;
+              this._scrollTimer = win.setInterval(() => {
+                this.scrollBox.scrollByIndex(scrollAmount, true);
+              }, this.AUTOSCROLL_INTERVAL);
+            }
+          }
+        });
+      ]]></constructor>
+    </implementation>
+
+    <handlers>
+      <handler event="popupshowing" phase="target">
+        <![CDATA[
+          var array = [];
+          var width = 0;
+          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
+            if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
+              var accel = menuitem.menuAccel;
+              if (accel) {
+                array.push(accel);
+                let accelWidth = accel.getBoundingClientRect().width;
+                if (accelWidth > width) {
+                  width = accelWidth;
+                }
+              }
+            }
+          }
+          for (var i = 0; i < array.length; i++)
+            array[i].width = width;
+        ]]>
+      </handler>
+    </handlers>
+  </binding>
+
   <binding id="panel">
     <implementation>
       <field name="_prevFocus">0</field>
     </implementation>
 
     <handlers>
       <handler event="popupshowing"><![CDATA[
         // Capture the previous focus before has a chance to get set inside the panel
@@ -213,9 +378,10 @@
           this.removeAttribute("animate");
         }
       </handler>
       <handler event="popuppositioned" phase="target">
         this.adjustArrowPosition();
       </handler>
     </handlers>
   </binding>
+
 </bindings>
