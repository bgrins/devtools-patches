# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a802d80660a00ed3c7a45a039aeb4e17244a08d9
Bug

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -1273,45 +1273,55 @@ MarkupView.prototype = {
     if (!aContainer.childrenDirty) {
       return promise.resolve(aContainer);
     }
 
     if (!aContainer.hasChildren) {
       while (aContainer.children.firstChild) {
         aContainer.children.removeChild(aContainer.children.firstChild);
       }
+      if (aContainer.singleTextContainer) {
+        aContainer.singleTextContainer.elt.remove();
+      }
       aContainer.childrenDirty = false;
       return promise.resolve(aContainer);
     }
 
-    if (aContainer.singleTextChild
-        && aContainer.singleTextChild != aContainer.node.singleTextChild) {
-
-      // This container was doing double duty as a container for a single
-      // text child, back that out.
-      this._containers.delete(aContainer.singleTextChild);
-      aContainer.clearSingleTextChild();
-
-      aContainer.setExpanded(true);
+    if (aContainer.node.singleTextChild) {
+      // aContainer.textEditor = new TextEditor(this.container, node, "text");
+      // aContainer.elt.insertBefore(this.textEditor.elt, this.elt.firstChild.nextSibling.nextSibling);
+
+      expand = true;
     }
 
-    if (aContainer.node.singleTextChild) {
-      aContainer.setExpanded(false);
-      // this container will do double duty as the container for the single
-      // text child.
-      while (aContainer.children.firstChild) {
-        aContainer.children.removeChild(aContainer.children.firstChild);
-      }
-
-      aContainer.setSingleTextChild(aContainer.node.singleTextChild);
-
-      this._containers.set(aContainer.node.singleTextChild, aContainer);
-      aContainer.childrenDirty = false;
-      return promise.resolve(aContainer);
-    }
+    // if (aContainer.singleTextChild
+    //     && aContainer.singleTextChild != aContainer.node.singleTextChild) {
+
+    //   // This container was doing double duty as a container for a single
+    //   // text child, back that out.
+    //   this._containers.delete(aContainer.singleTextChild);
+    //   aContainer.clearSingleTextChild();
+
+    //   aContainer.setExpanded(true);
+    // }
+
+    // if (aContainer.node.singleTextChild) {
+    //   aContainer.setExpanded(false);
+    //   // this container will do double duty as the container for the single
+    //   // text child.
+    //   while (aContainer.children.firstChild) {
+    //     aContainer.children.removeChild(aContainer.children.firstChild);
+    //   }
+
+    //   aContainer.setSingleTextChild(aContainer.node.singleTextChild);
+
+    //   this._containers.set(aContainer.node.singleTextChild, aContainer);
+    //   aContainer.childrenDirty = false;
+    //   return promise.resolve(aContainer);
+    // }
 
     // If we're not expanded (or asked to update anyway), we're done for
     // now.  Note that this will leave the childrenDirty flag set, so when
     // expanded we'll refresh the child list.
     if (!(aContainer.expanded || expand)) {
       return promise.resolve(aContainer);
     }
 
@@ -1332,25 +1342,33 @@ MarkupView.prototype = {
       // If children are dirty, we got a change notification for this node
       // while the request was in progress, we need to do it again.
       if (aContainer.childrenDirty) {
         return this._updateChildren(aContainer, {expand: centered});
       }
 
       let fragment = this.doc.createDocumentFragment();
 
-      for (let child of children.nodes) {
-        let container = this.importNode(child, flash);
-        fragment.appendChild(container.elt);
-      }
-
       while (aContainer.children.firstChild) {
         aContainer.children.removeChild(aContainer.children.firstChild);
       }
 
+      for (let child of children.nodes) {
+        let container = this.importNode(child, flash);
+        console.log(aContainer.node.nodeName, aContainer.node, child);
+        if (aContainer.node.singleTextChild) {
+          console.log("INSERTING BEFORE", container.elt, aContainer.elt.firstChild.nextSibling.nextSibling);
+          aContainer.singleTextContainer = container;
+          aContainer.editor.elt.insertBefore(container.elt, aContainer.editor.elt.firstChild.nextSibling.nextSibling);
+        } else {
+          fragment.appendChild(container.elt);
+        }
+      }
+
+
       if (!(children.hasFirst && children.hasLast)) {
         let data = {
           showing: this.strings.GetStringFromName("markupView.more.showing"),
           showAll: this.strings.formatStringFromName(
                     "markupView.more.showAll",
                     [aContainer.node.numChildren.toString()], 1),
           allButtonClick: () => {
             aContainer.maxChildren = -1;
@@ -1383,19 +1401,19 @@ MarkupView.prototype = {
     return promise.all([updatePromise for (updatePromise of this._queuedChildUpdates.values())]);
   },
 
   /**
    * Return a list of the children to display for this container.
    */
   _getVisibleChildren: function(aContainer, aCentered) {
     // If the backend has told us that there's only one child, just use that child.
-    if (aContainer.node.singleTextChild) {
-      return promise.resolve({ hasFirst: true, hasLast: true, nodes: [aContainer.node.singleTextChild]});
-    }
+    // if (aContainer.node.singleTextChild) {
+    //   return promise.resolve({ hasFirst: true, hasLast: true, nodes: [aContainer.node.singleTextChild]});
+    // }
 
     let maxChildren = aContainer.maxChildren || this.maxChildren;
     if (maxChildren == -1) {
       maxChildren = undefined;
     }
 
     return this.walker.children(aContainer.node, {
       maxNodes: maxChildren,
@@ -1681,17 +1699,25 @@ MarkupContainer.prototype = {
     this.win = this.markup._frame.contentWindow;
 
     // The template will fill the following properties
     this.elt = null;
     this.expander = null;
     this.tagState = null;
     this.tagLine = null;
     this.children = null;
-    this.markup.template(templateID, this);
+    if (node.parentNode().singleTextChild) {
+      this.elt = this.markup.doc.createElement("span");
+      this.tagLine = this.markup.doc.createElement("span");
+      this.children = this.markup.doc.createElement("span");
+      this.tagState = this.markup.doc.createElement("span");
+      this.elt.appendChild(this.tagLine);
+    } else {
+      this.markup.template(templateID, this);
+    }
     this.elt.container = this;
 
     this._onMouseDown = this._onMouseDown.bind(this);
     this._onToggle = this._onToggle.bind(this);
     this._onMouseUp = this._onMouseUp.bind(this);
     this._onMouseMove = this._onMouseMove.bind(this);
 
     // Binding event listeners
@@ -1748,17 +1774,17 @@ MarkupContainer.prototype = {
     this._hasChildren = aValue;
     this.updateExpander();
   },
 
   /**
    * True if the current node can be expanded.
    */
   get canExpand() {
-    return this._hasChildren && !this.node.singleTextChild;
+    return this._hasChildren && !this.node.singleTextChild
   },
 
   updateExpander: function() {
     if (!this.expander) {
       return;
     }
 
     if (this.canExpand) {
@@ -2227,22 +2253,22 @@ MarkupElementContainer.prototype = Herit
       data.data.string().then(str => {
         clipboardHelper.copyString(str, this.markup.doc);
       });
     });
   },
 
   setSingleTextChild: function(singleTextChild) {
     this.singleTextChild = singleTextChild;
-    this.editor.updateTextEditor();
+    // this.editor.updateTextEditor();
   },
 
   clearSingleTextChild: function() {
     this.singleTextChild = undefined;
-    this.editor.updateTextEditor();
+    // this.editor.updateTextEditor();
   }
 });
 
 /**
  * Dummy container node used for the root document element.
  */
 function RootContainer(aMarkupView, aNode) {
   this.doc = aMarkupView.doc;
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -226,28 +226,28 @@ var NodeActor = exports.NodeActor = prot
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
 
     let singleTextChild = undefined;
 
     if (this.rawNode.childNodes.length == 1 && this.rawNode.childNodes[0].nodeType === Ci.nsIDOMNode.TEXT_NODE) {
-      singleTextChild = this.walker._ref(this.rawNode.childNodes[0]);
+      singleTextChild = true;
     }
 
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
       numChildren: this.numChildren,
-      singleTextChild: singleTextChild ? singleTextChild.form() : undefined,
+      singleTextChild: singleTextChild,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
       isBeforePseudoElement: this.isBeforePseudoElement,
@@ -757,17 +757,17 @@ let NodeFront = protocol.FrontClass(Node
       // Get the owner actor for this actor (the walker), and find the
       // parent node of this actor from it, creating a standin node if
       // necessary.
       let parentNodeFront = ctx.marshallPool().ensureParentFront(form.parent);
       this.reparent(parentNodeFront);
     }
 
     if (form.singleTextChild) {
-      this.singleTextChild = types.getType("domnode").read(form.singleTextChild, ctx);
+      this.singleTextChild = true;
     } else {
       this.singleTextChild = undefined;
     }
   },
 
   /**
    * Returns the parent NodeFront for this NodeFront.
    */
@@ -2720,17 +2720,17 @@ var WalkerActor = protocol.ActorClass({
           this._orphaned.delete(addedActor);
           addedActors.push(addedActor.actorID);
         }
 
         mutation.removed = removedActors;
         mutation.added = addedActors;
 
         if (change.target.childNodes.length == 1 && change.target.childNodes[0].nodeType === Ci.nsIDOMNode.TEXT_NODE) {
-          mutation.singleTextChild = this._ref(change.target.childNodes[0]).form();
+          mutation.singleTextChild = true;
         }
 
       }
       this.queueMutation(mutation);
     }
   },
 
   onFrameLoad: function({ window, isTopLevel }) {
@@ -3217,17 +3217,17 @@ var WalkerFront = exports.WalkerFront = 
 
             // The actor is reconnected to the ownership tree, unorphan
             // it.
             this._orphaned.delete(addedFront);
             addedFronts.push(addedFront);
           }
 
           if (change.singleTextChild) {
-            targetFront.singleTextChild = types.getType("domnode").read(change.singleTextChild, this);
+            targetFront.singleTextChild = true;
           } else {
             targetFront.singleTextChild = undefined;
           }
 
           // Before passing to users, replace the added and removed actor
           // ids with front in the mutation record.
           emittedMutation.added = addedFronts;
           emittedMutation.removed = removedFronts;
