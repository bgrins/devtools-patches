# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  96b36c5f527dd42e680a230839519eee1fc2c9f3
Bug 1364596 - Remove SDK usage from the devtools DAMP test;r=jmaher

diff --git a/testing/talos/talos/tests/devtools/addon/content/damp.js b/testing/talos/talos/tests/devtools/addon/content/damp.js
--- a/testing/talos/talos/tests/devtools/addon/content/damp.js
+++ b/testing/talos/talos/tests/devtools/addon/content/damp.js
@@ -1,24 +1,29 @@
 Components.utils.import("resource://devtools/client/framework/gDevTools.jsm");
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 const { devtools } =
   Components.utils.import("resource://devtools/shared/Loader.jsm", {});
-const { getActiveTab } = devtools.require("sdk/tabs/utils");
-const { getMostRecentBrowserWindow } = devtools.require("sdk/window/utils");
 const ThreadSafeChromeUtils = devtools.require("ThreadSafeChromeUtils");
 const { EVENTS } = devtools.require("devtools/client/netmonitor/src/constants");
 const { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
 
 const webserver = Services.prefs.getCharPref("addon.test.damp.webserver");
 
 const SIMPLE_URL = webserver + "/tests/devtools/addon/content/pages/simple.html";
 const COMPLICATED_URL = webserver + "/tests/tp5n/bild.de/www.bild.de/index.html";
 
+const Ci = Components.interfaces;
+const wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);
+
+function getSelectedTab() {
+  return wm.getMostRecentWindow("navigator:browser").gBrowser.selectedTab;
+}
+
 function Damp() {
   // Path to the temp file where the heap snapshot file is saved. Set by
   // saveHeapSnapshot and read by readHeapSnapshot.
   this._heapSnapshotFilePath = null;
   // HeapSnapshot instance. Set by readHeapSnapshot, used by takeCensus.
   this._snapshot = null;
 
   // Use the old console for now: https://bugzilla.mozilla.org/show_bug.cgi?id=1306780
@@ -55,44 +60,44 @@ Damp.prototype = {
           time: stopReloadTimestamp - startReloadTimestamp
         });
       }, true);
       browser.reload();
     });
   },
 
   openToolbox: function (tool = "webconsole") {
-    let tab = getActiveTab(getMostRecentBrowserWindow());
+    let tab = getSelectedTab();
     let target = devtools.TargetFactory.forTab(tab);
     let startRecordTimestamp = performance.now();
     let showPromise = gDevTools.showToolbox(target, tool);
 
     return showPromise.then(toolbox => {
       let stopRecordTimestamp = performance.now();
       return {
         toolbox,
         time: stopRecordTimestamp - startRecordTimestamp
       };
     });
   },
 
   closeToolbox: Task.async(function*() {
-    let tab = getActiveTab(getMostRecentBrowserWindow());
+    let tab = getSelectedTab();
     let target = devtools.TargetFactory.forTab(tab);
     yield target.client.waitForRequestsToSettle();
     let startRecordTimestamp = performance.now();
     yield gDevTools.closeToolbox(target);
     let stopRecordTimestamp = performance.now();
     return {
       time: stopRecordTimestamp - startRecordTimestamp
     };
   }),
 
   saveHeapSnapshot: function(label) {
-    let tab = getActiveTab(getMostRecentBrowserWindow());
+    let tab = getSelectedTab();
     let target = devtools.TargetFactory.forTab(tab);
     let toolbox = gDevTools.getToolbox(target);
     let panel = toolbox.getCurrentPanel();
     let memoryFront = panel.panelWin.gFront;
 
     let start = performance.now();
     return memoryFront.saveHeapSnapshot().then(filePath => {
       this._heapSnapshotFilePath = filePath;
@@ -456,17 +461,17 @@ Damp.prototype = {
    * - it waits only for request that were issued after it was called. Requests that are
    *   already in mid-flight will be ignored.
    * - the request start and end times are overlapping. If a new request starts a moment
    *   after the previous one was finished, the wait will be ended in the "interim"
    *   period.
    * @returns a promise that resolves when the wait is done.
    */
   waitForAllRequestsFinished() {
-    let tab = getActiveTab(getMostRecentBrowserWindow());
+    let tab = getSelectedTab();
     let target = devtools.TargetFactory.forTab(tab);
     let toolbox = gDevTools.getToolbox(target);
     let window = toolbox.getCurrentPanel().panelWin;
 
     return new Promise(resolve => {
       // Key is the request id, value is a boolean - is request finished or not?
       let requests = new Map();
 
@@ -498,18 +503,16 @@ Damp.prototype = {
 
   startTest: function(doneCallback, config) {
     this._onTestComplete = function (results) {
       Profiler.mark("DAMP - end", true);
       doneCallback(results);
     };
     this._config = config;
 
-    const Ci = Components.interfaces;
-    var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);
     this._win = wm.getMostRecentWindow("navigator:browser");
     this._dampTab = this._win.gBrowser.selectedTab;
     this._win.gBrowser.selectedBrowser.focus(); // Unfocus the URL bar to avoid caret blink
 
     Profiler.mark("DAMP - start", true);
 
     let tests = [];
     tests = tests.concat(this._getToolLoadingTests(SIMPLE_URL, "simple"));
