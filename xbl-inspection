# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  1793a41066c3aea8b67f116be4546da225a0cd59
Bug 1360072

diff --git a/devtools/client/inspector/markup/markup.js b/devtools/client/inspector/markup/markup.js
--- a/devtools/client/inspector/markup/markup.js
+++ b/devtools/client/inspector/markup/markup.js
@@ -1569,16 +1569,18 @@ MarkupView.prototype = {
     let expand = options && options.expand;
     let flash = options && options.flash;
 
     container.hasChildren = container.node.hasChildren;
     // Accessibility should either ignore empty children or semantically
     // consider them a group.
     container.setChildrenRole();
 
+    console.log("Calling _updateChildren", container, options);
+
     if (!this._queuedChildUpdates) {
       this._queuedChildUpdates = new Map();
     }
 
     if (this._queuedChildUpdates.has(container)) {
       return this._queuedChildUpdates.get(container);
     }
 
@@ -1620,19 +1622,19 @@ MarkupView.prototype = {
       container.childrenDirty = false;
       container.setExpanded(false);
       return promise.resolve(container);
     }
 
     // If we're not expanded (or asked to update anyway), we're done for
     // now.  Note that this will leave the childrenDirty flag set, so when
     // expanded we'll refresh the child list.
-    if (!(container.expanded || expand)) {
-      return promise.resolve(container);
-    }
+    // if (!(container.expanded || expand)) {
+    //   return promise.resolve(container);
+    // }
 
     // We're going to issue a children request, make sure it includes the
     // centered node.
     let centered = this._checkSelectionVisible(container);
 
     // Children aren't updated yet, but clear the childrenDirty flag anyway.
     // If the dirty flag is re-set while we're fetching we'll need to fetch
     // again.
@@ -1713,16 +1715,18 @@ MarkupView.prototype = {
    * Return a list of the children to display for this container.
    */
   _getVisibleChildren: function (container, centered) {
     let maxChildren = container.maxChildren || this.maxChildren;
     if (maxChildren == -1) {
       maxChildren = undefined;
     }
 
+    console.log("Calling _getVisibleChildren", container)
+
     return this.walker.children(container.node, {
       maxNodes: maxChildren,
       center: centered
     });
   },
 
   /**
    * Tear down the markup panel.
diff --git a/devtools/shared/fronts/inspector.js b/devtools/shared/fronts/inspector.js
--- a/devtools/shared/fronts/inspector.js
+++ b/devtools/shared/fronts/inspector.js
@@ -123,16 +123,22 @@ const NodeFront = FrontClassWithSpec(nod
       form.nodeValue = form.incompleteValue ? null : form.shortValue;
     }
 
     // Shallow copy of the form.  We could just store a reference, but
     // eventually we'll want to update some of the data.
     this._form = object.merge(form);
     this._form.attrs = this._form.attrs ? this._form.attrs.slice() : [];
 
+    // Seems to do with <xul:children />
+    if (!this._form.nodeType) {
+      console.error("Bad form", form, this);
+      console.trace();
+    }
+
     if (form.parent) {
       // Get the owner actor for this actor (the walker), and find the
       // parent node of this actor from it, creating a standin node if
       // necessary.
       let parentNodeFront = ctx.marshallPool().ensureParentFront(form.parent);
       this.reparent(parentNodeFront);
     }
 
diff --git a/devtools/shared/protocol.js b/devtools/shared/protocol.js
--- a/devtools/shared/protocol.js
+++ b/devtools/shared/protocol.js
@@ -291,16 +291,20 @@ types.addActorType = function (name) {
       return front;
     },
     write: (v, ctx, detail) => {
       // If returning a response from the server side, make sure
       // the actor is added to a parent object and return its form.
       if (v instanceof Actor) {
         if (!v.actorID) {
           ctx.marshallPool().manage(v);
+        } else {
+          console.trace();
+        console.log("Writing to existing actor", v, ctx, detail)
+
         }
         return type.formType(detail).write(v.form(detail), ctx, detail);
       }
 
       // Writing a request from the client side, just send the actor id.
       return v.actorID;
     },
     formType: (detail) => {
@@ -1077,17 +1081,19 @@ var generateRequestHandlers = function (
         } catch (ex) {
           console.error("Error reading request: " + packet.type);
           throw ex;
         }
 
         let ret = this[spec.name].apply(this, args);
 
         let sendReturn = (retToSend) => {
+          console.log("sendReturn", retToSend, packet)
           if (spec.oneway) {
+            console.log("oneway");
             // No need to send a response.
             return;
           }
 
           let response;
           try {
             response = spec.response.write(retToSend, this);
           } catch (ex) {
