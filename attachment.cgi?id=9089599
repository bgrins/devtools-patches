# HG changeset patch
# User Mats Palmgren <mats@mozilla.com>
# Parent  193cdb5eaf42cbcd0ef46489a8a7a65b63b3798a

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -282,18 +282,20 @@ static inline bool IsAnonymousFlexOrGrid
   auto pseudoType = aFrame->Style()->GetPseudoType();
   return pseudoType == PseudoStyleType::anonymousFlexItem ||
          pseudoType == PseudoStyleType::anonymousGridItem;
 }
 
 // Returns true IFF the given nsIFrame is a nsFlexContainerFrame and
 // represents a -webkit-{inline-}box or -moz-{inline-}box container.
 static inline bool IsFlexContainerForLegacyBox(const nsIFrame* aFrame) {
-  return aFrame->IsFlexContainerFrame() &&
-         aFrame->HasAnyStateBits(NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX);
+  return (aFrame->IsFlexContainerFrame() &&
+          aFrame->HasAnyStateBits(NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX)) ||
+      (aFrame->IsGridContainerFrame() &&
+       aFrame->StylePosition()->mFlexDirection == StyleFlexDirection::Column);
 }
 
 #if DEBUG
 static void AssertAnonymousFlexOrGridItemParent(const nsIFrame* aChild,
                                                 const nsIFrame* aParent) {
   MOZ_ASSERT(IsAnonymousFlexOrGridItem(aChild),
              "expected an anonymous flex or grid item child frame");
   MOZ_ASSERT(aParent, "expected a parent frame");
diff --git a/servo/components/style/style_adjuster.rs b/servo/components/style/style_adjuster.rs
--- a/servo/components/style/style_adjuster.rs
+++ b/servo/components/style/style_adjuster.rs
@@ -157,24 +157,31 @@ impl<'a, 'b: 'a> StyleAdjuster<'a, 'b> {
     fn adjust_for_position(&mut self) {
         if self.style.out_of_flow_positioned() && self.style.floated() {
             self.style.mutate_box().set_float(Float::None);
         }
     }
 
     /// Whether we should skip any item-based display property blockification on
     /// this element.
-    fn skip_item_display_fixup<E>(&self, element: Option<E>) -> bool
+    fn skip_item_display_fixup<E>(&self, layout_parent_style: &ComputedValues, element: Option<E>) -> bool
     where
         E: TElement,
     {
+        use crate::properties::longhands::flex_direction::computed_value::T as FlexDirection;
+
         if let Some(pseudo) = self.style.pseudo {
             return pseudo.skip_item_display_fixup();
         }
 
+        let parent_display = layout_parent_style.get_box().clone_display();
+        if parent_display.inside() == DisplayInside::Grid &&
+            layout_parent_style.get_position().clone_flex_direction() == FlexDirection::Column {
+                return true;
+        }
         element.map_or(false, |e| e.skip_item_display_fixup())
     }
 
     /// Apply the blockification rules based on the table in CSS 2.2 section 9.7.
     /// <https://drafts.csswg.org/css2/visuren.html#dis-pos-flo>
     /// A ::marker pseudo-element with 'list-style-position:outside' needs to
     /// have its 'display' blockified, unless the ::marker is for an inline
     /// list-item (for which 'list-style-position:outside' behaves as 'inside').
@@ -191,17 +198,17 @@ impl<'a, 'b: 'a> StyleAdjuster<'a, 'b> {
                 if !blockify {
                     blockify = $if_what;
                 }
             };
         }
 
         let is_root = self.style.pseudo.is_none() && element.map_or(false, |e| e.is_root());
         blockify_if!(is_root);
-        if !self.skip_item_display_fixup(element) {
+        if !self.skip_item_display_fixup(layout_parent_style, element) {
             let parent_display = layout_parent_style.get_box().clone_display();
             blockify_if!(parent_display.is_item_container());
         }
 
         let is_item_or_root = blockify;
 
         blockify_if!(self.style.floated());
         blockify_if!(self.style.out_of_flow_positioned());
@@ -593,17 +600,17 @@ impl<'a, 'b: 'a> StyleAdjuster<'a, 'b> {
         use crate::properties::longhands::unicode_bidi::computed_value::T as UnicodeBidi;
 
         let self_display = self.style.get_box().clone_display();
         // Check whether line break should be suppressed for this element.
         if self.should_suppress_linebreak(layout_parent_style) {
             self.style
                 .add_flags(ComputedValueFlags::SHOULD_SUPPRESS_LINEBREAK);
             // Inlinify the display type if allowed.
-            if !self.skip_item_display_fixup(element) {
+            if !self.skip_item_display_fixup(layout_parent_style, element) {
                 let inline_display = self_display.inlinify();
                 if self_display != inline_display {
                     self.style
                         .mutate_box()
                         .set_adjusted_display(inline_display, false);
                 }
             }
         }
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -390,19 +390,25 @@ tree:not([treelines="true"]) treechildre
 treechildren::-moz-tree-cell(ltr) {
   direction: ltr !important;
 }
 
 /********** deck & stack *********/
 
 deck > * {
   -moz-box-flex: 1;
+  grid-area: 1/1;
+  inline-size: 100%;
+}
+deck {
+  display: grid;
+  flex-direction: column;
 }
 deck > *:not([selected]) {
-  visibility: collapse;
+  visibility: hidden;
 }
 
 stack {
   display: -moz-stack;
 }
 
 /********** tabbox *********/
 
