# HG changeset patch
# Parent d105e5b801f487c4a4bceee90e6bbe7fbb03beb4
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1088861 - Console doesn't respond when debugger is paused at breakpoint that was hit by executing a command in the console - part 2;r=past

diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js b/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
@@ -52,17 +52,17 @@ function test() {
                              "Float64Array"];
 
     const {tab} = yield loadTab(TEST_URI);
     const hud = yield openConsole(tab);
     jsterm = hud.jsterm;
 
     // Create an ArrayBuffer of 80 bytes to test TypedArrays. 80 bytes is
     // enough to get 10 items in all different TypedArrays.
-    jsterm.execute("let buf = new ArrayBuffer(80);");
+    yield jsterm.execute("let buf = new ArrayBuffer(80);");
 
     // Array
     yield testNotSorted("Array(0,1,2,3,4,5,6,7,8,9,10)");
     // NodeList
     yield testNotSorted("document.querySelectorAll('div')");
 
     // Typed arrays.
     for (let type of typedArrayTypes) {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
@@ -23,17 +23,17 @@ let test = asyncTest(function*() {
     yield deferred.promise;
 
     ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
   }
 
   let { jsterm } = yield openConsole();
   let popup = jsterm.autocompletePopup;
 
-  jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
+  yield jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
 
   // Should work with bug 967468.
   yield autocomplete("Object.__d");
   yield autocomplete("testObject.$$a");
 
   // Here's when things go wrong in bug 967468.
   yield autocomplete("Object.__de");
   yield autocomplete("testObject.$$aa");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -17,30 +17,30 @@ let test = asyncTest(function*() {
   yield testReturnWithNoSelection();
   yield popupHideAfterReturnWithNoSelection();
   yield testCompletionInText();
   yield popupHideAfterCompletionInText();
 
   HUD = popup = jsterm = inputNode = completeNode = null;
 });
 
-function consoleOpened(aHud) {
+let consoleOpened = Task.async(function*(aHud) {
   let deferred = promise.defer();
   HUD = aHud;
   info("web console opened");
 
   jsterm = HUD.jsterm;
 
-  jsterm.execute("window.foobarBug585991={" +
+  yield jsterm.execute("window.foobarBug585991={" +
     "'item0': 'value0'," +
     "'item1': 'value1'," +
     "'item2': 'value2'," +
     "'item3': 'value3'" +
   "}");
-  jsterm.execute("window.testBug873250a = 'hello world';"
+  yield jsterm.execute("window.testBug873250a = 'hello world';"
     + "window.testBug873250b = 'hello world 2';");
   popup = jsterm.autocompletePopup;
   completeNode = jsterm.completeNode;
   inputNode = jsterm.inputNode;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
@@ -128,17 +128,17 @@ function consoleOpened(aHud) {
     EventUtils.synthesizeKey("VK_TAB", {});
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   jsterm.setInputValue("window.foobarBug585991");
   EventUtils.synthesizeKey(".", {});
 
   return deferred.promise;
-}
+});
 
 function popupHideAfterTab()
 {
   let deferred = promise.defer();
 
   // At this point the completion suggestion should be accepted.
   ok(!popup.isOpen, "popup is not open");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -15,42 +15,42 @@ const TEST_URI = "http://example.com/";
 let test = asyncTest(function* () {
   yield loadTab(TEST_URI);
 
   let hud = yield openConsole();
   yield testSelectionWhenMovingBetweenBoxes(hud);
   performTestsAfterOutput(hud);
 })
 
-function testSelectionWhenMovingBetweenBoxes(aHud) {
+let testSelectionWhenMovingBetweenBoxes = Task.async(function *(aHud) {
   let hud = aHud;
   let jsterm = hud.jsterm;
 
   // Fill the console with some output.
   jsterm.clearOutput();
-  jsterm.execute("1 + 2");
-  jsterm.execute("3 + 4");
-  jsterm.execute("5 + 6");
+  yield jsterm.execute("1 + 2");
+  yield jsterm.execute("3 + 4");
+  yield jsterm.execute("5 + 6");
 
   return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "3",
       category: CATEGORY_OUTPUT,
     },
     {
       text: "7",
       category: CATEGORY_OUTPUT,
     },
     {
       text: "11",
       category: CATEGORY_OUTPUT,
     }],
   });
-}
+});
 
 function performTestsAfterOutput(aHud) {
   let hud = aHud;
   let outputNode = hud.outputNode;
 
   ok(outputNode.childNodes.length >= 3, "the output node has children after " +
      "executing some JavaScript");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js b/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
--- a/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
@@ -37,74 +37,74 @@ function test() {
   }];
 
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     const {tab} = yield loadTab(TEST_URI);
     hud = yield openConsole(tab);
 
-    executeWindowTest();
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     info("cd() into the iframe using a selector");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd('iframe')");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd('iframe')");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: childMessages });
 
     info("cd() out of the iframe, reset to default window");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd()");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd()");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     info("call cd() with unexpected arguments");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd(document)");
+    yield hud.jsterm.execute("cd(document)");
 
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "Cannot cd()",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_ERROR,
       }],
     });
 
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd('p')");
+    yield hud.jsterm.execute("cd('p')");
 
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "Cannot cd()",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_ERROR,
       }],
     });
 
     info("cd() into the iframe using an iframe DOM element");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd($('iframe'))");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd($('iframe'))");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: childMessages });
 
     info("cd(window.parent)");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd(window.parent)");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd(window.parent)");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     yield closeConsole(tab);
   }
 
   function executeWindowTest() {
-    hud.jsterm.execute("document.title");
-    hud.jsterm.execute("'p: ' + document.querySelector('p').textContent");
-    hud.jsterm.execute("'obj: ' + window.foobarBug609872");
+    yield hud.jsterm.execute("document.title");
+    yield hud.jsterm.execute("'p: ' + document.querySelector('p').textContent");
+    yield hud.jsterm.execute("'obj: ' + window.foobarBug609872");
   }
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_completion.js b/browser/devtools/webconsole/test/browser_webconsole_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_completion.js
@@ -64,17 +64,17 @@ let test = asyncTest(function* () {
   is(jsterm.completeNode.value, "                entsByTagNameNS", "'document.getElem' completion");
 
   jsterm.clearOutput();
 
   input.value = "docu";
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "    ment", "'docu' completion");
-  jsterm.execute();
+  yield jsterm.execute();
   is(jsterm.completeNode.value, "", "clear completion on execute()");
 
   // Test multi-line completion works
   input.value =                 "console.log('one');\nconsol";
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "                   \n      e", "multi-line completion");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
--- a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
@@ -1,178 +1,144 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let jsterm, testDriver;
+let jsterm;
 
-function test() {
-  loadTab(TEST_URI).then(() => {
-    openConsole().then((hud) => {
-      testDriver = testJSTerm(hud);
-      testDriver.next();
-    })
-  });
-}
-
-function nextTest() {
-  testDriver.next();
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  jsterm = hud.jsterm;
+  yield testJSTerm(hud);
+  jsterm  = null;
+});
 
 function checkResult(msg, desc) {
+  let def = promise.defer();
   waitForMessages({
     webconsole: jsterm.hud.owner,
     messages: [{
       name: desc,
       category: CATEGORY_OUTPUT,
     }],
   }).then(([result]) => {
     let node = [...result.matched][0].querySelector(".message-body");
     if (typeof msg == "string") {
       is(node.textContent.trim(), msg,
         "correct message shown for " + desc);
     }
     else if (typeof msg == "function") {
       ok(msg(node), "correct message shown for " + desc);
     }
 
-    nextTest();
+    def.resolve();
   });
+  return def.promise;
 }
 
 function testJSTerm(hud)
 {
-  jsterm = hud.jsterm;
   const HELP_URL = "https://developer.mozilla.org/docs/Tools/Web_Console/Helpers";
 
   jsterm.clearOutput();
-  jsterm.execute("$('#header').getAttribute('id')");
-  checkResult('"header"', "$() worked");
-  yield undefined;
+  yield jsterm.execute("$('#header').getAttribute('id')");
+  yield checkResult('"header"', "$() worked");
 
   jsterm.clearOutput();
-  jsterm.execute("$$('h1').length");
-  checkResult("1", "$$() worked");
-  yield undefined;
+  yield jsterm.execute("$$('h1').length");
+  yield checkResult("1", "$$() worked");
 
   jsterm.clearOutput();
-  jsterm.execute("$x('.//*', document.body)[0] == $$('h1')[0]");
-  checkResult("true", "$x() worked");
-  yield undefined;
+  yield jsterm.execute("$x('.//*', document.body)[0] == $$('h1')[0]");
+  yield checkResult("true", "$x() worked");
 
   // no jsterm.clearOutput() here as we clear the output using the clear() fn.
-  jsterm.execute("clear()");
+  yield jsterm.execute("clear()");
 
-  waitForSuccess({
+  yield waitForSuccess({
     name: "clear() worked",
     validator: function()
     {
       return jsterm.outputNode.childNodes.length == 0;
     }
-  }).then(nextTest);
-
-  yield undefined;
+  });
 
   jsterm.clearOutput();
-  jsterm.execute("keys({b:1})[0] == 'b'");
-  checkResult("true", "keys() worked", 1);
-  yield undefined;
+  yield jsterm.execute("keys({b:1})[0] == 'b'");
+  yield checkResult("true", "keys() worked", 1);
 
   jsterm.clearOutput();
-  jsterm.execute("values({b:1})[0] == 1");
-  checkResult("true", "values() worked", 1);
-  yield undefined;
+  yield jsterm.execute("values({b:1})[0] == 1");
+  yield checkResult("true", "values() worked", 1);
 
   jsterm.clearOutput();
 
   let openedLinks = 0;
-  let onExecuteCalls = 0;
   let oldOpenLink = hud.openLink;
   hud.openLink = (url) => {
     if (url == HELP_URL) {
       openedLinks++;
     }
   };
 
-  function onExecute() {
-    onExecuteCalls++;
-    if (onExecuteCalls == 3) {
-      nextTest();
-    }
-  }
-
-  jsterm.execute("help()", onExecute);
-  jsterm.execute("help", onExecute);
-  jsterm.execute("?", onExecute);
-  yield undefined;
+  yield jsterm.execute("help()");
+  yield jsterm.execute("help");
+  yield jsterm.execute("?");
 
   let output = jsterm.outputNode.querySelector(".message[category='output']");
   ok(!output, "no output for help() calls");
   is(openedLinks, 3, "correct number of pages opened by the help calls");
   hud.openLink = oldOpenLink;
 
   jsterm.clearOutput();
-  jsterm.execute("pprint({b:2, a:1})");
-  checkResult("\"  b: 2\n  a: 1\"", "pprint()");
-  yield undefined;
+  yield jsterm.execute("pprint({b:2, a:1})");
+  yield checkResult("\"  b: 2\n  a: 1\"", "pprint()");
 
   // check instanceof correctness, bug 599940
   jsterm.clearOutput();
-  jsterm.execute("[] instanceof Array");
-  checkResult("true", "[] instanceof Array == true");
-  yield undefined;
+  yield jsterm.execute("[] instanceof Array");
+  yield checkResult("true", "[] instanceof Array == true");
 
   jsterm.clearOutput();
-  jsterm.execute("({}) instanceof Object");
-  checkResult("true", "({}) instanceof Object == true");
-  yield undefined;
+  yield jsterm.execute("({}) instanceof Object");
+  yield checkResult("true", "({}) instanceof Object == true");
 
   // check for occurrences of Object XRayWrapper, bug 604430
   jsterm.clearOutput();
-  jsterm.execute("document");
-  checkResult(function(node) {
+  yield jsterm.execute("document");
+  yield checkResult(function(node) {
     return node.textContent.search(/\[object xraywrapper/i) == -1;
   }, "document - no XrayWrapper");
-  yield undefined;
 
   // check that pprint(window) and keys(window) don't throw, bug 608358
   jsterm.clearOutput();
-  jsterm.execute("pprint(window)");
-  checkResult(null, "pprint(window)");
-  yield undefined;
+  yield jsterm.execute("pprint(window)");
+  yield checkResult(null, "pprint(window)");
 
   jsterm.clearOutput();
-  jsterm.execute("keys(window)");
-  checkResult(null, "keys(window)");
-  yield undefined;
+  yield jsterm.execute("keys(window)");
+  yield checkResult(null, "keys(window)");
 
   // bug 614561
   jsterm.clearOutput();
-  jsterm.execute("pprint('hi')");
-  checkResult("\"  0: \"h\"\n  1: \"i\"\"", "pprint('hi')");
-  yield undefined;
+  yield jsterm.execute("pprint('hi')");
+  yield checkResult("\"  0: \"h\"\n  1: \"i\"\"", "pprint('hi')");
 
   // check that pprint(function) shows function source, bug 618344
   jsterm.clearOutput();
-  jsterm.execute("pprint(function() { var someCanaryValue = 42; })");
-  checkResult(function(node) {
+  yield jsterm.execute("pprint(function() { var someCanaryValue = 42; })");
+  yield checkResult(function(node) {
     return node.textContent.indexOf("someCanaryValue") > -1;
   }, "pprint(function) shows source");
-  yield undefined;
 
   // check that an evaluated null produces "null", bug 650780
   jsterm.clearOutput();
-  jsterm.execute("null");
-  checkResult("null", "null is null");
-  yield undefined;
+  yield jsterm.execute("null");
+  yield checkResult("null", "null is null");
 
   jsterm.clearOutput();
-  jsterm.execute("undefined");
-  checkResult("undefined", "undefined is printed");
-  yield undefined;
-
-  jsterm = testDriver = null;
-  executeSoon(finishTest);
-  yield undefined;
+  yield jsterm.execute("undefined");
+  yield checkResult("undefined", "undefined is printed");
 }
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -3313,19 +3313,29 @@ JSTerm.prototype = {
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [aExecuteString]
    *        The string you want to execute. If this is not provided, the current
    *        user input is used - taken from |this.inputNode.value|.
    * @param function [aCallback]
    *        Optional function to invoke when the result is displayed.
+   * @returns Promise
+   *          Resolves once the result is displayed.
    */
   execute: function JST_execute(aExecuteString, aCallback)
   {
+    let deferred = promise.defer();
+    let callback = function() {
+      deferred.resolve();
+      if (aCallback) {
+        aCallback.apply(this, arguments);
+      }
+    }
+
     // attempt to execute the content of the inputNode
     aExecuteString = aExecuteString || this.inputNode.value;
     if (!aExecuteString) {
       return;
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
@@ -3333,33 +3343,34 @@ JSTerm.prototype = {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
     }
 
     let message = new Messages.Simple(aExecuteString, {
       category: "input",
       severity: "log",
     });
     this.hud.output.addMessage(message);
-    let onResult = this._executeResultCallback.bind(this, message, aCallback);
+    let onResult = this._executeResultCallback.bind(this, message, callback);
 
     let options = {
       frame: this.SELECTED_FRAME,
       selectedNodeActor: selectedNodeActor,
     };
 
     this.requestEvaluation(aExecuteString, options).then(onResult, onResult);
 
     // Append a new value in the history of executed code, or overwrite the most
     // recent entry. The most recent entry may contain the last edited input
     // value that was not evaluated yet.
     this.history[this.historyIndex++] = aExecuteString;
     this.historyPlaceHolder = this.history.length;
     WebConsoleUtils.usageCount++;
     this.setInputValue("");
     this.clearCompletion();
+    return deferred.promise;
   },
 
   /**
    * Request a JavaScript string evaluation from the server.
    *
    * @param string aString
    *        String to execute.
    * @param object [aOptions]
