# HG changeset patch
# Parent 343160fa8c4fc59c09b5d2803afe1b6992f81dfd
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1088861 - Refactor console tests to prepare for async js evaluation requests;r=past

diff --git a/browser/devtools/commandline/test/browser_cmd_commands.js b/browser/devtools/commandline/test/browser_cmd_commands.js
--- a/browser/devtools/commandline/test/browser_cmd_commands.js
+++ b/browser/devtools/commandline/test/browser_cmd_commands.js
@@ -23,18 +23,17 @@ function spawnTest() {
   ]);
 
   let subject = yield subjectPromise;
 
   subject.QueryInterface(Ci.nsISupportsString);
   let hud = HUDService.getHudReferenceById(subject.data);
   ok(hud, "console open");
 
-  let jstermExecute = helpers.promiseify(hud.jsterm.execute, hud.jsterm);
-  let msg = yield jstermExecute("pprint(window)");
+  let msg = yield hud.jsterm.execute("pprint(window)");
 
   ok(msg, "output for pprint(window)");
 
   let oncePromise = hud.jsterm.once("messages-cleared");
 
   helpers.audit(options, [
     {
       setup: "console clear",
diff --git a/browser/devtools/webconsole/test/browser_console_dead_objects.js b/browser/devtools/webconsole/test/browser_console_dead_objects.js
--- a/browser/devtools/webconsole/test/browser_console_dead_objects.js
+++ b/browser/devtools/webconsole/test/browser_console_dead_objects.js
@@ -30,63 +30,57 @@ function test()
     Services.prefs.setBoolPref("devtools.chrome.enabled", true);
     let {tab} = yield loadTab(TEST_URI);
 
     info("open the browser console");
 
     hud = yield HUDService.toggleBrowserConsole();
     ok(hud, "browser console opened");
 
-    hud.jsterm.clearOutput();
+    let jsterm = hud.jsterm;
+
+    jsterm.clearOutput();
 
     // Add the reference to the content document.
-    yield execute("Cu = Components.utils;" +
+    yield jsterm.execute("Cu = Components.utils;" +
                   "Cu.import('resource://gre/modules/Services.jsm');" +
                   "chromeWindow = Services.wm.getMostRecentWindow('navigator:browser');" +
                   "foobarzTezt = chromeWindow.content.document;" +
                   "delete chromeWindow");
 
     gBrowser.removeCurrentTab();
 
-    let msg = yield execute("foobarzTezt");
+    let msg = yield jsterm.execute("foobarzTezt");
 
     isnot(hud.outputNode.textContent.indexOf("[object DeadObject]"), -1,
           "dead object found");
 
-    hud.jsterm.setInputValue("foobarzTezt");
+    jsterm.setInputValue("foobarzTezt");
 
     for (let c of ".hello") {
       EventUtils.synthesizeKey(c, {}, hud.iframeWindow);
     }
 
-    yield execute();
+    yield jsterm.execute();
 
     isnot(hud.outputNode.textContent.indexOf("can't access dead object"), -1,
           "'cannot access dead object' message found");
 
     // Click the second execute output.
     let clickable = msg.querySelector("a");
     ok(clickable, "clickable object found");
     isnot(clickable.textContent.indexOf("[object DeadObject]"), -1,
           "message text check");
 
     msg.scrollIntoView();
 
     executeSoon(() => {
       EventUtils.synthesizeMouseAtCenter(clickable, {}, hud.iframeWindow);
     });
 
-    yield hud.jsterm.once("variablesview-fetched");
+    yield jsterm.once("variablesview-fetched");
     ok(true, "variables view fetched");
 
-    msg = yield execute("delete window.foobarzTezt; 2013-26");
+    msg = yield jsterm.execute("delete window.foobarzTezt; 2013-26");
 
     isnot(msg.textContent.indexOf("1987"), -1, "result message found");
   }
-
-  function execute(str) {
-    let deferred = promise.defer();
-    hud.jsterm.execute(str, (msg) => {
-      deferred.resolve(msg);
-    });
-    return deferred.promise;
-  }
 }
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view.js b/browser/devtools/webconsole/test/browser_console_variables_view.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view.js
@@ -13,17 +13,17 @@ let hud;
 
 let test = asyncTest(function* () {
   yield loadTab(TEST_URI);
 
   hud = yield openConsole();
 
   gWebConsole = hud;
   gJSTerm = hud.jsterm;
-  let msg = yield execute(hud, "fooObj");
+  let msg = yield gJSTerm.execute("fooObj");
 
   ok(msg, "output message found");
   ok(msg.textContent.contains('{ testProp: "testValue" }'), "message text check");
 
   let anchor = msg.querySelector("a");
   ok(anchor, "object link found");
 
   let fetched = gJSTerm.once("variablesview-fetched");
@@ -182,14 +182,8 @@ function testPropDelete(aProp)
   });
 
   return waitForSuccess({
     name: "property deleted",
     timeout: 60000,
     validator: () => !("testUpdatedProp" in content.wrappedJSObject.fooObj)
   });
 }
-
-function execute(hud, str) {
-  let deferred = promise.defer();
-  hud.jsterm.execute(str, deferred.resolve);
-  return deferred.promise;
-}
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js b/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
@@ -52,17 +52,17 @@ function test() {
                              "Float64Array"];
 
     const {tab} = yield loadTab(TEST_URI);
     const hud = yield openConsole(tab);
     jsterm = hud.jsterm;
 
     // Create an ArrayBuffer of 80 bytes to test TypedArrays. 80 bytes is
     // enough to get 10 items in all different TypedArrays.
-    jsterm.execute("let buf = new ArrayBuffer(80);");
+    yield jsterm.execute("let buf = new ArrayBuffer(80);");
 
     // Array
     yield testNotSorted("Array(0,1,2,3,4,5,6,7,8,9,10)");
     // NodeList
     yield testNotSorted("document.querySelectorAll('div')");
 
     // Typed arrays.
     for (let type of typedArrayTypes) {
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js b/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
@@ -19,17 +19,17 @@ function test()
   });
 }
 
 function consoleOpened(hud)
 {
   gWebConsole = hud;
   gJSTerm = hud.jsterm;
   gToolbox = gDevTools.getToolbox(hud.target);
-  gJSTerm.execute("document.querySelectorAll('p')", onQSAexecuted);
+  gJSTerm.execute("document.querySelectorAll('p')").then(onQSAexecuted);
 }
 
 function onQSAexecuted(msg)
 {
   ok(msg, "output message found");
   let anchor = msg.querySelector("a");
   ok(anchor, "object link found");
 
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging.js b/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging.js
@@ -46,17 +46,17 @@ function debuggerOpened(aResult)
 }
 
 function onFramesAdded()
 {
   info("onFramesAdded");
 
   executeSoon(() =>
     openConsole().then(() =>
-      gJSTerm.execute("fooObj", onExecuteFooObj)
+      gJSTerm.execute("fooObj").then(onExecuteFooObj)
     )
   );
 }
 
 
 function onExecuteFooObj(msg)
 {
   ok(msg, "output message found");
@@ -109,17 +109,17 @@ function onFooObjFetchAfterUpdate(aVar)
 }
 
 function onUpdatedTestPropFound(aResults)
 {
   let prop = aResults[0].matchedProp;
   ok(prop, "matched the updated |testProp2| property value");
 
   // Check that testProp2 was updated.
-  executeSoon(() => gJSTerm.execute("fooObj.testProp2", onExecuteFooObjTestProp2));
+  executeSoon(() => gJSTerm.execute("fooObj.testProp2").then(onExecuteFooObjTestProp2));
 }
 
 function onExecuteFooObjTestProp2()
 {
   let para = content.wrappedJSObject.document.querySelector("p");
   let expected = content.document.title + "foo2SecondCall" + para;
 
   isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js b/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_while_debugging_and_inspecting.js
@@ -46,17 +46,17 @@ function inspectorOpened(aPanel)
   info("firstCall()");
   content.wrappedJSObject.firstCall();
 }
 
 function onFramesAdded()
 {
   info("onFramesAdded");
 
-  openConsole().then(() => gJSTerm.execute("fooObj", onExecuteFooObj));
+  openConsole().then(() => gJSTerm.execute("fooObj").then(onExecuteFooObj));
 }
 
 function onExecuteFooObj(msg)
 {
   ok(msg, "output message found");
   ok(msg.textContent.contains('{ testProp2: "testValue2" }'),
      "message text check");
 
@@ -106,17 +106,17 @@ function onFooObjFetchAfterUpdate(aVar)
 }
 
 function onUpdatedTestPropFound(aResults)
 {
   let prop = aResults[0].matchedProp;
   ok(prop, "matched the updated |testProp2| property value");
 
   // Check that testProp2 was updated.
-  gJSTerm.execute("fooObj.testProp2", onExecuteFooObjTestProp2);
+  gJSTerm.execute("fooObj.testProp2").then(onExecuteFooObjTestProp2);
 }
 
 function onExecuteFooObjTestProp2()
 {
   let para = content.wrappedJSObject.document.querySelector("p");
   let expected = content.document.title + "foo2SecondCall" + para;
 
   isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
diff --git a/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe.js b/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe.js
--- a/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe.js
+++ b/browser/devtools/webconsole/test/browser_eval_in_debugger_stackframe.js
@@ -16,29 +16,29 @@ function test()
     openConsole().then(consoleOpened);
   });
 }
 
 function consoleOpened(hud)
 {
   gWebConsole = hud;
   gJSTerm = hud.jsterm;
-  gJSTerm.execute("foo", onExecuteFoo);
+  gJSTerm.execute("foo").then(onExecuteFoo);
 }
 
 function onExecuteFoo()
 {
   isnot(gWebConsole.outputNode.textContent.indexOf("globalFooBug783499"), -1,
         "|foo| value is correct");
 
   gJSTerm.clearOutput();
 
   // Test for Bug 690529 - Web Console and Scratchpad should evaluate
   // expressions in the scope of the content window, not in a sandbox.
-  executeSoon(() => gJSTerm.execute("foo2 = 'newFoo'; window.foo2", onNewFoo2));
+  executeSoon(() => gJSTerm.execute("foo2 = 'newFoo'; window.foo2").then(onNewFoo2));
 }
 
 function onNewFoo2(msg)
 {
   is(gWebConsole.outputNode.textContent.indexOf("undefined"), -1,
      "|undefined| is not displayed after adding |foo2|");
 
   ok(msg, "output result found");
@@ -57,17 +57,17 @@ function debuggerOpened(aResult)
   gDebuggerWin = aResult.panelWin;
   gDebuggerController = gDebuggerWin.DebuggerController;
   gThread = gDebuggerController.activeThread;
   gStackframes = gDebuggerController.StackFrames;
 
   info("openConsole");
   executeSoon(() =>
     openConsole().then(() =>
-      gJSTerm.execute("foo + foo2", onExecuteFooAndFoo2)
+      gJSTerm.execute("foo + foo2").then(onExecuteFooAndFoo2)
     )
   );
 }
 
 function onExecuteFooAndFoo2()
 {
   let expected = "globalFooBug783499newFoo";
   isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
@@ -86,17 +86,17 @@ function onExecuteFooAndFoo2()
   });
 }
 
 function onFramesAdded()
 {
   info("onFramesAdded, openConsole() now");
   executeSoon(() =>
     openConsole().then(() =>
-      gJSTerm.execute("foo + foo2", onExecuteFooAndFoo2InSecondCall)
+      gJSTerm.execute("foo + foo2").then(onExecuteFooAndFoo2InSecondCall)
     )
   );
 }
 
 function onExecuteFooAndFoo2InSecondCall()
 {
   let expected = "globalFooBug783499foo2SecondCall";
   isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
@@ -108,31 +108,31 @@ function onExecuteFooAndFoo2InSecondCall
     info("openDebugger and selectFrame(1)");
 
     openDebugger().then(() => {
       gStackframes.selectFrame(1);
 
       info("openConsole");
       executeSoon(() =>
         openConsole().then(() =>
-          gJSTerm.execute("foo + foo2 + foo3", onExecuteFoo23InFirstCall)
+          gJSTerm.execute("foo + foo2 + foo3").then(onExecuteFoo23InFirstCall)
         )
       );
     });
   });
 }
 
 function onExecuteFoo23InFirstCall()
 {
   let expected = "fooFirstCallnewFoofoo3FirstCall";
   isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
         "|foo + foo2 + foo3| from |firstCall()|");
 
   executeSoon(() =>
-    gJSTerm.execute("foo = 'abba'; foo3 = 'bug783499'; foo + foo3",
+    gJSTerm.execute("foo = 'abba'; foo3 = 'bug783499'; foo + foo3").then(
                     onExecuteFooAndFoo3ChangesInFirstCall));
 }
 
 function onExecuteFooAndFoo3ChangesInFirstCall()
 {
   let expected = "abbabug783499";
   isnot(gWebConsole.outputNode.textContent.indexOf(expected), -1,
         "|foo + foo3| updated in |firstCall()|");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
@@ -23,17 +23,17 @@ let test = asyncTest(function*() {
     yield deferred.promise;
 
     ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
   }
 
   let { jsterm } = yield openConsole();
   let popup = jsterm.autocompletePopup;
 
-  jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
+  yield jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
 
   // Should work with bug 967468.
   yield autocomplete("Object.__d");
   yield autocomplete("testObject.$$a");
 
   // Here's when things go wrong in bug 967468.
   yield autocomplete("Object.__de");
   yield autocomplete("testObject.$$aa");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -17,30 +17,30 @@ let test = asyncTest(function*() {
   yield testReturnWithNoSelection();
   yield popupHideAfterReturnWithNoSelection();
   yield testCompletionInText();
   yield popupHideAfterCompletionInText();
 
   HUD = popup = jsterm = inputNode = completeNode = null;
 });
 
-function consoleOpened(aHud) {
+let consoleOpened = Task.async(function*(aHud) {
   let deferred = promise.defer();
   HUD = aHud;
   info("web console opened");
 
   jsterm = HUD.jsterm;
 
-  jsterm.execute("window.foobarBug585991={" +
+  yield jsterm.execute("window.foobarBug585991={" +
     "'item0': 'value0'," +
     "'item1': 'value1'," +
     "'item2': 'value2'," +
     "'item3': 'value3'" +
   "}");
-  jsterm.execute("window.testBug873250a = 'hello world';"
+  yield jsterm.execute("window.testBug873250a = 'hello world';"
     + "window.testBug873250b = 'hello world 2';");
   popup = jsterm.autocompletePopup;
   completeNode = jsterm.completeNode;
   inputNode = jsterm.inputNode;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
@@ -128,17 +128,17 @@ function consoleOpened(aHud) {
     EventUtils.synthesizeKey("VK_TAB", {});
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   jsterm.setInputValue("window.foobarBug585991");
   EventUtils.synthesizeKey(".", {});
 
   return deferred.promise;
-}
+});
 
 function popupHideAfterTab()
 {
   let deferred = promise.defer();
 
   // At this point the completion suggestion should be accepted.
   ok(!popup.isOpen, "popup is not open");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -15,42 +15,42 @@ const TEST_URI = "http://example.com/";
 let test = asyncTest(function* () {
   yield loadTab(TEST_URI);
 
   let hud = yield openConsole();
   yield testSelectionWhenMovingBetweenBoxes(hud);
   performTestsAfterOutput(hud);
 })
 
-function testSelectionWhenMovingBetweenBoxes(aHud) {
+let testSelectionWhenMovingBetweenBoxes = Task.async(function *(aHud) {
   let hud = aHud;
   let jsterm = hud.jsterm;
 
   // Fill the console with some output.
   jsterm.clearOutput();
-  jsterm.execute("1 + 2");
-  jsterm.execute("3 + 4");
-  jsterm.execute("5 + 6");
+  yield jsterm.execute("1 + 2");
+  yield jsterm.execute("3 + 4");
+  yield jsterm.execute("5 + 6");
 
   return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "3",
       category: CATEGORY_OUTPUT,
     },
     {
       text: "7",
       category: CATEGORY_OUTPUT,
     },
     {
       text: "11",
       category: CATEGORY_OUTPUT,
     }],
   });
-}
+});
 
 function performTestsAfterOutput(aHud) {
   let hud = aHud;
   let outputNode = hud.outputNode;
 
   ok(outputNode.childNodes.length >= 3, "the output node has children after " +
      "executing some JavaScript");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
@@ -109,17 +109,17 @@ function networkPanelHidden() {
   EventUtils.sendMouseEvent({type: "click", button: 2},
     outputItem);
 
   executeSoon(function() {
     document.removeEventListener("popupshown", networkPanelShowFailure, false);
 
     // Done with the network output. Now test the jsterm output and the property
     // panel.
-    HUD.jsterm.execute("document", (msg) => {
+    HUD.jsterm.execute("document").then((msg) => {
       info("jsterm execute 'document' callback");
 
       HUD.jsterm.once("variablesview-open", deferred.resolve);
       let outputItem = msg.querySelector(".message-body a");
       ok(outputItem, "jsterm output message found");
 
       // Send the mousedown and click events such that the property panel opens.
       EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
@@ -38,19 +38,17 @@ function test() {
         text: "LongNonwrappingMessage",
       }, {
         text: "test2 message 0",
       }, {
         text: "test2 message 49",
       }],
     });
 
-    let nodeDeferred = promise.defer();
-    hud.jsterm.execute("1+1", (node) => { nodeDeferred.resolve(node); });
-    let node = yield nodeDeferred.promise;
+    let node = yield hud.jsterm.execute("1+1");
 
     let scrollNode = hud.outputNode.parentNode;
     let rectNode = node.getBoundingClientRect();
     let rectOutput = scrollNode.getBoundingClientRect();
     console.debug("rectNode", rectNode, "rectOutput", rectOutput);
     console.log("scrollNode scrollHeight", scrollNode.scrollHeight, "scrollTop", scrollNode.scrollTop, "clientHeight", scrollNode.clientHeight);
 
     isnot(scrollNode.scrollTop, 0, "scroll location is not at the top");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
@@ -38,17 +38,17 @@ function consoleOpened(hud) {
       text: "test message 149",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
   }).then(() => {
     oldScrollTop = scrollNode.scrollTop;
     isnot(oldScrollTop, 0, "scroll location is not at the top");
 
-    hud.jsterm.execute("'hello world'", onExecute);
+    hud.jsterm.execute("'hello world'").then(onExecute);
   });
 
   function onExecute(msg)
   {
     isnot(scrollNode.scrollTop, oldScrollTop, "scroll location updated");
 
     oldScrollTop = scrollNode.scrollTop;
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js b/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
@@ -11,64 +11,64 @@ let test = asyncTest(function* () {
   yield loadTab(TEST_URI);
 
   let hud = yield openConsole();
   let jsterm = hud.jsterm;
   let outputNode = hud.outputNode;
 
   hud.jsterm.clearOutput();
 
-  jsterm.execute("console.group('bug664131a')")
+  yield jsterm.execute("console.group('bug664131a')")
 
   yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bug664131a",
       consoleGroup: 1,
     }],
   });
 
-  jsterm.execute("console.log('bug664131a-inside')")
+  yield jsterm.execute("console.log('bug664131a-inside')")
 
   yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bug664131a-inside",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       groupDepth: 1,
     }],
   });
 
-  jsterm.execute('console.groupEnd("bug664131a")');
-  jsterm.execute('console.log("bug664131-outside")');
+  yield jsterm.execute('console.groupEnd("bug664131a")');
+  yield jsterm.execute('console.log("bug664131-outside")');
 
   yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bug664131-outside",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       groupDepth: 0,
     }],
   });
 
-  jsterm.execute('console.groupCollapsed("bug664131b")');
+  yield jsterm.execute('console.groupCollapsed("bug664131b")');
 
   yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bug664131b",
       consoleGroup: 1,
     }],
   });
 
   // Test that clearing the console removes the indentation.
   hud.jsterm.clearOutput();
-  jsterm.execute('console.log("bug664131-cleared")');
+  yield jsterm.execute('console.log("bug664131-cleared")');
 
   yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bug664131-cleared",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       groupDepth: 0,
diff --git a/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js
@@ -29,17 +29,17 @@ let test = asyncTest(function* () {
 
   // Test typing 'window.'.
   input.value = "window.";
   input.setSelectionRange(7, 7);
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   ok(popup.getItems().length > 0, "'window.' gave a list of suggestions")
 
-  jsterm.execute("window.docfoobar = true");
+  yield jsterm.execute("window.docfoobar = true");
 
   // Test typing 'window.doc'.
   input.value = "window.doc";
   input.setSelectionRange(10, 10);
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   let newItems = popup.getItems();
   ok(newItems.every(function(item) {
@@ -51,17 +51,17 @@ let test = asyncTest(function* () {
   input.setSelectionRange(9, 9);
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems();
   ok(newItems.every(function(item) {
        return item.label != "docfoobar";
      }), "autocomplete cached results do not contain docfoobar. list has not been updated");
 
-  jsterm.execute("delete window.docfoobar");
+  yield jsterm.execute("delete window.docfoobar");
 
   // Test if 'window.getC' gives 'getComputedStyle'
   input.value = "window."
   input.setSelectionRange(7, 7);
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   input.value = "window.getC";
   input.setSelectionRange(11, 11);
@@ -79,29 +79,29 @@ let test = asyncTest(function* () {
 
   ok(popup.getItems().length > 0, "'dump(d' gives non-zero results");
 
   // Test that 'dump(window.)' works.
   input.value = "dump(window.)";
   input.setSelectionRange(12, 12);
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
-  jsterm.execute("window.docfoobar = true");
+  yield jsterm.execute("window.docfoobar = true");
 
   // Make sure 'dump(window.doc)' does not contain 'docfoobar'.
   input.value = "dump(window.doc)";
   input.setSelectionRange(15, 15);
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems();
   ok(newItems.every(function(item) {
        return item.label != "docfoobar";
      }), "autocomplete cached results do not contain docfoobar. list has not been updated");
 
-  jsterm.execute("delete window.docfoobar");
+  yield jsterm.execute("delete window.docfoobar");
 
   jsterm = null;
 });
 
 function complete(type) {
   let updated = jsterm.once("autocomplete-updated");
   jsterm.complete(type);
   return updated;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js b/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
--- a/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
@@ -37,74 +37,74 @@ function test() {
   }];
 
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     const {tab} = yield loadTab(TEST_URI);
     hud = yield openConsole(tab);
 
-    executeWindowTest();
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     info("cd() into the iframe using a selector");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd('iframe')");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd('iframe')");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: childMessages });
 
     info("cd() out of the iframe, reset to default window");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd()");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd()");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     info("call cd() with unexpected arguments");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd(document)");
+    yield hud.jsterm.execute("cd(document)");
 
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "Cannot cd()",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_ERROR,
       }],
     });
 
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd('p')");
+    yield hud.jsterm.execute("cd('p')");
 
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "Cannot cd()",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_ERROR,
       }],
     });
 
     info("cd() into the iframe using an iframe DOM element");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd($('iframe'))");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd($('iframe'))");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: childMessages });
 
     info("cd(window.parent)");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd(window.parent)");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd(window.parent)");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     yield closeConsole(tab);
   }
 
   function executeWindowTest() {
-    hud.jsterm.execute("document.title");
-    hud.jsterm.execute("'p: ' + document.querySelector('p').textContent");
-    hud.jsterm.execute("'obj: ' + window.foobarBug609872");
+    yield hud.jsterm.execute("document.title");
+    yield hud.jsterm.execute("'p: ' + document.querySelector('p').textContent");
+    yield hud.jsterm.execute("'obj: ' + window.foobarBug609872");
   }
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_completion.js b/browser/devtools/webconsole/test/browser_webconsole_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_completion.js
@@ -64,17 +64,17 @@ let test = asyncTest(function* () {
   is(jsterm.completeNode.value, "                entsByTagNameNS", "'document.getElem' completion");
 
   jsterm.clearOutput();
 
   input.value = "docu";
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "    ment", "'docu' completion");
-  jsterm.execute();
+  yield jsterm.execute();
   is(jsterm.completeNode.value, "", "clear completion on execute()");
 
   // Test multi-line completion works
   input.value =                 "console.log('one');\nconsol";
   yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "                   \n      e", "multi-line completion");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_history.js b/browser/devtools/webconsole/test/browser_webconsole_history.js
--- a/browser/devtools/webconsole/test/browser_webconsole_history.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_history.js
@@ -20,17 +20,17 @@ let test = asyncTest(function*() {
 
   let jsterm = hud.jsterm;
   let input = jsterm.inputNode;
 
   let executeList = ["document", "window", "window.location"];
 
   for each (var item in executeList) {
     input.value = item;
-    jsterm.execute();
+    yield jsterm.execute();
   }
 
   for (var i = executeList.length - 1; i != -1; i--) {
     jsterm.historyPeruse(HISTORY_BACK);
     is (input.value, executeList[i], "check history previous idx:" + i);
   }
 
   jsterm.historyPeruse(HISTORY_BACK);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
--- a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
@@ -1,178 +1,144 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let jsterm, testDriver;
+let jsterm;
 
-function test() {
-  loadTab(TEST_URI).then(() => {
-    openConsole().then((hud) => {
-      testDriver = testJSTerm(hud);
-      testDriver.next();
-    })
-  });
-}
-
-function nextTest() {
-  testDriver.next();
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  jsterm = hud.jsterm;
+  yield testJSTerm(hud);
+  jsterm  = null;
+});
 
 function checkResult(msg, desc) {
+  let def = promise.defer();
   waitForMessages({
     webconsole: jsterm.hud.owner,
     messages: [{
       name: desc,
       category: CATEGORY_OUTPUT,
     }],
   }).then(([result]) => {
     let node = [...result.matched][0].querySelector(".message-body");
     if (typeof msg == "string") {
       is(node.textContent.trim(), msg,
         "correct message shown for " + desc);
     }
     else if (typeof msg == "function") {
       ok(msg(node), "correct message shown for " + desc);
     }
 
-    nextTest();
+    def.resolve();
   });
+  return def.promise;
 }
 
 function testJSTerm(hud)
 {
-  jsterm = hud.jsterm;
   const HELP_URL = "https://developer.mozilla.org/docs/Tools/Web_Console/Helpers";
 
   jsterm.clearOutput();
-  jsterm.execute("$('#header').getAttribute('id')");
-  checkResult('"header"', "$() worked");
-  yield undefined;
+  yield jsterm.execute("$('#header').getAttribute('id')");
+  yield checkResult('"header"', "$() worked");
 
   jsterm.clearOutput();
-  jsterm.execute("$$('h1').length");
-  checkResult("1", "$$() worked");
-  yield undefined;
+  yield jsterm.execute("$$('h1').length");
+  yield checkResult("1", "$$() worked");
 
   jsterm.clearOutput();
-  jsterm.execute("$x('.//*', document.body)[0] == $$('h1')[0]");
-  checkResult("true", "$x() worked");
-  yield undefined;
+  yield jsterm.execute("$x('.//*', document.body)[0] == $$('h1')[0]");
+  yield checkResult("true", "$x() worked");
 
   // no jsterm.clearOutput() here as we clear the output using the clear() fn.
-  jsterm.execute("clear()");
+  yield jsterm.execute("clear()");
 
-  waitForSuccess({
+  yield waitForSuccess({
     name: "clear() worked",
     validator: function()
     {
       return jsterm.outputNode.childNodes.length == 0;
     }
-  }).then(nextTest);
-
-  yield undefined;
+  });
 
   jsterm.clearOutput();
-  jsterm.execute("keys({b:1})[0] == 'b'");
-  checkResult("true", "keys() worked", 1);
-  yield undefined;
+  yield jsterm.execute("keys({b:1})[0] == 'b'");
+  yield checkResult("true", "keys() worked", 1);
 
   jsterm.clearOutput();
-  jsterm.execute("values({b:1})[0] == 1");
-  checkResult("true", "values() worked", 1);
-  yield undefined;
+  yield jsterm.execute("values({b:1})[0] == 1");
+  yield checkResult("true", "values() worked", 1);
 
   jsterm.clearOutput();
 
   let openedLinks = 0;
-  let onExecuteCalls = 0;
   let oldOpenLink = hud.openLink;
   hud.openLink = (url) => {
     if (url == HELP_URL) {
       openedLinks++;
     }
   };
 
-  function onExecute() {
-    onExecuteCalls++;
-    if (onExecuteCalls == 3) {
-      nextTest();
-    }
-  }
-
-  jsterm.execute("help()", onExecute);
-  jsterm.execute("help", onExecute);
-  jsterm.execute("?", onExecute);
-  yield undefined;
+  yield jsterm.execute("help()");
+  yield jsterm.execute("help");
+  yield jsterm.execute("?");
 
   let output = jsterm.outputNode.querySelector(".message[category='output']");
   ok(!output, "no output for help() calls");
   is(openedLinks, 3, "correct number of pages opened by the help calls");
   hud.openLink = oldOpenLink;
 
   jsterm.clearOutput();
-  jsterm.execute("pprint({b:2, a:1})");
-  checkResult("\"  b: 2\n  a: 1\"", "pprint()");
-  yield undefined;
+  yield jsterm.execute("pprint({b:2, a:1})");
+  yield checkResult("\"  b: 2\n  a: 1\"", "pprint()");
 
   // check instanceof correctness, bug 599940
   jsterm.clearOutput();
-  jsterm.execute("[] instanceof Array");
-  checkResult("true", "[] instanceof Array == true");
-  yield undefined;
+  yield jsterm.execute("[] instanceof Array");
+  yield checkResult("true", "[] instanceof Array == true");
 
   jsterm.clearOutput();
-  jsterm.execute("({}) instanceof Object");
-  checkResult("true", "({}) instanceof Object == true");
-  yield undefined;
+  yield jsterm.execute("({}) instanceof Object");
+  yield checkResult("true", "({}) instanceof Object == true");
 
   // check for occurrences of Object XRayWrapper, bug 604430
   jsterm.clearOutput();
-  jsterm.execute("document");
-  checkResult(function(node) {
+  yield jsterm.execute("document");
+  yield checkResult(function(node) {
     return node.textContent.search(/\[object xraywrapper/i) == -1;
   }, "document - no XrayWrapper");
-  yield undefined;
 
   // check that pprint(window) and keys(window) don't throw, bug 608358
   jsterm.clearOutput();
-  jsterm.execute("pprint(window)");
-  checkResult(null, "pprint(window)");
-  yield undefined;
+  yield jsterm.execute("pprint(window)");
+  yield checkResult(null, "pprint(window)");
 
   jsterm.clearOutput();
-  jsterm.execute("keys(window)");
-  checkResult(null, "keys(window)");
-  yield undefined;
+  yield jsterm.execute("keys(window)");
+  yield checkResult(null, "keys(window)");
 
   // bug 614561
   jsterm.clearOutput();
-  jsterm.execute("pprint('hi')");
-  checkResult("\"  0: \"h\"\n  1: \"i\"\"", "pprint('hi')");
-  yield undefined;
+  yield jsterm.execute("pprint('hi')");
+  yield checkResult("\"  0: \"h\"\n  1: \"i\"\"", "pprint('hi')");
 
   // check that pprint(function) shows function source, bug 618344
   jsterm.clearOutput();
-  jsterm.execute("pprint(function() { var someCanaryValue = 42; })");
-  checkResult(function(node) {
+  yield jsterm.execute("pprint(function() { var someCanaryValue = 42; })");
+  yield checkResult(function(node) {
     return node.textContent.indexOf("someCanaryValue") > -1;
   }, "pprint(function) shows source");
-  yield undefined;
 
   // check that an evaluated null produces "null", bug 650780
   jsterm.clearOutput();
-  jsterm.execute("null");
-  checkResult("null", "null is null");
-  yield undefined;
+  yield jsterm.execute("null");
+  yield checkResult("null", "null is null");
 
   jsterm.clearOutput();
-  jsterm.execute("undefined");
-  checkResult("undefined", "undefined is printed");
-  yield undefined;
-
-  jsterm = testDriver = null;
-  executeSoon(finishTest);
-  yield undefined;
+  yield jsterm.execute("undefined");
+  yield checkResult("undefined", "undefined is printed");
 }
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -3313,19 +3313,30 @@ JSTerm.prototype = {
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [aExecuteString]
    *        The string you want to execute. If this is not provided, the current
    *        user input is used - taken from |this.inputNode.value|.
    * @param function [aCallback]
    *        Optional function to invoke when the result is displayed.
+   *        This is deprecated - please use the promise return value instead.
+   * @returns Promise
+   *          Resolves with the message once the result is displayed.
    */
   execute: function JST_execute(aExecuteString, aCallback)
   {
+    let deferred = promise.defer();
+    let callback = function(msg) {
+      deferred.resolve(msg);
+      if (aCallback) {
+        aCallback(msg);
+      }
+    }
+
     // attempt to execute the content of the inputNode
     aExecuteString = aExecuteString || this.inputNode.value;
     if (!aExecuteString) {
       return;
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
@@ -3333,33 +3344,34 @@ JSTerm.prototype = {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
     }
 
     let message = new Messages.Simple(aExecuteString, {
       category: "input",
       severity: "log",
     });
     this.hud.output.addMessage(message);
-    let onResult = this._executeResultCallback.bind(this, message, aCallback);
+    let onResult = this._executeResultCallback.bind(this, message, callback);
 
     let options = {
       frame: this.SELECTED_FRAME,
       selectedNodeActor: selectedNodeActor,
     };
 
     this.requestEvaluation(aExecuteString, options).then(onResult, onResult);
 
     // Append a new value in the history of executed code, or overwrite the most
     // recent entry. The most recent entry may contain the last edited input
     // value that was not evaluated yet.
     this.history[this.historyIndex++] = aExecuteString;
     this.historyPlaceHolder = this.history.length;
     WebConsoleUtils.usageCount++;
     this.setInputValue("");
     this.clearCompletion();
+    return deferred.promise;
   },
 
   /**
    * Request a JavaScript string evaluation from the server.
    *
    * @param string aString
    *        String to execute.
    * @param object [aOptions]
