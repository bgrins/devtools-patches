# HG changeset patch
# Parent fea380e421cce0f37b8c0664d58280e6d264b502
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1088861 - Console doesn't respond when debugger is paused at breakpoint that was hit by executing a command in the console - part 2;r=past


diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js b/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_dont_sort_non_sortable_classes_properties.js
@@ -52,17 +52,17 @@ function test() {
                              "Float64Array"];
 
     const {tab} = yield loadTab(TEST_URI);
     const hud = yield openConsole(tab);
     jsterm = hud.jsterm;
 
     // Create an ArrayBuffer of 80 bytes to test TypedArrays. 80 bytes is
     // enough to get 10 items in all different TypedArrays.
-    jsterm.execute("let buf = new ArrayBuffer(80);");
+    yield jsterm.execute("let buf = new ArrayBuffer(80);");
 
     // Array
     yield testNotSorted("Array(0,1,2,3,4,5,6,7,8,9,10)");
     // NodeList
     yield testNotSorted("document.querySelectorAll('div')");
 
     // Typed arrays.
     for (let type of typedArrayTypes) {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
@@ -24,17 +24,17 @@ function test() {
 
       ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
     }
 
     yield addTab(TEST_URI);
     let { jsterm } = yield openConsole(tab);
     let popup = jsterm.autocompletePopup;
 
-    jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
+    yield jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
 
     // Should work with bug 967468.
     yield autocomplete("Object.__d");
     yield autocomplete("testObject.$$a");
 
     // Here's when things go wrong in bug 967468.
     yield autocomplete("Object.__de");
     yield autocomplete("testObject.$$aa");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -9,23 +9,23 @@ let HUD, popup, jsterm, inputNode, compl
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, consoleOpened);
   }, true);
 }
 
-function consoleOpened(aHud) {
+let consoleOpened = Task.async(function*(aHud) {
   HUD = aHud;
   info("web console opened");
 
   jsterm = HUD.jsterm;
 
-  jsterm.execute("window.foobarBug585991={" +
+  yield jsterm.execute("window.foobarBug585991={" +
     "'item0': 'value0'," +
     "'item1': 'value1'," +
     "'item2': 'value2'," +
     "'item3': 'value3'" +
   "}");
   popup = jsterm.autocompletePopup;
   completeNode = jsterm.completeNode;
   inputNode = jsterm.inputNode;
@@ -112,17 +112,17 @@ function consoleOpened(aHud) {
     info("press Tab and wait for popup to hide");
     popup._panel.addEventListener("popuphidden", popupHideAfterTab, false);
     EventUtils.synthesizeKey("VK_TAB", {});
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   jsterm.setInputValue("window.foobarBug585991");
   EventUtils.synthesizeKey(".", {});
-}
+});
 
 function popupHideAfterTab()
 {
   // At this point the completion suggestion should be accepted.
   popup._panel.removeEventListener("popuphidden", popupHideAfterTab, false);
 
   ok(!popup.isOpen, "popup is not open");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -14,42 +14,42 @@ function test() {
   let hud;
 
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, testSelectionWhenMovingBetweenBoxes);
   }, true);
 
-  function testSelectionWhenMovingBetweenBoxes(aHud) {
+  let testSelectionWhenMovingBetweenBoxes = Task.async(function *(aHud) {
     hud = aHud;
     let jsterm = hud.jsterm;
 
     // Fill the console with some output.
     jsterm.clearOutput();
-    jsterm.execute("1 + 2");
-    jsterm.execute("3 + 4");
-    jsterm.execute("5 + 6");
+    yield jsterm.execute("1 + 2");
+    yield jsterm.execute("3 + 4");
+    yield jsterm.execute("5 + 6");
 
     waitForMessages({
       webconsole: hud,
       messages: [{
         text: "3",
         category: CATEGORY_OUTPUT,
       },
       {
         text: "7",
         category: CATEGORY_OUTPUT,
       },
       {
         text: "11",
         category: CATEGORY_OUTPUT,
       }],
     }).then(performTestsAfterOutput);
-  }
+  });
 
   function performTestsAfterOutput() {
     let outputNode = hud.outputNode;
 
     ok(outputNode.childNodes.length >= 3, "the output node has children after " +
        "executing some JavaScript");
 
     // Test that the global Firefox "Select All" functionality (e.g. Edit >
diff --git a/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js b/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
--- a/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_cd_iframe.js
@@ -37,74 +37,74 @@ function test() {
   }];
 
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     const {tab} = yield loadTab(TEST_URI);
     hud = yield openConsole(tab);
 
-    executeWindowTest();
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     info("cd() into the iframe using a selector");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd('iframe')");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd('iframe')");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: childMessages });
 
     info("cd() out of the iframe, reset to default window");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd()");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd()");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     info("call cd() with unexpected arguments");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd(document)");
+    yield hud.jsterm.execute("cd(document)");
 
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "Cannot cd()",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_ERROR,
       }],
     });
 
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd('p')");
+    yield hud.jsterm.execute("cd('p')");
 
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "Cannot cd()",
         category: CATEGORY_OUTPUT,
         severity: SEVERITY_ERROR,
       }],
     });
 
     info("cd() into the iframe using an iframe DOM element");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd($('iframe'))");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd($('iframe'))");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: childMessages });
 
     info("cd(window.parent)");
     hud.jsterm.clearOutput();
-    hud.jsterm.execute("cd(window.parent)");
-    executeWindowTest();
+    yield hud.jsterm.execute("cd(window.parent)");
+    yield executeWindowTest();
 
     yield waitForMessages({ webconsole: hud, messages: parentMessages });
 
     yield closeConsole(tab);
   }
 
   function executeWindowTest() {
-    hud.jsterm.execute("document.title");
-    hud.jsterm.execute("'p: ' + document.querySelector('p').textContent");
-    hud.jsterm.execute("'obj: ' + window.foobarBug609872");
+    yield hud.jsterm.execute("document.title");
+    yield hud.jsterm.execute("'p: ' + document.querySelector('p').textContent");
+    yield hud.jsterm.execute("'obj: ' + window.foobarBug609872");
   }
 }
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -3313,19 +3313,29 @@ JSTerm.prototype = {
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [aExecuteString]
    *        The string you want to execute. If this is not provided, the current
    *        user input is used - taken from |this.inputNode.value|.
    * @param function [aCallback]
    *        Optional function to invoke when the result is displayed.
+   * @returns Promise
+   *          Resolves once the result is displayed.
    */
   execute: function JST_execute(aExecuteString, aCallback)
   {
+    let deferred = promise.defer();
+    let callback = function() {
+      deferred.resolve();
+      if (aCallback) {
+        aCallback.apply(this, arguments);
+      }
+    }
+
     // attempt to execute the content of the inputNode
     aExecuteString = aExecuteString || this.inputNode.value;
     if (!aExecuteString) {
       return;
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
@@ -3333,33 +3343,34 @@ JSTerm.prototype = {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
     }
 
     let message = new Messages.Simple(aExecuteString, {
       category: "input",
       severity: "log",
     });
     this.hud.output.addMessage(message);
-    let onResult = this._executeResultCallback.bind(this, message, aCallback);
+    let onResult = this._executeResultCallback.bind(this, message, callback);
 
     let options = {
       frame: this.SELECTED_FRAME,
       selectedNodeActor: selectedNodeActor,
     };
 
     this.requestEvaluation(aExecuteString, options).then(onResult, onResult);
 
     // Append a new value in the history of executed code, or overwrite the most
     // recent entry. The most recent entry may contain the last edited input
     // value that was not evaluated yet.
     this.history[this.historyIndex++] = aExecuteString;
     this.historyPlaceHolder = this.history.length;
     WebConsoleUtils.usageCount++;
     this.setInputValue("");
     this.clearCompletion();
+    return deferred.promise;
   },
 
   /**
    * Request a JavaScript string evaluation from the server.
    *
    * @param string aString
    *        String to execute.
    * @param object [aOptions]
