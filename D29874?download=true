diff --git a/accessible/html/HTMLFormControlAccessible.h b/accessible/html/HTMLFormControlAccessible.h
--- a/accessible/html/HTMLFormControlAccessible.h
+++ b/accessible/html/HTMLFormControlAccessible.h
@@ -98,9 +98,21 @@
   virtual ENameValueFlag NativeName(nsString& aName) const override;
 
   /**
-   * Return a XUL widget element this input is part of.
+   * Return a widget element this input is part of, for example, XUL:textbox or
+   * HTML:input@type="number".
    */
-  nsIContent* BindingParent() const { return mContent->GetBindingParent(); }
+  nsIContent* BindingOrWidgetParent() const {
+    nsIContent * el = mContent->GetBindingParent();
+    if (el) {
+      return el;
+    }
+    // XUL textboxes custom elements implementation.
+    if (mDoc->DocumentNode()->IsXULDocument()) {
+      ErrorResult rv;
+      return Elm()->Closest(NS_LITERAL_STRING("textbox"), rv);
+    }
+    return nullptr;
+  }
 };
 
 /**
diff --git a/accessible/html/HTMLFormControlAccessible.cpp b/accessible/html/HTMLFormControlAccessible.cpp
--- a/accessible/html/HTMLFormControlAccessible.cpp
+++ b/accessible/html/HTMLFormControlAccessible.cpp
@@ -226,7 +226,7 @@
   // has an embedded anonymous input[type=text] (along with spinner buttons).
   // In that case, we would want to take the input type from the parent
   // and not the anonymous content.
-  nsIContent* widgetElm = BindingParent();
+  nsIContent* widgetElm = BindingOrWidgetParent();
   if ((widgetElm && widgetElm->AsElement()->GetAttr(kNameSpaceID_None,
                                                     nsGkAtoms::type, type)) ||
       mContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::type,
@@ -259,7 +259,7 @@
   if (!aName.IsEmpty()) return nameFlag;
 
   // If part of compound of XUL widget then grab a name from XUL widget element.
-  nsIContent* widgetElm = BindingParent();
+  nsIContent* widgetElm = BindingOrWidgetParent();
   if (widgetElm) XULElmName(mDoc, widgetElm, aName);
 
   if (!aName.IsEmpty()) return eNameOK;
@@ -295,7 +295,7 @@
 
   // If part of compound of XUL widget then pick up ARIA stuff from XUL widget
   // element.
-  nsIContent* widgetElm = BindingParent();
+  nsIContent* widgetElm = BindingOrWidgetParent();
   if (widgetElm)
     aria::MapToState(aria::eARIAAutoComplete, widgetElm->AsElement(), aState);
 }
@@ -338,7 +338,7 @@
     return state | states::SUPPORTS_AUTOCOMPLETION | states::HASPOPUP;
 
   // Ordinal XUL textboxes don't support autocomplete.
-  if (!BindingParent() && Preferences::GetBool("browser.formfill.enable")) {
+  if (!BindingOrWidgetParent() && Preferences::GetBool("browser.formfill.enable")) {
     // Check to see if autocompletion is allowed on this input. We don't expose
     // it for password fields even though the entire password can be remembered
     // for a page if the user asks it to be. However, the kind of autocomplete

