# HG changeset patch
# Parent a775b89631d4b3a30f2a6103113343eba9cd0704
# User Brian Grinstead <bgrinstead@mozilla.com>
trying to clean up exceptions in markup view

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -683,17 +683,17 @@ MarkupView.prototype = {
     }
     this._waitForChildren().then((nodes) => {
       this._flashMutatedNodes(aMutations);
       this._inspector.emit("markupmutation", aMutations);
 
       // Since the htmlEditor is absolutely positioned, a mutation may change
       // the location in which it should be shown.
       this.htmlEditor.refresh();
-    });
+    }, console.error);
   },
 
   /**
    * React to display-change events from the walker
    * @param {Array} nodes An array of nodeFronts
    */
   _onDisplayChange: function(nodes) {
     for (let node of nodes) {
@@ -764,17 +764,17 @@ MarkupView.prototype = {
       this.expandNode(parent);
     }
 
     return this._waitForChildren().then(() => {
       if (this._destroyer) {
         return promise.reject("markupview destroyed");
       }
       return this._ensureVisible(aNode);
-    }).then(() => {
+    }, console.error).then(() => {
       // Why is this not working?
       this.layoutHelpers.scrollIntoViewIfNeeded(this.getContainer(aNode).editor.elt, centered);
     }, e => {
       // Only report this rejection as an error if the panel hasn't been
       // destroyed in the meantime.
       if (!this._destroyer) {
         console.error(e);
       } else {
@@ -1254,32 +1254,43 @@ MarkupView.prototype = {
         if (!children.hasLast) {
           let span = this.template("more-nodes", data);
           fragment.appendChild(span);
         }
       }
 
       aContainer.children.appendChild(fragment);
       return aContainer;
-    }).then(null, console.error);
+    }, console.error).then(null, console.error);
     this._queuedChildUpdates.set(aContainer, updatePromise);
     return updatePromise;
   },
 
   _waitForChildren: function() {
     if (!this._queuedChildUpdates) {
       return promise.resolve(undefined);
     }
-    return promise.all([updatePromise for (updatePromise of this._queuedChildUpdates.values())]);
+    let defer = promise.defer();
+    promise.all([updatePromise for (updatePromise of this._queuedChildUpdates.values())]).then(() => {
+      if (this._destroyer) {
+        defer.reject("Markup view destroyed while waiting");
+      } else {
+        defer.resolve();
+      }
+    });
+    return defer.promise;
   },
 
   /**
    * Return a list of the children to display for this container.
    */
   _getVisibleChildren: function(aContainer, aCentered) {
+    if (this._destroyer) {
+      return promise.reject("_getVisibleChildren requested while destroyed");
+    }
     let maxChildren = aContainer.maxChildren || this.maxChildren;
     if (maxChildren == -1) {
       maxChildren = undefined;
     }
 
     return this.walker.children(aContainer.node, {
       maxNodes: maxChildren,
       center: aCentered
@@ -1346,16 +1357,18 @@ MarkupView.prototype = {
 
     this._elt.removeEventListener("mousemove", this._onMouseMove, false);
     this._elt.removeEventListener("mouseleave", this._onMouseLeave, false);
     this._elt = null;
 
     for (let [key, container] of this._containers) {
       container.destroy();
     }
+    console.log("BRIAN DESTROY");
+    console.trace();
     this._containers = null;
 
     this.tooltip.destroy();
     this.tooltip = null;
 
     return this._destroyer;
   },
 
@@ -1925,17 +1938,17 @@ MarkupElementContainer.prototype = Herit
    * Checks if the target is indeed something we want to have an image tooltip
    * preview over and, if so, inserts content into the tooltip.
    * @return a promise that resolves when the content has been inserted or
    * rejects if no preview is required. This promise is then used by Tooltip.js
    * to decide if/when to show the tooltip
    */
   isImagePreviewTarget: function(target, tooltip) {
     if (!this.tooltipData || this.tooltipData.target !== target) {
-      return promise.reject();
+      return promise.reject("wrong target");
     }
 
     return this.tooltipData.data.then(({data, size}) => {
       tooltip.setImageContent(data, size);
     }, () => {
       tooltip.setBrokenImageContent();
     });
   },
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1530,16 +1530,19 @@ var WalkerActor = protocol.ActorClass({
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   children: method(function(node, options={}) {
     if (options.center && options.start) {
       throw Error("Can't specify both 'center' and 'start' options.");
     }
+    if (!node) {
+      throw Error("Node is not defined");
+    }
     let maxNodes = options.maxNodes || -1;
     if (maxNodes == -1) {
       maxNodes = Number.MAX_VALUE;
     }
 
     // We're going to create a few document walkers with the same filter,
     // make it easier.
     let getFilteredWalker = (node) => {
