# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1539119208 25200
#      Tue Oct 09 14:06:48 2018 -0700
# Node ID e00942169a4739244cd7a54e49558e972ed70250
# Parent  a9616aaeff87448588d57c295e16eb4caec420fb
Bug 1497599 - Wait for isConnectedAndReady before running attributeChangedCallbacks;r=paolo

We usually don't want to run attributeChangedCallback logic until we are connected,
since we'll properly initialize the UI based on attribute values in connectedCallback.
However, in XML documents when attributeChangedCallback fires before connectedCallback
during parse, `this.isConnected` is true. `this.isConnectedAndReady` will make sure we
also early return in the parse case.

Differential Revision: https://phabricator.services.mozilla.com/D8150

diff --git a/toolkit/content/widgets/progressmeter.js b/toolkit/content/widgets/progressmeter.js
--- a/toolkit/content/widgets/progressmeter.js
+++ b/toolkit/content/widgets/progressmeter.js
@@ -76,16 +76,20 @@ class MozProgressmeter extends MozXULEle
     this.runAnimation = false;
   }
 
   static get observedAttributes() {
     return [ "mode" ];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady) {
+      return;
+    }
+
     if (name === "mode" && oldValue != newValue) {
       this._initUI();
     }
   }
 
   _initUI() {
     let isUndetermined = this.isUndetermined();
     let content = isUndetermined ?
diff --git a/toolkit/content/widgets/textbox.js b/toolkit/content/widgets/textbox.js
--- a/toolkit/content/widgets/textbox.js
+++ b/toolkit/content/widgets/textbox.js
@@ -56,28 +56,31 @@ const cachedFragments = {
 };
 
 class MozInputBox extends MozXULElement {
   static get observedAttributes() {
     return ["spellcheck"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
-    if (name === "spellcheck") {
-      this.spellcheck = newValue;
+    if (!this.isConnectedAndReady) {
+      return;
+    }
+
+    if (name === "spellcheck" && oldValue != newValue) {
       this._initUI();
     }
   }
 
   connectedCallback() {
-    this.spellcheck = this.hasAttribute("spellcheck");
     this._initUI();
   }
 
   _initUI() {
+    this.spellcheck = this.hasAttribute("spellcheck");
     if (this.menupopup) {
       this.menupopup.remove();
     }
 
     this.setAttribute("context", "_child");
     this.appendChild(this.spellcheck ? cachedFragments.spellcheck.cloneNode(true) :
                                        cachedFragments.normal.cloneNode(true));
     this.menupopup = this.querySelector(".textbox-contextmenu");
