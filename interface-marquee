# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4f3ed2b21f75b9bad640f60c304dbc350e1097f8

diff --git a/dom/html/HTMLMarqueeElement.cpp b/dom/html/HTMLMarqueeElement.cpp
--- a/dom/html/HTMLMarqueeElement.cpp
+++ b/dom/html/HTMLMarqueeElement.cpp
@@ -45,16 +45,22 @@ static const nsAttrValue::EnumTable* kDe
 
 JSObject*
 HTMLMarqueeElement::WrapNode(JSContext *aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return dom::HTMLMarqueeElement_Binding::Wrap(aCx, this, aGivenProto);
 }
 
 void
+HTMLMarqueeElement::SetStartStopCallback(FunctionStringCallback* aCallback)
+{
+  mStartStopCallback = aCallback;
+}
+
+void
 HTMLMarqueeElement::GetBehavior(nsAString& aValue)
 {
   GetEnumAttr(nsGkAtoms::behavior, kDefaultBehavior->tag, aValue);
 }
 
 void
 HTMLMarqueeElement::GetDirection(nsAString& aValue)
 {
@@ -125,31 +131,23 @@ nsMapRuleToAttributesFunc
 HTMLMarqueeElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
 
 void
 HTMLMarqueeElement::Start()
 {
-  RefPtr<CustomEvent> event = NS_NewDOMCustomEvent(this, nullptr, nullptr);
-  MOZ_ASSERT(event);
-  event->InitCustomEvent(nullptr, NS_LITERAL_STRING("marquee-start"), false, false, JS::NullHandleValue);
-  event->SetTrusted(true);
-
-  ErrorResult err;
-  this->DispatchEvent(*event, err);
+  if (mStartStopCallback) {
+    mStartStopCallback->Call(NS_LITERAL_STRING("start"));
+  }
 }
 
 void
 HTMLMarqueeElement::Stop()
 {
-  RefPtr<CustomEvent> event = NS_NewDOMCustomEvent(this, nullptr, nullptr);
-  MOZ_ASSERT(event);
-  event->InitCustomEvent(nullptr, NS_LITERAL_STRING("marquee-stop"), false, false, JS::NullHandleValue);
-  event->SetTrusted(true);
-
-  ErrorResult err;
-  this->DispatchEvent(*event, err);
+  if (mStartStopCallback) {
+    mStartStopCallback->Call(NS_LITERAL_STRING("stop"));
+  }
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/html/HTMLMarqueeElement.h b/dom/html/HTMLMarqueeElement.h
--- a/dom/html/HTMLMarqueeElement.h
+++ b/dom/html/HTMLMarqueeElement.h
@@ -4,32 +4,37 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef HTMLMarqueeElement_h___
 #define HTMLMarqueeElement_h___
 
 #include "mozilla/Attributes.h"
 #include "nsGenericHTMLElement.h"
 #include "nsContentUtils.h"
+#include "mozilla/dom/DataTransferItemBinding.h"
 
 namespace mozilla {
 namespace dom {
 
+class FunctionStringCallback;
+
 class HTMLMarqueeElement final : public nsGenericHTMLElement
 {
 public:
   explicit HTMLMarqueeElement(already_AddRefed<dom::NodeInfo>&& aNodeInfo)
     : nsGenericHTMLElement(std::move(aNodeInfo))
   {
   }
 
   static const int kDefaultLoop = -1;
   static const int kDefaultScrollAmount = 6;
   static const int kDefaultScrollDelayMS = 85;
 
+  void SetStartStopCallback(FunctionStringCallback* aCallback);
+
   void GetBehavior(nsAString& aValue);
   void SetBehavior(const nsAString& aValue, ErrorResult& aError)
   {
     SetHTMLAttr(nsGkAtoms::behavior, aValue, aError);
   }
 
   void GetDirection(nsAString& aValue);
   void SetDirection(const nsAString& aValue, ErrorResult& aError)
@@ -131,16 +136,17 @@ public:
   nsresult Clone(dom::NodeInfo*, nsINode** aResult) const override;
 
 protected:
   virtual ~HTMLMarqueeElement();
 
   JSObject* WrapNode(JSContext *aCx, JS::Handle<JSObject*> aGivenProto) override;
 
 private:
+  RefPtr<FunctionStringCallback> mStartStopCallback;
   static void MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                                     MappedDeclarations&);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* HTMLMarqueeElement_h___ */
diff --git a/dom/webidl/HTMLMarqueeElement.webidl b/dom/webidl/HTMLMarqueeElement.webidl
--- a/dom/webidl/HTMLMarqueeElement.webidl
+++ b/dom/webidl/HTMLMarqueeElement.webidl
@@ -27,9 +27,13 @@ interface HTMLMarqueeElement : HTMLEleme
   [CEReactions, SetterThrows] attribute DOMString width;
 
   //attribute EventHandler onbounce;
   //attribute EventHandler onfinish;
   //attribute EventHandler onstart;
 
   void start();
   void stop();
-};
\ No newline at end of file
+
+  [Func="IsChromeOrXBL"]
+  void setStartStopCallback(FunctionStringCallback? _callback);
+};
+
diff --git a/layout/style/xbl-marquee/xbl-marquee.xml b/layout/style/xbl-marquee/xbl-marquee.xml
--- a/layout/style/xbl-marquee/xbl-marquee.xml
+++ b/layout/style/xbl-marquee/xbl-marquee.xml
@@ -10,37 +10,16 @@
           xmlns:xbl="http://www.mozilla.org/xbl">
 
 
   <binding id="marquee" bindToUntrustedContent="true">
 
     <resources>
       <stylesheet src="chrome://xbl-marquee/content/xbl-marquee.css"/>
     </resources>
-    <handlers>
-      <handler event="marquee-start" allowuntrusted="false">
-        <![CDATA[
-          if (this.runId == 0) {
-            var lambda = () => this._doMove(false);
-            this.runId = window.setTimeout(lambda, this.scrollDelayWithTruespeed - this._deltaStartStop);
-            this._deltaStartStop = 0;
-          }
-        ]]>
-      </handler>
-      <handler event="marquee-stop" allowuntrusted="false">
-        <![CDATA[
-          if (this.runId != 0) {
-            this._deltaStartStop = Date.now()- this._lastMoveDate;
-            clearTimeout(this.runId);
-          }
-
-          this.runId = 0;
-        ]]>
-      </handler>
-    </handlers>
     <implementation>
       <property name="onstart" exposeToUntrustedContent="true">
         <getter>
           return this.getAttribute("onstart");
         </getter>
         <setter>
           this._setEventListener("start", val, true);
           this.setAttribute("onstart", val);
@@ -81,16 +60,40 @@
           if (this.scrollDelay < 60 && !this.trueSpeed) {
             return 60;
           }
           return this.scrollDelay;
           ]]>
         </getter>
       </property>
 
+      <method name="doStart">
+        <body>
+        <![CDATA[
+          if (this.runId == 0) {
+            var lambda = () => this._doMove(false);
+            this.runId = window.setTimeout(lambda, this.scrollDelayWithTruespeed - this._deltaStartStop);
+            this._deltaStartStop = 0;
+          }
+        ]]>
+        </body>
+      </method>
+      <method name="doStop">
+        <body>
+        <![CDATA[
+          if (this.runId != 0) {
+            this._deltaStartStop = Date.now()- this._lastMoveDate;
+            clearTimeout(this.runId);
+          }
+
+          this.runId = 0;
+        ]]>
+        </body>
+      </method>
+
       <method name="_setEventListener">
         <parameter name="aName"/>
         <parameter name="aValue"/>
         <parameter name="aIgnoreNextCall"/>
         <body>
           <![CDATA[
           // _setEventListener is only used for setting the attribute event
           // handlers, which we want to ignore if our document is sandboxed
@@ -374,16 +377,25 @@
             }
           }
         ]]>
         </body>
       </method>
 
       <constructor>
         <![CDATA[
+          this.setStartStopCallback(val => {
+            if (val == "start") {
+              this.doStart();
+            } else if (val == "stop") {
+              this.doStop();
+            } else {
+              throw new Error(`setStartStopCallback passed an invalid value: ${val}`);
+            }
+          });
           // Set up state.
           this._currentDirection = this.direction || "left";
           this._currentLoop = this.loop;
           this.dirsign = 1;
           this.startAt = 0;
           this.stopAt = 0;
           this.newPosition = 0;
           this.runId = 0;
