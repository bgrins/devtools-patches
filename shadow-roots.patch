# HG changeset patch
# User Gabriel Luong <gabriel.luong@gmail.com>
# Parent  23683baa29108ceaac4767a38ae9f6360afc2c24
Bug 1053898 - Show shadow roots in markup view - WIP!!!

diff --git a/devtools/shared/LayoutHelpers.jsm b/devtools/shared/LayoutHelpers.jsm
--- a/devtools/shared/LayoutHelpers.jsm
+++ b/devtools/shared/LayoutHelpers.jsm
@@ -561,17 +561,35 @@ LayoutHelpers.isXBLAnonymous = function(
 LayoutHelpers.isShadowAnonymous = function(node) {
   let parent = LayoutHelpers.getBindingParent(node);
   if (!parent) {
     return false;
   }
 
   // If there is a shadowRoot and this is part of it then this
   // is not native anonymous
-  return parent.shadowRoot && parent.shadowRoot.contains(node);
+  // XXX: This should loop over olderShadowRoots possibly
+  let root = parent.shadowRoot;
+  let isChild = false;
+
+  while (root) {
+    if (root.contains(node)) {
+      isChild = true;
+      break;
+    }
+    root = root.olderShadowRoot;
+  }
+
+  return isChild;
+};
+
+LayoutHelpers.isShadowRoot = function(node) {
+  let defaultView = (node.ownerDocument && node.ownerDocument.defaultView) || node.defaultView
+  return node.host &&
+         node instanceof defaultView.ShadowRoot;
 };
 
 /**
  * Get the current zoom factor applied to the container window of a given node.
  * Container windows are used as a weakmap key to store the corresponding
  * nsIDOMWindowUtils instance to avoid querying it every time.
  *
  * @param {DOMNode|DOMWindow} The node for which the zoom factor should be
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -3792,94 +3792,237 @@ function isNodeDead(node) {
  * @param {Function} filter A custom filter function Taking in a DOMNode
  *        and returning an Int. See WalkerActor.nodeFilter for an example.
  */
 function DocumentWalker(node, rootWin, whatToShow=Ci.nsIDOMNodeFilter.SHOW_ALL, filter=standardTreeWalkerFilter) {
   if (!rootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
+  this.rootWin = rootWin;
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
   this.walker.init(rootWin.document, whatToShow);
   this.filter = filter;
 
   // Make sure that the walker knows about the initial node (which could
   // be skipped due to a filter).  Note that simply calling parentNode()
   // causes currentNode to be updated.
-  this.walker.currentNode = node;
+
+  // XXX: this shouldnt be called if walker.currentNode setter pukes
+  this.currentNode = node;
   while (node &&
          this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
     node = this.walker.parentNode();
   }
 }
 
 DocumentWalker.prototype = {
   get node() {
     return this.walker.node;
   },
   get whatToShow() {
     return this.walker.whatToShow;
   },
   get currentNode() {
-    return this.walker.currentNode;
+    return this._currentNode;
   },
   set currentNode(aVal) {
-    this.walker.currentNode = aVal;
+    // if (LayoutHelpers.isShadowAnonymous(aVal)) {
+    //   console.log("shadow anon", aVal);
+    // }
+    try {
+      this.walker.currentNode = aVal;
+    } catch(e) {
+      console.log("Puke", e);
+    }
+    this._currentNode = aVal;
   },
 
   parentNode: function() {
-    return this.walker.parentNode();
+    let node = this.currentNode;
+
+    // ShadowHost is the parent of every ShadowRoot
+    if (LayoutHelpers.isShadowRoot(node)) {
+      this.currentNode = node.host;
+      return node.host;
+    }
+
+    let parentNode = this.walker.parentNode();
+    this.currentNode = parentNode;
+    return parentNode;
   },
 
+  createNormalWalker: function(node) {
+    //XXX: try to create a deeptreewalker without showAnonymous as gabor suggestd
+    // this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
+    // this.walker.showSubDocuments = true;
+    // this.walker.showDocumentsAsNodes = true;
+    // this.walker.init(rootWin.document, whatToShow);
+    return node.ownerDocument.createTreeWalker(
+        node, this.whatToShow);
+  },
+
   firstChild: function() {
-    let node = this.walker.currentNode;
+    let node = this.currentNode;
     if (!node)
       return null;
 
+    // Use a normal walker if this is a shadow root
+    if (LayoutHelpers.isShadowRoot(node)) {
+      let walker = this.createNormalWalker(node);
+      let firstChild = walker.firstChild();
+      while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        firstChild = walker.nextSibling();
+      }
+      this.currentNode = firstChild;
+      return firstChild;
+    }
+
+    if (node.shadowRoot) {
+      this.currentNode = node.shadowRoot;
+      return node.shadowRoot;
+    }
+
     let firstChild = this.walker.firstChild();
     while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       firstChild = this.walker.nextSibling();
     }
 
+    this.currentNode = firstChild;
     return firstChild;
   },
 
   lastChild: function() {
-    let node = this.walker.currentNode;
+    let node = this.currentNode;
     if (!node)
       return null;
 
+    // Use a normal walker if this is a shadow root
+    if (LayoutHelpers.isShadowRoot(node)) {
+      let walker = this.createNormalWalker(node);
+      let lastChild = walker.lastChild();
+      while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        lastChild = walker.previousSibling();
+      }
+
+      this.currentNode = lastChild;
+      return lastChild;
+    }
+
     let lastChild = this.walker.lastChild();
     while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       lastChild = this.walker.previousSibling();
     }
 
-    return lastChild;
+    if (lastChild) {
+      this.currentNode = lastChild;
+      return lastChild;
+    }
+
+    let root = node.shadowRoot || null;
+    while (root) {
+      root = root.olderShadowRoot;
+      this.currentNode = root;
+    }
+
+    return root;
   },
 
   previousSibling: function() {
-    let node = this.walker.previousSibling();
-    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
-      node = this.walker.previousSibling();
+    let node = this.currentNode;
+
+    if (LayoutHelpers.isShadowRoot(node)) {
+      let host = node.host;
+      let root = host.shadowRoot;
+      if (root == node) {
+        return null;
+      }
+
+      while (root && root.olderShadowRoot != node) {
+        root = root.olderShadowRoot;
+        this.currentNode = root;
+      }
+
+      return root;
     }
-    return node;
+
+    if (LayoutHelpers.isShadowAnonymous(node)) {
+
+      // Update the state of this.currentNode.
+      // XX: if this traverses to a non shadow element then we need to fall back to normal
+      // traversal.
+      // node = this.parentNode();
+
+      let walker = this.createNormalWalker(node);
+      let previousSibling = walker.previousSibling();
+      while (previousSibling && this.filter(previousSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        previousSibling = walker.previousSibling();
+      }
+      this.currentNode = previousSibling;
+      return previousSibling;
+    }
+
+    let previousSibling = this.walker.previousSibling();
+    while (previousSibling && this.filter(previousSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      previousSibling = this.walker.previousSibling();
+    }
+    this.currentNode = previousSibling;
+    return previousSibling;
   },
 
   nextSibling: function() {
-    let node = this.walker.nextSibling();
-    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
-      node = this.walker.nextSibling();
+    let node = this.currentNode;
+
+    if (LayoutHelpers.isShadowRoot(node) &&
+        node.olderShadowRoot) {
+      this.currentNode = node.olderShadowRoot;
+      return node.olderShadowRoot;
+    } else if (LayoutHelpers.isShadowRoot(node)) {
+      this.currentNode = node.host;
+
+      let firstChild = this.walker.firstChild();
+      while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        firstChild = this.walker.nextSibling();
+      }
+
+      this.currentNode = firstChild;
+      return firstChild;
     }
-    return node;
+
+    if (LayoutHelpers.isShadowAnonymous(node)) {
+
+      // Update the state of this.currentNode.
+      // XX: if this traverses to a non shadow element then we need to fall back to normal
+      // traversal.
+      // node = this.parentNode();
+
+      let walker = this.createNormalWalker(node);
+      let nextSibling = walker.nextSibling();
+      console.log("got next sibling", nextSibling, node);
+      while (nextSibling && this.filter(nextSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        nextSibling = walker.nextSibling();
+      }
+      this.currentNode = nextSibling;
+      return nextSibling;
+    }
+
+    let nextSibling = this.walker.nextSibling();
+    while (nextSibling && this.filter(nextSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      nextSibling = this.walker.nextSibling();
+    }
+    this.currentNode = nextSibling;
+    return nextSibling;
   }
 };
 
+exports.DocumentWalker = DocumentWalker;
+
 function isXULElement(el) {
   return el &&
          el.namespaceURI === XUL_NS;
 }
 
 /**
  * This DeepTreeWalker filter skips whitespace text nodes and anonymous
  * content with the exception of ::before and ::after and anonymous content
