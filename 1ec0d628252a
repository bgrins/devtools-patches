
# HG changeset patch
# User Zibi Braniecki <zbraniecki@mozilla.com>
# Date 1527011454 25200
# Node ID 1ec0d628252a23c4d9a91882ba9d87d1b6bad8bd
# Parent  d36cd8bdbc5c0df1d1d7a167f5fedb95c3a3648e
Bug 1455649 - Implement DocumentLocalization XPIDL API.

MozReview-Commit-ID: A4Mf5nY5MKb
* * *
Bug 1455649 - Implement DocumentL10n WebIDL.


Change the laziness structure of DocumentL10n.

MozReview-Commit-ID: DAfqJfS0s74
* * *
Bug 1411707 - Convert findbar.dtd to findbar.ftl;r=flod

This will be used when we migrate away from XBL and to a Custom Element
in the following changesets.

MozReview-Commit-ID: 7ScSAAwbgVf
* * *
Bug 1411707 - hg copy findbar XBL to findbar.js;

This'll make blame easier to follow when reviewing the next changeset

MozReview-Commit-ID: 5BYvzivlH9I
* * *
Bug 1411707 - Switch XUL findbar from a XBL binding to a Custom Element;

MozReview-Commit-ID: F95i9H9FvYv
* * *
Bug 1411707 - Fold the findbar-textbox XBL binding into findbar;

MozReview-Commit-ID: 9BgKABCy7h3

diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -721,16 +721,18 @@ BrowserGlue.prototype = {
       toolbar_field_text: "rgb(249, 249, 250)",
       author: vendorShortName,
     });
 
     Normandy.init();
 
     // Initialize the default l10n resource sources for L10nRegistry.
     let locales = Services.locale.getPackagedLocales();
+    const greSource = new FileSource("toolkit", locales, "resource://gre/localization/{locale}/");
+    L10nRegistry.registerSource(greSource);
     const appSource = new FileSource("app", locales, "resource://app/localization/{locale}/");
     L10nRegistry.registerSource(appSource);
 
     Services.obs.notifyObservers(null, "browser-ui-startup-complete");
   },
 
   _checkForOldBuildUpdates() {
     // check for update if our build is old
diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -355,16 +355,19 @@
 @RESPATH@/components/TestInterfaceJSMaplike.js
 #endif
 
 #if defined(MOZ_DEBUG) || defined(MOZ_DEV_EDITION) || defined(NIGHTLY_BUILD)
 @RESPATH@/browser/components/testComponents.manifest
 @RESPATH@/browser/components/startupRecorder.js
 #endif
 
+@RESPATH@/components/mozDocumentLocalization.js
+@RESPATH@/components/mozDocumentLocalization.manifest
+
 ; [Extensions]
 @RESPATH@/components/extensions-toolkit.manifest
 @RESPATH@/components/extension-process-script.js
 @RESPATH@/browser/components/extensions-browser.manifest
 
 ; Modules
 @RESPATH@/browser/modules/*
 @RESPATH@/modules/*
diff --git a/browser/themes/osx/browser.css b/browser/themes/osx/browser.css
--- a/browser/themes/osx/browser.css
+++ b/browser/themes/osx/browser.css
@@ -219,20 +219,20 @@
 }
 
 %include ../shared/toolbarbuttons.inc.css
 %include ../shared/toolbarbutton-icons.inc.css
 %include ../shared/menupanel.inc.css
 
 /* Override OSX-specific toolkit findbar button styles */
 .findbar-button {
-  background: none;
-  box-shadow: none;
-  border: none;
-  color: inherit;
+  background: none !important;;
+  box-shadow: none !important;
+  border: none !important;;
+  color: inherit !important;;
 }
 
 /* On Mac, native buttons keep their full opacity when they become disabled
  * and only the glyph or text on top of them becomes less opaque. */
 :root:not([customizing]) #back-button[disabled="true"] {
   opacity: 1 !important;
   /* Disabled toolbar buttons get an opacity of 0.4 which multiplies
    * their fill-opacity of 0.7. calc() doesn't work here - we'd need
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -204,16 +204,17 @@
 #include "nsWrapperCacheInlines.h"
 #include "nsSandboxFlags.h"
 #include "mozilla/dom/AnimatableBinding.h"
 #include "mozilla/dom/AnonymousContent.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/DocumentFragment.h"
+#include "mozilla/dom/DocumentL10n.h"
 #include "mozilla/dom/DocumentTimeline.h"
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/HTMLBodyElement.h"
 #include "mozilla/dom/HTMLInputElement.h"
 #include "mozilla/dom/ImageTracker.h"
 #include "mozilla/dom/MediaQueryList.h"
 #include "mozilla/dom/NodeFilterBinding.h"
 #include "mozilla/OwningNonNull.h"
@@ -1369,16 +1370,19 @@ nsIDocument::nsIDocument()
     mCharacterSet(WINDOWS_1252_ENCODING),
     mCharacterSetSource(0),
     mParentDocument(nullptr),
     mCachedRootElement(nullptr),
     mNodeInfoManager(nullptr),
 #ifdef DEBUG
     mStyledLinksCleared(false),
 #endif
+    mDocumentL10n(nullptr),
+    mL10nResourceContainerParsed(false),
+    mDOMParsed(false),
     mBidiEnabled(false),
     mMathMLEnabled(false),
     mIsInitialDocumentInWindow(false),
     mIgnoreDocGroupMismatches(false),
     mLoadedAsData(false),
     mLoadedAsInteractiveData(false),
     mMayStartLayout(true),
     mHaveFiredTitleChange(false),
@@ -1857,16 +1861,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   }
 
   // Traverse all nsIDocument pointer members.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSecurityInfo)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDisplayDocument)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFontFaceSet)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mReadyForIdle)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mAboutCapabilities)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDocumentL10n)
 
   // Traverse all nsDocument nsCOMPtrs.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mParser)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptGlobalObject)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mListenerManager)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDOMStyleSheets)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mStyleSheetSetList)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptLoader)
@@ -2012,16 +2017,17 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mForms);
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mScripts);
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mApplets);
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mAnchors);
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mOrientationPendingPromise)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mFontFaceSet)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mReadyForIdle);
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mAboutCapabilities)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDocumentL10n)
 
   tmp->mParentDocument = nullptr;
 
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPreloadingImages)
 
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIntersectionObservers)
 
   tmp->ClearAllBoxObjects();
@@ -2210,16 +2216,44 @@ nsIDocument::Reset(nsIChannel* aChannel,
       mDocumentBaseURI = baseURI;
       mChromeXHRDocBaseURI = nullptr;
     }
   }
 
   mChannel = aChannel;
 }
 
+bool
+PrincipalAllowsL10n(nsIPrincipal* principal) {
+  // Fast track privileged contexts
+  if (nsContentUtils::IsSystemPrincipal(principal)) {
+    return true;
+  }
+
+  nsCOMPtr<nsIURI> uri;
+  nsresult rv = principal->GetURI(getter_AddRefs(uri));
+  if (NS_FAILED(rv) || !uri) {
+    return false;
+  }
+
+  bool isAbout;
+  rv = uri->SchemeIs("about", &isAbout);
+  if (NS_FAILED(rv) || (!isAbout)) {
+    return false;
+  }
+
+  bool isNonWeb;
+  rv = NS_URIChainHasFlags(uri, nsIProtocolHandler::URI_DANGEROUS_TO_LOAD, &isNonWeb);
+  if (NS_FAILED(rv) || !isNonWeb) {
+    return false;
+  }
+
+  return true;
+}
+
 void
 nsIDocument::ResetToURI(nsIURI* aURI,
                         nsILoadGroup* aLoadGroup,
                         nsIPrincipal* aPrincipal)
 {
   MOZ_ASSERT(aURI, "Null URI passed to ResetToURI");
 
   MOZ_LOG(gDocumentLeakPRLog, LogLevel::Debug,
@@ -3350,16 +3384,121 @@ nsIDocument::GetAboutCapabilities(ErrorR
     mAboutCapabilities = new AboutCapabilities(jsImplObj, sgo);
   }
   RefPtr<AboutCapabilities> aboutCapabilities =
     static_cast<AboutCapabilities*>(mAboutCapabilities.get());
   return aboutCapabilities.forget();
 }
 
 bool
+nsDocument::DocumentSupportsL10n(JSContext* aCx, JSObject* aObject)
+{
+  return PrincipalAllowsL10n(nsContentUtils::SubjectPrincipal(aCx));
+}
+
+void
+nsIDocument::LocalizationLinkAdded(Element* aLinkElement)
+{
+  auto l10n = GetLocalization(true);
+  if (!l10n) {
+    return;
+  }
+
+  Element* parent = aLinkElement->GetParentElement();
+  if (!parent) {
+    return;
+  }
+
+  Element* head = GetHeadElement();
+  if (parent != head && !parent->NodeInfo()->Equals(nsGkAtoms::linkset, kNameSpaceID_XUL)) {
+    // TODO log a warning
+    return;
+  }
+
+  nsString href;
+  aLinkElement->GetAttr(kNameSpaceID_None, nsGkAtoms::href, href);
+  (*l10n)->AddResourceId(href);
+}
+
+void
+nsIDocument::LocalizationLinkRemoved(Element* aLinkElement)
+{
+  auto l10n = GetLocalization(true);
+  if (!l10n) {
+    return;
+  }
+
+  Element* parent = aLinkElement->GetParentElement();
+  if (!parent) {
+    return;
+  }
+
+  Element* head = GetHeadElement();
+  if (parent != head && !parent->NodeInfo()->Equals(nsGkAtoms::linkset, kNameSpaceID_XUL)) {
+    // TODO log a warning
+    return;
+  }
+
+  nsString href;
+  aLinkElement->GetAttr(kNameSpaceID_None, nsGkAtoms::href, href);
+  (*l10n)->RemoveResourceId(href);
+}
+
+mozilla::Maybe<RefPtr<DocumentL10n>>
+nsIDocument::GetLocalization(bool initialize)
+{
+  if (mDocumentL10n) {
+    return Some(mDocumentL10n);
+  } else if (initialize && PrincipalAllowsL10n(NodePrincipal())) {
+    mDocumentL10n = new DocumentL10n(this, mL10nResourceContainerParsed, mDOMParsed);
+    return Some(mDocumentL10n);
+  }
+  return Nothing();
+}
+
+void
+nsIDocument::OnL10nResourceContainerParsed()
+{
+  if (mL10nResourceContainerParsed) {
+    return;
+  }
+  auto l10n = GetLocalization(false);
+  if (l10n) {
+    (*l10n)->LoadLocalizations();
+  }
+  mL10nResourceContainerParsed = true;
+}
+
+void
+nsIDocument::OnDOMParsed()
+{
+  if (mDOMParsed) {
+    return;
+  }
+  auto l10n = GetLocalization(false);
+  if (l10n) {
+    (*l10n)->LocalizeDocument();
+  }
+  mDOMParsed = true;
+}
+
+already_AddRefed<DocumentL10n>
+nsIDocument::GetL10n(ErrorResult& aRv)
+{
+  auto l10nOrig = GetLocalization(true);
+  if (l10nOrig.isNothing()) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  RefPtr<DocumentL10n> l10n(l10nOrig.value());
+  return l10n.forget();
+}
+
+bool
 nsDocument::IsElementAnimateEnabled(JSContext* aCx, JSObject* /*unused*/)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   return nsContentUtils::IsSystemCaller(aCx) ||
          nsContentUtils::AnimationsAPICoreEnabled() ||
          nsContentUtils::AnimationsAPIElementAnimateEnabled();
 }
@@ -5103,16 +5242,19 @@ nsIDocument::DispatchContentLoadedEvents
 
   // Unpin references to preloaded images
   mPreloadingImages.Clear();
 
   // DOM manipulation after content loaded should not care if the element
   // came from the preloader.
   mPreloadedPreconnects.Clear();
 
+  // DOM has been parsed by now, we can start localization
+  OnDOMParsed();
+
   if (mTiming) {
     mTiming->NotifyDOMContentLoadedStart(nsIDocument::GetDocumentURI());
   }
 
   // Dispatch observer notification to notify observers document is interactive.
   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
   if (os) {
     nsIPrincipal* principal = NodePrincipal();
diff --git a/dom/base/nsDocument.h b/dom/base/nsDocument.h
--- a/dom/base/nsDocument.h
+++ b/dom/base/nsDocument.h
@@ -156,16 +156,17 @@ public:
                                      nsISupports* aContainer,
                                      nsIStreamListener **aDocListener,
                                      bool aReset = true,
                                      nsIContentSink* aContentSink = nullptr) override = 0;
 
   virtual void StopDocumentLoad() override;
 
   static bool CallerIsTrustedAboutPage(JSContext* aCx, JSObject* aObject);
+  static bool DocumentSupportsL10n(JSContext* aCx, JSObject* aObject);
   static bool IsElementAnimateEnabled(JSContext* aCx, JSObject* aObject);
   static bool IsWebAnimationsEnabled(JSContext* aCx, JSObject* aObject);
   static bool IsWebAnimationsEnabled(mozilla::dom::CallerType aCallerType);
 
   virtual void EndUpdate() override;
   virtual void BeginLoad() override;
   virtual void EndLoad() override;
 
diff --git a/dom/base/nsIDocument.h b/dom/base/nsIDocument.h
--- a/dom/base/nsIDocument.h
+++ b/dom/base/nsIDocument.h
@@ -143,16 +143,17 @@ class Attr;
 class BoxObject;
 class ClientInfo;
 class ClientState;
 class CDATASection;
 class Comment;
 struct CustomElementDefinition;
 class DocGroup;
 class DocumentFragment;
+class DocumentL10n;
 class DocumentTimeline;
 class DocumentType;
 class DOMImplementation;
 class DOMIntersectionObserver;
 class DOMStringList;
 class Element;
 struct ElementCreationOptions;
 class Event;
@@ -3134,16 +3135,22 @@ public:
   void GetInputEncoding(nsAString& aInputEncoding) const;
   already_AddRefed<mozilla::dom::Location> GetLocation() const;
   void GetReferrer(nsAString& aReferrer) const;
   void GetLastModified(nsAString& aLastModified) const;
   void GetReadyState(nsAString& aReadyState) const;
 
   already_AddRefed<mozilla::dom::AboutCapabilities> GetAboutCapabilities(
     ErrorResult& aRv);
+  void LocalizationLinkAdded(Element* aLinkElement);
+  void LocalizationLinkRemoved(Element* aLinkElement);
+  mozilla::Maybe<RefPtr<mozilla::dom::DocumentL10n>> GetLocalization(bool initialize);
+  void OnL10nResourceContainerParsed();
+  void OnDOMParsed();
+  already_AddRefed<mozilla::dom::DocumentL10n> GetL10n(ErrorResult& aRv);
 
   void GetTitle(nsAString& aTitle);
   void SetTitle(const nsAString& aTitle, mozilla::ErrorResult& rv);
   void GetDir(nsAString& aDirection) const;
   void SetDir(const nsAString& aDirection);
   nsIHTMLCollection* Images();
   nsIHTMLCollection* Embeds();
   nsIHTMLCollection* Plugins()
@@ -3808,16 +3815,19 @@ protected:
   // focus has never occurred then mLastFocusTime.IsNull() will be true.
   mozilla::TimeStamp mLastFocusTime;
 
   mozilla::EventStates mDocumentState;
 
   RefPtr<mozilla::dom::Promise> mReadyForIdle;
 
   RefPtr<mozilla::dom::AboutCapabilities> mAboutCapabilities;
+  RefPtr<mozilla::dom::DocumentL10n> mDocumentL10n;
+  bool mL10nResourceContainerParsed : 1;
+  bool mDOMParsed : 1;
 
   // True if BIDI is enabled.
   bool mBidiEnabled : 1;
   // True if a MathML element has ever been owned by this document.
   bool mMathMLEnabled : 1;
 
   // True if this document is the initial document for a window.  This should
   // basically be true only for documents that exist in newly-opened windows or
diff --git a/dom/html/HTMLBodyElement.cpp b/dom/html/HTMLBodyElement.cpp
--- a/dom/html/HTMLBodyElement.cpp
+++ b/dom/html/HTMLBodyElement.cpp
@@ -294,16 +294,21 @@ nsresult
 HTMLBodyElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                             nsIContent* aBindingParent,
                             bool aCompileEventHandlers)
 {
   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
                                                  aBindingParent,
                                                  aCompileEventHandlers);
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // We now have a body, if l10n resources were to be loaded, it would happen
+  // already.
+  OwnerDoc()->OnL10nResourceContainerParsed();
+
   return mAttrsAndChildren.ForceMapped(this, OwnerDoc());
 }
 
 nsresult
 HTMLBodyElement::AfterSetAttr(int32_t aNameSpaceID, nsAtom* aName,
                               const nsAttrValue* aValue,
                               const nsAttrValue* aOldValue,
                               nsIPrincipal* aSubjectPrincipal,
diff --git a/dom/html/HTMLLinkElement.cpp b/dom/html/HTMLLinkElement.cpp
--- a/dom/html/HTMLLinkElement.cpp
+++ b/dom/html/HTMLLinkElement.cpp
@@ -144,16 +144,23 @@ HTMLLinkElement::BindToTree(nsIDocument*
   if (IsInComposedDoc()) {
     TryDNSPrefetchOrPreconnectOrPrefetchOrPreloadOrPrerender();
   }
 
   void (HTMLLinkElement::*update)() = &HTMLLinkElement::UpdateStyleSheetInternal;
   nsContentUtils::AddScriptRunner(
     NewRunnableMethod("dom::HTMLLinkElement::BindToTree", this, update));
 
+  if (aDocument) {
+    nsAutoString rel;
+    GetAttr(kNameSpaceID_None, nsGkAtoms::rel, rel);
+    if (rel.EqualsLiteral("localization"))
+      aDocument->LocalizationLinkAdded(this);
+  }
+
   CreateAndDispatchEvent(aDocument, NS_LITERAL_STRING("DOMLinkAdded"));
 
   return rv;
 }
 
 void
 HTMLLinkElement::LinkAdded()
 {
@@ -184,16 +191,23 @@ HTMLLinkElement::UnbindFromTree(bool aDe
   // from the parser.
   nsCOMPtr<nsIDocument> oldDoc = GetUncomposedDoc();
 
   // Check for a ShadowRoot because link elements are inert in a
   // ShadowRoot.
   ShadowRoot* oldShadowRoot = GetBindingParent() ?
     GetBindingParent()->GetShadowRoot() : nullptr;
 
+  if (oldDoc) {
+    nsAutoString rel;
+    GetAttr(kNameSpaceID_None, nsGkAtoms::rel, rel);
+    if (rel.EqualsLiteral("localization"))
+      oldDoc->LocalizationLinkRemoved(this);
+  }
+
   CreateAndDispatchEvent(oldDoc, NS_LITERAL_STRING("DOMLinkRemoved"));
   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
 
   Unused << UpdateStyleSheetInternal(oldDoc, oldShadowRoot);
 }
 
 bool
 HTMLLinkElement::ParseAttribute(int32_t aNamespaceID,
diff --git a/dom/webidl/Document.webidl b/dom/webidl/Document.webidl
--- a/dom/webidl/Document.webidl
+++ b/dom/webidl/Document.webidl
@@ -497,16 +497,20 @@ partial interface Document {
   readonly attribute FlashClassification documentFlashClassification;
 };
 
 // Allows about: pages to query aboutCapabilities
 partial interface Document {
   [Throws, Func="nsDocument::CallerIsTrustedAboutPage"] readonly attribute AboutCapabilities aboutCapabilities;
 };
 
+partial interface Document {
+  [Throws, Func="nsDocument::DocumentSupportsL10n"] readonly attribute DocumentL10n l10n;
+};
+
 Document implements XPathEvaluator;
 Document implements GlobalEventHandlers;
 Document implements DocumentAndElementEventHandlers;
 Document implements TouchEventHandlers;
 Document implements ParentNode;
 Document implements OnErrorEventHandlerForNodes;
 Document implements GeometryUtils;
 Document implements FontFaceSource;
diff --git a/dom/webidl/DocumentL10n.webidl b/dom/webidl/DocumentL10n.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/DocumentL10n.webidl
@@ -0,0 +1,22 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+dictionary L10nKey {
+  required DOMString id;
+
+  object? args = null;
+};
+
+[NoInterfaceObject]
+interface DocumentL10n {
+  [Throws] void setAttributes(Element aElement, DOMString aId, optional object aArgs);
+
+  [Throws] Promise<DOMString> formatValue(DOMString aId, optional object aArgs);
+
+  [Throws] Promise<sequence<DOMString>> formatValues(sequence<L10nKey> aKeys);
+
+  [Throws] readonly attribute Promise<any> ready;
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -455,16 +455,17 @@ WEBIDL_FILES = [
     'DataTransferItemList.webidl',
     'DecoderDoctorNotification.webidl',
     'DedicatedWorkerGlobalScope.webidl',
     'DelayNode.webidl',
     'DeviceMotionEvent.webidl',
     'Directory.webidl',
     'Document.webidl',
     'DocumentFragment.webidl',
+    'DocumentL10n.webidl',
     'DocumentOrShadowRoot.webidl',
     'DocumentTimeline.webidl',
     'DocumentType.webidl',
     'DOMError.webidl',
     'DOMException.webidl',
     'DOMImplementation.webidl',
     'DOMMatrix.webidl',
     'DOMParser.webidl',
diff --git a/dom/xul/XULDocument.cpp b/dom/xul/XULDocument.cpp
--- a/dom/xul/XULDocument.cpp
+++ b/dom/xul/XULDocument.cpp
@@ -74,16 +74,17 @@
 #include "nsIObserverService.h"
 #include "nsNodeUtils.h"
 #include "nsIDocShellTreeOwner.h"
 #include "nsIXULWindow.h"
 #include "nsXULPopupManager.h"
 #include "nsCCUncollectableMarker.h"
 #include "nsURILoader.h"
 #include "mozilla/BasicEvents.h"
+#include "mozilla/dom/DocumentL10n.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/NodeInfoInlines.h"
 #include "mozilla/dom/ProcessingInstruction.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/XULDocumentBinding.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Preferences.h"
@@ -1405,16 +1406,19 @@ XULDocument::AddElementToDocumentPost(El
     if (aElement == GetRootElement()) {
         ResetDocumentDirection();
     }
 
     // We need to pay special attention to the keyset tag to set up a listener
     if (aElement->NodeInfo()->Equals(nsGkAtoms::keyset, kNameSpaceID_XUL)) {
         // Create our XUL key listener and hook it up.
         nsXBLService::AttachGlobalKeyHandler(aElement);
+    } else if (aElement->NodeInfo()->Equals(nsGkAtoms::linkset, kNameSpaceID_XUL)) {
+        // If l10n resources were to be loaded, it would happen already.
+        OnL10nResourceContainerParsed();
     }
 
     return NS_OK;
 }
 
 nsresult
 XULDocument::AddSubtreeToDocument(nsIContent* aContent)
 {
@@ -2707,16 +2711,22 @@ XULDocument::DoneWalking()
         // the |if (!mDocumentLoaded)| check above and since
         // mInitialLayoutComplete will be false will follow the else branch
         // there too.  See the big comment there for how such reentry can
         // happen.
         mDocumentLoaded = true;
 
         NotifyPossibleTitleChange(false);
 
+
+        // We parsed the whole document.
+        // If l10n resources were to be loaded, it would happen already.
+        OnL10nResourceContainerParsed();
+        OnDOMParsed();
+
         nsContentUtils::DispatchTrustedEvent(
             this,
             static_cast<nsIDocument*>(this),
             NS_LITERAL_STRING("MozBeforeInitialXULLayout"),
             true,
             false);
 
         // Before starting layout, check whether we're a toplevel chrome
diff --git a/intl/l10n/DOMLocalization.jsm b/intl/l10n/DOMLocalization.jsm
--- a/intl/l10n/DOMLocalization.jsm
+++ b/intl/l10n/DOMLocalization.jsm
@@ -545,16 +545,21 @@ class DOMLocalization extends Localizati
   }
 
   /**
    * Translate all roots associated with this `DOMLocalization`.
    *
    * @returns {Promise}
    */
   translateRoots() {
+    // Bail out early if there are no registered translations.
+    if (this.resourceIds.length == 0) {
+      return Promise.resolve();
+    }
+
     const roots = Array.from(this.roots);
     return Promise.all(
       roots.map(root => this.translateFragment(root))
     );
   }
 
   /**
    * Pauses the `MutationObserver`.
diff --git a/intl/l10n/DocumentL10n.cpp b/intl/l10n/DocumentL10n.cpp
new file mode 100644
--- /dev/null
+++ b/intl/l10n/DocumentL10n.cpp
@@ -0,0 +1,206 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/DocumentL10n.h"
+#include "mozilla/dom/DocumentL10nBinding.h"
+#include "nsQueryObject.h"
+#include "mozilla/dom/Promise.h"
+#include "nsISupports.h"
+#include "nsContentUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(DocumentL10n, mDocument, mDocumentLocalization)
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(DocumentL10n)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(DocumentL10n)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(DocumentL10n)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+DocumentL10n::DocumentL10n(nsIDocument* aDocument, bool aL10nResourceContainerParsed, bool aDOMParsed)
+  : mDocument(aDocument)
+  , mDocumentLocalization(nullptr)
+  , mL10nResourceContainerParsed(aL10nResourceContainerParsed)
+  , mDOMParsed(aDOMParsed)
+{
+  printf("DocumentL10n::DocumentL10n\n");
+  if (aL10nResourceContainerParsed) {
+    printf("DocumentL10n::DocumentL10n L10nResourceContainerParsed\n");
+  }
+  if (aDOMParsed) {
+    printf("DocumentL10n::DocumentL10n DOMParsed\n");
+  }
+  nsresult rv;
+  nsCOMPtr<mozIDocumentLocalization> docL10n = do_CreateInstance("@mozilla.org/intl/documentlocalization;1", &rv);
+  if (NS_FAILED(rv)) {
+    return;
+  }
+
+  mDocumentLocalization = docL10n;
+  mDocumentLocalization->Init(mDocument, mL10nResourceContainerParsed, mDOMParsed);
+}
+
+DocumentL10n::~DocumentL10n()
+{
+  mDocumentLocalization = nullptr;
+}
+
+void
+DocumentL10n::LocalizeDocument()
+{
+  printf("DocumentL10n::LocalizeDocument\n");
+  if (!mDOMParsed) {
+    if (nsContentUtils::IsSafeToRunScript()) {
+      mDocumentLocalization->LocalizeDocument();
+    } else {
+      nsContentUtils::AddScriptRunner(
+          NewRunnableMethod("mozIDocumentLocalization::LocalizeDocument",
+            mDocumentLocalization,
+            &mozIDocumentLocalization::LocalizeDocument));
+    }
+    mDOMParsed = true;
+  }
+}
+
+void
+DocumentL10n::LoadLocalizations()
+{
+  printf("DocumentL10n::LoadLocalizations\n");
+  if (!mL10nResourceContainerParsed) {
+    if (nsContentUtils::IsSafeToRunScript()) {
+      mDocumentLocalization->LoadLocalizations();
+    } else {
+      nsContentUtils::AddScriptRunner(
+          NewRunnableMethod("mozIDocumentLocalization::LoadLocalizations",
+            mDocumentLocalization,
+            &mozIDocumentLocalization::LoadLocalizations));
+    }
+    mL10nResourceContainerParsed = true;
+  }
+}
+
+JSObject*
+DocumentL10n::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  return DocumentL10nBinding::Wrap(aCx, this, aGivenProto);
+}
+
+void
+DocumentL10n::AddResourceId(const nsAString& aResourceId)
+{
+  printf("DocumentL10n::AddResourceId\n");
+  /* if (nsContentUtils::IsSafeToRunScript()) { */
+    printf("DocumentL10n::AddResourceId IsSafeToRunScript\n");
+    mDocumentLocalization->AddResourceId(aResourceId);
+  /* } else { */
+  /*   printf("DocumentL10n::AddResourceId IsNotSafeToRunScript\n"); */
+  /*   nsContentUtils::AddScriptRunner( */
+  /*       NewRunnableMethod<const nsAString&>("mozIDocumentLocalization::AddResourceId", */
+  /*         mDocumentLocalization, */
+  /*         &mozIDocumentLocalization::AddResourceId, */
+  /*         aResourceId)); */
+  /* } */
+}
+
+void
+DocumentL10n::RemoveResourceId(const nsAString& aResourceId)
+{
+  /* if (nsContentUtils::IsSafeToRunScript()) { */
+    mDocumentLocalization->RemoveResourceId(aResourceId);
+  /* } else { */
+  /*   nsContentUtils::AddScriptRunner( */
+  /*       NewRunnableMethod<const nsAString&>("mozIDocumentLocalization::RemoveResourceId", */
+  /*         mDocumentLocalization, */
+  /*         &mozIDocumentLocalization::RemoveResourceId, */
+  /*         aResourceId)); */
+  /* } */
+}
+
+void
+DocumentL10n::SetAttributes(JSContext* cx, Element& aElement, const nsAString& aId, const Optional<JS::Handle<JSObject*>>& aArgs, ErrorResult& aRv)
+{
+  JS::RootedValue args(cx);
+
+  if (aArgs.WasPassed()) {
+    args = JS::ObjectValue(*aArgs.Value());
+  } else {
+    args = JS::UndefinedValue();
+  }
+
+  nsresult rv = mDocumentLocalization->SetAttributes(&aElement, aId, args);
+
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+  }
+}
+
+already_AddRefed<Promise>
+DocumentL10n::FormatValue(JSContext* cx, const nsAString& aId, const Optional<JS::Handle<JSObject*>>& aArgs, ErrorResult& aRv)
+{
+  JS::RootedValue args(cx);
+
+  if (aArgs.WasPassed()) {
+    args = JS::ObjectValue(*aArgs.Value());
+  } else {
+    args = JS::UndefinedValue();
+  }
+
+  RefPtr<Promise> promise;
+  nsresult rv = mDocumentLocalization->FormatValue(aId, args, getter_AddRefs(promise));
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+DocumentL10n::FormatValues(JSContext* cx, const Sequence<L10nKey>& aKeys, ErrorResult& aRv)
+{
+  nsTArray<JS::HandleValue> jsKeys;
+  jsKeys.SetCapacity(aKeys.Length());
+
+  for (auto& key : aKeys) {
+    JS::RootedValue jsKey(cx);
+    if (!ToJSValue(cx, key, &jsKey)) {
+      aRv.Throw(NS_ERROR_UNEXPECTED);
+      return nullptr;
+    }
+
+    jsKeys.AppendElement(jsKey);
+  }
+
+  RefPtr<Promise> promise;
+  nsresult rv = mDocumentLocalization->FormatValues(jsKeys.Elements(), jsKeys.Length(), getter_AddRefs(promise));
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+DocumentL10n::GetReady(ErrorResult& aRv)
+{
+  RefPtr<Promise> promise;
+
+  nsresult rv = mDocumentLocalization->GetReady(getter_AddRefs(promise));
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  return promise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/intl/l10n/DocumentL10n.h b/intl/l10n/DocumentL10n.h
new file mode 100644
--- /dev/null
+++ b/intl/l10n/DocumentL10n.h
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_DocumentL10n_h
+#define mozilla_dom_DocumentL10n_h
+
+#include "js/TypeDecls.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/ErrorResult.h"
+#include "mozilla/dom/BindingDeclarations.h"
+#include "nsCycleCollectionParticipant.h"
+#include "nsWrapperCache.h"
+#include "nsIDocument.h"
+#include "mozIDocumentLocalization.h"
+
+namespace mozilla {
+namespace dom {
+
+class Element;
+class Promise;
+struct L10nKey;
+
+class DocumentL10n final : public nsISupports,
+                           public nsWrapperCache
+{
+public:
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(DocumentL10n)
+
+public:
+  explicit DocumentL10n(nsIDocument* aDocument, bool aL10nResourceContainerParsed, bool aDOMParsed);
+
+protected:
+  virtual ~DocumentL10n();
+
+  nsCOMPtr<nsIDocument> mDocument;
+  nsCOMPtr<mozIDocumentLocalization> mDocumentLocalization;
+  bool mL10nResourceContainerParsed;
+  bool mDOMParsed;
+
+public:
+  void LocalizeDocument();
+  void LoadLocalizations();
+
+  nsIDocument* GetParentObject() const { return mDocument; };
+
+  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  void AddResourceId(const nsAString& aResourceId);
+
+  void RemoveResourceId(const nsAString& aResourceId);
+
+  void SetAttributes(JSContext* cx, Element& aElement, const nsAString& aId, const Optional<JS::Handle<JSObject*>>& aArgs, ErrorResult& aRv);
+
+  already_AddRefed<Promise> FormatValue(JSContext* cx, const nsAString& aId, const Optional<JS::Handle<JSObject*>>& aArgs, ErrorResult& aRv);
+
+  already_AddRefed<Promise> FormatValues(JSContext* cx, const Sequence<L10nKey>& aKeys, ErrorResult& aRv);
+  already_AddRefed<Promise> GetReady(ErrorResult& aRv);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_DocumentL10n_h
diff --git a/intl/l10n/moz.build b/intl/l10n/moz.build
--- a/intl/l10n/moz.build
+++ b/intl/l10n/moz.build
@@ -6,16 +6,39 @@
 
 EXTRA_JS_MODULES += [
     'DOMLocalization.jsm',
     'L10nRegistry.jsm',
     'Localization.jsm',
     'MessageContext.jsm',
 ]
 
+XPIDL_SOURCES += [
+    'mozIDocumentLocalization.idl',
+]
+
+XPIDL_MODULE = 'locale'
+
+EXTRA_COMPONENTS += [
+    'mozDocumentLocalization.js',
+    'mozDocumentLocalization.manifest',
+]
+
+EXPORTS.mozilla.dom += [
+    'DocumentL10n.h',
+]
+
+UNIFIED_SOURCES += [
+    'DocumentL10n.cpp',
+]
+
+LOCAL_INCLUDES += [
+    '/dom/base',
+]
+
 XPCSHELL_TESTS_MANIFESTS += ['test/xpcshell.ini']
 
 MOCHITEST_CHROME_MANIFESTS += ['test/chrome.ini']
 
 JAR_MANIFESTS += ['jar.mn']
 
 SPHINX_TREES['l10n'] = 'docs'
 
diff --git a/intl/l10n/mozDocumentLocalization.js b/intl/l10n/mozDocumentLocalization.js
new file mode 100644
--- /dev/null
+++ b/intl/l10n/mozDocumentLocalization.js
@@ -0,0 +1,101 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const { XPCOMUtils } = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm", {});
+const { DOMLocalization } = ChromeUtils.import("resource://gre/modules/DOMLocalization.jsm", {});
+const { PromiseUtils } = ChromeUtils.import("resource://gre/modules/PromiseUtils.jsm", {});
+
+class mozDocumentLocalization {
+  constructor() {
+    this.resourceIds = [];
+
+    const deferredL10nContainerParsed = PromiseUtils.defer();
+    const deferredDOMParsed = PromiseUtils.defer();
+
+    this.localization = deferredL10nContainerParsed.promise.then(() => {
+      const l10n = new DOMLocalization(this.document.defaultView, this.resourceIds);
+      l10n.ctxs.touchNext(2);
+      this.resolveLocalization = null;
+      return l10n;
+    });
+
+    this.resolveLocalization = deferredL10nContainerParsed.resolve;
+
+    this.ready = deferredDOMParsed.promise;
+    this.resolveReady = deferredDOMParsed.resolve;
+  }
+
+  getReady() {
+    return this.ready;
+  }
+
+  init(document, isL10nContainerParsed, isDOMParsed) {
+    console.log('mozDocumentLocalization::init');
+    this.document = document;
+    if (isL10nContainerParsed) {
+      console.log('mozDocumentLocalization::init l10nContainerParsed');
+      this.resolveLocalization();
+    }
+    if (isDOMParsed) {
+      console.log('mozDocumentLocalization::init DOMParsed');
+      this.resolveReady();
+    }
+  }
+
+  async localizeDocument() {
+    console.log('mozDocumentLocalization::onDOMReady');
+    const l10n = await this.localization;
+    l10n.registerObservers();
+    l10n.connectRoot(this.document.documentElement);
+    await l10n.translateRoots();
+    this.resolveReady();
+  }
+
+  loadLocalizations() {
+    console.log('mozDocumentLocalization::loadLocalizations');
+    this.resolveLocalization();
+  }
+
+  async addResourceId(resourceId) {
+    console.log(`mozDocumentLocalization::addResourceId for "${resourceId}"`)
+    if (this.resolveLocalization) {
+      this.resourceIds.push(resourceId);
+    } else {
+      const l10n = await this.localization;
+      l10n.addResourceIds([resourceId]);
+    }
+  }
+
+  async removeResourceId(resourceId) {
+    const l10n = await this.localization;
+    l10n.removeResourceIds([resourceId]);
+  }
+
+  setAttributes(element, id, args) {
+    element.setAttribute("data-l10n-id", id);
+    if (args) {
+      element.setAttribute("data-l10n-args", JSON.stringify(args));
+    } else {
+      element.removeAttribute("data-l10n-args");
+    }
+    return element;
+  }
+
+  async formatValues(keys, length) {
+    let l10n = await this.localization;
+    return l10n.formatValues(keys);
+  }
+
+  async formatValue(id, args) {
+    let l10n = await this.localization;
+    return l10n.formatValue(id, args);
+  }
+}
+
+mozDocumentLocalization.prototype.classID =
+  Components.ID("{29cc3895-8835-4c5b-b53a-0c0d1a458dee}");
+mozDocumentLocalization.prototype.QueryInterface =
+  ChromeUtils.generateQI([Ci.mozIDocumentLocalization]);
+
+this.NSGetFactory = XPCOMUtils.generateNSGetFactory([mozDocumentLocalization]);
diff --git a/intl/l10n/mozDocumentLocalization.manifest b/intl/l10n/mozDocumentLocalization.manifest
new file mode 100644
--- /dev/null
+++ b/intl/l10n/mozDocumentLocalization.manifest
@@ -0,0 +1,2 @@
+component {29cc3895-8835-4c5b-b53a-0c0d1a458dee} mozDocumentLocalization.js
+contract @mozilla.org/intl/documentlocalization;1 {29cc3895-8835-4c5b-b53a-0c0d1a458dee}
diff --git a/intl/l10n/mozIDocumentLocalization.idl b/intl/l10n/mozIDocumentLocalization.idl
new file mode 100644
--- /dev/null
+++ b/intl/l10n/mozIDocumentLocalization.idl
@@ -0,0 +1,32 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+webidl Document;
+webidl Element;
+
+[scriptable, uuid(7c468500-541f-4fe0-98c9-92a53b63ec8d)]
+interface mozIDocumentLocalization : nsISupports
+{
+  void init(in Document document, in boolean isL10nContainerParsed, in boolean isDOMParsed);
+  void localizeDocument();
+  void loadLocalizations();
+
+  void setAttributes(in Element aElement, in DOMString aId, [optional] in jsval aArgs);
+  jsval getAttributes(in Element aElement);
+
+  Promise translateFragment(in Element aElement);
+  Promise translateElements([array, size_is(aLength)] in Element aElements, in unsigned long aLength);
+
+  void addResourceId(in DOMString aResource);
+  void removeResourceId(in DOMString aResource);
+
+  Promise formatMessages([array, size_is(aLength)] in jsval aKeys, in unsigned long aLength);
+  Promise formatValues([array, size_is(aLength)] in jsval aKeys, in unsigned long aLength);
+  Promise formatValue(in DOMString aId, [optional] in jsval aArgs);
+
+  Promise getReady();
+};
diff --git a/intl/l10n/test/chrome.ini b/intl/l10n/test/chrome.ini
--- a/intl/l10n/test/chrome.ini
+++ b/intl/l10n/test/chrome.ini
@@ -9,8 +9,17 @@
 [dom/test_domloc_translateRoots.html]
 [dom/test_domloc_mutations.html]
 [dom/test_domloc_overlay.html]
 [dom/test_domloc_overlay_repeated.html]
 [dom/test_domloc_overlay_missing_all.html]
 [dom/test_domloc_overlay_missing_children.html]
 [dom/test_domloc_overlay_sanitized.html]
 [dom/test_domloc.xul]
+
+[document_l10n/xul/test_api_before_links.xul]
+[document_l10n/xul/test_dom_loc.xul]
+[document_l10n/xul/test_lazy_resource_injection.xul]
+[document_l10n/xul/test_no_loc.xul]
+[document_l10n/xul/test_no_loc_api_calls.xul]
+
+[document_l10n/html/test_dom_loc.html]
+[document_l10n/html/test_no_loc.html]
diff --git a/intl/l10n/test/document_l10n/html/test_dom_loc.html b/intl/l10n/test/document_l10n/html/test_dom_loc.html
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/html/test_dom_loc.html
@@ -0,0 +1,23 @@
+<html>
+  <head>
+    <title>Testing that the DOM is localized at firstPaint</title>
+    <link rel="stylesheet" type="text/css"
+          href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+    <script type="application/javascript"
+            src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" /></script>
+    <script type="application/javascript">
+      SimpleTest.waitForExplicitFinish();
+
+      document.l10n.ready.then(() => {
+        // Test that it's before first paint
+        const label = document.getElementById("label");
+        isnot(label.textContent, "");
+        SimpleTest.finish();
+      });
+    </script>
+    <link rel="localization" href="browser/preferences/preferences.ftl"/>
+  </head>
+  <body>
+    <label id="label" data-l10n-id="pane-general-title"/>
+  </body>
+</html>
diff --git a/intl/l10n/test/document_l10n/html/test_no_loc.html b/intl/l10n/test/document_l10n/html/test_no_loc.html
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/html/test_no_loc.html
@@ -0,0 +1,23 @@
+<html>
+  <head>
+    <title>
+      Testing that document.l10n methods resolve even when there are no resources
+    </title>
+    <link rel="stylesheet" type="text/css"
+          href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+    <script type="application/javascript"
+            src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" /></script>
+    <script type="application/javascript">
+      SimpleTest.waitForExplicitFinish();
+
+      async function test() {
+        let value = await document.l10n.formatValue("pane-general-title");
+        is(value, undefined);
+        SimpleTest.finish();
+      }
+      test();
+    </script>
+  </head>
+  <body>
+  </body>
+</html>
diff --git a/intl/l10n/test/document_l10n/xul/test_api_before_links.xul b/intl/l10n/test/document_l10n/xul/test_api_before_links.xul
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/xul/test_api_before_links.xul
@@ -0,0 +1,27 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css"
+                 type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        title="Testing that document.l10n methods resolve once links are loaded">
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" />
+  <script type="application/javascript">
+  <![CDATA[
+    SimpleTest.waitForExplicitFinish();
+
+    async function test() {
+      let value = await document.l10n.formatValue("pane-general-title");
+      isnot(value, undefined);
+      SimpleTest.finish();
+    }
+    test();
+  ]]>
+  </script>
+  <linkset>
+    <html:link rel="localization" href="browser/preferences/preferences.ftl"/>
+  </linkset>
+</window>
diff --git a/intl/l10n/test/document_l10n/xul/test_dom_loc.xul b/intl/l10n/test/document_l10n/xul/test_dom_loc.xul
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/xul/test_dom_loc.xul
@@ -0,0 +1,31 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css"
+                 type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        title="Testing that the DOM is localized at firstPaint">
+  <label id="label-pre" data-l10n-id="pane-home-title"/>
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" />
+  <script type="application/javascript">
+  <![CDATA[
+    SimpleTest.waitForExplicitFinish();
+
+    document.l10n.ready.then(() => {
+      // Test that it's before first paint
+      const label1 = document.getElementById("label-pre");
+      const label2 = document.getElementById("label-post");
+      isnot(label1.textContent, "");
+      isnot(label2.textContent, "");
+      SimpleTest.finish();
+    });
+  ]]>
+  </script>
+  <linkset>
+    <html:link rel="localization" href="browser/preferences/preferences.ftl"/>
+  </linkset>
+  <label id="label-post" data-l10n-id="pane-general-title"/>
+</window>
diff --git a/intl/l10n/test/document_l10n/xul/test_lazy_resource_injection.xul b/intl/l10n/test/document_l10n/xul/test_lazy_resource_injection.xul
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/xul/test_lazy_resource_injection.xul
@@ -0,0 +1,52 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css"
+                 type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        title="Testing that a resource injected late becomes available">
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" />
+  <script type="application/javascript">
+  <![CDATA[
+    SimpleTest.waitForExplicitFinish();
+
+    function injectResource() {
+      let link = document.createElementNS("http://www.w3.org/1999/xhtml", "link");
+      link.setAttribute("rel", "localization");
+      link.setAttribute("href", "browser/preferences/colors.ftl");
+      let linkset = document.querySelector("linkset");
+      linkset.appendChild(link);
+    }
+
+    function removeResource() {
+      let link = document.querySelector("link[href='browser/preferences/colors.ftl']");
+      link.parentNode.removeChild(link);
+    }
+
+    document.l10n.ready.then(async () => {
+      // Test that it's before first paint
+      const label1 = document.getElementById("label");
+      isnot(label1.textContent, "");
+
+      injectResource();
+
+      let value = await document.l10n.formatValue("colors-links-header");
+      isnot(value, undefined);
+
+      removeResource();
+
+      let value2 = await document.l10n.formatValue("colors-links-header");
+      is(value2, undefined);
+
+
+      SimpleTest.finish();
+    });
+  ]]>
+  </script>
+  <linkset>
+    <html:link rel="localization" href="browser/preferences/preferences.ftl"/>
+  </linkset>
+  <label id="label" data-l10n-id="pane-general-title"/>
+</window>
diff --git a/intl/l10n/test/document_l10n/xul/test_no_loc.xul b/intl/l10n/test/document_l10n/xul/test_no_loc.xul
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/xul/test_no_loc.xul
@@ -0,0 +1,23 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css"
+                 type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        title="Testing that document.l10n methods resolve even when there are no resources">
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" />
+  <script type="application/javascript">
+  <![CDATA[
+    SimpleTest.waitForExplicitFinish();
+
+    async function test() {
+      let value = await document.l10n.formatValue("pane-general-title");
+      is(value, undefined);
+      SimpleTest.finish();
+    }
+    test();
+  ]]>
+  </script>
+</window>
diff --git a/intl/l10n/test/document_l10n/xul/test_no_loc_api_calls.xul b/intl/l10n/test/document_l10n/xul/test_no_loc_api_calls.xul
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/document_l10n/xul/test_no_loc_api_calls.xul
@@ -0,0 +1,22 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css"
+                 type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        title="Testing that API resolve if called late with no linkset">
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" />
+  <script type="application/javascript">
+  <![CDATA[
+    SimpleTest.waitForExplicitFinish();
+
+    window.onload = async () => {
+      await document.l10n.ready;
+      is(1, 1);
+      SimpleTest.finish();
+    };
+  ]]>
+  </script>
+</window>
diff --git a/intl/l10n/test/test_documentlocalization.js b/intl/l10n/test/test_documentlocalization.js
new file mode 100644
--- /dev/null
+++ b/intl/l10n/test/test_documentlocalization.js
@@ -0,0 +1,22 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const documentLocalization =
+  Cc["@mozilla.org/intl/documentlocalization;1"].createInstance(
+    Ci.mozIDocumentLocalization);
+
+add_task(function test_methods_presence() {
+  equal(typeof documentLocalization.setDocument, "function");
+  equal(typeof documentLocalization.init, "function");
+  equal(typeof documentLocalization.onDOMReady, "function");
+  equal(typeof documentLocalization.setAttributes, "function");
+  equal(typeof documentLocalization.getAttributes, "function");
+  equal(typeof documentLocalization.translateElements, "function");
+  equal(typeof documentLocalization.translateFragment, "function");
+  equal(typeof documentLocalization.addResourceId, "function");
+  equal(typeof documentLocalization.removeResourceId, "function");
+  equal(typeof documentLocalization.formatMessages, "function");
+  equal(typeof documentLocalization.formatValues, "function");
+  equal(typeof documentLocalization.formatValue, "function");
+  equal(typeof documentLocalization.getReady, "function");
+});
diff --git a/intl/l10n/test/xpcshell.ini b/intl/l10n/test/xpcshell.ini
--- a/intl/l10n/test/xpcshell.ini
+++ b/intl/l10n/test/xpcshell.ini
@@ -1,7 +1,8 @@
 [DEFAULT]
 head =
 
+[test_documentlocalization.js]
 [test_domlocalization.js]
 [test_l10nregistry.js]
 [test_localization.js]
 [test_messagecontext.js]
diff --git a/python/l10n/fluent_migrations/bug_1411707_findbar.py b/python/l10n/fluent_migrations/bug_1411707_findbar.py
new file mode 100644
--- /dev/null
+++ b/python/l10n/fluent_migrations/bug_1411707_findbar.py
@@ -0,0 +1,42 @@
+# coding=utf8
+
+# Any copyright is dedicated to the Public Domain.
+# http://creativecommons.org/publicdomain/zero/1.0/
+
+from __future__ import absolute_import
+import fluent.syntax.ast as FTL
+from fluent.migrate.helpers import transforms_from
+
+
+def migrate(ctx):
+    """Bug 1411707 - Migrate the findbar XBL binding to a Custom Element, part {index}."""
+
+    ctx.add_transforms(
+        'toolkit/toolkit/main-window/findbar.ftl',
+        'toolkit/toolkit/main-window/findbar.ftl',
+        transforms_from(
+"""
+findbar-next =
+    .tooltiptext = { COPY(from_path, "next.tooltip") }
+findbar-previous =
+    .tooltiptext = { COPY(from_path, "previous.tooltip") }
+
+findbar-find-button-close =
+    .tooltiptext = { COPY(from_path, "findCloseButton.tooltip") }
+
+findbar-highlight-all =
+    .label = { COPY(from_path, "highlightAll.label") }
+    .accesskey = { COPY(from_path, "highlightAll.accesskey") }
+    .tooltiptext = { COPY(from_path, "highlightAll.tooltiptext") }
+
+findbar-case-sensitive =
+    .label = { COPY(from_path, "caseSensitive.label") }
+    .accesskey = { COPY(from_path, "caseSensitive.accesskey") }
+    .tooltiptext = { COPY(from_path, "caseSensitive.tooltiptext") }
+
+findbar-entire-word =
+    .label = { COPY(from_path, "entireWord.label") }
+    .accesskey = { COPY(from_path, "entireWord.accesskey") }
+    .tooltiptext = { COPY(from_path, "entireWord.tooltiptext") }
+""", from_path="toolkit/chrome/global/findbar.dtd")
+    )
diff --git a/toolkit/components/extensions/test/browser/browser_ext_themes_findbar.js b/toolkit/components/extensions/test/browser/browser_ext_themes_findbar.js
--- a/toolkit/components/extensions/test/browser/browser_ext_themes_findbar.js
+++ b/toolkit/components/extensions/test/browser/browser_ext_themes_findbar.js
@@ -29,17 +29,17 @@ add_task(async function test_support_too
     files: {
       "image1.png": BACKGROUND,
     },
   });
 
   await extension.startup();
   await gBrowser.getFindBar();
 
-  let findbar_button = document.getAnonymousElementByAttribute(gFindBar, "anonid", "highlight");
+  let findbar_button = gFindBar.getElement("highlight");
 
   info("Checking findbar background is set as toolbar color");
   Assert.equal(window.getComputedStyle(gFindBar).backgroundColor,
                hexToCSS(TOOLBAR_COLOR),
                "Findbar background color should be the same as toolbar background color.");
 
   info("Checking findbar and button text color is set as toolbar text color");
   Assert.equal(window.getComputedStyle(gFindBar).color,
@@ -74,24 +74,21 @@ add_task(async function test_support_too
     files: {
       "image1.png": BACKGROUND,
     },
   });
 
   await extension.startup();
   await gBrowser.getFindBar();
 
-  let findbar_textbox =
-    document.getAnonymousElementByAttribute(gFindBar, "anonid", "findbar-textbox");
+  let findbar_textbox = gFindBar.getElement("findbar-textbox");
 
-  let findbar_prev_button =
-    document.getAnonymousElementByAttribute(gFindBar, "anonid", "find-previous");
+  let findbar_prev_button = gFindBar.getElement("find-previous");
 
-  let findbar_next_button =
-    document.getAnonymousElementByAttribute(gFindBar, "anonid", "find-next");
+  let findbar_next_button = gFindBar.getElement("find-next");
 
   info("Checking findbar textbox background is set as toolbar field background color");
   Assert.equal(window.getComputedStyle(findbar_textbox).backgroundColor,
                hexToCSS(TOOLBAR_FIELD_COLOR),
                "Findbar textbox background color should be the same as toolbar field color.");
 
   info("Checking findbar textbox color is set as toolbar field text color");
   Assert.equal(window.getComputedStyle(findbar_textbox).color,
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -53,21 +53,57 @@ class MozXULElement extends XULElement {
       currentNode = nodeIterator.nextNode();
     }
     // We use a range here so that we don't access the inner DOM elements from
     // JavaScript before they are imported and inserted into a document.
     let range = doc.createRange();
     range.selectNodeContents(doc.firstChild);
     return range.extractContents();
   }
+
+  static appendFluentLink(url) {
+    const HTML_NS = "http://www.w3.org/1999/xhtml";
+    let linkset = document.querySelector("linkset");
+    if (!linkset) {
+      linkset = document.createElement("linkset");
+      document.documentElement.prepend(linkset);
+    }
+
+    let link = null;
+    for (let i = 0; i < linkset.children.length; i++) {
+      console.log("LOOKING AT", linkset.children[i].getAttribute("href"), url)
+      if (linkset.children[i].getAttribute("href") === url) {
+        link = linkset.children[i];
+        console.log("Matched");
+        break;
+      }
+    }
+
+    if (!link) {
+      link = document.createElementNS(HTML_NS, "link");
+      link.setAttribute("href", url);
+      link.setAttribute("rel", "localization");
+      linkset.appendChild(link);
+    }
+
+    return link;
+  }
 }
 
 // Attach the base class to the window so other scripts can use it:
 window.MozXULElement = MozXULElement;
 
 for (let script of [
-  "chrome://global/content/elements/stringbundle.js",
   "chrome://global/content/elements/general.js",
 ]) {
   Services.scriptloader.loadSubScript(script, window);
 }
 
+for (let [tag, script] of [
+  ["findbar", "chrome://global/content/elements/findbar.js"],
+  ["stringbundle", "chrome://global/content/elements/stringbundle.js"],
+]) {
+  customElements.setElementCreationCallback(tag, () => {
+    Services.scriptloader.loadSubScript(script, window);
+  });
 }
+
+}
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -70,17 +70,16 @@ toolkit.jar:
    content/global/bindings/colorpicker.xml     (widgets/colorpicker.xml)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimepopup.xml   (widgets/datetimepopup.xml)
    content/global/bindings/datetimebox.xml     (widgets/datetimebox.xml)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
 *  content/global/bindings/dialog.xml          (widgets/dialog.xml)
    content/global/bindings/editor.xml          (widgets/editor.xml)
-*  content/global/bindings/findbar.xml         (widgets/findbar.xml)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/groupbox.xml        (widgets/groupbox.xml)
    content/global/bindings/listbox.xml         (widgets/listbox.xml)
    content/global/bindings/menu.xml            (widgets/menu.xml)
    content/global/bindings/menulist.xml        (widgets/menulist.xml)
    content/global/bindings/notification.xml    (widgets/notification.xml)
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
@@ -96,15 +95,16 @@ toolkit.jar:
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
 *  content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
-   content/global/elements/general.js           (widgets/general.js)
+   content/global/elements/findbar.js          (widgets/findbar.js)
+   content/global/elements/general.js          (widgets/general.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
    content/global/gmp-sources/widevinecdm.json (gmp-sources/widevinecdm.json)
diff --git a/toolkit/content/widgets/findbar.xml b/toolkit/content/widgets/findbar.js
rename from toolkit/content/widgets/findbar.xml
rename to toolkit/content/widgets/findbar.js
--- a/toolkit/content/widgets/findbar.xml
+++ b/toolkit/content/widgets/findbar.js
@@ -1,1364 +1,1192 @@
-<?xml version="1.0"?>
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Wrap to prevent accidentally leaking to window scope:
+{
+
+ChromeUtils.import("resource://gre/modules/Services.jsm");
 
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+class MozFindbar extends MozXULElement {
+  constructor() {
+    super();
+    MozXULElement.appendFluentLink("toolkit/main-window/findbar.ftl");
+    this.content = MozXULElement.parseXULToFragment(`
+      <hbox anonid="findbar-container" class="findbar-container" flex="1" align="center">
+        <hbox anonid="findbar-textbox-wrapper" align="stretch">
+          <textbox anonid="findbar-textbox" class="findbar-textbox findbar-find-fast" />
+          <toolbarbutton anonid="find-previous" class="findbar-find-previous tabbable" data-l10n-attrs="tooltiptext" data-l10n-id="findbar-previous" oncommand="onFindAgainCommand(true);" disabled="true" />
+          <toolbarbutton anonid="find-next" class="findbar-find-next tabbable" data-l10n-id="findbar-next" oncommand="onFindAgainCommand(false);" disabled="true" />
+        </hbox>
+        <toolbarbutton anonid="highlight" class="findbar-highlight findbar-button tabbable" data-l10n-id="findbar-highlight-all" oncommand="toggleHighlight(this.checked);" type="checkbox" />
+        <toolbarbutton anonid="find-case-sensitive" class="findbar-case-sensitive findbar-button tabbable" data-l10n-id="findbar-case-sensitive" oncommand="_setCaseSensitivity(this.checked ? 1 : 0);" type="checkbox" />
+        <toolbarbutton anonid="find-entire-word" class="findbar-entire-word findbar-button tabbable" data-l10n-id="findbar-entire-word" oncommand="toggleEntireWord(this.checked);" type="checkbox" />
+        <label anonid="match-case-status" class="findbar-find-fast" />
+        <label anonid="entire-word-status" class="findbar-find-fast" />
+        <label anonid="found-matches" class="findbar-find-fast found-matches" hidden="true" />
+        <image anonid="find-status-icon" class="findbar-find-fast find-status-icon" />
+        <description anonid="find-status" control="findbar-textbox" class="findbar-find-fast findbar-find-status" />
+      </hbox>
+      <toolbarbutton anonid="find-closebutton" class="findbar-closebutton close-icon" data-l10n-id="findbar-find-button-close" oncommand="close();" />
+    `);
+  }
+
+  connectedCallback() {
+    this.appendChild(document.importNode(this.content, true));
 
-<!DOCTYPE bindings [
-<!ENTITY % findBarDTD SYSTEM "chrome://global/locale/findbar.dtd" >
-%findBarDTD;
-]>
+    this.hidden = true;
+
+    /**
+     * Please keep in sync with toolkit/content/browser-content.js
+     */
+    this.FIND_NORMAL = 0;
+
+    this.FIND_TYPEAHEAD = 1;
+
+    this.FIND_LINKS = 2;
+
+    this.__findMode = 0;
+
+    this._flashFindBar = 0;
+
+    this._initialFlashFindBarCount = 6;
 
-<bindings id="findbarBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+    /**
+     * - For tests that need to know when the find bar is finished
+     * - initializing, we store a promise to notify on.
+     */
+    this._startFindDeferred = null;
+
+    this._browser = null;
+
+    this.__prefsvc = null;
+
+    this._observer = {
+      _self: this,
+
+      QueryInterface: ChromeUtils.generateQI(["nsIObserver",
+                                              "nsISupportsWeakReference"]),
+
+      observe(aSubject, aTopic, aPrefName) {
+        if (aTopic != "nsPref:changed")
+          return;
+
+        let prefsvc = this._self._prefsvc;
 
-  <!-- Private binding -->
-  <binding id="findbar-textbox"
-           extends="chrome://global/content/bindings/textbox.xml#textbox">
-    <implementation>
+        switch (aPrefName) {
+          case "accessibility.typeaheadfind":
+            this._self._findAsYouType = prefsvc.getBoolPref(aPrefName);
+            break;
+          case "accessibility.typeaheadfind.linksonly":
+            this._self._typeAheadLinksOnly = prefsvc.getBoolPref(aPrefName);
+            break;
+          case "accessibility.typeaheadfind.casesensitive":
+            this._self._setCaseSensitivity(prefsvc.getIntPref(aPrefName));
+            break;
+          case "findbar.entireword":
+            this._self._entireWord = prefsvc.getBoolPref(aPrefName);
+            this._self.toggleEntireWord(this._self._entireWord, true);
+            break;
+          case "findbar.highlightAll":
+            this._self.toggleHighlight(prefsvc.getBoolPref(aPrefName), true);
+            break;
+          case "findbar.modalHighlight":
+            this._self._useModalHighlight = prefsvc.getBoolPref(aPrefName);
+            if (this._self.browser.finder)
+              this._self.browser.finder.onModalHighlightChange(this._self._useModalHighlight);
+            break;
+        }
+      }
+    };
+
+    this._destroyed = false;
+
+    this._pluralForm = null;
+
+    this._strBundle = null;
+
+    this._xulBrowserWindow = null;
+
+    // These elements are accessed frequently and are therefore cached
+    this._findField = this.getElement("findbar-textbox");
+    this._foundMatches = this.getElement("found-matches");
+    this._findStatusIcon = this.getElement("find-status-icon");
+    this._findStatusDesc = this.getElement("find-status");
+
+    this._foundURL = null;
+
+    let prefsvc = this._prefsvc;
+
+    this._quickFindTimeoutLength =
+      prefsvc.getIntPref("accessibility.typeaheadfind.timeout");
+    this._flashFindBar =
+      prefsvc.getIntPref("accessibility.typeaheadfind.flashBar");
+    this._useModalHighlight = prefsvc.getBoolPref("findbar.modalHighlight");
+
+    prefsvc.addObserver("accessibility.typeaheadfind",
+      this._observer);
+    prefsvc.addObserver("accessibility.typeaheadfind.linksonly",
+      this._observer);
+    prefsvc.addObserver("accessibility.typeaheadfind.casesensitive",
+      this._observer);
+    prefsvc.addObserver("findbar.entireword", this._observer);
+    prefsvc.addObserver("findbar.highlightAll", this._observer);
+    prefsvc.addObserver("findbar.modalHighlight", this._observer);
 
-      <field name="_findbar">null</field>
-      <property name="findbar" readonly="true">
-        <getter>
-          return this._findbar ?
-                 this._findbar : this._findbar = document.getBindingParent(this);
-        </getter>
-      </property>
+    this._findAsYouType =
+      prefsvc.getBoolPref("accessibility.typeaheadfind");
+    this._typeAheadLinksOnly =
+      prefsvc.getBoolPref("accessibility.typeaheadfind.linksonly");
+    this._typeAheadCaseSensitive =
+      prefsvc.getIntPref("accessibility.typeaheadfind.casesensitive");
+    this._entireWord = prefsvc.getBoolPref("findbar.entireword");
+    this._highlightAll = prefsvc.getBoolPref("findbar.highlightAll");
+
+    // Convenience
+    this.nsITypeAheadFind = Ci.nsITypeAheadFind;
+    this.nsISelectionController = Ci.nsISelectionController;
+    this._findSelection = this.nsISelectionController.SELECTION_FIND;
+
+    this._findResetTimeout = -1;
+
+    // Make sure the FAYT keypress listener is attached by initializing the
+    // browser property
+    if (this.getAttribute("browserid"))
+      setTimeout(function(aSelf) { aSelf.browser = aSelf.browser; }, 0, this);
 
-      <method name="_handleEnter">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          if (this.findbar._findMode == this.findbar.FIND_NORMAL) {
-            let findString = this.findbar._findField;
+    // We have to guard against `this.close` being |null| due to an unknown
+    // issue, which is tracked in bug 957999.
+    this.addEventListener("keypress", (event) => {
+      if (event.keyCode == event.DOM_VK_ESCAPE) {
+        if (this.close)
+          this.close();
+        event.preventDefault();
+      }
+    }, true);
+
+    this.destroy = this.destroy.bind(this);
+    window.addEventListener("unload", this.destroy);
+
+    this._findField.addEventListener("input", (event) => {
+      // We should do nothing during composition.  E.g., composing string
+      // before converting may matches a forward word of expected word.
+      // After that, even if user converts the composition string to the
+      // expected word, it may find second or later searching word in the
+      // document.
+      if (this._isIMEComposing) {
+        return;
+      }
+
+      const value = this._findField.value;
+      if (this._hadValue && !value) {
+        this._willfullyDeleted = true;
+        this._hadValue = false;
+      } else if (value.trim()) {
+        this._hadValue = true;
+        this._willfullyDeleted = false;
+      }
+      this._find(value);
+    });
+
+    this._findField.addEventListener("keypress", (event) => {
+      switch (event.keyCode) {
+        case KeyEvent.DOM_VK_RETURN:
+          if (this._findMode == this.FIND_NORMAL) {
+            let findString = this._findField;
             if (!findString.value)
               return;
-            if (aEvent.getModifierState("Accel")) {
-              this.findbar.getElement("highlight").click();
+            if (event.getModifierState("Accel")) {
+              this.getElement("highlight").click();
               return;
             }
 
-            this.findbar.onFindAgainCommand(aEvent.shiftKey);
+            this.onFindAgainCommand(event.shiftKey);
           } else {
-            this.findbar._finishFAYT(aEvent);
+            this._finishFAYT(event);
           }
-        ]]></body>
-      </method>
+          break;
+        case KeyEvent.DOM_VK_TAB:
+          let shouldHandle = !event.altKey && !event.ctrlKey &&
+            !event.metaKey;
+          if (shouldHandle &&
+            this._findMode != this.FIND_NORMAL) {
 
-      <method name="_handleTab">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          let shouldHandle = !aEvent.altKey && !aEvent.ctrlKey &&
-                             !aEvent.metaKey;
-          if (shouldHandle &&
-              this.findbar._findMode != this.findbar.FIND_NORMAL) {
-
-            this.findbar._finishFAYT(aEvent);
+            this._finishFAYT(event);
           }
-        ]]></body>
-      </method>
-    </implementation>
+          break;
+        case KeyEvent.DOM_VK_PAGE_UP:
+        case KeyEvent.DOM_VK_PAGE_DOWN:
+          if (!event.altKey && !event.ctrlKey &&
+              !event.metaKey && !event.shiftKey) {
+            this.browser.finder.keyPress(event);
+            event.preventDefault();
+          }
+          break;
+        case KeyEvent.DOM_VK_UP:
+        case KeyEvent.DOM_VK_DOWN:
+          this.browser.finder.keyPress(event);
+          event.preventDefault();
+          break;
+      }
+    });
 
-    <handlers>
-      <handler event="input"><![CDATA[
-        // We should do nothing during composition.  E.g., composing string
-        // before converting may matches a forward word of expected word.
-        // After that, even if user converts the composition string to the
-        // expected word, it may find second or later searching word in the
-        // document.
-        if (this.findbar._isIMEComposing) {
-          return;
-        }
+    this._findField.addEventListener("blur", (event) => {
+      // Note: This code used to remove the selection
+      // if it matched an editable.
+      this.browser.finder.enableSelection();
+    });
+
+    this._findField.addEventListener("focus", (event) => {
+      if (/Mac/.test(navigator.platform)) {
+        this._onFindFieldFocus();
+      }
+      this._updateBrowserWithState();
+    });
 
-        if (this._hadValue && !this.value) {
-          this._willfullyDeleted = true;
-          this._hadValue = false;
-        } else if (this.value.trim()) {
-          this._hadValue = true;
-          this._willfullyDeleted = false;
-        }
-        this.findbar._find(this.value);
-      ]]></handler>
+    this._findField.addEventListener("compositionstart", (event) => {
+      // Don't close the find toolbar while IME is composing.
+      let findbar = this;
+      findbar._isIMEComposing = true;
+      if (findbar._quickFindTimeout) {
+        clearTimeout(findbar._quickFindTimeout);
+        findbar._quickFindTimeout = null;
+        findbar._updateBrowserWithState();
+      }
+    });
 
-      <handler event="keypress"><![CDATA[
-        let shouldHandle = !event.altKey && !event.ctrlKey &&
-                           !event.metaKey && !event.shiftKey;
+    this._findField.addEventListener("compositionend", (event) => {
+      this._isIMEComposing = false;
+      if (this._findMode != this.FIND_NORMAL)
+        this._setFindCloseTimeout();
+    });
 
-        switch (event.keyCode) {
-          case KeyEvent.DOM_VK_RETURN:
-            this._handleEnter(event);
-            break;
-          case KeyEvent.DOM_VK_TAB:
-            this._handleTab(event);
-            break;
-          case KeyEvent.DOM_VK_PAGE_UP:
-          case KeyEvent.DOM_VK_PAGE_DOWN:
-            if (shouldHandle) {
-              this.findbar.browser.finder.keyPress(event);
-              event.preventDefault();
-            }
-            break;
-          case KeyEvent.DOM_VK_UP:
-          case KeyEvent.DOM_VK_DOWN:
-            this.findbar.browser.finder.keyPress(event);
-            event.preventDefault();
-            break;
-        }
-      ]]></handler>
+    this._findField.addEventListener("dragover", (event) => {
+      if (event.dataTransfer.types.includes("text/plain"))
+        event.preventDefault();
+    });
+
+    this._findField.addEventListener("drop", (event) => {
+      let value = event.dataTransfer.getData("text/plain");
+      this._findField.value = value;
+      this._find(value);
+      event.stopPropagation();
+      event.preventDefault();
+    });
+  }
 
-      <handler event="blur"><![CDATA[
-        let findbar = this.findbar;
-        // Note: This code used to remove the selection
-        // if it matched an editable.
-        findbar.browser.finder.enableSelection();
-      ]]></handler>
+  set _findMode(val) {
+    this.__findMode = val;
+    this._updateBrowserWithState();
+    return val;
+  }
 
-      <handler event="focus"><![CDATA[
-        let findbar = this.findbar;
-        if (/Mac/.test(navigator.platform)) {
-          findbar._onFindFieldFocus();
-        }
-        findbar._updateBrowserWithState();
-      ]]></handler>
+  get _findMode() {
+    return this.__findMode;
+  }
+
+  set prefillWithSelection(val) {
+    this.setAttribute("prefillwithselection", val);
+    return val;
+  }
 
-      <handler event="compositionstart"><![CDATA[
-        // Don't close the find toolbar while IME is composing.
-        let findbar = this.findbar;
-        findbar._isIMEComposing = true;
-        if (findbar._quickFindTimeout) {
-          clearTimeout(findbar._quickFindTimeout);
-          findbar._quickFindTimeout = null;
-          findbar._updateBrowserWithState();
-        }
-      ]]></handler>
+  get prefillWithSelection() {
+    return this.getAttribute("prefillwithselection") != "false";
+  }
 
-      <handler event="compositionend"><![CDATA[
-        let findbar = this.findbar;
-        findbar._isIMEComposing = false;
-        if (findbar._findMode != findbar.FIND_NORMAL)
-          findbar._setFindCloseTimeout();
-      ]]></handler>
+  get findMode() {
+    return this._findMode;
+  }
+
+  get hasTransactions() {
+    if (this._findField.value)
+      return true;
 
-      <handler event="dragover"><![CDATA[
-        if (event.dataTransfer.types.includes("text/plain"))
-          event.preventDefault();
-      ]]></handler>
+    // Watch out for lazy editor init
+    if (this._findField.editor) {
+      let tm = this._findField.editor.transactionManager;
+      return !!(tm.numberOfUndoItems || tm.numberOfRedoItems);
+    }
+    return false;
+  }
 
-      <handler event="drop"><![CDATA[
-        let value = event.dataTransfer.getData("text/plain");
-        this.value = value;
-        this.findbar._find(value);
-        event.stopPropagation();
-        event.preventDefault();
-      ]]></handler>
-    </handlers>
-  </binding>
-
-  <binding id="findbar">
-    <resources>
-      <stylesheet src="chrome://global/skin/findBar.css"/>
-    </resources>
+  set browser(val) {
+    if (this._browser) {
+      if (this._browser.messageManager) {
+        this._browser.messageManager.removeMessageListener("Findbar:Keypress", this);
+        this._browser.messageManager.removeMessageListener("Findbar:Mouseup", this);
+      }
+      let finder = this._browser.finder;
+      if (finder)
+        finder.removeResultListener(this);
+    }
 
-    <content hidden="true">
-    <xul:hbox anonid="findbar-container" class="findbar-container" flex="1" align="center">
-      <xul:hbox anonid="findbar-textbox-wrapper" align="stretch">
-        <xul:textbox anonid="findbar-textbox"
-                     class="findbar-textbox findbar-find-fast"
-                     xbl:inherits="flash"/>
-        <xul:toolbarbutton anonid="find-previous"
-                           class="findbar-find-previous tabbable"
-                           tooltiptext="&previous.tooltip;"
-                           oncommand="onFindAgainCommand(true);"
-                           disabled="true"
-                           xbl:inherits="accesskey=findpreviousaccesskey"/>
-        <xul:toolbarbutton anonid="find-next"
-                           class="findbar-find-next tabbable"
-                           tooltiptext="&next.tooltip;"
-                           oncommand="onFindAgainCommand(false);"
-                           disabled="true"
-                           xbl:inherits="accesskey=findnextaccesskey"/>
-      </xul:hbox>
-      <xul:toolbarbutton anonid="highlight"
-                         class="findbar-highlight findbar-button tabbable"
-                         label="&highlightAll.label;"
-                         accesskey="&highlightAll.accesskey;"
-                         tooltiptext="&highlightAll.tooltiptext;"
-                         oncommand="toggleHighlight(this.checked);"
-                         type="checkbox"
-                         xbl:inherits="accesskey=highlightaccesskey"/>
-      <xul:toolbarbutton anonid="find-case-sensitive"
-                         class="findbar-case-sensitive findbar-button tabbable"
-                         label="&caseSensitive.label;"
-                         accesskey="&caseSensitive.accesskey;"
-                         tooltiptext="&caseSensitive.tooltiptext;"
-                         oncommand="_setCaseSensitivity(this.checked ? 1 : 0);"
-                         type="checkbox"
-                         xbl:inherits="accesskey=matchcaseaccesskey"/>
-      <xul:toolbarbutton anonid="find-entire-word"
-                         class="findbar-entire-word findbar-button tabbable"
-                         label="&entireWord.label;"
-                         accesskey="&entireWord.accesskey;"
-                         tooltiptext="&entireWord.tooltiptext;"
-                         oncommand="toggleEntireWord(this.checked);"
-                         type="checkbox"
-                         xbl:inherits="accesskey=entirewordaccesskey"/>
-      <xul:label anonid="match-case-status" class="findbar-find-fast"/>
-      <xul:label anonid="entire-word-status" class="findbar-find-fast"/>
-      <xul:label anonid="found-matches" class="findbar-find-fast found-matches" hidden="true"/>
-      <xul:image anonid="find-status-icon" class="findbar-find-fast find-status-icon"/>
-      <xul:description anonid="find-status"
-                       control="findbar-textbox"
-                       class="findbar-find-fast findbar-find-status">
-      <!-- Do not use value, first child is used because it provides a11y with text change events -->
-      </xul:description>
-    </xul:hbox>
-    <xul:toolbarbutton anonid="find-closebutton"
-                       class="findbar-closebutton close-icon"
-                       tooltiptext="&findCloseButton.tooltip;"
-                       oncommand="close();"/>
-    </content>
+    this._browser = val;
+    if (this._browser) {
+      // Need to do this to ensure the correct initial state.
+      this._updateBrowserWithState();
+      this._browser.messageManager.addMessageListener("Findbar:Keypress", this);
+      this._browser.messageManager.addMessageListener("Findbar:Mouseup", this);
+      this._browser.finder.addResultListener(this);
+
+      this._findField.value = this._browser._lastSearchString;
+    }
+    return val;
+  }
+
+  get browser() {
+    if (!this._browser) {
+      this._browser =
+        document.getElementById(this.getAttribute("browserid"));
+    }
+    return this._browser;
+  }
+
+  get _prefsvc() {
+    return Services.prefs;
+  }
 
-    <implementation>
-      <!-- Please keep in sync with toolkit/content/browser-content.js -->
-      <field name="FIND_NORMAL">0</field>
-      <field name="FIND_TYPEAHEAD">1</field>
-      <field name="FIND_LINKS">2</field>
+  get pluralForm() {
+    if (!this._pluralForm) {
+      this._pluralForm = ChromeUtils.import(
+        "resource://gre/modules/PluralForm.jsm", {}).PluralForm;
+    }
+    return this._pluralForm;
+  }
 
-      <field name="__findMode">0</field>
-      <property name="_findMode" onget="return this.__findMode;"
-                onset="this.__findMode = val; this._updateBrowserWithState(); return val;"/>
-
-      <field name="_flashFindBar">0</field>
-      <field name="_initialFlashFindBarCount">6</field>
-
-      <!--
-        - For tests that need to know when the find bar is finished
-        - initializing, we store a promise to notify on.
-        -->
-      <field name="_startFindDeferred">null</field>
+  get strBundle() {
+    if (!this._strBundle) {
+      this._strBundle = Services.strings.createBundle(
+        "chrome://global/locale/findbar.properties");
+    }
+    return this._strBundle;
+  }
 
-      <property name="prefillWithSelection"
-                onget="return this.getAttribute('prefillwithselection') != 'false'"
-                onset="this.setAttribute('prefillwithselection', val); return val;"/>
+  getElement(aAnonymousID) {
+    return this.querySelector(`[anonid=${aAnonymousID}]`);
+  }
 
-      <method name="getElement">
-        <parameter name="aAnonymousID"/>
-        <body><![CDATA[
-          return document.getAnonymousElementByAttribute(this,
-                                                         "anonid",
-                                                         aAnonymousID);
-        ]]></body>
-      </method>
+  /**
+   * This is necessary because the destructor isn't called when
+   * we are removed from a document that is not destroyed. This
+   * needs to be explicitly called in this case
+   */
+  destroy() {
+    if (this._destroyed)
+      return;
+    window.removeEventListener("unload", this.destroy);
+    this._destroyed = true;
 
-      <property name="findMode"
-                readonly="true"
-                onget="return this._findMode;"/>
+    if (this.browser && this.browser.finder)
+      this.browser.finder.destroy();
 
-      <property name="hasTransactions" readonly="true">
-        <getter><![CDATA[
-          if (this._findField.value)
-            return true;
+    this.browser = null;
 
-          // Watch out for lazy editor init
-          if (this._findField.editor) {
-            let tm = this._findField.editor.transactionManager;
-            return !!(tm.numberOfUndoItems || tm.numberOfRedoItems);
-          }
-          return false;
-        ]]></getter>
-      </property>
+    let prefsvc = this._prefsvc;
+    prefsvc.removeObserver("accessibility.typeaheadfind",
+      this._observer);
+    prefsvc.removeObserver("accessibility.typeaheadfind.linksonly",
+      this._observer);
+    prefsvc.removeObserver("accessibility.typeaheadfind.casesensitive",
+      this._observer);
+    prefsvc.removeObserver("findbar.entireword", this._observer);
+    prefsvc.removeObserver("findbar.highlightAll", this._observer);
+    prefsvc.removeObserver("findbar.modalHighlight", this._observer);
+
+    // Clear all timers that might still be running.
+    this._cancelTimers();
+  }
 
-      <field name="_browser">null</field>
-      <property name="browser">
-        <getter><![CDATA[
-          if (!this._browser) {
-            this._browser =
-              document.getElementById(this.getAttribute("browserid"));
-          }
-          return this._browser;
-        ]]></getter>
-        <setter><![CDATA[
-          if (this._browser) {
-            if (this._browser.messageManager) {
-              this._browser.messageManager.removeMessageListener("Findbar:Keypress", this);
-              this._browser.messageManager.removeMessageListener("Findbar:Mouseup", this);
-            }
-            let finder = this._browser.finder;
-            if (finder)
-              finder.removeResultListener(this);
-          }
-
-          this._browser = val;
-          if (this._browser) {
-            // Need to do this to ensure the correct initial state.
-            this._updateBrowserWithState();
-            this._browser.messageManager.addMessageListener("Findbar:Keypress", this);
-            this._browser.messageManager.addMessageListener("Findbar:Mouseup", this);
-            this._browser.finder.addResultListener(this);
-
-            this._findField.value = this._browser._lastSearchString;
-          }
-          return val;
-        ]]></setter>
-      </property>
+  _cancelTimers() {
+    if (this._flashFindBarTimeout) {
+      clearInterval(this._flashFindBarTimeout);
+      this._flashFindBarTimeout = null;
+    }
+    if (this._quickFindTimeout) {
+      clearTimeout(this._quickFindTimeout);
+      this._quickFindTimeout = null;
+    }
+    if (this._findResetTimeout) {
+      clearTimeout(this._findResetTimeout);
+      this._findResetTimeout = null;
+    }
+  }
 
-      <field name="__prefsvc">null</field>
-      <property name="_prefsvc">
-        <getter><![CDATA[
-          if (!this.__prefsvc) {
-            this.__prefsvc = Cc["@mozilla.org/preferences-service;1"]
-              .getService(Ci.nsIPrefBranch);
-          }
-          return this.__prefsvc;
-        ]]></getter>
-      </property>
+  _setFindCloseTimeout() {
+    if (this._quickFindTimeout)
+      clearTimeout(this._quickFindTimeout);
 
-      <field name="_observer"><![CDATA[({
-        _self: this,
-
-        QueryInterface: ChromeUtils.generateQI(["nsIObserver",
-                                                "nsISupportsWeakReference"]),
-
-        observe(aSubject, aTopic, aPrefName) {
-          if (aTopic != "nsPref:changed")
-            return;
-
-          let prefsvc = this._self._prefsvc;
+    // Don't close the find toolbar while IME is composing OR when the
+    // findbar is already hidden.
+    if (this._isIMEComposing || this.hidden) {
+      this._quickFindTimeout = null;
+      this._updateBrowserWithState();
+      return;
+    }
 
-          switch (aPrefName) {
-            case "accessibility.typeaheadfind":
-              this._self._findAsYouType = prefsvc.getBoolPref(aPrefName);
-              break;
-            case "accessibility.typeaheadfind.linksonly":
-              this._self._typeAheadLinksOnly = prefsvc.getBoolPref(aPrefName);
-              break;
-            case "accessibility.typeaheadfind.casesensitive":
-              this._self._setCaseSensitivity(prefsvc.getIntPref(aPrefName));
-              break;
-            case "findbar.entireword":
-              this._self._entireWord = prefsvc.getBoolPref(aPrefName);
-              this._self.toggleEntireWord(this._self._entireWord, true);
-              break;
-            case "findbar.highlightAll":
-              this._self.toggleHighlight(prefsvc.getBoolPref(aPrefName), true);
-              break;
-            case "findbar.modalHighlight":
-              this._self._useModalHighlight = prefsvc.getBoolPref(aPrefName);
-              if (this._self.browser.finder)
-                this._self.browser.finder.onModalHighlightChange(this._self._useModalHighlight);
-              break;
-          }
-        }
-      })]]></field>
+    this._quickFindTimeout = setTimeout(() => {
+      if (this._findMode != this.FIND_NORMAL)
+        this.close();
+      this._quickFindTimeout = null;
+    }, this._quickFindTimeoutLength);
+    this._updateBrowserWithState();
+  }
 
-      <field name="_destroyed">false</field>
+  /**
+   * - Updates the search match count after each find operation on a new string.
+   * - @param aRes
+   * -        the result of the find operation
+   */
+  _updateMatchesCount() {
+    if (!this._dispatchFindEvent("matchescount"))
+      return;
 
-      <constructor><![CDATA[
-        // These elements are accessed frequently and are therefore cached
-        this._findField = this.getElement("findbar-textbox");
-        this._foundMatches = this.getElement("found-matches");
-        this._findStatusIcon = this.getElement("find-status-icon");
-        this._findStatusDesc = this.getElement("find-status");
+    this.browser.finder.requestMatchesCount(this._findField.value,
+      this._findMode == this.FIND_LINKS);
+  }
 
-        this._foundURL = null;
-
-        let prefsvc = this._prefsvc;
-
-        this._quickFindTimeoutLength =
-          prefsvc.getIntPref("accessibility.typeaheadfind.timeout");
-        this._flashFindBar =
-          prefsvc.getIntPref("accessibility.typeaheadfind.flashBar");
-        this._useModalHighlight = prefsvc.getBoolPref("findbar.modalHighlight");
+  /**
+   * - Turns highlight on or off.
+   * - @param aHighlight (boolean)
+   * -        Whether to turn the highlight on or off
+   * - @param aFromPrefObserver (boolean)
+   * -        Whether the callee is the pref observer, which means we should
+   * -        not set the same pref again.
+   */
+  toggleHighlight(aHighlight, aFromPrefObserver) {
+    if (aHighlight === this._highlightAll) {
+      return;
+    }
 
-        prefsvc.addObserver("accessibility.typeaheadfind",
-                            this._observer);
-        prefsvc.addObserver("accessibility.typeaheadfind.linksonly",
-                            this._observer);
-        prefsvc.addObserver("accessibility.typeaheadfind.casesensitive",
-                            this._observer);
-        prefsvc.addObserver("findbar.entireword", this._observer);
-        prefsvc.addObserver("findbar.highlightAll", this._observer);
-        prefsvc.addObserver("findbar.modalHighlight", this._observer);
+    this.browser.finder.onHighlightAllChange(aHighlight);
+
+    this._setHighlightAll(aHighlight, aFromPrefObserver);
 
-        this._findAsYouType =
-          prefsvc.getBoolPref("accessibility.typeaheadfind");
-        this._typeAheadLinksOnly =
-          prefsvc.getBoolPref("accessibility.typeaheadfind.linksonly");
-        this._typeAheadCaseSensitive =
-          prefsvc.getIntPref("accessibility.typeaheadfind.casesensitive");
-        this._entireWord = prefsvc.getBoolPref("findbar.entireword");
-        this._highlightAll = prefsvc.getBoolPref("findbar.highlightAll");
+    if (!this._dispatchFindEvent("highlightallchange")) {
+      return;
+    }
 
-        // Convenience
-        this.nsITypeAheadFind = Ci.nsITypeAheadFind;
-        this.nsISelectionController = Ci.nsISelectionController;
-        this._findSelection = this.nsISelectionController.SELECTION_FIND;
-
-        this._findResetTimeout = -1;
+    let word = this._findField.value;
+    // Bug 429723. Don't attempt to highlight ""
+    if (aHighlight && !word)
+      return;
 
-        // Make sure the FAYT keypress listener is attached by initializing the
-        // browser property
-        if (this.getAttribute("browserid"))
-          setTimeout(function(aSelf) { aSelf.browser = aSelf.browser; }, 0, this);
-      ]]></constructor>
+    this.browser.finder.highlight(aHighlight, word,
+      this._findMode == this.FIND_LINKS);
 
-      <destructor><![CDATA[
-        this.destroy();
-      ]]></destructor>
-
-      <!-- This is necessary because the destructor isn't called when
-           we are removed from a document that is not destroyed. This
-           needs to be explicitly called in this case -->
-      <method name="destroy">
-        <body><![CDATA[
-          if (this._destroyed)
-            return;
-          this._destroyed = true;
+    // Update the matches count
+    this._updateMatchesCount(this.nsITypeAheadFind.FIND_FOUND);
+  }
 
-          if (this.browser && this.browser.finder)
-            this.browser.finder.destroy();
-
-          this.browser = null;
-
-          let prefsvc = this._prefsvc;
-          prefsvc.removeObserver("accessibility.typeaheadfind",
-                                 this._observer);
-          prefsvc.removeObserver("accessibility.typeaheadfind.linksonly",
-                                 this._observer);
-          prefsvc.removeObserver("accessibility.typeaheadfind.casesensitive",
-                                 this._observer);
-          prefsvc.removeObserver("findbar.entireword", this._observer);
-          prefsvc.removeObserver("findbar.highlightAll", this._observer);
-          prefsvc.removeObserver("findbar.modalHighlight", this._observer);
-
-          // Clear all timers that might still be running.
-          this._cancelTimers();
-        ]]></body>
-      </method>
+  /**
+   * - Updates the highlight-all mode of the findbar and its UI.
+   * - @param aHighlight (boolean)
+   * -        Whether to turn the highlight on or off.
+   * - @param aFromPrefObserver (boolean)
+   * -        Whether the callee is the pref observer, which means we should
+   * -        not set the same pref again.
+   */
+  _setHighlightAll(aHighlight, aFromPrefObserver) {
+    if (typeof aHighlight != "boolean") {
+      aHighlight = this._highlightAll;
+    }
+    if (aHighlight !== this._highlightAll && !aFromPrefObserver) {
+      this._prefsvc.setBoolPref("findbar.highlightAll", aHighlight);
+    }
+    this._highlightAll = aHighlight;
+    let checkbox = this.getElement("highlight");
+    checkbox.checked = this._highlightAll;
+  }
 
-      <method name="_cancelTimers">
-        <body><![CDATA[
-          if (this._flashFindBarTimeout) {
-            clearInterval(this._flashFindBarTimeout);
-            this._flashFindBarTimeout = null;
-          }
-          if (this._quickFindTimeout) {
-            clearTimeout(this._quickFindTimeout);
-            this._quickFindTimeout = null;
-          }
-          if (this._findResetTimeout) {
-            clearTimeout(this._findResetTimeout);
-            this._findResetTimeout = null;
-          }
-        ]]></body>
-      </method>
+  /**
+   * - Updates the case-sensitivity mode of the findbar and its UI.
+   * - @param [optional] aString
+   * -        The string for which case sensitivity might be turned on.
+   * -        This only used when case-sensitivity is in auto mode,
+   * -        @see _shouldBeCaseSensitive. The default value for this
+   * -        parameter is the find-field value.
+   */
+  _updateCaseSensitivity(aString) {
+    let val = aString || this._findField.value;
 
-      <method name="_setFindCloseTimeout">
-        <body><![CDATA[
-          if (this._quickFindTimeout)
-            clearTimeout(this._quickFindTimeout);
+    let caseSensitive = this._shouldBeCaseSensitive(val);
+    let checkbox = this.getElement("find-case-sensitive");
+    let statusLabel = this.getElement("match-case-status");
+    checkbox.checked = caseSensitive;
+
+    statusLabel.value = caseSensitive ? this._caseSensitiveStr : "";
 
-          // Don't close the find toolbar while IME is composing OR when the
-          // findbar is already hidden.
-          if (this._isIMEComposing || this.hidden) {
-            this._quickFindTimeout = null;
-            this._updateBrowserWithState();
-            return;
-          }
+    // Show the checkbox on the full Find bar in non-auto mode.
+    // Show the label in all other cases.
+    let hideCheckbox = this._findMode != this.FIND_NORMAL ||
+      (this._typeAheadCaseSensitive != 0 &&
+        this._typeAheadCaseSensitive != 1);
+    checkbox.hidden = hideCheckbox;
+    statusLabel.hidden = !hideCheckbox;
 
-          this._quickFindTimeout = setTimeout(() => {
-             if (this._findMode != this.FIND_NORMAL)
-               this.close();
-             this._quickFindTimeout = null;
-           }, this._quickFindTimeoutLength);
-          this._updateBrowserWithState();
-        ]]></body>
-      </method>
+    this.browser.finder.caseSensitive = caseSensitive;
+  }
 
-      <field name="_pluralForm">null</field>
-      <property name="pluralForm">
-        <getter><![CDATA[
-          if (!this._pluralForm) {
-            this._pluralForm = ChromeUtils.import(
-                               "resource://gre/modules/PluralForm.jsm", {}).PluralForm;
-          }
-          return this._pluralForm;
-        ]]></getter>
-      </property>
+  /**
+   * - Sets the findbar case-sensitivity mode
+   * - @param aCaseSensitivity (int)
+   * -   0 - case insensitive
+   * -   1 - case sensitive
+   * -   2 - auto = case sensitive iff match string contains upper case letters
+   * -   @see _shouldBeCaseSensitive
+   */
+  _setCaseSensitivity(aCaseSensitivity) {
+    this._typeAheadCaseSensitive = aCaseSensitivity;
+    this._updateCaseSensitivity();
+    this._findFailedString = null;
+    this._find();
 
-      <!--
-        - Updates the search match count after each find operation on a new string.
-        - @param aRes
-        -        the result of the find operation
-        -->
-      <method name="_updateMatchesCount">
-        <body><![CDATA[
-          if (!this._dispatchFindEvent("matchescount"))
-            return;
+    this._dispatchFindEvent("casesensitivitychange");
+  }
 
-          this.browser.finder.requestMatchesCount(this._findField.value,
-            this._findMode == this.FIND_LINKS);
-        ]]></body>
-      </method>
+  /**
+   * - Updates the entire-word mode of the findbar and its UI.
+   */
+  _setEntireWord() {
+    let entireWord = this._entireWord;
+    let checkbox = this.getElement("find-entire-word");
+    let statusLabel = this.getElement("entire-word-status");
+    checkbox.checked = entireWord;
 
-      <!--
-        - Turns highlight on or off.
-        - @param aHighlight (boolean)
-        -        Whether to turn the highlight on or off
-        - @param aFromPrefObserver (boolean)
-        -        Whether the callee is the pref observer, which means we should
-        -        not set the same pref again.
-        -->
-      <method name="toggleHighlight">
-        <parameter name="aHighlight"/>
-        <parameter name="aFromPrefObserver"/>
-        <body><![CDATA[
-          if (aHighlight === this._highlightAll) {
-            return;
-          }
+    statusLabel.value = entireWord ? this._entireWordStr : "";
 
-          this.browser.finder.onHighlightAllChange(aHighlight);
+    // Show the checkbox on the full Find bar in non-auto mode.
+    // Show the label in all other cases.
+    let hideCheckbox = this._findMode != this.FIND_NORMAL;
+    checkbox.hidden = hideCheckbox;
+    statusLabel.hidden = !hideCheckbox;
 
-          this._setHighlightAll(aHighlight, aFromPrefObserver);
+    this.browser.finder.entireWord = entireWord;
+  }
 
-          if (!this._dispatchFindEvent("highlightallchange")) {
-            return;
-          }
+  /**
+   * - Sets the findbar entire-word mode
+   * - @param aEntireWord (boolean)
+   * - Whether or not entire-word mode should be turned on.
+   */
+  toggleEntireWord(aEntireWord, aFromPrefObserver) {
+    if (!aFromPrefObserver) {
+      // Just set the pref; our observer will change the find bar behavior.
+      this._prefsvc.setBoolPref("findbar.entireword", aEntireWord);
+      return;
+    }
 
-          let word = this._findField.value;
-          // Bug 429723. Don't attempt to highlight ""
-          if (aHighlight && !word)
-            return;
+    this._findFailedString = null;
+    this._find();
+  }
 
-          this.browser.finder.highlight(aHighlight, word,
-            this._findMode == this.FIND_LINKS);
-
-          // Update the matches count
-          this._updateMatchesCount(this.nsITypeAheadFind.FIND_FOUND);
-        ]]></body>
-      </method>
+  /**
+   * - Opens and displays the find bar.
+   * -
+   * - @param aMode
+   * -        the find mode to be used, which is either FIND_NORMAL,
+   * -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last
+   * -        find mode if any or FIND_NORMAL.
+   * - @returns true if the find bar wasn't previously open, false otherwise.
+   */
+  open(aMode) {
+    if (aMode != undefined)
+      this._findMode = aMode;
 
-      <!--
-        - Updates the highlight-all mode of the findbar and its UI.
-        - @param aHighlight (boolean)
-        -        Whether to turn the highlight on or off.
-        - @param aFromPrefObserver (boolean)
-        -        Whether the callee is the pref observer, which means we should
-        -        not set the same pref again.
-        -->
-      <method name="_setHighlightAll">
-        <parameter name="aHighlight"/>
-        <parameter name="aFromPrefObserver"/>
-        <body><![CDATA[
-          if (typeof aHighlight != "boolean") {
-            aHighlight = this._highlightAll;
-          }
-          if (aHighlight !== this._highlightAll && !aFromPrefObserver) {
-            this._prefsvc.setBoolPref("findbar.highlightAll", aHighlight);
-          }
-          this._highlightAll = aHighlight;
-          let checkbox = this.getElement("highlight");
-          checkbox.checked = this._highlightAll;
-        ]]></body>
-      </method>
+    if (!this._notFoundStr) {
+      var stringsBundle = this.strBundle;
+      this._notFoundStr = stringsBundle.GetStringFromName("NotFound");
+      this._wrappedToTopStr =
+        stringsBundle.GetStringFromName("WrappedToTop");
+      this._wrappedToBottomStr =
+        stringsBundle.GetStringFromName("WrappedToBottom");
+      this._normalFindStr =
+        stringsBundle.GetStringFromName("NormalFind");
+      this._fastFindStr =
+        stringsBundle.GetStringFromName("FastFind");
+      this._fastFindLinksStr =
+        stringsBundle.GetStringFromName("FastFindLinks");
+      this._caseSensitiveStr =
+        stringsBundle.GetStringFromName("CaseSensitive");
+      this._entireWordStr =
+        stringsBundle.GetStringFromName("EntireWord");
+    }
 
-      <!--
-        - Updates the case-sensitivity mode of the findbar and its UI.
-        - @param [optional] aString
-        -        The string for which case sensitivity might be turned on.
-        -        This only used when case-sensitivity is in auto mode,
-        -        @see _shouldBeCaseSensitive. The default value for this
-        -        parameter is the find-field value.
-        -->
-      <method name="_updateCaseSensitivity">
-        <parameter name="aString"/>
-        <body><![CDATA[
-          let val = aString || this._findField.value;
+    this._findFailedString = null;
+
+    this._updateFindUI();
+    if (this.hidden) {
+      this.removeAttribute("noanim");
+      this.hidden = false;
 
-          let caseSensitive = this._shouldBeCaseSensitive(val);
-          let checkbox = this.getElement("find-case-sensitive");
-          let statusLabel = this.getElement("match-case-status");
-          checkbox.checked = caseSensitive;
-
-          statusLabel.value = caseSensitive ? this._caseSensitiveStr : "";
+      this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
 
-          // Show the checkbox on the full Find bar in non-auto mode.
-          // Show the label in all other cases.
-          let hideCheckbox = this._findMode != this.FIND_NORMAL ||
-            (this._typeAheadCaseSensitive != 0 &&
-             this._typeAheadCaseSensitive != 1);
-          checkbox.hidden = hideCheckbox;
-          statusLabel.hidden = !hideCheckbox;
+      let event = document.createEvent("Events");
+      event.initEvent("findbaropen", true, false);
+      this.dispatchEvent(event);
 
-          this.browser.finder.caseSensitive = caseSensitive;
-        ]]></body>
-      </method>
+      this.browser.finder.onFindbarOpen();
 
-      <!--
-        - Sets the findbar case-sensitivity mode
-        - @param aCaseSensitivity (int)
-        -   0 - case insensitive
-        -   1 - case sensitive
-        -   2 - auto = case sensitive iff match string contains upper case letters
-        -   @see _shouldBeCaseSensitive
-        -->
-      <method name="_setCaseSensitivity">
-        <parameter name="aCaseSensitivity"/>
-        <body><![CDATA[
-          this._typeAheadCaseSensitive = aCaseSensitivity;
-          this._updateCaseSensitivity();
-          this._findFailedString = null;
-          this._find();
+      return true;
+    }
+    return false;
+  }
 
-          this._dispatchFindEvent("casesensitivitychange");
-        ]]></body>
-      </method>
+  /**
+   * - Closes the findbar.
+   */
+  close(aNoAnim) {
+    if (this.hidden)
+      return;
 
-      <!--
-        - Updates the entire-word mode of the findbar and its UI.
-        -->
-      <method name="_setEntireWord">
-        <body><![CDATA[
-          let entireWord = this._entireWord;
-          let checkbox = this.getElement("find-entire-word");
-          let statusLabel = this.getElement("entire-word-status");
-          checkbox.checked = entireWord;
+    if (aNoAnim)
+      this.setAttribute("noanim", true);
+    this.hidden = true;
 
-          statusLabel.value = entireWord ? this._entireWordStr : "";
+    // 'focusContent()' iterates over all listeners in the chrome
+    // process, so we need to call it from here.
+    this.browser.finder.focusContent();
+    this.browser.finder.onFindbarClose();
 
-          // Show the checkbox on the full Find bar in non-auto mode.
-          // Show the label in all other cases.
-          let hideCheckbox = this._findMode != this.FIND_NORMAL;
-          checkbox.hidden = hideCheckbox;
-          statusLabel.hidden = !hideCheckbox;
+    this._cancelTimers();
+    this._updateBrowserWithState();
 
-          this.browser.finder.entireWord = entireWord;
-        ]]></body>
-      </method>
+    this._findFailedString = null;
+  }
 
-      <!--
-        - Sets the findbar entire-word mode
-        - @param aEntireWord (boolean)
-        - Whether or not entire-word mode should be turned on.
-        -->
-      <method name="toggleEntireWord">
-        <parameter name="aEntireWord"/>
-        <parameter name="aFromPrefObserver"/>
-        <body><![CDATA[
-          if (!aFromPrefObserver) {
-            // Just set the pref; our observer will change the find bar behavior.
-            this._prefsvc.setBoolPref("findbar.entireword", aEntireWord);
-            return;
-          }
+  clear() {
+    this.browser.finder.removeSelection();
+    this._findField.reset();
+    this.toggleHighlight(false);
+    this._updateStatusUI();
+    this._enableFindButtons(false);
+  }
 
-          this._findFailedString = null;
-          this._find();
-        ]]></body>
-      </method>
+  _dispatchKeypressEvent(aTarget, fakeEvent) {
+    if (!aTarget)
+      return;
+
+    // The event information comes from the child process. If we need more
+    // properties/information here, change the list of sent properties in
+    // browser-content.js
+    let event = new aTarget.ownerGlobal.KeyboardEvent(fakeEvent.type, fakeEvent);
+    aTarget.dispatchEvent(event);
+  }
 
-      <field name="_strBundle">null</field>
-      <property name="strBundle">
-        <getter><![CDATA[
-          if (!this._strBundle) {
-            this._strBundle =
-              Cc["@mozilla.org/intl/stringbundle;1"]
-                .getService(Ci.nsIStringBundleService)
-                .createBundle("chrome://global/locale/findbar.properties");
-          }
-          return this._strBundle;
-        ]]></getter>
-      </property>
+  _updateStatusUIBar(aFoundURL) {
+    if (!this._xulBrowserWindow) {
+      try {
+        this._xulBrowserWindow =
+          window.QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIWebNavigation)
+          .QueryInterface(Ci.nsIDocShellTreeItem)
+          .treeOwner
+          .QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIXULWindow)
+          .XULBrowserWindow;
+      } catch (ex) {}
+      if (!this._xulBrowserWindow)
+        return false;
+    }
 
-      <!--
-        - Opens and displays the find bar.
-        -
-        - @param aMode
-        -        the find mode to be used, which is either FIND_NORMAL,
-        -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last
-        -        find mode if any or FIND_NORMAL.
-        - @returns true if the find bar wasn't previously open, false otherwise.
-        -->
-      <method name="open">
-        <parameter name="aMode"/>
-        <body><![CDATA[
-          if (aMode != undefined)
-            this._findMode = aMode;
+    // Call this has the same effect like hovering over link,
+    // the browser shows the URL as a tooltip.
+    this._xulBrowserWindow.setOverLink(aFoundURL || "", null);
+    return true;
+  }
 
-          if (!this._notFoundStr) {
-            var stringsBundle = this.strBundle;
-            this._notFoundStr = stringsBundle.GetStringFromName("NotFound");
-            this._wrappedToTopStr =
-              stringsBundle.GetStringFromName("WrappedToTop");
-            this._wrappedToBottomStr =
-              stringsBundle.GetStringFromName("WrappedToBottom");
-            this._normalFindStr =
-              stringsBundle.GetStringFromName("NormalFind");
-            this._fastFindStr =
-              stringsBundle.GetStringFromName("FastFind");
-            this._fastFindLinksStr =
-              stringsBundle.GetStringFromName("FastFindLinks");
-            this._caseSensitiveStr =
-              stringsBundle.GetStringFromName("CaseSensitive");
-            this._entireWordStr =
-              stringsBundle.GetStringFromName("EntireWord");
-          }
+  _finishFAYT(aKeypressEvent) {
+    this.browser.finder.focusContent();
+
+    if (aKeypressEvent)
+      aKeypressEvent.preventDefault();
+
+    this.browser.finder.keyPress(aKeypressEvent);
 
-          this._findFailedString = null;
-
-          this._updateFindUI();
-          if (this.hidden) {
-            this.removeAttribute("noanim");
-            this.hidden = false;
+    this.close();
+    return true;
+  }
 
-            this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
+  _shouldBeCaseSensitive(aString) {
+    if (this._typeAheadCaseSensitive == 0)
+      return false;
+    if (this._typeAheadCaseSensitive == 1)
+      return true;
 
-            let event = document.createEvent("Events");
-            event.initEvent("findbaropen", true, false);
-            this.dispatchEvent(event);
-
-            this.browser.finder.onFindbarOpen();
+    return aString != aString.toLowerCase();
+  }
 
-            return true;
-          }
-          return false;
-        ]]></body>
-      </method>
+  /**
+   * We get a fake event object through an IPC message when FAYT is being used
+   * from within the browser. We then stuff that input in the find bar here.
+   */
+  _onBrowserKeypress(aFakeEvent) {
+    const FAYT_LINKS_KEY = "'";
+    const FAYT_TEXT_KEY = "/";
 
-      <!--
-        - Closes the findbar.
-        -->
-      <method name="close">
-        <parameter name="aNoAnim"/>
-        <body><![CDATA[
-          if (this.hidden)
-            return;
-
-          if (aNoAnim)
-            this.setAttribute("noanim", true);
-          this.hidden = true;
+    if (!this.hidden && this._findField.inputField == document.activeElement) {
+      this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
+      return;
+    }
 
-          // 'focusContent()' iterates over all listeners in the chrome
-          // process, so we need to call it from here.
-          this.browser.finder.focusContent();
-          this.browser.finder.onFindbarClose();
-
-          this._cancelTimers();
-          this._updateBrowserWithState();
+    if (this._findMode != this.FIND_NORMAL && this._quickFindTimeout) {
+      this._findField.select();
+      this._findField.focus();
+      this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
+      return;
+    }
 
-          this._findFailedString = null;
-        ]]></body>
-      </method>
-
-      <method name="clear">
-        <body><![CDATA[
-          this.browser.finder.removeSelection();
-          this._findField.reset();
-          this.toggleHighlight(false);
-          this._updateStatusUI();
-          this._enableFindButtons(false);
-        ]]></body>
-      </method>
+    let key = aFakeEvent.charCode ? String.fromCharCode(aFakeEvent.charCode) : null;
+    let manualstartFAYT = (key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY);
+    let autostartFAYT = !manualstartFAYT && this._findAsYouType &&
+      key && key != " ";
+    if (manualstartFAYT || autostartFAYT) {
+      let mode = (key == FAYT_LINKS_KEY ||
+          (autostartFAYT && this._typeAheadLinksOnly)) ?
+        this.FIND_LINKS : this.FIND_TYPEAHEAD;
 
-      <method name="_dispatchKeypressEvent">
-        <parameter name="aTarget"/>
-        <parameter name="fakeEvent"/>
-        <body><![CDATA[
-          if (!aTarget)
-            return;
-
-          // The event information comes from the child process. If we need more
-          // properties/information here, change the list of sent properties in
-          // browser-content.js
-          let event = new aTarget.ownerGlobal.KeyboardEvent(fakeEvent.type, fakeEvent);
-          aTarget.dispatchEvent(event);
-        ]]></body>
-      </method>
+      // Clear bar first, so that when openFindBar() calls setCaseSensitivity()
+      // it doesn't get confused by a lingering value
+      this._findField.value = "";
 
-      <field name="_xulBrowserWindow">null</field>
-      <method name="_updateStatusUIBar">
-        <parameter name="aFoundURL"/>
-        <body><![CDATA[
-          if (!this._xulBrowserWindow) {
-            try {
-              this._xulBrowserWindow =
-                window.QueryInterface(Ci.nsIInterfaceRequestor)
-                      .getInterface(Ci.nsIWebNavigation)
-                      .QueryInterface(Ci.nsIDocShellTreeItem)
-                      .treeOwner
-                      .QueryInterface(Ci.nsIInterfaceRequestor)
-                      .getInterface(Ci.nsIXULWindow)
-                      .XULBrowserWindow;
-            } catch (ex) { }
-            if (!this._xulBrowserWindow)
-              return false;
-          }
+      this.open(mode);
+      this._setFindCloseTimeout();
+      this._findField.select();
+      this._findField.focus();
 
-          // Call this has the same effect like hovering over link,
-          // the browser shows the URL as a tooltip.
-          this._xulBrowserWindow.setOverLink(aFoundURL || "", null);
-          return true;
-        ]]></body>
-      </method>
+      if (autostartFAYT)
+        this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
+      else
+        this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
+    }
+  }
 
-      <method name="_finishFAYT">
-        <parameter name="aKeypressEvent"/>
-        <body><![CDATA[
-          this.browser.finder.focusContent();
-
-          if (aKeypressEvent)
-            aKeypressEvent.preventDefault();
-
-          this.browser.finder.keyPress(aKeypressEvent);
-
+  /**
+   * See MessageListener
+   */
+  receiveMessage(aMessage) {
+    if (aMessage.target != this._browser) {
+      return undefined;
+    }
+    switch (aMessage.name) {
+      case "Findbar:Mouseup":
+        if (!this.hidden && this._findMode != this.FIND_NORMAL)
           this.close();
-          return true;
-        ]]></body>
-      </method>
-
-      <method name="_shouldBeCaseSensitive">
-        <parameter name="aString"/>
-        <body><![CDATA[
-          if (this._typeAheadCaseSensitive == 0)
-            return false;
-          if (this._typeAheadCaseSensitive == 1)
-            return true;
+        break;
+      case "Findbar:Keypress":
+        this._onBrowserKeypress(aMessage.data);
+        break;
+    }
+    return undefined;
+  }
 
-          return aString != aString.toLowerCase();
-        ]]></body>
-      </method>
-
-      <!-- We get a fake event object through an IPC message when FAYT is being used
-           from within the browser. We then stuff that input in the find bar here. -->
-      <method name="_onBrowserKeypress">
-        <parameter name="aFakeEvent"/>
-        <body><![CDATA[
-          const FAYT_LINKS_KEY = "'";
-          const FAYT_TEXT_KEY = "/";
+  _updateBrowserWithState() {
+    if (this._browser && this._browser.messageManager) {
+      this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", {
+        findMode: this._findMode,
+        isOpenAndFocused: !this.hidden && document.activeElement == this._findField.inputField,
+        hasQuickFindTimeout: !!this._quickFindTimeout,
+      });
+    }
+  }
 
-          if (!this.hidden && this._findField.inputField == document.activeElement) {
-            this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
-            return;
-          }
+  _enableFindButtons(aEnable) {
+    this.getElement("find-next").disabled =
+      this.getElement("find-previous").disabled = !aEnable;
+  }
 
-          if (this._findMode != this.FIND_NORMAL && this._quickFindTimeout) {
-            this._findField.select();
-            this._findField.focus();
-            this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
-            return;
-          }
+  /**
+   * - Determines whether minimalist or general-purpose search UI is to be
+   * - displayed when the find bar is activated.
+   */
+  _updateFindUI() {
+    let showMinimalUI = this._findMode != this.FIND_NORMAL;
 
-          let key = aFakeEvent.charCode ? String.fromCharCode(aFakeEvent.charCode) : null;
-          let manualstartFAYT = (key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY);
-          let autostartFAYT = !manualstartFAYT && this._findAsYouType &&
-                              key && key != " ";
-          if (manualstartFAYT || autostartFAYT) {
-            let mode = (key == FAYT_LINKS_KEY ||
-                        (autostartFAYT && this._typeAheadLinksOnly)) ?
-              this.FIND_LINKS : this.FIND_TYPEAHEAD;
-
-            // Clear bar first, so that when openFindBar() calls setCaseSensitivity()
-            // it doesn't get confused by a lingering value
-            this._findField.value = "";
+    let nodes = this.getElement("findbar-container").childNodes;
+    let wrapper = this.getElement("findbar-textbox-wrapper");
+    let foundMatches = this._foundMatches;
+    for (let node of nodes) {
+      if (node == wrapper || node == foundMatches)
+        continue;
+      node.hidden = showMinimalUI;
+    }
+    this.getElement("find-next").hidden =
+      this.getElement("find-previous").hidden = showMinimalUI;
+    foundMatches.hidden = showMinimalUI || !foundMatches.value;
+    this._updateCaseSensitivity();
+    this._setEntireWord();
+    this._setHighlightAll();
 
-            this.open(mode);
-            this._setFindCloseTimeout();
-            this._findField.select();
-            this._findField.focus();
+    if (showMinimalUI)
+      this._findField.classList.add("minimal");
+    else
+      this._findField.classList.remove("minimal");
 
-            if (autostartFAYT)
-              this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
-            else
-              this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
-          }
-        ]]></body>
-      </method>
+    if (this._findMode == this.FIND_TYPEAHEAD)
+      this._findField.placeholder = this._fastFindStr;
+    else if (this._findMode == this.FIND_LINKS)
+      this._findField.placeholder = this._fastFindLinksStr;
+    else
+      this._findField.placeholder = this._normalFindStr;
+  }
+
+  _find(aValue) {
+    if (!this._dispatchFindEvent(""))
+      return;
 
-      <!-- See MessageListener -->
-      <method name="receiveMessage">
-        <parameter name="aMessage"/>
-        <body><![CDATA[
-          if (aMessage.target != this._browser) {
-            return undefined;
-          }
-          switch (aMessage.name) {
-            case "Findbar:Mouseup":
-              if (!this.hidden && this._findMode != this.FIND_NORMAL)
-                this.close();
-              break;
-            case "Findbar:Keypress":
-              this._onBrowserKeypress(aMessage.data);
-              break;
-          }
-          return undefined;
-        ]]></body>
-      </method>
+    let val = aValue || this._findField.value;
+
+    // We have to carry around an explicit version of this,
+    // because finder.searchString doesn't update on failed
+    // searches.
+    this.browser._lastSearchString = val;
 
-      <method name="_updateBrowserWithState">
-        <body><![CDATA[
-          if (this._browser && this._browser.messageManager) {
-            this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", {
-              findMode: this._findMode,
-              isOpenAndFocused: !this.hidden && document.activeElement == this._findField.inputField,
-              hasQuickFindTimeout: !!this._quickFindTimeout,
-            });
-          }
-        ]]></body>
-      </method>
+    // Only search on input if we don't have a last-failed string,
+    // or if the current search string doesn't start with it.
+    // In entire-word mode we always attemp a find; since sequential matching
+    // is not guaranteed, the first character typed may not be a word (no
+    // match), but the with the second character it may well be a word,
+    // thus a match.
+    if (!this._findFailedString ||
+      !val.startsWith(this._findFailedString) ||
+      this._entireWord) {
+      // Getting here means the user commanded a find op. Make sure any
+      // initial prefilling is ignored if it hasn't happened yet.
+      if (this._startFindDeferred) {
+        this._startFindDeferred.resolve();
+        this._startFindDeferred = null;
+      }
 
-      <method name="_enableFindButtons">
-        <parameter name="aEnable"/>
-        <body><![CDATA[
-          this.getElement("find-next").disabled =
-            this.getElement("find-previous").disabled = !aEnable;
-        ]]></body>
-      </method>
+      this._enableFindButtons(val);
+      this._updateCaseSensitivity(val);
+      this._setEntireWord();
 
-      <!--
-        - Determines whether minimalist or general-purpose search UI is to be
-        - displayed when the find bar is activated.
-        -->
-      <method name="_updateFindUI">
-        <body><![CDATA[
-          let showMinimalUI = this._findMode != this.FIND_NORMAL;
+      this.browser.finder.fastFind(val, this._findMode == this.FIND_LINKS,
+        this._findMode != this.FIND_NORMAL);
+    }
+
+    if (this._findMode != this.FIND_NORMAL)
+      this._setFindCloseTimeout();
 
-          let nodes = this.getElement("findbar-container").childNodes;
-          let wrapper = this.getElement("findbar-textbox-wrapper");
-          let foundMatches = this._foundMatches;
-          for (let node of nodes) {
-            if (node == wrapper || node == foundMatches)
-               continue;
-            node.hidden = showMinimalUI;
-          }
-          this.getElement("find-next").hidden =
-            this.getElement("find-previous").hidden = showMinimalUI;
-          foundMatches.hidden = showMinimalUI || !foundMatches.value;
-          this._updateCaseSensitivity();
-          this._setEntireWord();
-          this._setHighlightAll();
+    if (this._findResetTimeout != -1)
+      clearTimeout(this._findResetTimeout);
 
-          if (showMinimalUI)
-            this._findField.classList.add("minimal");
-          else
-            this._findField.classList.remove("minimal");
+    // allow a search to happen on input again after a second has
+    // expired since the previous input, to allow for dynamic
+    // content and/or page loading
+    this._findResetTimeout = setTimeout(() => {
+      this._findFailedString = null;
+      this._findResetTimeout = -1;
+    }, 1000);
+  }
 
-          if (this._findMode == this.FIND_TYPEAHEAD)
-            this._findField.placeholder = this._fastFindStr;
-          else if (this._findMode == this.FIND_LINKS)
-            this._findField.placeholder = this._fastFindLinksStr;
-          else
-            this._findField.placeholder = this._normalFindStr;
-        ]]></body>
-      </method>
+  _flash() {
+    if (this._flashFindBarCount === undefined)
+      this._flashFindBarCount = this._initialFlashFindBarCount;
 
-      <method name="_find">
-        <parameter name="aValue"/>
-        <body><![CDATA[
-          if (!this._dispatchFindEvent(""))
-            return;
+    if (this._flashFindBarCount-- == 0) {
+      clearInterval(this._flashFindBarTimeout);
+      this._findField.removeAttribute("flash");
+      this._flashFindBarCount = 6;
+      return;
+    }
 
-          let val = aValue || this._findField.value;
-
-          // We have to carry around an explicit version of this,
-          // because finder.searchString doesn't update on failed
-          // searches.
-          this.browser._lastSearchString = val;
+    this._findField.setAttribute("flash",
+      (this._flashFindBarCount % 2 == 0) ?
+      "false" : "true");
+  }
 
-          // Only search on input if we don't have a last-failed string,
-          // or if the current search string doesn't start with it.
-          // In entire-word mode we always attemp a find; since sequential matching
-          // is not guaranteed, the first character typed may not be a word (no
-          // match), but the with the second character it may well be a word,
-          // thus a match.
-          if (!this._findFailedString ||
-              !val.startsWith(this._findFailedString) ||
-              this._entireWord) {
-            // Getting here means the user commanded a find op. Make sure any
-            // initial prefilling is ignored if it hasn't happened yet.
-            if (this._startFindDeferred) {
-              this._startFindDeferred.resolve();
-              this._startFindDeferred = null;
-            }
-
-            this._enableFindButtons(val);
-            this._updateCaseSensitivity(val);
-            this._setEntireWord();
-
-            this.browser.finder.fastFind(val, this._findMode == this.FIND_LINKS,
-                                         this._findMode != this.FIND_NORMAL);
-          }
-
-          if (this._findMode != this.FIND_NORMAL)
-            this._setFindCloseTimeout();
+  _findAgain(aFindPrevious) {
+    this.browser.finder.findAgain(aFindPrevious,
+      this._findMode == this.FIND_LINKS,
+      this._findMode != this.FIND_NORMAL);
+  }
 
-          if (this._findResetTimeout != -1)
-            clearTimeout(this._findResetTimeout);
-
-          // allow a search to happen on input again after a second has
-          // expired since the previous input, to allow for dynamic
-          // content and/or page loading
-          this._findResetTimeout = setTimeout(() => {
-            this._findFailedString = null;
-            this._findResetTimeout = -1;
-          }, 1000);
-        ]]></body>
-      </method>
+  _updateStatusUI(res, aFindPrevious) {
+    switch (res) {
+      case this.nsITypeAheadFind.FIND_WRAPPED:
+        this._findStatusIcon.setAttribute("status", "wrapped");
+        this._findStatusDesc.textContent =
+          aFindPrevious ? this._wrappedToBottomStr : this._wrappedToTopStr;
+        this._findField.removeAttribute("status");
+        break;
+      case this.nsITypeAheadFind.FIND_NOTFOUND:
+        this._findStatusIcon.setAttribute("status", "notfound");
+        this._findStatusDesc.textContent = this._notFoundStr;
+        this._findField.setAttribute("status", "notfound");
+        break;
+      case this.nsITypeAheadFind.FIND_PENDING:
+        this._findStatusIcon.setAttribute("status", "pending");
+        this._findStatusDesc.textContent = "";
+        this._findField.removeAttribute("status");
+        break;
+      case this.nsITypeAheadFind.FIND_FOUND:
+      default:
+        this._findStatusIcon.removeAttribute("status");
+        this._findStatusDesc.textContent = "";
+        this._findField.removeAttribute("status");
+        break;
+    }
+  }
 
-      <method name="_flash">
-        <body><![CDATA[
-          if (this._flashFindBarCount === undefined)
-            this._flashFindBarCount = this._initialFlashFindBarCount;
-
-          if (this._flashFindBarCount-- == 0) {
-            clearInterval(this._flashFindBarTimeout);
-            this.removeAttribute("flash");
-            this._flashFindBarCount = 6;
-            return;
-          }
-
-          this.setAttribute("flash",
-                            (this._flashFindBarCount % 2 == 0) ?
-                            "false" : "true");
-        ]]></body>
-      </method>
+  updateControlState(aResult, aFindPrevious) {
+    this._updateStatusUI(aResult, aFindPrevious);
+    this._enableFindButtons(aResult !== this.nsITypeAheadFind.FIND_NOTFOUND &&
+      !!this._findField.value);
+  }
 
-      <method name="_findAgain">
-        <parameter name="aFindPrevious"/>
-        <body><![CDATA[
-          this.browser.finder.findAgain(aFindPrevious,
-                                        this._findMode == this.FIND_LINKS,
-                                        this._findMode != this.FIND_NORMAL);
-        ]]></body>
-      </method>
+  _dispatchFindEvent(aType, aFindPrevious) {
+    let event = document.createEvent("CustomEvent");
+    event.initCustomEvent("find" + aType, true, true, {
+      query: this._findField.value,
+      caseSensitive: !!this._typeAheadCaseSensitive,
+      entireWord: this._entireWord,
+      highlightAll: this._highlightAll,
+      findPrevious: aFindPrevious
+    });
+    return this.dispatchEvent(event);
+  }
 
-      <method name="_updateStatusUI">
-        <parameter name="res"/>
-        <parameter name="aFindPrevious"/>
-        <body><![CDATA[
-          switch (res) {
-            case this.nsITypeAheadFind.FIND_WRAPPED:
-              this._findStatusIcon.setAttribute("status", "wrapped");
-              this._findStatusDesc.textContent =
-                aFindPrevious ? this._wrappedToBottomStr : this._wrappedToTopStr;
-              this._findField.removeAttribute("status");
-              break;
-            case this.nsITypeAheadFind.FIND_NOTFOUND:
-              this._findStatusIcon.setAttribute("status", "notfound");
-              this._findStatusDesc.textContent = this._notFoundStr;
-              this._findField.setAttribute("status", "notfound");
-              break;
-            case this.nsITypeAheadFind.FIND_PENDING:
-              this._findStatusIcon.setAttribute("status", "pending");
-              this._findStatusDesc.textContent = "";
-              this._findField.removeAttribute("status");
-              break;
-            case this.nsITypeAheadFind.FIND_FOUND:
-            default:
-              this._findStatusIcon.removeAttribute("status");
-              this._findStatusDesc.textContent = "";
-              this._findField.removeAttribute("status");
-              break;
-          }
-        ]]></body>
-      </method>
+  /**
+   * - Opens the findbar, focuses the findfield and selects its contents.
+   * - Also flashes the findbar the first time it's used.
+   * - @param aMode
+   * -        the find mode to be used, which is either FIND_NORMAL,
+   * -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last
+   * -        find mode if any or FIND_NORMAL.
+   */
+  startFind(aMode) {
+    let prefsvc = this._prefsvc;
+    let userWantsPrefill = true;
+    this.open(aMode);
 
-      <method name="updateControlState">
-        <parameter name="aResult"/>
-        <parameter name="aFindPrevious"/>
-        <body><![CDATA[
-          this._updateStatusUI(aResult, aFindPrevious);
-          this._enableFindButtons(aResult !== this.nsITypeAheadFind.FIND_NOTFOUND &&
-            !!this._findField.value);
-        ]]></body>
-      </method>
+    if (this._flashFindBar) {
+      this._flashFindBarTimeout = setInterval(() => this._flash(), 500);
+      prefsvc.setIntPref("accessibility.typeaheadfind.flashBar",
+        --this._flashFindBar);
+    }
+
+    let { PromiseUtils } =
+    ChromeUtils.import("resource://gre/modules/PromiseUtils.jsm", {});
+    this._startFindDeferred = PromiseUtils.defer();
+    let startFindPromise = this._startFindDeferred.promise;
+
+    if (this.prefillWithSelection)
+      userWantsPrefill =
+      prefsvc.getBoolPref("accessibility.typeaheadfind.prefillwithselection");
 
-      <method name="_dispatchFindEvent">
-        <parameter name="aType"/>
-        <parameter name="aFindPrevious"/>
-        <body><![CDATA[
-          let event = document.createEvent("CustomEvent");
-          event.initCustomEvent("find" + aType, true, true, {
-            query: this._findField.value,
-            caseSensitive: !!this._typeAheadCaseSensitive,
-            entireWord: this._entireWord,
-            highlightAll: this._highlightAll,
-            findPrevious: aFindPrevious
-          });
-          return this.dispatchEvent(event);
-        ]]></body>
-      </method>
+    if (this.prefillWithSelection && userWantsPrefill) {
+      // NB: We have to focus this._findField here so tests that send
+      // key events can open and close the find bar synchronously.
+      this._findField.focus();
 
+      // (e10s) since we focus lets also select it, otherwise that would
+      // only happen in this.onCurrentSelection and, because it is async,
+      // there's a chance keypresses could come inbetween, leading to
+      // jumbled up queries.
+      this._findField.select();
 
-      <!--
-        - Opens the findbar, focuses the findfield and selects its contents.
-        - Also flashes the findbar the first time it's used.
-        - @param aMode
-        -        the find mode to be used, which is either FIND_NORMAL,
-        -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last
-        -        find mode if any or FIND_NORMAL.
-        -->
-      <method name="startFind">
-        <parameter name="aMode"/>
-        <body><![CDATA[
-          let prefsvc = this._prefsvc;
-          let userWantsPrefill = true;
-          this.open(aMode);
+      this.browser.finder.getInitialSelection();
+      return startFindPromise;
+    }
 
-          if (this._flashFindBar) {
-            this._flashFindBarTimeout = setInterval(() => this._flash(), 500);
-            prefsvc.setIntPref("accessibility.typeaheadfind.flashBar",
-                               --this._flashFindBar);
-          }
-
-          let {PromiseUtils} =
-            ChromeUtils.import("resource://gre/modules/PromiseUtils.jsm", {});
-          this._startFindDeferred = PromiseUtils.defer();
-          let startFindPromise = this._startFindDeferred.promise;
-
-          if (this.prefillWithSelection)
-            userWantsPrefill =
-              prefsvc.getBoolPref("accessibility.typeaheadfind.prefillwithselection");
+    // If userWantsPrefill is false but prefillWithSelection is true,
+    // then we might need to check the selection clipboard. Call
+    // onCurrentSelection to do so.
+    // Note: this.onCurrentSelection clears this._startFindDeferred.
+    this.onCurrentSelection("", true);
+    return startFindPromise;
+  }
 
-          if (this.prefillWithSelection && userWantsPrefill) {
-            // NB: We have to focus this._findField here so tests that send
-            // key events can open and close the find bar synchronously.
-            this._findField.focus();
-
-            // (e10s) since we focus lets also select it, otherwise that would
-            // only happen in this.onCurrentSelection and, because it is async,
-            // there's a chance keypresses could come inbetween, leading to
-            // jumbled up queries.
-            this._findField.select();
+  /**
+   * - Convenient alias to startFind(gFindBar.FIND_NORMAL);
+   * -
+   * - You should generally map the window's find command to this method.
+   * -   e.g. <command name="cmd_find" oncommand="gFindBar.onFindCommand();"/>
+   */
+  onFindCommand() {
+    return this.startFind(this.FIND_NORMAL);
+  }
 
-            this.browser.finder.getInitialSelection();
-            return startFindPromise;
-          }
-
-          // If userWantsPrefill is false but prefillWithSelection is true,
-          // then we might need to check the selection clipboard. Call
-          // onCurrentSelection to do so.
-          // Note: this.onCurrentSelection clears this._startFindDeferred.
-          this.onCurrentSelection("", true);
-          return startFindPromise;
-        ]]></body>
-      </method>
+  /**
+   * - Stub for find-next and find-previous commands
+   * - @param aFindPrevious
+   * -        true for find-previous, false otherwise.
+   */
+  onFindAgainCommand(aFindPrevious) {
+    let findString = this._browser.finder.searchString || this._findField.value;
+    if (!findString)
+      return this.startFind();
 
-      <!--
-        - Convenient alias to startFind(gFindBar.FIND_NORMAL);
-        -
-        - You should generally map the window's find command to this method.
-        -   e.g. <command name="cmd_find" oncommand="gFindBar.onFindCommand();"/>
-        -->
-      <method name="onFindCommand">
-        <body><![CDATA[
-          return this.startFind(this.FIND_NORMAL);
-        ]]></body>
-      </method>
+    // We dispatch the findAgain event here instead of in _findAgain since
+    // if there is a find event handler that prevents the default then
+    // finder.searchString will never get updated which in turn means
+    // there would never be findAgain events because of the logic below.
+    if (!this._dispatchFindEvent("again", aFindPrevious))
+      return undefined;
 
-      <!--
-        - Stub for find-next and find-previous commands
-        - @param aFindPrevious
-        -        true for find-previous, false otherwise.
-        -->
-      <method name="onFindAgainCommand">
-        <parameter name="aFindPrevious"/>
-        <body><![CDATA[
-          let findString = this._browser.finder.searchString || this._findField.value;
-          if (!findString)
-            return this.startFind();
+    // user explicitly requested another search, so do it even if we think it'll fail
+    this._findFailedString = null;
 
-          // We dispatch the findAgain event here instead of in _findAgain since
-          // if there is a find event handler that prevents the default then
-          // finder.searchString will never get updated which in turn means
-          // there would never be findAgain events because of the logic below.
-          if (!this._dispatchFindEvent("again", aFindPrevious))
-            return undefined;
+    // Ensure the stored SearchString is in sync with what we want to find
+    if (this._findField.value != this._browser.finder.searchString) {
+      this._find(this._findField.value);
+    } else {
+      this._findAgain(aFindPrevious);
+      if (this._useModalHighlight) {
+        this.open();
+        this._findField.focus();
+      }
+    }
 
-          // user explicitly requested another search, so do it even if we think it'll fail
-          this._findFailedString = null;
+    return undefined;
+  }
 
-          // Ensure the stored SearchString is in sync with what we want to find
-          if (this._findField.value != this._browser.finder.searchString) {
-            this._find(this._findField.value);
-          } else {
-            this._findAgain(aFindPrevious);
-            if (this._useModalHighlight) {
-              this.open();
-              this._findField.focus();
-            }
-          }
+  /* Fetches the currently selected text and sets that as the text to search
+     next. This is a MacOS specific feature. */
+  onFindSelectionCommand() {
+    let searchString = this.browser.finder.setSearchStringToSelection();
+    if (searchString)
+      this._findField.value = searchString;
 
-          return undefined;
-        ]]></body>
-      </method>
+  }
+
+  _onFindFieldFocus() {
+    let prefsvc = this._prefsvc;
+    const kPref = "accessibility.typeaheadfind.prefillwithselection";
+    if (this.prefillWithSelection && prefsvc.getBoolPref(kPref))
+      return;
 
-#ifdef XP_MACOSX
-      <!--
-        - Fetches the currently selected text and sets that as the text to search
-        - next. This is a MacOS specific feature.
-      -->
-      <method name="onFindSelectionCommand">
-        <body><![CDATA[
-          let searchString = this.browser.finder.setSearchStringToSelection();
-          if (searchString)
-            this._findField.value = searchString;
-        ]]></body>
-      </method>
-
-      <method name="_onFindFieldFocus">
-        <body><![CDATA[
-          let prefsvc = this._prefsvc;
-          const kPref = "accessibility.typeaheadfind.prefillwithselection";
-          if (this.prefillWithSelection && prefsvc.getBoolPref(kPref))
-            return;
-
-          let clipboardSearchString = this._browser.finder.clipboardSearchString;
-          if (clipboardSearchString && this._findField.value != clipboardSearchString &&
-              !this._findField._willfullyDeleted) {
-            this._findField.value = clipboardSearchString;
-            this._findField._hadValue = true;
-            // Changing the search string makes the previous status invalid, so
-            // we better clear it here.
-            this._updateStatusUI();
-          }
-        ]]></body>
-      </method>
-#endif
+    let clipboardSearchString = this._browser.finder.clipboardSearchString;
+    if (clipboardSearchString && this._findField.value != clipboardSearchString &&
+        !this._findField._willfullyDeleted) {
+      this._findField.value = clipboardSearchString;
+      this._findField._hadValue = true;
+      // Changing the search string makes the previous status invalid, so
+      // we better clear it here.
+      this._updateStatusUI();
+    }
+  }
 
-      <!--
-        - This handles all the result changes for both
-        - type-ahead-find and highlighting.
-        - @param aResult
-        -   One of the nsITypeAheadFind.FIND_* constants
-        -   indicating the result of a search operation.
-        - @param aFindBackwards
-        -   If the search was done from the bottom to
-        -   the top. This is used for right error messages
-        -   when reaching "the end of the page".
-        - @param aLinkURL
-        -   When a link matched then its URK. Always null
-        -   when not in FIND_LINKS mode.
-        -->
-      <method name="onFindResult">
-        <parameter name="aData"/>
-        <body><![CDATA[
-          if (aData.result == this.nsITypeAheadFind.FIND_NOTFOUND) {
-            // If an explicit Find Again command fails, re-open the toolbar.
-            if (aData.storeResult && this.open()) {
-              this._findField.select();
-              this._findField.focus();
-            }
-            this._findFailedString = aData.searchString;
-          } else {
-            this._findFailedString = null;
-          }
+  /**
+   * - This handles all the result changes for both
+   * - type-ahead-find and highlighting.
+   * - @param aResult
+   * -   One of the nsITypeAheadFind.FIND_* constants
+   * -   indicating the result of a search operation.
+   * - @param aFindBackwards
+   * -   If the search was done from the bottom to
+   * -   the top. This is used for right error messages
+   * -   when reaching "the end of the page".
+   * - @param aLinkURL
+   * -   When a link matched then its URK. Always null
+   * -   when not in FIND_LINKS mode.
+   */
+  onFindResult(aData) {
+    if (aData.result == this.nsITypeAheadFind.FIND_NOTFOUND) {
+      // If an explicit Find Again command fails, re-open the toolbar.
+      if (aData.storeResult && this.open()) {
+        this._findField.select();
+        this._findField.focus();
+      }
+      this._findFailedString = aData.searchString;
+    } else {
+      this._findFailedString = null;
+    }
 
-          this._updateStatusUI(aData.result, aData.findBackwards);
-          this._updateStatusUIBar(aData.linkURL);
+    this._updateStatusUI(aData.result, aData.findBackwards);
+    this._updateStatusUIBar(aData.linkURL);
 
-          if (this._findMode != this.FIND_NORMAL)
-            this._setFindCloseTimeout();
-        ]]></body>
-      </method>
+    if (this._findMode != this.FIND_NORMAL)
+      this._setFindCloseTimeout();
+  }
 
-      <!--
-        - This handles all the result changes for matches counts.
-        - @param aResult
-        -   Result Object, containing the total amount of matches and a vector
-        -   of the current result.
-        -->
-      <method name="onMatchesCountResult">
-        <parameter name="aResult"/>
-        <body><![CDATA[
-          if (aResult.total !== 0) {
-            if (aResult.total == -1) {
-              this._foundMatches.value = this.pluralForm.get(
-                aResult.limit,
-                this.strBundle.GetStringFromName("FoundMatchesCountLimit")
-              ).replace("#1", aResult.limit);
-            } else {
-              this._foundMatches.value = this.pluralForm.get(
-                aResult.total,
-                this.strBundle.GetStringFromName("FoundMatches")
-              ).replace("#1", aResult.current)
-               .replace("#2", aResult.total);
-            }
-            this._foundMatches.hidden = false;
-          } else {
-            this._foundMatches.hidden = true;
-            this._foundMatches.value = "";
-          }
-        ]]></body>
-      </method>
+  /**
+   * - This handles all the result changes for matches counts.
+   * - @param aResult
+   * -   Result Object, containing the total amount of matches and a vector
+   * -   of the current result.
+   */
+  onMatchesCountResult(aResult) {
+    if (aResult.total !== 0) {
+      if (aResult.total == -1) {
+        this._foundMatches.value = this.pluralForm.get(
+          aResult.limit,
+          this.strBundle.GetStringFromName("FoundMatchesCountLimit")
+        ).replace("#1", aResult.limit);
+      } else {
+        this._foundMatches.value = this.pluralForm.get(
+            aResult.total,
+            this.strBundle.GetStringFromName("FoundMatches")
+          ).replace("#1", aResult.current)
+          .replace("#2", aResult.total);
+      }
+      this._foundMatches.hidden = false;
+    } else {
+      this._foundMatches.hidden = true;
+      this._foundMatches.value = "";
+    }
+  }
 
-      <method name="onHighlightFinished">
-        <parameter name="result"/>
-        <body><![CDATA[
-          // Noop.
-        ]]></body>
-      </method>
+  onHighlightFinished(result) {
+    // Noop.
+  }
 
-      <method name="onCurrentSelection">
-        <parameter name="aSelectionString" />
-        <parameter name="aIsInitialSelection" />
-        <body><![CDATA[
-          // Ignore the prefill if the user has already typed in the findbar,
-          // it would have been overwritten anyway. See bug 1198465.
-          if (aIsInitialSelection && !this._startFindDeferred)
-            return;
+  onCurrentSelection(aSelectionString, aIsInitialSelection) {
+    // Ignore the prefill if the user has already typed in the findbar,
+    // it would have been overwritten anyway. See bug 1198465.
+    if (aIsInitialSelection && !this._startFindDeferred)
+      return;
+
+    if (/Mac/.test(window.navigator.platform) && aIsInitialSelection && !aSelectionString) {
+      let clipboardSearchString = this.browser.finder.clipboardSearchString;
+      if (clipboardSearchString)
+        aSelectionString = clipboardSearchString;
+    }
 
-          if (/Mac/.test(navigator.platform) && aIsInitialSelection && !aSelectionString) {
-            let clipboardSearchString = this.browser.finder.clipboardSearchString;
-            if (clipboardSearchString)
-              aSelectionString = clipboardSearchString;
-          }
+    if (aSelectionString)
+      this._findField.value = aSelectionString;
 
-          if (aSelectionString)
-            this._findField.value = aSelectionString;
+    if (aIsInitialSelection) {
+      this._enableFindButtons(!!this._findField.value);
+      this._findField.select();
+      this._findField.focus();
 
-          if (aIsInitialSelection) {
-            this._enableFindButtons(!!this._findField.value);
-            this._findField.select();
-            this._findField.focus();
+      this._startFindDeferred.resolve();
+      this._startFindDeferred = null;
+    }
+  }
 
-            this._startFindDeferred.resolve();
-            this._startFindDeferred = null;
-          }
-        ]]></body>
-      </method>
+  /**
+   * - This handler may cancel a request to focus content by returning |false|
+   * - explicitly.
+   */
+  shouldFocusContent() {
+    const fm = Services.focus;
+    if (fm.focusedWindow != window)
+      return false;
 
-      <!--
-        - This handler may cancel a request to focus content by returning |false|
-        - explicitly.
-        -->
-      <method name="shouldFocusContent">
-        <body><![CDATA[
-          const fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-          if (fm.focusedWindow != window)
-            return false;
+    let focusedElement = fm.focusedElement;
+    if (!focusedElement)
+      return false;
 
-          let focusedElement = fm.focusedElement;
-          if (!focusedElement)
-            return false;
+    let bindingParent = document.getBindingParent(focusedElement);
+    if (bindingParent != this && bindingParent != this._findField)
+      return false;
+
+    return true;
+  }
 
-          let bindingParent = document.getBindingParent(focusedElement);
-          if (bindingParent != this && bindingParent != this._findField)
-            return false;
-
-          return true;
-        ]]></body>
-      </method>
-
-    </implementation>
+  disconnectedCallback() {
+    // Empty the DOM. We will rebuild if reconnected.
+    while (this.lastChild) {
+      this.removeChild(this.lastChild);
+    }
+    this.destroy();
+  }
+}
 
-    <handlers>
-      <!--
-        - We have to guard against `this.close` being |null| due to an unknown
-        - issue, which is tracked in bug 957999.
-        -->
-      <handler event="keypress" keycode="VK_ESCAPE" phase="capturing"
-               action="if (this.close) this.close();" preventdefault="true"/>
-    </handlers>
-  </binding>
-</bindings>
+customElements.define("findbar", MozFindbar);
+
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -935,24 +935,19 @@ richlistitem {
 
 richlistbox > listheader {
   -moz-box-ordinal-group: 1;
 }
 
 
 /*********** findbar ************/
 findbar {
-  -moz-binding: url('chrome://global/content/bindings/findbar.xml#findbar');
   overflow-x: hidden;
 }
 
-.findbar-textbox {
-  -moz-binding: url("chrome://global/content/bindings/findbar.xml#findbar-textbox");
-}
-
 /*********** tabmodalprompt ************/
 tabmodalprompt {
   -moz-binding: url("chrome://global/content/tabprompts.xml#tabmodalprompt");
   overflow: hidden;
   text-shadow: none;
 }
 
 .button-highlightable-text:not([highlightable="true"]),
diff --git a/toolkit/locales/en-US/chrome/global/findbar.dtd b/toolkit/locales/en-US/chrome/global/findbar.dtd
deleted file mode 100644
--- a/toolkit/locales/en-US/chrome/global/findbar.dtd
+++ /dev/null
@@ -1,19 +0,0 @@
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<!-- LOCALIZATION NOTE : FILE This file contains the entities needed to -->
-<!-- LOCALIZATION NOTE : FILE use the Find Bar. --> 
-
-<!ENTITY next.tooltip "Find the next occurrence of the phrase">
-<!ENTITY previous.tooltip "Find the previous occurrence of the phrase">
-<!ENTITY findCloseButton.tooltip "Close find bar">
-<!ENTITY highlightAll.label "Highlight All">
-<!ENTITY highlightAll.accesskey "l">
-<!ENTITY highlightAll.tooltiptext "Highlight all occurrences of the phrase">
-<!ENTITY caseSensitive.label "Match Case">
-<!ENTITY caseSensitive.accesskey "c">
-<!ENTITY caseSensitive.tooltiptext "Search with case sensitivity">
-<!ENTITY entireWord.label "Whole Words">
-<!ENTITY entireWord.accesskey "w">
-<!ENTITY entireWord.tooltiptext "Search whole words only">
diff --git a/toolkit/locales/en-US/toolkit/main-window/findbar.ftl b/toolkit/locales/en-US/toolkit/main-window/findbar.ftl
new file mode 100644
--- /dev/null
+++ b/toolkit/locales/en-US/toolkit/main-window/findbar.ftl
@@ -0,0 +1,24 @@
+### This file contains the entities needed to use the Find Bar.
+
+findbar-next =
+    .tooltiptext = Find the next occurrence of the phrase
+findbar-previous =
+    .tooltiptext = Find the previous occurrence of the phrase
+
+findbar-find-button-close =
+    .tooltiptext = Close find bar
+
+findbar-highlight-all =
+    .label = Highlight All
+    .accesskey = l
+    .tooltiptext = Highlight all occurrences of the phrase
+
+findbar-case-sensitive =
+    .label = Match Case
+    .accesskey = C
+    .tooltiptext = Search with case sensitivity
+
+findbar-entire-word =
+    .label = Whole Words
+    .accesskey = W
+    .tooltiptext = Search whole words only
\ No newline at end of file
diff --git a/toolkit/locales/jar.mn b/toolkit/locales/jar.mn
--- a/toolkit/locales/jar.mn
+++ b/toolkit/locales/jar.mn
@@ -1,13 +1,15 @@
 #filter substitution
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+[localization] @AB_CD@.jar:
+  toolkit                                          (%toolkit/**/*.ftl)
 
 @AB_CD@.jar:
 % locale global @AB_CD@ %locale/@AB_CD@/global/
   locale/@AB_CD@/global/aboutAbout.dtd                  (%chrome/global/aboutAbout.dtd)
   locale/@AB_CD@/global/aboutReader.properties          (%chrome/global/aboutReader.properties)
   locale/@AB_CD@/global/aboutRights.dtd                 (%chrome/global/aboutRights.dtd)
   locale/@AB_CD@/global/aboutNetworking.dtd             (%chrome/global/aboutNetworking.dtd)
 #ifndef ANDROID
@@ -38,17 +40,16 @@
   locale/@AB_CD@/global/dialogOverlay.dtd               (%chrome/global/dialogOverlay.dtd)
 #ifndef MOZ_FENNEC
   locale/@AB_CD@/global/editMenuOverlay.dtd             (%chrome/global/editMenuOverlay.dtd)
 #endif
   locale/@AB_CD@/global/extensions.properties           (%chrome/global/extensions.properties)
   locale/@AB_CD@/global/fallbackMenubar.properties      (%chrome/global/fallbackMenubar.properties)
   locale/@AB_CD@/global/filepicker.properties           (%chrome/global/filepicker.properties)
 #ifndef MOZ_FENNEC
-  locale/@AB_CD@/global/findbar.dtd                     (%chrome/global/findbar.dtd)
   locale/@AB_CD@/global/findbar.properties              (%chrome/global/findbar.properties)
 #endif
   locale/@AB_CD@/global/globalKeys.dtd                  (%chrome/global/globalKeys.dtd)
   locale/@AB_CD@/global/intl.css                        (%chrome/global/intl.css)
   locale/@AB_CD@/global/intl.properties                 (%chrome/global/intl.properties)
   locale/@AB_CD@/global/keys.properties                 (%chrome/global/keys.properties)
   locale/@AB_CD@/global/languageNames.properties        (%chrome/global/languageNames.properties)
   locale/@AB_CD@/global/mozilla.dtd                     (%chrome/global/mozilla.dtd)
diff --git a/toolkit/themes/linux/global/global.css b/toolkit/themes/linux/global/global.css
--- a/toolkit/themes/linux/global/global.css
+++ b/toolkit/themes/linux/global/global.css
@@ -3,16 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* ===== global.css =====================================================
   == Styles that apply everywhere.
   ======================================================================= */
 
 /* all localizable skin settings shall live here */
 @import url("chrome://global/locale/intl.css");
+@import url("chrome://global/skin/findBar.css");
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 
 /* ::::: XBL bindings ::::: */
 
 menulist > menupopup {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#popup-scrollbars");
 }
diff --git a/toolkit/themes/osx/global/global.css b/toolkit/themes/osx/global/global.css
--- a/toolkit/themes/osx/global/global.css
+++ b/toolkit/themes/osx/global/global.css
@@ -1,14 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* all localizable skin settings shall live here */
 @import url("chrome://global/locale/intl.css");
+@import url("chrome://global/skin/findBar.css");
 
 %include shared.inc
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 
 /* ::::: XBL bindings ::::: */
 
 menulist > menupopup {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#popup-scrollbars");
diff --git a/toolkit/themes/windows/global/global.css b/toolkit/themes/windows/global/global.css
--- a/toolkit/themes/windows/global/global.css
+++ b/toolkit/themes/windows/global/global.css
@@ -3,16 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* ===== global.css =====================================================
   == Styles that apply everywhere.
   ======================================================================= */
 
 /* all localizable skin settings shall live here */
 @import url("chrome://global/locale/intl.css");
+@import url("chrome://global/skin/findBar.css");
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 
 /* ::::: XBL bindings ::::: */
 
 menulist > menupopup {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#popup-scrollbars");
 }
diff --git a/xpcom/ds/nsGkAtomList.h b/xpcom/ds/nsGkAtomList.h
--- a/xpcom/ds/nsGkAtomList.h
+++ b/xpcom/ds/nsGkAtomList.h
@@ -543,16 +543,17 @@ GK_ATOM(left, "left")
 GK_ATOM(leftmargin, "leftmargin")
 GK_ATOM(legend, "legend")
 GK_ATOM(length, "length")
 GK_ATOM(letterValue, "letter-value")
 GK_ATOM(level, "level")
 GK_ATOM(li, "li")
 GK_ATOM(line, "line")
 GK_ATOM(link, "link")
+GK_ATOM(linkset, "linkset")
 //GK_ATOM(list, "list")  # "list" is present below
 GK_ATOM(listbox, "listbox")
 GK_ATOM(listboxbody, "listboxbody")
 GK_ATOM(listcell, "listcell")
 GK_ATOM(listcol, "listcol")
 GK_ATOM(listcols, "listcols")
 GK_ATOM(listener, "listener")
 GK_ATOM(listhead, "listhead")
