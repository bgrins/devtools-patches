# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4c944453210c428f505bc2d81b3b7f1c99a262a6
Convert menulist bindings to CE

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -56,16 +56,32 @@ const MozElementMixin = Base => class Mo
     return true;
   }
 
   get isConnectedAndReady() {
     return gIsDOMContentLoaded && this.isConnected;
   }
 
   /**
+   * XXX
+   */
+  inheritAttribute(child, attrName, attrNewName = attrName) {
+    if (attrNewName === "text") {
+      child.textContent = this.hasAttribute(attrName) ? this.getAttribute(attrName) : "";
+      return;
+    }
+
+    if (this.hasAttribute(attrName)) {
+      child.setAttribute(attrNewName, this.getAttribute(attrName));
+    } else {
+      child.removeAttribute(attrNewName);
+    }
+  }
+
+  /**
    * Allows eager deterministic construction of XUL elements with XBL attached, by
    * parsing an element tree and returning a DOM fragment to be inserted in the
    * document before any of the inner elements is referenced by JavaScript.
    *
    * This process is required instead of calling the createElement method directly
    * because bindings get attached when:
    *
    * 1. the node gets a layout frame constructed, or
@@ -203,55 +219,61 @@ function getInterfaceProxy(obj) {
         return propOrMethod;
       },
     });
   }
 
   return obj._customInterfaceProxy;
 }
 
-class MozBaseControl extends MozXULElement {
-  get disabled() {
-    return this.getAttribute("disabled") == "true";
-  }
+const MozBaseControlMixin = Base => {
+  class MozBaseControl extends Base {
+    get disabled() {
+      return this.getAttribute("disabled") == "true";
+    }
 
-  set disabled(val) {
-    if (val) {
-      this.setAttribute("disabled", "true");
-    } else {
-      this.removeAttribute("disabled");
+    set disabled(val) {
+      if (val) {
+        this.setAttribute("disabled", "true");
+      } else {
+        this.removeAttribute("disabled");
+      }
+    }
+
+    get tabIndex() {
+      return parseInt(this.getAttribute("tabindex")) || 0;
+    }
+
+    set tabIndex(val) {
+      if (val) {
+        this.setAttribute("tabindex", val);
+      } else {
+        this.removeAttribute("tabindex");
+      }
     }
   }
-
-  get tabIndex() {
-    return parseInt(this.getAttribute("tabindex")) || 0;
-  }
+  MozXULElement.implementCustomInterface(MozBaseControl, [Ci.nsIDOMXULControlElement]);
+  return MozBaseControl;
+};
 
-  set tabIndex(val) {
-    if (val) {
-      this.setAttribute("tabindex", val);
-    } else {
-      this.removeAttribute("tabindex");
-    }
-  }
-}
-
-MozXULElement.implementCustomInterface(MozBaseControl, [Ci.nsIDOMXULControlElement]);
+const MozBaseControl = MozBaseControlMixin(MozXULElement);
 
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozBaseControl = MozBaseControl;
+window.MozBaseControlMixin = MozBaseControlMixin;
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
+    "chrome://global/content/elements/menulist.js",
     "chrome://global/content/elements/progressmeter.js",
     "chrome://global/content/elements/radio.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -71,17 +71,16 @@ toolkit.jar:
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimepopup.xml   (widgets/datetimepopup.xml)
    content/global/bindings/datetimebox.xml     (widgets/datetimebox.xml)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
 *  content/global/bindings/dialog.xml          (widgets/dialog.xml)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/groupbox.xml        (widgets/groupbox.xml)
    content/global/bindings/menu.xml            (widgets/menu.xml)
-   content/global/bindings/menulist.xml        (widgets/menulist.xml)
    content/global/bindings/notification.xml    (widgets/notification.xml)
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
 *  content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
@@ -90,18 +89,19 @@ toolkit.jar:
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/findbar.js          (widgets/findbar.js)
-   content/global/elements/editor.js          (widgets/editor.js)
+   content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
+   content/global/elements/menulist.js         (widgets/menulist.js)
    content/global/elements/progressmeter.js    (widgets/progressmeter.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.js
rename from toolkit/content/widgets/menulist.xml
rename to toolkit/content/widgets/menulist.js
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.js
@@ -1,341 +1,370 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
 
-<bindings id="menulistBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:html="http://www.w3.org/1999/xhtml"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+/* globals MozBaseControlMixin,MozElementMixin,XULMenuElement */
 
-  <binding id="menulist"
-           extends="chrome://global/content/bindings/general.xml#basecontrol">
-    <content sizetopopup="pref">
-      <xul:hbox class="menulist-label-box" flex="1">
-        <xul:image class="menulist-icon" xbl:inherits="src=image"/>
-        <xul:label class="menulist-label" xbl:inherits="value=label,crop,accesskey,highlightable" crop="right" flex="1"/>
-        <xul:label class="menulist-highlightable-label" xbl:inherits="xbl:text=label,crop,accesskey,highlightable" crop="right" flex="1"/>
-      </xul:hbox>
-      <xul:dropmarker class="menulist-dropmarker" type="menu" xbl:inherits="disabled,open"/>
-      <children includes="menupopup"/>
-    </content>
+let gFragment = MozXULElement.parseXULToFragment(`
+  <hbox class="menulist-label-box" flex="1">
+    <image class="menulist-icon"></image>
+    <label class="menulist-label" inherits="value=label,crop,accesskey,highlightable" crop="right" flex="1"></label>
+    <label class="menulist-highlightable-label" inherits="text=label,crop,accesskey,highlightable" crop="right" flex="1"></label>
+  </hbox>
+  <dropmarker class="menulist-dropmarker" type="menu" inherits="disabled,open"></dropmarker>
+`);
 
-    <handlers>
-      <handler event="command" phase="capturing"
-        action="if (event.target.parentNode.parentNode == this) this.selectedItem = event.target;"/>
+class MozMenulist extends MozBaseControlMixin(MozElementMixin(XULMenuElement)) {
+  constructor() {
+    super();
 
-      <handler event="popupshowing">
-        <![CDATA[
-          if (event.target.parentNode == this) {
-            this.activeChild = null;
-            if (this.selectedItem)
-              // Not ready for auto-setting the active child in hierarchies yet.
-              // For now, only do this when the outermost menupopup opens.
-              this.activeChild = this.mSelectedInternal;
-          }
-        ]]>
-      </handler>
+    this.mSelectedInternal = null;
+    this.mAttributeObserver = null;
+
+    this.addEventListener("command", (event) => {
+      if (event.target.parentNode.parentNode == this) {
+        this.selectedItem = event.target;
+      }
+    }, true);
 
-      <handler event="keypress" modifiers="shift any" group="system">
-        <![CDATA[
-          if (!event.defaultPrevented &&
-              (event.keyCode == KeyEvent.DOM_VK_UP ||
-               event.keyCode == KeyEvent.DOM_VK_DOWN ||
-               event.keyCode == KeyEvent.DOM_VK_PAGE_UP ||
-               event.keyCode == KeyEvent.DOM_VK_PAGE_DOWN ||
-               event.keyCode == KeyEvent.DOM_VK_HOME ||
-               event.keyCode == KeyEvent.DOM_VK_END ||
-               event.keyCode == KeyEvent.DOM_VK_BACK_SPACE ||
-               event.charCode > 0)) {
-            // Moving relative to an item: start from the currently selected item
-            this.activeChild = this.mSelectedInternal;
-            if (this.handleKeyPress(event)) {
-              this.activeChild.doCommand();
-              event.preventDefault();
-            }
-          }
-        ]]>
-      </handler>
-    </handlers>
+    this.addEventListener("popupshowing", (event) => {
+      if (event.target.parentNode == this) {
+        this.activeChild = null;
+        if (this.selectedItem)
+          // Not ready for auto-setting the active child in hierarchies yet.
+          // For now, only do this when the outermost menupopup opens.
+          this.activeChild = this.mSelectedInternal;
+      }
+    });
 
-    <implementation implements="nsIDOMXULMenuListElement">
-      <constructor>
-        this.mSelectedInternal = null;
-        this.mAttributeObserver = null;
-        this.setInitialSelection();
-      </constructor>
+    this.addEventListener("keypress", (event) => {
+      if (!event.defaultPrevented &&
+        (event.keyCode == KeyEvent.DOM_VK_UP ||
+          event.keyCode == KeyEvent.DOM_VK_DOWN ||
+          event.keyCode == KeyEvent.DOM_VK_PAGE_UP ||
+          event.keyCode == KeyEvent.DOM_VK_PAGE_DOWN ||
+          event.keyCode == KeyEvent.DOM_VK_HOME ||
+          event.keyCode == KeyEvent.DOM_VK_END ||
+          event.keyCode == KeyEvent.DOM_VK_BACK_SPACE ||
+          event.charCode > 0)) {
+        // Moving relative to an item: start from the currently selected item
+        this.activeChild = this.mSelectedInternal;
+        if (this.handleKeyPress(event)) {
+          this.activeChild.doCommand();
+          event.preventDefault();
+        }
+      }
+    }, { mozSystemGroup: true });
+  }
 
-      <method name="setInitialSelection">
-        <body>
-          <![CDATA[
-            var popup = this.menupopup;
-            if (popup) {
-              var arr = popup.getElementsByAttribute("selected", "true");
+  static get observedAttributes() {
+    return ["image", "label", "crop", "accesskey", "highlightable"];
+  }
 
-              var editable = this.editable;
-              var value = this.value;
-              if (!arr.item(0) && value)
-                arr = popup.getElementsByAttribute(editable ? "label" : "value", value);
+  attributeChangedCallback() {
+    if (!this.isConnectedAndReady) {
+      return;
+    }
+
+    this.inheritAttributes();
+  }
+
+  inheritAttributes() {
+    if (!this.menulistIcon) {
+      return;
+    }
 
-              if (arr.item(0))
-                this.selectedItem = arr[0];
-              else if (!editable)
-                this.selectedIndex = 0;
-            }
-          ]]>
-        </body>
-      </method>
+    this.inheritAttribute(this.menulistIcon, "image", "src");
+    this.inheritAttribute(this.menulistLabel, "label", "value");
+    this.inheritAttribute(this.menulistLabel, "crop");
+    this.inheritAttribute(this.menulistLabel, "accesskey");
+    this.inheritAttribute(this.menulistLabel, "highlightable");
+    this.inheritAttribute(this.menulistHighlightableLabel, "label", "text");
+    this.inheritAttribute(this.menulistHighlightableLabel, "crop");
+    this.inheritAttribute(this.menulistHighlightableLabel, "accesskey");
+    this.inheritAttribute(this.menulistHighlightableLabel, "highlightable");
+    this.inheritAttribute(this.menulistDropmarker, "disabled");
+    this.inheritAttribute(this.menulistDropmarker, "open");
+  }
 
-      <property name="value" onget="return this.getAttribute('value');">
-        <setter>
-          <![CDATA[
-            // if the new value is null, we still need to remove the old value
-            if (val == null)
-              return this.selectedItem = val;
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    // XXX: Invert the relationship here and wait for menupopup to tell us it's created
+    // before we try and make the menulist?
 
-            var arr = null;
-            var popup = this.menupopup;
-            if (popup)
-              arr = popup.getElementsByAttribute("value", val);
+    if (!this.connectedOnce) {
+      this.connectedOnce = true;
+      this.setAttribute("sizetopopup", "pref");
 
-            if (arr && arr.item(0))
-              this.selectedItem = arr[0];
-            else {
-              this.selectedItem = null;
-              this.setAttribute("value", val);
-            }
+      if (!this.isPopupOnly) {
+        this.prepend(document.importNode(gFragment, true));
+        this.menulistIcon = this.querySelector(".menulist-icon");
+        this.menulistLabel = this.querySelector(".menulist-label");
+        this.menulistHighlightableLabel = this.querySelector(".menulist-highlightable-label");
+        this.menulistDropmarker = this.querySelector(".menulist-dropmarker");
+      }
+    }
 
-            return val;
-          ]]>
-        </setter>
-      </property>
+    this.inheritAttributes();
+    this.setInitialSelection();
+  }
 
-      <property name="crop" onset="this.setAttribute('crop',val); return val;"
-                            onget="return this.getAttribute('crop');"/>
-      <property name="image"  onset="this.setAttribute('image',val); return val;"
-                              onget="return this.getAttribute('image');"/>
-      <property name="label" readonly="true" onget="return this.getAttribute('label');"/>
-      <property name="description" onset="this.setAttribute('description',val); return val;"
-                                   onget="return this.getAttribute('description');"/>
+  disconnectedCallback() {
+    if (this.mAttributeObserver) {
+      this.mAttributeObserver.disconnect();
+    }
+    this._menupopup = null;
+  }
+
+  get isPopupOnly() {
+    return this.hasAttribute("popuponly");
+  }
 
-      <property name="open" onset="this.openMenu(val); return val;"
-                            onget="return this.hasAttribute('open');"/>
+  set value(val) {
+    // if the new value is null, we still need to remove the old value
+    if (val == null)
+      return this.selectedItem = val;
 
-      <property name="itemCount" readonly="true"
-                onget="return this.menupopup ? this.menupopup.children.length : 0"/>
+    var arr = null;
+    var popup = this.menupopup;
+    if (popup)
+      arr = popup.getElementsByAttribute("value", val);
 
-      <property name="menupopup" readonly="true">
-        <getter>
-          <![CDATA[
-            var popup = this.firstElementChild;
-            while (popup && popup.localName != "menupopup")
-              popup = popup.nextElementSibling;
-            return popup;
-          ]]>
-        </getter>
-      </property>
+    if (arr && arr.item(0))
+      this.selectedItem = arr[0];
+    else {
+      this.selectedItem = null;
+      this.setAttribute("value", val);
+    }
+
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
 
-      <method name="contains">
-        <parameter name="item"/>
-        <body>
-          <![CDATA[
-            if (!item)
-              return false;
+  set crop(val) {
+    this.setAttribute("crop", val);
+    return val;
+  }
 
-            var parent = item.parentNode;
-            return (parent && parent.parentNode == this);
-          ]]>
-        </body>
-      </method>
+  get crop() {
+    return this.getAttribute("crop");
+  }
+
+  set image(val) {
+    this.setAttribute("image", val);
+    return val;
+  }
 
-      <property name="selectedIndex">
-        <getter>
-          <![CDATA[
-            // Quick and dirty. We won't deal with hierarchical menulists yet.
-            if (!this.selectedItem ||
-                !this.mSelectedInternal.parentNode ||
-                this.mSelectedInternal.parentNode.parentNode != this)
-              return -1;
+  get image() {
+    return this.getAttribute("image");
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
 
-            var children = this.mSelectedInternal.parentNode.children;
-            var i = children.length;
-            while (i--)
-              if (children[i] == this.mSelectedInternal)
-                break;
+  set description(val) {
+    this.setAttribute("description", val);
+    return val;
+  }
+
+  get description() {
+    return this.getAttribute("description");
+  }
 
-            return i;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            var popup = this.menupopup;
-            if (popup && 0 <= val) {
-              if (val < popup.children.length)
-                this.selectedItem = popup.children[val];
-            } else
-              this.selectedItem = null;
-            return val;
-          ]]>
-        </setter>
-      </property>
+  set open(val) {
+    this.openMenu(val);
+    return val;
+  }
+
+  get open() {
+    return this.hasAttribute("open");
+  }
+
+  get itemCount() {
+    return this.menupopup ? this.menupopup.children.length : 0;
+  }
+
+  get menupopup() {
+    if (this._menupopup) {
+      return this._menupopup;
+    }
+    this._menupopup = this.querySelector(":scope > menupopup");
+    return this._menupopup;
+  }
 
-      <property name="selectedItem">
-        <getter>
-          <![CDATA[
-            return this.mSelectedInternal;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            var oldval = this.mSelectedInternal;
-            if (oldval == val)
-              return val;
+  set selectedIndex(val) {
+    var popup = this.menupopup;
+    if (popup && 0 <= val) {
+      if (val < popup.children.length)
+        this.selectedItem = popup.children[val];
+    } else
+      this.selectedItem = null;
+    return val;
+  }
 
-            if (val && !this.contains(val))
-              return val;
+  get selectedIndex() {
+    // Quick and dirty. We won't deal with hierarchical menulists yet.
+    if (!this.selectedItem ||
+      !this.mSelectedInternal.parentNode ||
+      this.mSelectedInternal.parentNode.parentNode != this)
+      return -1;
+
+    var children = this.mSelectedInternal.parentNode.children;
+    var i = children.length;
+    while (i--)
+      if (children[i] == this.mSelectedInternal)
+        break;
 
-            if (oldval) {
-              oldval.removeAttribute("selected");
-              this.mAttributeObserver.disconnect();
-            }
+    return i;
+  }
 
-            this.mSelectedInternal = val;
-            let attributeFilter = ["value", "label", "image", "description"];
-            if (val) {
-              val.setAttribute("selected", "true");
-              for (let attr of attributeFilter) {
-                if (val.hasAttribute(attr)) {
-                  this.setAttribute(attr, val.getAttribute(attr));
-                } else {
-                  this.removeAttribute(attr);
-                }
-              }
+  set selectedItem(val) {
+    var oldval = this.mSelectedInternal;
+    if (oldval == val)
+      return val;
+
+    if (val && !this.contains(val))
+      return val;
 
-              this.mAttributeObserver = new MutationObserver(this.handleMutation.bind(this));
-              this.mAttributeObserver.observe(val, { attributeFilter });
-            } else {
-              for (let attr of attributeFilter) {
-                this.removeAttribute(attr);
-              }
-            }
+    if (oldval) {
+      oldval.removeAttribute("selected");
+      this.mAttributeObserver.disconnect();
+    }
+    this.mSelectedInternal = val;
+    let attributeFilter = ["value", "label", "image", "description"];
+    if (val) {
+      val.setAttribute("selected", "true");
+      for (let attr of attributeFilter) {
+        if (val.hasAttribute(attr)) {
+          this.setAttribute(attr, val.getAttribute(attr));
+        } else {
+          this.removeAttribute(attr);
+        }
+      }
 
-            var event = document.createEvent("Events");
-            event.initEvent("select", true, true);
-            this.dispatchEvent(event);
+      this.mAttributeObserver = new MutationObserver(this.handleMutation.bind(this));
+      this.mAttributeObserver.observe(val, { attributeFilter });
+    } else {
+      for (let attr of attributeFilter) {
+        this.removeAttribute(attr);
+      }
+    }
 
-            event = document.createEvent("Events");
-            event.initEvent("ValueChange", true, true);
-            this.dispatchEvent(event);
+    var event = document.createEvent("Events");
+    event.initEvent("select", true, true);
+    this.dispatchEvent(event);
 
-            return val;
-          ]]>
-        </setter>
-      </property>
+    event = document.createEvent("Events");
+    event.initEvent("ValueChange", true, true);
+    this.dispatchEvent(event);
+
+    return val;
+  }
 
-      <method name="handleMutation">
-        <parameter name="aRecords"/>
-        <body>
-          <![CDATA[
-            for (let record of aRecords) {
-              let t = record.target;
-              if (t == this.mSelectedInternal) {
-                let attrName = record.attributeName;
-                switch (attrName) {
-                  case "value":
-                  case "label":
-                  case "image":
-                  case "description":
-                    if (t.hasAttribute(attrName)) {
-                      this.setAttribute(attrName, t.getAttribute(attrName));
-                    } else {
-                      this.removeAttribute(attrName);
-                    }
-                }
-              }
+  get selectedItem() {
+    return this.mSelectedInternal;
+  }
+
+  setInitialSelection() {
+    var popup = this.menupopup;
+    if (popup) {
+      var arr = popup.getElementsByAttribute("selected", "true");
+      var editable = this.editable;
+      var value = this.value;
+      if (!arr.item(0) && value)
+        arr = popup.getElementsByAttribute(editable ? "label" : "value", value);
+
+      if (arr.item(0))
+        this.selectedItem = arr[0];
+      else if (!editable)
+        this.selectedIndex = 0;
+    }
+  }
+
+  contains(item) {
+    if (!item)
+      return false;
+
+    var parent = item.parentNode;
+    return (parent && parent.parentNode == this);
+  }
+
+  handleMutation(aRecords) {
+    for (let record of aRecords) {
+      let t = record.target;
+      if (t == this.mSelectedInternal) {
+        let attrName = record.attributeName;
+        switch (attrName) {
+          case "value":
+          case "label":
+          case "image":
+          case "description":
+            if (t.hasAttribute(attrName)) {
+              this.setAttribute(attrName, t.getAttribute(attrName));
+            } else {
+              this.removeAttribute(attrName);
             }
-          ]]>
-        </body>
-      </method>
-
-      <method name="getIndexOfItem">
-        <parameter name="item"/>
-        <body>
-        <![CDATA[
-          var popup = this.menupopup;
-          if (popup) {
-            var children = popup.children;
-            var i = children.length;
-            while (i--)
-              if (children[i] == item)
-                return i;
-          }
-          return -1;
-        ]]>
-        </body>
-      </method>
+        }
+      }
+    }
+  }
 
-      <method name="getItemAtIndex">
-        <parameter name="index"/>
-        <body>
-        <![CDATA[
-          var popup = this.menupopup;
-          if (popup) {
-            var children = popup.children;
-            if (index >= 0 && index < children.length)
-              return children[index];
-          }
-          return null;
-        ]]>
-        </body>
-      </method>
+  getIndexOfItem(item) {
+    var popup = this.menupopup;
+    if (popup) {
+      var children = popup.children;
+      var i = children.length;
+      while (i--)
+        if (children[i] == item)
+          return i;
+    }
+    return -1;
+  }
 
-      <method name="appendItem">
-        <parameter name="label"/>
-        <parameter name="value"/>
-        <parameter name="description"/>
-        <body>
-        <![CDATA[
-          var popup = this.menupopup ||
-                      this.appendChild(document.createXULElement("menupopup"));
-          var item = document.createXULElement("menuitem");
-          item.setAttribute("label", label);
-          item.setAttribute("value", value);
-          if (description)
-            item.setAttribute("description", description);
+  getItemAtIndex(index) {
+    var popup = this.menupopup;
+    if (popup) {
+      var children = popup.children;
+      if (index >= 0 && index < children.length)
+        return children[index];
+    }
+    return null;
+  }
 
-          popup.appendChild(item);
-          return item;
-        ]]>
-        </body>
-      </method>
+  appendItem(label, value, description) {
+    var popup = this.menupopup ||
+      this.appendChild(document.createXULElement("menupopup"));
+    var item = document.createXULElement("menuitem");
+    item.setAttribute("label", label);
+    item.setAttribute("value", value);
+    if (description)
+      item.setAttribute("description", description);
 
-      <method name="removeAllItems">
-        <body>
-        <![CDATA[
-          this.selectedItem = null;
-          var popup = this.menupopup;
-          if (popup)
-            this.removeChild(popup);
-        ]]>
-        </body>
-      </method>
+    popup.appendChild(item);
+    return item;
+  }
 
-      <destructor>
-        <![CDATA[
-          if (this.mAttributeObserver) {
-            this.mAttributeObserver.disconnect();
-          }
-        ]]>
-      </destructor>
-    </implementation>
-  </binding>
+  removeAllItems() {
+    this.selectedItem = null;
+    var popup = this.menupopup;
+    if (popup)
+      this.removeChild(popup);
+  }
+}
 
-  <binding id="menulist-popuponly"
-           extends="chrome://global/content/bindings/menulist.xml#menulist">
-    <content sizetopopup="pref">
-      <children includes="menupopup"/>
-    </content>
-  </binding>
-</bindings>
+MozXULElement.implementCustomInterface(MozMenulist, [Ci.nsIDOMXULMenuListElement]);
+customElements.define("menulist", MozMenulist);
+
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -675,22 +675,17 @@ panel[type="autocomplete-richlistbox"] {
   max-width: 0px;
   width: 0 !important;
   min-width: 0%;
   min-height: 0%;
 }
 
 /********** menulist **********/
 
-menulist {
-  -moz-binding: url("chrome://global/content/bindings/menulist.xml#menulist");
-}
-
 menulist[popuponly="true"] {
-  -moz-binding: url("chrome://global/content/bindings/menulist.xml#menulist-popuponly");
   -moz-appearance: none !important;
   margin: 0 !important;
   height: 0 !important;
   min-height: 0 !important;
   border: 0 !important;
 }
 
 menulist > menupopup > menuitem {
diff --git a/toolkit/mozapps/extensions/content/extensions.xml b/toolkit/mozapps/extensions/content/extensions.xml
--- a/toolkit/mozapps/extensions/content/extensions.xml
+++ b/toolkit/mozapps/extensions/content/extensions.xml
@@ -714,16 +714,17 @@
             </xul:menulist>
           </xul:hbox>
         </xul:vbox>
       </xul:hbox>
     </content>
 
     <implementation>
       <constructor><![CDATA[
+        customElements.upgrade(this._stateMenulist);
         this._installStatus = document.getAnonymousElementByAttribute(this, "anonid", "install-status");
         this._installStatus.mControl = this;
 
         this.setAttribute("contextmenu", "addonitem-popup");
 
         this._showStatus("none");
 
         this._initWithAddon(this.mAddon);
