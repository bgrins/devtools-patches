# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b1821f8cf26114fe25d5da0c479377379ab53b7b
Bug XXX: Use codemirror in console

diff --git a/devtools/client/shared/autocomplete-popup.js b/devtools/client/shared/autocomplete-popup.js
--- a/devtools/client/shared/autocomplete-popup.js
+++ b/devtools/client/shared/autocomplete-popup.js
@@ -133,20 +133,27 @@ AutocompletePopup.prototype = {
    *        Optional node to anchor the panel to.
    * @param Number aXOffset
    *        Horizontal offset in pixels from the left of the node to the left
    *        of the popup.
    * @param Number aYOffset
    *        Vertical offset in pixels from the top of the node to the starting
    *        of the popup.
    */
-  openPopup: function AP_openPopup(aAnchor, aXOffset = 0, aYOffset = 0)
+  openPopup: function AP_openPopup(aAnchor, aXOffset = 0, aYOffset = 0, dimmed = false)
   {
     this.__maxLabelLength = -1;
     this._updateSize();
+
+    if (dimmed) {
+      this.dimPopup();
+    } else {
+      this.unDimPopup();
+    }
+
     this._panel.openPopup(aAnchor, this.position, aXOffset, aYOffset);
 
     if (this.autoSelect) {
       this.selectFirstItem();
     }
 
     this.emit("popup-opened");
   },
@@ -154,16 +161,37 @@ AutocompletePopup.prototype = {
   /**
    * Hide the autocomplete popup panel.
    */
   hidePopup: function AP_hidePopup()
   {
     // Return accessibility focus to the input.
     this._document.activeElement.removeAttribute("aria-activedescendant");
     this._panel.hidePopup();
+    this.unDimPopup();
+  },
+
+  /**
+   * "Dim" the autocomplete popup panel, meaning that it's still open
+   * but not visible.
+   */
+  dimPopup: function AP_dimPopup()
+  {
+    this._panel.style.opacity = 0;
+    this._panel.style.pointerEvents = "none";
+  },
+
+  /**
+   * "Dim" the autocomplete popup panel, meaning that it's still open
+   * but not visible.
+   */
+  unDimPopup: function AP_dimPopup()
+  {
+    this._panel.style.opacity = 1;
+    this._panel.style.pointerEvents = "auto";
   },
 
   /**
    * Check if the autocomplete popup is open.
    */
   get isOpen() {
     return this._panel &&
            (this._panel.state == "open" || this._panel.state == "showing");
diff --git a/devtools/client/sourceeditor/autocomplete.js b/devtools/client/sourceeditor/autocomplete.js
--- a/devtools/client/sourceeditor/autocomplete.js
+++ b/devtools/client/sourceeditor/autocomplete.js
@@ -1,43 +1,51 @@
 /* vim:set ts=2 sw=2 sts=2 et tw=80:
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Cu } = require("chrome");
 const cssAutoCompleter = require("devtools/client/sourceeditor/css-autocompleter");
+const consoleAutoCompleter = require("devtools/client/sourceeditor/console-autocompleter");
 const { AutocompletePopup } = require("devtools/client/shared/autocomplete-popup");
 
 const CM_TERN_SCRIPTS = [
   "chrome://devtools/content/sourceeditor/codemirror/tern/tern.js",
   "chrome://devtools/content/sourceeditor/codemirror/hint/show-hint.js"
 ];
 
 const autocompleteMap = new WeakMap();
 
 // A simple way to give each popup its own panelId.
 var autocompleteCounter = 0;
 
+let WEBCONSOLE_MODE = true;
+
 /**
  * Prepares an editor instance for autocompletion.
  */
 function initializeAutoCompletion(ctx, options = {}) {
   let { cm, ed, Editor } = ctx;
   if (autocompleteMap.has(ed)) {
     return;
   }
 
   let win = ed.container.contentWindow.wrappedJSObject;
   let { CodeMirror, document } = win;
 
   let completer = null;
   let autocompleteKey = "Ctrl-" +
                         Editor.keyFor("autocompletion", { noaccel: true });
-  if (ed.config.mode == Editor.modes.js) {
+  if (options.getWebConsoleClient) {
+    completer = new consoleAutoCompleter({
+      getWebConsoleClient: options.getWebConsoleClient,
+      getFrameActor: options.getFrameActor,
+    });
+  } else if (ed.config.mode == Editor.modes.js) {
     let defs = [
       "./tern/browser",
       "./tern/ecma5",
     ].map(require);
 
     CM_TERN_SCRIPTS.forEach(ed.loadScript, ed);
     win.tern = require("./tern/tern");
     cm.tern = new CodeMirror.TernServer({
@@ -103,27 +111,27 @@ function initializeAutoCompletion(ctx, o
 
     // TODO: Integrate tern autocompletion with this autocomplete API.
     return;
   } else if (ed.config.mode == Editor.modes.css) {
     completer = new cssAutoCompleter({walker: options.walker});
   }
 
   function insertSelectedPopupItem() {
-    let autocompleteState = autocompleteMap.get(ed);
-    if (!popup || !popup.isOpen || !autocompleteState) {
+    let private = autocompleteMap.get(ed);
+    if (!private || !private.popup || !private.popup.isOpen) {
       return;
     }
 
-    if (!autocompleteState.suggestionInsertedOnce && popup.selectedItem) {
-      autocompleteMap.get(ed).insertingSuggestion = true;
-      insertPopupItem(ed, popup.selectedItem);
+    if (!private.suggestionInsertedOnce && private.popup.selectedItem) {
+      private.insertingSuggestion = true;
+      insertPopupItem(ed, private.popup.selectedItem);
     }
 
-    popup.hidePopup();
+    private.hidePopup();
     ed.emit("popup-hidden"); // This event is used in tests.
     return true;
   }
 
   // Give each popup a new name to avoid sharing the elements.
   let panelId = "devtools_sourceEditorCompletePopup" + autocompleteCounter;
   ++autocompleteCounter;
 
@@ -141,19 +149,40 @@ function initializeAutoCompletion(ctx, o
       cycleSuggestions(ed, reverse == true);
       return;
     }
 
     return CodeMirror.Pass;
   };
 
   let keyMap = {
-    "Tab": cycle,
+    "Tab": () => {
+      if (WEBCONSOLE_MODE) {
+        let wasHandled = insertSelectedPopupItem();
+        return wasHandled ? true : CodeMirror.Pass;
+      } else {
+        cycle();
+      }
+    },
+    "Right": () => {
+      if (WEBCONSOLE_MODE) {
+        let wasHandled = insertSelectedPopupItem();
+        return wasHandled ? true : CodeMirror.Pass;
+      }
+      return CodeMirror.Pass;
+    },
     "Down": cycle,
-    "Shift-Tab": cycle.bind(null, true),
+    "Shift-Tab": () => {
+      if (WEBCONSOLE_MODE) {
+        let wasHandled = insertSelectedPopupItem();
+        return wasHandled ? true : CodeMirror.Pass;
+      } else {
+        cycle();
+      }
+    },
     "Up": cycle.bind(null, true),
     "Enter": () => {
       let wasHandled = insertSelectedPopupItem();
       return wasHandled ? true : CodeMirror.Pass;
     }
   };
   let autoCompleteCallback = autoComplete.bind(null, ctx);
   let keypressCallback = onEditorKeypress.bind(null, ctx);
@@ -172,16 +201,24 @@ function initializeAutoCompletion(ctx, o
     popup.destroy();
     keyMap = popup = completer = null;
     autocompleteMap.delete(ed);
   }
 
   autocompleteMap.set(ed, {
     popup: popup,
     completer: completer,
+    hidePopup: function() {
+      // XXX: Instead should bind to popuphide event and clear widget there..
+      // This is also causing a flicker while typing quickly, i.e. 'window'
+      this.popup.hidePopup();
+      if (this.widget) {
+        this.widget.clear();
+      }
+    },
     keyMap: keyMap,
     destroy: destroy,
     insertingSuggestion: false,
     suggestionInsertedOnce: false
   });
 }
 
 /**
@@ -202,36 +239,52 @@ function destroyAutoCompletion(ctx) {
  */
 function autoComplete({ ed, cm }) {
   let private = autocompleteMap.get(ed);
   let { completer, popup } = private;
   if (!completer || private.insertingSuggestion || private.doNotAutocomplete) {
     private.insertingSuggestion = false;
     return;
   }
+  if (WEBCONSOLE_MODE && ed.somethingSelected()) {
+    return;
+  }
   let cur = ed.getCursor();
   completer.complete(cm.getRange({line: 0, ch: 0}, cur), cur)
     .then(suggestions => {
     if (!suggestions || !suggestions.length || suggestions[0].preLabel == null) {
       private.suggestionInsertedOnce = false;
-      popup.hidePopup();
+      private.hidePopup();
       ed.emit("after-suggest");
       return;
     }
     // The cursor is at the end of the currently entered part of the token, like
     // "backgr|" but we need to open the popup at the beginning of the character
     // "b". Thus we need to calculate the width of the entered part of the token
     // ("backgr" here). 4 comes from the popup's left padding.
 
     let cursorElement = cm.display.cursorDiv.querySelector(".CodeMirror-cursor");
     let left = suggestions[0].preLabel.length * cm.defaultCharWidth() + 4;
-    popup.hidePopup();
+    private.hidePopup();
     popup.setItems(suggestions);
-    popup.openPopup(cursorElement, -1 * left, 0);
+
+    let dimmed = WEBCONSOLE_MODE && suggestions.length === 1;
+    popup.openPopup(cursorElement, -1 * left, 0, dimmed);
     private.suggestionInsertedOnce = false;
+
+    if (WEBCONSOLE_MODE) {
+      // Don't paint the option if this isn't the last char in a line.
+      // Could change this behavior if we set the actual text in the editor.
+      let cursor = ed.getCursor();
+      let line = ed.getText(cursor.line);
+      if (cursor.ch === line.length) {
+        private.widget = ed.addWidget(cur, popup.selectedItem.label.slice(popup.selectedItem.preLabel.length));
+      }
+    }
+
     // This event is used in tests.
     ed.emit("after-suggest");
   }).then(null, Cu.reportError);
 }
 
 /**
  * Inserts a popup item into the current cursor location
  * in the editor.
@@ -249,106 +302,125 @@ function insertPopupItem(ed, popupItem) 
   // then the final text needs to the end up as '#about'.
   if (backwardsPreLabel.indexOf(backwardsTextBeforeCursor) === 0) {
     ed.replaceText(text, {line: cur.line, ch: 0}, cur);
   } else {
     ed.replaceText(text.slice(preLabel.length), cur, cur);
   }
 }
 
+
 /**
  * Cycles through provided suggestions by the popup in a top to bottom manner
  * when `reverse` is not true. Opposite otherwise.
  */
 function cycleSuggestions(ed, reverse) {
   let private = autocompleteMap.get(ed);
   let { popup, completer } = private;
   let cur = ed.getCursor();
   private.insertingSuggestion = true;
-  if (!private.suggestionInsertedOnce) {
+  if (!private.suggestionInsertedOnce && !WEBCONSOLE_MODE) {
     private.suggestionInsertedOnce = true;
     let firstItem;
     if (reverse) {
       firstItem = popup.getItemAtIndex(popup.itemCount - 1);
       popup.selectPreviousItem();
     } else {
       firstItem = popup.getItemAtIndex(0);
       if (firstItem.label == firstItem.preLabel && popup.itemCount > 1) {
         firstItem = popup.getItemAtIndex(1);
         popup.selectNextItem();
       }
     }
     if (popup.itemCount == 1)
-      popup.hidePopup();
+      private.hidePopup();
     insertPopupItem(ed, firstItem);
   } else {
     let fromCur = {
       line: cur.line,
       ch  : cur.ch - popup.selectedItem.text.length
     };
     if (reverse)
       popup.selectPreviousItem();
     else
       popup.selectNextItem();
-    ed.replaceText(popup.selectedItem.text, fromCur, cur);
+
+    if (WEBCONSOLE_MODE) {
+      // Don't paint the option if this isn't the last char in a line.
+      // Could change this behavior if we set the actual text in the editor.
+      let cursor = ed.getCursor();
+      let line = ed.getText(cursor.line);
+      if (cursor.ch === line.length) {
+        private.widget = ed.addWidget(cur, popup.selectedItem.label.slice(popup.selectedItem.preLabel.length));
+      }
+    } else {
+      ed.replaceText(popup.selectedItem.text, fromCur, cur);
+    }
   }
   // This event is used in tests.
   ed.emit("suggestion-entered");
 }
 
 /**
  * onkeydown handler for the editor instance to prevent autocompleting on some
  * keypresses.
  */
 function onEditorKeypress({ ed, Editor }, cm, event) {
   let private = autocompleteMap.get(ed);
 
   // Do not try to autocomplete with multiple selections.
   if (ed.hasMultipleSelections()) {
     private.doNotAutocomplete = true;
-    private.popup.hidePopup();
+    private.hidePopup();
     return;
   }
 
   if ((event.ctrlKey || event.metaKey) && event.keyCode == event.DOM_VK_SPACE) {
     // When Ctrl/Cmd + Space is pressed, two simultaneous keypresses are emitted
     // first one for just the Ctrl/Cmd and second one for combo. The first one
     // leave the private.doNotAutocomplete as true, so we have to make it false
     private.doNotAutocomplete = false;
     return;
   }
 
   if (event.ctrlKey || event.metaKey || event.altKey) {
     private.doNotAutocomplete = true;
-    private.popup.hidePopup();
+    if (!WEBCONSOLE_MODE) {
+      private.hidePopup();
+    }
     return;
   }
 
   switch (event.keyCode) {
     case event.DOM_VK_RETURN:
       private.doNotAutocomplete = true;
       break;
 
     case event.DOM_VK_ESCAPE:
       if (private.popup.isOpen)
         event.preventDefault();
     case event.DOM_VK_LEFT:
     case event.DOM_VK_RIGHT:
     case event.DOM_VK_HOME:
     case event.DOM_VK_END:
+      // TODO: Handle rtl text
+      if (event.keyCode === event.DOM_VK_RIGHT && WEBCONSOLE_MODE) {
+        private.doNotAutocomplete = false;
+        break;
+      }
       private.doNotAutocomplete = true;
-      private.popup.hidePopup();
+      private.hidePopup();
       break;
 
     case event.DOM_VK_BACK_SPACE:
     case event.DOM_VK_DELETE:
       if (ed.config.mode == Editor.modes.css)
         private.completer.invalidateCache(ed.getCursor().line)
       private.doNotAutocomplete = true;
-      private.popup.hidePopup();
+      private.hidePopup();
       break;
 
     default:
       private.doNotAutocomplete = false;
   }
 }
 
 /**
diff --git a/devtools/client/sourceeditor/console-autocompleter.js b/devtools/client/sourceeditor/console-autocompleter.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/sourceeditor/console-autocompleter.js
@@ -0,0 +1,134 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const { Cc, Ci, Cu } = require('chrome');
+
+// Flip this to enable caching, which is helpful for perf when typing quicky
+// because it won't re-make the last request if it's not needed.
+const ENABLE_CACHING = false;
+
+/**
+ */
+
+/**
+ * Constructor for the autocompletion object.
+ */
+function ConsoleCompleter(options = {}) {
+  this.maxEntries = options.maxEntries || 15;
+  this.getFrameActor = options.getFrameActor;
+  this.getWebConsoleClient = options.getWebConsoleClient;
+}
+
+ConsoleCompleter.prototype = {
+  /**
+   * Array that caches the user input suggestions received from the server.
+   * @private
+   * @type array
+   */
+  _autocompleteCache: null,
+
+  /**
+   * The input that caused the last request to the server, whose response is
+   * cached in the _autocompleteCache array.
+   * @private
+   * @type string
+   */
+  _autocompleteQuery: null,
+
+
+  /**
+   * Returns a list of suggestions based on the caret position.
+   *
+   * @param source {String} String of the source code.
+   * @param caret {Object} Cursor location with line and ch properties.
+   *
+   * @returns [{object}] A sorted list of objects containing the following
+   *          peroperties:
+   *          - label {String} Full keyword for the suggestion
+   *          - preLabel {String} Already entered part of the label
+   */
+  complete: function(source, caret) {
+    let webConsoleClient = this.getWebConsoleClient();
+    if (!webConsoleClient) {
+      return Promise.resolve([]);
+    }
+
+    // Convert the editor caret format into the form webconsole expects
+    let start = caret.ch;
+    if (caret.line > 0) {
+      let lines = source.split("\n");
+      for (let i = 0; i < caret.line; i++) {
+        start += lines[i].length + 1;
+      }
+    }
+    let inputUntilCursor = source.substring(0, start);
+
+
+    // Handle cached results
+
+    // if (aRequestId != null && /[a-zA-Z0-9.]$/.test(inputUntilCursor)) {
+    //   this._autocompleteCache = aMessage.matches;
+    //   this._autocompleteQuery = inputUntilCursor;
+    // }
+    if (ENABLE_CACHING) {
+      let cachedResults = this.cacheComplete(source);
+      if (cachedResults) {
+        console.log("Cache hit for ", source, start);
+        return cachedResults;
+      }
+    }
+
+    return new Promise((resolve, reject) => {
+      let frameActor = this.getFrameActor();
+      let onAutocomplete = (message) => {
+        let lastPart = message.matchProp;
+        let matches = message.matches.map(function(aMatch) {
+          return {
+            preLabel: lastPart,
+            label: aMatch,
+            text: aMatch,
+          };
+        });
+
+        if (ENABLE_CACHING) {
+          this._autocompleteCache = matches;
+          this._autocompleteQuery = inputUntilCursor;
+        }
+        // if (aRequestId != null && /[a-zA-Z0-9.]$/.test(inputUntilCursor)) {
+        // }
+        console.log("Got matches", matches)
+        resolve(matches);
+      };
+      webConsoleClient.autocomplete(source, start, onAutocomplete, frameActor);
+    });
+  },
+
+  cacheComplete: function(source) {
+    if (this._autocompleteQuery && source.startsWith(this._autocompleteQuery)) {
+      let cache = this._autocompleteCache;
+      let filterBy = source;
+      // Find the last non-alphanumeric other than _ or $ if it exists.
+      let lastNonAlpha = source.match(/[^a-zA-Z0-9_$][a-zA-Z0-9_$]*$/);
+      // If input contains non-alphanumerics, use the part after the last one
+      // to filter the cache
+      if (lastNonAlpha) {
+        filterBy = source.substring(source.lastIndexOf(lastNonAlpha) + 1);
+      }
+      let newList = cache.sort().filter((m) => {
+        return m.text.startsWith(filterBy);
+      }).map(m => {
+        return {
+          preLabel: filterBy,
+          label: m.label,
+          text: m.text,
+        }
+      })
+
+      return new Promise(resolve => {
+        resolve(newList);
+      });
+    }
+  }
+};
+module.exports = ConsoleCompleter;
diff --git a/devtools/client/sourceeditor/editor.js b/devtools/client/sourceeditor/editor.js
--- a/devtools/client/sourceeditor/editor.js
+++ b/devtools/client/sourceeditor/editor.js
@@ -354,20 +354,19 @@ Editor.prototype = {
           if (ev.shiftKey) {
             cm.execCommand("findPrev");
           } else {
             cm.execCommand("findNext");
           }
         }
       });
 
-
       cm.on("focus", () => this.emit("focus"));
       cm.on("scroll", () => this.emit("scroll"));
-      cm.on("change", () => {
+      cm.on("changes", () => {
         this.emit("change");
         if (!this._lastDirty) {
           this._lastDirty = true;
           this.emit("dirty-change");
         }
       });
       cm.on("cursorActivity", (cm) => this.emit("cursorActivity"));
 
@@ -432,16 +431,30 @@ Editor.prototype = {
    * Returns the currently active highlighting mode.
    * See Editor.modes for the list of all suppoert modes.
    */
   getMode: function () {
     return this.getOption("mode");
   },
 
   /**
+   * Returns the currently active highlighting mode.
+   * See Editor.modes for the list of all suppoert modes.
+   */
+  getScrollHeight: function () {
+    let cm = editors.get(this);
+    let wrapper = cm.getWrapperElement();
+    let scroller = wrapper.querySelector(".CodeMirror-sizer");
+    // wrapper.style.height = "auto";
+    let scrollHeight = scroller.scrollHeight;
+    // delete wrapper.style.height;
+    return scrollHeight;
+  },
+
+  /**
    * Load a script into editor's containing window.
    */
   loadScript: function (url) {
     if (!this.container) {
       throw new Error("Can't load a script until the editor is loaded.")
     }
     let win = this.container.contentWindow.wrappedJSObject;
     Services.scriptloader.loadSubScript(url, win, "utf8");
@@ -802,16 +815,46 @@ Editor.prototype = {
     let mark = cm.markText(from, to, { replacedWith: span });
     return {
       anchor: span,
       clear: () => mark.clear()
     };
   },
 
   /**
+   * Add some text directly next to a position
+   */
+  addWidget: function (pos, text, className = "widget-text") {
+    let cm = editors.get(this);
+
+    if (this.widget) {
+      this.widget.remove();
+    }
+    let wrapper = cm.getWrapperElement();
+    let widget = this.widget = wrapper.ownerDocument.createElement("span");
+    widget.style.position = "absolute";
+    widget.className = className;
+
+    let lineHeight = cm.defaultTextHeight();
+    // let lineHeight = wrapper.ownerDocument.defaultView.getComputedStyle(wrapper, "").lineHeight;
+    widget.style.marginTop = "-" + lineHeight + "px";
+    widget.textContent = text;
+    console.log("Adding widget", pos, cm.cursorCoords(pos));
+    // cm.setBookmark(pos, {
+    //   widget: widget
+    // });
+    cm.addWidget(pos, widget);
+
+    return {
+      anchor: widget,
+      clear: () => widget.remove()
+    };
+  },
+
+  /**
    * Calculates and returns one or more {line, ch} objects for
    * a zero-based index who's value is relative to the start of
    * the editor's text.
    *
    * If only one argument is given, this method returns a single
    * {line,ch} object. Otherwise it returns an array.
    */
   getPosition: function (...args) {
diff --git a/devtools/client/sourceeditor/moz.build b/devtools/client/sourceeditor/moz.build
--- a/devtools/client/sourceeditor/moz.build
+++ b/devtools/client/sourceeditor/moz.build
@@ -5,14 +5,15 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DIRS += [
     'tern',
 ]
 
 DevToolsModules(
     'autocomplete.js',
+    'console-autocompleter.js',
     'css-autocompleter.js',
     'debugger.js',
     'editor.js'
 )
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
diff --git a/devtools/client/themes/dark-theme.css b/devtools/client/themes/dark-theme.css
--- a/devtools/client/themes/dark-theme.css
+++ b/devtools/client/themes/dark-theme.css
@@ -238,16 +238,21 @@ div.CodeMirror div.debug-line {
 /* Generic highlighted text */
 div.CodeMirror span.marked-text {
   background: rgba(255,255,0,0.2);
   border: 1px dashed rgba(192,192,0,0.6);
   -moz-margin-start: -1px;
   -moz-margin-end: -1px;
 }
 
+/* Suggestions for console */
+div.CodeMirror span.widget-text {
+  color: #808080;
+}
+
 /* Highlight for evaluating current statement. */
 div.CodeMirror span.eval-text {
   background-color: #556;
 }
 
 .cm-s-mozilla .CodeMirror-linenumber { /* line number text */
   color: var(--theme-content-color3);
 }
diff --git a/devtools/client/themes/light-theme.css b/devtools/client/themes/light-theme.css
--- a/devtools/client/themes/light-theme.css
+++ b/devtools/client/themes/light-theme.css
@@ -237,16 +237,21 @@ div.CodeMirror div.debug-line {
 /* Generic highlighted text */
 div.CodeMirror span.marked-text {
   background: rgba(255,255,0,0.2);
   border: 1px dashed rgba(192,192,0,0.6);
   -moz-margin-start: -1px;
   -moz-margin-end: -1px;
 }
 
+/* Suggestions for console */
+div.CodeMirror span.widget-text {
+  color: #808080;
+}
+
 /* Highlight for evaluating current statement. */
 div.CodeMirror span.eval-text {
   background-color: #ccd;
 }
 
 .cm-s-mozilla .CodeMirror-linenumber { /* line number text */
   color: var(--theme-content-color3);
 }
diff --git a/devtools/client/themes/webconsole.css b/devtools/client/themes/webconsole.css
--- a/devtools/client/themes/webconsole.css
+++ b/devtools/client/themes/webconsole.css
@@ -362,16 +362,25 @@ a {
 
 .theme-light .jsterm-input-container {
   /* For light theme use a white background for the input - it looks better
      than off-white */
   background-color: #fff;
   border-top-color: #e0e0e0;
 }
 
+
+#input-container iframe {
+  height: 100%;
+  width: 100%;
+  border: none;
+  margin: 0;
+  padding: 0;
+}
+
 .jsterm-input-node,
 .jsterm-complete-node {
   border: none;
   padding: 0 0 0 16px;
   -moz-appearance: none;
   background-color: transparent;
 }
 
diff --git a/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js b/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
--- a/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
+++ b/devtools/client/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
@@ -66,33 +66,33 @@ function consoleOpened(HUD) {
     for (let i = 0; i <= 3; i++) {
       jsterm.setInputValue(i);
       jsterm.execute();
     }
     is(WebConsoleUtils.usageCount, 4, "Usage count incremented");
     WebConsoleUtils.usageCount = 0;
     updateEditUIVisibility();
 
-    let oldVal = jsterm.inputNode.value;
+    let oldVal = jsterm.getInputValue();
     goDoCommand("cmd_paste");
     let notificationbox = jsterm.hud.document.getElementById("webconsole-notificationbox");
     let notification = notificationbox.getNotificationWithValue("selfxss-notification");
     ok(notification, "Self-xss notification shown");
-    is(oldVal, jsterm.inputNode.value, "Paste blocked by self-xss prevention");
+    is(oldVal, jsterm.getInputValue(), "Paste blocked by self-xss prevention");
 
     // Allow pasting
-    jsterm.inputNode.value = "allow pasting";
+    jsterm.setInputValue("allow pasting");
     let evt = document.createEvent("KeyboardEvent");
     evt.initKeyEvent("keyup", true, true, window,
                      0, 0, 0, 0,
                      0, " ".charCodeAt(0));
     jsterm.inputNode.dispatchEvent(evt);
-    jsterm.inputNode.value = "";
+    jsterm.setInputValue("");
     goDoCommand("cmd_paste");
-    isnot("", jsterm.inputNode.value, "Paste works");
+    isnot("", jsterm.getInputValue(), "Paste works");
   }
   function onClipboardPaste() {
     ok(!jsterm.completeNode.value, "no completion value after paste");
 
     info("wait for completion update after undo");
     jsterm.once("autocomplete-updated", onCompletionValueAfterUndo);
 
     // Get out of the webconsole event loop.
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -83,17 +83,17 @@ var consoleOpened = Task.async(function*
         "watch",
       ][index] === prop;
     }), "getItems returns the items we expect");
 
     is(popup.selectedIndex, 18,
        "Index of the first item from bottom is selected.");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
@@ -159,17 +159,17 @@ function popupHideAfterTab() {
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 19, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 18, "First index from bottom is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     popup._panel.addEventListener("popuphidden", function onHidden() {
       popup._panel.removeEventListener("popuphidden", onHidden, false);
@@ -207,17 +207,17 @@ function testReturnKey() {
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 19, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 18, "First index from bottom is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
-    let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
+    let prefix = jsterm.getInputValue().replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "watch", "watch is selected");
     is(completeNode.value, prefix + "watch",
         "completeNode.value holds watch");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
diff --git a/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js b/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
--- a/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
+++ b/devtools/client/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
@@ -26,17 +26,17 @@ var test = asyncTest(function* () {
   doTests(hud);
 
   jsterm = inputNode = null;
 });
 
 function doTests(HUD) {
   jsterm = HUD.jsterm;
   inputNode = jsterm.inputNode;
-  ok(!jsterm.inputNode.value, "inputNode.value is empty");
+  ok(!jsterm.getInputValue(), "inputNode.value is empty");
   is(jsterm.inputNode.selectionStart, 0);
   is(jsterm.inputNode.selectionEnd, 0);
 
   testSingleLineInputNavNoHistory();
   testMultiLineInputNavNoHistory();
   testNavWithHistory();
 }
 
diff --git a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
--- a/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
+++ b/devtools/client/webconsole/test/browser_webconsole_context_menu_store_as_global.js
@@ -52,15 +52,15 @@ add_task(function*() {
   yield waitForContextMenu(contextMenu, text, () => {
     ok(storeAsGlobalItem.disabled === true, "The \"Store as global\" " +
       "context menu item should be disabled for texts");
   });
 
   info("Waiting for input to be set");
   yield onceInputSet;
 
-  is(hud.jsterm.inputNode.value, "temp0", "Input was set");
+  is(hud.jsterm.getInputValue(), "temp0", "Input was set");
   let executedResult = yield hud.jsterm.execute();
 
   ok(executedResult.textContent.includes("{ baz: 1 }"),
      "Correct variable assigned into console");
 
 });
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -20,24 +20,27 @@ loader.lazyRequireGetter(this, "Autocomp
 loader.lazyRequireGetter(this, "ToolSidebar", "devtools/client/framework/sidebar", true);
 loader.lazyRequireGetter(this, "ConsoleOutput", "devtools/client/webconsole/console-output", true);
 loader.lazyRequireGetter(this, "Messages", "devtools/client/webconsole/console-output", true);
 loader.lazyRequireGetter(this, "asyncStorage", "devtools/shared/async-storage");
 loader.lazyRequireGetter(this, "EnvironmentClient", "devtools/shared/client/main", true);
 loader.lazyRequireGetter(this, "ObjectClient", "devtools/shared/client/main", true);
 loader.lazyRequireGetter(this, "system", "devtools/shared/system");
 loader.lazyRequireGetter(this, "Timers", "sdk/timers");
+loader.lazyRequireGetter(this, "Editor", "devtools/client/sourceeditor/editor");
 loader.lazyImporter(this, "VariablesView", "resource://devtools/client/shared/widgets/VariablesView.jsm");
 loader.lazyImporter(this, "VariablesViewController", "resource://devtools/client/shared/widgets/VariablesViewController.jsm");
 loader.lazyImporter(this, "PluralForm", "resource://gre/modules/PluralForm.jsm");
 loader.lazyImporter(this, "gDevTools", "resource://devtools/client/framework/gDevTools.jsm");
 
 const STRINGS_URI = "chrome://devtools/locale/webconsole.properties";
 var l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
+const CODEMIRROR_CONSOLE = true;
+
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 
 const MIXED_CONTENT_LEARN_MORE = "https://developer.mozilla.org/docs/Security/MixedContent";
 
 const TRACKING_PROTECTION_LEARN_MORE = "https://developer.mozilla.org/Firefox/Privacy/Tracking_Protection";
 
 const INSECURE_PASSWORDS_LEARN_MORE = "https://developer.mozilla.org/docs/Security/InsecurePasswords";
 
@@ -618,39 +621,39 @@ WebConsoleFrame.prototype = {
     /*
      * Focus input line whenever the output area is clicked.
      * Reusing _addMEssageLinkCallback since it correctly filters
      * drag and select events.
      */
     this._addFocusCallback(this.outputNode, (evt) => {
       if ((evt.target.nodeName.toLowerCase() != "a") &&
           (evt.target.parentNode.nodeName.toLowerCase() != "a")) {
-        this.jsterm.inputNode.focus();
+        this.jsterm.focus()
       }
     });
 
     // Toggle the timestamp on preference change
     gDevTools.on("pref-changed", this._onToolboxPrefChanged);
     this._onToolboxPrefChanged("pref-changed", {
       pref: PREF_MESSAGE_TIMESTAMP,
       newValue: Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP),
     });
 
     // focus input node
-    this.jsterm.inputNode.focus();
+    this.jsterm.focus();
   },
 
   /**
    * Sets the focus to JavaScript input field when the web console tab is
    * selected or when there is a split console present.
    * @private
    */
   _onPanelSelected: function WCF__onPanelSelected(evt, id)
   {
-    this.jsterm.inputNode.focus();
+    this.jsterm.focus();
   },
 
   /**
    * Initialize the default filter preferences.
    * @private
    */
   _initDefaultFilterPrefs: function WCF__initDefaultFilterPrefs()
   {
@@ -2177,16 +2180,20 @@ WebConsoleFrame.prototype = {
     if (this._outputQueue.length === 0 && this._flushCallback) {
       if (this._flushCallback() === false) {
         this._flushCallback = null;
       }
     }
 
     this._initOutputTimer();
 
+    // XXX: This is needed for now with codemirror console otherwise the
+    // input line takes up too much space...
+    this.jsterm.resizeInput();
+
     this._lastOutputFlush = Date.now();
   },
 
   /**
    * Initialize the output timer.
    * @private
    */
   _initOutputTimer: function WCF__initOutputTimer()
@@ -3010,16 +3017,66 @@ function JSTerm(aWebConsoleFrame)
   this._objectActorsInVariablesViews = new Map();
 
   this._keyPress = this._keyPress.bind(this);
   this._inputEventHandler = this._inputEventHandler.bind(this);
   this._focusEventHandler = this._focusEventHandler.bind(this);
   this._onKeypressInVariablesView = this._onKeypressInVariablesView.bind(this);
   this._blurEventHandler = this._blurEventHandler.bind(this);
 
+  if (CODEMIRROR_CONSOLE) {
+    let config = {
+      mode: Editor.modes.js,
+      value: "var xpathResult = document.evaluate( 'body/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div', document, null, XPathResult.ANY_TYPE,  );",
+      autocomplete: true,
+      lineWrapping: true,
+      extraKeys: {
+        "Enter": (e, cm) => {
+          this.execute();
+        },
+        "Up": (e, cm) => {
+          let inputUpdated = false;
+          if (this.canCaretGoPrevious()) {
+            inputUpdated = this.historyPeruse(HISTORY_BACK);
+          }
+          if (!inputUpdated) {
+            return "CodeMirror.Pass";
+          }
+        },
+        "Down": (e, cm) => {
+          let inputUpdated = false;
+          if (this.canCaretGoNext()) {
+            inputUpdated = this.historyPeruse(HISTORY_FORWARD);
+          }
+          if (!inputUpdated) {
+            return "CodeMirror.Pass";
+          }
+        },
+      },
+      autocompleteOpts: {
+        getFrameActor: this.getFrameActor.bind(this),
+        getWebConsoleClient: () => {
+          return this.hud.webConsoleClient;
+        }
+      },
+    };
+
+    this.editor = new Editor(config);
+    this.editorElement = this.hud.document.querySelector("#input-container");
+    this.editorElement.hidden = false;
+    this.hud.document.querySelector(".jsterm-stack-node").hidden = true;
+    this.editor.appendTo(this.editorElement).then(() => {
+      this.resizeInput();
+    });
+
+    this.editor.on("change", () => {
+      this._inputEventHandler();
+    });
+  }
+
   EventEmitter.decorate(this);
 }
 
 JSTerm.prototype = {
   SELECTED_FRAME: -1,
 
   /**
    * Load the console history from previous sessions.
@@ -3185,16 +3242,18 @@ JSTerm.prototype = {
   COMPLETE_PAGEUP: 3,
   COMPLETE_PAGEDOWN: 4,
 
   /**
    * Initialize the JSTerminal UI.
    */
   init: function JST_init()
   {
+    // XXX: A separate popup will be managed by the editor when CODEMIRROR_CONSOLE
+    // is true
     let autocompleteOptions = {
       onSelect: this.onAutocompleteSelect.bind(this),
       onClick: this.acceptProposedCompletion.bind(this),
       panelId: "webConsole_autocompletePopup",
       listBoxId: "webConsole_autocompletePopupListBox",
       position: "before_start",
       theme: "auto",
       direction: "ltr",
@@ -3226,19 +3285,18 @@ JSTerm.prototype = {
       this.inputNode.addEventListener("focus", this._focusEventHandler, false);
     }
 
     this.hud.window.addEventListener("blur", this._blurEventHandler, false);
     this.lastInputValue && this.setInputValue(this.lastInputValue);
   },
 
   focus: function() {
-    let inputNode = this.inputNode;
-    if (!inputNode.getAttribute("focused")) {
-      inputNode.focus();
+    if (!this.inputNode.getAttribute("focused")) {
+      this.inputNode.focus();
     }
   },
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
    * @param object [aAfterMessage]
@@ -3358,17 +3416,17 @@ JSTerm.prototype = {
     let callback = function(msg) {
       deferred.resolve(msg);
       if (aCallback) {
         aCallback(msg);
       }
     }
 
     // attempt to execute the content of the inputNode
-    aExecuteString = aExecuteString || this.inputNode.value;
+    aExecuteString = aExecuteString || this.getInputValue();
     if (!aExecuteString) {
       return;
     }
 
     let selectedNodeActor = null;
     let inspectorSelection = this.hud.owner.getInspectorSelection();
     if (inspectorSelection && inspectorSelection.nodeFront) {
       selectedNodeActor = inspectorSelection.nodeFront.actorID;
@@ -3620,17 +3678,17 @@ JSTerm.prototype = {
     let tag = aEvent.target.nodeName;
     if (aEvent.keyCode != Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE || aEvent.shiftKey ||
         aEvent.altKey || aEvent.ctrlKey || aEvent.metaKey ||
         ["input", "textarea", "select", "textbox"].indexOf(tag) > -1) {
         return;
     }
 
     this._sidebarDestroy();
-    this.inputNode.focus();
+    this.focus();
     aEvent.stopPropagation();
   },
 
   /**
    * Create a variables view instance.
    *
    * @private
    * @param object aOptions
@@ -3919,16 +3977,21 @@ JSTerm.prototype = {
 
   /**
    * Updates the size of the input field (command line) to fit its contents.
    *
    * @returns void
    */
   resizeInput: function JST_resizeInput()
   {
+    if (CODEMIRROR_CONSOLE) {
+      let height = this.editor.getScrollHeight();
+      this.editorElement.style.height = height + "px";
+      return;
+    }
     let inputNode = this.inputNode;
 
     // Reset the height so that scrollHeight will reflect the natural height of
     // the contents of the input field.
     inputNode.style.height = "auto";
 
     // Now resize the input field to fit its contents.
     let scrollHeight = inputNode.inputField.scrollHeight;
@@ -3943,34 +4006,66 @@ JSTerm.prototype = {
    * directly, because it correctly resizes the field.
    *
    * @param string aNewValue
    *        The new value to set.
    * @returns void
    */
   setInputValue: function JST_setInputValue(aNewValue)
   {
-    this.inputNode.value = aNewValue;
+    if (CODEMIRROR_CONSOLE) {
+      this.editor.setText(aNewValue);
+    } else {
+      this.inputNode.value = aNewValue;
+    }
     this.lastInputValue = aNewValue;
     this.completeNode.value = "";
     this.resizeInput();
     this._inputChanged = true;
     this.emit("set-input-value");
   },
 
   /**
+   * Gets the value from the input field
+   */
+  getInputValue: function()
+  {
+    if (CODEMIRROR_CONSOLE) {
+      return this.editor.getText() || "";
+    } else {
+      return this.inputNode.value || "";
+    }
+  },
+
+  get somethingSelected() {
+    if (CODEMIRROR_CONSOLE) {
+      return this.editor.somethingSelected();
+    } else {
+      return this.inputNode.selectionStart === this.inputNode.selectionEnd;
+    }
+  },
+
+  get selectionStart() {
+    if (CODEMIRROR_CONSOLE) {
+
+    } else {
+      return this.inputNode.selectionStart;
+    }
+  },
+
+  /**
    * The inputNode "input" and "keyup" event handler.
    * @private
    */
   _inputEventHandler: function JST__inputEventHandler()
   {
-    if (this.lastInputValue != this.inputNode.value) {
+    if (this.lastInputValue != this.getInputValue()) {
       this.resizeInput();
       this.complete(this.COMPLETE_HINT_ONLY);
-      this.lastInputValue = this.inputNode.value;
+      this.lastInputValue = this.getInputValue();
       this._inputChanged = true;
     }
   },
 
   /**
    * The window "blur" event handler.
    * @private
    */
@@ -3987,24 +4082,25 @@ JSTerm.prototype = {
    * @private
    * @param nsIDOMEvent aEvent
    */
   _keyPress: function JST__keyPress(aEvent)
   {
     let inputNode = this.inputNode;
     let inputUpdated = false;
 
+
     if (aEvent.ctrlKey) {
       switch (aEvent.charCode) {
         case 101:
           // control-e
           if (Services.appinfo.OS == "WINNT") {
             break;
           }
-          let lineEndPos = inputNode.value.length;
+          let lineEndPos = this.getInputValue().length;
           if (this.hasMultilineInput()) {
             // find index of closest newline >= cursor
             for (let i = inputNode.selectionEnd; i<lineEndPos; i++) {
               if (inputNode.value.charAt(i) == "\r" ||
                   inputNode.value.charAt(i) == "\n") {
                 lineEndPos = i;
                 break;
               }
@@ -4171,18 +4267,17 @@ JSTerm.prototype = {
 
       case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
         if (this.autocompletePopup.isOpen || this.lastCompletion.value) {
           this.clearCompletion();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_RIGHT: {
-        let cursorAtTheEnd = this.inputNode.selectionStart ==
-                             this.inputNode.selectionEnd &&
+        let cursorAtTheEnd = this.somethingSelected &&
                              this.inputNode.selectionStart ==
                              this.inputNode.value.length;
         let haveSuggestion = this.autocompletePopup.isOpen ||
                              this.lastCompletion.value;
         let useCompletion = cursorAtTheEnd || this._autocompletePopupNavigated;
         if (haveSuggestion && useCompletion &&
             this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion.value &&
@@ -4242,17 +4337,17 @@ JSTerm.prototype = {
       }
       let inputVal = this.history[--this.historyPlaceHolder];
 
       // Save the current input value as the latest entry in history, only if
       // the user is already at the last entry.
       // Note: this code does not store changes to items that are already in
       // history.
       if (this.historyPlaceHolder+1 == this.historyIndex) {
-        this.history[this.historyIndex] = this.inputNode.value || "";
+        this.history[this.historyIndex] = this.getInputValue() || "";
       }
 
       this.setInputValue(inputVal);
     }
     // Down Arrow key
     else if (aDirection == HISTORY_FORWARD) {
       if (this.historyPlaceHolder >= (this.history.length-1)) {
         return false;
@@ -4271,59 +4366,81 @@ JSTerm.prototype = {
   /**
    * Test for multiline input.
    *
    * @return boolean
    *         True if CR or LF found in node value; else false.
    */
   hasMultilineInput: function JST_hasMultilineInput()
   {
-    return /[\r\n]/.test(this.inputNode.value);
+    return /[\r\n]/.test(this.getInputValue());
   },
 
   /**
    * Check if the caret is at a location that allows selecting the previous item
    * in history when the user presses the Up arrow key.
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the
    *         previous item in history when the user presses the Up arrow key,
    *         otherwise false.
    */
   canCaretGoPrevious: function JST_canCaretGoPrevious()
   {
-    let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
+    if (this.somethingSelected) {
       return false;
     }
 
-    let multiline = /[\r\n]/.test(node.value);
-    return node.selectionStart == 0 ? true :
-           node.selectionStart == node.value.length && !multiline;
+    if (CODEMIRROR_CONSOLE) {
+      let cursor = this.editor.getCursor();
+      if (cursor.line === 0 && cursor.ch === 0) {
+        return true;
+      }
+
+      return false;
+    } else {
+      let node = this.inputNode;
+
+      let multiline = /[\r\n]/.test(node.value);
+      return node.selectionStart == 0 ? true :
+             node.selectionStart == node.value.length && !multiline;
+    }
   },
 
   /**
    * Check if the caret is at a location that allows selecting the next item in
    * history when the user presses the Down arrow key.
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the next
    *         item in history when the user presses the Down arrow key, otherwise
    *         false.
    */
   canCaretGoNext: function JST_canCaretGoNext()
   {
-    let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
+    if (this.somethingSelected) {
       return false;
     }
-
-    let multiline = /[\r\n]/.test(node.value);
-    return node.selectionStart == node.value.length ? true :
-           node.selectionStart == 0 && !multiline;
+    if (CODEMIRROR_CONSOLE) {
+      let cursor = this.editor.getCursor();
+      let value = this.getInputValue();
+      let lines = value.split(/[\r\n]/);
+      if (cursor.line === lines.length - 1 &&
+          cursor.ch === lines[lines.length - 1].length) {
+        return true;
+      }
+
+      return false;
+    } else {
+      let node = this.inputNode;
+
+      let multiline = /[\r\n]/.test(node.value);
+      return node.selectionStart == node.value.length ? true :
+             node.selectionStart == 0 && !multiline;
+    }
   },
 
   /**
    * Completes the current typed text in the inputNode. Completion is performed
    * only if the selection/cursor is at the end of the string. If no completion
    * is found, the current inputNode value and cursor/selection stay.
    *
    * @param int aType possible values are
@@ -4352,29 +4469,29 @@ JSTerm.prototype = {
    *        Optional function invoked when the autocomplete properties are
    *        updated.
    * @returns boolean true if there existed a completion for the current input,
    *          or false otherwise.
    */
   complete: function JSTF_complete(aType, aCallback)
   {
     let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
+    let inputValue = this.getInputValue();
     let frameActor = this.getFrameActor(this.SELECTED_FRAME);
 
     // If the inputNode has no value, then don't try to complete on it.
     if (!inputValue) {
       this.clearCompletion();
       aCallback && aCallback(this);
       this.emit("autocomplete-updated");
       return false;
     }
 
     // Only complete if the selection is empty.
-    if (inputNode.selectionStart != inputNode.selectionEnd) {
+    if (this.somethingSelected) {
       this.clearCompletion();
       aCallback && aCallback(this);
       this.emit("autocomplete-updated");
       return false;
     }
 
     // Update the completion results.
     if (this.lastCompletion.value != inputValue || frameActor != this._lastFrameActorId) {
@@ -4416,23 +4533,24 @@ JSTerm.prototype = {
    *        Completion type. See this.complete() for details.
    * @param function [aCallback]
    *        Optional, function to invoke when completion results are received.
    */
   _updateCompletionResult:
   function JST__updateCompletionResult(aType, aCallback)
   {
     let frameActor = this.getFrameActor(this.SELECTED_FRAME);
-    if (this.lastCompletion.value == this.inputNode.value && frameActor == this._lastFrameActorId) {
+    if (this.lastCompletion.value == this.getInputValue() &&
+        frameActor == this._lastFrameActorId) {
       return;
     }
 
     let requestId = gSequenceId();
     let cursor = this.inputNode.selectionStart;
-    let input = this.inputNode.value.substring(0, cursor);
+    let input = this.getInputValue().substring(0, cursor);
     let cache = this._autocompleteCache;
 
     // If the current input starts with the previous input, then we already
     // have a list of suggestions and we just need to filter the cached
     // suggestions. When the current input ends with a non-alphanumeric
     // character we ask the server again for suggestions.
 
     // Check if last character is non-alphanumeric
@@ -4492,17 +4610,17 @@ JSTerm.prototype = {
    * @param object aMessage
    *        The JSON message which holds the completion results received from
    *        the content process.
    */
   _receiveAutocompleteProperties:
   function JST__receiveAutocompleteProperties(aRequestId, aCallback, aMessage)
   {
     let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
+    let inputValue = this.getInputValue();
     if (this.lastCompletion.value == inputValue ||
         aRequestId != this.lastCompletion.requestId) {
       return;
     }
     // Cache whatever came from the server if the last char is alphanumeric or '.'
     let cursor = inputNode.selectionStart;
     let inputUntilCursor = inputValue.substring(0, cursor);
 
@@ -4529,17 +4647,17 @@ JSTerm.prototype = {
 
     let completionType = this.lastCompletion.completionType;
     this.lastCompletion = {
       value: inputValue,
       matchProp: lastPart,
     };
 
     if (items.length > 1 && !popup.isOpen) {
-      let str = this.inputNode.value.substr(0, this.inputNode.selectionStart);
+      let str = this.getInputValue().substr(0, this.inputNode.selectionStart);
       let offset = str.length - (str.lastIndexOf("\n") + 1) - lastPart.length;
       let x = offset * this.hud._inputCharWidth;
       popup.openPopup(inputNode, x + this.hud._chevronWidth);
       this._autocompletePopupNavigated = false;
     }
     else if (items.length < 2 && popup.isOpen) {
       popup.hidePopup();
       this._autocompletePopupNavigated = false;
@@ -4563,17 +4681,17 @@ JSTerm.prototype = {
 
     aCallback && aCallback(this);
     this.emit("autocomplete-updated");
   },
 
   onAutocompleteSelect: function JSTF_onAutocompleteSelect()
   {
     // Render the suggestion only if the cursor is at the end of the input.
-    if (this.inputNode.selectionStart != this.inputNode.value.length) {
+    if (this.inputNode.selectionStart != this.getInputValue().length) {
       return;
     }
 
     let currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.updateCompleteNode(suffix);
@@ -4609,17 +4727,17 @@ JSTerm.prototype = {
   {
     let updated = false;
 
     let currentItem = this.autocompletePopup.selectedItem;
     if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       let cursor = this.inputNode.selectionStart;
-      let value = this.inputNode.value;
+      let value = this.getInputValue();
       this.setInputValue(value.substr(0, cursor) + suffix + value.substr(cursor));
       let newCursor = cursor + suffix.length;
       this.inputNode.selectionStart = this.inputNode.selectionEnd = newCursor;
       updated = true;
     }
 
     this.clearCompletion();
 
@@ -4630,17 +4748,17 @@ JSTerm.prototype = {
    * Update the node that displays the currently selected autocomplete proposal.
    *
    * @param string aSuffix
    *        The proposed suffix for the inputNode value.
    */
   updateCompleteNode: function JSTF_updateCompleteNode(aSuffix)
   {
     // completion prefix = input, with non-control chars replaced by spaces
-    let prefix = aSuffix ? this.inputNode.value.replace(/[\S]/g, " ") : "";
+    let prefix = aSuffix ? this.getInputValue().replace(/[\S]/g, " ") : "";
     this.completeNode.value = prefix + aSuffix;
   },
 
 
   /**
    * Destroy the sidebar.
    * @private
    */
diff --git a/devtools/client/webconsole/webconsole.xul b/devtools/client/webconsole/webconsole.xul
--- a/devtools/client/webconsole/webconsole.xul
+++ b/devtools/client/webconsole/webconsole.xul
@@ -207,16 +207,17 @@ function goUpdateConsoleCommands() {
       </toolbar>
 
       <hbox id="output-wrapper" flex="1" context="output-contextmenu" tooltip="aHTMLTooltip">
         <div xmlns="http://www.w3.org/1999/xhtml" id="output-container"
              tabindex="0" role="document" aria-live="polite" />
       </hbox>
       <notificationbox id="webconsole-notificationbox">
         <hbox class="jsterm-input-container" style="direction:ltr">
+          <box id="input-container" flex="1" style="min-height: 20px;" hidden="true"></box>
           <stack class="jsterm-stack-node" flex="1">
             <textbox class="jsterm-complete-node devtools-monospace"
                      multiline="true" rows="1" tabindex="-1"/>
             <textbox class="jsterm-input-node devtools-monospace"
                      multiline="true" rows="1" tabindex="0"
                      aria-autocomplete="list"/>
           </stack>
         </hbox>
