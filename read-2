# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7e0886a94d70b8696d6fc0481d9f9ae12b85c41a
Bug 1608281 - Automated rewrite away from reading properties to `this` in JSM files - Round 1

This patch was generated with a script. It doesn't include all files:

- Files that use the preprocessor or fail to parse are skipped
- Files that are loaded as JSMs but don't use the .jsm extension are skipped (those will be renamed in Bug 1609269)

It was generated with the following command:

hg revert --all &&
cp .gitignore .rgignore &&
rg --files-without-match -g '*.jsm' '^#endif|^#include|^#filter' | jscodeshift --stdin --transform ~/Code/jsm-rewrites/no-this-property-read.js --ignore-pattern ./mobile/android/modules/Sanitizer.jsm --ignore-pattern ./js/xpconnect/tests/unit/syntax_error.jsm &&
./mach eslint `hg st | rg '^M ' | sed 's/^M //'`

diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -4439,18 +4439,18 @@ var CustomizableUI = {
 
     parent.appendChild(aSubview);
   },
 
   getCustomizationTarget(aElement) {
     return CustomizableUIInternal.getCustomizationTarget(aElement);
   },
 };
-Object.freeze(this.CustomizableUI);
-Object.freeze(this.CustomizableUI.windows);
+Object.freeze(CustomizableUI);
+Object.freeze(CustomizableUI.windows);
 
 /**
  * All external consumers of widgets are really interacting with these wrappers
  * which provide a common interface.
  */
 
 /**
  * WidgetGroupWrapper is the common interface for interacting with an entire
diff --git a/browser/components/downloads/DownloadsCommon.jsm b/browser/components/downloads/DownloadsCommon.jsm
--- a/browser/components/downloads/DownloadsCommon.jsm
+++ b/browser/components/downloads/DownloadsCommon.jsm
@@ -657,20 +657,20 @@ var DownloadsCommon = {
       s.unblockButtonConfirmBlock,
       null,
       {}
     );
     return [firstButtonAction, "cancel", "confirmBlock"][rv];
   },
 };
 
-XPCOMUtils.defineLazyGetter(this.DownloadsCommon, "log", () => {
+XPCOMUtils.defineLazyGetter(DownloadsCommon, "log", () => {
   return DownloadsLogger.log.bind(DownloadsLogger);
 });
-XPCOMUtils.defineLazyGetter(this.DownloadsCommon, "error", () => {
+XPCOMUtils.defineLazyGetter(DownloadsCommon, "error", () => {
   return DownloadsLogger.error.bind(DownloadsLogger);
 });
 
 /**
  * Returns true if we are executing on Windows Vista or a later version.
  */
 XPCOMUtils.defineLazyGetter(DownloadsCommon, "isWinVistaOrHigher", function() {
   let os = Services.appinfo.OS;
diff --git a/browser/components/downloads/DownloadsViewUI.jsm b/browser/components/downloads/DownloadsViewUI.jsm
--- a/browser/components/downloads/DownloadsViewUI.jsm
+++ b/browser/components/downloads/DownloadsViewUI.jsm
@@ -107,17 +107,17 @@ var DownloadsViewUI = {
       return "";
     }
 
     let [size, unit] = DownloadUtils.convertByteUnits(download.target.size);
     return DownloadsCommon.strings.sizeWithUnits(size, unit);
   },
 };
 
-this.DownloadsViewUI.BaseView = class {
+DownloadsViewUI.BaseView = class {
   canClearDownloads(nodeContainer) {
     // Downloads can be cleared if there's at least one removable download in
     // the list (either a history download or a completed session download).
     // Because history downloads are always removable and are listed after the
     // session downloads, check from bottom to top.
     for (let elt = nodeContainer.lastChild; elt; elt = elt.previousSibling) {
       // Stopped, paused, and failed downloads with partial data are removed.
       let download = elt._shell.download;
@@ -137,19 +137,19 @@ this.DownloadsViewUI.BaseView = class {
  * from the JavaScript API for downloads, and commands are executed using a
  * combination of Download methods and DownloadsCommon.jsm helper functions.
  *
  * Specialized versions of this shell must be defined, and they are required to
  * implement the "download" property or getter. Currently these objects are the
  * HistoryDownloadElementShell and the DownloadsViewItem for the panel. The
  * history view may use a HistoryDownload object in place of a Download object.
  */
-this.DownloadsViewUI.DownloadElementShell = function() {};
+DownloadsViewUI.DownloadElementShell = function() {};
 
-this.DownloadsViewUI.DownloadElementShell.prototype = {
+DownloadsViewUI.DownloadElementShell.prototype = {
   /**
    * The richlistitem for the download, initialized by the derived object.
    */
   element: null,
 
   /**
    * Manages the "active" state of the shell. By default all the shells are
    * inactive, thus their UI is not updated. They must be activated when
diff --git a/browser/components/sessionstore/SessionWorker.jsm b/browser/components/sessionstore/SessionWorker.jsm
--- a/browser/components/sessionstore/SessionWorker.jsm
+++ b/browser/components/sessionstore/SessionWorker.jsm
@@ -13,9 +13,9 @@ ChromeUtils.import("resource://gre/modul
 
 var EXPORTED_SYMBOLS = ["SessionWorker"];
 
 var SessionWorker = new BasePromiseWorker(
   "resource:///modules/sessionstore/SessionWorker.js"
 );
 // As the Session Worker performs I/O, we can receive instances of
 // OS.File.Error, so we need to install a decoder.
-this.SessionWorker.ExceptionHandlers["OS.File.Error"] = OS.File.Error.fromMsg;
+SessionWorker.ExceptionHandlers["OS.File.Error"] = OS.File.Error.fromMsg;
diff --git a/browser/components/translation/BingTranslator.jsm b/browser/components/translation/BingTranslator.jsm
--- a/browser/components/translation/BingTranslator.jsm
+++ b/browser/components/translation/BingTranslator.jsm
@@ -52,17 +52,17 @@ var BingTranslator = function(
   this.sourceLanguage = sourceLanguage;
   this.targetLanguage = targetLanguage;
   this._pendingRequests = 0;
   this._partialSuccess = false;
   this._serviceUnavailable = false;
   this._translatedCharacterCount = 0;
 };
 
-this.BingTranslator.prototype = {
+BingTranslator.prototype = {
   /**
    * Performs the translation, splitting the document into several chunks
    * respecting the data limits of the API.
    *
    * @returns {Promise}          A promise that will resolve when the translation
    *                             task is finished.
    */
   translate() {
diff --git a/browser/components/translation/GoogleTranslator.jsm b/browser/components/translation/GoogleTranslator.jsm
--- a/browser/components/translation/GoogleTranslator.jsm
+++ b/browser/components/translation/GoogleTranslator.jsm
@@ -50,17 +50,17 @@ var GoogleTranslator = function(
   this.translationDocument = translationDocument;
   this.sourceLanguage = sourceLanguage;
   this.targetLanguage = targetLanguage;
   this._pendingRequests = 0;
   this._partialSuccess = false;
   this._translatedCharacterCount = 0;
 };
 
-this.GoogleTranslator.prototype = {
+GoogleTranslator.prototype = {
   /**
    * Performs the translation, splitting the document into several chunks
    * respecting the data limits of the API.
    *
    * @returns {Promise}          A promise that will resolve when the translation
    *                             task is finished.
    */
   async translate() {
diff --git a/browser/components/translation/Translation.jsm b/browser/components/translation/Translation.jsm
--- a/browser/components/translation/Translation.jsm
+++ b/browser/components/translation/Translation.jsm
@@ -500,9 +500,9 @@ var TranslationTelemetry = {
   },
 
   _recordOpportunity(language, success) {
     this.HISTOGRAMS.OPPORTUNITIES().add(success);
     this.HISTOGRAMS.OPPORTUNITIES_BY_LANG().add(language, success);
   },
 };
 
-this.TranslationTelemetry.init();
+TranslationTelemetry.init();
diff --git a/browser/components/translation/TranslationDocument.jsm b/browser/components/translation/TranslationDocument.jsm
--- a/browser/components/translation/TranslationDocument.jsm
+++ b/browser/components/translation/TranslationDocument.jsm
@@ -22,17 +22,17 @@ XPCOMUtils.defineLazyGlobalGetters(this,
  * @param document  The document to be translated
  */
 var TranslationDocument = function(document) {
   this.itemsMap = new Map();
   this.roots = [];
   this._init(document);
 };
 
-this.TranslationDocument.prototype = {
+TranslationDocument.prototype = {
   translatedFrom: "",
   translatedTo: "",
   translationError: false,
   originalShown: true,
 
   /**
    * Initializes the object and populates
    * the roots lists.
diff --git a/browser/components/translation/YandexTranslator.jsm b/browser/components/translation/YandexTranslator.jsm
--- a/browser/components/translation/YandexTranslator.jsm
+++ b/browser/components/translation/YandexTranslator.jsm
@@ -68,17 +68,17 @@ var YandexTranslator = function(
   this.sourceLanguage = sourceLanguage;
   this.targetLanguage = targetLanguage;
   this._pendingRequests = 0;
   this._partialSuccess = false;
   this._serviceUnavailable = false;
   this._translatedCharacterCount = 0;
 };
 
-this.YandexTranslator.prototype = {
+YandexTranslator.prototype = {
   /**
    * Performs the translation, splitting the document into several chunks
    * respecting the data limits of the API.
    *
    * @returns {Promise}          A promise that will resolve when the translation
    *                             task is finished.
    */
   translate() {
diff --git a/browser/components/uitour/UITour.jsm b/browser/components/uitour/UITour.jsm
--- a/browser/components/uitour/UITour.jsm
+++ b/browser/components/uitour/UITour.jsm
@@ -2013,17 +2013,17 @@ var UITour = {
         let global = contextToVisit.currentWindowGlobal;
         let actor = global.getActor("UITour");
         actor.sendAsyncMessage("UITour:SendPageNotification", detail);
       }
     }
   },
 };
 
-this.UITour.init();
+UITour.init();
 
 /**
  * UITour Health Report
  */
 /**
  * Public API to be called by the UITour code
  */
 const UITourHealthReport = {
diff --git a/browser/extensions/formautofill/FormAutofillHeuristics.jsm b/browser/extensions/formautofill/FormAutofillHeuristics.jsm
--- a/browser/extensions/formautofill/FormAutofillHeuristics.jsm
+++ b/browser/extensions/formautofill/FormAutofillHeuristics.jsm
@@ -1213,38 +1213,34 @@ this.FormAutofillHeuristics = {
     // {REGEX_SEPARATOR, FIELD_NONE, 0},
 
     // Phone: <phone> (Ext: <ext>)?
     // {REGEX_PHONE, FIELD_PHONE, 0},
     // {REGEX_SEPARATOR, FIELD_NONE, 0},
   ],
 };
 
-XPCOMUtils.defineLazyGetter(this.FormAutofillHeuristics, "RULES", () => {
+XPCOMUtils.defineLazyGetter(FormAutofillHeuristics, "RULES", () => {
   let sandbox = {};
   const HEURISTICS_REGEXP = "chrome://formautofill/content/heuristicsRegexp.js";
   Services.scriptloader.loadSubScript(HEURISTICS_REGEXP, sandbox);
   return sandbox.HeuristicsRegExp.RULES;
 });
 
-XPCOMUtils.defineLazyGetter(this.FormAutofillHeuristics, "_prefEnabled", () => {
+XPCOMUtils.defineLazyGetter(FormAutofillHeuristics, "_prefEnabled", () => {
   return Services.prefs.getBoolPref(PREF_HEURISTICS_ENABLED);
 });
 
 Services.prefs.addObserver(PREF_HEURISTICS_ENABLED, () => {
-  this.FormAutofillHeuristics._prefEnabled = Services.prefs.getBoolPref(
+  FormAutofillHeuristics._prefEnabled = Services.prefs.getBoolPref(
     PREF_HEURISTICS_ENABLED
   );
 });
 
-XPCOMUtils.defineLazyGetter(
-  this.FormAutofillHeuristics,
-  "_sectionEnabled",
-  () => {
-    return Services.prefs.getBoolPref(PREF_SECTION_ENABLED);
-  }
-);
+XPCOMUtils.defineLazyGetter(FormAutofillHeuristics, "_sectionEnabled", () => {
+  return Services.prefs.getBoolPref(PREF_SECTION_ENABLED);
+});
 
 Services.prefs.addObserver(PREF_SECTION_ENABLED, () => {
-  this.FormAutofillHeuristics._sectionEnabled = Services.prefs.getBoolPref(
+  FormAutofillHeuristics._sectionEnabled = Services.prefs.getBoolPref(
     PREF_SECTION_ENABLED
   );
 });
diff --git a/browser/modules/PageActions.jsm b/browser/modules/PageActions.jsm
--- a/browser/modules/PageActions.jsm
+++ b/browser/modules/PageActions.jsm
@@ -1102,26 +1102,26 @@ Action.prototype = {
     return builtInIDs.includes(this.id);
   },
 
   get _isMozillaAction() {
     return this._isBuiltIn || this.id == "webcompat-reporter_mozilla_org";
   },
 };
 
-this.PageActions.Action = Action;
+PageActions.Action = Action;
 
-this.PageActions.ACTION_ID_BUILT_IN_SEPARATOR = ACTION_ID_BUILT_IN_SEPARATOR;
-this.PageActions.ACTION_ID_TRANSIENT_SEPARATOR = ACTION_ID_TRANSIENT_SEPARATOR;
+PageActions.ACTION_ID_BUILT_IN_SEPARATOR = ACTION_ID_BUILT_IN_SEPARATOR;
+PageActions.ACTION_ID_TRANSIENT_SEPARATOR = ACTION_ID_TRANSIENT_SEPARATOR;
 
 // These are only necessary so that Pocket and the test can use them.
-this.PageActions.ACTION_ID_BOOKMARK = ACTION_ID_BOOKMARK;
-this.PageActions.ACTION_ID_PIN_TAB = ACTION_ID_PIN_TAB;
-this.PageActions.ACTION_ID_BOOKMARK_SEPARATOR = ACTION_ID_BOOKMARK_SEPARATOR;
-this.PageActions.PREF_PERSISTED_ACTIONS = PREF_PERSISTED_ACTIONS;
+PageActions.ACTION_ID_BOOKMARK = ACTION_ID_BOOKMARK;
+PageActions.ACTION_ID_PIN_TAB = ACTION_ID_PIN_TAB;
+PageActions.ACTION_ID_BOOKMARK_SEPARATOR = ACTION_ID_BOOKMARK_SEPARATOR;
+PageActions.PREF_PERSISTED_ACTIONS = PREF_PERSISTED_ACTIONS;
 
 // Sorted in the order in which they should appear in the page action panel.
 // Does not include the page actions of extensions bundled with the browser.
 // They're added by the relevant extension code.
 // NOTE: If you add items to this list (or system add-on actions that we
 // want to keep track of), make sure to also update Histograms.json for the
 // new actions.
 var gBuiltInActions = [
diff --git a/devtools/shared/Loader.jsm b/devtools/shared/Loader.jsm
--- a/devtools/shared/Loader.jsm
+++ b/devtools/shared/Loader.jsm
@@ -173,9 +173,9 @@ this.loader = new DevToolsLoader({
    * B2G.  It is not the default case for desktop Firefox because we offer the
    * Browser Toolbox for chrome debugging there, which uses its own, separate
    * loader instance.
    * @see devtools/client/framework/browser-toolbox/Launcher.jsm
    */
   invisibleToDebugger: Services.appinfo.name !== "Firefox",
 });
 
-this.require = this.loader.require;
+this.require = loader.require;
diff --git a/devtools/startup/DevToolsShim.jsm b/devtools/startup/DevToolsShim.jsm
--- a/devtools/startup/DevToolsShim.jsm
+++ b/devtools/startup/DevToolsShim.jsm
@@ -312,17 +312,17 @@ const webExtensionsMethods = [
   "createTargetForTab",
   "createWebExtensionInspectedWindowFront",
   "getTargetForTab",
   "getTheme",
   "openBrowserConsole",
 ];
 
 for (const method of webExtensionsMethods) {
-  this.DevToolsShim[method] = function() {
+  DevToolsShim[method] = function() {
     if (!this.isEnabled()) {
       throw new Error(
         "Could not call a DevToolsShim webextension method ('" +
           method +
           "'): DevTools are not initialized."
       );
     }
 
diff --git a/dom/push/PushDB.jsm b/dom/push/PushDB.jsm
--- a/dom/push/PushDB.jsm
+++ b/dom/push/PushDB.jsm
@@ -26,17 +26,17 @@ function PushDB(dbName, dbVersion, dbSto
   this._dbStoreName = dbStoreName;
   this._keyPath = keyPath;
   this._model = model;
 
   // set the indexeddb database
   this.initDBHelper(dbName, dbVersion, [dbStoreName]);
 }
 
-this.PushDB.prototype = {
+PushDB.prototype = {
   __proto__: IndexedDBHelper.prototype,
 
   toPushRecord(record) {
     if (!record) {
       return null;
     }
     return new this._model(record);
   },
diff --git a/intl/l10n/L10nRegistry.jsm b/intl/l10n/L10nRegistry.jsm
--- a/intl/l10n/L10nRegistry.jsm
+++ b/intl/l10n/L10nRegistry.jsm
@@ -727,17 +727,17 @@ this.L10nRegistry = new L10nRegistryServ
  * always produce a promise rejection.
  *
  * We keep it as a method to make it easier to override for testing purposes.
  *
  * @param {string} url
  *
  * @returns {Promise<string>}
  */
-this.L10nRegistry.load = function(url) {
+L10nRegistry.load = function(url) {
   return fetch(url).then(response => {
     if (!response.ok) {
       return Promise.reject(response.statusText);
     }
     return response.text();
   });
 };
 
@@ -748,17 +748,17 @@ this.L10nRegistry.load = function(url) {
  *
  * Notice: Any changes to this method should be copied
  * to the `generateResourceSetSync` equivalent below.
  *
  * @param {string} url
  *
  * @returns {string}
  */
-this.L10nRegistry.loadSync = function(uri) {
+L10nRegistry.loadSync = function(uri) {
   try {
     let url = Services.io.newURI(uri);
     let data = Cu.readUTF8URI(url);
     return data;
   } catch (e) {
     if (
       e.result == Cr.NS_ERROR_INVALID_ARG ||
       e.result == Cr.NS_ERROR_NOT_INITIALIZED
diff --git a/layout/tools/reftest/globals.jsm b/layout/tools/reftest/globals.jsm
--- a/layout/tools/reftest/globals.jsm
+++ b/layout/tools/reftest/globals.jsm
@@ -158,10 +158,10 @@ for (let [key, val] of Object.entries({
 
     manifestsLoaded: {},
     // Only dump the sandbox once, because it doesn't depend on the
     // manifest URL (yet!).
     dumpedConditionSandbox: false,
   }
 })) {
   this[key] = val;
-  this.EXPORTED_SYMBOLS.push(key);
+  EXPORTED_SYMBOLS.push(key);
 }
diff --git a/mobile/android/modules/FxAccountsWebChannel.jsm b/mobile/android/modules/FxAccountsWebChannel.jsm
--- a/mobile/android/modules/FxAccountsWebChannel.jsm
+++ b/mobile/android/modules/FxAccountsWebChannel.jsm
@@ -57,17 +57,17 @@ ChromeUtils.defineModuleGetter(
 ChromeUtils.defineModuleGetter(
   this,
   "UITelemetry",
   "resource://gre/modules/UITelemetry.jsm"
 );
 
 this.FxAccountsWebChannelHelpers = function() {};
 
-this.FxAccountsWebChannelHelpers.prototype = {
+FxAccountsWebChannelHelpers.prototype = {
   /**
    * Get the hash of account name of the previously signed in account.
    */
   getPreviousAccountNameHashPref() {
     try {
       return Services.prefs.getStringPref(PREF_LAST_FXA_USER);
     } catch (_) {
       return "";
@@ -131,17 +131,17 @@ this.FxAccountsWebChannel = function(opt
   this._webChannelId = options.channel_id;
 
   // options.helpers is only specified by tests.
   this._helpers = options.helpers || new FxAccountsWebChannelHelpers(options);
 
   this._setupChannel();
 };
 
-this.FxAccountsWebChannel.prototype = {
+FxAccountsWebChannel.prototype = {
   /**
    * WebChannel that is used to communicate with content page
    */
   _channel: null,
 
   /**
    * WebChannel ID.
    */
@@ -518,14 +518,14 @@ var singleton;
 // allowing multiple channels would cause such notifications to be sent multiple
 // times.
 var EnsureFxAccountsWebChannel = () => {
   if (!singleton) {
     let contentUri = Services.urlFormatter.formatURLPref(
       "identity.fxaccounts.remote.webchannel.uri"
     );
     // The FxAccountsWebChannel listens for events and updates the Java layer.
-    singleton = new this.FxAccountsWebChannel({
+    singleton = new FxAccountsWebChannel({
       content_uri: contentUri,
       channel_id: WEBCHANNEL_ID,
     });
   }
 };
diff --git a/services/fxaccounts/FxAccountsClient.jsm b/services/fxaccounts/FxAccountsClient.jsm
--- a/services/fxaccounts/FxAccountsClient.jsm
+++ b/services/fxaccounts/FxAccountsClient.jsm
@@ -44,17 +44,17 @@ var FxAccountsClient = function(host = S
   this.hawk = new HawkClient(host);
   this.hawk.observerPrefix = "FxA:hawk";
 
   // Manage server backoff state. C.f.
   // https://github.com/mozilla/fxa-auth-server/blob/master/docs/api.md#backoff-protocol
   this.backoffError = null;
 };
 
-this.FxAccountsClient.prototype = {
+FxAccountsClient.prototype = {
   /**
    * Return client clock offset, in milliseconds, as determined by hawk client.
    * Provided because callers should not have to know about hawk
    * implementation.
    *
    * The offset is the number of milliseconds that must be added to the client
    * clock to make it equal to the server clock.  For example, if the client is
    * five minutes ahead of the server, the localtimeOffsetMsec will be -300000.
diff --git a/services/fxaccounts/FxAccountsOAuthGrantClient.jsm b/services/fxaccounts/FxAccountsOAuthGrantClient.jsm
--- a/services/fxaccounts/FxAccountsOAuthGrantClient.jsm
+++ b/services/fxaccounts/FxAccountsOAuthGrantClient.jsm
@@ -67,17 +67,17 @@ var FxAccountsOAuthGrantClient = functio
   let forceHTTPS = !Services.prefs.getBoolPref(ALLOW_HTTP_PREF, false);
   if (forceHTTPS && this.serverURL.protocol != "https:") {
     throw new Error("'serverURL' must be HTTPS");
   }
 
   log.debug("FxAccountsOAuthGrantClient Initialized");
 };
 
-this.FxAccountsOAuthGrantClient.prototype = {
+FxAccountsOAuthGrantClient.prototype = {
   /**
    * Retrieves an OAuth access token for the signed in user
    *
    * @param {Object} assertion BrowserID assertion
    * @param {String} scope OAuth scope
    * @return Promise
    *        Resolves: {Object} Object with access_token property
    */
diff --git a/services/fxaccounts/FxAccountsProfile.jsm b/services/fxaccounts/FxAccountsProfile.jsm
--- a/services/fxaccounts/FxAccountsProfile.jsm
+++ b/services/fxaccounts/FxAccountsProfile.jsm
@@ -44,17 +44,17 @@ var FxAccountsProfile = function(options
   // just incase this.tearDown isn't called in some cases.
   Services.obs.addObserver(this, ON_PROFILE_CHANGE_NOTIFICATION, true);
   // for testing
   if (options.channel) {
     this.channel = options.channel;
   }
 };
 
-this.FxAccountsProfile.prototype = {
+FxAccountsProfile.prototype = {
   // If we get subsequent requests for a profile within this period, don't bother
   // making another request to determine if it is fresh or not.
   PROFILE_FRESHNESS_THRESHOLD: 120000, // 2 minutes
 
   observe(subject, topic, data) {
     // If we get a profile change notification from our webchannel it means
     // the user has just changed their profile via the web, so we want to
     // ignore our "freshness threshold"
diff --git a/services/fxaccounts/FxAccountsProfileClient.jsm b/services/fxaccounts/FxAccountsProfileClient.jsm
--- a/services/fxaccounts/FxAccountsProfileClient.jsm
+++ b/services/fxaccounts/FxAccountsProfileClient.jsm
@@ -67,17 +67,17 @@ var FxAccountsProfileClient = function(o
     throw new Error("Invalid 'serverURL'");
   }
   this.oauthOptions = {
     scope: SCOPE_PROFILE,
   };
   log.debug("FxAccountsProfileClient: Initialized");
 };
 
-this.FxAccountsProfileClient.prototype = {
+FxAccountsProfileClient.prototype = {
   /**
    * {nsIURI}
    * The server to fetch profile information from.
    */
   serverURL: null,
 
   /**
    * Interface for making remote requests.
diff --git a/services/fxaccounts/FxAccountsStorage.jsm b/services/fxaccounts/FxAccountsStorage.jsm
--- a/services/fxaccounts/FxAccountsStorage.jsm
+++ b/services/fxaccounts/FxAccountsStorage.jsm
@@ -50,17 +50,17 @@ var FxAccountsStorageManager = function(
   }
   this._clearCachedData();
   // See .initialize() below - this protects against it not being called.
   this._promiseInitialized = Promise.reject("initialize not called");
   // A promise to avoid storage races - see _queueStorageOperation
   this._promiseStorageComplete = Promise.resolve();
 };
 
-this.FxAccountsStorageManager.prototype = {
+FxAccountsStorageManager.prototype = {
   _initialized: false,
   _needToReadSecure: true,
 
   // An initialization routine that *looks* synchronous to the callers, but
   // is actually async as everything else waits for it to complete.
   initialize(accountData) {
     if (this._initialized) {
       throw new Error("already initialized");
diff --git a/services/fxaccounts/FxAccountsWebChannel.jsm b/services/fxaccounts/FxAccountsWebChannel.jsm
--- a/services/fxaccounts/FxAccountsWebChannel.jsm
+++ b/services/fxaccounts/FxAccountsWebChannel.jsm
@@ -161,17 +161,17 @@ this.FxAccountsWebChannel = function(opt
   // options.helpers is only specified by tests.
   XPCOMUtils.defineLazyGetter(this, "_helpers", () => {
     return options.helpers || new FxAccountsWebChannelHelpers(options);
   });
 
   this._setupChannel();
 };
 
-this.FxAccountsWebChannel.prototype = {
+FxAccountsWebChannel.prototype = {
   /**
    * WebChannel that is used to communicate with content page
    */
   _channel: null,
 
   /**
    * Helpers interface that does the heavy lifting.
    */
@@ -395,17 +395,17 @@ this.FxAccountsWebChannelHelpers = funct
   options = options || {};
 
   this._fxAccounts = options.fxAccounts || fxAccounts;
   this._weaveXPCOM = options.weaveXPCOM || null;
   this._privateBrowsingUtils =
     options.privateBrowsingUtils || PrivateBrowsingUtils;
 };
 
-this.FxAccountsWebChannelHelpers.prototype = {
+FxAccountsWebChannelHelpers.prototype = {
   // If the last fxa account used for sync isn't this account, we display
   // a modal dialog checking they really really want to do this...
   // (This is sync-specific, so ideally would be in sync's identity module,
   // but it's a little more seamless to do here, and sync is currently the
   // only fxa consumer, so...
   shouldAllowRelink(acctName) {
     return (
       !this._needRelinkWarning(acctName) || this._promptForRelink(acctName)
@@ -733,17 +733,17 @@ var EnsureFxAccountsWebChannel = () => {
     singleton.tearDown();
     singleton = null;
   }
   if (!singleton) {
     try {
       if (contentUri) {
         // The FxAccountsWebChannel listens for events and updates
         // the state machine accordingly.
-        singleton = new this.FxAccountsWebChannel({
+        singleton = new FxAccountsWebChannel({
           content_uri: contentUri,
           channel_id: WEBCHANNEL_ID,
         });
       } else {
         log.warn("FxA WebChannel functionaly is disabled due to no URI pref.");
       }
     } catch (ex) {
       log.error("Failed to create FxA WebChannel", ex);
diff --git a/toolkit/actors/SelectChild.jsm b/toolkit/actors/SelectChild.jsm
--- a/toolkit/actors/SelectChild.jsm
+++ b/toolkit/actors/SelectChild.jsm
@@ -60,17 +60,17 @@ var SelectContentHelper = function(aElem
 };
 
 Object.defineProperty(SelectContentHelper, "open", {
   get() {
     return gOpen;
   },
 });
 
-this.SelectContentHelper.prototype = {
+SelectContentHelper.prototype = {
   init() {
     let win = this.element.ownerGlobal;
     win.addEventListener("pagehide", this, { mozSystemGroup: true });
     this.element.addEventListener("blur", this, { mozSystemGroup: true });
     this.element.addEventListener("transitionend", this, {
       mozSystemGroup: true,
     });
     let MutationObserver = this.element.ownerGlobal.MutationObserver;
diff --git a/toolkit/components/asyncshutdown/AsyncShutdown.jsm b/toolkit/components/asyncshutdown/AsyncShutdown.jsm
--- a/toolkit/components/asyncshutdown/AsyncShutdown.jsm
+++ b/toolkit/components/asyncshutdown/AsyncShutdown.jsm
@@ -1045,35 +1045,29 @@ Barrier.prototype = Object.freeze({
 
 // List of well-known phases
 // Ideally, phases should be registered from the component that decides
 // when they start/stop. For compatibility with existing startup/shutdown
 // mechanisms, we register a few phases here.
 
 // Parent process
 if (!isContent) {
-  this.AsyncShutdown.profileChangeTeardown = getPhase(
-    "profile-change-teardown"
-  );
-  this.AsyncShutdown.profileBeforeChange = getPhase("profile-before-change");
-  this.AsyncShutdown.sendTelemetry = getPhase(
-    "profile-before-change-telemetry"
-  );
+  AsyncShutdown.profileChangeTeardown = getPhase("profile-change-teardown");
+  AsyncShutdown.profileBeforeChange = getPhase("profile-before-change");
+  AsyncShutdown.sendTelemetry = getPhase("profile-before-change-telemetry");
 }
 
 // Notifications that fire in the parent and content process, but should
 // only have phases in the parent process.
 if (!isContent) {
-  this.AsyncShutdown.quitApplicationGranted = getPhase(
-    "quit-application-granted"
-  );
+  AsyncShutdown.quitApplicationGranted = getPhase("quit-application-granted");
 }
 
 // Don't add a barrier for content-child-shutdown because this
 // makes it easier to cause shutdown hangs.
 
 // All processes
-this.AsyncShutdown.webWorkersShutdown = getPhase("web-workers-shutdown");
-this.AsyncShutdown.xpcomWillShutdown = getPhase("xpcom-will-shutdown");
+AsyncShutdown.webWorkersShutdown = getPhase("web-workers-shutdown");
+AsyncShutdown.xpcomWillShutdown = getPhase("xpcom-will-shutdown");
 
-this.AsyncShutdown.Barrier = Barrier;
+AsyncShutdown.Barrier = Barrier;
 
-Object.freeze(this.AsyncShutdown);
+Object.freeze(AsyncShutdown);
diff --git a/toolkit/components/crashes/CrashManager.jsm b/toolkit/components/crashes/CrashManager.jsm
--- a/toolkit/components/crashes/CrashManager.jsm
+++ b/toolkit/components/crashes/CrashManager.jsm
@@ -154,17 +154,17 @@ var CrashManager = function(options) {
   // The timer controlling the expiration of the CrashStore instance.
   this._storeTimer = null;
 
   // This is a semaphore that prevents the store from being freed by our
   // timer-based resource freeing mechanism.
   this._storeProtectedCount = 0;
 };
 
-this.CrashManager.prototype = Object.freeze({
+CrashManager.prototype = Object.freeze({
   // A crash in the main process.
   PROCESS_TYPE_MAIN: "main",
 
   // A crash in a content process.
   PROCESS_TYPE_CONTENT: "content",
 
   // A crash in a plugin process.
   PROCESS_TYPE_PLUGIN: "plugin",
@@ -1518,17 +1518,17 @@ CrashRecord.prototype = Object.freeze({
 });
 
 /**
  * Obtain the global CrashManager instance used by the running application.
  *
  * CrashManager is likely only ever instantiated once per application lifetime.
  * The main reason it's implemented as a reusable type is to facilitate testing.
  */
-XPCOMUtils.defineLazyGetter(this.CrashManager, "Singleton", function() {
+XPCOMUtils.defineLazyGetter(CrashManager, "Singleton", function() {
   if (gCrashManager) {
     return gCrashManager;
   }
 
   gCrashManager = new CrashManager({
     telemetryStoreSizeKey: "CRASH_STORE_COMPRESSED_BYTES",
   });
 
diff --git a/toolkit/components/crashes/CrashManagerTest.jsm b/toolkit/components/crashes/CrashManagerTest.jsm
--- a/toolkit/components/crashes/CrashManagerTest.jsm
+++ b/toolkit/components/crashes/CrashManagerTest.jsm
@@ -43,17 +43,17 @@ var sleep = function(wait) {
     }, wait);
   });
 };
 
 var TestingCrashManager = function(options) {
   CrashManager.call(this, options);
 };
 
-this.TestingCrashManager.prototype = {
+TestingCrashManager.prototype = {
   __proto__: CrashManager.prototype,
 
   createDummyDump(submitted = false, date = new Date(), hr = false) {
     let uuid = Cc["@mozilla.org/uuid-generator;1"]
       .getService(Ci.nsIUUIDGenerator)
       .generateUUID()
       .toString();
     uuid = uuid.substring(1, uuid.length - 1);
diff --git a/toolkit/components/crashmonitor/CrashMonitor.jsm b/toolkit/components/crashmonitor/CrashMonitor.jsm
--- a/toolkit/components/crashmonitor/CrashMonitor.jsm
+++ b/toolkit/components/crashmonitor/CrashMonitor.jsm
@@ -218,9 +218,9 @@ var CrashMonitor = {
     if (NOTIFICATIONS.every(elem => elem in CrashMonitorInternal.checkpoints)) {
       // All notifications received, unregister observers
       NOTIFICATIONS.forEach(function(aTopic) {
         Services.obs.removeObserver(this, aTopic);
       }, this);
     }
   },
 };
-Object.freeze(this.CrashMonitor);
+Object.freeze(CrashMonitor);
diff --git a/toolkit/components/downloads/DownloadCore.jsm b/toolkit/components/downloads/DownloadCore.jsm
--- a/toolkit/components/downloads/DownloadCore.jsm
+++ b/toolkit/components/downloads/DownloadCore.jsm
@@ -138,17 +138,17 @@ const kProgressUpdateIntervalMs = 400;
  * Represents a single download, with associated state and actions.  This object
  * is transient, though it can be included in a DownloadList so that it can be
  * managed by the user interface and persisted across sessions.
  */
 var Download = function() {
   this._deferSucceeded = PromiseUtils.defer();
 };
 
-this.Download.prototype = {
+Download.prototype = {
   /**
    * DownloadSource object associated with this download.
    */
   source: null,
 
   /**
    * DownloadTarget object associated with this download.
    */
@@ -1288,17 +1288,17 @@ Download.fromSerializable = function(aSe
   return download;
 };
 
 /**
  * Represents the source of a download, for example a document or an URI.
  */
 var DownloadSource = function() {};
 
-this.DownloadSource.prototype = {
+DownloadSource.prototype = {
   /**
    * String containing the URI for the download source.
    */
   url: null,
 
   /**
    * Indicates whether the download originated from a private window.  This
    * determines the context of the network request that is made to retrieve the
@@ -1407,17 +1407,17 @@ this.DownloadSource.prototype = {
  *                           DownloadCopySaver, this function will determine, if
  *                           provided, if a download can progress or has to be
  *                           cancelled based on the HTTP status code of the
  *                           network channel.
  *        }
  *
  * @return The newly created DownloadSource object.
  */
-this.DownloadSource.fromSerializable = function(aSerializable) {
+DownloadSource.fromSerializable = function(aSerializable) {
   let source = new DownloadSource();
   if (isString(aSerializable)) {
     // Convert String objects to primitive strings at this point.
     source.url = aSerializable.toString();
   } else if (aSerializable instanceof Ci.nsIURI) {
     source.url = aSerializable.spec;
   } else if (aSerializable instanceof Ci.nsIDOMWindow) {
     source.url = aSerializable.location.href;
@@ -1464,17 +1464,17 @@ this.DownloadSource.fromSerializable = f
 };
 
 /**
  * Represents the target of a download, for example a file in the global
  * downloads directory, or a file in the system temporary directory.
  */
 var DownloadTarget = function() {};
 
-this.DownloadTarget.prototype = {
+DownloadTarget.prototype = {
   /**
    * String containing the path of the target file.
    */
   path: null,
 
   /**
    * String containing the path of the ".part" file containing the data
    * downloaded so far, or null to disable the use of a ".part" file to keep
@@ -1560,17 +1560,17 @@ this.DownloadTarget.prototype = {
  *        object with the following properties:
  *        {
  *          path: String containing the path of the target file.
  *          partFilePath: optional string containing the part file path.
  *        }
  *
  * @return The newly created DownloadTarget object.
  */
-this.DownloadTarget.fromSerializable = function(aSerializable) {
+DownloadTarget.fromSerializable = function(aSerializable) {
   let target = new DownloadTarget();
   if (isString(aSerializable)) {
     // Convert String objects to primitive strings at this point.
     target.path = aSerializable.toString();
   } else if (aSerializable instanceof Ci.nsIFile) {
     // Read the "path" property of nsIFile after checking the object type.
     target.path = aSerializable.path;
   } else {
@@ -1665,21 +1665,21 @@ var DownloadError = function(aProperties
 };
 
 /**
  * These constants are used by the reputationCheckVerdict property and indicate
  * the detailed reason why a download is blocked.
  *
  * @note These values should not be changed because they can be serialized.
  */
-this.DownloadError.BLOCK_VERDICT_MALWARE = "Malware";
-this.DownloadError.BLOCK_VERDICT_POTENTIALLY_UNWANTED = "PotentiallyUnwanted";
-this.DownloadError.BLOCK_VERDICT_UNCOMMON = "Uncommon";
+DownloadError.BLOCK_VERDICT_MALWARE = "Malware";
+DownloadError.BLOCK_VERDICT_POTENTIALLY_UNWANTED = "PotentiallyUnwanted";
+DownloadError.BLOCK_VERDICT_UNCOMMON = "Uncommon";
 
-this.DownloadError.prototype = {
+DownloadError.prototype = {
   __proto__: Error.prototype,
 
   /**
    * The result code associated with this error.
    */
   result: false,
 
   /**
@@ -1762,17 +1762,17 @@ this.DownloadError.prototype = {
 /**
  * Creates a new DownloadError object from its serializable representation.
  *
  * @param aSerializable
  *        Serializable representation of a DownloadError object.
  *
  * @return The newly created DownloadError object.
  */
-this.DownloadError.fromSerializable = function(aSerializable) {
+DownloadError.fromSerializable = function(aSerializable) {
   let e = new DownloadError(aSerializable);
   deserializeUnknownProperties(
     e,
     aSerializable,
     property =>
       property != "result" &&
       property != "message" &&
       property != "becauseSourceFailed" &&
@@ -1787,17 +1787,17 @@ this.DownloadError.fromSerializable = fu
   return e;
 };
 
 /**
  * Template for an object that actually transfers the data for the download.
  */
 var DownloadSaver = function() {};
 
-this.DownloadSaver.prototype = {
+DownloadSaver.prototype = {
   /**
    * Download object for raising notifications and reading properties.
    *
    * If the tryToKeepPartialData property of the download object is false, the
    * saver should never try to keep partially downloaded data if the download
    * fails.
    */
   download: null,
@@ -1887,17 +1887,17 @@ this.DownloadSaver.prototype = {
  *
  * @param aSerializable
  *        Serializable representation of a DownloadSaver object.  If no initial
  *        state information for the saver object is needed, can be a string
  *        representing the class of the download operation, for example "copy".
  *
  * @return The newly created DownloadSaver object.
  */
-this.DownloadSaver.fromSerializable = function(aSerializable) {
+DownloadSaver.fromSerializable = function(aSerializable) {
   let serializable = isString(aSerializable)
     ? { type: aSerializable }
     : aSerializable;
   let saver;
   switch (serializable.type) {
     case "copy":
       saver = DownloadCopySaver.fromSerializable(serializable);
       break;
@@ -1913,17 +1913,17 @@ this.DownloadSaver.fromSerializable = fu
   return saver;
 };
 
 /**
  * Saver object that simply copies the entire source file to the target.
  */
 var DownloadCopySaver = function() {};
 
-this.DownloadCopySaver.prototype = {
+DownloadCopySaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
   /**
    * BackgroundFileSaver object currently handling the download.
    */
   _backgroundFileSaver: null,
 
   /**
@@ -2429,17 +2429,17 @@ this.DownloadCopySaver.prototype = {
  * Creates a new DownloadCopySaver object, with its initial state derived from
  * its serializable representation.
  *
  * @param aSerializable
  *        Serializable representation of a DownloadCopySaver object.
  *
  * @return The newly created DownloadCopySaver object.
  */
-this.DownloadCopySaver.fromSerializable = function(aSerializable) {
+DownloadCopySaver.fromSerializable = function(aSerializable) {
   let saver = new DownloadCopySaver();
   if ("entityID" in aSerializable) {
     saver.entityID = aSerializable.entityID;
   }
 
   deserializeUnknownProperties(
     saver,
     aSerializable,
@@ -2454,17 +2454,17 @@ this.DownloadCopySaver.fromSerializable 
  *
  * For more background on the process, see the DownloadLegacyTransfer object.
  */
 var DownloadLegacySaver = function() {
   this.deferExecuted = PromiseUtils.defer();
   this.deferCanceled = PromiseUtils.defer();
 };
 
-this.DownloadLegacySaver.prototype = {
+DownloadLegacySaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
   /**
    * Save the SHA-256 hash in raw bytes of the downloaded file. This may be
    * null when nsExternalHelperAppService (and thus BackgroundFileSaver) is not
    * invoked.
    */
   _sha256Hash: null,
@@ -2796,34 +2796,34 @@ this.DownloadLegacySaver.prototype = {
   },
 };
 
 /**
  * Returns a new DownloadLegacySaver object.  This saver type has a
  * deserializable form only when creating a new object in memory, because it
  * cannot be serialized to disk.
  */
-this.DownloadLegacySaver.fromSerializable = function() {
+DownloadLegacySaver.fromSerializable = function() {
   return new DownloadLegacySaver();
 };
 
 /**
  * This DownloadSaver type creates a PDF file from the current document in a
  * given window, specified using the windowRef property of the DownloadSource
  * object associated with the download.
  *
  * In order to prevent the download from saving a different document than the one
  * originally loaded in the window, any attempt to restart the download will fail.
  *
  * Since this DownloadSaver type requires a live document as a source, it cannot
  * be persisted across sessions, unless the download already succeeded.
  */
 var DownloadPDFSaver = function() {};
 
-this.DownloadPDFSaver.prototype = {
+DownloadPDFSaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
   /**
    * An nsIWebBrowserPrint instance for printing this page.
    * This is null when saving has not started or has completed,
    * or while the operation is being canceled.
    */
   _webBrowserPrint: null,
@@ -2946,11 +2946,11 @@ this.DownloadPDFSaver.prototype = {
  * Creates a new DownloadPDFSaver object, with its initial state derived from
  * its serializable representation.
  *
  * @param aSerializable
  *        Serializable representation of a DownloadPDFSaver object.
  *
  * @return The newly created DownloadPDFSaver object.
  */
-this.DownloadPDFSaver.fromSerializable = function(aSerializable) {
+DownloadPDFSaver.fromSerializable = function(aSerializable) {
   return new DownloadPDFSaver();
 };
diff --git a/toolkit/components/downloads/DownloadHistory.jsm b/toolkit/components/downloads/DownloadHistory.jsm
--- a/toolkit/components/downloads/DownloadHistory.jsm
+++ b/toolkit/components/downloads/DownloadHistory.jsm
@@ -556,17 +556,17 @@ var DownloadHistoryList = function(publi
 
   // Our history result observer is long lived for fast shared views, so free
   // the reference on shutdown to prevent leaks.
   Services.obs.addObserver(() => {
     this.result = null;
   }, "quit-application-granted");
 };
 
-this.DownloadHistoryList.prototype = {
+DownloadHistoryList.prototype = {
   __proto__: DownloadList.prototype,
 
   /**
    * This is set when executing the Places query.
    */
   get result() {
     return this._result;
   },
diff --git a/toolkit/components/downloads/DownloadIntegration.jsm b/toolkit/components/downloads/DownloadIntegration.jsm
--- a/toolkit/components/downloads/DownloadIntegration.jsm
+++ b/toolkit/components/downloads/DownloadIntegration.jsm
@@ -1168,17 +1168,17 @@ var DownloadObserver = {
  * @param aList
  *        DownloadList object linked to this observer.
  */
 var DownloadHistoryObserver = function(aList) {
   this._list = aList;
   PlacesUtils.history.addObserver(this);
 };
 
-this.DownloadHistoryObserver.prototype = {
+DownloadHistoryObserver.prototype = {
   /**
    * DownloadList object linked to this observer.
    */
   _list: null,
 
   QueryInterface: ChromeUtils.generateQI([Ci.nsINavHistoryObserver]),
 
   // nsINavHistoryObserver
@@ -1220,17 +1220,17 @@ var DownloadAutoSaveView = function(aLis
   this._downloadsMap = new Map();
   this._writer = new DeferredTask(() => this._store.save(), kSaveDelayMs);
   AsyncShutdown.profileBeforeChange.addBlocker(
     "DownloadAutoSaveView: writing data",
     () => this._writer.finalize()
   );
 };
 
-this.DownloadAutoSaveView.prototype = {
+DownloadAutoSaveView.prototype = {
   /**
    * DownloadList object linked to this view.
    */
   _list: null,
 
   /**
    * The DownloadStore object used for saving.
    */
diff --git a/toolkit/components/downloads/DownloadList.jsm b/toolkit/components/downloads/DownloadList.jsm
--- a/toolkit/components/downloads/DownloadList.jsm
+++ b/toolkit/components/downloads/DownloadList.jsm
@@ -18,17 +18,17 @@ var EXPORTED_SYMBOLS = [
  * Represents a collection of Download objects that can be viewed and managed by
  * the user interface, and persisted across sessions.
  */
 var DownloadList = function() {
   this._downloads = [];
   this._views = new Set();
 };
 
-this.DownloadList.prototype = {
+DownloadList.prototype = {
   /**
    * Array of Download objects currently in the list.
    */
   _downloads: null,
 
   /**
    * Retrieves a snapshot of the downloads that are currently in the list.  The
    * returned array does not change when downloads are added or removed, though
@@ -247,17 +247,17 @@ this.DownloadList.prototype = {
 var DownloadCombinedList = function(aPublicList, aPrivateList) {
   DownloadList.call(this);
   this._publicList = aPublicList;
   this._privateList = aPrivateList;
   aPublicList.addView(this).catch(Cu.reportError);
   aPrivateList.addView(this).catch(Cu.reportError);
 };
 
-this.DownloadCombinedList.prototype = {
+DownloadCombinedList.prototype = {
   __proto__: DownloadList.prototype,
 
   /**
    * Underlying DownloadList containing public downloads.
    */
   _publicList: null,
 
   /**
@@ -335,17 +335,17 @@ this.DownloadCombinedList.prototype = {
 /**
  * Provides an aggregated view on the contents of a DownloadList.
  */
 var DownloadSummary = function() {
   this._downloads = [];
   this._views = new Set();
 };
 
-this.DownloadSummary.prototype = {
+DownloadSummary.prototype = {
   /**
    * Array of Download objects that are currently part of the summary.
    */
   _downloads: null,
 
   /**
    * Underlying DownloadList whose contents should be summarized.
    */
diff --git a/toolkit/components/downloads/DownloadStore.jsm b/toolkit/components/downloads/DownloadStore.jsm
--- a/toolkit/components/downloads/DownloadStore.jsm
+++ b/toolkit/components/downloads/DownloadStore.jsm
@@ -58,17 +58,17 @@ XPCOMUtils.defineLazyGetter(this, "gText
  * @param aPath
  *        String containing the file path where data should be saved.
  */
 var DownloadStore = function(aList, aPath) {
   this.list = aList;
   this.path = aPath;
 };
 
-this.DownloadStore.prototype = {
+DownloadStore.prototype = {
   /**
    * DownloadList object to be populated or serialized.
    */
   list: null,
 
   /**
    * String containing the file path where data should be saved.
    */
diff --git a/toolkit/components/downloads/DownloadUIHelper.jsm b/toolkit/components/downloads/DownloadUIHelper.jsm
--- a/toolkit/components/downloads/DownloadUIHelper.jsm
+++ b/toolkit/components/downloads/DownloadUIHelper.jsm
@@ -87,17 +87,17 @@ XPCOMUtils.defineLazyGetter(DownloadUIHe
  * @param aParent
  *        The nsIDOMWindow to which prompts should be attached, or null to
  *        attach prompts to the most recently active window.
  */
 var DownloadPrompter = function(aParent) {
   this._prompter = Services.ww.getNewPrompter(aParent);
 };
 
-this.DownloadPrompter.prototype = {
+DownloadPrompter.prototype = {
   /**
    * Constants with the different type of prompts.
    */
   ON_QUIT: "prompt-on-quit",
   ON_OFFLINE: "prompt-on-offline",
   ON_LEAVE_PRIVATE_BROWSING: "prompt-on-leave-private-browsing",
 
   /**
diff --git a/toolkit/components/extensions/ExtensionPreferencesManager.jsm b/toolkit/components/extensions/ExtensionPreferencesManager.jsm
--- a/toolkit/components/extensions/ExtensionPreferencesManager.jsm
+++ b/toolkit/components/extensions/ExtensionPreferencesManager.jsm
@@ -59,27 +59,27 @@ XPCOMUtils.defineLazyGetter(this, "defau
   return new Preferences({ defaultBranch: true });
 });
 
 /* eslint-disable mozilla/balanced-listeners */
 Management.on("uninstall", async (type, { id }) => {
   // Ensure managed preferences are cleared if they were
   // not cleared at the module level.
   await Management.asyncLoadSettingsModules();
-  return this.ExtensionPreferencesManager.removeAll(id);
+  return ExtensionPreferencesManager.removeAll(id);
 });
 
 Management.on("disable", async (type, id) => {
   await Management.asyncLoadSettingsModules();
-  return this.ExtensionPreferencesManager.disableAll(id);
+  return ExtensionPreferencesManager.disableAll(id);
 });
 
 Management.on("enabling", async (type, id) => {
   await Management.asyncLoadSettingsModules();
-  return this.ExtensionPreferencesManager.enableAll(id);
+  return ExtensionPreferencesManager.enableAll(id);
 });
 /* eslint-enable mozilla/balanced-listeners */
 
 const STORE_TYPE = "prefs";
 
 // Definitions of settings, each of which correspond to a different API.
 let settingsMap = new Map();
 
diff --git a/toolkit/components/extensions/MessageChannel.jsm b/toolkit/components/extensions/MessageChannel.jsm
--- a/toolkit/components/extensions/MessageChannel.jsm
+++ b/toolkit/components/extensions/MessageChannel.jsm
@@ -137,18 +137,18 @@ const MESSAGE_RESPONSE = "MessageChannel
 // ESLint can't tell that these are referenced, so tell it that they're
 // exported to make it happy.
 /* exported _deferredResult, _makeDeferred */
 var _deferredResult;
 var _makeDeferred = (resolve, reject) => {
   // We use arrow functions here and refer to the outer variables via
   // `this`, to avoid a lexical name lookup. Yes, it makes a difference.
   // No, I don't like it any more than you do.
-  this._deferredResult.resolve = resolve;
-  this._deferredResult.reject = reject;
+  _deferredResult.resolve = resolve;
+  _deferredResult.reject = reject;
 };
 
 /**
  * Helper to create a new Promise without allocating any closures to
  * receive its resolution functions.
  *
  * I know what you're thinking: "This is crazy. There is no possible way
  * this can be necessary. Just use the ordinary Promise constructor the
@@ -164,17 +164,17 @@ var _makeDeferred = (resolve, reject) =>
  *
  * (See also bug 1404950.)
  *
  * @returns {object}
  */
 let Deferred = () => {
   let res = {};
   this._deferredResult = res;
-  res.promise = new Promise(this._makeDeferred);
+  res.promise = new Promise(_makeDeferred);
   this._deferredResult = null;
   return res;
 };
 
 /**
  * Handles the mapping and dispatching of messages to their registered
  * handlers. There is one broker per message manager and class of
  * messages. Each class of messages is mapped to one native message
diff --git a/toolkit/components/osfile/modules/osfile_async_front.jsm b/toolkit/components/osfile/modules/osfile_async_front.jsm
--- a/toolkit/components/osfile/modules/osfile_async_front.jsm
+++ b/toolkit/components/osfile/modules/osfile_async_front.jsm
@@ -1570,30 +1570,30 @@ File.POS_START = SysAll.POS_START;
 File.POS_CURRENT = SysAll.POS_CURRENT;
 File.POS_END = SysAll.POS_END;
 
 // Exports
 File.Error = OSError;
 File.DirectoryIterator = DirectoryIterator;
 
 var OS = {};
-this.OS.File = File;
-this.OS.Constants = SharedAll.Constants;
-this.OS.Shared = {
+OS.File = File;
+OS.Constants = SharedAll.Constants;
+OS.Shared = {
   LOG: SharedAll.LOG,
   Type: SysAll.Type,
   get DEBUG() {
     return SharedAll.Config.DEBUG;
   },
   set DEBUG(x) {
     return (SharedAll.Config.DEBUG = x);
   },
 };
-Object.freeze(this.OS.Shared);
-this.OS.Path = Path;
+Object.freeze(OS.Shared);
+OS.Path = Path;
 
 // Returns a resolved promise when all the queued operation have been completed.
 Object.defineProperty(OS.File, "queue", {
   get() {
     return Scheduler.queue;
   },
 });
 
diff --git a/toolkit/components/osfile/modules/ospath.jsm b/toolkit/components/osfile/modules/ospath.jsm
--- a/toolkit/components/osfile/modules/ospath.jsm
+++ b/toolkit/components/osfile/modules/ospath.jsm
@@ -39,12 +39,12 @@ if (typeof Components == "undefined") {
   if (Scope.OS.Constants.Win) {
     ChromeUtils.import("resource://gre/modules/osfile/ospath_win.jsm", Path);
   } else {
     ChromeUtils.import("resource://gre/modules/osfile/ospath_unix.jsm", Path);
   }
 
   this.EXPORTED_SYMBOLS = [];
   for (let k in Path) {
-    this.EXPORTED_SYMBOLS.push(k);
+    EXPORTED_SYMBOLS.push(k);
     this[k] = Path[k];
   }
 }
diff --git a/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm b/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm
--- a/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm
+++ b/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm
@@ -230,13 +230,13 @@ this.InsecurePasswordUtils = {
 
     Services.telemetry
       .getHistogramById("PWMGR_LOGIN_PAGE_SAFETY")
       .add(passwordSafety);
   },
 };
 
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.InsecurePasswordUtils,
+  InsecurePasswordUtils,
   "_ignoreLocalIPAddress",
   "security.insecure_field_warning.ignore_local_ip_address",
   true
 );
diff --git a/toolkit/components/passwordmgr/LoginImport.jsm b/toolkit/components/passwordmgr/LoginImport.jsm
--- a/toolkit/components/passwordmgr/LoginImport.jsm
+++ b/toolkit/components/passwordmgr/LoginImport.jsm
@@ -38,17 +38,17 @@ ChromeUtils.defineModuleGetter(
  * @param aPath
  *        String containing the file path of the SQLite login database.
  */
 this.LoginImport = function(aStore, aPath) {
   this.store = aStore;
   this.path = aPath;
 };
 
-this.LoginImport.prototype = {
+LoginImport.prototype = {
   /**
    * LoginStore object where imported data will be added.
    */
   store: null,
 
   /**
    * String containing the file path of the SQLite login database.
    */
diff --git a/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm b/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm
--- a/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm
+++ b/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm
@@ -264,17 +264,17 @@ LoginManagerAuthPromptFactory.prototype 
           /* Just ignore exceptions from the callback */
         }
       }
     }
   },
 }; // end of LoginManagerAuthPromptFactory implementation
 
 XPCOMUtils.defineLazyGetter(
-  this.LoginManagerAuthPromptFactory.prototype,
+  LoginManagerAuthPromptFactory.prototype,
   "log",
   () => {
     let logger = LoginHelper.createLogger("LoginManagerAuthPromptFactory");
     return logger.log.bind(logger);
   }
 );
 
 /* ==================== LoginManagerAuthPrompter ==================== */
@@ -1374,21 +1374,17 @@ LoginManagerAuthPrompter.prototype = {
         this.callback.onAuthCancelled(this.context, false);
         this.callback = null;
         this.context = null;
       },
     };
   },
 }; // end of LoginManagerAuthPrompter implementation
 
-XPCOMUtils.defineLazyGetter(
-  this.LoginManagerAuthPrompter.prototype,
-  "log",
-  () => {
-    let logger = LoginHelper.createLogger("LoginManagerAuthPrompter");
-    return logger.log.bind(logger);
-  }
-);
+XPCOMUtils.defineLazyGetter(LoginManagerAuthPrompter.prototype, "log", () => {
+  let logger = LoginHelper.createLogger("LoginManagerAuthPrompter");
+  return logger.log.bind(logger);
+});
 
 const EXPORTED_SYMBOLS = [
   "LoginManagerAuthPromptFactory",
   "LoginManagerAuthPrompter",
 ];
diff --git a/toolkit/components/passwordmgr/test/LoginTestUtils.jsm b/toolkit/components/passwordmgr/test/LoginTestUtils.jsm
--- a/toolkit/components/passwordmgr/test/LoginTestUtils.jsm
+++ b/toolkit/components/passwordmgr/test/LoginTestUtils.jsm
@@ -121,17 +121,17 @@ this.LoginTestUtils = {
 /**
  * This object contains functions that return new instances of nsILoginInfo for
  * every call.  The returned instances can be compared using their "equals" or
  * "matches" methods, or modified for the needs of the specific test being run.
  *
  * Any modification to the test data requires updating the tests accordingly, in
  * particular the search tests.
  */
-this.LoginTestUtils.testData = {
+LoginTestUtils.testData = {
   /**
    * Returns a new nsILoginInfo for use with form submits.
    *
    * @param modifications
    *        Each property of this object replaces the property of the same name
    *        in the returned nsILoginInfo or nsILoginMetaInfo.
    */
   formLogin(modifications) {
@@ -450,31 +450,31 @@ this.LoginTestUtils.testData = {
         null,
         "javascript: username",
         "javascript: password"
       ),
     ];
   },
 };
 
-this.LoginTestUtils.recipes = {
+LoginTestUtils.recipes = {
   getRecipeParent() {
     let { LoginManagerParent } = ChromeUtils.import(
       "resource://gre/modules/LoginManagerParent.jsm"
     );
     if (!LoginManagerParent.recipeParentPromise) {
       return null;
     }
     return LoginManagerParent.recipeParentPromise.then(recipeParent => {
       return recipeParent;
     });
   },
 };
 
-this.LoginTestUtils.masterPassword = {
+LoginTestUtils.masterPassword = {
   masterPassword: "omgsecret!",
 
   _set(enable) {
     let oldPW, newPW;
     if (enable) {
       oldPW = "";
       newPW = this.masterPassword;
     } else {
@@ -507,17 +507,17 @@ this.LoginTestUtils.masterPassword = {
   disable() {
     this._set(false);
   },
 };
 
 /**
  * Utilities related to interacting with login fields in content.
  */
-this.LoginTestUtils.loginField = {
+LoginTestUtils.loginField = {
   checkPasswordMasked(field, expected, msg) {
     let { editor } = field;
     let valueLength = field.value.length;
     Assert.equal(
       editor.autoMaskingEnabled,
       expected,
       `Check autoMaskingEnabled: ${msg}`
     );
@@ -529,22 +529,22 @@ this.LoginTestUtils.loginField = {
         editor.unmaskedEnd,
         valueLength,
         `Unmasked to the end: ${msg}`
       );
     }
   },
 };
 
-this.LoginTestUtils.generation = {
+LoginTestUtils.generation = {
   LENGTH: 15,
   REGEX: /^[a-km-np-zA-HJ-NP-Z2-9]{15}$/,
 };
 
-this.LoginTestUtils.telemetry = {
+LoginTestUtils.telemetry = {
   async waitForEventCount(count, process = "content", category = "pwmgr") {
     let events = await TestUtils.waitForCondition(() => {
       let events = Services.telemetry.snapshotEvents(
         Ci.nsITelemetry.DATASET_PRERELEASE_CHANNELS,
         false
       )[process];
 
       if (!events) {
diff --git a/toolkit/components/promiseworker/PromiseWorker.jsm b/toolkit/components/promiseworker/PromiseWorker.jsm
--- a/toolkit/components/promiseworker/PromiseWorker.jsm
+++ b/toolkit/components/promiseworker/PromiseWorker.jsm
@@ -164,17 +164,17 @@ var BasePromiseWorker = function(url) {
    */
   this.launchTimeStamp = null;
 
   /**
    * Timestamps provided by the worker for statistics purposes.
    */
   this.workerTimeStamps = null;
 };
-this.BasePromiseWorker.prototype = {
+BasePromiseWorker.prototype = {
   log() {
     // By Default, ignore all logs.
   },
 
   /**
    * Instantiate the worker lazily.
    */
   get _worker() {
@@ -435,12 +435,12 @@ function WorkerError(data) {
  * @param {object=} data The data to send to the caller thread.
  * @param {object=} meta Additional instructions, as an object
  * that may contain the following fields:
  * - {Array} transfers An array of objects that should be transferred
  *   instead of being copied.
  *
  * @constructor
  */
-this.BasePromiseWorker.Meta = function(data, meta) {
+BasePromiseWorker.Meta = function(data, meta) {
   this.data = data;
   this.meta = meta;
 };
diff --git a/toolkit/components/prompts/src/SharedPromptUtils.jsm b/toolkit/components/prompts/src/SharedPromptUtils.jsm
--- a/toolkit/components/prompts/src/SharedPromptUtils.jsm
+++ b/toolkit/components/prompts/src/SharedPromptUtils.jsm
@@ -74,17 +74,17 @@ var EnableDelayHelper = function({ enabl
   // While the user key-repeats, we want to renew the timer until keyup:
   this.focusTarget.addEventListener("keyup", this, true);
   this.focusTarget.addEventListener("keydown", this, true);
   this.focusTarget.document.addEventListener("unload", this);
 
   this.startOnFocusDelay();
 };
 
-this.EnableDelayHelper.prototype = {
+EnableDelayHelper.prototype = {
   get delayTime() {
     return Services.prefs.getIntPref("security.dialog_enable_delay");
   },
 
   handleEvent(event) {
     if (
       !event.type.startsWith("key") &&
       event.target != this.focusTarget &&
diff --git a/toolkit/components/search/SearchSuggestionController.jsm b/toolkit/components/search/SearchSuggestionController.jsm
--- a/toolkit/components/search/SearchSuggestionController.jsm
+++ b/toolkit/components/search/SearchSuggestionController.jsm
@@ -59,17 +59,17 @@ var gFirstPartyDomains = new Map();
  * @param {function} [callback] - Callback for search suggestion results. You can use the promise
  *                                returned by the search method instead if you prefer.
  * @constructor
  */
 function SearchSuggestionController(callback = null) {
   this._callback = callback;
 }
 
-this.SearchSuggestionController.prototype = {
+SearchSuggestionController.prototype = {
   /**
    * The maximum number of local form history results to return. This limit is
    * only enforced if remote results are also returned.
    */
   maxLocalResults: 5,
 
   /**
    * The maximum number of remote search engine results to return.
@@ -495,41 +495,41 @@ this.SearchSuggestionController.prototyp
 };
 
 /**
  * Determines whether the given engine offers search suggestions.
  *
  * @param {nsISearchEngine} engine - The search engine
  * @returns {boolean} True if the engine offers suggestions and false otherwise.
  */
-this.SearchSuggestionController.engineOffersSuggestions = function(engine) {
+SearchSuggestionController.engineOffersSuggestions = function(engine) {
   return engine.supportsResponseType(SEARCH_RESPONSE_SUGGESTION_JSON);
 };
 
 /**
  * The maximum time (ms) to wait before giving up on a remote suggestions.
  */
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.SearchSuggestionController.prototype,
+  SearchSuggestionController.prototype,
   "remoteTimeout",
   REMOTE_TIMEOUT_PREF,
   REMOTE_TIMEOUT_DEFAULT
 );
 
 /**
  * Whether or not remote suggestions are turned on.
  */
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.SearchSuggestionController.prototype,
+  SearchSuggestionController.prototype,
   "suggestionsEnabled",
   BROWSER_SUGGEST_PREF,
   true
 );
 
 /**
  * Whether or not remote suggestions are turned on in private browsing mode.
  */
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.SearchSuggestionController.prototype,
+  SearchSuggestionController.prototype,
   "suggestionsInPrivateBrowsingEnabled",
   BROWSER_SUGGEST_PRIVATE_PREF,
   false
 );
diff --git a/toolkit/crashreporter/CrashReports.jsm b/toolkit/crashreporter/CrashReports.jsm
--- a/toolkit/crashreporter/CrashReports.jsm
+++ b/toolkit/crashreporter/CrashReports.jsm
@@ -74,11 +74,11 @@ function CrashReports_reportsDir() {
 
 function CrashReports_submittedDir() {
   let submittedDir = Services.dirsvc.get("UAppData", Ci.nsIFile);
   submittedDir.append("Crash Reports");
   submittedDir.append("submitted");
   return submittedDir;
 }
 
-this.CrashReports.pendingDir = CrashReports_pendingDir();
-this.CrashReports.reportsDir = CrashReports_reportsDir();
-this.CrashReports.submittedDir = CrashReports_submittedDir();
+CrashReports.pendingDir = CrashReports_pendingDir();
+CrashReports.reportsDir = CrashReports_reportsDir();
+CrashReports.submittedDir = CrashReports_submittedDir();
diff --git a/toolkit/modules/DeferredTask.jsm b/toolkit/modules/DeferredTask.jsm
--- a/toolkit/modules/DeferredTask.jsm
+++ b/toolkit/modules/DeferredTask.jsm
@@ -115,17 +115,17 @@ const Timer = Components.Constructor(
  *        callback.
  */
 var DeferredTask = function(aTaskFn, aDelayMs, aIdleTimeoutMs) {
   this._taskFn = aTaskFn;
   this._delayMs = aDelayMs;
   this._timeoutMs = aIdleTimeoutMs;
 };
 
-this.DeferredTask.prototype = {
+DeferredTask.prototype = {
   /**
    * Function to execute.
    */
   _taskFn: null,
 
   /**
    * Time between executions, in milliseconds.
    */
diff --git a/toolkit/modules/Integration.jsm b/toolkit/modules/Integration.jsm
--- a/toolkit/modules/Integration.jsm
+++ b/toolkit/modules/Integration.jsm
@@ -152,17 +152,17 @@ var IntegrationPoint = function() {
         Cr.NS_ERROR_NO_INTERFACE
       );
       Cu.reportError(ex);
       throw ex;
     },
   };
 };
 
-this.IntegrationPoint.prototype = {
+IntegrationPoint.prototype = {
   /**
    * Ordered set of registered functions defining integration overrides.
    */
   _overrideFns: null,
 
   /**
    * Combined integration object. When this reference changes, properties
    * defined directly on this object are copied to the new object.
diff --git a/toolkit/modules/WebChannel.jsm b/toolkit/modules/WebChannel.jsm
--- a/toolkit/modules/WebChannel.jsm
+++ b/toolkit/modules/WebChannel.jsm
@@ -120,17 +120,17 @@ var WebChannel = function(id, originOrPe
     // such as containers or private browsing.
     this._originCheckCallback = requestPrincipal => {
       return originOrPermission.prePath === requestPrincipal.originNoSuffix;
     };
   }
   this._originOrPermission = originOrPermission;
 };
 
-this.WebChannel.prototype = {
+WebChannel.prototype = {
   /**
    * WebChannel id
    */
   id: null,
 
   /**
    * The originOrPermission value passed to the constructor, mainly for
    * debugging and tests.
diff --git a/toolkit/mozapps/extensions/AddonManager.jsm b/toolkit/mozapps/extensions/AddonManager.jsm
--- a/toolkit/mozapps/extensions/AddonManager.jsm
+++ b/toolkit/mozapps/extensions/AddonManager.jsm
@@ -4746,20 +4746,20 @@ AMTelemetry = {
     } catch (err) {
       // If the telemetry throws just log the error so it doesn't break any
       // functionality.
       Cu.reportError(err);
     }
   },
 };
 
-this.AddonManager.init();
+AddonManager.init();
 
 // Setup the AMTelemetry once the AddonManager has been started.
-this.AddonManager.addManagerListener(AMTelemetry);
+AddonManager.addManagerListener(AMTelemetry);
 
 // load the timestamps module into AddonManagerInternal
 ChromeUtils.import(
   "resource://gre/modules/TelemetryTimestamps.jsm",
   AddonManagerInternal
 );
 Object.freeze(AddonManagerInternal);
 Object.freeze(AddonManagerPrivate);
