# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  18859d2fec94f35e924e9093a99169623e0b2d78

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -55,16 +55,29 @@ const MozElementMixin = Base => class Mo
     gElementsPendingConnection.add(this);
     return true;
   }
 
   get isConnectedAndReady() {
     return gIsDOMContentLoaded && this.isConnected;
   }
 
+  inheritAttribute(child, attrName, attrNewName = attrName) {
+    if (attrNewName === "text") {
+      child.textContent = this.hasAttribute(attrName) ? this.getAttribute(attrName) : "";
+      return;
+    }
+
+    if (this.hasAttribute(attrName)) {
+      child.setAttribute(attrNewName, this.getAttribute(attrName));
+    } else {
+      child.removeAttribute(attrNewName);
+    }
+  }
+
   /**
    * Allows eager deterministic construction of XUL elements with XBL attached, by
    * parsing an element tree and returning a DOM fragment to be inserted in the
    * document before any of the inner elements is referenced by JavaScript.
    *
    * This process is required instead of calling the createElement method directly
    * because bindings get attached when:
    *
@@ -231,20 +244,239 @@ class MozBaseControl extends MozXULEleme
     } else {
       this.removeAttribute("tabindex");
     }
   }
 }
 
 MozXULElement.implementCustomInterface(MozBaseControl, [Ci.nsIDOMXULControlElement]);
 
+
+class MozBaseText extends MozBaseControl {
+  set label(val) {
+    this.setAttribute("label", val);
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set crop(val) {
+    this.setAttribute("crop", val);
+  }
+
+  get crop() {
+    return this.getAttribute("crop");
+  }
+
+  set image(val) {
+    this.setAttribute("image", val);
+  }
+
+  get image() {
+    return this.getAttribute("image");
+  }
+
+  set command(val) {
+    this.setAttribute("command", val);
+  }
+
+  get command() {
+    return this.getAttribute("command");
+  }
+
+  set accessKey(val) {
+    // Always store on the control
+    this.setAttribute("accesskey", val);
+    // If there is a label, change the accesskey on the labelElement
+    // if it's also set there
+    if (this.labelElement) {
+      this.labelElement.accessKey = val;
+    }
+    return val;
+  }
+
+  get accessKey() {
+    return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+  }
+}
+
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozBaseControl = MozBaseControl;
+window.MozBaseText = MozBaseText;
+
+let menuitems = new Set();
+window.addEventListener("popupshowing", (e) => {
+  if (e.originalTarget.ownerDocument != document) {
+    return;
+  }
+  var d = Date.now();
+  for (let menuitem of menuitems) {
+    if (e.originalTarget.contains(menuitem)) {
+      if (!(menuitem instanceof MozMenuItem)) {
+        // Let's see if this can happen. if it can (i.e. when inside of XBL anon content),
+        // then we can do customElements.upgrade(menuitem)
+        throw new Error("Can this happen?");
+      }
+      console.log(menuitem instanceof MozMenuItem);
+      menuitem.render();
+    }
+  }
+  console.log("Took", Date.now() - d, menuitems.size);
+}, { capture: true });
+
+class MozMenuitemBase extends MozBaseText {
+  set value(val) {
+    this.setAttribute("value", val);
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  get selected() {
+    return this.getAttribute("selected") == "true";
+  }
+
+  get control() {
+    var parent = this.parentNode;
+    if (parent &&
+      parent.parentNode instanceof Ci.nsIDOMXULSelectControlElement)
+      return parent.parentNode;
+    return null;
+  }
+  /**
+   * nsIDOMXULContainerItemElement
+   */
+  get parentContainer() {
+    for (var parent = this.parentNode; parent; parent = parent.parentNode) {
+      if (parent instanceof Ci.nsIDOMXULContainerElement)
+        return parent;
+    }
+    return null;
+  }
+}
+
+MozXULElement.implementCustomInterface(MozMenuitemBase, [Ci.nsIDOMXULSelectControlItemElement, Ci.nsIDOMXULContainerItemElement]);
+
+/*
+
+
+      <hbox class="menu-iconic-left" align="center" pack="center"
+                inherits="selected,_moz-menuactive,disabled,checked">
+        <image class="menu-iconic-icon" inherits="src=image,triggeringprincipal=iconloadingprincipal,validate,src"/>
+      </hbox>
+      <label class="menu-iconic-text" flex="1" inherits="value=label,accesskey,crop,highlightable" crop="right"/>
+      <label class="menu-iconic-highlightable-text" inherits="text=label,crop,accesskey,highlightable" crop="right"/>
+      <children/>
+      <hbox class="menu-accel-container">
+        <label class="menu-iconic-accel" inherits="value=acceltext"/>
+      </hbox>
+
+  */
+class MozMenuItem extends MozMenuitemBase {
+
+  static get observedAttributes() {
+
+  }
+
+  inheritAttributes() {
+    if (!this.renderedOnce) {
+      return;
+    }
+
+    if (this.menuText) {
+      this.inheritAttribute(this.menuText, "label", "value");
+      this.inheritAttribute(this.menuText, "crop");
+      this.inheritAttribute(this.menuText, "accesskey");
+      this.inheritAttribute(this.menuText, "highlightable");
+    }
+
+    if (this.menuHighlightableText) {
+      this.inheritAttribute(this.menuText, "label", "text");
+      this.inheritAttribute(this.menuText, "crop");
+      this.inheritAttribute(this.menuText, "accesskey");
+      this.inheritAttribute(this.menuText, "highlightable");
+    }
+
+    if (this.menuAccel) {
+      this.inheritAttribute(this.menuAccel, "acceltext", "value");
+    }
+  }
+
+  get isIconic() {
+    return this.matches(`menuitem[type="checkbox"], menuitem[type="radio"], menuitem.menuitem-iconic`)
+  }
+
+  get isIconicNoAccel() {
+    return this.matches("menulist > menupopup > menuitem");
+  }
+
+  render() {
+    if (this.renderedOnce) {
+      return;
+    }
+    this.renderedOnce = true;
+    if (this.isIconicNoAccel) {
+      this.append(MozXULElement.parseXULToFragment(`
+        <hbox class="menu-iconic-left" align="center" pack="center"
+                  inherits="selected,disabled,checked">
+          <image class="menu-iconic-icon" inherits="src=image,validate,src"/>
+        </hbox>
+        <label class="menu-iconic-text" flex="1" crop="right"/>
+        <label class="menu-iconic-highlightable-text" crop="right"/>
+      `));
+      this.menuText = this.querySelector(".menu-iconic-text");
+      this.menuHighlightableText = this.querySelector(".menu-iconic-highlightable-text");
+    } else if (this.isIconic) {
+      this.prepend(MozXULElement.parseXULToFragment(`
+        <hbox class="menu-iconic-left" align="center" pack="center"
+                  inherits="selected,_moz-menuactive,disabled,checked">
+          <image class="menu-iconic-icon" inherits="src=image,triggeringprincipal=iconloadingprincipal,validate,src"/>
+        </hbox>
+        <label class="menu-iconic-text" flex="1" crop="right"/>
+        <label class="menu-iconic-highlightable-text" crop="right"/>
+      `));
+      this.append(MozXULElement.parseXULToFragment(`
+        <hbox class="menu-accel-container">
+          <label class="menu-iconic-accel" inherits="value=acceltext"/>
+        </hbox>
+      `));
+      this.menuText = this.querySelector(".menu-iconic-text");
+      this.menuHighlightableText = this.querySelector(".menu-iconic-highlightable-text");
+      this.menuAccel = this.querySelector(".menu-iconic-accel");
+    } else {
+      this.append(MozXULElement.parseXULToFragment(`
+        <label class="menu-text" crop="right"/>
+        <hbox class="menu-accel-container">
+          <label class="menu-accel"/>
+        </hbox>
+      `));
+      this.menuText = this.querySelector(".menu-text");
+      this.menuAccel = this.querySelector(".menu-accel");
+    }
+
+    this.inheritAttributes();
+  }
+
+  connectedCallback() {
+    menuitems.add(this);
+  }
+
+  disconnectedCallback() {
+    menuitems.delete(this);
+  }
+}
+
+customElements.define("menuitem", MozMenuItem);
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/progressmeter.js",
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -25,19 +25,20 @@
       </field>
     </implementation>
 
     <handlers>
       <handler event="popupshowing" phase="target">
         <![CDATA[
           var array = [];
           var width = 0;
+          console.log("POpupshowing")
           for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
             if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
-              var accel = document.getAnonymousElementByAttribute(menuitem, "anonid", "accel");
+              var accel = menuitem.menuAccel;
               if (accel && accel.boxObject) {
                 array.push(accel);
                 if (accel.boxObject.width > width)
                   width = accel.boxObject.width;
               }
             }
           }
           for (var i = 0; i < array.length; i++)
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -317,31 +317,16 @@ menu {
 menu.menu-iconic {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menu-iconic");
 }
 
 menubar > menu:empty {
   visibility: collapse;
 }
 
-/********* menuitem ***********/
-
-menuitem {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem");
-}
-
-menuitem.menuitem-iconic {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
-}
-
-menuitem[type="checkbox"],
-menuitem[type="radio"] {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
-}
-
 menucaption {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menucaption");
 }
 
 .menu-text {
   -moz-box-flex: 1;
 }
 
@@ -688,20 +673,16 @@ menulist[popuponly="true"] {
   -moz-binding: url("chrome://global/content/bindings/menulist.xml#menulist-popuponly");
   -moz-appearance: none !important;
   margin: 0 !important;
   height: 0 !important;
   min-height: 0 !important;
   border: 0 !important;
 }
 
-menulist > menupopup > menuitem {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic-noaccel");
-}
-
 dropmarker > .dropmarker-icon {
   pointer-events: none;
 }
 
 /********** splitter **********/
 
 .tree-splitter {
   width: 0px;
