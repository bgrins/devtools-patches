# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a9616aaeff87448588d57c295e16eb4caec420fb

diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -84,16 +84,17 @@ xmlns="http://www.w3.org/1999/xhtml"
 >
   Services.scriptloader.loadSubScript("chrome://global/content/contentAreaUtils.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/tabbrowser.js", this);
 
   window.onload = gBrowserInit.onLoad.bind(gBrowserInit);
   window.onunload = gBrowserInit.onUnload.bind(gBrowserInit);
   window.onclose = WindowIsClosing;
 #ifdef BROWSER_XHTML
+  //gBrowserInit.onBeforeInitialXULLayout()
   window.addEventListener("DOMContentLoaded",
     gBrowserInit.onBeforeInitialXULLayout.bind(gBrowserInit), { once: true });
 #else
   window.addEventListener("MozBeforeInitialXULLayout",
     gBrowserInit.onBeforeInitialXULLayout.bind(gBrowserInit), { once: true });
 #endif
   // The listener of DOMContentLoaded must be set on window, rather than
   // document, because the window can go away before the event is fired.
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -1087,16 +1087,19 @@
       <method name="getRelatedElement">
         <parameter name="aTab"/>
         <body>
         <![CDATA[
           if (!aTab) {
             return null;
           }
 
+          console.log("getRelatedElement", gBrowser);
+          console.trace();
+
           // Cannot access gBrowser before it's initialized.
           if (!gBrowser) {
             return this.tabbox.tabpanels.firstElementChild;
           }
 
           // If the tab's browser is lazy, we need to `_insertBrowser` in order
           // to have a linkedPanel.  This will also serve to bind the browser
           // and make it ready to use when the tab is selected.
diff --git a/toolkit/content/widgets/progressmeter.js b/toolkit/content/widgets/progressmeter.js
--- a/toolkit/content/widgets/progressmeter.js
+++ b/toolkit/content/widgets/progressmeter.js
@@ -64,52 +64,63 @@ class MozProgressmeter extends MozXULEle
     return val;
   }
 
   isUndetermined() {
     return this.getAttribute("mode") == "undetermined";
   }
 
   connectedCallback() {
+    this._hasBeenConnected = true;
     this._initUI();
   }
 
   disconnectedCallback() {
     this.runAnimation = false;
   }
 
   static get observedAttributes() {
     return [ "mode" ];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
+    console.log(name, oldValue, newValue);
+    console.trace();
     if (name === "mode" && oldValue != newValue) {
       this._initUI();
     }
   }
 
   _initUI() {
+    if (!this._hasBeenConnected) {
+      console.log("Early return");
+      return;
+    }
+    console.log("Progressmeter initui", this);
+    console.trace();
     let isUndetermined = this.isUndetermined();
     let content = isUndetermined ?
       `
         <stack class="progress-remainder" flex="1" style="overflow: -moz-hidden-unscrollable;">
           <spacer class="progress-bar" top="0" style="margin-right: -1000px;"/>
         </stack>
       ` :
       `
         <spacer class="progress-bar"/>
         <spacer class="progress-remainder"/>
       `;
 
     this._stack = null;
     this._spacer = null;
     this._runAnimation = isUndetermined;
-
+    console.log("Setting textContent", document.readyState, this, this.innerHTML, this.isConnected, this.parentNode);
     this.textContent = "";
+    console.log("Appending child", this.innerHTML);
     this.appendChild(MozXULElement.parseXULToFragment(content));
+    console.log("Done with append", this.innerHTML);
 
     if (!isUndetermined) {
       return;
     }
 
     this._stack = this.querySelector(".progress-remainder");
     this._spacer = this.querySelector(".progress-bar");
     this._isLTR = document.defaultView.getComputedStyle(this).direction == "ltr";
