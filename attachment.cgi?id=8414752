# HG changeset patch
# Parent 79989d4a8d24a5135fa5b02bedf1ce0c24052f30
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 997198 - Create a standalone reflow actor; r=bgrins

diff --git a/browser/devtools/layoutview/test/browser.ini b/browser/devtools/layoutview/test/browser.ini
--- a/browser/devtools/layoutview/test/browser.ini
+++ b/browser/devtools/layoutview/test/browser.ini
@@ -1,12 +1,11 @@
 [DEFAULT]
 skip-if = e10s # Bug ?????? - devtools tests disabled with e10s
 subsuite = devtools
 support-files =
   head.js
 
 [browser_layoutview.js]
-skip-if = true
 [browser_editablemodel.js]
 [browser_editablemodel_allproperties.js]
 [browser_editablemodel_border.js]
 [browser_editablemodel_stylerules.js]
diff --git a/browser/devtools/layoutview/test/browser_editablemodel.js b/browser/devtools/layoutview/test/browser_editablemodel.js
--- a/browser/devtools/layoutview/test/browser_editablemodel.js
+++ b/browser/devtools/layoutview/test/browser_editablemodel.js
@@ -78,19 +78,17 @@ function*() {
   is(editor.value, "10px", "Should have the right value in the editor.");
   is(getStyle(node, "margin-left"), "10px", "Should have updated the margin.");
 
   EventUtils.synthesizeKey("VK_UP", { shiftKey: true }, view);
   yield waitForUpdate();
 
   is(editor.value, "20px", "Should have the right value in the editor.");
   is(getStyle(node, "margin-left"), "20px", "Should have updated the margin.");
-
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "margin-left"), "20px", "Should be the right margin-top on the element.")
   is(span.textContent, 20, "Should have the right value in the box model.");
 });
 
 addTest("Test that deleting the value removes the property but escape undoes that",
 function*() {
   let node = doc.getElementById("div1");
@@ -134,13 +132,12 @@ function*() {
 
   EventUtils.synthesizeKey("VK_DELETE", {}, view);
   yield waitForUpdate();
 
   is(editor.value, "", "Should have the right value in the editor.");
   is(getStyle(node, "margin-right"), "", "Should have updated the margin.");
 
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "margin-right"), "", "Should be the right margin-top on the element.")
   is(span.textContent, 10, "Should have the right value in the box model.");
 });
diff --git a/browser/devtools/layoutview/test/browser_editablemodel_allproperties.js b/browser/devtools/layoutview/test/browser_editablemodel_allproperties.js
--- a/browser/devtools/layoutview/test/browser_editablemodel_allproperties.js
+++ b/browser/devtools/layoutview/test/browser_editablemodel_allproperties.js
@@ -43,17 +43,16 @@ function*() {
 
   EventUtils.synthesizeKey("7", {}, view);
   yield waitForUpdate();
 
   is(editor.value, "7", "Should have the right value in the editor.");
   is(getStyle(node, "padding-bottom"), "7px", "Should have updated the padding");
 
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "padding-bottom"), "7px", "Should be the right padding.")
   is(span.textContent, 7, "Should have the right value in the box model.");
 });
 
 addTest("When all properties are set on the node editing one should work",
 function*() {
   let node = doc.getElementById("div1");
@@ -97,17 +96,16 @@ function*() {
 
   EventUtils.synthesizeKey("VK_DELETE", {}, view);
   yield waitForUpdate();
 
   is(editor.value, "", "Should have the right value in the editor.");
   is(getStyle(node, "padding-left"), "", "Should have updated the padding");
 
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "padding-left"), "", "Should be the right padding.")
   is(span.textContent, 3, "Should have the right value in the box model.");
 });
 
 addTest("When all properties are set on the node deleting one then cancelling should work",
 function*() {
   let node = doc.getElementById("div1");
diff --git a/browser/devtools/layoutview/test/browser_editablemodel_stylerules.js b/browser/devtools/layoutview/test/browser_editablemodel_stylerules.js
--- a/browser/devtools/layoutview/test/browser_editablemodel_stylerules.js
+++ b/browser/devtools/layoutview/test/browser_editablemodel_stylerules.js
@@ -49,17 +49,16 @@ function*() {
 
   EventUtils.synthesizeKey("m", {}, view);
   yield waitForUpdate();
 
   is(editor.value, "1em", "Should have the right value in the editor.");
   is(getStyle(node, "padding-top"), "1em", "Should have updated the padding.");
 
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "padding-top"), "1em", "Should be the right padding.")
   is(span.textContent, 16, "Should have the right value in the box model.");
 });
 
 addTest("Test that we pick up the value from a higher style rule",
 function*() {
   let node = doc.getElementById("div2");
@@ -76,17 +75,16 @@ function*() {
 
   EventUtils.synthesizeKey("0", {}, view);
   yield waitForUpdate();
 
   is(editor.value, "0", "Should have the right value in the editor.");
   is(getStyle(node, "border-bottom-width"), "0px", "Should have updated the border.");
 
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "border-bottom-width"), "0px", "Should be the right border-bottom-width.")
   is(span.textContent, 0, "Should have the right value in the box model.");
 });
 
 addTest("Test that shorthand properties are parsed correctly",
 function*() {
   let node = doc.getElementById("div3");
@@ -97,13 +95,12 @@ function*() {
   is(span.textContent, 32, "Should have the right value in the box model.");
 
   EventUtils.synthesizeMouseAtCenter(span, {}, view);
   let editor = view.document.querySelector(".styleinspector-propertyeditor");
   ok(editor, "Should have opened the editor.");
   is(editor.value, "2em", "Should have the right value in the editor.");
 
   EventUtils.synthesizeKey("VK_RETURN", {}, view);
-  yield waitForUpdate();
 
   is(getStyle(node, "padding-right"), "", "Should be the right padding.")
   is(span.textContent, 32, "Should have the right value in the box model.");
 });
diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -13,16 +13,17 @@ const Cc = Components.classes;
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/Task.jsm");
 Cu.import("resource://gre/modules/devtools/Loader.jsm");
 Cu.import("resource://gre/modules/devtools/Console.jsm");
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const {InplaceEditor, editableItem} = devtools.require("devtools/shared/inplace-editor");
 const {parseDeclarations} = devtools.require("devtools/styleinspector/css-parsing-utils");
+const {ReflowFront} = devtools.require("devtools/server/actors/layout");
 
 const NUMERIC = /^-?[\d\.]+$/;
 const LONG_TEXT_ROTATE_LIMIT = 3;
 
 /**
  * An instance of EditingSession tracks changes that have been made during the
  * modification of box model values. All of these changes can be reverted by
  * calling revert.
@@ -85,70 +86,85 @@ EditingSession.prototype = {
    * @param properties  An array of properties, each is an object with name and
    *                    value properties. If the value is "" then the property
    *                    is removed.
    */
   setProperties: function(properties) {
     let modifications = this._rules[0].startModifyingProperties();
 
     for (let property of properties) {
-      if (!this._modifications.has(property.name))
-        this._modifications.set(property.name, this.getPropertyFromRule(this._rules[0], property.name));
+      if (!this._modifications.has(property.name)) {
+        this._modifications.set(property.name,
+          this.getPropertyFromRule(this._rules[0], property.name));
+      }
 
-      if (property.value == "")
+      if (property.value == "") {
         modifications.removeProperty(property.name);
-      else
+      } else {
         modifications.setProperty(property.name, property.value, "");
+      }
     }
 
     return modifications.apply().then(null, console.error);
   },
 
   /**
    * Reverts all of the property changes made by this instance. Returns a
    * promise that will be resolved when complete.
    */
   revert: function() {
     let modifications = this._rules[0].startModifyingProperties();
 
     for (let [property, value] of this._modifications) {
-      if (value != "")
+      if (value != "") {
         modifications.setProperty(property, value, "");
-      else
+      } else {
         modifications.removeProperty(property);
+      }
     }
 
     return modifications.apply().then(null, console.error);
+  },
+
+  destroy: function() {
+    this._doc = null;
+    this._rules = null;
+    this._modifications.clear();
   }
 };
 
-function LayoutView(aInspector, aWindow)
-{
-  this.inspector = aInspector;
+/**
+ * The layout-view panel
+ * @param {InspectorPanel} inspector An instance of the inspector-panel
+ * currently loaded in the toolbox
+ * @param {Window} win The window containing the panel
+ */
+function LayoutView(inspector, win) {
+  this.inspector = inspector;
 
-  // <browser> is not always available (for Chrome targets for example)
-  if (this.inspector.target.tab) {
-    this.browser = aInspector.target.tab.linkedBrowser;
-  }
-
-  this.doc = aWindow.document;
+  this.doc = win.document;
   this.sizeLabel = this.doc.querySelector(".size > span");
   this.sizeHeadingLabel = this.doc.getElementById("element-size");
 
   this.init();
 }
 
 LayoutView.prototype = {
-  init: function LV_init() {
+  init: function() {
     this.update = this.update.bind(this);
-    this.onNewNode = this.onNewNode.bind(this);
+
     this.onNewSelection = this.onNewSelection.bind(this);
     this.inspector.selection.on("new-node-front", this.onNewSelection);
+
+    this.onNewNode = this.onNewNode.bind(this);
     this.inspector.sidebar.on("layoutview-selected", this.onNewNode);
 
+    this.onSidebarSelect = this.onSidebarSelect.bind(this);
+    this.inspector.sidebar.on("select", this.onSidebarSelect);
+
     // Store for the different dimensions of the node.
     // 'selector' refers to the element that holds the value in view.xhtml;
     // 'property' is what we are measuring;
     // 'value' is the computed dimension, computed in update().
     this.map = {
       position: {selector: "#element-position",
                  property: "position",
                  value: undefined},
@@ -201,140 +217,186 @@ LayoutView.prototype = {
     };
 
     // Make each element the dimensions editable
     for (let i in this.map) {
       if (i == "position")
         continue;
 
       let dimension = this.map[i];
-      editableItem({ element: this.doc.querySelector(dimension.selector) }, (element, event) => {
+      editableItem({
+        element: this.doc.querySelector(dimension.selector)
+      }, (element, event) => {
         this.initEditor(element, event, dimension);
       });
     }
 
     this.onNewNode();
   },
 
   /**
+   * Start listening to reflows in the current tab.
+   */
+  trackReflows: function() {
+    if (!this.reflowFront) {
+      let toolbox = this.inspector.toolbox;
+      if (toolbox.target.form.reflowActor) {
+        this.reflowFront = ReflowFront(toolbox.target.client, toolbox.target.form);
+      } else {
+        return;
+      }
+    }
+
+    this.reflowFront.on("reflows", this.update);
+    this.reflowFront.start();
+  },
+
+  /**
+   * Stop listening to reflows in the current tab.
+   */
+  untrackReflows: function() {
+    if (!this.reflowFront) {
+      return;
+    }
+
+    this.reflowFront.off("reflows", this.update);
+    this.reflowFront.stop();
+  },
+
+  /**
    * Called when the user clicks on one of the editable values in the layoutview
    */
-  initEditor: function LV_initEditor(element, event, dimension) {
+  initEditor: function(element, event, dimension) {
     let { property, realProperty } = dimension;
     if (!realProperty)
       realProperty = property;
     let session = new EditingSession(document, this.elementRules);
     let initialValue = session.getProperty(realProperty);
 
     let editor = new InplaceEditor({
       element: element,
       initial: initialValue,
 
       start: (editor) => {
         editor.elt.parentNode.classList.add("editing");
       },
 
       change: (value) => {
-        if (NUMERIC.test(value))
+        if (NUMERIC.test(value)) {
           value += "px";
+        }
+
         let properties = [
           { name: property, value: value }
-        ]
+        ];
 
         if (property.substring(0, 7) == "border-") {
           let bprop = property.substring(0, property.length - 5) + "style";
           let style = session.getProperty(bprop);
-          if (!style || style == "none" || style == "hidden")
+          if (!style || style == "none" || style == "hidden") {
             properties.push({ name: bprop, value: "solid" });
+          }
         }
 
         session.setProperties(properties);
       },
 
       done: (value, commit) => {
         editor.elt.parentNode.classList.remove("editing");
-        if (!commit)
+        if (!commit) {
           session.revert();
+          session.destroy();
+        }
       }
     }, event);
   },
 
   /**
    * Is the layoutview visible in the sidebar?
    */
-  isActive: function LV_isActive() {
-    return this.inspector.sidebar.getCurrentTabID() == "layoutview";
+  isActive: function() {
+    return this.inspector &&
+           this.inspector.sidebar.getCurrentTabID() == "layoutview";
   },
 
   /**
    * Destroy the nodes. Remove listeners.
    */
-  destroy: function LV_destroy() {
+  destroy: function() {
     this.inspector.sidebar.off("layoutview-selected", this.onNewNode);
     this.inspector.selection.off("new-node-front", this.onNewSelection);
-    if (this.browser) {
-      this.browser.removeEventListener("MozAfterPaint", this.update, true);
-    }
+    this.inspector.sidebar.off("select", this.onSidebarSelect);
+
     this.sizeHeadingLabel = null;
     this.sizeLabel = null;
     this.inspector = null;
     this.doc = null;
+
+    if (reflowFront) {
+      this.untrackReflows();
+      this.reflowFront.destroy();
+      this.reflowFront = null;
+    }
+  },
+
+  onSidebarSelect: function(e, sidebar) {
+    if (sidebar !== "layoutview") {
+      this.dim();
+    }
   },
 
   /**
    * Selection 'new-node-front' event handler.
    */
   onNewSelection: function() {
     let done = this.inspector.updating("layoutview");
     this.onNewNode().then(done, (err) => { console.error(err); done() });
   },
 
-  onNewNode: function LV_onNewNode() {
+  /**
+   * @return a promise that resolves when the view has been updated
+   */
+  onNewNode: function() {
     if (this.isActive() &&
         this.inspector.selection.isConnected() &&
         this.inspector.selection.isElementNode()) {
       this.undim();
     } else {
       this.dim();
     }
+
     return this.update();
   },
 
   /**
-   * Hide the layout boxes. No node are selected.
+   * Hide the layout boxes and stop refreshing on reflows. No node is selected
+   * or the layout-view sidebar is inactive.
    */
-  dim: function LV_dim() {
-    if (this.browser) {
-      this.browser.removeEventListener("MozAfterPaint", this.update, true);
-    }
-    this.trackingPaint = false;
+  dim: function() {
+    this.untrackReflows();
     this.doc.body.classList.add("dim");
     this.dimmed = true;
   },
 
   /**
-   * Show the layout boxes. A node is selected.
+   * Show the layout boxes and start refreshing on reflows. A node is selected
+   * and the layout-view side is active.
    */
-  undim: function LV_undim() {
-    if (!this.trackingPaint) {
-      if (this.browser) {
-        this.browser.addEventListener("MozAfterPaint", this.update, true);
-      }
-      this.trackingPaint = true;
-    }
+  undim: function() {
+    this.trackReflows();
     this.doc.body.classList.remove("dim");
     this.dimmed = false;
   },
 
   /**
    * Compute the dimensions of the node and update the values in
-   * the layoutview/view.xhtml document. Returns a promise that will be resolved
-   * when complete.
+   * the layoutview/view.xhtml document.
+   * @return a promise that will be resolved when complete.
    */
-  update: function LV_update() {
+  update: function() {
     let lastRequest = Task.spawn((function*() {
       if (!this.isActive() ||
           !this.inspector.selection.isConnected() ||
           !this.inspector.selection.isElementNode()) {
         return;
       }
 
       let node = this.inspector.selection.nodeFront;
@@ -410,23 +472,30 @@ LayoutView.prototype = {
       this.elementRules = [e.rule for (e of styleEntries)];
 
       this.inspector.emit("layoutview-updated");
     }).bind(this)).then(null, console.error);
 
     return this._lastRequest = lastRequest;
   },
 
+  /**
+   * Show the box-model highlighter on the currently selected element
+   * @param {Object} options Options passed to the highlighter actor
+   */
   showBoxModel: function(options={}) {
     let toolbox = this.inspector.toolbox;
     let nodeFront = this.inspector.selection.nodeFront;
 
     toolbox.highlighterUtils.highlightNodeFront(nodeFront, options);
   },
 
+  /**
+   * Hide the box-model highlighter on the currently selected element
+   */
   hideBoxModel: function() {
     let toolbox = this.inspector.toolbox;
 
     toolbox.highlighterUtils.unhighlight();
   },
 
   manageOverflowingText: function(span) {
     let classList = span.parentNode.classList;
diff --git a/toolkit/devtools/server/actors/layout.js b/toolkit/devtools/server/actors/layout.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/actors/layout.js
@@ -0,0 +1,390 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ * About the types of objects in this file:
+ *
+ * - ReflowActor: the actor class used for protocol purposes.
+ *   Mostly empty, just gets an instance of LayoutChangesObserver and forwards
+ *   its "reflows" events to clients.
+ *
+ * - Observable: A utility parent class, meant at being extended by classes that
+ *   need a start/stop behavior.
+ *
+ * - LayoutChangesObserver: extends Observable and uses the ReflowObserver, to
+ *   track reflows on the page.
+ *   Used by the LayoutActor, but is also exported on the module, so can be used
+ *   by any other actor that needs it.
+ *
+ * - Dedicated observers: There's only one of them for now: ReflowObserver which
+ *   listens to reflow events via the docshell,
+ *   These dedicated classes are used by the LayoutChangesObserver.
+ */
+
+const {Ci, Cu} = require("chrome");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+const protocol = require("devtools/server/protocol");
+const {method, Arg, RetVal, types} = protocol;
+const events = require("sdk/event/core");
+const Heritage = require("sdk/core/heritage");
+const {EventEmitter} = Cu.import("resource://gre/modules/devtools/event-emitter.js");
+
+XPCOMUtils.defineLazyModuleGetter(this, "setNamedTimeout",
+  "resource:///modules/devtools/ViewHelpers.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "clearNamedTimeout",
+  "resource:///modules/devtools/ViewHelpers.jsm");
+
+// The lower the value, the more event packets will be sent to the clients,
+// potentially impacting performance. The higher the value, the more time we'll
+// wait until sending batched reflow events, which is better for performance but
+// has an effect on how soon changes are shown in the toolbox
+const EVENT_BATCHING_DELAY = 300;
+
+exports.register = function(handle) {
+  handle.addTabActor(ReflowActor, "reflowActor");
+};
+
+exports.unregister = function(handle) {
+  handle.removeTabActor(ReflowActor);
+};
+
+/**
+ * The reflow actor tracks reflows and emits events about them.
+ */
+let ReflowActor = protocol.ActorClass({
+  typeName: "reflow",
+
+  events: {
+    /**
+     * The reflows event is emitted when reflows have been detected. The event
+     * is sent with an array of reflows that occured. Each item has the
+     * following properties:
+     * - start {Number}
+     * - end {Number}
+     * - isInterruptible {Boolean}
+     */
+    "reflows" : {
+      type: "reflows",
+      reflows: Arg(0, "array:json")
+    }
+  },
+
+  initialize: function(conn, tabActor) {
+    protocol.Actor.prototype.initialize.call(this, conn);
+
+    this.tabActor = tabActor;
+    this._onReflow = this._onReflow.bind(this);
+    this.observer = getLayoutChangesObserver(tabActor);
+    this._isStarted = false;
+  },
+
+  /**
+   * The reflow actor is the first (and last) in its hierarchy to use protocol.js
+   * so it doesn't have a parent protocol actor that takes care of its lifetime.
+   * So it needs a disconnect method to cleanup.
+   */
+  disconnect: function() {
+    this.destroy();
+  },
+
+  destroy: function() {
+    this.stop();
+    releaseLayoutChangesObserver(this.tabActor);
+    this.observer = null;
+    this.tabActor = null;
+
+    protocol.Actor.prototype.destroy.call(this);
+  },
+
+  /**
+   * Start tracking reflows and sending events to clients about them.
+   * This is a oneway method, do not expect a response and it won't return a
+   * promise.
+   */
+  start: method(function() {
+    if (!this._isStarted) {
+      this.observer.on("reflows", this._onReflow);
+      this._isStarted = true;
+    }
+  }, {oneway: true}),
+
+  /**
+   * Stop tracking reflows and sending events to clients about them.
+   * This is a oneway method, do not expect a response and it won't return a
+   * promise.
+   */
+  stop: method(function() {
+    if (this._isStarted) {
+      this.observer.off("reflows", this._onReflow);
+      this._isStarted = false;
+    }
+  }, {oneway: true}),
+
+  _onReflow: function(event, reflows) {
+    if (this._isStarted) {
+      events.emit(this, "reflows", reflows);
+    }
+  }
+});
+
+/**
+ * Usage example of the reflow front:
+ *
+ * let front = ReflowFront(toolbox.target.client, toolbox.target.form);
+ * front.on("reflows", this._onReflows);
+ * front.start();
+ * // now wait for events to come
+ */
+exports.ReflowFront = protocol.FrontClass(ReflowActor, {
+  initialize: function(client, {reflowActor}) {
+    protocol.Front.prototype.initialize.call(this, client, {actor: reflowActor});
+    client.addActorPool(this);
+    this.manage(this);
+  },
+
+  destroy: function() {
+    protocol.Front.prototype.destroy.call(this);
+  },
+});
+
+/**
+ * Base class for all sorts of observers we need to create for a given window.
+ * @param {TabActor} tabActor
+ * @param {Function} callback Executed everytime the observer observes something
+ */
+function Observable(tabActor, callback) {
+  this.tabActor = tabActor;
+  this.win = tabActor.window;
+  this.callback = callback;
+}
+
+Observable.prototype = {
+  /**
+   * Is the observer currently observing
+   */
+  observing: false,
+
+  /**
+   * Start observing whatever it is this observer is supposed to observe
+   */
+  start: function() {
+    if (!this.observing) {
+      this._start();
+      this.observing = true;
+    }
+  },
+
+  _start: function() {
+    /* To be implemented by sub-classes */
+  },
+
+  /**
+   * Stop observing
+   */
+  stop: function() {
+    if (this.observing) {
+      this._stop();
+      this.observing = false;
+    }
+  },
+
+  _stop: function() {
+    /* To be implemented by sub-classes */
+  },
+
+  /**
+   * To be called by sub-classes when something has been observed
+   */
+  notifyCallback: function(...args) {
+    this.callback && this.callback.apply(null, args);
+  },
+
+  /**
+   * Stop observing and detroy this observer instance
+   */
+  destroy: function() {
+    this.stop();
+    this.callback = null;
+    this.win = null;
+    this.tabActor = null;
+  }
+};
+
+/**
+ * The LayoutChangesObserver class is instantiated only once per given tab
+ * and is used to track reflows and dom and style changes in that tab.
+ * The LayoutActor uses this class to send reflow events to its clients.
+ *
+ * This class isn't exported on the module because it shouldn't be instantiated
+ * to avoid creating several instances per tabs.
+ * Use `getLayoutChangesObserver(tabActor)`
+ * and `releaseLayoutChangesObserver(tabActor)`
+ * which are exported to get and release instances.
+ *
+ * The observer loops every EVENT_BATCHING_DELAY ms and checks if layout changes
+ * have happened since the last loop iteration. If there are, it sends the
+ * corresponding events:
+ *
+ * - "reflows", with an array of all the reflows that occured,
+ *
+ * @param {TabActor} tabActor
+ */
+function LayoutChangesObserver(tabActor) {
+  Observable.call(this, tabActor);
+
+  this._startEventLoop = this._startEventLoop.bind(this);
+
+  // Creating the various observers we're going to need
+  // For now, just the reflow observer, but later we can add markupMutation,
+  // styleSheetChanges and styleRuleChanges
+  this._onReflow = this._onReflow.bind(this);
+  this.reflowObserver = new ReflowObserver(this.tabActor, this._onReflow);
+
+  EventEmitter.decorate(this);
+}
+
+LayoutChangesObserver.prototype = Heritage.extend(Observable.prototype, {
+  destroy: function() {
+    this.reflowObserver.destroy();
+    this.reflows = null;
+
+    Observable.prototype.destroy.call(this);
+  },
+
+  _start: function() {
+    this.reflows = [];
+    this._startEventLoop();
+    this.reflowObserver.start();
+  },
+
+  _stop: function() {
+    this._stopEventLoop();
+    this.reflows = [];
+    this.reflowObserver.stop();
+  },
+
+  /**
+   * Start the event loop, which regularly checks if there are any observer
+   * events to be sent as batched events
+   * Calls itself in a loop.
+   */
+  _startEventLoop: function() {
+    // Send any reflows we have
+    if (this.reflows && this.reflows.length) {
+      this.emit("reflows", this.reflows);
+      this.reflows = [];
+    }
+    setNamedTimeout("event-loop", EVENT_BATCHING_DELAY,
+      this._startEventLoop);
+  },
+
+  _stopEventLoop: function() {
+    clearNamedTimeout("event-loop");
+  },
+
+  /**
+   * Executed whenever a reflow is observed. Only stacks the reflow in the
+   * reflows array.
+   * The EVENT_BATCHING_DELAY loop will take care of it later.
+   * @param {Number} start When the reflow started
+   * @param {Number} end When the reflow ended
+   * @param {Boolean} isInterruptible
+   */
+  _onReflow: function(start, end, isInterruptible) {
+    // XXX: when/if bug 997092 gets fixed, we will be able to know which
+    // elements have been reflowed, which would be a nice thing to add here.
+    this.reflows.push({
+      start: start,
+      end: end,
+      isInterruptible: isInterruptible
+    });
+  }
+});
+
+/**
+ * Get a LayoutChangesObserver instance for a given window. This function makes
+ * sure there is only one instance per window.
+ * @param {TabActor} tabActor
+ * @return {LayoutChangesObserver}
+ */
+let observedWindows = new Map();
+function getLayoutChangesObserver(tabActor) {
+  let observerData = observedWindows.get(tabActor);
+  if (observerData) {
+    observerData.refCounting ++;
+    return observerData.observer;
+  }
+
+  let obs = new LayoutChangesObserver(tabActor);
+  observedWindows.set(tabActor, {
+    observer: obs,
+    refCounting: 1 // counting references allows to stop the observer when no
+                   // tabActor owns an instance
+  });
+  obs.start();
+  return obs;
+};
+exports.getLayoutChangesObserver = getLayoutChangesObserver;
+
+/**
+ * Release a LayoutChangesObserver instance that was retrieved by
+ * getLayoutChangesObserver. This is required to ensure the tabActor reference
+ * is removed and the observer is eventually stopped and destroyed.
+ * @param {TabActor} tabActor
+ */
+function releaseLayoutChangesObserver(tabActor) {
+  let observerData = observedWindows.get(tabActor);
+  if (!observerData) {
+    return;
+  }
+
+  observerData.refCounting --;
+  if (!observerData.refCounting) {
+    observerData.observer.destroy();
+    observedWindows.delete(tabActor);
+  }
+};
+exports.releaseLayoutChangesObserver = releaseLayoutChangesObserver;
+
+/**
+ * Instantiate and start a reflow observer on a given window's document element.
+ * Will report any reflow that occurs in this window's docshell.
+ * @extends Observable
+ * @param {TabActor} tabActor
+ * @param {Function} callback Executed everytime a reflow occurs
+ */
+function ReflowObserver(tabActor, callback) {
+  Observable.call(this, tabActor, callback);
+  this.docshell = this.win.QueryInterface(Ci.nsIInterfaceRequestor)
+                     .getInterface(Ci.nsIWebNavigation)
+                     .QueryInterface(Ci.nsIDocShell);
+}
+
+ReflowObserver.prototype = Heritage.extend(Observable.prototype, {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIReflowObserver,
+    Ci.nsISupportsWeakReference]),
+
+  _start: function() {
+    this.docshell.addWeakReflowObserver(this);
+  },
+
+  _stop: function() {
+    this.docshell.removeWeakReflowObserver(this);
+  },
+
+  reflow: function(start, end) {
+    this.notifyCallback(start, end, false);
+  },
+
+  reflowInterruptible: function(start, end) {
+    this.notifyCallback(start, end, true);
+  },
+
+  destroy: function() {
+    Observable.prototype.destroy.call(this);
+    this.docshell = null;
+  }
+});
diff --git a/toolkit/devtools/server/main.js b/toolkit/devtools/server/main.js
--- a/toolkit/devtools/server/main.js
+++ b/toolkit/devtools/server/main.js
@@ -386,16 +386,17 @@ var DebuggerServer = {
     this.registerModule("devtools/server/actors/webaudio");
     this.registerModule("devtools/server/actors/stylesheets");
     this.registerModule("devtools/server/actors/styleeditor");
     this.registerModule("devtools/server/actors/storage");
     this.registerModule("devtools/server/actors/gcli");
     this.registerModule("devtools/server/actors/tracer");
     this.registerModule("devtools/server/actors/memory");
     this.registerModule("devtools/server/actors/eventlooplag");
+    this.registerModule("devtools/server/actors/layout");
     if ("nsIProfiler" in Ci) {
       this.addActors("resource://gre/modules/devtools/server/actors/profiler.js");
     }
   },
 
   /**
    * Passes a set of options to the BrowserAddonActors for the given ID.
    *
