# HG changeset patch
# Parent a3f38364796686fb7787fb2868dd0ed25a20089a
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 1014547 - part 1 - Remove the css transform preview tooltip

diff --git a/browser/devtools/shared/test/browser.ini b/browser/devtools/shared/test/browser.ini
--- a/browser/devtools/shared/test/browser.ini
+++ b/browser/devtools/shared/test/browser.ini
@@ -34,9 +34,8 @@ support-files =
 [browser_toolbar_webconsole_errors_count.js]
 [browser_treeWidget_basic.js]
 [browser_treeWidget_keyboard_interaction.js]
 [browser_treeWidget_mouse_interaction.js]
 [browser_tableWidget_basic.js]
 [browser_tableWidget_keyboard_interaction.js]
 [browser_tableWidget_mouse_interaction.js]
 [browser_spectrum.js]
-[browser_csstransformpreview.js]
diff --git a/browser/devtools/shared/test/browser_csstransformpreview.js b/browser/devtools/shared/test/browser_csstransformpreview.js
deleted file mode 100644
--- a/browser/devtools/shared/test/browser_csstransformpreview.js
+++ /dev/null
@@ -1,139 +0,0 @@
-/* vim: set ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-// Tests that the spectrum color picker works correctly
-
-const TEST_URI = "data:text/html;charset=utf-8,<div></div>";
-const {CSSTransformPreviewer} = devtools.require("devtools/shared/widgets/CSSTransformPreviewer");
-
-let doc, root;
-
-function test() {
-  waitForExplicitFinish();
-  addTab(TEST_URI, () => {
-    doc = content.document;
-    root = doc.querySelector("div");
-    startTests();
-  });
-}
-
-function endTests() {
-  doc = root = null;
-  gBrowser.removeCurrentTab();
-  finish();
-}
-
-function startTests() {
-  testCreateAndDestroyShouldAppendAndRemoveElements();
-}
-
-function testCreateAndDestroyShouldAppendAndRemoveElements() {
-  ok(root, "We have the root node to append the preview to");
-  is(root.childElementCount, 0, "Root node is empty");
-
-  let p = new CSSTransformPreviewer(root);
-  p.preview("matrix(1, -0.2, 0, 1, 0, 0)");
-  ok(root.childElementCount > 0, "Preview has appended elements");
-  ok(root.querySelector("canvas"), "Canvas preview element is here");
-
-  p.destroy();
-  is(root.childElementCount, 0, "Destroying preview removed all nodes");
-
-  testCanvasDimensionIsConstrainedByMaxDim();
-}
-
-function testCanvasDimensionIsConstrainedByMaxDim() {
-  let p = new CSSTransformPreviewer(root);
-  p.MAX_DIM = 500;
-  p.preview("scale(1)", "center", 1000, 1000);
-
-  let canvas = root.querySelector("canvas");
-  is(canvas.width, 500, "Canvas width is correct");
-  is(canvas.height, 500, "Canvas height is correct");
-
-  p.destroy();
-
-  testCallingPreviewSeveralTimesReusesTheSameCanvas();
-}
-
-function testCallingPreviewSeveralTimesReusesTheSameCanvas() {
-  let p = new CSSTransformPreviewer(root);
-
-  p.preview("scale(1)", "center", 1000, 1000);
-  let canvas = root.querySelector("canvas");
-
-  p.preview("rotate(90deg)");
-  let canvases = root.querySelectorAll("canvas");
-  is(canvases.length, 1, "Still one canvas element");
-  is(canvases[0], canvas, "Still the same canvas element");
-  p.destroy();
-
-  testCanvasDimensionAreCorrect();
-}
-
-function testCanvasDimensionAreCorrect() {
-  // Only test a few simple transformations
-  let p = new CSSTransformPreviewer(root);
-
-  // Make sure we have a square
-  let w = 200, h = w;
-  p.MAX_DIM = w;
-
-  // We can't test the content of the canvas here, just that, given a max width
-  // the aspect ratio of the canvas seems correct.
-
-  // Translate a square by its width, should be a rectangle
-  p.preview("translateX(200px)", "center", w, h);
-  let canvas = root.querySelector("canvas");
-  is(canvas.width, w, "width is correct");
-  is(canvas.height, h/2, "height is half of the width");
-
-  // Rotate on the top right corner, should be a rectangle
-  p.preview("rotate(-90deg)", "top right", w, h);
-  is(canvas.width, w, "width is correct");
-  is(canvas.height, h/2, "height is half of the width");
-
-  // Rotate on the bottom left corner, should be a rectangle
-  p.preview("rotate(90deg)", "top right", w, h);
-  is(canvas.width, w/2, "width is half of the height");
-  is(canvas.height, h, "height is correct");
-
-  // Scale from center, should still be a square
-  p.preview("scale(2)", "center", w, h);
-  is(canvas.width, w, "width is correct");
-  is(canvas.height, h, "height is correct");
-
-  // Skew from center, 45deg, should be a rectangle
-  p.preview("skew(45deg)", "center", w, h);
-  is(canvas.width, w, "width is correct");
-  is(canvas.height, h/2, "height is half of the height");
-
-  p.destroy();
-
-  testPreviewingInvalidTransformReturnsFalse();
-}
-
-function testPreviewingInvalidTransformReturnsFalse() {
-  let p = new CSSTransformPreviewer(root);
-  ok(!p.preview("veryWow(muchPx) suchTransform(soDeg)"), "Returned false for invalid transform");
-  ok(!p.preview("rotae(3deg)"), "Returned false for invalid transform");
-
-  // Verify the canvas is empty by checking the image data
-  let canvas = root.querySelector("canvas"), ctx = canvas.getContext("2d");
-  let data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
-  for (let i = 0, n = data.length; i < n; i += 4) {
-    // Let's not log 250*250*4 asserts! Instead, just log when it fails
-    let red = data[i];
-    let green = data[i + 1];
-    let blue = data[i + 2];
-    let alpha = data[i + 3];
-    if (red !== 0 || green !== 0 || blue !== 0 || alpha !== 0) {
-      ok(false, "Image data is not empty after an invalid transformed was previewed");
-      break;
-    }
-  }
-
-  is(p.preview("translateX(30px)"), true, "Returned true for a valid transform");
-  endTests();
-}
diff --git a/browser/devtools/shared/widgets/CSSTransformPreviewer.js b/browser/devtools/shared/widgets/CSSTransformPreviewer.js
deleted file mode 100644
--- a/browser/devtools/shared/widgets/CSSTransformPreviewer.js
+++ /dev/null
@@ -1,389 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-/**
- * The CSSTransformPreview module displays, using a <canvas> a rectangle, with
- * a given width and height and its transformed version, given a css transform
- * property and origin. It also displays arrows from/to each corner.
- *
- * It is useful to visualize how a css transform affected an element. It can
- * help debug tricky transformations. It is used today in a tooltip, and this
- * tooltip is shown when hovering over a css transform declaration in the rule
- * and computed view panels.
- *
- * TODO: For now, it multiplies matrices itself to calculate the coordinates of
- * the transformed box, but that should be removed as soon as we can get access
- * to getQuads().
- */
-
-const HTML_NS = "http://www.w3.org/1999/xhtml";
-
-/**
- * The TransformPreview needs an element to output a canvas tag.
- *
- * Usage example:
- *
- * let t = new CSSTransformPreviewer(myRootElement);
- * t.preview("rotate(45deg)", "top left", 200, 400);
- * t.preview("skew(19deg)", "center", 100, 500);
- * t.preview("matrix(1, -0.2, 0, 1, 0, 0)");
- * t.destroy();
- *
- * @param {nsIDOMElement} parentEl
- *        Where the canvas will go
- */
-function CSSTransformPreviewer(parentEl) {
-  this.parentEl = parentEl;
-  this.doc = this.parentEl.ownerDocument;
-  this.canvas = null;
-  this.ctx = null;
-}
-
-module.exports.CSSTransformPreviewer = CSSTransformPreviewer;
-
-CSSTransformPreviewer.prototype = {
-  /**
-   * The preview look-and-feel can be changed using these properties
-   */
-  MAX_DIM: 250,
-  PAD: 5,
-  ORIGINAL_FILL: "#1F303F",
-  ORIGINAL_STROKE: "#B2D8FF",
-  TRANSFORMED_FILL: "rgba(200, 200, 200, .5)",
-  TRANSFORMED_STROKE: "#B2D8FF",
-  ARROW_STROKE: "#329AFF",
-  ORIGIN_STROKE: "#329AFF",
-  ARROW_TIP_HEIGHT: 10,
-  ARROW_TIP_WIDTH: 8,
-  CORNER_SIZE_RATIO: 6,
-
-  /**
-   * Destroy removes the canvas from the parentelement passed in the constructor
-   */
-  destroy: function() {
-    if (this.canvas) {
-      this.parentEl.removeChild(this.canvas);
-    }
-    if (this._hiddenDiv) {
-      this.parentEl.removeChild(this._hiddenDiv);
-    }
-    this.parentEl = this.canvas = this.ctx = this.doc = null;
-  },
-
-  _createMarkup: function() {
-    this.canvas = this.doc.createElementNS(HTML_NS, "canvas");
-
-    this.canvas.setAttribute("id", "canvas");
-    this.canvas.setAttribute("width", this.MAX_DIM);
-    this.canvas.setAttribute("height", this.MAX_DIM);
-    this.canvas.style.position = "relative";
-    this.parentEl.appendChild(this.canvas);
-
-    this.ctx = this.canvas.getContext("2d");
-  },
-
-  _getComputed: function(name, value, width, height) {
-    if (!this._hiddenDiv) {
-      // Create a hidden element to apply the style to
-      this._hiddenDiv = this.doc.createElementNS(HTML_NS, "div");
-      this._hiddenDiv.style.visibility = "hidden";
-      this._hiddenDiv.style.position = "absolute";
-      this.parentEl.appendChild(this._hiddenDiv);
-    }
-
-    // Camelcase the name
-    name = name.replace(/-([a-z]{1})/g, (m, letter) => letter.toUpperCase());
-
-    // Apply width and height to make sure computation is made correctly
-    this._hiddenDiv.style.width = width + "px";
-    this._hiddenDiv.style.height = height + "px";
-
-    // Show the hidden div, apply the style, read the computed style, hide the
-    // hidden div again
-    this._hiddenDiv.style.display = "block";
-    this._hiddenDiv.style[name] = value;
-    let computed = this.doc.defaultView.getComputedStyle(this._hiddenDiv);
-    let computedValue = computed[name];
-    this._hiddenDiv.style.display = "none";
-
-    return computedValue;
-  },
-
-  _getMatrixFromTransformString: function(transformStr) {
-    let matrix = transformStr.substring(0, transformStr.length - 1).
-      substring(transformStr.indexOf("(") + 1).split(",");
-
-    matrix.forEach(function(value, index) {
-      matrix[index] = parseFloat(value, 10);
-    });
-
-    let transformMatrix = null;
-
-    if (matrix.length === 6) {
-      // 2d transform
-      transformMatrix = [
-        [matrix[0], matrix[2], matrix[4], 0],
-        [matrix[1], matrix[3], matrix[5], 0],
-        [0,     0,     1,     0],
-        [0,     0,     0,     1]
-      ];
-    } else {
-      // 3d transform
-      transformMatrix = [
-        [matrix[0], matrix[4], matrix[8],  matrix[12]],
-        [matrix[1], matrix[5], matrix[9],  matrix[13]],
-        [matrix[2], matrix[6], matrix[10], matrix[14]],
-        [matrix[3], matrix[7], matrix[11], matrix[15]]
-      ];
-    }
-
-    return transformMatrix;
-  },
-
-  _getOriginFromOriginString: function(originStr) {
-    let offsets = originStr.split(" ");
-    offsets.forEach(function(item, index) {
-      offsets[index] = parseInt(item, 10);
-    });
-
-    return offsets;
-  },
-
-  _multiply: function(m1, m2) {
-    let m = [];
-    for (let m1Line = 0; m1Line < m1.length; m1Line++) {
-      m[m1Line] = 0;
-      for (let m2Col = 0; m2Col < m2.length; m2Col++) {
-        m[m1Line] += m1[m1Line][m2Col] * m2[m2Col];
-      }
-    }
-    return [m[0], m[1]];
-  },
-
-  _getTransformedPoint: function(matrix, point, origin) {
-    let pointMatrix = [point[0] - origin[0], point[1] - origin[1], 1, 1];
-    return this._multiply(matrix, pointMatrix);
-  },
-
-  _getTransformedPoints: function(matrix, rect, origin) {
-    return rect.map(point => {
-      let tPoint = this._getTransformedPoint(matrix, [point[0], point[1]], origin);
-      return [tPoint[0] + origin[0], tPoint[1] + origin[1]];
-    });
-  },
-
-  /**
-   * For canvas to avoid anti-aliasing
-   */
-  _round: x => Math.round(x) + .5,
-
-  _drawShape: function(points, fillStyle, strokeStyle) {
-    this.ctx.save();
-
-    this.ctx.lineWidth = 1;
-    this.ctx.strokeStyle = strokeStyle;
-    this.ctx.fillStyle = fillStyle;
-
-    this.ctx.beginPath();
-    this.ctx.moveTo(this._round(points[0][0]), this._round(points[0][1]));
-    for (var i = 1; i < points.length; i++) {
-      this.ctx.lineTo(this._round(points[i][0]), this._round(points[i][1]));
-    }
-    this.ctx.lineTo(this._round(points[0][0]), this._round(points[0][1]));
-    this.ctx.fill();
-    this.ctx.stroke();
-
-    this.ctx.restore();
-  },
-
-  _drawArrow: function(x1, y1, x2, y2) {
-    // do not draw if the line is too small
-    if (Math.abs(x2-x1) < 20 && Math.abs(y2-y1) < 20) {
-      return;
-    }
-
-    this.ctx.save();
-
-    this.ctx.strokeStyle = this.ARROW_STROKE;
-    this.ctx.fillStyle = this.ARROW_STROKE;
-    this.ctx.lineWidth = 1;
-
-    this.ctx.beginPath();
-    this.ctx.moveTo(this._round(x1), this._round(y1));
-    this.ctx.lineTo(this._round(x2), this._round(y2));
-    this.ctx.stroke();
-
-    this.ctx.beginPath();
-    this.ctx.translate(x2, y2);
-    let radians = Math.atan((y1 - y2) / (x1 - x2));
-    radians += ((x1 >= x2) ? -90 : 90) * Math.PI / 180;
-    this.ctx.rotate(radians);
-    this.ctx.moveTo(0, 0);
-    this.ctx.lineTo(this.ARROW_TIP_WIDTH / 2, this.ARROW_TIP_HEIGHT);
-    this.ctx.lineTo(-this.ARROW_TIP_WIDTH / 2, this.ARROW_TIP_HEIGHT);
-    this.ctx.closePath();
-    this.ctx.fill();
-
-    this.ctx.restore();
-  },
-
-  _drawOrigin: function(x, y) {
-    this.ctx.save();
-
-    this.ctx.strokeStyle = this.ORIGIN_STROKE;
-    this.ctx.fillStyle = this.ORIGIN_STROKE;
-
-    this.ctx.beginPath();
-    this.ctx.arc(x, y, 4, 0, 2 * Math.PI, false);
-    this.ctx.stroke();
-    this.ctx.fill();
-
-    this.ctx.restore();
-  },
-
-  /**
-   * Computes the largest width and height of all the given shapes and changes
-   * all of the shapes' points (by reference) so they fit into the configured
-   * MAX_DIM - 2*PAD area.
-   * @return {Object} A {w, h} giving the size the canvas should be
-   */
-  _fitAllShapes: function(allShapes) {
-    let allXs = [], allYs = [];
-    for (let shape of allShapes) {
-      for (let point of shape) {
-        allXs.push(point[0]);
-        allYs.push(point[1]);
-      }
-    }
-    let minX = Math.min.apply(Math, allXs);
-    let maxX = Math.max.apply(Math, allXs);
-    let minY = Math.min.apply(Math, allYs);
-    let maxY = Math.max.apply(Math, allYs);
-
-    let spanX = maxX - minX;
-    let spanY = maxY - minY;
-    let isWide = spanX > spanY;
-
-    let cw = isWide ? this.MAX_DIM :
-      this.MAX_DIM * Math.min(spanX, spanY) / Math.max(spanX, spanY);
-    let ch = !isWide ? this.MAX_DIM :
-      this.MAX_DIM * Math.min(spanX, spanY) / Math.max(spanX, spanY);
-
-    let mapX = x => this.PAD + ((cw - 2 * this.PAD) / (maxX - minX)) * (x - minX);
-    let mapY = y => this.PAD + ((ch - 2 * this.PAD) / (maxY - minY)) * (y - minY);
-
-    for (let shape of allShapes) {
-      for (let point of shape) {
-        point[0] = mapX(point[0]);
-        point[1] = mapY(point[1]);
-      }
-    }
-
-    return {w: cw, h: ch};
-  },
-
-  _drawShapes: function(shape, corner, transformed, transformedCorner) {
-    this._drawOriginal(shape);
-    this._drawOriginalCorner(corner);
-    this._drawTransformed(transformed);
-    this._drawTransformedCorner(transformedCorner);
-  },
-
-  _drawOriginal: function(points) {
-    this._drawShape(points, this.ORIGINAL_FILL, this.ORIGINAL_STROKE);
-  },
-
-  _drawTransformed: function(points) {
-    this._drawShape(points, this.TRANSFORMED_FILL, this.TRANSFORMED_STROKE);
-  },
-
-  _drawOriginalCorner: function(points) {
-    this._drawShape(points, this.ORIGINAL_STROKE, this.ORIGINAL_STROKE);
-  },
-
-  _drawTransformedCorner: function(points) {
-    this._drawShape(points, this.TRANSFORMED_STROKE, this.TRANSFORMED_STROKE);
-  },
-
-  _drawArrows: function(shape, transformed) {
-    this._drawArrow(shape[0][0], shape[0][1], transformed[0][0], transformed[0][1]);
-    this._drawArrow(shape[1][0], shape[1][1], transformed[1][0], transformed[1][1]);
-    this._drawArrow(shape[2][0], shape[2][1], transformed[2][0], transformed[2][1]);
-    this._drawArrow(shape[3][0], shape[3][1], transformed[3][0], transformed[3][1]);
-  },
-
-  /**
-   * Draw a transform preview
-   *
-   * @param {String} transform
-   *        The css transform value as a string, as typed by the user, as long
-   *        as it can be computed by the browser
-   * @param {String} origin
-   *        Same as above for the transform-origin value. Defaults to "center"
-   * @param {Number} width
-   *        The width of the container. Defaults to 200
-   * @param {Number} height
-   *        The height of the container. Defaults to 200
-   * @return {Boolean} Whether or not the preview could be created. Will return
-   *         false for instance if the transform is invalid
-   */
-  preview: function(transform, origin="center", width=200, height=200) {
-    // Create/clear the canvas
-    if (!this.canvas) {
-      this._createMarkup();
-    }
-    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
-
-    // Get computed versions of transform and origin
-    transform = this._getComputed("transform", transform, width, height);
-    if (transform && transform !== "none") {
-      origin = this._getComputed("transform-origin", origin, width, height);
-
-      // Get the matrix, origin and width height data for the previewed element
-      let originData = this._getOriginFromOriginString(origin);
-      let matrixData = this._getMatrixFromTransformString(transform);
-
-      // Compute the original box rect and transformed box rect
-      let shapePoints = [
-        [0, 0],
-        [width, 0],
-        [width, height],
-        [0, height]
-      ];
-      let transformedPoints = this._getTransformedPoints(matrixData, shapePoints, originData);
-
-      // Do the same for the corner triangle shape
-      let cornerSize = Math.min(shapePoints[2][1] - shapePoints[1][1],
-        shapePoints[1][0] - shapePoints[0][0]) / this.CORNER_SIZE_RATIO;
-      let cornerPoints = [
-        [shapePoints[1][0], shapePoints[1][1]],
-        [shapePoints[1][0], shapePoints[1][1] + cornerSize],
-        [shapePoints[1][0] - cornerSize, shapePoints[1][1]]
-      ];
-      let transformedCornerPoints = this._getTransformedPoints(matrixData, cornerPoints, originData);
-
-      // Resize points to fit everything in the canvas
-      let {w, h} = this._fitAllShapes([
-        shapePoints,
-        transformedPoints,
-        cornerPoints,
-        transformedCornerPoints,
-        [originData]
-      ]);
-
-      this.canvas.setAttribute("width", w);
-      this.canvas.setAttribute("height", h);
-
-      this._drawShapes(shapePoints, cornerPoints, transformedPoints, transformedCornerPoints)
-      this._drawArrows(shapePoints, transformedPoints);
-      this._drawOrigin(originData[0], originData[1]);
-
-      return true;
-    } else {
-      return false;
-    }
-  }
-};
diff --git a/browser/devtools/shared/widgets/Tooltip.js b/browser/devtools/shared/widgets/Tooltip.js
--- a/browser/devtools/shared/widgets/Tooltip.js
+++ b/browser/devtools/shared/widgets/Tooltip.js
@@ -7,17 +7,16 @@
 const {Cc, Cu, Ci} = require("chrome");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const IOService = Cc["@mozilla.org/network/io-service;1"]
   .getService(Ci.nsIIOService);
 const {Spectrum} = require("devtools/shared/widgets/Spectrum");
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const {colorUtils} = require("devtools/css-color");
 const Heritage = require("sdk/core/heritage");
-const {CSSTransformPreviewer} = require("devtools/shared/widgets/CSSTransformPreviewer");
 const {Eyedropper} = require("devtools/eyedropper/eyedropper");
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "setNamedTimeout",
   "resource:///modules/devtools/ViewHelpers.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "clearNamedTimeout",
@@ -733,55 +732,16 @@ Tooltip.prototype = {
 
     // Put the iframe in the tooltip
     this.content = iframe;
 
     return def.promise;
   },
 
   /**
-   * Set the content of the tooltip to be the result of CSSTransformPreviewer.
-   * Meaning a canvas previewing a css transformation.
-   *
-   * @param {String} transform
-   *        The CSS transform value (e.g. "rotate(45deg) translateX(50px)")
-   * @param {PageStyleActor} pageStyle
-   *        An instance of the PageStyleActor that will be used to retrieve
-   *        computed styles
-   * @param {NodeActor} node
-   *        The NodeActor for the currently selected node
-   * @return A promise that resolves when the tooltip content is ready, or
-   *         rejects if no transform is provided or the transform is invalid
-   */
-  setCssTransformContent: Task.async(function*(transform, pageStyle, node) {
-    if (!transform) {
-      throw "Missing transform";
-    }
-
-    // Look into the computed styles to find the width and height and possibly
-    // the origin if it hadn't been provided
-    let styles = yield pageStyle.getComputed(node, {
-      filter: "user",
-      markMatched: false,
-      onlyMatched: false
-    });
-
-    let origin = styles["transform-origin"].value;
-    let width = parseInt(styles["width"].value);
-    let height = parseInt(styles["height"].value);
-
-    let root = this.doc.createElementNS(XHTML_NS, "div");
-    let previewer = new CSSTransformPreviewer(root);
-    this.content = root;
-    if (!previewer.preview(transform, origin, width, height)) {
-      throw "Invalid transform";
-    }
-  }),
-
-  /**
    * Set the content of the tooltip to display a font family preview.
    * This is based on Lea Verou's Dablet. See https://github.com/LeaVerou/dabblet
    * for more info.
    * @param {String} font The font family value.
    * @param {object} nodeFront
    *        The NodeActor that will used to retrieve the dataURL for the font
    *        family tooltip contents.
    * @return A promise that resolves when the font tooltip content is ready, or
diff --git a/browser/devtools/styleinspector/computed-view.js b/browser/devtools/styleinspector/computed-view.js
--- a/browser/devtools/styleinspector/computed-view.js
+++ b/browser/devtools/styleinspector/computed-view.js
@@ -532,22 +532,16 @@ CssHtmlTree.prototype = {
         return this.tooltip.setRelativeImageContent(uri, inspector.inspector, maxDim);
       }
     }
 
     if (target.classList.contains("property-value")) {
       let propValue = target;
       let propName = target.parentNode.querySelector(".property-name");
 
-      // Test for css transform
-      if (propName.textContent === "transform") {
-        return this.tooltip.setCssTransformContent(propValue.textContent,
-          this.pageStyle, this.viewedElement);
-      }
-
       // Test for font family
       if (propName.textContent === "font-family") {
         let prop = propValue.textContent.toLowerCase();
 
         if (prop !== "inherit" && prop !== "unset" && prop !== "initial") {
           return this.tooltip.setFontFamilyContent(propValue.textContent,
             inspector.selection.nodeFront);
         }
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1139,29 +1139,23 @@ CssRuleView.prototype = {
       doc.documentElement.appendChild(popupset);
     }
 
     popupset.appendChild(this._contextmenu);
   },
 
   /**
    * Which type of hover-tooltip should be shown for the given element?
-   * This depends on the element: does it contain an image URL, a CSS transform,
-   * a font-family, ...
+   * This depends on the element: does it contain a URL, a font-family, ...
    * @param {DOMNode} el The element to test
    * @return {String} The type of hover-tooltip
    */
   _getHoverTooltipTypeForTarget: function(el) {
     let prop = el.textProperty;
 
-    // Test for css transform
-    if (prop && prop.name === "transform") {
-      return "transform";
-    }
-
     // Test for image
     let isUrl = el.classList.contains("theme-link") &&
                 el.parentNode.classList.contains("ruleview-propertyvalue");
     if (this.inspector.hasUrlToImageDataResolver && isUrl) {
       return "image";
     }
 
     // Test for font-family
@@ -1196,20 +1190,16 @@ CssRuleView.prototype = {
       return false;
     }
 
     if (this.colorPicker.tooltip.isShown()) {
       this.colorPicker.revert();
       this.colorPicker.hide();
     }
 
-    if (tooltipType === "transform") {
-      return this.previewTooltip.setCssTransformContent(target.textProperty.value,
-        this.pageStyle, this._viewedElement);
-    }
     if (tooltipType === "image") {
       let prop = target.parentNode.textProperty;
       let dim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");
       let uri = CssLogic.getBackgroundImageUriFromProperty(prop.value, prop.rule.domRule.href);
       return this.previewTooltip.setRelativeImageContent(uri, this.inspector.inspector, dim);
     }
     if (tooltipType === "font") {
       let prop = target.textContent.toLowerCase();
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -89,9 +89,8 @@ skip-if = os == "win" && debug # bug 963
 [browser_styleinspector_csslogic-specificity.js]
 [browser_styleinspector_inplace-editor.js]
 [browser_styleinspector_output-parser.js]
 [browser_styleinspector_tooltip-background-image.js]
 [browser_styleinspector_tooltip-closes-on-new-selection.js]
 [browser_styleinspector_tooltip-longhand-fontfamily.js]
 [browser_styleinspector_tooltip-shorthand-fontfamily.js]
 [browser_styleinspector_tooltip-size.js]
-[browser_styleinspector_tooltip-transform.js]
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-hides-on-tooltip.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-hides-on-tooltip.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-hides-on-tooltip.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-hides-on-tooltip.js
@@ -1,40 +1,37 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test that the color picker tooltip hides when an image or transform
-// tooltip appears
+// Test that the color picker tooltip hides when an image tooltip appears
 
 const PAGE_CONTENT = [
   '<style type="text/css">',
   '  body {',
   '    color: red;',
   '    background-color: #ededed;',
   '    background-image: url(chrome://global/skin/icons/warning-64.png);',
   '    border: 2em solid rgba(120, 120, 120, .5);',
-  '    transform: skew(-16deg);',
   '  }',
   '</style>',
   'Testing the color picker tooltip!'
 ].join("\n");
 
 let test = asyncTest(function*() {
   yield addTab("data:text/html,rule view color picker tooltip test");
   content.document.body.innerHTML = PAGE_CONTENT;
   let {toolbox, inspector, view} = yield openRuleView();
 
   let swatch = getRuleViewProperty(view, "body", "color").valueSpan
     .querySelector(".ruleview-colorswatch");
 
   yield testColorPickerHidesWhenImageTooltipAppears(view, swatch);
-  yield testColorPickerHidesWhenTransformTooltipAppears(view, swatch);
 });
 
 function* testColorPickerHidesWhenImageTooltipAppears(view, swatch) {
   let bgImageSpan = getRuleViewProperty(view, "body", "background-image").valueSpan;
   let uriSpan = bgImageSpan.querySelector(".theme-link");
   let tooltip = view.colorPicker.tooltip;
 
   info("Showing the color picker tooltip by clicking on the color swatch");
@@ -44,25 +41,8 @@ function* testColorPickerHidesWhenImageT
 
   info("Now showing the image preview tooltip to hide the color picker");
   let onHidden = tooltip.once("hidden");
   yield assertHoverTooltipOn(view.previewTooltip, uriSpan);
   yield onHidden;
 
   ok(true, "The color picker closed when the image preview tooltip appeared");
 }
-
-function* testColorPickerHidesWhenTransformTooltipAppears(view, swatch) {
-  let transformSpan = getRuleViewProperty(view, "body", "transform").valueSpan;
-  let tooltip = view.colorPicker.tooltip;
-
-  info("Showing the color picker tooltip by clicking on the color swatch");
-  let onShown = tooltip.once("shown");
-  swatch.click();
-  yield onShown;
-
-  info("Now showing the transform preview tooltip to hide the color picker");
-  let onHidden = tooltip.once("hidden");
-  yield assertHoverTooltipOn(view.previewTooltip, transformSpan);
-  yield onHidden;
-
-  ok(true, "The color picker closed when the transform preview tooltip appeared");
-}
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-size.js b/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-size.js
--- a/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-size.js
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-size.js
@@ -7,65 +7,32 @@
 // Checking tooltips dimensions, to make sure their big enough to display their
 // content
 
 const TEST_PAGE = [
   'data:text/html;charset=utf-8,',
   '<style type="text/css">',
   '  div {',
   '    width: 300px;height: 300px;border-radius: 50%;',
-  '    transform: skew(45deg);',
   '    background: red url(chrome://global/skin/icons/warning-64.png);',
   '  }',
   '</style>',
   '<div></div>'
 ].join("\n");
 
 let test = asyncTest(function*() {
   yield addTab(TEST_PAGE);
   let {toolbox, inspector, view} = yield openRuleView();
 
   yield selectNode("div", inspector);
 
-  yield testTransformDimension(view);
   yield testImageDimension(view);
   yield testPickerDimension(view);
 });
 
-function* testTransformDimension(ruleView) {
-  info("Testing css transform tooltip dimensions");
-
-  let tooltip = ruleView.previewTooltip;
-  let panel = tooltip.panel;
-  let {valueSpan} = getRuleViewProperty(ruleView, "div", "transform");
-
-  // Make sure there is a hover tooltip for this property, this also will fill
-  // the tooltip with its content
-  yield assertHoverTooltipOn(tooltip, valueSpan);
-
-  info("Showing the tooltip");
-  let onShown = tooltip.once("shown");
-  tooltip.show();
-  yield onShown;
-
-  // Let's not test for a specific size, but instead let's make sure it's at
-  // least as big as the preview canvas
-  let canvas = panel.querySelector("canvas");
-  let w = canvas.width;
-  let h = canvas.height;
-  let panelRect = panel.getBoundingClientRect();
-
-  ok(panelRect.width >= w, "The panel is wide enough to show the canvas");
-  ok(panelRect.height >= h, "The panel is high enough to show the canvas");
-
-  let onHidden = tooltip.once("hidden");
-  tooltip.hide();
-  yield onHidden;
-}
-
 function* testImageDimension(ruleView) {
   info("Testing background-image tooltip dimensions");
 
   let tooltip = ruleView.previewTooltip;
   let panel = tooltip.panel;
   let {valueSpan} = getRuleViewProperty(ruleView, "div", "background");
   let uriSpan = valueSpan.querySelector(".theme-link");
 
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-transform.js b/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-transform.js
deleted file mode 100644
--- a/browser/devtools/styleinspector/test/browser_styleinspector_tooltip-transform.js
+++ /dev/null
@@ -1,87 +0,0 @@
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
- http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-// Test that the css transform preview tooltip is shown on transform properties
-
-const PAGE_CONTENT = [
-  '<style type="text/css">',
-  '  #testElement {',
-  '    width: 500px;',
-  '    height: 300px;',
-  '    background: red;',
-  '    transform: skew(16deg);',
-  '  }',
-  '  .test-element {',
-  '    transform-origin: top left;',
-  '    transform: rotate(45deg);',
-  '  }',
-  '  div {',
-  '    transform: scaleX(1.5);',
-  '    transform-origin: bottom right;',
-  '  }',
-  '  [attr] {',
-  '  }',
-  '</style>',
-  '<div id="testElement" class="test-element" attr="value">transformed element</div>'
-].join("\n");
-
-let test = asyncTest(function*() {
-  yield addTab("data:text/html,rule view css transform tooltip test");
-  content.document.body.innerHTML = PAGE_CONTENT;
-  let {toolbox, inspector, view} = yield openRuleView();
-
-  info("Selecting the test node");
-  yield selectNode("#testElement", inspector);
-
-  info("Checking that transforms tooltips are shown in various rule-view properties");
-  for (let selector of [".test-element", "div", "#testElement"]) {
-    yield testTransformTooltipOnSelector(view, selector);
-  }
-
-  info("Checking that the transform tooltip doesn't appear for invalid transforms");
-  yield testTransformTooltipNotShownOnInvalidTransform(view);
-
-  info("Checking transforms in the computed-view");
-  let {view} = yield openComputedView();
-  yield testTransformTooltipOnComputedView(view);
-});
-
-function* testTransformTooltipOnSelector(view, selector) {
-  info("Testing that a transform tooltip appears on transform in " + selector);
-
-  let {valueSpan} = getRuleViewProperty(view, selector, "transform");
-  ok(valueSpan, "The transform property was found");
-  yield assertHoverTooltipOn(view.previewTooltip, valueSpan);
-
-  // The transform preview is canvas, so there's not much we can test, so for
-  // now, let's just be happy with the fact that the tooltips is shown!
-  ok(true, "Tooltip shown on the transform property in " + selector);
-}
-
-function* testTransformTooltipNotShownOnInvalidTransform(view) {
-  let ruleEditor;
-  for (let rule of view._elementStyle.rules) {
-    if (rule.matchedSelectors[0] === "[attr]") {
-      ruleEditor = rule.editor;
-    }
-  }
-  ruleEditor.addProperty("transform", "muchTransform(suchAngle)", "");
-
-  let {valueSpan} = getRuleViewProperty(view, "[attr]", "transform");
-  let isValid = yield isHoverTooltipTarget(view.previewTooltip, valueSpan);
-  ok(!isValid, "The tooltip did not appear on hover of an invalid transform value");
-}
-
-function* testTransformTooltipOnComputedView(view) {
-  info("Testing that a transform tooltip appears in the computed view too");
-
-  let {valueSpan} = getComputedViewProperty(view, "transform");
-  yield assertHoverTooltipOn(view.tooltip, valueSpan);
-
-  // The transform preview is canvas, so there's not much we can test, so for
-  // now, let's just be happy with the fact that the tooltips is shown!
-  ok(true, "Tooltip shown on the computed transform property");
-}
