# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1541884457 28800
#      Sat Nov 10 13:14:17 2018 -0800
# Node ID 49a504f073f6530b43b19a2ab258806f8c0b7b79
# Parent  2f1158e5e0ce2523f93482abf6158db058a782a1
Bug 1503342 - Rename richlistbox.children to richlistbox.itemChildren so .children will refer to the normal DOM API;r=paolo

In Bug 1479125 we put calls to .children that were intended to access child elements into the custom
method, which is a slower path. We may eventually want to remove itemChildren altogether and just assume
that all children are items, but that's out of scope for a perf fix like this.

Differential Revision: https://phabricator.services.mozilla.com/D10751

diff --git a/browser/base/content/test/urlbar/browser_autocomplete_a11y_label.js b/browser/base/content/test/urlbar/browser_autocomplete_a11y_label.js
--- a/browser/base/content/test/urlbar/browser_autocomplete_a11y_label.js
+++ b/browser/base/content/test/urlbar/browser_autocomplete_a11y_label.js
@@ -31,26 +31,26 @@ add_task(async function searchSuggestion
     Services.prefs.clearUserPref(SUGGEST_ALL_PREF);
     Services.prefs.setBoolPref(SUGGEST_URLBAR_PREF, suggestionsEnabled);
   });
 
   await promiseAutocompleteResultPopup("foo");
   await waitForAutocompleteResultAt(2);
   // Don't assume that the search doesn't match history or bookmarks left around
   // by earlier tests.
-  Assert.ok(gURLBar.popup.richlistbox.children.length >= 3,
+  Assert.ok(gURLBar.popup.richlistbox.itemChildren.length >= 3,
             "Should get at least heuristic result + two search suggestions");
   // The first expected search is the search term itself since the heuristic
   // result will come before the search suggestions.
   let expectedSearches = [
     "foo",
     "foofoo",
     "foobar",
   ];
-  for (let child of gURLBar.popup.richlistbox.children) {
+  for (let child of gURLBar.popup.richlistbox.itemChildren) {
     if (child.getAttribute("type").split(/\s+/).includes("searchengine")) {
       Assert.ok(expectedSearches.length > 0);
       let suggestion = expectedSearches.shift();
       Assert.equal(child.label, suggestion + " browser_searchSuggestionEngine searchSuggestionEngine.xml Search",
                    "Result label should be: <search term> <engine name> Search");
     }
   }
   Assert.ok(expectedSearches.length == 0);
diff --git a/browser/base/content/test/urlbar/browser_autocomplete_autoselect.js b/browser/base/content/test/urlbar/browser_autocomplete_autoselect.js
--- a/browser/base/content/test/urlbar/browser_autocomplete_autoselect.js
+++ b/browser/base/content/test/urlbar/browser_autocomplete_autoselect.js
@@ -45,17 +45,17 @@ add_task(async function() {
     });
   });
   await PlacesTestUtils.addVisits(visits);
 
   await promiseAutocompleteResultPopup("example.com/autocomplete");
   await waitForAutocompleteResultAt(maxResults - 1);
 
   let popup = gURLBar.popup;
-  let results = popup.richlistbox.children;
+  let results = popup.richlistbox.itemChildren;
   is(results.length, maxResults,
      "Should get maxResults=" + maxResults + " results");
   is_selected(0);
 
   info("Key Down to select the next item");
   EventUtils.synthesizeKey("KEY_ArrowDown");
   is_selected(1);
 
diff --git a/browser/base/content/test/urlbar/browser_urlbarEnterAfterMouseOver.js b/browser/base/content/test/urlbar/browser_urlbarEnterAfterMouseOver.js
--- a/browser/base/content/test/urlbar/browser_urlbarEnterAfterMouseOver.js
+++ b/browser/base/content/test/urlbar/browser_urlbarEnterAfterMouseOver.js
@@ -33,17 +33,17 @@ add_task(async function() {
     });
   });
   await PlacesTestUtils.addVisits(visits);
 
   gBrowser.selectedTab = BrowserTestUtils.addTab(gBrowser, "about:blank");
   await promiseAutoComplete("http://example.com/autocomplete/");
 
   let popup = gURLBar.popup;
-  let results = popup.richlistbox.children;
+  let results = popup.richlistbox.itemChildren;
   is(results.length, gMaxResults,
      "Should get gMaxResults=" + gMaxResults + " results");
 
   let initiallySelected = gURLBar.popup.richlistbox.selectedIndex;
 
   info("Key Down to select the next item");
   EventUtils.synthesizeKey("KEY_ArrowDown");
   is_selected(initiallySelected + 1);
diff --git a/browser/base/content/test/urlbar/browser_urlbarOneOffs_searchSuggestions.js b/browser/base/content/test/urlbar/browser_urlbarOneOffs_searchSuggestions.js
--- a/browser/base/content/test/urlbar/browser_urlbarOneOffs_searchSuggestions.js
+++ b/browser/base/content/test/urlbar/browser_urlbarOneOffs_searchSuggestions.js
@@ -90,22 +90,22 @@ add_task(async function overridden_engin
     // Down to select the first search suggestion.
     EventUtils.synthesizeKey("KEY_ArrowDown");
     assertState(1, -1, "foofoo");
     // ALT+Down to select the second search engine.
     EventUtils.synthesizeKey("KEY_ArrowDown", {altKey: true});
     EventUtils.synthesizeKey("KEY_ArrowDown", {altKey: true});
     assertState(1, 1, "foofoo");
 
-    let label = gURLBar.popup.richlistbox.children[gURLBar.popup.richlistbox.selectedIndex].label;
+    let label = gURLBar.popup.richlistbox.itemChildren[gURLBar.popup.richlistbox.selectedIndex].label;
     // Run again the query, check the label has been replaced.
     await promiseAutocompleteResultPopup(typedValue, window, true);
     await promiseSuggestionsPresent();
     assertState(0, -1, "foo");
-    let newLabel = gURLBar.popup.richlistbox.children[1].label;
+    let newLabel = gURLBar.popup.richlistbox.itemChildren[1].label;
     Assert.notEqual(newLabel, label, "The label should have been updated");
 
     BrowserTestUtils.removeTab(tab);
 });
 
 function assertState(result, oneOff, textValue = undefined) {
   Assert.equal(gURLBar.popup.selectedIndex, result,
                "Expected result should be selected");
diff --git a/browser/base/content/test/urlbar/browser_urlbarStopSearchOnSelection.js b/browser/base/content/test/urlbar/browser_urlbarStopSearchOnSelection.js
--- a/browser/base/content/test/urlbar/browser_urlbarStopSearchOnSelection.js
+++ b/browser/base/content/test/urlbar/browser_urlbarStopSearchOnSelection.js
@@ -61,28 +61,28 @@ add_task(async function mainTest() {
   // typing the "x" character.  Wait a bit to make sure it really stopped.
   await new Promise(r => setTimeout(r, 2 * TEST_ENGINE_SUGGESTIONS_TIMEOUT));
 
   // Both of the suggestion results should retain their initial values,
   // "testfoo" and "testbar".  They should *not* be "testxfoo" and "textxbar".
 
   // + 1 for the heuristic result
   let numExpectedResults = TEST_ENGINE_NUM_EXPECTED_RESULTS + 1;
-  let results = gURLBar.popup.richlistbox.children;
+  let results = gURLBar.popup.richlistbox.itemChildren;
   let numActualResults = Array.reduce(results, (memo, result) => {
     if (!result.collapsed) {
       memo++;
     }
     return memo;
   }, 0);
   Assert.equal(numActualResults, numExpectedResults);
 
   let expectedSuggestions = ["testfoo", "testbar"];
   for (let i = 0; i < TEST_ENGINE_NUM_EXPECTED_RESULTS; i++) {
     // + 1 to skip the heuristic result
-    let item = gURLBar.popup.richlistbox.children[i + 1];
+    let item = gURLBar.popup.richlistbox.itemChildren[i + 1];
     let action = item._parseActionUrl(item.getAttribute("url"));
     Assert.ok(action);
     Assert.equal(action.type, "searchengine");
     Assert.ok("searchSuggestion" in action.params);
     Assert.equal(action.params.searchSuggestion, expectedSuggestions[i]);
   }
 });
diff --git a/browser/base/content/test/urlbar/browser_urlbar_autoFill_backspaced.js b/browser/base/content/test/urlbar/browser_urlbar_autoFill_backspaced.js
--- a/browser/base/content/test/urlbar/browser_urlbar_autoFill_backspaced.js
+++ b/browser/base/content/test/urlbar/browser_urlbar_autoFill_backspaced.js
@@ -12,18 +12,18 @@ async function test_autocomplete(data) {
     onAutoFill();
 
   keys.forEach(key => EventUtils.synthesizeKey(key));
 
   is(gURLBar.textValue, modified, "backspaced value is as expected");
 
   await promiseSearchComplete();
 
-  ok(gURLBar.popup.richlistbox.children.length > 0, "Should get at least 1 result");
-  let result = gURLBar.popup.richlistbox.children[0];
+  ok(gURLBar.popup.richlistbox.itemChildren.length > 0, "Should get at least 1 result");
+  let result = gURLBar.popup.richlistbox.itemChildren[0];
   let type = result.getAttribute("type");
   let types = type.split(/\s+/);
   ok(types.includes(action), `The type attribute "${type}" includes the expected action "${action}"`);
 
   gURLBar.popup.hidePopup();
   await promisePopupHidden(gURLBar.popup);
   gURLBar.blur();
 }
diff --git a/browser/base/content/test/urlbar/browser_urlbar_remove_match.js b/browser/base/content/test/urlbar/browser_urlbar_remove_match.js
--- a/browser/base/content/test/urlbar/browser_urlbar_remove_match.js
+++ b/browser/base/content/test/urlbar/browser_urlbar_remove_match.js
@@ -18,14 +18,14 @@ add_task(async function test_remove_hist
   Assert.equal(result.getAttribute("ac-value"), TEST_URL, "Found the expected result");
 
   EventUtils.synthesizeKey("KEY_ArrowDown");
   Assert.equal(gURLBar.popup.richlistbox.selectedIndex, 1);
   let options = AppConstants.platform == "macosx" ? { shiftKey: true } : {};
   EventUtils.synthesizeKey("KEY_Delete", options);
   await promiseVisitRemoved;
   await BrowserTestUtils.waitForCondition(
-    () => !gURLBar.popup.richlistbox.children.some(c => !c.collapsed && c.getAttribute("ac-value") == TEST_URL),
+    () => !gURLBar.popup.richlistbox.itemChildren.some(c => !c.collapsed && c.getAttribute("ac-value") == TEST_URL),
     "Waiting for the result to disappear");
 
   gURLBar.popup.hidePopup();
   await promisePopupHidden(gURLBar.popup);
 });
diff --git a/browser/base/content/test/urlbar/head.js b/browser/base/content/test/urlbar/head.js
--- a/browser/base/content/test/urlbar/head.js
+++ b/browser/base/content/test/urlbar/head.js
@@ -299,22 +299,22 @@ function promiseSpeculativeConnection(ht
     }
     return false;
   }, "Waiting for connection setup");
 }
 
 async function waitForAutocompleteResultAt(index) {
   let searchString = gURLBar.controller.searchString;
   await BrowserTestUtils.waitForCondition(
-    () => gURLBar.popup.richlistbox.children.length > index &&
-          gURLBar.popup.richlistbox.children[index].getAttribute("ac-text") == searchString.trim(),
+    () => gURLBar.popup.richlistbox.itemChildren.length > index &&
+          gURLBar.popup.richlistbox.itemChildren[index].getAttribute("ac-text") == searchString.trim(),
     `Waiting for the autocomplete result for "${searchString}" at [${index}] to appear`);
   // Ensure the addition is complete, for proper mouse events on the entries.
   await new Promise(resolve => window.requestIdleCallback(resolve, {timeout: 1000}));
-  return gURLBar.popup.richlistbox.children[index];
+  return gURLBar.popup.richlistbox.itemChildren[index];
 }
 
 function promiseSuggestionsPresent(msg = "") {
   return TestUtils.waitForCondition(suggestionsPresent,
                                     msg || "Waiting for suggestions");
 }
 
 function suggestionsPresent() {
diff --git a/browser/base/content/test/webextensions/browser_extension_sideloading.js b/browser/base/content/test/webextensions/browser_extension_sideloading.js
--- a/browser/base/content/test/webextensions/browser_extension_sideloading.js
+++ b/browser/base/content/test/webextensions/browser_extension_sideloading.js
@@ -207,17 +207,17 @@ add_task(async function() {
 
   win = await BrowserOpenAddonsMgr(VIEW);
 
   let list = win.document.getElementById("addon-list");
 
   // Make sure XBL bindings are applied
   list.clientHeight;
 
-  let item = list.children.find(_item => _item.value == ID3);
+  let item = list.itemChildren.find(_item => _item.value == ID3);
   ok(item, "Found entry for sideloaded extension in about:addons");
   item.scrollIntoView({behavior: "instant"});
 
   ok(BrowserTestUtils.is_visible(item._enableBtn), "Enable button is visible for sideloaded extension");
   ok(BrowserTestUtils.is_hidden(item._disableBtn), "Disable button is not visible for sideloaded extension");
 
   // When clicking enable we should see the permissions notification
   popupPromise = promisePopupNotificationShown("addon-webext-permissions");
diff --git a/browser/base/content/test/webextensions/head.js b/browser/base/content/test/webextensions/head.js
--- a/browser/base/content/test/webextensions/head.js
+++ b/browser/base/content/test/webextensions/head.js
@@ -418,17 +418,17 @@ async function interactiveUpdateTest(aut
     if (manualUpdatePromise) {
       await manualUpdatePromise;
 
       let list = win.document.getElementById("addon-list");
 
       // Make sure we have XBL bindings
       list.clientHeight;
 
-      let item = list.children.find(_item => _item.value == ID);
+      let item = list.itemChildren.find(_item => _item.value == ID);
       EventUtils.synthesizeMouseAtCenter(item._updateBtn, {}, win);
     }
 
     return {promise};
   }
 
   // Navigate away from the starting page to force about:addons to load
   // in a new tab during the tests below.
diff --git a/browser/components/downloads/test/browser/browser_basic_functionality.js b/browser/components/downloads/test/browser/browser_basic_functionality.js
--- a/browser/components/downloads/test/browser/browser_basic_functionality.js
+++ b/browser/components/downloads/test/browser/browser_basic_functionality.js
@@ -38,19 +38,19 @@ add_task(async function test_basic_funct
   await task_addDownloads(DownloadData);
 
   // Open the user interface and wait for data to be fully loaded.
   await task_openPanel();
 
   // Test item data and count.  This also tests the ordering of the display.
   let richlistbox = document.getElementById("downloadsListBox");
   /* disabled for failing intermittently (bug 767828)
-    is(richlistbox.children.length, DownloadData.length,
+    is(richlistbox.itemChildren.length, DownloadData.length,
        "There is the correct number of richlistitems");
   */
-  let itemCount = richlistbox.children.length;
+  let itemCount = richlistbox.itemChildren.length;
   for (let i = 0; i < itemCount; i++) {
-    let element = richlistbox.children[itemCount - i - 1];
+    let element = richlistbox.itemChildren[itemCount - i - 1];
     let download = DownloadsView.itemForElement(element).download;
     is(DownloadsCommon.stateOfDownload(download), DownloadData[i].state,
        "Download states match up");
   }
 });
diff --git a/browser/components/downloads/test/browser/browser_library_clearall.js b/browser/components/downloads/test/browser/browser_library_clearall.js
--- a/browser/components/downloads/test/browser/browser_library_clearall.js
+++ b/browser/components/downloads/test/browser/browser_library_clearall.js
@@ -83,22 +83,22 @@ add_task(async function test_clear_downl
   await testClearingDownloads(async () => {
     win.document.getElementById("clearDownloadsButton").click();
   });
 });
 
 add_task(async function test_clear_downloads_context_menu() {
   await testClearingDownloads(async listbox => {
     // Select one of the downloads.
-    listbox.children[0].click();
+    listbox.itemChildren[0].click();
 
     let contextMenu = win.document.getElementById("downloadsContextMenu");
 
     let popupShownPromise = BrowserTestUtils.waitForEvent(contextMenu, "popupshown");
-    EventUtils.synthesizeMouseAtCenter(listbox.children[0], {type: "contextmenu", button: 2}, win);
+    EventUtils.synthesizeMouseAtCenter(listbox.itemChildren[0], {type: "contextmenu", button: 2}, win);
     await popupShownPromise;
 
     // Find the clear context item.
     let clearDownloadsButton =
       [...contextMenu.children].find(child => child.command == "downloadsCmd_clearDownloads");
     clearDownloadsButton.click();
   });
 });
diff --git a/browser/components/extensions/test/browser/browser_ext_omnibox.js b/browser/components/extensions/test/browser/browser_ext_omnibox.js
--- a/browser/components/extensions/test/browser/browser_ext_omnibox.js
+++ b/browser/components/extensions/test/browser/browser_ext_omnibox.js
@@ -79,22 +79,22 @@ add_task(async function() {
       is(actual.disposition, expected.disposition,
          `Expected "${event}" to have fired with disposition: "${expected.disposition}".`);
     }
   }
 
   async function waitForAutocompleteResultAt(index) {
     let searchString = gURLBar.controller.searchString;
     await BrowserTestUtils.waitForCondition(
-      () => gURLBar.popup.richlistbox.children.length > index &&
-            gURLBar.popup.richlistbox.children[index].getAttribute("ac-text") == searchString,
+      () => gURLBar.popup.richlistbox.itemChildren.length > index &&
+            gURLBar.popup.richlistbox.itemChildren[index].getAttribute("ac-text") == searchString,
       `Waiting for the autocomplete result for "${searchString}" at [${index}] to appear`);
     // Ensure the addition is complete, for proper mouse events on the entries.
     await new Promise(resolve => window.requestIdleCallback(resolve, {timeout: 1000}));
-    return gURLBar.popup.richlistbox.children[index];
+    return gURLBar.popup.richlistbox.itemChildren[index];
   }
 
   async function promiseClickOnItem(item, details) {
     // The Address Bar panel is animated and updated on a timer, thus it may not
     // yet be listening to events when we try to click on it.  This uses a
     // polling strategy to repeat the click, if it doesn't go through.
     let clicked = false;
     item.addEventListener("mousedown", () => { clicked = true; }, {once: true});
@@ -184,17 +184,17 @@ add_task(async function() {
         },
       });
       await extension.awaitMessage("default-suggestion-set");
     }
 
     let text = await startInputSession();
     await waitForAutocompleteResultAt(0);
 
-    let item = gURLBar.popup.richlistbox.children[0];
+    let item = gURLBar.popup.richlistbox.itemChildren[0];
 
     is(item.getAttribute("title"), expectedText,
        `Expected heuristic result to have title: "${expectedText}".`);
 
     is(item.getAttribute("displayurl"), `${keyword} ${text}`,
        `Expected heuristic result to have displayurl: "${keyword} ${text}".`);
 
     let promiseEvent = expectEvent("on-input-entered-fired", {
@@ -212,33 +212,33 @@ add_task(async function() {
     // Select the suggestion.
     EventUtils.synthesizeKey("KEY_ArrowDown", {repeat: suggestionIndex});
 
     let promiseEvent = expectEvent("on-input-entered-fired", {
       text: expectedText,
       disposition: expectedDisposition,
     });
 
-    let item = gURLBar.popup.richlistbox.children[suggestionIndex];
+    let item = gURLBar.popup.richlistbox.itemChildren[suggestionIndex];
     if (expectedDisposition == "currentTab") {
       await promiseClickOnItem(item, {});
     } else if (expectedDisposition == "newForegroundTab") {
       await promiseClickOnItem(item, {accelKey: true});
     } else if (expectedDisposition == "newBackgroundTab") {
       await promiseClickOnItem(item, {shiftKey: true, accelKey: true});
     }
     await promiseEvent;
   }
 
   async function testSuggestions(info) {
     extension.sendMessage("set-synchronous", {synchronous: false});
     await extension.awaitMessage("set-synchronous-set");
 
     function expectSuggestion({content, description}, index) {
-      let item = gURLBar.popup.richlistbox.children[index + 1]; // Skip the heuristic result.
+      let item = gURLBar.popup.richlistbox.itemChildren[index + 1]; // Skip the heuristic result.
 
       ok(!!item, "Expected item to exist");
       is(item.getAttribute("title"), description,
          `Expected suggestion to have title: "${description}".`);
 
       is(item.getAttribute("displayurl"), `${keyword} ${content}`,
          `Expected suggestion to have displayurl: "${keyword} ${content}".`);
     }
@@ -253,17 +253,17 @@ add_task(async function() {
 
     await waitForAutocompleteResultAt(info.suggestions.length - 1);
     info.suggestions.forEach(expectSuggestion);
 
     let promiseEvent = expectEvent("on-input-entered-fired", {
       text,
       disposition: "currentTab",
     });
-    await promiseClickOnItem(gURLBar.popup.richlistbox.children[0], {});
+    await promiseClickOnItem(gURLBar.popup.richlistbox.itemChildren[0], {});
     await promiseEvent;
   }
 
   await extension.startup();
 
   await SimpleTest.promiseFocus(window);
 
   await testInputEvents();
diff --git a/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js b/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
--- a/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
+++ b/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
@@ -103,29 +103,29 @@ add_task(async function() {
 
   // Doing this backwords tests more interesting paths.
   for (let i = tags.length - 1; i >= 0 ; i -= 2) {
     tagsSelector.selectedIndex = i;
     let listItem = tagsSelector.selectedItem;
     isnot(listItem, null, "Valid listItem found");
 
     tagsSelector.ensureElementIsVisible(listItem);
-    let items = [...tagsSelector.children];
+    let items = [...tagsSelector.itemChildren];
     let topTag = items.find(e => scrolledIntoView(e, tagsSelector)).label;
 
     ok(listItem.hasAttribute("checked"), "Item is checked " + i);
 
     // Uncheck the tag.
     let promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                                 "BookmarkTagsSelectorUpdated");
     EventUtils.synthesizeMouseAtCenter(listItem.firstElementChild, {});
     await promise;
 
     // The listbox is rebuilt, so we have to get the new element.
-    let topItem = [...tagsSelector.children].find(e => e.label == topTag);
+    let topItem = [...tagsSelector.itemChildren].find(e => e.label == topTag);
     ok(scrolledIntoView(topItem, tagsSelector), "Scroll position is correct");
 
     let newItem = tagsSelector.selectedItem;
     isnot(newItem, null, "Valid new listItem found");
     ok(newItem.hasAttribute("checked"), "New listItem is checked " + i);
     is(tagsSelector.selectedItem.label,
        tags[Math.min(i + 1, tags.length - 2)],
        "The next tag is now selected");
diff --git a/browser/components/places/tests/browser/browser_library_downloads.js b/browser/components/places/tests/browser/browser_library_downloads.js
--- a/browser/components/places/tests/browser/browser_library_downloads.js
+++ b/browser/components/places/tests/browser/browser_library_downloads.js
@@ -36,16 +36,16 @@ add_task(async function test() {
   // Make sure Downloads is present.
   Assert.notEqual(library.PlacesOrganizer._places.selectedNode, null,
     "Downloads is present and selected");
 
   // Check results.
   let testURIs = ["http://ubuntu.org/", "http://google.com/"];
 
   await BrowserTestUtils.waitForCondition(() =>
-    library.ContentArea.currentView.associatedElement.children.length == testURIs.length);
+    library.ContentArea.currentView.associatedElement.itemChildren.length == testURIs.length);
 
   for (let element of library.ContentArea.currentView
-                                          .associatedElement.children) {
+                                          .associatedElement.itemChildren) {
     Assert.equal(element._shell.download.source.url, testURIs.shift(),
       "URI matches");
   }
 });
diff --git a/browser/components/preferences/in-content/tests/browser_search_within_preferences_1.js b/browser/components/preferences/in-content/tests/browser_search_within_preferences_1.js
--- a/browser/components/preferences/in-content/tests/browser_search_within_preferences_1.js
+++ b/browser/components/preferences/in-content/tests/browser_search_within_preferences_1.js
@@ -33,31 +33,31 @@ add_task(async function show_search_resu
   let searchCompletedPromise = BrowserTestUtils.waitForEvent(
     gBrowser.contentWindow, "PreferencesSearchCompleted", evt => evt.detail == query);
   EventUtils.sendString(query);
   await searchCompletedPromise;
 
   let categoriesList = gBrowser.contentDocument.getElementById("categories");
 
   for (let i = 0; i < categoriesList.childElementCount; i++) {
-    let child = categoriesList.children[i];
+    let child = categoriesList.itemChildren[i];
     is(child.selected, false, "No other panel should be selected");
   }
   // Takes search off
   searchCompletedPromise = BrowserTestUtils.waitForEvent(
     gBrowser.contentWindow, "PreferencesSearchCompleted", evt => evt.detail == "");
   let count = query.length;
   while (count--) {
     EventUtils.sendKey("BACK_SPACE");
   }
   await searchCompletedPromise;
 
   // Checks if back to generalPane
   for (let i = 0; i < categoriesList.childElementCount; i++) {
-    let child = categoriesList.children[i];
+    let child = categoriesList.itemChildren[i];
     if (child.id == "category-general") {
       is(child.selected, true, "General panel should be selected");
     } else if (child.id) {
       is(child.selected, false, "No other panel should be selected");
     }
   }
 
   BrowserTestUtils.removeTab(gBrowser.selectedTab);
@@ -228,17 +228,17 @@ add_task(async function changing_tabs_af
   EventUtils.sendString(query);
   await searchCompletedPromise;
 
   let privacyCategory = gBrowser.contentDocument.getElementById("category-privacy");
   privacyCategory.click();
   is(searchInput.value, "", "search input should be empty");
   let categoriesList = gBrowser.contentDocument.getElementById("categories");
   for (let i = 0; i < categoriesList.childElementCount; i++) {
-    let child = categoriesList.children[i];
+    let child = categoriesList.itemChildren[i];
     if (child.id == "category-privacy") {
       is(child.selected, true, "Privacy panel should be selected");
     } else if (child.id) {
       is(child.selected, false, "No other panel should be selected");
     }
   }
 
   BrowserTestUtils.removeTab(gBrowser.selectedTab);
diff --git a/browser/components/search/test/browser_426329.js b/browser/components/search/test/browser_426329.js
--- a/browser/components/search/test/browser_426329.js
+++ b/browser/components/search/test/browser_426329.js
@@ -28,17 +28,17 @@ function checkMenuEntries(expectedValues
   is(actualValues.length, expectedValues.length, "Checking length of expected menu");
   for (var i = 0; i < expectedValues.length; i++)
     is(actualValues[i], expectedValues[i], "Checking menu entry #" + i);
 }
 
 function getMenuEntries() {
   // Could perhaps pull values directly from the controller, but it seems
   // more reliable to test the values that are actually in the richlistbox?
-  return Array.map(searchBar.textbox.popup.richlistbox.children,
+  return Array.map(searchBar.textbox.popup.richlistbox.itemChildren,
                    item => item.getAttribute("ac-value"));
 }
 
 function countEntries(name, value) {
   return new Promise(resolve => {
     let count = 0;
     let obj = name && value ? {fieldname: name, value} : {};
     FormHistory.count(obj,
diff --git a/browser/components/search/test/browser_private_search_perwindowpb.js b/browser/components/search/test/browser_private_search_perwindowpb.js
--- a/browser/components/search/test/browser_private_search_perwindowpb.js
+++ b/browser/components/search/test/browser_private_search_perwindowpb.js
@@ -63,11 +63,11 @@ add_task(async function() {
   windowsToClose.forEach(function(win) {
     win.close();
   });
 });
 
 function getMenuEntries(searchBar) {
   // Could perhaps pull values directly from the controller, but it seems
   // more reliable to test the values that are actually in the richlistbox?
-  return Array.map(searchBar.textbox.popup.richlistbox.children,
+  return Array.map(searchBar.textbox.popup.richlistbox.itemChildren,
                    item => item.getAttribute("ac-value"));
 }
diff --git a/toolkit/components/extensions/test/browser/browser_ext_themes_autocomplete_popup.js b/toolkit/components/extensions/test/browser/browser_ext_themes_autocomplete_popup.js
--- a/toolkit/components/extensions/test/browser/browser_ext_themes_autocomplete_popup.js
+++ b/toolkit/components/extensions/test/browser/browser_ext_themes_autocomplete_popup.js
@@ -42,22 +42,22 @@ async function promiseAutocompleteResult
     return gURLBar.controller.searchStatus >=
       Ci.nsIAutoCompleteController.STATUS_COMPLETE_NO_MATCH;
   });
 }
 
 async function waitForAutocompleteResultAt(index) {
   let searchString = gURLBar.controller.searchString;
   await BrowserTestUtils.waitForCondition(
-    () => gURLBar.popup.richlistbox.children.length > index &&
-          gURLBar.popup.richlistbox.children[index].getAttribute("ac-text") == searchString,
+    () => gURLBar.popup.richlistbox.itemChildren.length > index &&
+          gURLBar.popup.richlistbox.itemChildren[index].getAttribute("ac-text") == searchString,
     `Waiting for the autocomplete result for "${searchString}" at [${index}] to appear`);
   // Ensure the addition is complete, for proper mouse events on the entries.
   await new Promise(resolve => window.requestIdleCallback(resolve, {timeout: 1000}));
-  return gURLBar.popup.richlistbox.children[index];
+  return gURLBar.popup.richlistbox.itemChildren[index];
 }
 
 add_task(async function setup() {
   await PlacesUtils.history.clear();
   const NUM_VISITS = 10;
   let visits = [];
 
   for (let i = 0; i < NUM_VISITS; ++i) {
@@ -115,17 +115,17 @@ add_task(async function test_popup_url()
     visits.push({uri: makeURI("http://example.com/autocomplete/?" + i)});
   }
 
   await PlacesTestUtils.addVisits(visits);
   await promiseAutocompleteResultPopup("example.com/autocomplete");
   await waitForAutocompleteResultAt(maxResults - 1);
 
   let popup = gURLBar.popup;
-  let results = popup.richlistbox.children;
+  let results = popup.richlistbox.itemChildren;
   is(results.length, maxResults,
      "Should get maxResults=" + maxResults + " results");
 
   let popupCS = window.getComputedStyle(popup);
 
   Assert.equal(popupCS.backgroundColor,
                `rgb(${hexToRGB(POPUP_COLOR).join(", ")})`,
                `Popup background color should be set to ${POPUP_COLOR}`);
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -188,41 +188,41 @@
             this.selectItem(kids[0]);
           return val;
         ]]>
         </setter>
       </property>
 
       <!-- nsIDOMXULSelectControlElement -->
       <property name="itemCount" readonly="true"
-                onget="return this.children.length"/>
+                onget="return this.itemChildren.length"/>
 
       <!-- nsIDOMXULSelectControlElement -->
       <method name="getIndexOfItem">
         <parameter name="aItem"/>
         <body>
           <![CDATA[
             // don't search the children, if we're looking for none of them
             if (aItem == null)
               return -1;
             if (this._selecting && this._selecting.item == aItem)
               return this._selecting.index;
-            return this.children.indexOf(aItem);
+            return this.itemChildren.indexOf(aItem);
           ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULSelectControlElement -->
       <method name="getItemAtIndex">
         <parameter name="aIndex"/>
         <body>
           <![CDATA[
             if (this._selecting && this._selecting.index == aIndex)
               return this._selecting.item;
-            return this.children[aIndex] || null;
+            return this.itemChildren[aIndex] || null;
           ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULMultiSelectControlElement -->
       <property name="selType"
                 onget="return this.getAttribute('seltype');"
                 onset="this.setAttribute('seltype', val); return val;"/>
@@ -510,40 +510,40 @@
               this._scrollbox.scrollToElement(item);
           ]]>
         </body>
       </method>
 
       <method name="getIndexOfFirstVisibleRow">
         <body>
           <![CDATA[
-            var children = this.children;
+            var children = this.itemChildren;
 
             for (var ix = 0; ix < children.length; ix++)
               if (this._isItemVisible(children[ix]))
                 return ix;
 
             return -1;
           ]]>
         </body>
       </method>
 
       <method name="getRowCount">
         <body>
           <![CDATA[
-            return this.children.length;
+            return this.itemChildren.length;
           ]]>
         </body>
       </method>
 
       <method name="scrollOnePage">
         <parameter name="aDirection"/> <!-- Must be -1 or 1 -->
         <body>
           <![CDATA[
-            var children = this.children;
+            var children = this.itemChildren;
 
             if (children.length == 0)
               return 0;
 
             // If nothing is selected, we just select the first element
             // at the extreme we're moving away from
             if (!this.currentItem)
               return aDirection == -1 ? children.length : 0;
@@ -573,22 +573,22 @@
               index = ix;
             }
 
             return index != this.currentIndex ? index - this.currentIndex : aDirection;
           ]]>
         </body>
       </method>
 
-      <property name="children" readonly="true">
+      <property name="itemChildren" readonly="true">
         <getter>
           <![CDATA[
             let iface = Ci.nsIDOMXULSelectControlItemElement;
-            let children = Array.from(this.childNodes)
-                                .filter(node => node.nodeType == 1 && node instanceof iface);
+            let children = Array.from(this.children)
+                                .filter(node => node instanceof iface);
             if (this.dir == "reverse" && this._mayReverse) {
               children.reverse();
             }
             return children;
           ]]>
         </getter>
       </property>
 
@@ -662,17 +662,17 @@
 
             // if we have no previously current item or if the above check fails to
             // find the previous nodes (which causes it to clear selection)
             if (!this.currentItem && this.selectedCount == 0) {
               this.currentIndex = this._currentIndex ? this._currentIndex - 1 : 0;
 
               // cf. listbox constructor:
               // select items according to their attributes
-              var children = this.children;
+              var children = this.itemChildren;
               for (let i = 0; i < children.length; ++i) {
                 if (children[i].getAttribute("selected") == "true")
                   this.selectedItems.append(children[i]);
               }
             }
 
             if (this.selType != "multiple" && this.selectedCount == 0)
               this.selectedItem = this.currentItem;
diff --git a/toolkit/mozapps/extensions/content/extensions.js b/toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js
+++ b/toolkit/mozapps/extensions/content/extensions.js
@@ -1768,17 +1768,17 @@ var gCategories = {
     category.setAttribute("value", aView);
     category.setAttribute("class", "category");
     category.setAttribute("name", aName);
     category.setAttribute("tooltiptext", aName);
     category.setAttribute("priority", aPriority);
     category.setAttribute("hidden", aStartHidden);
 
     var node;
-    for (node of this.node.children) {
+    for (node of this.node.itemChildren) {
       var nodePriority = parseInt(node.getAttribute("priority"));
       // If the new type's priority is higher than this one then this is the
       // insertion point
       if (aPriority < nodePriority)
         break;
       // If the new type's priority is lower than this one then this is isn't
       // the insertion point
       if (aPriority > nodePriority)
diff --git a/toolkit/mozapps/extensions/test/browser/browser_langpack_signing.js b/toolkit/mozapps/extensions/test/browser/browser_langpack_signing.js
--- a/toolkit/mozapps/extensions/test/browser/browser_langpack_signing.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_langpack_signing.js
@@ -24,18 +24,18 @@ add_task(async function() {
     isCorrectlySigned: false,
   }]);
 
 
   let mgrWin = await open_manager(null);
 
   function checklist(signingRequired) {
     let list = mgrWin.document.getElementById("addon-list");
-    is(list.children.length, 2, "Found 2 items in langpack list");
-    for (let item of list.children) {
+    is(list.itemChildren.length, 2, "Found 2 items in langpack list");
+    for (let item of list.itemChildren) {
       let what, warningVisible, errorVisible;
 
       if (item.mAddon.id.startsWith("signed")) {
         // Signed langpack should not have any warning/error
         what = "signed langpack";
         warningVisible = false;
         errorVisible = false;
       } else if (signingRequired) {
diff --git a/toolkit/mozapps/extensions/test/browser/browser_legacy.js b/toolkit/mozapps/extensions/test/browser/browser_legacy.js
--- a/toolkit/mozapps/extensions/test/browser/browser_legacy.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_legacy.js
@@ -73,17 +73,17 @@ add_task(async function() {
 
   let mgrWin = await open_manager(null);
   let catUtils = new CategoryUtilities(mgrWin);
 
   // Check that the test addons in the given list are exactly those
   // in the expected list.
   async function checkList(listId, expectIds) {
     let ids = new Set(expectIds);
-    for (let item of mgrWin.document.getElementById(listId).children) {
+    for (let item of mgrWin.document.getElementById(listId).itemChildren) {
       if (!item.mAddon.id.endsWith("@tests.mozilla.org")) {
         continue;
       }
 
       ok(ids.has(item.mAddon.id), `Found ${item.mAddon.id} in addons list`);
       ids.delete(item.mAddon.id);
     }
 
