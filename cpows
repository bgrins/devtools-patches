# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e99e3e62cfa8bbc7d430f64d4fbdf77ffb81e979
Bug 1382833 - Don't throw when dealing with CPOWs in the Object Actor;r=jimb

diff --git a/devtools/server/actors/object.js b/devtools/server/actors/object.js
--- a/devtools/server/actors/object.js
+++ b/devtools/server/actors/object.js
@@ -86,23 +86,29 @@ ObjectActor.prototype = {
 
     // If it's a proxy, lie and tell that it belongs to an invented
     // "Proxy" class, and avoid calling the [[IsExtensible]] trap
     if (this.obj.isProxy) {
       g.class = "Proxy";
       g.proxyTarget = this.hooks.createValueGrip(this.obj.proxyTarget);
       g.proxyHandler = this.hooks.createValueGrip(this.obj.proxyHandler);
     } else {
-      g.class = this.obj.class;
-      g.extensible = this.obj.isExtensible();
-      g.frozen = this.obj.isFrozen();
-      g.sealed = this.obj.isSealed();
+      try {
+        g.class = DevToolsUtils.isCPOW(this.obj) ? ("CPOW: " + this.obj.class) : this.obj.class;
+        g.extensible = this.obj.isExtensible();
+        g.frozen = this.obj.isFrozen();
+        g.sealed = this.obj.isSealed();
+      } catch(e) {
+        // Handle cases where the underlying object's calls to isExtensible, etc throw.
+        // This is possible with ProxyObjects like CPOWs. Note these are different from
+        // scripted Proxies created via `new Proxy`, which match this.obj.isProxy above.
+      }
     }
 
-    if (g.class != "DeadObject") {
+    if (g.class != "DeadObject" && !DevToolsUtils.isCPOW(this.obj)) {
       if (g.class == "Promise") {
         g.promiseState = this._createPromiseState();
       }
 
       // FF40+: Allow to know how many properties an object has
       // to lazily display them when there is a bunch.
       // Throws on some MouseEvent object in tests.
       try {
diff --git a/devtools/shared/DevToolsUtils.js b/devtools/shared/DevToolsUtils.js
--- a/devtools/shared/DevToolsUtils.js
+++ b/devtools/shared/DevToolsUtils.js
@@ -24,16 +24,31 @@ var DevToolsUtils = exports;
 
 // Re-export the thread-safe utils.
 const ThreadSafeDevToolsUtils = require("./ThreadSafeDevToolsUtils.js");
 for (let key of Object.keys(ThreadSafeDevToolsUtils)) {
   exports[key] = ThreadSafeDevToolsUtils[key];
 }
 
 /**
+ * Helper for Cu.isCrossProcessWrapper that works with Debugger.Objects.
+ * This will always return false in workers (see the implementation in
+ * ThreadSafeDevToolsUtils.js).
+ *
+ * @param Debugger.Object debuggerObject
+ * @return bool
+ */
+exports.isCPOW = function (debuggerObject) {
+  try {
+    return Cu.isCrossProcessWrapper(debuggerObject.unsafeDereference());
+  } catch(e) { }
+  return false;
+};
+
+/**
  * Waits for the next tick in the event loop to execute a callback.
  */
 exports.executeSoon = function (fn) {
   if (isWorker) {
     setImmediate(fn);
   } else {
     let executor;
     // Only enable async stack reporting when DEBUG_JS_MODULES is set
diff --git a/devtools/shared/ThreadSafeDevToolsUtils.js b/devtools/shared/ThreadSafeDevToolsUtils.js
--- a/devtools/shared/ThreadSafeDevToolsUtils.js
+++ b/devtools/shared/ThreadSafeDevToolsUtils.js
@@ -65,16 +65,24 @@ exports.update = function update(target,
  * @param object Object
  *        The object to iterate over
  */
 exports.values = function values(object) {
   return Object.keys(object).map(k => object[k]);
 };
 
 /**
+ * This is overridden in DevToolsUtils for the main thread, where we have the
+ * Cu object available.
+ */
+exports.isCPOW = function () {
+  return false;
+};
+
+/**
  * Report that |who| threw an exception, |exception|.
  */
 exports.reportException = function reportException(who, exception) {
   const msg = `${who} threw an exception: ${exports.safeErrorString(exception)}`;
   dump(msg + "\n");
 
   if (typeof console !== "undefined" && console && console.error) {
     console.error(msg);
