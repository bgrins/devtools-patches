# HG changeset patch
# Parent d26c54bb8c631dd5fb7b9be5ff37363bb03308c1
# User Brian Grinstead <bgrinstead@mozilla.com>
pairing with project editor

diff --git a/browser/devtools/framework/target.js b/browser/devtools/framework/target.js
--- a/browser/devtools/framework/target.js
+++ b/browser/devtools/framework/target.js
@@ -365,16 +365,17 @@ TabTarget.prototype = {
     };
     this.client.addListener("tabDetached", this._onTabDetached);
 
     this._onTabNavigated = function onRemoteTabNavigated(aType, aPacket) {
       let event = Object.create(null);
       event.url = aPacket.url;
       event.title = aPacket.title;
       event.nativeConsoleAPI = aPacket.nativeConsoleAPI;
+      console.log("ON TAB NAVIGFATED!!", aType, aPacket);
       // Send any stored event payload (DOMWindow or nsIRequest) for backwards
       // compatibility with non-remotable tools.
       if (aPacket.state == "start") {
         event._navPayload = this._navRequest;
         this.emit("will-navigate", event);
         this._navRequest = null;
       } else {
         event._navPayload = this._navWindow;
@@ -534,16 +535,20 @@ TabWebProgressListener.prototype = {
     if (this.target && this.target.window == progress.DOMWindow) {
       // Emit the event if the target is not remoted or store the payload for
       // later emission otherwise.
       if (this.target._client) {
         this.target._navRequest = request;
       } else {
         this.target.emit("will-navigate", request);
       }
+    } else if (this.target && this.target.window != progress.DOMWindow) {
+      /// XXX: hack to emit event for frame loading
+      // XXX: Maybe Bug 977043 will allow this?
+      this.target.emit("frame-will-navigate", request, this.target.window);
     }
   },
 
   onProgressChange: function() {},
   onSecurityChange: function() {},
   onStatusChange: function() {},
 
   onLocationChange: function TWPL_onLocationChange(webProgress, request, URI, flags) {
@@ -552,16 +557,20 @@ TabWebProgressListener.prototype = {
       let window = webProgress.DOMWindow;
       // Emit the event if the target is not remoted or store the payload for
       // later emission otherwise.
       if (this.target._client) {
         this.target._navWindow = window;
       } else {
         this.target.emit("navigate", window);
       }
+    } else if (this.target) {
+      // XXX: Maybe Bug 977043 will allow this?
+        let window = webProgress.DOMWindow;
+        this.target.emit("frame-navigate", window);
     }
   },
 
   /**
    * Destroy the progress listener instance.
    */
   destroy: function TWPL_destroy() {
     if (this.target.tab) {
diff --git a/browser/devtools/projecteditor/chrome/content/projecteditor-loader.js b/browser/devtools/projecteditor/chrome/content/projecteditor-loader.js
--- a/browser/devtools/projecteditor/chrome/content/projecteditor-loader.js
+++ b/browser/devtools/projecteditor/chrome/content/projecteditor-loader.js
@@ -1,19 +1,22 @@
 const Cu = Components.utils;
 const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 const {FileUtils} = Cu.import("resource://gre/modules/FileUtils.jsm", {});
 const {NetUtil} = Cu.import("resource://gre/modules/NetUtil.jsm", {});
 const require = devtools.require;
 const promise = require("projecteditor/helpers/promise");
 const ProjectEditor = require("projecteditor/projecteditor");
+const TargetFactory = require("devtools/framework/target").TargetFactory;
+const tabs = require("sdk/tabs");
+Cu.import("resource://gre/modules/Services.jsm");
+
 
 const SAMPLE_PATH = buildTempDirectoryStructure();
 const SAMPLE_NAME = "DevTools Content Application Name";
-const SAMPLE_PROJECT_URL = "http://mozilla.org";
 const SAMPLE_ICON = "chrome://browser/skin/devtools/tool-debugger.svg";
 
 /**
  * Create a workspace for working on projecteditor, available at
  * chrome://browser/content/devtools/projecteditor-loader.xul.
  * This emulates the integration points that the app manager uses.
  */
 document.addEventListener("DOMContentLoaded", function onDOMReady(e) {
@@ -47,25 +50,39 @@ document.addEventListener("DOMContentLoa
   });
   projecteditor.on("onEditorCursorActivity", (editor) => {
     console.log("editor cursor activity: " + editor);
   });
   projecteditor.on("onCommand", (cmd) => {
     console.log("Command: " + cmd);
   });
 
+
+  let topWindow = Services.wm.getMostRecentWindow("navigator:browser");
+  let gBrowser = topWindow.gBrowser;
+
+console.log(gBrowser.mCurrentTab);
   projecteditor.loaded.then(() => {
     projecteditor.setProjectToAppPath(SAMPLE_PATH, {
       name: SAMPLE_NAME,
       iconUrl: SAMPLE_ICON,
-      projectOverviewURL: SAMPLE_PROJECT_URL,
+      projectOverviewURL: "file://" + FileUtils.getFile("TmpD", ["ProjectEditor", "index.html"]).path,
       validationStatus: "valid"
     }).then(() => {
+      let root = projecteditor.project.allResources()[0];
+      let win = projecteditor.editorFor(root).iframe.contentWindow;
       let allResources = projecteditor.project.allResources();
-      console.log("All resources have been loaded", allResources, allResources.map(r=>r.basename).join("|"));
+      let tab = gBrowser.mCurrentTab;
+      let target = TargetFactory.forTab(tab);
+      target.makeRemote().then(() => {
+        console.log("Making remote", target);
+        projecteditor.setTarget(target, win);
+      });
+
+      console.log("All resources have been loaded", allResources.map(r=>r.basename).join("|"));
     });
 
   });
 
 }, false);
 
 /**
  * Build a temporary directory as a workspace for this loader
@@ -87,21 +104,41 @@ function buildTempDirectoryStructure() {
 
   let htmlFile = FileUtils.getFile("TmpD", ["ProjectEditor", "index.html"]);
   htmlFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   writeToFile(htmlFile, [
     '<!DOCTYPE html>',
     '<html lang="en">',
     ' <head>',
     '   <meta charset="utf-8" />',
-    '   <title>ProjectEditor Temp File</title>',
-    '   <link rel="stylesheet" href="style.css" />',
+    '   <title>ProjectEditor Home Page</title>',
+    '   <link rel="stylesheet" href="css/styles.css" />',
     ' </head>',
     ' <body id="home">',
-    '   <p>ProjectEditor Temp File</p>',
+    '   <p>ProjectEditor Home Page</p>',
+    '   <button onclick="window.location.reload()">Reload Page</button>',
+    '   <a href="sample.html">Navigate to sample.html</a>',
+    ' </body>',
+    '</html>'].join("\n")
+  );
+
+  let htmlFile2 = FileUtils.getFile("TmpD", ["ProjectEditor", "sample.html"]);
+  htmlFile2.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
+  writeToFile(htmlFile2, [
+    '<!DOCTYPE html>',
+    '<html lang="en">',
+    ' <head>',
+    '   <meta charset="utf-8" />',
+    '   <title>ProjectEditor Sample Page</title>',
+    '   <link rel="stylesheet" href="css/styles.css" />',
+    ' </head>',
+    ' <body id="home">',
+    '   <p>ProjectEditor Sample Page</p>',
+    '   <button onclick="window.location.reload()">Reload Page</button>',
+    '   <a href="index.html">Navigate to index.html</a>',
     ' </body>',
     '</html>'].join("\n")
   );
 
   let readmeFile = FileUtils.getFile("TmpD", ["ProjectEditor", "README.md"]);
   readmeFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   writeToFile(readmeFile, [
     '## Readme'
@@ -116,17 +153,20 @@ function buildTempDirectoryStructure() {
    ' * file, You can obtain one at http://mozilla.org/MPL/2.0/. */'
     ].join("\n")
   );
 
   let cssFile = FileUtils.getFile("TmpD", ["ProjectEditor", "css", "styles.css"]);
   cssFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   writeToFile(cssFile, [
     'body {',
-    ' background: red;',
+    '  background: #fee;',
+    '}',
+    'p {',
+    '  padding: 10px',
     '}'
     ].join("\n")
   );
 
   FileUtils.getFile("TmpD", ["ProjectEditor", "js", "script.js"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
 
   FileUtils.getFile("TmpD", ["ProjectEditor", "img", "fake.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   FileUtils.getFile("TmpD", ["ProjectEditor", "img", "icons", "16x16.png"]).createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
diff --git a/browser/devtools/projecteditor/lib/plugins/pairing/pairing.js b/browser/devtools/projecteditor/lib/plugins/pairing/pairing.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/projecteditor/lib/plugins/pairing/pairing.js
@@ -0,0 +1,82 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const { Class } = require("sdk/core/heritage");
+const { registerPlugin, Plugin } = require("projecteditor/plugins/core");
+const { StyleSheetsFront } = require("devtools/server/actors/stylesheets");
+const { StyleEditorFront } = require("devtools/server/actors/styleeditor");
+const { CssLogic } = require("devtools/styleinspector/css-logic");
+const { ResourceMap } = require("projecteditor/plugins/pairing/resource-map");
+
+// Handles the new command.
+var Pairing = Class({
+  extends: Plugin,
+
+  init: function() {
+    console.log("PAIRING INIT");
+    this._onStyleSheetsCleared = this._onStyleSheetsCleared.bind(this);
+    this._onNavigate = this._onNavigate.bind(this);
+    this.resourceMap = new ResourceMap(this.host);
+  },
+
+  get target() {
+    return this.host.target;
+  },
+
+  get targetWin() {
+    return this.host.targetWin;
+  },
+
+  newTarget: function(target, win) {
+    console.log("NEW PARING", target);
+
+    // XXX: Need to share style editor fronts with the style editor.
+    if (this.target.form.styleSheetsActor) {
+      this.debuggee = StyleSheetsFront(this.target.client, this.target.form);
+    } else {
+      // We're talking to a pre-firefox 29 server-side
+      this.debuggee = StyleEditorFront(this.target.client, this.target.form);
+    }
+
+    this.debuggee.getStyleSheets().then(styleSheets => {
+      if (this.target !== target) {
+        return;
+      }
+
+      this.resourceMap.setSheets(styleSheets);
+      this.target.on("will-navigate", this._onStyleSheetsCleared);
+      this.target.on("frame-will-navigate", this._onNavigate);
+
+      this.target.on("navigate", this._onNavigate);
+      this.target.on("frame-navigate", this._onNavigate);
+      console.log("BINDING TO EVENTS", this._onStyleSheetsCleared, this._onNavigate);
+    }).then(null, console.error);
+  },
+  _onStyleSheetsCleared: function() {
+    console.log("Pairing: on stylesheets cleared");
+  },
+  _onNavigate: function() {
+    console.log("Pairing: _onNavigate");
+  },
+  removeTarget: function(target) {
+    console.log("REMOVE PARING", target);
+    this.resources.clear();
+
+    if (this.debuggee) {
+      this.debuggee.destroy();
+    }
+
+    if (this.target) {
+      this.target.off("will-navigate", this._onStyleSheetsCleared);
+      this.target.off("navigate", this._onNavigate);
+    }
+  },
+  destroy: function() {
+    this.removeTarget();
+  }
+})
+exports.Pairing = Pairing;
+registerPlugin(Pairing);
diff --git a/browser/devtools/projecteditor/lib/plugins/pairing/resource-map.js b/browser/devtools/projecteditor/lib/plugins/pairing/resource-map.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/projecteditor/lib/plugins/pairing/resource-map.js
@@ -0,0 +1,279 @@
+const { Class } = require("sdk/core/heritage");
+const { emit } = require("sdk/event/core");
+const { EventTarget } = require("sdk/event/target");
+const timers = require("sdk/timers");
+const { on, off, forget } = require("projecteditor/helpers/event");
+
+// Maintains the list of pairs.
+var ResourceMap = Class({
+  initialize: function(host) {
+    this.map = new Map();
+    this.styleSheetMap = new Map();
+    this.host = host;
+
+    this.scheduleRebuild = this.scheduleRebuild.bind(this);
+    this.rebuild = this.rebuild.bind(this)
+    this.watchCollection = this.watchCollection.bind(this);
+    this.unwatchCollection = this.unwatchCollection.bind(this);
+
+    [...this.host.project.allStores()].forEach(this.watchCollection);
+    on(this, this.host.project, "store-added", this.watchCollection);
+    on(this, this.host.project, "store-removed", this.unwatchCollection);
+    console.log("NEW RESOURCE MAP");
+  },
+
+  get target () {
+    return this.host.target;
+  },
+  get targetWin () {
+    return this.host.targetWin;
+  },
+  allResources: function() {
+    return this.host.project.allResources();
+  },
+
+  setSheets: function(styleSheets) {
+
+    this.styleSheetMap = new Map();
+
+    console.log("SETTING SHEETS", this.debuggee, styleSheets);
+    // this.root.setSheets(styleSheets);
+    this.styleSheets = styleSheets;
+    styleSheets.forEach((sheet) => {
+      let processSheet = !!sheet.href;
+      if (this.targetWin) {
+        let location = this.targetWin.location.toString();
+        if (sheet.nodeHref !== location) {
+          processSheet = false;
+        }
+      }
+      if (processSheet) {
+        this.styleSheetMap.set(sheet.href, sheet);
+        // sheet.update("body { color: red }", true);
+      }
+    });
+    this.rebuild();
+  },
+
+  watchCollection: function(collection) {
+    console.log("Watching collection", collection);
+    on(this, collection, "resource-added", this.scheduleRebuild);
+    on(this, collection, "resource-removed", this.scheduleRebuild);
+  },
+
+  unwatchCollection: function(collection) {
+    forget(this, collection);
+  },
+
+  scheduleRebuild: function() {
+    if (this._scheduledRebuild) {
+      timers.clearTimeout(this._scheduledRebuild);
+    }
+    this._scheduledRebuild = timers.setTimeout(this.rebuild, 100);
+  },
+
+  /**
+  * Rebuild the project pairings.
+  */
+  rebuild: function() {
+    if (this._scheduledRebuild) {
+      timers.clearTimeout(this._scheduledRebuild);
+      this._scheduledRebuild = null;
+    }
+    let start = Date.now();
+    // Rules:
+    // - Pairs stay with the local resource if they change.
+
+    let newPairs = new Map();
+    console.log("foo",this.styleSheetMap, this.styleSheetMap.size,this.styleSheets);
+
+    let needUpdate = false;
+    for (let stylesheet of this.styleSheetMap.keys()) {
+      let resource = this._findBestResource(stylesheet);
+      if (resource) {
+        if (this.map.get(resource) !== stylesheet) {
+          needUpdate = true;
+        }
+        this.map.set(resource, stylesheet);
+      }
+    }
+
+    // XXX: selectively notify only changed ones
+    if (needUpdate) {
+
+    }
+
+    // for (let resource of this.allResources()) {
+    //   console.log(resource.path);
+
+    //   let assets = this._findPageAssets(resource);
+    //   if (assets) {
+    //     this.map.set(resource, assets);
+    //   }
+
+    //   if (this.styleSheetMap.get(resource.path)) {
+    //     console.log("HELLO THERE", resource.path);
+    //   }
+    //   if (this.map.get(resource)) {
+
+    //   }
+    //   // let newPair = newPairs.get(resource);
+    //   // if (newPair) {
+    //   //   // Already taken care of.
+    //   //   continue;
+    //   // }
+    //   // let oldPair = this.map.get(resource);
+    //   // if (oldPair) {
+    //   //   oldPair.live = null;
+    //   //   newPairs.set(project, oldPair);
+    //   // }
+    // }
+
+
+    let end = Date.now();
+    console.log("Rebuilt project map in " + (end - start) + "ms");
+
+
+
+    // console.log("aboutto fail hard");
+    // // Walk through all live resources...
+    // for (let live of this.page.allResources()) {
+    //   if (live.isDir) {
+    //     continue;
+    //   }
+
+    //   // If there's a manual pair, just trust it.
+    //   if (this.manualPairs.has(live)) {
+    //     let manual = this.manualPairs.get(live);
+    //     newPairs.set(manual.project, manual);
+    //     newPairs.set(manual.live, manual);
+    //     continue;
+    //   }
+
+    //   // Find a project resource for this resource...
+    //   let project = this._findPair(live);
+
+    //   if (!project) {
+    //     // No paired resource, no need to save a pair, but do
+    //     // keep the one-sided pair around if there is one.
+    //     let oldPair = this.pairs.get(live);
+    //     if (oldPair) {
+    //       // Just in case.
+    //       oldPair.project = null;
+
+    //       newPairs.set(live, oldPair);
+    //     }
+    //     continue;
+    //   }
+
+    //   // We have a real pair. Update it if it already exists.
+    //   // XXX: This could leave us with an empty pair, make
+    //   // sure editors close properly...
+    //   let pair = this.pairs.get(project);
+    //   if (pair) {
+    //     pair.live = live;
+    //   } else {
+    //     pair = new Pair(this, project, live);
+    //   }
+    //   newPairs.set(live, pair);
+    //   newPairs.set(project, pair);
+
+    //   // Remove the project link from the map so the next pass
+    //   // doesn't pick it up.
+    //   this.pairs.delete(project);
+    // }
+
+    // // Now newPairs has pairs for all live resources that
+    // // need them (either because they already had a single-sided pair
+    // // in the wild or because they found a real pair)
+    // // Now make sure that any project resources with an outstanding pair
+    // // are included.
+    // for (let project of this.allResources()) {
+    //   let newPair = newPairs.get(project);
+    //   if (newPair) {
+    //     // Already taken care of.
+    //     continue;
+    //   }
+    //   let oldPair = this.pairs.get(project);
+    //   if (oldPair) {
+    //     oldPair.live = null;
+    //     newPairs.set(project, oldPair);
+    //   }
+    // }
+
+    // this.pairs = newPairs;
+
+  },
+
+  /**
+  * Find the best resource for a page asset
+  *
+  * Right now we only have one strategy, but new strategies
+  * can be added here.
+  */
+  _findBestResource: function(href) {
+
+    /// XXX: wrap stylesheet into a PageAsset class that has basename
+    // and href
+    let splitHref = href.split('/')
+    let basename = splitHref[splitHref.length - 1];
+    return this._fuzzyStrategy(basename, href);
+  },
+
+  /**
+  * The default fuzzy match strategy for finding a live pairing.
+  * Finds a project resources with the same basename, and chooses
+  * the one with the most path component matches.
+  */
+  _fuzzyStrategy: function(basename, path) {
+    let matches = this._findBasenameMatches(basename);
+    console.log(basename, path, matches);
+    if (matches.length < 1) {
+      return null;
+    }
+
+    let searchPath = path.split('/').filter(item => !!item);
+    searchPath.reverse();
+
+    let bestMatch = null;
+    let bestMatchComponents = 0;
+    let bestMatchExtra = 1000;
+    for (let match of matches) {
+      let matchPath = path.split('/').filter(item => !!item);
+      matchPath.reverse();
+      let i;
+      for (i = 0; i < matchPath.length && i < searchPath.length; i++) {
+        if (matchPath[i] != searchPath[i]) {
+          break;
+        }
+      }
+
+      // In case of a tie in matched components, arbitrarily assume that
+      // resources closer to the project root are correct.
+      let remaining = matchPath.length - i;
+      if (i > bestMatchComponents ||
+          (i === bestMatchComponents && remaining < bestMatchExtra)) {
+        bestMatch = match;
+        bestMatchComponents = i;
+        bestMatchExtra = remaining;
+      }
+    }
+
+    return bestMatch;
+  },
+
+  _findBasenameMatches: function(basename) {
+    console.log("Finding basename matches", basename);
+    let matches = [];
+    for (let resource of this.allResources()) {
+      console.log("Checking for resource", resource.basename);
+      if (resource.basename == basename) {
+        matches.push(resource);
+      }
+    }
+    return matches;
+  }
+});
+
+
+exports.ResourceMap = ResourceMap;
\ No newline at end of file
diff --git a/browser/devtools/projecteditor/lib/projecteditor.js b/browser/devtools/projecteditor/lib/projecteditor.js
--- a/browser/devtools/projecteditor/lib/projecteditor.js
+++ b/browser/devtools/projecteditor/lib/projecteditor.js
@@ -24,16 +24,17 @@ const ITCHPAD_URL = "chrome://browser/co
 // Enabled Plugins
 require("projecteditor/plugins/dirty/dirty");
 require("projecteditor/plugins/delete/delete");
 require("projecteditor/plugins/new/new");
 require("projecteditor/plugins/save/save");
 require("projecteditor/plugins/image-view/plugin");
 require("projecteditor/plugins/app-manager/plugin");
 require("projecteditor/plugins/status-bar/plugin");
+require("projecteditor/plugins/pairing/pairing");
 
 // Uncomment to enable logging.
 // require("projecteditor/plugins/logging/logging");
 
 /**
  * This is the main class tying together an instance of the ProjectEditor.
  * The frontend is contained inside of this.iframe, which loads projecteditor.xul.
  *
@@ -282,16 +283,39 @@ var ProjectEditor = Class({
       let rootResource = this.project.localStores.get(path).root;
       emit(rootResource, "label-change", rootResource);
     }
 
     return this.project.refresh();
   },
 
   /**
+   * Set a TabTarget for pairing with the editor
+   *
+   * @param TabTarget target
+   *                  The target for pairing.
+   * @param Window win
+   *               The window within the target that should be watched
+   *               If null, all windows will be watched.
+   */
+  setTarget: function(target, win=null) {
+    if (!target) {
+      this.pluginDispatch("removeTarget", this.target);
+      this.target = this.targetWin = null;
+    } else if (target !== this.target) {
+      if (this.target) {
+        this.pluginDispatch("removeTarget", this.target, this.targetWin);
+      }
+      this.target = target;
+      this.targetWin = win;
+      this.pluginDispatch("newTarget", target, win);
+    }
+  },
+
+  /**
    * Open a resource in a particular shell.
    *
    * @param Resource resource
    *                 The file to be opened.
    */
   openResource: function(resource) {
     this.shells.open(resource);
     this.projectTree.selectResource(resource);
