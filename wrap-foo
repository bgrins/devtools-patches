# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4a699b34f3c36dfd5b8af1e213ba91918bdad7f0

diff --git a/browser/base/content/test/tabs/browser_allow_process_switches_despite_related_browser.js b/browser/base/content/test/tabs/browser_allow_process_switches_despite_related_browser.js
--- a/browser/base/content/test/tabs/browser_allow_process_switches_despite_related_browser.js
+++ b/browser/base/content/test/tabs/browser_allow_process_switches_despite_related_browser.js
@@ -21,13 +21,14 @@ add_task(async function() {
 
   let dummyPage = getChromeDir(getResolvedURI(gTestPath));
   dummyPage.append(DUMMY_FILE);
   const uriString = Services.io.newFileURI(dummyPage).spec;
 
   let viewSourceBrowser = viewSourceTab.linkedBrowser;
   let promiseLoad =
     BrowserTestUtils.browserLoaded(viewSourceBrowser, false, uriString);
+    
   BrowserTestUtils.loadURI(viewSourceBrowser, uriString);
   let href = await promiseLoad;
   is(href, uriString,
     "Check file:// URI loads in a browser that was previously for view-source");
 });
diff --git a/toolkit/content/widgets/browser.js b/toolkit/content/widgets/browser.js
--- a/toolkit/content/widgets/browser.js
+++ b/toolkit/content/widgets/browser.js
@@ -3,16 +3,25 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
+const elementsToDestroyOnUnload = new Set();
+
+window.addEventListener("unload", e => {
+  for (let element of elementsToDestroyOnUnload.values()) {
+    element.remove();
+  }
+  elementsToDestroyOnUnload.clear();
+});
+
 let LOG = () => { };// console.log.bind(null, "browser logging:");
 let browserNumber = 0;
 const WINDOW_ID = window.windowUtils.currentInnerWindowID;
 /* globals XULFrameElement */
 
 class MozBrowser extends XULFrameElement {
 
   static get observedAttributes() {
@@ -34,18 +43,16 @@ class MozBrowser extends XULFrameElement
   }
 
   constructor() {
     super();
 
     this.browserNumber = browserNumber++;
     LOG("constructor() called", this.logString);
 
-    this.destroyOnUnload = this.destroyOnUnload.bind(this);
-
 
     /**
      * These are managed by the tabbrowser
      */
     this.droppedLinkHandler = null;
 
     this.mIconURL = null;
 
@@ -148,31 +155,22 @@ class MozBrowser extends XULFrameElement
       // with the mouse movement.
       if (this.isRemoteBrowser) {
         event.stopPropagation();
       }
     });
 
   }
 
-  destroyOnUnload(e) {
-    if (e.originalTarget == document) {
-      window.removeEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
-      LOG("Destroying due to unload", this.logString);
-      this.destroy();
-    }
-  }
-
   disconnectedCallback() {
-    window.removeEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
     this.destroy();
+    this.mDisconnected = true;
   }
 
   connectedCallback() {
-    window.addEventListener("unload", this.destroyOnUnload, { mozSystemGroup: true, capture: true });
     this.construct();
   }
 
   get autoscrollEnabled() {
     if (this.getAttribute("autoscroll") == "false")
       return false;
 
     return this.mPrefs.getBoolPref("general.autoScroll", true);
@@ -845,16 +843,19 @@ class MozBrowser extends XULFrameElement
   didStartLoadSinceLastUserTyping() {
     return !this.inLoadURI &&
       this.urlbarChangeTracker._startedLoadSinceLastUserTyping;
   }
 
   construct() {
     LOG("construct() called", this.logString);
 
+    elementsToDestroyOnUnload.add(this);
+
+    this.mDisconnected = false;
     this._documentURI = null;
 
     this._documentContentType = null;
 
     /**
      * Weak reference to an optional frame loader that can be used to influence
      * process selection for this browser.
      * See nsIBrowser.sameProcessAsFrameLoader.
@@ -1075,24 +1076,26 @@ class MozBrowser extends XULFrameElement
   }
 
   /**
    * This is necessary because the destructor doesn't always get called when
    * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
    */
   destroy() {
     LOG("destroy() called", this.logString);
+
+    elementsToDestroyOnUnload.delete(this);
+    this._sameProcessAsFrameLoader = null;
     // Make sure that any open select is closed.
     if (this._selectParentHelper) {
       let menulist = document.getElementById(this.getAttribute("selectmenulist"));
       this._selectParentHelper.hide(menulist, this);
     }
     if (this.mDestroyed)
       return;
-    this.mDestroyed = true;
 
     if (this.isRemoteBrowser) {
       try {
         this.controllers.removeController(this._controller);
       } catch (ex) {
         // This can fail when this browser element is not attached to a
         // BrowserDOMWindow.
       }
@@ -1100,40 +1103,40 @@ class MozBrowser extends XULFrameElement
       if (!this.hasAttribute("disablehistory")) {
         try {
           Services.obs.removeObserver(this, "browser:purge-session-history");
         } catch (ex) {
           // It's not clear why this sometimes throws an exception.
         }
       }
 
-      return;
-    }
+      this._controller = null;
+    } else {
+      if (this.docShell && this.webNavigation.sessionHistory) {
+        try {
+          Services.obs.removeObserver(this, "browser:purge-session-history");
+        } catch (ex) {
+          // It's not clear why this sometimes throws an exception.
+        }
+      }
 
-    if (this.docShell && this.webNavigation.sessionHistory) {
-      try {
-        Services.obs.removeObserver(this, "browser:purge-session-history");
-      } catch (ex) {
-        // It's not clear why this sometimes throws an exception.
+      this._fastFind = null;
+      this._webBrowserFind = null;
+
+      this.lastURI = null;
+
+      this.removeEventListener("pagehide", this.onPageHide, true);
+
+      if (this._autoScrollNeedsCleanup) {
+        // we polluted the global scope, so clean it up
+        this._autoScrollPopup.remove();
       }
     }
 
-    this._fastFind = null;
-    this._webBrowserFind = null;
-
-    this.lastURI = null;
-
-    if (!this.isRemoteBrowser) {
-      this.removeEventListener("pagehide", this.onPageHide, true);
-    }
-
-    if (this._autoScrollNeedsCleanup) {
-      // we polluted the global scope, so clean it up
-      this._autoScrollPopup.remove();
-    }
+    this.mDestroyed = true;
   }
 
   /**
    * We call this _receiveMessage (and alias receiveMessage to it) so that
    * bindings that inherit from this one can delegate to it.
    */
   _receiveMessage(aMessage) {
     let data = aMessage.data;
@@ -1789,12 +1792,68 @@ class MozBrowser extends XULFrameElement
         type: aLinks[i + 2],
       });
     }
     this.droppedLinkHandler(null, links, aTriggeringPrincipal);
     return true;
   }
 }
 
+function wrap(f, n) {
+  return function() {
+    // if (this.mDisconnected == this.isConnected) {
+    //   console.log(n, this.mDisconnected);
+    //   console.trace();
+    // }
+    if (this.mDisconnected) {
+      // console.log("Early return for ", n);
+      return undefined;
+    }
+
+    return f.apply(this, arguments);
+  };
+}
+
+// Wrap every function, getter, and setter into a function that simulates
+// XBL behavior when disconnected.
+let descriptors = Object.getOwnPropertyDescriptors(MozBrowser.prototype);
+let skipDescriptors = {
+  "destroy": 1,
+  "destroyOnUnload": 1,
+  "connectedCallback": 1,
+  "disconnectedCallback": 1,
+  "construct": 1,
+  "logString": 1,
+  "attributeChangedCallback": 1,
+  "enableDisableCommandsRemoteOnly": 1,
+  "isRemoteBrowser": 1,
+  "sameProcessAsFrameLoader": 1,
+  "webNavigation": 1,
+};
+
+for (let name in descriptors) {
+  if (skipDescriptors[name]) {
+    continue;
+  }
+  // if (name != "finder") {
+  //   continue;
+  // }
+  let descriptor = descriptors[name];
+  let newDescriptor = Object.assign({}, descriptor);
+  if (typeof descriptor.value == "function") {
+    newDescriptor.value = wrap(descriptor.value, name);
+  }
+  if (typeof descriptor.get == "function") {
+    newDescriptor.get = wrap(descriptor.get, name);
+  }
+  if (typeof descriptor.set == "function") {
+    newDescriptor.set = wrap(descriptor.set, name);
+  }
+
+  Object.defineProperty(MozBrowser.prototype, name, newDescriptor);
+}
+
+
+
 MozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIObserver, Ci.nsIBrowser]);
 customElements.define("browser", MozBrowser);
 
 }
