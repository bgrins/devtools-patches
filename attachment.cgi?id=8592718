# HG changeset patch
# User Sami Jaktholm <sjakthol@outlook.com>
# Date 1428136941 -10800
#      Sat Apr 04 11:42:21 2015 +0300
# Node ID 3ce5921a213672dc3e17c4d51558e6ae213da3d4
# Parent  886d14f69d7203aa0b415f59cfa86cf4d4449505
Bug 1148893 - Clean up browser_styleeditor_autocomplete.js and split disabled autocomplete test into separate file.

diff --git a/browser/devtools/styleeditor/test/browser.ini b/browser/devtools/styleeditor/test/browser.ini
--- a/browser/devtools/styleeditor/test/browser.ini
+++ b/browser/devtools/styleeditor/test/browser.ini
@@ -43,16 +43,17 @@ support-files =
   sourcemaps-watching.html
   test_private.css
   test_private.html
   doc_uncached.css
   doc_uncached.html
   doc_xulpage.xul
 
 [browser_styleeditor_autocomplete.js]
+[browser_styleeditor_autocomplete-disabled.js]
 [browser_styleeditor_bug_740541_iframes.js]
 skip-if = os == "linux" || "mac" # bug 949355
 [browser_styleeditor_bug_851132_middle_click.js]
 [browser_styleeditor_bug_870339.js]
 [browser_styleeditor_cmd_edit.js]
 skip-if = e10s # Bug 1055333 - style editor tests disabled with e10s
 [browser_styleeditor_enabled.js]
 [browser_styleeditor_fetch-from-cache.js]
diff --git a/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete-disabled.js b/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete-disabled.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete-disabled.js
@@ -0,0 +1,26 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Test that autocomplete can be disabled.
+
+const TESTCASE_URI = TEST_BASE_HTTP + "autocomplete.html";
+
+// Pref which decides if CSS autocompletion is enabled in Style Editor or not.
+const AUTOCOMPLETION_PREF = "devtools.styleeditor.autocompletion-enabled";
+
+add_task(function* () {
+  Services.prefs.setBoolPref(AUTOCOMPLETION_PREF, false);
+  let { ui } = yield openStyleEditorForURL(TESTCASE_URI);
+  let editor = yield ui.editors[0].getSourceEditor();
+
+  is(editor.sourceEditor.getOption("autocomplete"), false,
+     "Autocompletion option does not exist");
+  ok(!editor.sourceEditor.getAutocompletionPopup(),
+     "Autocompletion popup does not exist");
+});
+
+registerCleanupFunction(() => {
+  Services.prefs.clearUserPref(AUTOCOMPLETION_PREF);
+});
diff --git a/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js b/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js
--- a/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js
+++ b/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js
@@ -1,25 +1,18 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
 
-///////////////////
-//
-// Whitelisting this test.
-// As part of bug 1077403, the leaking uncaught rejection should be fixed. 
-//
-thisTestLeaksUncaughtRejectionsAndShouldBeFixed("Error: Unknown sheet source");
+// Test that autocompletion works as expected.
 
 const TESTCASE_URI = TEST_BASE_HTTP + "autocomplete.html";
 const MAX_SUGGESTIONS = 15;
 
-// Pref which decides if CSS autocompletion is enabled in Style Editor or not.
-const AUTOCOMPLETION_PREF = "devtools.styleeditor.autocompletion-enabled";
-
 const {CSSProperties, CSSValues} = getCSSKeywords();
 
 // Test cases to test that autocompletion works correctly when enabled.
 // Format:
 // [
 //   key,
 //   {
 //     total: Number of suggestions in the popup (-1 if popup is closed),
@@ -82,45 +75,31 @@ let TEST_CASES = [
   ['VK_RIGHT'],
   ['VK_RIGHT'],
   ['VK_RIGHT'],
   ['VK_RIGHT'],
   ['VK_RIGHT'],
   ['Ctrl+Space', {total: 1, current: 0}],
 ];
 
-let gEditor;
-let gPopup;
-let index = 0;
+add_task(function* () {
+  let { panel, ui } = yield openStyleEditorForURL(TESTCASE_URI);
+  let editor = yield ui.editors[0].getSourceEditor();
+  let sourceEditor = editor.sourceEditor;
+  let popup = sourceEditor.getAutocompletionPopup();
 
-function test()
-{
-  waitForExplicitFinish();
+  yield SimpleTest.promiseFocus(panel.panelWindow);
 
-  addTabAndOpenStyleEditors(1, testEditorAdded);
+  for (let index in TEST_CASES) {
+    yield testState(index, sourceEditor, popup, panel.panelWindow);
+    yield checkState(index, sourceEditor, popup);
+  }
+});
 
-  content.location = TESTCASE_URI;
-}
-
-function testEditorAdded(panel) {
-  info("Editor added, getting the source editor and starting tests");
-  panel.UI.editors[0].getSourceEditor().then(editor => {
-    info("source editor found, starting tests.");
-    gEditor = editor.sourceEditor;
-    gPopup = gEditor.getAutocompletionPopup();
-    waitForFocus(testState, gPanelWindow);
-  });
-}
-
-function testState() {
-  if (index == TEST_CASES.length) {
-    testAutocompletionDisabled();
-    return;
-  }
-
+function testState(index, sourceEditor, popup, panelWindow) {
   let [key, details] = TEST_CASES[index];
   let entered;
   if (details) {
     entered = details.entered;
   }
   let mods = {};
 
   info("pressing key " + key + " to get result: " +
@@ -131,90 +110,64 @@ function testState() {
   if (key == 'Ctrl+Space') {
     key = " ";
     mods.ctrlKey = true;
   }
   else if (key == "VK_RETURN" && entered) {
     evt = "popup-hidden";
   }
   else if (/(left|right|return|home|end)/ig.test(key) ||
-           (key == "VK_DOWN" && !gPopup.isOpen)) {
+           (key == "VK_DOWN" && !popup.isOpen)) {
     evt = "cursorActivity";
   }
   else if (key == "VK_TAB" || key == "VK_UP" || key == "VK_DOWN") {
     evt = "suggestion-entered";
   }
 
-  gEditor.once(evt, checkState);
-  EventUtils.synthesizeKey(key, mods, gPanelWindow);
+  let ready = sourceEditor.once(evt);
+  EventUtils.synthesizeKey(key, mods, panelWindow);
+
+  return ready;
 }
 
-function checkState() {
+function checkState(index, sourceEditor, popup) {
+  let deferred = promise.defer();
   executeSoon(() => {
     let [key, details] = TEST_CASES[index];
     details = details || {};
     let {total, current, inserted} = details;
 
     if (total != undefined) {
-      ok(gPopup.isOpen, "Popup is open for index " + index);
-      is(total, gPopup.itemCount,
+      ok(popup.isOpen, "Popup is open for index " + index);
+      is(total, popup.itemCount,
          "Correct total suggestions for index " + index);
-      is(current, gPopup.selectedIndex,
+      is(current, popup.selectedIndex,
          "Correct index is selected for index " + index);
       if (inserted) {
-        let { preLabel, label, text } = gPopup.getItemAtIndex(current);
-        let { line, ch } = gEditor.getCursor();
-        let lineText = gEditor.getText(line);
+        let { preLabel, label, text } = popup.getItemAtIndex(current);
+        let { line, ch } = sourceEditor.getCursor();
+        let lineText = sourceEditor.getText(line);
         is(lineText.substring(ch - text.length, ch), text,
            "Current suggestion from the popup is inserted into the editor.");
       }
     }
     else {
-      ok(!gPopup.isOpen, "Popup is closed for index " + index);
+      ok(!popup.isOpen, "Popup is closed for index " + index);
       if (inserted) {
-        let { preLabel, label, text } = gPopup.getItemAtIndex(current);
-        let { line, ch } = gEditor.getCursor();
-        let lineText = gEditor.getText(line);
+        let { preLabel, label, text } = popup.getItemAtIndex(current);
+        let { line, ch } = sourceEditor.getCursor();
+        let lineText = sourceEditor.getText(line);
         is(lineText.substring(ch - text.length, ch), text,
            "Current suggestion from the popup is inserted into the editor.");
       }
     }
-    index++;
-    testState();
+    deferred.resolve();
   });
-}
 
-function testAutocompletionDisabled() {
-  gBrowser.removeCurrentTab();
-
-  index = 0;
-  info("Starting test to check if autocompletion is disabled correctly.")
-  Services.prefs.setBoolPref(AUTOCOMPLETION_PREF, false);
-
-  addTabAndOpenStyleEditors(1, testEditorAddedDisabled);
-
-  content.location = TESTCASE_URI;
-}
-
-function testEditorAddedDisabled(panel) {
-  info("Editor added, getting the source editor and starting tests");
-  panel.UI.editors[0].getSourceEditor().then(editor => {
-    is(editor.sourceEditor.getOption("autocomplete"), false,
-       "Autocompletion option does not exist");
-    ok(!editor.sourceEditor.getAutocompletionPopup(),
-       "Autocompletion popup does not exist");
-    cleanup();
-  });
-}
-
-function cleanup() {
-  Services.prefs.clearUserPref(AUTOCOMPLETION_PREF);
-  gEditor = null;
-  gPopup = null;
-  finish();
+  return deferred.promise;
 }
 
 /**
  * Returns a list of all property names and a map of property name vs possible
  * CSS values provided by the Gecko engine.
  *
  * @return {Object} An object with following properties:
  *         - CSSProperties {Array} Array of string containing all the possible
