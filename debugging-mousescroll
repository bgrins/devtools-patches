# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7207a6e375fbe90a1bbf90f4f2572d04344e6868

diff --git a/toolkit/content/widgets/arrowscrollbox.js b/toolkit/content/widgets/arrowscrollbox.js
--- a/toolkit/content/widgets/arrowscrollbox.js
+++ b/toolkit/content/widgets/arrowscrollbox.js
@@ -71,22 +71,22 @@
             this.sample.bind(this)
           );
         },
       };
 
       this._scrollIndex = 0;
       this._scrollIncrement = null;
       this._ensureElementIsVisibleAnimationFrame = 0;
-      this._prevMouseScrolls = [null, null];
       this._touchStart = -1;
       this._scrollButtonUpdatePending = false;
       this._isScrolling = false;
       this._destination = 0;
       this._direction = 0;
+      this._prevMouseScrolls = [null, null];
 
       this.addEventListener("wheel", this.on_wheel);
       this.addEventListener("touchstart", this.on_touchstart);
       this.addEventListener("touchmove", this.on_touchmove);
       this.addEventListener("touchend", this.on_touchend);
       this.addEventListener("click", this.on_click);
       this.addEventListener("mousedown", this.on_mousedown);
       this.addEventListener("mouseover", this.on_mouseover);
@@ -94,24 +94,26 @@
       this.addEventListener("mouseout", this.on_mouseout);
 
       // These events don't get retargeted outside of the shadow root, but
       // some callers like tests wait for these events. So run handlers
       // and then retarget events from the scrollbox to host.F
       this.scrollbox.addEventListener(
         "underflow",
         event => {
+          console.log("UNderflow");
           this.on_underflow(event);
           this.dispatchEvent(new Event("underflow"));
         },
         true
       );
       this.scrollbox.addEventListener(
         "overflow",
         event => {
+          console.log("Overflow");
           this.on_overflow(event);
           this.dispatchEvent(new Event("overflow"));
         },
         true
       );
       this.scrollbox.addEventListener("scroll", event => {
         this.on_scroll(event);
         this.dispatchEvent(new Event("scroll"));
@@ -264,16 +266,17 @@
       if (this._clickToScroll) {
         this._pauseScroll();
       } else {
         this._stopScroll();
       }
     }
 
     _boundsWithoutFlushing(element) {
+      return element.getBoundingClientRect();
       if (!("_DOMWindowUtils" in this)) {
         this._DOMWindowUtils = window.windowUtils;
       }
 
       return this._DOMWindowUtils
         ? this._DOMWindowUtils.getBoundsWithoutFlushing(element)
         : element.getBoundingClientRect();
     }
@@ -298,17 +301,17 @@
 
       if (this._ensureElementIsVisibleAnimationFrame) {
         window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);
       }
       this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(
         () => {
           element.scrollIntoView({
             block: "nearest",
-            behavior: aInstant ? "instant" : "auto",
+            behavior: "instant",
           });
           this._ensureElementIsVisibleAnimationFrame = 0;
         }
       );
     }
 
     scrollByIndex(index, aInstant) {
       if (index == 0) {
@@ -561,22 +564,22 @@
 
       if (this._scrollButtonUpdatePending) {
         return;
       }
       this._scrollButtonUpdatePending = true;
 
       // Wait until after the next paint to get current layout data from
       // getBoundsWithoutFlushing.
-      window.requestAnimationFrame(() => {
-        setTimeout(() => {
-          if (!this.isConnected) {
-            // We've been destroyed in the meantime.
-            return;
-          }
+      // // window.requestAnimationFrame(() => {
+      // //   setTimeout(() => {
+      //     if (!this.isConnected) {
+      //       // We've been destroyed in the meantime.
+      //       return;
+      //     }
 
           this._scrollButtonUpdatePending = false;
 
           let scrolledToStart = false;
           let scrolledToEnd = false;
 
           if (this.hasAttribute("notoverflowing")) {
             scrolledToStart = true;
@@ -622,29 +625,30 @@
             this.removeAttribute("scrolledtoend");
           }
 
           if (scrolledToStart) {
             this.setAttribute("scrolledtostart", "true");
           } else {
             this.removeAttribute("scrolledtostart");
           }
-        }, 0);
-      });
+      //   }, 0);
+      // });
     }
 
     disconnectedCallback() {
       // Release timer to avoid reference cycles.
       if (this._scrollTimer) {
         this._scrollTimer.cancel();
         this._scrollTimer = null;
       }
     }
 
     on_wheel(event) {
+      console.log("wheel", this.hasAttribute("notoverflowing"), this.scrollX, event.deltaX, event.deltaY);
       // Don't consume the event if we can't scroll.
       if (this.hasAttribute("notoverflowing")) {
         return;
       }
 
       let doScroll = false;
       let instant;
       let scrollAmount = 0;
