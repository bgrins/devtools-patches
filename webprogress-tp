# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a82db11776c36e4459d90e36615ee15943946811
Try to detect a tab switch differently from a reload

diff --git a/browser/base/content/browser-trackingprotection.js b/browser/base/content/browser-trackingprotection.js
--- a/browser/base/content/browser-trackingprotection.js
+++ b/browser/base/content/browser-trackingprotection.js
@@ -2,16 +2,17 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 let TrackingProtection = {
   PREF_ENABLED_GLOBALLY: "privacy.trackingprotection.enabled",
   PREF_ENABLED_IN_PRIVATE_WINDOWS: "privacy.trackingprotection.pbmode.enabled",
   enabledGlobally: false,
   enabledInPrivateWindows: false,
+  _loadingSpec: null,
 
   init() {
     let $ = selector => document.querySelector(selector);
     this.container = $("#tracking-protection-container");
     this.content = $("#tracking-protection-content");
     this.icon = $("#tracking-protection-icon");
 
     this.updateEnabled();
@@ -47,21 +48,34 @@ let TrackingProtection = {
   get enabledHistogram() {
     return Services.telemetry.getHistogramById("TRACKING_PROTECTION_ENABLED");
   },
 
   get eventsHistogram() {
     return Services.telemetry.getHistogramById("TRACKING_PROTECTION_EVENTS");
   },
 
-  onSecurityChange(state) {
+  onSecurityChange(state, request) {
     if (!this.enabled) {
       return;
     }
 
+    // Only animate the shield on an actual request (not on a tab switch).
+    // On a tab switch, a single securityChange is fired without a request.
+    // On an actual request, we get two securityChange calls.  The first
+    // has a request, and the second doesn't.  And we don't want to cancel
+    // the animation when the second securityChange fires.
+    let spec = gBrowser.currentURI.spec;
+    if (request) {
+      this._loadingSpec = spec;
+      this.icon.setAttribute("animate", "true");
+    } else if (spec != this._loadingSpec) {
+      this.icon.removeAttribute("animate");
+    }
+
     let {
       STATE_BLOCKED_TRACKING_CONTENT, STATE_LOADED_TRACKING_CONTENT
     } = Ci.nsIWebProgressListener;
 
     for (let element of [this.icon, this.content]) {
       if (state & STATE_BLOCKED_TRACKING_CONTENT) {
         element.setAttribute("state", "blocked-tracking-content");
       } else if (state & STATE_LOADED_TRACKING_CONTENT) {
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -4399,17 +4399,17 @@ var XULBrowserWindow = {
     // Make sure the "https" part of the URL is striked out or not,
     // depending on the current mixed active content blocking state.
     gURLBar.formatValue();
 
     try {
       uri = Services.uriFixup.createExposableURI(uri);
     } catch (e) {}
     gIdentityHandler.checkIdentity(this._state, uri);
-    TrackingProtection.onSecurityChange(this._state);
+    TrackingProtection.onSecurityChange(this._state, aRequest);
   },
 
   // simulate all change notifications after switching tabs
   onUpdateCurrentBrowser: function XWB_onUpdateCurrentBrowser(aStateFlags, aStatus, aMessage, aTotalProgress) {
     if (FullZoom.updateBackgroundTabs)
       FullZoom.onLocationChange(gBrowser.currentURI, true);
     var nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
     var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
@@ -6823,27 +6823,27 @@ var gIdentityHandler = {
       this.setMode(this.IDENTITY_MODE_UNKNOWN);
     }
 
     // Show the doorhanger when:
     // - mixed active content is blocked
     // - mixed active content is loaded (detected but not blocked)
     // - tracking content is blocked
     // - tracking content is not blocked
-    if (state &
-        (nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT |
-         nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT  |
-         nsIWebProgressListener.STATE_BLOCKED_TRACKING_CONTENT     |
-         nsIWebProgressListener.STATE_LOADED_TRACKING_CONTENT)) {
-      this.showBadContentDoorhanger(state);
-    } else if (TrackingProtection.enabled) {
-      // We didn't show the shield
-      Services.telemetry.getHistogramById("TRACKING_PROTECTION_SHIELD")
-        .add(0);
-    }
+    // if (state &
+    //     (nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT |
+    //      nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT  |
+    //      nsIWebProgressListener.STATE_BLOCKED_TRACKING_CONTENT     |
+    //      nsIWebProgressListener.STATE_LOADED_TRACKING_CONTENT)) {
+    //   this.showBadContentDoorhanger(state);
+    // } else if (TrackingProtection.enabled) {
+    //   // We didn't show the shield
+    //   Services.telemetry.getHistogramById("TRACKING_PROTECTION_SHIELD")
+    //     .add(0);
+    // }
   },
 
   showBadContentDoorhanger : function(state) {
     var currentNotification =
       PopupNotifications.getNotification("bad-content",
         gBrowser.selectedBrowser);
 
     // Avoid showing the same notification (same state) repeatedly.
diff --git a/browser/base/content/test/general/browser.ini b/browser/base/content/test/general/browser.ini
--- a/browser/base/content/test/general/browser.ini
+++ b/browser/base/content/test/general/browser.ini
@@ -417,16 +417,18 @@ support-files =
   benignPage.html
 [browser_trackingUI_2.js]
 tags = trackingprotection
 support-files =
   trackingPage.html
   benignPage.html
 [browser_trackingUI_3.js]
 tags = trackingprotection
+[browser_trackingUI_4.js]
+tags = trackingprotection
 support-files =
   trackingPage.html
   benignPage.html
 [browser_typeAheadFind.js]
 skip-if = buildapp == 'mulet'
 [browser_unknownContentType_title.js]
 [browser_unloaddialogs.js]
 skip-if = e10s # Bug 1100700 - test relies on unload event firing on closed tabs, which it doesn't
diff --git a/browser/base/content/test/general/browser_trackingUI_1.js b/browser/base/content/test/general/browser_trackingUI_1.js
--- a/browser/base/content/test/general/browser_trackingUI_1.js
+++ b/browser/base/content/test/general/browser_trackingUI_1.js
@@ -28,17 +28,18 @@ registerCleanupFunction(function() {
     gBrowser.removeCurrentTab();
   }
 });
 
 function hidden(sel) {
   let win = browser.ownerGlobal;
   let el = win.document.querySelector(sel);
   let display = win.getComputedStyle(el).getPropertyValue("display", null);
-  return display === "none";
+  let opacity = win.getComputedStyle(el).getPropertyValue("opacity", null);
+  return display === "none" || opacity === "0";
 }
 
 function clickButton(sel) {
   let win = browser.ownerGlobal;
   let el = win.document.querySelector(sel);
   el.doCommand();
 }
 
diff --git a/browser/base/content/test/general/browser_trackingUI_3.js b/browser/base/content/test/general/browser_trackingUI_3.js
--- a/browser/base/content/test/general/browser_trackingUI_3.js
+++ b/browser/base/content/test/general/browser_trackingUI_3.js
@@ -5,18 +5,16 @@
 // Test that the Tracking Protection is correctly enabled / disabled
 // in both normal and private windows given all possible states of the prefs:
 //   privacy.trackingprotection.enabled
 //   privacy.trackingprotection.pbmode.enabled
 // See also Bug 1178985.
 
 const PREF = "privacy.trackingprotection.enabled";
 const PB_PREF = "privacy.trackingprotection.pbmode.enabled";
-const BENIGN_PAGE = "http://tracking.example.org/browser/browser/base/content/test/general/benignPage.html";
-const TRACKING_PAGE = "http://tracking.example.org/browser/browser/base/content/test/general/trackingPage.html";
 
 registerCleanupFunction(function() {
   Services.prefs.clearUserPref(PREF);
   Services.prefs.clearUserPref(PB_PREF);
 });
 
 add_task(function* testNormalBrowsing() {
   let browser = gBrowser;
diff --git a/browser/base/content/test/general/browser_trackingUI_4.js b/browser/base/content/test/general/browser_trackingUI_4.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser_trackingUI_4.js
@@ -0,0 +1,141 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Test that the Tracking Protection icon is properly animated in the identity
+// block when loading tabs and switching between tabs.
+// See also Bug 1175858.
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+const PREF = "privacy.trackingprotection.enabled";
+const PB_PREF = "privacy.trackingprotection.pbmode.enabled";
+const BENIGN_PAGE = "http://tracking.example.org/browser/browser/base/content/test/general/benignPage.html";
+const TRACKING_PAGE = "http://tracking.example.org/browser/browser/base/content/test/general/trackingPage.html";
+let TrackingProtection = null;
+let browser = null;
+
+let {UrlClassifierTestUtils} = Cu.import("resource://testing-common/UrlClassifierTestUtils.jsm", {});
+
+registerCleanupFunction(function() {
+  TrackingProtection = browser = null;
+  UrlClassifierTestUtils.cleanupTestTrackers();
+  Services.prefs.clearUserPref(PREF);
+  Services.prefs.clearUserPref(PB_PREF);
+  while (gBrowser.tabs.length > 1) {
+    gBrowser.removeCurrentTab();
+  }
+});
+
+function hidden(sel) {
+  let win = browser.ownerGlobal;
+  let el = win.document.querySelector(sel);
+  let display = win.getComputedStyle(el).getPropertyValue("display", null);
+  let opacity = win.getComputedStyle(el).getPropertyValue("opacity", null);
+  return display === "none" || opacity === "0";
+}
+
+function clickButton(sel) {
+  let win = browser.ownerGlobal;
+  let el = win.document.querySelector(sel);
+  el.doCommand();
+}
+
+function testBenignPage() {
+  info("Non-tracking content must not be blocked");
+  ok (!TrackingProtection.container.hidden, "The container is visible");
+  ok (!TrackingProtection.content.hasAttribute("state"), "content: no state");
+  ok (!TrackingProtection.icon.hasAttribute("state"), "icon: no state");
+
+  ok (hidden("#tracking-protection-icon"), "icon is hidden");
+  ok (hidden("#tracking-action-block"), "blockButton is hidden");
+  ok (hidden("#tracking-action-unblock"), "unblockButton is hidden");
+
+  // Make sure that the no tracking elements message appears
+  ok (!hidden("#tracking-not-detected"), "labelNoTracking is visible");
+  ok (hidden("#tracking-loaded"), "labelTrackingLoaded is hidden");
+  ok (hidden("#tracking-blocked"), "labelTrackingBlocked is hidden");
+
+  // Icon animation state
+  is (TrackingProtection._loadingSpec, BENIGN_PAGE, "TP is keeping track of correct URL");
+}
+
+function testTrackingPage(window) {
+  info("Tracking content must be blocked");
+  ok (!TrackingProtection.container.hidden, "The container is visible");
+  is (TrackingProtection.content.getAttribute("state"), "blocked-tracking-content",
+      'content: state="blocked-tracking-content"');
+  is (TrackingProtection.icon.getAttribute("state"), "blocked-tracking-content",
+      'icon: state="blocked-tracking-content"');
+
+  ok (!hidden("#tracking-protection-icon"), "icon is visible");
+  ok (hidden("#tracking-action-block"), "blockButton is hidden");
+
+
+  if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+    ok(hidden("#tracking-action-unblock"), "unblockButton is hidden");
+    ok(!hidden("#tracking-action-unblock-private"), "unblockButtonPrivate is visible");
+  } else {
+    ok(!hidden("#tracking-action-unblock"), "unblockButton is visible");
+    ok(hidden("#tracking-action-unblock-private"), "unblockButtonPrivate is hidden");
+  }
+
+  // Make sure that the blocked tracking elements message appears
+  ok (hidden("#tracking-not-detected"), "labelNoTracking is hidden");
+  ok (hidden("#tracking-loaded"), "labelTrackingLoaded is hidden");
+  ok (!hidden("#tracking-blocked"), "labelTrackingBlocked is visible");
+
+  // Icon animation state
+  is (TrackingProtection._loadingSpec, TRACKING_PAGE, "TP is keeping track of correct URL");
+}
+
+function* testTrackingProtectionForTab(tab) {
+  info("Load a test page not containing tracking elements");
+  yield promiseTabLoadEvent(tab, BENIGN_PAGE);
+  testBenignPage();
+
+  info("Load a test page containing tracking elements");
+  yield promiseTabLoadEvent(tab, TRACKING_PAGE);
+  testTrackingPage(tab.ownerDocument.defaultView);
+}
+
+add_task(function* testNormalBrowsing() {
+  yield UrlClassifierTestUtils.addTestTrackers();
+
+  browser = gBrowser;
+  let tab = browser.selectedTab = browser.addTab();
+
+  TrackingProtection = gBrowser.ownerGlobal.TrackingProtection;
+  ok (TrackingProtection, "TP is attached to the browser window");
+  is (TrackingProtection.enabled, Services.prefs.getBoolPref(PREF),
+    "TP.enabled is based on the original pref value");
+
+  Services.prefs.setBoolPref(PREF, true);
+  ok (TrackingProtection.enabled, "TP is enabled after setting the pref");
+
+  yield testTrackingProtectionForTab(tab);
+
+  Services.prefs.setBoolPref(PREF, false);
+  ok (!TrackingProtection.enabled, "TP is disabled after setting the pref");
+});
+
+add_task(function* testPrivateBrowsing() {
+  let privateWin = yield promiseOpenAndLoadWindow({private: true}, true);
+  browser = privateWin.gBrowser;
+  let tab = browser.selectedTab = browser.addTab();
+
+  TrackingProtection = browser.ownerGlobal.TrackingProtection;
+  ok (TrackingProtection, "TP is attached to the private window");
+  is (TrackingProtection.enabled, Services.prefs.getBoolPref(PB_PREF),
+    "TP.enabled is based on the pb pref value");
+
+  Services.prefs.setBoolPref(PB_PREF, true);
+  ok (TrackingProtection.enabled, "TP is enabled after setting the pref");
+
+  yield testTrackingProtectionForTab(tab);
+
+  Services.prefs.setBoolPref(PB_PREF, false);
+  ok (!TrackingProtection.enabled, "TP is disabled after setting the pref");
+
+  yield new Promise(() => {});
+  privateWin.close();
+});
diff --git a/browser/themes/shared/identity-block/identity-block.inc.css b/browser/themes/shared/identity-block/identity-block.inc.css
--- a/browser/themes/shared/identity-block/identity-block.inc.css
+++ b/browser/themes/shared/identity-block/identity-block.inc.css
@@ -67,24 +67,27 @@
 
 /* TRACKING PROTECTION ICON */
 
 #tracking-protection-icon {
   width: 16px;
   height: 16px;
   list-style-image: url(chrome://browser/skin/tracking-protection-16.svg);
   margin-left: 0;
-  transition: margin-left 200ms ease-out;
   opacity: 1;
 }
 
 #tracking-protection-icon[state="loaded-tracking-content"] {
   list-style-image: url(chrome://browser/skin/tracking-protection-disabled-16.svg);
 }
 
+#tracking-protection-icon[animate] {
+  transition: margin-left 200ms ease-out;
+}
+
 #tracking-protection-icon:not([state]) {
   margin-left: -16px;
   pointer-events: none;
   opacity: 0;
   /* Only animate the shield in, when it disappears hide it immediately. */
   transition: none;
 }
 
