
# HG changeset patch
# User Alexander Surkov <surkov.alexander@gmail.com>
# Date 1549644409 18000
# Node ID 6bd519d805b5fbd034afb471a8ee2301afdde95e
# Parent  7ebcd074e346adf4ba6ddf835ee0ff8951398a2f
Bug 1519533 - convert formautofill autocomplete-profile-listitem bindings to CE, r=MattN

diff --git a/browser/extensions/formautofill/FormAutofillParent.jsm b/browser/extensions/formautofill/FormAutofillParent.jsm
--- a/browser/extensions/formautofill/FormAutofillParent.jsm
+++ b/browser/extensions/formautofill/FormAutofillParent.jsm
@@ -26,16 +26,17 @@
  */
 
 "use strict";
 
 // We expose a singleton from this module. Some tests may import the
 // constructor via a backstage pass.
 var EXPORTED_SYMBOLS = ["formAutofillParent"];
 
+const {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const {XPCOMUtils} = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const {FormAutofill} = ChromeUtils.import("resource://formautofill/FormAutofill.jsm");
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   CreditCard: "resource://gre/modules/CreditCard.jsm",
@@ -96,22 +97,24 @@ FormAutofillParent.prototype = {
   get initialized() {
     return this._initialized;
   },
 
   /**
    * Initializes FormAutofillStorage and registers the message handler.
    */
   async init() {
+    console.log(`FormAutofillStorage init, is initialized: ${this._initialized}`);
     if (this._initialized) {
       return;
     }
     this._initialized = true;
 
     Services.obs.addObserver(this, "privacy-pane-loaded");
+    Services.obs.addObserver(this, "document-element-inserted");
     Services.ppmm.addMessageListener("FormAutofill:InitStorage", this);
     Services.ppmm.addMessageListener("FormAutofill:GetRecords", this);
     Services.ppmm.addMessageListener("FormAutofill:SaveAddress", this);
     Services.ppmm.addMessageListener("FormAutofill:RemoveAddresses", this);
     Services.ppmm.addMessageListener("FormAutofill:OpenPreferences", this);
     Services.mm.addMessageListener("FormAutofill:OnFormSubmit", this);
 
     // Observing the pref and storage changes
@@ -120,30 +123,52 @@ FormAutofillParent.prototype = {
 
     // Only listen to credit card related messages if it is available
     if (FormAutofill.isAutofillCreditCardsAvailable) {
       Services.ppmm.addMessageListener("FormAutofill:SaveCreditCard", this);
       Services.ppmm.addMessageListener("FormAutofill:RemoveCreditCards", this);
       Services.ppmm.addMessageListener("FormAutofill:GetDecryptedString", this);
       Services.prefs.addObserver(ENABLED_AUTOFILL_CREDITCARDS_PREF, this);
     }
+
+    for (let win of BrowserWindowTracker.orderedWindows) {
+      this.injectElements(win.document);
+    }
+  },
+
+  injectElements(doc) {
+    console.log('loading customElements.js and formautofill.js scripts');
+    Services.scriptloader.loadSubScript(
+      "chrome://global/content/customElements.js", doc.ownerGlobal
+    );
+    Services.scriptloader.loadSubScript(
+      "chrome://formautofill/content/formautofill.js", doc.ownerGlobal
+    );
   },
 
   observe(subject, topic, data) {
     log.debug("observe:", topic, "with data:", data);
     switch (topic) {
       case "privacy-pane-loaded": {
         let formAutofillPreferences = new FormAutofillPreferences();
         let document = subject.document;
         let prefFragment = formAutofillPreferences.init(document);
         let formAutofillGroupBox = document.getElementById("formAutofillGroupBox");
         formAutofillGroupBox.appendChild(prefFragment);
         break;
       }
 
+      case "document-element-inserted": {
+        console.log(`document-element-inserted for ${subject.documentURI}`);
+        if (subject.documentURI == AppConstants.BROWSER_CHROME_URL) {
+          this.injectElements(subject);
+        }
+        break;
+      }
+
       case "nsPref:changed": {
         // Observe pref changes and update _active cache if status is changed.
         this._updateStatus();
         break;
       }
 
       case "formautofill-storage-changed": {
         // Early exit if only metadata is changed
diff --git a/browser/extensions/formautofill/content/formautofill.css b/browser/extensions/formautofill/content/formautofill.css
--- a/browser/extensions/formautofill/content/formautofill.css
+++ b/browser/extensions/formautofill/content/formautofill.css
@@ -6,33 +6,19 @@
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-footer"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-insecureWarning"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-clear-button"] {
   display: block;
   margin: 0;
   padding: 0;
   height: auto;
   min-height: auto;
-}
-
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-profile"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem");
+  -moz-binding: none;
 }
 
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-footer"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-footer");
-}
-
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-insecureWarning"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-creditcard-insecure-field");
-}
-
-#PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-clear-button"] {
-  -moz-binding: url("chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-clear-button");
-}
 /* Treat @collpased="true" as display: none similar to how it is for XUL elements.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#Values */
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-profile"][collapsed="true"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-footer"][collapsed="true"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-insecureWarning"][collapsed="true"],
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="autofill-clear-button"][collapsed="true"] {
   display: none;
 }
diff --git a/browser/extensions/formautofill/content/formautofill.xml b/browser/extensions/formautofill/content/formautofill.js
rename from browser/extensions/formautofill/content/formautofill.xml
rename to browser/extensions/formautofill/content/formautofill.js
--- a/browser/extensions/formautofill/content/formautofill.xml
+++ b/browser/extensions/formautofill/content/formautofill.js
@@ -1,354 +1,360 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-<bindings id="formautofillBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:html="http://www.w3.org/1999/xhtml"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:xbl="http://www.mozilla.org/xbl">
+// This file is loaded into the browser window scope.
+/* eslint-env mozilla/browser-window */
+/* eslint-disable mozilla/balanced-listeners */ // Not relevant since the document gets unloaded.
+
+"use strict";
+
+// Wrap in a block to prevent leaking to window scope.
+(() => {
+  console.log(`formautofill.js loading`);
+  const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 
-  <binding id="autocomplete-profile-listitem-base" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-      </constructor>
-      <!-- For form autofill, we want to unify the selection no matter by
-      keyboard navigation or mouseover in order not to confuse user which
-      profile preview is being shown. This field is set to true to indicate
-      that selectedIndex of popup should be changed while mouseover item -->
-      <field name="selectedByMouseOver">true</field>
+  class MozAutocompleteProfileListitemBase extends MozElements.MozRichlistitem {
+    constructor() {
+      console.log(`MozAutocompleteProfileListitemBase created`);
+      super();
 
-      <property name="_stringBundle">
-        <getter><![CDATA[
-          /* global Services */
-          if (!this.__stringBundle) {
-            this.__stringBundle = Services.strings.createBundle("chrome://formautofill/locale/formautofill.properties");
-          }
-          return this.__stringBundle;
-        ]]></getter>
-      </property>
+      /**
+       * For form autofill, we want to unify the selection no matter by
+       * keyboard navigation or mouseover in order not to confuse user which
+       * profile preview is being shown. This field is set to true to indicate
+       * that selectedIndex of popup should be changed while mouseover item
+       */
+      this.selectedByMouseOver = true;
+    }
+
+    get _stringBundle() {
+      if (!this.__stringBundle) {
+        this.__stringBundle = Services.strings.createBundle(
+        "chrome://formautofill/locale/formautofill.properties"
+      );
+      }
+      return this.__stringBundle;
+    }
 
-      <method name="_cleanup">
-        <body>
-        <![CDATA[
-          this.removeAttribute("formautofillattached");
-          if (this._itemBox) {
-            this._itemBox.removeAttribute("size");
-          }
-        ]]>
-        </body>
-      </method>
+    _cleanup() {
+      this.removeAttribute("formautofillattached");
+      if (this._itemBox) {
+        this._itemBox.removeAttribute("size");
+      }
+    }
 
-      <method name="_onOverflow">
-        <body></body>
-      </method>
+    _onOverflow() {}
+
+    _onUnderflow() {}
 
-      <method name="_onUnderflow">
-        <body></body>
-      </method>
+    handleOverUnderflow() {}
 
-      <method name="handleOverUnderflow">
-        <body></body>
-      </method>
+    _adjustAutofillItemLayout() {
+      let outerBoxRect = this.parentNode.getBoundingClientRect();
 
-      <method name="_adjustAutofillItemLayout">
-        <body>
-        <![CDATA[
-          let outerBoxRect = this.parentNode.getBoundingClientRect();
+    // Make item fit in popup as XUL box could not constrain
+    // item's width
+      this._itemBox.style.width = outerBoxRect.width + "px";
+    // Use two-lines layout when width is smaller than 150px or
+    // 185px if an image precedes the label.
+      let oneLineMinRequiredWidth = this.getAttribute("ac-image") ? 185 : 150;
 
-          // Make item fit in popup as XUL box could not constrain
-          // item's width
-          this._itemBox.style.width = outerBoxRect.width + "px";
-          // Use two-lines layout when width is smaller than 150px or
-          // 185px if an image precedes the label.
-          let oneLineMinRequiredWidth = this.getAttribute("ac-image") ? 185 : 150;
+      if (outerBoxRect.width <= oneLineMinRequiredWidth) {
+        this._itemBox.setAttribute("size", "small");
+      } else {
+        this._itemBox.removeAttribute("size");
+      }
+    }
+  }
 
-          if (outerBoxRect.width <= oneLineMinRequiredWidth) {
-            this._itemBox.setAttribute("size", "small");
-          } else {
-            this._itemBox.removeAttribute("size");
-          }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-  </binding>
+  MozElements.MozAutocompleteProfileListitem = class MozAutocompleteProfileListitem extends MozAutocompleteProfileListitemBase {
+    connectedCallback() {
+      console.log('MozAutocompleteProfileListitem connected');
+      if (this.delayConnectedCallback()) {
+        return;
+      }
 
-  <binding id="autocomplete-profile-listitem" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-item-box" class="autofill-item-box" xbl:inherits="ac-image">
-        <div class="profile-label-col profile-item-col">
-          <span anonid="profile-label-affix" class="profile-label-affix"></span>
-          <span anonid="profile-label" class="profile-label"></span>
-        </div>
-        <div class="profile-comment-col profile-item-col">
-          <span anonid="profile-comment" class="profile-comment"></span>
-        </div>
-      </div>
-    </xbl:content>
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+        <html:div class="autofill-item-box">
+          <html:div class="profile-label-col profile-item-col">
+            <html:span class="profile-label-affix"></html:span>
+            <html:span class="profile-label"></html:span>
+          </html:div>
+          <html:div class="profile-comment-col profile-item-col">
+            <html:span class="profile-comment"></html:span>
+          </html:div>
+        </html:div>
+      `));
+
+      this._itemBox = this.querySelector(".autofill-item-box");
+      this._labelAffix = this.querySelector(".profile-label-affix");
+      this._label = this.querySelector(".profile-label");
+      this._comment = this.querySelector(".profile-comment");
 
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-        <![CDATA[
-          this._itemBox = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-item-box"
-          );
-          this._labelAffix = document.getAnonymousElementByAttribute(
-            this, "anonid", "profile-label-affix"
-          );
-          this._label = document.getAnonymousElementByAttribute(
-            this, "anonid", "profile-label"
-          );
-          this._comment = document.getAnonymousElementByAttribute(
-            this, "anonid", "profile-comment"
-          );
+      this._updateAttributes();
+      this._adjustAcItem();
+    }
+
+    static get observedAttributes() {
+      return [
+        "ac-image",
+      ];
+    }
 
-          this._adjustAcItem();
-        ]]>
-      </constructor>
+    attributeChangedCallback(name, oldValue, newValue) {
+      if (this.isConnectedAndReady && name == "ac-image" && oldValue != newValue) {
+        this._updateAttributes();
+      }
+    }
+
+    _updateAttributes() {
+      this.inheritAttribute(this._itemBox, "ac-image");
+    }
 
-      <property name="selected" onget="return this.getAttribute('selected') == 'true';">
-        <setter><![CDATA[
-          /* global Cu */
-          if (val) {
-            this.setAttribute("selected", "true");
-          } else {
-            this.removeAttribute("selected");
-          }
+    set selected(val) {
+      if (val) {
+        this.setAttribute("selected", "true");
+      } else {
+        this.removeAttribute("selected");
+      }
 
-          let {AutoCompletePopup} = ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
+      let {AutoCompletePopup} =
+        ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
+      AutoCompletePopup.sendMessageToBrowser("FormAutofill:PreviewProfile");
 
-          AutoCompletePopup.sendMessageToBrowser("FormAutofill:PreviewProfile");
-
-          return val;
-        ]]></setter>
-      </property>
+      return val;
+    }
 
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
-          this._itemBox.style.setProperty("--primary-icon", `url(${this.getAttribute("ac-image")})`);
+    get selected() {
+      return this.getAttribute("selected") == "true";
+    }
+
+    _adjustAcItem() {
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
+      this._itemBox.style.setProperty("--primary-icon", `url(${this.getAttribute("ac-image")})`);
 
-          let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute("ac-value"));
+      let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute("ac-value"));
 
-          this._labelAffix.textContent = primaryAffix;
-          this._label.textContent = primary;
-          this._comment.textContent = secondary;
-        ]]>
-        </body>
-      </method>
-    </implementation>
-  </binding>
+      this._labelAffix.textContent = primaryAffix;
+      this._label.textContent = primary;
+      this._comment.textContent = secondary;
+    }
+  };
 
-  <binding id="autocomplete-profile-listitem-footer" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-footer" class="autofill-item-box autofill-footer">
-        <div anonid="autofill-warning" class="autofill-footer-row autofill-warning">
-        </div>
-        <div anonid="autofill-option-button" class="autofill-footer-row autofill-button">
-        </div>
-      </div>
-    </xbl:content>
+  customElements.define(
+    "autocomplete-profile-listitem",
+    MozElements.MozAutocompleteProfileListitem,
+    {extends: "richlistitem"}
+  );
 
-    <handlers>
-      <handler event="click" button="0"><![CDATA[
+  class MozAutocompleteProfileListitemFooter extends MozAutocompleteProfileListitemBase {
+    constructor() {
+      super();
+
+      this.addEventListener("click", (event) => {
+        if (event.button != 0) {
+          return;
+        }
+
         if (this._warningTextBox.contains(event.originalTarget)) {
           return;
         }
 
         window.openPreferences("privacy-form-autofill", {origin: "autofillFooter"});
-      ]]></handler>
-    </handlers>
+      });
+    }
 
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-        <![CDATA[
-          this._itemBox = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-footer"
-          );
-          this._optionButton = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-option-button"
-          );
-          this._warningTextBox = document.getAnonymousElementByAttribute(
-            this, "anonid", "autofill-warning"
-          );
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
 
-          /**
-           * A handler for updating warning message once selectedIndex has been changed.
-           *
-           * There're three different states of warning message:
-           * 1. None of addresses were selected: We show all the categories intersection of fields in the
-           *    form and fields in the results.
-           * 2. An address was selested: Show the additional categories that will also be filled.
-           * 3. An address was selected, but the focused category is the same as the only one category: Only show
-           * the exact category that we're going to fill in.
-           *
-           * @private
-           * @param {string[]} data.categories
-           *        The categories of all the fields contained in the selected address.
-           */
-          this._updateWarningNote = ({data} = {}) => {
-            let categories = (data && data.categories) ? data.categories : this._allFieldCategories;
-            // If the length of categories is 1, that means all the fillable fields are in the same
-            // category. We will change the way to inform user according to this flag. When the value
-            // is true, we show "Also autofills ...", otherwise, show "Autofills ..." only.
-            let hasExtraCategories = categories.length > 1;
-            // Show the categories in certain order to conform with the spec.
-            let orderedCategoryList = [{id: "address", l10nId: "category.address"},
-                                       {id: "name", l10nId: "category.name"},
-                                       {id: "organization", l10nId: "category.organization2"},
-                                       {id: "tel", l10nId: "category.tel"},
-                                       {id: "email", l10nId: "category.email"}];
-            let showCategories = hasExtraCategories ?
-              orderedCategoryList.filter(category => categories.includes(category.id) && category.id != this._focusedCategory) :
-              [orderedCategoryList.find(category => category.id == this._focusedCategory)];
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+        <html:div class="autofill-item-box autofill-footer">
+          <html:div class="autofill-footer-row autofill-warning"></html:div>
+          <html:div class="autofill-footer-row autofill-button"></html:div>
+        </html:div>
+      `));
+
+      this._itemBox = this.querySelector(".autofill-footer");
+      this._optionButton = this.querySelector(".autofill-button");
+      this._warningTextBox = this.querySelector(".autofill-warning");
 
-            let separator = this._stringBundle.GetStringFromName("fieldNameSeparator");
-            let warningTextTmplKey = hasExtraCategories ? "phishingWarningMessage" : "phishingWarningMessage2";
-            let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(category.l10nId)).join(separator);
-
-            this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey,
-              [categoriesText], 1);
-            this.parentNode.parentNode.adjustHeight();
-          };
+      /**
+       * A handler for updating warning message once selectedIndex has been changed.
+       *
+       * There're three different states of warning message:
+       * 1. None of addresses were selected: We show all the categories intersection of fields in the
+       *    form and fields in the results.
+       * 2. An address was selested: Show the additional categories that will also be filled.
+       * 3. An address was selected, but the focused category is the same as the only one category: Only show
+       * the exact category that we're going to fill in.
+       *
+       * @private
+       * @param {string[]} data.categories
+       *        The categories of all the fields contained in the selected address.
+       */
+      this._updateWarningNote = ({data} = {}) => {
+        let categories = (data && data.categories) ? data.categories : this._allFieldCategories;
+        // If the length of categories is 1, that means all the fillable fields are in the same
+        // category. We will change the way to inform user according to this flag. When the value
+        // is true, we show "Also autofills ...", otherwise, show "Autofills ..." only.
+        let hasExtraCategories = categories.length > 1;
+        // Show the categories in certain order to conform with the spec.
+        let orderedCategoryList = [{id: "address", l10nId: "category.address"},
+        {id: "name", l10nId: "category.name"},
+        {id: "organization", l10nId: "category.organization2"},
+        {id: "tel", l10nId: "category.tel"},
+        {id: "email", l10nId: "category.email"},
+        ];
+        let showCategories = hasExtraCategories ?
+            orderedCategoryList.filter(category => categories.includes(category.id) && category.id != this._focusedCategory) :
+            [orderedCategoryList.find(category => category.id == this._focusedCategory)];
 
-          this._adjustAcItem();
-        ]]>
-      </constructor>
-
-      <method name="_onCollapse">
-        <body>
-        <![CDATA[
-          /* global messageManager */
-
-          if (this.showWarningText) {
-            messageManager.removeMessageListener("FormAutofill:UpdateWarningMessage", this._updateWarningNote);
-          }
+        let separator = this._stringBundle.GetStringFromName("fieldNameSeparator");
+        let warningTextTmplKey = hasExtraCategories ? "phishingWarningMessage" : "phishingWarningMessage2";
+        let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(category.l10nId)).join(separator);
 
-          this._itemBox.removeAttribute("no-warning");
-        ]]>
-        </body>
-      </method>
+        this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey, [categoriesText], 1);
+        this.parentNode.parentNode.adjustHeight();
+      };
+
+      this._adjustAcItem();
+    }
 
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          /* global Cu */
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
+    _onCollapse() {
+      /* global messageManager */
+      if (this.showWarningText) {
+        messageManager.removeMessageListener(
+          "FormAutofill:UpdateWarningMessage", this._updateWarningNote
+        );
+      }
+      this._itemBox.removeAttribute("no-warning");
+    }
 
-          let {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
-          // TODO: The "Short" suffix is pointless now as normal version string is no longer needed,
-          // we should consider removing the suffix if possible when the next time locale change.
-          let buttonTextBundleKey = AppConstants.platform == "macosx" ?
-            "autocompleteFooterOptionOSXShort" : "autocompleteFooterOptionShort";
-          let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);
-          this._optionButton.textContent = buttonText;
+    _adjustAcItem() {
+      /* global Cu */
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
 
-          let value = JSON.parse(this.getAttribute("ac-value"));
+      let {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm", {});
+      // TODO: The "Short" suffix is pointless now as normal version string is no longer needed,
+      // we should consider removing the suffix if possible when the next time locale change.
+      let buttonTextBundleKey = AppConstants.platform == "macosx" ?
+      "autocompleteFooterOptionOSXShort" : "autocompleteFooterOptionShort";
+      let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);
+      this._optionButton.textContent = buttonText;
 
-          this._allFieldCategories = value.categories;
-          this._focusedCategory = value.focusedCategory;
-          this.showWarningText = this._allFieldCategories && this._focusedCategory;
+      let value = JSON.parse(this.getAttribute("ac-value"));
+
+      this._allFieldCategories = value.categories;
+      this._focusedCategory = value.focusedCategory;
+      this.showWarningText = this._allFieldCategories && this._focusedCategory;
 
-          if (this.showWarningText) {
-            messageManager.addMessageListener("FormAutofill:UpdateWarningMessage", this._updateWarningNote);
+      if (this.showWarningText) {
+        messageManager.addMessageListener("FormAutofill:UpdateWarningMessage", this._updateWarningNote);
+        this._updateWarningNote();
+      } else {
+        this._itemBox.setAttribute("no-warning", "true");
+      }
+    }
+  }
 
-            this._updateWarningNote();
-          } else {
-            this._itemBox.setAttribute("no-warning", "true");
-          }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-  </binding>
-
-  <binding id="autocomplete-creditcard-insecure-field" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-item-box" class="autofill-insecure-item">
-      </div>
-    </xbl:content>
+  customElements.define(
+    "autocomplete-profile-listitem-footer",
+    MozAutocompleteProfileListitemFooter,
+    {extends: "richlistitem"}
+  );
 
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-      <![CDATA[
-        this._itemBox = document.getAnonymousElementByAttribute(
-          this, "anonid", "autofill-item-box"
-        );
+  class MozAutocompleteCreditcardInsecureField extends MozAutocompleteProfileListitemBase {
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+        <html:div class="autofill-insecure-item"></html:div>
+      `));
 
-        this._adjustAcItem();
-      ]]>
-      </constructor>
+      this._itemBox = this.querySelector(".autofill-insecure-item");
+
+      this._adjustAcItem();
+    }
 
-      <property name="selected" onget="return this.getAttribute('selected') == 'true';">
-        <setter><![CDATA[
-          // Make this item unselectable since we see this item as a pure message.
-          return false;
-        ]]></setter>
-      </property>
+    set selected(val) {
+    // Make this item unselectable since we see this item as a pure message.
+      return false;
+    }
+
+    get selected() {
+      return this.getAttribute("selected") == "true";
+    }
 
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
+    _adjustAcItem() {
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
 
-          let value = this.getAttribute("ac-value");
-          this._itemBox.textContent = value;
-        ]]>
-        </body>
-      </method>
+      let value = this.getAttribute("ac-value");
+      this._itemBox.textContent = value;
+    }
+  }
 
-    </implementation>
-  </binding>
+  customElements.define(
+    "autocomplete-creditcard-insecure-field",
+    MozAutocompleteCreditcardInsecureField,
+    {extends: "richlistitem"}
+  );
+
+  class MozAutocompleteProfileListitemClearButton extends MozAutocompleteProfileListitemBase {
+    constructor() {
+      super();
 
-  <binding id="autocomplete-profile-listitem-clear-button" extends="chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base">
-    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
-      <div anonid="autofill-item-box" class="autofill-item-box autofill-footer">
-        <div anonid="autofill-clear-button" class="autofill-footer-row autofill-button"></div>
-      </div>
-    </xbl:content>
+      this.addEventListener("click", (event) => {
+        if (event.button != 0) {
+          return;
+        }
 
-    <handlers>
-      <handler event="click" button="0"><![CDATA[
-        /* global Cu */
-        let {AutoCompletePopup} = ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
+        let {AutoCompletePopup} =
+        ChromeUtils.import("resource://gre/modules/AutoCompletePopup.jsm");
+        AutoCompletePopup.sendMessageToBrowser("FormAutofill:ClearForm");
+      });
+    }
 
-        AutoCompletePopup.sendMessageToBrowser("FormAutofill:ClearForm");
-      ]]></handler>
-    </handlers>
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
 
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-      <![CDATA[
-        this._itemBox = document.getAnonymousElementByAttribute(
-          this, "anonid", "autofill-item-box"
-        );
-        this._clearBtn = document.getAnonymousElementByAttribute(
-          this, "anonid", "autofill-clear-button"
-        );
+      this.textContent = "";
+      this.appendChild(MozXULElement.parseXULToFragment(`
+        <html:div class="autofill-item-box autofill-footer">
+          <html:div class="autofill-footer-row autofill-button"></html:div>
+        </html:div>
+      `));
 
-        this._adjustAcItem();
-      ]]>
-      </constructor>
+      this._itemBox = this.querySelector(".autofill-item-box");
+      this._clearBtn = this.querySelector(".autofill-button");
+
+      this._adjustAcItem();
+    }
 
-      <method name="_adjustAcItem">
-        <body>
-        <![CDATA[
-          this._adjustAutofillItemLayout();
-          this.setAttribute("formautofillattached", "true");
+    _adjustAcItem() {
+      this._adjustAutofillItemLayout();
+      this.setAttribute("formautofillattached", "true");
 
-          let clearFormBtnLabel = this._stringBundle.GetStringFromName("clearFormBtnLabel2");
-          this._clearBtn.textContent = clearFormBtnLabel;
-        ]]>
-        </body>
-      </method>
+      let clearFormBtnLabel =
+      this._stringBundle.GetStringFromName("clearFormBtnLabel2");
+      this._clearBtn.textContent = clearFormBtnLabel;
+    }
+  }
 
-    </implementation>
-  </binding>
-
-</bindings>
+  customElements.define(
+    "autocomplete-profile-listitem-clear-button",
+    MozAutocompleteProfileListitemClearButton,
+    {extends: "richlistitem"}
+  );
+  console.log(`formautofill.js loaded`);
+})();
diff --git a/browser/extensions/formautofill/test/browser/head.js b/browser/extensions/formautofill/test/browser/head.js
--- a/browser/extensions/formautofill/test/browser/head.js
+++ b/browser/extensions/formautofill/test/browser/head.js
@@ -201,16 +201,19 @@ async function focusAndWaitForFieldsIden
 async function expectPopupOpen(browser) {
   info("expectPopupOpen");
   const {autoCompletePopup} = browser;
   await BrowserTestUtils.waitForCondition(() => autoCompletePopup.popupOpen,
                                           "popup should be open");
   await BrowserTestUtils.waitForCondition(() => {
     const listItemElems = getDisplayedPopupItems(browser);
     return [...listItemElems].length > 0 && [...listItemElems].every(item => {
+      info(
+        `item; originaltype: ${item.getAttribute("originaltype")}, formautofillattached: ${item.hasAttribute("formautofillattached")}`
+      );
       return (item.getAttribute("originaltype") == "autofill-profile" ||
              item.getAttribute("originaltype") == "autofill-insecureWarning" ||
              item.getAttribute("originaltype") == "autofill-footer") &&
              item.hasAttribute("formautofillattached");
     });
   }, "The popup should be a form autofill one");
 }
 
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -1051,27 +1051,34 @@
                 !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
             }
 
             // If no reusable item available, then create a new item.
             if (!reusable) {
               let options = null;
               switch (style) {
                 case "autofill-profile":
+                  options = { is: "autocomplete-profile-listitem" };
+                  break;
                 case "autofill-footer":
+                  options = { is: "autocomplete-profile-listitem-footer" };
+                  break;
                 case "autofill-clear-button":
+                  options = { is: "autocomplete-profile-listitem-clear-button" };
+                  break;
                 case "autofill-insecureWarning":
-                  // implemented via XBL bindings, no CE for them
+                  options = { is: "autocomplete-creditcard-insecure-field" };
                   break;
                 case "insecureWarning":
                   options = { is: "autocomplete-richlistitem-insecure-warning" };
                   break;
                 default:
                   options = { is: "autocomplete-richlistitem" };
               }
+              console.log(`create autocomplete richlistitem: ${options.is}`);
               item = document.createXULElement("richlistitem", options);
               item.className = "autocomplete-richlistitem";
             }
 
             item.setAttribute("dir", this.style.direction);
             item.setAttribute("ac-image", image);
             item.setAttribute("ac-value", value);
             item.setAttribute("ac-label", label);
@@ -1102,16 +1109,19 @@
             }
 
             if (reusable) {
               // Adjust only when the result's type is reusable for existing
               // item's. Otherwise, we might insensibly call old _adjustAcItem()
               // as new binding has not been attached yet.
               // We don't need to worry about switching to new binding, since
               // _adjustAcItem() will fired by its own constructor accordingly.
+              if (!item._adjustAcItem) {
+                console.log(item.outerHTML);
+              }
               item._adjustAcItem();
               item.collapsed = false;
             } else if (itemExists) {
               let oldItem = this.richlistbox.children[this._currentIndex];
               this.richlistbox.replaceChild(item, oldItem);
             } else {
               this.richlistbox.appendChild(item);
             }

