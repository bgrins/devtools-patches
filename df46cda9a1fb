
# HG changeset patch
# User Nick Alexander <nalexander@mozilla.com>
# Date 1499793856 25200
# Node ID df46cda9a1fbaddfe8be8422cac0bf92e0a4c497
# Parent  f1d4e27a8ff869902f006dc18314869d3f3b621c
Bug 1384241 - Frontend changes for integration with mach watch

MozReview-Commit-ID: AoQUnwoajV5

diff --git a/browser/base/content/browser-sets.inc b/browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc
+++ b/browser/base/content/browser-sets.inc
@@ -11,16 +11,18 @@
 
   <stringbundleset id="stringbundleset">
     <stringbundle id="bundle_brand" src="chrome://branding/locale/brand.properties"/>
     <stringbundle id="bundle_shell" src="chrome://browser/locale/shellservice.properties"/>
     <stringbundle id="bundle_preferences" src="chrome://browser/locale/preferences/preferences.properties"/>
   </stringbundleset>
 
   <commandset id="mainCommandSet">
+    <command id="cmd_quickRestart" oncommand="QuickRestart()"/>
+    <command id="cmd_quickReload" oncommand="QuickReload()"/>
     <command id="cmd_newNavigator" oncommand="OpenBrowserWindow()"/>
     <command id="cmd_handleBackspace" oncommand="BrowserHandleBackspace();" />
     <command id="cmd_handleShiftBackspace" oncommand="BrowserHandleShiftBackspace();" />
 
     <command id="cmd_newNavigatorTab" oncommand="BrowserOpenTab(event);"/>
     <command id="cmd_newNavigatorTabNoEvent" oncommand="BrowserOpenTab();"/>
     <command id="Browser:OpenFile"  oncommand="BrowserOpenFileWindow();"/>
     <command id="Browser:SavePage" oncommand="saveBrowser(gBrowser.selectedBrowser);"/>
@@ -190,16 +192,26 @@
                  label="&pageSourceCmd.label;"
                  key="key_viewSource"
                  command="View:PageSource">
       <observes element="canViewSource" attribute="disabled"/>
     </broadcaster>
   </broadcasterset>
 
   <keyset id="mainKeyset">
+    <key id="key_quickRestart"
+         key="R"
+         command="cmd_quickRestart"
+         modifiers="accel,alt"
+    />
+    <key id="key_quickReload"
+         key="R"
+         command="cmd_quickReload"
+         modifiers="accel,alt,shift"
+    />
     <key id="key_newNavigator"
          key="&newNavigatorCmd.key;"
          command="cmd_newNavigator"
          modifiers="accel" reserved="true"/>
     <key id="key_newNavigatorTab" key="&tabCmd.commandkey;" modifiers="accel"
          command="cmd_newNavigatorTabNoEvent" reserved="true"/>
     <key id="focusURLBar" key="&openCmd.commandkey;" command="Browser:OpenLocation"
          modifiers="accel"/>
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -4160,16 +4160,60 @@ function toOpenWindowByType(inType, uri,
   if (topWindow)
     topWindow.focus();
   else if (features)
     window.open(uri, "_blank", features);
   else
     window.open(uri, "_blank", "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar");
 }
 
+function QuickRestart() {
+  Services.obs.notifyObservers(null, "startupcache-invalidate");
+  let canceled = Cc["@mozilla.org/supports-PRBool;1"]
+      .createInstance(Ci.nsISupportsPRBool);
+
+  Services.obs.notifyObservers(canceled, "quit-application-requested", "restart");
+
+  if (canceled.data) return false;
+
+  Cc['@mozilla.org/toolkit/app-startup;1'].getService(Ci.nsIAppStartup)
+      .quit(Ci.nsIAppStartup.eAttemptQuit | Ci.nsIAppStartup.eRestart);
+}
+
+function QuickReload() {
+  // window.location.reload() has problems (on at least Mac OS X) with
+  // the title bar, so instead let's make a new window and transfer
+  // this window's session state into that window.
+
+  const ss = Cc["@mozilla.org/browser/sessionstore;1"].getService(Ci.nsISessionStore);
+  let stateString = ss.getWindowState(window);
+
+  // Replacement window.
+  let next = OpenBrowserWindow({suppressanimation: true});
+
+  // Arrange for replacement window to get this windows session state.
+  let delayedStartupObserver = aSubject => {
+    if (aSubject == next) {
+      Services.obs.removeObserver(delayedStartupObserver, "browser-delayed-startup-finished");
+      ss.setWindowState(next, stateString, /* overwriteTabs */ true);
+
+      // We move by a few pixels so that it's clear that something has
+      // happened.  The window features are restored on the next tick,
+      // so we have to wait in order to move the window.
+      next.setTimeout(() => {
+        next.moveBy(10, 10);
+      }, 0);
+
+      // Fairly abruptly close this window.
+      closeWindow(true);
+    }
+  };
+  Services.obs.addObserver(delayedStartupObserver, "browser-delayed-startup-finished");
+}
+
 function OpenBrowserWindow(options) {
   var telemetryObj = {};
   TelemetryStopwatch.start("FX_NEW_WINDOW_MS", telemetryObj);
 
   function newDocumentShown(doc, topic, data) {
     if (topic == "document-shown" &&
         doc != document &&
         doc.defaultView == win) {
@@ -4212,17 +4256,17 @@ function OpenBrowserWindow(options) {
     extraFeatures += ",remote";
   } else if (options && options.remote === false) {
     extraFeatures += ",non-remote";
   }
 
   // If the window is maximized, we want to skip the animation, since we're
   // going to be taking up most of the screen anyways, and we want to optimize
   // for showing the user a useful window as soon as possible.
-  if (window.windowState == window.STATE_MAXIMIZED) {
+  if (window.windowState == window.STATE_MAXIMIZED || (options && options.suppressanimation)) {
     extraFeatures += ",suppressanimation";
   }
 
   // if and only if the current window is a browser window and it has a document with a character
   // set, then extract the current charset menu setting from the current document and use it to
   // initialize the new browser window...
   var win;
   if (window && (wintype == "navigator:browser") && window.content && window.content.document) {
diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -14,17 +14,17 @@ Cu.import("resource://gre/modules/Servic
 Cu.import("resource://gre/modules/AppConstants.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "WindowsUIUtils", "@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils");
 XPCOMUtils.defineLazyGetter(this, "WeaveService", () =>
   Cc["@mozilla.org/weave/service;1"].getService().wrappedJSObject
 );
 XPCOMUtils.defineLazyModuleGetter(this, "ContextualIdentityService",
                                   "resource://gre/modules/ContextualIdentityService.jsm");
-
+XPCOMUtils.defineLazyModuleGetter(this, "console", "resource://gre/modules/Console.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "SafeBrowsing",
                                   "resource://gre/modules/SafeBrowsing.jsm");
 
 // lazy module getters
 
 /* global AboutHome:false, AboutNewTab:false, AddonManager:false, AppMenuNotifications:false,
           AsyncPrefs: false, AsyncShutdown:false, AutoCompletePopup:false, BookmarkHTMLUtils:false,
           BookmarkJSONUtils:false, BrowserUITelemetry:false, BrowserUsageTelemetry:false,
@@ -614,16 +614,17 @@ BrowserGlue.prototype = {
     this._distributionCustomizer.applyCustomizations();
 
     // handle any UI migration
     this._migrateUI();
 
     listeners.init();
 
     SessionStore.init();
+    DevRefresher.init();
 
     if (AppConstants.INSTALL_COMPACT_THEMES) {
       let vendorShortName = gBrandBundle.GetStringFromName("vendorShortName");
 
       LightweightThemeManager.addBuiltInTheme({
         id: "firefox-compact-light@mozilla.org",
         name: gBrowserBundle.GetStringFromName("compactLightTheme.name"),
         description: gBrowserBundle.GetStringFromName("compactLightTheme.description"),
@@ -2866,8 +2867,201 @@ this.NSGetFactory = XPCOMUtils.generateN
 
 // Listen for UITour messages.
 // Do it here instead of the UITour module itself so that the UITour module is lazy loaded
 // when the first message is received.
 var globalMM = Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
 globalMM.addMessageListener("UITour:onPageEvent", function(aMessage) {
   UITour.onPageEvent(aMessage, aMessage.data);
 });
+
+
+var DevRefresher = {
+  resolveURIToLocalPath(aURI) {
+    let resolved;
+    switch (aURI.scheme) {
+      case "jar":
+      case "file":
+        return aURI;
+
+      case "chrome":
+        resolved = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                   getService(Ci.nsIChromeRegistry).convertChromeURL(aURI);
+        return this.resolveURIToLocalPath(resolved);
+
+      case "resource":
+        resolved = Cc["@mozilla.org/network/protocol;1?name=resource"].
+                   getService(Ci.nsIResProtocolHandler).resolveURI(aURI);
+        aURI = Services.io.newURI(resolved, null, null);
+        return this.resolveURIToLocalPath(aURI);
+
+      default:
+        return null;
+    }
+  },
+  getLocalPath(url) {
+    let uri = null;
+    let ios = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces["nsIIOService"]);
+    try {
+        uri = this.resolveURIToLocalPath(ios.newURI(url, "UTF-8", null));
+    } catch(e){}
+
+    let ret = null;
+    if (uri) {
+      ret = AppConstants.platform == "win" ? uri.spec.replace(/file:\/\/\//, "") : uri.spec.replace(/file:\/\//, "");
+    }
+    return ret;
+  },
+  iterStyleNodes(window, func) {
+    for (let node of window.document.childNodes) {
+      // Look for ProcessingInstruction nodes.
+      if (node.nodeType === 7) {
+        func(node);
+      }
+    }
+
+    const links = window.document.getElementsByTagNameNS(
+      "http://www.w3.org/1999/xhtml", "link"
+    );
+    for (let node of links) {
+      func(node);
+    }
+  },
+  replaceCSS(window, fileURI) {
+    const document = window.document;
+    const appendRandom = (href) => {
+      return href.split("?s")[0] + `?s=${Math.random()}`;
+    };
+    // console.log("Checking for replacement at:", window.location.toString(), "with: ", fileURI);
+
+    // Scan every CSS tag and reload ones that match the file we are
+    // looking for.
+    this.iterStyleNodes(window, node => {
+      if (node.nodeType === 7) {
+        // xml-stylesheet declaration
+        // Convert a string like href="chrome://browser/content/browser.css" type="text/css" to:
+        // chrome://browser/content/browser.css, then convert it to a local path
+        let originalHref = node.data.match(/href=([^\s]*)/)[1].replace(/["']/g, '')
+        const path = this.getLocalPath(originalHref);
+        // console.log("Looking into PI", "\nhref: " + originalHref, "\npath: " + path, "\nfileURI: " + fileURI);
+        if (path && path.includes(fileURI)) {
+          // Special case chrome://browser/skin/ which does a redircet
+          if (originalHref == "chrome://browser/skin/") {
+            originalHref = "chrome://browser/skin/browser.css";
+          }
+          console.log("Replacing the PI at: ", originalHref);
+          const newNode = window.document.createProcessingInstruction(
+            "xml-stylesheet",
+            `href="${appendRandom(originalHref)}" type="text/css"`
+          );
+          document.insertBefore(newNode, node);
+          document.removeChild(node);
+        }
+      } else {
+        const originalHref = node.href;
+        const path = this.getLocalPath(originalHref);
+        // console.log("Looking into stylesheet", path, fileURI);
+        if (path && path.includes(fileURI)) {
+          console.log("Replacing the stylesheet at: ", originalHref);
+          const parentNode = node.parentNode;
+          const newNode = window.document.createElementNS(
+            "http://www.w3.org/1999/xhtml",
+            "link"
+          );
+          newNode.rel = "stylesheet";
+          newNode.type = "text/css";
+          newNode.href = appendRandom(originalHref);
+
+          parentNode.insertBefore(newNode, node);
+          parentNode.removeChild(node);
+        }
+     }
+    });
+  },
+
+  replaceCSSImports(window, fileURI) {
+    const document = window.document;
+    const appendRandom = (href) => {
+      return href.split("?s")[0] + `?s=${Math.random()}`;
+    };
+    // Only match the filename. False positives are much better than
+    // missing updates, as all that would happen is we reload more
+    // resources than we need. We do this because many resources only
+    // use relative paths.
+    const parts = fileURI.split("/");
+    const file = parts[parts.length - 1];
+
+    // Scan every single rule in the entire page for any reference to
+    // this resource, and re-insert the rule to force it to update.
+    for (let sheet of document.styleSheets) {
+      if (sheet.ownerNode.nodeType === 7) { continue; }
+      for (let i = 0; i < sheet.cssRules.length; i++) {
+        const rule = sheet.cssRules[i];
+        if (rule.type === rule.IMPORT_RULE) {
+          // console.log("Found an import", "\n" + rule.href,  "\n" + this.getLocalPath(rule.href.split("?s")[0]), "\n" + fileURI);
+          // TODO (if nested imports are used) - recurse into the imported sheet
+          if (this.getLocalPath(rule.href.split("?s")[0]) === fileURI) {
+              let newRule = `@import url("${appendRandom(rule.href)}");`;
+              sheet.deleteRule(i);
+              sheet.insertRule(newRule, i);
+          }
+        }
+      }
+    }
+  },
+
+  getAllDocuments(win) {
+    let walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].
+                 createInstance(Ci.inIDeepTreeWalker);
+    walker.showAnonymousContent = true;
+    walker.showSubDocuments = true;
+    walker.showDocumentsAsNodes = true;
+    walker.init(win.document.documentElement, Ci.nsIDOMNodeFilter.SHOW_ELEMENT);
+    let documents = [win.document]
+    while (walker.nextNode()) {
+      if (walker.currentNode.nodeType === 9) {
+        documents.push(walker.currentNode)
+      }
+    }
+    return documents;
+  },
+
+  init() {
+    const watchRoot = this.getLocalPath("resource://").replace(/browser\/$/, '');
+    const ws = new Services.appShell.hiddenDOMWindow.WebSocket('ws://localhost:8080/websocket');
+    console.log("DevRefresher started", this);
+    ws.onopen = (e) => {
+      console.log("On open", e);
+    };
+    ws.onerror = (e) => {
+      console.log("Error connecting to 8080 - is |mach watch| running?", e);
+    };
+    ws.onmessage = (e) => {
+      console.log("On message", e);
+        let data = {};
+        try {
+          data = JSON.parse(e.data);
+        } catch(e) { }
+      if (data.type == "change") {
+        Services.obs.notifyObservers(null, "startupcache-invalidate");
+
+        console.log("Received change");
+        for (let output of data.change.outputs) {
+          const path = watchRoot + output;
+          console.log(`replacing ${path}`);
+          // // This covers extra globals like additional browser windows and the browser toolbox
+          var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                         .getService(Components.interfaces.nsIWindowMediator);
+          var enumerator = wm.getEnumerator(null);
+          while(enumerator.hasMoreElements()) {
+            var win = enumerator.getNext();
+            // This covers extra globals within a window, like devtools frames
+            let allDocuments = this.getAllDocuments(win);
+            for (var i = 0; i < allDocuments.length; i++) {
+              this.replaceCSS(allDocuments[i].defaultView, path);
+              this.replaceCSSImports(allDocuments[i].defaultView, path);
+            }
+          }
+        }
+      }
+    };
+  },
+};
