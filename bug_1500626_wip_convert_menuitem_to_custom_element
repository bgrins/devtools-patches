# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1539992100 25200
#      Fri Oct 19 16:35:00 2018 -0700
# Node ID 7f01f084f6fd7b33dee4649f215ec3283dcdb09c
# Parent  18859d2fec94f35e924e9093a99169623e0b2d78
Bug 1500626 - WIP - convert <menuitem> to Custom Element

Differential Revision: https://phabricator.services.mozilla.com/D9322

diff --git a/browser/components/preferences/browserLanguages.js b/browser/components/preferences/browserLanguages.js
--- a/browser/components/preferences/browserLanguages.js
+++ b/browser/components/preferences/browserLanguages.js
@@ -214,17 +214,19 @@ class SortedItemSelectList {
     items.splice(i, 0, item);
     popup.insertBefore(this.createItem(item), menulist.getItemAtIndex(i));
 
     menulist.disabled = menulist.itemCount == 0;
   }
 
   createItem({label, value, className, disabled}) {
     let item = document.createElement("menuitem");
-    item.value = value;
+    if (value !== undefined) {
+      item.value = value;
+    }
     item.setAttribute("label", label);
     if (className)
       item.classList.add(className);
     if (disabled)
       item.setAttribute("disabled", "true");
     return item;
   }
 
diff --git a/devtools/client/shared/test/browser_tableWidget_mouse_interaction.js b/devtools/client/shared/test/browser_tableWidget_mouse_interaction.js
--- a/devtools/client/shared/test/browser_tableWidget_mouse_interaction.js
+++ b/devtools/client/shared/test/browser_tableWidget_mouse_interaction.js
@@ -193,21 +193,22 @@ var testMouseInteraction = async functio
   // hiding second column
   // event listener for popupshown
   info("right click on the first column header");
   node = table.tbody.firstChild.firstChild.firstChild;
   let onPopupShown = once(table.menupopup, "popupshown");
   click(node, 2);
   await onPopupShown;
 
-  is(table.menupopup.querySelectorAll("[disabled]").length, 1,
+  is(table.menupopup.querySelectorAll("menuitem[disabled]").length, 1,
      "Only 1 menuitem is disabled");
-  is(table.menupopup.querySelector("[disabled]"),
+  is(table.menupopup.querySelector("menuitem[disabled]"),
      table.menupopup.querySelector("[data-id='col1']"),
      "Which is the unique column");
+
   // popup should be open now
   // clicking on second column label
   let onPopupHidden = once(table.menupopup, "popuphidden");
   event = table.once(TableWidget.EVENTS.HEADER_CONTEXT_MENU);
   node = table.menupopup.querySelector("[data-id='col2']");
   info("selecting to hide the second column");
   ok(!table.tbody.children[2].hasAttribute("hidden"),
      "Column is not hidden before hiding it");
@@ -221,17 +222,17 @@ var testMouseInteraction = async functio
   // hiding third column
   // event listener for popupshown
   info("right clicking on the first column header");
   node = table.tbody.firstChild.firstChild.firstChild;
   onPopupShown = once(table.menupopup, "popupshown");
   click(node, 2);
   await onPopupShown;
 
-  is(table.menupopup.querySelectorAll("[disabled]").length, 1,
+  is(table.menupopup.querySelectorAll("menuitem[disabled]").length, 1,
      "Only 1 menuitem is disabled");
   // popup should be open now
   // clicking on second column label
   onPopupHidden = once(table.menupopup, "popuphidden");
   event = table.once(TableWidget.EVENTS.HEADER_CONTEXT_MENU);
   node = table.menupopup.querySelector("[data-id='col3']");
   info("selecting to hide the second column");
   ok(!table.tbody.children[4].hasAttribute("hidden"),
@@ -246,22 +247,22 @@ var testMouseInteraction = async functio
   // opening again to see if 2 items are disabled now
   // event listener for popupshown
   info("right clicking on the first column header");
   node = table.tbody.firstChild.firstChild.firstChild;
   onPopupShown = once(table.menupopup, "popupshown");
   click(node, 2);
   await onPopupShown;
 
-  is(table.menupopup.querySelectorAll("[disabled]").length, 2,
+  is(table.menupopup.querySelectorAll("menuitem[disabled]").length, 2,
      "2 menuitems are disabled now as only 2 columns remain visible");
-  is(table.menupopup.querySelectorAll("[disabled]")[0],
+  is(table.menupopup.querySelectorAll("menuitem[disabled]")[0],
      table.menupopup.querySelector("[data-id='col1']"),
      "First is the unique column");
-  is(table.menupopup.querySelectorAll("[disabled]")[1],
+  is(table.menupopup.querySelectorAll("menuitem[disabled]")[1],
      table.menupopup.querySelector("[data-id='col4']"),
      "Second is the last column");
 
   // showing back 2nd column
   // popup should be open now
   // clicking on second column label
   onPopupHidden = once(table.menupopup, "popuphidden");
   event = table.once(TableWidget.EVENTS.HEADER_CONTEXT_MENU);
diff --git a/toolkit/components/processsingleton/CustomElementsListener.jsm b/toolkit/components/processsingleton/CustomElementsListener.jsm
--- a/toolkit/components/processsingleton/CustomElementsListener.jsm
+++ b/toolkit/components/processsingleton/CustomElementsListener.jsm
@@ -8,15 +8,16 @@ ChromeUtils.import("resource://gre/modul
 // Set up Custom Elements for XUL and XHTML documents before anything else
 // happens. Anything loaded here should be considered part of core XUL functionality.
 // Any window-specific elements can be registered via <script> tags at the
 // top of individual documents.
 Services.obs.addObserver({
   observe(doc) {
     if (doc.nodePrincipal.isSystemPrincipal && (
       doc.contentType == "application/vnd.mozilla.xul+xml" ||
-      doc.contentType == "application/xhtml+xml"
+      doc.contentType == "application/xhtml+xml" ||
+      doc.contentType == "text/html"
     )) {
       Services.scriptloader.loadSubScript(
         "chrome://global/content/customElements.js", doc.ownerGlobal);
     }
   },
 }, "document-element-inserted");
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -55,16 +55,29 @@ const MozElementMixin = Base => class Mo
     gElementsPendingConnection.add(this);
     return true;
   }
 
   get isConnectedAndReady() {
     return gIsDOMContentLoaded && this.isConnected;
   }
 
+  inheritAttribute(child, attrName, attrNewName = attrName) {
+    if (attrNewName === "text") {
+      child.textContent = this.hasAttribute(attrName) ? this.getAttribute(attrName) : "";
+      return;
+    }
+
+    if (this.hasAttribute(attrName)) {
+      child.setAttribute(attrNewName, this.getAttribute(attrName));
+    } else {
+      child.removeAttribute(attrNewName);
+    }
+  }
+
   /**
    * Allows eager deterministic construction of XUL elements with XBL attached, by
    * parsing an element tree and returning a DOM fragment to be inserted in the
    * document before any of the inner elements is referenced by JavaScript.
    *
    * This process is required instead of calling the createElement method directly
    * because bindings get attached when:
    *
@@ -231,27 +244,78 @@ class MozBaseControl extends MozXULEleme
     } else {
       this.removeAttribute("tabindex");
     }
   }
 }
 
 MozXULElement.implementCustomInterface(MozBaseControl, [Ci.nsIDOMXULControlElement]);
 
+class MozBaseText extends MozBaseControl {
+  set label(val) {
+    this.setAttribute("label", val);
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set crop(val) {
+    this.setAttribute("crop", val);
+  }
+
+  get crop() {
+    return this.getAttribute("crop");
+  }
+
+  set image(val) {
+    this.setAttribute("image", val);
+  }
+
+  get image() {
+    return this.getAttribute("image");
+  }
+
+  set command(val) {
+    this.setAttribute("command", val);
+  }
+
+  get command() {
+    return this.getAttribute("command");
+  }
+
+  set accessKey(val) {
+    // Always store on the control
+    this.setAttribute("accesskey", val);
+    // If there is a label, change the accesskey on the labelElement
+    // if it's also set there
+    if (this.labelElement) {
+      this.labelElement.accessKey = val;
+    }
+    return val;
+  }
+
+  get accessKey() {
+    return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+  }
+}
+
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozBaseControl = MozBaseControl;
+window.MozBaseText = MozBaseText;
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
+    "chrome://global/content/elements/menu.js",
     "chrome://global/content/elements/progressmeter.js",
     "chrome://global/content/elements/radio.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -90,18 +90,19 @@ toolkit.jar:
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/findbar.js          (widgets/findbar.js)
-   content/global/elements/editor.js          (widgets/editor.js)
+   content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
+   content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/progressmeter.js    (widgets/progressmeter.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
diff --git a/toolkit/content/tests/chrome/test_menulist_paging.xul b/toolkit/content/tests/chrome/test_menulist_paging.xul
--- a/toolkit/content/tests/chrome/test_menulist_paging.xul
+++ b/toolkit/content/tests/chrome/test_menulist_paging.xul
@@ -1,15 +1,14 @@
 <?xml version="1.0"?>
 <?xml-stylesheet href="chrome://global/skin" type="text/css"?>
 <?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css" type="text/css"?>
 
 <window title="Menulist Tests"
-        onload="setTimeout(startTest, 0);"
-        onpopupshown="menulistShown()" onpopuphidden="runTest()"
+        onload="startTest();"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>      
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>      
 
 <menulist id="menulist1">
   <menupopup id="menulist-popup1">
     <menuitem label="One"/>
@@ -70,89 +69,93 @@
   </menupopup>
 </menulist>
 
 <script class="testbody" type="application/javascript">
 <![CDATA[
 
 SimpleTest.waitForExplicitFinish();
 
-let test;
-
 // Fields:
 //  list - menulist id
 //  initial - initial selected index
 //  scroll - index of item at top of the visible scrolled area, -1 to skip this test
 //  downs - array of indicies that will be selected when pressing down in sequence
 //  ups - array of indicies that will be selected when pressing up in sequence
 let tests = [
   { list: "menulist1", initial: 0, scroll: 0, downs: [3, 6, 9, 9],
                                    ups: [6, 3, 0, 0] },
   { list: "menulist2", initial: 1, scroll: 0, downs: [4, 7, 8, 8],
                                    ups: [5, 2, 1] },
   { list: "menulist3", initial: 1, scroll: -1, downs: [6, 8, 8],
                                    ups: [3, 1, 1] },
-  { list: "menulist4", initial: 5, scroll: 2, downs: [], ups: [] }
+  { list: "menulist4", initial: 5, scroll: 2, downs: [], ups: [] },
 ];
 
-function startTest()
+async function startTest()
 {
   let popup = document.getElementById("menulist-popup1");
+  let shown = new Promise(r => popup.addEventListener("popupshown", r, { once: true }));
+  popup.openPopup();
+  await shown;
   let menupopupHeight = popup.getBoundingClientRect().height;
   let menuitemHeight = popup.firstChild.getBoundingClientRect().height;
+  let hidden = new Promise(r => popup.addEventListener("popuphidden", r, { once: true }));
+  popup.hidePopup();
+  await hidden;
 
   // First, set the height of each popup to the height of four menuitems plus
   // any padding and border on the menupopup.
   let height = menuitemHeight * 4 + (menupopupHeight - menuitemHeight * 10);
-  popup.height = height;
-  document.getElementById("menulist-popup2").height = height;
-  document.getElementById("menulist-popup3").height = height;
-  document.getElementById("menulist-popup4").height = height;
+  for (let menupopup of [...document.querySelectorAll("menupopup")]) {
+    menupopup.height = height;
+  }
 
-  runTest();
+  for (let i = 0; i < tests.length; i++) {
+    await runTest(tests[i]);
+  }
+
+  SimpleTest.finish();
 }
 
-function runTest()
-{
-  if (!tests.length) {
-    SimpleTest.finish();
-    return;
-  }
-
-  test = tests.shift();
-  document.getElementById(test.list).open = true;
-}
-
-function menulistShown()
+async function runTest(test)
 {
   let menulist = document.getElementById(test.list);
+  let menupopup = menulist.menupopup;
+  let shown = new Promise(r => menupopup.addEventListener("popupshown", r, { once: true }));
+  menulist.open = true;
+  await shown;
+
   is(menulist.activeChild.label, menulist.getItemAtIndex(test.initial).label, test.list + " initial selection");
 
-  let cs = window.getComputedStyle(menulist.menupopup);
+  let cs = window.getComputedStyle(menupopup);
   let bpTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
 
   // Skip menulist3 as it has a label that scrolling doesn't need normally deal with.
   if (test.scroll >= 0) {
-    is(menulist.menupopup.childNodes[test.scroll].getBoundingClientRect().top,
-       menulist.menupopup.getBoundingClientRect().top + bpTop,
+    is(menupopup.childNodes[test.scroll].getBoundingClientRect().top,
+       menupopup.getBoundingClientRect().top + bpTop,
        "Popup scroll at correct position");
   }
 
   for (let i = 0; i < test.downs.length; i++) {
     sendKey("PAGE_DOWN");
     is(menulist.activeChild.label, menulist.getItemAtIndex(test.downs[i]).label, test.list + " page down " + i);
   }
 
   for (let i = 0; i < test.ups.length; i++) {
     sendKey("PAGE_UP");
     is(menulist.activeChild.label, menulist.getItemAtIndex(test.ups[i]).label, test.list + " page up " + i);
   }
 
+  let hidden = new Promise(r => menupopup.addEventListener("popuphidden", r, { once: true }));
   menulist.open = false;
+  await hidden;
 }
+
 ]]>
 </script>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
 <p id="display">
 </p>
 <div id="content" style="display: none">
 </div>
diff --git a/toolkit/content/tests/chrome/test_menulist_position.xul b/toolkit/content/tests/chrome/test_menulist_position.xul
--- a/toolkit/content/tests/chrome/test_menulist_position.xul
+++ b/toolkit/content/tests/chrome/test_menulist_position.xul
@@ -37,17 +37,17 @@ function popupShown()
 
   let marginLeft = parseFloat(getComputedStyle(menulist.menupopup).marginLeft);
   ok(isWithinHalfPixel(menurect.left + marginLeft, popuprect.left), "left position");
   ok(isWithinHalfPixel(menurect.right + marginLeft, popuprect.right), "right position");
 
   let index = menulist.selectedIndex;
   if (menulist.selectedItem && navigator.platform.includes("Mac")) {
     let menulistlabel = document.getAnonymousElementByAttribute(menulist, "class", "menulist-label");
-    let mitemlabel = document.getAnonymousElementByAttribute(menulist.selectedItem, "class", "menu-iconic-text");
+    let mitemlabel = menulist.selectedItem.querySelector(".menu-iconic-text");
 
     ok(isWithinHalfPixel(menulistlabel.getBoundingClientRect().left,
                          mitemlabel.getBoundingClientRect().left),
        "Labels horizontally aligned for index " + index);
     ok(isWithinHalfPixel(menulistlabel.getBoundingClientRect().top,
                          mitemlabel.getBoundingClientRect().top),
        "Labels vertically aligned for index " + index);
 
diff --git a/toolkit/content/widgets/menu.js b/toolkit/content/widgets/menu.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/menu.js
@@ -0,0 +1,207 @@
+{
+
+/* globals MozBaseText */
+
+const openPopups = new Set();
+window.addEventListener("popupshowing", (e) => {
+  if (e.originalTarget.ownerDocument != document) {
+    return;
+  }
+  openPopups.add(e.originalTarget);
+  for (let menuitem of e.originalTarget.querySelectorAll("menuitem")) {
+    if (menuitem.render) {
+      menuitem.render();
+    } else {
+      // Let's see if this can happen. if it can (i.e. when inside of XBL anon content),
+      // then we can do customElements.upgrade(menuitem)
+      throw new Error("Can this happen?");
+    }
+  }
+}, { capture: true });
+
+window.addEventListener("popuphidden", (e) => {
+  openPopups.delete(e.originalTarget);
+}, { capture: true });
+
+class MozMenuItemBase extends MozBaseText {
+  set value(val) {
+    this.setAttribute("value", val);
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  get selected() {
+    return this.getAttribute("selected") == "true";
+  }
+
+  get control() {
+    var parent = this.parentNode;
+    if (parent &&
+      parent.parentNode instanceof Ci.nsIDOMXULSelectControlElement)
+      return parent.parentNode;
+    return null;
+  }
+  /**
+   * nsIDOMXULContainerItemElement
+   */
+  get parentContainer() {
+    for (var parent = this.parentNode; parent; parent = parent.parentNode) {
+      if (parent instanceof Ci.nsIDOMXULContainerElement)
+        return parent;
+    }
+    return null;
+  }
+}
+
+MozXULElement.implementCustomInterface(MozMenuItemBase, [Ci.nsIDOMXULSelectControlItemElement, Ci.nsIDOMXULContainerItemElement]);
+
+class MozMenuItem extends MozMenuItemBase {
+
+  // static get observedAttributes() {
+  //   return ["label", "crop", "accesskey", "highlightable"];
+  // }
+
+  attributeChangedCallback() {
+    if (!this.isConnectedAndReady) {
+      return;
+    }
+
+    this.inheritAttributes();
+  }
+
+  get isInsideOpenPopup() {
+    for (let popup of openPopups) {
+      if (popup.contains(this)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  connectedCallback() {
+    return;
+
+    // We typically don't want to eagerly render (instead wait for the
+    // popup to be shown). But if this is selected, we'll want it to render
+    // so the preview text shows properly in the menulist.
+    // XXX: why? this can be seen on the font size dropdown on about:preferences
+    if (!this.isInsideOpenPopup) {
+      return;
+    }
+
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    this.render();
+  }
+
+  inheritAttributes() {
+    if (!this.renderedOnce) {
+      return;
+    }
+
+    if (this.menuText) {
+      this.inheritAttribute(this.menuText, "label", "value");
+      this.inheritAttribute(this.menuText, "crop");
+      this.inheritAttribute(this.menuText, "accesskey");
+      this.inheritAttribute(this.menuText, "highlightable");
+    }
+
+    if (this.menuHighlightableText) {
+      this.inheritAttribute(this.menuText, "label", "text");
+      this.inheritAttribute(this.menuText, "crop");
+      this.inheritAttribute(this.menuText, "accesskey");
+      this.inheritAttribute(this.menuText, "highlightable");
+    }
+
+    if (this.menuAccel) {
+      this.inheritAttribute(this.menuAccel, "acceltext", "value");
+    }
+
+    if (this.menuIconContainer) {
+      this.inheritAttribute(this.menuIconContainer, "selected");
+      // XXX: is this safe for both variations?
+      this.inheritAttribute(this.menuIconContainer, "_moz-menuactive");
+      this.inheritAttribute(this.menuIconContainer, "disabled");
+      this.inheritAttribute(this.menuIconContainer, "checked");
+    }
+
+    if (this.menuIcon) {
+      this.inheritAttribute(this.menuIcon, "image", "src");
+      this.inheritAttribute(this.menuIcon, "validate");
+      this.inheritAttribute(this.menuIcon, "iconloadingprincipal", "triggeringprincipal");
+      // XXX: Can we remove this? https://searchfox.org/mozilla-central/search?q=menuitem.*src&case=false&regexp=true&path=
+      if (this.hasAttribute("src")) {
+        this.inheritAttribute(this.menuIcon, "src");
+      }
+    }
+  }
+
+  get isIconic() {
+    return this.matches(`menuitem[type="checkbox"], menuitem[type="radio"], menuitem.menuitem-iconic`);
+  }
+
+  get isIconicNoAccel() {
+    return this.matches("menulist > menupopup > menuitem");
+  }
+
+  render() {
+    return;
+    if (this.renderedOnce) {
+      return;
+    }
+    this.renderedOnce = true;
+    if (this.isIconicNoAccel) {
+      this.append(MozXULElement.parseXULToFragment(`
+        <hbox class="menu-iconic-left" align="center" pack="center">
+          <image class="menu-iconic-icon"/>
+        </hbox>
+        <label class="menu-iconic-text" flex="1" crop="right"/>
+        <label class="menu-iconic-highlightable-text" crop="right"/>
+      `));
+      this.menuText = this.querySelector(".menu-iconic-text");
+      this.menuIconContainer = this.querySelector(".menu-iconic-left");
+      this.menuIcon = this.querySelector(".menu-iconic-icon");
+      this.menuHighlightableText = this.querySelector(".menu-iconic-highlightable-text");
+    } else if (this.isIconic) {
+      this.prepend(MozXULElement.parseXULToFragment(`
+        <hbox class="menu-iconic-left" align="center" pack="center">
+          <image class="menu-iconic-icon"/>
+        </hbox>
+        <label class="menu-iconic-text" flex="1" crop="right"/>
+        <label class="menu-iconic-highlightable-text" crop="right"/>
+      `));
+      this.append(MozXULElement.parseXULToFragment(`
+        <hbox class="menu-accel-container">
+          <label class="menu-iconic-accel" inherits="value=acceltext"/>
+        </hbox>
+      `));
+      this.menuText = this.querySelector(".menu-iconic-text");
+      this.menuHighlightableText = this.querySelector(".menu-iconic-highlightable-text");
+      this.menuAccel = this.querySelector(".menu-iconic-accel");
+      this.menuIconContainer = this.querySelector(".menu-iconic-left");
+      this.menuIcon = this.querySelector(".menu-iconic-icon");
+    } else {
+      this.append(MozXULElement.parseXULToFragment(`
+        <label class="menu-text" crop="right"/>
+        <hbox class="menu-accel-container">
+          <label class="menu-accel"/>
+        </hbox>
+      `));
+      this.menuText = this.querySelector(".menu-text");
+      this.menuAccel = this.querySelector(".menu-accel");
+    }
+
+    this.inheritAttributes();
+  }
+}
+
+customElements.define("menuitem", MozMenuItem);
+
+}
diff --git a/toolkit/content/widgets/menu.xml b/toolkit/content/widgets/menu.xml
--- a/toolkit/content/widgets/menu.xml
+++ b/toolkit/content/widgets/menu.xml
@@ -136,25 +136,16 @@
       </xul:hbox>
       <xul:hbox align="center" class="menu-right" xbl:inherits="_moz-menuactive,disabled">
         <xul:image/>
       </xul:hbox>
       <children includes="menupopup"/>
     </content>
   </binding>
 
-  <binding id="menuitem" extends="chrome://global/content/bindings/menu.xml#menuitem-base">
-    <content>
-      <xul:label class="menu-text" xbl:inherits="value=label,accesskey,crop,highlightable" crop="right"/>
-      <xul:hbox class="menu-accel-container" anonid="accel">
-        <xul:label class="menu-accel" xbl:inherits="value=acceltext"/>
-      </xul:hbox>
-    </content>
-  </binding>
-
   <binding id="menu-menubar"
            extends="chrome://global/content/bindings/menu.xml#menu-base">
     <content>
       <xul:label class="menubar-text" xbl:inherits="value=label,accesskey,crop" crop="right"/>
       <children includes="menupopup"/>
     </content>
   </binding>
 
@@ -162,42 +153,16 @@
            extends="chrome://global/content/bindings/menu.xml#menu-base">
     <content>
       <xul:image class="menubar-left" xbl:inherits="src=image"/>
       <xul:label class="menubar-text" xbl:inherits="value=label,accesskey,crop" crop="right"/>
       <children includes="menupopup"/>
     </content>
   </binding>
 
-  <binding id="menuitem-iconic" extends="chrome://global/content/bindings/menu.xml#menuitem">
-    <content>
-      <xul:hbox class="menu-iconic-left" align="center" pack="center"
-                xbl:inherits="selected,_moz-menuactive,disabled,checked">
-        <xul:image class="menu-iconic-icon" xbl:inherits="src=image,triggeringprincipal=iconloadingprincipal,validate,src"/>
-      </xul:hbox>
-      <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop,highlightable" crop="right"/>
-      <xul:label class="menu-iconic-highlightable-text" xbl:inherits="xbl:text=label,crop,accesskey,highlightable" crop="right"/>
-      <children/>
-      <xul:hbox class="menu-accel-container" anonid="accel">
-        <xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext"/>
-      </xul:hbox>
-    </content>
-  </binding>
-
-  <binding id="menuitem-iconic-noaccel" extends="chrome://global/content/bindings/menu.xml#menuitem">
-    <content>
-      <xul:hbox class="menu-iconic-left" align="center" pack="center"
-                xbl:inherits="selected,disabled,checked">
-        <xul:image class="menu-iconic-icon" xbl:inherits="src=image,validate,src"/>
-      </xul:hbox>
-      <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop,highlightable" crop="right"/>
-      <xul:label class="menu-iconic-highlightable-text" xbl:inherits="xbl:text=label,crop,accesskey,highlightable" crop="right"/>
-    </content>
-  </binding>
-
   <binding id="menucaption" extends="chrome://global/content/bindings/menu.xml#menu-base">
     <content>
       <xul:hbox class="menu-iconic-left" align="center" pack="center"
                 xbl:inherits="selected,disabled,checked">
         <xul:image class="menu-iconic-icon" xbl:inherits="src=image,validate,src"/>
       </xul:hbox>
       <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,crop,highlightable" crop="right"/>
       <xul:label class="menu-iconic-highlightable-text" xbl:inherits="xbl:text=label,crop,highlightable" crop="right"/>
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -60,16 +60,19 @@
       </handler>
     </handlers>
 
     <implementation implements="nsIDOMXULMenuListElement">
       <constructor>
         this.mSelectedInternal = null;
         this.mAttributeObserver = null;
         this.setInitialSelection();
+        [...this.querySelectorAll("menuitem")].forEach(menuitem => {
+          menuitem.render();
+        });
       </constructor>
 
       <method name="setInitialSelection">
         <body>
           <![CDATA[
             var popup = this.menupopup;
             if (popup) {
               var arr = popup.getElementsByAttribute("selected", "true");
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -27,17 +27,17 @@
 
     <handlers>
       <handler event="popupshowing" phase="target">
         <![CDATA[
           var array = [];
           var width = 0;
           for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
             if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
-              var accel = document.getAnonymousElementByAttribute(menuitem, "anonid", "accel");
+              var accel = menuitem.menuAccel;
               if (accel && accel.boxObject) {
                 array.push(accel);
                 if (accel.boxObject.width > width)
                   width = accel.boxObject.width;
               }
             }
           }
           for (var i = 0; i < array.length; i++)
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -317,31 +317,16 @@ menu {
 menu.menu-iconic {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menu-iconic");
 }
 
 menubar > menu:empty {
   visibility: collapse;
 }
 
-/********* menuitem ***********/
-
-menuitem {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem");
-}
-
-menuitem.menuitem-iconic {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
-}
-
-menuitem[type="checkbox"],
-menuitem[type="radio"] {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
-}
-
 menucaption {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menucaption");
 }
 
 .menu-text {
   -moz-box-flex: 1;
 }
 
@@ -688,20 +673,16 @@ menulist[popuponly="true"] {
   -moz-binding: url("chrome://global/content/bindings/menulist.xml#menulist-popuponly");
   -moz-appearance: none !important;
   margin: 0 !important;
   height: 0 !important;
   min-height: 0 !important;
   border: 0 !important;
 }
 
-menulist > menupopup > menuitem {
-  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic-noaccel");
-}
-
 dropmarker > .dropmarker-icon {
   pointer-events: none;
 }
 
 /********** splitter **********/
 
 .tree-splitter {
   width: 0px;
diff --git a/toolkit/mozapps/extensions/content/extensions.xml b/toolkit/mozapps/extensions/content/extensions.xml
--- a/toolkit/mozapps/extensions/content/extensions.xml
+++ b/toolkit/mozapps/extensions/content/extensions.xml
@@ -717,16 +717,20 @@
             </xul:menulist>
           </xul:hbox>
         </xul:vbox>
       </xul:hbox>
     </content>
 
     <implementation>
       <constructor><![CDATA[
+        // Custom Elements for anon content don't always get upgraded before the constructor runs (Bug 1470242)
+        customElements.upgrade(this._askToActivateMenuitem);
+        customElements.upgrade(this._alwaysActivateMenuitem);
+        customElements.upgrade(this._alwaysActivateMenuitem);
         this._installStatus = document.getAnonymousElementByAttribute(this, "anonid", "install-status");
         this._installStatus.mControl = this;
 
         this.setAttribute("contextmenu", "addonitem-popup");
 
         this._showStatus("none");
 
         this._initWithAddon(this.mAddon);
