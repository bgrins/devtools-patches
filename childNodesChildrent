# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dead9fcddd4a25fd36d54ab7eb782d7d9b8bb7a1
Bug 1479125 - Rewrite callers firstChild/lastChild/childNodes with firstElementChild/lastElementChild/children in browser.xul

diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -319,17 +319,17 @@ var gXPInstallObserver = {
       messageString = PluralForm.get(installInfo.installs.length, messageString);
       messageString = messageString.replace("#1", installInfo.installs.length);
       options.installs = installInfo.installs;
       options.contentWindow = browser.contentWindow;
       options.sourceURI = browser.currentURI;
       options.eventCallback = function(aEvent) {
         switch (aEvent) {
           case "shown":
-            let notificationElement = [...this.owner.panel.childNodes]
+            let notificationElement = [...this.owner.panel.children]
                                       .find(n => n.notification == this);
             if (notificationElement) {
               if (Services.prefs.getBoolPref("xpinstall.customConfirmationUI", false)) {
                 notificationElement.setAttribute("mainactiondisabled", "true");
               } else {
                 notificationElement.button.hidden = true;
               }
             }
diff --git a/browser/base/content/browser-customization.js b/browser/base/content/browser-customization.js
--- a/browser/base/content/browser-customization.js
+++ b/browser/base/content/browser-customization.js
@@ -25,17 +25,17 @@ var CustomizationHandler = {
 
   isCustomizing() {
     return document.documentElement.hasAttribute("customizing");
   },
 
   _customizationStarting() {
     // Disable the toolbar context menu items
     let menubar = document.getElementById("main-menubar");
-    for (let childNode of menubar.childNodes)
+    for (let childNode of menubar.children)
       childNode.setAttribute("disabled", true);
 
     let cmd = document.getElementById("cmd_CustomizeToolbars");
     cmd.setAttribute("disabled", "true");
 
     UpdateUrlbarSearchSplitterState();
 
     PlacesToolbarHelper.customizeStart();
@@ -64,16 +64,16 @@ var CustomizationHandler = {
     UpdateUrlbarSearchSplitterState();
 
     // Update the urlbar
     URLBarSetURI();
     XULBrowserWindow.asyncUpdateUI();
 
     // Re-enable parts of the UI we disabled during the dialog
     let menubar = document.getElementById("main-menubar");
-    for (let childNode of menubar.childNodes)
+    for (let childNode of menubar.children)
       childNode.setAttribute("disabled", false);
     let cmd = document.getElementById("cmd_CustomizeToolbars");
     cmd.removeAttribute("disabled");
 
     gBrowser.selectedBrowser.focus();
   }
 };
diff --git a/browser/base/content/browser-feeds.js b/browser/base/content/browser-feeds.js
--- a/browser/base/content/browser-feeds.js
+++ b/browser/base/content/browser-feeds.js
@@ -135,18 +135,18 @@ var FeedHandler = {
       // set (because it thinks it's already open).  onpopupshowing gets
       // called after the attribute is unset, and it doesn't get unset
       // if we return false.  so we unset it here; otherwise, the menu
       // refuses to work past this point.
       container.parentNode.removeAttribute("open");
       return false;
     }
 
-    for (let i = container.childNodes.length - 1; i >= 0; --i) {
-      let node = container.childNodes[i];
+    for (let i = container.children.length - 1; i >= 0; --i) {
+      let node = container.children[i];
       if (isSubview && node.localName == "label")
         continue;
       container.removeChild(node);
     }
 
     if (!feeds || feeds.length <= 1)
       return false;
 
diff --git a/browser/base/content/browser-pageActions.js b/browser/base/content/browser-pageActions.js
--- a/browser/base/content/browser-pageActions.js
+++ b/browser/base/content/browser-pageActions.js
@@ -1018,17 +1018,17 @@ BrowserPageActions.sendToDevice = {
     notReady.classList.add(
       "subviewbutton",
       "subviewbutton-iconic",
       "pageAction-sendToDevice-notReady"
     );
     notReady.setAttribute("label", "sendToDevice-notReadyTitle");
     notReady.setAttribute("disabled", "true");
     bodyNode.appendChild(notReady);
-    for (let node of bodyNode.childNodes) {
+    for (let node of bodyNode.children) {
       BrowserPageActions.takeNodeAttributeFromPanel(node, "title");
       BrowserPageActions.takeNodeAttributeFromPanel(node, "shortcut");
     }
   },
 
   onLocationChange() {
     let action = PageActions.actionForID("sendToDevice");
     let browser = gBrowser.selectedBrowser;
@@ -1213,17 +1213,17 @@ BrowserPageActions.shareURL = {
     BrowserPageActions.takeActionTitleFromPanel(action);
   },
 
   onShowingSubview(panelViewNode) {
     let bodyNode = panelViewNode.querySelector(".panel-subview-body");
 
     // We cache the providers + the UI if the user selects the share
     // panel multiple times while the panel is open.
-    if (this._cached && bodyNode.childNodes.length > 0) {
+    if (this._cached && bodyNode.children.length > 0) {
       return;
     }
 
     let sharingService = this._sharingService;
     let url = gBrowser.selectedBrowser.currentURI;
     let currentURI = gURLBar.makeURIReadable(url).displaySpec;
     let shareProviders = sharingService.getSharingProviders(currentURI);
     let fragment = document.createDocumentFragment();
diff --git a/browser/base/content/browser-sidebar.js b/browser/base/content/browser-sidebar.js
--- a/browser/base/content/browser-sidebar.js
+++ b/browser/base/content/browser-sidebar.js
@@ -165,17 +165,17 @@ var SidebarUI = {
 
   /**
    * Read the positioning pref and position the sidebar and the splitter
    * appropriately within the browser container.
    */
   setPosition() {
     // First reset all ordinals to match DOM ordering.
     let browser = document.getElementById("browser");
-    [...browser.childNodes].forEach((node, i) => {
+    [...browser.children].forEach((node, i) => {
       node.ordinal = i + 1;
     });
 
     if (!this._positionStart) {
       // DOM ordering is:     |  sidebar-box  | splitter |   appcontent  |
       // Want to display as:  |   appcontent  | splitter |  sidebar-box  |
       // So we just swap box and appcontent ordering
       let appcontent = document.getElementById("appcontent");
diff --git a/browser/base/content/browser-sync.js b/browser/base/content/browser-sync.js
--- a/browser/base/content/browser-sync.js
+++ b/browser/base/content/browser-sync.js
@@ -368,18 +368,18 @@ var gSync = {
     if (!createDeviceNodeFn) {
       createDeviceNodeFn = (clientId, name, clientType, lastModified) => {
         let eltName = name ? "menuitem" : "menuseparator";
         return document.createElement(eltName);
       };
     }
 
     // remove existing menu items
-    for (let i = devicesPopup.childNodes.length - 1; i >= 0; --i) {
-      let child = devicesPopup.childNodes[i];
+    for (let i = devicesPopup.children.length - 1; i >= 0; --i) {
+      let child = devicesPopup.children[i];
       if (child.classList.contains("sync-menuitem")) {
         child.remove();
       }
     }
 
     if (gSync.syncConfiguredAndLoading) {
       // We can only be in this case in the page action menu.
       return;
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -751,17 +751,17 @@ var gPopupBlockerObserver = {
       if (foundUsablePopupURI)
         blockedPopupsSeparator.removeAttribute("hidden");
     }, null);
   },
 
   onPopupHiding(aEvent) {
     let item = aEvent.target.lastChild;
     while (item && item.id != "blockedPopupsSeparator") {
-      let next = item.previousSibling;
+      let next = item.previousElementSibling;
       item.remove();
       item = next;
     }
   },
 
   showBlockedPopup(aEvent) {
     var target = aEvent.target;
     var popupReportIndex = target.getAttribute("popupReportIndex");
@@ -2787,26 +2787,26 @@ function UpdateUrlbarSearchSplitterState
     if (splitter) {
       splitter.remove();
     }
     return;
   }
 
   // If the splitter is already in the right place, we don't need to do anything:
   if (splitter &&
-      ((splitter.nextSibling == searchbar && splitter.previousSibling == urlbar) ||
-       (splitter.nextSibling == urlbar && splitter.previousSibling == searchbar))) {
+      ((splitter.nextElementSibling == searchbar && splitter.previousElementSibling == urlbar) ||
+       (splitter.nextElementSibling == urlbar && splitter.previousElementSibling == searchbar))) {
     return;
   }
 
   var ibefore = null;
   if (urlbar && searchbar) {
-    if (urlbar.nextSibling == searchbar)
+    if (urlbar.nextElementSibling == searchbar)
       ibefore = searchbar;
-    else if (searchbar.nextSibling == urlbar)
+    else if (searchbar.nextElementSibling == urlbar)
       ibefore = urlbar;
   }
 
   if (ibefore) {
     if (!splitter) {
       splitter = document.createElement("splitter");
       splitter.id = "urlbar-search-splitter";
       splitter.setAttribute("resizebefore", "flex");
@@ -4140,17 +4140,17 @@ function FillHistoryMenu(aParent) {
     aParent.addEventListener("DOMMenuItemInactive", function() {
       XULBrowserWindow.setOverLink("");
     });
 
     aParent.hasStatusListener = true;
   }
 
   // Remove old entries if any
-  let children = aParent.childNodes;
+  let children = aParent.children;
   for (var i = children.length - 1; i >= 0; --i) {
     if (children[i].hasAttribute("index"))
       aParent.removeChild(children[i]);
   }
 
   const MAX_HISTORY_MENU_ITEMS = 15;
 
   const tooltipBack = gNavigatorBundle.getString("tabHistory.goBack");
@@ -5531,25 +5531,25 @@ nsBrowserAccess.prototype = {
 };
 
 function onViewToolbarsPopupShowing(aEvent, aInsertPoint) {
   var popup = aEvent.target;
   if (popup != aEvent.currentTarget)
     return;
 
   // Empty the menu
-  for (var i = popup.childNodes.length - 1; i >= 0; --i) {
-    var deadItem = popup.childNodes[i];
+  for (var i = popup.children.length - 1; i >= 0; --i) {
+    var deadItem = popup.children[i];
     if (deadItem.hasAttribute("toolbarId"))
       popup.removeChild(deadItem);
   }
 
   var firstMenuItem = aInsertPoint || popup.firstChild;
 
-  let toolbarNodes = gNavToolbox.childNodes;
+  let toolbarNodes = gNavToolbox.children;
 
   for (let toolbar of toolbarNodes) {
     if (!toolbar.hasAttribute("toolbarname")) {
       continue;
     }
 
     let menuItem = document.createElement("menuitem");
     let hidingAttribute = toolbar.getAttribute("type") == "menubar" ?
@@ -6356,20 +6356,20 @@ var gPageStyleMenu = {
     }
 
     return data;
   },
 
   fillPopup(menuPopup) {
     let styleSheetInfo = this._getStyleSheetInfo(gBrowser.selectedBrowser);
     var noStyle = menuPopup.firstChild;
-    var persistentOnly = noStyle.nextSibling;
-    var sep = persistentOnly.nextSibling;
-    while (sep.nextSibling)
-      menuPopup.removeChild(sep.nextSibling);
+    var persistentOnly = noStyle.nextElementSibling;
+    var sep = persistentOnly.nextElementSibling;
+    while (sep.nextElementSibling)
+      menuPopup.removeChild(sep.nextElementSibling);
 
     let styleSheets = styleSheetInfo.filteredStyleSheets;
     var currentStyleSheets = {};
     var styleDisabled = styleSheetInfo.authorStyleDisabled;
     var haveAltSheets = false;
     var altStyleSelected = false;
 
     for (let currentStyleSheet of styleSheets) {
@@ -8100,17 +8100,17 @@ TabModalPromptBox.prototype = {
     }
     onCloseCallback.apply(this, args);
   },
 
   appendPrompt(args, onCloseCallback) {
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
     let newPrompt = document.createElementNS(XUL_NS, "tabmodalprompt");
     let browser = this.browser;
-    browser.parentNode.insertBefore(newPrompt, browser.nextSibling);
+    browser.parentNode.insertBefore(newPrompt, browser.nextElementSibling);
     browser.setAttribute("tabmodalPromptShowing", true);
 
     newPrompt.clientTop; // style flush to assure binding is attached
 
     let prompts = this.listPrompts();
     if (prompts.length > 1) {
       // Let's hide ourself behind the current prompt.
       newPrompt.hidden = true;
diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -1393,21 +1393,21 @@ nsContextMenu.prototype = {
   },
 
   // Determines whether or not the separator with the specified ID should be
   // shown or not by determining if there are any non-hidden items between it
   // and the previous separator.
   shouldShowSeparator(aSeparatorID) {
     var separator = document.getElementById(aSeparatorID);
     if (separator) {
-      var sibling = separator.previousSibling;
+      var sibling = separator.previousElementSibling;
       while (sibling && sibling.localName != "menuseparator") {
         if (!sibling.hidden)
           return true;
-        sibling = sibling.previousSibling;
+        sibling = sibling.previousElementSibling;
       }
     }
     return false;
   },
 
   addDictionaries() {
     var uri = formatURL("browser.dictionaries.download.url", true);
 
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -194,17 +194,17 @@ window._gBrowser = {
 
   get tabContainer() {
     delete this.tabContainer;
     return this.tabContainer = document.getElementById("tabbrowser-tabs");
   },
 
   get tabs() {
     delete this.tabs;
-    return this.tabs = this.tabContainer.childNodes;
+    return this.tabs = this.tabContainer.children;
   },
 
   get tabbox() {
     delete this.tabbox;
     return this.tabbox = document.getElementById("tabbrowser-tabbox");
   },
 
   get tabpanels() {
@@ -302,17 +302,17 @@ window._gBrowser = {
     for (let attribute in this._defaultBrowserAttributes) {
       this._defaultBrowserAttributes[attribute] = browser.getAttribute(attribute);
     }
 
     let tab = this.tabs[0];
     this._selectedTab = tab;
 
     let uniqueId = this._generateUniquePanelID();
-    this.tabpanels.childNodes[0].id = uniqueId;
+    this.tabpanels.children[0].id = uniqueId;
     tab.linkedPanel = uniqueId;
     tab.permanentKey = browser.permanentKey;
     tab._tPos = 0;
     tab._fullyOpen = true;
     tab.linkedBrowser = browser;
     this._tabForBrowser.set(browser, tab);
 
     // Hook the browser up with a progress listener.
@@ -528,17 +528,17 @@ window._gBrowser = {
     aTab.dispatchEvent(event);
 
     return findBar;
   },
 
   _appendStatusPanel() {
     let browser = this.selectedBrowser;
     let browserContainer = this.getBrowserContainer(browser);
-    browserContainer.insertBefore(StatusPanel.panel, browser.parentNode.nextSibling);
+    browserContainer.insertBefore(StatusPanel.panel, browser.parentNode.nextElementSibling);
   },
 
   _updateTabBarForPinnedTabs() {
     this.tabContainer._unlockTabSizing();
     this.tabContainer._positionPinnedTabs();
     this.tabContainer._updateCloseButtons();
   },
 
@@ -2995,24 +2995,24 @@ window._gBrowser = {
       remainingTabs = Array.filter(this.tabs, function(tab) {
         return !tab.closing;
       }, this);
     }
 
     // Try to find a remaining tab that comes after the given tab
     let tab = aTab;
     do {
-      tab = tab.nextSibling;
+      tab = tab.nextElementSibling;
     } while (tab && !remainingTabs.includes(tab));
 
     if (!tab) {
       tab = aTab;
 
       do {
-        tab = tab.previousSibling;
+        tab = tab.previousElementSibling;
       } while (tab && !remainingTabs.includes(tab));
     }
 
     return tab;
   },
 
   _blurTab(aTab) {
     this.selectedTab = this._findTabToBlurTo(aTab);
@@ -3535,19 +3535,19 @@ window._gBrowser = {
     this.tabContainer._setPositionalAttributes();
 
     var evt = document.createEvent("UIEvents");
     evt.initUIEvent("TabMove", true, false, window, oldPosition);
     aTab.dispatchEvent(evt);
   },
 
   moveTabForward() {
-    let nextTab = this.selectedTab.nextSibling;
+    let nextTab = this.selectedTab.nextElementSibling;
     while (nextTab && nextTab.hidden)
-      nextTab = nextTab.nextSibling;
+      nextTab = nextTab.nextElementSibling;
 
     if (nextTab)
       this.moveTabTo(this.selectedTab, nextTab._tPos);
     else if (this.arrowKeysShouldWrap)
       this.moveTabToStart();
   },
 
   /**
@@ -3602,19 +3602,19 @@ window._gBrowser = {
       // for our new tab after we've done swapBrowsersAndCloseOther.
       this.updateCurrentBrowser(true);
     }
 
     return newTab;
   },
 
   moveTabBackward() {
-    let previousTab = this.selectedTab.previousSibling;
+    let previousTab = this.selectedTab.previousElementSibling;
     while (previousTab && previousTab.hidden)
-      previousTab = previousTab.previousSibling;
+      previousTab = previousTab.previousElementSibling;
 
     if (previousTab)
       this.moveTabTo(this.selectedTab, previousTab._tPos);
     else if (this.arrowKeysShouldWrap)
       this.moveTabToEnd();
   },
 
   moveTabToStart() {
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -10,17 +10,17 @@
           xmlns:xbl="http://www.mozilla.org/xbl">
 
   <binding id="tabbrowser-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
     <implementation>
       <!-- Override scrollbox.xml method, since our scrollbox's children are
            inherited from the binding parent -->
       <method name="_getScrollableElements">
         <body><![CDATA[
-          return Array.filter(document.getBindingParent(this).childNodes,
+          return Array.filter(document.getBindingParent(this).children,
                               this._canScrollToElement, this);
         ]]></body>
       </method>
       <method name="_canScrollToElement">
         <parameter name="tab"/>
         <body><![CDATA[
           return !tab._pinnedUnscrollable && !tab.hidden;
         ]]></body>
@@ -104,17 +104,17 @@
         <![CDATA[
           this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
           this._hiddenSoundPlayingTabs = new Set();
 
           let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
               "emptyPrivateTabTitle" : "emptyTabTitle";
           this.emptyTabTitle = gTabBrowserBundle.GetStringFromName("tabs." + strId);
 
-          var tab = this.firstChild;
+          var tab = this.firstElementChild;
           tab.label = this.emptyTabTitle;
 
           window.addEventListener("resize", this);
 
           Services.prefs.addObserver("privacy.userContext", this);
           this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
 
           XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
@@ -246,17 +246,17 @@
           return document.documentElement.getAttribute("customizing") == "true";
         ]]></getter>
       </property>
 
       <method name="_getVisibleTabs">
         <body><![CDATA[
           // Cannot access gBrowser before it's initialized.
           if (!gBrowser) {
-            return [ this.firstChild ];
+            return [ this.firstElementChild ];
           }
 
           return gBrowser.visibleTabs;
         ]]></body>
       </method>
 
       <method name="_setPositionalAttributes">
         <body><![CDATA[
@@ -512,34 +512,34 @@
 
             let layoutData = this._pinnedTabsLayoutCache;
             let uiDensity = document.documentElement.getAttribute("uidensity");
             if (!layoutData ||
                 layoutData.uiDensity != uiDensity) {
               let arrowScrollbox = this.arrowScrollbox;
               layoutData = this._pinnedTabsLayoutCache = {
                 uiDensity,
-                pinnedTabWidth: this.childNodes[0].getBoundingClientRect().width,
+                pinnedTabWidth: this.children[0].getBoundingClientRect().width,
                 scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width
               };
             }
 
             let width = 0;
             for (let i = numPinned - 1; i >= 0; i--) {
-              let tab = this.childNodes[i];
+              let tab = this.children[i];
               width += layoutData.pinnedTabWidth;
               tab.style.marginInlineStart = -(width + layoutData.scrollButtonWidth) + "px";
               tab._pinnedUnscrollable = true;
             }
             this.style.paddingInlineStart = width + "px";
           } else {
             this.removeAttribute("positionpinnedtabs");
 
             for (let i = 0; i < numPinned; i++) {
-              let tab = this.childNodes[i];
+              let tab = this.children[i];
               tab.style.marginInlineStart = "";
               tab._pinnedUnscrollable = false;
             }
 
             this.style.paddingInlineStart = "";
           }
 
           if (this._lastNumPinned != numPinned) {
@@ -755,17 +755,17 @@
           return tab;
         ]]></body>
       </method>
 
       <method name="_getDropIndex">
         <parameter name="event"/>
         <parameter name="isLink"/>
         <body><![CDATA[
-          var tabs = this.childNodes;
+          var tabs = this.children;
           var tab = this._getDragTargetTab(event, isLink);
           if (window.getComputedStyle(this).direction == "ltr") {
             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
               if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                 return i;
           } else {
             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
               if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
@@ -854,17 +854,17 @@
         <body>
         <![CDATA[
           if (!aTab) {
             return null;
           }
 
           // Cannot access gBrowser before it's initialized.
           if (!gBrowser) {
-            return this.tabbox.tabpanels.firstChild;
+            return this.tabbox.tabpanels.firstElementChild;
           }
 
           // If the tab's browser is lazy, we need to `_insertBrowser` in order
           // to have a linkedPanel.  This will also serve to bind the browser
           // and make it ready to use when the tab is selected.
           gBrowser._insertBrowser(aTab);
           return document.getElementById(aTab.linkedPanel);
         ]]>
@@ -1310,24 +1310,24 @@
           let maxMargin = Math.min(minMargin + scrollRect.width,
                                    scrollRect.right);
           if (!ltr)
             [minMargin, maxMargin] = [this.clientWidth - maxMargin,
                                       this.clientWidth - minMargin];
           newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
         } else {
           let newIndex = this._getDropIndex(event, effects == "link");
-          if (newIndex == this.childNodes.length) {
-            let tabRect = this.childNodes[newIndex - 1].getBoundingClientRect();
+          if (newIndex == this.children.length) {
+            let tabRect = this.children[newIndex - 1].getBoundingClientRect();
             if (ltr)
               newMargin = tabRect.right - rect.left;
             else
               newMargin = rect.right - tabRect.left;
           } else {
-            let tabRect = this.childNodes[newIndex].getBoundingClientRect();
+            let tabRect = this.children[newIndex].getBoundingClientRect();
             if (ltr)
               newMargin = tabRect.left - rect.left;
             else
               newMargin = rect.right - tabRect.right;
           }
         }
 
         ind.collapsed = false;
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -786,30 +786,30 @@ var CustomizableUIInternal = {
     // through a migration path (bug 938980) or an add-on.
     if (aArea == CustomizableUI.AREA_NAVBAR) {
       aAreaNode.collapsed = false;
     }
 
     this.beginBatchUpdate();
 
     try {
-      let currentNode = container.firstChild;
+      let currentNode = container.firstElementChild;
       let placementsToRemove = new Set();
       for (let id of aPlacements) {
         while (currentNode && currentNode.getAttribute("skipintoolbarset") == "true") {
-          currentNode = currentNode.nextSibling;
+          currentNode = currentNode.nextElementSibling;
         }
 
         // Fix ids for specials and continue, for correctly placed specials.
         if (currentNode && (!currentNode.id || CustomizableUI.isSpecialWidget(currentNode)) &&
             this.matchingSpecials(id, currentNode)) {
           currentNode.id = id;
         }
         if (currentNode && currentNode.id == id) {
-          currentNode = currentNode.nextSibling;
+          currentNode = currentNode.nextElementSibling;
           continue;
         }
 
         if (this.isSpecialWidget(id) && areaIsPanel) {
           placementsToRemove.add(id);
           continue;
         }
 
@@ -4460,17 +4460,17 @@ OverflowableToolbar.prototype = {
 
       if (child.getAttribute("overflows") != "false") {
         this._collapsed.set(child.id, this._target.clientWidth);
         child.setAttribute("overflowedItem", true);
         child.setAttribute("cui-anchorid", this._chevron.id);
         CustomizableUIInternal.ensureButtonContextMenu(child, this._toolbar, true);
         CustomizableUIInternal.notifyListeners("onWidgetOverflow", child, this._target);
 
-        this._list.insertBefore(child, this._list.firstChild);
+        this._list.insertBefore(child, this._list.firstElementChild);
         if (!this._addedListener) {
           CustomizableUI.addListener(this);
         }
         if (!CustomizableUI.isSpecialWidget(child.id)) {
           this._toolbar.setAttribute("overflowing", "true");
         }
       }
       child = prevChild;
@@ -4511,18 +4511,18 @@ OverflowableToolbar.prototype = {
    *        While there are items in the list, this width won't change, and so
    *        we can avoid flushing layout by providing it and/or caching it.
    *        Note that if `shouldMoveAllItems` is true, we never need the width
    *        anyway.
    */
   _moveItemsBackToTheirOrigin(shouldMoveAllItems, targetWidth) {
     let placements = gPlacements.get(this._toolbar.id);
     let win = this._target.ownerGlobal;
-    while (this._list.firstChild) {
-      let child = this._list.firstChild;
+    while (this._list.firstElementChild) {
+      let child = this._list.firstElementChild;
       let minSize = this._collapsed.get(child.id);
 
       if (!shouldMoveAllItems && minSize) {
         if (!targetWidth) {
           let dwu = win.windowUtils;
           targetWidth = Math.floor(dwu.getBoundsWithoutFlushing(this._target).width);
         }
         if (targetWidth <= minSize) {
@@ -4612,20 +4612,20 @@ OverflowableToolbar.prototype = {
     if (aNode.parentNode == this._list) {
       let updatedMinSize;
       if (aNode.previousSibling) {
         updatedMinSize = this._collapsed.get(aNode.previousSibling.id);
       } else {
         // Force (these) items to try to flow back into the bar:
         updatedMinSize = 1;
       }
-      let nextItem = aNode.nextSibling;
+      let nextItem = aNode.nextElementSibling;
       while (nextItem) {
         this._collapsed.set(nextItem.id, updatedMinSize);
-        nextItem = nextItem.nextSibling;
+        nextItem = nextItem.nextElementSibling;
       }
     }
   },
 
   onWidgetAfterDOMChange(aNode, aNextNode, aContainer) {
     if (aContainer != this._target && aContainer != this._list) {
       return;
     }
@@ -4743,17 +4743,17 @@ OverflowableToolbar.prototype = {
   _hideTimeoutId: null,
   _showWithTimeout() {
     this.show().then(() => {
       let window = this._toolbar.ownerGlobal;
       if (this._hideTimeoutId) {
         window.clearTimeout(this._hideTimeoutId);
       }
       this._hideTimeoutId = window.setTimeout(() => {
-        if (!this._panel.firstChild.matches(":hover")) {
+        if (!this._panel.firstElementChild.matches(":hover")) {
           PanelMultiView.hidePopup(this._panel);
         }
       }, OVERFLOW_PANEL_HIDE_DELAY_MS);
     });
   },
 };
 
 CustomizableUIInternal.initialize();
diff --git a/browser/components/customizableui/PanelMultiView.jsm b/browser/components/customizableui/PanelMultiView.jsm
--- a/browser/components/customizableui/PanelMultiView.jsm
+++ b/browser/components/customizableui/PanelMultiView.jsm
@@ -1198,17 +1198,18 @@ var PanelView = class extends Associated
     }
   }
 
   /**
    * Adds a header with the given title, or removes it if the title is empty.
    */
   set headerText(value) {
     // If the header already exists, update or remove it as requested.
-    let header = this.node.firstChild;
+    let header = this.node.firstElementChild;
+    console.log(header, this.node);
     if (header && header.classList.contains("panel-header")) {
       if (value) {
         header.querySelector("label").setAttribute("value", value);
       } else {
         header.remove();
       }
       return;
     }
diff --git a/browser/components/customizableui/content/toolbar.xml b/browser/components/customizableui/content/toolbar.xml
--- a/browser/components/customizableui/content/toolbar.xml
+++ b/browser/components/customizableui/content/toolbar.xml
@@ -25,17 +25,17 @@
                 toolbox.palette = node;
                 toolbox.removeChild(node);
                 break;
               }
             }
           }
 
           // pass the current set of children for comparison with placements:
-          let children = Array.from(this.childNodes)
+          let children = Array.from(this.children)
                               .filter(node => node.getAttribute("skipintoolbarset") != "true" && node.id)
                               .map(node => node.id);
           CustomizableUI.registerToolbarNode(this, children);
       ]]></constructor>
 
       <method name="insertItem">
         <parameter name="aId"/>
         <parameter name="aBeforeElt"/>
diff --git a/browser/components/search/content/search.xml b/browser/components/search/content/search.xml
--- a/browser/components/search/content/search.xml
+++ b/browser/components/search/content/search.xml
@@ -533,27 +533,27 @@
           let stringBundle = document.getBindingParent(this)._stringBundle;
 
           let pasteAndSearch, suggestMenuItem;
           let element, label, akey;
 
           element = document.createElementNS(kXULNS, "menuseparator");
           aMenu.appendChild(element);
 
-          let insertLocation = aMenu.firstChild;
-          while (insertLocation.nextSibling &&
+          let insertLocation = aMenu.firstElementChild;
+          while (insertLocation.nextElementSibling &&
                  insertLocation.getAttribute("cmd") != "cmd_paste")
-            insertLocation = insertLocation.nextSibling;
+            insertLocation = insertLocation.nextElementSibling;
           if (insertLocation) {
             element = document.createElementNS(kXULNS, "menuitem");
             label = stringBundle.getString("cmd_pasteAndSearch");
             element.setAttribute("label", label);
             element.setAttribute("anonid", "paste-and-search");
             element.setAttribute("oncommand", "BrowserSearch.pasteAndSearch(event)");
-            aMenu.insertBefore(element, insertLocation.nextSibling);
+            aMenu.insertBefore(element, insertLocation.nextElementSibling);
             pasteAndSearch = element;
           }
 
           element = document.createElementNS(kXULNS, "menuitem");
           label = stringBundle.getString("cmd_clearHistory");
           akey = stringBundle.getString("cmd_clearHistory_accesskey");
           element.setAttribute("label", label);
           element.setAttribute("accesskey", akey);
@@ -1379,19 +1379,19 @@
           let isOneOffSelected =
             this.selectedButton &&
             this.selectedButton.classList.contains("searchbar-engine-one-off-item");
           // Typing de-selects the settings or opensearch buttons at the bottom
           // of the search panel, as typing shows the user intends to search.
           if (this.selectedButton && !isOneOffSelected)
             this.selectedButton = null;
           if (this.query) {
-            groupText = headerSearchText.previousSibling.value +
+            groupText = headerSearchText.previousElementSibling.value +
                         '"' + headerSearchText.value + '"' +
-                        headerSearchText.nextSibling.value;
+                        headerSearchText.nextElementSibling.value;
             if (!isOneOffSelected)
               this.header.selectedIndex = 1;
           } else {
             let noSearchHeader =
               document.getAnonymousElementByAttribute(this, "anonid",
                                                       "searchbar-oneoffheader-search");
             groupText = noSearchHeader.value;
             if (!isOneOffSelected)
@@ -1448,22 +1448,22 @@
             // width has changed.
             if (this._engines && this._textboxWidth == textboxWidth) {
               return;
             }
             this._textboxWidth = textboxWidth;
           }
 
           // Finally, build the list of one-off buttons.
-          while (this.buttons.firstChild != this.settingsButtonCompact)
-            this.buttons.firstChild.remove();
+          while (this.buttons.firstElementChild != this.settingsButtonCompact)
+            this.buttons.firstElementChild.remove();
           // Remove the trailing empty text node introduced by the binding's
           // content markup above.
-          if (this.settingsButtonCompact.nextSibling)
-            this.settingsButtonCompact.nextSibling.remove();
+          if (this.settingsButtonCompact.nextElementSibling)
+            this.settingsButtonCompact.nextElementSibling.remove();
 
           let engines = this.engines;
           let oneOffCount = engines.length;
           let collapsed = !oneOffCount ||
                           (oneOffCount == 1 && engines[0].name == Services.search.currentEngine.name);
 
           // header is a xul:deck so collapsed doesn't work on it, see bug 589569.
           this.header.hidden = this.buttons.collapsed = collapsed;
@@ -1553,33 +1553,33 @@
             if (rowCount == 1 && hasDummyItems) {
               // When there's only one row, make the compact settings button
               // hug the right edge of the panel.  It may not due to the panel's
               // width not being an integral multiple of the button width.  (See
               // the "There will be an emtpy area" comment above.)  Increase the
               // width of the last dummy item by the remainder.
               let remainder = panelWidth - (enginesPerRow * buttonWidth);
               let width = remainder + buttonWidth;
-              let lastDummyItem = this.settingsButtonCompact.previousSibling;
+              let lastDummyItem = this.settingsButtonCompact.previousElementSibling;
               lastDummyItem.setAttribute("width", width);
             }
           }
         ]]></body>
       </method>
 
       <!-- If a page offers more than this number of engines, the add-engines
            menu button is shown, instead of showing the engines directly in the
            popup. -->
       <field name="_addEngineMenuThreshold">5</field>
 
       <method name="_rebuildAddEngineList">
         <body><![CDATA[
         let list = this.addEngines;
-        while (list.firstChild) {
-          list.firstChild.remove();
+        while (list.firstElementChild) {
+          list.firstElementChild.remove();
         }
 
         // Add a button for each engine that the page in the selected browser
         // offers, except when there are too many offered engines.
         // The popup isn't designed to handle too many (by scrolling for
         // example), so a page could break the popup by offering too many.
         // Instead, add a single menu button with a submenu of all the engines.
 
@@ -1734,31 +1734,31 @@
           }
         ]]></body>
       </method>
 
       <method name="getSelectableButtons">
         <parameter name="aIncludeNonEngineButtons"/>
         <body><![CDATA[
           let buttons = [];
-          for (let oneOff = this.buttons.firstChild; oneOff; oneOff = oneOff.nextSibling) {
+          for (let oneOff = this.buttons.firstElementChild; oneOff; oneOff = oneOff.nextElementSibling) {
             // oneOff may be a text node since the list xul:description contains
             // whitespace and the compact settings button.  See the markup
             // above.  _rebuild removes text nodes, but it may not have been
             // called yet (because e.g. the popup hasn't been opened yet).
             if (oneOff.nodeType == Node.ELEMENT_NODE) {
               if (oneOff.classList.contains("dummy") ||
                   oneOff.classList.contains("search-setting-button-compact"))
                 break;
               buttons.push(oneOff);
             }
           }
 
           if (aIncludeNonEngineButtons) {
-            for (let addEngine = this.addEngines.firstChild; addEngine; addEngine = addEngine.nextSibling) {
+            for (let addEngine = this.addEngines.firstElementChild; addEngine; addEngine = addEngine.nextElementSibling) {
               buttons.push(addEngine);
             }
             buttons.push(this.compact ? this.settingsButtonCompact : this.settingsButton);
           }
 
           return buttons;
         ]]></body>
       </method>
diff --git a/browser/modules/AsyncTabSwitcher.jsm b/browser/modules/AsyncTabSwitcher.jsm
--- a/browser/modules/AsyncTabSwitcher.jsm
+++ b/browser/modules/AsyncTabSwitcher.jsm
@@ -409,17 +409,17 @@ class AsyncTabSwitcher {
     if (this.visibleTab !== showTab) {
       this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
       this.visibleTab = showTab;
 
       this.maybeVisibleTabs.add(showTab);
 
       let tabpanels = this.tabbrowser.tabpanels;
       let showPanel = this.tabbrowser.tabContainer.getRelatedElement(showTab);
-      let index = Array.indexOf(tabpanels.childNodes, showPanel);
+      let index = Array.indexOf(tabpanels.children, showPanel);
       if (index != -1) {
         this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
         tabpanels.setAttribute("selectedIndex", index);
         if (showTab === this.requestedTab) {
           if (this._requestingTab) {
             /*
              * If _requestingTab is set, that means that we're switching the
              * visibility of the tab synchronously, and we need to wait for
diff --git a/devtools/startup/devtools-startup.js b/devtools/startup/devtools-startup.js
--- a/devtools/startup/devtools-startup.js
+++ b/devtools/startup/devtools-startup.js
@@ -25,16 +25,18 @@ const kDebuggerPrefs = [
   "devtools.debugger.remote-enabled",
   "devtools.chrome.enabled"
 ];
 
 const DEVTOOLS_ENABLED_PREF = "devtools.enabled";
 
 const DEVTOOLS_POLICY_DISABLED_PREF = "devtools.policy.disabled";
 
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
 const { XPCOMUtils } = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm", {});
 
 ChromeUtils.defineModuleGetter(this, "Services",
                                "resource://gre/modules/Services.jsm");
 ChromeUtils.defineModuleGetter(this, "AppConstants",
                                "resource://gre/modules/AppConstants.jsm");
 ChromeUtils.defineModuleGetter(this, "CustomizableUI",
                                "resource:///modules/CustomizableUI.jsm");
@@ -564,17 +566,17 @@ DevToolsStartup.prototype = {
     const doc = window.document;
 
     // hookKeyShortcuts can be called both from hookWindow and from the developer toggle
     // onBeforeCreated. Make sure shortcuts are only added once per window.
     if (doc.getElementById("devtoolsKeyset")) {
       return;
     }
 
-    const keyset = doc.createElement("keyset");
+    const keyset = doc.createElementNS(XUL_NS, "keyset");
     keyset.setAttribute("id", "devtoolsKeyset");
 
     for (const key of KeyShortcuts) {
       const xulKey = this.createKey(doc, key, () => this.onKey(window, key));
       keyset.appendChild(xulKey);
     }
 
     // Appending a <key> element is not always enough. The <keyset> needs
@@ -596,17 +598,17 @@ DevToolsStartup.prototype = {
       const require = this.initDevTools("KeyShortcut", key);
       const { gDevToolsBrowser } = require("devtools/client/framework/devtools-browser");
       gDevToolsBrowser.onKeyShortcut(window, key, startTime);
     }
   },
 
   // Create a <xul:key> DOM Element
   createKey(doc, { id, toolId, shortcut, modifiers: mod }, oncommand) {
-    const k = doc.createElement("key");
+    const k = doc.createElementNS(XUL_NS, "key");
     k.id = "key_" + (id || toolId);
 
     if (shortcut.startsWith("VK_")) {
       k.setAttribute("keycode", shortcut);
     } else {
       k.setAttribute("key", shortcut);
     }
 
diff --git a/toolkit/components/normandy/lib/Heartbeat.jsm b/toolkit/components/normandy/lib/Heartbeat.jsm
--- a/toolkit/components/normandy/lib/Heartbeat.jsm
+++ b/toolkit/components/normandy/lib/Heartbeat.jsm
@@ -212,17 +212,17 @@ var Heartbeat = class {
 
     // Make sure the stars are not pushed to the right by the spacer.
     const rightSpacer = this.chromeWindow.document.createElement("spacer");
     rightSpacer.flex = 20;
     frag.appendChild(rightSpacer);
 
     // collapse the space before the stars
     this.messageText.flex = 0;
-    const leftSpacer = this.messageText.nextSibling;
+    const leftSpacer = this.messageText.nextElementSibling;
     leftSpacer.flex = 0;
 
     // Add Learn More Link
     if (this.options.learnMoreMessage && this.options.learnMoreUrl) {
       const learnMore = this.chromeWindow.document.createElement("label");
       learnMore.className = "text-link";
       learnMore.href = this.options.learnMoreUrl.toString();
       learnMore.setAttribute("value", this.options.learnMoreMessage);
diff --git a/toolkit/components/processsingleton/MainProcessSingleton.js b/toolkit/components/processsingleton/MainProcessSingleton.js
--- a/toolkit/components/processsingleton/MainProcessSingleton.js
+++ b/toolkit/components/processsingleton/MainProcessSingleton.js
@@ -73,16 +73,39 @@ MainProcessSingleton.prototype = {
     }
 
     case "document-element-inserted":
       // Set up Custom Elements for XUL windows before anything else happens
       // in the document. Anything loaded here should be considered part of
       // core XUL functionality. Any window-specific elements can be registered
       // via <script> tags at the top of individual documents.
       const doc = subject;
+
+      // XXX: Shim some XUL document stuff onto HTML:
+      if (doc.nodePrincipal.isSystemPrincipal &&
+          doc.contentType == "application/xhtml+xml") {
+        doc.commandDispatcher = {
+          get focusedElement() {
+
+          },
+          get focusedWindow() {
+
+          },
+          addCommandUpdater: () => {},
+          removeCommandUpdater: () => {},
+          updateCommands: () => {},
+          getControllerForCommand: () => {},
+          getControllers: () => {},
+          advanceFocus: () => {},
+          rewindFocus: () => {},
+          advanceFocusIntoSubtree: () => {},
+          lock: () => {},
+          unlock: () => {},
+        };
+      }
       if (doc.nodePrincipal.isSystemPrincipal &&
           doc.contentType == "application/vnd.mozilla.xul+xml") {
         Services.scriptloader.loadSubScript(
           "chrome://global/content/customElements.js", doc.ownerGlobal);
       }
       break;
 
     case "xpcom-shutdown":
diff --git a/toolkit/content/editMenuCommands.inc.xul b/toolkit/content/editMenuCommands.inc.xul
--- a/toolkit/content/editMenuCommands.inc.xul
+++ b/toolkit/content/editMenuCommands.inc.xul
@@ -1,9 +1,9 @@
-<script type="application/javascript" src="chrome://global/content/editMenuOverlay.js"/>
+<script src="chrome://global/content/editMenuOverlay.js"></script>
 <commandset id="editMenuCommands">
   <commandset id="editMenuCommandSetAll" commandupdater="true" events="focus,select"
               oncommandupdate="goUpdateGlobalEditMenuItems()"/>
   <commandset id="editMenuCommandSetUndo" commandupdater="true" events="undo"
               oncommandupdate="goUpdateUndoEditMenuItems()"/>
   <commandset id="editMenuCommandSetPaste" commandupdater="true" events="clipboard"
               oncommandupdate="goUpdatePasteMenuItems()"/>
   <command id="cmd_undo" oncommand="goDoCommand('cmd_undo')"/>
diff --git a/toolkit/content/widgets/datetimebox.xml b/toolkit/content/widgets/datetimebox.xml
--- a/toolkit/content/widgets/datetimebox.xml
+++ b/toolkit/content/widgets/datetimebox.xml
@@ -1385,17 +1385,17 @@
       <method name="focusInnerTextBox">
         <body>
         <![CDATA[
           this.log("Focus inner editable field.");
 
           let editRoot =
             document.getAnonymousElementByAttribute(this, "anonid", "edit-wrapper");
 
-          for (let child = editRoot.firstChild; child; child = child.nextSibling) {
+          for (let child = editRoot.firstChild; child; child = child.nextElementSibling) {
             if ((child instanceof HTMLSpanElement) &&
                 child.classList.contains("datetime-edit-field")) {
               this.mLastFocusedField = child;
               child.focus();
               break;
             }
           }
         ]]>
@@ -1410,17 +1410,17 @@
           if (this.mLastFocusedField) {
             this.mLastFocusedField.blur();
           } else {
             // If .mLastFocusedField hasn't been set, blur all editable fields,
             // so that the bound element will actually be blurred. Note that
             // blurring on a element that has no focus won't have any effect.
             let editRoot =
               document.getAnonymousElementByAttribute(this, "anonid", "edit-wrapper");
-            for (let child = editRoot.firstChild; child; child = child.nextSibling) {
+            for (let child = editRoot.firstChild; child; child = child.nextElementSibling) {
               if ((child instanceof HTMLSpanElement) &&
                   child.classList.contains("datetime-edit-field")) {
                 child.blur();
               }
             }
           }
         ]]>
         </body>
@@ -1516,17 +1516,17 @@
           if (aName != "tabindex" && aName != "disabled" &&
               aName != "readonly") {
             return;
           }
 
           let editRoot =
             document.getAnonymousElementByAttribute(this, "anonid", "edit-wrapper");
 
-          for (let child = editRoot.firstChild; child; child = child.nextSibling) {
+          for (let child = editRoot.firstChild; child; child = child.nextElementSibling) {
             if ((child instanceof HTMLSpanElement) &&
                 child.classList.contains("datetime-edit-field")) {
 
               switch (aName) {
                 case "tabindex":
                   child.setAttribute(aName, aValue);
                   break;
                 case "disabled": {
@@ -1557,17 +1557,17 @@
           if (aName != "tabindex" && aName != "disabled" &&
               aName != "readonly") {
             return;
           }
 
           let editRoot =
             document.getAnonymousElementByAttribute(this, "anonid", "edit-wrapper");
 
-          for (let child = editRoot.firstChild; child; child = child.nextSibling) {
+          for (let child = editRoot.firstChild; child; child = child.nextElementSibling) {
             if ((child instanceof HTMLSpanElement) &&
                 child.classList.contains("datetime-edit-field")) {
               child.removeAttribute(aName);
               // Update property as well.
               if (aName == "readonly") {
                 child.readOnly = false;
               } else if (aName == "disabled") {
                 child.disabled = false;
diff --git a/toolkit/content/widgets/findbar.xml b/toolkit/content/widgets/findbar.xml
--- a/toolkit/content/widgets/findbar.xml
+++ b/toolkit/content/widgets/findbar.xml
@@ -927,17 +927,17 @@
       <!--
         - Determines whether minimalist or general-purpose search UI is to be
         - displayed when the find bar is activated.
         -->
       <method name="_updateFindUI">
         <body><![CDATA[
           let showMinimalUI = this._findMode != this.FIND_NORMAL;
 
-          let nodes = this.getElement("findbar-container").childNodes;
+          let nodes = this.getElement("findbar-container").children;
           let wrapper = this.getElement("findbar-textbox-wrapper");
           let foundMatches = this._foundMatches;
           for (let node of nodes) {
             if (node == wrapper || node == foundMatches)
                continue;
             node.hidden = showMinimalUI;
           }
           this.getElement("find-next").hidden =
diff --git a/toolkit/content/widgets/general.js b/toolkit/content/widgets/general.js
--- a/toolkit/content/widgets/general.js
+++ b/toolkit/content/widgets/general.js
@@ -24,17 +24,17 @@ class MozDeck extends MozXULElement {
     var selectedIndex = -1;
     for (var panel = val; panel != null; panel = panel.previousSibling)
       ++selectedIndex;
     this.selectedIndex = selectedIndex;
     return val;
   }
 
   get selectedPanel() {
-    return this.childNodes[this.selectedIndex];
+    return this.children[this.selectedIndex];
   }
 }
 
 customElements.define("deck", MozDeck);
 
 class MozDropmarker extends MozXULElement {
   connectedCallback() {
     // Only create the image the first time we are connected
diff --git a/toolkit/content/widgets/menu.xml b/toolkit/content/widgets/menu.xml
--- a/toolkit/content/widgets/menu.xml
+++ b/toolkit/content/widgets/menu.xml
@@ -120,17 +120,17 @@
       </method>
 
       <property name="menupopup" readonly="true">
         <getter>
         <![CDATA[
           const XUL_NS =
             "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
-          for (var child = this.firstChild; child; child = child.nextSibling) {
+          for (var child = this.firstChild; child; child = child.nextElementSibling) {
             if (child.namespaceURI == XUL_NS && child.localName == "menupopup")
               return child;
           }
           return null;
         ]]>
         </getter>
       </property>
     </implementation>
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -145,19 +145,19 @@
                             onget="return this.hasAttribute('open');"/>
 
       <property name="itemCount" readonly="true"
                 onget="return this.menupopup ? this.menupopup.childNodes.length : 0"/>
 
       <property name="menupopup" readonly="true">
         <getter>
           <![CDATA[
-            var popup = this.firstChild;
+            var popup = this.firstElementChild;
             while (popup && popup.localName != "menupopup")
-              popup = popup.nextSibling;
+              popup = popup.nextElementSibling;
             return popup;
           ]]>
         </getter>
       </property>
 
       <method name="contains">
         <parameter name="item"/>
         <body>
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -25,17 +25,17 @@
       </field>
     </implementation>
 
     <handlers>
       <handler event="popupshowing" phase="target">
         <![CDATA[
           var array = [];
           var width = 0;
-          for (var menuitem = this.firstChild; menuitem; menuitem = menuitem.nextSibling) {
+          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
             if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
               var accel = document.getAnonymousElementByAttribute(menuitem, "anonid", "accel");
               if (accel && accel.boxObject) {
                 array.push(accel);
                 if (accel.boxObject.width > width)
                   width = accel.boxObject.width;
               }
             }
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -55,17 +55,17 @@
             if (this.currentIndex > -1)
               this._currentIndex = this.currentIndex + 1;
 
             var event = document.createEvent("Events");
             event.initEvent("select", true, true);
             this.dispatchEvent(event);
 
             // always call this (allows a commandupdater without controller)
-            document.commandDispatcher.updateCommands("richlistbox-select");
+            document.commandDispatcher && document.commandDispatcher.updateCommands("richlistbox-select");
           ]]>
         </body>
       </method>
 
       <!-- We override base-listbox here because those methods don't take dir
            into account on listbox (which doesn't support dir yet) -->
       <method name="getNextItem">
         <parameter name="aStartItem"/>
@@ -625,18 +625,18 @@
                 if (this.selType != "multiple" && this.selectedCount == 0)
                   this.selectedItem = currentItem;
 
                 if (this._scrollbox.boxObject.height) {
                   this.ensureElementIsVisible(currentItem);
                 } else {
                   // XXX hack around a bug in ensureElementIsVisible as it will
                   // scroll beyond the last element, bug 493645.
-                  var previousElement = this.dir == "reverse" ? currentItem.nextSibling :
-                                                                currentItem.previousSibling;
+                  var previousElement = this.dir == "reverse" ? currentItem.nextElementSibling :
+                                                                currentItem.previousElementSibling;
                   this.ensureElementIsVisible(previousElement);
                 }
               }
               this._suppressOnSelect = suppressSelect;
               // XXX actually it's just a refresh, but at least
               // the Extensions manager expects this:
               this._fireOnSelect();
               return;
diff --git a/toolkit/content/widgets/scrollbox.xml b/toolkit/content/widgets/scrollbox.xml
--- a/toolkit/content/widgets/scrollbox.xml
+++ b/toolkit/content/widgets/scrollbox.xml
@@ -229,17 +229,17 @@
             if (this._canScrollToElement(nextElement))
               targetElement = nextElement;
             nextElement = nextElement.previousSibling;
             index++;
           }
           while (index > 0 && nextElement) {
             if (this._canScrollToElement(nextElement))
               targetElement = nextElement;
-            nextElement = nextElement.nextSibling;
+            nextElement = nextElement.nextElementSibling;
             index--;
           }
           if (!targetElement)
             return;
 
           this.ensureElementIsVisible(targetElement, aInstant);
         ]]></body>
       </method>
@@ -752,18 +752,18 @@
             else
               x = this.scrollClientRect[end] + this.scrollClientSize;
             targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);
 
             // the next partly-hidden element will become fully visible,
             // so don't scroll too far
             if (targetElement)
               targetElement = scrollBack ?
-                              targetElement.nextSibling :
-                              targetElement.previousSibling;
+                              targetElement.nextElementSibling :
+                              targetElement.previousElementSibling;
           }
 
           if (!targetElement) {
             // scroll to the first resp. last element
             let elements = this._getScrollableElements();
             targetElement = scrollBack ?
                             elements[0] :
                             elements[elements.length - 1];
diff --git a/toolkit/content/widgets/tabbox.xml b/toolkit/content/widgets/tabbox.xml
--- a/toolkit/content/widgets/tabbox.xml
+++ b/toolkit/content/widgets/tabbox.xml
@@ -235,17 +235,17 @@
           this.setAttribute("orient", "horizontal");
 
         if (this.tabbox && this.tabbox.hasAttribute("selectedIndex")) {
           let selectedIndex = parseInt(this.tabbox.getAttribute("selectedIndex"));
           this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;
           return;
         }
 
-        var children = this.childNodes;
+        var children = this.children;
         var length = children.length;
         for (var i = 0; i < length; i++) {
           if (children[i].getAttribute("selected") == "true") {
             this.selectedIndex = i;
             return;
           }
         }
 
@@ -293,30 +293,30 @@
                                                              linkedPanelId);
 
             return ownerDoc.getElementById(linkedPanelId);
           }
 
           // otherwise linked tabpanel element has the same index as the given
           // tab element.
           let tabElmIdx = this.getIndexOfItem(aTabElm);
-          return tabpanelsElm.childNodes[tabElmIdx];
+          return tabpanelsElm.children[tabElmIdx];
         ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULSelectControlElement -->
       <property name="itemCount" readonly="true"
-                onget="return this.childNodes.length"/>
+                onget="return this.children.length"/>
 
       <property name="value" onget="return this.getAttribute('value');">
         <setter>
           <![CDATA[
             this.setAttribute("value", val);
-            var children = this.childNodes;
+            var children = this.children;
             for (var c = children.length - 1; c >= 0; c--) {
               if (children[c].value == val) {
                 this.selectedIndex = c;
                 break;
               }
             }
             return val;
           ]]>
@@ -347,30 +347,30 @@
       <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->
       <field name="_tabbox" readonly="true"><![CDATA[
         this.tabbox;
       ]]></field>
 
       <property name="selectedIndex">
         <getter>
         <![CDATA[
-          const tabs = this.childNodes;
+          const tabs = this.children;
           for (var i = 0; i < tabs.length; i++) {
             if (tabs[i].selected)
               return i;
           }
           return -1;
         ]]>
         </getter>
 
         <setter>
         <![CDATA[
           var tab = this.getItemAtIndex(val);
           if (tab) {
-            Array.forEach(this.childNodes, function(aTab) {
+            Array.forEach(this.children, function(aTab) {
               if (aTab.selected && aTab != tab)
                 aTab._selected = false;
             });
             tab._selected = true;
 
             this.setAttribute("value", tab.value);
 
             let linkedPanel = this.getRelatedElement(tab);
@@ -385,17 +385,17 @@
           return val;
         ]]>
         </setter>
       </property>
 
       <property name="selectedItem">
         <getter>
         <![CDATA[
-          const tabs = this.childNodes;
+          const tabs = this.children;
           for (var i = 0; i < tabs.length; i++) {
             if (tabs[i].selected)
               return tabs[i];
           }
           return null;
         ]]>
         </getter>
 
@@ -409,42 +409,42 @@
         ]]>
         </setter>
       </property>
 
       <method name="getIndexOfItem">
         <parameter name="item"/>
         <body>
         <![CDATA[
-          return Array.indexOf(this.childNodes, item);
+          return Array.indexOf(this.children, item);
         ]]>
         </body>
       </method>
 
       <method name="getItemAtIndex">
         <parameter name="index"/>
         <body>
         <![CDATA[
-          return this.childNodes.item(index);
+          return this.children.item(index);
         ]]>
         </body>
       </method>
 
       <method name="_selectNewTab">
         <parameter name="aNewTab"/>
         <parameter name="aFallbackDir"/>
         <parameter name="aWrap"/>
         <body>
         <![CDATA[
           var requestedTab = aNewTab;
           while (aNewTab.hidden || aNewTab.disabled || !this._canAdvanceToTab(aNewTab)) {
-            aNewTab = aFallbackDir == -1 ? aNewTab.previousSibling : aNewTab.nextSibling;
+            aNewTab = aFallbackDir == -1 ? aNewTab.previousElementSibling : aNewTab.nextElementSibling;
             if (!aNewTab && aWrap)
-              aNewTab = aFallbackDir == -1 ? this.childNodes[this.childNodes.length - 1] :
-                                             this.childNodes[0];
+              aNewTab = aFallbackDir == -1 ? this.children[this.children.length - 1] :
+                                             this.children[0];
             if (!aNewTab || aNewTab == requestedTab)
               return;
           }
 
           var isTabFocused = false;
           try {
             isTabFocused =
               (document.commandDispatcher.focusedElement == this.selectedItem);
@@ -486,18 +486,18 @@
       <method name="advanceSelectedTab">
         <parameter name="aDir"/>
         <parameter name="aWrap"/>
         <body>
         <![CDATA[
           var startTab = this.selectedItem;
           var next = startTab[aDir == -1 ? "previousSibling" : "nextSibling"];
           if (!next && aWrap) {
-            next = aDir == -1 ? this.childNodes[this.childNodes.length - 1] :
-                                this.childNodes[0];
+            next = aDir == -1 ? this.children[this.children.length - 1] :
+                                this.children[0];
           }
           if (next && next != startTab) {
             this._selectNewTab(next, aDir, aWrap);
           }
         ]]>
         </body>
       </method>
 
@@ -552,21 +552,21 @@
             return null;
 
           let tabsElm = tabboxElm.tabs;
           if (!tabsElm)
             return null;
 
           // Return tab element having 'linkedpanel' attribute equal to the id
           // of the tab panel or the same index as the tab panel element.
-          let tabpanelIdx = Array.indexOf(this.childNodes, aTabPanelElm);
+          let tabpanelIdx = Array.indexOf(this.children, aTabPanelElm);
           if (tabpanelIdx == -1)
             return null;
 
-          let tabElms = tabsElm.childNodes;
+          let tabElms = tabsElm.children;
           let tabElmFromIndex = tabElms[tabpanelIdx];
 
           let tabpanelId = aTabPanelElm.id;
           if (tabpanelId) {
             for (let idx = 0; idx < tabElms.length; idx++) {
               var tabElm = tabElms[idx];
               if (tabElm.linkedPanel == tabpanelId)
                 return tabElm;
@@ -595,38 +595,38 @@
             }
             parent = parent.parentNode;
           }
 
           return this._tabbox = parent;
         ]]></getter>
       </property>
 
-      <field name="_selectedPanel">this.childNodes.item(this.selectedIndex)</field>
+      <field name="_selectedPanel">this.children.item(this.selectedIndex)</field>
 
       <property name="selectedIndex">
         <getter>
         <![CDATA[
           var indexStr = this.getAttribute("selectedIndex");
           return indexStr ? parseInt(indexStr) : -1;
         ]]>
         </getter>
 
         <setter>
         <![CDATA[
-          if (val < 0 || val >= this.childNodes.length)
+          if (val < 0 || val >= this.children.length)
             return val;
 
           // Give the tabbrowser a chance to run logic regardless of
           // whether the panel is going to change:
           this.dispatchEvent(new CustomEvent("preselect",
-            { detail: this.getRelatedElement(this.childNodes[val]) }));
+            { detail: this.getRelatedElement(this.children[val]) }));
 
           var panel = this._selectedPanel;
-          this._selectedPanel = this.childNodes[val];
+          this._selectedPanel = this.children[val];
           this.setAttribute("selectedIndex", val);
           if (this._selectedPanel != panel) {
             var event = document.createEvent("Events");
             event.initEvent("select", true, true);
             this.dispatchEvent(event);
           }
           return val;
         ]]>
@@ -786,22 +786,22 @@
       <handler event="keydown" keycode="VK_DOWN" group="system" preventdefault="true">
       <![CDATA[
         this.parentNode.advanceSelectedTab(1, this.arrowKeysShouldWrap);
       ]]>
       </handler>
 
       <handler event="keydown" keycode="VK_HOME" group="system" preventdefault="true">
       <![CDATA[
-        this.parentNode._selectNewTab(this.parentNode.childNodes[0]);
+        this.parentNode._selectNewTab(this.parentNode.children[0]);
       ]]>
       </handler>
 
       <handler event="keydown" keycode="VK_END" group="system" preventdefault="true">
       <![CDATA[
-        var tabs = this.parentNode.childNodes;
+        var tabs = this.parentNode.children;
         this.parentNode._selectNewTab(tabs[tabs.length - 1], -1);
       ]]>
       </handler>
     </handlers>
   </binding>
 
 </bindings>
diff --git a/toolkit/modules/PopupNotifications.jsm b/toolkit/modules/PopupNotifications.jsm
--- a/toolkit/modules/PopupNotifications.jsm
+++ b/toolkit/modules/PopupNotifications.jsm
@@ -736,17 +736,17 @@ PopupNotifications.prototype = {
       let originalParent = gNotificationParents.get(popupnotification);
       if (originalParent) {
         popupnotification.notification = null;
 
         // Remove nodes dynamically added to the notification's menu button
         // in _refreshPanel.
         let contentNode = popupnotification.lastChild;
         while (contentNode) {
-          let previousSibling = contentNode.previousSibling;
+          let previousSibling = contentNode.previousElementSibling;
           if (contentNode.nodeName == "menuitem" ||
               contentNode.nodeName == "menuseparator")
             popupnotification.removeChild(contentNode);
           contentNode = previousSibling;
         }
 
         // Re-hide the notification such that it isn't rendered in the chrome
         // document. _refreshPanel will unhide it again when needed.
diff --git a/toolkit/modules/SelectParentHelper.jsm b/toolkit/modules/SelectParentHelper.jsm
--- a/toolkit/modules/SelectParentHelper.jsm
+++ b/toolkit/modules/SelectParentHelper.jsm
@@ -140,19 +140,19 @@ var SelectParentHelper = {
     closedWithEnter = false;
     selectRect = rect;
     this._registerListeners(browser, menulist.menupopup);
 
     let win = browser.ownerGlobal;
 
     // Set the maximum height to show exactly MAX_ROWS items.
     let menupopup = menulist.menupopup;
-    let firstItem = menupopup.firstChild;
+    let firstItem = menupopup.firstElement;
     while (firstItem && firstItem.hidden) {
-      firstItem = firstItem.nextSibling;
+      firstItem = firstItem.nextElementSibling;
     }
 
     if (firstItem) {
       let itemHeight = firstItem.getBoundingClientRect().height;
 
       // Include the padding and border on the popup.
       let cs = win.getComputedStyle(menupopup);
       let bpHeight = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth) +
@@ -464,24 +464,24 @@ function populateChildren(menulist, opti
       switch (event.key) {
         case "Escape":
           searchbox.parentElement.hidePopup();
           break;
         case "ArrowDown":
         case "Enter":
         case "Tab":
           searchbox.blur();
-          if (searchbox.nextSibling.localName == "menuitem" &&
-              !searchbox.nextSibling.hidden) {
-            menulist.menuBoxObject.activeChild = searchbox.nextSibling;
+          if (searchbox.nextElementSibling.localName == "menuitem" &&
+              !searchbox.nextElementSibling.hidden) {
+            menulist.menuBoxObject.activeChild = searchbox.nextElementSibling;
           } else {
-            var currentOption = searchbox.nextSibling;
+            var currentOption = searchbox.nextElementSibling;
             while (currentOption && (currentOption.localName != "menuitem" ||
                   currentOption.hidden)) {
-              currentOption = currentOption.nextSibling;
+              currentOption = currentOption.nextElementSibling;
             }
             if (currentOption) {
               menulist.menuBoxObject.activeChild = currentOption;
             } else {
               searchbox.focus();
             }
           }
           break;
@@ -527,17 +527,17 @@ function onSearchInput() {
       } else if (currentItem.localName == "menucaption") {
         if (prevCaption != null) {
           prevCaption.hidden = allHidden;
         }
         prevCaption = currentItem;
         allHidden = true;
       } else {
         if (!currentItem.classList.contains("contentSelectDropdown-ingroup") &&
-            currentItem.previousSibling.classList.contains("contentSelectDropdown-ingroup")) {
+            currentItem.previousElementSibling.classList.contains("contentSelectDropdown-ingroup")) {
           if (prevCaption != null) {
             prevCaption.hidden = allHidden;
           }
           prevCaption = null;
           allHidden = true;
         }
         if (itemLabel.includes(input) || itemTooltip.includes(input)) {
           currentItem.hidden = false;
diff --git a/toolkit/modules/SelectionSourceContent.jsm b/toolkit/modules/SelectionSourceContent.jsm
--- a/toolkit/modules/SelectionSourceContent.jsm
+++ b/toolkit/modules/SelectionSourceContent.jsm
@@ -131,17 +131,17 @@ var SelectionSourceContent = {
             !endContainer.parentNode || !endContainer.parentNode.parentNode)
           endContainer.insertData(endOffset, MARK_SELECTION_END);
         else {
           tmpNode = dataDoc.createTextNode(MARK_SELECTION_END);
           endContainer = endContainer.parentNode;
           if (endOffset === 0)
             endContainer.parentNode.insertBefore(tmpNode, endContainer);
           else
-            endContainer.parentNode.insertBefore(tmpNode, endContainer.nextSibling);
+            endContainer.parentNode.insertBefore(tmpNode, endContainer.nextElementSibling);
         }
       } else {
         tmpNode = dataDoc.createTextNode(MARK_SELECTION_END);
         endContainer.insertBefore(tmpNode, endContainer.childNodes.item(endOffset));
       }
 
       if (startContainer.nodeType == Node.TEXT_NODE ||
           startContainer.nodeType == Node.CDATA_SECTION_NODE) {
@@ -155,17 +155,17 @@ var SelectionSourceContent = {
             startContainer != startContainer.parentNode.lastChild)
           startContainer.insertData(startOffset, MARK_SELECTION_START);
         else {
           tmpNode = dataDoc.createTextNode(MARK_SELECTION_START);
           startContainer = startContainer.parentNode;
           if (startOffset === 0)
             startContainer.parentNode.insertBefore(tmpNode, startContainer);
           else
-            startContainer.parentNode.insertBefore(tmpNode, startContainer.nextSibling);
+            startContainer.parentNode.insertBefore(tmpNode, startContainer.nextElementSibling);
         }
       } else {
         tmpNode = dataDoc.createTextNode(MARK_SELECTION_START);
         startContainer.insertBefore(tmpNode, startContainer.childNodes.item(startOffset));
       }
     }
 
     // now extract and display the syntax highlighted source
