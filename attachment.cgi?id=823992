# HG changeset patch
# Parent 200fa2ac65e4c1d1c947a5cac90e22a9013f07a2
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 932218 - Hides previous image preview tooltip in markup view when another one shows; r=bgrins

diff --git a/browser/devtools/shared/widgets/Tooltip.js b/browser/devtools/shared/widgets/Tooltip.js
--- a/browser/devtools/shared/widgets/Tooltip.js
+++ b/browser/devtools/shared/widgets/Tooltip.js
@@ -11,16 +11,18 @@ const IOService = Cc["@mozilla.org/netwo
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 
 const GRADIENT_RE = /\b(repeating-)?(linear|radial)-gradient\(((rgb|hsl)a?\(.+?\)|[^\)])+\)/gi;
 const BORDERCOLOR_RE = /^border-[-a-z]*color$/ig;
 const BORDER_RE = /^border(-(top|bottom|left|right))?$/ig;
 const BACKGROUND_IMAGE_RE = /url\([\'\"]?(.*?)[\'\"]?\)/;
+const HOVER_MODE_SINGLE = 1;
+const HOVER_MODE_MULTI = 2;
 
 /**
  * Tooltip widget.
  *
  * This widget is intended at any tool that may need to show rich content in the
  * form of floating panels.
  * A common use case is image previewing in the CSS rule view, but more complex
  * use cases may include color pickers, object inspection, etc...
@@ -176,16 +178,19 @@ Tooltip.prototype = {
    *        An optional delay that will be observed before showing the tooltip.
    *        Defaults to 750ms
    */
   startTogglingOnHover: function(baseNode, targetNodeCb, showDelay = 750) {
     if (this._basedNode) {
       this.stopTogglingOnHover();
     }
 
+    this._toggleOnHoverMode = targetNodeCb ?
+      HOVER_MODE_MULTI : HOVER_MODE_SINGLE;
+
     this._basedNode = baseNode;
     this._showDelay = showDelay;
     this._targetNodeCb = targetNodeCb || (() => true);
 
     this._onBaseNodeMouseMove = this._onBaseNodeMouseMove.bind(this);
     this._onBaseNodeMouseLeave = this._onBaseNodeMouseLeave.bind(this);
 
     baseNode.addEventListener("mousemove", this._onBaseNodeMouseMove, false);
@@ -216,25 +221,33 @@ Tooltip.prototype = {
       this._lastHovered = null;
       setNamedTimeout(this.uid, this._showDelay, () => {
         this._showOnHover(event.target);
       });
     }
   },
 
   _showOnHover: function(target) {
-    if (this._targetNodeCb && this._targetNodeCb(target, this)) {
+    let doShow = true;
+    if (this._toggleOnHoverMode === HOVER_MODE_MULTI) {
+      doShow = this._targetNodeCb && this._targetNodeCb(target, this);
+    }
+
+    if (doShow) {
       this.show(target);
       this._lastHovered = target;
     }
   },
 
   _onBaseNodeMouseLeave: function() {
     clearNamedTimeout(this.uid);
     this._lastHovered = null;
+    if (this._toggleOnHoverMode === HOVER_MODE_SINGLE) {
+      this.hide();
+    }
   },
 
   /**
    * Set the content of this tooltip. Will first empty the tooltip and then
    * append the new content element.
    * Consider using one of the set<type>Content() functions instead.
    * @param {node} content
    *        A node that can be appended in the tooltip XUL element
