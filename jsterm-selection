# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  4425a9b2daf0833c7891d63d7ca41e79132344e8
Bug XXX - Create methods for jsterm selection API

diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -2100,16 +2100,20 @@ WebConsoleFrame.prototype = {
     if (this._outputQueue.length === 0 && this._flushCallback) {
       if (this._flushCallback() === false) {
         this._flushCallback = null;
       }
     }
 
     this._initOutputTimer();
 
+    // XXX: This is needed for now with codemirror console otherwise the
+    // input line takes up too much space...
+    this.jsterm.resizeInput();
+
     this._lastOutputFlush = Date.now();
   },
 
   /**
    * Initialize the output timer.
    * @private
    */
   _initOutputTimer: function WCF__initOutputTimer()
@@ -3866,16 +3870,24 @@ JSTerm.prototype = {
    * Gets the value from the input field
    */
   getInputValue: function()
   {
     return this.inputNode.value || "";
   },
 
   /**
+   * Is there text selected? In other words, is the selection *not* collapsed?
+   */
+  get isSomethingSelected()
+  {
+    return this.inputNode.selectionStart !== this.inputNode.selectionEnd;
+  },
+
+  /**
    * The inputNode "input" and "keyup" event handler.
    * @private
    */
   _inputEventHandler: function JST__inputEventHandler()
   {
     if (this.lastInputValue != this.getInputValue()) {
       this.resizeInput();
       this.complete(this.COMPLETE_HINT_ONLY);
@@ -4086,18 +4098,17 @@ JSTerm.prototype = {
 
       case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
         if (this.autocompletePopup.isOpen || this.lastCompletion.value) {
           this.clearCompletion();
         }
         break;
 
       case Ci.nsIDOMKeyEvent.DOM_VK_RIGHT: {
-        let cursorAtTheEnd = this.inputNode.selectionStart ==
-                             this.inputNode.selectionEnd &&
+        let cursorAtTheEnd = this.isSomethingSelected &&
                              this.inputNode.selectionStart ==
                              this.getInputValue().length;
         let haveSuggestion = this.autocompletePopup.isOpen ||
                              this.lastCompletion.value;
         let useCompletion = cursorAtTheEnd || this._autocompletePopupNavigated;
         if (haveSuggestion && useCompletion &&
             this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion.value &&
@@ -4200,20 +4211,21 @@ JSTerm.prototype = {
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the
    *         previous item in history when the user presses the Up arrow key,
    *         otherwise false.
    */
   canCaretGoPrevious: function JST_canCaretGoPrevious()
   {
+    if (this.isSomethingSelected) {
+      return false;
+    }
+
     let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
-      return false;
-    }
 
     let multiline = /[\r\n]/.test(node.value);
     return node.selectionStart == 0 ? true :
            node.selectionStart == node.value.length && !multiline;
   },
 
   /**
    * Check if the caret is at a location that allows selecting the next item in
@@ -4221,20 +4233,21 @@ JSTerm.prototype = {
    *
    * @return boolean
    *         True if the caret is at a location that allows selecting the next
    *         item in history when the user presses the Down arrow key, otherwise
    *         false.
    */
   canCaretGoNext: function JST_canCaretGoNext()
   {
+    if (this.isSomethingSelected) {
+      return false;
+    }
+
     let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
-      return false;
-    }
 
     let multiline = /[\r\n]/.test(node.value);
     return node.selectionStart == node.value.length ? true :
            node.selectionStart == 0 && !multiline;
   },
 
   /**
    * Completes the current typed text in the inputNode. Completion is performed
@@ -4279,17 +4292,17 @@ JSTerm.prototype = {
     if (!inputValue) {
       this.clearCompletion();
       callback && callback(this);
       this.emit("autocomplete-updated");
       return false;
     }
 
     // Only complete if the selection is empty.
-    if (inputNode.selectionStart != inputNode.selectionEnd) {
+    if (this.isSomethingSelected) {
       this.clearCompletion();
       callback && callback(this);
       this.emit("autocomplete-updated");
       return false;
     }
 
     // Update the completion results.
     if (this.lastCompletion.value != inputValue || frameActor != this._lastFrameActorId) {
