# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  ca4acb214ef7f747898764c60b8cd3aaeae0bb5d
Require accessKey to be properly set on the label instead of reading from binding parent

diff --git a/toolkit/content/tests/chrome/test_labelcontrol.xul b/toolkit/content/tests/chrome/test_labelcontrol.xul
--- a/toolkit/content/tests/chrome/test_labelcontrol.xul
+++ b/toolkit/content/tests/chrome/test_labelcontrol.xul
@@ -6,38 +6,36 @@
   -->
 <window title="tabindex" width="500" height="600"
         onload="runTests()"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>  
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>  
 
 <label id="lab" control="ctl"/>
-<textbox id="ctl" value="Test"/>
-<checkbox id="chk" value="Checkbox"/>
+<checkbox id="ctl" value="Checkbox"/>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
 <p id="display"></p>
 <div id="content" style="display: none">
 </div>
 <pre id="test">
 </pre>
 </body>
 
 <script>
 <![CDATA[
 
 SimpleTest.waitForExplicitFinish();
- 
+
 function runTests()
 {
   is($("lab").control, "ctl", "control");
   is($("lab").labeledControlElement, $("ctl"), "labeledControlElement");
   is($("ctl").labelElement, $("lab"), "labelElement");
-  is($("chk").labelElement.className, "checkbox-label", "labelElement");
 
   SimpleTest.finish();
 }
 
 ]]>
 
 </script>
 
diff --git a/toolkit/content/widgets/general.xml b/toolkit/content/widgets/general.xml
--- a/toolkit/content/widgets/general.xml
+++ b/toolkit/content/widgets/general.xml
@@ -28,33 +28,40 @@
       <property name="label"      onset="this.setAttribute('label',val); return val;"
                                   onget="return this.getAttribute('label');"/>
       <property name="crop"       onset="this.setAttribute('crop',val); return val;"
                                   onget="return this.getAttribute('crop');"/>
       <property name="image"      onset="this.setAttribute('image',val); return val;"
                                   onget="return this.getAttribute('image');"/>
       <property name="command"    onset="this.setAttribute('command',val); return val;"
                                   onget="return this.getAttribute('command');"/>
+      <property name="labelElement">
+        <getter>
+          <![CDATA[
+            return document.getElementsByAttribute("control", this.id)[0];
+          ]]>
+        </getter>
+      </property>
       <property name="accessKey">
         <getter>
           <![CDATA[
-            return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+            let labelElement = this.labelElement;
+            return labelElement ? labelElement.accessKey : this.getAttribute("accesskey");
           ]]>
         </getter>
         <setter>
           <![CDATA[
             // Always store on the control
             this.setAttribute("accesskey", val);
             // If there is a label, change the accesskey on the labelElement
             // if it's also set there
-            if (this.labelElement) {
-              this.labelElement.accessKey = val;
+            let labelElement = this.labelElement;
+            if (labelElement) {
+              labelElement.accessKey = val;
             }
             return val;
           ]]>
         </setter>
       </property>
-
-      <field name="labelElement"/>
     </implementation>
   </binding>
 
 </bindings>
diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -13,17 +13,17 @@ function mergeElement(element) {
     element.previousSibling.appendData(element.textContent);
   } else {
     element.parentNode.insertBefore(element.firstChild, element);
   }
   element.remove();
 }
 
 function wrapChar(parent, element, index) {
-  var treeWalker = document.createTreeWalker(parent,
+  var treeWalker = document.createNodeIterator(parent,
     NodeFilter.SHOW_TEXT,
     null);
   var node = treeWalker.nextNode();
   while (index >= node.length) {
     index -= node.length;
     node = treeWalker.nextNode();
   }
   if (index) {
@@ -52,127 +52,93 @@ function setGlobalAccessKeyFormattingSta
       "intl.menuitems.alwaysappendaccesskeys";
 
     var val = Services.prefs.getComplexValue(prefNameInsertSeparator,
       nsIPrefLocalizedString).data;
     gInsertSeparator = (val == "true");
 
     val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
       nsIPrefLocalizedString).data;
-    gAlwaysAppendAccessKey = (val == "true");
+    gAlwaysAppendAccessKey = val == "true";
   } catch (e) {
     gInsertSeparator = true;
   }
-  // console.log("setGlobalAccessKeyFormattingState", gInsertSeparator, gUnderlineAccesskey, gAlwaysAppendAccessKey);
 }
 
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
-  constructor() {
-    super();
-
-    setGlobalAccessKeyFormattingState();
-
-    this.addEventListener("click", event => {
-      if (!this.isTextLink || (event.button != 0 && event.button != 1)) {
-        return;
-      }
-      this.open(event);
-    }, true);
-
-    this.addEventListener("keypress", event => {
-      if (!this.isTextLink || event.keyCode != 13) {
-        return;
-      }
-      this.click();
-    });
-
-    this.addEventListener("click", (event) => {
-      if (this.disabled || !this.isLabelControl) {
-        return;
-      }
-      var controlElement = this.labeledControlElement;
-      if (!controlElement) {
-        return;
-      }
-      controlElement.focus();
-      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
-      if (controlElement.namespaceURI != XUL_NS) {
-        return;
-      }
-      if (controlElement.localName == "checkbox") {
-        controlElement.checked = !controlElement.checked;
-      } else if (controlElement.localName == "radio") {
-        controlElement.control.selectedItem = controlElement;
-      }
-    });
-  }
-
   static get observedAttributes() {
-    return ["control", "class"];
+    return ["accesskey"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
-    if (oldValue == newValue) {
-      return;
-    }
-    this.setupAsControlIfNeeded();
+    // if (!this.isConnectedAndReady || oldValue == newValue) {
+    //   return;
+    // }
+    // console.log("caught attr change", oldValue, newValue, this);
+    // setTimeout(() => {
+    //   console.log("still?", this.getAttribute(name) == newValue, this);
+    // }, 100);
+    // console.trace();
+    // XXX: Reformat accessKey
+    // this.formatAccessKey();
   }
 
   connectedCallback() {
     if (this.delayConnectedCallback()) {
       return;
     }
-    this.setupAsControlIfNeeded();
+
+
+    if (!this.connectedOnce) {
+      this.connectedOnce = true;
+      setGlobalAccessKeyFormattingState();
+      this.addEventListener("click", event => {
+        if (!this.isTextLink || (event.button != 0 && event.button != 1)) {
+          return;
+        }
+        this.open(event);
+      }, true);
+
+      this.addEventListener("keypress", event => {
+        if (!this.isTextLink || event.keyCode != 13) {
+          return;
+        }
+        this.click();
+      });
+
+      this.addEventListener("click", (event) => {
+        var controlElement = this.labeledControlElement;
+        if (!controlElement || this.disabled) {
+          return;
+        }
+        controlElement.focus();
+        const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+        if (controlElement.namespaceURI != XUL_NS) {
+          return;
+        }
+        if (controlElement.localName == "checkbox") {
+          controlElement.checked = !controlElement.checked;
+        } else if (controlElement.localName == "radio") {
+          controlElement.control.selectedItem = controlElement;
+        }
+      });
+    }
+
+    // this.inMenubar = this.closest("menubar");
+    // this.formatAccessKey();
   }
 
   get isTextLink() {
     return this.classList.contains("text-link") || this.hasAttribute("onClick");
   }
 
-  setupAsControlIfNeeded() {
-    if (!this.isConnectedAndReady) {
-      return;
-    }
-
-    let wasLabelControl = this.isLabelControl;
-    this.isLabelControl = this.hasAttribute("control") ||
-                          this.classList.contains("radio-label") ||
-                          this.classList.contains("checkbox-label") ||
-                          this.classList.contains("toolbarbutton-multiline-text");
-    if (!wasLabelControl && this.isLabelControl) {
-      if (gUnderlineAccesskey) {
-        this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
-        this.appendChild(this.accessKeyParens);
-      }
-      this.formatAccessKey(true);
-    }
-
-    if (wasLabelControl && !this.isLabelControl) {
-      this.accessKeyParens.remove();
-    }
-  }
-
   set accessKey(val) {
-    if (!this.isLabelControl) {
-      this.setAttribute("accesskey", val);
-      return val;
-    }
-
-    // If this label already has an accesskey attribute store it here as well
-    if (this.hasAttribute("accesskey")) {
-      this.setAttribute("accesskey", val);
-    }
-    var control = this.labeledControlElement;
-    if (control) {
-      control.setAttribute("accesskey", val);
-    }
-    this.formatAccessKey(false);
-    return val;
+    this.setAttribute("accesskey", val);
   }
 
   get accessKey() {
     var accessKey = this.getAttribute("accesskey");
     return accessKey ? accessKey[0] : null;
   }
 
   get labeledControlElement() {
@@ -180,44 +146,122 @@ class MozTextLabel extends MozElementMix
       return null;
     }
 
     var control = this.control;
     return control ? document.getElementById(control) : null;
   }
 
   set control(val) {
-    if (!this.isLabelControl) {
-      // After this gets set, the label will switch to `isLabelControl`
-      this.setAttribute("control", val);
-      return val;
-    }
-
-    var control = this.labeledControlElement;
-    if (control) {
-      control.labelElement = null; // No longer pointed to be this label
-    }
     this.setAttribute("control", val);
-    this.formatAccessKey(false);
-    return val;
   }
 
   get control() {
     return this.getAttribute("control");
   }
 
   set href(val) {
     this.setAttribute("href", val);
-    return val;
   }
 
   get href() {
     return this.getAttribute("href");
   }
 
+  formatAccessKey() {
+    if (!gUnderlineAccesskey)
+      return;
+
+    // XXX: is this the slow part?
+    if (this.inMenubar) {
+      return;
+    }
+
+    var accessKey = this.accessKey;
+    if (!accessKey) {
+      return;
+    }
+
+    if (!this.accessKeyParens) {
+      this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+      this.appendChild(this.accessKeyParens);
+    }
+
+    var afterLabel = this.accessKeyParens;
+    afterLabel.textContent = "";
+
+    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
+    if (oldAccessKey) { // Clear old accesskey
+      mergeElement(oldAccessKey);
+    }
+
+    var oldHiddenSpan =
+      this.getElementsByAttribute("class", "hiddenColon").item(0);
+    if (oldHiddenSpan) {
+      mergeElement(oldHiddenSpan);
+    }
+
+    var labelText = this.textContent;
+    if (!accessKey || !labelText) {
+      return;
+    }
+    var accessKeyIndex = -1;
+    if (!gAlwaysAppendAccessKey) {
+      accessKeyIndex = labelText.indexOf(accessKey);
+      if (accessKeyIndex < 0) { // Try again in upper case
+        accessKeyIndex =
+          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+      }
+    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+    }
+
+    const HTML_NS = "http://www.w3.org/1999/xhtml";
+    var span = document.createElementNS(HTML_NS, "span");
+    span.className = "accesskey";
+
+    // Note that if you change the following code, see the comment of
+    // nsTextBoxFrame::UpdateAccessTitle.
+
+    // If accesskey is not in string, append in parentheses
+    if (accessKeyIndex < 0) {
+      // If end is colon, we should insert before colon.
+      // i.e., "label:" -> "label(X):"
+      var colonHidden = false;
+      if (/:$/.test(labelText)) {
+        labelText = labelText.slice(0, -1);
+        var hiddenSpan = document.createElementNS(HTML_NS, "span");
+        hiddenSpan.className = "hiddenColon";
+        hiddenSpan.style.display = "none";
+        // Hide the last colon by using span element.
+        // I.e., label<span style="display:none;">:</span>
+        wrapChar(this, hiddenSpan, labelText.length);
+        colonHidden = true;
+      }
+      // If end is space(U+20),
+      // we should not add space before parentheses.
+      var endIsSpace = false;
+      if (/ $/.test(labelText)) {
+        endIsSpace = true;
+      }
+      if (gInsertSeparator && !endIsSpace)
+        afterLabel.textContent = " (";
+      else
+        afterLabel.textContent = "(";
+      span.textContent = accessKey.toUpperCase();
+      afterLabel.appendChild(span);
+      if (!colonHidden)
+        afterLabel.appendChild(document.createTextNode(")"));
+      else
+        afterLabel.appendChild(document.createTextNode("):"));
+      return;
+    }
+    wrapChar(this, span, accessKeyIndex);
+  }
+
   open(aEvent) {
     if (!this.isTextLink) {
       return;
     }
 
     var href = this.href;
     if (!href || this.disabled || aEvent.defaultPrevented)
       return;
@@ -281,116 +325,13 @@ class MozTextLabel extends MozElementMix
     // otherwise, fall back to opening the anchor directly
     var win = window;
     if (window.isChromeWindow) {
       while (win.opener && !win.opener.closed)
         win = win.opener;
     }
     win.open(href);
   }
-
-  formatAccessKey(firstTime) {
-    if (!this.isLabelControl) {
-      return;
-    }
-
-    var control = this.labeledControlElement;
-    if (!control) {
-      var bindingParent = document.getBindingParent(this);
-      if (!bindingParent) {
-        throw new Error("Label created without control or binding parent");
-      }
-      if ("accessKey" in bindingParent) {
-        control = bindingParent; // For controls that make the <label> an anon child
-      }
-    }
-    if (control) {
-      control.labelElement = this;
-      var controlAccessKey = control.getAttribute("accesskey");
-      if (controlAccessKey) {
-        this.setAttribute("accesskey", controlAccessKey);
-      }
-    }
-
-    if (!gUnderlineAccesskey)
-      return;
-
-    var accessKey = this.accessKey;
-    // No need to remove existing formatting the first time.
-    if (firstTime && !accessKey)
-      return;
-
-    var afterLabel = this.accessKeyParens;
-    afterLabel.textContent = "";
-
-    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
-    if (oldAccessKey) { // Clear old accesskey
-      mergeElement(oldAccessKey);
-    }
-
-    var oldHiddenSpan =
-      this.getElementsByAttribute("class", "hiddenColon").item(0);
-    if (oldHiddenSpan) {
-      mergeElement(oldHiddenSpan);
-    }
-
-    var labelText = this.textContent;
-    if (!accessKey || !labelText || !control) {
-      return;
-    }
-    var accessKeyIndex = -1;
-    if (!gAlwaysAppendAccessKey) {
-      accessKeyIndex = labelText.indexOf(accessKey);
-      if (accessKeyIndex < 0) { // Try again in upper case
-        accessKeyIndex =
-          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
-      }
-    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
-      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
-    }
-
-    const HTML_NS = "http://www.w3.org/1999/xhtml";
-    var span = document.createElementNS(HTML_NS, "span");
-    span.className = "accesskey";
-
-    // Note that if you change the following code, see the comment of
-    // nsTextBoxFrame::UpdateAccessTitle.
-
-    // If accesskey is not in string, append in parentheses
-    if (accessKeyIndex < 0) {
-      // If end is colon, we should insert before colon.
-      // i.e., "label:" -> "label(X):"
-      var colonHidden = false;
-      if (/:$/.test(labelText)) {
-        labelText = labelText.slice(0, -1);
-        var hiddenSpan = document.createElementNS(HTML_NS, "span");
-        hiddenSpan.className = "hiddenColon";
-        hiddenSpan.style.display = "none";
-        // Hide the last colon by using span element.
-        // I.e., label<span style="display:none;">:</span>
-        wrapChar(this, hiddenSpan, labelText.length);
-        colonHidden = true;
-      }
-      // If end is space(U+20),
-      // we should not add space before parentheses.
-      var endIsSpace = false;
-      if (/ $/.test(labelText)) {
-        endIsSpace = true;
-      }
-      if (gInsertSeparator && !endIsSpace)
-        afterLabel.textContent = " (";
-      else
-        afterLabel.textContent = "(";
-      span.textContent = accessKey.toUpperCase();
-      afterLabel.appendChild(span);
-      if (!colonHidden)
-        afterLabel.appendChild(document.createTextNode(")"));
-      else
-        afterLabel.appendChild(document.createTextNode("):"));
-      return;
-    }
-    wrapChar(this, span, accessKeyIndex);
-  }
 }
 
 customElements.define("label", MozTextLabel);
 
 }
