# HG changeset patch
# Parent ab49c1ad9f2b77df921d9a782d68d4d49d367444
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 726427 - CSS transform preview tooltip in style inspector, r=bgrins

diff --git a/browser/devtools/shared/test/browser.ini b/browser/devtools/shared/test/browser.ini
--- a/browser/devtools/shared/test/browser.ini
+++ b/browser/devtools/shared/test/browser.ini
@@ -26,8 +26,9 @@ support-files =
 [browser_telemetry_toolboxtabs_options.js]
 [browser_telemetry_toolboxtabs_styleeditor.js]
 [browser_telemetry_toolboxtabs_webconsole.js]
 [browser_templater_basic.js]
 [browser_toolbar_basic.js]
 [browser_toolbar_tooltip.js]
 [browser_toolbar_webconsole_errors_count.js]
 [browser_spectrum.js]
+[browser_csstransformpreview.js]
diff --git a/browser/devtools/shared/test/browser_csstransformpreview.js b/browser/devtools/shared/test/browser_csstransformpreview.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/test/browser_csstransformpreview.js
@@ -0,0 +1,117 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Tests that the spectrum color picker works correctly
+
+const TEST_URI = "data:text/html;charset=utf-8,<div></div>";
+const {CSSTransformPreviewer} = devtools.require("devtools/shared/widgets/CSSTransformPreviewer");
+
+let doc, root;
+
+function test() {
+  waitForExplicitFinish();
+  addTab(TEST_URI, () => {
+    doc = content.document;
+    root = doc.querySelector("div");
+    startTests();
+  });
+}
+
+function endTests() {
+  doc = root = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function startTests() {
+  testCreateAndDestroyShouldAppendAndRemoveElements();
+}
+
+function testCreateAndDestroyShouldAppendAndRemoveElements() {
+  ok(root, "We have the root node to append the preview to");
+  is(root.childElementCount, 0, "Root node is empty");
+
+  let p = new CSSTransformPreviewer(root);
+  p.preview("matrix(1, -0.2, 0, 1, 0, 0)");
+  ok(root.childElementCount > 0, "Preview has appended elements");
+  ok(root.querySelector("canvas"), "Canvas preview element is here");
+
+  p.destroy();
+  is(root.childElementCount, 0, "Destroying preview removed all nodes");
+
+  testCanvasDimensionIsConstrainedByMaxDim();
+}
+
+function testCanvasDimensionIsConstrainedByMaxDim() {
+  let p = new CSSTransformPreviewer(root);
+  p.MAX_DIM = 500;
+  p.preview("scale(1)", "center", 1000, 1000);
+
+  let canvas = root.querySelector("canvas");
+  is(canvas.width, 500, "Canvas width is correct");
+  is(canvas.height, 500, "Canvas height is correct");
+
+  p.destroy();
+
+  testCallingPreviewSeveralTimesReusesTheSameCanvas();
+}
+
+function testCallingPreviewSeveralTimesReusesTheSameCanvas() {
+  let p = new CSSTransformPreviewer(root);
+
+  p.preview("scale(1)", "center", 1000, 1000);
+  let canvas = root.querySelector("canvas");
+
+  p.preview("rotate(90deg)");
+  let canvases = root.querySelectorAll("canvas");
+  is(canvases.length, 1, "Still one canvas element");
+  is(canvases[0], canvas, "Still the same canvas element");
+  p.destroy();
+
+  testCanvasDimensionCorrectInSomeCases();
+}
+
+function testCanvasDimensionCorrectInSomeCases() {
+  let p = new CSSTransformPreviewer(root);
+  p.MAX_DIM = 200;
+
+  // Translate a square by its width
+  p.preview("translateX(200px)", "center", 200, 200);
+  let canvas = root.querySelector("canvas");
+  is(canvas.width, 200, "width is correct");
+  is(canvas.height, 100, "height is half of the width");
+
+  // Rotate on the top right corner
+  p.preview("rotate(-90deg)", "top right", 200, 200);
+  is(canvas.width, 200, "width is correct");
+  is(canvas.height, 100, "height is half of the width");
+
+  p.destroy();
+
+  testPreviewingInvalidTransformReturnsFalse();
+}
+
+function testPreviewingInvalidTransformReturnsFalse() {
+  let p = new CSSTransformPreviewer(root);
+  ok(!p.preview("veryWow(muchPx) suchTransform(soDeg)"), "Returned false for invalid transform");
+  ok(!p.preview("rotae(3deg)"), "Returned false for invalid transform");
+
+  // Verify the canvas is empty by checking the image data
+  let canvas = root.querySelector("canvas"), ctx = canvas.getContext("2d");
+  let data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
+  for (let i = 0, n = data.length; i < n; i += 4) {
+    // Let's not log 250*250*4 asserts! Instead, just log when it fails
+    let red = data[i];
+    let green = data[i + 1];
+    let blue = data[i + 2];
+    let alpha = data[i + 3];
+    if (red !== 0 || green !== 0 || blue !== 0 || alpha !== 0) {
+      ok(false, "Image data is not empty after an invalid transformed was previewed");
+      break;
+    }
+  }
+
+  is(p.preview("translateX(30px)"), true, "Returned true for a valid transform");
+  endTests();
+}
diff --git a/browser/devtools/shared/widgets/CSSTransformPreviewer.js b/browser/devtools/shared/widgets/CSSTransformPreviewer.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/widgets/CSSTransformPreviewer.js
@@ -0,0 +1,353 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ * The CSSTransformPreview module displays, using a <canvas> a rectangle, with
+ * a given width and height and its transformed version, given a css transform
+ * property and origin. It also displays arrows from/to each corner.
+ *
+ * It is useful to visualize how a css transform affected an element. It can
+ * help debug tricky transformations. It is used today in a tooltip, and this
+ * tooltip is shown when hovering over a css transform declaration in the rule
+ * and computed view panels.
+ *
+ * TODO: For now, it multiplies matrices itself to calculate the coordinates of
+ * the transformed box, but that should be removed as soon as we can get access
+ * to getQuads().
+ */
+
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+
+/**
+ * The TransformPreview needs an element to output a canvas tag.
+ *
+ * Usage example:
+ *
+ * let t = new CSSTransformPreviewer(myRootElement);
+ * t.preview("rotate(45deg)", "top left", 200, 400);
+ * t.preview("skew(19deg)", "center", 100, 500);
+ * t.preview("matrix(1, -0.2, 0, 1, 0, 0)");
+ * t.destroy();
+ *
+ * @param {nsIDOMElement} parentEl
+ *        Where the canvas will go
+ */
+function CSSTransformPreviewer(parentEl) {
+  this.parentEl = parentEl;
+  this.doc = this.parentEl.ownerDocument;
+  this.canvas = null;
+  this.ctx = null;
+}
+
+module.exports.CSSTransformPreviewer = CSSTransformPreviewer;
+
+CSSTransformPreviewer.prototype = {
+  /**
+   * The preview look-and-feel can be changed using these properties
+   */
+  MAX_DIM: 250,
+  PAD: 5,
+  ORIGINAL_FILL: "#1F303F",
+  ORIGINAL_STROKE: "#B2D8FF",
+  TRANSFORMED_FILL: "rgba(200, 200, 200, .5)",
+  TRANSFORMED_STROKE: "#B2D8FF",
+  ARROW_STROKE: "#329AFF",
+  ORIGIN_STROKE: "#329AFF",
+  ARROW_TIP_HEIGHT: 10,
+  ARROW_TIP_WIDTH: 8,
+
+  /**
+   * Destroy removes the canvas from the parentelement passed in the constructor
+   */
+  destroy: function() {
+    if (this.canvas) this.parentEl.removeChild(this.canvas);
+    if (this._hiddenDiv) this.parentEl.removeChild(this._hiddenDiv);
+    this.parentEl = this.canvas = this.ctx = null;
+  },
+
+  _createMarkup: function() {
+    this.canvas = this.doc.createElementNS(HTML_NS, "canvas");
+
+    this.canvas.setAttribute("id", "canvas");
+    this.canvas.setAttribute("width", this.MAX_DIM);
+    this.canvas.setAttribute("height", this.MAX_DIM);
+    this.canvas.style.position = "relative";
+    this.parentEl.appendChild(this.canvas);
+
+    this.ctx = this.canvas.getContext("2d");
+  },
+
+  _getComputed: function(name, value, width, height) {
+    if (!this._hiddenDiv) {
+      // Create a hidden element to apply the style to
+      this._hiddenDiv = this.doc.createElementNS(HTML_NS, "div");
+      this._hiddenDiv.style.visibility = "hidden";
+      this._hiddenDiv.style.position = "absolute";
+      this.parentEl.appendChild(this._hiddenDiv);
+    }
+
+    // Camelcase the name
+    name = name.replace(/-([a-z]{1})/g, (m, letter) => letter.toUpperCase());
+
+    // Apply width and height to make sure computation is made correctly
+    this._hiddenDiv.style.width = width + "px";
+    this._hiddenDiv.style.height = height + "px";
+
+    // Show the hidden div, apply the style, read the computed style, hide the
+    // hidden div again
+    this._hiddenDiv.style.display = "block";
+    this._hiddenDiv.style[name] = value;
+    let computed = this.doc.defaultView.getComputedStyle(this._hiddenDiv);
+    let computedValue = computed[name];
+    this._hiddenDiv.style.display = "none";
+
+    return computedValue;
+  },
+
+  _getMatrixFromTransformString: function(transformStr) {
+    let matrix = transformStr.substring(0, transformStr.length - 1).
+      substring(transformStr.indexOf("(") + 1).split(",");
+
+    matrix.forEach(function(value, index) {
+      matrix[index] = parseFloat(value, 10);
+    });
+
+    let transformMatrix = null;
+
+    if (matrix.length === 6) {
+      // 2d transform
+      transformMatrix = [
+        [matrix[0], matrix[2], matrix[4], 0],
+        [matrix[1], matrix[3], matrix[5], 0],
+        [0,     0,     1,     0],
+        [0,     0,     0,     1]
+      ];
+    } else {
+      // 3d transform
+      transformMatrix = [
+        [matrix[0], matrix[4], matrix[8],  matrix[12]],
+        [matrix[1], matrix[5], matrix[9],  matrix[13]],
+        [matrix[2], matrix[6], matrix[10], matrix[14]],
+        [matrix[3], matrix[7], matrix[11], matrix[15]]
+      ];
+    }
+
+    return transformMatrix;
+  },
+
+  _getOriginFromOriginString: function(originStr) {
+    let offsets = originStr.split(" ");
+    offsets.forEach(function(item, index) {
+      offsets[index] = parseInt(item, 10);
+    });
+
+    return offsets;
+  },
+
+  // Get the coords of the target without transformation
+  _getOriginalRect: function(width, height) {
+    return {
+      x1: 0,
+      y1: 0,
+      x2: width,
+      y2: 0,
+      x3: width,
+      y3: height,
+      x4: 0,
+      y4: height
+    };
+  },
+
+  _multiply: function(m1, m2) {
+    let m = [];
+    for (let m1Line = 0; m1Line < m1.length; m1Line ++) {
+      m[m1Line] = 0;
+      for (let m2Col = 0; m2Col < m2.length; m2Col ++) {
+        m[m1Line] += m1[m1Line][m2Col] * m2[m2Col];
+      }
+    }
+    return {x: m[0], y: m[1]};
+  },
+
+  _getTransformedRect: function(matrix, originRect, origin) {
+    let tlMatrix = [originRect.x1 - origin[0], originRect.y1 - origin[1], 1, 1];
+    let trMatrix = [originRect.x2 - origin[0], originRect.y2 - origin[1], 1, 1];
+    let brMatrix = [originRect.x3 - origin[0], originRect.y3 - origin[1], 1, 1];
+    let blMatrix = [originRect.x4 - origin[0], originRect.y4 - origin[1], 1, 1];
+
+    let topLeft = this._multiply(matrix, tlMatrix);
+    let topRight = this._multiply(matrix, trMatrix);
+    let bottomRight = this._multiply(matrix, brMatrix);
+    let bottomLeft = this._multiply(matrix, blMatrix);
+
+    return {
+      x1: topLeft.x + origin[0],
+      y1: topLeft.y + origin[1],
+      x2: topRight.x + origin[0],
+      y2: topRight.y + origin[1],
+      x3: bottomRight.x + origin[0],
+      y3: bottomRight.y + origin[1],
+      x4: bottomLeft.x + origin[0],
+      y4: bottomLeft.y + origin[1]
+    };
+  },
+
+  /**
+   * For canvas to avoid anti-aliasing
+   */
+  _round: x => Math.round(x) + .5,
+
+  _drawRect: function(rect, fillStyle, strokeStyle) {
+    this.ctx.save();
+
+    this.ctx.lineWidth = 1;
+    this.ctx.strokeStyle = strokeStyle;
+    this.ctx.fillStyle = fillStyle;
+
+    this.ctx.beginPath();
+    this.ctx.moveTo(this._round(rect.x1), this._round(rect.y1));
+    this.ctx.lineTo(this._round(rect.x2), this._round(rect.y2));
+    this.ctx.lineTo(this._round(rect.x3), this._round(rect.y3));
+    this.ctx.lineTo(this._round(rect.x4), this._round(rect.y4));
+    this.ctx.lineTo(this._round(rect.x1), this._round(rect.y1));
+    this.ctx.fill();
+    this.ctx.stroke();
+
+    this.ctx.restore();
+  },
+
+  _drawLine: function(x1, y1, x2, y2) {
+    // do not draw if the line is too small
+    if (Math.abs(x2-x1) < 20 && Math.abs(y2-y1) < 20) {
+      return;
+    }
+
+    this.ctx.save();
+
+    this.ctx.strokeStyle = this.ARROW_STROKE;
+    this.ctx.fillStyle = this.ARROW_STROKE;
+    this.ctx.lineWidth = 1;
+
+    // line
+    this.ctx.beginPath();
+    this.ctx.moveTo(this._round(x1), this._round(y1));
+    this.ctx.lineTo(this._round(x2), this._round(y2));
+    this.ctx.stroke();
+
+    // tip
+    this.ctx.beginPath();
+    this.ctx.translate(x2, y2);
+    let radians = Math.atan((y1 - y2) / (x1 - x2));
+    radians += ((x1 >= x2) ? -90 : 90) * Math.PI / 180;
+    this.ctx.rotate(radians);
+    this.ctx.moveTo(0, 0);
+    this.ctx.lineTo(this.ARROW_TIP_WIDTH / 2, this.ARROW_TIP_HEIGHT);
+    this.ctx.lineTo(-this.ARROW_TIP_WIDTH / 2, this.ARROW_TIP_HEIGHT);
+    this.ctx.closePath();
+    this.ctx.fill();
+
+    this.ctx.restore();
+  },
+
+  _drawOrigin: function(x, y) {
+    this.ctx.save();
+
+    this.ctx.strokeStyle = this.ORIGIN_STROKE;
+    this.ctx.fillStyle = this.ORIGIN_STROKE;
+
+    this.ctx.beginPath();
+    this.ctx.arc(x, y, 4, 0, 2 * Math.PI, false);
+    this.ctx.stroke();
+    this.ctx.fill();
+
+    this.ctx.restore();
+  },
+
+  /**
+   * Draw a transform preview
+   *
+   * @param {String} transform
+   *        The css transform value as a string, as typed by the user, as long
+   *        as it can be computed by the browser
+   * @param {String} origin
+   *        Same as above for the transform-origin value. Defaults to "center"
+   * @param {Number} width
+   *        The width of the container. Defaults to 200
+   * @param {Number} height
+   *        The height of the container. Defaults to 200
+   * @return {Boolean} Whether or not the preview could be created. Will return
+   *         false for instance if the transform is invalid
+   */
+  preview: function(transform, origin="center", width=200, height=200) {
+    // Create/clear the canvas
+    if (!this.canvas) {
+      this._createMarkup();
+    }
+    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
+
+    // Get computed versions of transform and origin
+    transform = this._getComputed("transform", transform, width, height);
+    if (transform && transform !== "none") {
+      origin = this._getComputed("transform-origin", origin, width, height);
+
+      // Get the matrix, origin and width height data for the previewed element
+      let originData = this._getOriginFromOriginString(origin);
+      let matrixData = this._getMatrixFromTransformString(transform);
+
+      // Compute the original box rect and transformed box rect
+      let oRect = this._getOriginalRect(width, height);
+      let tRect = this._getTransformedRect(matrixData, oRect, originData);
+
+      // Resize rects to fit everything in the canvas
+      let allXs = [], allYs = [];
+      for (let i = 1; i < 5; i ++) {
+        allXs.push(oRect["x" + i]);
+        allXs.push(tRect["x" + i]);
+        allYs.push(oRect["y" + i]);
+        allYs.push(tRect["y" + i]);
+      }
+      let minX = Math.min.apply(Math, allXs);
+      let maxX = Math.max.apply(Math, allXs);
+      let minY = Math.min.apply(Math, allYs);
+      let maxY = Math.max.apply(Math, allYs);
+
+      let spanX = maxX - minX;
+      let spanY = maxY - minY;
+      let isWide = spanX > spanY;
+
+      let cw = isWide ? this.MAX_DIM :
+        this.MAX_DIM * Math.min(spanX, spanY) / Math.max(spanX, spanY);
+      let ch = !isWide ? this.MAX_DIM :
+        this.MAX_DIM * Math.min(spanX, spanY) / Math.max(spanX, spanY);
+
+      this.canvas.setAttribute("width", cw);
+      this.canvas.setAttribute("height", ch);
+
+      let mapX = x => this.PAD + ((cw - 2 * this.PAD) / (maxX - minX)) * (x - minX);
+      let mapY = y => this.PAD + ((ch - 2 * this.PAD) / (maxY - minY)) * (y - minY);
+
+      for (let i = 1; i < 5; i ++) {
+        oRect["x" + i] = mapX(oRect["x" + i]);
+        oRect["y" + i] = mapY(oRect["y" + i]);
+        tRect["x" + i] = mapX(tRect["x" + i]);
+        tRect["y" + i] = mapY(tRect["y" + i]);
+      }
+
+      this._drawRect(oRect, this.ORIGINAL_FILL, this.ORIGINAL_STROKE);
+      this._drawRect(tRect, this.TRANSFORMED_FILL, this.TRANSFORMED_STROKE);
+
+      this._drawLine(oRect.x1, oRect.y1, tRect.x1, tRect.y1);
+      this._drawLine(oRect.x2, oRect.y2, tRect.x2, tRect.y2);
+      this._drawLine(oRect.x3, oRect.y3, tRect.x3, tRect.y3);
+      this._drawLine(oRect.x4, oRect.y4, tRect.x4, tRect.y4);
+
+      this._drawOrigin(mapX(originData[0]), mapY(originData[1]));
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
diff --git a/browser/devtools/shared/widgets/Tooltip.js b/browser/devtools/shared/widgets/Tooltip.js
--- a/browser/devtools/shared/widgets/Tooltip.js
+++ b/browser/devtools/shared/widgets/Tooltip.js
@@ -7,29 +7,29 @@
 const {Cc, Cu, Ci} = require("chrome");
 const promise = require("sdk/core/promise");
 const IOService = Cc["@mozilla.org/network/io-service;1"]
   .getService(Ci.nsIIOService);
 const {Spectrum} = require("devtools/shared/widgets/Spectrum");
 const EventEmitter = require("devtools/shared/event-emitter");
 const {colorUtils} = require("devtools/css-color");
 const Heritage = require("sdk/core/heritage");
+const {CSSTransformPreviewer} = require("devtools/shared/widgets/CSSTransformPreviewer");
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 
 const GRADIENT_RE = /\b(repeating-)?(linear|radial)-gradient\(((rgb|hsl)a?\(.+?\)|[^\)])+\)/gi;
 const BORDERCOLOR_RE = /^border-[-a-z]*color$/ig;
 const BORDER_RE = /^border(-(top|bottom|left|right))?$/ig;
 const BACKGROUND_IMAGE_RE = /url\([\'\"]?(.*?)[\'\"]?\)/;
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const SPECTRUM_FRAME = "chrome://browser/content/devtools/spectrum-frame.xhtml";
 const ESCAPE_KEYCODE = Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE;
 const ENTER_KEYCODE = Ci.nsIDOMKeyEvent.DOM_VK_RETURN;
-const SHOW_TIMEOUT = 50;
 
 /**
  * Tooltip widget.
  *
  * This widget is intended at any tool that may need to show rich content in the
  * form of floating panels.
  * A common use case is image previewing in the CSS rule view, but more complex
  * use cases may include color pickers, object inspection, etc...
@@ -87,17 +87,16 @@ let PanelFactory = {
    *        An options store to get some configuration from
    */
   get: function(doc, options) {
     // Create the tooltip
     let panel = doc.createElement("panel");
     panel.setAttribute("hidden", true);
     panel.setAttribute("ignorekeys", true);
 
-    // Prevent the click used to close the panel from being consumed
     panel.setAttribute("consumeoutsideclicks", options.get("consumeOutsideClick"));
     panel.setAttribute("noautofocus", options.get("noAutoFocus"));
     panel.setAttribute("type", "arrow");
     panel.setAttribute("level", "top");
 
     panel.setAttribute("class", "devtools-tooltip theme-tooltip-panel");
     doc.querySelector("window").appendChild(panel);
 
@@ -179,16 +178,17 @@ function Tooltip(doc, options) {
 }
 
 module.exports.Tooltip = Tooltip;
 
 Tooltip.prototype = {
   defaultPosition: "before_start",
   defaultOffsetX: 0,
   defaultOffsetY: 0,
+  defaultShowDelay: 50,
 
   /**
    * Show the tooltip. It might be wise to append some content first if you
    * don't want the tooltip to be empty. You may access the content of the
    * tooltip by setting a XUL node to t.content.
    * @param {node} anchor
    *        Which node should the tooltip be shown on
    * @param {string} position
@@ -277,21 +277,23 @@ Tooltip.prototype = {
    * @param {node} baseNode
    *        The container for all target nodes
    * @param {Function} targetNodeCb
    *        A function that accepts a node argument and returns true or false
    *        to signify if the tooltip should be shown on that node or not.
    *        Additionally, the function receives a second argument which is the
    *        tooltip instance itself, to be used to add/modify the content of the
    *        tooltip if needed. If omitted, the tooltip will be shown everytime.
+   *        Note that on top of a boolean, the function may return a node. This
+   *        can be used to show the tooltip on a different node.
    * @param {Number} showDelay
    *        An optional delay that will be observed before showing the tooltip.
-   *        Defaults to SHOW_TIMEOUT
+   *        Defaults to this.defaultShowDelay
    */
-  startTogglingOnHover: function(baseNode, targetNodeCb, showDelay=SHOW_TIMEOUT) {
+  startTogglingOnHover: function(baseNode, targetNodeCb, showDelay=this.defaultShowDelay) {
     if (this._basedNode) {
       this.stopTogglingOnHover();
     }
 
     this._basedNode = baseNode;
     this._showDelay = showDelay;
     this._targetNodeCb = targetNodeCb || (() => true);
 
@@ -326,17 +328,22 @@ Tooltip.prototype = {
       this._lastHovered = event.target;
       setNamedTimeout(this.uid, this._showDelay, () => {
         this._showOnHover(event.target);
       });
     }
   },
 
   _showOnHover: function(target) {
-    if (this._targetNodeCb(target, this)) {
+    let res = this._targetNodeCb(target, this);
+
+    // The cb can also return an element to change the target of the tooltip
+    target = res && res.nodeType ? res : target;
+
+    if (res) {
       this.show(target);
     }
   },
 
   _onBaseNodeMouseLeave: function() {
     clearNamedTimeout(this.uid);
     this._lastHovered = null;
     this.hide();
@@ -483,16 +490,59 @@ Tooltip.prototype = {
     }
     iframe.addEventListener("load", onLoad, true);
     iframe.setAttribute("src", SPECTRUM_FRAME);
 
     // Put the iframe in the tooltip
     this.content = iframe;
 
     return def.promise;
+  },
+
+  /**
+   * Set the content of the tooltip to be the result of CSSTransformPreview.
+   * Meaning a canvas previewing a css transformation.
+   *
+   * @param {String} transform
+   *        The CSS transform value (e.g. "rotate(45deg) translateX(50px)")
+   * @param {String} origin
+   *        The CSS transform-origin value (e.g. "center top"). This is optional
+   *        and if not provided, the pageStyle actor and node actor will be used
+   *        to get the computed transform-origin
+   * @param {PageStyleActor} pageStyle
+   *        An instance of the PageStyleActor that will be used to retrieve
+   *        computed styles
+   * @param {NodeActor} node
+   *        The NodeActor for the currently selected node
+   */
+  setCssTransformContent: function(transform, origin, pageStyle, node) {
+    if (transform) {
+      // Look into the computed styles to find the width and height and possibly
+      // the origin if it hadn't been provided
+      pageStyle.getComputed(node, {
+        filter: "user",
+        markMatched: false,
+        onlyMatched: false
+      }).then(styles => {
+        if (!origin) {
+          origin = styles["transform-origin"].value;
+        }
+        let width = parseInt(styles["width"].value);
+        let height = parseInt(styles["height"].value);
+
+        let root = this.doc.createElementNS(XHTML_NS, "div");
+        this.content = root;
+        let previewer = new CSSTransformPreviewer(root);
+        // If the preview doesn't work (invalid transform for instance) then
+        // hide the tooltip right away
+        if (!previewer.preview(transform, origin, width, height)) {
+          this.hide();
+        }
+      });
+    }
   }
 };
 
 /**
  * Base class for all (color, gradient, ...)-swatch based value editors inside
  * tooltips
  *
  * @param {XULDocument} doc
diff --git a/browser/devtools/styleinspector/computed-view.js b/browser/devtools/styleinspector/computed-view.js
--- a/browser/devtools/styleinspector/computed-view.js
+++ b/browser/devtools/styleinspector/computed-view.js
@@ -500,31 +500,38 @@ CssHtmlTree.prototype = {
   },
 
   /**
    * Verify that target is indeed a css value we want a tooltip on, and if yes
    * prepare some content for the tooltip
    */
   _buildTooltipContent: function(target)
   {
-    // If the hovered element is not a property view and is not a background
-    // image, then don't show a tooltip
-    let isPropertyValue = target.classList.contains("property-value");
-    if (!isPropertyValue) {
-      return false;
-    }
-    let propName = target.parentNode.querySelector(".property-name");
-    let isBackgroundImage = propName.textContent === "background-image";
-    if (!isBackgroundImage) {
-      return false;
+    // Test for image url
+    if (target.classList.contains("theme-link")) {
+      let propValue = target.parentNode;
+      let propName = propValue.parentNode.querySelector(".property-name");
+      if (propName.textContent === "background-image") {
+        this.tooltip.setCssBackgroundImageContent(propValue.textContent);
+        return true;
+      }
     }
 
-    // Fill some content
-    this.tooltip.setCssBackgroundImageContent(target.textContent);
-    return true;
+    // Test for css transform
+    if (target.classList.contains("property-value")) {
+      let propValue = target;
+      let propName = target.parentNode.querySelector(".property-name");
+      if (propName.textContent === "transform") {
+        // In the computed-view, we always pass the transform-origin to null so
+        // that it is retrieved from the computed styles.
+        this.tooltip.setCssTransformContent(propValue.textContent, null,
+          this.pageStyle, this.viewedElement);
+        return true;
+      }
+    }
   },
 
   /**
    * Create a context menu.
    */
   _buildContextMenu: function()
   {
     let doc = this.styleDocument.defaultView.parent.document;
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1120,37 +1120,48 @@ CssRuleView.prototype = {
     popupset.appendChild(this._contextmenu);
   },
 
   /**
    * Verify that target is indeed a css value we want a tooltip on, and if yes
    * prepare some content for the tooltip
    */
   _buildTooltipContent: function(target) {
+    let property = target.textProperty, hasTooltip = false;
+
+    // Test for css transform
+    if (property && property.name === "transform") {
+      // Look into the rule see if there is the origin
+      let origin;
+      for (let prop of property.rule.textProps) {
+        if (prop.name === "transform-origin") {
+          origin = prop.value;
+        }
+      }
+      this.previewTooltip.setCssTransformContent(property.value, origin,
+        this.pageStyle, this._viewedElement);
+      hasTooltip = true;
+    }
+
+    // Test for image
     let isImageHref = target.classList.contains("theme-link") &&
       target.parentNode.classList.contains("ruleview-propertyvalue");
-
-    // If the inplace-editor is visible or if this is not a background image
-    // don't show the tooltip
-    if (!isImageHref) {
-      return false;
+    if (isImageHref) {
+      property = target.parentNode.textProperty;
+      this.previewTooltip.setCssBackgroundImageContent(property.value,
+        property.rule.domRule.href);
+      hasTooltip = true;
     }
 
-    // Retrieve the TextProperty for the hovered element
-    let property = target.parentNode.textProperty;
-    let href = property.rule.domRule.href;
-
-    // Fill some content
-    this.previewTooltip.setCssBackgroundImageContent(property.value, href);
-
-    // Hide the color picker tooltip if shown and revert changes
-    this.colorPicker.revert();
-    this.colorPicker.hide();
-
-    return true;
+    if (hasTooltip) {
+      // Hide the color picker tooltip if shown and revert changes
+      this.colorPicker.revert();
+      this.colorPicker.hide();
+      return true;
+    }
   },
 
   /**
    * Update the context menu. This means enabling or disabling menuitems as
    * appropriate.
    */
   _contextMenuUpdate: function() {
     let win = this.doc.defaultView;
@@ -1296,17 +1307,17 @@ CssRuleView.prototype = {
     }
 
     this.popup.destroy();
   },
 
   /**
    * Update the highlighted element.
    *
-   * @param {nsIDOMElement} aElement
+   * @param {NodeActor} aElement
    *        The node whose style rules we'll inspect.
    */
   highlight: function CssRuleView_highlight(aElement)
   {
     if (this._viewedElement === aElement) {
       return promise.resolve(undefined);
     }
 
diff --git a/browser/devtools/styleinspector/test/Makefile.in b/browser/devtools/styleinspector/test/Makefile.in
--- a/browser/devtools/styleinspector/test/Makefile.in
+++ b/browser/devtools/styleinspector/test/Makefile.in
@@ -35,16 +35,17 @@ MOCHITEST_BROWSER_FILES = \
   browser_bug894376_css_value_completion_new_property_value_pair.js \
   browser_bug894376_css_value_completion_existing_property_value_pair.js \
   browser_ruleview_bug_902966_revert_value_on_ESC.js \
   browser_ruleview_pseudoelement.js \
   browser_computedview_bug835808_keyboard_nav.js \
   browser_bug913014_matched_expand.js \
   browser_bug765105_background_image_tooltip.js \
   browser_bug889638_rule_view_color_picker.js \
+  browser_bug726427_csstransform_tooltip.js \
   head.js \
   $(NULL)
 
 MOCHITEST_BROWSER_FILES += \
   browser_bug683672.html \
   browser_bug705707_is_content_stylesheet.html \
   browser_bug705707_is_content_stylesheet_imported.css \
   browser_bug705707_is_content_stylesheet_imported2.css \
diff --git a/browser/devtools/styleinspector/test/browser_bug726427_csstransform_tooltip.js b/browser/devtools/styleinspector/test/browser_bug726427_csstransform_tooltip.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_bug726427_csstransform_tooltip.js
@@ -0,0 +1,224 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+let contentDoc;
+let inspector;
+let ruleView;
+let computedView;
+
+const PAGE_CONTENT = [
+  '<style type="text/css">',
+  '  #testElement {',
+  '    width: 500px;',
+  '    height: 300px;',
+  '    background: red;',
+  '    transform: skew(16deg);',
+  '  }',
+  '  .test-element {',
+  '    transform-origin: top left;',
+  '    transform: rotate(45deg);',
+  '  }',
+  '  div {',
+  '    transform: scaleX(1.5);',
+  '    transform-origin: bottom right;',
+  '  }',
+  '  [attr] {',
+  '  }',
+  '</style>',
+  '<div id="testElement" class="test-element" attr="value">transformed element</div>'
+].join("\n");
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, arguments.callee, true);
+    contentDoc = content.document;
+    waitForFocus(createDocument, content);
+  }, true);
+
+  content.location = "data:text/html,rule view css transform tooltip test";
+}
+
+function createDocument() {
+  contentDoc.body.innerHTML = PAGE_CONTENT;
+
+  openRuleView((aInspector, aRuleView) => {
+    inspector = aInspector;
+    ruleView = aRuleView;
+    startTests();
+  });
+}
+
+function startTests() {
+  inspector.selection.setNode(contentDoc.querySelector("#testElement"));
+  inspector.once("inspector-updated", testTransformTooltipOnIDSelector);
+}
+
+function endTests() {
+  contentDoc = inspector = ruleView = computedView = null;
+  gBrowser.removeCurrentTab();
+  finish();
+}
+
+function testTransformTooltipOnIDSelector() {
+  info("Testing that a transform tooltip appears on the #ID rule");
+
+  let panel = ruleView.previewTooltip.panel;
+  ok(panel, "The XUL panel exists for the rule-view preview tooltips");
+
+  let {valueSpan} = getRuleViewProperty("#testElement", "transform");
+  assertTooltipShownOn(ruleView.previewTooltip, valueSpan, () => {
+    // The transform preview is canvas, so there's not much we can test, so for
+    // now, let's just be happy with the fact that the tooltips is shown!
+    ok(true, "Tooltip shown on the transform property of the #ID rule");
+    ruleView.previewTooltip.hide();
+    executeSoon(testTransformTooltipOnClassSelector);
+  });
+}
+
+function testTransformTooltipOnClassSelector() {
+  info("Testing that a transform tooltip appears on the .class rule");
+
+  let {valueSpan} = getRuleViewProperty(".test-element", "transform");
+  assertTooltipShownOn(ruleView.previewTooltip, valueSpan, () => {
+    // The transform preview is canvas, so there's not much we can test, so for
+    // now, let's just be happy with the fact that the tooltips is shown!
+    ok(true, "Tooltip shown on the transform property of the .class rule");
+    ruleView.previewTooltip.hide();
+    executeSoon(testTransformTooltipOnTagSelector);
+  });
+}
+
+function testTransformTooltipOnTagSelector() {
+  info("Testing that a transform tooltip appears on the tag rule");
+
+  let {valueSpan} = getRuleViewProperty("div", "transform");
+  assertTooltipShownOn(ruleView.previewTooltip, valueSpan, () => {
+    // The transform preview is canvas, so there's not much we can test, so for
+    // now, let's just be happy with the fact that the tooltips is shown!
+    ok(true, "Tooltip shown on the transform property of the tag rule");
+    ruleView.previewTooltip.hide();
+    executeSoon(testTransformTooltipNotShownOnInvalidTransform);
+  });
+}
+
+function testTransformTooltipNotShownOnInvalidTransform() {
+  info("Testing that a transform tooltip does not appear for invalid values");
+
+  // This is the list of keys to type in the inplace-editor
+  let keyData = "transform".split("");
+  keyData.push("VK_TAB");
+  keyData = keyData.concat("muchTransform(suchAngle)".split(""));
+  keyData.push("VK_RETURN");
+
+  // Focus the inplace editor
+  let rule = getRule("[attr]");
+  let brace = rule.querySelector(".ruleview-ruleclose");
+  waitForEditorFocus(brace.parentNode, editor => {
+    // Enter an invalid value
+    typeKeySequence(keyData, () => {
+      let {valueSpan} = getRuleViewProperty("[attr]", "transform");
+      assertTooltipNotShownOn(ruleView.previewTooltip, valueSpan, () => {
+        executeSoon(testTransformTooltipOnComputedView);
+      });
+    });
+  });
+  brace.click();
+}
+
+function testTransformTooltipOnComputedView() {
+  info("Testing that a transform tooltip appears in the computed view too");
+
+  inspector.sidebar.select("computedview");
+  computedView = inspector.sidebar.getWindowForTab("computedview").computedview.view;
+  let doc = computedView.styleDocument;
+
+  let panel = computedView.tooltip.panel;
+  let {valueSpan} = getComputedViewProperty("transform");
+
+  assertTooltipShownOn(computedView.tooltip, valueSpan, () => {
+    // The transform preview is canvas, so there's not much we can test, so for
+    // now, let's just be happy with the fact that the tooltips is shown!
+    ok(true, "Tooltip shown on the computed transform property");
+    computedView.tooltip.hide();
+    executeSoon(endTests);
+  });
+}
+
+function assertTooltipShownOn(tooltip, element, cb) {
+  // If there is indeed a show-on-hover on element, the xul panel will be shown
+  tooltip.panel.addEventListener("popupshown", function shown() {
+    tooltip.panel.removeEventListener("popupshown", shown, true);
+    cb();
+  }, true);
+  tooltip._showOnHover(element);
+}
+
+function assertTooltipNotShownOn(tooltip, element, cb) {
+  // The only way to make sure the tooltip is not shown is try and show it, wait
+  // for a given amount of time, and then check if it's shown or not
+  tooltip._showOnHover(element);
+  setTimeout(() => {
+    ok(!tooltip.isShown(), "The tooltip did not appear on hover of the element");
+    cb();
+  }, tooltip.defaultShowDelay + 100);
+}
+
+function typeKeySequence(sequence, cb, index=0) {
+  if (index === sequence.length) {
+    return cb();
+  }
+
+  EventUtils.synthesizeKey(sequence[index], {}, ruleView.doc.defaultView);
+  executeSoon(() => {
+    typeKeySequence(sequence, cb, index + 1);
+  });
+}
+
+function getRule(selectorText) {
+  let rule;
+
+  [].forEach.call(ruleView.doc.querySelectorAll(".ruleview-rule"), aRule => {
+    let selector = aRule.querySelector(".ruleview-selector-matched");
+    if (selector && selector.textContent === selectorText) {
+      rule = aRule;
+    }
+  });
+
+  return rule;
+}
+
+function getRuleViewProperty(selectorText, propertyName) {
+  let prop;
+
+  let rule = getRule(selectorText);
+  if (rule) {
+    // Look for the propertyName in that rule element
+    [].forEach.call(rule.querySelectorAll(".ruleview-property"), property => {
+      let nameSpan = property.querySelector(".ruleview-propertyname");
+      let valueSpan = property.querySelector(".ruleview-propertyvalue");
+
+      if (nameSpan.textContent === propertyName) {
+        prop = {nameSpan: nameSpan, valueSpan: valueSpan};
+      }
+    });
+  }
+
+  return prop;
+}
+
+function getComputedViewProperty(name) {
+  let prop;
+  [].forEach.call(computedView.styleDocument.querySelectorAll(".property-view"), property => {
+    let nameSpan = property.querySelector(".property-name");
+    let valueSpan = property.querySelector(".property-value");
+
+    if (nameSpan.textContent === name) {
+      prop = {nameSpan: nameSpan, valueSpan: valueSpan};
+    }
+  });
+  return prop;
+}
diff --git a/browser/devtools/styleinspector/test/browser_bug765105_background_image_tooltip.js b/browser/devtools/styleinspector/test/browser_bug765105_background_image_tooltip.js
--- a/browser/devtools/styleinspector/test/browser_bug765105_background_image_tooltip.js
+++ b/browser/devtools/styleinspector/test/browser_bug765105_background_image_tooltip.js
@@ -137,18 +137,19 @@ function testComputedView() {
   info("Testing tooltips in the computed view");
 
   inspector.sidebar.select("computedview");
   computedView = inspector.sidebar.getWindowForTab("computedview").computedview.view;
   let doc = computedView.styleDocument;
 
   let panel = computedView.tooltip.panel;
   let {valueSpan} = getComputedViewProperty("background-image");
+  let uriSpan = valueSpan.querySelector(".theme-link");
 
-  assertTooltipShownOn(computedView.tooltip, valueSpan, () => {
+  assertTooltipShownOn(computedView.tooltip, uriSpan, () => {
     let images = panel.getElementsByTagName("image");
     is(images.length, 1, "Tooltip contains an image");
     ok(images[0].src === "chrome://global/skin/icons/warning-64.png");
 
     computedView.tooltip.hide();
 
     endTests();
   });
