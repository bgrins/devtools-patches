# HG changeset patch
# Parent 9ba49ba2a1c2bcf63fa2b4e045116b569a7929d8
# User Brian Grinstead <bgrinstead@mozilla.com>
extra logging


diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1178,17 +1178,16 @@ var WalkerActor = protocol.ActorClass({
     }
 
     // XXX: Can also fake the shadowRoot, but since there are actually
     // siblings, this should probably be coming from deeptreewalker
     // if (rawNode.shadowRoot) {
     //   firstChild = rawNode.shadowRoot;
     // }
 
-    console.log(rawNode, firstChild, lastChild);
     if (!firstChild) {
       // No children, we're done.
       return { hasFirst: true, hasLast: true, nodes: [] };
     }
 
     let start;
     if (options.center) {
       start = options.center.rawNode;
@@ -1201,34 +1200,41 @@ var WalkerActor = protocol.ActorClass({
     let nodes = [];
 
     // Start by reading backward from the starting point if we're centering...
     let backwardWalker = filteredWalker(start);
     if (start != firstChild && options.center) {
       backwardWalker.previousSibling();
       let backwardCount = Math.floor(maxNodes / 2);
       let backwardNodes = this._readBackward(backwardWalker, backwardCount);
+      console.log("BACKWARD NODES", nodes.map(n=>n.rawNode.nodeName).join(","));
       nodes = backwardNodes;
     }
 
     // Then read forward by any slack left in the max children...
+    console.log("START POS", start);
     let forwardWalker = filteredWalker(start);
     let forwardCount = maxNodes - nodes.length;
-    nodes = nodes.concat(this._readForward(forwardWalker, forwardCount));
+    console.log("HOW FAR TO READ", forwardCount);
+    let nodes1 = this._readForward(forwardWalker, forwardCount);
+    nodes = nodes.concat(nodes1);
+    console.log("ALL NODES", nodes.map(n=>n.rawNode.nodeName).join(","));
+
 
     // If there's any room left, it means we've run all the way to the end.
     // If we're centering, check if there are more items to read at the front.
     let remaining = maxNodes - nodes.length;
     if (options.center && remaining > 0 && nodes[0].rawNode != firstChild) {
       let firstNodes = this._readBackward(backwardWalker, remaining);
 
       // Then put it all back together.
       nodes = firstNodes.concat(nodes);
     }
 
+console.log("Has first return: ", nodes[0].rawNode == firstChild, nodes[0].rawNode, nodes[0].rawNode.previousSibling,nodes[0].rawNode.nextSibling, firstChild)
     return {
       hasFirst: nodes[0].rawNode == firstChild,
       hasLast: nodes[nodes.length - 1].rawNode == lastChild,
       nodes: nodes
     };
   }, nodeArrayMethod),
 
   /**
@@ -2662,17 +2668,17 @@ function nodeDocument(node) {
 function DocumentWalker(aNode, aRootWin, aShow, aFilter, aExpandEntityReferences) {
   let doc = aRootWin.document;
 
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.init(doc, aShow);
   this.walker.currentNode = aNode;
-  this.filter = aFilter;
+  this.filter = aFilter || function() {};
 }
 
 DocumentWalker.prototype = {
   get node() this.walker.node,
   get whatToShow() this.walker.whatToShow,
   get expandEntityReferences() this.walker.expandEntityReferences,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
@@ -2686,46 +2692,55 @@ DocumentWalker.prototype = {
     if (!node)
       return null;
 
     let firstChild = this.walker.firstChild();
     console.log("Current node:", node, "First child: ", firstChild);
     while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       firstChild = this.walker.nextSibling();
     }
+    console.log("Current node:", node, "First child returned: ", firstChild);
 
     return firstChild;
   },
 
   lastChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
 
     let lastChild = this.walker.lastChild();
+    console.log("Current node:", node, "Last child: ", lastChild);
+
     while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       lastChild = this.walker.previousSibling();
     }
+    console.log("Current node:", node, "Last child returned: ", lastChild);
 
     return lastChild;
   },
 
   previousSibling: function() {
     let node = this.walker.previousSibling();
+    console.log("Previous sibling: ", node, this.walker.currentNode);
+
     while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       node = this.walker.previousSibling();
     }
+    console.log("Previous sibling return: ", node, this.walker.currentNode);
     return node;
   },
 
   nextSibling: function() {
     let node = this.walker.nextSibling();
+    console.log("Next sibling: ", node, this.walker.currentNode);
     while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       node = this.walker.nextSibling();
     }
+    console.log("Next sibling return: ", node, this.walker.currentNode);
     return node;
   }
 };
 
 /**
  * A tree walker filter for avoiding empty whitespace text nodes.
  */
 function whitespaceTextFilter(aNode) {
