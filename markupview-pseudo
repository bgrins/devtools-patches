# HG changeset patch
# Parent 48c22e4237e61b63edda86d9570c7a7500356394
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 920141 - [markup view] Show :before and :after pseudo elements in the tree

diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -88,17 +88,17 @@ FontInspector.prototype = {
       return;
     }
 
     let node = this.inspector.selection.node;
     let contentDocument = node.ownerDocument;
 
     // We don't get fonts for a node, but for a range
     let rng = contentDocument.createRange();
-    rng.selectNode(node);
+    rng.selectNodeContents(node);
     let fonts = DOMUtils.getUsedFontFaces(rng);
     let fontsArray = [];
     for (let i = 0; i < fonts.length; i++) {
       fontsArray.push(fonts.item(i));
     }
     fontsArray = fontsArray.sort(function(a, b) {
       return a.srcIndex < b.srcIndex;
     });
diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
--- a/browser/devtools/framework/selection.js
+++ b/browser/devtools/framework/selection.js
@@ -220,21 +220,35 @@ Selection.prototype = {
     // accessing node.rawNode, this needs to stay.
     let rawNode = null;
     if (node.isLocal_toBeDeprecated()) {
       rawNode = node.rawNode();
     }
     if (rawNode) {
       try {
         let doc = this.document;
-        return (doc && doc.defaultView && doc.documentElement.contains(rawNode));
+        if (doc && doc.defaultView) {
+          let docEl = doc.documentElement;
+
+          if (docEl.contains(rawNode)) {
+            return true;
+          }
+
+          // Recurse up anonymous parent to see if it is in document
+          let bindingParent = rawNode;
+          while ((bindingParent = doc.getBindingParent(bindingParent))) {
+            if (docEl.contains(bindingParent)) {
+              return true;
+            }
+          }
+        }
       } catch (e) {
         // "can't access dead object" error
-        return false;
       }
+      return false;
     }
 
     while(node) {
       if (node === this._walker.rootNode) {
         return true;
       }
       node = node.parentNode();
     };
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -383,17 +383,19 @@ InspectorPanel.prototype = {
     // client know.
     let selection = this.selection.nodeFront;
 
     // On any new selection made by the user, store the unique css selector
     // of the selected node so it can be restored after reload of the same page
     if (reason !== "navigateaway" &&
         this.selection.node &&
         this.selection.isElementNode()) {
-      this.selectionCssSelector = CssLogic.findCssSelector(this.selection.node);
+      try {
+        this.selectionCssSelector = CssLogic.findCssSelector(this.selection.node);
+      } catch(e) { }
     }
 
     let selfUpdate = this.updating("inspector-panel");
     Services.tm.mainThread.dispatch(() => {
       try {
         selfUpdate(selection);
       } catch(ex) {
         console.error(ex);
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -247,17 +247,17 @@ MarkupView.prototype = {
     while (parent !== this.doc.body) {
       if (parent.container) {
         container = parent.container;
         break;
       }
       parent = parent.parentNode;
     }
 
-    if (container) {
+    if (container && container._isImagePreviewTarget) {
       // With the newly found container, delegate the tooltip content creation
       // and decision to show or not the tooltip
       return container._isImagePreviewTarget(target, this.tooltip);
     }
   },
 
   /**
    * Given the known reason, should the current selection be briefly highlighted
@@ -1250,16 +1250,23 @@ function MarkupContainer(aMarkupView, aN
   this.expander = null;
   this.tagState = null;
   this.tagLine = null;
   this.children = null;
   this.markup.template("container", this);
   this.elt.container = this;
   this.children.container = this;
 
+  if (aNode.isPseudoElement) {
+    this.expander.remove();
+  }
+  if (aNode.isAnonymous) {
+    this.elt.classList.add("anonymous");
+  }
+
   // Expanding/collapsing the node on dblclick of the whole tag-line element
   this._onToggle = this._onToggle.bind(this);
   this.elt.addEventListener("dblclick", this._onToggle, false);
   this.expander.addEventListener("click", this._onToggle, false);
 
   // Appending the editor element and attaching event listeners
   this.tagLine.appendChild(this.editor.elt);
 
@@ -1743,16 +1750,27 @@ function ElementEditor(aContainer, aNode
   // The templates will fill the following properties
   this.elt = null;
   this.tag = null;
   this.closeTag = null;
   this.attrList = null;
   this.newAttr = null;
   this.closeElt = null;
 
+  if (aNode.isPseudoElement) {
+    this.template("pseudoelement", this);
+    this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
+    // XXX: we should update functions to not access these in case
+    // of pseudo elements instead of faking them.
+    this.attrList = this.doc.createElement("span");
+    this.closeTag = this.doc.createElement("span");
+    this.newAttr = this.doc.createElement("span");
+    this.closeElt = this.doc.createElement("span");
+  } else {
+    // XXX: Don't indent yet so diff is easier to read.
   // Create the main editor
   this.template("element", this);
 
   if (aNode.isLocal_toBeDeprecated()) {
     this.rawNode = aNode.rawNode();
   }
 
   // Make the tag name editable (unless this is a remote node or
@@ -1793,16 +1811,19 @@ function ElementEditor(aContainer, aNode
       }
     }
   });
 
   let tagName = this.node.nodeName.toLowerCase();
   this.tag.textContent = tagName;
   this.closeTag.textContent = tagName;
 
+  }
+
+
   this.update();
 }
 
 ElementEditor.prototype = {
   /**
    * Update the state of the editor from the node.
    */
   update: function() {
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -25,16 +25,18 @@
       <li id="template-container" save="${elt}" class="child collapsed">
         <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span><span save="${expander}" class="theme-twisty expander"></span></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
       <li id="template-more-nodes" class="more-nodes devtools-class-comment" save="${elt}"><span>${showing}</span> <button href="#" onclick="${allButtonClick}">${showAll}</button></li>
     </ul>
 
+    <span id="template-pseudoelement" save="${elt}" class="editor"><span save="${tag}" class="tag theme-fg-color5" tabindex="0"></span></span>
+
     <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span></span>
 
     <span id="template-attribute" save="${attr}" data-attr="${attrName}" class="attreditor" style="display:none"> <span class="editable" save="${inner}" tabindex="0"><span save="${name}" class="attr-name theme-fg-color2"></span>=&quot;<span save="${val}" class="attr-value theme-fg-color6"></span>&quot;</span></span>
 
     <span id="template-text" save="${elt}" class="editor text">
       <pre save="${value}" style="display:inline-block;" tabindex="0"></pre>
     </span>
 
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -143,17 +143,21 @@ ElementStyle.prototype = {
   dummyElement: null,
 
   init: function()
   {
     // To figure out how shorthand properties are interpreted by the
     // engine, we will set properties on a dummy element and observe
     // how their .style attribute reflects them as computed values.
     return this.dummyElementPromise = createDummyDocument().then(document => {
-      this.dummyElement = document.createElementNS(this.element.namespaceURI,
+      // XXX ewww
+      let isPseudo = this.element.tagName == "_moz_generated_content_before" || this.element.tagName == "_moz_generated_content_after";
+      let namespaceURI = isPseudo ? document.documentElement.namespaceURI : this.element.namespaceURI;
+
+      this.dummyElement = document.createElementNS(namespaceURI,
                                                    this.element.tagName);
       document.documentElement.appendChild(this.dummyElement);
       return this.dummyElement;
     }).then(null, promiseWarn);
   },
 
   destroy: function() {
     this.dummyElement = null;
diff --git a/browser/themes/shared/devtools/markup-view.css b/browser/themes/shared/devtools/markup-view.css
--- a/browser/themes/shared/devtools/markup-view.css
+++ b/browser/themes/shared/devtools/markup-view.css
@@ -10,16 +10,20 @@
 .more-nodes {
   padding-left: 16px;
 }
 
 .styleinspector-propertyeditor {
   border: 1px solid #CCC;
 }
 
+.anonymous .editor {
+  opacity: .8;
+  font-style: italic;
+}
 
 /* Selected nodes in the tree should have light selected text.
    theme-selected doesn't work in this case since the text is a
    sibling of the class, not a child. */
 .theme-selected ~ .editor,
 .theme-selected ~ .editor .theme-fg-color1,
 .theme-selected ~ .editor .theme-fg-color2,
 .theme-selected ~ .editor .theme-fg-color3,
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -98,43 +98,52 @@ let HighlighterActor = protocol.ActorCla
    * method several times won't display several highlighters, it will just move
    * the highlighter instance to these nodes.
    *
    * @param NodeActor The node to be highlighted
    * @param Options See the request part for existing options. Note that not
    * all options may be supported by all types of highlighters.
    */
   showBoxModel: method(function(node, options={}) {
-    if (node && this._isNodeValidForHighlighting(node.rawNode)) {
+    if (node && this._isNodeValidForHighlighting(node)) {
       this._boxModelHighlighter.show(node.rawNode, options);
     } else {
       this._boxModelHighlighter.hide();
     }
   }, {
     request: {
       node: Arg(0, "domnode"),
       region: Option(1)
     }
   }),
 
   _isNodeValidForHighlighting: function(node) {
     // Is it null or dead?
-    let isNotDead = node && !Cu.isDeadWrapper(node);
+    let rawNode = node.rawNode;
+    let isNotDead = rawNode && !Cu.isDeadWrapper(rawNode);
 
     // Is it connected to the document?
     let isConnected = false;
     try {
-      let doc = node.ownerDocument;
-      isConnected = (doc && doc.defaultView && doc.documentElement.contains(node));
+      let doc = rawNode.ownerDocument;
+      let form = node.form();
+      if (doc && doc.defaultView) {
+        if (form.isAnonymous) {
+          let bindingParent = doc.getBindingParent(rawNode);
+          isConnected = doc.documentElement.contains(bindingParent);
+        } else {
+          isConnected = doc.documentElement.contains(rawNode);
+        }
+      }
     } catch (e) {
       // "can't access dead object" error
     }
 
     // Is it an element node
-    let isElementNode = node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE;
+    let isElementNode = rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE;
 
     return isNotDead && isConnected && isElementNode;
   },
 
   /**
    * Hide the box model highlighting if it was shown before
    */
   hideBoxModel: method(function() {
@@ -701,27 +710,34 @@ BoxModelHighlighter.prototype = {
     }
   },
 
   /**
    * Update node information (tagName#id.class)
    */
   _updateInfobar: function() {
     if (this.currentNode) {
+
       // Tag name
-      this.nodeInfo.tagNameLabel.textContent = this.currentNode.tagName;
+      let tagName = this.currentNode.tagName;
+      if (tagName === "_moz_generated_content_before") {
+        tagName = "::before";
+      } else if (tagName === "_moz_generated_content_after") {
+        tagName = "::after";
+      }
+      this.nodeInfo.tagNameLabel.textContent = tagName;
 
       // ID
       this.nodeInfo.idLabel.textContent = this.currentNode.id ? "#" + this.currentNode.id : "";
 
       // Classes
       let classes = this.nodeInfo.classesBox;
-
-      classes.textContent = this.currentNode.classList.length ?
-                              "." + Array.join(this.currentNode.classList, ".") : "";
+      let classList = this.currentNode.classList || [];
+      classes.textContent = classList.length ?
+                              "." + Array.join(classList, ".") : "";
 
       // Pseudo-classes
       let pseudos = PSEUDO_CLASSES.filter(pseudo => {
         return DOMUtils.hasPseudoClassLock(this.currentNode, pseudo);
       }, this);
 
       let pseudoBox = this.nodeInfo.pseudoClassesBox;
       pseudoBox.textContent = pseudos.join("");
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -202,40 +202,54 @@ var NodeActor = exports.NodeActor = prot
 
     // Estimate the number of children.
     let numChildren = this.rawNode.childNodes.length;
     if (numChildren === 0 &&
         (this.rawNode.contentDocument || this.rawNode.getSVGDocument)) {
       // This might be an iframe with virtual children.
       numChildren = 1;
     }
+    if (this.rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+      let anonChildren = this.rawNode.ownerDocument.getAnonymousNodes(this.rawNode);
+      if (anonChildren) {
+        numChildren += anonChildren.length;
+      }
+    }
 
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
       numChildren: numChildren,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
-
+      isBeforePseudoElement: this.rawNode.nodeName === "_moz_generated_content_before",
+      isAfterPseudoElement: this.rawNode.nodeName === "_moz_generated_content_after",
       pseudoClassLocks: this.writePseudoClassLocks(),
     };
 
     if (this.isDocumentElement()) {
       form.isDocumentElement = true;
     }
 
+    if (this.rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+      let bindingParent = this.rawNode.ownerDocument.getBindingParent(this.rawNode);
+
+      // XXX: should we also include a reference to the binding parent?
+      form.isAnonymous = !!bindingParent;
+    }
+
     if (this.rawNode.nodeValue) {
       // We only include a short version of the value if it's longer than
       // gValueSummaryLength
       if (this.rawNode.nodeValue.length > gValueSummaryLength) {
         form.shortValue = this.rawNode.nodeValue.substring(0, gValueSummaryLength);
         form.incompleteValue = true;
       } else {
         form.shortValue = this.rawNode.nodeValue;
@@ -473,16 +487,21 @@ let NodeFront = protocol.FrontClass(Node
 
   get className() {
     return this.getAttribute("class") || '';
   },
 
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
 
+  get isBeforePseudoElement() this._form.isBeforePseudoElement,
+  get isAfterPseudoElement() this._form.isAfterPseudoElement,
+  get isPseudoElement() this.isBeforePseudoElement || this.isAfterPseudoElement,
+  get isAnonymous() this._form.isAnonymous,
+
   get tagName() this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE ? this.nodeName : null,
   get shortValue() this._form.shortValue,
   get incompleteValue() !!this._form.incompleteValue,
 
   get isDocumentElement() !!this._form.isDocumentElement,
 
   // doctype properties
   get name() this._form.name,
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -18,17 +18,17 @@ loader.lazyGetter(this, "CssLogic", () =
 loader.lazyGetter(this, "DOMUtils", () => Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils));
 
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
-const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
+const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":-moz-selection"];
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
 
 // Predeclare the domnode actor type for use in requests.
 types.addActorType("domnode");
 
 /**
  * DOM Nodes returned by the style actor will be owned by the DOM walker
  * for the connection.
@@ -352,35 +352,53 @@ var PageStyleActor = protocol.ActorClass
   },
 
   /**
    * Helper function for getApplied, adds all the rules from a given
    * element.
    */
   addElementRules: function(element, inherited, options, rules)
   {
+    if (element.style) {
+      let elementStyle = this._styleRef(element);
+      if (!inherited || this._hasInheritedProps(element.style)) {
+        rules.push({
+          rule: elementStyle,
+          inherited: inherited,
+        });
+      }
+    }
+
+    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
+    let isBeforeOrAfter = false;
+
+    // If it is before or after, then we don't want to get styles for
+    // this element.  Want to get it for the parent, but with the corresponding
+    // pseudo.  Then we want to lie to the view and tell it that it isn't a pseudo
+    // style so that it shows up normally.
+    if (element.nodeName == "_moz_generated_content_before") {
+      pseudoElements = [":before"];
+      element = element.parentNode;
+      isBeforeOrAfter = true;
+    }
+
+    if (element.nodeName == "_moz_generated_content_after") {
+      pseudoElements = [":after"];
+      element = element.parentNode;
+      isBeforeOrAfter = true;
+    }
+
     if (!element.style) {
       return;
     }
 
-    let elementStyle = this._styleRef(element);
-
-    if (!inherited || this._hasInheritedProps(element.style)) {
-      rules.push({
-        rule: elementStyle,
-        inherited: inherited,
-      });
-    }
-
-    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
     for (let pseudo of pseudoElements) {
 
       // Get the styles that apply to the element.
       let domRules = DOMUtils.getCSSStyleRules(element, pseudo);
-
       if (!domRules) {
         continue;
       }
 
       // getCSSStyleRules returns ordered from least-specific to
       // most-specific.
       for (let i = domRules.Count() - 1; i >= 0; i--) {
         let domRule = domRules.GetElementAt(i);
@@ -401,17 +419,17 @@ var PageStyleActor = protocol.ActorClass
             continue;
           }
         }
 
         let ruleActor = this._styleRef(domRule);
         rules.push({
           rule: ruleActor,
           inherited: inherited,
-          pseudoElement: pseudo
+          pseudoElement: isBeforeOrAfter ? null : pseudo
         });
       }
 
     }
   },
 
   /**
    * Expand Sets of rules and sheets to include all parent rules and sheets.
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -167,17 +167,30 @@ CssLogic.prototype = {
     } else {
       // Clear cached data in the CssPropertyInfo objects.
       this._propertyInfos = {};
     }
 
     this._matchedRules = null;
     this._matchedSelectors = null;
     let win = this.viewedDocument.defaultView;
-    this._computedStyle = win.getComputedStyle(this.viewedElement, "");
+
+    // Handle computed styles on pseudo by reading parent node with proper
+    // pseudo arg to getComputedStyle.
+    let elementToRead = this.viewedElement;
+    let pseudoToRead = "";
+    if (this.viewedElement.nodeName == "_moz_generated_content_before") {
+      elementToRead = this.viewedElement.parentNode;
+      pseudoToRead = ":before";
+    }
+    if (this.viewedElement.nodeName == "_moz_generated_content_after") {
+      elementToRead = this.viewedElement.parentNode;
+      pseudoToRead = ":after";
+    }
+    this._computedStyle = win.getComputedStyle(elementToRead, pseudoToRead);
   },
 
   /**
    * Get the source filter.
    * @returns {string} The source filter being used.
    */
   get sourceFilter() {
     return this._sourceFilter;
@@ -578,23 +591,39 @@ CssLogic.prototype = {
       return;
     }
 
     do {
       let status = this.viewedElement === element ?
                    CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
 
       try {
-        domRules = domUtils.getCSSStyleRules(element);
+
+      // Handle computed styles on pseudo by reading parent node with proper
+      // pseudo arg to getCSSStyleRules.
+        let cssRuleElement = element;
+        let pseudoElement = null;
+        if (element.nodeName == "_moz_generated_content_before") {
+          pseudoElement = ":before";
+          cssRuleElement = element.parentNode;
+        }
+
+        if (element.nodeName == "_moz_generated_content_after") {
+          pseudoElement = ":after";
+          cssRuleElement = element.parentNode;
+        }
+
+        domRules = domUtils.getCSSStyleRules(cssRuleElement, pseudoElement);
       } catch (ex) {
         Services.console.
           logStringMessage("CL__buildMatchedRules error: " + ex);
         continue;
       }
 
+      if (domRules) {
       for (let i = 0, n = domRules.Count(); i < n; i++) {
         let domRule = domRules.GetElementAt(i);
         if (domRule.type !== Ci.nsIDOMCSSRule.STYLE_RULE) {
           continue;
         }
 
         let sheet = this.getSheet(domRule.parentStyleSheet, -1);
         if (sheet._passId !== this._passId) {
@@ -610,16 +639,17 @@ CssLogic.prototype = {
         if (rule._passId === this._passId) {
           continue;
         }
 
         rule._matchId = this._matchId;
         rule._passId = this._passId;
         this._matchedRules.push([rule, status]);
       }
+      }
 
 
       // Add element.style information.
       if (element.style && element.style.length > 0) {
         let rule = new CssRule(null, { style: element.style }, element);
         rule._matchId = this._matchId;
         rule._passId = this._passId;
         this._matchedRules.push([rule, status]);
