# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e54372da162ada1ca3504fbfd7ca8d5df62ae00f

diff --git a/accessible/interfaces/nsIAccessible.idl b/accessible/interfaces/nsIAccessible.idl
--- a/accessible/interfaces/nsIAccessible.idl
+++ b/accessible/interfaces/nsIAccessible.idl
@@ -80,16 +80,21 @@ interface nsIAccessible : nsISupports
   readonly attribute Node DOMNode;
 
   /**
     * For remote accessibles the id of the related DOM node.
     */
   readonly attribute AString id;
 
   /**
+    *
+    */
+  readonly attribute uint64_t uniqueID;
+
+  /**
    * The document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument document;
 
   /**
    * The root document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument rootDocument;
diff --git a/accessible/xpcom/xpcAccessible.cpp b/accessible/xpcom/xpcAccessible.cpp
--- a/accessible/xpcom/xpcAccessible.cpp
+++ b/accessible/xpcom/xpcAccessible.cpp
@@ -92,16 +92,28 @@ xpcAccessible::GetLastChild(nsIAccessibl
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   NS_IF_ADDREF(*aLastChild = ToXPC(IntlGeneric().LastChild()));
   return NS_OK;
 }
 
 NS_IMETHODIMP
+xpcAccessible::GetUniqueID(uint64_t* aUniqueID) {
+  NS_ENSURE_ARG_POINTER(aUniqueID);
+
+  if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
+
+  void* uniqueID = static_cast<void*>(this);
+  *aUniqueID = reinterpret_cast<uint64_t>(uniqueID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 xpcAccessible::GetChildCount(int32_t* aChildCount) {
   NS_ENSURE_ARG_POINTER(aChildCount);
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   *aChildCount = IntlGeneric().ChildCount();
   return NS_OK;
 }
diff --git a/accessible/xpcom/xpcAccessible.h b/accessible/xpcom/xpcAccessible.h
--- a/accessible/xpcom/xpcAccessible.h
+++ b/accessible/xpcom/xpcAccessible.h
@@ -25,16 +25,17 @@ class xpcAccessible : public nsIAccessib
  public:
   // nsIAccessible
   NS_IMETHOD GetParent(nsIAccessible** aParent) final;
   NS_IMETHOD GetNextSibling(nsIAccessible** aNextSibling) final;
   NS_IMETHOD GetPreviousSibling(nsIAccessible** aPreviousSibling) final;
   NS_IMETHOD GetFirstChild(nsIAccessible** aFirstChild) final;
   NS_IMETHOD GetLastChild(nsIAccessible** aLastChild) final;
   NS_IMETHOD GetChildCount(int32_t* aChildCount) final;
+  NS_IMETHOD GetUniqueID(uint64_t* aUniqueID) final;
   NS_IMETHOD GetChildAt(int32_t aChildIndex, nsIAccessible** aChild) final;
   NS_IMETHOD GetChildren(nsIArray** aChildren) final;
   NS_IMETHOD GetIndexInParent(int32_t* aIndexInParent) final;
 
   NS_IMETHOD GetDOMNode(nsINode** aDOMNode) final;
   NS_IMETHOD GetId(nsAString& aID) final;
   NS_IMETHOD GetDocument(nsIAccessibleDocument** aDocument) final;
   NS_IMETHOD GetRootDocument(nsIAccessibleDocument** aRootDocument) final;
diff --git a/browser/actors/BrowserTabParent.jsm b/browser/actors/BrowserTabParent.jsm
--- a/browser/actors/BrowserTabParent.jsm
+++ b/browser/actors/BrowserTabParent.jsm
@@ -11,16 +11,20 @@ class BrowserTabParent extends JSWindowA
     if (!browser) {
       return; // Can happen sometimes if browser is being destroyed
     }
 
     if (browser.outerBrowser) {
       browser = browser.outerBrowser; // handle RDM mode
     }
 
+    if (browser.hostBrowser) {
+      return;
+    }
+
     let gBrowser = browser.ownerGlobal.gBrowser;
 
     if (!gBrowser) {
       // Note: gBrowser might be null because this message might be received
       // from the extension process. There's still an embedderElement involved,
       // but it's the one coming from dummy.xul.
       // This should probably be fixed by adding support to specifying "group: 'browsers"
       // in the registerWindowActor options/. See bug 1557118.
diff --git a/browser/base/content/browser-sets.inc b/browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc
+++ b/browser/base/content/browser-sets.inc
@@ -38,16 +38,17 @@
     <command id="cmd_CustomizeToolbars" oncommand="gCustomizeMode.enter()"/>
     <command id="cmd_toggleOfflineStatus" oncommand="BrowserOffline.toggleOfflineStatus();"/>
     <command id="cmd_quitApplication" oncommand="goQuitApplication()"/>
 
     <command id="View:PageSource" oncommand="BrowserViewSource(window.gBrowser.selectedBrowser);"/>
     <command id="View:PageInfo" oncommand="BrowserPageInfo();"/>
     <command id="View:FullScreen" oncommand="BrowserFullScreen();"/>
     <command id="View:ReaderView" oncommand="ReaderParent.toggleReaderMode(event);"/>
+    <command id="View:SecondaryBrowser" oncommand="ReaderParent.toggleSecondaryBrowser(event);"/>
     <command id="View:PictureInPicture" oncommand="PictureInPicture.onCommand(event);"/>
     <command id="cmd_find" oncommand="gLazyFindCommand('onFindCommand')"/>
     <command id="cmd_findAgain" oncommand="gLazyFindCommand('onFindAgainCommand', false)"/>
     <command id="cmd_findPrevious" oncommand="gLazyFindCommand('onFindAgainCommand', true)"/>
 #ifdef XP_MACOSX
     <command id="cmd_findSelection" oncommand="gLazyFindCommand('onFindSelectionCommand')"/>
 #endif
     <!-- work-around bug 392512 -->
@@ -228,16 +229,20 @@
          command="View:ReaderView"
 #ifdef XP_WIN
          data-l10n-id="reader-mode-toggle-shortcut-windows"
 #else
          data-l10n-id="reader-mode-toggle-shortcut-other"
          modifiers="accel,alt"
 #endif
          disabled="true"/>
+    <key id="key_toggleSecondaryBrowser"
+         command="View:SecondaryBrowser"
+         key="o"
+         modifiers="accel,shift"/>
 
 #ifndef XP_MACOSX
     <key id="key_togglePictureInPicture" data-l10n-id="picture-in-picture-toggle-shortcut" command="View:PictureInPicture" modifiers="accel,shift"/>
     <key                                 data-l10n-id="picture-in-picture-toggle-shortcut-alt" command="View:PictureInPicture" modifiers="accel,shift"/>
 #endif
 
     <key data-l10n-id="nav-reload-shortcut" command="Browser:Reload" modifiers="accel" id="key_reload"/>
     <key data-l10n-id="nav-reload-shortcut" command="Browser:ReloadSkipCache" modifiers="accel,shift" id="key_reload_skip_cache"/>
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,66 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  /* margin-inline-start: 32px;
+  width: calc(100% - 32px); */
+}
+.browserStack:not([secondarybrowser]) > .secondarybrowser {
+  display: none;
+}
+/* 
+.browserStack > .secondarybrowser-controls {
+  justify-self: start;
+  width: 32px;
+  background: rgba(255, 255, 255, .8);
+}
+
+.browserStack > .secondarybrowser-controls > toolbarbutton {
+  width: 32px;
+  height: 32px;
+}
+.browserStack > .secondarybrowser-controls > toolbarbutton:hover,
+.browserStack > .secondarybrowser-controls > toolbarbutton[active] {
+  background-color: hsla(240,5%,5%,.1);
+} */
+
+  /* icons grabbed from https://www.iconfinder.com/iconsets/material-core */
+.secondarybrowser-on {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-split {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxNnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAxNiIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01MDYuMDAwMDAwLCAtMTMwLjAwMDAwMCkiPjxnIGlkPSJkcmF3ZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwNi4wMDAwMDAsIDEzMC4wMDAwMDApIj48cGF0aCBkPSJNMTgsMCBMMiwwIEMwLjgsMCAwLDAuOCAwLDIgTDAsMTQgQzAsMTUuMiAwLjgsMTYgMiwxNiBMMTgsMTYgQzE5LDE2IDIwLDE1LjIgMjAsMTQgTDIwLDIgQzIwLDAuOCAxOSwwIDE4LDAgTDE4LDAgWiBNMTgsMTQgTDEyLDE0IEwxMiwyIEwxOCwyIEwxOCwxNCBMMTgsMTQgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-off {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAyMCIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTYuMDAwMDAwLCAtMjk2LjAwMDAwMCkiPjxnIGlkPSJsYW5ndWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk2LjAwMDAwMCwgMjk2LjAwMDAwMCkiPjxwYXRoIGQ9Ik0xMCwwIEM0LjUsMCAwLDQuNSAwLDEwIEMwLDE1LjUgNC41LDIwIDEwLDIwIEMxNS41LDIwIDIwLDE1LjUgMjAsMTAgQzIwLDQuNSAxNS41LDAgMTAsMCBMMTAsMCBaIE0xNi45LDYgTDE0LDYgQzEzLjcsNC43IDEzLjIsMy42IDEyLjYsMi40IEMxNC40LDMuMSAxNiw0LjMgMTYuOSw2IEwxNi45LDYgWiBNMTAsMiBDMTAuOCwzLjIgMTEuNSw0LjUgMTEuOSw2IEw4LjEsNiBDOC41LDQuNiA5LjIsMy4yIDEwLDIgTDEwLDIgWiBNMi4zLDEyIEMyLjEsMTEuNCAyLDEwLjcgMiwxMCBDMiw5LjMgMi4xLDguNiAyLjMsOCBMNS43LDggQzUuNiw4LjcgNS42LDkuMyA1LjYsMTAgQzUuNiwxMC43IDUuNywxMS4zIDUuNywxMiBMMi4zLDEyIEwyLjMsMTIgWiBNMy4xLDE0IEw2LDE0IEM2LjMsMTUuMyA2LjgsMTYuNCA3LjQsMTcuNiBDNS42LDE2LjkgNCwxNS43IDMuMSwxNCBMMy4xLDE0IFogTTYsNiBMMy4xLDYgQzQuMSw0LjMgNS42LDMuMSA3LjQsMi40IEM2LjgsMy42IDYuMyw0LjcgNiw2IEw2LDYgWiBNMTAsMTggQzkuMiwxNi44IDguNSwxNS41IDguMSwxNCBMMTEuOSwxNCBDMTEuNSwxNS40IDEwLjgsMTYuOCAxMCwxOCBMMTAsMTggWiBNMTIuMywxMiBMNy43LDEyIEM3LjYsMTEuMyA3LjUsMTAuNyA3LjUsMTAgQzcuNSw5LjMgNy42LDguNyA3LjcsOCBMMTIuNCw4IEMxMi41LDguNyAxMi42LDkuMyAxMi42LDEwIEMxMi42LDEwLjcgMTIuNCwxMS4zIDEyLjMsMTIgTDEyLjMsMTIgWiBNMTIuNiwxNy42IEMxMy4yLDE2LjUgMTMuNywxNS4zIDE0LDE0IEwxNi45LDE0IEMxNiwxNS43IDE0LjQsMTYuOSAxMi42LDE3LjYgTDEyLjYsMTcuNiBaIE0xNC40LDEyIEMxNC41LDExLjMgMTQuNSwxMC43IDE0LjUsMTAgQzE0LjUsOS4zIDE0LjQsOC43IDE0LjQsOCBMMTcuOCw4IEMxOCw4LjYgMTguMSw5LjMgMTguMSwxMCBDMTguMSwxMC43IDE4LDExLjQgMTcuOCwxMiBMMTQuNCwxMiBMMTQuNCwxMiBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-media {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxOHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxOCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzEuMDAwMDAwLCAtMTcxLjAwMDAwMCkiPjxnIGlkPSJkcml2ZS1pbWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTcxLjAwMDAwMCkiPjxwYXRoIGQ9Ik0xOCwxNiBMMTgsMiBDMTgsMC45IDE3LjEsMCAxNiwwIEwyLDAgQzAuOSwwIDAsMC45IDAsMiBMMCwxNiBDMCwxNy4xIDAuOSwxOCAyLDE4IEwxNiwxOCBDMTcuMSwxOCAxOCwxNy4xIDE4LDE2IEwxOCwxNiBaIE01LjUsMTAuNSBMOCwxMy41IEwxMS41LDkgTDE2LDE1IEwyLDE1IEw1LjUsMTAuNSBMNS41LDEwLjUgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-outline {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00MjMuMDAwMDAwLCAtMzAxLjAwMDAwMCkiPjxnIGlkPSJsaXN0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjMuMDAwMDAwLCAzMDEuMDAwMDAwKSI+PHBhdGggZD0iTTAsNiBMMiw2IEwyLDQgTDAsNCBMMCw2IEwwLDYgWiBNMCwxMCBMMiwxMCBMMiw4IEwwLDggTDAsMTAgTDAsMTAgWiBNMCwyIEwyLDIgTDIsMCBMMCwwIEwwLDIgTDAsMiBaIE00LDYgTDE4LDYgTDE4LDQgTDQsNCBMNCw2IEw0LDYgWiBNNCwxMCBMMTgsMTAgTDE4LDggTDQsOCBMNCwxMCBMNCwxMCBaIE00LDAgTDQsMiBMMTgsMiBMMTgsMCBMNCwwIEw0LDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-reader {
+  background: no-repeat center center url(chrome://browser/skin/readerMode.svg);
+}
+
+.browserStack[secondarybrowser="overlay"] > .secondarybrowser {
+  width: 95%;
+  height: 95%;
+  z-index: 1;
+  justify-self: center;
+  align-self: start;
+  border: solid 2px rgba(0,0,0,.05);
+  border-top: none;
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -1014,16 +1014,21 @@
                   <image id="cfr-button"
                          class="urlbar-icon urlbar-page-action"
                          role="presentation"/>
                 </hbox>
                 <hbox id="userContext-icons" hidden="true">
                   <label id="userContext-label"/>
                   <image id="userContext-indicator"/>
                 </hbox>
+                <image id="secondary-browser-button"
+                       class="urlbar-icon urlbar-page-action"
+                       tooltip="Open secondary browser"
+                       role="button"
+                       onclick="ReaderParent.secondaryBrowserButtonClick(event);"/>
                 <image id="reader-mode-button"
                        class="urlbar-icon urlbar-page-action"
                        tooltip="dynamic-shortcut-tooltip"
                        role="button"
                        hidden="true"
                        onclick="ReaderParent.buttonClick(event);"/>
                 <toolbarbutton id="urlbar-zoom-button"
                        onclick="FullZoom.reset();"
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -607,16 +607,19 @@
     /**
      * Create a findbar instance.
      * @param aTab the tab to create the find bar for.
      * @return the created findbar, or null if the window or tab is closed/closing.
      */
     async _createFindBar(aTab) {
       let findBar = document.createXULElement("findbar");
       let browser = this.getBrowserForTab(aTab);
+      if (browser.secondaryBrowser) {
+        browser = browser.secondaryBrowser;
+      }
 
       // The findbar should be inserted after the browserStack and, if present for
       // this tab, after the StatusPanel as well.
       let insertAfterElement = browser.parentNode;
       if (insertAfterElement.nextElementSibling == StatusPanel.panel) {
         insertAfterElement = StatusPanel.panel;
       }
       insertAfterElement.insertAdjacentElement("afterend", findBar);
@@ -1852,16 +1855,17 @@
       let oldUserTypedValue = aBrowser.userTypedValue;
       let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
       let parent = aBrowser.parentNode;
 
       // Change the "remote" attribute.
 
       // Make sure the browser is destroyed so it unregisters from observer notifications
       aBrowser.destroy();
+
       // Only remove the node if we're not rebuilding the frameloader via nsFrameLoaderOwner.
       let rebuildFrameLoaders =
         E10SUtils.rebuildFrameloadersOnRemotenessChange ||
         window.docShell.nsILoadContext.useRemoteSubframes;
       if (!rebuildFrameLoaders) {
         aBrowser.remove();
       }
 
@@ -2042,20 +2046,21 @@
       openWindowInfo,
       remoteType,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
-      b.permanentKey = new (Cu.getGlobalForObject(Services).Object)();
+      b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
@@ -2094,17 +2099,16 @@
        *      browsers will attempt to switch to a new content process,
        *      therefore the 'preloadedState' attribute is removed from
        *      that browser altogether
        * See more details on Bug 1420285.
        */
       if (isPreloadBrowser) {
         b.setAttribute("preloadedState", "preloaded");
       }
-
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
 
       // Propagate information about the opening content window to the browser.
       if (openWindowInfo) {
         b.openWindowInfo = openWindowInfo;
       }
@@ -2392,16 +2396,25 @@
         !browser.permitUnload(permitUnloadFlags).permitUnload
       ) {
         return false;
       }
 
       return true;
     },
 
+    closeFindbarForTab(aTab) {
+      // Reset the findbar and remove it if it is attached to the tab.
+      if (aTab._findBar) {
+        aTab._findBar.close(true);
+        aTab._findBar.remove();
+        delete aTab._findBar;
+      }
+    },
+
     discardBrowser(aTab, aForceDiscard) {
       "use strict";
       let browser = aTab.linkedBrowser;
 
       if (!this._mayDiscardBrowser(aTab, aForceDiscard)) {
         return false;
       }
 
@@ -2429,22 +2442,17 @@
       let listener = this._tabListeners.get(aTab);
       browser.webProgress.removeProgressListener(filter);
       filter.removeProgressListener(listener);
       listener.destroy();
 
       this._tabListeners.delete(aTab);
       this._tabFilters.delete(aTab);
 
-      // Reset the findbar and remove it if it is attached to the tab.
-      if (aTab._findBar) {
-        aTab._findBar.close(true);
-        aTab._findBar.remove();
-        delete aTab._findBar;
-      }
+      this.closeFindbarForTab();
 
       // Remove stale loading attributes.
       let attributesToRemove = ["busy", "progress", "pendingicon"];
       let removedAttributes = [];
       for (let attr of attributesToRemove) {
         if (aTab.hasAttribute(attr)) {
           removedAttributes.push(attr);
           aTab.removeAttribute(attr);
@@ -4145,16 +4153,26 @@
 
     announceWindowCreated(browser, userContextId) {
       let tab = this.getTabForBrowser(browser);
       if (tab && userContextId) {
         ContextualIdentityService.telemetry(userContextId);
         tab.setUserContextId(userContextId);
       }
 
+      // Automatically create the secondaryBrowser:
+      // XXX: this should only happen if the tab previously had it or if
+      // there's some global state
+      if (tab) {
+        // if (!browser.secondaryBrowser) {
+        //   // XXX: Make a module to control the sidebar here instead of random clicking
+        //   browser.parentNode.querySelector(".secondarybrowser-split").click();
+        // }
+      }
+
       // We don't want to update the container icon and identifier if
       // this is not the selected browser.
       if (browser == gBrowser.selectedBrowser) {
         updateUserContextUIIndicator();
       }
     },
 
     reloadMultiSelectedTabs() {
@@ -5133,17 +5151,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
@@ -5473,16 +5490,21 @@
 
       let onTabCrashed = event => {
         if (!event.isTrusted || !event.isTopFrame) {
           return;
         }
 
         let browser = event.originalTarget;
 
+        if (browser.hostBrowser) {
+          console.error("secondarybrowser crashed");
+          return;
+        }
+
         // Preloaded browsers do not actually have any tabs. If one crashes,
         // it should be released and removed.
         if (browser === this.preloadedBrowser) {
           NewTabPagePreloading.removePreloadedBrowser(window);
           return;
         }
 
         let isRestartRequiredCrash =
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -87,16 +87,32 @@ let ACTORS = {
         AboutLoginsSyncEnable: { wantUntrusted: true },
         AboutLoginsSyncOptions: { wantUntrusted: true },
         AboutLoginsUpdateLogin: { wantUntrusted: true },
       },
     },
     matches: ["about:logins", "about:logins?*"],
   },
 
+  SecondaryBrowser: {
+    parent: {
+      moduleURI: "resource:///actors/secondarybrowserParent.jsm",
+    },
+    child: {
+      moduleURI: "resource:///actors/SecondaryBrowserChild.jsm",
+      events: {
+        SecondaryBrowserContentView: { wantUntrusted: true },
+        SecondaryBrowserContentLoaded: { wantUntrusted: true },
+        SecondaryBrowserContentClicked: { wantUntrusted: true },
+        SecondaryBrowserContentScroll: { wantUntrusted: true },
+        SecondaryBrowserContentEvent: { wantUntrusted: true },
+      },
+    },
+  },
+
   AboutNewTab: {
     child: {
       moduleURI: "resource:///actors/AboutNewTabChild.jsm",
       events: {
         DOMContentLoaded: {},
       },
     },
     // The wildcard on about:newtab is for the ?endpoint query parameter
diff --git a/browser/components/about/AboutRedirector.cpp b/browser/components/about/AboutRedirector.cpp
--- a/browser/components/about/AboutRedirector.cpp
+++ b/browser/components/about/AboutRedirector.cpp
@@ -103,16 +103,20 @@ static const RedirEntry kRedirMap[] = {
      nsIAboutModule::ALLOW_SCRIPT},
     {"downloads",
      "chrome://browser/content/downloads/contentAreaDownloadsView.xhtml",
      nsIAboutModule::ALLOW_SCRIPT},
     {"reader", "chrome://global/content/reader/aboutReader.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::HIDE_FROM_ABOUTABOUT},
+    {"secondarybrowser", "chrome://browser/content/secondarybrowser/secondaryui.html",
+     nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
+         nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_CAN_LOAD_IN_CHILD |
+         nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"restartrequired", "chrome://browser/content/aboutRestartRequired.xhtml",
      nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"newinstall", "chrome://browser/content/newInstallPage.html",
      nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"protections", "chrome://browser/content/protections.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
diff --git a/browser/components/about/components.conf b/browser/components/about/components.conf
--- a/browser/components/about/components.conf
+++ b/browser/components/about/components.conf
@@ -1,15 +1,16 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 pages = [
+    'secondarybrowser',
     'blocked',
     'certerror',
     'config',
     'downloads',
     'framecrashed',
     'home',
     'logins',
     'newinstall',
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -25,16 +25,17 @@ with Files("safebrowsing/**"):
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
 
 
 DIRS += [
     'about',
     'aboutconfig',
     'aboutlogins',
+    'secondarybrowser',
     'attribution',
     'contextualidentity',
     'customizableui',
     'dirprovider',
     'doh',
     'downloads',
     'enterprisepolicies',
     'extensions',
diff --git a/browser/components/secondarybrowser/SecondaryBrowserChild.jsm b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
@@ -0,0 +1,103 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["SecondaryBrowserChild"];
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+
+const hostToSecondaryBrowserMap = new WeakMap();
+const overlayToHostMap = new WeakMap();
+
+function sendToContent(browsingContext, messageType, detail = {}) {
+  let win = browsingContext.window;
+  let message = Object.assign({ messageType }, { value: detail });
+  let event = new win.CustomEvent("SecondaryBrowserChromeToContent", {
+    detail: Cu.cloneInto(message, win),
+  });
+  win.dispatchEvent(event);
+}
+
+// See stuff like https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/walker.js#499
+
+// Basic idea here is to use this actor to receive the accessibility tree and
+// subsequent events from a 'host' browser, and then to send them along to an
+// 'secondarybrowser' browser (which are running in the same content process)
+// Maybe this should be two different actors?
+class SecondaryBrowserChild extends JSWindowActorChild {
+  willDestroy(e) {
+    // Overlay is destroyed. Kill observing:
+    if (overlayToHostMap.has(this.browsingContext)) {
+      overlayToHostMap.delete(this.browsingContext);
+    }
+  }
+  actorCreated(e) {
+    // I think it's better to wait for SecondaryBrowserContentLoaded to
+    // signal the connection so there's no races.. but maybe this
+    // would come in handy somehow?
+  }
+
+  receiveMessage(message) {
+    console.log(
+      "SecondaryBrowserChild::receiveMessage",
+      message.name,
+      Services.appinfo.processID,
+      this.browsingContext.window.location.toString()
+    );
+    switch (message.name) {
+      case "SecondaryBrowser:UpdateBrowsingContext":
+        const { browsingContext, initialView } = message.data;
+        hostToSecondaryBrowserMap.set(this.browsingContext, browsingContext);
+        overlayToHostMap.set(browsingContext, this.browsingContext);
+
+        console.log("HERE");
+        
+        let win = this.browsingContext.window;
+        let doc = win.document;
+
+        console.log(
+          doc.URI,
+          win.windowUtils.getTrackedImages(),
+          [...win.windowUtils.getTrackedImages()].map(img => {
+            return img.image.width;
+          }),
+          [...win.windowUtils.getTrackedImages()]
+            .map(img => {
+              return img.URI.spec;
+            })
+            .join("\n")
+        );
+
+        sendToContent(
+          browsingContext,
+          "TrackedImages",
+          [...win.windowUtils.getTrackedImages()].map(img => {
+            return img.URI.spec;
+          })
+        );
+
+        // This is only called aftter the initial SecondaryBrowserContentLoaded happens,
+        // so send an entire snapshot now (we can then observe and signal incrementtal
+        // changes later).
+        // walker.sendSnapshot();
+
+        break;
+    }
+  }
+  handleEvent(event) {
+    console.log(event);
+    switch (event.type) {
+      case "SecondaryBrowserClose":
+        this.sendAsyncMessage("SecondaryBrowser:Close");
+        break;
+      case "SecondaryBrowserContentView":
+        if (event.detail.split) {
+          this.sendAsyncMessage("SecondaryBrowser:Split");
+        } else {
+          this.sendAsyncMessage("SecondaryBrowser:Unsplit");
+        }
+        break;
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/SecondaryBrowserParent.jsm b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
@@ -0,0 +1,59 @@
+/* vim: set ts=2 sw=2 sts=2 et tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+var EXPORTED_SYMBOLS = ["SecondaryBrowserParent"];
+
+class SecondaryBrowserParent extends JSWindowActorParent {
+  receiveMessage(message) {
+    // console.log("SecondaryBrowserParent::receiveMessage", message);
+    let browser = this.manager.browsingContext.embedderElement;
+    if (!browser) {
+      return; // Can happen sometimes if browser is being destroyed
+    }
+    if (!browser.hostBrowser) {
+      // This shouldn't really happen - the message is coming from a secondary browser
+      // which by definition should have a host.
+      return;
+    }
+
+    switch (message.name) {
+      // XXX: This could be used if we have an 'overlay' view
+      case "SecondaryBrowser:Close": {
+        browser.hostBrowser.closeSecondaryBrowser();
+        break;
+      }
+      case "SecondaryBrowser:Split": {
+        browser.hostBrowser.parentNode.setAttribute(
+          "secondarybrowser",
+          "split"
+        );
+        break;
+      }
+      case "SecondaryBrowser:Unsplit": {
+        browser.hostBrowser.parentNode.setAttribute("secondarybrowser", "on");
+        break;
+      }
+
+      case "SecondaryBrowser:WindowCreated": {
+        let initialView;
+        // XXX: We need a cleaner way to signal initial state (or just build a prototype
+        // that only deals with outline)
+        initialView = "outline";
+        if (browser.parentNode.getAttribute("secondarybrowser") == "overlay") {
+          initialView = "outline";
+        }
+
+        browser.hostBrowser.browsingContext.currentWindowGlobal
+          .getActor("SecondaryBrowser")
+          .sendAsyncMessage("SecondaryBrowser:UpdateBrowsingContext", {
+            browsingContext: browser.browsingContext,
+            initialView,
+          });
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/content/jar.mn b/browser/components/secondarybrowser/content/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/jar.mn
@@ -0,0 +1,9 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+    content/browser/secondarybrowser/secondaryui.html
+    content/browser/secondarybrowser/secondaryui.js
+    content/browser/secondarybrowser/roles.js
+    content/browser/secondarybrowser/secondaryui.css
diff --git a/browser/components/secondarybrowser/content/roles.js b/browser/components/secondarybrowser/content/roles.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/roles.js
@@ -0,0 +1,1622 @@
+// Built from https://searchfox.org/mozilla-central/source/accessible/base/RoleMap.h
+// Copy in the contents of that file and then
+// VSCode: Find with regex ".*" and then alt+enter to select all
+"use strict";
+
+function setControllerFor(treeItem, container) {
+  let controllerFor = treeItem.relations.filter(
+    r => r.type == "controller for"
+  );
+  if (controllerFor[0]) {
+    // XXX: handle more than one:
+    container.dataset.controllerFor = controllerFor[0].targets[0];
+  }
+}
+
+window.ROLE_MAP = {
+  nothing: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  titlebar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  menubar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  scrollbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grip: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  sound: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  cursor: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  caret: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  alert: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  window: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "internal frame": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.classList.add("internal-frame");
+      container.append(...children);
+      return [container];
+    },
+  },
+  menupopup: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  menuitem: {
+    render(treeItem, children) {
+      // XXX: See https://www.bbc.com/sport
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  tooltip: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHelpTag: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  application: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  document: {
+    render(treeItem, children) {
+      return [...children];
+      // let container = document.createElement("h1");
+      // container.textContent = `${treeItem.name}`;
+      // return [container, ...children];
+    },
+  },
+  AXWebArea: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  pane: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  chart: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  dialog: {
+    render(treeItem, children) {
+      // XXX: Use something like https://github.com/edenspiekermann/a11y-dialog/tree/master/example?
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  border: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grouping: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  separator: {
+    render(treeItem, children) {
+      if (treeItem.attributes.tag == "li") {
+        // The pagination buttons at: https://www.bbc.co.uk/search?q=d
+        return [document.createElement("li")];
+      }
+      return [document.createElement("hr")];
+    },
+  },
+  toolbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  statusbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  table: {
+    render(treeItem, children) {
+      let container = document.createElement("table");
+      container.append(...children);
+      return [container];
+    },
+  },
+  columnheader: {
+    // See https://www.w3.org/WAI/tutorials/tables/irregular/
+    // https://matrix.to/#/!jmuErVonajdNMbgdeY:mozilla.org/$jesupx87ZSzpVWWWp2iQYEBHnQeRadQilupRbngtW80?via=mozilla.org
+    // https://searchfox.org/mozilla-central/source/accessible/generic/TableAccessible.h
+    render(treeItem, children) {
+      let container = document.createElement("th");
+      container.append(...children);
+      return [container];
+    },
+  },
+  rowheader: {
+    render(treeItem, children) {
+      let container = document.createElement("th");
+      container.append(...children);
+      return [container];
+    },
+  },
+  column: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  row: {
+    render(treeItem, children) {
+      let container = document.createElement("tr");
+      container.append(...children);
+      return [container];
+    },
+  },
+  cell: {
+    render(treeItem, children) {
+      let container = document.createElement("td");
+      container.append(...children);
+      return [container];
+    },
+  },
+  link: {
+    render(treeItem, children) {
+      let container = document.createElement("a");
+
+      if (!treeItem.value) {
+        return [...children];
+      }
+
+      if (treeItem.value.toLowerCase().startsWith("javascript:")) {
+        container.href = "#";
+      } else {
+        container.href = treeItem.value;
+      }
+
+      if (children.length) {
+        // XXX: In some cases (i.e. logo on https://developer.mozilla.org/en-US/)
+        // where the child is just an svg image) we also want to include treeItem.name.
+        // In other cases it ends up with duplicated content.
+        container.append(...children);
+      } else {
+        container.append(treeItem.name);
+      }
+
+      container.dataset.accId = treeItem.id;
+      return [container];
+    },
+  },
+  AXLink: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  helpballoon: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHelpTag: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  character: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  list: {
+    render(treeItem, children) {
+      let tag = treeItem.attributes.tag == "ol" ? "ol" : "ul";
+      let container = document.createElement(tag);
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  listitem: {
+    render(treeItem, children) {
+      let container = document.createElement("li");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  outline: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  outlineitem: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  pagetab: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  propertypage: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  indicator: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  graphic: {
+    render(treeItem, children) {
+      if (treeItem.attributes.tag == "svg") {
+        return ["<svg image>"];
+      }
+      if (treeItem.attributes.tag == "_moz_generated_content_image") {
+        // This is for ::before / ::after content.
+        // XXX: Why does this come through the tree?
+        return [];
+      }
+
+      let img = document.createElement("img");
+      img.setAttribute("alt", treeItem.attributes.src);
+      img.setAttribute("src", treeItem.attributes.src);
+      // img.setAttribute("width", treeItem.attributes.width);
+      // img.setAttribute("height", treeItem.attributes.height);
+      return [img];
+    },
+  },
+  statictext: {
+    render(treeItem, children) {
+      if (!treeItem.name) {
+        return [];
+      }
+      return [treeItem.name];
+    },
+  },
+  "text leaf": {
+    render(treeItem, children) {
+      return [treeItem.name];
+      // Leafs will be rendered by parents via name. XXX is that always true?
+      // return [];
+    },
+  },
+  pushbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+
+      setControllerFor(treeItem, container);
+      if (children.length) {
+        container.append(...children);
+      } else {
+        container.append(treeItem.name || "");
+      }
+      return [container];
+    },
+  },
+  checkbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  radiobutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "1": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  combobox: {
+    render(treeItem, children) {
+      let container = document.createElement("select");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  droplist: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  progressbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  dial: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  hotkeyfield: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  slider: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  spinbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  diagram: {
+    render(treeItem, children) {
+      // XXX: Actually render svgs or other diagrams
+      return [];
+    },
+  },
+  animation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  equation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttondropdown: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttonmenu: {
+    render(treeItem, children) {
+      // XXX copy over
+
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+      setControllerFor(treeItem, container);
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttondropdowngrid: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  whitespace: {
+    render(treeItem, children) {
+      return [treeItem.name];
+    },
+  },
+  pagetablist: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  clock: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  splitbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  ipaddress: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "accel label": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  arrow: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  canvas: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "check menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "color chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "date editor": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "desktop icon": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "desktop frame": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "directory pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "file chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "font chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "chrome window": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "glass pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "html container": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  icon: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  label: {
+    render(treeItem, children) {
+      let container = document.createElement("label");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "layered pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "option pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "password text": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "popup menu": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "radio menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "root pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "scroll pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "split pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "table column header": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "table row header": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "tear off menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  terminal: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "text container": {
+    render(treeItem, children) {
+      // XXX: do this for all tags?
+      if (treeItem.attributes.tag == "pre" || treeItem.attributes.tag == "li") {
+        let container = document.createElement(treeItem.attributes.tag);
+        container.append(...children);
+        return [container];
+      }
+
+      return [...children];
+    },
+  },
+  "toggle button": {
+    render(treeItem, children) {
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "tree table": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  viewport: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  header: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  footer: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  paragraph: {
+    render(treeItem, children) {
+      if (!children.length) {
+        return [];
+      }
+      let container = document.createElement("p");
+      container.append(...children);
+      return [container];
+    },
+  },
+  ruler: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXRuler: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  autocomplete: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  editbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  entry: {
+    render(treeItem, children) {
+      // XXX: [relations] is missing from JSON export but would be needed to set up
+      // proper labeling on i.e. amazon.com.
+      let input = document.createElement("input");
+      input.dataset.accId = treeItem.id;
+
+      input.value = treeItem.value;
+      // container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      // container.append(...children);
+      return [input];
+    },
+  },
+  caption: {
+    render(treeItem, children) {
+      let container = document.createElement(
+        treeItem.attributes.tag == "figcaption" ? "figcaption" : "caption"
+      );
+      container.append(...children);
+      return [container];
+    },
+  },
+  "non-native document": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  heading: {
+    render(treeItem, children) {
+      let tag = treeItem.attributes.tag;
+      let container = document.createElement(tag); // XXX: make sure it's an h tag
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHeading: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  page: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  section: {
+    render(treeItem, children) {
+      // Section holds 0 or 1 children.. just skip it.
+      // XXX: Do we need to include a section for certain single-children (display inline?)
+      // if (!children.length || children.length === 1) {
+      //   return [...children];
+      // }
+      // Use display: contents from CSS so the section is maintained but doesn't
+      // do anything visually. XXX: We may want to do something more specific here
+      // like allow certain ones to be block
+      let container = document.createElement("section");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+
+      // let container = document.createElement("div");
+      // container.append(...children);
+      // return [container];
+    },
+  },
+  "redundant object": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  form: {
+    render(treeItem, children) {
+      let container = document.createElement("form");
+      container.append(...children);
+      return [container];
+    },
+  },
+  ime: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "app root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "parent menuitem": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  calendar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "combobox list": {
+    render(treeItem, children) {
+      return [...children];
+    },
+  },
+  "combobox option": {
+    render(treeItem /*, children*/) {
+      let container = document.createElement("option");
+      container.textContent = `${treeItem.name}`;
+      container.dataset.accId = treeItem.id;
+      return [container];
+    },
+  },
+  "image map": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "listbox option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "listbox rich option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  listbox: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "flat equation": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  gridcell: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "embedded object": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  note: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.setAttribute("role", "note");
+      container.append(...children);
+      return [container];
+    },
+  },
+  figure: {
+    render(treeItem, children) {
+      let container = document.createElement("figure");
+      // container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "check rich option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  definitionlist: {
+    render(treeItem, children) {
+      let container = document.createElement("dl");
+      container.append(...children);
+      return [container];
+    },
+  },
+  term: {
+    render(treeItem, children) {
+      let container = document.createElement("dt");
+      container.append(...children);
+      return [container];
+    },
+  },
+  definition: {
+    render(treeItem, children) {
+      let container = document.createElement("dd");
+      container.append(...children);
+      return [container];
+    },
+  },
+  key: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  switch: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  math: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml identifier": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml number": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml operator": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml text": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml string literal": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml glyph": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml fraction": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml square root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml fenced": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml enclosed": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml style": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sub": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sup": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sub sup": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml under": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml over": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml under over": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml multiscripts": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml table": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml labeled row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml table row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml cell": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml action": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml error": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml long division": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack group": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack carries": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack carry": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack line": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grouping: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  text: {
+    render(treeItem, children) {
+      if (!treeItem.name) {
+        return [...children];
+      }
+      return [treeItem.name];
+    },
+  },
+  details: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  summary: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  landmark: {
+    render(treeItem, children) {
+      let roles = treeItem.attributes["xml-roles"].split(" ");
+
+      /*
+    <article>
+    <aside>
+    <details>
+    <figcaption>
+    <figure>
+    <footer>
+    <header>
+    <main>
+    <mark>
+    <nav>
+    <section>
+    <summary>
+    <time>
+      */
+
+      let container;
+      if (roles.includes("banner")) {
+        container = document.createElement("header");
+      }
+      if (roles.includes("navigation")) {
+        // (e.g., a menu)
+        container = document.createElement("nav");
+        if (treeItem.attributes.tag == "ul") {
+          // https://www.bbc.com/news/world-asia-52508437
+          let list = document.createElement("ul");
+          container.append(list);
+          list.append(...children);
+          return [container];
+        }
+      }
+      if (roles.includes("main")) {
+        // (the main content of the page)
+        container = document.createElement("main");
+      }
+      if (roles.includes("complementary")) {
+        // (e.g., a sidebar)
+        container = document.createElement("aside");
+      }
+      if (roles.includes("contentinfo")) {
+        // (meta data about the page, e.g., a copyright statement)
+        container = document.createElement("footer");
+      }
+      if (roles.includes("search")) {
+        container = document.createElement("form");
+        container.setAttribute("role", "search");
+      }
+      if (roles.includes("form")) {
+        container = document.createElement("form");
+      }
+      if (roles.includes("application")) {
+        // (a web application with its own keyboard interface)
+        container = document.createElement("div");
+        container.setAttribute("role", "application");
+      }
+
+      // container.textContent = `${treeItem.role}: ${roles.join(" ")}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  navigation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  footnote: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  article: {
+    render(treeItem, children) {
+      let container = document.createElement("article");
+      container.append(...children);
+      return [container];
+    },
+  },
+  region: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  editcombobox: {
+    render(treeItem, children) {
+      let container = document.createElement("label");
+      container.textContent = `${treeItem.name}`;
+      let input = document.createElement("input");
+      input.dataset.accId = treeItem.id;
+      input.value = treeItem.value;
+      container.appendChild(input);
+      return [container];
+    },
+  },
+  blockquote: {
+    render(treeItem, children) {
+      let container = document.createElement("blockquote");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "content deletion": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "content insertion": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  // form: { this is FORM_LANDMARK https://searchfox.org/mozilla-central/rev/96f1457323cc598a36f5701f8e67aedaf97acfcf/accessible/base/RoleMap.h#1625-1632
+  //   render(treeItem, children) {
+  //     let container = document.createElement("div");
+  //     container.textContent = `${treeItem.role}: ${treeItem.name}`;
+  //     container.append(...children);
+  //     return [container];
+  //   }
+  // },
+  mark: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+};
diff --git a/browser/components/secondarybrowser/content/secondaryui.css b/browser/components/secondarybrowser/content/secondaryui.css
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.css
@@ -0,0 +1,4 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
diff --git a/browser/components/secondarybrowser/content/secondaryui.html b/browser/components/secondarybrowser/content/secondaryui.html
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.html
@@ -0,0 +1,20 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE html>
+
+<html>
+<head>
+  <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'" />
+  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
+  <meta name="viewport" content="width=device-width; user-scalable=0" />
+  <link rel="stylesheet" href="chrome://browser/content/secondarybrowser/secondaryui.css">
+</head>
+<body>
+  <div id="content">
+    hi
+    <button id="close">Close</button>
+  </div>
+</body>
+</html>
diff --git a/browser/components/secondarybrowser/content/secondaryui.js b/browser/components/secondarybrowser/content/secondaryui.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.js
@@ -0,0 +1,27 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+window.addEventListener("DOMContentLoaded", function() {
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserContentLoaded", { bubbles: true })
+  );
+});
+
+document.querySelector("#close").addEventListener("click", () => {
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserClose", { bubbles: true })
+  );
+});
+
+window.addEventListener("SecondaryBrowserChromeToContent", event => {
+  console.log("SecondaryBrowserChromeToContent", event.detail);
+  switch (event.detail.messageType) {
+    case "TrackedImages": {
+      console.log(event.detail);
+      break;
+    }
+  }
+});
diff --git a/browser/components/secondarybrowser/moz.build b/browser/components/secondarybrowser/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/moz.build
@@ -0,0 +1,15 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ['content/jar.mn']
+
+#EXTRA_JS_MODULES += [
+#]
+
+FINAL_TARGET_FILES.actors += [
+    'SecondaryBrowserChild.jsm',
+    'SecondaryBrowserParent.jsm',
+]
diff --git a/browser/modules/ReaderParent.jsm b/browser/modules/ReaderParent.jsm
--- a/browser/modules/ReaderParent.jsm
+++ b/browser/modules/ReaderParent.jsm
@@ -70,37 +70,59 @@ var ReaderParent = {
   },
 
   updateReaderButton(browser) {
     let win = browser.ownerGlobal;
     if (browser != win.gBrowser.selectedBrowser) {
       return;
     }
 
+    let secondaryBrowserButton = win.document.getElementById(
+      "secondary-browser-button"
+    );
     let button = win.document.getElementById("reader-mode-button");
     let menuitem = win.document.getElementById("menu_readerModeItem");
     let key = win.document.getElementById("key_toggleReaderMode");
+
+    if (browser.secondaryBrowser) {
+      secondaryBrowserButton.setAttribute("readeractive", true);
+    } else {
+      secondaryBrowserButton.removeAttribute("readeractive");
+    }
+
     if (browser.currentURI.spec.startsWith("about:reader")) {
       let closeText = gStringBundle.GetStringFromName("readerView.close");
 
+      // if (browser.parentNode.querySelector(".secondarybrowser-reader")) {
+      //   browser.parentNode
+      //     .querySelector(".secondarybrowser-reader")
+      //     .setAttribute("active", "true");
+      // }
+
       button.setAttribute("readeractive", true);
       button.hidden = false;
       button.setAttribute("aria-label", closeText);
 
       menuitem.setAttribute("label", closeText);
       menuitem.setAttribute("hidden", false);
       menuitem.setAttribute(
         "accesskey",
         gStringBundle.GetStringFromName("readerView.close.accesskey")
       );
 
       key.setAttribute("disabled", false);
 
       Services.obs.notifyObservers(null, "reader-mode-available");
     } else {
+      // if (browser.parentNode.querySelector(".secondarybrowser-reader")) {
+      //   browser.parentNode
+      //     .querySelector(".secondarybrowser-reader")
+      //     .removeAttribute("active");
+      // }
+
       let enterText = gStringBundle.GetStringFromName("readerView.enter");
 
       button.removeAttribute("readeractive");
       button.hidden = !browser.isArticle;
       button.setAttribute("aria-label", enterText);
 
       menuitem.setAttribute("label", enterText);
       menuitem.setAttribute("hidden", !browser.isArticle);
@@ -117,16 +139,62 @@ var ReaderParent = {
     }
   },
 
   forceShowReaderIcon(browser) {
     browser.isArticle = true;
     this.updateReaderButton(browser);
   },
 
+  toggleSecondaryBrowser(event) {
+    let win = event.target.ownerGlobal;
+    let gBrowser = win.gBrowser;
+    let browser = gBrowser.selectedBrowser;
+
+    let stack = browser.parentNode;
+    let closeSecondaryBrowser = () => {
+      stack.removeAttribute("secondarybrowser");
+      if (browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.destroySecondaryBrowser();
+      }
+      for (let active of stack.querySelectorAll(
+        ".secondarybrowser-controls toolbarbutton[active]"
+      )) {
+        active.removeAttribute("active");
+      }
+    };
+    browser.closeSecondaryBrowser = closeSecondaryBrowser;
+
+    let openSecondaryBrowser = () => {
+      if (!browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.before(browser.createSecondaryBrowser());
+      }
+      if (!stack.hasAttribute("secondarybrowser")) {
+        stack.setAttribute("secondarybrowser", "overlay");
+      }
+    };
+    browser.openSecondaryBrowser = openSecondaryBrowser;
+    if (browser.secondaryBrowser) {
+      closeSecondaryBrowser();
+    } else {
+      openSecondaryBrowser();
+    }
+    this.updateReaderButton(browser);
+  },
+
+  secondaryBrowserButtonClick(event) {
+    if (event.button != 0) {
+      return;
+    }
+
+    this.toggleSecondaryBrowser(event);
+  },
+
   buttonClick(event) {
     if (event.button != 0) {
       return;
     }
     this.toggleReaderMode(event);
   },
 
   toggleReaderMode(event) {
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -782,16 +782,23 @@
   mask-image: linear-gradient(to right, transparent, black 3ch);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input {
   mask-position-x: calc(var(--cfr-label-width) * -1);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input:-moz-locale-dir(rtl) {
   mask-position-x: calc(var(--cfr-label-width));
 }
+#secondary-browser-button {
+  list-style-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+#secondary-browser-button[readeractive] {
+  background: var(--toolbarbutton-icon-fill-attention);
+  background: rgb(159, 200, 213);
+}
 
 /* Reader mode icon */
 
 #reader-mode-button {
   list-style-image: url(chrome://browser/skin/readerMode.svg);
 }
 
 #reader-mode-button[readeractive] {
diff --git a/toolkit/actors/SelectParent.jsm b/toolkit/actors/SelectParent.jsm
--- a/toolkit/actors/SelectParent.jsm
+++ b/toolkit/actors/SelectParent.jsm
@@ -549,23 +549,26 @@ var SelectParentHelper = {
         }
       }
     }
 
     if (parentElement && ariaOwns) {
       parentElement.setAttribute("aria-owns", ariaOwns);
     }
 
+    // XXX: Pass in whether we are opening for a secondary browser. In the meantime
+    // we'll just enable search everywhere.add-a-comment
     // Check if search pref is enabled, if this is the first time iterating through
     // the dropdown, and if the list is long enough for a search element to be added.
-    if (
-      Services.prefs.getBoolPref("dom.forms.selectSearch") &&
-      addSearch &&
-      element.childElementCount > SEARCH_MINIMUM_ELEMENTS
-    ) {
+    if (true) {
+      // if (
+      //   Services.prefs.getBoolPref("dom.forms.selectSearch") &&
+      //   addSearch &&
+      //   element.childElementCount > SEARCH_MINIMUM_ELEMENTS
+      // ) {
       // Add a search text field as the first element of the dropdown
       let searchbox = element.ownerDocument.createXULElement("search-textbox");
       searchbox.className = "contentSelectDropdown-searchbox";
       searchbox.addEventListener("input", this.onSearchInput);
       searchbox.addEventListener("focus", this.onSearchFocus.bind(this));
       searchbox.addEventListener("blur", this.onSearchBlur);
       searchbox.addEventListener("command", this.onSearchInput);
 
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -449,18 +449,75 @@
         if (this.isRemoteBrowser) {
           this._documentContentType = aContentType;
         } else {
           this.contentDocument.documentContentType = aContentType;
         }
       }
     }
 
+    createSecondaryBrowser() {
+      if (!this.secondaryBrowser) {
+        this.secondaryBrowser = document.createXULElement("browser");
+        this.secondaryBrowser.classList.add("secondarybrowser");
+        this.secondaryBrowser.setAttribute("disablehistory", "true");
+        this.secondaryBrowser.setAttribute("nodefaultsrc", "true");
+        this.secondaryBrowser.setAttribute(
+          "remoteType",
+          this.getAttribute("remoteType")
+        );
+        this.secondaryBrowser.setAttribute(
+          "remote",
+          this.getAttribute("remote")
+        );
+        this.secondaryBrowser.setAttribute("type", "content");
+        this.secondaryBrowser.setAttribute(
+          "contextmenu",
+          this.getAttribute("contextmenu")
+        );
+        this.secondaryBrowser.setAttribute(
+          "datetimepicker",
+          this.getAttribute("datetimepicker")
+        );
+        this.secondaryBrowser.setAttribute(
+          "selectmenulist",
+          this.getAttribute("selectmenulist")
+        );
+        this.secondaryBrowser.setAttribute(
+          "tooltip",
+          this.getAttribute("tooltip")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autocompletepopup",
+          this.getAttribute("autocompletepopup")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autoscrollpopup",
+          this.getAttribute("autoscrollpopup")
+        );
+        this.secondaryBrowser.setAttribute("message", "true");
+        this.secondaryBrowser.setAttribute(
+          "messagemanagergroup",
+          "secondarybrowsers"
+        );
+
+        this.secondaryBrowser.sameProcessAsFrameLoader = this.frameLoader;
+        this.secondaryBrowser.hostBrowser = this;
+        this.secondaryBrowser.src = "about:secondarybrowser";
+      }
+      return this.secondaryBrowser;
+    }
+
     set sameProcessAsFrameLoader(val) {
       this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+      if (this.secondaryBrowser) {
+        this.secondaryBrowser.sameProcessAsFrameLoader = Cu.getWeakReference(
+          val
+        );
+      }
     }
 
     get sameProcessAsFrameLoader() {
       return (
         this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get()
       );
     }
 
@@ -1275,25 +1332,41 @@
         // our RemoteWebProgress or its associated manager, but we'll need to
         // add the progress listeners to the new non-remote WebProgress.
         this._remoteWebProgressManager = null;
         this._remoteWebProgress = null;
         this.restoreProgressListeners();
 
         this.addEventListener("pagehide", this.onPageHide, true);
       }
+
+      if (this.hadsecondaryBrowser) {
+        this.hadsecondaryBrowser = false;
+        this.before(this.createSecondaryBrowser());
+      }
     }
 
+    destroySecondaryBrowser() {
+      if (this.secondaryBrowser) {
+        this.hadsecondaryBrowser = true;
+        this.secondaryBrowser.remove();
+        this.secondaryBrowser = null;
+      }
+    }
     /**
      * This is necessary because the destructor doesn't always get called when
      * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
      */
     destroy() {
       elementsToDestroyOnUnload.delete(this);
 
+      // Just remove the secondarybrowser browser entirely and let it get recreated
+      // when we are re-added (i.e. with a remoteness change)
+      this.destroySecondaryBrowser();
+
       // Make sure that any open select is closed.
       if (this.hasAttribute("selectmenulist")) {
         let menulist = document.getElementById(
           this.getAttribute("selectmenulist")
         );
         if (menulist && menulist.open) {
           let resourcePath = "resource://gre/actors/SelectParent.jsm";
           let { SelectParentHelper } = ChromeUtils.import(resourcePath);
@@ -1979,17 +2052,23 @@
 
       function sendToChildren(browsingContext, childScope) {
         let windowGlobal = browsingContext.currentWindowGlobal;
         // If 'roots' is set, only send if windowGlobal.isProcessRoot is true.
         if (
           windowGlobal &&
           (childScope != "roots" || windowGlobal.isProcessRoot)
         ) {
-          windowGlobal.getActor(actorName).sendAsyncMessage(messageName, args);
+          try {
+            windowGlobal
+              .getActor(actorName)
+              .sendAsyncMessage(messageName, args);
+          } catch (e) {
+            console.log(actorName, messageName, e);
+          }
         }
 
         // Iterate as long as scope in assigned. Note that we use the original
         // passed in scope, not childScope here.
         if (scope) {
           for (let context of browsingContext.children) {
             sendToChildren(context, scope);
           }
diff --git a/toolkit/modules/ActorManagerParent.jsm b/toolkit/modules/ActorManagerParent.jsm
--- a/toolkit/modules/ActorManagerParent.jsm
+++ b/toolkit/modules/ActorManagerParent.jsm
@@ -178,17 +178,17 @@ let ACTORS = {
     child: {
       moduleURI: "resource://gre/actors/FindBarChild.jsm",
       events: {
         keypress: { mozSystemGroup: true },
       },
     },
 
     allFrames: true,
-    messageManagerGroups: ["browsers", "test"],
+    messageManagerGroups: ["browsers", "test", "secondarybrowsers"],
   },
 
   // This is the actor that responds to requests from the find toolbar and
   // searches for matches and highlights them.
   Finder: {
     child: {
       moduleURI: "resource://gre/actors/FinderChild.jsm",
     },
