# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7df4f1544df0d5edf6c8402106ef5dbd66b0ac36

diff --git a/accessible/interfaces/nsIAccessible.idl b/accessible/interfaces/nsIAccessible.idl
--- a/accessible/interfaces/nsIAccessible.idl
+++ b/accessible/interfaces/nsIAccessible.idl
@@ -80,16 +80,21 @@ interface nsIAccessible : nsISupports
   readonly attribute Node DOMNode;
 
   /**
     * For remote accessibles the id of the related DOM node.
     */
   readonly attribute AString id;
 
   /**
+    *
+    */
+  readonly attribute uint64_t uniqueID;
+
+  /**
    * The document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument document;
 
   /**
    * The root document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument rootDocument;
diff --git a/accessible/xpcom/xpcAccessible.cpp b/accessible/xpcom/xpcAccessible.cpp
--- a/accessible/xpcom/xpcAccessible.cpp
+++ b/accessible/xpcom/xpcAccessible.cpp
@@ -92,16 +92,28 @@ xpcAccessible::GetLastChild(nsIAccessibl
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   NS_IF_ADDREF(*aLastChild = ToXPC(IntlGeneric().LastChild()));
   return NS_OK;
 }
 
 NS_IMETHODIMP
+xpcAccessible::GetUniqueID(uint64_t* aUniqueID) {
+  NS_ENSURE_ARG_POINTER(aUniqueID);
+
+  if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
+
+  void* uniqueID = static_cast<void*>(this);
+  *aUniqueID = reinterpret_cast<uint64_t>(uniqueID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 xpcAccessible::GetChildCount(int32_t* aChildCount) {
   NS_ENSURE_ARG_POINTER(aChildCount);
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   *aChildCount = IntlGeneric().ChildCount();
   return NS_OK;
 }
diff --git a/accessible/xpcom/xpcAccessible.h b/accessible/xpcom/xpcAccessible.h
--- a/accessible/xpcom/xpcAccessible.h
+++ b/accessible/xpcom/xpcAccessible.h
@@ -25,16 +25,17 @@ class xpcAccessible : public nsIAccessib
  public:
   // nsIAccessible
   NS_IMETHOD GetParent(nsIAccessible** aParent) final;
   NS_IMETHOD GetNextSibling(nsIAccessible** aNextSibling) final;
   NS_IMETHOD GetPreviousSibling(nsIAccessible** aPreviousSibling) final;
   NS_IMETHOD GetFirstChild(nsIAccessible** aFirstChild) final;
   NS_IMETHOD GetLastChild(nsIAccessible** aLastChild) final;
   NS_IMETHOD GetChildCount(int32_t* aChildCount) final;
+  NS_IMETHOD GetUniqueID(uint64_t* aUniqueID) final;
   NS_IMETHOD GetChildAt(int32_t aChildIndex, nsIAccessible** aChild) final;
   NS_IMETHOD GetChildren(nsIArray** aChildren) final;
   NS_IMETHOD GetIndexInParent(int32_t* aIndexInParent) final;
 
   NS_IMETHOD GetDOMNode(nsINode** aDOMNode) final;
   NS_IMETHOD GetId(nsAString& aID) final;
   NS_IMETHOD GetDocument(nsIAccessibleDocument** aDocument) final;
   NS_IMETHOD GetRootDocument(nsIAccessibleDocument** aRootDocument) final;
diff --git a/browser/actors/BrowserTabParent.jsm b/browser/actors/BrowserTabParent.jsm
--- a/browser/actors/BrowserTabParent.jsm
+++ b/browser/actors/BrowserTabParent.jsm
@@ -11,16 +11,20 @@ class BrowserTabParent extends JSWindowA
     if (!browser) {
       return; // Can happen sometimes if browser is being destroyed
     }
 
     if (browser.outerBrowser) {
       browser = browser.outerBrowser; // handle RDM mode
     }
 
+    if (browser.hostBrowser) {
+      return;
+    }
+
     let gBrowser = browser.ownerGlobal.gBrowser;
 
     if (!gBrowser) {
       // Note: gBrowser might be null because this message might be received
       // from the extension process. There's still an embedderElement involved,
       // but it's the one coming from dummy.xul.
       // This should probably be fixed by adding support to specifying "group: 'browsers"
       // in the registerWindowActor options/. See bug 1557118.
diff --git a/browser/base/content/browser-sets.inc b/browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc
+++ b/browser/base/content/browser-sets.inc
@@ -38,16 +38,17 @@
     <command id="cmd_CustomizeToolbars" oncommand="gCustomizeMode.enter()"/>
     <command id="cmd_toggleOfflineStatus" oncommand="BrowserOffline.toggleOfflineStatus();"/>
     <command id="cmd_quitApplication" oncommand="goQuitApplication()"/>
 
     <command id="View:PageSource" oncommand="BrowserViewSource(window.gBrowser.selectedBrowser);"/>
     <command id="View:PageInfo" oncommand="BrowserPageInfo();"/>
     <command id="View:FullScreen" oncommand="BrowserFullScreen();"/>
     <command id="View:ReaderView" oncommand="ReaderParent.toggleReaderMode(event);"/>
+    <command id="View:SecondaryBrowser" oncommand="ReaderParent.toggleSecondaryBrowser(event);"/>
     <command id="View:PictureInPicture" oncommand="PictureInPicture.onCommand(event);"/>
     <command id="cmd_find" oncommand="gLazyFindCommand('onFindCommand')"/>
     <command id="cmd_findAgain" oncommand="gLazyFindCommand('onFindAgainCommand', false)"/>
     <command id="cmd_findPrevious" oncommand="gLazyFindCommand('onFindAgainCommand', true)"/>
 #ifdef XP_MACOSX
     <command id="cmd_findSelection" oncommand="gLazyFindCommand('onFindSelectionCommand')"/>
 #endif
     <!-- work-around bug 392512 -->
@@ -228,16 +229,20 @@
          command="View:ReaderView"
 #ifdef XP_WIN
          data-l10n-id="reader-mode-toggle-shortcut-windows"
 #else
          data-l10n-id="reader-mode-toggle-shortcut-other"
          modifiers="accel,alt"
 #endif
          disabled="true"/>
+    <key id="key_toggleSecondaryBrowser"
+         command="View:SecondaryBrowser"
+         key="o"
+         modifiers="accel,shift"/>
 
 #ifndef XP_MACOSX
     <key id="key_togglePictureInPicture" data-l10n-id="picture-in-picture-toggle-shortcut" command="View:PictureInPicture" modifiers="accel,shift"/>
     <key                                 data-l10n-id="picture-in-picture-toggle-shortcut-alt" command="View:PictureInPicture" modifiers="accel,shift"/>
 #endif
 
     <key data-l10n-id="nav-reload-shortcut" command="Browser:Reload" modifiers="accel" id="key_reload"/>
     <key data-l10n-id="nav-reload-shortcut" command="Browser:ReloadSkipCache" modifiers="accel,shift" id="key_reload_skip_cache"/>
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,76 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  /* margin-inline-start: 32px;
+  width: calc(100% - 32px); */
+}
+.browserStack:not([secondarybrowser]) > .secondarybrowser {
+  display: none;
+}
+/* 
+.browserStack > .secondarybrowser-controls {
+  justify-self: start;
+  width: 32px;
+  background: rgba(255, 255, 255, .8);
+}
+
+.browserStack > .secondarybrowser-controls > toolbarbutton {
+  width: 32px;
+  height: 32px;
+}
+.browserStack > .secondarybrowser-controls > toolbarbutton:hover,
+.browserStack > .secondarybrowser-controls > toolbarbutton[active] {
+  background-color: hsla(240,5%,5%,.1);
+} */
+
+  /* icons grabbed from https://www.iconfinder.com/iconsets/material-core */
+.secondarybrowser-on {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-split {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxNnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAxNiIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01MDYuMDAwMDAwLCAtMTMwLjAwMDAwMCkiPjxnIGlkPSJkcmF3ZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwNi4wMDAwMDAsIDEzMC4wMDAwMDApIj48cGF0aCBkPSJNMTgsMCBMMiwwIEMwLjgsMCAwLDAuOCAwLDIgTDAsMTQgQzAsMTUuMiAwLjgsMTYgMiwxNiBMMTgsMTYgQzE5LDE2IDIwLDE1LjIgMjAsMTQgTDIwLDIgQzIwLDAuOCAxOSwwIDE4LDAgTDE4LDAgWiBNMTgsMTQgTDEyLDE0IEwxMiwyIEwxOCwyIEwxOCwxNCBMMTgsMTQgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-off {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAyMCIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTYuMDAwMDAwLCAtMjk2LjAwMDAwMCkiPjxnIGlkPSJsYW5ndWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk2LjAwMDAwMCwgMjk2LjAwMDAwMCkiPjxwYXRoIGQ9Ik0xMCwwIEM0LjUsMCAwLDQuNSAwLDEwIEMwLDE1LjUgNC41LDIwIDEwLDIwIEMxNS41LDIwIDIwLDE1LjUgMjAsMTAgQzIwLDQuNSAxNS41LDAgMTAsMCBMMTAsMCBaIE0xNi45LDYgTDE0LDYgQzEzLjcsNC43IDEzLjIsMy42IDEyLjYsMi40IEMxNC40LDMuMSAxNiw0LjMgMTYuOSw2IEwxNi45LDYgWiBNMTAsMiBDMTAuOCwzLjIgMTEuNSw0LjUgMTEuOSw2IEw4LjEsNiBDOC41LDQuNiA5LjIsMy4yIDEwLDIgTDEwLDIgWiBNMi4zLDEyIEMyLjEsMTEuNCAyLDEwLjcgMiwxMCBDMiw5LjMgMi4xLDguNiAyLjMsOCBMNS43LDggQzUuNiw4LjcgNS42LDkuMyA1LjYsMTAgQzUuNiwxMC43IDUuNywxMS4zIDUuNywxMiBMMi4zLDEyIEwyLjMsMTIgWiBNMy4xLDE0IEw2LDE0IEM2LjMsMTUuMyA2LjgsMTYuNCA3LjQsMTcuNiBDNS42LDE2LjkgNCwxNS43IDMuMSwxNCBMMy4xLDE0IFogTTYsNiBMMy4xLDYgQzQuMSw0LjMgNS42LDMuMSA3LjQsMi40IEM2LjgsMy42IDYuMyw0LjcgNiw2IEw2LDYgWiBNMTAsMTggQzkuMiwxNi44IDguNSwxNS41IDguMSwxNCBMMTEuOSwxNCBDMTEuNSwxNS40IDEwLjgsMTYuOCAxMCwxOCBMMTAsMTggWiBNMTIuMywxMiBMNy43LDEyIEM3LjYsMTEuMyA3LjUsMTAuNyA3LjUsMTAgQzcuNSw5LjMgNy42LDguNyA3LjcsOCBMMTIuNCw4IEMxMi41LDguNyAxMi42LDkuMyAxMi42LDEwIEMxMi42LDEwLjcgMTIuNCwxMS4zIDEyLjMsMTIgTDEyLjMsMTIgWiBNMTIuNiwxNy42IEMxMy4yLDE2LjUgMTMuNywxNS4zIDE0LDE0IEwxNi45LDE0IEMxNiwxNS43IDE0LjQsMTYuOSAxMi42LDE3LjYgTDEyLjYsMTcuNiBaIE0xNC40LDEyIEMxNC41LDExLjMgMTQuNSwxMC43IDE0LjUsMTAgQzE0LjUsOS4zIDE0LjQsOC43IDE0LjQsOCBMMTcuOCw4IEMxOCw4LjYgMTguMSw5LjMgMTguMSwxMCBDMTguMSwxMC43IDE4LDExLjQgMTcuOCwxMiBMMTQuNCwxMiBMMTQuNCwxMiBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-media {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxOHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxOCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzEuMDAwMDAwLCAtMTcxLjAwMDAwMCkiPjxnIGlkPSJkcml2ZS1pbWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTcxLjAwMDAwMCkiPjxwYXRoIGQ9Ik0xOCwxNiBMMTgsMiBDMTgsMC45IDE3LjEsMCAxNiwwIEwyLDAgQzAuOSwwIDAsMC45IDAsMiBMMCwxNiBDMCwxNy4xIDAuOSwxOCAyLDE4IEwxNiwxOCBDMTcuMSwxOCAxOCwxNy4xIDE4LDE2IEwxOCwxNiBaIE01LjUsMTAuNSBMOCwxMy41IEwxMS41LDkgTDE2LDE1IEwyLDE1IEw1LjUsMTAuNSBMNS41LDEwLjUgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-outline {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00MjMuMDAwMDAwLCAtMzAxLjAwMDAwMCkiPjxnIGlkPSJsaXN0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjMuMDAwMDAwLCAzMDEuMDAwMDAwKSI+PHBhdGggZD0iTTAsNiBMMiw2IEwyLDQgTDAsNCBMMCw2IEwwLDYgWiBNMCwxMCBMMiwxMCBMMiw4IEwwLDggTDAsMTAgTDAsMTAgWiBNMCwyIEwyLDIgTDIsMCBMMCwwIEwwLDIgTDAsMiBaIE00LDYgTDE4LDYgTDE4LDQgTDQsNCBMNCw2IEw0LDYgWiBNNCwxMCBMMTgsMTAgTDE4LDggTDQsOCBMNCwxMCBMNCwxMCBaIE00LDAgTDQsMiBMMTgsMiBMMTgsMCBMNCwwIEw0LDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-reader {
+  background: no-repeat center center url(chrome://browser/skin/readerMode.svg);
+}
+
+.browserStack[secondarybrowser="overlay"]::after {
+  content: "";
+  position: absolute;
+  left: 0;
+  right: 0;
+  top: 0;
+  bottom: 0;
+  background: rgba(0, 0, 0, .2);
+  z-index: 1;
+}
+
+.browserStack[secondarybrowser="overlay"] > .secondarybrowser {
+  width: 97%;
+  height: 100%;
+  z-index: 2;
+  justify-self: start;
+  align-self: start;
+  border-right: solid 2px rgba(0,0,0,.05);
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -1014,16 +1014,21 @@
                   <image id="cfr-button"
                          class="urlbar-icon urlbar-page-action"
                          role="presentation"/>
                 </hbox>
                 <hbox id="userContext-icons" hidden="true">
                   <label id="userContext-label"/>
                   <image id="userContext-indicator"/>
                 </hbox>
+                <image id="secondary-browser-button"
+                       class="urlbar-icon urlbar-page-action"
+                       tooltip="Open secondary browser"
+                       role="button"
+                       onclick="ReaderParent.secondaryBrowserButtonClick(event);"/>
                 <image id="reader-mode-button"
                        class="urlbar-icon urlbar-page-action"
                        tooltip="dynamic-shortcut-tooltip"
                        role="button"
                        hidden="true"
                        onclick="ReaderParent.buttonClick(event);"/>
                 <toolbarbutton id="urlbar-zoom-button"
                        onclick="FullZoom.reset();"
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -607,16 +607,19 @@
     /**
      * Create a findbar instance.
      * @param aTab the tab to create the find bar for.
      * @return the created findbar, or null if the window or tab is closed/closing.
      */
     async _createFindBar(aTab) {
       let findBar = document.createXULElement("findbar");
       let browser = this.getBrowserForTab(aTab);
+      if (browser.secondaryBrowser) {
+        browser = browser.secondaryBrowser;
+      }
 
       // The findbar should be inserted after the browserStack and, if present for
       // this tab, after the StatusPanel as well.
       let insertAfterElement = browser.parentNode;
       if (insertAfterElement.nextElementSibling == StatusPanel.panel) {
         insertAfterElement = StatusPanel.panel;
       }
       insertAfterElement.insertAdjacentElement("afterend", findBar);
@@ -1852,16 +1855,17 @@
       let oldUserTypedValue = aBrowser.userTypedValue;
       let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
       let parent = aBrowser.parentNode;
 
       // Change the "remote" attribute.
 
       // Make sure the browser is destroyed so it unregisters from observer notifications
       aBrowser.destroy();
+
       // Only remove the node if we're not rebuilding the frameloader via nsFrameLoaderOwner.
       let rebuildFrameLoaders =
         E10SUtils.rebuildFrameloadersOnRemotenessChange ||
         window.docShell.nsILoadContext.useRemoteSubframes;
       if (!rebuildFrameLoaders) {
         aBrowser.remove();
       }
 
@@ -2042,20 +2046,21 @@
       openWindowInfo,
       remoteType,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
-      b.permanentKey = new (Cu.getGlobalForObject(Services).Object)();
+      b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
@@ -2094,17 +2099,16 @@
        *      browsers will attempt to switch to a new content process,
        *      therefore the 'preloadedState' attribute is removed from
        *      that browser altogether
        * See more details on Bug 1420285.
        */
       if (isPreloadBrowser) {
         b.setAttribute("preloadedState", "preloaded");
       }
-
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
 
       // Propagate information about the opening content window to the browser.
       if (openWindowInfo) {
         b.openWindowInfo = openWindowInfo;
       }
@@ -2392,16 +2396,25 @@
         !browser.permitUnload(permitUnloadFlags).permitUnload
       ) {
         return false;
       }
 
       return true;
     },
 
+    closeFindbarForTab(aTab) {
+      // Reset the findbar and remove it if it is attached to the tab.
+      if (aTab._findBar) {
+        aTab._findBar.close(true);
+        aTab._findBar.remove();
+        delete aTab._findBar;
+      }
+    },
+
     discardBrowser(aTab, aForceDiscard) {
       "use strict";
       let browser = aTab.linkedBrowser;
 
       if (!this._mayDiscardBrowser(aTab, aForceDiscard)) {
         return false;
       }
 
@@ -2429,22 +2442,17 @@
       let listener = this._tabListeners.get(aTab);
       browser.webProgress.removeProgressListener(filter);
       filter.removeProgressListener(listener);
       listener.destroy();
 
       this._tabListeners.delete(aTab);
       this._tabFilters.delete(aTab);
 
-      // Reset the findbar and remove it if it is attached to the tab.
-      if (aTab._findBar) {
-        aTab._findBar.close(true);
-        aTab._findBar.remove();
-        delete aTab._findBar;
-      }
+      this.closeFindbarForTab();
 
       // Remove stale loading attributes.
       let attributesToRemove = ["busy", "progress", "pendingicon"];
       let removedAttributes = [];
       for (let attr of attributesToRemove) {
         if (aTab.hasAttribute(attr)) {
           removedAttributes.push(attr);
           aTab.removeAttribute(attr);
@@ -4145,16 +4153,26 @@
 
     announceWindowCreated(browser, userContextId) {
       let tab = this.getTabForBrowser(browser);
       if (tab && userContextId) {
         ContextualIdentityService.telemetry(userContextId);
         tab.setUserContextId(userContextId);
       }
 
+      // Automatically create the secondaryBrowser:
+      // XXX: this should only happen if the tab previously had it or if
+      // there's some global state
+      if (tab) {
+        // if (!browser.secondaryBrowser) {
+        //   // XXX: Make a module to control the sidebar here instead of random clicking
+        //   browser.parentNode.querySelector(".secondarybrowser-split").click();
+        // }
+      }
+
       // We don't want to update the container icon and identifier if
       // this is not the selected browser.
       if (browser == gBrowser.selectedBrowser) {
         updateUserContextUIIndicator();
       }
     },
 
     reloadMultiSelectedTabs() {
@@ -5133,17 +5151,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
@@ -5473,16 +5490,21 @@
 
       let onTabCrashed = event => {
         if (!event.isTrusted || !event.isTopFrame) {
           return;
         }
 
         let browser = event.originalTarget;
 
+        if (browser.hostBrowser) {
+          console.error("secondarybrowser crashed");
+          return;
+        }
+
         // Preloaded browsers do not actually have any tabs. If one crashes,
         // it should be released and removed.
         if (browser === this.preloadedBrowser) {
           NewTabPagePreloading.removePreloadedBrowser(window);
           return;
         }
 
         let isRestartRequiredCrash =
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -87,16 +87,32 @@ let ACTORS = {
         AboutLoginsSyncEnable: { wantUntrusted: true },
         AboutLoginsSyncOptions: { wantUntrusted: true },
         AboutLoginsUpdateLogin: { wantUntrusted: true },
       },
     },
     matches: ["about:logins", "about:logins?*"],
   },
 
+  SecondaryBrowser: {
+    parent: {
+      moduleURI: "resource:///actors/secondarybrowserParent.jsm",
+    },
+    child: {
+      moduleURI: "resource:///actors/SecondaryBrowserChild.jsm",
+      events: {
+        SecondaryBrowserContentLoaded: { wantUntrusted: true },
+        SecondaryBrowserClose: { wantUntrusted: true },
+        DOMContentLoaded: {},
+        pageshow: {},
+        unload: {},
+      },
+    },
+  },
+
   AboutNewTab: {
     child: {
       moduleURI: "resource:///actors/AboutNewTabChild.jsm",
       events: {
         DOMContentLoaded: {},
       },
     },
     // The wildcard on about:newtab is for the ?endpoint query parameter
diff --git a/browser/components/about/AboutRedirector.cpp b/browser/components/about/AboutRedirector.cpp
--- a/browser/components/about/AboutRedirector.cpp
+++ b/browser/components/about/AboutRedirector.cpp
@@ -103,16 +103,20 @@ static const RedirEntry kRedirMap[] = {
      nsIAboutModule::ALLOW_SCRIPT},
     {"downloads",
      "chrome://browser/content/downloads/contentAreaDownloadsView.xhtml",
      nsIAboutModule::ALLOW_SCRIPT},
     {"reader", "chrome://global/content/reader/aboutReader.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::HIDE_FROM_ABOUTABOUT},
+    {"secondarybrowser", "chrome://browser/content/secondarybrowser/secondaryui.html",
+     nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
+         nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::URI_CAN_LOAD_IN_CHILD |
+         nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"restartrequired", "chrome://browser/content/aboutRestartRequired.xhtml",
      nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"newinstall", "chrome://browser/content/newInstallPage.html",
      nsIAboutModule::URI_MUST_LOAD_IN_CHILD |
          nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
          nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::HIDE_FROM_ABOUTABOUT},
     {"protections", "chrome://browser/content/protections.html",
      nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
diff --git a/browser/components/about/components.conf b/browser/components/about/components.conf
--- a/browser/components/about/components.conf
+++ b/browser/components/about/components.conf
@@ -1,15 +1,16 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 pages = [
+    'secondarybrowser',
     'blocked',
     'certerror',
     'config',
     'downloads',
     'framecrashed',
     'home',
     'logins',
     'newinstall',
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -25,16 +25,17 @@ with Files("safebrowsing/**"):
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
 
 
 DIRS += [
     'about',
     'aboutconfig',
     'aboutlogins',
+    'secondarybrowser',
     'attribution',
     'contextualidentity',
     'customizableui',
     'dirprovider',
     'doh',
     'downloads',
     'enterprisepolicies',
     'extensions',
diff --git a/browser/components/secondarybrowser/SecondaryBrowserChild.jsm b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
@@ -0,0 +1,226 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+
+const EXPORTED_SYMBOLS = ["SecondaryBrowserChild"];
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  FileUtils: "resource://gre/modules/FileUtils.jsm",
+  NetUtil: "resource://gre/modules/NetUtil.jsm",
+  Services: "resource://gre/modules/Services.jsm",
+});
+
+const hostToSecondaryBrowserMap = new WeakMap();
+const overlayToHostMap = new WeakMap();
+
+XPCOMUtils.defineLazyServiceGetter(
+  this,
+  "ImgTools",
+  "@mozilla.org/image/tools;1",
+  Ci.imgITools
+);
+
+// See also https://searchfox.org/mozilla-central/source/browser/base/content/nsContextMenu.js#1637-1652
+// and https://searchfox.org/mozilla-central/source/browser/actors/ContextMenuChild.jsm#593-601 for how
+// normal save image works
+// Along with https://searchfox.org/mozilla-central/source/browser/components/ssb/SiteSpecificBrowserService.jsm#162
+
+function saveIcon(container, width, height, target) {
+  return new Promise((resolve, reject) => {
+    let output = FileUtils.openFileOutputStream(target);
+    let stream = ImgTools.encodeScaledImage(
+      container,
+      "image/vnd.microsoft.icon",
+      width,
+      height,
+      ""
+    );
+    NetUtil.asyncCopy(stream, output, status => {
+      if (Components.isSuccessCode(status)) {
+        resolve();
+      } else {
+        reject(Components.Exception("Failed to save icon.", status));
+      }
+    });
+  });
+}
+
+function sendToContent(browsingContext, messageType, detail = {}) {
+  let win = browsingContext.window;
+  let message = Object.assign({ messageType }, { value: detail });
+  let event = new win.CustomEvent("SecondaryBrowserChromeToContent", {
+    detail: Cu.cloneInto(message, win),
+  });
+  win.dispatchEvent(event);
+}
+
+// See stuff like https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/walker.js#499
+
+// Basic idea here is to use this actor to receive the accessibility tree and
+// subsequent events from a 'host' browser, and then to send them along to an
+// 'secondarybrowser' browser (which are running in the same content process)
+// Maybe this should be two different actors?
+class SecondaryBrowserChild extends JSWindowActorChild {
+  willDestroy(e) {
+    // Overlay is destroyed. Kill observing:
+    if (overlayToHostMap.has(this.browsingContext)) {
+      overlayToHostMap.delete(this.browsingContext);
+    }
+  }
+  actorCreated(e) {
+    // I think it's better to wait for SecondaryBrowserContentLoaded to
+    // signal the connection so there's no races.. but maybe this
+    // would come in handy somehow?
+  }
+
+  receiveMessage(message) {
+    console.log(
+      "SecondaryBrowserChild::receiveMessage",
+      message.name,
+      Services.appinfo.processID,
+      this.browsingContext.window.location.toString()
+    );
+    switch (message.name) {
+      case "SecondaryBrowser:UpdateBrowsingContext": {
+        const { browsingContext, initialView } = message.data;
+        hostToSecondaryBrowserMap.set(this.browsingContext, browsingContext);
+        overlayToHostMap.set(browsingContext, this.browsingContext);
+        this.sendImages();
+
+        break;
+      }
+    }
+  }
+
+  sendImages() {
+    // XXX: Set up notification on ImageTracker::Add to update as new
+    // ones are added.
+
+    let win = this.browsingContext.window;
+    let doc = win.document;
+    let browsingContext = hostToSecondaryBrowserMap.get(this.browsingContext);
+    if (!browsingContext) {
+      return;
+    }
+    // console.log(
+    //   doc.URI,
+    //   win.windowUtils.getTrackedImages(),
+    //   [...win.windowUtils.getTrackedImages()].map(img => {
+    //     return img.image.width;
+    //   }),
+    //   [...win.windowUtils.getTrackedImages()]
+    //     .map(img => {
+    //       return img.URI.spec;
+    //     })
+    //     .join("\n")
+    // );
+
+    sendToContent(
+      browsingContext,
+      "TrackedImages",
+      [...win.windowUtils.getTrackedImages()]
+        .filter(img => {
+          // Why is resource://gre-resources/arrow.gif included?
+          return img.URI.scheme != "resource" && img.URI.scheme != "chrome";
+        })
+        .map(img => {
+          // var img = window.windowUtils.getTrackedImages()[0];
+          var imageCache = Cc["@mozilla.org/image/tools;1"]
+            .getService(Ci.imgITools)
+            .getImgCacheForDocument(doc);
+          // The image cache's notion of where this image is located is
+          // the currentURI of the image loading content.
+          var props = imageCache.findEntryProperties(img.finalURI, doc);
+
+          var contentType;
+          var contentDisposition;
+          var width;
+          var height;
+
+          try {
+            width = img.image.width;
+          } catch (e) {}
+          try {
+            height = img.image.height;
+          } catch (e) {}
+
+          try {
+            contentType = props.get("type", Ci.nsISupportsCString).data;
+          } catch (e) {}
+
+          try {
+            contentDisposition = props.get(
+              "content-disposition",
+              Ci.nsISupportsCString
+            ).data;
+          } catch (e) {}
+          console.log(contentType, contentDisposition);
+
+          return {
+            finalURI: img.finalURI.spec,
+            contentType,
+            contentDisposition,
+            width,
+            height,
+          };
+        })
+    );
+
+    // We can either sendToContent or directly change the DOM:
+    console.log(
+      "SecondaryBrowserContentLoaded, PID:",
+      Services.appinfo.processID
+    );
+    let secondaryDoc = browsingContext.window.document;
+    // doc = hostToSecondaryBrowserMap.get(this.browsingContext);
+    let title = secondaryDoc.querySelector("#title");
+    title.textContent = `Page Info: ${this.browsingContext.window.document.title}`;
+  }
+
+  handleEvent(event) {
+    console.log(event);
+
+    switch (event.type) {
+      case "pageshow": {
+        this.sendImages();
+        break;
+      }
+      case "DOMContentLoaded": {
+        this.sendImages();
+        break;
+      }
+      case "unload": {
+        console.log("unload");
+        this.sendImages();
+        break;
+      }
+      case "SecondaryBrowserContentLoaded": {
+        this.sendAsyncMessage("SecondaryBrowser:WindowCreated");
+        break;
+      }
+      case "SecondaryBrowserSaveMedia": {
+        // XXX: Forward this to parent and call internalSave (including
+        // zipping if multiple)
+        break;
+      }
+      case "SecondaryBrowserClose": {
+        this.sendAsyncMessage("SecondaryBrowser:Close");
+        break;
+      }
+      case "SecondaryBrowserContentView": {
+        if (event.detail.split) {
+          this.sendAsyncMessage("SecondaryBrowser:Split");
+        } else {
+          this.sendAsyncMessage("SecondaryBrowser:Unsplit");
+        }
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/SecondaryBrowserParent.jsm b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
@@ -0,0 +1,59 @@
+/* vim: set ts=2 sw=2 sts=2 et tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+var EXPORTED_SYMBOLS = ["SecondaryBrowserParent"];
+
+class SecondaryBrowserParent extends JSWindowActorParent {
+  receiveMessage(message) {
+    // console.log("SecondaryBrowserParent::receiveMessage", message);
+    let browser = this.manager.browsingContext.embedderElement;
+    if (!browser) {
+      return; // Can happen sometimes if browser is being destroyed
+    }
+    if (!browser.hostBrowser) {
+      // This shouldn't really happen - the message is coming from a secondary browser
+      // which by definition should have a host.
+      return;
+    }
+
+    switch (message.name) {
+      // XXX: This could be used if we have an 'overlay' view
+      case "SecondaryBrowser:Close": {
+        browser.hostBrowser.closeSecondaryBrowser();
+        break;
+      }
+      case "SecondaryBrowser:Split": {
+        browser.hostBrowser.parentNode.setAttribute(
+          "secondarybrowser",
+          "split"
+        );
+        break;
+      }
+      case "SecondaryBrowser:Unsplit": {
+        browser.hostBrowser.parentNode.setAttribute("secondarybrowser", "on");
+        break;
+      }
+
+      case "SecondaryBrowser:WindowCreated": {
+        let initialView;
+        // XXX: We need a cleaner way to signal initial state (or just build a prototype
+        // that only deals with outline)
+        initialView = "outline";
+        if (browser.parentNode.getAttribute("secondarybrowser") == "overlay") {
+          initialView = "outline";
+        }
+
+        browser.hostBrowser.browsingContext.currentWindowGlobal
+          .getActor("SecondaryBrowser")
+          .sendAsyncMessage("SecondaryBrowser:UpdateBrowsingContext", {
+            browsingContext: browser.browsingContext,
+            initialView,
+          });
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/content/jar.mn b/browser/components/secondarybrowser/content/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/jar.mn
@@ -0,0 +1,9 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+    content/browser/secondarybrowser/secondaryui.html
+    content/browser/secondarybrowser/secondaryui.js
+    content/browser/secondarybrowser/roles.js
+    content/browser/secondarybrowser/secondaryui.css
diff --git a/browser/components/secondarybrowser/content/roles.js b/browser/components/secondarybrowser/content/roles.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/roles.js
@@ -0,0 +1,1622 @@
+// Built from https://searchfox.org/mozilla-central/source/accessible/base/RoleMap.h
+// Copy in the contents of that file and then
+// VSCode: Find with regex ".*" and then alt+enter to select all
+"use strict";
+
+function setControllerFor(treeItem, container) {
+  let controllerFor = treeItem.relations.filter(
+    r => r.type == "controller for"
+  );
+  if (controllerFor[0]) {
+    // XXX: handle more than one:
+    container.dataset.controllerFor = controllerFor[0].targets[0];
+  }
+}
+
+window.ROLE_MAP = {
+  nothing: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  titlebar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  menubar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  scrollbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grip: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  sound: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  cursor: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  caret: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  alert: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  window: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "internal frame": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.classList.add("internal-frame");
+      container.append(...children);
+      return [container];
+    },
+  },
+  menupopup: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  menuitem: {
+    render(treeItem, children) {
+      // XXX: See https://www.bbc.com/sport
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  tooltip: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHelpTag: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  application: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  document: {
+    render(treeItem, children) {
+      return [...children];
+      // let container = document.createElement("h1");
+      // container.textContent = `${treeItem.name}`;
+      // return [container, ...children];
+    },
+  },
+  AXWebArea: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  pane: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  chart: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  dialog: {
+    render(treeItem, children) {
+      // XXX: Use something like https://github.com/edenspiekermann/a11y-dialog/tree/master/example?
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  border: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grouping: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  separator: {
+    render(treeItem, children) {
+      if (treeItem.attributes.tag == "li") {
+        // The pagination buttons at: https://www.bbc.co.uk/search?q=d
+        return [document.createElement("li")];
+      }
+      return [document.createElement("hr")];
+    },
+  },
+  toolbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  statusbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  table: {
+    render(treeItem, children) {
+      let container = document.createElement("table");
+      container.append(...children);
+      return [container];
+    },
+  },
+  columnheader: {
+    // See https://www.w3.org/WAI/tutorials/tables/irregular/
+    // https://matrix.to/#/!jmuErVonajdNMbgdeY:mozilla.org/$jesupx87ZSzpVWWWp2iQYEBHnQeRadQilupRbngtW80?via=mozilla.org
+    // https://searchfox.org/mozilla-central/source/accessible/generic/TableAccessible.h
+    render(treeItem, children) {
+      let container = document.createElement("th");
+      container.append(...children);
+      return [container];
+    },
+  },
+  rowheader: {
+    render(treeItem, children) {
+      let container = document.createElement("th");
+      container.append(...children);
+      return [container];
+    },
+  },
+  column: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  row: {
+    render(treeItem, children) {
+      let container = document.createElement("tr");
+      container.append(...children);
+      return [container];
+    },
+  },
+  cell: {
+    render(treeItem, children) {
+      let container = document.createElement("td");
+      container.append(...children);
+      return [container];
+    },
+  },
+  link: {
+    render(treeItem, children) {
+      let container = document.createElement("a");
+
+      if (!treeItem.value) {
+        return [...children];
+      }
+
+      if (treeItem.value.toLowerCase().startsWith("javascript:")) {
+        container.href = "#";
+      } else {
+        container.href = treeItem.value;
+      }
+
+      if (children.length) {
+        // XXX: In some cases (i.e. logo on https://developer.mozilla.org/en-US/)
+        // where the child is just an svg image) we also want to include treeItem.name.
+        // In other cases it ends up with duplicated content.
+        container.append(...children);
+      } else {
+        container.append(treeItem.name);
+      }
+
+      container.dataset.accId = treeItem.id;
+      return [container];
+    },
+  },
+  AXLink: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  helpballoon: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHelpTag: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  character: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  list: {
+    render(treeItem, children) {
+      let tag = treeItem.attributes.tag == "ol" ? "ol" : "ul";
+      let container = document.createElement(tag);
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  listitem: {
+    render(treeItem, children) {
+      let container = document.createElement("li");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  outline: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  outlineitem: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  pagetab: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  propertypage: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  indicator: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  graphic: {
+    render(treeItem, children) {
+      if (treeItem.attributes.tag == "svg") {
+        return ["<svg image>"];
+      }
+      if (treeItem.attributes.tag == "_moz_generated_content_image") {
+        // This is for ::before / ::after content.
+        // XXX: Why does this come through the tree?
+        return [];
+      }
+
+      let img = document.createElement("img");
+      img.setAttribute("alt", treeItem.attributes.src);
+      img.setAttribute("src", treeItem.attributes.src);
+      // img.setAttribute("width", treeItem.attributes.width);
+      // img.setAttribute("height", treeItem.attributes.height);
+      return [img];
+    },
+  },
+  statictext: {
+    render(treeItem, children) {
+      if (!treeItem.name) {
+        return [];
+      }
+      return [treeItem.name];
+    },
+  },
+  "text leaf": {
+    render(treeItem, children) {
+      return [treeItem.name];
+      // Leafs will be rendered by parents via name. XXX is that always true?
+      // return [];
+    },
+  },
+  pushbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+
+      setControllerFor(treeItem, container);
+      if (children.length) {
+        container.append(...children);
+      } else {
+        container.append(treeItem.name || "");
+      }
+      return [container];
+    },
+  },
+  checkbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  radiobutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "1": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  combobox: {
+    render(treeItem, children) {
+      let container = document.createElement("select");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  droplist: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  progressbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  dial: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  hotkeyfield: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  slider: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  spinbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  diagram: {
+    render(treeItem, children) {
+      // XXX: Actually render svgs or other diagrams
+      return [];
+    },
+  },
+  animation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  equation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttondropdown: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttonmenu: {
+    render(treeItem, children) {
+      // XXX copy over
+
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+      setControllerFor(treeItem, container);
+      container.append(...children);
+      return [container];
+    },
+  },
+  buttondropdowngrid: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  whitespace: {
+    render(treeItem, children) {
+      return [treeItem.name];
+    },
+  },
+  pagetablist: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  clock: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  splitbutton: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  ipaddress: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "accel label": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  arrow: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  canvas: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "check menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "color chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "date editor": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "desktop icon": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "desktop frame": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "directory pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "file chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "font chooser": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "chrome window": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "glass pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "html container": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  icon: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  label: {
+    render(treeItem, children) {
+      let container = document.createElement("label");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "layered pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "option pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "password text": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "popup menu": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "radio menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "root pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "scroll pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "split pane": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "table column header": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "table row header": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "tear off menu item": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  terminal: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "text container": {
+    render(treeItem, children) {
+      // XXX: do this for all tags?
+      if (treeItem.attributes.tag == "pre" || treeItem.attributes.tag == "li") {
+        let container = document.createElement(treeItem.attributes.tag);
+        container.append(...children);
+        return [container];
+      }
+
+      return [...children];
+    },
+  },
+  "toggle button": {
+    render(treeItem, children) {
+      let container = document.createElement("button");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "tree table": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  viewport: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  header: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  footer: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  paragraph: {
+    render(treeItem, children) {
+      if (!children.length) {
+        return [];
+      }
+      let container = document.createElement("p");
+      container.append(...children);
+      return [container];
+    },
+  },
+  ruler: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXRuler: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  autocomplete: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  editbar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  entry: {
+    render(treeItem, children) {
+      // XXX: [relations] is missing from JSON export but would be needed to set up
+      // proper labeling on i.e. amazon.com.
+      let input = document.createElement("input");
+      input.dataset.accId = treeItem.id;
+
+      input.value = treeItem.value;
+      // container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      // container.append(...children);
+      return [input];
+    },
+  },
+  caption: {
+    render(treeItem, children) {
+      let container = document.createElement(
+        treeItem.attributes.tag == "figcaption" ? "figcaption" : "caption"
+      );
+      container.append(...children);
+      return [container];
+    },
+  },
+  "non-native document": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  heading: {
+    render(treeItem, children) {
+      let tag = treeItem.attributes.tag;
+      let container = document.createElement(tag); // XXX: make sure it's an h tag
+      container.append(...children);
+      return [container];
+    },
+  },
+  AXHeading: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  page: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  section: {
+    render(treeItem, children) {
+      // Section holds 0 or 1 children.. just skip it.
+      // XXX: Do we need to include a section for certain single-children (display inline?)
+      // if (!children.length || children.length === 1) {
+      //   return [...children];
+      // }
+      // Use display: contents from CSS so the section is maintained but doesn't
+      // do anything visually. XXX: We may want to do something more specific here
+      // like allow certain ones to be block
+      let container = document.createElement("section");
+      container.dataset.accId = treeItem.id;
+      container.append(...children);
+      return [container];
+
+      // let container = document.createElement("div");
+      // container.append(...children);
+      // return [container];
+    },
+  },
+  "redundant object": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  form: {
+    render(treeItem, children) {
+      let container = document.createElement("form");
+      container.append(...children);
+      return [container];
+    },
+  },
+  ime: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "app root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "parent menuitem": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  calendar: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "combobox list": {
+    render(treeItem, children) {
+      return [...children];
+    },
+  },
+  "combobox option": {
+    render(treeItem /*, children*/) {
+      let container = document.createElement("option");
+      container.textContent = `${treeItem.name}`;
+      container.dataset.accId = treeItem.id;
+      return [container];
+    },
+  },
+  "image map": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "listbox option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "listbox rich option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  listbox: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "flat equation": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  gridcell: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "embedded object": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  note: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.setAttribute("role", "note");
+      container.append(...children);
+      return [container];
+    },
+  },
+  figure: {
+    render(treeItem, children) {
+      let container = document.createElement("figure");
+      // container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "check rich option": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  definitionlist: {
+    render(treeItem, children) {
+      let container = document.createElement("dl");
+      container.append(...children);
+      return [container];
+    },
+  },
+  term: {
+    render(treeItem, children) {
+      let container = document.createElement("dt");
+      container.append(...children);
+      return [container];
+    },
+  },
+  definition: {
+    render(treeItem, children) {
+      let container = document.createElement("dd");
+      container.append(...children);
+      return [container];
+    },
+  },
+  key: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  switch: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  math: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml identifier": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml number": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml operator": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml text": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml string literal": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml glyph": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml fraction": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml square root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml root": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml fenced": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml enclosed": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml style": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sub": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sup": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml sub sup": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml under": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml over": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml under over": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml multiscripts": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml table": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml labeled row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml table row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml cell": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml action": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml error": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml long division": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack group": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack row": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack carries": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack carry": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "mathml stack line": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  grouping: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  text: {
+    render(treeItem, children) {
+      if (!treeItem.name) {
+        return [...children];
+      }
+      return [treeItem.name];
+    },
+  },
+  details: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  summary: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  landmark: {
+    render(treeItem, children) {
+      let roles = treeItem.attributes["xml-roles"].split(" ");
+
+      /*
+    <article>
+    <aside>
+    <details>
+    <figcaption>
+    <figure>
+    <footer>
+    <header>
+    <main>
+    <mark>
+    <nav>
+    <section>
+    <summary>
+    <time>
+      */
+
+      let container;
+      if (roles.includes("banner")) {
+        container = document.createElement("header");
+      }
+      if (roles.includes("navigation")) {
+        // (e.g., a menu)
+        container = document.createElement("nav");
+        if (treeItem.attributes.tag == "ul") {
+          // https://www.bbc.com/news/world-asia-52508437
+          let list = document.createElement("ul");
+          container.append(list);
+          list.append(...children);
+          return [container];
+        }
+      }
+      if (roles.includes("main")) {
+        // (the main content of the page)
+        container = document.createElement("main");
+      }
+      if (roles.includes("complementary")) {
+        // (e.g., a sidebar)
+        container = document.createElement("aside");
+      }
+      if (roles.includes("contentinfo")) {
+        // (meta data about the page, e.g., a copyright statement)
+        container = document.createElement("footer");
+      }
+      if (roles.includes("search")) {
+        container = document.createElement("form");
+        container.setAttribute("role", "search");
+      }
+      if (roles.includes("form")) {
+        container = document.createElement("form");
+      }
+      if (roles.includes("application")) {
+        // (a web application with its own keyboard interface)
+        container = document.createElement("div");
+        container.setAttribute("role", "application");
+      }
+
+      // container.textContent = `${treeItem.role}: ${roles.join(" ")}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  navigation: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  footnote: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  article: {
+    render(treeItem, children) {
+      let container = document.createElement("article");
+      container.append(...children);
+      return [container];
+    },
+  },
+  region: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  editcombobox: {
+    render(treeItem, children) {
+      let container = document.createElement("label");
+      container.textContent = `${treeItem.name}`;
+      let input = document.createElement("input");
+      input.dataset.accId = treeItem.id;
+      input.value = treeItem.value;
+      container.appendChild(input);
+      return [container];
+    },
+  },
+  blockquote: {
+    render(treeItem, children) {
+      let container = document.createElement("blockquote");
+      container.append(...children);
+      return [container];
+    },
+  },
+  "content deletion": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  "content insertion": {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+  // form: { this is FORM_LANDMARK https://searchfox.org/mozilla-central/rev/96f1457323cc598a36f5701f8e67aedaf97acfcf/accessible/base/RoleMap.h#1625-1632
+  //   render(treeItem, children) {
+  //     let container = document.createElement("div");
+  //     container.textContent = `${treeItem.role}: ${treeItem.name}`;
+  //     container.append(...children);
+  //     return [container];
+  //   }
+  // },
+  mark: {
+    render(treeItem, children) {
+      let container = document.createElement("div");
+      container.textContent = `${treeItem.role}: ${treeItem.name}`;
+      container.append(...children);
+      return [container];
+    },
+  },
+};
diff --git a/browser/components/secondarybrowser/content/secondaryui.css b/browser/components/secondarybrowser/content/secondaryui.css
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.css
@@ -0,0 +1,38 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+ * {
+  box-sizing: border-box;
+ }
+ #close {
+  position: absolute;
+  right: 4px;
+  top: 1px;
+  min-height: 30px;
+  margin: 0;
+  min-width: 20px;
+ }
+
+ #content {
+   display: flex;
+   flex-direction: column;
+   height: 100vh;
+ }
+ #details-deck {
+  flex: 1;
+  overflow: scroll;
+ }
+ .tab-group {
+   margin-inline: 0;
+   margin-top: 0;
+   border-top: none;
+ }
+img {
+  /* max-width: 80%;
+  margin: 2px; */
+  max-width: 100%;
+
+}
+
+.grid-item { max-width: 200px; }
\ No newline at end of file
diff --git a/browser/components/secondarybrowser/content/secondaryui.html b/browser/components/secondarybrowser/content/secondaryui.html
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.html
@@ -0,0 +1,40 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE html>
+
+<html>
+<head>
+  <!-- <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'" /> -->
+  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
+  <meta name="viewport" content="width=device-width; user-scalable=0" />
+  <link rel="stylesheet" href="chrome://global/skin/in-content/common.css">
+  <link rel="stylesheet" href="chrome://mozapps/content/extensions/aboutaddons.css">
+  <link rel="stylesheet" href="chrome://browser/content/secondarybrowser/secondaryui.css">
+</head>
+<body>
+  <div id="content">
+    <button id="close" aria-label="close">X</button>
+    <button-group class="tab-group">
+      <button is="named-deck-button" deck="details-deck" name="info" class="tab-button">Info</button>
+      <button is="named-deck-button" deck="details-deck" name="images" class="tab-button">Images</button>
+    </button-group>
+    <named-deck id="details-deck" selected-view="images">
+      <section name="info">
+        <h2>Page Info</h2>
+        <div id="title"></div>
+      </section>
+      <section name="images">
+        <h2>Images</h2>
+        <div id="grid"></div>
+      </section>
+    </named-deck>
+
+
+
+  </div>
+  <script src="chrome://mozapps/content/extensions/named-deck.js"></script>
+  <script src="chrome://browser/content/secondarybrowser/secondaryui.js"></script>
+</body>
+</html>
diff --git a/browser/components/secondarybrowser/content/secondaryui.js b/browser/components/secondarybrowser/content/secondaryui.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.js
@@ -0,0 +1,2529 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/*!
+ * Masonry PACKAGED v4.2.2
+ * Cascading grid layout library
+ * https://masonry.desandro.com
+ * MIT License
+ * by David DeSandro
+ */
+
+/**
+ * Bridget makes jQuery widgets
+ * v2.0.1
+ * MIT license
+ */
+
+/* jshint browser: true, strict: true, undef: true, unused: true */
+
+(function(window, factory) {
+  // universal module definition
+  /*jshint strict: false */ /* globals define, module, require */
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define("jquery-bridget/jquery-bridget", ["jquery"], function(jQuery) {
+      return factory(window, jQuery);
+    });
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory(window, require("jquery"));
+  } else {
+    // browser global
+    window.jQueryBridget = factory(window, window.jQuery);
+  }
+})(window, function factory(window, jQuery) {
+  "use strict";
+
+  // ----- utils ----- //
+
+  var arraySlice = Array.prototype.slice;
+
+  // helper function for logging errors
+  // $.error breaks jQuery chaining
+  var console = window.console;
+  var logError =
+    typeof console == "undefined"
+      ? function() {}
+      : function(message) {
+          console.error(message);
+        };
+
+  // ----- jQueryBridget ----- //
+
+  function jQueryBridget(namespace, PluginClass, $) {
+    $ = $ || jQuery || window.jQuery;
+    if (!$) {
+      return;
+    }
+
+    // add option method -> $().plugin('option', {...})
+    if (!PluginClass.prototype.option) {
+      // option setter
+      PluginClass.prototype.option = function(opts) {
+        // bail out if not an object
+        if (!$.isPlainObject(opts)) {
+          return;
+        }
+        this.options = $.extend(true, this.options, opts);
+      };
+    }
+
+    // make jQuery plugin
+    $.fn[namespace] = function(arg0 /*, arg1 */) {
+      if (typeof arg0 == "string") {
+        // method call $().plugin( 'methodName', { options } )
+        // shift arguments by 1
+        var args = arraySlice.call(arguments, 1);
+        return methodCall(this, arg0, args);
+      }
+      // just $().plugin({ options })
+      plainCall(this, arg0);
+      return this;
+    };
+
+    // $().plugin('methodName')
+    function methodCall($elems, methodName, args) {
+      var returnValue;
+      var pluginMethodStr = "$()." + namespace + '("' + methodName + '")';
+
+      $elems.each(function(i, elem) {
+        // get instance
+        var instance = $.data(elem, namespace);
+        if (!instance) {
+          logError(
+            namespace +
+              " not initialized. Cannot call methods, i.e. " +
+              pluginMethodStr
+          );
+          return;
+        }
+
+        var method = instance[methodName];
+        if (!method || methodName.charAt(0) == "_") {
+          logError(pluginMethodStr + " is not a valid method");
+          return;
+        }
+
+        // apply method, get return value
+        var value = method.apply(instance, args);
+        // set return value if value is returned, use only first value
+        returnValue = returnValue === undefined ? value : returnValue;
+      });
+
+      return returnValue !== undefined ? returnValue : $elems;
+    }
+
+    function plainCall($elems, options) {
+      $elems.each(function(i, elem) {
+        var instance = $.data(elem, namespace);
+        if (instance) {
+          // set options & init
+          instance.option(options);
+          instance._init();
+        } else {
+          // initialize new instance
+          instance = new PluginClass(elem, options);
+          $.data(elem, namespace, instance);
+        }
+      });
+    }
+
+    updateJQuery($);
+  }
+
+  // ----- updateJQuery ----- //
+
+  // set $.bridget for v1 backwards compatibility
+  function updateJQuery($) {
+    if (!$ || ($ && $.bridget)) {
+      return;
+    }
+    $.bridget = jQueryBridget;
+  }
+
+  updateJQuery(jQuery || window.jQuery);
+
+  // -----  ----- //
+
+  return jQueryBridget;
+});
+
+/**
+ * EvEmitter v1.1.0
+ * Lil' event emitter
+ * MIT License
+ */
+
+/* jshint unused: true, undef: true, strict: true */
+
+(function(global, factory) {
+  // universal module definition
+  /* jshint strict: false */ /* globals define, module, window */
+  if (typeof define == "function" && define.amd) {
+    // AMD - RequireJS
+    define("ev-emitter/ev-emitter", factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS - Browserify, Webpack
+    module.exports = factory();
+  } else {
+    // Browser globals
+    global.EvEmitter = factory();
+  }
+})(typeof window != "undefined" ? window : this, function() {
+  function EvEmitter() {}
+
+  var proto = EvEmitter.prototype;
+
+  proto.on = function(eventName, listener) {
+    if (!eventName || !listener) {
+      return;
+    }
+    // set events hash
+    var events = (this._events = this._events || {});
+    // set listeners array
+    var listeners = (events[eventName] = events[eventName] || []);
+    // only add once
+    if (listeners.indexOf(listener) == -1) {
+      listeners.push(listener);
+    }
+
+    return this;
+  };
+
+  proto.once = function(eventName, listener) {
+    if (!eventName || !listener) {
+      return;
+    }
+    // add event
+    this.on(eventName, listener);
+    // set once flag
+    // set onceEvents hash
+    var onceEvents = (this._onceEvents = this._onceEvents || {});
+    // set onceListeners object
+    var onceListeners = (onceEvents[eventName] = onceEvents[eventName] || {});
+    // set flag
+    onceListeners[listener] = true;
+
+    return this;
+  };
+
+  proto.off = function(eventName, listener) {
+    var listeners = this._events && this._events[eventName];
+    if (!listeners || !listeners.length) {
+      return;
+    }
+    var index = listeners.indexOf(listener);
+    if (index != -1) {
+      listeners.splice(index, 1);
+    }
+
+    return this;
+  };
+
+  proto.emitEvent = function(eventName, args) {
+    var listeners = this._events && this._events[eventName];
+    if (!listeners || !listeners.length) {
+      return;
+    }
+    // copy over to avoid interference if .off() in listener
+    listeners = listeners.slice(0);
+    args = args || [];
+    // once stuff
+    var onceListeners = this._onceEvents && this._onceEvents[eventName];
+
+    for (var i = 0; i < listeners.length; i++) {
+      var listener = listeners[i];
+      var isOnce = onceListeners && onceListeners[listener];
+      if (isOnce) {
+        // remove listener
+        // remove before trigger to prevent recursion
+        this.off(eventName, listener);
+        // unset once flag
+        delete onceListeners[listener];
+      }
+      // trigger listener
+      listener.apply(this, args);
+    }
+
+    return this;
+  };
+
+  proto.allOff = function() {
+    delete this._events;
+    delete this._onceEvents;
+  };
+
+  return EvEmitter;
+});
+
+/*!
+ * getSize v2.0.3
+ * measure size of elements
+ * MIT license
+ */
+
+/* jshint browser: true, strict: true, undef: true, unused: true */
+/* globals console: false */
+
+(function(window, factory) {
+  /* jshint strict: false */ /* globals define, module */
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define("get-size/get-size", factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory();
+  } else {
+    // browser global
+    window.getSize = factory();
+  }
+})(window, function factory() {
+  "use strict";
+
+  // -------------------------- helpers -------------------------- //
+
+  // get a number from a string, not a percentage
+  function getStyleSize(value) {
+    var num = parseFloat(value);
+    // not a percent like '100%', and a number
+    var isValid = value.indexOf("%") == -1 && !isNaN(num);
+    return isValid && num;
+  }
+
+  function noop() {}
+
+  var logError =
+    typeof console == "undefined"
+      ? noop
+      : function(message) {
+          console.error(message);
+        };
+
+  // -------------------------- measurements -------------------------- //
+
+  var measurements = [
+    "paddingLeft",
+    "paddingRight",
+    "paddingTop",
+    "paddingBottom",
+    "marginLeft",
+    "marginRight",
+    "marginTop",
+    "marginBottom",
+    "borderLeftWidth",
+    "borderRightWidth",
+    "borderTopWidth",
+    "borderBottomWidth",
+  ];
+
+  var measurementsLength = measurements.length;
+
+  function getZeroSize() {
+    var size = {
+      width: 0,
+      height: 0,
+      innerWidth: 0,
+      innerHeight: 0,
+      outerWidth: 0,
+      outerHeight: 0,
+    };
+    for (var i = 0; i < measurementsLength; i++) {
+      var measurement = measurements[i];
+      size[measurement] = 0;
+    }
+    return size;
+  }
+
+  // -------------------------- getStyle -------------------------- //
+
+  /**
+   * getStyle, get style of element, check for Firefox bug
+   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
+   */
+  function getStyle(elem) {
+    var style = getComputedStyle(elem);
+    if (!style) {
+      logError(
+        "Style returned " +
+          style +
+          ". Are you running this code in a hidden iframe on Firefox? " +
+          "See https://bit.ly/getsizebug1"
+      );
+    }
+    return style;
+  }
+
+  // -------------------------- setup -------------------------- //
+
+  var isSetup = false;
+
+  var isBoxSizeOuter;
+
+  /**
+   * setup
+   * check isBoxSizerOuter
+   * do on first getSize() rather than on page load for Firefox bug
+   */
+  function setup() {
+    // setup once
+    if (isSetup) {
+      return;
+    }
+    isSetup = true;
+
+    // -------------------------- box sizing -------------------------- //
+
+    /**
+     * Chrome & Safari measure the outer-width on style.width on border-box elems
+     * IE11 & Firefox<29 measures the inner-width
+     */
+    var div = document.createElement("div");
+    div.style.width = "200px";
+    div.style.padding = "1px 2px 3px 4px";
+    div.style.borderStyle = "solid";
+    div.style.borderWidth = "1px 2px 3px 4px";
+    div.style.boxSizing = "border-box";
+
+    var body = document.body || document.documentElement;
+    body.appendChild(div);
+    var style = getStyle(div);
+    // round value for browser zoom. desandro/masonry#928
+    isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;
+    getSize.isBoxSizeOuter = isBoxSizeOuter;
+
+    body.removeChild(div);
+  }
+
+  // -------------------------- getSize -------------------------- //
+
+  function getSize(elem) {
+    setup();
+
+    // use querySeletor if elem is string
+    if (typeof elem == "string") {
+      elem = document.querySelector(elem);
+    }
+
+    // do not proceed on non-objects
+    if (!elem || typeof elem != "object" || !elem.nodeType) {
+      return;
+    }
+
+    var style = getStyle(elem);
+
+    // if hidden, everything is 0
+    if (style.display == "none") {
+      return getZeroSize();
+    }
+
+    var size = {};
+    size.width = elem.offsetWidth;
+    size.height = elem.offsetHeight;
+
+    var isBorderBox = (size.isBorderBox = style.boxSizing == "border-box");
+
+    // get all measurements
+    for (var i = 0; i < measurementsLength; i++) {
+      var measurement = measurements[i];
+      var value = style[measurement];
+      var num = parseFloat(value);
+      // any 'auto', 'medium' value will be 0
+      size[measurement] = !isNaN(num) ? num : 0;
+    }
+
+    var paddingWidth = size.paddingLeft + size.paddingRight;
+    var paddingHeight = size.paddingTop + size.paddingBottom;
+    var marginWidth = size.marginLeft + size.marginRight;
+    var marginHeight = size.marginTop + size.marginBottom;
+    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
+    var borderHeight = size.borderTopWidth + size.borderBottomWidth;
+
+    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
+
+    // overwrite width and height if we can get it from style
+    var styleWidth = getStyleSize(style.width);
+    if (styleWidth !== false) {
+      size.width =
+        styleWidth +
+        // add padding and border unless it's already including it
+        (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
+    }
+
+    var styleHeight = getStyleSize(style.height);
+    if (styleHeight !== false) {
+      size.height =
+        styleHeight +
+        // add padding and border unless it's already including it
+        (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
+    }
+
+    size.innerWidth = size.width - (paddingWidth + borderWidth);
+    size.innerHeight = size.height - (paddingHeight + borderHeight);
+
+    size.outerWidth = size.width + marginWidth;
+    size.outerHeight = size.height + marginHeight;
+
+    return size;
+  }
+
+  return getSize;
+});
+
+/**
+ * matchesSelector v2.0.2
+ * matchesSelector( element, '.selector' )
+ * MIT license
+ */
+
+/*jshint browser: true, strict: true, undef: true, unused: true */
+
+(function(window, factory) {
+  /*global define: false, module: false */
+  "use strict";
+  // universal module definition
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define("desandro-matches-selector/matches-selector", factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory();
+  } else {
+    // browser global
+    window.matchesSelector = factory();
+  }
+})(window, function factory() {
+  "use strict";
+
+  var matchesMethod = (function() {
+    var ElemProto = window.Element.prototype;
+    // check for the standard method name first
+    if (ElemProto.matches) {
+      return "matches";
+    }
+    // check un-prefixed
+    if (ElemProto.matchesSelector) {
+      return "matchesSelector";
+    }
+    // check vendor prefixes
+    var prefixes = ["webkit", "moz", "ms", "o"];
+
+    for (var i = 0; i < prefixes.length; i++) {
+      var prefix = prefixes[i];
+      var method = prefix + "MatchesSelector";
+      if (ElemProto[method]) {
+        return method;
+      }
+    }
+  })();
+
+  return function matchesSelector(elem, selector) {
+    return elem[matchesMethod](selector);
+  };
+});
+
+/**
+ * Fizzy UI utils v2.0.7
+ * MIT license
+ */
+
+/*jshint browser: true, undef: true, unused: true, strict: true */
+
+(function(window, factory) {
+  // universal module definition
+  /*jshint strict: false */ /*globals define, module, require */
+
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define("fizzy-ui-utils/utils", [
+      "desandro-matches-selector/matches-selector",
+    ], function(matchesSelector) {
+      return factory(window, matchesSelector);
+    });
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory(window, require("desandro-matches-selector"));
+  } else {
+    // browser global
+    window.fizzyUIUtils = factory(window, window.matchesSelector);
+  }
+})(window, function factory(window, matchesSelector) {
+  var utils = {};
+
+  // ----- extend ----- //
+
+  // extends objects
+  utils.extend = function(a, b) {
+    for (var prop in b) {
+      a[prop] = b[prop];
+    }
+    return a;
+  };
+
+  // ----- modulo ----- //
+
+  utils.modulo = function(num, div) {
+    return ((num % div) + div) % div;
+  };
+
+  // ----- makeArray ----- //
+
+  var arraySlice = Array.prototype.slice;
+
+  // turn element or nodeList into an array
+  utils.makeArray = function(obj) {
+    if (Array.isArray(obj)) {
+      // use object if already an array
+      return obj;
+    }
+    // return empty array if undefined or null. #6
+    if (obj === null || obj === undefined) {
+      return [];
+    }
+
+    var isArrayLike = typeof obj == "object" && typeof obj.length == "number";
+    if (isArrayLike) {
+      // convert nodeList to array
+      return arraySlice.call(obj);
+    }
+
+    // array of single index
+    return [obj];
+  };
+
+  // ----- removeFrom ----- //
+
+  utils.removeFrom = function(ary, obj) {
+    var index = ary.indexOf(obj);
+    if (index != -1) {
+      ary.splice(index, 1);
+    }
+  };
+
+  // ----- getParent ----- //
+
+  utils.getParent = function(elem, selector) {
+    while (elem.parentNode && elem != document.body) {
+      elem = elem.parentNode;
+      if (matchesSelector(elem, selector)) {
+        return elem;
+      }
+    }
+  };
+
+  // ----- getQueryElement ----- //
+
+  // use element as selector string
+  utils.getQueryElement = function(elem) {
+    if (typeof elem == "string") {
+      return document.querySelector(elem);
+    }
+    return elem;
+  };
+
+  // ----- handleEvent ----- //
+
+  // enable .ontype to trigger from .addEventListener( elem, 'type' )
+  utils.handleEvent = function(event) {
+    var method = "on" + event.type;
+    if (this[method]) {
+      this[method](event);
+    }
+  };
+
+  // ----- filterFindElements ----- //
+
+  utils.filterFindElements = function(elems, selector) {
+    // make array of elems
+    elems = utils.makeArray(elems);
+    var ffElems = [];
+
+    elems.forEach(function(elem) {
+      // check that elem is an actual element
+      if (!(elem instanceof HTMLElement)) {
+        return;
+      }
+      // add elem if no selector
+      if (!selector) {
+        ffElems.push(elem);
+        return;
+      }
+      // filter & find items if we have a selector
+      // filter
+      if (matchesSelector(elem, selector)) {
+        ffElems.push(elem);
+      }
+      // find children
+      var childElems = elem.querySelectorAll(selector);
+      // concat childElems to filterFound array
+      for (var i = 0; i < childElems.length; i++) {
+        ffElems.push(childElems[i]);
+      }
+    });
+
+    return ffElems;
+  };
+
+  // ----- debounceMethod ----- //
+
+  utils.debounceMethod = function(_class, methodName, threshold) {
+    threshold = threshold || 100;
+    // original method
+    var method = _class.prototype[methodName];
+    var timeoutName = methodName + "Timeout";
+
+    _class.prototype[methodName] = function() {
+      var timeout = this[timeoutName];
+      clearTimeout(timeout);
+
+      var args = arguments;
+      var _this = this;
+      this[timeoutName] = setTimeout(function() {
+        method.apply(_this, args);
+        delete _this[timeoutName];
+      }, threshold);
+    };
+  };
+
+  // ----- docReady ----- //
+
+  utils.docReady = function(callback) {
+    var readyState = document.readyState;
+    if (readyState == "complete" || readyState == "interactive") {
+      // do async to allow for other scripts to run. metafizzy/flickity#441
+      setTimeout(callback);
+    } else {
+      document.addEventListener("DOMContentLoaded", callback);
+    }
+  };
+
+  // ----- htmlInit ----- //
+
+  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
+  utils.toDashed = function(str) {
+    return str
+      .replace(/(.)([A-Z])/g, function(match, $1, $2) {
+        return $1 + "-" + $2;
+      })
+      .toLowerCase();
+  };
+
+  var console = window.console;
+  /**
+   * allow user to initialize classes via [data-namespace] or .js-namespace class
+   * htmlInit( Widget, 'widgetName' )
+   * options are parsed from data-namespace-options
+   */
+  utils.htmlInit = function(WidgetClass, namespace) {
+    utils.docReady(function() {
+      var dashedNamespace = utils.toDashed(namespace);
+      var dataAttr = "data-" + dashedNamespace;
+      var dataAttrElems = document.querySelectorAll("[" + dataAttr + "]");
+      var jsDashElems = document.querySelectorAll(".js-" + dashedNamespace);
+      var elems = utils
+        .makeArray(dataAttrElems)
+        .concat(utils.makeArray(jsDashElems));
+      var dataOptionsAttr = dataAttr + "-options";
+      var jQuery = window.jQuery;
+
+      elems.forEach(function(elem) {
+        var attr =
+          elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
+        var options;
+        try {
+          options = attr && JSON.parse(attr);
+        } catch (error) {
+          // log error, do not initialize
+          if (console) {
+            console.error(
+              "Error parsing " +
+                dataAttr +
+                " on " +
+                elem.className +
+                ": " +
+                error
+            );
+          }
+          return;
+        }
+        // initialize
+        var instance = new WidgetClass(elem, options);
+        // make available via $().data('namespace')
+        if (jQuery) {
+          jQuery.data(elem, namespace, instance);
+        }
+      });
+    });
+  };
+
+  // -----  ----- //
+
+  return utils;
+});
+
+/**
+ * Outlayer Item
+ */
+
+(function(window, factory) {
+  // universal module definition
+  /* jshint strict: false */ /* globals define, module, require */
+  if (typeof define == "function" && define.amd) {
+    // AMD - RequireJS
+    define("outlayer/item", [
+      "ev-emitter/ev-emitter",
+      "get-size/get-size",
+    ], factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS - Browserify, Webpack
+    module.exports = factory(require("ev-emitter"), require("get-size"));
+  } else {
+    // browser global
+    window.Outlayer = {};
+    window.Outlayer.Item = factory(window.EvEmitter, window.getSize);
+  }
+})(window, function factory(EvEmitter, getSize) {
+  "use strict";
+
+  // ----- helpers ----- //
+
+  function isEmptyObj(obj) {
+    for (var prop in obj) {
+      return false;
+    }
+    prop = null;
+    return true;
+  }
+
+  // -------------------------- CSS3 support -------------------------- //
+
+  var docElemStyle = document.documentElement.style;
+
+  var transitionProperty =
+    typeof docElemStyle.transition == "string"
+      ? "transition"
+      : "WebkitTransition";
+  var transformProperty =
+    typeof docElemStyle.transform == "string" ? "transform" : "WebkitTransform";
+
+  var transitionEndEvent = {
+    WebkitTransition: "webkitTransitionEnd",
+    transition: "transitionend",
+  }[transitionProperty];
+
+  // cache all vendor properties that could have vendor prefix
+  var vendorProperties = {
+    transform: transformProperty,
+    transition: transitionProperty,
+    transitionDuration: transitionProperty + "Duration",
+    transitionProperty: transitionProperty + "Property",
+    transitionDelay: transitionProperty + "Delay",
+  };
+
+  // -------------------------- Item -------------------------- //
+
+  function Item(element, layout) {
+    if (!element) {
+      return;
+    }
+
+    this.element = element;
+    // parent layout class, i.e. Masonry, Isotope, or Packery
+    this.layout = layout;
+    this.position = {
+      x: 0,
+      y: 0,
+    };
+
+    this._create();
+  }
+
+  // inherit EvEmitter
+  var proto = (Item.prototype = Object.create(EvEmitter.prototype));
+  proto.constructor = Item;
+
+  proto._create = function() {
+    // transition objects
+    this._transn = {
+      ingProperties: {},
+      clean: {},
+      onEnd: {},
+    };
+
+    this.css({
+      position: "absolute",
+    });
+  };
+
+  // trigger specified handler for event type
+  proto.handleEvent = function(event) {
+    var method = "on" + event.type;
+    if (this[method]) {
+      this[method](event);
+    }
+  };
+
+  proto.getSize = function() {
+    this.size = getSize(this.element);
+  };
+
+  /**
+   * apply CSS styles to element
+   * @param {Object} style
+   */
+  proto.css = function(style) {
+    var elemStyle = this.element.style;
+
+    for (var prop in style) {
+      // use vendor property if available
+      var supportedProp = vendorProperties[prop] || prop;
+      elemStyle[supportedProp] = style[prop];
+    }
+  };
+
+  // measure position, and sets it
+  proto.getPosition = function() {
+    var style = getComputedStyle(this.element);
+    var isOriginLeft = this.layout._getOption("originLeft");
+    var isOriginTop = this.layout._getOption("originTop");
+    var xValue = style[isOriginLeft ? "left" : "right"];
+    var yValue = style[isOriginTop ? "top" : "bottom"];
+    var x = parseFloat(xValue);
+    var y = parseFloat(yValue);
+    // convert percent to pixels
+    var layoutSize = this.layout.size;
+    if (xValue.indexOf("%") != -1) {
+      x = (x / 100) * layoutSize.width;
+    }
+    if (yValue.indexOf("%") != -1) {
+      y = (y / 100) * layoutSize.height;
+    }
+    // clean up 'auto' or other non-integer values
+    x = isNaN(x) ? 0 : x;
+    y = isNaN(y) ? 0 : y;
+    // remove padding from measurement
+    x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
+    y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
+
+    this.position.x = x;
+    this.position.y = y;
+  };
+
+  // set settled position, apply padding
+  proto.layoutPosition = function() {
+    var layoutSize = this.layout.size;
+    var style = {};
+    var isOriginLeft = this.layout._getOption("originLeft");
+    var isOriginTop = this.layout._getOption("originTop");
+
+    // x
+    var xPadding = isOriginLeft ? "paddingLeft" : "paddingRight";
+    var xProperty = isOriginLeft ? "left" : "right";
+    var xResetProperty = isOriginLeft ? "right" : "left";
+
+    var x = this.position.x + layoutSize[xPadding];
+    // set in percentage or pixels
+    style[xProperty] = this.getXValue(x);
+    // reset other property
+    style[xResetProperty] = "";
+
+    // y
+    var yPadding = isOriginTop ? "paddingTop" : "paddingBottom";
+    var yProperty = isOriginTop ? "top" : "bottom";
+    var yResetProperty = isOriginTop ? "bottom" : "top";
+
+    var y = this.position.y + layoutSize[yPadding];
+    // set in percentage or pixels
+    style[yProperty] = this.getYValue(y);
+    // reset other property
+    style[yResetProperty] = "";
+
+    this.css(style);
+    this.emitEvent("layout", [this]);
+  };
+
+  proto.getXValue = function(x) {
+    var isHorizontal = this.layout._getOption("horizontal");
+    return this.layout.options.percentPosition && !isHorizontal
+      ? (x / this.layout.size.width) * 100 + "%"
+      : x + "px";
+  };
+
+  proto.getYValue = function(y) {
+    var isHorizontal = this.layout._getOption("horizontal");
+    return this.layout.options.percentPosition && isHorizontal
+      ? (y / this.layout.size.height) * 100 + "%"
+      : y + "px";
+  };
+
+  proto._transitionTo = function(x, y) {
+    this.getPosition();
+    // get current x & y from top/left
+    var curX = this.position.x;
+    var curY = this.position.y;
+
+    var didNotMove = x == this.position.x && y == this.position.y;
+
+    // save end position
+    this.setPosition(x, y);
+
+    // if did not move and not transitioning, just go to layout
+    if (didNotMove && !this.isTransitioning) {
+      this.layoutPosition();
+      return;
+    }
+
+    var transX = x - curX;
+    var transY = y - curY;
+    var transitionStyle = {};
+    transitionStyle.transform = this.getTranslate(transX, transY);
+
+    this.transition({
+      to: transitionStyle,
+      onTransitionEnd: {
+        transform: this.layoutPosition,
+      },
+      isCleaning: true,
+    });
+  };
+
+  proto.getTranslate = function(x, y) {
+    // flip cooridinates if origin on right or bottom
+    var isOriginLeft = this.layout._getOption("originLeft");
+    var isOriginTop = this.layout._getOption("originTop");
+    x = isOriginLeft ? x : -x;
+    y = isOriginTop ? y : -y;
+    return "translate3d(" + x + "px, " + y + "px, 0)";
+  };
+
+  // non transition + transform support
+  proto.goTo = function(x, y) {
+    this.setPosition(x, y);
+    this.layoutPosition();
+  };
+
+  proto.moveTo = proto._transitionTo;
+
+  proto.setPosition = function(x, y) {
+    this.position.x = parseFloat(x);
+    this.position.y = parseFloat(y);
+  };
+
+  // ----- transition ----- //
+
+  /**
+   * @param {Object} style - CSS
+   * @param {Function} onTransitionEnd
+   */
+
+  // non transition, just trigger callback
+  proto._nonTransition = function(args) {
+    this.css(args.to);
+    if (args.isCleaning) {
+      this._removeStyles(args.to);
+    }
+    for (var prop in args.onTransitionEnd) {
+      args.onTransitionEnd[prop].call(this);
+    }
+  };
+
+  /**
+   * proper transition
+   * @param {Object} args - arguments
+   *   @param {Object} to - style to transition to
+   *   @param {Object} from - style to start transition from
+   *   @param {Boolean} isCleaning - removes transition styles after transition
+   *   @param {Function} onTransitionEnd - callback
+   */
+  proto.transition = function(args) {
+    // redirect to nonTransition if no transition duration
+    if (!parseFloat(this.layout.options.transitionDuration)) {
+      this._nonTransition(args);
+      return;
+    }
+
+    var _transition = this._transn;
+    // keep track of onTransitionEnd callback by css property
+    for (var prop in args.onTransitionEnd) {
+      _transition.onEnd[prop] = args.onTransitionEnd[prop];
+    }
+    // keep track of properties that are transitioning
+    for (prop in args.to) {
+      _transition.ingProperties[prop] = true;
+      // keep track of properties to clean up when transition is done
+      if (args.isCleaning) {
+        _transition.clean[prop] = true;
+      }
+    }
+
+    // set from styles
+    if (args.from) {
+      this.css(args.from);
+      // force redraw. http://blog.alexmaccaw.com/css-transitions
+      var h = this.element.offsetHeight;
+      // hack for JSHint to hush about unused var
+      h = null;
+    }
+    // enable transition
+    this.enableTransition(args.to);
+    // set styles that are transitioning
+    this.css(args.to);
+
+    this.isTransitioning = true;
+  };
+
+  // dash before all cap letters, including first for
+  // WebkitTransform => -webkit-transform
+  function toDashedAll(str) {
+    return str.replace(/([A-Z])/g, function($1) {
+      return "-" + $1.toLowerCase();
+    });
+  }
+
+  var transitionProps = "opacity," + toDashedAll(transformProperty);
+
+  proto.enableTransition = function(/* style */) {
+    // HACK changing transitionProperty during a transition
+    // will cause transition to jump
+    if (this.isTransitioning) {
+      return;
+    }
+
+    // make `transition: foo, bar, baz` from style object
+    // HACK un-comment this when enableTransition can work
+    // while a transition is happening
+    // var transitionValues = [];
+    // for ( var prop in style ) {
+    //   // dash-ify camelCased properties like WebkitTransition
+    //   prop = vendorProperties[ prop ] || prop;
+    //   transitionValues.push( toDashedAll( prop ) );
+    // }
+    // munge number to millisecond, to match stagger
+    var duration = this.layout.options.transitionDuration;
+    duration = typeof duration == "number" ? duration + "ms" : duration;
+    // enable transition styles
+    this.css({
+      transitionProperty: transitionProps,
+      transitionDuration: duration,
+      transitionDelay: this.staggerDelay || 0,
+    });
+    // listen for transition end event
+    this.element.addEventListener(transitionEndEvent, this, false);
+  };
+
+  // ----- events ----- //
+
+  proto.onwebkitTransitionEnd = function(event) {
+    this.ontransitionend(event);
+  };
+
+  proto.onotransitionend = function(event) {
+    this.ontransitionend(event);
+  };
+
+  // properties that I munge to make my life easier
+  var dashedVendorProperties = {
+    "-webkit-transform": "transform",
+  };
+
+  proto.ontransitionend = function(event) {
+    // disregard bubbled events from children
+    if (event.target !== this.element) {
+      return;
+    }
+    var _transition = this._transn;
+    // get property name of transitioned property, convert to prefix-free
+    var propertyName =
+      dashedVendorProperties[event.propertyName] || event.propertyName;
+
+    // remove property that has completed transitioning
+    delete _transition.ingProperties[propertyName];
+    // check if any properties are still transitioning
+    if (isEmptyObj(_transition.ingProperties)) {
+      // all properties have completed transitioning
+      this.disableTransition();
+    }
+    // clean style
+    if (propertyName in _transition.clean) {
+      // clean up style
+      this.element.style[event.propertyName] = "";
+      delete _transition.clean[propertyName];
+    }
+    // trigger onTransitionEnd callback
+    if (propertyName in _transition.onEnd) {
+      var onTransitionEnd = _transition.onEnd[propertyName];
+      onTransitionEnd.call(this);
+      delete _transition.onEnd[propertyName];
+    }
+
+    this.emitEvent("transitionEnd", [this]);
+  };
+
+  proto.disableTransition = function() {
+    this.removeTransitionStyles();
+    this.element.removeEventListener(transitionEndEvent, this, false);
+    this.isTransitioning = false;
+  };
+
+  /**
+   * removes style property from element
+   * @param {Object} style
+   **/
+  proto._removeStyles = function(style) {
+    // clean up transition styles
+    var cleanStyle = {};
+    for (var prop in style) {
+      cleanStyle[prop] = "";
+    }
+    this.css(cleanStyle);
+  };
+
+  var cleanTransitionStyle = {
+    transitionProperty: "",
+    transitionDuration: "",
+    transitionDelay: "",
+  };
+
+  proto.removeTransitionStyles = function() {
+    // remove transition
+    this.css(cleanTransitionStyle);
+  };
+
+  // ----- stagger ----- //
+
+  proto.stagger = function(delay) {
+    delay = isNaN(delay) ? 0 : delay;
+    this.staggerDelay = delay + "ms";
+  };
+
+  // ----- show/hide/remove ----- //
+
+  // remove element from DOM
+  proto.removeElem = function() {
+    this.element.parentNode.removeChild(this.element);
+    // remove display: none
+    this.css({ display: "" });
+    this.emitEvent("remove", [this]);
+  };
+
+  proto.remove = function() {
+    // just remove element if no transition support or no transition
+    if (
+      !transitionProperty ||
+      !parseFloat(this.layout.options.transitionDuration)
+    ) {
+      this.removeElem();
+      return;
+    }
+
+    // start transition
+    this.once("transitionEnd", function() {
+      this.removeElem();
+    });
+    this.hide();
+  };
+
+  proto.reveal = function() {
+    delete this.isHidden;
+    // remove display: none
+    this.css({ display: "" });
+
+    var options = this.layout.options;
+
+    var onTransitionEnd = {};
+    var transitionEndProperty = this.getHideRevealTransitionEndProperty(
+      "visibleStyle"
+    );
+    onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;
+
+    this.transition({
+      from: options.hiddenStyle,
+      to: options.visibleStyle,
+      isCleaning: true,
+      onTransitionEnd: onTransitionEnd,
+    });
+  };
+
+  proto.onRevealTransitionEnd = function() {
+    // check if still visible
+    // during transition, item may have been hidden
+    if (!this.isHidden) {
+      this.emitEvent("reveal");
+    }
+  };
+
+  /**
+   * get style property use for hide/reveal transition end
+   * @param {String} styleProperty - hiddenStyle/visibleStyle
+   * @returns {String}
+   */
+  proto.getHideRevealTransitionEndProperty = function(styleProperty) {
+    var optionStyle = this.layout.options[styleProperty];
+    // use opacity
+    if (optionStyle.opacity) {
+      return "opacity";
+    }
+    // get first property
+    for (var prop in optionStyle) {
+      return prop;
+    }
+  };
+
+  proto.hide = function() {
+    // set flag
+    this.isHidden = true;
+    // remove display: none
+    this.css({ display: "" });
+
+    var options = this.layout.options;
+
+    var onTransitionEnd = {};
+    var transitionEndProperty = this.getHideRevealTransitionEndProperty(
+      "hiddenStyle"
+    );
+    onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;
+
+    this.transition({
+      from: options.visibleStyle,
+      to: options.hiddenStyle,
+      // keep hidden stuff hidden
+      isCleaning: true,
+      onTransitionEnd: onTransitionEnd,
+    });
+  };
+
+  proto.onHideTransitionEnd = function() {
+    // check if still hidden
+    // during transition, item may have been un-hidden
+    if (this.isHidden) {
+      this.css({ display: "none" });
+      this.emitEvent("hide");
+    }
+  };
+
+  proto.destroy = function() {
+    this.css({
+      position: "",
+      left: "",
+      right: "",
+      top: "",
+      bottom: "",
+      transition: "",
+      transform: "",
+    });
+  };
+
+  return Item;
+});
+
+/*!
+ * Outlayer v2.1.1
+ * the brains and guts of a layout library
+ * MIT license
+ */
+
+(function(window, factory) {
+  "use strict" /* globals define, module, require */;
+  // universal module definition
+  /* jshint strict: false */ if (typeof define == "function" && define.amd) {
+    // AMD - RequireJS
+    define("outlayer/outlayer", [
+      "ev-emitter/ev-emitter",
+      "get-size/get-size",
+      "fizzy-ui-utils/utils",
+      "./item",
+    ], function(EvEmitter, getSize, utils, Item) {
+      return factory(window, EvEmitter, getSize, utils, Item);
+    });
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS - Browserify, Webpack
+    module.exports = factory(
+      window,
+      require("ev-emitter"),
+      require("get-size"),
+      require("fizzy-ui-utils"),
+      require("./item")
+    );
+  } else {
+    // browser global
+    window.Outlayer = factory(
+      window,
+      window.EvEmitter,
+      window.getSize,
+      window.fizzyUIUtils,
+      window.Outlayer.Item
+    );
+  }
+})(window, function factory(window, EvEmitter, getSize, utils, Item) {
+  "use strict";
+
+  // ----- vars ----- //
+
+  var console = window.console;
+  var jQuery = window.jQuery;
+  var noop = function() {};
+
+  // -------------------------- Outlayer -------------------------- //
+
+  // globally unique identifiers
+  var GUID = 0;
+  // internal store of all Outlayer intances
+  var instances = {};
+
+  /**
+   * @param {Element, String} element
+   * @param {Object} options
+   * @constructor
+   */
+  function Outlayer(element, options) {
+    var queryElement = utils.getQueryElement(element);
+    if (!queryElement) {
+      if (console) {
+        console.error(
+          "Bad element for " +
+            this.constructor.namespace +
+            ": " +
+            (queryElement || element)
+        );
+      }
+      return;
+    }
+    this.element = queryElement;
+    // add jQuery
+    if (jQuery) {
+      this.$element = jQuery(this.element);
+    }
+
+    // options
+    this.options = utils.extend({}, this.constructor.defaults);
+    this.option(options);
+
+    // add id for Outlayer.getFromElement
+    var id = ++GUID;
+    this.element.outlayerGUID = id; // expando
+    instances[id] = this; // associate via id
+
+    // kick it off
+    this._create();
+
+    var isInitLayout = this._getOption("initLayout");
+    if (isInitLayout) {
+      this.layout();
+    }
+  }
+
+  // settings are for internal use only
+  Outlayer.namespace = "outlayer";
+  Outlayer.Item = Item;
+
+  // default options
+  Outlayer.defaults = {
+    containerStyle: {
+      position: "relative",
+    },
+    initLayout: true,
+    originLeft: true,
+    originTop: true,
+    resize: true,
+    resizeContainer: true,
+    // item options
+    transitionDuration: "0.4s",
+    hiddenStyle: {
+      opacity: 0,
+      transform: "scale(0.001)",
+    },
+    visibleStyle: {
+      opacity: 1,
+      transform: "scale(1)",
+    },
+  };
+
+  var proto = Outlayer.prototype;
+  // inherit EvEmitter
+  utils.extend(proto, EvEmitter.prototype);
+
+  /**
+   * set options
+   * @param {Object} opts
+   */
+  proto.option = function(opts) {
+    utils.extend(this.options, opts);
+  };
+
+  /**
+   * get backwards compatible option value, check old name
+   */
+  proto._getOption = function(option) {
+    var oldOption = this.constructor.compatOptions[option];
+    return oldOption && this.options[oldOption] !== undefined
+      ? this.options[oldOption]
+      : this.options[option];
+  };
+
+  Outlayer.compatOptions = {
+    // currentName: oldName
+    initLayout: "isInitLayout",
+    horizontal: "isHorizontal",
+    layoutInstant: "isLayoutInstant",
+    originLeft: "isOriginLeft",
+    originTop: "isOriginTop",
+    resize: "isResizeBound",
+    resizeContainer: "isResizingContainer",
+  };
+
+  proto._create = function() {
+    // get items from children
+    this.reloadItems();
+    // elements that affect layout, but are not laid out
+    this.stamps = [];
+    this.stamp(this.options.stamp);
+    // set container style
+    utils.extend(this.element.style, this.options.containerStyle);
+
+    // bind resize method
+    var canBindResize = this._getOption("resize");
+    if (canBindResize) {
+      this.bindResize();
+    }
+  };
+
+  // goes through all children again and gets bricks in proper order
+  proto.reloadItems = function() {
+    // collection of item elements
+    this.items = this._itemize(this.element.children);
+  };
+
+  /**
+   * turn elements into Outlayer.Items to be used in layout
+   * @param {Array or NodeList or HTMLElement} elems
+   * @returns {Array} items - collection of new Outlayer Items
+   */
+  proto._itemize = function(elems) {
+    var itemElems = this._filterFindItemElements(elems);
+    var Item = this.constructor.Item;
+
+    // create new Outlayer Items for collection
+    var items = [];
+    for (var i = 0; i < itemElems.length; i++) {
+      var elem = itemElems[i];
+      var item = new Item(elem, this);
+      items.push(item);
+    }
+
+    return items;
+  };
+
+  /**
+   * get item elements to be used in layout
+   * @param {Array or NodeList or HTMLElement} elems
+   * @returns {Array} items - item elements
+   */
+  proto._filterFindItemElements = function(elems) {
+    return utils.filterFindElements(elems, this.options.itemSelector);
+  };
+
+  /**
+   * getter method for getting item elements
+   * @returns {Array} elems - collection of item elements
+   */
+  proto.getItemElements = function() {
+    return this.items.map(function(item) {
+      return item.element;
+    });
+  };
+
+  // ----- init & layout ----- //
+
+  /**
+   * lays out all items
+   */
+  proto.layout = function() {
+    this._resetLayout();
+    this._manageStamps();
+
+    // don't animate first layout
+    var layoutInstant = this._getOption("layoutInstant");
+    var isInstant =
+      layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;
+    this.layoutItems(this.items, isInstant);
+
+    // flag for initalized
+    this._isLayoutInited = true;
+  };
+
+  // _init is alias for layout
+  proto._init = proto.layout;
+
+  /**
+   * logic before any new layout
+   */
+  proto._resetLayout = function() {
+    this.getSize();
+  };
+
+  proto.getSize = function() {
+    this.size = getSize(this.element);
+  };
+
+  /**
+   * get measurement from option, for columnWidth, rowHeight, gutter
+   * if option is String -> get element from selector string, & get size of element
+   * if option is Element -> get size of element
+   * else use option as a number
+   *
+   * @param {String} measurement
+   * @param {String} size - width or height
+   * @private
+   */
+  proto._getMeasurement = function(measurement, size) {
+    var option = this.options[measurement];
+    var elem;
+    if (!option) {
+      // default to 0
+      this[measurement] = 0;
+    } else {
+      // use option as an element
+      if (typeof option == "string") {
+        elem = this.element.querySelector(option);
+      } else if (option instanceof HTMLElement) {
+        elem = option;
+      }
+      // use size of element, if element
+      this[measurement] = elem ? getSize(elem)[size] : option;
+    }
+  };
+
+  /**
+   * layout a collection of item elements
+   * @api public
+   */
+  proto.layoutItems = function(items, isInstant) {
+    items = this._getItemsForLayout(items);
+
+    this._layoutItems(items, isInstant);
+
+    this._postLayout();
+  };
+
+  /**
+   * get the items to be laid out
+   * you may want to skip over some items
+   * @param {Array} items
+   * @returns {Array} items
+   */
+  proto._getItemsForLayout = function(items) {
+    return items.filter(function(item) {
+      return !item.isIgnored;
+    });
+  };
+
+  /**
+   * layout items
+   * @param {Array} items
+   * @param {Boolean} isInstant
+   */
+  proto._layoutItems = function(items, isInstant) {
+    this._emitCompleteOnItems("layout", items);
+
+    if (!items || !items.length) {
+      // no items, emit event with empty array
+      return;
+    }
+
+    var queue = [];
+
+    items.forEach(function(item) {
+      // get x/y object from method
+      var position = this._getItemLayoutPosition(item);
+      // enqueue
+      position.item = item;
+      position.isInstant = isInstant || item.isLayoutInstant;
+      queue.push(position);
+    }, this);
+
+    this._processLayoutQueue(queue);
+  };
+
+  /**
+   * get item layout position
+   * @param {Outlayer.Item} item
+   * @returns {Object} x and y position
+   */
+  proto._getItemLayoutPosition = function(/* item */) {
+    return {
+      x: 0,
+      y: 0,
+    };
+  };
+
+  /**
+   * iterate over array and position each item
+   * Reason being - separating this logic prevents 'layout invalidation'
+   * thx @paul_irish
+   * @param {Array} queue
+   */
+  proto._processLayoutQueue = function(queue) {
+    this.updateStagger();
+    queue.forEach(function(obj, i) {
+      this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
+    }, this);
+  };
+
+  // set stagger from option in milliseconds number
+  proto.updateStagger = function() {
+    var stagger = this.options.stagger;
+    if (stagger === null || stagger === undefined) {
+      this.stagger = 0;
+      return;
+    }
+    this.stagger = getMilliseconds(stagger);
+    return this.stagger;
+  };
+
+  /**
+   * Sets position of item in DOM
+   * @param {Outlayer.Item} item
+   * @param {Number} x - horizontal position
+   * @param {Number} y - vertical position
+   * @param {Boolean} isInstant - disables transitions
+   */
+  proto._positionItem = function(item, x, y, isInstant, i) {
+    if (isInstant) {
+      // if not transition, just set CSS
+      item.goTo(x, y);
+    } else {
+      item.stagger(i * this.stagger);
+      item.moveTo(x, y);
+    }
+  };
+
+  /**
+   * Any logic you want to do after each layout,
+   * i.e. size the container
+   */
+  proto._postLayout = function() {
+    this.resizeContainer();
+  };
+
+  proto.resizeContainer = function() {
+    var isResizingContainer = this._getOption("resizeContainer");
+    if (!isResizingContainer) {
+      return;
+    }
+    var size = this._getContainerSize();
+    if (size) {
+      this._setContainerMeasure(size.width, true);
+      this._setContainerMeasure(size.height, false);
+    }
+  };
+
+  /**
+   * Sets width or height of container if returned
+   * @returns {Object} size
+   *   @param {Number} width
+   *   @param {Number} height
+   */
+  proto._getContainerSize = noop;
+
+  /**
+   * @param {Number} measure - size of width or height
+   * @param {Boolean} isWidth
+   */
+  proto._setContainerMeasure = function(measure, isWidth) {
+    if (measure === undefined) {
+      return;
+    }
+
+    var elemSize = this.size;
+    // add padding and border width if border box
+    if (elemSize.isBorderBox) {
+      measure += isWidth
+        ? elemSize.paddingLeft +
+          elemSize.paddingRight +
+          elemSize.borderLeftWidth +
+          elemSize.borderRightWidth
+        : elemSize.paddingBottom +
+          elemSize.paddingTop +
+          elemSize.borderTopWidth +
+          elemSize.borderBottomWidth;
+    }
+
+    measure = Math.max(measure, 0);
+    this.element.style[isWidth ? "width" : "height"] = measure + "px";
+  };
+
+  /**
+   * emit eventComplete on a collection of items events
+   * @param {String} eventName
+   * @param {Array} items - Outlayer.Items
+   */
+  proto._emitCompleteOnItems = function(eventName, items) {
+    var _this = this;
+    function onComplete() {
+      _this.dispatchEvent(eventName + "Complete", null, [items]);
+    }
+
+    var count = items.length;
+    if (!items || !count) {
+      onComplete();
+      return;
+    }
+
+    var doneCount = 0;
+    function tick() {
+      doneCount++;
+      if (doneCount == count) {
+        onComplete();
+      }
+    }
+
+    // bind callback
+    items.forEach(function(item) {
+      item.once(eventName, tick);
+    });
+  };
+
+  /**
+   * emits events via EvEmitter and jQuery events
+   * @param {String} type - name of event
+   * @param {Event} event - original event
+   * @param {Array} args - extra arguments
+   */
+  proto.dispatchEvent = function(type, event, args) {
+    // add original event to arguments
+    var emitArgs = event ? [event].concat(args) : args;
+    this.emitEvent(type, emitArgs);
+
+    if (jQuery) {
+      // set this.$element
+      this.$element = this.$element || jQuery(this.element);
+      if (event) {
+        // create jQuery event
+        var $event = jQuery.Event(event);
+        $event.type = type;
+        this.$element.trigger($event, args);
+      } else {
+        // just trigger with type if no event available
+        this.$element.trigger(type, args);
+      }
+    }
+  };
+
+  // -------------------------- ignore & stamps -------------------------- //
+
+  /**
+   * keep item in collection, but do not lay it out
+   * ignored items do not get skipped in layout
+   * @param {Element} elem
+   */
+  proto.ignore = function(elem) {
+    var item = this.getItem(elem);
+    if (item) {
+      item.isIgnored = true;
+    }
+  };
+
+  /**
+   * return item to layout collection
+   * @param {Element} elem
+   */
+  proto.unignore = function(elem) {
+    var item = this.getItem(elem);
+    if (item) {
+      delete item.isIgnored;
+    }
+  };
+
+  /**
+   * adds elements to stamps
+   * @param {NodeList, Array, Element, or String} elems
+   */
+  proto.stamp = function(elems) {
+    elems = this._find(elems);
+    if (!elems) {
+      return;
+    }
+
+    this.stamps = this.stamps.concat(elems);
+    // ignore
+    elems.forEach(this.ignore, this);
+  };
+
+  /**
+   * removes elements to stamps
+   * @param {NodeList, Array, or Element} elems
+   */
+  proto.unstamp = function(elems) {
+    elems = this._find(elems);
+    if (!elems) {
+      return;
+    }
+
+    elems.forEach(function(elem) {
+      // filter out removed stamp elements
+      utils.removeFrom(this.stamps, elem);
+      this.unignore(elem);
+    }, this);
+  };
+
+  /**
+   * finds child elements
+   * @param {NodeList, Array, Element, or String} elems
+   * @returns {Array} elems
+   */
+  proto._find = function(elems) {
+    if (!elems) {
+      return;
+    }
+    // if string, use argument as selector string
+    if (typeof elems == "string") {
+      elems = this.element.querySelectorAll(elems);
+    }
+    elems = utils.makeArray(elems);
+    return elems;
+  };
+
+  proto._manageStamps = function() {
+    if (!this.stamps || !this.stamps.length) {
+      return;
+    }
+
+    this._getBoundingRect();
+
+    this.stamps.forEach(this._manageStamp, this);
+  };
+
+  // update boundingLeft / Top
+  proto._getBoundingRect = function() {
+    // get bounding rect for container element
+    var boundingRect = this.element.getBoundingClientRect();
+    var size = this.size;
+    this._boundingRect = {
+      left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
+      top: boundingRect.top + size.paddingTop + size.borderTopWidth,
+      right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
+      bottom:
+        boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth),
+    };
+  };
+
+  /**
+   * @param {Element} stamp
+   **/
+  proto._manageStamp = noop;
+
+  /**
+   * get x/y position of element relative to container element
+   * @param {Element} elem
+   * @returns {Object} offset - has left, top, right, bottom
+   */
+  proto._getElementOffset = function(elem) {
+    var boundingRect = elem.getBoundingClientRect();
+    var thisRect = this._boundingRect;
+    var size = getSize(elem);
+    var offset = {
+      left: boundingRect.left - thisRect.left - size.marginLeft,
+      top: boundingRect.top - thisRect.top - size.marginTop,
+      right: thisRect.right - boundingRect.right - size.marginRight,
+      bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom,
+    };
+    return offset;
+  };
+
+  // -------------------------- resize -------------------------- //
+
+  // enable event handlers for listeners
+  // i.e. resize -> onresize
+  proto.handleEvent = utils.handleEvent;
+
+  /**
+   * Bind layout to window resizing
+   */
+  proto.bindResize = function() {
+    window.addEventListener("resize", this);
+    this.isResizeBound = true;
+  };
+
+  /**
+   * Unbind layout to window resizing
+   */
+  proto.unbindResize = function() {
+    window.removeEventListener("resize", this);
+    this.isResizeBound = false;
+  };
+
+  proto.onresize = function() {
+    this.resize();
+  };
+
+  utils.debounceMethod(Outlayer, "onresize", 100);
+
+  proto.resize = function() {
+    // don't trigger if size did not change
+    // or if resize was unbound. See #9
+    if (!this.isResizeBound || !this.needsResizeLayout()) {
+      return;
+    }
+
+    this.layout();
+  };
+
+  /**
+   * check if layout is needed post layout
+   * @returns Boolean
+   */
+  proto.needsResizeLayout = function() {
+    var size = getSize(this.element);
+    // check that this.size and size are there
+    // IE8 triggers resize on body size change, so they might not be
+    var hasSizes = this.size && size;
+    return hasSizes && size.innerWidth !== this.size.innerWidth;
+  };
+
+  // -------------------------- methods -------------------------- //
+
+  /**
+   * add items to Outlayer instance
+   * @param {Array or NodeList or Element} elems
+   * @returns {Array} items - Outlayer.Items
+   **/
+  proto.addItems = function(elems) {
+    var items = this._itemize(elems);
+    // add items to collection
+    if (items.length) {
+      this.items = this.items.concat(items);
+    }
+    return items;
+  };
+
+  /**
+   * Layout newly-appended item elements
+   * @param {Array or NodeList or Element} elems
+   */
+  proto.appended = function(elems) {
+    var items = this.addItems(elems);
+    if (!items.length) {
+      return;
+    }
+    // layout and reveal just the new items
+    this.layoutItems(items, true);
+    this.reveal(items);
+  };
+
+  /**
+   * Layout prepended elements
+   * @param {Array or NodeList or Element} elems
+   */
+  proto.prepended = function(elems) {
+    var items = this._itemize(elems);
+    if (!items.length) {
+      return;
+    }
+    // add items to beginning of collection
+    var previousItems = this.items.slice(0);
+    this.items = items.concat(previousItems);
+    // start new layout
+    this._resetLayout();
+    this._manageStamps();
+    // layout new stuff without transition
+    this.layoutItems(items, true);
+    this.reveal(items);
+    // layout previous items
+    this.layoutItems(previousItems);
+  };
+
+  /**
+   * reveal a collection of items
+   * @param {Array of Outlayer.Items} items
+   */
+  proto.reveal = function(items) {
+    this._emitCompleteOnItems("reveal", items);
+    if (!items || !items.length) {
+      return;
+    }
+    var stagger = this.updateStagger();
+    items.forEach(function(item, i) {
+      item.stagger(i * stagger);
+      item.reveal();
+    });
+  };
+
+  /**
+   * hide a collection of items
+   * @param {Array of Outlayer.Items} items
+   */
+  proto.hide = function(items) {
+    this._emitCompleteOnItems("hide", items);
+    if (!items || !items.length) {
+      return;
+    }
+    var stagger = this.updateStagger();
+    items.forEach(function(item, i) {
+      item.stagger(i * stagger);
+      item.hide();
+    });
+  };
+
+  /**
+   * reveal item elements
+   * @param {Array}, {Element}, {NodeList} items
+   */
+  proto.revealItemElements = function(elems) {
+    var items = this.getItems(elems);
+    this.reveal(items);
+  };
+
+  /**
+   * hide item elements
+   * @param {Array}, {Element}, {NodeList} items
+   */
+  proto.hideItemElements = function(elems) {
+    var items = this.getItems(elems);
+    this.hide(items);
+  };
+
+  /**
+   * get Outlayer.Item, given an Element
+   * @param {Element} elem
+   * @param {Function} callback
+   * @returns {Outlayer.Item} item
+   */
+  proto.getItem = function(elem) {
+    // loop through items to get the one that matches
+    for (var i = 0; i < this.items.length; i++) {
+      var item = this.items[i];
+      if (item.element == elem) {
+        // return item
+        return item;
+      }
+    }
+  };
+
+  /**
+   * get collection of Outlayer.Items, given Elements
+   * @param {Array} elems
+   * @returns {Array} items - Outlayer.Items
+   */
+  proto.getItems = function(elems) {
+    elems = utils.makeArray(elems);
+    var items = [];
+    elems.forEach(function(elem) {
+      var item = this.getItem(elem);
+      if (item) {
+        items.push(item);
+      }
+    }, this);
+
+    return items;
+  };
+
+  /**
+   * remove element(s) from instance and DOM
+   * @param {Array or NodeList or Element} elems
+   */
+  proto.remove = function(elems) {
+    var removeItems = this.getItems(elems);
+
+    this._emitCompleteOnItems("remove", removeItems);
+
+    // bail if no items to remove
+    if (!removeItems || !removeItems.length) {
+      return;
+    }
+
+    removeItems.forEach(function(item) {
+      item.remove();
+      // remove item from collection
+      utils.removeFrom(this.items, item);
+    }, this);
+  };
+
+  // ----- destroy ----- //
+
+  // remove and disable Outlayer instance
+  proto.destroy = function() {
+    // clean up dynamic styles
+    var style = this.element.style;
+    style.height = "";
+    style.position = "";
+    style.width = "";
+    // destroy items
+    this.items.forEach(function(item) {
+      item.destroy();
+    });
+
+    this.unbindResize();
+
+    var id = this.element.outlayerGUID;
+    delete instances[id]; // remove reference to instance by id
+    delete this.element.outlayerGUID;
+    // remove data for jQuery
+    if (jQuery) {
+      jQuery.removeData(this.element, this.constructor.namespace);
+    }
+  };
+
+  // -------------------------- data -------------------------- //
+
+  /**
+   * get Outlayer instance from element
+   * @param {Element} elem
+   * @returns {Outlayer}
+   */
+  Outlayer.data = function(elem) {
+    elem = utils.getQueryElement(elem);
+    var id = elem && elem.outlayerGUID;
+    return id && instances[id];
+  };
+
+  // -------------------------- create Outlayer class -------------------------- //
+
+  /**
+   * create a layout class
+   * @param {String} namespace
+   */
+  Outlayer.create = function(namespace, options) {
+    // sub-class Outlayer
+    var Layout = subclass(Outlayer);
+    // apply new options and compatOptions
+    Layout.defaults = utils.extend({}, Outlayer.defaults);
+    utils.extend(Layout.defaults, options);
+    Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);
+
+    Layout.namespace = namespace;
+
+    Layout.data = Outlayer.data;
+
+    // sub-class Item
+    Layout.Item = subclass(Item);
+
+    // -------------------------- declarative -------------------------- //
+
+    utils.htmlInit(Layout, namespace);
+
+    // -------------------------- jQuery bridge -------------------------- //
+
+    // make into jQuery plugin
+    if (jQuery && jQuery.bridget) {
+      jQuery.bridget(namespace, Layout);
+    }
+
+    return Layout;
+  };
+
+  function subclass(Parent) {
+    function SubClass() {
+      Parent.apply(this, arguments);
+    }
+
+    SubClass.prototype = Object.create(Parent.prototype);
+    SubClass.prototype.constructor = SubClass;
+
+    return SubClass;
+  }
+
+  // ----- helpers ----- //
+
+  // how many milliseconds are in each unit
+  var msUnits = {
+    ms: 1,
+    s: 1000,
+  };
+
+  // munge time-like parameter into millisecond number
+  // '0.4s' -> 40
+  function getMilliseconds(time) {
+    if (typeof time == "number") {
+      return time;
+    }
+    var matches = time.match(/(^\d*\.?\d*)(\w*)/);
+    var num = matches && matches[1];
+    var unit = matches && matches[2];
+    if (!num.length) {
+      return 0;
+    }
+    num = parseFloat(num);
+    var mult = msUnits[unit] || 1;
+    return num * mult;
+  }
+
+  // ----- fin ----- //
+
+  // back in global
+  Outlayer.Item = Item;
+
+  return Outlayer;
+});
+
+/*!
+ * Masonry v4.2.2
+ * Cascading grid layout library
+ * https://masonry.desandro.com
+ * MIT License
+ * by David DeSandro
+ */
+
+(function(window, factory) {
+  // universal module definition
+  /* jshint strict: false */ /*globals define, module, require */
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define(["outlayer/outlayer", "get-size/get-size"], factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory(require("outlayer"), require("get-size"));
+  } else {
+    // browser global
+    window.Masonry = factory(window.Outlayer, window.getSize);
+  }
+})(window, function factory(Outlayer, getSize) {
+  // -------------------------- masonryDefinition -------------------------- //
+
+  // create an Outlayer layout class
+  var Masonry = Outlayer.create("masonry");
+  // isFitWidth -> fitWidth
+  Masonry.compatOptions.fitWidth = "isFitWidth";
+
+  var proto = Masonry.prototype;
+
+  proto._resetLayout = function() {
+    this.getSize();
+    this._getMeasurement("columnWidth", "outerWidth");
+    this._getMeasurement("gutter", "outerWidth");
+    this.measureColumns();
+
+    // reset column Y
+    this.colYs = [];
+    for (var i = 0; i < this.cols; i++) {
+      this.colYs.push(0);
+    }
+
+    this.maxY = 0;
+    this.horizontalColIndex = 0;
+  };
+
+  proto.measureColumns = function() {
+    this.getContainerWidth();
+    // if columnWidth is 0, default to outerWidth of first item
+    if (!this.columnWidth) {
+      var firstItem = this.items[0];
+      var firstItemElem = firstItem && firstItem.element;
+      // columnWidth fall back to item of first element
+      this.columnWidth =
+        (firstItemElem && getSize(firstItemElem).outerWidth) ||
+        // if first elem has no width, default to size of container
+        this.containerWidth;
+    }
+
+    var columnWidth = (this.columnWidth += this.gutter);
+
+    // calculate columns
+    var containerWidth = this.containerWidth + this.gutter;
+    var cols = containerWidth / columnWidth;
+    // fix rounding errors, typically with gutters
+    var excess = columnWidth - (containerWidth % columnWidth);
+    // if overshoot is less than a pixel, round up, otherwise floor it
+    var mathMethod = excess && excess < 1 ? "round" : "floor";
+    cols = Math[mathMethod](cols);
+    this.cols = Math.max(cols, 1);
+  };
+
+  proto.getContainerWidth = function() {
+    // container is parent if fit width
+    var isFitWidth = this._getOption("fitWidth");
+    var container = isFitWidth ? this.element.parentNode : this.element;
+    // check that this.size and size are there
+    // IE8 triggers resize on body size change, so they might not be
+    var size = getSize(container);
+    this.containerWidth = size && size.innerWidth;
+  };
+
+  proto._getItemLayoutPosition = function(item) {
+    item.getSize();
+    // how many columns does this brick span
+    var remainder = item.size.outerWidth % this.columnWidth;
+    var mathMethod = remainder && remainder < 1 ? "round" : "ceil";
+    // round if off by 1 pixel, otherwise use ceil
+    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
+    colSpan = Math.min(colSpan, this.cols);
+    // use horizontal or top column position
+    var colPosMethod = this.options.horizontalOrder
+      ? "_getHorizontalColPosition"
+      : "_getTopColPosition";
+    var colPosition = this[colPosMethod](colSpan, item);
+    // position the brick
+    var position = {
+      x: this.columnWidth * colPosition.col,
+      y: colPosition.y,
+    };
+    // apply setHeight to necessary columns
+    var setHeight = colPosition.y + item.size.outerHeight;
+    var setMax = colSpan + colPosition.col;
+    for (var i = colPosition.col; i < setMax; i++) {
+      this.colYs[i] = setHeight;
+    }
+
+    return position;
+  };
+
+  proto._getTopColPosition = function(colSpan) {
+    var colGroup = this._getTopColGroup(colSpan);
+    // get the minimum Y value from the columns
+    var minimumY = Math.min.apply(Math, colGroup);
+
+    return {
+      col: colGroup.indexOf(minimumY),
+      y: minimumY,
+    };
+  };
+
+  /**
+   * @param {Number} colSpan - number of columns the element spans
+   * @returns {Array} colGroup
+   */
+  proto._getTopColGroup = function(colSpan) {
+    if (colSpan < 2) {
+      // if brick spans only one column, use all the column Ys
+      return this.colYs;
+    }
+
+    var colGroup = [];
+    // how many different places could this brick fit horizontally
+    var groupCount = this.cols + 1 - colSpan;
+    // for each group potential horizontal position
+    for (var i = 0; i < groupCount; i++) {
+      colGroup[i] = this._getColGroupY(i, colSpan);
+    }
+    return colGroup;
+  };
+
+  proto._getColGroupY = function(col, colSpan) {
+    if (colSpan < 2) {
+      return this.colYs[col];
+    }
+    // make an array of colY values for that one group
+    var groupColYs = this.colYs.slice(col, col + colSpan);
+    // and get the max value of the array
+    return Math.max.apply(Math, groupColYs);
+  };
+
+  // get column position based on horizontal index. #873
+  proto._getHorizontalColPosition = function(colSpan, item) {
+    var col = this.horizontalColIndex % this.cols;
+    var isOver = colSpan > 1 && col + colSpan > this.cols;
+    // shift to next row if item can't fit on current row
+    col = isOver ? 0 : col;
+    // don't let zero-size items take up space
+    var hasSize = item.size.outerWidth && item.size.outerHeight;
+    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;
+
+    return {
+      col: col,
+      y: this._getColGroupY(col, colSpan),
+    };
+  };
+
+  proto._manageStamp = function(stamp) {
+    var stampSize = getSize(stamp);
+    var offset = this._getElementOffset(stamp);
+    // get the columns that this stamp affects
+    var isOriginLeft = this._getOption("originLeft");
+    var firstX = isOriginLeft ? offset.left : offset.right;
+    var lastX = firstX + stampSize.outerWidth;
+    var firstCol = Math.floor(firstX / this.columnWidth);
+    firstCol = Math.max(0, firstCol);
+    var lastCol = Math.floor(lastX / this.columnWidth);
+    // lastCol should not go over if multiple of columnWidth #425
+    lastCol -= lastX % this.columnWidth ? 0 : 1;
+    lastCol = Math.min(this.cols - 1, lastCol);
+    // set colYs to bottom of the stamp
+
+    var isOriginTop = this._getOption("originTop");
+    var stampMaxY =
+      (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
+    for (var i = firstCol; i <= lastCol; i++) {
+      this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
+    }
+  };
+
+  proto._getContainerSize = function() {
+    this.maxY = Math.max.apply(Math, this.colYs);
+    var size = {
+      height: this.maxY,
+    };
+
+    if (this._getOption("fitWidth")) {
+      size.width = this._getContainerFitWidth();
+    }
+
+    return size;
+  };
+
+  proto._getContainerFitWidth = function() {
+    var unusedCols = 0;
+    // count unused columns
+    var i = this.cols;
+    while (--i) {
+      if (this.colYs[i] !== 0) {
+        break;
+      }
+      unusedCols++;
+    }
+    // fit container to columns that have been used
+    return (this.cols - unusedCols) * this.columnWidth - this.gutter;
+  };
+
+  proto.needsResizeLayout = function() {
+    var previousWidth = this.containerWidth;
+    this.getContainerWidth();
+    return previousWidth != this.containerWidth;
+  };
+
+  return Masonry;
+});
+
+window.addEventListener("DOMContentLoaded", function() {
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserContentLoaded", { bubbles: true })
+  );
+});
+
+document.querySelector("#close").addEventListener("click", () => {
+  console.log("DISPATCH");
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserClose", { bubbles: true })
+  );
+});
+
+window.addEventListener("SecondaryBrowserChromeToContent", event => {
+  console.log("SecondaryBrowserChromeToContent", event.detail);
+  switch (event.detail.messageType) {
+    case "TrackedImages": {
+      let grid = document.querySelector("#grid");
+      grid.innerHTML = "";
+      let images = event.detail.value;
+      for (let image of images) {
+        let item = document.createElement("div");
+        item.classList.add("grid-item");
+        let img = document.createElement("img");
+        img.src = image.finalURI;
+        item.append(img);
+        grid.append(item);
+      }
+
+      // var msnry = new Masonry(grid, {
+      //   // options
+      //   itemSelector: ".grid-item",
+      //   columnWidth: 200,
+      // });
+      // msnry.imagesLoaded().progress(function() {
+      //   msnry.masonry("layout");
+      // });
+
+      break;
+    }
+  }
+});
diff --git a/browser/components/secondarybrowser/moz.build b/browser/components/secondarybrowser/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/moz.build
@@ -0,0 +1,15 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ['content/jar.mn']
+
+#EXTRA_JS_MODULES += [
+#]
+
+FINAL_TARGET_FILES.actors += [
+    'SecondaryBrowserChild.jsm',
+    'SecondaryBrowserParent.jsm',
+]
diff --git a/browser/modules/ReaderParent.jsm b/browser/modules/ReaderParent.jsm
--- a/browser/modules/ReaderParent.jsm
+++ b/browser/modules/ReaderParent.jsm
@@ -70,37 +70,59 @@ var ReaderParent = {
   },
 
   updateReaderButton(browser) {
     let win = browser.ownerGlobal;
     if (browser != win.gBrowser.selectedBrowser) {
       return;
     }
 
+    let secondaryBrowserButton = win.document.getElementById(
+      "secondary-browser-button"
+    );
     let button = win.document.getElementById("reader-mode-button");
     let menuitem = win.document.getElementById("menu_readerModeItem");
     let key = win.document.getElementById("key_toggleReaderMode");
+
+    if (browser.secondaryBrowser) {
+      secondaryBrowserButton.setAttribute("readeractive", true);
+    } else {
+      secondaryBrowserButton.removeAttribute("readeractive");
+    }
+
     if (browser.currentURI.spec.startsWith("about:reader")) {
       let closeText = gStringBundle.GetStringFromName("readerView.close");
 
+      // if (browser.parentNode.querySelector(".secondarybrowser-reader")) {
+      //   browser.parentNode
+      //     .querySelector(".secondarybrowser-reader")
+      //     .setAttribute("active", "true");
+      // }
+
       button.setAttribute("readeractive", true);
       button.hidden = false;
       button.setAttribute("aria-label", closeText);
 
       menuitem.setAttribute("label", closeText);
       menuitem.setAttribute("hidden", false);
       menuitem.setAttribute(
         "accesskey",
         gStringBundle.GetStringFromName("readerView.close.accesskey")
       );
 
       key.setAttribute("disabled", false);
 
       Services.obs.notifyObservers(null, "reader-mode-available");
     } else {
+      // if (browser.parentNode.querySelector(".secondarybrowser-reader")) {
+      //   browser.parentNode
+      //     .querySelector(".secondarybrowser-reader")
+      //     .removeAttribute("active");
+      // }
+
       let enterText = gStringBundle.GetStringFromName("readerView.enter");
 
       button.removeAttribute("readeractive");
       button.hidden = !browser.isArticle;
       button.setAttribute("aria-label", enterText);
 
       menuitem.setAttribute("label", enterText);
       menuitem.setAttribute("hidden", !browser.isArticle);
@@ -117,16 +139,62 @@ var ReaderParent = {
     }
   },
 
   forceShowReaderIcon(browser) {
     browser.isArticle = true;
     this.updateReaderButton(browser);
   },
 
+  toggleSecondaryBrowser(event) {
+    let win = event.target.ownerGlobal;
+    let gBrowser = win.gBrowser;
+    let browser = gBrowser.selectedBrowser;
+
+    let stack = browser.parentNode;
+    let closeSecondaryBrowser = () => {
+      stack.removeAttribute("secondarybrowser");
+      if (browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.destroySecondaryBrowser();
+      }
+      for (let active of stack.querySelectorAll(
+        ".secondarybrowser-controls toolbarbutton[active]"
+      )) {
+        active.removeAttribute("active");
+      }
+    };
+    browser.closeSecondaryBrowser = closeSecondaryBrowser;
+
+    let openSecondaryBrowser = () => {
+      if (!browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.before(browser.createSecondaryBrowser());
+      }
+      if (!stack.hasAttribute("secondarybrowser")) {
+        stack.setAttribute("secondarybrowser", "overlay");
+      }
+    };
+    browser.openSecondaryBrowser = openSecondaryBrowser;
+    if (browser.secondaryBrowser) {
+      closeSecondaryBrowser();
+    } else {
+      openSecondaryBrowser();
+    }
+    this.updateReaderButton(browser);
+  },
+
+  secondaryBrowserButtonClick(event) {
+    if (event.button != 0) {
+      return;
+    }
+
+    this.toggleSecondaryBrowser(event);
+  },
+
   buttonClick(event) {
     if (event.button != 0) {
       return;
     }
     this.toggleReaderMode(event);
   },
 
   toggleReaderMode(event) {
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -782,16 +782,23 @@
   mask-image: linear-gradient(to right, transparent, black 3ch);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input {
   mask-position-x: calc(var(--cfr-label-width) * -1);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input:-moz-locale-dir(rtl) {
   mask-position-x: calc(var(--cfr-label-width));
 }
+#secondary-browser-button {
+  list-style-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+#secondary-browser-button[readeractive] {
+  background: var(--toolbarbutton-icon-fill-attention);
+  background: rgb(159, 200, 213);
+}
 
 /* Reader mode icon */
 
 #reader-mode-button {
   list-style-image: url(chrome://browser/skin/readerMode.svg);
 }
 
 #reader-mode-button[readeractive] {
diff --git a/toolkit/actors/SelectParent.jsm b/toolkit/actors/SelectParent.jsm
--- a/toolkit/actors/SelectParent.jsm
+++ b/toolkit/actors/SelectParent.jsm
@@ -549,23 +549,26 @@ var SelectParentHelper = {
         }
       }
     }
 
     if (parentElement && ariaOwns) {
       parentElement.setAttribute("aria-owns", ariaOwns);
     }
 
+    // XXX: Pass in whether we are opening for a secondary browser. In the meantime
+    // we'll just enable search everywhere.add-a-comment
     // Check if search pref is enabled, if this is the first time iterating through
     // the dropdown, and if the list is long enough for a search element to be added.
-    if (
-      Services.prefs.getBoolPref("dom.forms.selectSearch") &&
-      addSearch &&
-      element.childElementCount > SEARCH_MINIMUM_ELEMENTS
-    ) {
+    if (true) {
+      // if (
+      //   Services.prefs.getBoolPref("dom.forms.selectSearch") &&
+      //   addSearch &&
+      //   element.childElementCount > SEARCH_MINIMUM_ELEMENTS
+      // ) {
       // Add a search text field as the first element of the dropdown
       let searchbox = element.ownerDocument.createXULElement("search-textbox");
       searchbox.className = "contentSelectDropdown-searchbox";
       searchbox.addEventListener("input", this.onSearchInput);
       searchbox.addEventListener("focus", this.onSearchFocus.bind(this));
       searchbox.addEventListener("blur", this.onSearchBlur);
       searchbox.addEventListener("command", this.onSearchInput);
 
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -449,18 +449,78 @@
         if (this.isRemoteBrowser) {
           this._documentContentType = aContentType;
         } else {
           this.contentDocument.documentContentType = aContentType;
         }
       }
     }
 
+    createSecondaryBrowser() {
+      if (!this.secondaryBrowser) {
+        this.secondaryBrowser = document.createXULElement("browser");
+        this.secondaryBrowser.classList.add("secondarybrowser");
+        this.secondaryBrowser.setAttribute("disablehistory", "true");
+        this.secondaryBrowser.setAttribute("nodefaultsrc", "true");
+        this.secondaryBrowser.setAttribute(
+          "remoteType",
+          this.getAttribute("remoteType")
+        );
+        this.secondaryBrowser.setAttribute(
+          "remote",
+          this.getAttribute("remote")
+        );
+        this.secondaryBrowser.setAttribute("type", "content");
+        this.secondaryBrowser.setAttribute(
+          "contextmenu",
+          this.getAttribute("contextmenu")
+        );
+        this.secondaryBrowser.setAttribute(
+          "datetimepicker",
+          this.getAttribute("datetimepicker")
+        );
+        this.secondaryBrowser.setAttribute(
+          "selectmenulist",
+          this.getAttribute("selectmenulist")
+        );
+        this.secondaryBrowser.setAttribute(
+          "tooltip",
+          this.getAttribute("tooltip")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autocompletepopup",
+          this.getAttribute("autocompletepopup")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autoscrollpopup",
+          this.getAttribute("autoscrollpopup")
+        );
+        this.secondaryBrowser.setAttribute("message", "true");
+        this.secondaryBrowser.setAttribute(
+          "messagemanagergroup",
+          "secondarybrowsers"
+        );
+
+        this.secondaryBrowser.sameProcessAsFrameLoader = this.frameLoader;
+        this.secondaryBrowser.hostBrowser = this;
+        this.secondaryBrowser.src = "chrome://browser/content/secondarybrowser/secondaryui.html";
+        // XXX if we load "about:secondarybrowser" we get
+        // Security Error: Content at about:secondarybrowser may not load or link to chrome://mozapps/content/extensions/aboutaddons.css.
+
+      }
+      return this.secondaryBrowser;
+    }
+
     set sameProcessAsFrameLoader(val) {
       this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+      if (this.secondaryBrowser) {
+        this.secondaryBrowser.sameProcessAsFrameLoader = Cu.getWeakReference(
+          val
+        );
+      }
     }
 
     get sameProcessAsFrameLoader() {
       return (
         this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get()
       );
     }
 
@@ -1275,25 +1335,41 @@
         // our RemoteWebProgress or its associated manager, but we'll need to
         // add the progress listeners to the new non-remote WebProgress.
         this._remoteWebProgressManager = null;
         this._remoteWebProgress = null;
         this.restoreProgressListeners();
 
         this.addEventListener("pagehide", this.onPageHide, true);
       }
+
+      if (this.hadsecondaryBrowser) {
+        this.hadsecondaryBrowser = false;
+        this.before(this.createSecondaryBrowser());
+      }
     }
 
+    destroySecondaryBrowser() {
+      if (this.secondaryBrowser) {
+        this.hadsecondaryBrowser = true;
+        this.secondaryBrowser.remove();
+        this.secondaryBrowser = null;
+      }
+    }
     /**
      * This is necessary because the destructor doesn't always get called when
      * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
      */
     destroy() {
       elementsToDestroyOnUnload.delete(this);
 
+      // Just remove the secondarybrowser browser entirely and let it get recreated
+      // when we are re-added (i.e. with a remoteness change)
+      this.destroySecondaryBrowser();
+
       // Make sure that any open select is closed.
       if (this.hasAttribute("selectmenulist")) {
         let menulist = document.getElementById(
           this.getAttribute("selectmenulist")
         );
         if (menulist && menulist.open) {
           let resourcePath = "resource://gre/actors/SelectParent.jsm";
           let { SelectParentHelper } = ChromeUtils.import(resourcePath);
@@ -1979,17 +2055,23 @@
 
       function sendToChildren(browsingContext, childScope) {
         let windowGlobal = browsingContext.currentWindowGlobal;
         // If 'roots' is set, only send if windowGlobal.isProcessRoot is true.
         if (
           windowGlobal &&
           (childScope != "roots" || windowGlobal.isProcessRoot)
         ) {
-          windowGlobal.getActor(actorName).sendAsyncMessage(messageName, args);
+          try {
+            windowGlobal
+              .getActor(actorName)
+              .sendAsyncMessage(messageName, args);
+          } catch (e) {
+            console.log(actorName, messageName, e);
+          }
         }
 
         // Iterate as long as scope in assigned. Note that we use the original
         // passed in scope, not childScope here.
         if (scope) {
           for (let context of browsingContext.children) {
             sendToChildren(context, scope);
           }
diff --git a/toolkit/modules/ActorManagerParent.jsm b/toolkit/modules/ActorManagerParent.jsm
--- a/toolkit/modules/ActorManagerParent.jsm
+++ b/toolkit/modules/ActorManagerParent.jsm
@@ -178,17 +178,17 @@ let ACTORS = {
     child: {
       moduleURI: "resource://gre/actors/FindBarChild.jsm",
       events: {
         keypress: { mozSystemGroup: true },
       },
     },
 
     allFrames: true,
-    messageManagerGroups: ["browsers", "test"],
+    messageManagerGroups: ["browsers", "test", "secondarybrowsers"],
   },
 
   // This is the actor that responds to requests from the find toolbar and
   // searches for matches and highlights them.
   Finder: {
     child: {
       moduleURI: "resource://gre/actors/FinderChild.jsm",
     },
