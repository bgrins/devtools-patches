# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  03dbf81208ba10eda2da3ac67b9eda4a4151f5c1

diff --git a/accessible/interfaces/nsIAccessible.idl b/accessible/interfaces/nsIAccessible.idl
--- a/accessible/interfaces/nsIAccessible.idl
+++ b/accessible/interfaces/nsIAccessible.idl
@@ -80,16 +80,21 @@ interface nsIAccessible : nsISupports
   readonly attribute Node DOMNode;
 
   /**
     * For remote accessibles the id of the related DOM node.
     */
   readonly attribute AString id;
 
   /**
+    *
+    */
+  readonly attribute uint64_t uniqueID;
+
+  /**
    * The document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument document;
 
   /**
    * The root document accessible that this access node resides in.
    */
   readonly attribute nsIAccessibleDocument rootDocument;
diff --git a/accessible/xpcom/xpcAccessible.cpp b/accessible/xpcom/xpcAccessible.cpp
--- a/accessible/xpcom/xpcAccessible.cpp
+++ b/accessible/xpcom/xpcAccessible.cpp
@@ -92,16 +92,28 @@ xpcAccessible::GetLastChild(nsIAccessibl
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   NS_IF_ADDREF(*aLastChild = ToXPC(IntlGeneric().LastChild()));
   return NS_OK;
 }
 
 NS_IMETHODIMP
+xpcAccessible::GetUniqueID(uint64_t* aUniqueID) {
+  NS_ENSURE_ARG_POINTER(aUniqueID);
+
+  if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
+
+  void* uniqueID = static_cast<void*>(this);
+  *aUniqueID = reinterpret_cast<uint64_t>(uniqueID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 xpcAccessible::GetChildCount(int32_t* aChildCount) {
   NS_ENSURE_ARG_POINTER(aChildCount);
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   *aChildCount = IntlGeneric().ChildCount();
   return NS_OK;
 }
diff --git a/accessible/xpcom/xpcAccessible.h b/accessible/xpcom/xpcAccessible.h
--- a/accessible/xpcom/xpcAccessible.h
+++ b/accessible/xpcom/xpcAccessible.h
@@ -25,16 +25,17 @@ class xpcAccessible : public nsIAccessib
  public:
   // nsIAccessible
   NS_IMETHOD GetParent(nsIAccessible** aParent) final;
   NS_IMETHOD GetNextSibling(nsIAccessible** aNextSibling) final;
   NS_IMETHOD GetPreviousSibling(nsIAccessible** aPreviousSibling) final;
   NS_IMETHOD GetFirstChild(nsIAccessible** aFirstChild) final;
   NS_IMETHOD GetLastChild(nsIAccessible** aLastChild) final;
   NS_IMETHOD GetChildCount(int32_t* aChildCount) final;
+  NS_IMETHOD GetUniqueID(uint64_t* aUniqueID) final;
   NS_IMETHOD GetChildAt(int32_t aChildIndex, nsIAccessible** aChild) final;
   NS_IMETHOD GetChildren(nsIArray** aChildren) final;
   NS_IMETHOD GetIndexInParent(int32_t* aIndexInParent) final;
 
   NS_IMETHOD GetDOMNode(nsINode** aDOMNode) final;
   NS_IMETHOD GetId(nsAString& aID) final;
   NS_IMETHOD GetDocument(nsIAccessibleDocument** aDocument) final;
   NS_IMETHOD GetRootDocument(nsIAccessibleDocument** aRootDocument) final;
diff --git a/browser/actors/BrowserTabParent.jsm b/browser/actors/BrowserTabParent.jsm
--- a/browser/actors/BrowserTabParent.jsm
+++ b/browser/actors/BrowserTabParent.jsm
@@ -11,16 +11,20 @@ class BrowserTabParent extends JSWindowA
     if (!browser) {
       return; // Can happen sometimes if browser is being destroyed
     }
 
     if (browser.outerBrowser) {
       browser = browser.outerBrowser; // handle RDM mode
     }
 
+    if (browser.hostBrowser) {
+      return;
+    }
+
     let gBrowser = browser.ownerGlobal.gBrowser;
 
     if (!gBrowser) {
       // Note: gBrowser might be null because this message might be received
       // from the extension process. There's still an embedderElement involved,
       // but it's the one coming from dummy.xul.
       // This should probably be fixed by adding support to specifying "group: 'browsers"
       // in the registerWindowActor options/. See bug 1557118.
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,76 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  /* margin-inline-start: 32px;
+  width: calc(100% - 32px); */
+}
+.browserStack:not([secondarybrowser]) > .secondarybrowser {
+  display: none;
+}
+/* 
+.browserStack > .secondarybrowser-controls {
+  justify-self: start;
+  width: 32px;
+  background: rgba(255, 255, 255, .8);
+}
+
+.browserStack > .secondarybrowser-controls > toolbarbutton {
+  width: 32px;
+  height: 32px;
+}
+.browserStack > .secondarybrowser-controls > toolbarbutton:hover,
+.browserStack > .secondarybrowser-controls > toolbarbutton[active] {
+  background-color: hsla(240,5%,5%,.1);
+} */
+
+  /* icons grabbed from https://www.iconfinder.com/iconsets/material-core */
+.secondarybrowser-on {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-split {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxNnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAxNiIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01MDYuMDAwMDAwLCAtMTMwLjAwMDAwMCkiPjxnIGlkPSJkcmF3ZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwNi4wMDAwMDAsIDEzMC4wMDAwMDApIj48cGF0aCBkPSJNMTgsMCBMMiwwIEMwLjgsMCAwLDAuOCAwLDIgTDAsMTQgQzAsMTUuMiAwLjgsMTYgMiwxNiBMMTgsMTYgQzE5LDE2IDIwLDE1LjIgMjAsMTQgTDIwLDIgQzIwLDAuOCAxOSwwIDE4LDAgTDE4LDAgWiBNMTgsMTQgTDEyLDE0IEwxMiwyIEwxOCwyIEwxOCwxNCBMMTgsMTQgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-off {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAyMCIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTYuMDAwMDAwLCAtMjk2LjAwMDAwMCkiPjxnIGlkPSJsYW5ndWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk2LjAwMDAwMCwgMjk2LjAwMDAwMCkiPjxwYXRoIGQ9Ik0xMCwwIEM0LjUsMCAwLDQuNSAwLDEwIEMwLDE1LjUgNC41LDIwIDEwLDIwIEMxNS41LDIwIDIwLDE1LjUgMjAsMTAgQzIwLDQuNSAxNS41LDAgMTAsMCBMMTAsMCBaIE0xNi45LDYgTDE0LDYgQzEzLjcsNC43IDEzLjIsMy42IDEyLjYsMi40IEMxNC40LDMuMSAxNiw0LjMgMTYuOSw2IEwxNi45LDYgWiBNMTAsMiBDMTAuOCwzLjIgMTEuNSw0LjUgMTEuOSw2IEw4LjEsNiBDOC41LDQuNiA5LjIsMy4yIDEwLDIgTDEwLDIgWiBNMi4zLDEyIEMyLjEsMTEuNCAyLDEwLjcgMiwxMCBDMiw5LjMgMi4xLDguNiAyLjMsOCBMNS43LDggQzUuNiw4LjcgNS42LDkuMyA1LjYsMTAgQzUuNiwxMC43IDUuNywxMS4zIDUuNywxMiBMMi4zLDEyIEwyLjMsMTIgWiBNMy4xLDE0IEw2LDE0IEM2LjMsMTUuMyA2LjgsMTYuNCA3LjQsMTcuNiBDNS42LDE2LjkgNCwxNS43IDMuMSwxNCBMMy4xLDE0IFogTTYsNiBMMy4xLDYgQzQuMSw0LjMgNS42LDMuMSA3LjQsMi40IEM2LjgsMy42IDYuMyw0LjcgNiw2IEw2LDYgWiBNMTAsMTggQzkuMiwxNi44IDguNSwxNS41IDguMSwxNCBMMTEuOSwxNCBDMTEuNSwxNS40IDEwLjgsMTYuOCAxMCwxOCBMMTAsMTggWiBNMTIuMywxMiBMNy43LDEyIEM3LjYsMTEuMyA3LjUsMTAuNyA3LjUsMTAgQzcuNSw5LjMgNy42LDguNyA3LjcsOCBMMTIuNCw4IEMxMi41LDguNyAxMi42LDkuMyAxMi42LDEwIEMxMi42LDEwLjcgMTIuNCwxMS4zIDEyLjMsMTIgTDEyLjMsMTIgWiBNMTIuNiwxNy42IEMxMy4yLDE2LjUgMTMuNywxNS4zIDE0LDE0IEwxNi45LDE0IEMxNiwxNS43IDE0LjQsMTYuOSAxMi42LDE3LjYgTDEyLjYsMTcuNiBaIE0xNC40LDEyIEMxNC41LDExLjMgMTQuNSwxMC43IDE0LjUsMTAgQzE0LjUsOS4zIDE0LjQsOC43IDE0LjQsOCBMMTcuOCw4IEMxOCw4LjYgMTguMSw5LjMgMTguMSwxMCBDMTguMSwxMC43IDE4LDExLjQgMTcuOCwxMiBMMTQuNCwxMiBMMTQuNCwxMiBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-media {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxOHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxOCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzEuMDAwMDAwLCAtMTcxLjAwMDAwMCkiPjxnIGlkPSJkcml2ZS1pbWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTcxLjAwMDAwMCkiPjxwYXRoIGQ9Ik0xOCwxNiBMMTgsMiBDMTgsMC45IDE3LjEsMCAxNiwwIEwyLDAgQzAuOSwwIDAsMC45IDAsMiBMMCwxNiBDMCwxNy4xIDAuOSwxOCAyLDE4IEwxNiwxOCBDMTcuMSwxOCAxOCwxNy4xIDE4LDE2IEwxOCwxNiBaIE01LjUsMTAuNSBMOCwxMy41IEwxMS41LDkgTDE2LDE1IEwyLDE1IEw1LjUsMTAuNSBMNS41LDEwLjUgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-outline {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00MjMuMDAwMDAwLCAtMzAxLjAwMDAwMCkiPjxnIGlkPSJsaXN0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjMuMDAwMDAwLCAzMDEuMDAwMDAwKSI+PHBhdGggZD0iTTAsNiBMMiw2IEwyLDQgTDAsNCBMMCw2IEwwLDYgWiBNMCwxMCBMMiwxMCBMMiw4IEwwLDggTDAsMTAgTDAsMTAgWiBNMCwyIEwyLDIgTDIsMCBMMCwwIEwwLDIgTDAsMiBaIE00LDYgTDE4LDYgTDE4LDQgTDQsNCBMNCw2IEw0LDYgWiBNNCwxMCBMMTgsMTAgTDE4LDggTDQsOCBMNCwxMCBMNCwxMCBaIE00LDAgTDQsMiBMMTgsMiBMMTgsMCBMNCwwIEw0LDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-reader {
+  background: no-repeat center center url(chrome://browser/skin/readerMode.svg);
+}
+
+.browserStack[secondarybrowser="overlay"]::after {
+  content: "";
+  position: absolute;
+  left: 0;
+  right: 0;
+  top: 0;
+  bottom: 0;
+  background: rgba(0, 0, 0, .2);
+  z-index: 1;
+}
+
+.browserStack[secondarybrowser="overlay"] > .secondarybrowser {
+  width: 97%;
+  height: 100%;
+  z-index: 2;
+  justify-self: start;
+  align-self: start;
+  border-right: solid 2px rgba(0,0,0,.05);
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -3262,39 +3262,40 @@ function BrowserPageInfo(
       "https://bugzilla.mozilla.org/show_bug.cgi?id=1238180"
     );
     documentURL = documentURL.location;
   }
 
   let args = { initialTab, imageElement, browsingContext, browser };
 
   documentURL = documentURL || window.gBrowser.selectedBrowser.currentURI.spec;
-
-  // Check for windows matching the url
-  for (let currentWindow of Services.wm.getEnumerator("Browser:page-info")) {
-    if (currentWindow.closed) {
-      continue;
-    }
-    if (
-      currentWindow.document.documentElement.getAttribute("relatedUrl") ==
-      documentURL
-    ) {
-      currentWindow.focus();
-      currentWindow.resetPageInfo(args);
-      return currentWindow;
-    }
-  }
-
-  // We didn't find a matching window, so open a new one.
-  return openDialog(
-    "chrome://browser/content/pageinfo/pageInfo.xhtml",
-    "",
-    "chrome,toolbar,dialog=no,resizable",
-    args
-  );
+  console.log(args);
+  gBrowser.toggleSecondaryBrowser(gBrowser.selectedBrowser);
+  // // Check for windows matching the url
+  // for (let currentWindow of Services.wm.getEnumerator("Browser:page-info")) {
+  //   if (currentWindow.closed) {
+  //     continue;
+  //   }
+  //   if (
+  //     currentWindow.document.documentElement.getAttribute("relatedUrl") ==
+  //     documentURL
+  //   ) {
+  //     currentWindow.focus();
+  //     currentWindow.resetPageInfo(args);
+  //     return currentWindow;
+  //   }
+  // }
+
+  // // We didn't find a matching window, so open a new one.
+  // return openDialog(
+  //   "chrome://browser/content/pageinfo/pageInfo.xhtml",
+  //   "",
+  //   "chrome,toolbar,dialog=no,resizable",
+  //   args
+  // );
 }
 
 function UpdateUrlbarSearchSplitterState() {
   var splitter = document.getElementById("urlbar-search-splitter");
   var urlbar = document.getElementById("urlbar-container");
   var searchbar = document.getElementById("search-container");
 
   if (document.documentElement.getAttribute("customizing") == "true") {
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -607,16 +607,19 @@
     /**
      * Create a findbar instance.
      * @param aTab the tab to create the find bar for.
      * @return the created findbar, or null if the window or tab is closed/closing.
      */
     async _createFindBar(aTab) {
       let findBar = document.createXULElement("findbar");
       let browser = this.getBrowserForTab(aTab);
+      if (browser.secondaryBrowser) {
+        browser = browser.secondaryBrowser;
+      }
 
       // The findbar should be inserted after the browserStack and, if present for
       // this tab, after the StatusPanel as well.
       let insertAfterElement = browser.parentNode;
       if (insertAfterElement.nextElementSibling == StatusPanel.panel) {
         insertAfterElement = StatusPanel.panel;
       }
       insertAfterElement.insertAdjacentElement("afterend", findBar);
@@ -1852,16 +1855,17 @@
       let oldUserTypedValue = aBrowser.userTypedValue;
       let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
       let parent = aBrowser.parentNode;
 
       // Change the "remote" attribute.
 
       // Make sure the browser is destroyed so it unregisters from observer notifications
       aBrowser.destroy();
+
       // Only remove the node if we're not rebuilding the frameloader via nsFrameLoaderOwner.
       let rebuildFrameLoaders =
         E10SUtils.rebuildFrameloadersOnRemotenessChange ||
         window.docShell.nsILoadContext.useRemoteSubframes;
       if (!rebuildFrameLoaders) {
         aBrowser.remove();
       }
 
@@ -2031,31 +2035,65 @@
       // correct type.
       if (oldRemoteType != aOptions.remoteType || aOptions.newFrameloader) {
         return this.updateBrowserRemoteness(aBrowser, aOptions);
       }
 
       return false;
     },
 
+    closeSecondaryBrowser(browser) {
+      let stack = browser.parentNode;
+      stack.removeAttribute("secondarybrowser");
+      if (browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.destroySecondaryBrowser();
+      }
+      for (let active of stack.querySelectorAll(
+        ".secondarybrowser-controls toolbarbutton[active]"
+      )) {
+        active.removeAttribute("active");
+      }
+    },
+
+    openSecondaryBrowser(browser) {
+      let stack = browser.parentNode;
+      if (!browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.before(browser.createSecondaryBrowser());
+      }
+      if (!stack.hasAttribute("secondarybrowser")) {
+        stack.setAttribute("secondarybrowser", "overlay");
+      }
+    },
+
+    toggleSecondaryBrowser(browser) {
+      if (browser.secondaryBrowser) {
+        this.closeSecondaryBrowser(browser);
+      } else {
+        this.openSecondaryBrowser(browser);
+      }
+    },
+
     createBrowser({
       isPreloadBrowser,
       name,
       openWindowInfo,
       remoteType,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
-      b.permanentKey = new (Cu.getGlobalForObject(Services).Object)();
+      b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
@@ -2094,17 +2132,16 @@
        *      browsers will attempt to switch to a new content process,
        *      therefore the 'preloadedState' attribute is removed from
        *      that browser altogether
        * See more details on Bug 1420285.
        */
       if (isPreloadBrowser) {
         b.setAttribute("preloadedState", "preloaded");
       }
-
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
 
       // Propagate information about the opening content window to the browser.
       if (openWindowInfo) {
         b.openWindowInfo = openWindowInfo;
       }
@@ -2392,16 +2429,25 @@
         !browser.permitUnload(permitUnloadFlags).permitUnload
       ) {
         return false;
       }
 
       return true;
     },
 
+    closeFindbarForTab(aTab) {
+      // Reset the findbar and remove it if it is attached to the tab.
+      if (aTab._findBar) {
+        aTab._findBar.close(true);
+        aTab._findBar.remove();
+        delete aTab._findBar;
+      }
+    },
+
     discardBrowser(aTab, aForceDiscard) {
       "use strict";
       let browser = aTab.linkedBrowser;
 
       if (!this._mayDiscardBrowser(aTab, aForceDiscard)) {
         return false;
       }
 
@@ -2429,22 +2475,17 @@
       let listener = this._tabListeners.get(aTab);
       browser.webProgress.removeProgressListener(filter);
       filter.removeProgressListener(listener);
       listener.destroy();
 
       this._tabListeners.delete(aTab);
       this._tabFilters.delete(aTab);
 
-      // Reset the findbar and remove it if it is attached to the tab.
-      if (aTab._findBar) {
-        aTab._findBar.close(true);
-        aTab._findBar.remove();
-        delete aTab._findBar;
-      }
+      this.closeFindbarForTab();
 
       // Remove stale loading attributes.
       let attributesToRemove = ["busy", "progress", "pendingicon"];
       let removedAttributes = [];
       for (let attr of attributesToRemove) {
         if (aTab.hasAttribute(attr)) {
           removedAttributes.push(attr);
           aTab.removeAttribute(attr);
@@ -4145,16 +4186,26 @@
 
     announceWindowCreated(browser, userContextId) {
       let tab = this.getTabForBrowser(browser);
       if (tab && userContextId) {
         ContextualIdentityService.telemetry(userContextId);
         tab.setUserContextId(userContextId);
       }
 
+      // Automatically create the secondaryBrowser:
+      // XXX: this should only happen if the tab previously had it or if
+      // there's some global state
+      if (tab) {
+        // if (!browser.secondaryBrowser) {
+        //   // XXX: Make a module to control the sidebar here instead of random clicking
+        //   browser.parentNode.querySelector(".secondarybrowser-split").click();
+        // }
+      }
+
       // We don't want to update the container icon and identifier if
       // this is not the selected browser.
       if (browser == gBrowser.selectedBrowser) {
         updateUserContextUIIndicator();
       }
     },
 
     reloadMultiSelectedTabs() {
@@ -5133,17 +5184,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
@@ -5473,16 +5523,21 @@
 
       let onTabCrashed = event => {
         if (!event.isTrusted || !event.isTopFrame) {
           return;
         }
 
         let browser = event.originalTarget;
 
+        if (browser.hostBrowser) {
+          console.error("secondarybrowser crashed");
+          return;
+        }
+
         // Preloaded browsers do not actually have any tabs. If one crashes,
         // it should be released and removed.
         if (browser === this.preloadedBrowser) {
           NewTabPagePreloading.removePreloadedBrowser(window);
           return;
         }
 
         let isRestartRequiredCrash =
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -87,16 +87,32 @@ let ACTORS = {
         AboutLoginsSyncEnable: { wantUntrusted: true },
         AboutLoginsSyncOptions: { wantUntrusted: true },
         AboutLoginsUpdateLogin: { wantUntrusted: true },
       },
     },
     matches: ["about:logins", "about:logins?*"],
   },
 
+  SecondaryBrowser: {
+    parent: {
+      moduleURI: "resource:///actors/secondarybrowserParent.jsm",
+    },
+    child: {
+      moduleURI: "resource:///actors/SecondaryBrowserChild.jsm",
+      events: {
+        SecondaryBrowserContentLoaded: { wantUntrusted: true },
+        SecondaryBrowserClose: { wantUntrusted: true },
+        DOMContentLoaded: {},
+        pageshow: {},
+        unload: {},
+      },
+    },
+  },
+
   AboutNewTab: {
     child: {
       moduleURI: "resource:///actors/AboutNewTabChild.jsm",
       events: {
         DOMContentLoaded: {},
       },
     },
     // The wildcard on about:newtab is for the ?endpoint query parameter
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -25,16 +25,17 @@ with Files("safebrowsing/**"):
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
 
 
 DIRS += [
     'about',
     'aboutconfig',
     'aboutlogins',
+    'secondarybrowser',
     'attribution',
     'contextualidentity',
     'customizableui',
     'dirprovider',
     'doh',
     'downloads',
     'enterprisepolicies',
     'extensions',
diff --git a/browser/components/secondarybrowser/SecondaryBrowserChild.jsm b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
@@ -0,0 +1,224 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+
+const EXPORTED_SYMBOLS = ["SecondaryBrowserChild"];
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  FileUtils: "resource://gre/modules/FileUtils.jsm",
+  NetUtil: "resource://gre/modules/NetUtil.jsm",
+  Services: "resource://gre/modules/Services.jsm",
+});
+
+const hostToSecondaryBrowserMap = new WeakMap();
+const overlayToHostMap = new WeakMap();
+
+XPCOMUtils.defineLazyServiceGetter(
+  this,
+  "ImgTools",
+  "@mozilla.org/image/tools;1",
+  Ci.imgITools
+);
+
+// See also https://searchfox.org/mozilla-central/source/browser/base/content/nsContextMenu.js#1637-1652
+// and https://searchfox.org/mozilla-central/source/browser/actors/ContextMenuChild.jsm#593-601 for how
+// normal save image works
+// Along with https://searchfox.org/mozilla-central/source/browser/components/ssb/SiteSpecificBrowserService.jsm#162
+
+function saveIcon(container, width, height, target) {
+  return new Promise((resolve, reject) => {
+    let output = FileUtils.openFileOutputStream(target);
+    let stream = ImgTools.encodeScaledImage(
+      container,
+      "image/vnd.microsoft.icon",
+      width,
+      height,
+      ""
+    );
+    NetUtil.asyncCopy(stream, output, status => {
+      if (Components.isSuccessCode(status)) {
+        resolve();
+      } else {
+        reject(Components.Exception("Failed to save icon.", status));
+      }
+    });
+  });
+}
+
+function sendToContent(browsingContext, messageType, detail = {}) {
+  let win = browsingContext.window;
+  let message = Object.assign({ messageType }, { value: detail });
+  let event = new win.CustomEvent("SecondaryBrowserChromeToContent", {
+    detail: Cu.cloneInto(message, win),
+  });
+  win.dispatchEvent(event);
+}
+
+// See stuff like https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/walker.js#499
+
+// Basic idea here is to use this actor to receive the accessibility tree and
+// subsequent events from a 'host' browser, and then to send them along to an
+// 'secondarybrowser' browser (which are running in the same content process)
+// Maybe this should be two different actors?
+class SecondaryBrowserChild extends JSWindowActorChild {
+  willDestroy(e) {
+    // Overlay is destroyed. Kill observing:
+    if (overlayToHostMap.has(this.browsingContext)) {
+      overlayToHostMap.delete(this.browsingContext);
+    }
+  }
+  actorCreated(e) {
+    // I think it's better to wait for SecondaryBrowserContentLoaded to
+    // signal the connection so there's no races.. but maybe this
+    // would come in handy somehow?
+  }
+
+  receiveMessage(message) {
+    console.log(
+      "SecondaryBrowserChild::receiveMessage",
+      message.name,
+      Services.appinfo.processID,
+      this.browsingContext.window.location.toString()
+    );
+    switch (message.name) {
+      case "SecondaryBrowser:UpdateBrowsingContext": {
+        const { browsingContext, initialView } = message.data;
+        hostToSecondaryBrowserMap.set(this.browsingContext, browsingContext);
+        overlayToHostMap.set(browsingContext, this.browsingContext);
+        this.sendImages();
+
+        break;
+      }
+    }
+  }
+
+  sendImages() {
+    // XXX: Set up notification on ImageTracker::Add to update as new
+    // ones are added.
+
+    let win = this.browsingContext.window;
+    let doc = win.document;
+    let browsingContext = hostToSecondaryBrowserMap.get(this.browsingContext);
+    if (!browsingContext) {
+      return;
+    }
+    // console.log(
+    //   doc.URI,
+    //   win.windowUtils.getTrackedImages(),
+    //   [...win.windowUtils.getTrackedImages()].map(img => {
+    //     return img.image.width;
+    //   }),
+    //   [...win.windowUtils.getTrackedImages()]
+    //     .map(img => {
+    //       return img.URI.spec;
+    //     })
+    //     .join("\n")
+    // );
+
+    sendToContent(
+      browsingContext,
+      "TrackedImages",
+      [...win.windowUtils.getTrackedImages()]
+        .filter(img => {
+          // Why is resource://gre-resources/arrow.gif included?
+          return img.URI.scheme != "resource" && img.URI.scheme != "chrome";
+        })
+        .map(img => {
+          // var img = window.windowUtils.getTrackedImages()[0];
+          var imageCache = Cc["@mozilla.org/image/tools;1"]
+            .getService(Ci.imgITools)
+            .getImgCacheForDocument(doc);
+          // The image cache's notion of where this image is located is
+          // the currentURI of the image loading content.
+          var props = imageCache.findEntryProperties(img.finalURI, doc);
+
+          var contentType;
+          var contentDisposition;
+          var width;
+          var height;
+
+          try {
+            width = img.image.width;
+          } catch (e) {}
+          try {
+            height = img.image.height;
+          } catch (e) {}
+
+          try {
+            contentType = props.get("type", Ci.nsISupportsCString).data;
+          } catch (e) {}
+
+          try {
+            contentDisposition = props.get(
+              "content-disposition",
+              Ci.nsISupportsCString
+            ).data;
+          } catch (e) {}
+          console.log(contentType, contentDisposition);
+
+          return {
+            finalURI: img.finalURI.spec,
+            contentType,
+            contentDisposition,
+            width,
+            height,
+          };
+        })
+    );
+
+    // We can either sendToContent or directly change the DOM:
+    console.log(
+      "SecondaryBrowserContentLoaded, PID:",
+      Services.appinfo.processID
+    );
+    let secondaryDoc = browsingContext.window.document;
+    // doc = hostToSecondaryBrowserMap.get(this.browsingContext);
+    let title = secondaryDoc.querySelector("#title");
+    title.textContent = `Page Info: ${this.browsingContext.window.document.title}`;
+  }
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "pageshow": {
+        this.sendImages();
+        break;
+      }
+      case "DOMContentLoaded": {
+        this.sendImages();
+        break;
+      }
+      case "unload": {
+        console.log("unload");
+        this.sendImages();
+        break;
+      }
+      case "SecondaryBrowserContentLoaded": {
+        this.sendAsyncMessage("SecondaryBrowser:WindowCreated");
+        break;
+      }
+      case "SecondaryBrowserSaveMedia": {
+        // XXX: Forward this to parent and call internalSave (including
+        // zipping if multiple)
+        break;
+      }
+      case "SecondaryBrowserClose": {
+        this.sendAsyncMessage("SecondaryBrowser:Close");
+        break;
+      }
+      case "SecondaryBrowserContentView": {
+        if (event.detail.split) {
+          this.sendAsyncMessage("SecondaryBrowser:Split");
+        } else {
+          this.sendAsyncMessage("SecondaryBrowser:Unsplit");
+        }
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/SecondaryBrowserParent.jsm b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
@@ -0,0 +1,60 @@
+/* vim: set ts=2 sw=2 sts=2 et tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+var EXPORTED_SYMBOLS = ["SecondaryBrowserParent"];
+
+class SecondaryBrowserParent extends JSWindowActorParent {
+  receiveMessage(message) {
+    // console.log("SecondaryBrowserParent::receiveMessage", message);
+    let browser = this.manager.browsingContext.embedderElement;
+    if (!browser) {
+      return; // Can happen sometimes if browser is being destroyed
+    }
+    if (!browser.hostBrowser) {
+      // This shouldn't really happen - the message is coming from a secondary browser
+      // which by definition should have a host.
+      return;
+    }
+
+    switch (message.name) {
+      // XXX: This could be used if we have an 'overlay' view
+      case "SecondaryBrowser:Close": {
+        let gBrowser = browser.hostBrowser.getTabBrowser();
+        gBrowser.closeSecondaryBrowser(browser.hostBrowser);
+        break;
+      }
+      case "SecondaryBrowser:Split": {
+        browser.hostBrowser.parentNode.setAttribute(
+          "secondarybrowser",
+          "split"
+        );
+        break;
+      }
+      case "SecondaryBrowser:Unsplit": {
+        browser.hostBrowser.parentNode.setAttribute("secondarybrowser", "on");
+        break;
+      }
+
+      case "SecondaryBrowser:WindowCreated": {
+        let initialView;
+        // XXX: We need a cleaner way to signal initial state (or just build a prototype
+        // that only deals with outline)
+        initialView = "outline";
+        if (browser.parentNode.getAttribute("secondarybrowser") == "overlay") {
+          initialView = "outline";
+        }
+
+        browser.hostBrowser.browsingContext.currentWindowGlobal
+          .getActor("SecondaryBrowser")
+          .sendAsyncMessage("SecondaryBrowser:UpdateBrowsingContext", {
+            browsingContext: browser.browsingContext,
+            initialView,
+          });
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/content/jar.mn b/browser/components/secondarybrowser/content/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/jar.mn
@@ -0,0 +1,8 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+    content/browser/secondarybrowser/secondaryui.html
+    content/browser/secondarybrowser/secondaryui.js
+    content/browser/secondarybrowser/secondaryui.css
diff --git a/browser/components/secondarybrowser/content/secondaryui.css b/browser/components/secondarybrowser/content/secondaryui.css
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.css
@@ -0,0 +1,110 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+ * {
+  box-sizing: border-box;
+ }
+
+ #close {
+  position: absolute;
+  right: 4px;
+  top: 1px;
+  min-height: 30px;
+  margin: 0;
+  min-width: 20px;
+ }
+
+ #content {
+   display: flex;
+   flex-direction: column;
+   height: 100vh;
+ }
+ #details-deck {
+  flex: 1;
+  overflow: scroll;
+ }
+ .tab-group {
+   margin-inline: 0;
+   margin-top: 0;
+   border-top: none;
+ }
+img {
+  /* max-width: 80%;
+  margin: 2px; */
+  max-width: 100%;
+
+}
+
+/*
+:root {
+  counter-reset: image-grid;
+}
+
+.image-grid {
+  display: grid;
+  grid-gap: 10px;
+  grid-template-columns: repeat(auto-fill, minmax(200px,1fr));
+  grid-auto-rows: 0;
+}
+
+.image-grid-item {
+  border-radius: 5px;
+}
+
+.image-grid-item {
+   background-color: #eee;
+   border-radius: 5px;
+   overflow: hidden;
+}
+
+.image-grid-item,
+.image-grid-item img {
+   position: relative;
+}
+
+.image-grid-item:after {
+  font-weight: bold;
+  background-color: rgba(0, 0, 0, .5);
+  content: counter(image-grid);
+  counter-increment: image-grid;
+  position: absolute;
+  top: 0;
+  left: 0; 
+  height: 100%;
+  width: 100%;
+  color: white;
+  display: flex;
+  justify-content: center; 
+  align-items: center;
+  transition: all .1s ease-in;
+}
+
+.image-grid-item:hover:after {
+  font-size: 30px;
+  background-color: rgba(0, 0, 0, .75);
+}
+*/
+
+/* with flexbox */
+.image-grid {
+  display: flex;
+}
+
+.image-grid-col {
+  flex-grow: 1;
+  margin: 2px;
+}
+
+/* 2 columns by default, hide columns 2 & 3 */
+.image-grid-col--2, .image-grid-col--3 { display: none }
+
+/* 3 columns at medium size */
+@media ( min-width: 768px ) {
+  .image-grid-col--2 { display: block; } /* show column 2 */
+}
+
+/* 4 columns at large size */
+@media ( min-width: 1080px ) {
+  .image-grid-col--3 { display: block; } /* show column 3 */
+}
diff --git a/browser/components/secondarybrowser/content/secondaryui.html b/browser/components/secondarybrowser/content/secondaryui.html
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.html
@@ -0,0 +1,51 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE html>
+<html>
+<head>
+  <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'" />
+  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
+  <meta name="viewport" content="width=device-width; user-scalable=0" />
+  <link rel="stylesheet" href="chrome://global/skin/in-content/common.css">
+  <link rel="stylesheet" href="chrome://mozapps/content/extensions/aboutaddons.css">
+  <link rel="stylesheet" href="chrome://browser/content/secondarybrowser/secondaryui.css">
+  <title>Page Info</title>
+</head>
+<body>
+  <div id="content">
+    <button id="close" aria-label="close">X</button>
+    <button-group class="tab-group">
+      <button is="named-deck-button" deck="details-deck" name="info" class="tab-button">Info</button>
+      <button is="named-deck-button" deck="details-deck" name="images" class="tab-button">Images</button>
+      <button is="named-deck-button" deck="details-deck" name="outline" class="tab-button">Outline</button>
+      <!-- <button is="named-deck-button" deck="details-deck" name="dev" class="tab-button">Firefox Developer</button> -->
+    </button-group>
+    <named-deck id="details-deck" selected-view="images">
+      <section name="info">
+        <h2>Page Info</h2>
+        <div id="title"></div>
+      </section>
+      <section name="images">
+        <div class="controls">
+          <button>Save All as Zip</button>
+        </div>
+        <div id="full-image-grid" class="image-grid"></div>
+        <div id="icon-image-grid" class="image-grid"></div>
+      </section>
+      <section name="outline">
+        <h2>Outline</h2>
+      </section>
+      <!-- <section name="dev">
+        <h2>Firefox Developer</h2>
+        <p>Pid:</p>
+        <button>Reload tab</button>
+        <button>Crash tab</button>
+      </section> -->
+    </named-deck>
+  </div>
+  <script src="chrome://mozapps/content/extensions/named-deck.js"></script>
+  <script src="chrome://browser/content/secondarybrowser/secondaryui.js"></script>
+</body>
+</html>
diff --git a/browser/components/secondarybrowser/content/secondaryui.js b/browser/components/secondarybrowser/content/secondaryui.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.js
@@ -0,0 +1,443 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/*!
+ * Colcade v0.2.0
+ * Lightweight masonry layout
+ * by David DeSandro
+ * MIT license
+ */
+
+/*jshint browser: true, undef: true, unused: true */
+
+(function(window, factory) {
+  // universal module definition
+  /*jshint strict: false */
+  /*global define: false, module: false */
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define(factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory();
+  } else {
+    // browser global
+    window.Colcade = factory();
+  }
+})(window, function factory() {
+  // -------------------------- Colcade -------------------------- //
+
+  function Colcade(element, options) {
+    element = getQueryElement(element);
+
+    // do not initialize twice on same element
+    if (element && element.colcadeGUID) {
+      var instance = instances[element.colcadeGUID];
+      instance.option(options);
+      return instance;
+    }
+
+    this.element = element;
+    // options
+    this.options = {};
+    this.option(options);
+    // kick things off
+    this.create();
+  }
+
+  var proto = Colcade.prototype;
+
+  proto.option = function(options) {
+    this.options = extend(this.options, options);
+  };
+
+  // globally unique identifiers
+  var GUID = 0;
+  // internal store of all Colcade intances
+  var instances = {};
+
+  proto.create = function() {
+    this.errorCheck();
+    // add guid for Colcade.data
+    var guid = (this.guid = ++GUID);
+    this.element.colcadeGUID = guid;
+    instances[guid] = this; // associate via id
+    // update initial properties & layout
+    this.reload();
+    // events
+    this._windowResizeHandler = this.onWindowResize.bind(this);
+    this._loadHandler = this.onLoad.bind(this);
+    window.addEventListener("resize", this._windowResizeHandler);
+    this.element.addEventListener("load", this._loadHandler, true);
+  };
+
+  proto.errorCheck = function() {
+    var errors = [];
+    if (!this.element) {
+      errors.push("Bad element: " + this.element);
+    }
+    if (!this.options.columns) {
+      errors.push("columns option required: " + this.options.columns);
+    }
+    if (!this.options.items) {
+      errors.push("items option required: " + this.options.items);
+    }
+
+    if (errors.length) {
+      throw new Error("[Colcade error] " + errors.join(". "));
+    }
+  };
+
+  // update properties and do layout
+  proto.reload = function() {
+    this.updateColumns();
+    this.updateItems();
+    this.layout();
+  };
+
+  proto.updateColumns = function() {
+    this.columns = querySelect(this.options.columns, this.element);
+  };
+
+  proto.updateItems = function() {
+    this.items = querySelect(this.options.items, this.element);
+  };
+
+  proto.getActiveColumns = function() {
+    return this.columns.filter(function(column) {
+      var style = getComputedStyle(column);
+      return style.display != "none";
+    });
+  };
+
+  // ----- layout ----- //
+
+  // public, updates activeColumns
+  proto.layout = function() {
+    this.activeColumns = this.getActiveColumns();
+    this._layout();
+  };
+
+  // private, does not update activeColumns
+  proto._layout = function() {
+    // reset column heights
+    this.columnHeights = this.activeColumns.map(function() {
+      return 0;
+    });
+    // layout all items
+    this.layoutItems(this.items);
+  };
+
+  proto.layoutItems = function(items) {
+    items.forEach(this.layoutItem, this);
+  };
+
+  proto.layoutItem = function(item) {
+    // layout item by appending to column
+    var minHeight = Math.min.apply(Math, this.columnHeights);
+    var index = this.columnHeights.indexOf(minHeight);
+    this.activeColumns[index].appendChild(item);
+    // at least 1px, if item hasn't loaded
+    // Not exactly accurate, but it's cool
+    this.columnHeights[index] += item.offsetHeight || 1;
+  };
+
+  // ----- adding items ----- //
+
+  proto.append = function(elems) {
+    var items = this.getQueryItems(elems);
+    // add items to collection
+    this.items = this.items.concat(items);
+    // lay them out
+    this.layoutItems(items);
+  };
+
+  proto.prepend = function(elems) {
+    var items = this.getQueryItems(elems);
+    // add items to collection
+    this.items = items.concat(this.items);
+    // lay out everything
+    this._layout();
+  };
+
+  proto.getQueryItems = function(elems) {
+    elems = makeArray(elems);
+    var fragment = document.createDocumentFragment();
+    elems.forEach(function(elem) {
+      fragment.appendChild(elem);
+    });
+    return querySelect(this.options.items, fragment);
+  };
+
+  // ----- measure column height ----- //
+
+  proto.measureColumnHeight = function(elem) {
+    var boundingRect = this.element.getBoundingClientRect();
+    this.activeColumns.forEach(function(column, i) {
+      // if elem, measure only that column
+      // if no elem, measure all columns
+      if (!elem || column.contains(elem)) {
+        var lastChildRect = column.lastElementChild.getBoundingClientRect();
+        // not an exact calculation as it includes top border, and excludes item bottom margin
+        this.columnHeights[i] = lastChildRect.bottom - boundingRect.top;
+      }
+    }, this);
+  };
+
+  // ----- events ----- //
+
+  proto.onWindowResize = function() {
+    clearTimeout(this.resizeTimeout);
+    this.resizeTimeout = setTimeout(
+      function() {
+        this.onDebouncedResize();
+      }.bind(this),
+      100
+    );
+  };
+
+  proto.onDebouncedResize = function() {
+    var activeColumns = this.getActiveColumns();
+    // check if columns changed
+    var isSameLength = activeColumns.length == this.activeColumns.length;
+    var isSameColumns = true;
+    this.activeColumns.forEach(function(column, i) {
+      isSameColumns = isSameColumns && column == activeColumns[i];
+    });
+    if (isSameLength && isSameColumns) {
+      return;
+    }
+    // activeColumns changed
+    this.activeColumns = activeColumns;
+    this._layout();
+  };
+
+  proto.onLoad = function(event) {
+    this.measureColumnHeight(event.target);
+  };
+
+  // ----- destroy ----- //
+
+  proto.destroy = function() {
+    // move items back to container
+    this.items.forEach(function(item) {
+      this.element.appendChild(item);
+    }, this);
+    // remove events
+    window.removeEventListener("resize", this._windowResizeHandler);
+    this.element.removeEventListener("load", this._loadHandler, true);
+    // remove data
+    delete this.element.colcadeGUID;
+    delete instances[this.guid];
+  };
+
+  // -------------------------- HTML init -------------------------- //
+
+  docReady(function() {
+    var dataElems = querySelect("[data-colcade]");
+    dataElems.forEach(htmlInit);
+  });
+
+  function htmlInit(elem) {
+    // convert attribute "foo: bar, qux: baz" into object
+    var attr = elem.getAttribute("data-colcade");
+    var attrParts = attr.split(",");
+    var options = {};
+    attrParts.forEach(function(part) {
+      var pair = part.split(":");
+      var key = pair[0].trim();
+      var value = pair[1].trim();
+      options[key] = value;
+    });
+
+    new Colcade(elem, options);
+  }
+
+  Colcade.data = function(elem) {
+    elem = getQueryElement(elem);
+    var id = elem && elem.colcadeGUID;
+    return id && instances[id];
+  };
+
+  // -------------------------- jQuery -------------------------- //
+
+  Colcade.makeJQueryPlugin = function($) {
+    $ = $ || window.jQuery;
+    if (!$) {
+      return;
+    }
+
+    $.fn.colcade = function(arg0 /*, arg1 */) {
+      // method call $().colcade( 'method', { options } )
+      if (typeof arg0 == "string") {
+        // shift arguments by 1
+        var args = Array.prototype.slice.call(arguments, 1);
+        return methodCall(this, arg0, args);
+      }
+      // just $().colcade({ options })
+      plainCall(this, arg0);
+      return this;
+    };
+
+    function methodCall($elems, methodName, args) {
+      var returnValue;
+      $elems.each(function(i, elem) {
+        // get instance
+        var colcade = $.data(elem, "colcade");
+        if (!colcade) {
+          return;
+        }
+        // apply method, get return value
+        var value = colcade[methodName].apply(colcade, args);
+        // set return value if value is returned, use only first value
+        returnValue = returnValue === undefined ? value : returnValue;
+      });
+      return returnValue !== undefined ? returnValue : $elems;
+    }
+
+    function plainCall($elems, options) {
+      $elems.each(function(i, elem) {
+        var colcade = $.data(elem, "colcade");
+        if (colcade) {
+          // set options & init
+          colcade.option(options);
+          colcade.layout();
+        } else {
+          // initialize new instance
+          colcade = new Colcade(elem, options);
+          $.data(elem, "colcade", colcade);
+        }
+      });
+    }
+  };
+
+  // try making plugin
+  Colcade.makeJQueryPlugin();
+
+  // -------------------------- utils -------------------------- //
+
+  function extend(a, b) {
+    for (var prop in b) {
+      a[prop] = b[prop];
+    }
+    return a;
+  }
+
+  // turn element or nodeList into an array
+  function makeArray(obj) {
+    var ary = [];
+    if (Array.isArray(obj)) {
+      // use object if already an array
+      ary = obj;
+    } else if (obj && typeof obj.length == "number") {
+      // convert nodeList to array
+      for (var i = 0; i < obj.length; i++) {
+        ary.push(obj[i]);
+      }
+    } else {
+      // array of single index
+      ary.push(obj);
+    }
+    return ary;
+  }
+
+  // get array of elements
+  function querySelect(selector, elem) {
+    elem = elem || document;
+    var elems = elem.querySelectorAll(selector);
+    return makeArray(elems);
+  }
+
+  function getQueryElement(elem) {
+    if (typeof elem == "string") {
+      elem = document.querySelector(elem);
+    }
+    return elem;
+  }
+
+  function docReady(onReady) {
+    if (document.readyState == "complete") {
+      onReady();
+      return;
+    }
+    document.addEventListener("DOMContentLoaded", onReady);
+  }
+
+  // -------------------------- end -------------------------- //
+
+  return Colcade;
+});
+
+window.addEventListener("DOMContentLoaded", function() {
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserContentLoaded", { bubbles: true })
+  );
+});
+
+document.querySelector("#close").addEventListener("click", () => {
+  console.log("DISPATCH");
+  document.dispatchEvent(
+    new CustomEvent("SecondaryBrowserClose", { bubbles: true })
+  );
+});
+
+window.addEventListener("SecondaryBrowserChromeToContent", event => {
+  console.log("SecondaryBrowserChromeToContent", event.detail);
+  switch (event.detail.messageType) {
+    case "TrackedImages": {
+      let fullGrid = document.querySelector("#full-image-grid");
+      let iconGrid = document.querySelector("#icon-image-grid");
+      fullGrid.innerHTML = iconGrid.innerHTML = `
+      <div class="image-grid-col image-grid-col--1"></div>
+      <div class="image-grid-col image-grid-col--2"></div>
+      <div class="image-grid-col image-grid-col--3"></div>
+      <div class="image-grid-col image-grid-col--4"></div>`;
+      let images = event.detail.value;
+      for (let image of images) {
+        let item = document.createElement("div");
+        item.classList.add("image-grid-item");
+        let img = document.createElement("img");
+        // XXX: We may be able to directly render an imgIRequest without needing to re-fetch
+        img.src = image.finalURI;
+        // if (image.width && image.height) {
+        //   img.width = image.width;
+        //   img.height = image.height;
+        // }
+        item.append(img);
+        if (
+          image.width &&
+          image.height &&
+          image.width <= 48 &&
+          image.height <= 48
+        ) {
+          iconGrid.append(item);
+        } else {
+          fullGrid.append(item);
+        }
+      }
+
+      new Colcade(fullGrid, {
+        columns: ".image-grid-col",
+        items: ".image-grid-item",
+      });
+      new Colcade(iconGrid, {
+        columns: ".image-grid-col",
+        items: ".image-grid-item",
+      });
+
+      // var msnry = new Masonry(grid, {
+      //   // options
+      //   itemSelector: ".grid-item",
+      //   columnWidth: 200,
+      // });
+      // msnry.imagesLoaded().progress(function() {
+      //   msnry.masonry("layout");
+      // });
+
+      break;
+    }
+  }
+});
diff --git a/browser/components/secondarybrowser/moz.build b/browser/components/secondarybrowser/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/moz.build
@@ -0,0 +1,15 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ['content/jar.mn']
+
+#EXTRA_JS_MODULES += [
+#]
+
+FINAL_TARGET_FILES.actors += [
+    'SecondaryBrowserChild.jsm',
+    'SecondaryBrowserParent.jsm',
+]
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -782,16 +782,23 @@
   mask-image: linear-gradient(to right, transparent, black 3ch);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input {
   mask-position-x: calc(var(--cfr-label-width) * -1);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input:-moz-locale-dir(rtl) {
   mask-position-x: calc(var(--cfr-label-width));
 }
+#secondary-browser-button {
+  list-style-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+#secondary-browser-button[readeractive] {
+  background: var(--toolbarbutton-icon-fill-attention);
+  background: rgb(159, 200, 213);
+}
 
 /* Reader mode icon */
 
 #reader-mode-button {
   list-style-image: url(chrome://browser/skin/readerMode.svg);
 }
 
 #reader-mode-button[readeractive] {
diff --git a/toolkit/actors/SelectParent.jsm b/toolkit/actors/SelectParent.jsm
--- a/toolkit/actors/SelectParent.jsm
+++ b/toolkit/actors/SelectParent.jsm
@@ -549,23 +549,26 @@ var SelectParentHelper = {
         }
       }
     }
 
     if (parentElement && ariaOwns) {
       parentElement.setAttribute("aria-owns", ariaOwns);
     }
 
+    // XXX: Pass in whether we are opening for a secondary browser. In the meantime
+    // we'll just enable search everywhere.add-a-comment
     // Check if search pref is enabled, if this is the first time iterating through
     // the dropdown, and if the list is long enough for a search element to be added.
-    if (
-      Services.prefs.getBoolPref("dom.forms.selectSearch") &&
-      addSearch &&
-      element.childElementCount > SEARCH_MINIMUM_ELEMENTS
-    ) {
+    if (true) {
+      // if (
+      //   Services.prefs.getBoolPref("dom.forms.selectSearch") &&
+      //   addSearch &&
+      //   element.childElementCount > SEARCH_MINIMUM_ELEMENTS
+      // ) {
       // Add a search text field as the first element of the dropdown
       let searchbox = element.ownerDocument.createXULElement("search-textbox");
       searchbox.className = "contentSelectDropdown-searchbox";
       searchbox.addEventListener("input", this.onSearchInput);
       searchbox.addEventListener("focus", this.onSearchFocus.bind(this));
       searchbox.addEventListener("blur", this.onSearchBlur);
       searchbox.addEventListener("command", this.onSearchInput);
 
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -449,18 +449,78 @@
         if (this.isRemoteBrowser) {
           this._documentContentType = aContentType;
         } else {
           this.contentDocument.documentContentType = aContentType;
         }
       }
     }
 
+    createSecondaryBrowser() {
+      if (!this.secondaryBrowser) {
+        this.secondaryBrowser = document.createXULElement("browser");
+        this.secondaryBrowser.classList.add("secondarybrowser");
+        this.secondaryBrowser.setAttribute("disablehistory", "true");
+        this.secondaryBrowser.setAttribute("nodefaultsrc", "true");
+        this.secondaryBrowser.setAttribute(
+          "remoteType",
+          this.getAttribute("remoteType")
+        );
+        this.secondaryBrowser.setAttribute(
+          "remote",
+          this.getAttribute("remote")
+        );
+        this.secondaryBrowser.setAttribute("type", "content");
+        this.secondaryBrowser.setAttribute(
+          "contextmenu",
+          this.getAttribute("contextmenu")
+        );
+        this.secondaryBrowser.setAttribute(
+          "datetimepicker",
+          this.getAttribute("datetimepicker")
+        );
+        this.secondaryBrowser.setAttribute(
+          "selectmenulist",
+          this.getAttribute("selectmenulist")
+        );
+        this.secondaryBrowser.setAttribute(
+          "tooltip",
+          this.getAttribute("tooltip")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autocompletepopup",
+          this.getAttribute("autocompletepopup")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autoscrollpopup",
+          this.getAttribute("autoscrollpopup")
+        );
+        this.secondaryBrowser.setAttribute("message", "true");
+        this.secondaryBrowser.setAttribute(
+          "messagemanagergroup",
+          "secondarybrowsers"
+        );
+
+        this.secondaryBrowser.sameProcessAsFrameLoader = this.frameLoader;
+        this.secondaryBrowser.hostBrowser = this;
+        this.secondaryBrowser.src = "chrome://browser/content/secondarybrowser/secondaryui.html";
+        // XXX if we load "about:secondarybrowser" we get
+        // Security Error: Content at about:secondarybrowser may not load or link to chrome://mozapps/content/extensions/aboutaddons.css.
+
+      }
+      return this.secondaryBrowser;
+    }
+
     set sameProcessAsFrameLoader(val) {
       this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+      if (this.secondaryBrowser) {
+        this.secondaryBrowser.sameProcessAsFrameLoader = Cu.getWeakReference(
+          val
+        );
+      }
     }
 
     get sameProcessAsFrameLoader() {
       return (
         this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get()
       );
     }
 
@@ -1275,25 +1335,41 @@
         // our RemoteWebProgress or its associated manager, but we'll need to
         // add the progress listeners to the new non-remote WebProgress.
         this._remoteWebProgressManager = null;
         this._remoteWebProgress = null;
         this.restoreProgressListeners();
 
         this.addEventListener("pagehide", this.onPageHide, true);
       }
+
+      if (this.hadsecondaryBrowser) {
+        this.hadsecondaryBrowser = false;
+        this.before(this.createSecondaryBrowser());
+      }
     }
 
+    destroySecondaryBrowser() {
+      if (this.secondaryBrowser) {
+        this.hadsecondaryBrowser = true;
+        this.secondaryBrowser.remove();
+        this.secondaryBrowser = null;
+      }
+    }
     /**
      * This is necessary because the destructor doesn't always get called when
      * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
      */
     destroy() {
       elementsToDestroyOnUnload.delete(this);
 
+      // Just remove the secondarybrowser browser entirely and let it get recreated
+      // when we are re-added (i.e. with a remoteness change)
+      this.destroySecondaryBrowser();
+
       // Make sure that any open select is closed.
       if (this.hasAttribute("selectmenulist")) {
         let menulist = document.getElementById(
           this.getAttribute("selectmenulist")
         );
         if (menulist && menulist.open) {
           let resourcePath = "resource://gre/actors/SelectParent.jsm";
           let { SelectParentHelper } = ChromeUtils.import(resourcePath);
@@ -1979,17 +2055,23 @@
 
       function sendToChildren(browsingContext, childScope) {
         let windowGlobal = browsingContext.currentWindowGlobal;
         // If 'roots' is set, only send if windowGlobal.isProcessRoot is true.
         if (
           windowGlobal &&
           (childScope != "roots" || windowGlobal.isProcessRoot)
         ) {
-          windowGlobal.getActor(actorName).sendAsyncMessage(messageName, args);
+          try {
+            windowGlobal
+              .getActor(actorName)
+              .sendAsyncMessage(messageName, args);
+          } catch (e) {
+            console.log(actorName, messageName, e);
+          }
         }
 
         // Iterate as long as scope in assigned. Note that we use the original
         // passed in scope, not childScope here.
         if (scope) {
           for (let context of browsingContext.children) {
             sendToChildren(context, scope);
           }
diff --git a/toolkit/modules/ActorManagerParent.jsm b/toolkit/modules/ActorManagerParent.jsm
--- a/toolkit/modules/ActorManagerParent.jsm
+++ b/toolkit/modules/ActorManagerParent.jsm
@@ -178,17 +178,17 @@ let ACTORS = {
     child: {
       moduleURI: "resource://gre/actors/FindBarChild.jsm",
       events: {
         keypress: { mozSystemGroup: true },
       },
     },
 
     allFrames: true,
-    messageManagerGroups: ["browsers", "test"],
+    messageManagerGroups: ["browsers", "test", "secondarybrowsers"],
   },
 
   // This is the actor that responds to requests from the find toolbar and
   // searches for matches and highlights them.
   Finder: {
     child: {
       moduleURI: "resource://gre/actors/FinderChild.jsm",
     },
