# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dd6702b8f640f868ad26b4ece5a5451a076ee5da
Watch the objdir for changed files and refresh them

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1269,16 +1269,17 @@ var gBrowserInit = {
     BrowserOnClick.init();
     FeedHandler.init();
     CompactTheme.init();
     AboutPrivateBrowsingListener.init();
     TrackingProtection.init();
     RefreshBlocker.init();
     CaptivePortalWatcher.init();
     FullZoomUI.init(window);
+    DevRefresher.init();
 
     let mm = window.getGroupMessageManager("browsers");
     mm.loadFrameScript("chrome://browser/content/tab-content.js", true);
     mm.loadFrameScript("chrome://browser/content/content.js", true);
     mm.loadFrameScript("chrome://browser/content/content-UITour.js", true);
     mm.loadFrameScript("chrome://global/content/manifestMessages.js", true);
 
     // initialize observers and listeners
@@ -8871,8 +8872,188 @@ TabModalPromptBox.prototype = {
   get browser() {
     let browser = this._weakBrowserRef.get();
     if (!browser) {
       throw "Stale promptbox! The associated browser is gone.";
     }
     return browser;
   },
 };
+
+var DevRefresher = {
+  resolveURIToLocalPath(aURI) {
+    let resolved;
+    switch (aURI.scheme) {
+      case "jar":
+      case "file":
+        return aURI;
+
+      case "chrome":
+        resolved = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                   getService(Ci.nsIChromeRegistry).convertChromeURL(aURI);
+        return this.resolveURIToLocalPath(resolved);
+
+      case "resource":
+        resolved = Cc["@mozilla.org/network/protocol;1?name=resource"].
+                   getService(Ci.nsIResProtocolHandler).resolveURI(aURI);
+        aURI = Services.io.newURI(resolved, null, null);
+        return this.resolveURIToLocalPath(aURI);
+
+      default:
+        return null;
+    }
+  },
+  getLocalPath(url) {
+    let uri = null;
+    let ios = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces["nsIIOService"]);
+    try {
+        uri = this.resolveURIToLocalPath(ios.newURI(url, "UTF-8", null));
+    } catch(e){}
+    return uri ? uri.spec : uri;
+  },
+
+  watchFiles(path, onFileChanged) {
+    const watchWorker = new ChromeWorker(
+      "resource://devtools/client/shared/file-watcher-worker.js"
+    );
+
+    watchWorker.onmessage = event => {
+      // We need to turn a local path back into a resource URI (or
+      // chrome). This means that this system will only work when built
+      // files are symlinked, so that these URIs actually read from
+      // local sources. There might be a better way to do this.
+      const { path: newPath } = event.data;
+      onFileChanged(newPath);
+    };
+
+    watchWorker.postMessage({
+      path,
+      fileRegex: /\.(js|css|svg|png)$/
+    });
+    return watchWorker;
+  },
+
+
+  iterStyleNodes(window, func) {
+    for (let node of window.document.childNodes) {
+      // Look for ProcessingInstruction nodes.
+      if (node.nodeType === 7) {
+        func(node);
+      }
+    }
+
+    const links = window.document.getElementsByTagNameNS(
+      "http://www.w3.org/1999/xhtml", "link"
+    );
+    for (let node of links) {
+      func(node);
+    }
+  },
+
+  replaceCSS(window, fileURI) {
+    const document = window.document;
+    const randomKey = Math.random();
+    console.log("Replacing", window, fileURI);
+    Services.obs.notifyObservers(null, "startupcache-invalidate");
+
+    // Scan every CSS tag and reload ones that match the file we are
+    // looking for.
+    this.iterStyleNodes(window, node => {
+      if (node.nodeType === 7) {
+        // xml-stylesheet declaration
+        // Convert a string like href="chrome://browser/content/browser.css" type="text/css" to:
+        // chrome://browser/content/browser.css, then convert it to a local path
+        let originalHref = node.data.match(/href=([^\s]*)/)[1].replace(/["']/g, '')
+        const path = this.getLocalPath(originalHref);
+        console.log("Looking into PI", path, fileURI, originalHref);
+        if (path && path.includes(fileURI)) {
+          // Special case chrome://browser/skin/ which does a redircet
+          if (originalHref == "chrome://browser/skin/") {
+            originalHref = "chrome://browser/skin/browser.css";
+          }
+          console.log("Replacing the PI at: ", originalHref);
+          const newNode = window.document.createProcessingInstruction(
+            "xml-stylesheet",
+            `href="${originalHref}?s=${randomKey}" type="text/css"`
+          );
+          document.insertBefore(newNode, node);
+          document.removeChild(node);
+        }
+      } else {
+        const originalHref = node.href;
+        const path = this.getLocalPath(originalHref);
+        console.log("Looking into stylesheet", path, fileURI);
+        if (path && path.includes(fileURI)) {
+          console.log("Replacing the stylesheet at: ", originalHref);
+          const parentNode = node.parentNode;
+          const newNode = window.document.createElementNS(
+            "http://www.w3.org/1999/xhtml",
+            "link"
+          );
+          newNode.rel = "stylesheet";
+          newNode.type = "text/css";
+          newNode.href = originalHref + "?s=" + randomKey;
+
+          parentNode.insertBefore(newNode, node);
+          parentNode.removeChild(node);
+        }
+     }
+    });
+  },
+
+  _replaceResourceInSheet(sheet, filename, randomKey) {
+    for (let i = 0; i < sheet.cssRules.length; i++) {
+      const rule = sheet.cssRules[i];
+      if (rule.type === rule.IMPORT_RULE) {
+        this._replaceResourceInSheet(rule.styleSheet, filename);
+      } else if (rule.cssText.includes(filename)) {
+        // Strip off any existing query strings. This might lose
+        // updates for files if there are multiple resources
+        // referenced in the same rule, but the chances of someone hot
+        // reloading multiple resources in the same rule is very low.
+        const text = rule.cssText.replace(/\?s=0.\d+/g, "");
+        const newRule = (
+          text.replace(filename, filename + "?s=" + randomKey)
+        );
+
+        sheet.deleteRule(i);
+        sheet.insertRule(newRule, i);
+      }
+    }
+  },
+
+  replaceCSSResource(window, fileURI) {
+    const document = window.document;
+    const randomKey = Math.random();
+
+    // Only match the filename. False positives are much better than
+    // missing updates, as all that would happen is we reload more
+    // resources than we need. We do this because many resources only
+    // use relative paths.
+    const parts = fileURI.split("/");
+    const file = parts[parts.length - 1];
+
+    // Scan every single rule in the entire page for any reference to
+    // this resource, and re-insert the rule to force it to update.
+    for (let sheet of document.styleSheets) {
+      this._replaceResourceInSheet(sheet, file, randomKey);
+    }
+
+    for (let node of document.querySelectorAll("img,image")) {
+      if (node.src.startsWith(fileURI)) {
+        node.src = fileURI + "?s=" + randomKey;
+      }
+    }
+  },
+
+  init() {
+    const watchRoot = this.getLocalPath("resource://").replace(/file:\/\//, "");
+    this.worker = this.watchFiles(watchRoot, path => {
+      let relativePath = path.replace(watchRoot + "/", "");
+      console.log("Change detected", path, relativePath);
+
+      // XXX: remove double slash that's coming back from worker:
+      path = path.replace('//', '/');
+
+      this.replaceCSS(window, path);
+    });
+  },
+};
