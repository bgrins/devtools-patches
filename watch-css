# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dd6702b8f640f868ad26b4ece5a5451a076ee5da
Watch the objdir for changed files and refresh them

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1269,16 +1269,17 @@ var gBrowserInit = {
     BrowserOnClick.init();
     FeedHandler.init();
     CompactTheme.init();
     AboutPrivateBrowsingListener.init();
     TrackingProtection.init();
     RefreshBlocker.init();
     CaptivePortalWatcher.init();
     FullZoomUI.init(window);
+    DevRefresher.init();
 
     let mm = window.getGroupMessageManager("browsers");
     mm.loadFrameScript("chrome://browser/content/tab-content.js", true);
     mm.loadFrameScript("chrome://browser/content/content.js", true);
     mm.loadFrameScript("chrome://browser/content/content-UITour.js", true);
     mm.loadFrameScript("chrome://global/content/manifestMessages.js", true);
 
     // initialize observers and listeners
@@ -8871,8 +8872,191 @@ TabModalPromptBox.prototype = {
   get browser() {
     let browser = this._weakBrowserRef.get();
     if (!browser) {
       throw "Stale promptbox! The associated browser is gone.";
     }
     return browser;
   },
 };
+
+var DevRefresher = {
+  resolveURIToLocalPath(aURI) {
+    let resolved;
+    switch (aURI.scheme) {
+      case "jar":
+      case "file":
+        return aURI;
+
+      case "chrome":
+        resolved = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                   getService(Ci.nsIChromeRegistry).convertChromeURL(aURI);
+        return this.resolveURIToLocalPath(resolved);
+
+      case "resource":
+        resolved = Cc["@mozilla.org/network/protocol;1?name=resource"].
+                   getService(Ci.nsIResProtocolHandler).resolveURI(aURI);
+        aURI = Services.io.newURI(resolved, null, null);
+        return this.resolveURIToLocalPath(aURI);
+
+      default:
+        return null;
+    }
+  },
+  getLocalPath(url) {
+    let uri = null;
+    let ios = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces["nsIIOService"]);
+    try {
+        uri = this.resolveURIToLocalPath(ios.newURI(url, "UTF-8", null));
+    } catch(e){}
+    return uri ? uri.spec : uri;
+  },
+
+  watchFiles(path, onFileChanged) {
+    const watchWorker = new ChromeWorker(
+      "resource://devtools/client/shared/file-watcher-worker.js"
+    );
+
+    watchWorker.onmessage = event => {
+      // We need to turn a local path back into a resource URI (or
+      // chrome). This means that this system will only work when built
+      // files are symlinked, so that these URIs actually read from
+      // local sources. There might be a better way to do this.
+      const { path: newPath } = event.data;
+      onFileChanged(newPath);
+    };
+
+    watchWorker.postMessage({
+      path,
+      fileRegex: /\.(js|css|svg|png)$/
+    });
+    return watchWorker;
+  },
+
+
+  iterStyleNodes(window, func) {
+    for (let node of window.document.childNodes) {
+      // Look for ProcessingInstruction nodes.
+      if (node.nodeType === 7) {
+        func(node);
+      }
+    }
+
+    const links = window.document.getElementsByTagNameNS(
+      "http://www.w3.org/1999/xhtml", "link"
+    );
+    for (let node of links) {
+      func(node);
+    }
+  },
+
+  replaceCSS(window, fileURI) {
+    const document = window.document;
+    const randomKey = Math.random();
+    console.log("Replacing", window, fileURI);
+    Services.obs.notifyObservers(null, "startupcache-invalidate");
+
+    // Scan every CSS tag and reload ones that match the file we are
+    // looking for.
+    this.iterStyleNodes(window, node => {
+      if (node.nodeType === 7) {
+        // xml-stylesheet declaration
+        // Convert a string like href="chrome://browser/content/browser.css" type="text/css" to:
+        // chrome://browser/content/browser.css, then convert it to a local path
+        let originalHref = node.data.match(/href=([^\s]*)/)[1].replace(/["']/g, '')
+        const path = this.getLocalPath(originalHref);
+        console.log("Looking into PI", path, fileURI, originalHref);
+        if (path && path.includes(fileURI)) {
+          // Special case chrome://browser/skin/ which does a redircet
+          if (originalHref == "chrome://browser/skin/") {
+            originalHref = "chrome://browser/skin/browser.css";
+          }
+          console.log("Got a replacement!", originalHref)
+          const newNode = window.document.createProcessingInstruction(
+            "xml-stylesheet",
+            `href="${originalHref}?s=${randomKey}" type="text/css"`
+          );
+          document.insertBefore(newNode, node);
+          document.removeChild(node);
+        }
+      } else {
+        const originalHref = node.href;
+        const path = this.getLocalPath(originalHref);
+        console.log("Looking into stylesheet", path, fileURI);
+        if (path && path.includes(fileURI)) {
+          const parentNode = node.parentNode;
+          const newNode = window.document.createElementNS(
+            "http://www.w3.org/1999/xhtml",
+            "link"
+          );
+          newNode.rel = "stylesheet";
+          newNode.type = "text/css";
+          newNode.href = originalHref + "?s=" + randomKey;
+
+          parentNode.insertBefore(newNode, node);
+          parentNode.removeChild(node);
+        }
+     }
+    });
+  },
+
+  _replaceResourceInSheet(sheet, filename, randomKey) {
+    for (let i = 0; i < sheet.cssRules.length; i++) {
+      const rule = sheet.cssRules[i];
+      if (rule.type === rule.IMPORT_RULE) {
+        this._replaceResourceInSheet(rule.styleSheet, filename);
+      } else if (rule.cssText.includes(filename)) {
+        // Strip off any existing query strings. This might lose
+        // updates for files if there are multiple resources
+        // referenced in the same rule, but the chances of someone hot
+        // reloading multiple resources in the same rule is very low.
+        const text = rule.cssText.replace(/\?s=0.\d+/g, "");
+        const newRule = (
+          text.replace(filename, filename + "?s=" + randomKey)
+        );
+
+        sheet.deleteRule(i);
+        sheet.insertRule(newRule, i);
+      }
+    }
+  },
+
+  replaceCSSResource(window, fileURI) {
+    const document = window.document;
+    const randomKey = Math.random();
+
+    // Only match the filename. False positives are much better than
+    // missing updates, as all that would happen is we reload more
+    // resources than we need. We do this because many resources only
+    // use relative paths.
+    const parts = fileURI.split("/");
+    const file = parts[parts.length - 1];
+
+    // Scan every single rule in the entire page for any reference to
+    // this resource, and re-insert the rule to force it to update.
+    for (let sheet of document.styleSheets) {
+      this._replaceResourceInSheet(sheet, file, randomKey);
+    }
+
+    for (let node of document.querySelectorAll("img,image")) {
+      if (node.src.startsWith(fileURI)) {
+        node.src = fileURI + "?s=" + randomKey;
+      }
+    }
+  },
+
+  init() {
+    const watchRoot = this.getLocalPath("resource://").replace(/file:\/\//, "");
+    console.log("Setting up watcher at", watchRoot);
+    this.worker = this.watchFiles(watchRoot, path => {
+      let relativePath = path.replace(watchRoot + "/", "");
+      console.log("Change detected", path, relativePath);
+
+      // XXX: remove double slash that's coming back from worker:
+      path = path.replace('//', '/');
+
+      this.replaceCSS(window, path);
+    });
+    // const searchPoint = OS.Path.dirname(OS.Path.dirname(devtoolsPath));
+    // console.log(this.getLocalPath("chrome://"));
+    // console.log(this.getLocalPath("chrome://browser/content/browser.css"));
+  },
+};
diff --git a/browser/themes/osx/browser.css b/browser/themes/osx/browser.css
--- a/browser/themes/osx/browser.css
+++ b/browser/themes/osx/browser.css
@@ -632,17 +632,17 @@ toolbarpaletteitem[place="palette"] > #p
 @conditionalForwardWithUrlbar@:-moz-locale-dir(rtl) {
   -moz-box-direction: reverse;
 }
 %endif
 
 %include ../shared/identity-block/identity-block.inc.css
 
 #identity-box {
-  padding-top: 2px;
+  padding-top: 10px;
   padding-bottom: 2px;
 }
 
 #urlbar:not([focused="true"]) > #identity-box {
   margin-top: -1px;
   margin-bottom: -1px;
   padding-top: 3px;
   padding-bottom: 3px;
@@ -1567,17 +1567,18 @@ toolbarbutton.chevron > .toolbarbutton-m
 #TabsToolbar:not(:-moz-lwtheme) {
   color: #333;
   text-shadow: @loweredShadow@;
 }
 
 %ifdef MOZ_PHOTON_THEME
 :root:-moz-any([inFullscreen], [tabsintitlebar]):not([customizing]) #TabsToolbar:not(:-moz-lwtheme) {
   -moz-appearance: none;
-  background-color: #232323;
+  background-color: orange;
+  padding: 10px;
   color: hsl(240, 9%, 98%);
   text-shadow: none;
 }
 %endif
 
 %ifndef MOZ_PHOTON_THEME
 #navigator-toolbox[inFullscreen] > #TabsToolbar {
   padding-top: var(--space-above-tabbar);
diff --git a/devtools/client/shared/file-watcher-worker.js b/devtools/client/shared/file-watcher-worker.js
--- a/devtools/client/shared/file-watcher-worker.js
+++ b/devtools/client/shared/file-watcher-worker.js
@@ -66,16 +66,17 @@ onmessage = function (event) {
     throw new Error("Watcher expects a directory as root path");
   }
 
   // We get a list of all the files upfront, which means we don't
   // support adding new files. But you need to rebuild Firefox when
   // adding a new file anyway.
   const files = gatherFiles(path, fileRegex || /.*/);
 
+  console.log("Got path", path, files);
   // Every second, scan for file changes by stat-ing each of them and
   // comparing modification time.
   setInterval(() => {
     scanFiles(files, changedFile => {
       postMessage({ path: changedFile });
     });
   }, 1000);
 };
