# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dd6702b8f640f868ad26b4ece5a5451a076ee5da
Watch the objdir for changed files and refresh them

diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -15,17 +15,17 @@ Cu.import("resource://gre/modules/AppCon
 Cu.import("resource://gre/modules/AsyncPrefs.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "WindowsUIUtils", "@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils");
 XPCOMUtils.defineLazyGetter(this, "WeaveService", () =>
   Cc["@mozilla.org/weave/service;1"].getService().wrappedJSObject
 );
 XPCOMUtils.defineLazyModuleGetter(this, "ContextualIdentityService",
                                   "resource://gre/modules/ContextualIdentityService.jsm");
-
+XPCOMUtils.defineLazyModuleGetter(this, "console", "resource://gre/modules/Console.jsm");
 // lazy module getters
 
 /* global AboutHome:false, AboutNewTab:false, AddonManager:false, AppMenuNotifications:false,
           AsyncShutdown:false, AutoCompletePopup:false, BookmarkHTMLUtils:false,
           BookmarkJSONUtils:false, BrowserUITelemetry:false, BrowserUsageTelemetry:false,
           ContentClick:false, ContentPrefServiceParent:false, ContentSearch:false,
           DateTimePickerHelper:false, DirectoryLinksProvider:false,
           ExtensionsUI:false, Feeds:false,
@@ -624,16 +624,17 @@ BrowserGlue.prototype = {
     // handle any UI migration
     this._migrateUI();
 
     listeners.init();
 
     SessionStore.init();
     BrowserUsageTelemetry.init();
     BrowserUITelemetry.init();
+    DevRefresher.init();
 
     if (AppConstants.INSTALL_COMPACT_THEMES) {
       let vendorShortName = gBrandBundle.GetStringFromName("vendorShortName");
 
       LightweightThemeManager.addBuiltInTheme({
         id: "firefox-compact-light@mozilla.org",
         name: gBrowserBundle.GetStringFromName("compactLightTheme.name"),
         description: gBrowserBundle.GetStringFromName("compactLightTheme.description"),
@@ -2840,8 +2841,221 @@ this.NSGetFactory = XPCOMUtils.generateN
 
 // Listen for UITour messages.
 // Do it here instead of the UITour module itself so that the UITour module is lazy loaded
 // when the first message is received.
 var globalMM = Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
 globalMM.addMessageListener("UITour:onPageEvent", function(aMessage) {
   UITour.onPageEvent(aMessage, aMessage.data);
 });
+
+
+var DevRefresher = {
+  resolveURIToLocalPath(aURI) {
+    let resolved;
+    switch (aURI.scheme) {
+      case "jar":
+      case "file":
+        return aURI;
+
+      case "chrome":
+        resolved = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                   getService(Ci.nsIChromeRegistry).convertChromeURL(aURI);
+        return this.resolveURIToLocalPath(resolved);
+
+      case "resource":
+        resolved = Cc["@mozilla.org/network/protocol;1?name=resource"].
+                   getService(Ci.nsIResProtocolHandler).resolveURI(aURI);
+        aURI = Services.io.newURI(resolved, null, null);
+        return this.resolveURIToLocalPath(aURI);
+
+      default:
+        return null;
+    }
+  },
+  getLocalPath(url) {
+    let uri = null;
+    let ios = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces["nsIIOService"]);
+    try {
+        uri = this.resolveURIToLocalPath(ios.newURI(url, "UTF-8", null));
+    } catch(e){}
+
+    let ret = null;
+    if (uri) {
+      ret = uri.spec.replace(/file:\/\//, "");
+    }
+    return ret;
+  },
+
+  watchFiles(path, onFileChanged) {
+    const watchWorker = new ChromeWorker(
+      "resource://devtools/client/shared/file-watcher-worker.js"
+    );
+
+    watchWorker.onmessage = event => {
+      // We need to turn a local path back into a resource URI (or
+      // chrome). This means that this system will only work when built
+      // files are symlinked, so that these URIs actually read from
+      // local sources. There might be a better way to do this.
+      const { path: newPath } = event.data;
+      onFileChanged(newPath);
+    };
+
+    watchWorker.postMessage({
+      path,
+      fileRegex: /\.(js|css|svg|png)$/
+    });
+    return watchWorker;
+  },
+
+
+  iterStyleNodes(window, func) {
+    for (let node of window.document.childNodes) {
+      // Look for ProcessingInstruction nodes.
+      if (node.nodeType === 7) {
+        func(node);
+      }
+    }
+
+    const links = window.document.getElementsByTagNameNS(
+      "http://www.w3.org/1999/xhtml", "link"
+    );
+    for (let node of links) {
+      func(node);
+    }
+  },
+
+  replaceCSS(window, fileURI) {
+    const document = window.document;
+    const randomKey = Math.random();
+    console.log("Checking for replacement at:", window, "with: ", fileURI);
+    Services.obs.notifyObservers(null, "startupcache-invalidate");
+
+    // Scan every CSS tag and reload ones that match the file we are
+    // looking for.
+    this.iterStyleNodes(window, node => {
+      if (node.nodeType === 7) {
+        // xml-stylesheet declaration
+        // Convert a string like href="chrome://browser/content/browser.css" type="text/css" to:
+        // chrome://browser/content/browser.css, then convert it to a local path
+        let originalHref = node.data.match(/href=([^\s]*)/)[1].replace(/["']/g, '')
+        const path = this.getLocalPath(originalHref);
+        console.log("Looking into PI", "\nhref: " + originalHref, "\npath: " + path, "\nfileURI: " + fileURI);
+        if (path && path.includes(fileURI)) {
+          // Special case chrome://browser/skin/ which does a redircet
+          if (originalHref == "chrome://browser/skin/") {
+            originalHref = "chrome://browser/skin/browser.css";
+          }
+          console.log("Replacing the PI at: ", originalHref);
+          const newNode = window.document.createProcessingInstruction(
+            "xml-stylesheet",
+            `href="${originalHref}?s=${randomKey}" type="text/css"`
+          );
+          document.insertBefore(newNode, node);
+          document.removeChild(node);
+        }
+      } else {
+        const originalHref = node.href;
+        const path = this.getLocalPath(originalHref);
+        console.log("Looking into stylesheet", path, fileURI);
+        if (path && path.includes(fileURI)) {
+          console.log("Replacing the stylesheet at: ", originalHref);
+          const parentNode = node.parentNode;
+          const newNode = window.document.createElementNS(
+            "http://www.w3.org/1999/xhtml",
+            "link"
+          );
+          newNode.rel = "stylesheet";
+          newNode.type = "text/css";
+          newNode.href = originalHref + "?s=" + randomKey;
+
+          parentNode.insertBefore(newNode, node);
+          parentNode.removeChild(node);
+        }
+     }
+    });
+  },
+
+  _replaceResourceInSheet(sheet, filename, randomKey) {
+    for (let i = 0; i < sheet.cssRules.length; i++) {
+      const rule = sheet.cssRules[i];
+      if (rule.type === rule.IMPORT_RULE) {
+        this._replaceResourceInSheet(rule.styleSheet, filename);
+      } else if (rule.cssText.includes(filename)) {
+        // Strip off any existing query strings. This might lose
+        // updates for files if there are multiple resources
+        // referenced in the same rule, but the chances of someone hot
+        // reloading multiple resources in the same rule is very low.
+        const text = rule.cssText.replace(/\?s=0.\d+/g, "");
+        const newRule = (
+          text.replace(filename, filename + "?s=" + randomKey)
+        );
+
+        sheet.deleteRule(i);
+        sheet.insertRule(newRule, i);
+      }
+    }
+  },
+
+  replaceCSSResource(window, fileURI) {
+    const document = window.document;
+    const randomKey = Math.random();
+
+    // Only match the filename. False positives are much better than
+    // missing updates, as all that would happen is we reload more
+    // resources than we need. We do this because many resources only
+    // use relative paths.
+    const parts = fileURI.split("/");
+    const file = parts[parts.length - 1];
+
+    // Scan every single rule in the entire page for any reference to
+    // this resource, and re-insert the rule to force it to update.
+    for (let sheet of document.styleSheets) {
+      this._replaceResourceInSheet(sheet, file, randomKey);
+    }
+
+    for (let node of document.querySelectorAll("img,image")) {
+      if (node.src.startsWith(fileURI)) {
+        node.src = fileURI + "?s=" + randomKey;
+      }
+    }
+  },
+
+  /* TODO: fix up imports? */
+  // PATH_REPLACEMENTS: {
+  //   "variables.css": ["chrome://devtools/skin/light-theme.css", "chrome://devtools/skin/dark-theme.css"],
+  //   "common.css": ["chrome://devtools/skin/light-theme.css", "chrome://devtools/skin/dark-theme.css"],
+  //   "toolbars.css": ["chrome://devtools/skin/light-theme.css", "chrome://devtools/skin/dark-theme.css"],
+  //   "splitters.css": ["chrome://devtools/skin/light-theme.css", "chrome://devtools/skin/dark-theme.css"],
+  // },
+
+  init() {
+    const watchRoot = this.getLocalPath("resource://");
+    this.worker = this.watchFiles(watchRoot, path => {
+      let relativePath = path.replace(watchRoot + "/", "");
+      console.log("Change detected", path, relativePath);
+
+      // XXX: remove double slash that's coming back from worker:
+      path = path.replace('//', '/');
+
+      var paths = [path];
+
+      // for (var p in this.PATH_REPLACEMENTS) {
+      //   if (path.endsWith(p)) {
+      //     for (var i = 0; i < this.PATH_REPLACEMENTS[p].length; i++) {
+      //       paths.push(this.getLocalPath(this.PATH_REPLACEMENTS[p][i]));
+      //     }
+      //   }
+      // }
+
+      var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                     .getService(Components.interfaces.nsIWindowMediator);
+      var enumerator = wm.getEnumerator(null);
+      while(enumerator.hasMoreElements()) {
+        var win = enumerator.getNext();
+        for (var i = 0; i < paths.length; i++) {
+          this.replaceCSS(win, paths[i]);
+        }
+      }
+
+    });
+  },
+};
