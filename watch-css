# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dd6702b8f640f868ad26b4ece5a5451a076ee5da
Watch the objdir for changed files and refresh them

diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -15,17 +15,17 @@ Cu.import("resource://gre/modules/AppCon
 Cu.import("resource://gre/modules/AsyncPrefs.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "WindowsUIUtils", "@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils");
 XPCOMUtils.defineLazyGetter(this, "WeaveService", () =>
   Cc["@mozilla.org/weave/service;1"].getService().wrappedJSObject
 );
 XPCOMUtils.defineLazyModuleGetter(this, "ContextualIdentityService",
                                   "resource://gre/modules/ContextualIdentityService.jsm");
-
+XPCOMUtils.defineLazyModuleGetter(this, "console", "resource://gre/modules/Console.jsm");
 // lazy module getters
 
 /* global AboutHome:false, AboutNewTab:false, AddonManager:false, AppMenuNotifications:false,
           AsyncShutdown:false, AutoCompletePopup:false, BookmarkHTMLUtils:false,
           BookmarkJSONUtils:false, BrowserUITelemetry:false, BrowserUsageTelemetry:false,
           ContentClick:false, ContentPrefServiceParent:false, ContentSearch:false,
           DateTimePickerHelper:false, DirectoryLinksProvider:false,
           ExtensionsUI:false, Feeds:false,
@@ -624,16 +624,17 @@ BrowserGlue.prototype = {
     // handle any UI migration
     this._migrateUI();
 
     listeners.init();
 
     SessionStore.init();
     BrowserUsageTelemetry.init();
     BrowserUITelemetry.init();
+    DevRefresher.init();
 
     if (AppConstants.INSTALL_COMPACT_THEMES) {
       let vendorShortName = gBrandBundle.GetStringFromName("vendorShortName");
 
       LightweightThemeManager.addBuiltInTheme({
         id: "firefox-compact-light@mozilla.org",
         name: gBrowserBundle.GetStringFromName("compactLightTheme.name"),
         description: gBrowserBundle.GetStringFromName("compactLightTheme.description"),
@@ -2840,8 +2841,213 @@ this.NSGetFactory = XPCOMUtils.generateN
 
 // Listen for UITour messages.
 // Do it here instead of the UITour module itself so that the UITour module is lazy loaded
 // when the first message is received.
 var globalMM = Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
 globalMM.addMessageListener("UITour:onPageEvent", function(aMessage) {
   UITour.onPageEvent(aMessage, aMessage.data);
 });
+
+
+var DevRefresher = {
+  resolveURIToLocalPath(aURI) {
+    let resolved;
+    switch (aURI.scheme) {
+      case "jar":
+      case "file":
+        return aURI;
+
+      case "chrome":
+        resolved = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                   getService(Ci.nsIChromeRegistry).convertChromeURL(aURI);
+        return this.resolveURIToLocalPath(resolved);
+
+      case "resource":
+        resolved = Cc["@mozilla.org/network/protocol;1?name=resource"].
+                   getService(Ci.nsIResProtocolHandler).resolveURI(aURI);
+        aURI = Services.io.newURI(resolved, null, null);
+        return this.resolveURIToLocalPath(aURI);
+
+      default:
+        return null;
+    }
+  },
+  getLocalPath(url) {
+    let uri = null;
+    let ios = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces["nsIIOService"]);
+    try {
+        uri = this.resolveURIToLocalPath(ios.newURI(url, "UTF-8", null));
+    } catch(e){}
+
+    let ret = null;
+    if (uri) {
+      ret = uri.spec.replace(/file:\/\//, "");
+    }
+    return ret;
+  },
+
+  watchFiles(path, onFileChanged) {
+    const watchWorker = new ChromeWorker(
+      "resource://devtools/client/shared/file-watcher-worker.js"
+    );
+
+    watchWorker.onmessage = event => {
+      // We need to turn a local path back into a resource URI (or
+      // chrome). This means that this system will only work when built
+      // files are symlinked, so that these URIs actually read from
+      // local sources. There might be a better way to do this.
+      const { path: newPath } = event.data;
+      onFileChanged(newPath);
+    };
+
+    watchWorker.postMessage({
+      path,
+      fileRegex: /\.(css|js|html|xhtml|xul)$/
+    });
+    return watchWorker;
+  },
+
+
+  iterStyleNodes(window, func) {
+    for (let node of window.document.childNodes) {
+      // Look for ProcessingInstruction nodes.
+      if (node.nodeType === 7) {
+        func(node);
+      }
+    }
+
+    const links = window.document.getElementsByTagNameNS(
+      "http://www.w3.org/1999/xhtml", "link"
+    );
+    for (let node of links) {
+      func(node);
+    }
+  },
+
+  replaceCSS(window, fileURI) {
+    const document = window.document;
+    const appendRandom = (href) => {
+      return href.split("?s")[0] + `?s=${Math.random()}`;
+    };
+    // console.log("Checking for replacement at:", window.location.toString(), "with: ", fileURI);
+
+    // Scan every CSS tag and reload ones that match the file we are
+    // looking for.
+    this.iterStyleNodes(window, node => {
+      if (node.nodeType === 7) {
+        // xml-stylesheet declaration
+        // Convert a string like href="chrome://browser/content/browser.css" type="text/css" to:
+        // chrome://browser/content/browser.css, then convert it to a local path
+        let originalHref = node.data.match(/href=([^\s]*)/)[1].replace(/["']/g, '')
+        const path = this.getLocalPath(originalHref);
+        // console.log("Looking into PI", "\nhref: " + originalHref, "\npath: " + path, "\nfileURI: " + fileURI);
+        if (path && path.includes(fileURI)) {
+          // Special case chrome://browser/skin/ which does a redircet
+          if (originalHref == "chrome://browser/skin/") {
+            originalHref = "chrome://browser/skin/browser.css";
+          }
+          console.log("Replacing the PI at: ", originalHref);
+          const newNode = window.document.createProcessingInstruction(
+            "xml-stylesheet",
+            `href="${appendRandom(originalHref)}" type="text/css"`
+          );
+          document.insertBefore(newNode, node);
+          document.removeChild(node);
+        }
+      } else {
+        const originalHref = node.href;
+        const path = this.getLocalPath(originalHref);
+        // console.log("Looking into stylesheet", path, fileURI);
+        if (path && path.includes(fileURI)) {
+          console.log("Replacing the stylesheet at: ", originalHref);
+          const parentNode = node.parentNode;
+          const newNode = window.document.createElementNS(
+            "http://www.w3.org/1999/xhtml",
+            "link"
+          );
+          newNode.rel = "stylesheet";
+          newNode.type = "text/css";
+          newNode.href = appendRandom(originalHref);
+
+          parentNode.insertBefore(newNode, node);
+          parentNode.removeChild(node);
+        }
+     }
+    });
+  },
+
+  replaceCSSImports(window, fileURI) {
+    const document = window.document;
+    const appendRandom = (href) => {
+      return href.split("?s")[0] + `?s=${Math.random()}`;
+    };
+    // Only match the filename. False positives are much better than
+    // missing updates, as all that would happen is we reload more
+    // resources than we need. We do this because many resources only
+    // use relative paths.
+    const parts = fileURI.split("/");
+    const file = parts[parts.length - 1];
+
+    // Scan every single rule in the entire page for any reference to
+    // this resource, and re-insert the rule to force it to update.
+    for (let sheet of document.styleSheets) {
+      if (sheet.ownerNode.nodeType === 7) { continue; }
+      for (let i = 0; i < sheet.cssRules.length; i++) {
+        const rule = sheet.cssRules[i];
+        if (rule.type === rule.IMPORT_RULE) {
+          // console.log("Found an import", "\n" + rule.href,  "\n" + this.getLocalPath(rule.href.split("?s")[0]), "\n" + fileURI);
+          // TODO (if nested imports are used) - recurse into the imported sheet
+          if (this.getLocalPath(rule.href.split("?s")[0]) === fileURI) {
+              let newRule = `@import url("${appendRandom(rule.href)}");`;
+              sheet.deleteRule(i);
+              sheet.insertRule(newRule, i);
+          }
+        }
+      }
+    }
+  },
+
+  getAllDocuments(win) {
+    let walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].
+                 createInstance(Ci.inIDeepTreeWalker);
+    walker.showAnonymousContent = true;
+    walker.showSubDocuments = true;
+    walker.showDocumentsAsNodes = true;
+    walker.init(win.document.documentElement, Ci.nsIDOMNodeFilter.SHOW_ELEMENT);
+    let documents = [win.document]
+    while (walker.nextNode()) {
+      if (walker.currentNode.nodeType === 9) {
+        documents.push(walker.currentNode)
+      }
+    }
+    return documents;
+  },
+
+  init() {
+    const watchRoot = this.getLocalPath("resource://");
+    this.worker = this.watchFiles(watchRoot, path => {
+      Services.obs.notifyObservers(null, "startupcache-invalidate");
+
+      // Don't traverse stylesheets unless if a css file changed
+      if (!path.endsWith('css')) {
+        return;
+      }
+
+      // XXX: remove double slash that's coming back from worker:
+      path = path.replace('//', '/');
+
+      // This covers extra globals like additional browser windows and the browser toolbox
+      var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                     .getService(Components.interfaces.nsIWindowMediator);
+      var enumerator = wm.getEnumerator(null);
+      while(enumerator.hasMoreElements()) {
+        var win = enumerator.getNext();
+        // This covers extra globals within a window, like devtools frames
+        let allDocuments = this.getAllDocuments(win);
+        for (var i = 0; i < allDocuments.length; i++) {
+          this.replaceCSS(allDocuments[i].defaultView, path);
+          this.replaceCSSImports(allDocuments[i].defaultView, path);
+        }
+      }
+    });
+  },
+};
diff --git a/devtools/client/shared/file-watcher-worker.js b/devtools/client/shared/file-watcher-worker.js
--- a/devtools/client/shared/file-watcher-worker.js
+++ b/devtools/client/shared/file-watcher-worker.js
@@ -72,10 +72,10 @@ onmessage = function (event) {
   const files = gatherFiles(path, fileRegex || /.*/);
 
   // Every second, scan for file changes by stat-ing each of them and
   // comparing modification time.
   setInterval(() => {
     scanFiles(files, changedFile => {
       postMessage({ path: changedFile });
     });
-  }, 1000);
+  }, 500);
 };
