# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b7f409bd51c8ae7260c1675785c698a9cb061244
browser_findbar.js intermittent investigation

diff --git a/testing/mochitest/tests/SimpleTest/EventUtils.js b/testing/mochitest/tests/SimpleTest/EventUtils.js
--- a/testing/mochitest/tests/SimpleTest/EventUtils.js
+++ b/testing/mochitest/tests/SimpleTest/EventUtils.js
@@ -979,17 +979,19 @@ function synthesizeAndWaitKey(aKey, aEve
   let keyRegisteredPromise = new Promise(resolve => {
     mm.addMessageListener("Test:KeyRegistered", function processed(message) {
       mm.removeMessageListener("Test:KeyRegistered", processed);
       resolve();
     });
   });
   let keyReceivedPromise = ContentTask.spawn(browser, keyCode, (keyCode) => {
     return new Promise(resolve => {
+      console.log("keyReceivedPromise setup", keyCode);
       addEventListener("keyup", function onKeyEvent(e) {
+        console.log("keyReceivedPromise setup", e.keyCode, keyCode);
         if (e.keyCode == keyCode) {
           removeEventListener("keyup", onKeyEvent);
           resolve();
         }
       });
       sendAsyncMessage("Test:KeyRegistered");
     });
   });
diff --git a/toolkit/content/tests/browser/browser_findbar.js b/toolkit/content/tests/browser/browser_findbar.js
--- a/toolkit/content/tests/browser/browser_findbar.js
+++ b/toolkit/content/tests/browser/browser_findbar.js
@@ -1,11 +1,13 @@
 /* eslint-disable mozilla/no-arbitrary-setTimeout */
 ChromeUtils.import("resource://gre/modules/Timer.jsm", this);
 
+SimpleTest.requestCompleteLog();
+
 const TEST_PAGE_URI = "data:text/html;charset=utf-8,The letter s.";
 // Using 'javascript' schema to bypass E10SUtils.canLoadURIInProcess, because
 // it does not allow 'data:' URI to be loaded in the parent process.
 const E10S_PARENT_TEST_PAGE_URI = "javascript:document.write('The letter s.');";
 
 /**
  * Makes sure that the findbar hotkeys (' and /) event listeners
  * are added to the system event group and do not get blocked
@@ -31,19 +33,19 @@ add_task(async function test_hotkey_even
     is(findbar.hidden, false, "Findbar should not be hidden.");
     await closeFindbarAndWait(findbar);
   }
 
   // Stop propagation for all keyboard events.
   let frameScript = () => {
     const stopPropagation = e => e.stopImmediatePropagation();
     let window = content.document.defaultView;
-    window.removeEventListener("keydown", stopPropagation);
-    window.removeEventListener("keypress", stopPropagation);
-    window.removeEventListener("keyup", stopPropagation);
+    window.addEventListener("keydown", stopPropagation);
+    window.addEventListener("keypress", stopPropagation);
+    window.addEventListener("keyup", stopPropagation);
   };
 
   let mm = browser.messageManager;
   mm.loadFrameScript("data:,(" + frameScript.toString() + ")();", false);
 
   // Checking if findbar still appears when any hotkey is pressed.
   for (let key of HOTKEYS) {
     is(findbar.hidden, true, "Findbar is hidden now.");
@@ -171,29 +173,36 @@ add_task(async function e10sLostKeys() {
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, TEST_PAGE_URI);
 
   ok(!gFindBarInitialized, "findbar isn't initialized yet");
 
   await gFindBarPromise;
   let findBar = gFindBar;
   let initialValue = findBar._findField.value;
 
+  console.log("XXXXX0:", findBar._findField.value);
+
   await EventUtils.synthesizeAndWaitKey("f", { accelKey: true }, window, null, () => {
     // We can't afford to wait for the promise to resolve, by then the
     // find bar is visible and focused, so sending characters to the
     // content browser wouldn't work.
     isnot(document.activeElement, findBar._findField.inputField,
       "findbar is not yet focused");
+    console.log("Active element: ", document.activeElement, document.activeElement.outerHTML);
     EventUtils.synthesizeKey("a");
     EventUtils.synthesizeKey("b");
     EventUtils.synthesizeKey("c");
     is(findBar._findField.value, initialValue, "still has initial find query");
   });
 
+  console.log("XXXXX1:", findBar._findField.value, "initial: ", initialValue);
+
   await BrowserTestUtils.waitForCondition(() => findBar._findField.value.length == 3);
+  console.log("XXXXX2:", findBar._findField.value, "initial: ", initialValue);
+
   is(document.activeElement, findBar._findField.inputField,
     "findbar is now focused");
   is(findBar._findField.value, "abc", "abc fully entered as find query");
 
   BrowserTestUtils.removeTab(tab);
 });
 
 function promiseFindFinished(searchText, highlightOn) {
diff --git a/toolkit/content/widgets/findbar.js b/toolkit/content/widgets/findbar.js
--- a/toolkit/content/widgets/findbar.js
+++ b/toolkit/content/widgets/findbar.js
@@ -173,27 +173,30 @@ class MozFindbar extends XULElement {
     this._findSelection = this.nsISelectionController.SELECTION_FIND;
 
     this._findResetTimeout = -1;
 
     // Make sure the FAYT keypress listener is attached by initializing the
     // browser property
     if (this.getAttribute("browserid")) {
       // eslint-disable-next-line no-self-assign
-      setTimeout(function(aSelf) { aSelf.browser = aSelf.browser; }, 0, this);
+      this.browser = this.browser;
+      console.log("Setting browser");
+      setTimeout(function(aSelf) { /*aSelf.browser = aSelf.browser;*/ console.log("Would be setting browser now"); }, 0, this);
     }
 
     window.addEventListener("unload", this.destroy);
 
     this._findField.addEventListener("input", (event) => {
       // We should do nothing during composition.  E.g., composing string
       // before converting may matches a forward word of expected word.
       // After that, even if user converts the composition string to the
       // expected word, it may find second or later searching word in the
       // document.
+      console.log("Received input", this._isIMEComposing, this._findField.value);
       if (this._isIMEComposing) {
         return;
       }
 
       const value = this._findField.value;
       if (this._hadValue && !value) {
         this._willfullyDeleted = true;
         this._hadValue = false;
@@ -332,16 +335,18 @@ class MozFindbar extends XULElement {
         this._browser.messageManager.removeMessageListener("Findbar:Mouseup", this);
       }
       let finder = this._browser.finder;
       if (finder)
         finder.removeResultListener(this);
     }
 
     this._browser = val;
+    console.log("Browser setter", this._browser, this._browser && this._browser._lastSearchString);
+    console.trace();
     if (this._browser) {
       // Need to do this to ensure the correct initial state.
       this._updateBrowserWithState();
       this._browser.messageManager.addMessageListener("Findbar:Keypress", this);
       this._browser.messageManager.addMessageListener("Findbar:Mouseup", this);
       this._browser.finder.addResultListener(this);
 
       this._findField.value = this._browser._lastSearchString;
@@ -780,16 +785,17 @@ class MozFindbar extends XULElement {
         this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
     }
   }
 
   /**
    * See MessageListener
    */
   receiveMessage(aMessage) {
+    console.log("receiveMessage", aMessage.target != this._browser, aMessage.name);
     if (aMessage.target != this._browser) {
       return undefined;
     }
     switch (aMessage.name) {
       case "Findbar:Mouseup":
         if (!this.hidden && this._findMode != this.FIND_NORMAL)
           this.close();
         break;
@@ -802,16 +808,18 @@ class MozFindbar extends XULElement {
 
   _updateBrowserWithState() {
     if (this._browser && this._browser.messageManager) {
       this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", {
         findMode: this._findMode,
         isOpenAndFocused: !this.hidden && document.activeElement == this._findField.inputField,
         hasQuickFindTimeout: !!this._quickFindTimeout,
       });
+      // console.trace();
+      console.log("_updateBrowserWithState", this._findMode, (!this.hidden && document.activeElement == this._findField.inputField), !!this._quickFindTimeout);
     }
   }
 
   _enableFindButtons(aEnable) {
     this.getElement("find-next").disabled =
       this.getElement("find-previous").disabled = !aEnable;
   }
 
@@ -1073,16 +1081,17 @@ class MozFindbar extends XULElement {
 
   _onFindFieldFocus() {
     let prefsvc = this._prefsvc;
     const kPref = "accessibility.typeaheadfind.prefillwithselection";
     if (this.prefillWithSelection && prefsvc.getBoolPref(kPref))
       return;
 
     let clipboardSearchString = this._browser.finder.clipboardSearchString;
+    console.log("_onFindFieldFocus", this._findField.value, this._findField._willfullyDeleted);
     if (clipboardSearchString && this._findField.value != clipboardSearchString &&
         !this._findField._willfullyDeleted) {
       this._findField.value = clipboardSearchString;
       this._findField._hadValue = true;
       // Changing the search string makes the previous status invalid, so
       // we better clear it here.
       this._updateStatusUI();
     }
