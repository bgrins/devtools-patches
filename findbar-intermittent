# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b7f409bd51c8ae7260c1675785c698a9cb061244
browser_findbar.js intermittent investigation

diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -4252,16 +4252,17 @@ window._gBrowser = {
           updateUserContextUIIndicator();
         }
 
         break;
       }
       case "Findbar:Keypress":
       {
         let tab = this.getTabForBrowser(browser);
+        console.log("Findbar:Keypress received from tabbrowser", this.isFindBarInitialized(tab), data);
         if (!this.isFindBarInitialized(tab)) {
           let fakeEvent = data;
           this.getFindBar(tab).then(findbar => {
             findbar._onBrowserKeypress(fakeEvent);
           });
         }
         break;
       }
diff --git a/testing/mochitest/tests/SimpleTest/EventUtils.js b/testing/mochitest/tests/SimpleTest/EventUtils.js
--- a/testing/mochitest/tests/SimpleTest/EventUtils.js
+++ b/testing/mochitest/tests/SimpleTest/EventUtils.js
@@ -989,24 +989,28 @@ function synthesizeAndWaitKey(aKey, aEve
           removeEventListener("keyup", onKeyEvent);
           resolve();
         }
       });
       sendAsyncMessage("Test:KeyRegistered");
     });
   });
   keyRegisteredPromise.then(() => {
+    console.log("keyRegisteredPromise resolved");
     if (checkBeforeSynthesize) {
       checkBeforeSynthesize();
     }
     synthesizeKey(aKey, aEvent, aWindow);
     if (checkAfterSynthesize) {
       checkAfterSynthesize();
     }
   });
+  keyReceivedPromise.then(() => {
+    console.log("keyReceivedPromise resolved");
+  })
   return keyReceivedPromise;
 }
 
 function _parseNativeModifiers(aModifiers, aWindow = window)
 {
   var navigator = _getNavigator(aWindow);
   var modifiers;
   if (aModifiers.capsLockKey) {
diff --git a/toolkit/content/tests/browser/browser_findbar.js b/toolkit/content/tests/browser/browser_findbar.js
--- a/toolkit/content/tests/browser/browser_findbar.js
+++ b/toolkit/content/tests/browser/browser_findbar.js
@@ -1,11 +1,13 @@
 /* eslint-disable mozilla/no-arbitrary-setTimeout */
 ChromeUtils.import("resource://gre/modules/Timer.jsm", this);
 
+SimpleTest.requestCompleteLog();
+
 const TEST_PAGE_URI = "data:text/html;charset=utf-8,The letter s.";
 // Using 'javascript' schema to bypass E10SUtils.canLoadURIInProcess, because
 // it does not allow 'data:' URI to be loaded in the parent process.
 const E10S_PARENT_TEST_PAGE_URI = "javascript:document.write('The letter s.');";
 
 /**
  * Makes sure that the findbar hotkeys (' and /) event listeners
  * are added to the system event group and do not get blocked
@@ -31,19 +33,19 @@ add_task(async function test_hotkey_even
     is(findbar.hidden, false, "Findbar should not be hidden.");
     await closeFindbarAndWait(findbar);
   }
 
   // Stop propagation for all keyboard events.
   let frameScript = () => {
     const stopPropagation = e => e.stopImmediatePropagation();
     let window = content.document.defaultView;
-    window.removeEventListener("keydown", stopPropagation);
-    window.removeEventListener("keypress", stopPropagation);
-    window.removeEventListener("keyup", stopPropagation);
+    window.addEventListener("keydown", stopPropagation);
+    window.addEventListener("keypress", stopPropagation);
+    window.addEventListener("keyup", stopPropagation);
   };
 
   let mm = browser.messageManager;
   mm.loadFrameScript("data:,(" + frameScript.toString() + ")();", false);
 
   // Checking if findbar still appears when any hotkey is pressed.
   for (let key of HOTKEYS) {
     is(findbar.hidden, true, "Findbar is hidden now.");
@@ -171,29 +173,37 @@ add_task(async function e10sLostKeys() {
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, TEST_PAGE_URI);
 
   ok(!gFindBarInitialized, "findbar isn't initialized yet");
 
   await gFindBarPromise;
   let findBar = gFindBar;
   let initialValue = findBar._findField.value;
 
+  console.log("XXXXX0:", findBar._findField.value);
+
   await EventUtils.synthesizeAndWaitKey("f", { accelKey: true }, window, null, () => {
     // We can't afford to wait for the promise to resolve, by then the
     // find bar is visible and focused, so sending characters to the
     // content browser wouldn't work.
     isnot(document.activeElement, findBar._findField.inputField,
       "findbar is not yet focused");
+    console.log("Active element: ", document.activeElement, document.activeElement.outerHTML);
     EventUtils.synthesizeKey("a");
     EventUtils.synthesizeKey("b");
     EventUtils.synthesizeKey("c");
     is(findBar._findField.value, initialValue, "still has initial find query");
   });
 
+  console.log("XXXXX1:", findBar._findField.value, "initial: ", initialValue);
+
+  is(document.activeElement, findBar._findField.inputField, "findbar is now focused");
   await BrowserTestUtils.waitForCondition(() => findBar._findField.value.length == 3);
+  console.log("XXXXX2:", findBar._findField.value, "initial: ", initialValue);
+
   is(document.activeElement, findBar._findField.inputField,
     "findbar is now focused");
   is(findBar._findField.value, "abc", "abc fully entered as find query");
 
   BrowserTestUtils.removeTab(tab);
 });
 
 function promiseFindFinished(searchText, highlightOn) {
diff --git a/toolkit/content/widgets/findbar.js b/toolkit/content/widgets/findbar.js
--- a/toolkit/content/widgets/findbar.js
+++ b/toolkit/content/widgets/findbar.js
@@ -173,27 +173,30 @@ class MozFindbar extends XULElement {
     this._findSelection = this.nsISelectionController.SELECTION_FIND;
 
     this._findResetTimeout = -1;
 
     // Make sure the FAYT keypress listener is attached by initializing the
     // browser property
     if (this.getAttribute("browserid")) {
       // eslint-disable-next-line no-self-assign
-      setTimeout(function(aSelf) { aSelf.browser = aSelf.browser; }, 0, this);
+      this.browser = this.browser;
+      console.log("Setting browser");
+      setTimeout(function(aSelf) { /*aSelf.browser = aSelf.browser;*/ console.log("Would be setting browser now"); }, 0, this);
     }
 
     window.addEventListener("unload", this.destroy);
 
     this._findField.addEventListener("input", (event) => {
       // We should do nothing during composition.  E.g., composing string
       // before converting may matches a forward word of expected word.
       // After that, even if user converts the composition string to the
       // expected word, it may find second or later searching word in the
       // document.
+      console.log("Received input", this._findField.value);
       if (this._isIMEComposing) {
         return;
       }
 
       const value = this._findField.value;
       if (this._hadValue && !value) {
         this._willfullyDeleted = true;
         this._hadValue = false;
@@ -248,20 +251,23 @@ class MozFindbar extends XULElement {
 
     this._findField.addEventListener("blur", (event) => {
       // Note: This code used to remove the selection
       // if it matched an editable.
       this.browser.finder.enableSelection();
     });
 
     this._findField.addEventListener("focus", (event) => {
-      if (/Mac/.test(navigator.platform)) {
-        this._onFindFieldFocus();
-      }
-      this._updateBrowserWithState();
+      setTimeout(() => {
+        if (this._destroyed) {return;}
+        if (/Mac/.test(navigator.platform)) {
+          this._onFindFieldFocus();
+        }
+        this._updateBrowserWithState();
+      }, 1000);
     });
 
     this._findField.addEventListener("compositionstart", (event) => {
       // Don't close the find toolbar while IME is composing.
       let findbar = this;
       findbar._isIMEComposing = true;
       if (findbar._quickFindTimeout) {
         clearTimeout(findbar._quickFindTimeout);
@@ -323,25 +329,28 @@ class MozFindbar extends XULElement {
       return !!(tm.numberOfUndoItems || tm.numberOfRedoItems);
     }
     return false;
   }
 
   set browser(val) {
     if (this._browser) {
       if (this._browser.messageManager) {
+        console.log("Removing message listeners");
         this._browser.messageManager.removeMessageListener("Findbar:Keypress", this);
         this._browser.messageManager.removeMessageListener("Findbar:Mouseup", this);
       }
       let finder = this._browser.finder;
       if (finder)
         finder.removeResultListener(this);
     }
 
     this._browser = val;
+    console.log("Browser setter", this._browser, this._browser && this._browser._lastSearchString);
+    console.trace();
     if (this._browser) {
       // Need to do this to ensure the correct initial state.
       this._updateBrowserWithState();
       this._browser.messageManager.addMessageListener("Findbar:Keypress", this);
       this._browser.messageManager.addMessageListener("Findbar:Mouseup", this);
       this._browser.finder.addResultListener(this);
 
       this._findField.value = this._browser._lastSearchString;
@@ -780,16 +789,17 @@ class MozFindbar extends XULElement {
         this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
     }
   }
 
   /**
    * See MessageListener
    */
   receiveMessage(aMessage) {
+    console.log("receiveMessage", aMessage.target != this._browser, aMessage.name, aMessage.data);
     if (aMessage.target != this._browser) {
       return undefined;
     }
     switch (aMessage.name) {
       case "Findbar:Mouseup":
         if (!this.hidden && this._findMode != this.FIND_NORMAL)
           this.close();
         break;
@@ -802,16 +812,20 @@ class MozFindbar extends XULElement {
 
   _updateBrowserWithState() {
     if (this._browser && this._browser.messageManager) {
       this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", {
         findMode: this._findMode,
         isOpenAndFocused: !this.hidden && document.activeElement == this._findField.inputField,
         hasQuickFindTimeout: !!this._quickFindTimeout,
       });
+      console.log("_updateBrowserWithState", this._findMode, (!this.hidden && document.activeElement == this._findField.inputField), !!this._quickFindTimeout);
+      console.trace();
+    } else {
+      console.log("Null brwoser _updateBrowserWithState", this._browser);
     }
   }
 
   _enableFindButtons(aEnable) {
     this.getElement("find-next").disabled =
       this.getElement("find-previous").disabled = !aEnable;
   }
 
@@ -1073,16 +1087,17 @@ class MozFindbar extends XULElement {
 
   _onFindFieldFocus() {
     let prefsvc = this._prefsvc;
     const kPref = "accessibility.typeaheadfind.prefillwithselection";
     if (this.prefillWithSelection && prefsvc.getBoolPref(kPref))
       return;
 
     let clipboardSearchString = this._browser.finder.clipboardSearchString;
+    console.log("_onFindFieldFocus", this._findField.value, this._findField._willfullyDeleted);
     if (clipboardSearchString && this._findField.value != clipboardSearchString &&
         !this._findField._willfullyDeleted) {
       this._findField.value = clipboardSearchString;
       this._findField._hadValue = true;
       // Changing the search string makes the previous status invalid, so
       // we better clear it here.
       this._updateStatusUI();
     }
diff --git a/toolkit/modules/FindBarContent.jsm b/toolkit/modules/FindBarContent.jsm
--- a/toolkit/modules/FindBarContent.jsm
+++ b/toolkit/modules/FindBarContent.jsm
@@ -46,16 +46,17 @@ class FindBarContent {
   }
 
   receiveMessage(msg) {
     switch (msg.name) {
       case "Findbar:UpdateState":
         this.findMode = msg.data.findMode;
         this.inQuickFind = msg.data.hasQuickFindTimeout;
         if (msg.data.isOpenAndFocused) {
+          console.log("Changing inpassthrough to false");
           this.inPassThrough = false;
         }
         break;
     }
   }
 
   handleEvent(event) {
     switch (event.type) {
@@ -64,24 +65,27 @@ class FindBarContent {
         break;
       case "mouseup":
         this.onMouseup(event);
         break;
     }
   }
 
   onKeypress(event) {
+    console.log("onKeyPress", event.keyCode);
     if (this.inPassThrough) {
       this.passKeyToParent(event);
     } else if (this.findMode != FIND_NORMAL && this.inQuickFind && event.charCode) {
       this.passKeyToParent(event);
     }
   }
 
   passKeyToParent(event) {
+    console.log("passKeyToParent called");
+    console.trace();
     event.preventDefault();
     // These are the properties required to dispatch another 'real' event
     // to the findbar in the parent in _dispatchKeypressEvent in findbar.xml .
     // If you make changes here, verify that that method can still do its job.
     const kRequiredProps = [
       "type", "bubbles", "cancelable", "ctrlKey", "altKey", "shiftKey",
       "metaKey", "keyCode", "charCode",
     ];
