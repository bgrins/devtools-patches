# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b7f409bd51c8ae7260c1675785c698a9cb061244
browser_findbar.js intermittent investigation

diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -523,16 +523,17 @@ window._gBrowser = {
 
     await new Promise(r => requestAnimationFrame(r));
     delete aTab._pendingFindBar;
     if (window.closed || aTab.closing) {
       return null;
     }
 
     findBar.browser = browser;
+    console.log("_createFindBar Reseting to ", this._lastFindValue);
     findBar._findField.value = this._lastFindValue;
 
     aTab._findBar = findBar;
 
     let event = document.createEvent("Events");
     event.initEvent("TabFindInitialized", true, false);
     aTab.dispatchEvent(event);
 
@@ -3229,16 +3230,17 @@ window._gBrowser = {
         otherFindBar.findMode == otherFindBar.FIND_NORMAL) {
       let oldValue = otherFindBar._findField.value;
       let wasHidden = otherFindBar.hidden;
       let ourFindBarPromise = this.getFindBar(aOurTab);
       ourFindBarPromise.then(ourFindBar => {
         if (!ourFindBar) {
           return;
         }
+        console.log("RESETTING TO ", oldValue);
         ourFindBar._findField.value = oldValue;
         if (!wasHidden)
           ourFindBar.onFindCommand();
       });
     }
 
     // Finish tearing down the tab that's going away.
     if (closeWindow) {
@@ -4252,16 +4254,17 @@ window._gBrowser = {
           updateUserContextUIIndicator();
         }
 
         break;
       }
       case "Findbar:Keypress":
       {
         let tab = this.getTabForBrowser(browser);
+        console.log("Findbar:Keypress received from tabbrowser", this.isFindBarInitialized(tab), data);
         if (!this.isFindBarInitialized(tab)) {
           let fakeEvent = data;
           this.getFindBar(tab).then(findbar => {
             findbar._onBrowserKeypress(fakeEvent);
           });
         }
         break;
       }
diff --git a/testing/mochitest/tests/SimpleTest/EventUtils.js b/testing/mochitest/tests/SimpleTest/EventUtils.js
--- a/testing/mochitest/tests/SimpleTest/EventUtils.js
+++ b/testing/mochitest/tests/SimpleTest/EventUtils.js
@@ -989,24 +989,28 @@ function synthesizeAndWaitKey(aKey, aEve
           removeEventListener("keyup", onKeyEvent);
           resolve();
         }
       });
       sendAsyncMessage("Test:KeyRegistered");
     });
   });
   keyRegisteredPromise.then(() => {
+    console.log("keyRegisteredPromise resolved");
     if (checkBeforeSynthesize) {
       checkBeforeSynthesize();
     }
     synthesizeKey(aKey, aEvent, aWindow);
     if (checkAfterSynthesize) {
       checkAfterSynthesize();
     }
   });
+  keyReceivedPromise.then(() => {
+    console.log("keyReceivedPromise resolved");
+  })
   return keyReceivedPromise;
 }
 
 function _parseNativeModifiers(aModifiers, aWindow = window)
 {
   var navigator = _getNavigator(aWindow);
   var modifiers;
   if (aModifiers.capsLockKey) {
diff --git a/toolkit/content/tests/browser/browser_findbar.js b/toolkit/content/tests/browser/browser_findbar.js
--- a/toolkit/content/tests/browser/browser_findbar.js
+++ b/toolkit/content/tests/browser/browser_findbar.js
@@ -1,11 +1,13 @@
 /* eslint-disable mozilla/no-arbitrary-setTimeout */
 ChromeUtils.import("resource://gre/modules/Timer.jsm", this);
 
+SimpleTest.requestCompleteLog();
+
 const TEST_PAGE_URI = "data:text/html;charset=utf-8,The letter s.";
 // Using 'javascript' schema to bypass E10SUtils.canLoadURIInProcess, because
 // it does not allow 'data:' URI to be loaded in the parent process.
 const E10S_PARENT_TEST_PAGE_URI = "javascript:document.write('The letter s.');";
 
 /**
  * Makes sure that the findbar hotkeys (' and /) event listeners
  * are added to the system event group and do not get blocked
@@ -31,19 +33,19 @@ add_task(async function test_hotkey_even
     is(findbar.hidden, false, "Findbar should not be hidden.");
     await closeFindbarAndWait(findbar);
   }
 
   // Stop propagation for all keyboard events.
   let frameScript = () => {
     const stopPropagation = e => e.stopImmediatePropagation();
     let window = content.document.defaultView;
-    window.removeEventListener("keydown", stopPropagation);
-    window.removeEventListener("keypress", stopPropagation);
-    window.removeEventListener("keyup", stopPropagation);
+    window.addEventListener("keydown", stopPropagation);
+    window.addEventListener("keypress", stopPropagation);
+    window.addEventListener("keyup", stopPropagation);
   };
 
   let mm = browser.messageManager;
   mm.loadFrameScript("data:,(" + frameScript.toString() + ")();", false);
 
   // Checking if findbar still appears when any hotkey is pressed.
   for (let key of HOTKEYS) {
     is(findbar.hidden, true, "Findbar is hidden now.");
@@ -171,29 +173,37 @@ add_task(async function e10sLostKeys() {
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, TEST_PAGE_URI);
 
   ok(!gFindBarInitialized, "findbar isn't initialized yet");
 
   await gFindBarPromise;
   let findBar = gFindBar;
   let initialValue = findBar._findField.value;
 
+  console.log("XXXXX0:", findBar._findField.value);
+
   await EventUtils.synthesizeAndWaitKey("f", { accelKey: true }, window, null, () => {
     // We can't afford to wait for the promise to resolve, by then the
     // find bar is visible and focused, so sending characters to the
     // content browser wouldn't work.
     isnot(document.activeElement, findBar._findField.inputField,
       "findbar is not yet focused");
+    console.log("Active element: ", document.activeElement, document.activeElement.outerHTML);
     EventUtils.synthesizeKey("a");
     EventUtils.synthesizeKey("b");
     EventUtils.synthesizeKey("c");
     is(findBar._findField.value, initialValue, "still has initial find query");
   });
 
+  console.log("XXXXX1:", findBar._findField.value, "initial: ", initialValue);
+
+  is(document.activeElement, findBar._findField.inputField, "findbar is now focused");
   await BrowserTestUtils.waitForCondition(() => findBar._findField.value.length == 3);
+  console.log("XXXXX2:", findBar._findField.value, "initial: ", initialValue);
+
   is(document.activeElement, findBar._findField.inputField,
     "findbar is now focused");
   is(findBar._findField.value, "abc", "abc fully entered as find query");
 
   BrowserTestUtils.removeTab(tab);
 });
 
 function promiseFindFinished(searchText, highlightOn) {
diff --git a/toolkit/content/widgets/findbar.js b/toolkit/content/widgets/findbar.js
--- a/toolkit/content/widgets/findbar.js
+++ b/toolkit/content/widgets/findbar.js
@@ -184,16 +184,17 @@ class MozFindbar extends XULElement {
     window.addEventListener("unload", this.destroy);
 
     this._findField.addEventListener("input", (event) => {
       // We should do nothing during composition.  E.g., composing string
       // before converting may matches a forward word of expected word.
       // After that, even if user converts the composition string to the
       // expected word, it may find second or later searching word in the
       // document.
+      console.log("Received input", this._findField.value);
       if (this._isIMEComposing) {
         return;
       }
 
       const value = this._findField.value;
       if (this._hadValue && !value) {
         this._willfullyDeleted = true;
         this._hadValue = false;
@@ -248,21 +249,24 @@ class MozFindbar extends XULElement {
 
     this._findField.addEventListener("blur", (event) => {
       // Note: This code used to remove the selection
       // if it matched an editable.
       this.browser.finder.enableSelection();
     });
 
     this._findField.addEventListener("focus", (event) => {
-      if (/Mac/.test(navigator.platform)) {
-        this._onFindFieldFocus();
-      }
-      this._updateBrowserWithState();
-    });
+      setTimeout(() => {
+        // if (this._destroyed) {return;}
+        if (/Mac/.test(navigator.platform)) {
+          this._onFindFieldFocus();
+        }
+        this._updateBrowserWithState();
+      }, 2000);
+    }, {mozSystemGroup: true});
 
     this._findField.addEventListener("compositionstart", (event) => {
       // Don't close the find toolbar while IME is composing.
       let findbar = this;
       findbar._isIMEComposing = true;
       if (findbar._quickFindTimeout) {
         clearTimeout(findbar._quickFindTimeout);
         findbar._quickFindTimeout = null;
@@ -323,32 +327,35 @@ class MozFindbar extends XULElement {
       return !!(tm.numberOfUndoItems || tm.numberOfRedoItems);
     }
     return false;
   }
 
   set browser(val) {
     if (this._browser) {
       if (this._browser.messageManager) {
+        console.log("Removing message listeners");
         this._browser.messageManager.removeMessageListener("Findbar:Keypress", this);
         this._browser.messageManager.removeMessageListener("Findbar:Mouseup", this);
       }
       let finder = this._browser.finder;
       if (finder)
         finder.removeResultListener(this);
     }
 
     this._browser = val;
+    console.log("Browser setter", this._browser, this._browser && this._browser._lastSearchString);
+    console.trace();
     if (this._browser) {
       // Need to do this to ensure the correct initial state.
       this._updateBrowserWithState();
       this._browser.messageManager.addMessageListener("Findbar:Keypress", this);
       this._browser.messageManager.addMessageListener("Findbar:Mouseup", this);
       this._browser.finder.addResultListener(this);
-
+      console.log("Setting last search string", this._browser._lastSearchString);
       this._findField.value = this._browser._lastSearchString;
     }
     return val;
   }
 
   get browser() {
     if (!this._browser) {
       this._browser =
@@ -439,21 +446,21 @@ class MozFindbar extends XULElement {
       this._quickFindTimeout = null;
       this._updateBrowserWithState();
       return;
     }
 
     if (this.quickFindTimeoutLength < 1) {
       this._quickFindTimeout = null;
     } else {
-      this._quickFindTimeout = setTimeout(() => {
-        if (this._findMode != this.FIND_NORMAL)
-            this.close();
-          this._quickFindTimeout = null;
-      }, this.quickFindTimeoutLength);
+      // this._quickFindTimeout = setTimeout(() => {
+      //   if (this._findMode != this.FIND_NORMAL)
+      //       this.close();
+      //     this._quickFindTimeout = null;
+      // }, this.quickFindTimeoutLength);
     }
     this._updateBrowserWithState();
   }
 
   /**
    * - Updates the search match count after each find operation on a new string.
    * - @param aRes
    * -        the result of the find operation
@@ -738,16 +745,17 @@ class MozFindbar extends XULElement {
   /**
    * We get a fake event object through an IPC message when FAYT is being used
    * from within the browser. We then stuff that input in the find bar here.
    */
   _onBrowserKeypress(aFakeEvent) {
     const FAYT_LINKS_KEY = "'";
     const FAYT_TEXT_KEY = "/";
 
+    console.log("_onBrowserKeypress", aFakeEvent);
     if (!this.hidden && this._findField.inputField == document.activeElement) {
       this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);
       return;
     }
 
     if (this._findMode != this.FIND_NORMAL && this._quickFindTimeout) {
       this._findField.select();
       this._findField.focus();
@@ -780,16 +788,17 @@ class MozFindbar extends XULElement {
         this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);
     }
   }
 
   /**
    * See MessageListener
    */
   receiveMessage(aMessage) {
+    console.log("receiveMessage", aMessage.target != this._browser, aMessage.name, aMessage.data);
     if (aMessage.target != this._browser) {
       return undefined;
     }
     switch (aMessage.name) {
       case "Findbar:Mouseup":
         if (!this.hidden && this._findMode != this.FIND_NORMAL)
           this.close();
         break;
@@ -802,16 +811,20 @@ class MozFindbar extends XULElement {
 
   _updateBrowserWithState() {
     if (this._browser && this._browser.messageManager) {
       this._browser.messageManager.sendAsyncMessage("Findbar:UpdateState", {
         findMode: this._findMode,
         isOpenAndFocused: !this.hidden && document.activeElement == this._findField.inputField,
         hasQuickFindTimeout: !!this._quickFindTimeout,
       });
+      console.log("_updateBrowserWithState", this._findMode, (!this.hidden && document.activeElement == this._findField.inputField), !!this._quickFindTimeout);
+      console.trace();
+    } else {
+      console.log("Null brwoser _updateBrowserWithState", this._browser);
     }
   }
 
   _enableFindButtons(aEnable) {
     this.getElement("find-next").disabled =
       this.getElement("find-previous").disabled = !aEnable;
   }
 
@@ -855,16 +868,17 @@ class MozFindbar extends XULElement {
       return;
 
     let val = aValue || this._findField.value;
 
     // We have to carry around an explicit version of this,
     // because finder.searchString doesn't update on failed
     // searches.
     this.browser._lastSearchString = val;
+    console.log("Storing last search string for browser: ", this.browser._lastSearchString);
 
     // Only search on input if we don't have a last-failed string,
     // or if the current search string doesn't start with it.
     // In entire-word mode we always attemp a find; since sequential matching
     // is not guaranteed, the first character typed may not be a word (no
     // match), but the with the second character it may well be a word,
     // thus a match.
     if (!this._findFailedString ||
@@ -875,34 +889,34 @@ class MozFindbar extends XULElement {
       if (this._startFindDeferred) {
         this._startFindDeferred.resolve();
         this._startFindDeferred = null;
       }
 
       this._enableFindButtons(val);
       this._updateCaseSensitivity(val);
       this._setEntireWord();
-
+      console.log("Fastfind from client");
       this.browser.finder.fastFind(val, this._findMode == this.FIND_LINKS,
         this._findMode != this.FIND_NORMAL);
     }
 
     if (this._findMode != this.FIND_NORMAL)
       this._setFindCloseTimeout();
 
     if (this._findResetTimeout != -1)
       clearTimeout(this._findResetTimeout);
 
     // allow a search to happen on input again after a second has
     // expired since the previous input, to allow for dynamic
     // content and/or page loading
-    this._findResetTimeout = setTimeout(() => {
-      this._findFailedString = null;
-      this._findResetTimeout = -1;
-    }, 1000);
+    // this._findResetTimeout = setTimeout(() => {
+    //   this._findFailedString = null;
+    //   this._findResetTimeout = -1;
+    // }, 1000);
   }
 
   _flash() {
     if (this._flashFindBarCount === undefined)
       this._flashFindBarCount = this._initialFlashFindBarCount;
 
     if (this._flashFindBarCount-- == 0) {
       clearInterval(this._flashFindBarTimeout);
@@ -1061,30 +1075,33 @@ class MozFindbar extends XULElement {
 
     return undefined;
   }
 
   /* Fetches the currently selected text and sets that as the text to search
      next. This is a MacOS specific feature. */
   onFindSelectionCommand() {
     let searchString = this.browser.finder.setSearchStringToSelection();
+    console.trace();
     if (searchString)
       this._findField.value = searchString;
 
   }
 
   _onFindFieldFocus() {
     let prefsvc = this._prefsvc;
     const kPref = "accessibility.typeaheadfind.prefillwithselection";
     if (this.prefillWithSelection && prefsvc.getBoolPref(kPref))
       return;
 
     let clipboardSearchString = this._browser.finder.clipboardSearchString;
+    console.log("_onFindFieldFocus", this._findField.value, this._findField._willfullyDeleted, clipboardSearchString);
     if (clipboardSearchString && this._findField.value != clipboardSearchString &&
         !this._findField._willfullyDeleted) {
+          console.log("Resetting input to ", clipboardSearchString)
       this._findField.value = clipboardSearchString;
       this._findField._hadValue = true;
       // Changing the search string makes the previous status invalid, so
       // we better clear it here.
       this._updateStatusUI();
     }
   }
 
diff --git a/toolkit/modules/FindBarContent.jsm b/toolkit/modules/FindBarContent.jsm
--- a/toolkit/modules/FindBarContent.jsm
+++ b/toolkit/modules/FindBarContent.jsm
@@ -46,16 +46,17 @@ class FindBarContent {
   }
 
   receiveMessage(msg) {
     switch (msg.name) {
       case "Findbar:UpdateState":
         this.findMode = msg.data.findMode;
         this.inQuickFind = msg.data.hasQuickFindTimeout;
         if (msg.data.isOpenAndFocused) {
+          console.log("Changing inpassthrough to false", this.inPassThrough);
           this.inPassThrough = false;
         }
         break;
     }
   }
 
   handleEvent(event) {
     switch (event.type) {
@@ -64,24 +65,27 @@ class FindBarContent {
         break;
       case "mouseup":
         this.onMouseup(event);
         break;
     }
   }
 
   onKeypress(event) {
+    console.log("onKeyPress", event.keyCode, this.inPassThrough);
     if (this.inPassThrough) {
       this.passKeyToParent(event);
     } else if (this.findMode != FIND_NORMAL && this.inQuickFind && event.charCode) {
       this.passKeyToParent(event);
     }
   }
 
   passKeyToParent(event) {
+    console.log("passKeyToParent called");
+    console.trace();
     event.preventDefault();
     // These are the properties required to dispatch another 'real' event
     // to the findbar in the parent in _dispatchKeypressEvent in findbar.xml .
     // If you make changes here, verify that that method can still do its job.
     const kRequiredProps = [
       "type", "bubbles", "cancelable", "ctrlKey", "altKey", "shiftKey",
       "metaKey", "keyCode", "charCode",
     ];
diff --git a/toolkit/modules/Finder.jsm b/toolkit/modules/Finder.jsm
--- a/toolkit/modules/Finder.jsm
+++ b/toolkit/modules/Finder.jsm
@@ -78,16 +78,18 @@ Finder.prototype = {
   },
 
   _notify(options) {
     if (typeof options.storeResult != "boolean")
       options.storeResult = true;
 
     if (options.storeResult) {
       this._searchString = options.searchString;
+      console.trace();
+      console.log("Storing result", options.searchString);
       this.clipboardSearchString = options.searchString;
     }
 
     let foundLink = this._fastFind.foundLink;
     let linkURL = null;
     if (foundLink) {
       let docCharset = null;
       let ownerDoc = foundLink.ownerDocument;
@@ -222,16 +224,17 @@ Finder.prototype = {
    */
   setSearchStringToSelection() {
     let searchString = this.getActiveSelectionText();
 
     // Empty strings are rather useless to search for.
     if (!searchString.length)
       return null;
 
+    console.log("setSearchStringToSelection")
     this.clipboardSearchString = searchString;
     return searchString;
   },
 
   async highlight(aHighlight, aWord, aLinksOnly) {
     await this.highlighter.highlight(aHighlight, aWord, aLinksOnly);
   },
 
