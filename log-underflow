# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  d3444f7c85e5e1aa5d488043d9ae05362d6a1892

diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -12,17 +12,18 @@
            extends="chrome://global/content/bindings/tabbox.xml#tabs">
     <content>
       <xul:hbox class="tab-drop-indicator-box">
         <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
       </xul:hbox>
       <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
                           style="min-width: 1px;"
                           clicktoscroll="true"
-                          class="tabbrowser-arrowscrollbox">
+                          class="tabbrowser-arrowscrollbox"
+                          smoothscroll="false">
 <!--
  This is a hack to circumvent bug 472020, otherwise the tabs show up on the
  right of the newtab button.
 -->
         <children includes="tab"/>
 <!--
   This is to ensure anything extensions put here will go before the newtab
   button, necessary due to the previous hack.
@@ -134,21 +135,22 @@
         <getter>
           return this.getAttribute("aria-multiselectable") == "true";
         </getter>
       </property>
 
       <method name="_initializeArrowScrollbox">
         <body><![CDATA[
           let tabs = this;
-          this.arrowScrollbox.addEventListener("underflow", (event) => {
+          this.arrowScrollbox._onUnderflow = function(event) {
             // Ignore underflow events:
             // - from nested scrollable elements
             // - for vertical orientation
             // - corresponding to an overflow event that we ignored
+            console.log("_onUnderflow", event, event.originalTarget == this.scrollbox, event.target == this.scrollbox, event.explicitOriginalTarget == this.scrollbox);
             if (event.originalTarget != this.scrollbox ||
               event.detail == 0 ||
               !tabs.hasAttribute("overflow")) {
               return;
             }
 
             tabs.removeAttribute("overflow");
 
@@ -156,31 +158,33 @@
               tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);
             }
 
             for (let tab of Array.from(gBrowser._removingTabs)) {
               gBrowser.removeTab(tab);
             }
 
             tabs._positionPinnedTabs();
-          }, true);
+          };
 
-          this.arrowScrollbox.addEventListener("overflow", (event) => {
+          this.arrowScrollbox._onOverflow = function(event) {
             // Ignore overflow events:
             // - from nested scrollable elements
             // - for vertical orientation
+            console.log("_onOverflow", event, event.originalTarget == this.scrollbox, event.target == this.scrollbox, event.explicitOriginalTarget == this.scrollbox);
+
             if (event.originalTarget != this.scrollbox ||
               event.detail == 0) {
               return;
             }
 
             tabs.setAttribute("overflow", "true");
             tabs._positionPinnedTabs();
             tabs._handleTabSelect(true);
-          }, true);
+          };
 
           /**
           * Override scrollbox.xml method, since our scrollbox's children are
           * inherited from the scrollbox binding parent (this).
           */
           this.arrowScrollbox._getScrollableElements = function() {
             return Array.filter(tabs.children, this._canScrollToElement, this);
           };
diff --git a/browser/base/content/test/tabs/browser_overflowScroll.js b/browser/base/content/test/tabs/browser_overflowScroll.js
--- a/browser/base/content/test/tabs/browser_overflowScroll.js
+++ b/browser/base/content/test/tabs/browser_overflowScroll.js
@@ -69,16 +69,20 @@ add_task(async function() {
 
   element = nextLeftElement();
   EventUtils.synthesizeMouseAtCenter(upButton, {});
   await waitForNextFrame();
   isLeft(element, "Scrolled one tab to the left with a single click");
 
   let elementPoint = left(scrollbox) - width(scrollbox);
   element = elementFromPoint(elementPoint);
+  // if (!element) {
+  console.log(elementPoint, element, scrollbox, left(scrollbox), width(scrollbox));
+  await new Promise(r => r);
+  // }
   element = element.nextElementSibling;
 
   EventUtils.synthesizeMouseAtCenter(upButton, {clickCount: 2});
   await waitForNextFrame();
   await BrowserTestUtils.waitForCondition(() =>
     !gBrowser.tabContainer.arrowScrollbox._isScrolling);
   isLeft(element, "Scrolled one page of tabs with a double click");
 
diff --git a/toolkit/content/widgets/scrollbox.xml b/toolkit/content/widgets/scrollbox.xml
--- a/toolkit/content/widgets/scrollbox.xml
+++ b/toolkit/content/widgets/scrollbox.xml
@@ -40,17 +40,16 @@
     </content>
 
     <implementation>
       <constructor><![CDATA[
         if (!this.hasAttribute("smoothscroll")) {
           this.smoothScroll = this._prefBranch
                                   .getBoolPref("toolkit.scrollbox.smoothScroll", true);
         }
-
         this.setAttribute("notoverflowing", "true");
         this._updateScrollButtonsDisabledState();
       ]]></constructor>
 
       <destructor><![CDATA[
         // Release timer to avoid reference cycles.
         if (this._scrollTimer) {
           this._scrollTimer.cancel();
@@ -704,20 +703,24 @@
         }
       ]]></handler>
 
       <handler event="touchend"><![CDATA[
         this._touchStart = -1;
       ]]></handler>
 
       <handler event="underflow" phase="capturing"><![CDATA[
+        if (this._onUnderflow) {
+          this._onUnderflow(event);
+        }
+        console.log(event.target == this, event.originalTarget == this.scrollbox);
         // Ignore underflow events:
         // - from nested scrollable elements
         // - corresponding to an overflow event that we ignored
-        if (event.target != this ||
+        if (event.originalTarget != this.scrollbox ||
             this.hasAttribute("notoverflowing")) {
           return;
         }
 
         // Ignore events that doesn't match our orientation.
         // Scrollport event orientation:
         //   0: vertical
         //   1: horizontal
@@ -732,17 +735,17 @@
 
         this.setAttribute("notoverflowing", "true");
         this._updateScrollButtonsDisabledState();
       ]]></handler>
 
       <handler event="overflow" phase="capturing"><![CDATA[
         // Ignore overflow events:
         // - from nested scrollable elements
-        if (event.target != this) {
+        if (event.originalTarget != this.scrollbox) {
           return;
         }
 
         // Ignore events that doesn't match our orientation.
         // Scrollport event orientation:
         //   0: vertical
         //   1: horizontal
         //   2: both
@@ -751,16 +754,20 @@
             return;
         } else if (event.detail == 0) {
           // horizontal scrollbox
           return;
         }
 
         this.removeAttribute("notoverflowing");
         this._updateScrollButtonsDisabledState();
+      console.log("Overflow fired", event, this, event.originalTarget == this.scrollbox, event.target == this);
+        if (this._onOverflow) {
+          this._onOverflow(event);
+        }
       ]]></handler>
 
       <handler event="scroll"><![CDATA[
         this._isScrolling = true;
         this._updateScrollButtonsDisabledState();
       ]]></handler>
 
       <handler event="scrollend"><![CDATA[
