# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8c14b7f30616dc4281896f5a9025d06b913915b4

diff --git a/toolkit/content/widgets/arrowscrollbox.js b/toolkit/content/widgets/arrowscrollbox.js
--- a/toolkit/content/widgets/arrowscrollbox.js
+++ b/toolkit/content/widgets/arrowscrollbox.js
@@ -13,36 +13,21 @@
 
   class MozArrowScrollbox extends MozElements.BaseControl {
     constructor() {
       super();
       this.attachShadow({ mode: "open" });
       this.shadowRoot.appendChild(this.fragment);
 
       this.scrollbox = this.shadowRoot.querySelector("[part=scrollbox]");
-
-      // Retarget events from shadow DOM scrollbox to the host.
-      this.scrollbox.addEventListener("scroll", ev =>
-        this.dispatchEvent(new Event("scroll"))
-      );
-      this.scrollbox.addEventListener("overflow", ev =>
-        this.dispatchEvent(new Event("overflow"))
-      );
-      this.scrollbox.addEventListener("underflow", ev =>
-        this.dispatchEvent(new Event("underflow"))
-      );
-
       this._scrollButtonUp = this.shadowRoot.querySelector(".scrollbutton-up");
       this._scrollButtonDown = this.shadowRoot.querySelector(
         ".scrollbutton-down"
       );
 
-      this.initializeAttributeInheritance();
-      this._scrollIndex = 0;
-
       this._arrowScrollAnim = {
         scrollbox: this,
         requestHandle: 0,
         /* 0 indicates there is no pending request */
         start: function arrowSmoothScroll_start() {
           this.lastFrameTime = window.performance.now();
           if (!this.requestHandle) {
             this.requestHandle = window.requestAnimationFrame(
@@ -62,263 +47,52 @@
           const scrollDelta = 0.5 * timePassed * scrollIndex;
           this.scrollbox.scrollByPixels(scrollDelta, true);
           this.requestHandle = window.requestAnimationFrame(
             this.sample.bind(this)
           );
         },
       };
 
+      this._scrollIndex = 0;
       this._scrollIncrement = null;
-
-      this._startEndProps =
-        this.orient == "vertical" ? ["top", "bottom"] : ["left", "right"];
-
-      this._isRTLScrollbox =
-        this.orient != "vertical" &&
-        document.defaultView.getComputedStyle(this.scrollbox).direction ==
-          "rtl";
-
       this._ensureElementIsVisibleAnimationFrame = 0;
-
       this._prevMouseScrolls = [null, null];
-
       this._touchStart = -1;
-
       this._scrollButtonUpdatePending = false;
-
       this._isScrolling = false;
-
       this._destination = 0;
-
       this._direction = 0;
 
-      this.addEventListener("wheel", event => {
-        // Don't consume the event if we can't scroll.
-        if (this.hasAttribute("notoverflowing")) {
-          return;
-        }
-
-        let doScroll = false;
-        let instant;
-        let scrollAmount = 0;
-        if (this.orient == "vertical") {
-          doScroll = true;
-          if (event.deltaMode == event.DOM_DELTA_PIXEL) {
-            scrollAmount = event.deltaY;
-          } else if (event.deltaMode == event.DOM_DELTA_PAGE) {
-            scrollAmount = event.deltaY * this.scrollClientSize;
-          } else {
-            scrollAmount = event.deltaY * this.lineScrollAmount;
-          }
-        } else {
-          // We allow vertical scrolling to scroll a horizontal scrollbox
-          // because many users have a vertical scroll wheel but no
-          // horizontal support.
-          // Because of this, we need to avoid scrolling chaos on trackpads
-          // and mouse wheels that support simultaneous scrolling in both axes.
-          // We do this by scrolling only when the last two scroll events were
-          // on the same axis as the current scroll event.
-          // For diagonal scroll events we only respect the dominant axis.
-          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);
-          let delta = isVertical ? event.deltaY : event.deltaX;
-          let scrollByDelta =
-            isVertical && this._isRTLScrollbox ? -delta : delta;
-
-          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {
-            doScroll = true;
-            if (event.deltaMode == event.DOM_DELTA_PIXEL) {
-              scrollAmount = scrollByDelta;
-              instant = true;
-            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {
-              scrollAmount = scrollByDelta * this.scrollClientSize;
-            } else {
-              scrollAmount = scrollByDelta * this.lineScrollAmount;
-            }
-          }
-
-          if (this._prevMouseScrolls.length > 1) {
-            this._prevMouseScrolls.shift();
-          }
-          this._prevMouseScrolls.push(isVertical);
-        }
-
-        if (doScroll) {
-          let direction = scrollAmount < 0 ? -1 : 1;
-          let startPos = this.scrollPosition;
-
-          if (!this._isScrolling || this._direction != direction) {
-            this._destination = startPos + scrollAmount;
-            this._direction = direction;
-          } else {
-            // We were already in the process of scrolling in this direction
-            this._destination = this._destination + scrollAmount;
-            scrollAmount = this._destination - startPos;
-          }
-          this.scrollByPixels(scrollAmount, instant);
-        }
-
-        event.stopPropagation();
-        event.preventDefault();
-      });
-
-      this.addEventListener("touchstart", event => {
-        if (event.touches.length > 1) {
-          // Multiple touch points detected, abort. In particular this aborts
-          // the panning gesture when the user puts a second finger down after
-          // already panning with one finger. Aborting at this point prevents
-          // the pan gesture from being resumed until all fingers are lifted
-          // (as opposed to when the user is back down to one finger).
-          this._touchStart = -1;
-        } else {
-          this._touchStart =
-            this.orient == "vertical"
-              ? event.touches[0].screenY
-              : event.touches[0].screenX;
-        }
-      });
-
-      this.addEventListener("touchmove", event => {
-        if (event.touches.length == 1 && this._touchStart >= 0) {
-          var touchPoint =
-            this.orient == "vertical"
-              ? event.touches[0].screenY
-              : event.touches[0].screenX;
-          var delta = this._touchStart - touchPoint;
-          if (Math.abs(delta) > 0) {
-            this.scrollByPixels(delta, true);
-            this._touchStart = touchPoint;
-          }
-          event.preventDefault();
-        }
-      });
-
-      this.addEventListener("touchend", event => {
-        this._touchStart = -1;
-      });
+      this.addEventListener("wheel", this.on_wheel);
+      this.addEventListener("touchstart", this.on_touchstart);
+      this.addEventListener("touchmove", this.on_touchmove);
+      this.addEventListener("touchend", this.on_touchend);
+      this.addEventListener("click", this.on_click);
+      this.addEventListener("mousedown", this.on_mousedown);
+      this.addEventListener("mouseover", this.on_mouseover);
+      this.addEventListener("mouseup", this.on_mouseup);
+      this.addEventListener("mouseout", this.on_mouseout);
 
       this.shadowRoot.addEventListener(
         "underflow",
-        event => {
-          // Ignore underflow events:
-          // - from nested scrollable elements
-          // - corresponding to an overflow event that we ignored
-          if (
-            event.target != this.scrollbox ||
-            this.hasAttribute("notoverflowing")
-          ) {
-            return;
-          }
-
-          // Ignore events that doesn't match our orientation.
-          // Scrollport event orientation:
-          //   0: vertical
-          //   1: horizontal
-          //   2: both
-          if (this.orient == "vertical") {
-            if (event.detail == 1) {
-              return;
-            }
-          } else if (event.detail == 0) {
-            // horizontal scrollbox
-            return;
-          }
-
-          this.setAttribute("notoverflowing", "true");
-          this._updateScrollButtonsDisabledState();
-        },
-        true
-      );
-
-      this.shadowRoot.addEventListener(
-        "overflow",
-        event => {
-          // Ignore overflow events:
-          // - from nested scrollable elements
-          if (event.target != this.scrollbox) {
-            return;
-          }
-
-          // Ignore events that doesn't match our orientation.
-          // Scrollport event orientation:
-          //   0: vertical
-          //   1: horizontal
-          //   2: both
-          if (this.orient == "vertical") {
-            if (event.detail == 1) {
-              return;
-            }
-          } else if (event.detail == 0) {
-            // horizontal scrollbox
-            return;
-          }
-
-          this.removeAttribute("notoverflowing");
-          this._updateScrollButtonsDisabledState();
-        },
+        this.on_underflow.bind(this),
         true
       );
-
-      this.scrollbox.addEventListener("scroll", event => {
-        this._isScrolling = true;
-        this._updateScrollButtonsDisabledState();
-      });
-
-      this.shadowRoot.addEventListener("scrollend", event => {
-        this._isScrolling = false;
-        this._destination = 0;
-        this._direction = 0;
-      });
+      this.shadowRoot.addEventListener(
+        "overflow",
+        this.on_overflow.bind(this),
+        true
+      );
+      this.scrollbox.addEventListener("scroll", this.on_scroll.bind(this));
 
-      // Ultimately Bug 1514926 will convert arrowscrollbox binding to a custom element.
-      // For the needs of Bug 1497189, where we apply a custom CSP to about:addons, we had
-      // to remove inline handlers and hence added event listeners for mouse events here.
-      this.shadowRoot.addEventListener("click", e => {
-        if (
-          e.originalTarget != this._scrollButtonUp &&
-          e.originalTarget != this._scrollButtonDown
-        ) {
-          return;
-        }
-        this._onButtonClick(e);
-      });
-      this.shadowRoot.addEventListener("mousedown", e => {
-        if (e.originalTarget == this._scrollButtonUp) {
-          this._onButtonMouseDown(e, -1);
-        }
-        if (e.originalTarget == this._scrollButtonDown) {
-          this._onButtonMouseDown(e, 1);
-        }
-      });
-      this.shadowRoot.addEventListener("mouseup", e => {
-        if (
-          e.originalTarget != this._scrollButtonUp &&
-          e.originalTarget != this._scrollButtonDown
-        ) {
-          return;
-        }
-        this._onButtonMouseUp(e);
-      });
-      this.shadowRoot.addEventListener("mouseover", e => {
-        if (e.originalTarget == this._scrollButtonUp) {
-          this._onButtonMouseOver(-1);
-        }
-        if (e.originalTarget == this._scrollButtonDown) {
-          this._onButtonMouseOver(1);
-        }
-      });
-      this.shadowRoot.addEventListener("mouseout", e => {
-        if (
-          e.originalTarget != this._scrollButtonUp &&
-          e.originalTarget != this._scrollButtonDown
-        ) {
-          return;
-        }
-        this._onButtonMouseOut();
-      });
+      this.shadowRoot.addEventListener(
+        "scrollend",
+        this.on_scrollend.bind(this)
+      );
     }
 
     static get inheritedAttributes() {
       return {
         ".scrollbutton-up": "orient,disabled=scrolledtostart",
         "[part=scrollbox]": "orient,align,pack,dir,smoothscroll",
         ".scrollbutton-down": "orient,disabled=scrolledtoend",
       };
@@ -342,30 +116,23 @@
         <html:slot></html:slot>
       </scrollbox>
       <spacer part="arrowscrollbox-overflow-end-indicator"></spacer>
       <toolbarbutton class="scrollbutton-down" part="scrollbutton-down"/>
     `;
     }
 
     connectedCallback() {
-      if (this.hasConnected) {
+      if (this.delayConnectedCallback() || this.hasConnected) {
         return;
       }
-
       this.hasConnected = true;
 
-      if (!this.hasAttribute("smoothscroll")) {
-        this.smoothScroll = Services.prefs.getBoolPref(
-          "toolkit.scrollbox.smoothScroll",
-          true
-        );
-      }
-
       this.setAttribute("notoverflowing", "true");
+      this.initializeAttributeInheritance();
       this._updateScrollButtonsDisabledState();
     }
 
     get _clickToScroll() {
       return this.hasAttribute("clicktoscroll");
     }
 
     get _scrollDelay() {
@@ -385,22 +152,47 @@
         this._scrollIncrement = Services.prefs.getIntPref(
           "toolkit.scrollbox.scrollIncrement",
           20
         );
       }
       return this._scrollIncrement;
     }
 
+    get startEndProps() {
+      if (!this._startEndProps) {
+        this._startEndProps =
+          this.orient == "vertical" ? ["top", "bottom"] : ["left", "right"];
+      }
+      return this._startEndProps;
+    }
+
+    get isRTLScrollbox() {
+      if (!this._isRTLScrollbox) {
+        this._isRTLScrollbox =
+          this.orient != "vertical" &&
+          document.defaultView.getComputedStyle(this.scrollbox).direction ==
+            "rtl";
+      }
+      return this._isRTLScrollbox;
+    }
+
     set smoothScroll(val) {
       this.setAttribute("smoothscroll", !!val);
       return val;
     }
 
     get smoothScroll() {
+      if (!this.hasAttribute("smoothscroll")) {
+        this.smoothScroll = Services.prefs.getBoolPref(
+          "toolkit.scrollbox.smoothScroll",
+          true
+        );
+      }
+
       return this.getAttribute("smoothscroll") == "true";
     }
 
     get scrollClientRect() {
       return this.scrollbox.getBoundingClientRect();
     }
 
     get scrollClientSize() {
@@ -451,17 +243,17 @@
     _onButtonMouseOver(index) {
       if (this._clickToScroll) {
         this._continueScroll(index);
       } else {
         this._startScroll(index);
       }
     }
 
-    _onButtonMouseOut(index) {
+    _onButtonMouseOut() {
       if (this._clickToScroll) {
         this._pauseScroll();
       } else {
         this._stopScroll();
       }
     }
 
     _boundsWithoutFlushing(element) {
@@ -507,25 +299,25 @@
     }
 
     scrollByIndex(index, aInstant) {
       if (index == 0) {
         return;
       }
 
       var rect = this.scrollClientRect;
-      var [start, end] = this._startEndProps;
+      var [start, end] = this.startEndProps;
       var x = index > 0 ? rect[end] + 1 : rect[start] - 1;
       var nextElement = this._elementFromPoint(x, index);
       if (!nextElement) {
         return;
       }
 
       var targetElement;
-      if (this._isRTLScrollbox) {
+      if (this.isRTLScrollbox) {
         index *= -1;
       }
       while (index < 0 && nextElement) {
         if (this._canScrollToElement(nextElement)) {
           targetElement = nextElement;
         }
         nextElement = nextElement.previousElementSibling;
         index++;
@@ -564,21 +356,21 @@
     }
 
     _elementFromPoint(aX, aPhysicalScrollDir) {
       var elements = this._getScrollableElements();
       if (!elements.length) {
         return null;
       }
 
-      if (this._isRTLScrollbox) {
+      if (this.isRTLScrollbox) {
         elements.reverse();
       }
 
-      var [start, end] = this._startEndProps;
+      var [start, end] = this.startEndProps;
       var low = 0;
       var high = elements.length - 1;
 
       if (
         aX < elements[low].getBoundingClientRect()[start] ||
         aX > elements[high].getBoundingClientRect()[end]
       ) {
         return null;
@@ -610,17 +402,17 @@
       } else if (aPhysicalScrollDir > 0 && rect[end] < aX) {
         mid = Math.min(mid + 1, elements.length - 1);
       }
 
       return elements[mid];
     }
 
     _startScroll(index) {
-      if (this._isRTLScrollbox) {
+      if (this.isRTLScrollbox) {
         index *= -1;
       }
 
       if (this._clickToScroll) {
         this._scrollIndex = index;
         this._mousedown = true;
 
         if (this.smoothScroll) {
@@ -692,22 +484,22 @@
     }
 
     _distanceScroll(aEvent) {
       if (aEvent.detail < 2 || aEvent.detail > 3) {
         return;
       }
 
       var scrollBack = aEvent.originalTarget == this._scrollButtonUp;
-      var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;
+      var scrollLeftOrUp = this.isRTLScrollbox ? !scrollBack : scrollBack;
       var targetElement;
 
       if (aEvent.detail == 2) {
         // scroll by the size of the scrollbox
-        let [start, end] = this._startEndProps;
+        let [start, end] = this.startEndProps;
         let x;
         if (scrollLeftOrUp) {
           x = this.scrollClientRect[start] - this.scrollClientSize;
         } else {
           x = this.scrollClientRect[end] + this.scrollClientSize;
         }
         targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);
 
@@ -739,17 +531,17 @@
         this._mousedown = false;
         document.removeEventListener("mouseup", this);
         document.removeEventListener("blur", this, true);
       }
     }
 
     scrollByPixels(aPixels, aInstant) {
       let scrollOptions = { behavior: aInstant ? "instant" : "auto" };
-      scrollOptions[this._startEndProps[0]] = aPixels;
+      scrollOptions[this.startEndProps[0]] = aPixels;
       this.scrollbox.scrollBy(scrollOptions);
     }
 
     _updateScrollButtonsDisabledState() {
       if (this.hasAttribute("notoverflowing")) {
         this.setAttribute("scrolledtoend", "true");
         this.setAttribute("scrolledtostart", "true");
         return;
@@ -759,42 +551,42 @@
         return;
       }
       this._scrollButtonUpdatePending = true;
 
       // Wait until after the next paint to get current layout data from
       // getBoundsWithoutFlushing.
       window.requestAnimationFrame(() => {
         setTimeout(() => {
-          if (!this._startEndProps) {
+          if (!this.isConnected) {
             // We've been destroyed in the meantime.
             return;
           }
 
           this._scrollButtonUpdatePending = false;
 
           let scrolledToStart = false;
           let scrolledToEnd = false;
 
           if (this.hasAttribute("notoverflowing")) {
             scrolledToStart = true;
             scrolledToEnd = true;
           } else {
-            let [leftOrTop, rightOrBottom] = this._startEndProps;
+            let [leftOrTop, rightOrBottom] = this.startEndProps;
             let leftOrTopEdge = ele =>
               Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);
             let rightOrBottomEdge = ele =>
               Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);
 
             let elements = this._getScrollableElements();
             let [leftOrTopElement, rightOrBottomElement] = [
               elements[0],
               elements[elements.length - 1],
             ];
-            if (this._isRTLScrollbox) {
+            if (this.isRTLScrollbox) {
               [leftOrTopElement, rightOrBottomElement] = [
                 rightOrBottomElement,
                 leftOrTopElement,
               ];
             }
 
             // XXX: For some reason the scrolled to start/end detection isn't working with Shadow DOM impl. May
             // have something do with calls to getBoundsWithoutFlushing, or maybe some missing styles:
@@ -805,25 +597,25 @@
             //   rightOrBottomEdge(rightOrBottomElement) <=
             //     rightOrBottomEdge(this.scrollbox)
             // );
 
             if (
               leftOrTopElement &&
               leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)
             ) {
-              scrolledToStart = !this._isRTLScrollbox;
-              scrolledToEnd = this._isRTLScrollbox;
+              scrolledToStart = !this.isRTLScrollbox;
+              scrolledToEnd = this.isRTLScrollbox;
             } else if (
               rightOrBottomElement &&
               rightOrBottomEdge(rightOrBottomElement) <=
                 rightOrBottomEdge(this.scrollbox)
             ) {
-              scrolledToStart = this._isRTLScrollbox;
-              scrolledToEnd = !this._isRTLScrollbox;
+              scrolledToStart = this.isRTLScrollbox;
+              scrolledToEnd = !this.isRTLScrollbox;
             }
           }
 
           if (scrolledToEnd) {
             this.setAttribute("scrolledtoend", "true");
           } else {
             this.removeAttribute("scrolledtoend");
           }
@@ -839,12 +631,237 @@
 
     disconnectedCallback() {
       // Release timer to avoid reference cycles.
       if (this._scrollTimer) {
         this._scrollTimer.cancel();
         this._scrollTimer = null;
       }
     }
+
+    on_wheel(event) {
+      // Don't consume the event if we can't scroll.
+      if (this.hasAttribute("notoverflowing")) {
+        return;
+      }
+
+      let doScroll = false;
+      let instant;
+      let scrollAmount = 0;
+      if (this.orient == "vertical") {
+        doScroll = true;
+        if (event.deltaMode == event.DOM_DELTA_PIXEL) {
+          scrollAmount = event.deltaY;
+        } else if (event.deltaMode == event.DOM_DELTA_PAGE) {
+          scrollAmount = event.deltaY * this.scrollClientSize;
+        } else {
+          scrollAmount = event.deltaY * this.lineScrollAmount;
+        }
+      } else {
+        // We allow vertical scrolling to scroll a horizontal scrollbox
+        // because many users have a vertical scroll wheel but no
+        // horizontal support.
+        // Because of this, we need to avoid scrolling chaos on trackpads
+        // and mouse wheels that support simultaneous scrolling in both axes.
+        // We do this by scrolling only when the last two scroll events were
+        // on the same axis as the current scroll event.
+        // For diagonal scroll events we only respect the dominant axis.
+        let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);
+        let delta = isVertical ? event.deltaY : event.deltaX;
+        let scrollByDelta = isVertical && this.isRTLScrollbox ? -delta : delta;
+
+        if (this._prevMouseScrolls.every(prev => prev == isVertical)) {
+          doScroll = true;
+          if (event.deltaMode == event.DOM_DELTA_PIXEL) {
+            scrollAmount = scrollByDelta;
+            instant = true;
+          } else if (event.deltaMode == event.DOM_DELTA_PAGE) {
+            scrollAmount = scrollByDelta * this.scrollClientSize;
+          } else {
+            scrollAmount = scrollByDelta * this.lineScrollAmount;
+          }
+        }
+
+        if (this._prevMouseScrolls.length > 1) {
+          this._prevMouseScrolls.shift();
+        }
+        this._prevMouseScrolls.push(isVertical);
+      }
+
+      if (doScroll) {
+        let direction = scrollAmount < 0 ? -1 : 1;
+        let startPos = this.scrollPosition;
+
+        if (!this._isScrolling || this._direction != direction) {
+          this._destination = startPos + scrollAmount;
+          this._direction = direction;
+        } else {
+          // We were already in the process of scrolling in this direction
+          this._destination = this._destination + scrollAmount;
+          scrollAmount = this._destination - startPos;
+        }
+        this.scrollByPixels(scrollAmount, instant);
+      }
+
+      event.stopPropagation();
+      event.preventDefault();
+    }
+
+    on_touchstart(event) {
+      if (event.touches.length > 1) {
+        // Multiple touch points detected, abort. In particular this aborts
+        // the panning gesture when the user puts a second finger down after
+        // already panning with one finger. Aborting at this point prevents
+        // the pan gesture from being resumed until all fingers are lifted
+        // (as opposed to when the user is back down to one finger).
+        this._touchStart = -1;
+      } else {
+        this._touchStart =
+          this.orient == "vertical"
+            ? event.touches[0].screenY
+            : event.touches[0].screenX;
+      }
+    }
+
+    on_touchmove(event) {
+      if (event.touches.length == 1 && this._touchStart >= 0) {
+        var touchPoint =
+          this.orient == "vertical"
+            ? event.touches[0].screenY
+            : event.touches[0].screenX;
+        var delta = this._touchStart - touchPoint;
+        if (Math.abs(delta) > 0) {
+          this.scrollByPixels(delta, true);
+          this._touchStart = touchPoint;
+        }
+        event.preventDefault();
+      }
+    }
+
+    on_touchend(event) {
+      this._touchStart = -1;
+    }
+
+    on_underflow(event) {
+      // Ignore underflow events:
+      // - from nested scrollable elements
+      // - corresponding to an overflow event that we ignored
+      if (
+        event.target != this.scrollbox ||
+        this.hasAttribute("notoverflowing")
+      ) {
+        return;
+      }
+
+      // Ignore events that doesn't match our orientation.
+      // Scrollport event orientation:
+      //   0: vertical
+      //   1: horizontal
+      //   2: both
+      let ignore = false;
+      if (this.orient == "vertical") {
+        if (event.detail == 1) {
+          ignore = true;
+        }
+      } else if (event.detail == 0) {
+        // horizontal scrollbox
+        ignore = true;
+      }
+
+      if (!ignore) {
+        this.setAttribute("notoverflowing", "true");
+        this._updateScrollButtonsDisabledState();
+      }
+      this.dispatchEvent(new Event("underflow"));
+    }
+
+    on_overflow(event) {
+      // Ignore overflow events:
+      // - from nested scrollable elements
+      if (event.target != this.scrollbox) {
+        return;
+      }
+
+      // Ignore events that doesn't match our orientation.
+      // Scrollport event orientation:
+      //   0: vertical
+      //   1: horizontal
+      //   2: both
+      let ignore = false;
+      if (this.orient == "vertical") {
+        if (event.detail == 1) {
+          ignore = true;
+        }
+      } else if (event.detail == 0) {
+        // horizontal scrollbox
+        ignore = true;
+      }
+
+      if (!ignore) {
+        this.removeAttribute("notoverflowing");
+        this._updateScrollButtonsDisabledState();
+      }
+      this.dispatchEvent(new Event("overflow"));
+    }
+
+    on_scroll(event) {
+      this._isScrolling = true;
+      this._updateScrollButtonsDisabledState();
+      this.dispatchEvent(new Event("scroll"));
+    }
+
+    on_scrollend(event) {
+      this._isScrolling = false;
+      this._destination = 0;
+      this._direction = 0;
+    }
+
+    on_click(event) {
+      if (
+        event.originalTarget != this._scrollButtonUp &&
+        event.originalTarget != this._scrollButtonDown
+      ) {
+        return;
+      }
+      this._onButtonClick(event);
+    }
+
+    on_mousedown(event) {
+      if (event.originalTarget == this._scrollButtonUp) {
+        this._onButtonMouseDown(event, -1);
+      }
+      if (event.originalTarget == this._scrollButtonDown) {
+        this._onButtonMouseDown(event, 1);
+      }
+    }
+
+    on_mouseup(event) {
+      if (
+        event.originalTarget != this._scrollButtonUp &&
+        event.originalTarget != this._scrollButtonDown
+      ) {
+        return;
+      }
+      this._onButtonMouseUp(event);
+    }
+
+    on_mouseover(event) {
+      if (event.originalTarget == this._scrollButtonUp) {
+        this._onButtonMouseOver(-1);
+      }
+      if (event.originalTarget == this._scrollButtonDown) {
+        this._onButtonMouseOver(1);
+      }
+    }
+
+    on_mouseout(event) {
+      if (
+        event.originalTarget != this._scrollButtonUp &&
+        event.originalTarget != this._scrollButtonDown
+      ) {
+        return;
+      }
+      this._onButtonMouseOut();
+    }
   }
 
   customElements.define("arrowscrollbox", MozArrowScrollbox);
 }
