# HG changeset patch
# Parent 2e2222a40262fbd848f59204e418ea05d7416274
# User Florent Fayolle <fayolle-florent@orange.fr>
# Parent  01482cdccd72b4f36f10ff3706a92c4c77c48253
Bug 1143497 - Offer a way to extend WebConsole commands

diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -27,17 +27,17 @@ XPCOMUtils.defineLazyGetter(this, "Conso
   return require("devtools/toolkit/webconsole/network-monitor")
          .ConsoleProgressListener;
 });
 XPCOMUtils.defineLazyGetter(this, "events", () => {
   return require("sdk/event/core");
 });
 
 for (let name of ["WebConsoleUtils", "ConsoleServiceListener",
-                  "ConsoleAPIListener", "JSTermHelpers", "JSPropertyProvider",
+                  "ConsoleAPIListener", "WebConsoleCommands", "JSPropertyProvider",
                   "ConsoleReflowListener"]) {
   Object.defineProperty(this, name, {
     get: function(prop) {
       if (prop == "WebConsoleUtils") {
         prop = "Utils";
       }
       return require("devtools/toolkit/webconsole/utils")[prop];
     }.bind(null, name),
@@ -866,17 +866,17 @@ WebConsoleActor.prototype =
     // We consider '$' as alphanumerc because it is used in the names of some
     // helper functions.
     let lastNonAlphaIsDot = /[.][a-zA-Z0-9$]*$/.test(reqText);
     if (!lastNonAlphaIsDot) {
       if (!this._jstermHelpersCache) {
         let helpers = {
           sandbox: Object.create(null)
         };
-        JSTermHelpers(helpers);
+        WebConsoleCommands._addBindings(helpers);
         this._jstermHelpersCache = Object.getOwnPropertyNames(helpers.sandbox);
       }
       matches = matches.concat(this._jstermHelpersCache.filter(n => n.startsWith(result.matchProp)));
     }
 
     return {
       from: this.actorID,
       matches: matches.sort(),
@@ -952,28 +952,28 @@ WebConsoleActor.prototype =
    * @param object aDebuggerGlobal
    *        A Debugger.Object that wraps a content global. This is used for the
    *        JSTerm helpers.
    * @return object
    *         The same object as |this|, but with an added |sandbox| property.
    *         The sandbox holds methods and properties that can be used as
    *         bindings during JS evaluation.
    */
-  _getJSTermHelpers: function WCA__getJSTermHelpers(aDebuggerGlobal)
+  _getWebConsoleCommands: function(aDebuggerGlobal)
   {
     let helpers = {
       window: this.evalWindow,
       chromeWindow: this.chromeWindow.bind(this),
       makeDebuggeeValue: aDebuggerGlobal.makeDebuggeeValue.bind(aDebuggerGlobal),
       createValueGrip: this.createValueGrip.bind(this),
       sandbox: Object.create(null),
       helperResult: null,
       consoleActor: this,
     };
-    JSTermHelpers(helpers);
+    WebConsoleCommands._addBindings(helpers);
 
     let evalWindow = this.evalWindow;
     function maybeExport(obj, name) {
       if (typeof obj[name] != "function") {
         return;
       }
 
       // By default, chrome-implemented functions that are exposed to content
@@ -1106,17 +1106,17 @@ WebConsoleActor.prototype =
         // jsObj appropriately for the evaluation compartment.
         let global = Cu.getGlobalForObject(jsObj);
         dbgWindow = dbg.makeGlobalObjectReference(global);
         bindSelf = dbgWindow.makeDebuggeeValue(jsObj);
       }
     }
 
     // Get the JSTerm helpers for the given debugger window.
-    let helpers = this._getJSTermHelpers(dbgWindow);
+    let helpers = this._getWebConsoleCommands(dbgWindow);
     let bindings = helpers.sandbox;
     if (bindSelf) {
       bindings._self = bindSelf;
     }
 
     if (aOptions.selectedNodeActor) {
       let actor = this.conn.getActor(aOptions.selectedNodeActor);
       if (actor) {
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -9,17 +9,17 @@
 const {Cc, Ci, Cu, components} = require("chrome");
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyImporter(this, "Services", "resource://gre/modules/Services.jsm");
 loader.lazyImporter(this, "LayoutHelpers", "resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 // TODO: Bug 842672 - toolkit/ imports modules from browser/.
-// Note that these are only used in JSTermHelpers, see $0 and pprint().
+// Note that these are only used in WebConsoleCommands, see $0 and pprint().
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "devtools", "resource://gre/modules/devtools/Loader.jsm");
 loader.lazyImporter(this, "VariablesView", "resource:///modules/devtools/VariablesView.jsm");
 loader.lazyImporter(this, "DevToolsUtils", "resource://gre/modules/devtools/DevToolsUtils.jsm");
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
@@ -27,17 +27,17 @@ loader.lazyImporter(this, "DevToolsUtils
 // function foobar2(a) { ...
 // function() { ...
 const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;
 
 // Match the function arguments from the result of toString() or toSource().
 const REGEX_MATCH_FUNCTION_ARGS = /^\(?function\s*[^\s(]*\s*\((.+?)\)/;
 
 // Number of terminal entries for the self-xss prevention to go away
-const CONSOLE_ENTRY_THRESHOLD = 5
+const CONSOLE_ENTRY_THRESHOLD = 5;
 
 // Provide an easy way to bail out of even attempting an autocompletion
 // if an object has way too many properties. Protects against large objects
 // with numeric values that wouldn't be tallied towards MAX_AUTOCOMPLETIONS.
 const MAX_AUTOCOMPLETE_ATTEMPTS = exports.MAX_AUTOCOMPLETE_ATTEMPTS = 100000;
 
 // Prevent iterating over too many properties during autocomplete suggestions.
 const MAX_AUTOCOMPLETIONS = exports.MAX_AUTOCOMPLETIONS = 1500;
@@ -545,17 +545,17 @@ let WebConsoleUtils = {
    * Value of devtools.selfxss.count preference
    *
    * @type number
    * @private
    */
   _usageCount: 0,
   get usageCount() {
     if (WebConsoleUtils._usageCount < CONSOLE_ENTRY_THRESHOLD) {
-      WebConsoleUtils._usageCount = Services.prefs.getIntPref("devtools.selfxss.count")
+      WebConsoleUtils._usageCount = Services.prefs.getIntPref("devtools.selfxss.count");
       if (Services.prefs.getBoolPref("devtools.chrome.enabled")) {
         WebConsoleUtils.usageCount = CONSOLE_ENTRY_THRESHOLD;
       }
     }
     return WebConsoleUtils._usageCount;
   },
   set usageCount(newUC) {
     if (newUC <= CONSOLE_ENTRY_THRESHOLD) {
@@ -907,17 +907,17 @@ function JSPropertyProvider(aDbgObject, 
   // We get the rest of the properties recursively starting from the Debugger.Object
   // that wraps the first property
   for (let prop of properties) {
     prop = prop.trim();
     if (!prop) {
       return null;
     }
 
-    if (/\[\d+\]$/.test(prop))Â {
+    if (/\[\d+\]$/.test(prop)) {
       // The property to autocomplete is a member of array. For example
       // list[i][j]..[n]. Traverse the array to get the actual element.
       obj = getArrayMemberProperty(obj, prop);
     }
     else {
       obj = DevToolsUtils.getProperty(obj, prop);
     }
 
@@ -1502,303 +1502,396 @@ ConsoleAPIListener.prototype =
    */
   destroy: function CAL_destroy()
   {
     Services.obs.removeObserver(this, "console-api-log-event");
     this.window = this.owner = null;
   },
 };
 
+/**
+ * WebConsole commands manager.
+ *
+ * Defines a set of functions /variables ("commands") that are available from
+ * the Web Console but not from the web page.
+ */
 
+let WebConsoleCommands = {
+  _registeredCommands: new Map(),
+
+  /**
+   * Register a new command.
+   * @param {string} name The command name (exemple: "$")
+   * @param {(function|object)} command The command to register.
+   *  It can be a function so the command is a function (like "$()"),
+   *  or it can also be a property descriptor to describe a getter / value (like
+   *  "$0").
+   *
+   *  The command function or the command getter are passed a owner object as
+   *  their first parameter (see the example below).
+   *
+   *  Note that setters don't work currently and "enumerable" and "configurable"
+   *  are forced to true.
+   *
+   * @example
+   *
+   *   WebConsoleCommands.register("$", function JSTH_$(aOwner, aSelector)
+   *   {
+   *     return aOwner.window.document.querySelector(aSelector);
+   *   });
+   *
+   *   WebConsoleCommands.register("$0", {
+   *     get: function(aOwner) {
+   *       return aOwner.makeDebuggeeValue(aOwner.selectedNode);
+   *     }
+   *   });
+   */
+  register: function(name, command) {
+    this._registeredCommands.set(name, command);
+  },
+
+  /**
+   * Unregister a command.
+   *
+   * @param {string} name The name of the command
+   */
+  unregister: function(name) {
+    this._registeredCommands.delete(name);
+  },
+
+  /**
+   * Returns a command by its name.
+   *
+   * @param {string} name The name of the command.
+   *
+   * @return {(function|object)} The command.
+   */
+  getCommand: function(name) {
+    return this._registeredCommands.get(name);
+  },
+
+  /**
+   * Returns true if a command is registered with the given name.
+   *
+   * @param {string} name The name of the command.
+   *
+   * @return {boolean} True if the command is registered.
+   */
+  hasCommand: function(name) {
+    return this._registeredCommands.has(name);
+  },
+
+  /**
+   * (Internal only) Add the bindings to |owner.sandbox|.
+   * This is intended to be used by the WebConsole actor only.
+   *
+   * @param object aOwner
+   *        The owning object.
+   */
+  _addBindings: function(owner) {
+    if (!owner) {
+      throw new Error("The owner is required");
+    }
+    for (let [name, command] of this._registeredCommands) {
+      if (typeof command === "object") {
+        let clone = Object.assign({}, command, {
+          // We force the enumerability and the configurability (so the
+          // WebConsoleActor can reconfigure the property).
+          enumerable: true,
+          configurable: true
+        });
+        for (let funcName of ["get", "set"]) {
+          let func = command[funcName];
+          if (typeof func === "function") {
+            clone[funcName] = func.bind(undefined, owner);
+          }
+        }
+        Object.defineProperty(owner.sandbox, name, clone);
+      }
+      else {
+        owner.sandbox[name] = command.bind(undefined, owner);
+      }
+    }
+  },
+};
+
+exports.WebConsoleCommands = WebConsoleCommands;
 
 /**
- * JSTerm helper functions.
- *
- * Defines a set of functions ("helper functions") that are available from the
- * Web Console but not from the web page.
- *
+ * Built in helper functions
  * A list of helper functions used by Firebug can be found here:
  *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ */
+
+/**
+ * Find a node by ID.
  *
- * @param object aOwner
- *        The owning object.
+ * @param string aId
+ *        The ID of the element you want.
+ * @return nsIDOMNode or null
+ *         The result of calling document.querySelector(aSelector).
  */
-function JSTermHelpers(aOwner)
+WebConsoleCommands.register("$", function JSTH_$(aOwner, aSelector)
 {
-  /**
-   * Find a node by ID.
-   *
-   * @param string aId
-   *        The ID of the element you want.
-   * @return nsIDOMNode or null
-   *         The result of calling document.querySelector(aSelector).
-   */
-  aOwner.sandbox.$ = function JSTH_$(aSelector)
-  {
-    return aOwner.window.document.querySelector(aSelector);
+  return aOwner.window.document.querySelector(aSelector);
+});
+
+/**
+ * Find the nodes matching a CSS selector.
+ *
+ * @param string aSelector
+ *        A string that is passed to window.document.querySelectorAll.
+ * @return nsIDOMNodeList
+ *         Returns the result of document.querySelectorAll(aSelector).
+ */
+WebConsoleCommands.register("$$", function JSTH_$$(aOwner, aSelector)
+{
+  return aOwner.window.document.querySelectorAll(aSelector);
+});
+
+/**
+ * Runs an xPath query and returns all matched nodes.
+ *
+ * @param string aXPath
+ *        xPath search query to execute.
+ * @param [optional] nsIDOMNode aContext
+ *        Context to run the xPath query on. Uses window.document if not set.
+ * @return array of nsIDOMNode
+ */
+WebConsoleCommands.register("$x", function JSTH_$x(aOwner, aXPath, aContext)
+{
+  let nodes = new aOwner.window.wrappedJSObject.Array();
+  let doc = aOwner.window.document;
+  aContext = aContext || doc;
+
+  let results = doc.evaluate(aXPath, aContext, null,
+                             Ci.nsIDOMXPathResult.ANY_TYPE, null);
+  let node;
+  while ((node = results.iterateNext())) {
+    nodes.push(node);
+  }
+
+  return nodes;
+});
+
+/**
+ * Returns the currently selected object in the highlighter.
+ *
+ * @return Object representing the current selection in the
+ *         Inspector, or null if no selection exists.
+ */
+WebConsoleCommands.register("$0", {
+  get: function(aOwner) {
+    return aOwner.makeDebuggeeValue(aOwner.selectedNode);
+  }
+});
+
+/**
+ * Clears the output of the WebConsole.
+ */
+WebConsoleCommands.register("clear", function JSTH_clear(aOwner)
+{
+  aOwner.helperResult = {
+    type: "clearOutput",
   };
+});
 
-  /**
-   * Find the nodes matching a CSS selector.
-   *
-   * @param string aSelector
-   *        A string that is passed to window.document.querySelectorAll.
-   * @return nsIDOMNodeList
-   *         Returns the result of document.querySelectorAll(aSelector).
-   */
-  aOwner.sandbox.$$ = function JSTH_$$(aSelector)
-  {
-    return aOwner.window.document.querySelectorAll(aSelector);
+/**
+ * Clears the input history of the WebConsole.
+ */
+WebConsoleCommands.register("clearHistory", function JSTH_clearHistory(aOwner)
+{
+  aOwner.helperResult = {
+    type: "clearHistory",
   };
+});
 
-  /**
-   * Runs an xPath query and returns all matched nodes.
-   *
-   * @param string aXPath
-   *        xPath search query to execute.
-   * @param [optional] nsIDOMNode aContext
-   *        Context to run the xPath query on. Uses window.document if not set.
-   * @return array of nsIDOMNode
-   */
-  aOwner.sandbox.$x = function JSTH_$x(aXPath, aContext)
-  {
-    let nodes = new aOwner.window.wrappedJSObject.Array();
-    let doc = aOwner.window.document;
-    aContext = aContext || doc;
+/**
+ * Returns the result of Object.keys(aObject).
+ *
+ * @param object aObject
+ *        Object to return the property names from.
+ * @return array of strings
+ */
+WebConsoleCommands.register("keys", function JSTH_keys(aOwner, aObject)
+{
+  return aOwner.window.wrappedJSObject.Object.keys(WebConsoleUtils.unwrap(aObject));
+});
 
-    let results = doc.evaluate(aXPath, aContext, null,
-                               Ci.nsIDOMXPathResult.ANY_TYPE, null);
-    let node;
-    while ((node = results.iterateNext())) {
-      nodes.push(node);
+/**
+ * Returns the values of all properties on aObject.
+ *
+ * @param object aObject
+ *        Object to display the values from.
+ * @return array of string
+ */
+WebConsoleCommands.register("values", function JSTH_values(aOwner, aObject)
+{
+  let arrValues = new aOwner.window.wrappedJSObject.Array();
+  let obj = WebConsoleUtils.unwrap(aObject);
+
+  for (let prop in obj) {
+    arrValues.push(obj[prop]);
+  }
+
+  return arrValues;
+});
+
+/**
+ * Opens a help window in MDN.
+ */
+WebConsoleCommands.register("help", function JSTH_help(aOwner)
+{
+  aOwner.helperResult = { type: "help" };
+});
+
+/**
+ * Change the JS evaluation scope.
+ *
+ * @param DOMElement|string|window aWindow
+ *        The window object to use for eval scope. This can be a string that
+ *        is used to perform document.querySelector(), to find the iframe that
+ *        you want to cd() to. A DOMElement can be given as well, the
+ *        .contentWindow property is used. Lastly, you can directly pass
+ *        a window object. If you call cd() with no arguments, the current
+ *        eval scope is cleared back to its default (the top window).
+ */
+WebConsoleCommands.register("cd", function JSTH_cd(aOwner, aWindow)
+{
+  if (!aWindow) {
+    aOwner.consoleActor.evalWindow = null;
+    aOwner.helperResult = { type: "cd" };
+    return;
+  }
+
+  if (typeof aWindow == "string") {
+    aWindow = aOwner.window.document.querySelector(aWindow);
+  }
+  if (aWindow instanceof Ci.nsIDOMElement && aWindow.contentWindow) {
+    aWindow = aWindow.contentWindow;
+  }
+  if (!(aWindow instanceof Ci.nsIDOMWindow)) {
+    aOwner.helperResult = { type: "error", message: "cdFunctionInvalidArgument" };
+    return;
+  }
+
+  aOwner.consoleActor.evalWindow = aWindow;
+  aOwner.helperResult = { type: "cd" };
+});
+
+/**
+ * Inspects the passed aObject. This is done by opening the PropertyPanel.
+ *
+ * @param object aObject
+ *        Object to inspect.
+ */
+WebConsoleCommands.register("inspect", function JSTH_inspect(aOwner, aObject)
+{
+  let dbgObj = aOwner.makeDebuggeeValue(aObject);
+  let grip = aOwner.createValueGrip(dbgObj);
+  aOwner.helperResult = {
+    type: "inspectObject",
+    input: aOwner.evalInput,
+    object: grip,
+  };
+});
+
+/**
+ * Prints aObject to the output.
+ *
+ * @param object aObject
+ *        Object to print to the output.
+ * @return string
+ */
+WebConsoleCommands.register("pprint", function JSTH_pprint(aOwner, aObject)
+{
+  if (aObject === null || aObject === undefined || aObject === true ||
+      aObject === false) {
+    aOwner.helperResult = {
+      type: "error",
+      message: "helperFuncUnsupportedTypeError",
+    };
+    return null;
+  }
+
+  aOwner.helperResult = { rawOutput: true };
+
+  if (typeof aObject == "function") {
+    return aObject + "\n";
+  }
+
+  let output = [];
+
+  let obj = WebConsoleUtils.unwrap(aObject);
+  for (let name in obj) {
+    let desc = WebConsoleUtils.getPropertyDescriptor(obj, name) || {};
+    if (desc.get || desc.set) {
+      // TODO: Bug 842672 - toolkit/ imports modules from browser/.
+      let getGrip = VariablesView.getGrip(desc.get);
+      let setGrip = VariablesView.getGrip(desc.set);
+      let getString = VariablesView.getString(getGrip);
+      let setString = VariablesView.getString(setGrip);
+      output.push(name + ":", "  get: " + getString, "  set: " + setString);
     }
+    else {
+      let valueGrip = VariablesView.getGrip(obj[name]);
+      let valueString = VariablesView.getString(valueGrip);
+      output.push(name + ": " + valueString);
+    }
+  }
 
-    return nodes;
+  return "  " + output.join("\n  ");
+});
+
+/**
+ * Print the String representation of a value to the output, as-is.
+ *
+ * @param any aValue
+ *        A value you want to output as a string.
+ * @return void
+ */
+WebConsoleCommands.register("print", function JSTH_print(aOwner, aValue)
+{
+  aOwner.helperResult = { rawOutput: true };
+  if (typeof aValue === "symbol") {
+    return Symbol.prototype.toString.call(aValue);
+  }
+  // Waiving Xrays here allows us to see a closer representation of the
+  // underlying object. This may execute arbitrary content code, but that
+  // code will run with content privileges, and the result will be rendered
+  // inert by coercing it to a String.
+  return String(Cu.waiveXrays(aValue));
+});
+
+/**
+ * Copy the String representation of a value to the clipboard.
+ *
+ * @param any aValue
+ *        A value you want to copy as a string.
+ * @return void
+ */
+WebConsoleCommands.register("copy", function JSTH_copy(aOwner, aValue)
+{
+  let payload;
+  try {
+    if (aValue instanceof Ci.nsIDOMElement) {
+      payload = aValue.outerHTML;
+    } else if (typeof aValue == "string") {
+      payload = aValue;
+    } else {
+      payload = JSON.stringify(aValue, null, "  ");
+    }
+  } catch (ex) {
+    payload = "/* " + ex  + " */";
+  }
+  aOwner.helperResult = {
+    type: "copyValueToClipboard",
+    value: payload,
   };
-
-  /**
-   * Returns the currently selected object in the highlighter.
-   *
-   * @return Object representing the current selection in the
-   *         Inspector, or null if no selection exists.
-   */
-  Object.defineProperty(aOwner.sandbox, "$0", {
-    get: function() {
-      return aOwner.makeDebuggeeValue(aOwner.selectedNode)
-    },
-    enumerable: true,
-    configurable: true
-  });
-
-  /**
-   * Clears the output of the JSTerm.
-   */
-  aOwner.sandbox.clear = function JSTH_clear()
-  {
-    aOwner.helperResult = {
-      type: "clearOutput",
-    };
-  };
-
-  /**
-   * Clears the input history of the JSTerm.
-   */
-  aOwner.sandbox.clearHistory = function JSTH_clearHistory()
-  {
-    aOwner.helperResult = {
-      type: "clearHistory",
-    };
-  };
-
-  /**
-   * Returns the result of Object.keys(aObject).
-   *
-   * @param object aObject
-   *        Object to return the property names from.
-   * @return array of strings
-   */
-  aOwner.sandbox.keys = function JSTH_keys(aObject)
-  {
-    return aOwner.window.wrappedJSObject.Object.keys(WebConsoleUtils.unwrap(aObject));
-  };
-
-  /**
-   * Returns the values of all properties on aObject.
-   *
-   * @param object aObject
-   *        Object to display the values from.
-   * @return array of string
-   */
-  aOwner.sandbox.values = function JSTH_values(aObject)
-  {
-    let arrValues = new aOwner.window.wrappedJSObject.Array();
-    let obj = WebConsoleUtils.unwrap(aObject);
-
-    for (let prop in obj) {
-      arrValues.push(obj[prop]);
-    }
-
-    return arrValues;
-  };
-
-  /**
-   * Opens a help window in MDN.
-   */
-  aOwner.sandbox.help = function JSTH_help()
-  {
-    aOwner.helperResult = { type: "help" };
-  };
-
-  /**
-   * Change the JS evaluation scope.
-   *
-   * @param DOMElement|string|window aWindow
-   *        The window object to use for eval scope. This can be a string that
-   *        is used to perform document.querySelector(), to find the iframe that
-   *        you want to cd() to. A DOMElement can be given as well, the
-   *        .contentWindow property is used. Lastly, you can directly pass
-   *        a window object. If you call cd() with no arguments, the current
-   *        eval scope is cleared back to its default (the top window).
-   */
-  aOwner.sandbox.cd = function JSTH_cd(aWindow)
-  {
-    if (!aWindow) {
-      aOwner.consoleActor.evalWindow = null;
-      aOwner.helperResult = { type: "cd" };
-      return;
-    }
-
-    if (typeof aWindow == "string") {
-      aWindow = aOwner.window.document.querySelector(aWindow);
-    }
-    if (aWindow instanceof Ci.nsIDOMElement && aWindow.contentWindow) {
-      aWindow = aWindow.contentWindow;
-    }
-    if (!(aWindow instanceof Ci.nsIDOMWindow)) {
-      aOwner.helperResult = { type: "error", message: "cdFunctionInvalidArgument" };
-      return;
-    }
-
-    aOwner.consoleActor.evalWindow = aWindow;
-    aOwner.helperResult = { type: "cd" };
-  };
-
-  /**
-   * Inspects the passed aObject. This is done by opening the PropertyPanel.
-   *
-   * @param object aObject
-   *        Object to inspect.
-   */
-  aOwner.sandbox.inspect = function JSTH_inspect(aObject)
-  {
-    let dbgObj = aOwner.makeDebuggeeValue(aObject);
-    let grip = aOwner.createValueGrip(dbgObj);
-    aOwner.helperResult = {
-      type: "inspectObject",
-      input: aOwner.evalInput,
-      object: grip,
-    };
-  };
-
-  /**
-   * Prints aObject to the output.
-   *
-   * @param object aObject
-   *        Object to print to the output.
-   * @return string
-   */
-  aOwner.sandbox.pprint = function JSTH_pprint(aObject)
-  {
-    if (aObject === null || aObject === undefined || aObject === true ||
-        aObject === false) {
-      aOwner.helperResult = {
-        type: "error",
-        message: "helperFuncUnsupportedTypeError",
-      };
-      return null;
-    }
-
-    aOwner.helperResult = { rawOutput: true };
-
-    if (typeof aObject == "function") {
-      return aObject + "\n";
-    }
-
-    let output = [];
-
-    let obj = WebConsoleUtils.unwrap(aObject);
-    for (let name in obj) {
-      let desc = WebConsoleUtils.getPropertyDescriptor(obj, name) || {};
-      if (desc.get || desc.set) {
-        // TODO: Bug 842672 - toolkit/ imports modules from browser/.
-        let getGrip = VariablesView.getGrip(desc.get);
-        let setGrip = VariablesView.getGrip(desc.set);
-        let getString = VariablesView.getString(getGrip);
-        let setString = VariablesView.getString(setGrip);
-        output.push(name + ":", "  get: " + getString, "  set: " + setString);
-      }
-      else {
-        let valueGrip = VariablesView.getGrip(obj[name]);
-        let valueString = VariablesView.getString(valueGrip);
-        output.push(name + ": " + valueString);
-      }
-    }
-
-    return "  " + output.join("\n  ");
-  };
-
-  /**
-   * Print the String representation of a value to the output, as-is.
-   *
-   * @param any aValue
-   *        A value you want to output as a string.
-   * @return void
-   */
-  aOwner.sandbox.print = function JSTH_print(aValue)
-  {
-    aOwner.helperResult = { rawOutput: true };
-    if (typeof aValue === "symbol") {
-      return Symbol.prototype.toString.call(aValue);
-    }
-    // Waiving Xrays here allows us to see a closer representation of the
-    // underlying object. This may execute arbitrary content code, but that
-    // code will run with content privileges, and the result will be rendered
-    // inert by coercing it to a String.
-    return String(Cu.waiveXrays(aValue));
-  };
-
-  /**
-   * Copy the String representation of a value to the clipboard.
-   *
-   * @param any aValue
-   *        A value you want to copy as a string.
-   * @return void
-   */
-  aOwner.sandbox.copy = function JSTH_copy(aValue)
-  {
-    let payload;
-    try {
-      if (aValue instanceof Ci.nsIDOMElement) {
-        payload = aValue.outerHTML;
-      } else if (typeof aValue == "string") {
-        payload = aValue;
-      } else {
-        payload = JSON.stringify(aValue, null, "  ");
-      }
-    } catch (ex) {
-      payload = "/* " + ex  + " */";
-    }
-    aOwner.helperResult = {
-      type: "copyValueToClipboard",
-      value: payload,
-    };
-  };
-}
-exports.JSTermHelpers = JSTermHelpers;
-
+});
 
 /**
  * A ReflowObserver that listens for reflow events from the page.
  * Implements nsIReflowObserver.
  *
  * @constructor
  * @param object aWindow
  *        The window for which we need to track reflow.
