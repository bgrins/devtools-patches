# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  9028d93acbd1ab12e5dc79e520d1be85a1450e97

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -192,16 +192,18 @@ window.addEventListener("DOMContentLoade
     } catch (ex) { console.error(ex); }
     element.isRunningDelayedConnectedCallback = false;
   }
   gElementsPendingConnection.clear();
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
+const gXULDOMFragments = {};
+const gXULDOMFragments1 = {};
 
 MozElements.MozElementMixin = Base => {
   let MozElementBase = class extends Base {
   constructor() {
     super();
 
     if (instrumentClasses) {
       let proto = this.constructor;
@@ -405,16 +407,34 @@ MozElements.MozElementMixin = Base => {
     gElementsPendingConnection.add(this);
     return true;
   }
 
   get isConnectedAndReady() {
     return gIsDOMContentLoaded && this.isConnected;
   }
 
+  static parseXULToFragTemplate(markup) {
+    if (!gXULDOMFragments[markup]) {
+      let doc = gXULDOMParser.parseFromString(`
+        <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+              xmlns:html="http://www.w3.org/1999/xhtml">
+          <html:template>
+            ${markup}
+          </html:template>
+        </box>
+      `, "application/xml");
+
+      gXULDOMFragments[markup] = doc.firstElementChild.firstElementChild.content;
+    }
+
+
+    return gXULDOMFragments[markup].cloneNode(true);
+  }
+
   /**
    * Allows eager deterministic construction of XUL elements with XBL attached, by
    * parsing an element tree and returning a DOM fragment to be inserted in the
    * document before any of the inner elements is referenced by JavaScript.
    *
    * This process is required instead of calling the createElement method directly
    * because bindings get attached when:
    *
@@ -432,48 +452,54 @@ MozElements.MozElementMixin = Base => {
    * @param {string[]} [entities]
    *        An array of DTD URLs containing entity definitions.
    *
    * @return {DocumentFragment} `DocumentFragment` instance containing
    *         the corresponding element tree, including element nodes
    *         but excluding any text node.
    */
   static parseXULToFragment(str, entities = []) {
-    let doc = gXULDOMParser.parseFromString(`
+    let markup = `
       ${entities.length ? `<!DOCTYPE bindings [
         ${entities.reduce((preamble, url, index) => {
           return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}">
             %_dtd-${index};
             `;
         }, "")}
       ]>` : ""}
       <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-           xmlns:html="http://www.w3.org/1999/xhtml">
+          xmlns:html="http://www.w3.org/1999/xhtml">
         ${str}
       </box>
-    `, "application/xml");
-    // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
-    // does not do this. Most XUL code assumes that the whitespace has been
-    // stripped out, so we simply remove all text nodes after using the parser.
-    let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
-    let currentNode = nodeIterator.nextNode();
-    while (currentNode) {
-      // Remove whitespace-only nodes. Regex is taken from:
-      // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace_in_the_DOM
-      if (!(/[^\t\n\r ]/.test(currentNode.textContent))) {
-        currentNode.remove();
+    `;
+
+    if (!gXULDOMFragments1[markup]) {
+      let doc = gXULDOMParser.parseFromString(markup, "application/xml");
+
+      // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
+      // does not do this. Most XUL code assumes that the whitespace has been
+      // stripped out, so we simply remove all text nodes after using the parser.
+      let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
+      let currentNode = nodeIterator.nextNode();
+      while (currentNode) {
+        // Remove whitespace-only nodes. Regex is taken from:
+        // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace_in_the_DOM
+        if (!(/[^\t\n\r ]/.test(currentNode.textContent))) {
+          currentNode.remove();
+        }
+
+        currentNode = nodeIterator.nextNode();
       }
-
-      currentNode = nodeIterator.nextNode();
+      // We use a range here so that we don't access the inner DOM elements from
+      // JavaScript before they are imported and inserted into a document.
+      let range = doc.createRange();
+      range.selectNodeContents(doc.querySelector("box"));
+      gXULDOMFragments1[markup] = range.extractContents();
     }
-    // We use a range here so that we don't access the inner DOM elements from
-    // JavaScript before they are imported and inserted into a document.
-    let range = doc.createRange();
-    range.selectNodeContents(doc.querySelector("box"));
-    return range.extractContents();
+    return gXULDOMFragments1[markup].cloneNode(true);
   }
 
   /**
    * Insert a localization link to an FTL file. This is used so that
    * a Custom Element can wait to inject the link until it's connected,
    * and so that consuming documents don't require the correct <link>
    * present in the markup.
    *
diff --git a/toolkit/content/widgets/menu.js b/toolkit/content/widgets/menu.js
--- a/toolkit/content/widgets/menu.js
+++ b/toolkit/content/widgets/menu.js
@@ -183,34 +183,34 @@ class MozMenu extends MozMenuBaseMixin(M
   }
 
   get fragment() {
     let {isMenubarChild, isIconic} = this;
     let fragment = null;
     // Add aria-hidden="true" on all DOM, since XULMenuAccessible handles accessibility here.
     if (isMenubarChild && isIconic) {
       if (!MozMenu.menubarIconicFrag) {
-        MozMenu.menubarIconicFrag = MozXULElement.parseXULToFragment(`
+        MozMenu.menubarIconicFrag = MozXULElement.parseXULToFragTemplate(`
           <image class="menubar-left" aria-hidden="true"/>
           <label class="menubar-text" crop="right" aria-hidden="true"/>
         `);
       }
       fragment = document.importNode(MozMenu.menubarIconicFrag, true);
     }
     if (isMenubarChild && !isIconic) {
       if (!MozMenu.menubarFrag) {
-        MozMenu.menubarFrag = MozXULElement.parseXULToFragment(`
+        MozMenu.menubarFrag = MozXULElement.parseXULToFragTemplate(`
           <label class="menubar-text" crop="right" aria-hidden="true"/>
         `);
       }
       fragment = document.importNode(MozMenu.menubarFrag, true);
     }
     if (!isMenubarChild && isIconic) {
       if (!MozMenu.normalIconicFrag) {
-        MozMenu.normalIconicFrag = MozXULElement.parseXULToFragment(`
+        MozMenu.normalIconicFrag = MozXULElement.parseXULToFragTemplate(`
           <hbox class="menu-iconic-left" align="center" pack="center" aria-hidden="true">
             <image class="menu-iconic-icon"/>
           </hbox>
           <label class="menu-iconic-text" flex="1" crop="right" aria-hidden="true"/>
           <label class="menu-iconic-highlightable-text" crop="right" aria-hidden="true"/>
           <hbox class="menu-accel-container" anonid="accel" aria-hidden="true">
             <label class="menu-iconic-accel"/>
           </hbox>
@@ -219,17 +219,17 @@ class MozMenu extends MozMenuBaseMixin(M
           </hbox>
        `);
       }
 
       fragment = document.importNode(MozMenu.normalIconicFrag, true);
     }
     if (!isMenubarChild && !isIconic) {
       if (!MozMenu.normalFrag) {
-        MozMenu.normalFrag = MozXULElement.parseXULToFragment(`
+        MozMenu.normalFrag = MozXULElement.parseXULToFragTemplate(`
           <label class="menu-text" crop="right" aria-hidden="true"/>
           <hbox class="menu-accel-container" anonid="accel" aria-hidden="true">
             <label class="menu-accel"/>
           </hbox>
           <hbox align="center" class="menu-right" aria-hidden="true">
             <image/>
           </hbox>
        `);
