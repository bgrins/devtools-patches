diff --git a/browser/base/content/test/performance/browser_appmenu.js b/browser/base/content/test/performance/browser_appmenu.js
--- a/browser/base/content/test/performance/browser_appmenu.js
+++ b/browser/base/content/test/performance/browser_appmenu.js
@@ -25,8 +25,8 @@
 
   {
     stack: [
-      "adjustArrowPosition@chrome://global/content/bindings/popup.xml",
-      "onxblpopuppositioned@chrome://global/content/bindings/popup.xml",
+      "adjustArrowPosition@chrome://global/content/elements/panel.js",
+      "on_popuppositioned@chrome://global/content/elements/panel.js",
     ],
 
     maxCount: 22, // This number should only ever go down - never up.
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_background.js b/browser/components/extensions/test/browser/browser_ext_popup_background.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_background.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_background.js
@@ -5,12 +5,8 @@
 
 async function testPanel(browser, standAlone, initial_background) {
   let panel = getPanelForNode(browser);
-  let arrowContent = document.getAnonymousElementByAttribute(
-    panel,
-    "class",
-    "panel-arrowcontent"
-  );
-  let arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
+  let arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   let checkArrow = (background = null) => {
     if (background == null || !standAlone) {
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_corners.js b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_corners.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
@@ -35,11 +35,7 @@
 
   async function testPanel(browser, standAlone = true) {
     let panel = getPanelForNode(browser);
-    let arrowContent = document.getAnonymousElementByAttribute(
-      panel,
-      "class",
-      "panel-arrowcontent"
-    );
+    let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
 
     let panelStyle = getComputedStyle(arrowContent);
 
diff --git a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
--- a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
+++ b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
@@ -54,10 +54,8 @@
       // Open the information arrow panel
       await openIdentityPopup();
 
-      let arrowContent = document.getAnonymousElementByAttribute(
-        gIdentityHandler._identityPopup,
-        "class",
-        "panel-arrowcontent"
+      let arrowContent = gIdentityHandler._identityPopup.shadowRoot.querySelector(
+        ".panel-arrowcontent"
       );
       let arrowContentComputedStyle = window.getComputedStyle(arrowContent);
       // Ensure popup background color was set properly
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -460,6 +460,18 @@
       }
 
       /**
+       * Passes DOM events to the on_<event type> methods.
+       */
+      handleEvent(event) {
+        let methodName = "on_" + event.type;
+        if (methodName in this) {
+          this[methodName](event);
+        } else {
+          throw new Error("Unrecognized event: " + event.type);
+        }
+      }
+
+      /**
        * Allows eager deterministic construction of XUL elements with XBL attached, by
        * parsing an element tree and returning a DOM fragment to be inserted in the
        * document before any of the inner elements is referenced by JavaScript.
@@ -758,6 +770,7 @@
       "chrome://global/content/elements/menu.js",
       "chrome://global/content/elements/menupopup.js",
       "chrome://global/content/elements/notificationbox.js",
+      "chrome://global/content/elements/panel.js",
       "chrome://global/content/elements/popupnotification.js",
       "chrome://global/content/elements/radio.js",
       "chrome://global/content/elements/richlistbox.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -86,6 +86,7 @@
    content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/menupopup.js        (widgets/menupopup.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
+   content/global/elements/panel.js            (widgets/panel.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
diff --git a/toolkit/content/tests/chrome/test_arrowpanel.xul b/toolkit/content/tests/chrome/test_arrowpanel.xul
--- a/toolkit/content/tests/chrome/test_arrowpanel.xul
+++ b/toolkit/content/tests/chrome/test_arrowpanel.xul
@@ -286,7 +286,7 @@
 
   is(anchor, expectedAnchor, "anchor");
 
-  var arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  var arrow = panel.shadowRoot.querySelector(".panel-arrow");
   is(arrow.getAttribute("side"), expectedSide, "panel arrow side");
   is(arrow.hidden, false, "panel hidden");
   is(arrow.parentNode.pack, expectedPack, "panel arrow pack");
diff --git a/toolkit/content/tests/widgets/test_popupanchor.xul b/toolkit/content/tests/widgets/test_popupanchor.xul
--- a/toolkit/content/tests/widgets/test_popupanchor.xul
+++ b/toolkit/content/tests/widgets/test_popupanchor.xul
@@ -433,7 +433,7 @@
   // anchor is set by the test runner above
   panel = document.getElementById("testPanel");
 
-  arrow = SpecialPowers.wrap(document).getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
   runTests();
 });
 
diff --git a/toolkit/content/tests/widgets/test_popupreflows.xul b/toolkit/content/tests/widgets/test_popupreflows.xul
--- a/toolkit/content/tests/widgets/test_popupreflows.xul
+++ b/toolkit/content/tests/widgets/test_popupreflows.xul
@@ -87,7 +87,7 @@
 addEventListener("load", function() {
   anchor = document.getElementById("anchor");
   panel = document.getElementById("testPanel");
-  arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   // Cancel the arrow panel slide-in transition (bug 767133) - we are only
   // testing reflows in the core panel implementation and not reflows that may
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/panel.js
copy from toolkit/content/widgets/popup.xml
copy to toolkit/content/widgets/panel.js
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/panel.js
@@ -1,339 +1,165 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+  class MozPanel extends MozElements.MozElementMixin(XULPopupElement) {
+    constructor() {
+      super();
+
+      this._prevFocus = 0;
 
-<bindings id="popupBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+      this.addEventListener("popupshowing", this);
+      this.addEventListener("popupshown", this);
+      this.addEventListener("popuphiding", this);
+      this.addEventListener("popuphidden", this);
+      this.addEventListener("popuppositioned", this);
+
+      this.attachShadow({ mode: "open" });
+    }
+
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      if (!this.isArrowPanel) {
+        this.shadowRoot.appendChild(document.createElement("slot"));
+        return;
+      }
 
-  <binding id="popup">
-    <content>
-      <xul:arrowscrollbox class="popup-internal-box" flex="1" orient="vertical"
-                          smoothscroll="false">
-        <children/>
-      </xul:arrowscrollbox>
-    </content>
+      this.shadowRoot.appendChild(this.fragment);
+
+      if (!this.hasAttribute("flip")) {
+        this.setAttribute("flip", "both");
+      }
+      if (!this.hasAttribute("side")) {
+        this.setAttribute("side", "top");
+      }
+      if (!this.hasAttribute("position")) {
+        this.setAttribute("position", "bottomcenter topleft");
+      }
+      if (!this.hasAttribute("consumeoutsideclicks")) {
+        this.setAttribute("consumeoutsideclicks", "false");
+      }
+
+      this.initializeAttributeInheritance();
 
-    <implementation>
-      <field name="scrollBox" readonly="true">
-        document.getAnonymousElementByAttribute(this, "class", "popup-internal-box");
-      </field>
+      this._fadeTimer = null;
+    }
 
-      <field name="AUTOSCROLL_INTERVAL">25</field>
-      <field name="NOT_DRAGGING">0</field>
-      <field name="DRAG_OVER_BUTTON">-1</field>
-      <field name="DRAG_OVER_POPUP">1</field>
-
-      <field name="_draggingState">this.NOT_DRAGGING</field>
-      <field name="_scrollTimer">0</field>
+    get fragment() {
+      if (!this.constructor.hasOwnProperty("_fragment")) {
+        this.constructor._fragment = MozXULElement.parseXULToFragment(`
+        <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
+        <vbox class="panel-arrowcontainer" flex="1">
+          <box class="panel-arrowbox" part="arrowbox">
+            <image class="panel-arrow" part="arrow"/>
+          </box>
+          <box class="panel-arrowcontent" flex="1" part="arrowcontent"><html:slot/></box>
+        </vbox>
+      `);
+      }
+      return document.importNode(this.constructor._fragment, true);
+    }
 
-      <method name="_enableDragScrolling">
-        <!-- when overItem is true, drag started over menuitem; when false, drag
-             started while the popup was opening.
-          -->
-        <parameter name="overItem"/>
-        <body>
-        <![CDATA[
-          if (!this._draggingState) {
-            this.setCaptureAlways();
-            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;
-          }
-        ]]>
-        </body>
-      </method>
+    static get inheritedAttributes() {
+      return {
+        ".panel-arrowcontainer": "side,panelopen",
+        ".panel-arrow": "side",
+        ".panel-arrowcontent": "side,align,dir,orient,pack",
+      };
+    }
+
+    get isArrowPanel() {
+      return this.getAttribute("type") == "arrow";
+    }
+
+    adjustArrowPosition() {
+      if (!this.isArrowPanel) {
+        return;
+      }
+
+      var anchor = this.anchorNode;
+      if (!anchor) {
+        return;
+      }
+
+      var container = this.shadowRoot.querySelector(".panel-arrowcontainer");
+      var arrowbox = this.shadowRoot.querySelector(".panel-arrowbox");
+
+      var position = this.alignmentPosition;
+      var offset = this.alignmentOffset;
+
+      this.setAttribute("arrowposition", position);
+
+      if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
+        container.orient = "horizontal";
+        arrowbox.orient = "vertical";
+        if (position.indexOf("_after") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
+        }
+        arrowbox.style.transform = "translate(0, " + -offset + "px)";
 
-      <method name="_clearScrollTimer">
-        <body>
-        <![CDATA[
-          if (this._scrollTimer) {
-            this.ownerGlobal.clearInterval(this._scrollTimer);
-            this._scrollTimer = 0;
-          }
-        ]]>
-        </body>
-      </method>
+        // The assigned side stays the same regardless of direction.
+        var isRTL = window.getComputedStyle(this).direction == "rtl";
 
-      <constructor><![CDATA[
-        // Enable the drag-to-scroll events only in menulist popups.
-        if (!this.parentNode || this.parentNode.localName != "menulist") {
-          return;
+        if (position.indexOf("start_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", isRTL ? "left" : "right");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", isRTL ? "right" : "left");
+        }
+      } else if (
+        position.indexOf("before_") == 0 ||
+        position.indexOf("after_") == 0
+      ) {
+        container.orient = "";
+        arrowbox.orient = "";
+        if (position.indexOf("_end") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
         }
+        arrowbox.style.transform = "translate(" + -offset + "px, 0)";
 
-        // XBL bindings might be constructed more than once.
-        if (this.eventListenersAdded) {
+        if (position.indexOf("before_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", "bottom");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", "top");
+        }
+      }
+    }
+
+    on_popupshowing(event) {
+      // Capture the previous focus before has a chance to get set inside the panel
+      try {
+        this._prevFocus = Cu.getWeakReference(
+          document.commandDispatcher.focusedElement
+        );
+        if (!this._prevFocus.get()) {
+          this._prevFocus = Cu.getWeakReference(document.activeElement);
           return;
         }
-        this.eventListenersAdded = true;
-
-        this.addEventListener("popupshown", () => {
-          // Enable drag scrolling even when the mouse wasn't used. The
-          // mousemove handler will remove it if the mouse isn't down.
-          this._enableDragScrolling(false);
-        });
-
-        this.addEventListener("popuphidden", () => {
-          this._draggingState = this.NOT_DRAGGING;
-          this._clearScrollTimer();
-          this.releaseCapture();
-        });
-
-        this.addEventListener("mousedown", event => {
-          if (event.button != 0) {
-            return;
-          }
-
-          if (this.state == "open" &&
-            (event.target.localName == "menuitem" ||
-              event.target.localName == "menu" ||
-              event.target.localName == "menucaption")) {
-            this._enableDragScrolling(true);
-          }
-        });
-
-        this.addEventListener("mouseup", event => {
-          if (event.button != 0) {
-            return;
-          }
-
-          this._draggingState = this.NOT_DRAGGING;
-          this._clearScrollTimer();
-        });
-
-        this.addEventListener("mousemove", event => {
-          if (!this._draggingState) {
-            return;
-          }
-
-          this._clearScrollTimer();
-
-          // If the user released the mouse before the popup opens, we will
-          // still be capturing, so check that the button is still pressed. If
-          // not, release the capture and do nothing else. This also handles if
-          // the dropdown was opened via the keyboard.
-          if (!(event.buttons & 1)) {
-            this._draggingState = this.NOT_DRAGGING;
-            this.releaseCapture();
-            return;
-          }
-
-          // If dragging outside the top or bottom edge of the popup, but within
-          // the popup area horizontally, scroll the list in that direction. The
-          // _draggingState flag is used to ensure that scrolling does not start
-          // until the mouse has moved over the popup first, preventing
-          // scrolling while over the dropdown button.
-          let popupRect = this.getOuterScreenRect();
-          if (event.screenX >= popupRect.left &&
-              event.screenX <= popupRect.right) {
-            if (this._draggingState == this.DRAG_OVER_BUTTON) {
-              if (event.screenY > popupRect.top &&
-                  event.screenY < popupRect.bottom) {
-                this._draggingState = this.DRAG_OVER_POPUP;
-              }
-            }
-
-            if (this._draggingState == this.DRAG_OVER_POPUP &&
-                (event.screenY <= popupRect.top ||
-                 event.screenY >= popupRect.bottom)) {
-              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;
-              this.scrollBox.scrollByIndex(scrollAmount, true);
-
-              let win = this.ownerGlobal;
-              this._scrollTimer = win.setInterval(() => {
-                this.scrollBox.scrollByIndex(scrollAmount, true);
-              }, this.AUTOSCROLL_INTERVAL);
-            }
-          }
-        });
-      ]]></constructor>
-    </implementation>
-
-    <handlers>
-      <handler event="popupshowing" phase="target">
-        <![CDATA[
-          var array = [];
-          var width = 0;
-          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
-            if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
-              var accel = menuitem.menuAccel;
-              if (accel) {
-                array.push(accel);
-                let accelWidth = accel.getBoundingClientRect().width;
-                if (accelWidth > width) {
-                  width = accelWidth;
-                }
-              }
-            }
-          }
-          for (var i = 0; i < array.length; i++)
-            array[i].width = width;
-        ]]>
-      </handler>
-    </handlers>
-  </binding>
-
-  <binding id="panel">
-    <implementation>
-      <field name="_prevFocus">0</field>
-    </implementation>
-
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // Capture the previous focus before has a chance to get set inside the panel
-        try {
-          this._prevFocus = Cu
-                            .getWeakReference(document.commandDispatcher.focusedElement);
-          if (this._prevFocus.get())
-            return;
-        } catch (ex) { }
-
+      } catch (ex) {
         this._prevFocus = Cu.getWeakReference(document.activeElement);
-      ]]></handler>
-      <handler event="popupshown"><![CDATA[
-        // Fire event for accessibility APIs
-        var alertEvent = document.createEvent("Events");
-        alertEvent.initEvent("AlertActive", true, true);
-        this.dispatchEvent(alertEvent);
-       ]]></handler>
-      <handler event="popuphiding"><![CDATA[
-        try {
-          this._currentFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          this._currentFocus = document.activeElement;
-        }
-      ]]></handler>
-      <handler event="popuphidden"><![CDATA[
-        function doFocus() {
-          // Focus was set on an element inside this panel,
-          // so we need to move it back to where it was previously
-          try {
-            let fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
-          } catch (e) {
-            prevFocus.focus();
-          }
-        }
-        var currentFocus = this._currentFocus;
-        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
-        this._currentFocus = null;
-        this._prevFocus = null;
-
-        // Avoid changing focus if focus changed while we hide the popup
-        // (This can happen e.g. if the popup is hiding as a result of a
-        // click/keypress that focused something)
-        let nowFocus;
-        try {
-          nowFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          nowFocus = document.activeElement;
-        }
-        if (nowFocus && nowFocus != currentFocus)
-          return;
-
-        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
-          // Try to restore focus
-          try {
-            if (document.commandDispatcher.focusedWindow != window)
-              return; // Focus has already been set to a window outside of this panel
-          } catch (ex) {}
-
-          if (!currentFocus) {
-            doFocus();
-            return;
-          }
-          while (currentFocus) {
-            if (currentFocus == this) {
-              doFocus();
-              return;
-            }
-            currentFocus = currentFocus.parentNode;
-          }
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
+      }
 
-  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
-    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
-      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
-               xbl:inherits="side,panelopen">
-        <xul:box anonid="arrowbox" class="panel-arrowbox">
-          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
-        </xul:box>
-        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
-          <children/>
-        </xul:box>
-      </xul:vbox>
-    </content>
-    <implementation>
-      <field name="_fadeTimer">null</field>
-      <method name="adjustArrowPosition">
-        <body>
-        <![CDATA[
-        var anchor = this.anchorNode;
-        if (!anchor) {
-          return;
-        }
-
-        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
-        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
-
-        var position = this.alignmentPosition;
-        var offset = this.alignmentOffset;
-
-        this.setAttribute("arrowposition", position);
-
-        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
-          container.orient = "horizontal";
-          arrowbox.orient = "vertical";
-          if (position.indexOf("_after") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(0, " + -offset + "px)";
-
-          // The assigned side stays the same regardless of direction.
-          var isRTL = (window.getComputedStyle(this).direction == "rtl");
-
-          if (position.indexOf("start_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", isRTL ? "left" : "right");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", isRTL ? "right" : "left");
-          }
-        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
-          container.orient = "";
-          arrowbox.orient = "";
-          if (position.indexOf("_end") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(" + -offset + "px, 0)";
-
-          if (position.indexOf("before_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", "bottom");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", "top");
-          }
-        }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="popupshowing" phase="target">
-      <![CDATA[
-        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
+      if (this.isArrowPanel && event.target == this) {
+        var arrow = this.shadowRoot.querySelector(".panel-arrow");
         arrow.hidden = this.anchorNode == null;
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
-                .style.removeProperty("transform");
+        this.shadowRoot
+          .querySelector(".panel-arrowbox")
+          .style.removeProperty("transform");
 
         if (this.getAttribute("animate") != "false") {
           this.setAttribute("animate", "open");
@@ -349,15 +175,39 @@
           fadeDelay = 1;
         } else if (fade == "slow") {
           fadeDelay = 4000;
-        } else {
-          return;
         }
 
-        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
-      ]]>
-      </handler>
-      <handler event="popuphiding" phase="target">
-        let animate = (this.getAttribute("animate") != "false");
+        if (["fast", "slow"].includes(fade)) {
+          this._fadeTimer = setTimeout(
+            () => this.hidePopup(true),
+            fadeDelay,
+            this
+          );
+        }
+      }
+    }
+
+    on_popupshown(event) {
+      // Fire event for accessibility APIs
+      let alertEvent = document.createEvent("Events");
+      alertEvent.initEvent("AlertActive", true, true);
+      this.dispatchEvent(alertEvent);
+
+      if (this.isArrowPanel && event.target == this) {
+        this.removeAttribute("animating");
+        this.setAttribute("panelopen", "true");
+      }
+    }
+
+    on_popuphiding(event) {
+      try {
+        this._currentFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        this._currentFocus = document.activeElement;
+      }
+
+      if (this.isArrowPanel && event.target == this) {
+        let animate = this.getAttribute("animate") != "false";
 
         if (this._fadeTimer) {
           clearTimeout(this._fadeTimer);
@@ -367,20 +217,74 @@
         } else if (animate) {
           this.setAttribute("animate", "cancel");
         }
-      </handler>
-      <handler event="popupshown" phase="target">
-        this.removeAttribute("animating");
-        this.setAttribute("panelopen", "true");
-      </handler>
-      <handler event="popuphidden" phase="target">
+      }
+    }
+
+    on_popuphidden(event) {
+      if (this.isArrowPanel && event.target == this) {
         this.removeAttribute("panelopen");
         if (this.getAttribute("animate") != "false") {
           this.removeAttribute("animate");
         }
-      </handler>
-      <handler event="popuppositioned" phase="target">
+      }
+
+      function doFocus() {
+        // Focus was set on an element inside this panel,
+        // so we need to move it back to where it was previously
+        try {
+          let fm = Services.focus;
+          fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
+        } catch (e) {
+          prevFocus.focus();
+        }
+      }
+      var currentFocus = this._currentFocus;
+      var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
+      this._currentFocus = null;
+      this._prevFocus = null;
+
+      // Avoid changing focus if focus changed while we hide the popup
+      // (This can happen e.g. if the popup is hiding as a result of a
+      // click/keypress that focused something)
+      let nowFocus;
+      try {
+        nowFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        nowFocus = document.activeElement;
+      }
+      if (nowFocus && nowFocus != currentFocus) {
+        return;
+      }
+
+      if (prevFocus && this.getAttribute("norestorefocus") != "true") {
+        // Try to restore focus
+        try {
+          if (document.commandDispatcher.focusedWindow != window) {
+            // Focus has already been set to a window outside of this panel
+            return;
+          }
+        } catch (ex) {}
+
+        if (!currentFocus) {
+          doFocus();
+          return;
+        }
+        while (currentFocus) {
+          if (currentFocus == this) {
+            doFocus();
+            return;
+          }
+          currentFocus = currentFocus.parentNode;
+        }
+      }
+    }
+
+    on_popuppositioned(event) {
+      if (event.target == this) {
         this.adjustArrowPosition();
-      </handler>
-    </handlers>
-  </binding>
-</bindings>
+      }
+    }
+  }
+
+  customElements.define("panel", MozPanel);
+}
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -172,215 +172,4 @@
       </handler>
     </handlers>
   </binding>
-
-  <binding id="panel">
-    <implementation>
-      <field name="_prevFocus">0</field>
-    </implementation>
-
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // Capture the previous focus before has a chance to get set inside the panel
-        try {
-          this._prevFocus = Cu
-                            .getWeakReference(document.commandDispatcher.focusedElement);
-          if (this._prevFocus.get())
-            return;
-        } catch (ex) { }
-
-        this._prevFocus = Cu.getWeakReference(document.activeElement);
-      ]]></handler>
-      <handler event="popupshown"><![CDATA[
-        // Fire event for accessibility APIs
-        var alertEvent = document.createEvent("Events");
-        alertEvent.initEvent("AlertActive", true, true);
-        this.dispatchEvent(alertEvent);
-       ]]></handler>
-      <handler event="popuphiding"><![CDATA[
-        try {
-          this._currentFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          this._currentFocus = document.activeElement;
-        }
-      ]]></handler>
-      <handler event="popuphidden"><![CDATA[
-        function doFocus() {
-          // Focus was set on an element inside this panel,
-          // so we need to move it back to where it was previously
-          try {
-            let fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
-          } catch (e) {
-            prevFocus.focus();
-          }
-        }
-        var currentFocus = this._currentFocus;
-        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
-        this._currentFocus = null;
-        this._prevFocus = null;
-
-        // Avoid changing focus if focus changed while we hide the popup
-        // (This can happen e.g. if the popup is hiding as a result of a
-        // click/keypress that focused something)
-        let nowFocus;
-        try {
-          nowFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          nowFocus = document.activeElement;
-        }
-        if (nowFocus && nowFocus != currentFocus)
-          return;
-
-        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
-          // Try to restore focus
-          try {
-            if (document.commandDispatcher.focusedWindow != window)
-              return; // Focus has already been set to a window outside of this panel
-          } catch (ex) {}
-
-          if (!currentFocus) {
-            doFocus();
-            return;
-          }
-          while (currentFocus) {
-            if (currentFocus == this) {
-              doFocus();
-              return;
-            }
-            currentFocus = currentFocus.parentNode;
-          }
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
-
-  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
-    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
-      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
-               xbl:inherits="side,panelopen">
-        <xul:box anonid="arrowbox" class="panel-arrowbox">
-          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
-        </xul:box>
-        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
-          <children/>
-        </xul:box>
-      </xul:vbox>
-    </content>
-    <implementation>
-      <field name="_fadeTimer">null</field>
-      <method name="adjustArrowPosition">
-        <body>
-        <![CDATA[
-        var anchor = this.anchorNode;
-        if (!anchor) {
-          return;
-        }
-
-        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
-        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
-
-        var position = this.alignmentPosition;
-        var offset = this.alignmentOffset;
-
-        this.setAttribute("arrowposition", position);
-
-        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
-          container.orient = "horizontal";
-          arrowbox.orient = "vertical";
-          if (position.indexOf("_after") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(0, " + -offset + "px)";
-
-          // The assigned side stays the same regardless of direction.
-          var isRTL = (window.getComputedStyle(this).direction == "rtl");
-
-          if (position.indexOf("start_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", isRTL ? "left" : "right");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", isRTL ? "right" : "left");
-          }
-        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
-          container.orient = "";
-          arrowbox.orient = "";
-          if (position.indexOf("_end") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(" + -offset + "px, 0)";
-
-          if (position.indexOf("before_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", "bottom");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", "top");
-          }
-        }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="popupshowing" phase="target">
-      <![CDATA[
-        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
-        arrow.hidden = this.anchorNode == null;
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
-                .style.removeProperty("transform");
-
-        if (this.getAttribute("animate") != "false") {
-          this.setAttribute("animate", "open");
-          // the animating attribute prevents user interaction during transition
-          // it is removed when popupshown fires
-          this.setAttribute("animating", "true");
-        }
-
-        // set fading
-        var fade = this.getAttribute("fade");
-        var fadeDelay = 0;
-        if (fade == "fast") {
-          fadeDelay = 1;
-        } else if (fade == "slow") {
-          fadeDelay = 4000;
-        } else {
-          return;
-        }
-
-        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
-      ]]>
-      </handler>
-      <handler event="popuphiding" phase="target">
-        let animate = (this.getAttribute("animate") != "false");
-
-        if (this._fadeTimer) {
-          clearTimeout(this._fadeTimer);
-          if (animate) {
-            this.setAttribute("animate", "fade");
-          }
-        } else if (animate) {
-          this.setAttribute("animate", "cancel");
-        }
-      </handler>
-      <handler event="popupshown" phase="target">
-        this.removeAttribute("animating");
-        this.setAttribute("panelopen", "true");
-      </handler>
-      <handler event="popuphidden" phase="target">
-        this.removeAttribute("panelopen");
-        if (this.getAttribute("animate") != "false") {
-          this.removeAttribute("animate");
-        }
-      </handler>
-      <handler event="popuppositioned" phase="target">
-        this.adjustArrowPosition();
-      </handler>
-    </handlers>
-  </binding>
 </bindings>
diff --git a/toolkit/content/widgets/tabbox.js b/toolkit/content/widgets/tabbox.js
--- a/toolkit/content/widgets/tabbox.js
+++ b/toolkit/content/widgets/tabbox.js
@@ -321,18 +321,6 @@
       }
     }
 
-    /**
-     * Passes DOM events to the on_<event type> methods.
-     */
-    handleEvent(event) {
-      let methodName = "on_" + event.type;
-      if (methodName in this) {
-        this[methodName](event);
-      } else {
-        throw new Error("Unrecognized event: " + event.type);
-      }
-    }
-
     on_mousedown(event) {
       if (event.button != 0 || this.disabled) {
         return;
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -234,7 +234,6 @@
 }
 
 panel {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#panel");
   -moz-box-orient: vertical;
 }
 
@@ -252,10 +251,6 @@
   margin-top: 21px;
 }
 
-panel[type="arrow"] {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
-}
-
 @supports -moz-bool-pref("xul.panel-animations.enabled") {
 %ifdef MOZ_WIDGET_COCOA
   /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"

