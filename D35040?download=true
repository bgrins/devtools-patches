# HG changeset patch
# Parent  6aec99b90f85428f659777d3fcb80aedb539acab

diff --git a/browser/base/content/test/performance/browser_appmenu.js b/browser/base/content/test/performance/browser_appmenu.js
--- a/browser/base/content/test/performance/browser_appmenu.js
+++ b/browser/base/content/test/performance/browser_appmenu.js
@@ -20,18 +20,18 @@ const EXPECTED_APPMENU_OPEN_REFLOWS = [
   {
     stack: [
       "openPopup/this._openPopupPromise<@resource:///modules/PanelMultiView.jsm",
     ],
   },
 
   {
     stack: [
-      "adjustArrowPosition@chrome://global/content/bindings/popup.xml",
-      "onxblpopuppositioned@chrome://global/content/bindings/popup.xml",
+      "adjustArrowPosition@chrome://global/content/elements/panel.js",
+      "on_popuppositioned@chrome://global/content/elements/panel.js",
     ],
 
     maxCount: 22, // This number should only ever go down - never up.
   },
 
   {
     stack: [
       "_calculateMaxHeight@resource:///modules/PanelMultiView.jsm",
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_background.js b/browser/components/extensions/test/browser/browser_ext_popup_background.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_background.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_background.js
@@ -1,21 +1,17 @@
 /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set sts=2 sw=2 et tw=80: */
 /* eslint-disable mozilla/no-arbitrary-setTimeout */
 "use strict";
 
 async function testPanel(browser, standAlone, initial_background) {
   let panel = getPanelForNode(browser);
-  let arrowContent = document.getAnonymousElementByAttribute(
-    panel,
-    "class",
-    "panel-arrowcontent"
-  );
-  let arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
+  let arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   let checkArrow = (background = null) => {
     if (background == null || !standAlone) {
       if (standAlone) {
         is(
           getComputedStyle(arrow).fill,
           "rgb(255, 255, 255)",
           "Arrow fill should be set to #fff when no background is supplied and popup is standAlone"
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_corners.js b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_corners.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
@@ -30,21 +30,17 @@ add_task(async function testPopupBorderR
         </html>`,
     },
   });
 
   await extension.startup();
 
   async function testPanel(browser, standAlone = true) {
     let panel = getPanelForNode(browser);
-    let arrowContent = document.getAnonymousElementByAttribute(
-      panel,
-      "class",
-      "panel-arrowcontent"
-    );
+    let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
 
     let panelStyle = getComputedStyle(arrowContent);
 
     let stack = browser.parentNode;
     let viewNode = stack.parentNode === panel ? browser : stack.parentNode;
     let viewStyle = getComputedStyle(viewNode);
 
     let props = [
diff --git a/browser/components/places/content/places-menupopup.js b/browser/components/places/content/places-menupopup.js
--- a/browser/components/places/content/places-menupopup.js
+++ b/browser/components/places/content/places-menupopup.js
@@ -588,37 +588,35 @@
       ];
       for (let event_name of event_names) {
         this.addEventListener(event_name, ev => this[`on_${event_name}`](ev));
       }
     }
 
     static get inheritedAttributes() {
       return {
-        ".panel-arrowcontainer": "side,panelopen",
-        ".panel-arrow": "side",
         ".panel-arrowcontent": "side,align,dir,orient,pack",
       };
     }
 
     get markup() {
       return `
-      <html:link rel="stylesheet" href="chrome://global/skin/global.css" />
+      <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
       <vbox class="panel-arrowcontainer" flex="1">
-        <box class="panel-arrowbox">
-          <image class="panel-arrow"></image>
+        <box class="panel-arrowbox" part="arrowbox">
+          <image class="panel-arrow" part="arrow"/>
         </box>
         <box class="panel-arrowcontent" part="arrowcontent" flex="1">
           <vbox part="drop-indicator-bar" hidden="true">
-            <image part="drop-indicator" mousethrough="always"></image>
+            <image part="drop-indicator" mousethrough="always"/>
           </vbox>
           <arrowscrollbox class="popup-internal-box" flex="1"
                           orient="vertical" smoothscroll="false"
                           part="popupbox">
-            <html:slot></html:slot>
+            <html:slot/>
           </arrowscrollbox>
         </box>
       </vbox>
     `;
     }
 
     connectedCallback() {
       if (this.delayConnectedCallback()) {
diff --git a/browser/themes/linux/customizableui/panelUI.css b/browser/themes/linux/customizableui/panelUI.css
--- a/browser/themes/linux/customizableui/panelUI.css
+++ b/browser/themes/linux/customizableui/panelUI.css
@@ -22,12 +22,11 @@ menuitem.subviewbutton {
 }
 
 /*
  * #pageActionFeedbackAnimatableImage is wider than the panel, and due to a
  * bug in panels on Linux, a box-shadow appears where the image would be if
  * overflow:hidden wasn't applied. Disabling the box-shadow for this panel on
  * Linux works around this issue. This bug is on file as 1394575.
  */
-#pageActionFeedback > .panel-arrowcontainer > .panel-arrowcontent {
+#pageActionFeedback::part(arrowcontent) {
   box-shadow: none;
 }
-
diff --git a/browser/themes/shared/controlcenter/panel.inc.css b/browser/themes/shared/controlcenter/panel.inc.css
--- a/browser/themes/shared/controlcenter/panel.inc.css
+++ b/browser/themes/shared/controlcenter/panel.inc.css
@@ -235,27 +235,27 @@
 #identity-popup-mainView-panel-header,
 #protections-popup-mainView-panel-header {
   padding: var(--vertical-section-padding) var(--horizontal-padding);
   min-height: 40px;
   -moz-box-pack: center;
   -moz-box-align: center;
 }
 
-#protections-popup > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+#protections-popup::part(arrow) {
   transition-property: fill;
   transition-timing-function: var(--animation-easing-function);
   transition-duration: var(--panelui-subview-transition-duration);
 }
 
-#protections-popup[mainviewshowing] > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+#protections-popup[mainviewshowing]::part(arrow) {
   fill: #0A51BF;
 }
 
-:root[lwt-popup-brighttext] #protections-popup[mainviewshowing] > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+:root[lwt-popup-brighttext] #protections-popup[mainviewshowing]::part(arrow) {
   fill: #0CB0F5;
 }
 
 #protections-popup-mainView-panel-header {
   color: white;
   background: radial-gradient(circle at top right, #9059FF, #0250BB);
 }
 
diff --git a/browser/themes/shared/customizableui/panelUI.inc.css b/browser/themes/shared/customizableui/panelUI.inc.css
--- a/browser/themes/shared/customizableui/panelUI.inc.css
+++ b/browser/themes/shared/customizableui/panelUI.inc.css
@@ -250,21 +250,21 @@ panelview {
   --arrowpanel-background: #0060df;
   --arrowpanel-border-color: #0060df;
   --arrowpanel-color: #fff;
   --arrowpanel-padding: 6px 10px;
   font-weight: 400;
   font-size: 1.1rem;
 }
 
-#confirmation-hint > .panel-arrowcontainer > .panel-arrowcontent {
+#confirmation-hint::part(arrowcontent) {
   -moz-box-align: center;
 }
 
-#confirmation-hint[hidearrow] > .panel-arrowcontainer > .panel-arrowbox {
+#confirmation-hint[hidearrow]::part(arrowbox) {
   /* Don't display the arrow but keep the popup at the same vertical
      offset as other arrow panels. */
   visibility: hidden;
 }
 
 #confirmation-hint-checkmark-animation-container {
   position: relative;
   overflow: hidden;
@@ -366,18 +366,17 @@ panelview:not([mainview]) .toolbarbutton
   max-width: @wideMenuPanelWidth@;
 }
 
 /* Add 2 * 16px extra width for touch mode button padding. */
 #appMenu-popup[touchmode] panelview {
   min-width: calc(@menuPanelWidth@ + 32px);
 }
 
-.cui-widget-panel.cui-widget-panelWithFooter::part(arrowcontent),
-.cui-widget-panel.cui-widget-panelWithFooter > .panel-arrowcontainer > .panel-arrowcontent {
+.cui-widget-panel.cui-widget-panelWithFooter::part(arrowcontent) {
   padding-bottom: 0;
 }
 
 .toolbaritem-combined-buttons@inAnyPanel@ > toolbarbutton > .toolbarbutton-icon {
   min-width: 0;
   min-height: 0;
   margin: 0;
 }
diff --git a/devtools/client/themes/tooltips.css b/devtools/client/themes/tooltips.css
--- a/devtools/client/themes/tooltips.css
+++ b/devtools/client/themes/tooltips.css
@@ -174,17 +174,17 @@ strong {
 
 .tooltip-xul-wrapper[type="arrow"][side] {
   margin: 0;
 }
 
 /* The arrow image is hidden because the panel is opened using openPopupAtScreen(). */
 
 /* Remove all decorations on .panel-arrowcontent is the tooltip content container. */
-.tooltip-xul-wrapper[type="arrow"] .panel-arrowcontent {
+.tooltip-xul-wrapper[type="arrow"]::part(arrowcontent) {
   margin: 0;
   padding: 0;
   background: transparent;
   border: none;
   box-shadow: none;
 }
 
 /* Tooltip : arrow style */
diff --git a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
--- a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
+++ b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
@@ -49,20 +49,18 @@ add_task(async function test_popup_styli
   await BrowserTestUtils.withNewTab(
     { gBrowser, url: "https://example.com" },
     async function(browser) {
       await extension.startup();
 
       // Open the information arrow panel
       await openIdentityPopup();
 
-      let arrowContent = document.getAnonymousElementByAttribute(
-        gIdentityHandler._identityPopup,
-        "class",
-        "panel-arrowcontent"
+      let arrowContent = gIdentityHandler._identityPopup.shadowRoot.querySelector(
+        ".panel-arrowcontent"
       );
       let arrowContentComputedStyle = window.getComputedStyle(arrowContent);
       // Ensure popup background color was set properly
       Assert.equal(
         arrowContentComputedStyle.getPropertyValue("background-color"),
         `rgb(${hexToRGB(POPUP_BACKGROUND_COLOR).join(", ")})`,
         "Popup background color should have been themed"
       );
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -455,16 +455,28 @@
         return true;
       }
 
       get isConnectedAndReady() {
         return gIsDOMContentLoaded && this.isConnected;
       }
 
       /**
+       * Passes DOM events to the on_<event type> methods.
+       */
+      handleEvent(event) {
+        let methodName = "on_" + event.type;
+        if (methodName in this) {
+          this[methodName](event);
+        } else {
+          throw new Error("Unrecognized event: " + event.type);
+        }
+      }
+
+      /**
        * Allows eager deterministic construction of XUL elements with XBL attached, by
        * parsing an element tree and returning a DOM fragment to be inserted in the
        * document before any of the inner elements is referenced by JavaScript.
        *
        * This process is required instead of calling the createElement method directly
        * because bindings get attached when:
        *
        * 1. the node gets a layout frame constructed, or
@@ -753,16 +765,17 @@
     for (let script of [
       "chrome://global/content/elements/dialog.js",
       "chrome://global/content/elements/general.js",
       "chrome://global/content/elements/button.js",
       "chrome://global/content/elements/checkbox.js",
       "chrome://global/content/elements/menu.js",
       "chrome://global/content/elements/menupopup.js",
       "chrome://global/content/elements/notificationbox.js",
+      "chrome://global/content/elements/panel.js",
       "chrome://global/content/elements/popupnotification.js",
       "chrome://global/content/elements/radio.js",
       "chrome://global/content/elements/richlistbox.js",
       "chrome://global/content/elements/autocomplete-popup.js",
       "chrome://global/content/elements/autocomplete-richlistitem.js",
       "chrome://global/content/elements/textbox.js",
       "chrome://global/content/elements/tabbox.js",
       "chrome://global/content/elements/text.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -81,16 +81,17 @@ toolkit.jar:
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/dialog.js           (widgets/dialog.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/menupopup.js        (widgets/menupopup.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
+   content/global/elements/panel.js            (widgets/panel.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
    content/global/elements/marquee.js          (widgets/marquee.js)
    content/global/elements/menulist.js         (widgets/menulist.js)
    content/global/elements/popupnotification.js  (widgets/popupnotification.js)
    content/global/elements/search-textbox.js     (widgets/search-textbox.js)
diff --git a/toolkit/content/tests/chrome/test_arrowpanel.xul b/toolkit/content/tests/chrome/test_arrowpanel.xul
--- a/toolkit/content/tests/chrome/test_arrowpanel.xul
+++ b/toolkit/content/tests/chrome/test_arrowpanel.xul
@@ -281,18 +281,17 @@ function checkPanelPosition(panel)
         adj += Math.round(anchorRect.width) / 2;
       if (!isOSXYosemite)
         isWithinHalfPixel(panelRect.right, anchorRect.right * zoomFactor - adj, "anchored on right");
       break;
   }
 
   is(anchor, expectedAnchor, "anchor");
 
-  var arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
-  is(arrow.getAttribute("side"), expectedSide, "panel arrow side");
+  var arrow = panel.shadowRoot.querySelector(".panel-arrow");
   is(arrow.hidden, false, "panel hidden");
   is(arrow.parentNode.pack, expectedPack, "panel arrow pack");
   is(panel.alignmentPosition, expectedAlignment, "panel alignmentPosition");
 
   panel.hidePopup();
 }
 
 function isWithinHalfPixel(a, b, desc)
diff --git a/toolkit/content/tests/widgets/test_popupanchor.xul b/toolkit/content/tests/widgets/test_popupanchor.xul
--- a/toolkit/content/tests/widgets/test_popupanchor.xul
+++ b/toolkit/content/tests/widgets/test_popupanchor.xul
@@ -428,17 +428,17 @@ function runTests() {
 }
 
 SimpleTest.waitForExplicitFinish();
 
 addEventListener("load", function() {
   // anchor is set by the test runner above
   panel = document.getElementById("testPanel");
 
-  arrow = SpecialPowers.wrap(document).getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
   runTests();
 });
 
 ]]>
 </script>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
 <!-- Our tests assume at least 100px around the anchor on all sides, else the
diff --git a/toolkit/content/tests/widgets/test_popupreflows.xul b/toolkit/content/tests/widgets/test_popupreflows.xul
--- a/toolkit/content/tests/widgets/test_popupreflows.xul
+++ b/toolkit/content/tests/widgets/test_popupreflows.xul
@@ -82,17 +82,17 @@ function testSimplePanel() {
 // ********************
 // The test harness...
 //
 SimpleTest.waitForExplicitFinish();
 
 addEventListener("load", function() {
   anchor = document.getElementById("anchor");
   panel = document.getElementById("testPanel");
-  arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   // Cancel the arrow panel slide-in transition (bug 767133) - we are only
   // testing reflows in the core panel implementation and not reflows that may
   // or may not be caused by transitioning....
   arrow.style.transition = "none";
 
   // and off we go...
   countReflows(testSimplePanel, 0).then(SimpleTest.finish);
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/panel.js
copy from toolkit/content/widgets/popup.xml
copy to toolkit/content/widgets/panel.js
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/panel.js
@@ -1,386 +1,288 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+  class MozPanel extends MozElements.MozElementMixin(XULPopupElement) {
+    constructor() {
+      super();
+
+      this._prevFocus = 0;
 
-<bindings id="popupBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+      this.addEventListener("popupshowing", this);
+      this.addEventListener("popupshown", this);
+      this.addEventListener("popuphiding", this);
+      this.addEventListener("popuphidden", this);
+      this.addEventListener("popuppositioned", this);
+
+      this.attachShadow({ mode: "open" });
+    }
+
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      if (!this.isArrowPanel) {
+        this.shadowRoot.appendChild(document.createElement("slot"));
+        return;
+      }
 
-  <binding id="popup">
-    <content>
-      <xul:arrowscrollbox class="popup-internal-box" flex="1" orient="vertical"
-                          smoothscroll="false">
-        <children/>
-      </xul:arrowscrollbox>
-    </content>
+      this.shadowRoot.appendChild(this.fragment);
+
+      if (!this.hasAttribute("flip")) {
+        this.setAttribute("flip", "both");
+      }
+      if (!this.hasAttribute("side")) {
+        this.setAttribute("side", "top");
+      }
+      if (!this.hasAttribute("position")) {
+        this.setAttribute("position", "bottomcenter topleft");
+      }
+      if (!this.hasAttribute("consumeoutsideclicks")) {
+        this.setAttribute("consumeoutsideclicks", "false");
+      }
+
+      this.initializeAttributeInheritance();
 
-    <implementation>
-      <field name="scrollBox" readonly="true">
-        document.getAnonymousElementByAttribute(this, "class", "popup-internal-box");
-      </field>
+      this._fadeTimer = null;
+    }
 
-      <field name="AUTOSCROLL_INTERVAL">25</field>
-      <field name="NOT_DRAGGING">0</field>
-      <field name="DRAG_OVER_BUTTON">-1</field>
-      <field name="DRAG_OVER_POPUP">1</field>
-
-      <field name="_draggingState">this.NOT_DRAGGING</field>
-      <field name="_scrollTimer">0</field>
+    get fragment() {
+      if (!this.constructor.hasOwnProperty("_fragment")) {
+        this.constructor._fragment = MozXULElement.parseXULToFragment(`
+        <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
+        <vbox class="panel-arrowcontainer" flex="1">
+          <box class="panel-arrowbox" part="arrowbox">
+            <image class="panel-arrow" part="arrow"/>
+          </box>
+          <box class="panel-arrowcontent" flex="1" part="arrowcontent"><html:slot/></box>
+        </vbox>
+      `);
+      }
+      return document.importNode(this.constructor._fragment, true);
+    }
 
-      <method name="_enableDragScrolling">
-        <!-- when overItem is true, drag started over menuitem; when false, drag
-             started while the popup was opening.
-          -->
-        <parameter name="overItem"/>
-        <body>
-        <![CDATA[
-          if (!this._draggingState) {
-            this.setCaptureAlways();
-            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;
-          }
-        ]]>
-        </body>
-      </method>
+    static get inheritedAttributes() {
+      return {
+        ".panel-arrowcontent": "side,align,dir,orient,pack",
+      };
+    }
+
+    get isArrowPanel() {
+      return this.getAttribute("type") == "arrow";
+    }
+
+    adjustArrowPosition() {
+      if (!this.isArrowPanel) {
+        return;
+      }
+
+      var anchor = this.anchorNode;
+      if (!anchor) {
+        return;
+      }
+
+      var container = this.shadowRoot.querySelector(".panel-arrowcontainer");
+      var arrowbox = this.shadowRoot.querySelector(".panel-arrowbox");
+
+      var position = this.alignmentPosition;
+      var offset = this.alignmentOffset;
+
+      this.setAttribute("arrowposition", position);
+
+      if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
+        container.orient = "horizontal";
+        arrowbox.orient = "vertical";
+        if (position.indexOf("_after") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
+        }
+        arrowbox.style.transform = "translate(0, " + -offset + "px)";
 
-      <method name="_clearScrollTimer">
-        <body>
-        <![CDATA[
-          if (this._scrollTimer) {
-            this.ownerGlobal.clearInterval(this._scrollTimer);
-            this._scrollTimer = 0;
-          }
-        ]]>
-        </body>
-      </method>
+        // The assigned side stays the same regardless of direction.
+        var isRTL = window.getComputedStyle(this).direction == "rtl";
 
-      <constructor><![CDATA[
-        // Enable the drag-to-scroll events only in menulist popups.
-        if (!this.parentNode || this.parentNode.localName != "menulist") {
-          return;
+        if (position.indexOf("start_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", isRTL ? "left" : "right");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", isRTL ? "right" : "left");
+        }
+      } else if (
+        position.indexOf("before_") == 0 ||
+        position.indexOf("after_") == 0
+      ) {
+        container.orient = "";
+        arrowbox.orient = "";
+        if (position.indexOf("_end") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
         }
+        arrowbox.style.transform = "translate(" + -offset + "px, 0)";
 
-        // XBL bindings might be constructed more than once.
-        if (this.eventListenersAdded) {
+        if (position.indexOf("before_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", "bottom");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", "top");
+        }
+      }
+    }
+
+    on_popupshowing(event) {
+      // Capture the previous focus before has a chance to get set inside the panel
+      try {
+        this._prevFocus = Cu.getWeakReference(
+          document.commandDispatcher.focusedElement
+        );
+        if (!this._prevFocus.get()) {
+          this._prevFocus = Cu.getWeakReference(document.activeElement);
           return;
         }
-        this.eventListenersAdded = true;
-
-        this.addEventListener("popupshown", () => {
-          // Enable drag scrolling even when the mouse wasn't used. The
-          // mousemove handler will remove it if the mouse isn't down.
-          this._enableDragScrolling(false);
-        });
-
-        this.addEventListener("popuphidden", () => {
-          this._draggingState = this.NOT_DRAGGING;
-          this._clearScrollTimer();
-          this.releaseCapture();
-        });
-
-        this.addEventListener("mousedown", event => {
-          if (event.button != 0) {
-            return;
-          }
-
-          if (this.state == "open" &&
-            (event.target.localName == "menuitem" ||
-              event.target.localName == "menu" ||
-              event.target.localName == "menucaption")) {
-            this._enableDragScrolling(true);
-          }
-        });
-
-        this.addEventListener("mouseup", event => {
-          if (event.button != 0) {
-            return;
-          }
-
-          this._draggingState = this.NOT_DRAGGING;
-          this._clearScrollTimer();
-        });
-
-        this.addEventListener("mousemove", event => {
-          if (!this._draggingState) {
-            return;
-          }
-
-          this._clearScrollTimer();
-
-          // If the user released the mouse before the popup opens, we will
-          // still be capturing, so check that the button is still pressed. If
-          // not, release the capture and do nothing else. This also handles if
-          // the dropdown was opened via the keyboard.
-          if (!(event.buttons & 1)) {
-            this._draggingState = this.NOT_DRAGGING;
-            this.releaseCapture();
-            return;
-          }
-
-          // If dragging outside the top or bottom edge of the popup, but within
-          // the popup area horizontally, scroll the list in that direction. The
-          // _draggingState flag is used to ensure that scrolling does not start
-          // until the mouse has moved over the popup first, preventing
-          // scrolling while over the dropdown button.
-          let popupRect = this.getOuterScreenRect();
-          if (event.screenX >= popupRect.left &&
-              event.screenX <= popupRect.right) {
-            if (this._draggingState == this.DRAG_OVER_BUTTON) {
-              if (event.screenY > popupRect.top &&
-                  event.screenY < popupRect.bottom) {
-                this._draggingState = this.DRAG_OVER_POPUP;
-              }
-            }
-
-            if (this._draggingState == this.DRAG_OVER_POPUP &&
-                (event.screenY <= popupRect.top ||
-                 event.screenY >= popupRect.bottom)) {
-              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;
-              this.scrollBox.scrollByIndex(scrollAmount, true);
-
-              let win = this.ownerGlobal;
-              this._scrollTimer = win.setInterval(() => {
-                this.scrollBox.scrollByIndex(scrollAmount, true);
-              }, this.AUTOSCROLL_INTERVAL);
-            }
-          }
-        });
-      ]]></constructor>
-    </implementation>
-
-    <handlers>
-      <handler event="popupshowing" phase="target">
-        <![CDATA[
-          var array = [];
-          var width = 0;
-          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
-            if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
-              var accel = menuitem.menuAccel;
-              if (accel) {
-                array.push(accel);
-                let accelWidth = accel.getBoundingClientRect().width;
-                if (accelWidth > width) {
-                  width = accelWidth;
-                }
-              }
-            }
-          }
-          for (var i = 0; i < array.length; i++)
-            array[i].width = width;
-        ]]>
-      </handler>
-    </handlers>
-  </binding>
-
-  <binding id="panel">
-    <implementation>
-      <field name="_prevFocus">0</field>
-    </implementation>
-
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // Capture the previous focus before has a chance to get set inside the panel
-        try {
-          this._prevFocus = Cu
-                            .getWeakReference(document.commandDispatcher.focusedElement);
-          if (this._prevFocus.get())
-            return;
-        } catch (ex) { }
-
+      } catch (ex) {
         this._prevFocus = Cu.getWeakReference(document.activeElement);
-      ]]></handler>
-      <handler event="popupshown"><![CDATA[
-        // Fire event for accessibility APIs
-        var alertEvent = document.createEvent("Events");
-        alertEvent.initEvent("AlertActive", true, true);
-        this.dispatchEvent(alertEvent);
-       ]]></handler>
-      <handler event="popuphiding"><![CDATA[
-        try {
-          this._currentFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          this._currentFocus = document.activeElement;
-        }
-      ]]></handler>
-      <handler event="popuphidden"><![CDATA[
-        function doFocus() {
-          // Focus was set on an element inside this panel,
-          // so we need to move it back to where it was previously
-          try {
-            let fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
-          } catch (e) {
-            prevFocus.focus();
-          }
-        }
-        var currentFocus = this._currentFocus;
-        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
-        this._currentFocus = null;
-        this._prevFocus = null;
-
-        // Avoid changing focus if focus changed while we hide the popup
-        // (This can happen e.g. if the popup is hiding as a result of a
-        // click/keypress that focused something)
-        let nowFocus;
-        try {
-          nowFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          nowFocus = document.activeElement;
-        }
-        if (nowFocus && nowFocus != currentFocus)
-          return;
-
-        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
-          // Try to restore focus
-          try {
-            if (document.commandDispatcher.focusedWindow != window)
-              return; // Focus has already been set to a window outside of this panel
-          } catch (ex) {}
-
-          if (!currentFocus) {
-            doFocus();
-            return;
-          }
-          while (currentFocus) {
-            if (currentFocus == this) {
-              doFocus();
-              return;
-            }
-            currentFocus = currentFocus.parentNode;
-          }
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
+      }
 
-  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
-    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
-      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
-               xbl:inherits="side,panelopen">
-        <xul:box anonid="arrowbox" class="panel-arrowbox">
-          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
-        </xul:box>
-        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
-          <children/>
-        </xul:box>
-      </xul:vbox>
-    </content>
-    <implementation>
-      <field name="_fadeTimer">null</field>
-      <method name="adjustArrowPosition">
-        <body>
-        <![CDATA[
-        var anchor = this.anchorNode;
-        if (!anchor) {
-          return;
-        }
-
-        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
-        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
-
-        var position = this.alignmentPosition;
-        var offset = this.alignmentOffset;
-
-        this.setAttribute("arrowposition", position);
-
-        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
-          container.orient = "horizontal";
-          arrowbox.orient = "vertical";
-          if (position.indexOf("_after") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(0, " + -offset + "px)";
-
-          // The assigned side stays the same regardless of direction.
-          var isRTL = (window.getComputedStyle(this).direction == "rtl");
-
-          if (position.indexOf("start_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", isRTL ? "left" : "right");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", isRTL ? "right" : "left");
-          }
-        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
-          container.orient = "";
-          arrowbox.orient = "";
-          if (position.indexOf("_end") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(" + -offset + "px, 0)";
-
-          if (position.indexOf("before_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", "bottom");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", "top");
-          }
-        }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="popupshowing" phase="target">
-      <![CDATA[
-        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
+      if (this.isArrowPanel && event.target == this) {
+        var arrow = this.shadowRoot.querySelector(".panel-arrow");
         arrow.hidden = this.anchorNode == null;
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
-                .style.removeProperty("transform");
+        this.shadowRoot
+          .querySelector(".panel-arrowbox")
+          .style.removeProperty("transform");
 
         if (this.getAttribute("animate") != "false") {
           this.setAttribute("animate", "open");
           // the animating attribute prevents user interaction during transition
           // it is removed when popupshown fires
           this.setAttribute("animating", "true");
         }
 
         // set fading
         var fade = this.getAttribute("fade");
         var fadeDelay = 0;
         if (fade == "fast") {
           fadeDelay = 1;
         } else if (fade == "slow") {
           fadeDelay = 4000;
-        } else {
-          return;
         }
 
-        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
-      ]]>
-      </handler>
-      <handler event="popuphiding" phase="target">
-        let animate = (this.getAttribute("animate") != "false");
+        if (["fast", "slow"].includes(fade)) {
+          this._fadeTimer = setTimeout(
+            () => this.hidePopup(true),
+            fadeDelay,
+            this
+          );
+        }
+      }
+    }
+
+    on_popupshown(event) {
+      // Fire event for accessibility APIs
+      let alertEvent = document.createEvent("Events");
+      alertEvent.initEvent("AlertActive", true, true);
+      this.dispatchEvent(alertEvent);
+
+      if (this.isArrowPanel && event.target == this) {
+        this.removeAttribute("animating");
+        this.setAttribute("panelopen", "true");
+      }
+    }
+
+    on_popuphiding(event) {
+      try {
+        this._currentFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        this._currentFocus = document.activeElement;
+      }
+
+      if (this.isArrowPanel && event.target == this) {
+        let animate = this.getAttribute("animate") != "false";
 
         if (this._fadeTimer) {
           clearTimeout(this._fadeTimer);
           if (animate) {
             this.setAttribute("animate", "fade");
           }
         } else if (animate) {
           this.setAttribute("animate", "cancel");
         }
-      </handler>
-      <handler event="popupshown" phase="target">
-        this.removeAttribute("animating");
-        this.setAttribute("panelopen", "true");
-      </handler>
-      <handler event="popuphidden" phase="target">
+      }
+    }
+
+    on_popuphidden(event) {
+      if (this.isArrowPanel && event.target == this) {
         this.removeAttribute("panelopen");
         if (this.getAttribute("animate") != "false") {
           this.removeAttribute("animate");
         }
-      </handler>
-      <handler event="popuppositioned" phase="target">
+      }
+
+      function doFocus() {
+        // Focus was set on an element inside this panel,
+        // so we need to move it back to where it was previously
+        try {
+          let fm = Services.focus;
+          fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
+        } catch (e) {
+          prevFocus.focus();
+        }
+      }
+      var currentFocus = this._currentFocus;
+      var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
+      this._currentFocus = null;
+      this._prevFocus = null;
+
+      // Avoid changing focus if focus changed while we hide the popup
+      // (This can happen e.g. if the popup is hiding as a result of a
+      // click/keypress that focused something)
+      let nowFocus;
+      try {
+        nowFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        nowFocus = document.activeElement;
+      }
+      if (nowFocus && nowFocus != currentFocus) {
+        return;
+      }
+
+      if (prevFocus && this.getAttribute("norestorefocus") != "true") {
+        // Try to restore focus
+        try {
+          if (document.commandDispatcher.focusedWindow != window) {
+            // Focus has already been set to a window outside of this panel
+            return;
+          }
+        } catch (ex) {}
+
+        if (!currentFocus) {
+          doFocus();
+          return;
+        }
+        while (currentFocus) {
+          if (currentFocus == this) {
+            doFocus();
+            return;
+          }
+          currentFocus = currentFocus.parentNode;
+        }
+      }
+    }
+
+    on_popuppositioned(event) {
+      if (event.target == this) {
         this.adjustArrowPosition();
-      </handler>
-    </handlers>
-  </binding>
-</bindings>
+      }
+    }
+  }
+
+  customElements.define("panel", MozPanel);
+}
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -167,220 +167,9 @@
             }
           }
           for (var i = 0; i < array.length; i++)
             array[i].width = width;
         ]]>
       </handler>
     </handlers>
   </binding>
-
-  <binding id="panel">
-    <implementation>
-      <field name="_prevFocus">0</field>
-    </implementation>
-
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // Capture the previous focus before has a chance to get set inside the panel
-        try {
-          this._prevFocus = Cu
-                            .getWeakReference(document.commandDispatcher.focusedElement);
-          if (this._prevFocus.get())
-            return;
-        } catch (ex) { }
-
-        this._prevFocus = Cu.getWeakReference(document.activeElement);
-      ]]></handler>
-      <handler event="popupshown"><![CDATA[
-        // Fire event for accessibility APIs
-        var alertEvent = document.createEvent("Events");
-        alertEvent.initEvent("AlertActive", true, true);
-        this.dispatchEvent(alertEvent);
-       ]]></handler>
-      <handler event="popuphiding"><![CDATA[
-        try {
-          this._currentFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          this._currentFocus = document.activeElement;
-        }
-      ]]></handler>
-      <handler event="popuphidden"><![CDATA[
-        function doFocus() {
-          // Focus was set on an element inside this panel,
-          // so we need to move it back to where it was previously
-          try {
-            let fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
-          } catch (e) {
-            prevFocus.focus();
-          }
-        }
-        var currentFocus = this._currentFocus;
-        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
-        this._currentFocus = null;
-        this._prevFocus = null;
-
-        // Avoid changing focus if focus changed while we hide the popup
-        // (This can happen e.g. if the popup is hiding as a result of a
-        // click/keypress that focused something)
-        let nowFocus;
-        try {
-          nowFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          nowFocus = document.activeElement;
-        }
-        if (nowFocus && nowFocus != currentFocus)
-          return;
-
-        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
-          // Try to restore focus
-          try {
-            if (document.commandDispatcher.focusedWindow != window)
-              return; // Focus has already been set to a window outside of this panel
-          } catch (ex) {}
-
-          if (!currentFocus) {
-            doFocus();
-            return;
-          }
-          while (currentFocus) {
-            if (currentFocus == this) {
-              doFocus();
-              return;
-            }
-            currentFocus = currentFocus.parentNode;
-          }
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
-
-  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
-    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
-      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
-               xbl:inherits="side,panelopen">
-        <xul:box anonid="arrowbox" class="panel-arrowbox">
-          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
-        </xul:box>
-        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
-          <children/>
-        </xul:box>
-      </xul:vbox>
-    </content>
-    <implementation>
-      <field name="_fadeTimer">null</field>
-      <method name="adjustArrowPosition">
-        <body>
-        <![CDATA[
-        var anchor = this.anchorNode;
-        if (!anchor) {
-          return;
-        }
-
-        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
-        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
-
-        var position = this.alignmentPosition;
-        var offset = this.alignmentOffset;
-
-        this.setAttribute("arrowposition", position);
-
-        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
-          container.orient = "horizontal";
-          arrowbox.orient = "vertical";
-          if (position.indexOf("_after") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(0, " + -offset + "px)";
-
-          // The assigned side stays the same regardless of direction.
-          var isRTL = (window.getComputedStyle(this).direction == "rtl");
-
-          if (position.indexOf("start_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", isRTL ? "left" : "right");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", isRTL ? "right" : "left");
-          }
-        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
-          container.orient = "";
-          arrowbox.orient = "";
-          if (position.indexOf("_end") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(" + -offset + "px, 0)";
-
-          if (position.indexOf("before_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", "bottom");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", "top");
-          }
-        }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="popupshowing" phase="target">
-      <![CDATA[
-        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
-        arrow.hidden = this.anchorNode == null;
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
-                .style.removeProperty("transform");
-
-        if (this.getAttribute("animate") != "false") {
-          this.setAttribute("animate", "open");
-          // the animating attribute prevents user interaction during transition
-          // it is removed when popupshown fires
-          this.setAttribute("animating", "true");
-        }
-
-        // set fading
-        var fade = this.getAttribute("fade");
-        var fadeDelay = 0;
-        if (fade == "fast") {
-          fadeDelay = 1;
-        } else if (fade == "slow") {
-          fadeDelay = 4000;
-        } else {
-          return;
-        }
-
-        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
-      ]]>
-      </handler>
-      <handler event="popuphiding" phase="target">
-        let animate = (this.getAttribute("animate") != "false");
-
-        if (this._fadeTimer) {
-          clearTimeout(this._fadeTimer);
-          if (animate) {
-            this.setAttribute("animate", "fade");
-          }
-        } else if (animate) {
-          this.setAttribute("animate", "cancel");
-        }
-      </handler>
-      <handler event="popupshown" phase="target">
-        this.removeAttribute("animating");
-        this.setAttribute("panelopen", "true");
-      </handler>
-      <handler event="popuphidden" phase="target">
-        this.removeAttribute("panelopen");
-        if (this.getAttribute("animate") != "false") {
-          this.removeAttribute("animate");
-        }
-      </handler>
-      <handler event="popuppositioned" phase="target">
-        this.adjustArrowPosition();
-      </handler>
-    </handlers>
-  </binding>
 </bindings>
diff --git a/toolkit/content/widgets/tabbox.js b/toolkit/content/widgets/tabbox.js
--- a/toolkit/content/widgets/tabbox.js
+++ b/toolkit/content/widgets/tabbox.js
@@ -316,28 +316,16 @@
       if (!this._initialized) {
         this.textContent = "";
         this.appendChild(this.fragment);
         this.initializeAttributeInheritance();
         this._initialized = true;
       }
     }
 
-    /**
-     * Passes DOM events to the on_<event type> methods.
-     */
-    handleEvent(event) {
-      let methodName = "on_" + event.type;
-      if (methodName in this) {
-        this[methodName](event);
-      } else {
-        throw new Error("Unrecognized event: " + event.type);
-      }
-    }
-
     on_mousedown(event) {
       if (event.button != 0 || this.disabled) {
         return;
       }
 
       this.parentNode.ariaFocusedItem = null;
 
       if (this == this.parentNode.selectedItem) {
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -229,17 +229,16 @@ menubar > menu:empty {
 /********* menupopup, panel, & tooltip ***********/
 
 menupopup {
   -moz-binding: url("chrome://global/content/bindings/popup.xml#popup");
   -moz-box-orient: vertical;
 }
 
 panel {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#panel");
   -moz-box-orient: vertical;
 }
 
 menupopup,
 panel,
 tooltip {
   display: -moz-popup;
   z-index: 2147483647;
@@ -247,20 +246,16 @@ tooltip {
 }
 
 tooltip {
   -moz-box-orient: vertical;
   white-space: pre-wrap;
   margin-top: 21px;
 }
 
-panel[type="arrow"] {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
-}
-
 @supports -moz-bool-pref("xul.panel-animations.enabled") {
 %ifdef MOZ_WIDGET_COCOA
   /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"
      instead of "transform" and "opacity" for these animations.
      The -moz-window* properties apply to the whole window including the window's
      shadow, and they don't affect the window's "shape", so the system doesn't
      have to recompute the shadow shape during the animation. This makes them a
      lot faster. In fact, Gecko no longer triggers shadow shape recomputations
diff --git a/toolkit/themes/linux/global/popup.css b/toolkit/themes/linux/global/popup.css
--- a/toolkit/themes/linux/global/popup.css
+++ b/toolkit/themes/linux/global/popup.css
@@ -35,57 +35,57 @@ panel[type="arrow"][side="right"] {
   padding: var(--arrowpanel-padding);
   color: var(--arrowpanel-color);
   background: var(--arrowpanel-background);
   border: 1px solid var(--arrowpanel-border-color);
   box-shadow: 0 0 4px hsla(0,0%,0%,.2);
   margin: 4px;
 }
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border */
 }
 
 .panel-arrow {
   -moz-context-properties: fill, stroke;
   fill: var(--arrowpanel-background);
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"],
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow),
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   position: relative;
   margin-left: 10px;
   margin-right: 10px;
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   margin-bottom: -5px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   transform: scaleY(-1);
   margin-top: -5px;
 }
 
-.panel-arrow[side="left"],
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow),
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   position: relative;
   margin-top: 10px;
   margin-bottom: 10px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   margin-right: -5px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   transform: scaleX(-1);
   margin-left: -5px;
 }
 
 /* rules for popups associated with menulists */
 
 menulist > menupopup {
   padding: 0px;
diff --git a/toolkit/themes/osx/global/popup.css b/toolkit/themes/osx/global/popup.css
--- a/toolkit/themes/osx/global/popup.css
+++ b/toolkit/themes/osx/global/popup.css
@@ -48,50 +48,50 @@ panel[type="arrow"][side="right"] {
   border-radius: var(--arrowpanel-border-radius);
   box-shadow: 0 0 0 1px var(--arrowpanel-border-color);
   color: var(--arrowpanel-color);
   border: none;
   padding: var(--arrowpanel-padding);
   margin: 1px;
 }
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border-radius */
 }
 
 .panel-arrow {
   -moz-context-properties: fill, stroke;
   fill: var(--arrowpanel-background);
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   margin-left: 16px;
   margin-right: 16px;
   margin-bottom: -1px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   -moz-transform: scaleY(-1);
   margin-left: 16px;
   margin-right: 16px;
   margin-top: -1px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   margin-top: 16px;
   margin-bottom: 16px;
   margin-right: -1px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   transform: scaleX(-1);
   margin-top: 16px;
   margin-bottom: 16px;
   margin-left: -1px;
 }
 
 /* rules for popups associated with menulists */
diff --git a/toolkit/themes/shared/notification-popup.inc.css b/toolkit/themes/shared/notification-popup.inc.css
--- a/toolkit/themes/shared/notification-popup.inc.css
+++ b/toolkit/themes/shared/notification-popup.inc.css
@@ -1,9 +1,9 @@
-.popup-notification-panel > .panel-arrowcontainer > .panel-arrowcontent {
+.popup-notification-panel::part(arrowcontent) {
   /* To keep the rounded borders of the panel, we use overflow: hidden; from the
    * panel-no-padding class to ensure the contents are clipped to the border box.
    * That causes us to override the "display" property so that the height of the
    * contents is computed correctly. */
   display: flex;
   /* Make multiple popupnotifications stack vertically. */
   flex-direction: column;
 }
diff --git a/toolkit/themes/windows/global/popup.css b/toolkit/themes/windows/global/popup.css
--- a/toolkit/themes/windows/global/popup.css
+++ b/toolkit/themes/windows/global/popup.css
@@ -58,57 +58,57 @@ panel[type="arrow"][side="right"] {
 %endif
 .panel-arrowcontent {
   border-radius: 4px;
 }
 %ifdef XP_WIN
 }
 %endif
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border-radius */
 }
 
 .panel-arrow {
   -moz-context-properties: fill, stroke;
   fill: var(--arrowpanel-background);
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"],
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow),
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   position: relative;
   margin-left: 10px;
   margin-right: 10px;
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   margin-bottom: -5px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   transform: scaleY(-1);
   margin-top: -5px;
 }
 
-.panel-arrow[side="left"],
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow),
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   position: relative;
   margin-top: 10px;
   margin-bottom: 10px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   margin-right: -5px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   transform: scaleX(-1);
   margin-left: -5px;
 }
 
 %ifdef XP_WIN
 @media (-moz-windows-default-theme) {
   .panel-arrowcontent {
     box-shadow: 0 0 4px hsla(210,4%,10%,.2);
