diff --git a/browser/base/content/test/performance/browser_appmenu.js b/browser/base/content/test/performance/browser_appmenu.js
--- a/browser/base/content/test/performance/browser_appmenu.js
+++ b/browser/base/content/test/performance/browser_appmenu.js
@@ -25,8 +25,8 @@
 
   {
     stack: [
-      "adjustArrowPosition@chrome://global/content/bindings/popup.xml",
-      "onxblpopuppositioned@chrome://global/content/bindings/popup.xml",
+      "adjustArrowPosition@chrome://global/content/elements/panel.js",
+      "on_popuppositioned@chrome://global/content/elements/panel.js",
     ],
 
     maxCount: 22, // This number should only ever go down - never up.
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_background.js b/browser/components/extensions/test/browser/browser_ext_popup_background.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_background.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_background.js
@@ -5,12 +5,8 @@
 
 async function testPanel(browser, standAlone, initial_background) {
   let panel = getPanelForNode(browser);
-  let arrowContent = document.getAnonymousElementByAttribute(
-    panel,
-    "class",
-    "panel-arrowcontent"
-  );
-  let arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
+  let arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   let checkArrow = (background = null) => {
     if (background == null || !standAlone) {
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_corners.js b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_corners.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_corners.js
@@ -35,11 +35,7 @@
 
   async function testPanel(browser, standAlone = true) {
     let panel = getPanelForNode(browser);
-    let arrowContent = document.getAnonymousElementByAttribute(
-      panel,
-      "class",
-      "panel-arrowcontent"
-    );
+    let arrowContent = panel.shadowRoot.querySelector(".panel-arrowcontent");
 
     let panelStyle = getComputedStyle(arrowContent);
 
diff --git a/browser/components/places/content/places-menupopup.js b/browser/components/places/content/places-menupopup.js
--- a/browser/components/places/content/places-menupopup.js
+++ b/browser/components/places/content/places-menupopup.js
@@ -585,27 +585,25 @@
 
     static get inheritedAttributes() {
       return {
-        ".panel-arrowcontainer": "side,panelopen",
-        ".panel-arrow": "side",
         ".panel-arrowcontent": "side,align,dir,orient,pack",
       };
     }
 
     get markup() {
       return `
-      <html:link rel="stylesheet" href="chrome://global/skin/global.css" />
+      <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
       <vbox class="panel-arrowcontainer" flex="1">
-        <box class="panel-arrowbox">
-          <image class="panel-arrow"></image>
+        <box class="panel-arrowbox" part="arrowbox">
+          <image class="panel-arrow" part="arrow"/>
         </box>
         <box class="panel-arrowcontent" part="arrowcontent" flex="1">
           <vbox part="drop-indicator-bar" hidden="true">
-            <image part="drop-indicator" mousethrough="always"></image>
+            <image part="drop-indicator" mousethrough="always"/>
           </vbox>
           <arrowscrollbox class="popup-internal-box" flex="1"
                           orient="vertical" smoothscroll="false"
                           part="popupbox">
-            <html:slot></html:slot>
+            <html:slot/>
           </arrowscrollbox>
         </box>
       </vbox>
diff --git a/browser/themes/linux/customizableui/panelUI.css b/browser/themes/linux/customizableui/panelUI.css
--- a/browser/themes/linux/customizableui/panelUI.css
+++ b/browser/themes/linux/customizableui/panelUI.css
@@ -27,7 +27,6 @@
  * overflow:hidden wasn't applied. Disabling the box-shadow for this panel on
  * Linux works around this issue. This bug is on file as 1394575.
  */
-#pageActionFeedback > .panel-arrowcontainer > .panel-arrowcontent {
+#pageActionFeedback::part(arrowcontent) {
   box-shadow: none;
 }
-
diff --git a/browser/themes/shared/controlcenter/panel.inc.css b/browser/themes/shared/controlcenter/panel.inc.css
--- a/browser/themes/shared/controlcenter/panel.inc.css
+++ b/browser/themes/shared/controlcenter/panel.inc.css
@@ -244,17 +244,17 @@
   -moz-box-align: center;
 }
 
-#protections-popup > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+#protections-popup::part(arrow) {
   transition-property: fill;
   transition-timing-function: var(--animation-easing-function);
   transition-duration: var(--panelui-subview-transition-duration);
 }
 
-#protections-popup[mainviewshowing] > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+#protections-popup[mainviewshowing]::part(arrow) {
   fill: #0A51BF;
 }
 
-:root[lwt-popup-brighttext] #protections-popup[mainviewshowing] > .panel-arrowcontainer > .panel-arrowbox > .panel-arrow {
+:root[lwt-popup-brighttext] #protections-popup[mainviewshowing]::part(arrow) {
   fill: #0CB0F5;
 }
 
diff --git a/browser/themes/shared/customizableui/panelUI.inc.css b/browser/themes/shared/customizableui/panelUI.inc.css
--- a/browser/themes/shared/customizableui/panelUI.inc.css
+++ b/browser/themes/shared/customizableui/panelUI.inc.css
@@ -255,11 +255,11 @@
   font-size: 1.1rem;
 }
 
-#confirmation-hint > .panel-arrowcontainer > .panel-arrowcontent {
+#confirmation-hint::part(arrowcontent) {
   -moz-box-align: center;
 }
 
-#confirmation-hint[hidearrow] > .panel-arrowcontainer > .panel-arrowbox {
+#confirmation-hint[hidearrow]::part(arrowbox) {
   /* Don't display the arrow but keep the popup at the same vertical
      offset as other arrow panels. */
   visibility: hidden;
@@ -371,8 +371,7 @@
   min-width: calc(@menuPanelWidth@ + 32px);
 }
 
-.cui-widget-panel.cui-widget-panelWithFooter::part(arrowcontent),
-.cui-widget-panel.cui-widget-panelWithFooter > .panel-arrowcontainer > .panel-arrowcontent {
+.cui-widget-panel.cui-widget-panelWithFooter::part(arrowcontent) {
   padding-bottom: 0;
 }
 
diff --git a/devtools/client/themes/tooltips.css b/devtools/client/themes/tooltips.css
--- a/devtools/client/themes/tooltips.css
+++ b/devtools/client/themes/tooltips.css
@@ -178,8 +178,8 @@
 
 /* The arrow image is hidden because the panel is opened using openPopupAtScreen(). */
 
-/* Remove all decorations on .panel-arrowcontent is the tooltip content container. */
-.tooltip-xul-wrapper[type="arrow"] .panel-arrowcontent {
+/* The arrow content is styled on the HTML, so we don't need the styling on the XUL element */
+.tooltip-xul-wrapper[type="arrow"]::part(arrowcontent) {
   margin: 0;
   padding: 0;
   background: transparent;
diff --git a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
--- a/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
+++ b/toolkit/components/extensions/test/browser/browser_ext_themes_arrowpanels.js
@@ -54,10 +54,8 @@
       // Open the information arrow panel
       await openIdentityPopup();
 
-      let arrowContent = document.getAnonymousElementByAttribute(
-        gIdentityHandler._identityPopup,
-        "class",
-        "panel-arrowcontent"
+      let arrowContent = gIdentityHandler._identityPopup.shadowRoot.querySelector(
+        ".panel-arrowcontent"
       );
       let arrowContentComputedStyle = window.getComputedStyle(arrowContent);
       // Ensure popup background color was set properly
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -460,6 +460,18 @@
       }
 
       /**
+       * Passes DOM events to the on_<event type> methods.
+       */
+      handleEvent(event) {
+        let methodName = "on_" + event.type;
+        if (methodName in this) {
+          this[methodName](event);
+        } else {
+          throw new Error("Unrecognized event: " + event.type);
+        }
+      }
+
+      /**
        * Allows eager deterministic construction of XUL elements with XBL attached, by
        * parsing an element tree and returning a DOM fragment to be inserted in the
        * document before any of the inner elements is referenced by JavaScript.
@@ -760,6 +772,7 @@
       "chrome://global/content/elements/menu.js",
       "chrome://global/content/elements/menupopup.js",
       "chrome://global/content/elements/notificationbox.js",
+      "chrome://global/content/elements/panel.js",
       "chrome://global/content/elements/popupnotification.js",
       "chrome://global/content/elements/radio.js",
       "chrome://global/content/elements/richlistbox.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -86,6 +86,7 @@
    content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/menupopup.js        (widgets/menupopup.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
+   content/global/elements/panel.js            (widgets/panel.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
diff --git a/toolkit/content/tests/chrome/test_arrowpanel.xul b/toolkit/content/tests/chrome/test_arrowpanel.xul
--- a/toolkit/content/tests/chrome/test_arrowpanel.xul
+++ b/toolkit/content/tests/chrome/test_arrowpanel.xul
@@ -286,8 +286,8 @@
 
   is(anchor, expectedAnchor, "anchor");
 
-  var arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
-  is(arrow.getAttribute("side"), expectedSide, "panel arrow side");
+  var arrow = panel.shadowRoot.querySelector(".panel-arrow");
+  is(panel.getAttribute("side"), expectedSide, "panel arrow side");
   is(arrow.hidden, false, "panel hidden");
   is(arrow.parentNode.pack, expectedPack, "panel arrow pack");
   is(panel.alignmentPosition, expectedAlignment, "panel alignmentPosition");
diff --git a/toolkit/content/tests/widgets/test_popupanchor.xul b/toolkit/content/tests/widgets/test_popupanchor.xul
--- a/toolkit/content/tests/widgets/test_popupanchor.xul
+++ b/toolkit/content/tests/widgets/test_popupanchor.xul
@@ -433,7 +433,7 @@
   // anchor is set by the test runner above
   panel = document.getElementById("testPanel");
 
-  arrow = SpecialPowers.wrap(document).getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
   runTests();
 });
 
diff --git a/toolkit/content/tests/widgets/test_popupreflows.xul b/toolkit/content/tests/widgets/test_popupreflows.xul
--- a/toolkit/content/tests/widgets/test_popupreflows.xul
+++ b/toolkit/content/tests/widgets/test_popupreflows.xul
@@ -87,7 +87,7 @@
 addEventListener("load", function() {
   anchor = document.getElementById("anchor");
   panel = document.getElementById("testPanel");
-  arrow = document.getAnonymousElementByAttribute(panel, "anonid", "arrow");
+  arrow = panel.shadowRoot.querySelector(".panel-arrow");
 
   // Cancel the arrow panel slide-in transition (bug 767133) - we are only
   // testing reflows in the core panel implementation and not reflows that may
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/panel.js
copy from toolkit/content/widgets/popup.xml
copy to toolkit/content/widgets/panel.js
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/panel.js
@@ -1,174 +1,163 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
 
-<bindings id="popupBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+  class MozPanel extends MozElements.MozElementMixin(XULPopupElement) {
+    constructor() {
+      super();
+
+      this._prevFocus = 0;
+
+      this.addEventListener("popupshowing", this);
+      this.addEventListener("popupshown", this);
+      this.addEventListener("popuphiding", this);
+      this.addEventListener("popuphidden", this);
+      this.addEventListener("popuppositioned", this);
+
+      this.attachShadow({ mode: "open" });
+    }
 
-  <binding id="panel">
-    <implementation>
-      <field name="_prevFocus">0</field>
-    </implementation>
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+
+      if (!this.isArrowPanel) {
+        this.shadowRoot.appendChild(document.createElement("slot"));
+        return;
+      }
+
+      this.shadowRoot.appendChild(this.fragment);
 
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // Capture the previous focus before has a chance to get set inside the panel
-        try {
-          this._prevFocus = Cu
-                            .getWeakReference(document.commandDispatcher.focusedElement);
-          if (this._prevFocus.get())
-            return;
-        } catch (ex) { }
+      if (!this.hasAttribute("flip")) {
+        this.setAttribute("flip", "both");
+      }
+      if (!this.hasAttribute("side")) {
+        this.setAttribute("side", "top");
+      }
+      if (!this.hasAttribute("position")) {
+        this.setAttribute("position", "bottomcenter topleft");
+      }
+      if (!this.hasAttribute("consumeoutsideclicks")) {
+        this.setAttribute("consumeoutsideclicks", "false");
+      }
+
+      this.initializeAttributeInheritance();
 
-        this._prevFocus = Cu.getWeakReference(document.activeElement);
-      ]]></handler>
-      <handler event="popupshown"><![CDATA[
-        // Fire event for accessibility APIs
-        var alertEvent = document.createEvent("Events");
-        alertEvent.initEvent("AlertActive", true, true);
-        this.dispatchEvent(alertEvent);
-       ]]></handler>
-      <handler event="popuphiding"><![CDATA[
-        try {
-          this._currentFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          this._currentFocus = document.activeElement;
-        }
-      ]]></handler>
-      <handler event="popuphidden"><![CDATA[
-        function doFocus() {
-          // Focus was set on an element inside this panel,
-          // so we need to move it back to where it was previously
-          try {
-            let fm = Cc["@mozilla.org/focus-manager;1"]
-                       .getService(Ci.nsIFocusManager);
-            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
-          } catch (e) {
-            prevFocus.focus();
-          }
+      this._fadeTimer = null;
+    }
+
+    get fragment() {
+      if (!this.constructor.hasOwnProperty("_fragment")) {
+        this.constructor._fragment = MozXULElement.parseXULToFragment(`
+        <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
+        <vbox class="panel-arrowcontainer" flex="1">
+          <box class="panel-arrowbox" part="arrowbox">
+            <image class="panel-arrow" part="arrow"/>
+          </box>
+          <box class="panel-arrowcontent" flex="1" part="arrowcontent"><html:slot/></box>
+        </vbox>
+      `);
+      }
+      return document.importNode(this.constructor._fragment, true);
+    }
+
+    static get inheritedAttributes() {
+      return {
+        ".panel-arrowcontent": "side,align,dir,orient,pack",
+      };
+    }
+
+    get isArrowPanel() {
+      return this.getAttribute("type") == "arrow";
+    }
+
+    adjustArrowPosition() {
+      if (!this.isArrowPanel) {
+        return;
+      }
+
+      var anchor = this.anchorNode;
+      if (!anchor) {
+        return;
+      }
+
+      var container = this.shadowRoot.querySelector(".panel-arrowcontainer");
+      var arrowbox = this.shadowRoot.querySelector(".panel-arrowbox");
+
+      var position = this.alignmentPosition;
+      var offset = this.alignmentOffset;
+
+      this.setAttribute("arrowposition", position);
+
+      if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
+        container.orient = "horizontal";
+        arrowbox.orient = "vertical";
+        if (position.indexOf("_after") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
         }
-        var currentFocus = this._currentFocus;
-        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
-        this._currentFocus = null;
-        this._prevFocus = null;
+        arrowbox.style.transform = "translate(0, " + -offset + "px)";
 
-        // Avoid changing focus if focus changed while we hide the popup
-        // (This can happen e.g. if the popup is hiding as a result of a
-        // click/keypress that focused something)
-        let nowFocus;
-        try {
-          nowFocus = document.commandDispatcher.focusedElement;
-        } catch (e) {
-          nowFocus = document.activeElement;
-        }
-        if (nowFocus && nowFocus != currentFocus)
-          return;
-
-        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
-          // Try to restore focus
-          try {
-            if (document.commandDispatcher.focusedWindow != window)
-              return; // Focus has already been set to a window outside of this panel
-          } catch (ex) {}
+        // The assigned side stays the same regardless of direction.
+        var isRTL = window.getComputedStyle(this).direction == "rtl";
 
-          if (!currentFocus) {
-            doFocus();
-            return;
-          }
-          while (currentFocus) {
-            if (currentFocus == this) {
-              doFocus();
-              return;
-            }
-            currentFocus = currentFocus.parentNode;
-          }
+        if (position.indexOf("start_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", isRTL ? "left" : "right");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", isRTL ? "right" : "left");
         }
-      ]]></handler>
-    </handlers>
-  </binding>
+      } else if (
+        position.indexOf("before_") == 0 ||
+        position.indexOf("after_") == 0
+      ) {
+        container.orient = "";
+        arrowbox.orient = "";
+        if (position.indexOf("_end") > 0) {
+          arrowbox.pack = "end";
+        } else {
+          arrowbox.pack = "start";
+        }
+        arrowbox.style.transform = "translate(" + -offset + "px, 0)";
 
-  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
-    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
-      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
-               xbl:inherits="side,panelopen">
-        <xul:box anonid="arrowbox" class="panel-arrowbox">
-          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
-        </xul:box>
-        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
-          <children/>
-        </xul:box>
-      </xul:vbox>
-    </content>
-    <implementation>
-      <field name="_fadeTimer">null</field>
-      <method name="adjustArrowPosition">
-        <body>
-        <![CDATA[
-        var anchor = this.anchorNode;
-        if (!anchor) {
+        if (position.indexOf("before_") == 0) {
+          container.dir = "reverse";
+          this.setAttribute("side", "bottom");
+        } else {
+          container.dir = "";
+          this.setAttribute("side", "top");
+        }
+      }
+    }
+
+    on_popupshowing(event) {
+      // Capture the previous focus before has a chance to get set inside the panel
+      try {
+        this._prevFocus = Cu.getWeakReference(
+          document.commandDispatcher.focusedElement
+        );
+        if (!this._prevFocus.get()) {
+          this._prevFocus = Cu.getWeakReference(document.activeElement);
           return;
         }
-
-        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
-        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
-
-        var position = this.alignmentPosition;
-        var offset = this.alignmentOffset;
-
-        this.setAttribute("arrowposition", position);
-
-        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
-          container.orient = "horizontal";
-          arrowbox.orient = "vertical";
-          if (position.indexOf("_after") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(0, " + -offset + "px)";
-
-          // The assigned side stays the same regardless of direction.
-          var isRTL = (window.getComputedStyle(this).direction == "rtl");
+      } catch (ex) {
+        this._prevFocus = Cu.getWeakReference(document.activeElement);
+      }
 
-          if (position.indexOf("start_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", isRTL ? "left" : "right");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", isRTL ? "right" : "left");
-          }
-        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
-          container.orient = "";
-          arrowbox.orient = "";
-          if (position.indexOf("_end") > 0) {
-            arrowbox.pack = "end";
-          } else {
-            arrowbox.pack = "start";
-          }
-          arrowbox.style.transform = "translate(" + -offset + "px, 0)";
-
-          if (position.indexOf("before_") == 0) {
-            container.dir = "reverse";
-            this.setAttribute("side", "bottom");
-          } else {
-            container.dir = "";
-            this.setAttribute("side", "top");
-          }
-        }
-        ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="popupshowing" phase="target">
-      <![CDATA[
-        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
+      if (this.isArrowPanel && event.target == this) {
+        var arrow = this.shadowRoot.querySelector(".panel-arrow");
         arrow.hidden = this.anchorNode == null;
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
-                .style.removeProperty("transform");
+        this.shadowRoot
+          .querySelector(".panel-arrowbox")
+          .style.removeProperty("transform");
 
         if (this.getAttribute("animate") != "false") {
           this.setAttribute("animate", "open");
@@ -184,15 +173,39 @@
           fadeDelay = 1;
         } else if (fade == "slow") {
           fadeDelay = 4000;
-        } else {
-          return;
         }
 
-        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
-      ]]>
-      </handler>
-      <handler event="popuphiding" phase="target">
-        let animate = (this.getAttribute("animate") != "false");
+        if (["fast", "slow"].includes(fade)) {
+          this._fadeTimer = setTimeout(
+            () => this.hidePopup(true),
+            fadeDelay,
+            this
+          );
+        }
+      }
+    }
+
+    on_popupshown(event) {
+      // Fire event for accessibility APIs
+      let alertEvent = document.createEvent("Events");
+      alertEvent.initEvent("AlertActive", true, true);
+      this.dispatchEvent(alertEvent);
+
+      if (this.isArrowPanel && event.target == this) {
+        this.removeAttribute("animating");
+        this.setAttribute("panelopen", "true");
+      }
+    }
+
+    on_popuphiding(event) {
+      try {
+        this._currentFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        this._currentFocus = document.activeElement;
+      }
+
+      if (this.isArrowPanel && event.target == this) {
+        let animate = this.getAttribute("animate") != "false";
 
         if (this._fadeTimer) {
           clearTimeout(this._fadeTimer);
@@ -202,20 +215,74 @@
         } else if (animate) {
           this.setAttribute("animate", "cancel");
         }
-      </handler>
-      <handler event="popupshown" phase="target">
-        this.removeAttribute("animating");
-        this.setAttribute("panelopen", "true");
-      </handler>
-      <handler event="popuphidden" phase="target">
+      }
+    }
+
+    on_popuphidden(event) {
+      if (this.isArrowPanel && event.target == this) {
         this.removeAttribute("panelopen");
         if (this.getAttribute("animate") != "false") {
           this.removeAttribute("animate");
         }
-      </handler>
-      <handler event="popuppositioned" phase="target">
+      }
+
+      function doFocus() {
+        // Focus was set on an element inside this panel,
+        // so we need to move it back to where it was previously
+        try {
+          let fm = Services.focus;
+          fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
+        } catch (e) {
+          prevFocus.focus();
+        }
+      }
+      var currentFocus = this._currentFocus;
+      var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
+      this._currentFocus = null;
+      this._prevFocus = null;
+
+      // Avoid changing focus if focus changed while we hide the popup
+      // (This can happen e.g. if the popup is hiding as a result of a
+      // click/keypress that focused something)
+      let nowFocus;
+      try {
+        nowFocus = document.commandDispatcher.focusedElement;
+      } catch (e) {
+        nowFocus = document.activeElement;
+      }
+      if (nowFocus && nowFocus != currentFocus) {
+        return;
+      }
+
+      if (prevFocus && this.getAttribute("norestorefocus") != "true") {
+        // Try to restore focus
+        try {
+          if (document.commandDispatcher.focusedWindow != window) {
+            // Focus has already been set to a window outside of this panel
+            return;
+          }
+        } catch (ex) {}
+
+        if (!currentFocus) {
+          doFocus();
+          return;
+        }
+        while (currentFocus) {
+          if (currentFocus == this) {
+            doFocus();
+            return;
+          }
+          currentFocus = currentFocus.parentNode;
+        }
+      }
+    }
+
+    on_popuppositioned(event) {
+      if (event.target == this) {
         this.adjustArrowPosition();
-      </handler>
-    </handlers>
-  </binding>
-</bindings>
+      }
+    }
+  }
+
+  customElements.define("panel", MozPanel);
+}
diff --git a/toolkit/content/widgets/tabbox.js b/toolkit/content/widgets/tabbox.js
--- a/toolkit/content/widgets/tabbox.js
+++ b/toolkit/content/widgets/tabbox.js
@@ -321,18 +321,6 @@
       }
     }
 
-    /**
-     * Passes DOM events to the on_<event type> methods.
-     */
-    handleEvent(event) {
-      let methodName = "on_" + event.type;
-      if (methodName in this) {
-        this[methodName](event);
-      } else {
-        throw new Error("Unrecognized event: " + event.type);
-      }
-    }
-
     on_mousedown(event) {
       if (event.button != 0 || this.disabled) {
         return;
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -233,7 +233,6 @@
 }
 
 panel {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#panel");
   -moz-box-orient: vertical;
 }
 
@@ -251,10 +250,6 @@
   margin-top: 21px;
 }
 
-panel[type="arrow"] {
-  -moz-binding: url("chrome://global/content/bindings/popup.xml#arrowpanel");
-}
-
 @supports -moz-bool-pref("xul.panel-animations.enabled") {
 %ifdef MOZ_WIDGET_COCOA
   /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"
diff --git a/toolkit/themes/linux/global/popup.css b/toolkit/themes/linux/global/popup.css
--- a/toolkit/themes/linux/global/popup.css
+++ b/toolkit/themes/linux/global/popup.css
@@ -40,7 +40,7 @@
   margin: 4px;
 }
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border */
 }
@@ -51,36 +51,36 @@
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"],
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow),
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   position: relative;
   margin-left: 10px;
   margin-right: 10px;
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   margin-bottom: -5px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   transform: scaleY(-1);
   margin-top: -5px;
 }
 
-.panel-arrow[side="left"],
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow),
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   position: relative;
   margin-top: 10px;
   margin-bottom: 10px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   margin-right: -5px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   transform: scaleX(-1);
   margin-left: -5px;
 }
diff --git a/toolkit/themes/osx/global/popup.css b/toolkit/themes/osx/global/popup.css
--- a/toolkit/themes/osx/global/popup.css
+++ b/toolkit/themes/osx/global/popup.css
@@ -53,7 +53,7 @@
   margin: 1px;
 }
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border-radius */
 }
@@ -64,14 +64,14 @@
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   margin-left: 16px;
   margin-right: 16px;
   margin-bottom: -1px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   -moz-transform: scaleY(-1);
   margin-left: 16px;
@@ -79,14 +79,14 @@
   margin-top: -1px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   margin-top: 16px;
   margin-bottom: 16px;
   margin-right: -1px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   transform: scaleX(-1);
   margin-top: 16px;
diff --git a/toolkit/themes/shared/notification-popup.inc.css b/toolkit/themes/shared/notification-popup.inc.css
--- a/toolkit/themes/shared/notification-popup.inc.css
+++ b/toolkit/themes/shared/notification-popup.inc.css
@@ -1,4 +1,4 @@
-.popup-notification-panel > .panel-arrowcontainer > .panel-arrowcontent {
+.popup-notification-panel::part(arrowcontent) {
   /* To keep the rounded borders of the panel, we use overflow: hidden; from the
    * panel-no-padding class to ensure the contents are clipped to the border box.
    * That causes us to override the "display" property so that the height of the
diff --git a/toolkit/themes/windows/global/popup.css b/toolkit/themes/windows/global/popup.css
--- a/toolkit/themes/windows/global/popup.css
+++ b/toolkit/themes/windows/global/popup.css
@@ -63,7 +63,7 @@
 }
 %endif
 
-panel[type="arrow"].panel-no-padding > .panel-arrowcontainer > .panel-arrowcontent {
+panel[type="arrow"].panel-no-padding::part(arrowcontent) {
   padding: 0;
   overflow: hidden; /* Don't let panel content overflow the border-radius */
 }
@@ -74,36 +74,36 @@
   stroke: var(--arrowpanel-border-color);
 }
 
-.panel-arrow[side="top"],
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow),
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-vertical.svg");
   position: relative;
   margin-left: 10px;
   margin-right: 10px;
 }
 
-.panel-arrow[side="top"] {
+:-moz-any(panel, menupopup)[side="top"]::part(arrow) {
   margin-bottom: -5px;
 }
 
-.panel-arrow[side="bottom"] {
+:-moz-any(panel, menupopup)[side="bottom"]::part(arrow) {
   transform: scaleY(-1);
   margin-top: -5px;
 }
 
-.panel-arrow[side="left"],
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow),
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   list-style-image: url("chrome://global/skin/arrow/panelarrow-horizontal.svg");
   position: relative;
   margin-top: 10px;
   margin-bottom: 10px;
 }
 
-.panel-arrow[side="left"] {
+:-moz-any(panel, menupopup)[side="left"]::part(arrow) {
   margin-right: -5px;
 }
 
-.panel-arrow[side="right"] {
+:-moz-any(panel, menupopup)[side="right"]::part(arrow) {
   transform: scaleX(-1);
   margin-left: -5px;
 }

