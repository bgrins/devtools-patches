# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  74b7ae11c6bf8677ac9a3569e2f25b7c9ec2c090

diff --git a/browser/base/content/tabbrowser-tabs.js b/browser/base/content/tabbrowser-tabs.js
--- a/browser/base/content/tabbrowser-tabs.js
+++ b/browser/base/content/tabbrowser-tabs.js
@@ -8,16 +8,87 @@
 
 // This is loaded into all browser.xul windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 class MozTabbrowserTabs extends MozElements.TabsBase {
   constructor() {
     super();
 
+    let self = this;
+    this.observer = {
+      observe(aSubject, aTopic, aData) {
+        switch (aTopic) {
+          case "nsPref:changed":
+            // This is has to deal with changes in
+            // privacy.userContext.enabled and
+            // privacy.userContext.longPressBehavior.
+            let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled") &&
+                                    !PrivateBrowsingUtils.isWindowPrivate(window);
+
+            // This pref won't change so often, so just recreate the menu.
+            let longPressBehavior = Services.prefs.getIntPref("privacy.userContext.longPressBehavior");
+
+            // If longPressBehavior pref is set to 0 (or any invalid value)
+            // long press menu is disabled.
+            if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
+              containersEnabled = false;
+            }
+
+            // There are separate "new tab" buttons for when the tab strip
+            // is overflowed and when it is not.  Attach the long click
+            // popup to both of them.
+            const newTab = document.getElementById("new-tab-button");
+            const newTab2 = self.newTabButton;
+
+            for (let parent of [newTab, newTab2]) {
+              if (!parent)
+                continue;
+
+              gClickAndHoldListenersOnElement.remove(parent);
+              parent.removeAttribute("type");
+              if (parent.menupopup) {
+                parent.menupopup.remove();
+              }
+
+              if (containersEnabled) {
+                let popup = document.createElementNS(
+                  "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+                  "menupopup");
+                if (parent.id) {
+                  popup.id = "newtab-popup";
+                } else {
+                  popup.setAttribute("anonid", "newtab-popup");
+                }
+                popup.className = "new-tab-popup";
+                popup.setAttribute("position", "after_end");
+                popup.addEventListener("popupshowing", event => {
+                  createUserContextMenu(event, {
+                    useAccessKeys: false,
+                    showDefaultTab: Services.prefs.getIntPref("privacy.userContext.longPressBehavior") == 1,
+                  });
+                });
+                parent.prepend(popup);
+
+                // longPressBehavior == 2 means that the menu is shown after X
+                // millisecs. Otherwise, with 1, the menu is open immediatelly.
+                if (longPressBehavior == 2) {
+                  gClickAndHoldListenersOnElement.add(parent);
+                }
+
+                parent.setAttribute("type", "menu");
+              }
+            }
+
+            break;
+        }
+      },
+      QueryInterface: ChromeUtils.generateQI([Ci.nsIObserver]),
+    };
+
     this.addEventListener("TabSelect", (event) => {
       this._handleTabSelect();
     });
 
     this.addEventListener("TabClose", (event) => {
       this._hiddenSoundPlayingStatusChanged(event.target, { closed: true });
     });
 
@@ -768,18 +839,18 @@ class MozTabbrowserTabs extends MozEleme
 
     var tab = this.firstTab;
     tab.label = this.emptyTabTitle;
 
     this.newTabButton.setAttribute("tooltiptext", GetDynamicShortcutTooltipText("tabs-newtab-button"));
 
     window.addEventListener("resize", this);
 
-    Services.prefs.addObserver("privacy.userContext", (...args) => this.observe(...args));
-    this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
+    Services.prefs.addObserver("privacy.userContext", this.observer);
+    this.observer.observe(null, "nsPref:changed", "privacy.userContext.enabled");
 
     XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
                                           "browser.tabs.tabMinWidth", null,
                                           (pref, prevValue, newValue) => this._tabMinWidth = newValue,
                                           newValue => {
                                             const LIMIT = 50;
                                             return Math.max(newValue, LIMIT);
                                           },
@@ -911,83 +982,16 @@ class MozTabbrowserTabs extends MozEleme
     arrowScrollbox._getScrollableElements = () => {
       return Array.prototype.filter.call(this.allTabs, arrowScrollbox._canScrollToElement);
     };
     arrowScrollbox._canScrollToElement = tab => {
       return !tab._pinnedUnscrollable && !tab.hidden;
     };
   }
 
-  observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "nsPref:changed":
-        // This is has to deal with changes in
-        // privacy.userContext.enabled and
-        // privacy.userContext.longPressBehavior.
-        let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled") &&
-                                !PrivateBrowsingUtils.isWindowPrivate(window);
-
-        // This pref won't change so often, so just recreate the menu.
-        let longPressBehavior = Services.prefs.getIntPref("privacy.userContext.longPressBehavior");
-
-        // If longPressBehavior pref is set to 0 (or any invalid value)
-        // long press menu is disabled.
-        if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
-          containersEnabled = false;
-        }
-
-        // There are separate "new tab" buttons for when the tab strip
-        // is overflowed and when it is not.  Attach the long click
-        // popup to both of them.
-        const newTab = document.getElementById("new-tab-button");
-        const newTab2 = this.newTabButton;
-
-        for (let parent of [newTab, newTab2]) {
-          if (!parent)
-            continue;
-
-          gClickAndHoldListenersOnElement.remove(parent);
-          parent.removeAttribute("type");
-          if (parent.menupopup) {
-            parent.menupopup.remove();
-          }
-
-          if (containersEnabled) {
-            let popup = document.createElementNS(
-              "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
-              "menupopup");
-            if (parent.id) {
-              popup.id = "newtab-popup";
-            } else {
-              popup.setAttribute("anonid", "newtab-popup");
-            }
-            popup.className = "new-tab-popup";
-            popup.setAttribute("position", "after_end");
-            popup.addEventListener("popupshowing", event => {
-              createUserContextMenu(event, {
-                useAccessKeys: false,
-                showDefaultTab: Services.prefs.getIntPref("privacy.userContext.longPressBehavior") == 1,
-              });
-            });
-            parent.prepend(popup);
-
-            // longPressBehavior == 2 means that the menu is shown after X
-            // millisecs. Otherwise, with 1, the menu is open immediatelly.
-            if (longPressBehavior == 2) {
-              gClickAndHoldListenersOnElement.add(parent);
-            }
-
-            parent.setAttribute("type", "menu");
-          }
-        }
-
-        break;
-    }
-  }
-
   _getVisibleTabs() {
     // Cannot access gBrowser before it's initialized.
     if (!gBrowser) {
       return [this.firstElementChild];
     }
 
     return gBrowser.visibleTabs;
   }
@@ -1812,18 +1816,16 @@ class MozTabbrowserTabs extends MozEleme
       this.setAttribute("hiddensoundplaying", "true");
     } else {
       this._hiddenSoundPlayingTabs.delete(tab);
       if (this._hiddenSoundPlayingTabs.size == 0) {
         this.removeAttribute("hiddensoundplaying");
       }
     }
   }
-  disconnectedCallback() {
-    Services.prefs.removeObserver("privacy.userContext", this);
-
+  destroy() {
+    Services.prefs.removeObserver("privacy.userContext", this.observer);
     CustomizableUI.removeListener(this);
   }
 }
 
-MozXULElement.implementCustomInterface(MozTabbrowserTabs, [Ci.nsIObserver]);
 customElements.define("tabbrowser-tabs", MozTabbrowserTabs, {extends: "tabs"});
 }
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -4471,16 +4471,17 @@ window._gBrowser = {
 
     // We want panel IDs to be globally unique, that's why we include the
     // window ID. We switched to a monotonic counter as Date.now() lead
     // to random failures because of colliding IDs.
     return "panel-" + outerID + "-" + (++this._uniquePanelIDCounter);
   },
 
   destroy() {
+    this.tabContainer.destroy();
     Services.obs.removeObserver(this, "contextual-identity-updated");
 
     for (let tab of this.tabs) {
       let browser = tab.linkedBrowser;
       if (browser.registeredOpenURI) {
         let userContextId = browser.getAttribute("usercontextid") || 0;
         this.UrlbarProviderOpenTabs.unregisterOpenTab(browser.registeredOpenURI.spec,
                                                       userContextId);
