# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  9af095f0970f081dfdfc7aa2e7205d72001934a9

diff --git a/devtools/client/inspector/rules/views/rule-editor.js b/devtools/client/inspector/rules/views/rule-editor.js
--- a/devtools/client/inspector/rules/views/rule-editor.js
+++ b/devtools/client/inspector/rules/views/rule-editor.js
@@ -53,42 +53,44 @@ const XUL_NS = "http://www.mozilla.org/k
  *        The CssRuleView containg the document holding this rule editor.
  * @param {Rule} rule
  *        The Rule object we're editing.
  */
 function RuleEditor(ruleView, rule) {
   EventEmitter.decorate(this);
 
   this.ruleView = ruleView;
+  this.toolbox = ruleView.inspector.toolbox;
   this.doc = this.ruleView.styleDocument;
   this.rule = rule;
 
   this.isEditable = !rule.isSystem;
   // Flag that blocks updates of the selector and properties when it is
   // being edited
   this.isEditing = false;
 
   this._onNewProperty = this._onNewProperty.bind(this);
   this._newPropertyDestroy = this._newPropertyDestroy.bind(this);
   this._onSelectorDone = this._onSelectorDone.bind(this);
   this._locationChanged = this._locationChanged.bind(this);
   this._toolRegistrationChanged = this._toolRegistrationChanged.bind(this);
+  this.updateSourceLink = this.updateSourceLink.bind(this);
 
   this.rule.domRule.on("location-changed", this._locationChanged);
-  gDevTools.on("tool-registered", this._toolRegistrationChanged);
-  gDevTools.on("tool-unregistered", this._toolRegistrationChanged);
+  this.toolbox.on("tool-registered", this.updateSourceLink);
+  this.toolbox.on("tool-unregistered", this.updateSourceLink);
 
   this._create();
 }
 
 RuleEditor.prototype = {
   destroy: function() {
     this.rule.domRule.off("location-changed");
-    gDevTools.off("tool-registered", this._toolRegistrationChanged);
-    gDevTools.off("tool-unregistered", this._toolRegistrationChanged);
+    this.toolbox.off("tool-registered", this._toolRegistrationChanged);
+    this.toolbox.off("tool-unregistered", this._toolRegistrationChanged);
   },
 
   get isSelectorEditable() {
     let toolbox = this.ruleView.inspector.toolbox;
     let trait = this.isEditable &&
       toolbox.target.client.traits.selectorEditable &&
       this.rule.domRule.type !== ELEMENT_STYLE &&
       this.rule.domRule.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE;
@@ -216,16 +218,18 @@ RuleEditor.prototype = {
    * Event handler called when a property changes on the
    * StyleRuleActor.
    */
   _locationChanged: function() {
     this.updateSourceLink();
   },
 
   updateSourceLink: function() {
+
+    console.log("updateSourceLink")
     let sourceLabel = this.element.querySelector(".ruleview-rule-source-label");
     let title = this.rule.title;
     let sourceHref = (this.rule.sheet && this.rule.sheet.href) ?
       this.rule.sheet.href : title;
     let sourceLine = this.rule.ruleLine > 0 ? ":" + this.rule.ruleLine : "";
 
     sourceLabel.setAttribute("tooltiptext", sourceHref + sourceLine);
 
@@ -243,18 +247,20 @@ RuleEditor.prototype = {
       }
     } else {
       sourceLabel.setAttribute("value", title);
       if (this.rule.ruleLine === -1 && this.rule.domRule.parentStyleSheet) {
         sourceLabel.parentNode.setAttribute("unselectable", "true");
       }
     }
 
-    if (!this._isStyleEditorEnabled()) {
-      sourceLabel.parentNode.setAttribute("unselectable", "true");
+    if (this.toolbox.isToolRegistered("styleeditor")) {
+      this.source.removeAttribute("unselectable");
+    } else {
+      this.source.setAttribute("unselectable", "true");
     }
 
     let showOrig = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);
     if (showOrig && !this.rule.isSystem &&
         this.rule.domRule.type !== ELEMENT_STYLE) {
       // Only get the original source link if the right pref is set, if the rule
       // isn't a system rule and if it isn't an inline rule.
       this.rule.getOriginalSourceStrings().then((strings) => {
