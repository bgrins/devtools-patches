# HG changeset patch
# Parent 0b5f99a3db3596d11d1708fa2add47ecbdc9da08
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 899375 - Inspector attributes get removed if the name contains a colon

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -16,16 +16,20 @@ let {UndoStack} = require("devtools/shar
 let EventEmitter = require("devtools/shared/event-emitter");
 let {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 let promise = require("sdk/core/promise");
 
 Cu.import("resource:///modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+loader.lazyGetter(this, "DOMParser", function() {
+ return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
+});
 loader.lazyGetter(this, "AutocompletePopup", () => require("devtools/shared/autocomplete-popup").AutocompletePopup);
 
 /**
  * Vocabulary for the purposes of this file:
  *
  * MarkupContainer - the structure that holds an editor and its
  *  immediate children in the markup panel.
  * Node - A content node.
@@ -1106,17 +1110,17 @@ function ElementEditor(aContainer, aNode
 {
   this.doc = aContainer.doc;
   this.undo = aContainer.undo;
   this.template = aContainer.markup.template.bind(aContainer.markup);
   this.container = aContainer;
   this.markup = this.container.markup;
   this.node = aNode;
 
-  this.attrs = [];
+  this.attrs = { };
 
   // The templates will fill the following properties
   this.elt = null;
   this.tag = null;
   this.attrList = null;
   this.newAttr = null;
   this.summaryElt = null;
   this.closeElt = null;
@@ -1163,17 +1167,17 @@ function ElementEditor(aContainer, aNode
         let undoMods = this._startModifyingAttributes();
         this._applyAttributes(aVal, null, doMods, undoMods);
         this.undo.do(() => {
           doMods.apply();
         }, function() {
           undoMods.apply();
         });
       } catch(x) {
-        console.log(x);
+        console.error(x);
       }
     }
   });
 
   let tagName = this.node.nodeName.toLowerCase();
   this.tag.textContent = tagName;
   this.closeTag.textContent = tagName;
 
@@ -1212,17 +1216,17 @@ ElementEditor.prototype = {
   },
 
   _startModifyingAttributes: function() {
     return this.node.startModifyingAttributes();
   },
 
   _createAttribute: function EE_createAttribute(aAttr, aBefore)
   {
-    if (this.attrs.indexOf(aAttr.name) !== -1) {
+    if (this.attrs.hasOwnProperty(aAttr.name)) {
       var attr = this.attrs[aAttr.name];
       var name = attr.querySelector(".attrname");
       var val = attr.querySelector(".attrvalue");
     } else {
       // Create the template editor, which will save some variables here.
       let data = {
         attrName: aAttr.name,
       };
@@ -1302,18 +1306,17 @@ ElementEditor.prototype = {
    *
    * @param string aValue the user-entered value.
    * @param Element aAttrNode the attribute editor that created this
    *        set of attributes, used to place new attributes where the
    *        user put them.
    */
   _applyAttributes: function EE__applyAttributes(aValue, aAttrNode, aDoMods, aUndoMods)
   {
-    let attrs = escapeAttributeValues(aValue);
-
+    let attrs = parseAttributeValues(aValue, this.doc);
     for (let attr of attrs) {
       // Create an attribute editor next to the current attribute if needed.
       this._createAttribute(attr, aAttrNode ? aAttrNode.nextSibling : null);
 
       this._saveAttribute(attr.name, aUndoMods);
       aDoMods.setAttribute(attr.name, attr.value);
     }
   },
@@ -1398,107 +1401,51 @@ RootContainer.prototype = {
   update: function RC_update() {}
 };
 
 function nodeDocument(node) {
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
- * Properly escape attribute values.
+ * Parse attribute names and values from a string.
  *
  * @param  {String} attr
- *         The attributes for which the values are to be escaped.
+ *         The input string for which names/values are to be parsed.
+ * @param  {HTMLDocument} doc
+ *         A document that can be used to test valid attributes.
  * @return {Array}
- *         An array of attribute names and their escaped values.
+ *         An array of attribute names and their values.
  */
-function escapeAttributeValues(attr) {
-  let name = null;
-  let value = null;
-  let result = "";
+function parseAttributeValues(attr, doc) {
+
+  attr = attr.trim();
+
+  // Handle bad user inputs by appending a " or ' if it fails to parse without them.
+  let el = DOMParser.parseFromString("<div " + attr + "></div>", "text/html").body.childNodes[0] ||
+           DOMParser.parseFromString("<div " + attr + "\"></div>", "text/html").body.childNodes[0] ||
+           DOMParser.parseFromString("<div " + attr + "'></div>", "text/html").body.childNodes[0];
+  let div = doc.createElement("div");
+
   let attributes = [];
+  for (let attribute of el.attributes) {
+    // Try to set on an element in the document, throws exception on bad input.
+    // Prevents InvalidCharacterError - "String contains an invalid character".
+    try {
+      div.setAttribute(attribute.name, attribute.value);
+      attributes.push({
+        name: attribute.name,
+        value: attribute.value
+      });
+    }
+    catch(e) { }
+  }
 
-  while(attr.length > 0) {
-    let match;
-    let dirty = false;
-
-    // Trim quotes and spaces from attr start
-    match = attr.match(/^["\s]+/);
-    if (match && match.length == 1) {
-      attr = attr.substr(match[0].length);
-    }
-
-    // Name
-    if (!dirty) {
-      match = attr.match(/^([\w-]+)="/);
-      if (match && match.length == 2) {
-        if (name) {
-          // We had a name without a value e.g. disabled. Let's set the value to "";
-          value = "";
-        } else {
-          name = match[1];
-          attr = attr.substr(match[0].length);
-        }
-        dirty = true;
-      }
-    }
-
-    // Value (in the case of multiple attributes)
-    if (!dirty) {
-      match = attr.match(/^(.+?)"\s+[\w-]+="/);
-      if (match && match.length > 1) {
-        value = typeof match[1] == "undefined" ? match[2] : match[1];
-        attr = attr.substr(value.length);
-        value = simpleEscape(value);
-        dirty = true;
-      }
-    }
-
-    // Final value
-    if (!dirty && attr.indexOf("=\"") == -1) {
-      // No more attributes, get the remaining value minus it's ending quote.
-      if (attr.charAt(attr.length - 1) == '"') {
-        attr = attr.substr(0, attr.length - 1);
-      }
-
-      if (!name) {
-        name = attr;
-        value = "";
-      } else {
-        value = simpleEscape(attr);
-      }
-      attr = "";
-      dirty = true;
-    }
-
-    if (name !== null && value !== null) {
-      attributes.push({name: name, value: value});
-      name = value = null;
-    }
-
-    if (!dirty) {
-      // This should never happen but we exit here if it does.
-      return attributes;
-    }
-  }
-  return attributes;
-}
-
-/**
- * Escape basic html entities <, >, " and '.
- * @param  {String} value
- *         Value to escape.
- * @return {String}
- *         Escaped value.
- */
-function simpleEscape(value) {
-  return value.replace(/</g, "&lt;")
-              .replace(/>/g, "&gt;")
-              .replace(/"/g, "&quot;")
-              .replace(/'/g, "&apos;");
+  // Attributes return from DOMParser in reverse order from how they are entered.
+  return attributes.reverse();
 }
 
 /**
  * A tree walker filter for avoiding empty whitespace text nodes.
  */
 function whitespaceTextFilter(aNode)
 {
     if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
diff --git a/browser/devtools/markupview/test/browser_inspector_markup_edit.js b/browser/devtools/markupview/test/browser_inspector_markup_edit.js
--- a/browser/devtools/markupview/test/browser_inspector_markup_edit.js
+++ b/browser/devtools/markupview/test/browser_inspector_markup_edit.js
@@ -225,25 +225,157 @@ function test() {
         assertAttributes(doc.querySelector("#node25"), {
           id: "node25",
         });
       },
       execute: function(after) {
         inspector.once("markupmutation", after);
         let editor = getContainerForRawNode(markup, doc.querySelector("#node25")).editor;
         let attr = editor.newAttr;
-        editField(attr, 'src="somefile.html?param1=<a>&param2=&uuml;"bl\'ah"');
+        editField(attr, 'src="somefile.html?param1=<a>&param2=&uuml;&param3=\'&quot;\'"');
       },
       after: function() {
         assertAttributes(doc.querySelector("#node25"), {
           id: "node25",
-          src: "somefile.html?param1=&lt;a&gt;&param2=&uuml;&quot;bl&apos;ah"
+          src: "somefile.html?param1=<a>&param2=\xfc&param3='\"'"
         });
       }
     },
+    {
+      desc: "Add an attribute value without closing \"",
+      enteredText: 'style="display: block;',
+      expectedAttributes: {
+        style: "display: block;"
+      }
+    },
+    {
+      desc: "Add an attribute value without closing '",
+      enteredText: "style='display: inline;",
+      expectedAttributes: {
+        style: "display: inline;"
+      }
+    },
+    {
+      desc: "Add an attribute wrapped with with double quotes double quote in it",
+      enteredText: 'style="display: "inline',
+      expectedAttributes: {
+        style: "display: ",
+        inline: ""
+      }
+    },
+    {
+      desc: "Add an attribute wrapped with single quotes with single quote in it",
+      enteredText: "style='display: 'inline",
+      expectedAttributes: {
+        style: "display: ",
+        inline: ""
+      }
+    },
+    {
+      desc: "Add an attribute with no value",
+      enteredText: "disabled",
+      expectedAttributes: {
+        disabled: ""
+      }
+    },
+    {
+      desc: "Add multiple attributes with no value",
+      enteredText: "disabled autofocus",
+      expectedAttributes: {
+        disabled: "",
+        autofocus: ""
+      }
+    },
+    {
+      desc: "Add multiple attributes with no value, and some with value",
+      enteredText: "disabled name='name' data-test='test' autofocus",
+      expectedAttributes: {
+        disabled: "",
+        autofocus: "",
+        name: "name",
+        'data-test': "test"
+      }
+    },
+    {
+      desc: "Add attribute with xmlns",
+      enteredText: "xmlns:edi='http://ecommerce.example.org/schema'",
+      expectedAttributes: {
+        'xmlns:edi': "http://ecommerce.example.org/schema"
+      }
+    },
+    {
+      desc: "Mixed single and double quotes",
+      enteredText: "name=\"hi\" maxlength='not a number'",
+      expectedAttributes: {
+        maxlength: "not a number",
+        name: "hi"
+      }
+    },
+    {
+      desc: "Invalid attribute name",
+      enteredText: "x='y' <why-would-you-do-this>=\"???\"",
+      expectedAttributes: {
+        x: "y"
+      }
+    },
+    {
+      desc: "Double quote wrapped in single quotes",
+      enteredText: "x='h\"i'",
+      expectedAttributes: {
+        x: "h\"i"
+      }
+    },
+    {
+      desc: "Single quote wrapped in double quotes",
+      enteredText: "x=\"h'i\"",
+      expectedAttributes: {
+        x: "h'i"
+      }
+    },
+    {
+      desc: "No quote wrapping",
+      enteredText: "a=b x=y data-test=Some spaced data",
+      expectedAttributes: {
+        a: "b",
+        x: "y",
+        "data-test": "Some",
+        spaced: "",
+        data: ""
+      }
+    },
+    {
+      desc: "Duplicate Attributes",
+      enteredText: "a=b a='c' a=\"d\"",
+      expectedAttributes: {
+        a: "b"
+      }
+    },
+    {
+      desc: "Inline styles",
+      enteredText: "style=\"font-family: 'Lucida Grande', sans-serif; font-size: 75%;\"",
+      expectedAttributes: {
+        style: "font-family: 'Lucida Grande', sans-serif; font-size: 75%;"
+      }
+    },
+    {
+      desc: "Object attribute names",
+      enteredText: "toString=\"true\" hasOwnProperty=\"false\"",
+      expectedAttributes: {
+        toString: "true",
+        hasOwnProperty: "false"
+      }
+    },
+    {
+      desc: "Add event handlers",
+      enteredText: "onclick=\"javascript: throw new Error('wont fire');\" onload=\"alert('here');\"",
+      expectedAttributes: {
+        onclick: "javascript: throw new Error('wont fire');",
+        onload: "alert('here');"
+      }
+    }
   ];
 
   // Create the helper tab for parsing...
   gBrowser.selectedTab = gBrowser.addTab();
   gBrowser.selectedBrowser.addEventListener("load", function onload() {
     gBrowser.selectedBrowser.removeEventListener("load", onload, true);
     doc = content.document;
     waitForFocus(setupTest, content);
@@ -255,16 +387,48 @@ function test() {
     gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
       inspector = toolbox.getCurrentPanel();
       startTests();
     });
   }
 
   function startTests() {
     markup = inspector.markup;
+
+    // expectedAttributes - Shortcut to provide a more decalarative test when you only
+    // want to check the outcome of setting an attribute to a string.
+    edits.forEach((edit, i) => {
+      if (edit.expectedAttributes) {
+        let id = "expectedAttributes" + i;
+
+        let div = doc.createElement("div");
+        div.id = id;
+        doc.body.appendChild(div);
+
+        // Attach the ID onto the object that will assert attributes
+        edit.expectedAttributes.id = id;
+
+        edit.before = () => {
+          assertAttributes(doc.querySelector("#" + id), {
+            id: id,
+          });
+        };
+
+        edit.execute = (after) =>{
+          inspector.once("markupmutation", after);
+          let editor = getContainerForRawNode(markup, doc.querySelector("#" + id)).editor;
+          editField(editor.newAttr, edit.enteredText);
+        };
+
+        edit.after = () => {
+          assertAttributes(doc.querySelector("#" + id), edit.expectedAttributes);
+        };
+      }
+    });
+
     markup.expandAll().then(() => {
 
       let cursor = 0;
 
       function nextEditTest() {
         executeSoon(function() {
           if (cursor >= edits.length) {
             addAttributes();
