# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8801c220fd4f77e46ab9de5629866b1558a2b75a

diff --git a/dom/base/nsContentSink.cpp b/dom/base/nsContentSink.cpp
--- a/dom/base/nsContentSink.cpp
+++ b/dom/base/nsContentSink.cpp
@@ -1235,24 +1235,27 @@ nsContentSink::ScrollToRef()
 }
 
 void
 nsContentSink::StartLayout(bool aIgnorePendingSheets)
 {
   AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING("nsContentSink::StartLayout", LAYOUT,
                                         mDocumentURI->GetSpecOrDefault());
 
+  printf("nsContentSink::StartLayout %d %d %s\n", mLayoutStarted, mDeferredLayoutStart, mDocument->GetDocumentURI()->GetSpecOrDefault().get());
+
   if (mLayoutStarted) {
     // Nothing to do here
     return;
   }
 
   mDeferredLayoutStart = true;
 
   if (!aIgnorePendingSheets && WaitForPendingSheets()) {
+    printf("nsContentSink::StartLayout Bail out\n");
     // Bail out; we'll start layout when the sheets load
     return;
   }
 
   mDeferredLayoutStart = false;
 
   // Notify on all our content.  If none of our presshells have started layout
   // yet it'll be a no-op except for updating our data structures, a la
@@ -1260,16 +1263,17 @@ nsContentSink::StartLayout(bool aIgnoreP
   // have right now).  If some of them _have_ started layout, we want to make
   // sure to flush tags instead of just calling UpdateChildCounts() after we
   // loop over the shells.
   FlushTags();
 
   mLayoutStarted = true;
   mLastNotificationTime = PR_Now();
 
+  printf("nsContentSink::StartLayout mLayoutStarted\n");
   mDocument->SetMayStartLayout(true);
   nsCOMPtr<nsIPresShell> shell = mDocument->GetShell();
   // Make sure we don't call Initialize() for a shell that has
   // already called it. This can happen when the layout frame for
   // an iframe is constructed *between* the Embed() call for the
   // docshell in the iframe, and the content sink's call to OpenBody().
   // (Bug 153815)
   if (shell && !shell->DidInitialize()) {
diff --git a/dom/xml/nsXMLContentSink.cpp b/dom/xml/nsXMLContentSink.cpp
--- a/dom/xml/nsXMLContentSink.cpp
+++ b/dom/xml/nsXMLContentSink.cpp
@@ -1314,16 +1314,17 @@ nsXMLContentSink::HandleProcessingInstru
   if (ssle) {
     ssle->InitStyleLinkElement(false);
     ssle->SetEnableUpdates(false);
     mPrettyPrintXML = false;
   }
 
   nsresult rv = AddContentAsLeaf(node);
   NS_ENSURE_SUCCESS(rv, rv);
+  printf("Added stylesheet to %s", mDocument->GetDocumentURI()->GetSpecOrDefault().get());
   DidAddContent();
 
   if (ssle) {
     // This is an xml-stylesheet processing instruction... but it might not be
     // a CSS one if the type is set to something else.
     ssle->SetEnableUpdates(true);
     auto updateOrError =
       ssle->UpdateStyleSheet(mRunsToCompletion ? nullptr : this);
diff --git a/dom/xul/XULDocument.cpp b/dom/xul/XULDocument.cpp
--- a/dom/xul/XULDocument.cpp
+++ b/dom/xul/XULDocument.cpp
@@ -708,19 +708,21 @@ XULDocument::Init()
 
     return NS_OK;
 }
 
 
 nsresult
 XULDocument::StartLayout(void)
 {
+    printf("XULDocument STartLayout %s\n", GetDocumentURI()->GetSpecOrDefault().get());
     mMayStartLayout = true;
     nsCOMPtr<nsIPresShell> shell = GetShell();
     if (shell) {
+    printf("XULDocument STartLayout with shell\n");
         // Resize-reflow this time
         nsPresContext *cx = shell->GetPresContext();
         NS_ASSERTION(cx != nullptr, "no pres context");
         if (! cx)
             return NS_ERROR_UNEXPECTED;
 
         nsCOMPtr<nsIDocShell> docShell = cx->GetDocShell();
         NS_ASSERTION(docShell != nullptr, "container is not a docshell");
