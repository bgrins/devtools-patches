# HG changeset patch
# Parent eca72af01ab2a8aa3cef5712d956be733963bf58
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 892979 - Clicking on the markup view scrolls the view in a weird way

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -170,22 +170,34 @@ MarkupView.prototype = {
       // and decision to show or not the tooltip
       return container._buildTooltipContent(target, this.tooltip);
     }
   },
 
   /**
    * Highlight the inspector selected node.
    */
-  _onNewSelection: function() {
+  _onNewSelection: function(event = "none", data = {}, reason = "") {
+    console.log("ON new selected", data, data.ignoreScroll, reason);
+
     this.htmlEditor.hide();
     let done = this._inspector.updating("markup-view");
     if (this._inspector.selection.isNode()) {
-      this.showNode(this._inspector.selection.nodeFront, true).then(() => {
-        this.markNodeAsSelected(this._inspector.selection.nodeFront);
+      let node = this._inspector.selection.nodeFront;
+      // TODO: This is called multiple times from navigate with the same node, making tracking scrolling silly
+      this.showNode(node).then(() => {
+        this.markNodeAsSelected(node);
+        console.log("HERE WE GO.  CONTINUE? ", reason !== "mousedown")
+        if (reason !== "mousedown") {
+          console.log("SCROLLING");
+          let centered = true;
+          this.layoutHelpers.scrollIntoViewIfNeeded(
+            this._containers.get(node).editor.elt, centered);
+        }
+
         done();
       });
     } else {
       this.unmarkSelectedNode();
       done();
     }
   },
 
@@ -354,31 +366,35 @@ MarkupView.prototype = {
   },
 
   /**
    * Handle a user-requested navigation to a given MarkupContainer,
    * updating the inspector's currently-selected node.
    *
    * @param MarkupContainer aContainer
    *        The container we're navigating to.
-   * @param aIgnoreFocus aIgnoreFocus
+   * @param boolean aIgnoreFocus
    *        If falsy, keyboard focus will be moved to the container too.
+   * @param boolean aIgnoreScroll
+   *        If falsy, scroll will not move to the element
    */
-  navigate: function(aContainer, aIgnoreFocus) {
+  navigate: function(aContainer, aIgnoreFocus = false, aIgnoreScroll = false) {
     if (!aContainer) {
       return;
     }
 
+    console.log("\nNavigate requested.  Should ignore scroll?", aIgnoreScroll)
     let node = aContainer.node;
-    this.markNodeAsSelected(node, "treepanel");
+    let reason = aIgnoreScroll ? "mousedown" : "treepanel";
+    this.markNodeAsSelected(node, reason);
 
     // This event won't be fired if the node is the same. But the highlighter
     // need to lock the node if it wasn't.
-    this._inspector.selection.emit("new-node");
-    this._inspector.selection.emit("new-node-front");
+    this._inspector.selection.emit("new-node", { }, reason);
+    this._inspector.selection.emit("new-node-front", { }, reason);
 
     if (!aIgnoreFocus) {
       aContainer.focus();
     }
   },
 
   /**
    * Make sure a node is included in the markup tool.
@@ -540,32 +556,30 @@ MarkupView.prototype = {
       container.flashMutation();
     }
     for (let container of addedOrEditedContainers) {
       container.flashMutation();
     }
   },
 
   /**
-   * Make sure the given node's parents are expanded and the
-   * node is scrolled on to screen.
+   * Make sure the given node's parents are expanded
    */
-  showNode: function(aNode, centered) {
+  showNode: function(aNode) {
+    console.log("Show node");
+    console.trace();
     let container = this.importNode(aNode);
     let parent = aNode;
     while ((parent = parent.parentNode())) {
       this.importNode(parent);
       this.expandNode(parent);
     }
 
     return this._waitForChildren().then(() => {
       return this._ensureVisible(aNode);
-    }).then(() => {
-      // Why is this not working?
-      this.layoutHelpers.scrollIntoViewIfNeeded(this._containers.get(aNode).editor.elt, centered);
     });
   },
 
   /**
    * Expand the container's children.
    */
   _expandContainer: function(aContainer) {
     return this._updateChildren(aContainer, {expand: true}).then(() => {
@@ -1276,17 +1290,17 @@ MarkupContainer.prototype = {
   _onMouseOut: function(event) {
     this.highlighted = false;
     event.stopPropagation();
   },
 
   _onMouseDown: function(event) {
     if (event.target.nodeName !== "a") {
       this.highlighted = false;
-      this.markup.navigate(this);
+      this.markup.navigate(this, false, true);
       event.stopPropagation();
     }
   },
 
   _onClick: function(event) {
     let target = event.target;
 
     if (target.nodeName === "a") {
