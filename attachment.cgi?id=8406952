# HG changeset patch
# Parent 12796fe3eb01e86b2d725cd617863325c0052eec
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 825410 - intermittent browser_inspector_pseudoclass_lock.js test failures; r=bgrins

diff --git a/browser/devtools/inspector/test/browser_inspector_bug_672902_keyboard_shortcuts.js b/browser/devtools/inspector/test/browser_inspector_bug_672902_keyboard_shortcuts.js
--- a/browser/devtools/inspector/test/browser_inspector_bug_672902_keyboard_shortcuts.js
+++ b/browser/devtools/inspector/test/browser_inspector_bug_672902_keyboard_shortcuts.js
@@ -31,24 +31,22 @@ function test()
   }
 
   function findAndHighlightNode(aInspector, aToolbox)
   {
     inspector = aInspector;
 
     // Make sure the body element is selected initially.
     node = doc.querySelector("body");
-    inspector.once("inspector-updated", () => {
-      is(inspector.selection.node, node, "Body should be selected initially.");
-      node = doc.querySelector("h1")
-      inspector.once("inspector-updated", highlightHeaderNode);
-      let bc = inspector.breadcrumbs;
-      bc.nodeHierarchy[bc.currentIndex].button.focus();
-      EventUtils.synthesizeKey("VK_RIGHT", { });
-    });
+    is(inspector.selection.node, node, "Body should be selected initially.");
+    node = doc.querySelector("h1")
+    inspector.once("inspector-updated", highlightHeaderNode);
+    let bc = inspector.breadcrumbs;
+    bc.nodeHierarchy[bc.currentIndex].button.focus();
+    EventUtils.synthesizeKey("VK_RIGHT", {});
   }
 
   function highlightHeaderNode()
   {
     is(inspector.selection.node, node, "selected h1 element");
 
     executeSoon(function() {
       inspector.once("inspector-updated", highlightParagraphNode);
diff --git a/browser/devtools/inspector/test/browser_inspector_bug_958456_highlight_comments.js b/browser/devtools/inspector/test/browser_inspector_bug_958456_highlight_comments.js
--- a/browser/devtools/inspector/test/browser_inspector_bug_958456_highlight_comments.js
+++ b/browser/devtools/inspector/test/browser_inspector_bug_958456_highlight_comments.js
@@ -20,17 +20,17 @@ function test() {
   gBrowser.selectedBrowser.addEventListener("load", function onload() {
     gBrowser.selectedBrowser.removeEventListener("load", onload, true);
     doc = content.document;
 
     waitForFocus(function() {
       openInspector((aInspector, aToolbox) => {
         inspector = aInspector;
         markupView = inspector.markup;
-        inspector.once("inspector-updated", startTests);
+        startTests();
       });
     }, content);
   }, true);
   content.location = TEST_PAGE;
 }
 
 function startTests() {
   Task.spawn(function() {
diff --git a/browser/devtools/inspector/test/browser_inspector_iframeTest.js b/browser/devtools/inspector/test/browser_inspector_iframeTest.js
--- a/browser/devtools/inspector/test/browser_inspector_iframeTest.js
+++ b/browser/devtools/inspector/test/browser_inspector_iframeTest.js
@@ -30,19 +30,17 @@ function createDocument() {
 
       div2 = iframe2.contentDocument.createElement('div');
       div2.textContent = 'nested div';
       iframe2.contentDocument.body.appendChild(div2);
 
       // Open the inspector, start the picker mode, and start the tests
       openInspector(aInspector => {
         inspector = aInspector;
-        inspector.once("inspector-updated", () => {
-          inspector.toolbox.highlighterUtils.startPicker().then(runTests);
-        });
+        inspector.toolbox.highlighterUtils.startPicker().then(runTests);
       });
     }, false);
 
     iframe2.src = 'data:text/html,nested iframe';
     iframe1.contentDocument.body.appendChild(iframe2);
   }, false);
 
   iframe1.src = 'data:text/html,little iframe';
diff --git a/browser/devtools/inspector/test/browser_inspector_invalidate.js b/browser/devtools/inspector/test/browser_inspector_invalidate.js
--- a/browser/devtools/inspector/test/browser_inspector_invalidate.js
+++ b/browser/devtools/inspector/test/browser_inspector_invalidate.js
@@ -8,19 +8,17 @@ function test() {
 
   function createDocument() {
     div = doc.createElement("div");
     div.setAttribute("style", "width: 100px; height: 100px; background:yellow;");
     doc.body.appendChild(div);
 
     openInspector(aInspector => {
       inspector = aInspector;
-      inspector.once("inspector-updated", () => {
-        inspector.toolbox.highlighter.showBoxModel(getNodeFront(div)).then(runTest);
-      });
+      inspector.toolbox.highlighter.showBoxModel(getNodeFront(div)).then(runTest);
     });
   }
 
   function runTest() {
     let rect = getSimpleBorderRect();
     is(rect.width, 100, "outline has the right width");
 
     div.style.width = "200px";
diff --git a/browser/devtools/inspector/test/browser_inspector_pseudoclass_lock.js b/browser/devtools/inspector/test/browser_inspector_pseudoclass_lock.js
--- a/browser/devtools/inspector/test/browser_inspector_pseudoclass_lock.js
+++ b/browser/devtools/inspector/test/browser_inspector_pseudoclass_lock.js
@@ -1,189 +1,159 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
+// Test that locking the pseudoclass displays correctly in the ruleview
+
 let DOMUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
+const PSEUDO = ":hover";
 
-let doc;
-let parentDiv, div, div2;
-let inspector;
-let ruleview;
+waitForExplicitFinish();
 
-let pseudo = ":hover";
-
-function test()
-{
-  waitForExplicitFinish();
+function test() {
   ignoreAllUncaughtExceptions();
   gBrowser.selectedTab = gBrowser.addTab();
   gBrowser.selectedBrowser.addEventListener("load", function() {
     gBrowser.selectedBrowser.removeEventListener("load", arguments.callee, true);
-    doc = content.document;
-    waitForFocus(createDocument, content);
+    waitForFocus(startTests, content);
   }, true);
 
   content.location = "data:text/html,pseudo-class lock tests";
 }
 
-function createDocument()
-{
-  parentDiv = doc.createElement("div");
+let startTests = Task.async(function*() {
+  createDocument();
+  let {toolbox, inspector, view} = yield openRuleView();
+  yield selectNode("#div-1", inspector);
+
+  yield performTests(inspector, view);
+
+  yield finishUp(toolbox);
+  finish();
+});
+
+function createDocument() {
+  let doc = content.document;
+
+  let parentDiv = doc.createElement("div");
   parentDiv.textContent = "parent div";
+  parentDiv.id = "parent-div";
 
-  div = doc.createElement("div");
+  let div = doc.createElement("div");
   div.textContent = "test div";
+  div.id = "div-1";
 
-  div2 = doc.createElement("div");
+  let div2 = doc.createElement("div");
   div2.textContent = "test div2";
+  div2.id = "div-2";
 
   let head = doc.getElementsByTagName('head')[0];
   let style = doc.createElement('style');
   let rules = doc.createTextNode('div { color: red; } div:hover { color: blue; }');
 
   style.appendChild(rules);
   head.appendChild(style);
   parentDiv.appendChild(div);
   parentDiv.appendChild(div2);
   doc.body.appendChild(parentDiv);
-
-  openInspector(selectNode);
 }
 
-function selectNode(aInspector)
-{
-  inspector = aInspector;
+function* performTests(inspector, ruleview) {
+  yield togglePseudoClass(inspector);
+  yield testAdded(inspector, ruleview);
 
-  waitForView("ruleview", () => {
-    ruleview = inspector.sidebar.getWindowForTab("ruleview").ruleview.view;
-    inspector.sidebar.select("ruleview");
-    inspector.selection.setNode(div, "test");
-    inspector.once("inspector-updated", performTests);
-  });
+  yield togglePseudoClass(inspector);
+  yield testRemoved();
+  yield testRemovedFromUI(inspector, ruleview);
+
+  yield togglePseudoClass(inspector);
+  yield testNavigate(inspector, ruleview);
 }
 
-function performTests()
-{
-  // toggle the class
-  inspector.togglePseudoClass(pseudo);
+function* togglePseudoClass(inspector) {
+  info("Toggle the pseudoclass, wait for the pseudoclass event and wait for the refresh of the rule view");
 
-  // Wait for the "pseudoclass" event so we know the
-  // inspector has been told of the pseudoclass lock change.
-  inspector.selection.once("pseudoclass", () => {
-    inspector.once("rule-view-refreshed", () => {
-      testAdded(() => {
-        // Change the pseudo class and give the rule view time to update.
-        inspector.togglePseudoClass(pseudo);
-        inspector.selection.once("pseudoclass", () => {
-          inspector.once("rule-view-refreshed", () => {
-            testRemoved();
-            testRemovedFromUI(() => {
-              // toggle it back on
-              inspector.togglePseudoClass(pseudo);
-              inspector.selection.once("pseudoclass", () => {
-                inspector.once("rule-view-refreshed", () => {
-                  testNavigate(() => {
-                    // close the inspector
-                    finishUp();
-                  });
-                });
-              });
-            });
-          });
-        });
-      });
-    });
-  });
+  let onPseudo = inspector.selection.once("pseudoclass");
+  let onRefresh = inspector.once("rule-view-refreshed");
+  inspector.togglePseudoClass(PSEUDO);
+
+  yield onPseudo;
+  yield onRefresh;
 }
 
-function testNavigate(callback)
-{
-  inspector.selection.setNode(parentDiv, "test");
-  inspector.once("inspector-updated", () => {
+function* testNavigate(inspector, ruleview) {
+  yield selectNode("#parent-div", inspector);
 
-    // make sure it's still on after naving to parent
-    is(DOMUtils.hasPseudoClassLock(div, pseudo), true,
-      "pseudo-class lock is still applied after inspecting ancestor");
+  info("Make sure the pseudoclass is still on after navigating to a parent");
+  is(DOMUtils.hasPseudoClassLock(getNode("#div-1"), PSEUDO), true,
+    "pseudo-class lock is still applied after inspecting ancestor");
 
-    inspector.selection.setNode(div2, "test");
-    inspector.selection.once("pseudoclass", () => {
-      // make sure it's removed after naving to a non-hierarchy node
-      is(DOMUtils.hasPseudoClassLock(div, pseudo), false,
-        "pseudo-class lock is removed after inspecting sibling node");
+  let onPseudo = inspector.selection.once("pseudoclass");
+  yield selectNode("#div-2", inspector);
+  yield onPseudo;
 
-      // toggle it back on
-      inspector.selection.setNode(div, "test");
-      inspector.once("inspector-updated", () => {
-        inspector.togglePseudoClass(pseudo);
-        inspector.once("computed-view-refreshed", callback);
-      });
-    });
-  });
+  info("Make sure the pseudoclass is removed after navigating to a non-hierarchy node");
+  is(DOMUtils.hasPseudoClassLock(getNode("#div-1"), PSEUDO), false,
+    "pseudo-class lock is removed after inspecting sibling node");
+
+  yield selectNode("#div-1", inspector);
+  yield togglePseudoClass(inspector);
+  yield inspector.once("computed-view-refreshed");
 }
 
-function showPickerOn(node, cb)
-{
+function showPickerOn(node, inspector) {
   let highlighter = inspector.toolbox.highlighter;
-  highlighter.showBoxModel(getNodeFront(node)).then(cb);
+  return highlighter.showBoxModel(getNodeFront(node));
 }
 
-function testAdded(cb)
-{
-  // lock is applied to it and ancestors
-  let node = div;
+function* testAdded(inspector, ruleview) {
+  info("Make sure the pseudoclass lock is applied to #div-1 and its ancestors");
+  let node = getNode("#div-1");
   do {
-    is(DOMUtils.hasPseudoClassLock(node, pseudo), true,
+    is(DOMUtils.hasPseudoClassLock(node, PSEUDO), true,
       "pseudo-class lock has been applied");
     node = node.parentNode;
   } while (node.parentNode)
 
-  // ruleview contains pseudo-class rule
+  info("Check that the ruleview contains the pseudo-class rule");
   let rules = ruleview.element.querySelectorAll(".ruleview-rule.theme-separator");
   is(rules.length, 3, "rule view is showing 3 rules for pseudo-class locked div");
-  is(rules[1]._ruleEditor.rule.selectorText, "div:hover", "rule view is showing " + pseudo + " rule");
+  is(rules[1]._ruleEditor.rule.selectorText, "div:hover", "rule view is showing " + PSEUDO + " rule");
 
-  // Show the highlighter by starting the pick mode and hovering over the div
-  showPickerOn(div, () => {
-    // infobar selector contains pseudo-class
-    let pseudoClassesBox = getHighlighter().querySelector(".highlighter-nodeinfobar-pseudo-classes");
-    is(pseudoClassesBox.textContent, pseudo, "pseudo-class in infobar selector");
-    inspector.toolbox.highlighter.hideBoxModel().then(cb);
-  });
+  info("Show the highlighter on #div-1");
+  yield showPickerOn(getNode("#div-1"), inspector);
+
+  info("Check that the infobar selector contains the pseudo-class");
+  let pseudoClassesBox = getHighlighter().querySelector(".highlighter-nodeinfobar-pseudo-classes");
+  is(pseudoClassesBox.textContent, PSEUDO, "pseudo-class in infobar selector");
+  yield inspector.toolbox.highlighter.hideBoxModel();
 }
 
-function testRemoved()
-{
-  // lock removed from node and ancestors
-  let node = div;
+function* testRemoved() {
+  info("Make sure the pseudoclass lock is removed from #div-1 and its ancestors");
+  let node = getNode("#div-1");
   do {
-    is(DOMUtils.hasPseudoClassLock(node, pseudo), false,
+    is(DOMUtils.hasPseudoClassLock(node, PSEUDO), false,
        "pseudo-class lock has been removed");
     node = node.parentNode;
   } while (node.parentNode)
 }
 
-function testRemovedFromUI(cb)
-{
-  // ruleview no longer contains pseudo-class rule
+function* testRemovedFromUI(inspector, ruleview) {
+  info("Check that the ruleview no longer contains the pseudo-class rule");
   let rules = ruleview.element.querySelectorAll(".ruleview-rule.theme-separator");
   is(rules.length, 2, "rule view is showing 2 rules after removing lock");
 
-  showPickerOn(div, () => {
-    let pseudoClassesBox = getHighlighter().querySelector(".highlighter-nodeinfobar-pseudo-classes");
-    is(pseudoClassesBox.textContent, "", "pseudo-class removed from infobar selector");
-    inspector.toolbox.highlighter.hideBoxModel().then(cb);
-  });
+  yield showPickerOn(getNode("#div-1"), inspector);
+
+  let pseudoClassesBox = getHighlighter().querySelector(".highlighter-nodeinfobar-pseudo-classes");
+  is(pseudoClassesBox.textContent, "", "pseudo-class removed from infobar selector");
+  yield inspector.toolbox.highlighter.hideBoxModel();
 }
 
-function finishUp()
-{
-  gDevTools.once("toolbox-destroyed", function() {
-    testRemoved();
-    inspector = ruleview = null;
-    doc = div = null;
-    gBrowser.removeCurrentTab();
-    finish();
-  });
+function* finishUp(toolbox) {
+  let onDestroy = gDevTools.once("toolbox-destroyed");
+  toolbox.destroy();
+  yield onDestroy;
 
-  let target = TargetFactory.forTab(gBrowser.selectedTab);
-  let toolbox = gDevTools.getToolbox(target);
-  toolbox.destroy();
+  yield testRemoved(getNode("#div-1"));
+  gBrowser.removeCurrentTab();
 }
diff --git a/browser/devtools/inspector/test/head.js b/browser/devtools/inspector/test/head.js
--- a/browser/devtools/inspector/test/head.js
+++ b/browser/devtools/inspector/test/head.js
@@ -36,24 +36,172 @@ SimpleTest.registerCleanupFunction(() =>
   console.error("Here we are\n");
   let {DebuggerServer} = Cu.import("resource://gre/modules/devtools/dbg-server.jsm", {});
   console.error("DebuggerServer open connections: " + Object.getOwnPropertyNames(DebuggerServer._connections).length);
 
   Services.prefs.clearUserPref("devtools.dump.emit");
   Services.prefs.clearUserPref("devtools.inspector.activeSidebar");
 });
 
-function openInspector(callback)
-{
+/**
+ * Simple DOM node accesor function that takes either a node or a string css
+ * selector as argument and returns the corresponding node
+ * @param {String|DOMNode} nodeOrSelector
+ * @return {DOMNode}
+ */
+function getNode(nodeOrSelector) {
+  return typeof nodeOrSelector === "string" ?
+    content.document.querySelector(nodeOrSelector) :
+    nodeOrSelector;
+}
+
+/**
+ * Set the inspector's current selection to a node or to the first match of the
+ * given css selector
+ * @param {InspectorPanel} inspector The instance of InspectorPanel currently
+ * loaded in the toolbox
+ * @param {String} reason Defaults to "test" which instructs the inspector not
+ * to highlight the node upon selection
+ * @param {String} reason Defaults to "test" which instructs the inspector not to highlight the node upon selection
+ * @return a promise that resolves when the inspector is updated with the new
+ * node
+ */
+function selectNode(nodeOrSelector, inspector, reason="test") {
+  info("Selecting the node " + nodeOrSelector);
+  let node = getNode(nodeOrSelector);
+  let updated = inspector.once("inspector-updated");
+  inspector.selection.setNode(node, reason);
+  return updated;
+}
+
+/**
+ * Open the toolbox, with the inspector tool visible.
+ * @param {Function} cb Optional callback, if you don't want to use the returned
+ * promise
+ * @return a promise that resolves when the inspector is ready
+ */
+let openInspector = Task.async(function*(cb) {
+  info("Opening the inspector");
   let target = TargetFactory.forTab(gBrowser.selectedTab);
-  gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
-    callback(toolbox.getCurrentPanel(), toolbox);
-  }).then(null, console.error);
+
+  let inspector, toolbox;
+
+  // Checking if the toolbox and the inspector are already loaded
+  // The inspector-updated event should only be waited for if the inspector
+  // isn't loaded yet
+  toolbox = gDevTools.getToolbox(target);
+  if (toolbox) {
+    inspector = toolbox.getPanel("inspector");
+    if (inspector) {
+      info("Toolbox and inspector already open");
+      if (cb) {
+        return cb(inspector, toolbox);
+      } else {
+        return {
+          toolbox: toolbox,
+          inspector: inspector
+        };
+      }
+    }
+  }
+
+  info("Opening the toolbox");
+  toolbox = yield gDevTools.showToolbox(target, "inspector");
+  yield waitForToolboxFrameFocus(toolbox);
+  inspector = toolbox.getPanel("inspector");
+
+  info("Waiting for the inspector to update");
+  yield inspector.once("inspector-updated");
+
+  if (cb) {
+    return cb(inspector, toolbox);
+  } else {
+    return {
+      toolbox: toolbox,
+      inspector: inspector
+    };
+  }
+});
+
+/**
+ * Wait for the toolbox frame to receive focus after it loads
+ * @param {Toolbox} toolbox
+ * @return a promise that resolves when focus has been received
+ */
+function waitForToolboxFrameFocus(toolbox) {
+  info("Making sure that the toolbox's frame is focused");
+  let def = promise.defer();
+  let win = toolbox.frame.contentWindow;
+  waitForFocus(def.resolve, win);
+  return def.promise;
 }
 
+/**
+ * Open the toolbox, with the inspector tool visible, and the sidebar that
+ * corresponds to the given id selected
+ * @return a promise that resolves when the inspector is ready and the sidebar
+ * view is visible and ready
+ */
+let openInspectorSideBar = Task.async(function*(id) {
+  let {toolbox, inspector} = yield openInspector();
+
+  if (!hasSideBarTab(inspector, id)) {
+    info("Waiting for the " + id + " sidebar to be ready");
+    yield inspector.sidebar.once(id + "-ready");
+  }
+
+  info("Selecting the " + id + " sidebar");
+  inspector.sidebar.select(id);
+
+  return {
+    toolbox: toolbox,
+    inspector: inspector,
+    view: inspector.sidebar.getWindowForTab(id)[id].view
+  };
+});
+
+/**
+ * Open the toolbox, with the inspector tool visible, and the computed-view
+ * sidebar tab selected.
+ * @return a promise that resolves when the inspector is ready and the computed
+ * view is visible and ready
+ */
+function openComputedView() {
+  return openInspectorSideBar("computedview");
+}
+
+/**
+ * Open the toolbox, with the inspector tool visible, and the rule-view
+ * sidebar tab selected.
+ * @return a promise that resolves when the inspector is ready and the rule
+ * view is visible and ready
+ */
+function openRuleView() {
+  return openInspectorSideBar("ruleview");
+}
+
+/**
+ * Checks whether the inspector's sidebar corresponding to the given id already
+ * exists
+ * @param {InspectorPanel}
+ * @param {String}
+ * @return {Boolean}
+ */
+function hasSideBarTab(inspector, id) {
+  return !!inspector.sidebar.getWindowForTab(id);
+}
+
+// function openInspector(callback)
+// {
+//   let target = TargetFactory.forTab(gBrowser.selectedTab);
+//   gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
+//     callback(toolbox.getCurrentPanel(), toolbox);
+//   }).then(null, console.error);
+// }
+
 function getActiveInspector()
 {
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   return gDevTools.getToolbox(target).getPanel("inspector");
 }
 
 function getNodeFront(node)
 {
