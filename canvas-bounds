# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c93b53c3289594e8056c63cbf94f6a7ad87b4c69
Bug 1169035 - Use getBoundsWithoutFlushing instead of getBoxQuads to get coordinates of Graph canvas;r=vporof

diff --git a/browser/devtools/shared/widgets/Graphs.jsm b/browser/devtools/shared/widgets/Graphs.jsm
--- a/browser/devtools/shared/widgets/Graphs.jsm
+++ b/browser/devtools/shared/widgets/Graphs.jsm
@@ -945,42 +945,64 @@ AbstractCanvasGraph.prototype = {
    * Checks whether a region is hovered.
    * @return boolean
    */
   _isHoveringRegion: function() {
     return !!this.getHoveredRegion();
   },
 
   /**
+   * Get the bounds of the canvas while traversing frame boundaries.
+   * @return object {top,left,width,height}
+   */
+  _getCanvasBoundsRelativeToTopWindow: function() {
+    let utils = this._window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+                            .getInterface(Components.interfaces.nsIDOMWindowUtils);
+
+    let {left,top,width,height} = utils.getBoundsWithoutFlushing(this._canvas);
+    let frame = this._window.frameElement;
+
+    while (frame) {
+      let bounds = utils.getBoundsWithoutFlushing(frame);
+      left += bounds.left;
+      top += bounds.top;
+      frame = frame.contentWindow.parent.frameElement;
+    }
+
+    return {
+      left: left,
+      top: top,
+      width: width,
+      height: height
+    }
+  },
+
+  /**
    * Given a MouseEvent, make it relative to this._canvas.
    * @return object {mouseX,mouseY}
    */
   _getRelativeEventCoordinates: function(e) {
     // For ease of testing, testX and testY can be passed in as the event
     // object.  If so, just return this.
     if ("testX" in e && "testY" in e) {
       return {
         mouseX: e.testX * this._pixelRatio,
         mouseY: e.testY * this._pixelRatio
       };
     }
 
-    let quad = this._canvas.getBoxQuads({
-      relativeTo: this._topWindow.document
-    })[0];
+    let {left,top,width,height} = this._getCanvasBoundsRelativeToTopWindow();
 
-    let x = (e.screenX - this._topWindow.screenX) - quad.p1.x;
-    let y = (e.screenY - this._topWindow.screenY) - quad.p1.y;
+    let x = (e.screenX - this._topWindow.screenX) - left;
+    let y = (e.screenY - this._topWindow.screenY) - top;
 
     // Don't allow the event coordinates to be bigger than the canvas
     // or less than 0.
-    let maxX = quad.p2.x - quad.p1.x;
-    let maxY = quad.p3.y - quad.p1.y;
-    let mouseX = Math.max(0, Math.min(x, maxX)) * this._pixelRatio;
-    let mouseY = Math.max(0, Math.min(x, maxY)) * this._pixelRatio;
+    let mouseX = Math.max(0, Math.min(x, width)) * this._pixelRatio;
+    let mouseY = Math.max(0, Math.min(x, height)) * this._pixelRatio;
 
     return {mouseX,mouseY};
   },
 
   /**
    * Listener for the "mousemove" event on the graph's container.
    */
   _onMouseMove: function(e) {
