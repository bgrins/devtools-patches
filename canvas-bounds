# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  67db850294e49c0ac66c6e923d5de2442d5b173c
Bug 1169035 - Use getBoundsWithoutFlushing instead of getBoxQuads to get coordinates of Graph canvas;r=vporof

diff --git a/devtools/client/shared/widgets/Graphs.jsm b/devtools/client/shared/widgets/Graphs.jsm
--- a/devtools/client/shared/widgets/Graphs.jsm
+++ b/devtools/client/shared/widgets/Graphs.jsm
@@ -1,14 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Cu = Components.utils;
+const Ci = Components.interfaces;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 const promise = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
 const {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 const {EventEmitter} = Cu.import("resource://gre/modules/devtools/event-emitter.js", {});
 const {DevToolsWorker} = Cu.import("resource://gre/modules/devtools/shared/worker.js", {});
 const {LayoutHelpers} = Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm", {});
 
@@ -946,42 +947,64 @@ AbstractCanvasGraph.prototype = {
    * Checks whether a region is hovered.
    * @return boolean
    */
   _isHoveringRegion: function() {
     return !!this.getHoveredRegion();
   },
 
   /**
+   * Get the bounds of the canvas while traversing frame boundaries.
+   * @return object {top,left,width,height}
+   */
+  _getCanvasBoundsRelativeToTopWindow: function() {
+    let utils = this._window.QueryInterface(Ci.nsIInterfaceRequestor)
+                            .getInterface(Ci.nsIDOMWindowUtils);
+
+    let {left,top,width,height} = utils.getBoundsWithoutFlushing(this._canvas);
+    let frame = this._window.frameElement;
+
+    while (frame) {
+      let bounds = utils.getBoundsWithoutFlushing(frame);
+      left += bounds.left;
+      top += bounds.top;
+      frame = frame.contentWindow.parent.frameElement;
+    }
+
+    return {
+      left: left,
+      top: top,
+      width: width,
+      height: height
+    }
+  },
+
+  /**
    * Given a MouseEvent, make it relative to this._canvas.
    * @return object {mouseX,mouseY}
    */
   _getRelativeEventCoordinates: function(e) {
     // For ease of testing, testX and testY can be passed in as the event
     // object.  If so, just return this.
     if ("testX" in e && "testY" in e) {
       return {
         mouseX: e.testX * this._pixelRatio,
         mouseY: e.testY * this._pixelRatio
       };
     }
 
-    let quad = this._canvas.getBoxQuads({
-      relativeTo: this._topWindow.document
-    })[0];
+    let {left,top,width,height} = this._getCanvasBoundsRelativeToTopWindow();
 
-    let x = (e.screenX - this._topWindow.screenX) - quad.p1.x;
-    let y = (e.screenY - this._topWindow.screenY) - quad.p1.y;
+    let x = (e.screenX - this._topWindow.screenX) - left;
+    let y = (e.screenY - this._topWindow.screenY) - top;
 
     // Don't allow the event coordinates to be bigger than the canvas
     // or less than 0.
-    let maxX = quad.p2.x - quad.p1.x;
-    let maxY = quad.p3.y - quad.p1.y;
-    let mouseX = Math.max(0, Math.min(x, maxX)) * this._pixelRatio;
-    let mouseY = Math.max(0, Math.min(x, maxY)) * this._pixelRatio;
+    let mouseX = Math.max(0, Math.min(x, width)) * this._pixelRatio;
+    let mouseY = Math.max(0, Math.min(x, height)) * this._pixelRatio;
 
     // The coordinates need to be modified with the current zoom level
     // to prevent them from being wrong.
     let zoom = LayoutHelpers.getCurrentZoom(this._canvas);
     mouseX /= zoom;
     mouseY /= zoom;
 
     return {mouseX,mouseY};
