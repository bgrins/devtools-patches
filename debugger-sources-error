# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  16958c3e86dab77a301918df0d77400674f794d1
Bug 1153903 - Get rid of logspam during devtools talos test runs;r=pbrosset

diff --git a/browser/devtools/animationinspector/animation-controller.js b/browser/devtools/animationinspector/animation-controller.js
--- a/browser/devtools/animationinspector/animation-controller.js
+++ b/browser/devtools/animationinspector/animation-controller.js
@@ -39,28 +39,31 @@ let startup = Task.async(function*(inspe
   if (!typeof AnimationsPanel === "undefined") {
     throw new Error("AnimationsPanel was not loaded in the animationinspector window");
   }
 
   // Startup first initalizes the controller and then the panel, in sequence.
   // If you want to know when everything's ready, do:
   // AnimationsPanel.once(AnimationsPanel.PANEL_INITIALIZED)
   yield AnimationsController.initialize();
-  yield AnimationsPanel.initialize();
+
+  if (!AnimationsController.destroyed) {
+    yield AnimationsPanel.initialize();
+  }
 });
 
 /**
  * Shutdown the animationinspector controller and view, called by the sidebar
  * widget when loading/unloading the iframe into the tab.
  */
 let shutdown = Task.async(function*() {
   yield AnimationsController.destroy();
   // Don't assume that AnimationsPanel is defined here, it's in another file.
-  if (typeof AnimationsPanel !== "undefined") {
-    yield AnimationsPanel.destroy()
+  if (typeof AnimationsPanel !== "undefined" && AnimationsPanel.initialized) {
+    yield AnimationsPanel.destroy();
   }
   gToolbox = gInspector = null;
 });
 
 // This is what makes the sidebar widget able to load/unload the panel.
 function setPanel(panel) {
   return startup(panel).catch(Cu.reportError);
 }
@@ -92,35 +95,36 @@ let AnimationsController = {
   PLAYERS_UPDATED_EVENT: "players-updated",
 
   initialize: Task.async(function*() {
     if (this.initialized) {
       return this.initialized.promise;
     }
     this.initialized = promise.defer();
 
-    let target = gToolbox.target;
-    this.animationsFront = new AnimationsFront(target.client, target.form);
+    this.onPanelVisibilityChange = this.onPanelVisibilityChange.bind(this);
+    this.onNewNodeFront = this.onNewNodeFront.bind(this);
+    this.onAnimationMutations = this.onAnimationMutations.bind(this);
+
+    let {target} = gToolbox;
 
     // Expose actor capabilities.
     this.hasToggleAll = yield target.actorHasMethod("animations", "toggleAll");
     this.hasSetCurrentTime = yield target.actorHasMethod("animationplayer",
                                                          "setCurrentTime");
     this.hasMutationEvents = yield target.actorHasMethod("animations",
                                                          "stopAnimationPlayerUpdates");
     this.hasSetPlaybackRate = yield target.actorHasMethod("animationplayer",
                                                           "setPlaybackRate");
 
-    this.onPanelVisibilityChange = this.onPanelVisibilityChange.bind(this);
-    this.onNewNodeFront = this.onNewNodeFront.bind(this);
-    this.onAnimationMutations = this.onAnimationMutations.bind(this);
-
-    this.startListeners();
-
-    yield this.onNewNodeFront();
+    if (!this.destroyed) {
+      this.animationsFront = new AnimationsFront(target.client, target.form);
+      this.startListeners();
+      yield this.onNewNodeFront();
+    }
 
     this.initialized.resolve();
   }),
 
   destroy: Task.async(function*() {
     if (!this.initialized) {
       return;
     }
diff --git a/browser/devtools/debugger/debugger-controller.js b/browser/devtools/debugger/debugger-controller.js
--- a/browser/devtools/debugger/debugger-controller.js
+++ b/browser/devtools/debugger/debugger-controller.js
@@ -1217,16 +1217,22 @@ SourceScripts.prototype = {
     // Signal that a new source has been added.
     window.emit(EVENTS.NEW_SOURCE);
   },
 
   /**
    * Callback for the debugger's active thread getSources() method.
    */
   _onSourcesAdded: function(aResponse) {
+    // if (!this.activeThread) {
+    //   let msg = "No active thread";
+    //   Cu.reportError(msg);
+    //   dumpn(msg);
+    //   return;
+    // }
     if (aResponse.error) {
       let msg = "Error getting sources: " + aResponse.message;
       Cu.reportError(msg);
       dumpn(msg);
       return;
     }
 
     if (aResponse.sources.length === 0) {
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -404,16 +404,20 @@ InspectorPanel.prototype = {
   _selectionCssSelector: null,
 
   /**
    * Set the currently selected node unique css selector.
    * Will store the current target url along with it to allow pre-selection at
    * reload
    */
   set selectionCssSelector(cssSelector = null) {
+    if (this._panelDestroyer) {
+      return;
+    }
+
     this._selectionCssSelector = {
       selector: cssSelector,
       url: this._target.url
     };
   },
 
   /**
    * Get the current selection unique css selector if any, that is, if a node
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -3063,17 +3063,17 @@ var WalkerFront = exports.WalkerFront = 
   }),
 
   /**
    * Handle the `new-mutations` notification by fetching the
    * available mutation records.
    */
   onMutations: protocol.preEvent("new-mutations", function() {
     // Fetch and process the mutations.
-    this.getMutations({cleanup: this.autoCleanup}).then(null, console.error);
+    this.getMutations({cleanup: this.autoCleanup}).catch(() => {});
   }),
 
   isLocal: function() {
     return !!this.conn._transport._serverConnection;
   },
 
   // XXX hack during transition to remote inspector: get a proper NodeFront
   // for a given local node.  Only works locally.
