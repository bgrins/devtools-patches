# HG changeset patch
# Parent 60f4ea5f21dfa0be0d3e8a6c05541fa695a9d6ee
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 1014547 - part 3 - Revisit the highlighter API to support multiple highlighter types

diff --git a/browser/devtools/framework/toolbox-highlighter-utils.js b/browser/devtools/framework/toolbox-highlighter-utils.js
--- a/browser/devtools/framework/toolbox-highlighter-utils.js
+++ b/browser/devtools/framework/toolbox-highlighter-utils.js
@@ -46,38 +46,40 @@ exports.getHighlighterUtils = function(t
    */
   let requireInspector = generator => {
     return Task.async(function*(...args) {
       yield toolbox.initInspector();
       return yield generator.apply(null, args);
     });
   };
 
+  let exported = {};
+
   /**
    * Start/stop the element picker on the debuggee target.
    * @return A promise that resolves when done
    */
-  function togglePicker() {
+  let togglePicker = exported.togglePicker = function() {
     if (isPicking) {
       return stopPicker();
     } else {
       return startPicker();
     }
   }
 
   /**
    * Start the element picker on the debuggee target.
    * This will request the inspector actor to start listening for mouse/touch
    * events on the target to highlight the hovered/picked element.
    * Depending on the server-side capabilities, this may fire events when nodes
    * are hovered.
    * @return A promise that resolves when the picker has started or immediately
    * if it is already started
    */
-  let startPicker = requireInspector(function*() {
+  let startPicker = exported.startPicker = requireInspector(function*() {
     if (isPicking) {
       return;
     }
 
     yield toolbox.selectTool("inspector");
 
     toolbox.pickerButtonChecked = true;
 
@@ -92,17 +94,17 @@ exports.getHighlighterUtils = function(t
   });
 
   /**
    * Stop the element picker. Note that the picker is automatically stopped when
    * an element is picked
    * @return A promise that resolves when the picker has stopped or immediately
    * if it is already stopped
    */
-  let stopPicker = requireInspector(function*() {
+  let stopPicker = exported.stopPicker = requireInspector(function*() {
     if (!isPicking) {
       return;
     }
 
     isPicking = false;
     toolbox.pickerButtonChecked = false;
 
     yield toolbox.highlighter.cancelPick();
@@ -133,67 +135,76 @@ exports.getHighlighterUtils = function(t
   /**
    * Show the box model highlighter on a node in the content page.
    * The node needs to be a NodeFront, as defined by the inspector actor
    * @see toolkit/devtools/server/actors/inspector.js
    * @param {NodeFront} nodeFront The node to highlight
    * @param {Object} options
    * @return A promise that resolves when the node has been highlighted
    */
-  let highlightNodeFront = requireInspector(function*(nodeFront, options={}) {
+  let highlightNodeFront = exported.highlightNodeFront = requireInspector(
+  function*(nodeFront, options={}) {
     yield toolbox.highlighter.showBoxModel(nodeFront, options);
     toolbox.emit("node-highlight", nodeFront);
   });
 
   /**
    * This is a convenience method in case you don't have a nodeFront but a
    * valueGrip. This is often the case with VariablesView properties.
    * This method will simply translate the grip into a nodeFront and call
    * highlightNodeFront, so it has the same signature.
    * @see highlightNodeFront
    */
-  let highlightDomValueGrip = requireInspector(function*(valueGrip, options={}) {
-    let nodeFront = yield translateGripToNodeFront(valueGrip);
+  let highlightDomValueGrip = exported.highlightDomValueGrip = requireInspector(
+  function*(valueGrip, options={}) {
+    let nodeFront = yield gripToNodeFront(valueGrip);
     if (nodeFront) {
       yield highlightNodeFront(nodeFront, options);
     } else {
       throw new Error("The ValueGrip passed could not be translated to a NodeFront");
     }
   });
 
   /**
    * Translate a debugger value grip into a node front usable by the inspector
    * @param {ValueGrip}
    * @return a promise that resolves to the node front when done
    */
-  let translateGripToNodeFront = requireInspector(function*(grip) {
+  let gripToNodeFront = exported.gripToNodeFront = requireInspector(
+  function*(grip) {
     return yield toolbox.walker.getNodeActorFromObjectActor(grip.actor);
   });
 
   /**
    * Hide the highlighter.
    * @param {Boolean} forceHide Only really matters in test mode (when
    * gDevTools.testing is true). In test mode, hovering over several nodes in
    * the markup view doesn't hide/show the highlighter to ease testing. The
    * highlighter stays visible at all times, except when the mouse leaves the
    * markup view, which is when this param is passed to true
    * @return a promise that resolves when the highlighter is hidden
    */
-  let unhighlight = Task.async(function*(forceHide=false) {
+  let unhighlight = exported.unhighlight = Task.async(
+  function*(forceHide=false) {
     forceHide = forceHide || !gDevTools.testing;
 
     if (forceHide && toolbox.highlighter) {
       yield toolbox.highlighter.hideBoxModel();
     }
 
     toolbox.emit("node-unhighlight");
   });
 
-  // Public API
-  return {
-    togglePicker: togglePicker,
-    startPicker: startPicker,
-    stopPicker: stopPicker,
-    highlightNodeFront: highlightNodeFront,
-    highlightDomValueGrip: highlightDomValueGrip,
-    unhighlight: unhighlight
-  };
+  /**
+   * If the main, box-model, highlighter isn't enough, or if multiple
+   * highlighters are needed in parallel, this method can be used to return a
+   * new instance of a highlighter actor, given a type.
+   * The type of the highlighter passed must be known by the server.
+   * The highlighter actor returned will have the show(nodeFront) and hide()
+   * methods and needs to be released by the consumer when not needed anymore
+   */
+  let getHighlighterByType = exported.getHighlighterByType = requireInspector(
+  function*(typeName) {
+    return yield toolbox.inspector.getHighlighterByType(typeName);
+  });
+
+  return exported;
 };
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -24,65 +24,74 @@ const PSEUDO_CLASSES = [":hover", ":acti
 const HIGHLIGHTED_PSEUDO_CLASS = ":-moz-devtools-highlighted";
 let HELPER_SHEET = ".__fx-devtools-hide-shortcut__ { visibility: hidden !important } ";
 HELPER_SHEET += ":-moz-devtools-highlighted { outline: 2px dashed #F06!important; outline-offset: -2px!important } ";
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const SVG_NS = "http://www.w3.org/2000/svg";
 const HIGHLIGHTER_PICKED_TIMER = 1000;
 const INFO_BAR_OFFSET = 5;
 
+// All possible highlighter classes
+const HIGHLIGHTER_CLASSES = {
+  "BoxModelHighlighter": BoxModelHighlighter
+};
+
 /**
- * The HighlighterActor is the server-side entry points for any tool that wishes
- * to highlight elements in the content document.
+ * The Highlighter is the server-side entry points for any tool that wishes to
+ * highlight elements in some way in the content document.
  *
- * The highlighter can be retrieved via the inspector's getHighlighter method.
+ * A little bit of vocabulary:
+ * - <something>HighlighterActor classes are the actors that can be used from
+ *   the client. They do very little else than instantiate a given
+ *   <something>Highlighter and use it to highlight elements.
+ * - <something>Highlighter classes aren't actors, they're just JS classes that
+ *   know how to create and attach the actual highlighter elements on top of the
+ *   content
+ *
+ * The most used highlighter actor is the HighlighterActor which can be
+ * conveniently retrieved via the InspectorActor's 'getHighlighter' method.
+ * The InspectorActor will always return the same instance of
+ * HighlighterActor if asked several times and this instance is used in the
+ * toolbox to highlighter elements's box-model from the markup-view, layout-view,
+ * console, debugger, ... as well as select elements with the pointer (pick).
+ *
+ * Other types of highlighter actors exist and can be accessed via the
+ * InspectorActor's 'getHighlighterByType' method.
  */
 
 /**
  * The HighlighterActor class
  */
-let HighlighterActor = protocol.ActorClass({
+let HighlighterActor = exports.HighlighterActor = protocol.ActorClass({
   typeName: "highlighter",
 
   initialize: function(inspector, autohide) {
     protocol.Actor.prototype.initialize.call(this, null);
 
     this._autohide = autohide;
     this._inspector = inspector;
     this._walker = this._inspector.walker;
     this._tabActor = this._inspector.tabActor;
 
     this._highlighterReady = this._highlighterReady.bind(this);
     this._highlighterHidden = this._highlighterHidden.bind(this);
 
-    if (this._supportsBoxModelHighlighter()) {
+    if (supportXULBasedHighlighter(this._tabActor)) {
       this._boxModelHighlighter =
         new BoxModelHighlighter(this._tabActor, this._inspector);
 
         this._boxModelHighlighter.on("ready", this._highlighterReady);
         this._boxModelHighlighter.on("hide", this._highlighterHidden);
     } else {
       this._boxModelHighlighter = new SimpleOutlineHighlighter(this._tabActor);
     }
   },
 
   get conn() this._inspector && this._inspector.conn,
 
-  /**
-   * Can the host support the box model highlighter which requires a parent
-   * XUL node to attach itself.
-   */
-  _supportsBoxModelHighlighter: function() {
-    // Note that <browser>s on Fennec also have a XUL parentNode but the box
-    // model highlighter doesn't display correctly on Fennec (bug 993190)
-    return this._tabActor.browser &&
-           !!this._tabActor.browser.parentNode &&
-           Services.appinfo.ID !== "{aa3c5121-dab2-40e2-81ca-7ea25febc110}";
-  },
-
   destroy: function() {
     protocol.Actor.prototype.destroy.call(this);
     if (this._boxModelHighlighter) {
       this._boxModelHighlighter.off("ready", this._highlighterReady);
       this._boxModelHighlighter.off("hide", this._highlighterHidden);
       this._boxModelHighlighter.destroy();
       this._boxModelHighlighter = null;
     }
@@ -98,47 +107,28 @@ let HighlighterActor = protocol.ActorCla
    * method several times won't display several highlighters, it will just move
    * the highlighter instance to these nodes.
    *
    * @param NodeActor The node to be highlighted
    * @param Options See the request part for existing options. Note that not
    * all options may be supported by all types of highlighters.
    */
   showBoxModel: method(function(node, options={}) {
-    if (node && this._isNodeValidForHighlighting(node.rawNode)) {
+    if (node && isNodeValidForHighlighting(node.rawNode)) {
       this._boxModelHighlighter.show(node.rawNode, options);
     } else {
       this._boxModelHighlighter.hide();
     }
   }, {
     request: {
       node: Arg(0, "domnode"),
       region: Option(1)
     }
   }),
 
-  _isNodeValidForHighlighting: function(node) {
-    // Is it null or dead?
-    let isNotDead = node && !Cu.isDeadWrapper(node);
-
-    // Is it connected to the document?
-    let isConnected = false;
-    try {
-      let doc = node.ownerDocument;
-      isConnected = (doc && doc.defaultView && doc.documentElement.contains(node));
-    } catch (e) {
-      // "can't access dead object" error
-    }
-
-    // Is it an element node
-    let isElementNode = node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE;
-
-    return isNotDead && isConnected && isElementNode;
-  },
-
   /**
    * Hide the box model highlighting if it was shown before
    */
   hideBoxModel: method(function() {
     this._boxModelHighlighter.hide();
   }, {
     request: {}
   }),
@@ -253,22 +243,87 @@ let HighlighterActor = protocol.ActorCla
       this._boxModelHighlighter.hide();
       this._stopPickerListeners();
       this._isPicking = false;
       this._hoveredNode = null;
     }
   })
 });
 
-exports.HighlighterActor = HighlighterActor;
+let HighlighterFront = protocol.FrontClass(HighlighterActor, {});
 
 /**
- * The HighlighterFront class
+ * A generic highlighter actor class that instantiate a highlighter given its
+ * type name and allows to show/hide it.
  */
-let HighlighterFront = protocol.FrontClass(HighlighterActor, {});
+let CustomHighlighterActor = exports.CustomHighlighterActor = protocol.ActorClass({
+  typeName: "customhighlighter",
+
+  /**
+   * Create a highlighter instance given its typename
+   * The typename must be one of HIGHLIGHTER_CLASSES and the class must
+   * implement constructor(tab, inspector), show(node), hide(), destroy()
+   */
+  initialize: function(inspector, typeName) {
+    protocol.Actor.prototype.initialize.call(this, null);
+
+    let constructor = HIGHLIGHTER_CLASSES[typeName];
+    if (!constructor) {
+      throw new Error(typeName + " isn't a valid highlighter class");
+      return;
+    }
+
+    // The assumption is that all custom highlighters need a XUL parent in the
+    // browser to append their elements
+    if (supportXULBasedHighlighter(inspector.tabActor)) {
+      this._highlighter = new constructor(inspector.tabActor, inspector);
+    }
+  },
+
+  get conn() this._inspector && this._inspector.conn,
+
+  destroy: function() {
+    protocol.Actor.prototype.destroy.call(this);
+    if (this._highlighter) {
+      this._boxModelHighlighter.destroy();
+      this._boxModelHighlighter = null;
+    }
+  },
+
+  /**
+   * Display the highlighter on a given NodeActor.
+   * @param NodeActor The node to be highlighted
+   * @param Options Passed to the highlighter's show function
+   */
+  show: method(function(node, options={}) {
+    if (!node || !isNodeValidForHighlighting(node.rawNode) || !this._highlighter) {
+      return;
+    }
+
+    this._highlighter.show(node.rawNode, options);
+  }, {
+    request: {
+      node: Arg(0, "domnode"),
+      options: Arg(1, "json")
+    }
+  }),
+
+  /**
+   * Hide the highlighter if it was shown before
+   */
+  hide: method(function() {
+    if (this._highlighter) {
+      this._highlighter.hide();
+    }
+  }, {
+    request: {}
+  })
+});
+
+let CustomHighlighterFront = protocol.FrontClass(CustomHighlighterActor, {});
 
 /**
  * The BoxModelHighlighter is the class that actually draws the the box model
  * regions on top of a node.
  * It is used by the HighlighterActor.
  *
  * Usage example:
  *
@@ -877,11 +932,44 @@ SimpleOutlineHighlighter.prototype = {
   hide: function() {
     if (this.currentNode) {
       DOMUtils.removePseudoClassLock(this.currentNode, HIGHLIGHTED_PSEUDO_CLASS);
       this.currentNode = null;
     }
   }
 };
 
+/**
+ * Can the host support the XUL-based highlighters which require a parent
+ * XUL node to get attached.
+ * @param {TabActor}
+ * @return {Boolean}
+ */
+function supportXULBasedHighlighter(tabActor) {
+  // Note that <browser>s on Fennec also have a XUL parentNode but the box
+  // model highlighter doesn't display correctly on Fennec (bug 993190)
+  return tabActor.browser &&
+         !!tabActor.browser.parentNode &&
+         Services.appinfo.ID !== "{aa3c5121-dab2-40e2-81ca-7ea25febc110}";
+}
+
+function isNodeValidForHighlighting(node) {
+  // Is it null or dead?
+  let isNotDead = node && !Cu.isDeadWrapper(node);
+
+  // Is it connected to the document?
+  let isConnected = false;
+  try {
+    let doc = node.ownerDocument;
+    isConnected = (doc && doc.defaultView && doc.documentElement.contains(node));
+  } catch (e) {
+    // "can't access dead object" error
+  }
+
+  // Is it an element node
+  let isElementNode = node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE;
+
+  return isNotDead && isConnected && isElementNode;
+}
+
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
 });
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -56,17 +56,18 @@ const protocol = require("devtools/serve
 const {Arg, Option, method, RetVal, types} = protocol;
 const {LongStringActor, ShortLongString} = require("devtools/server/actors/string");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const object = require("sdk/util/object");
 const events = require("sdk/event/core");
 const {Unknown} = require("sdk/platform/xpcom");
 const {Class} = require("sdk/core/heritage");
 const {PageStyleActor} = require("devtools/server/actors/styles");
-const {HighlighterActor} = require("devtools/server/actors/highlighter");
+const {HighlighterActor,
+  CustomHighlighterActor} = require("devtools/server/actors/highlighter");
 
 const FONT_FAMILY_PREVIEW_TEXT = "The quick brown fox jumps over the lazy dog";
 const FONT_FAMILY_PREVIEW_TEXT_SIZE = 20;
 const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
 const HIDDEN_CLASS = "__fx-devtools-hide-shortcut__";
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const IMAGE_FETCHING_TIMEOUT = 500;
 // The possible completions to a ':' with added score to give certain values
@@ -2524,33 +2525,69 @@ var InspectorActor = protocol.ActorClass
     return this._pageStylePromise;
   }, {
     request: {},
     response: {
       pageStyle: RetVal("pagestyle")
     }
   }),
 
+  /**
+   * The most used highlighter actor is the HighlighterActor which can be
+   * conveniently retrieved by this method.
+   * The same instance will always be returned by this method when called
+   * several times.
+   * The highlighter actor returned here is used to highlighter elements's
+   * box-models from the markup-view, layout-view, console, debugger, ... as
+   * well as select elements with the pointer (pick).
+   *
+   * @param {Boolean} autohide Optionally autohide the highlighter after an
+   * element has been picked
+   * @return {HighlighterActor}
+   */
   getHighlighter: method(function (autohide) {
     if (this._highlighterPromise) {
       return this._highlighterPromise;
     }
 
     this._highlighterPromise = this.getWalker().then(walker => {
       return HighlighterActor(this, autohide);
     });
     return this._highlighterPromise;
   }, {
-    request: { autohide: Arg(0, "boolean") },
+    request: {
+      autohide: Arg(0, "boolean")
+    },
     response: {
       highligter: RetVal("highlighter")
     }
   }),
 
   /**
+   * If consumers need to display several highlighters at the same time or
+   * different types of highlighters, then this method should be used, passing
+   * the type name of the highlighter needed as argument.
+   * A new instance will be created everytime the method is called, so it's up
+   * to the consumer to release it when it is not needed anymore
+   *
+   * @param {String} type The type of highlighter to create
+   * @return {Highlighter}
+   */
+  getHighlighterByType: method(function (typeName) {
+    return CustomHighlighterActor(this, typeName);
+  }, {
+    request: {
+      typeName: Arg(0)
+    },
+    response: {
+      highlighter: RetVal("customhighlighter")
+    }
+  }),
+
+  /**
    * Get the node's image data if any (for canvas and img nodes).
    * Returns an imageData object with the actual data being a LongStringActor
    * and a size json object.
    * The image data is transmitted as a base64 encoded png data-uri.
    * The method rejects if the node isn't an image or if the image is missing
    *
    * Accepts a maxDim request parameter to resize images that are larger. This
    * is important as the resizing occurs server-side so that image-data being
