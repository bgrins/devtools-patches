diff -r 77303df92deb -r b99f8be2a117 browser/devtools/inspector/breadcrumbs.js
--- a/browser/devtools/inspector/breadcrumbs.js	Tue Apr 07 14:27:00 2015 +0200
+++ b/browser/devtools/inspector/breadcrumbs.js	Wed Apr 08 15:08:18 2015 +0200
@@ -1,84 +1,71 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 const {Cc, Cu, Ci} = require("chrome");
-
-const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
-const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
-
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
+const {Promise: promise} = require("resource://gre/modules/Promise.jsm");
+XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
+  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
+});
+
+const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
+const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 const MAX_LABEL_LENGTH = 40;
-
-let promise = require("resource://gre/modules/Promise.jsm").Promise;
-
 const LOW_PRIORITY_ELEMENTS = {
   "HEAD": true,
   "BASE": true,
   "BASEFONT": true,
   "ISINDEX": true,
   "LINK": true,
   "META": true,
   "SCRIPT": true,
   "STYLE": true,
   "TITLE": true,
 };
 
-function resolveNextTick(value) {
-  let deferred = promise.defer();
-  Services.tm.mainThread.dispatch(() => {
-    try {
-      deferred.resolve(value);
-    } catch(ex) {
-      console.error(ex);
-    }
-  }, Ci.nsIThread.DISPATCH_NORMAL);
-  return deferred.promise;
-}
-
-///////////////////////////////////////////////////////////////////////////
-//// HTML Breadcrumbs
-
 /**
  * Display the ancestors of the current node and its children.
  * Only one "branch" of children are displayed (only one line).
  *
  * FIXME: Bug 822388 - Use the BreadcrumbsWidget in the Inspector.
  *
  * Mechanism:
- * . If no nodes displayed yet:
- *    then display the ancestor of the selected node and the selected node;
+ * - If no nodes displayed yet:
+ *   then display the ancestor of the selected node and the selected node;
  *   else select the node;
- * . If the selected node is the last node displayed, append its first (if any).
+ * - If the selected node is the last node displayed, append its first (if any).
+ *
+ * @param {InspectorPanel} inspector The inspector hosting this widget.
  */
-function HTMLBreadcrumbs(aInspector)
-{
-  this.inspector = aInspector;
+function HTMLBreadcrumbs(inspector) {
+  this.inspector = inspector;
   this.selection = this.inspector.selection;
   this.chromeWin = this.inspector.panelWin;
   this.chromeDoc = this.inspector.panelDoc;
   this.DOMHelpers = new DOMHelpers(this.chromeWin);
   this._init();
 }
 
 exports.HTMLBreadcrumbs = HTMLBreadcrumbs;
 
 HTMLBreadcrumbs.prototype = {
   get walker() this.inspector.walker,
 
-  _init: function BC__init()
-  {
+  _init: function() {
     this.container = this.chromeDoc.getElementById("inspector-breadcrumbs");
 
     // These separators are used for CSS purposes only, and are positioned
     // off screen, but displayed with -moz-element.
     this.separators = this.chromeDoc.createElement("box");
     this.separators.className = "breadcrumb-separator-container";
     this.separators.innerHTML =
                       "<box id='breadcrumb-separator-before'></box>" +
@@ -134,98 +121,94 @@ HTMLBreadcrumbs.prototype = {
         return promise.reject("selection-changed");
       }
       return result;
     }
   },
 
   /**
    * Warn if rejection was caused by selection change, print an error otherwise.
+   * @param {Error} err
    */
   selectionGuardEnd: function(err) {
     if (err === "selection-changed") {
       console.warn("Asynchronous operation was aborted as selection changed.");
     } else {
       console.error(err);
     }
   },
 
   /**
    * Build a string that represents the node: tagName#id.class1.class2.
-   *
-   * @param aNode The node to pretty-print
-   * @returns a string
+   * @param {NodeFront} node The node to pretty-print
+   * @return {String}
    */
-  prettyPrintNodeAsText: function BC_prettyPrintNodeText(aNode)
-  {
-    let text = aNode.tagName.toLowerCase();
-    if (aNode.isPseudoElement) {
-      text = aNode.isBeforePseudoElement ? "::before" : "::after";
+  prettyPrintNodeAsText: function(node) {
+    let text = node.tagName.toLowerCase();
+    if (node.isPseudoElement) {
+      text = node.isBeforePseudoElement ? "::before" : "::after";
     }
 
-    if (aNode.id) {
-      text += "#" + aNode.id;
+    if (node.id) {
+      text += "#" + node.id;
     }
 
-    if (aNode.className) {
-      let classList = aNode.className.split(/\s+/);
+    if (node.className) {
+      let classList = node.className.split(/\s+/);
       for (let i = 0; i < classList.length; i++) {
         text += "." + classList[i];
       }
     }
 
-    for (let pseudo of aNode.pseudoClassLocks) {
+    for (let pseudo of node.pseudoClassLocks) {
       text += pseudo;
     }
 
     return text;
   },
 
-
   /**
    * Build <label>s that represent the node:
    *   <label class="breadcrumbs-widget-item-tag">tagName</label>
    *   <label class="breadcrumbs-widget-item-id">#id</label>
    *   <label class="breadcrumbs-widget-item-classes">.class1.class2</label>
-   *
-   * @param aNode The node to pretty-print
-   * @returns a document fragment.
+   * @param {NodeFront} node The node to pretty-print
+   * @returns {DocumentFragment}
    */
-  prettyPrintNodeAsXUL: function BC_prettyPrintNodeXUL(aNode)
-  {
+  prettyPrintNodeAsXUL: function(node) {
     let fragment = this.chromeDoc.createDocumentFragment();
 
     let tagLabel = this.chromeDoc.createElement("label");
     tagLabel.className = "breadcrumbs-widget-item-tag plain";
 
     let idLabel = this.chromeDoc.createElement("label");
     idLabel.className = "breadcrumbs-widget-item-id plain";
 
     let classesLabel = this.chromeDoc.createElement("label");
     classesLabel.className = "breadcrumbs-widget-item-classes plain";
 
     let pseudosLabel = this.chromeDoc.createElement("label");
     pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";
 
-    let tagText = aNode.tagName.toLowerCase();
-    if (aNode.isPseudoElement) {
-      tagText = aNode.isBeforePseudoElement ? "::before" : "::after";
+    let tagText = node.tagName.toLowerCase();
+    if (node.isPseudoElement) {
+      tagText = node.isBeforePseudoElement ? "::before" : "::after";
     }
-    let idText = aNode.id ? ("#" + aNode.id) : "";
+    let idText = node.id ? ("#" + node.id) : "";
     let classesText = "";
 
-    if (aNode.className) {
-      let classList = aNode.className.split(/\s+/);
+    if (node.className) {
+      let classList = node.className.split(/\s+/);
       for (let i = 0; i < classList.length; i++) {
         classesText += "." + classList[i];
       }
     }
 
     // XXX: Until we have pseudoclass lock in the node.
-    for (let pseudo of aNode.pseudoClassLocks) {
+    for (let pseudo of node.pseudoClassLocks) {
 
     }
 
     // Figure out which element (if any) needs ellipsing.
     // Substring for that element, then clear out any extras
     // (except for pseudo elements).
     let maxTagLength = MAX_LABEL_LENGTH;
     let maxIdLength = MAX_LABEL_LENGTH - tagText.length;
@@ -239,340 +222,345 @@ HTMLBreadcrumbs.prototype = {
        classesText = "";
     } else if (classesText.length > maxClassLength) {
       classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
     }
 
     tagLabel.textContent = tagText;
     idLabel.textContent = idText;
     classesLabel.textContent = classesText;
-    pseudosLabel.textContent = aNode.pseudoClassLocks.join("");
+    pseudosLabel.textContent = node.pseudoClassLocks.join("");
 
     fragment.appendChild(tagLabel);
     fragment.appendChild(idLabel);
     fragment.appendChild(classesLabel);
     fragment.appendChild(pseudosLabel);
 
     return fragment;
   },
 
   /**
    * Open the sibling menu.
-   *
-   * @param aButton the button representing the node.
-   * @param aNode the node we want the siblings from.
+   * @param {DOMNode} button the button representing the node.
+   * @param {NodeFront} node the node we want the siblings from.
    */
-  openSiblingMenu: function BC_openSiblingMenu(aButton, aNode)
-  {
+  openSiblingMenu: function(button, node) {
     // We make sure that the targeted node is selected
     // because we want to use the nodemenu that only works
     // for inspector.selection
-    this.selection.setNodeFront(aNode, "breadcrumbs");
+    this.selection.setNodeFront(node, "breadcrumbs");
 
     let title = this.chromeDoc.createElement("menuitem");
     title.setAttribute("label", this.inspector.strings.GetStringFromName("breadcrumbs.siblings"));
     title.setAttribute("disabled", "true");
 
     let separator = this.chromeDoc.createElement("menuseparator");
 
     let items = [title, separator];
 
-    this.walker.siblings(aNode, {
+    this.walker.siblings(node, {
       whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
     }).then(siblings => {
       let nodes = siblings.nodes;
       for (let i = 0; i < nodes.length; i++) {
         let item = this.chromeDoc.createElement("menuitem");
-        if (nodes[i] === aNode) {
+        if (nodes[i] === node) {
           item.setAttribute("disabled", "true");
           item.setAttribute("checked", "true");
         }
 
         item.setAttribute("type", "radio");
         item.setAttribute("label", this.prettyPrintNodeAsText(nodes[i]));
 
         let selection = this.selection;
-        item.onmouseup = (function(aNode) {
+        item.onmouseup = (function(node) {
           return function() {
-            selection.setNodeFront(aNode, "breadcrumbs");
+            selection.setNodeFront(node, "breadcrumbs");
           }
         })(nodes[i]);
 
         items.push(item);
-        this.inspector.showNodeMenu(aButton, "before_start", items);
+        this.inspector.showNodeMenu(button, "before_start", items);
       }
     });
   },
 
   /**
    * Generic event handler.
-   *
-   * @param nsIDOMEvent event
-   *        The DOM event object.
+   * @param {DOMEvent} event.
    */
-  handleEvent: function BC_handleEvent(event)
-  {
+  handleEvent: function(event) {
     if (event.type == "mousedown" && event.button == 0) {
-      // on Click and Hold, open the Siblings menu
-
-      let timer;
-      let container = this.container;
-
-      function openMenu(event) {
-        cancelHold();
-        let target = event.originalTarget;
-        if (target.tagName == "button") {
-          target.onBreadcrumbsHold();
-        }
-      }
-
-      function handleClick(event) {
-        cancelHold();
-        let target = event.originalTarget;
-        if (target.tagName == "button") {
-          target.onBreadcrumbsClick();
-        }
-      }
-
-      let window = this.chromeWin;
-      function cancelHold(event) {
-        window.clearTimeout(timer);
-        container.removeEventListener("mouseout", cancelHold, false);
-        container.removeEventListener("mouseup", handleClick, false);
-      }
-
-      container.addEventListener("mouseout", cancelHold, false);
-      container.addEventListener("mouseup", handleClick, false);
-      timer = window.setTimeout(openMenu, 500, event);
-    }
-
-    if (event.type == "keypress" && this.selection.isElementNode()) {
-      let node = null;
-
-
-      this._keyPromise = this._keyPromise || promise.resolve(null);
-
-      this._keyPromise = (this._keyPromise || promise.resolve(null)).then(() => {
-        switch (event.keyCode) {
-          case this.chromeWin.KeyEvent.DOM_VK_LEFT:
-            if (this.currentIndex != 0) {
-              node = promise.resolve(this.nodeHierarchy[this.currentIndex - 1].node);
-            }
-            break;
-          case this.chromeWin.KeyEvent.DOM_VK_RIGHT:
-            if (this.currentIndex < this.nodeHierarchy.length - 1) {
-              node = promise.resolve(this.nodeHierarchy[this.currentIndex + 1].node);
-            }
-            break;
-          case this.chromeWin.KeyEvent.DOM_VK_UP:
-            node = this.walker.previousSibling(this.selection.nodeFront, {
-              whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-            });
-            break;
-          case this.chromeWin.KeyEvent.DOM_VK_DOWN:
-            node = this.walker.nextSibling(this.selection.nodeFront, {
-              whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-            });
-            break;
-        }
-
-        return node.then((node) => {
-          if (node) {
-            this.selection.setNodeFront(node, "breadcrumbs");
-          }
-        });
-      });
-      event.preventDefault();
-      event.stopPropagation();
-    }
-
-    if (event.type == "mouseover") {
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsHover();
-      }
-    }
-
-    if (event.type == "mouseleave") {
-      this.inspector.toolbox.highlighterUtils.unhighlight();
+      this.handleMouseDown(event);
+    } else if (event.type == "keypress" && this.selection.isElementNode()) {
+      this.handleKeyPress(event);
+    } else if (event.type == "mouseover") {
+      this.handleMouseOver(event);
+    } else if (event.type == "mouseleave") {
+      this.handleMouseLeave(event);
     }
   },
 
   /**
-   * Remove nodes and delete properties.
+   * On click and hold, open the siblings menu.
+   * @param {DOMEvent} event.
    */
-  destroy: function BC_destroy()
-  {
+  handleMouseDown: function(event) {
+    let timer;
+    let container = this.container;
+
+    function openMenu(event) {
+      cancelHold();
+      let target = event.originalTarget;
+      if (target.tagName == "button") {
+        target.onBreadcrumbsHold();
+      }
+    }
+
+    function handleClick(event) {
+      cancelHold();
+      let target = event.originalTarget;
+      if (target.tagName == "button") {
+        target.onBreadcrumbsClick();
+      }
+    }
+
+    let window = this.chromeWin;
+    function cancelHold(event) {
+      window.clearTimeout(timer);
+      container.removeEventListener("mouseout", cancelHold, false);
+      container.removeEventListener("mouseup", handleClick, false);
+    }
+
+    container.addEventListener("mouseout", cancelHold, false);
+    container.addEventListener("mouseup", handleClick, false);
+    timer = window.setTimeout(openMenu, 500, event);
+  },
+
+  /**
+   * On mouse over, highlight the corresponding content DOM Node.
+   * @param {DOMEvent} event.
+   */
+  handleMouseOver: function(event) {
+    let target = event.originalTarget;
+    if (target.tagName == "button") {
+      target.onBreadcrumbsHover();
+    }
+  },
+
+  /**
+   * On mouse leave, make sure to unhighlight.
+   * @param {DOMEvent} event.
+   */
+  handleMouseLeave: function(event) {
+    this.inspector.toolbox.highlighterUtils.unhighlight();
+  },
+
+  /**
+   * On key press, navigate the node hierarchy.
+   * @param {DOMEvent} event.
+   */
+  handleKeyPress: function(event) {
+    let node = null;
+    this._keyPromise = this._keyPromise || promise.resolve(null);
+
+    this._keyPromise = (this._keyPromise || promise.resolve(null)).then(() => {
+      switch (event.keyCode) {
+        case this.chromeWin.KeyEvent.DOM_VK_LEFT:
+          if (this.currentIndex != 0) {
+            node = promise.resolve(this.nodeHierarchy[this.currentIndex - 1].node);
+          }
+          break;
+        case this.chromeWin.KeyEvent.DOM_VK_RIGHT:
+          if (this.currentIndex < this.nodeHierarchy.length - 1) {
+            node = promise.resolve(this.nodeHierarchy[this.currentIndex + 1].node);
+          }
+          break;
+        case this.chromeWin.KeyEvent.DOM_VK_UP:
+          node = this.walker.previousSibling(this.selection.nodeFront, {
+            whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
+          });
+          break;
+        case this.chromeWin.KeyEvent.DOM_VK_DOWN:
+          node = this.walker.nextSibling(this.selection.nodeFront, {
+            whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
+          });
+          break;
+      }
+
+      return node.then((node) => {
+        if (node) {
+          this.selection.setNodeFront(node, "breadcrumbs");
+        }
+      });
+    });
+    event.preventDefault();
+    event.stopPropagation();
+  },
+
+  /**
+   * Remove nodes and clean up.
+   */
+  destroy: function() {
     this.selection.off("new-node-front", this.update);
     this.selection.off("pseudoclass", this.updateSelectors);
     this.selection.off("attribute-changed", this.updateSelectors);
     this.inspector.off("markupmutation", this.update);
 
     this.container.removeEventListener("underflow", this.onscrollboxreflow, false);
     this.container.removeEventListener("overflow", this.onscrollboxreflow, false);
-    this.onscrollboxreflow = null;
-
-    this.empty();
     this.container.removeEventListener("mousedown", this, true);
     this.container.removeEventListener("keypress", this, true);
     this.container.removeEventListener("mouseover", this, true);
     this.container.removeEventListener("mouseleave", this, true);
+
+    this.empty();
+    this.separators.remove();
+
+    this.onscrollboxreflow = null;
     this.container = null;
-
-    this.separators.remove();
     this.separators = null;
-
     this.nodeHierarchy = null;
 
     this.isDestroyed = true;
   },
 
   /**
    * Empty the breadcrumbs container.
    */
-  empty: function BC_empty()
-  {
+  empty: function() {
     while (this.container.hasChildNodes()) {
-      this.container.removeChild(this.container.firstChild);
+      this.container.firstChild.remove();
     }
   },
 
   /**
    * Set which button represent the selected node.
-   *
-   * @param aIdx Index of the displayed-button to select
+   * @param {Number} index Index of the displayed-button to select.
    */
-  setCursor: function BC_setCursor(aIdx)
-  {
+  setCursor: function(index) {
     // Unselect the previously selected button
     if (this.currentIndex > -1 && this.currentIndex < this.nodeHierarchy.length) {
       this.nodeHierarchy[this.currentIndex].button.removeAttribute("checked");
     }
-    if (aIdx > -1) {
-      this.nodeHierarchy[aIdx].button.setAttribute("checked", "true");
+    if (index > -1) {
+      this.nodeHierarchy[index].button.setAttribute("checked", "true");
       if (this.hadFocus)
-        this.nodeHierarchy[aIdx].button.focus();
+        this.nodeHierarchy[index].button.focus();
     }
-    this.currentIndex = aIdx;
+    this.currentIndex = index;
   },
 
   /**
    * Get the index of the node in the cache.
-   *
-   * @param aNode
-   * @returns integer the index, -1 if not found
+   * @param {NodeFront} node.
+   * @returns {Number} The index for this node or -1 if not found.
    */
-  indexOf: function BC_indexOf(aNode)
-  {
+  indexOf: function(node) {
     let i = this.nodeHierarchy.length - 1;
     for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
-      if (this.nodeHierarchy[i].node === aNode) {
+      if (this.nodeHierarchy[i].node === node) {
         return i;
       }
     }
     return -1;
   },
 
   /**
-   * Remove all the buttons and their references in the cache
-   * after a given index.
-   *
-   * @param aIdx
+   * Remove all the buttons and their references in the cache after a given
+   * index.
+   * @param {Number} index.
    */
-  cutAfter: function BC_cutAfter(aIdx)
-  {
-    while (this.nodeHierarchy.length > (aIdx + 1)) {
+  cutAfter: function(index) {
+    while (this.nodeHierarchy.length > (index + 1)) {
       let toRemove = this.nodeHierarchy.pop();
       this.container.removeChild(toRemove.button);
     }
   },
 
   /**
    * Build a button representing the node.
-   *
-   * @param aNode The node from the page.
-   * @returns aNode The <button>.
+   * @param {NodeFront} node The node from the page.
+   * @return {DOMNode} The <button> for this node.
    */
-  buildButton: function BC_buildButton(aNode)
-  {
+  buildButton: function(node) {
     let button = this.chromeDoc.createElement("button");
-    button.appendChild(this.prettyPrintNodeAsXUL(aNode));
+    button.appendChild(this.prettyPrintNodeAsXUL(node));
     button.className = "breadcrumbs-widget-item";
 
-    button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(aNode));
+    button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(node));
 
     button.onkeypress = function onBreadcrumbsKeypress(e) {
       if (e.charCode == Ci.nsIDOMKeyEvent.DOM_VK_SPACE ||
           e.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN)
         button.click();
     }
 
     button.onBreadcrumbsClick = () => {
-      this.selection.setNodeFront(aNode, "breadcrumbs");
+      this.selection.setNodeFront(node, "breadcrumbs");
     };
 
     button.onBreadcrumbsHover = () => {
-      this.inspector.toolbox.highlighterUtils.highlightNodeFront(aNode);
+      this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
     };
 
     button.onclick = (function _onBreadcrumbsRightClick(event) {
       button.focus();
       if (event.button == 2) {
-        this.openSiblingMenu(button, aNode);
+        this.openSiblingMenu(button, node);
       }
     }).bind(this);
 
     button.onBreadcrumbsHold = (function _onBreadcrumbsHold() {
-      this.openSiblingMenu(button, aNode);
+      this.openSiblingMenu(button, node);
     }).bind(this);
     return button;
   },
 
   /**
    * Connecting the end of the breadcrumbs to a node.
-   *
-   * @param aNode The node to reach.
+   * @param {NodeFront} node The node to reach.
    */
-  expand: function BC_expand(aNode)
-  {
-      let fragment = this.chromeDoc.createDocumentFragment();
-      let toAppend = aNode;
-      let lastButtonInserted = null;
-      let originalLength = this.nodeHierarchy.length;
-      let stopNode = null;
-      if (originalLength > 0) {
-        stopNode = this.nodeHierarchy[originalLength - 1].node;
+  expand: function(node) {
+    let fragment = this.chromeDoc.createDocumentFragment();
+    let lastButtonInserted = null;
+    let originalLength = this.nodeHierarchy.length;
+    let stopNode = null;
+    if (originalLength > 0) {
+      stopNode = this.nodeHierarchy[originalLength - 1].node;
+    }
+    while (node && node != stopNode) {
+      if (node.tagName) {
+        let button = this.buildButton(node);
+        fragment.insertBefore(button, lastButtonInserted);
+        lastButtonInserted = button;
+        this.nodeHierarchy.splice(originalLength, 0, {
+          node,
+          button,
+          currentOutput: this.prettyPrintNodeAsText(node)
+        });
       }
-      while (toAppend && toAppend != stopNode) {
-        if (toAppend.tagName) {
-          let button = this.buildButton(toAppend);
-          fragment.insertBefore(button, lastButtonInserted);
-          lastButtonInserted = button;
-          this.nodeHierarchy.splice(originalLength, 0, {node: toAppend, button: button});
-        }
-        toAppend = toAppend.parentNode();
-      }
-      this.container.appendChild(fragment, this.container.firstChild);
+      node = node.parentNode();
+    }
+    this.container.appendChild(fragment, this.container.firstChild);
   },
 
   /**
-   * Get a child of a node that can be displayed in the breadcrumbs
-   * and that is probably visible. See LOW_PRIORITY_ELEMENTS.
-   *
-   * @param aNode The parent node.
-   * @returns nsIDOMNode|null
+   * Get a child of a node that can be displayed in the breadcrumbs and that is
+   * probably visible. See LOW_PRIORITY_ELEMENTS.
+   * @param {NodeFront} node The parent node.
+   * @return {Promise} Resolves to the NodeFront.
    */
-  getInterestingFirstNode: function BC_getInterestingFirstNode(aNode)
-  {
+  getInterestingFirstNode: function(node) {
     let deferred = promise.defer();
 
-    var fallback = null;
+    let fallback = null;
 
-    var moreChildren = () => {
-      this.walker.children(aNode, {
+    let moreChildren = () => {
+      this.walker.children(node, {
         start: fallback,
         maxNodes: 10,
         whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
       }).then(this.selectionGuard()).then(response => {
         for (let node of response.nodes) {
           if (!(node.tagName in LOW_PRIORITY_ELEMENTS)) {
             deferred.resolve(node);
             return;
@@ -583,47 +571,45 @@ HTMLBreadcrumbs.prototype = {
         }
         if (response.hasLast) {
           deferred.resolve(fallback);
           return;
         } else {
           moreChildren();
         }
       }).then(null, this.selectionGuardEnd);
-    }
+    };
+
     moreChildren();
     return deferred.promise;
   },
 
   /**
    * Find the "youngest" ancestor of a node which is already in the breadcrumbs.
-   *
-   * @param aNode
-   * @returns Index of the ancestor in the cache
+   * @param {NodeFront} node.
+   * @return {Number} Index of the ancestor in the cache, or -1 if not found.
    */
-  getCommonAncestor: function BC_getCommonAncestor(aNode)
-  {
-    let node = aNode;
+  getCommonAncestor: function(node) {
     while (node) {
       let idx = this.indexOf(node);
       if (idx > -1) {
         return idx;
       } else {
         node = node.parentNode();
       }
     }
     return -1;
   },
 
   /**
    * Make sure that the latest node in the breadcrumbs is not the selected node
    * if the selected node still has children.
+   * @return {Promise}
    */
-  ensureFirstChild: function BC_ensureFirstChild()
-  {
+  ensureFirstChild: function() {
     // If the last displayed node is the selected node
     if (this.currentIndex == this.nodeHierarchy.length - 1) {
       let node = this.nodeHierarchy[this.currentIndex].node;
       return this.getInterestingFirstNode(node).then(child => {
         // If the node has a child and we've not been destroyed in the meantime
         if (child && !this.isDestroyed) {
           // Show this child
           this.expand(child);
@@ -632,62 +618,95 @@ HTMLBreadcrumbs.prototype = {
     }
 
     return resolveNextTick(true);
   },
 
   /**
    * Ensure the selected node is visible.
    */
-  scroll: function BC_scroll()
-  {
+  scroll: function() {
     // FIXME bug 684352: make sure its immediate neighbors are visible too.
 
     let scrollbox = this.container;
     let element = this.nodeHierarchy[this.currentIndex].button;
 
     // Repeated calls to ensureElementIsVisible would interfere with each other
     // and may sometimes result in incorrect scroll positions.
     this.chromeWin.clearTimeout(this._ensureVisibleTimeout);
     this._ensureVisibleTimeout = this.chromeWin.setTimeout(function() {
       scrollbox.ensureElementIsVisible(element);
     }, ENSURE_SELECTION_VISIBLE_DELAY);
   },
 
-  updateSelectors: function BC_updateSelectors()
-  {
+  /**
+   * Update all button outputs.
+   */
+  updateSelectors: function() {
     if (this.isDestroyed) {
       return;
     }
 
     for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
-      let crumb = this.nodeHierarchy[i];
-      let button = crumb.button;
+      let {node, button, currentOutput} = this.nodeHierarchy[i];
 
-      while(button.hasChildNodes()) {
-        button.removeChild(button.firstChild);
+      // If the output of the node doesn't change, skip the update.
+      let textOutput = this.prettyPrintNodeAsText(node);
+      if (currentOutput === textOutput) {
+        continue;
       }
-      button.appendChild(this.prettyPrintNodeAsXUL(crumb.node));
-      button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(crumb.node));
+
+      // Otherwise, update the whole markup for the button.
+      while (button.hasChildNodes()) {
+        button.firstChild.remove();
+      }
+      button.appendChild(this.prettyPrintNodeAsXUL(node));
+      button.setAttribute("tooltiptext", textOutput);
+
+      this.nodeHierarchy[i].currentOutput = textOutput;
     }
   },
 
   /**
    * Update the breadcrumbs display when a new node is selected.
+   * @param {String} reason The reason for the update, if any.
+   * @param {Array} mutations An array of mutations in case this was called as
+   * the "markupmutation" event listener.
    */
-  update: function BC_update(reason)
-  {
+  update: function(reason, mutations) {
     if (this.isDestroyed) {
       return;
     }
 
     if (reason !== "markupmutation") {
       this.inspector.hideNodeMenu();
     }
 
+    let hasInterestingMutations = (() => {
+      if (reason === "markupmutation" && mutations.length) {
+        for (let {type, added, removed, target, attributeName} of mutations) {
+          if (type === "childList" && (added.length || removed.length)) {
+            // Only interested in childList mutations if the added or removed
+            // nodes are currently displayed.
+            return added.some(node => this.indexOf(node) > -1) ||
+                   removed.some(node => this.indexOf(node) > -1);
+          } else if (type === "attributes" && this.indexOf(target) > -1) {
+            // Only interested in attributes mutations if the target is
+            // currently displayed, and the attribute is either id or class.
+            return attributeName === "class" || attributeName === "id";
+          }
+        }
+      }
+      return false;
+    })();
+
+    if (reason === "markupmutation" && !hasInterestingMutations) {
+      return;
+    }
+
     let cmdDispatcher = this.chromeDoc.commandDispatcher;
     this.hadFocus = (cmdDispatcher.focusedElement &&
                      cmdDispatcher.focusedElement.parentNode == this.container);
 
     if (!this.selection.isConnected()) {
       this.cutAfter(-1); // remove all the crumbs
       return;
     }
@@ -696,17 +715,17 @@ HTMLBreadcrumbs.prototype = {
       this.setCursor(-1); // no selection
       return;
     }
 
     let idx = this.indexOf(this.selection.nodeFront);
 
     // Is the node already displayed in the breadcrumbs?
     // (and there are no mutations that need re-display of the crumbs)
-    if (idx > -1 && reason !== "markupmutation") {
+    if (idx > -1 && !hasInterestingMutations) {
       // Yes. We select it.
       this.setCursor(idx);
     } else {
       // No. Is the breadcrumbs display empty?
       if (this.nodeHierarchy.length > 0) {
         // No. We drop all the element that are not direct ancestors
         // of the selection
         let parent = this.selection.nodeFront.parentNode();
@@ -739,11 +758,22 @@ HTMLBreadcrumbs.prototype = {
       });
     }).then(null, err => {
       doneUpdating(this.selection.nodeFront);
       this.selectionGuardEnd(err);
     });
   }
 };
 
-XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
-  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
-});
+/**
+ * Returns a promise that resolves at the next main thread tick.
+ */
+function resolveNextTick(value) {
+  let deferred = promise.defer();
+  Services.tm.mainThread.dispatch(() => {
+    try {
+      deferred.resolve(value);
+    } catch(e) {
+      deferred.reject(e);
+    }
+  }, Ci.nsIThread.DISPATCH_NORMAL);
+  return deferred.promise;
+}
diff -r 77303df92deb -r b99f8be2a117 browser/devtools/inspector/test/browser_inspector_highlighter-hover_01.js
--- a/browser/devtools/inspector/test/browser_inspector_highlighter-hover_01.js	Tue Apr 07 14:27:00 2015 +0200
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-hover_01.js	Wed Apr 08 15:08:18 2015 +0200
@@ -21,21 +21,19 @@ add_task(function*() {
 
   info("selecting the <p> line by clicking in the markup-view");
   yield clickContainer("p", inspector);
 
   p.textContent = "wait for it ....";
   info("wait and see if the highlighter stays visible even after the node was selected");
   yield waitForTheBrieflyShowBoxModelTimeout();
 
-  let updated = inspector.once("inspector-updated");
   p.textContent = "dary!!!!";
   isVisible = yield isHighlighting(toolbox);
   ok(isVisible, "the highlighter is still visible");
-  yield updated;
 });
 
 function waitForTheBrieflyShowBoxModelTimeout() {
   let deferred = promise.defer();
   // Note that the current timeout is 1 sec and is neither configurable nor
   // exported anywhere we can access, so hard-coding the timeout
   content.setTimeout(deferred.resolve, 1500);
   return deferred.promise;
