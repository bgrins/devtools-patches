# HG changeset patch
# Parent  6bbc3b58e018010c1c3064535a219e1e488cb9a7

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -687,16 +687,19 @@ InspectorPanel.prototype = {
       copyInnerHTML.setAttribute("disabled", "true");
       copyOuterHTML.setAttribute("disabled", "true");
       scrollIntoView.setAttribute("disabled", "true");
     }
     if (!this.canGetUniqueSelector) {
       unique.hidden = true;
     }
 
+    // Enable/Disable the link open/copy items.
+    this._setupNodeLinkMenu();
+
     // Enable the "edit HTML" item if the selection is an element and the root
     // actor has the appropriate trait (isOuterHTMLEditable)
     let editHTML = this.panelDoc.getElementById("node-menu-edithtml");
     if (isEditableElement && this.isOuterHTMLEditable) {
       editHTML.removeAttribute("disabled");
     } else {
       editHTML.setAttribute("disabled", "true");
     }
@@ -745,16 +748,66 @@ InspectorPanel.prototype = {
   _resetNodeMenu: function InspectorPanel_resetNodeMenu() {
     // Remove any extra items
     while (this.lastNodemenuItem.nextSibling) {
       let toDelete = this.lastNodemenuItem.nextSibling;
       toDelete.parentNode.removeChild(toDelete);
     }
   },
 
+  /**
+   * Link menu items can be shown or hidden depending on the context and
+   * selected node, and their labels can vary.
+   */
+  _setupNodeLinkMenu: function InspectorPanel_setupNodeLinkMenu() {
+    let linkSeparator = this.panelDoc.getElementById("node-menu-link-separator");
+    let linkFollow = this.panelDoc.getElementById("node-menu-link-follow");
+    let linkCopy = this.panelDoc.getElementById("node-menu-link-copy");
+
+    // Hide all by default.
+    linkSeparator.setAttribute("hidden", "true");
+    linkFollow.setAttribute("hidden", "true");
+    linkCopy.setAttribute("hidden", "true");
+
+    // Get information about the right-clicked node.
+    let popupNode = this.panelDoc.popupNode;
+    if (!popupNode || !popupNode.classList.contains("link")) {
+      return;
+    }
+
+    let type = popupNode.dataset.type;
+    // Bug 1158822 will make "resource" type URLs open in devtools, but for now
+    // they're considered like "uri".
+    if (type === "uri" || type === "resource") {
+      // First make sure the target can resolve relative URLs.
+      this.target.actorHasMethod("inspector", "resolveRelativeURL").then(canResolve => {
+        if (!canResolve) {
+          return;
+        }
+
+        linkSeparator.removeAttribute("hidden");
+
+        // Links can't be opened in new tabs in the browser toolbox.
+        if (!this.target.chrome) {
+          linkFollow.removeAttribute("hidden");
+          linkFollow.setAttribute("label", this.strings.GetStringFromName(
+            "inspector.menu.openUrlInNewTab.label"));
+        }
+        linkCopy.removeAttribute("hidden");
+        linkCopy.setAttribute("label", this.strings.GetStringFromName(
+          "inspector.menu.copyUrlToClipboard.label"));
+      }, console.error);
+    } else if (type === "idref") {
+      linkSeparator.removeAttribute("hidden");
+      linkFollow.removeAttribute("hidden");
+      linkFollow.setAttribute("label", this.strings.formatStringFromName(
+        "inspector.menu.selectElement.label", [popupNode.dataset.link], 1));
+    }
+  },
+
   _initMarkup: function InspectorPanel_initMarkup() {
     let doc = this.panelDoc;
 
     this._markupBox = doc.getElementById("markup-box");
 
     // create tool iframe
     this._markupFrame = doc.createElement("iframe");
     this._markupFrame.setAttribute("flex", "1");
@@ -1033,16 +1086,54 @@ InspectorPanel.prototype = {
       this.markup.deleteNode(this.selection.nodeFront);
     } else {
       // remove the node from content
       this.walker.removeNode(this.selection.nodeFront);
     }
   },
 
   /**
+   * This method is here for the benefit of the node-menu-link-follow menu item
+   * in the inspector contextual-menu. It's behavior depends on which node was
+   * right-clicked when the menu was opened.
+   */
+  followAttributeLink: function InspectorPanel_followLink(e) {
+    let type = this.panelDoc.popupNode.dataset.type;
+    let link = this.panelDoc.popupNode.dataset.link;
+
+    // "resource" type links should open appropriate tool instead (bug 1158822).
+    if (type === "uri" || type === "resource") {
+      // Open link in a new tab.
+      this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(url => {
+        let browserWin = this.target.tab.ownerDocument.defaultView;
+        browserWin.openUILinkIn(url, "tab");
+      }, console.error);
+    } else if (type == "idref") {
+      // Select the node in the same document.
+      this.walker.document(this.selection.nodeFront).then(doc => {
+        this.walker.querySelector(doc, "#" + CSS.escape(link)).then(node => {
+          this.selection.setNodeFront(node);
+        }, console.error);
+      }, console.error);
+    }
+  },
+
+  /**
+   * This method is here for the benefit of the node-menu-link-copy menu item
+   * in the inspector contextual-menu. It's behavior depends on which node was
+   * right-clicked when the menu was opened.
+   */
+  copyAttributeLink: function InspectorPanel_copyLink(e) {
+    let link = this.panelDoc.popupNode.dataset.link;
+    this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(url => {
+      clipboardHelper.copyString(url);
+    }, console.error);
+  },
+
+  /**
   * Trigger a high-priority layout change for things that need to be
   * updated immediately
   */
   immediateLayoutChange: function Inspector_immediateLayoutChange()
   {
     this.emit("layout-change");
   },
 
diff --git a/browser/devtools/inspector/inspector.xul b/browser/devtools/inspector/inspector.xul
--- a/browser/devtools/inspector/inspector.xul
+++ b/browser/devtools/inspector/inspector.xul
@@ -86,21 +86,25 @@
             oncommand="inspector.pasteAdjacentHTML('beforeEnd')"/>
         </menupopup>
       </menu>
       <menuseparator/>
       <menuitem id="node-menu-scrollnodeintoview"
         label="&inspectorScrollNodeIntoView.label;"
         accesskey="&inspectorScrollNodeIntoView.accesskey;"
         oncommand="inspector.scrollNodeIntoView()"/>
-      <menuseparator/>
       <menuitem id="node-menu-delete"
         label="&inspectorHTMLDelete.label;"
         accesskey="&inspectorHTMLDelete.accesskey;"
         oncommand="inspector.deleteNode()"/>
+      <menuseparator id="node-menu-link-separator"/>
+      <menuitem id="node-menu-link-follow"
+        oncommand="inspector.followAttributeLink()"/>
+      <menuitem id="node-menu-link-copy"
+        oncommand="inspector.copyAttributeLink()"/>
       <menuseparator/>
       <menuitem id="node-menu-pseudo-hover"
         label=":hover" type="checkbox"
         oncommand="inspector.togglePseudoClass(':hover')"/>
       <menuitem id="node-menu-pseudo-active"
         label=":active" type="checkbox"
         oncommand="inspector.togglePseudoClass(':active')"/>
       <menuitem id="node-menu-pseudo-focus"
diff --git a/browser/devtools/markupview/markup-view.css b/browser/devtools/markupview/markup-view.css
--- a/browser/devtools/markupview/markup-view.css
+++ b/browser/devtools/markupview/markup-view.css
@@ -157,16 +157,20 @@ ul.children + .tag-line::before {
 .newattr {
   display: inline-block;
   width: 1em;
   height: 1ex;
   margin-right: -1em;
   padding: 1px 0;
 }
 
+.attr-value .link {
+  text-decoration: underline;
+}
+
 .newattr:focus {
   margin-right: 0;
 }
 
 .flash-out {
   transition: background .5s;
 }
 
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -23,16 +23,17 @@ const {UndoStack} = require("devtools/sh
 const {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/markupview/html-editor");
 const promise = require("resource://gre/modules/Promise.jsm").Promise;
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const Heritage = require("sdk/core/heritage");
 const {setTimeout, clearTimeout, setInterval, clearInterval} = require("sdk/timers");
+const {parseAttribute} = require("devtools/shared/node-attribute-parser");
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
@@ -1809,26 +1810,16 @@ MarkupContainer.prototype = {
   _onMouseDown: function(event) {
     let target = event.target;
 
     // The "show more nodes" button (already has its onclick).
     if (target.nodeName === "button") {
       return;
     }
 
-    // output-parser generated links handling.
-    if (target.nodeName === "a") {
-      event.stopPropagation();
-      event.preventDefault();
-      let browserWin = this.markup._inspector.target
-                           .tab.ownerDocument.defaultView;
-      browserWin.openUILinkIn(target.href, "tab");
-      return;
-    }
-
     // target is the MarkupContainer itself.
     this._isMouseDown = true;
     this.hovered = false;
     this.markup.navigate(this);
     event.stopPropagation();
 
     // Preventing the default behavior will avoid the body to gain focus on
     // mouseup (through bubbling) when clicking on a non focusable node in the
@@ -2134,18 +2125,19 @@ MarkupElementContainer.prototype = Herit
    * been retrieved
    */
   _prepareImagePreview: function() {
     if (this.isPreviewable()) {
       // Get the image data for later so that when the user actually hovers over
       // the element, the tooltip does contain the image
       let def = promise.defer();
 
+      let hasSrc = this.editor.getAttributeElement("src");
       this.tooltipData = {
-        target: this.editor.getAttributeElement("src") || this.editor.tag,
+        target: hasSrc ? hasSrc.querySelector(".link") : this.editor.tag,
         data: def.promise
       };
 
       let maxDim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");
       this.node.getImageData(maxDim).then(data => {
         data.data.string().then(str => {
           let res = {data: str, size: data.size};
           // Resolving the data promise and, to always keep tooltipData.data
@@ -2434,17 +2426,17 @@ ElementEditor.prototype = {
         this.removeAttribute(name);
       }
     }
 
     // Only loop through the current attributes on the node.  Missing
     // attributes have already been removed at this point.
     for (let attr of nodeAttributes) {
       let el = this.attrElements.get(attr.name);
-      let valueChanged = el && el.querySelector(".attr-value").innerHTML !== attr.value;
+      let valueChanged = el && el.querySelector(".attr-value").textContent !== attr.value;
       let isEditing = el && el.querySelector(".editable").inplaceEditor;
       let canSimplyShowEditor = el && (!valueChanged || isEditing);
 
       if (canSimplyShowEditor) {
         // Element already exists and doesn't need to be recreated.
         // Just show it (it's hidden by default due to the template).
         el.style.removeProperty("display");
       } else {
@@ -2490,52 +2482,52 @@ ElementEditor.prototype = {
   },
 
   _createAttribute: function(aAttr, aBefore = null) {
     // Create the template editor, which will save some variables here.
     let data = {
       attrName: aAttr.name,
     };
     this.template("attribute", data);
-    var {attr, inner, name, val} = data;
+    let {attr, inner, name, val} = data;
 
     // Double quotes need to be handled specially to prevent DOMParser failing.
     // name="v"a"l"u"e" when editing -> name='v"a"l"u"e"'
     // name="v'a"l'u"e" when editing -> name="v'a&quot;l'u&quot;e"
     let editValueDisplayed = aAttr.value || "";
     let hasDoubleQuote = editValueDisplayed.includes('"');
     let hasSingleQuote = editValueDisplayed.includes("'");
     let initial = aAttr.name + '="' + editValueDisplayed + '"';
 
     // Can't just wrap value with ' since the value contains both " and '.
     if (hasDoubleQuote && hasSingleQuote) {
-        editValueDisplayed = editValueDisplayed.replace(/\"/g, "&quot;");
-        initial = aAttr.name + '="' + editValueDisplayed + '"';
+      editValueDisplayed = editValueDisplayed.replace(/\"/g, "&quot;");
+      initial = aAttr.name + '="' + editValueDisplayed + '"';
     }
 
     // Wrap with ' since there are no single quotes in the attribute value.
     if (hasDoubleQuote && !hasSingleQuote) {
-        initial = aAttr.name + "='" + editValueDisplayed + "'";
+      initial = aAttr.name + "='" + editValueDisplayed + "'";
     }
 
     // Make the attribute editable.
     attr.editMode = editableField({
       element: inner,
       trigger: "dblclick",
       stopOnReturn: true,
       selectAll: false,
       initial: initial,
       contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
       popup: this.markup.popup,
       start: (aEditor, aEvent) => {
         // If the editing was started inside the name or value areas,
         // select accordingly.
         if (aEvent && aEvent.target === name) {
           aEditor.input.setSelectionRange(0, name.textContent.length);
-        } else if (aEvent && aEvent.target === val) {
+        } else if (aEvent && aEvent.target.closest(".attr-value") === val) {
           let length = editValueDisplayed.length;
           let editorLength = aEditor.input.value.length;
           let start = editorLength - (length + 1);
           aEditor.input.setSelectionRange(start, start + length);
         } else {
           aEditor.input.select();
         }
       },
@@ -2574,25 +2566,50 @@ ElementEditor.prototype = {
       let idNode = this.attrElements.get("id");
       before = idNode ? idNode.nextSibling : this.attrList.firstChild;
     }
     this.attrList.insertBefore(attr, before);
 
     this.removeAttribute(aAttr.name);
     this.attrElements.set(aAttr.name, attr);
 
-    let collapsedValue;
-    if (aAttr.value.match(COLLAPSE_DATA_URL_REGEX)) {
-      collapsedValue = truncateString(aAttr.value, COLLAPSE_DATA_URL_LENGTH);
-    } else {
-      collapsedValue = truncateString(aAttr.value, COLLAPSE_ATTRIBUTE_LENGTH);
+    // Parse the attribute value to detect whether there are linkable parts in
+    // it (make sure to pass a complete list of existing attributes to the
+    // parseAttribute function, by concatenating aAttr, because this could be a
+    // newly added attribute not yet on this.node).
+    let attributes = this.node.attributes.filter(({name}) => name !== aAttr.name);
+    attributes.push(aAttr);
+    let parsedLinksData = parseAttribute(this.node.namespaceURI,
+      this.node.tagName, attributes, aAttr.name);
+
+    // Create links in the attribute value, and collapse long attributes if
+    // needed.
+    let collapse = value => {
+      if (value.match(COLLAPSE_DATA_URL_REGEX)) {
+        return truncateString(value, COLLAPSE_DATA_URL_LENGTH);
+      } else {
+        return truncateString(value, COLLAPSE_ATTRIBUTE_LENGTH);
+      }
+    };
+
+    val.innerHTML = "";
+    for (let token of parsedLinksData) {
+      if (token.type === "string") {
+        val.appendChild(this.doc.createTextNode(collapse(token.value)));
+      } else {
+        let link = this.doc.createElement("span");
+        link.classList.add("link");
+        link.setAttribute("data-type", token.type);
+        link.setAttribute("data-link", token.value);
+        link.textContent = collapse(token.value);
+        val.appendChild(link);
+      }
     }
 
     name.textContent = aAttr.name;
-    val.textContent = collapsedValue;
 
     return attr;
   },
 
   /**
    * Parse a user-entered attribute string and apply the resulting
    * attributes to the node.  This operation is undoable.
    *
diff --git a/browser/devtools/markupview/test/browser.ini b/browser/devtools/markupview/test/browser.ini
--- a/browser/devtools/markupview/test/browser.ini
+++ b/browser/devtools/markupview/test/browser.ini
@@ -5,16 +5,17 @@ support-files =
   doc_markup_anonymous.html
   doc_markup_dragdrop.html
   doc_markup_dragdrop_autoscroll.html
   doc_markup_edit.html
   doc_markup_events.html
   doc_markup_events_jquery.html
   doc_markup_events-overflow.html
   doc_markup_flashing.html
+  doc_markup_links.html
   doc_markup_mutation.html
   doc_markup_navigation.html
   doc_markup_not_displayed.html
   doc_markup_pagesize_01.html
   doc_markup_pagesize_02.html
   doc_markup_search.html
   doc_markup_svg_attributes.html
   doc_markup_toggle.html
@@ -63,16 +64,21 @@ skip-if = e10s # Bug 1040751 - CodeMirro
 [browser_markupview_events_jquery_1.6.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_1.7.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_1.11.1.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_2.1.1.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
+[browser_markupview_links_01.js]
+[browser_markupview_links_02.js]
+[browser_markupview_links_03.js]
+[browser_markupview_links_04.js]
+[browser_markupview_links_05.js]
 [browser_markupview_load_01.js]
 [browser_markupview_html_edit_01.js]
 [browser_markupview_html_edit_02.js]
 [browser_markupview_html_edit_03.js]
 [browser_markupview_image_tooltip.js]
 [browser_markupview_keybindings_01.js]
 [browser_markupview_keybindings_02.js]
 [browser_markupview_keybindings_03.js]
diff --git a/browser/devtools/markupview/test/browser_markupview_image_tooltip.js b/browser/devtools/markupview/test/browser_markupview_image_tooltip.js
--- a/browser/devtools/markupview/test/browser_markupview_image_tooltip.js
+++ b/browser/devtools/markupview/test/browser_markupview_image_tooltip.js
@@ -56,20 +56,20 @@ function createPage() {
 }
 
 function* getImageTooltipTarget({selector}, inspector) {
   let nodeFront = yield getNodeFront(selector, inspector);
   let isImg = nodeFront.tagName.toLowerCase() === "img";
 
   let container = getContainerForNodeFront(nodeFront, inspector);
 
-   let target = container.editor.tag;
-   if (isImg) {
-     target = container.editor.getAttributeElement("src");
-   }
+  let target = container.editor.tag;
+  if (isImg) {
+    target = container.editor.getAttributeElement("src").querySelector(".link");
+  }
   return target;
 }
 
 function* assertTooltipShownOn(element, {markup}) {
   info("Is the element a valid hover target");
   let isValid = yield markup.tooltip.isValidHoverTarget(element);
   ok(isValid, "The element is a valid hover target for the image tooltip");
 }
diff --git a/browser/devtools/markupview/test/browser_markupview_links_01.js b/browser/devtools/markupview/test/browser_markupview_links_01.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_links_01.js
@@ -0,0 +1,121 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that links are shown in attributes when the values (or part of the
+// values) are URIs or pointers to IDs.
+
+const TEST_URL = TEST_URL_ROOT + "doc_markup_links.html";
+
+const TEST_DATA = [{
+  selector: "link",
+  attributes: [{
+    attributeName: "href",
+    links: [{type: "resource", value: "style.css"}]
+  }]
+}, {
+  selector: "link[rel=icon]",
+  attributes: [{
+    attributeName: "href",
+    links: [{type: "uri", value: "/media/img/firefox/favicon-196.223e1bcaf067.png"}]
+  }]
+}, {
+  selector: "form",
+  attributes: [{
+    attributeName: "action",
+    links: [{type: "uri", value: "/post_message"}]
+  }]
+}, {
+  selector: "label[for=name]",
+  attributes: [{
+    attributeName: "for",
+    links: [{type: "idref", value: "name"}]
+  }]
+}, {
+  selector: "label[for=message]",
+  attributes: [{
+    attributeName: "for",
+    links: [{type: "idref", value: "message"}]
+  }]
+}, {
+  selector: "output",
+  attributes: [{
+    attributeName: "form",
+    links: [{type: "idref", value: "message-form"}]
+  }, {
+    attributeName: "for",
+    links: [
+      {type: "idref", value: "name"},
+      {type: "idref", value: "message"}
+    ]
+  }]
+}, {
+  selector: "a",
+  attributes: [{
+    attributeName: "href",
+    links: [{type: "uri", value: "/go/somewhere/else"}]
+  }, {
+    attributeName: "ping",
+    links: [
+      {type: "uri", value: "/analytics?page=pageA"},
+      {type: "uri", value: "/analytics?user=test"}
+    ]
+  }]
+}, {
+  selector: "li[contextmenu=menu1]",
+  attributes: [{
+    attributeName: "contextmenu",
+    links: [{type: "idref", value: "menu1"}]
+  }]
+}, {
+  selector: "li[contextmenu=menu2]",
+  attributes: [{
+    attributeName: "contextmenu",
+    links: [{type: "idref", value: "menu2"}]
+  }]
+}, {
+  selector: "li[contextmenu=menu3]",
+  attributes: [{
+    attributeName: "contextmenu",
+    links: [{type: "idref", value: "menu3"}]
+  }]
+}, {
+  selector: "video",
+  attributes: [{
+    attributeName: "poster",
+    links: [{type: "uri", value: "doc_markup_tooltip.png"}]
+  }, {
+    attributeName: "src",
+    links: [{type: "uri", value: "code-rush.mp4"}]
+  }]
+}, {
+  selector: "script",
+  attributes: [{
+    attributeName: "src",
+    links: [{type: "resource", value: "lib_jquery_1.0.js"}]
+  }]
+}];
+
+add_task(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  for (let {selector, attributes} of TEST_DATA) {
+    info("Testing attributes on node " + selector);
+    yield selectNode(selector, inspector);
+    let {editor} = yield getContainerForSelector(selector, inspector);
+
+    for (let {attributeName, links} of attributes) {
+      info("Testing attribute " + attributeName);
+      let linkEls = editor.attrElements.get(attributeName).querySelectorAll(".link");
+
+      is(linkEls.length, links.length, "The right number of links were found");
+
+      for (let i = 0; i < links.length; i ++) {
+        is(linkEls[i].dataset.type, links[i].type, "Link " + i + " has the right type");
+        is(linkEls[i].textContent, links[i].value, "Link " + i + " has the right value");
+      }
+    }
+  }
+});
diff --git a/browser/devtools/markupview/test/browser_markupview_links_02.js b/browser/devtools/markupview/test/browser_markupview_links_02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_links_02.js
@@ -0,0 +1,37 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that attributes are linkified correctly when attributes are updated
+// and created.
+
+const TEST_URL = TEST_URL_ROOT + "doc_markup_links.html";
+
+add_task(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  info("Adding a contextmenu attribute to the body node");
+  yield addNewAttributes("body", "contextmenu=\"menu1\"", inspector);
+
+  info("Checking for links in the new attribute");
+  let {editor} = yield getContainerForSelector("body", inspector);
+  let linkEls = editor.attrElements.get("contextmenu").querySelectorAll(".link");
+  is(linkEls.length, 1, "There is one link in the contextmenu attribute");
+  is(linkEls[0].dataset.type, "idref", "The link has the right type");
+  is(linkEls[0].textContent, "menu1", "The link has the right value");
+
+  info("Editing the contextmenu attribute on the body node");
+  let nodeMutated = inspector.once("markupmutation");
+  let attr = editor.attrElements.get("contextmenu").querySelector(".editable");
+  setEditableFieldValue(attr, "contextmenu=\"menu2\"", inspector);
+  yield nodeMutated;
+
+  info("Checking for links in the updated attribute");
+  ({editor}) = yield getContainerForSelector("body", inspector);
+  linkEls = editor.attrElements.get("contextmenu").querySelectorAll(".link");
+  is(linkEls.length, 1, "There is one link in the contextmenu attribute");
+  is(linkEls[0].dataset.type, "idref", "The link has the right type");
+  is(linkEls[0].textContent, "menu2", "The link has the right value");
+});
diff --git a/browser/devtools/markupview/test/browser_markupview_links_03.js b/browser/devtools/markupview/test/browser_markupview_links_03.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_links_03.js
@@ -0,0 +1,37 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that links appear correctly in attributes created in content.
+
+const TEST_URL = TEST_URL_ROOT + "doc_markup_links.html";
+
+add_task(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  info("Adding a contextmenu attribute to the body node via the content");
+  let onMutated = inspector.once("markupmutation");
+  yield setNodeAttribute("body", "contextmenu", "menu1");
+  yield onMutated;
+
+  info("Checking for links in the new attribute");
+  let {editor} = yield getContainerForSelector("body", inspector);
+  let linkEls = editor.attrElements.get("contextmenu").querySelectorAll(".link");
+  is(linkEls.length, 1, "There is one link in the contextmenu attribute");
+  is(linkEls[0].dataset.type, "idref", "The link has the right type");
+  is(linkEls[0].textContent, "menu1", "The link has the right value");
+
+  info("Editing the contextmenu attribute on the body node");
+  onMutated = inspector.once("markupmutation");
+  yield setNodeAttribute("body", "contextmenu", "menu2");
+  yield onMutated;
+
+  info("Checking for links in the updated attribute");
+  ({editor}) = yield getContainerForSelector("body", inspector);
+  linkEls = editor.attrElements.get("contextmenu").querySelectorAll(".link");
+  is(linkEls.length, 1, "There is one link in the contextmenu attribute");
+  is(linkEls[0].dataset.type, "idref", "The link has the right type");
+  is(linkEls[0].textContent, "menu2", "The link has the right value");
+});
diff --git a/browser/devtools/markupview/test/browser_markupview_links_04.js b/browser/devtools/markupview/test/browser_markupview_links_04.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_links_04.js
@@ -0,0 +1,102 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that the contextual menu shows the right items when clicking on a link
+// in an attribute.
+
+const TEST_URL = TEST_URL_ROOT + "doc_markup_links.html";
+const STRINGS = Services.strings
+  .createBundle("chrome://browser/locale/devtools/inspector.properties");
+
+// The test case array contains objects with the following properties:
+// - selector: css selector for the node to select in the inspector
+// - attributeName: name of the attribute to test
+// - popupNodeSelector: css selector for the element inside the attribute
+//   element to use as the contextual menu anchor
+// - isLinkFollowItemVisible: is the follow-link item expected to be displayed
+// - isLinkCopyItemVisible: is the copy-link item expected to be displayed
+// - linkFollowItemLabel: the expected label of the follow-link item
+// - linkCopyItemLabel: the expected label of the copy-link item
+const TEST_DATA = [{
+  selector: "link",
+  attributeName: "href",
+  popupNodeSelector: ".link",
+  isLinkFollowItemVisible: true,
+  isLinkCopyItemVisible: true,
+  linkFollowItemLabel: STRINGS.GetStringFromName("inspector.menu.openUrlInNewTab.label"),
+  linkCopyItemLabel: STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
+}, {
+  selector: "link[rel=icon]",
+  attributeName: "href",
+  popupNodeSelector: ".link",
+  isLinkFollowItemVisible: true,
+  isLinkCopyItemVisible: true,
+  linkFollowItemLabel: STRINGS.GetStringFromName("inspector.menu.openUrlInNewTab.label"),
+  linkCopyItemLabel: STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
+}, {
+  selector: "link",
+  attributeName: "rel",
+  popupNodeSelector: ".attr-value",
+  isLinkFollowItemVisible: false,
+  isLinkCopyItemVisible: false
+}, {
+  selector: "output",
+  attributeName: "for",
+  popupNodeSelector: ".link",
+  isLinkFollowItemVisible: true,
+  isLinkCopyItemVisible: false,
+  linkFollowItemLabel: STRINGS.formatStringFromName(
+    "inspector.menu.selectElement.label", ["name"], 1)
+}, {
+  selector: "script",
+  attributeName: "src",
+  popupNodeSelector: ".link",
+  isLinkFollowItemVisible: true,
+  isLinkCopyItemVisible: true,
+  linkFollowItemLabel: STRINGS.GetStringFromName("inspector.menu.openUrlInNewTab.label"),
+  linkCopyItemLabel: STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
+}];
+
+add_task(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  let linkFollow = inspector.panelDoc.getElementById("node-menu-link-follow");
+  let linkCopy = inspector.panelDoc.getElementById("node-menu-link-copy");
+
+  for (let test of TEST_DATA) {
+    info("Selecting test node " + test.selector);
+    yield selectNode(test.selector, inspector);
+
+    info("Finding the popupNode to anchor the context-menu to");
+    let {editor} = yield getContainerForSelector(test.selector, inspector);
+    let popupNode = editor.attrElements.get(test.attributeName)
+                    .querySelector(test.popupNodeSelector);
+    ok(popupNode, "Found the popupNode in attribute " + test.attributeName);
+
+    info("Simulating a context click on the popupNode");
+    contextMenuClick(popupNode);
+
+    // The contextual menu setup is async, because it needs to know if the
+    // inspector has the resolveRelativeURL method first. So call actorHasMethod
+    // here too to make sure the first call resolves first and the menu is
+    // properly setup.
+    yield inspector.target.actorHasMethod("inspector", "resolveRelativeURL");
+
+    is(linkFollow.hasAttribute("hidden"), !test.isLinkFollowItemVisible,
+      "The follow-link item display is correct");
+    is(linkCopy.hasAttribute("hidden"), !test.isLinkCopyItemVisible,
+      "The copy-link item display is correct");
+
+    if (test.isLinkFollowItemVisible) {
+      is(linkFollow.getAttribute("label"), test.linkFollowItemLabel,
+        "the follow-link label is correct");
+    }
+    if (test.isLinkCopyItemVisible) {
+      is(linkCopy.getAttribute("label"), test.linkCopyItemLabel,
+        "the copy-link label is correct");
+    }
+  }
+});
diff --git a/browser/devtools/markupview/test/browser_markupview_links_05.js b/browser/devtools/markupview/test/browser_markupview_links_05.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_links_05.js
@@ -0,0 +1,65 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that the contextual menu items shown when clicking on links in
+// attributes actually do the right things.
+
+const TEST_URL = TEST_URL_ROOT + "doc_markup_links.html";
+
+add_task(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  let linkFollow = inspector.panelDoc.getElementById("node-menu-link-follow");
+  let linkCopy = inspector.panelDoc.getElementById("node-menu-link-copy");
+
+  info("Select a node with a URI attribute");
+  yield selectNode("video", inspector);
+
+  info("Set the popupNode to the node that contains the uri");
+  let {editor} = yield getContainerForSelector("video", inspector);
+  let popupNode = editor.attrElements.get("poster").querySelector(".link");
+  inspector.panelDoc.popupNode = popupNode;
+
+  info("Follow the link and wait for the new tab to open");
+  let onTabOpened = once(gBrowser.tabContainer, "TabOpen");
+  inspector.followAttributeLink();
+  let {target: tab} = yield onTabOpened;
+  yield waitForTabLoad(tab);
+
+  ok(true, "A new tab opened");
+  is(tab.linkedBrowser.currentURI.spec, TEST_URL_ROOT + "doc_markup_tooltip.png",
+    "The URL for the new tab is correct");
+  gBrowser.removeTab(tab);
+
+  info("Select a node with a IDREF attribute");
+  yield selectNode("label", inspector);
+
+  info("Set the popupNode to the node that contains the ref");
+  ({editor}) = yield getContainerForSelector("label", inspector);
+  popupNode = editor.attrElements.get("for").querySelector(".link");
+  inspector.panelDoc.popupNode = popupNode;
+
+  info("Follow the link and ref for the new node to be selected");
+  let onSelection = inspector.selection.once("new-node-front");
+  inspector.followAttributeLink();
+  yield onSelection;
+
+  ok(true, "A new node was selected");
+  is(inspector.selection.nodeFront.id, "name", "The right node was selected");
+});
+
+function waitForTabLoad(tab) {
+  let def = promise.defer();
+  tab.addEventListener("load", function onLoad(e) {
+    // Skip load event for about:blank
+    if (tab.linkedBrowser.currentURI.spec === "about:blank") {
+      return;
+    }
+    tab.removeEventListener("load", onLoad);
+    def.resolve();
+  });
+  return def.promise;
+}
diff --git a/browser/devtools/markupview/test/doc_markup_links.html b/browser/devtools/markupview/test/doc_markup_links.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/doc_markup_links.html
@@ -0,0 +1,42 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <meta charset="utf-8">
+    <title>Markup-view links</title>
+    <link rel="stylesheet" type="text/css" href="style.css">
+    <link rel="icon" type="image/png" sizes="196x196" href="/media/img/firefox/favicon-196.223e1bcaf067.png">
+  </head>
+  <body>
+    <form id="message-form" method="post" action="/post_message">
+      <p>
+        <label for="name">Name</label>
+        <input id="name" type="text" />
+      </p>
+      <p>
+        <label for="message">Message</label>
+        <input id="message" type="text" />
+      </p>
+      <p>
+        <button>Send message</button>
+      </p>
+      <output form="message-form" for="name message">Thank you for your message!</output>
+    </form>
+    <a href="/go/somewhere/else" ping="/analytics?page=pageA /analytics?user=test">Click me, I'm a link</a>
+    <ul>
+      <li contextmenu="menu1">Item 1</li>
+      <li contextmenu="menu2">Item 2</li>
+      <li contextmenu="menu3">Item 3</li>
+    </ul>
+    <menu type="context" id="menu1">
+      <menuitem label="custom menu 1"></menuitem>
+    </menu>
+    <menu type="context" id="menu2">
+      <menuitem label="custom menu 2"></menuitem>
+    </menu>
+    <menu type="context" id="menu3">
+      <menuitem label="custom menu 3"></menuitem>
+    </menu>
+    <video controls poster="doc_markup_tooltip.png" src="code-rush.mp4"></video>
+    <script type="text/javascript" src="lib_jquery_1.0.js"></script>
+  </body>
+</html>
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -680,8 +680,22 @@ function createTestHTTPServer() {
       destroyed.resolve();
     });
     yield destroyed.promise;
   });
 
   server.start(-1);
   return server;
 }
+
+/**
+ * A helper that simulates a contextmenu event on the given chrome DOM element.
+ */
+function contextMenuClick(element) {
+  let evt = element.ownerDocument.createEvent('MouseEvents');
+  let button = 2;  // right click
+
+  evt.initMouseEvent('contextmenu', true, true,
+       element.ownerDocument.defaultView, 1, 0, 0, 0, 0, false,
+       false, false, false, button, null);
+
+  element.dispatchEvent(evt);
+}
diff --git a/browser/devtools/shared/moz.build b/browser/devtools/shared/moz.build
--- a/browser/devtools/shared/moz.build
+++ b/browser/devtools/shared/moz.build
@@ -47,16 +47,17 @@ EXTRA_JS_MODULES.devtools.shared.timelin
 
 EXTRA_JS_MODULES.devtools.shared += [
     'autocomplete-popup.js',
     'devices.js',
     'doorhanger.js',
     'frame-script-utils.js',
     'getjson.js',
     'inplace-editor.js',
+    'node-attribute-parser.js',
     'observable-object.js',
     'options-view.js',
     'source-utils.js',
     'telemetry.js',
     'theme-switching.js',
     'theme.js',
     'undo.js',
 ]
diff --git a/browser/devtools/shared/node-attribute-parser.js b/browser/devtools/shared/node-attribute-parser.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/node-attribute-parser.js
@@ -0,0 +1,278 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2; js-indent-level: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ * This module contains a small element attribute value parser. It's primary
+ * goal is to extract link information from attribute values (like the href in
+ * <a href="/some/link.html"> for example).
+ *
+ * There are several types of linkable attribute values:
+ * - TYPE_URI: a URI (e.g. <a href="uri">).
+ * - TYPE_URI_LIST: a space separated list of URIs (e.g. <a ping="uri1 uri2">).
+ * - TYPE_IDREF: a reference to an other element in the same document via its id
+ *   (e.g. <label for="input-id"> or <key command="command-id">).
+ * - TYPE_IDREF_LIST: a space separated list of IDREFs (e.g.
+ *   <output for="id1 id2">).
+ * - TYPE_RESOURCE_URI: a URI to a javascript or css resource that can be opened
+ *   in the devtools (e.g. <script src="uri">).
+ *
+ * parseAttribute is the parser entry function, exported on this module.
+ */
+
+const TYPE_STRING = "string";
+const TYPE_URI = "uri";
+const TYPE_URI_LIST = "uriList";
+const TYPE_IDREF = "idref";
+const TYPE_IDREF_LIST = "idrefList";
+const TYPE_RESOURCE_URI = "resource";
+
+const SVG_NS = "http://www.w3.org/2000/svg";
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+
+const ATTRIBUTE_TYPES = [
+  {namespaceURI: HTML_NS, attributeName: "action", tagName: "form", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "background", tagName: "body", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "blockquote", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "q", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "del", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "ins", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "classid", tagName: "object", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "codebase", tagName: "object", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "codebase", tagName: "applet", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "command", tagName: "menuitem", type: TYPE_IDREF},
+  {namespaceURI: "*", attributeName: "contextmenu", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "data", tagName: "object", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "for", tagName: "label", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "for", tagName: "output", type: TYPE_IDREF_LIST},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "button", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "fieldset", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "input", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "keygen", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "label", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "object", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "output", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "select", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "form", tagName: "textarea", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "formaction", tagName: "button", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "formaction", tagName: "input", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "headers", tagName: "td", type: TYPE_IDREF_LIST},
+  {namespaceURI: HTML_NS, attributeName: "headers", tagName: "th", type: TYPE_IDREF_LIST},
+  {namespaceURI: HTML_NS, attributeName: "href", tagName: "a", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "href", tagName: "area", type: TYPE_URI},
+  {namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_RESOURCE_URI,
+   isValid: (namespaceURI, tagName, attributes) => {
+    return getAttribute(attributes, "rel") === "stylesheet";
+   }},
+  {namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "href", tagName: "base", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "icon", tagName: "menuitem", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "list", tagName: "input", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "img", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "frame", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "iframe", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "manifest", tagName: "html", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "menu", tagName: "button", type: TYPE_IDREF},
+  {namespaceURI: HTML_NS, attributeName: "ping", tagName: "a", type: TYPE_URI_LIST},
+  {namespaceURI: HTML_NS, attributeName: "ping", tagName: "area", type: TYPE_URI_LIST},
+  {namespaceURI: HTML_NS, attributeName: "poster", tagName: "video", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "profile", tagName: "head", type: TYPE_URI},
+  {namespaceURI: "*", attributeName: "src", tagName: "script", type: TYPE_RESOURCE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "input", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "frame", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "iframe", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "img", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "audio", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "embed", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "source", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "track", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "src", tagName: "video", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "img", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "input", type: TYPE_URI},
+  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "object", type: TYPE_URI},
+  {namespaceURI: "*", attributeName: "xmlns", tagName: "*", type: TYPE_URI},
+  {namespaceURI: XUL_NS, attributeName: "command", tagName: "key", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "containment", tagName: "*", type: TYPE_URI},
+  {namespaceURI: XUL_NS, attributeName: "context", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "datasources", tagName: "*", type: TYPE_URI_LIST},
+  {namespaceURI: XUL_NS, attributeName: "insertafter", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "insertbefore", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "menu", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "observes", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "popup", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "ref", tagName: "*", type: TYPE_URI},
+  {namespaceURI: XUL_NS, attributeName: "removeelement", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "sortResource", tagName: "*", type: TYPE_URI},
+  {namespaceURI: XUL_NS, attributeName: "sortResource2", tagName: "*", type: TYPE_URI},
+  {namespaceURI: XUL_NS, attributeName: "src", tagName: "stringbundle", type: TYPE_URI},
+  {namespaceURI: XUL_NS, attributeName: "template", tagName: "*", type: TYPE_IDREF},
+  {namespaceURI: XUL_NS, attributeName: "tooltip", tagName: "*", type: TYPE_IDREF},
+  // SVG links aren't handled yet, see bug 1158831.
+  // {namespaceURI: SVG_NS, attributeName: "fill", tagName: "*", type: },
+  // {namespaceURI: SVG_NS, attributeName: "stroke", tagName: "*", type: },
+  // {namespaceURI: SVG_NS, attributeName: "markerstart", tagName: "*", type: },
+  // {namespaceURI: SVG_NS, attributeName: "markermid", tagName: "*", type: },
+  // {namespaceURI: SVG_NS, attributeName: "markerend", tagName: "*", type: },
+  // {namespaceURI: SVG_NS, attributeName: "xlink:href", tagName: "*", type: }
+];
+
+let parsers = {
+  [TYPE_URI]: function(attributeValue) {
+    return [{
+      type: TYPE_URI,
+      value: attributeValue
+    }];
+  },
+  [TYPE_URI_LIST]: function(attributeValue) {
+    let data = splitBy(attributeValue, " ");
+    for (let token of data) {
+      if (!token.type) {
+        token.type = TYPE_URI;
+      }
+    }
+    return data;
+  },
+  [TYPE_RESOURCE_URI]: function(attributeValue) {
+    return [{
+      type: TYPE_RESOURCE_URI,
+      value: attributeValue
+    }];
+  },
+  [TYPE_IDREF]: function(attributeValue) {
+    return [{
+      type: TYPE_IDREF,
+      value: attributeValue
+    }];
+  },
+  [TYPE_IDREF_LIST]: function(attributeValue) {
+    let data = splitBy(attributeValue, " ");
+    for (let token of data) {
+      if (!token.type) {
+        token.type = TYPE_IDREF;
+      }
+    }
+    return data;
+  }
+};
+
+/**
+ * Parse an attribute value.
+ * @param {String} namespaceURI The namespaceURI of the node that has the
+ * attribute.
+ * @param {String} tagName The tagName of the node that has the attribute.
+ * @param {Array} attributes The list of all attributes of the node. This should
+ * be an array of {name, value} objects.
+ * @param {String} attributeName The name of the attribute to parse.
+ * @return {Array} An array of tokens that represents the value. Each token is
+ * an object {type: [string|uri|resource|idref], value}.
+ * For instance parsing the ping attribute in <a ping="uri1 uri2"> returns:
+ * [
+ *   {type: "uri", value: "uri2"},
+ *   {type: "string", value: " "},
+ *   {type: "uri", value: "uri1"}
+ * ]
+ */
+function parseAttribute(namespaceURI, tagName, attributes, attributeName) {
+  if (!hasAttribute(attributes, attributeName)) {
+    throw new Error(`Attribute ${attributeName} isn't part of the provided attributes`);
+  }
+
+  let type = getType(namespaceURI, tagName, attributes, attributeName);
+  if (!type) {
+    return [{
+      type: TYPE_STRING,
+      value: getAttribute(attributes, attributeName)
+    }];
+  }
+
+  return parsers[type](getAttribute(attributes, attributeName));
+}
+
+/**
+ * Get the type for links in this attribute if any.
+ * @param {String} namespaceURI The node's namespaceURI.
+ * @param {String} tagName The node's tagName.
+ * @param {Array} attributes The node's attributes, as a list of {name, value}
+ * objects.
+ * @param {String} attributeName The name of the attribute to get the type for.
+ * @return {Object} null if no type exist for this attribute on this node, the
+ * type object otherwise.
+ */
+function getType(namespaceURI, tagName, attributes, attributeName) {
+  for (let typeData of ATTRIBUTE_TYPES) {
+    let hasAttribute = attributeName === typeData.attributeName ||
+                       typeData.attributeName === "*";
+    let hasNamespace = namespaceURI === typeData.namespaceURI ||
+                       typeData.namespaceURI === "*";
+    let hasTagName = tagName.toLowerCase() === typeData.tagName ||
+                     typeData.tagName === "*";
+    let isValid = typeData.isValid
+                  ? typeData.isValid(namespaceURI, tagName, attributes, attributeName)
+                  : true;
+
+    if (hasAttribute && hasNamespace && hasTagName && isValid) {
+      return typeData.type;
+    }
+  }
+
+  return null;
+}
+
+function getAttribute(attributes, attributeName) {
+  for (let {name, value} of attributes) {
+    if (name === attributeName) {
+      return value;
+    }
+  }
+  return null;
+}
+
+function hasAttribute(attributes, attributeName) {
+  for (let {name, value} of attributes) {
+    if (name === attributeName) {
+      return true;
+    }
+  }
+  return false;
+}
+
+/**
+ * Split a string by a given character and return an array of objects parts.
+ * The array will contain objects for the split character too, marked with
+ * TYPE_STRING type.
+ * @param {String} value The string to parse.
+ * @param {String} splitChar A 1 length split character.
+ * @return {Array}
+ */
+function splitBy(value, splitChar) {
+  let data = [], i = 0, buffer = "";
+  while (i <= value.length) {
+    if (i === value.length && buffer) {
+      data.push({value: buffer});
+    }
+    if (value[i] === splitChar) {
+      if (buffer) {
+        data.push({value: buffer});
+      }
+      data.push({
+        type: TYPE_STRING,
+        value: splitChar
+      });
+      buffer = "";
+    } else {
+      buffer += value[i];
+    }
+
+    i ++;
+  }
+  return data;
+}
+
+exports.parseAttribute = parseAttribute;
+// Exported for testing only.
+exports.splitBy = splitBy;
diff --git a/browser/devtools/shared/test/unit/test_attribute-parsing-01.js b/browser/devtools/shared/test/unit/test_attribute-parsing-01.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/test/unit/test_attribute-parsing-01.js
@@ -0,0 +1,73 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Test splitBy from node-attribute-parser.js
+
+const Cu = Components.utils;
+let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+let require = devtools.require;
+const {splitBy} = require("devtools/shared/node-attribute-parser");
+
+const TEST_DATA = [{
+  value: "this is a test",
+  splitChar: " ",
+  expected: [
+    {value: "this"},
+    {value: " ", type: "string"},
+    {value: "is"},
+    {value: " ", type: "string"},
+    {value: "a"},
+    {value: " ", type: "string"},
+    {value: "test"}
+  ]
+}, {
+  value: "/path/to/handler",
+  splitChar: " ",
+  expected: [
+    {value: "/path/to/handler"}
+  ]
+}, {
+  value: "test",
+  splitChar: " ",
+  expected: [
+    {value: "test"}
+  ]
+}, {
+  value: " test ",
+  splitChar: " ",
+  expected: [
+    {value: " ", type: "string"},
+    {value: "test"},
+    {value: " ", type: "string"}
+  ]
+}, {
+  value: "",
+  splitChar: " ",
+  expected: []
+}, {
+  value: "   ",
+  splitChar: " ",
+  expected: [
+    {value: " ", type: "string"},
+    {value: " ", type: "string"},
+    {value: " ", type: "string"}
+  ]
+}];
+
+function run_test() {
+  for (let {value, splitChar, expected} of TEST_DATA) {
+    do_print("Splitting string: " + value);
+    let tokens = splitBy(value, splitChar);
+
+    do_print("Checking that the number of parsed tokens is correct");
+    do_check_eq(tokens.length, expected.length);
+
+    for (let i = 0; i < tokens.length; i ++) {
+      do_print("Checking the data in token " + i);
+      do_check_eq(tokens[i].value, expected[i].value);
+      if (expected[i].type) {
+        do_check_eq(tokens[i].type, expected[i].type);
+      }
+    }
+  }
+}
diff --git a/browser/devtools/shared/test/unit/test_attribute-parsing-02.js b/browser/devtools/shared/test/unit/test_attribute-parsing-02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/shared/test/unit/test_attribute-parsing-02.js
@@ -0,0 +1,131 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Test parseAttribute from node-attribute-parser.js
+
+const Cu = Components.utils;
+let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+let require = devtools.require;
+const {parseAttribute} = require("devtools/shared/node-attribute-parser");
+
+const TEST_DATA = [{
+  tagName: "body",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "class",
+  attributeValue: "some css class names",
+  expected: [
+    {value: "some css class names", type: "string"}
+  ]
+}, {
+  tagName: "box",
+  namespaceURI: "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+  attributeName: "datasources",
+  attributeValue: "/url/1?test=1#test http://mozilla.org/wow",
+  expected: [
+    {value: "/url/1?test=1#test", type: "uri"},
+    {value: " ", type: "string"},
+    {value: "http://mozilla.org/wow", type: "uri"}
+  ]
+}, {
+  tagName: "form",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "action",
+  attributeValue: "/path/to/handler",
+  expected: [
+    {value: "/path/to/handler", type: "uri"}
+  ]
+}, {
+  tagName: "a",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "ping",
+  attributeValue: "http://analytics.com/track?id=54 http://analytics.com/track?id=55",
+  expected: [
+    {value: "http://analytics.com/track?id=54", type: "uri"},
+    {value: " ", type: "string"},
+    {value: "http://analytics.com/track?id=55", type: "uri"}
+  ]
+}, {
+  tagName: "link",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "href",
+  attributeValue: "styles.css",
+  otherAttributes: [{name: "rel", value: "stylesheet"}],
+  expected: [
+    {value: "styles.css", type: "resource"}
+  ]
+}, {
+  tagName: "link",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "href",
+  attributeValue: "styles.css",
+  expected: [
+    {value: "styles.css", type: "uri"}
+  ]
+}, {
+  tagName: "output",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "for",
+  attributeValue: "element-id something id",
+  expected: [
+    {value: "element-id", type: "idref"},
+    {value: " ", type: "string"},
+    {value: "something", type: "idref"},
+    {value: " ", type: "string"},
+    {value: "id", type: "idref"}
+  ]
+}, {
+  tagName: "img",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "contextmenu",
+  attributeValue: "id-of-menu",
+  expected: [
+    {value: "id-of-menu", type: "idref"}
+  ]
+}, {
+  tagName: "img",
+  namespaceURI: "http://www.w3.org/1999/xhtml",
+  attributeName: "src",
+  attributeValue: "omg-thats-so-funny.gif",
+  expected: [
+    {value: "omg-thats-so-funny.gif", type: "uri"}
+  ]
+}, {
+  tagName: "key",
+  namespaceURI: "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+  attributeName: "command",
+  attributeValue: "some_command_id",
+  expected: [
+    {value: "some_command_id", type: "idref"}
+  ]
+}, {
+  tagName: "script",
+  namespaceURI: "whatever",
+  attributeName: "src",
+  attributeValue: "script.js",
+  expected: [
+    {value: "script.js", type: "resource"}
+  ]
+}];
+
+function run_test() {
+  for (let {tagName, namespaceURI, attributeName,
+            otherAttributes, attributeValue, expected} of TEST_DATA) {
+    do_print("Testing <" + tagName + " " + attributeName + "='" + attributeValue + "'>");
+
+    let attributes = [...otherAttributes||[], {name: attributeName, value: attributeValue}];
+    let tokens = parseAttribute(namespaceURI, tagName, attributes, attributeName);
+    if (!expected) {
+      do_check_true(!tokens);
+      continue;
+    }
+
+    do_print("Checking that the number of parsed tokens is correct");
+    do_check_eq(tokens.length, expected.length);
+
+    for (let i = 0; i < tokens.length; i ++) {
+      do_print("Checking the data in token " + i);
+      do_check_eq(tokens[i].value, expected[i].value);
+      do_check_eq(tokens[i].type, expected[i].type);
+    }
+  }
+}
diff --git a/browser/devtools/shared/test/unit/xpcshell.ini b/browser/devtools/shared/test/unit/xpcshell.ini
--- a/browser/devtools/shared/test/unit/xpcshell.ini
+++ b/browser/devtools/shared/test/unit/xpcshell.ini
@@ -1,11 +1,13 @@
 [DEFAULT]
 tags = devtools
 head =
 tail =
 firefox-appdir = browser
 skip-if = toolkit == 'android' || toolkit == 'gonk'
 
+[test_attribute-parsing-01.js]
+[test_attribute-parsing-02.js]
 [test_bezierCanvas.js]
 [test_cubicBezier.js]
 [test_undoStack.js]
 [test_VariablesView_getString_promise.js]
diff --git a/browser/locales/en-US/chrome/browser/devtools/inspector.properties b/browser/locales/en-US/chrome/browser/devtools/inspector.properties
--- a/browser/locales/en-US/chrome/browser/devtools/inspector.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/inspector.properties
@@ -67,8 +67,41 @@ docsTooltip.loadDocsError=Could not load
 # that collapses the right panel (rules, computed, box-model, etc...) in the
 # inspector UI.
 inspector.collapsePane=Collapse pane
 
 # LOCALIZATION NOTE (inspector.expandPane): This is the tooltip for the button
 # that expands the right panel (rules, computed, box-model, etc...) in the
 # inspector UI.
 inspector.expandPane=Expand pane
+
+# LOCALIZATION NOTE (inspector.menu.openUrlInNewTab.label): This is the label of
+# a menu item in the inspector contextual-menu that appears when the user right-
+# clicks on the attribute of a node in the inspector that is a URL, and that
+# allows to open that URL in a new tab.
+inspector.menu.openUrlInNewTab.label=Open Link in New Tab
+
+# LOCALIZATION NOTE (inspector.menu.copyUrlToClipboard.label): This is the label
+# of a menu item in the inspector contextual-menu that appears when the user
+# right-clicks on the attribute of a node in the inspector that is a URL, and
+# that allows to copy that URL in the clipboard.
+inspector.menu.copyUrlToClipboard.label=Copy Link Address
+
+# LOCALIZATION NOTE (inspector.menu.openFileInDebugger.label): This is the label
+# of a menu item in the inspector contextual-menu that appears when the user
+# right-clicks on the attribute of a node in the inspector that is a URL to a
+# javascript filename, and that allows to open the corresponding file in the
+# debugger.
+inspector.menu.openFileInDebugger.label=Open File in Debugger
+
+# LOCALIZATION NOTE (inspector.menu.openFileInStyleEditor.label): This is the
+# label of a menu item in the inspector contextual-menu that appears when the
+# user right-clicks on the attribute of a node in the inspector that is a URL to
+# a css filename, and that allows to open the corresponding file in the style
+# editor.
+inspector.menu.openFileInStyleEditor.label=Open File in Style-Editor
+
+# LOCALIZATION NOTE (inspector.menu.selectElement.label): This is the label of a
+# menu item in the inspector contextual-menu that appears when the user right-
+# clicks on the attribute of a node in the inspector that is the ID of another
+# element in the DOM (like with <label for="input-id">), and that allows to
+# select that element in the inspector.
+inspector.menu.selectElement.label=Select Element #%S
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -3466,16 +3466,39 @@ var InspectorActor = exports.InspectorAc
     }
 
     img.src = url;
 
     return deferred.promise;
   }, {
     request: {url: Arg(0), maxDim: Arg(1, "nullable:number")},
     response: RetVal("imageData")
+  }),
+
+  /**
+   * Resolve a URL to its absolute form, in the scope of a given content window.
+   * @param {String} url.
+   * @param {NodeActor} node If provided, the owner window of this node will be
+   * used to resolve the URL. Otherwise, the top-level content window will be
+   * used instead.
+   * @return {String} url.
+   */
+  resolveRelativeURL: method(function(url, node) {
+    let document;
+    if (!node) {
+      document = this.window.document;
+    } else {
+      document = node.rawNode.ownerDocument;
+    }
+
+    let baseURI = Services.io.newURI(document.location.href, null, null);
+    return Services.io.newURI(url, null, baseURI).spec;
+  }, {
+    request: {url: Arg(0, "string"), node: Arg(1, "nullable:domnode")},
+    response: {value: RetVal("string")}
   })
 });
 
 /**
  * Client side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorFront = exports.InspectorFront = protocol.FrontClass(InspectorActor, {
diff --git a/toolkit/devtools/server/tests/mochitest/chrome.ini b/toolkit/devtools/server/tests/mochitest/chrome.ini
--- a/toolkit/devtools/server/tests/mochitest/chrome.ini
+++ b/toolkit/devtools/server/tests/mochitest/chrome.ini
@@ -58,16 +58,17 @@ skip-if = buildapp == 'mulet'
 [test_inspector-mutations-attr.html]
 [test_inspector-mutations-childlist.html]
 [test_inspector-mutations-frameload.html]
 [test_inspector-mutations-value.html]
 [test_inspector-pseudoclass-lock.html]
 [test_inspector-release.html]
 [test_inspector-reload.html]
 [test_inspector-remove.html]
+[test_inspector-resolve-url.html]
 [test_inspector-retain.html]
 [test_inspector-scroll-into-view.html]
 [test_inspector-traversal.html]
 [test_makeGlobalObjectReference.html]
 [test_memory.html]
 [test_memory_allocations_01.html]
 [test_memory_allocations_02.html]
 [test_memory_allocations_03.html]
diff --git a/toolkit/devtools/server/tests/mochitest/test_inspector-resolve-url.html b/toolkit/devtools/server/tests/mochitest/test_inspector-resolve-url.html
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/mochitest/test_inspector-resolve-url.html
@@ -0,0 +1,90 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=921102
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 921102</title>
+
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+  <script type="application/javascript;version=1.8" src="inspector-helpers.js"></script>
+  <script type="application/javascript;version=1.8">
+Components.utils.import("resource://gre/modules/devtools/Loader.jsm");
+const {Promise: promise} = Components.utils.import("resource://gre/modules/Promise.jsm", {});
+const inspector = devtools.require("devtools/server/actors/inspector");
+
+window.onload = function() {
+  SimpleTest.waitForExplicitFinish();
+  runNextTest();
+}
+
+var gInspector;
+var gDoc;
+
+addTest(function setup() {
+  let url = document.getElementById("inspectorContent").href;
+  attachURL(url, function(err, client, tab, doc) {
+    gDoc = doc;
+    let {InspectorFront} = devtools.require("devtools/server/actors/inspector");
+    gInspector = InspectorFront(client, tab);
+    runNextTest();
+  });
+});
+
+addTest(function testLargeImage() {
+  info("Resolve a relative URL without providing a context node");
+  gInspector.resolveRelativeURL("test.png?id=4#wow").then(url => {
+    is(url, "chrome://mochitests/content/chrome/toolkit/devtools/server/tests/" +
+            "mochitest/test.png?id=4#wow");
+    runNextTest();
+  });
+});
+
+addTest(function testLargeImage() {
+  info("Resolve an absolute URL without providing a context node");
+  gInspector.resolveRelativeURL("chrome://mochitests/content/chrome/toolkit/" +
+                                "devtools/server/").then(url => {
+    is(url, "chrome://mochitests/content/chrome/toolkit/devtools/server/");
+    runNextTest();
+  });
+});
+
+addTest(function testLargeImage() {
+  info("Resolve a relative URL providing a context node");
+  let node = gDoc.querySelector(".big-horizontal");
+  gInspector.resolveRelativeURL("test.png?id=4#wow", node).then(url => {
+    is(url, "chrome://mochitests/content/chrome/toolkit/devtools/server/tests/" +
+            "mochitest/test.png?id=4#wow");
+    runNextTest();
+  });
+});
+
+addTest(function testLargeImage() {
+  info("Resolve an absolute URL providing a context node");
+  let node = gDoc.querySelector(".big-horizontal");
+  gInspector.resolveRelativeURL("chrome://mochitests/content/chrome/toolkit/" +
+                                "devtools/server/", node).then(url => {
+    is(url, "chrome://mochitests/content/chrome/toolkit/devtools/server/");
+    runNextTest();
+  });
+});
+
+addTest(function cleanup() {
+  gInspector = gDoc = null;
+  runNextTest();
+});
+  </script>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=921102">Mozilla Bug 921102</a>
+<a id="inspectorContent" target="_blank" href="inspector_getImageData.html">Test Document</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+</body>
+</html>
