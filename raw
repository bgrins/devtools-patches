diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/inspector/breadcrumbs.js
--- a/browser/devtools/inspector/breadcrumbs.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/inspector/breadcrumbs.js	Thu Apr 09 14:59:51 2015 +0200
@@ -1,84 +1,71 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 const {Cc, Cu, Ci} = require("chrome");
-
-const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
-const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
-
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
+const {Promise: promise} = require("resource://gre/modules/Promise.jsm");
+XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
+  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
+});
+
+const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
+const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 const MAX_LABEL_LENGTH = 40;
-
-let promise = require("resource://gre/modules/Promise.jsm").Promise;
-
 const LOW_PRIORITY_ELEMENTS = {
   "HEAD": true,
   "BASE": true,
   "BASEFONT": true,
   "ISINDEX": true,
   "LINK": true,
   "META": true,
   "SCRIPT": true,
   "STYLE": true,
   "TITLE": true,
 };
 
-function resolveNextTick(value) {
-  let deferred = promise.defer();
-  Services.tm.mainThread.dispatch(() => {
-    try {
-      deferred.resolve(value);
-    } catch(ex) {
-      console.error(ex);
-    }
-  }, Ci.nsIThread.DISPATCH_NORMAL);
-  return deferred.promise;
-}
-
-///////////////////////////////////////////////////////////////////////////
-//// HTML Breadcrumbs
-
 /**
  * Display the ancestors of the current node and its children.
  * Only one "branch" of children are displayed (only one line).
  *
  * FIXME: Bug 822388 - Use the BreadcrumbsWidget in the Inspector.
  *
  * Mechanism:
- * . If no nodes displayed yet:
- *    then display the ancestor of the selected node and the selected node;
+ * - If no nodes displayed yet:
+ *   then display the ancestor of the selected node and the selected node;
  *   else select the node;
- * . If the selected node is the last node displayed, append its first (if any).
+ * - If the selected node is the last node displayed, append its first (if any).
+ *
+ * @param {InspectorPanel} inspector The inspector hosting this widget.
  */
-function HTMLBreadcrumbs(aInspector)
-{
-  this.inspector = aInspector;
+function HTMLBreadcrumbs(inspector) {
+  this.inspector = inspector;
   this.selection = this.inspector.selection;
   this.chromeWin = this.inspector.panelWin;
   this.chromeDoc = this.inspector.panelDoc;
   this.DOMHelpers = new DOMHelpers(this.chromeWin);
   this._init();
 }
 
 exports.HTMLBreadcrumbs = HTMLBreadcrumbs;
 
 HTMLBreadcrumbs.prototype = {
   get walker() this.inspector.walker,
 
-  _init: function BC__init()
-  {
+  _init: function() {
     this.container = this.chromeDoc.getElementById("inspector-breadcrumbs");
 
     // These separators are used for CSS purposes only, and are positioned
     // off screen, but displayed with -moz-element.
     this.separators = this.chromeDoc.createElement("box");
     this.separators.className = "breadcrumb-separator-container";
     this.separators.innerHTML =
                       "<box id='breadcrumb-separator-before'></box>" +
@@ -134,98 +121,94 @@ HTMLBreadcrumbs.prototype = {
         return promise.reject("selection-changed");
       }
       return result;
     }
   },
 
   /**
    * Warn if rejection was caused by selection change, print an error otherwise.
+   * @param {Error} err
    */
   selectionGuardEnd: function(err) {
     if (err === "selection-changed") {
       console.warn("Asynchronous operation was aborted as selection changed.");
     } else {
       console.error(err);
     }
   },
 
   /**
    * Build a string that represents the node: tagName#id.class1.class2.
-   *
-   * @param aNode The node to pretty-print
-   * @returns a string
+   * @param {NodeFront} node The node to pretty-print
+   * @return {String}
    */
-  prettyPrintNodeAsText: function BC_prettyPrintNodeText(aNode)
-  {
-    let text = aNode.tagName.toLowerCase();
-    if (aNode.isPseudoElement) {
-      text = aNode.isBeforePseudoElement ? "::before" : "::after";
+  prettyPrintNodeAsText: function(node) {
+    let text = node.tagName.toLowerCase();
+    if (node.isPseudoElement) {
+      text = node.isBeforePseudoElement ? "::before" : "::after";
     }
 
-    if (aNode.id) {
-      text += "#" + aNode.id;
+    if (node.id) {
+      text += "#" + node.id;
     }
 
-    if (aNode.className) {
-      let classList = aNode.className.split(/\s+/);
+    if (node.className) {
+      let classList = node.className.split(/\s+/);
       for (let i = 0; i < classList.length; i++) {
         text += "." + classList[i];
       }
     }
 
-    for (let pseudo of aNode.pseudoClassLocks) {
+    for (let pseudo of node.pseudoClassLocks) {
       text += pseudo;
     }
 
     return text;
   },
 
-
   /**
    * Build <label>s that represent the node:
    *   <label class="breadcrumbs-widget-item-tag">tagName</label>
    *   <label class="breadcrumbs-widget-item-id">#id</label>
    *   <label class="breadcrumbs-widget-item-classes">.class1.class2</label>
-   *
-   * @param aNode The node to pretty-print
-   * @returns a document fragment.
+   * @param {NodeFront} node The node to pretty-print
+   * @returns {DocumentFragment}
    */
-  prettyPrintNodeAsXUL: function BC_prettyPrintNodeXUL(aNode)
-  {
+  prettyPrintNodeAsXUL: function(node) {
     let fragment = this.chromeDoc.createDocumentFragment();
 
     let tagLabel = this.chromeDoc.createElement("label");
     tagLabel.className = "breadcrumbs-widget-item-tag plain";
 
     let idLabel = this.chromeDoc.createElement("label");
     idLabel.className = "breadcrumbs-widget-item-id plain";
 
     let classesLabel = this.chromeDoc.createElement("label");
     classesLabel.className = "breadcrumbs-widget-item-classes plain";
 
     let pseudosLabel = this.chromeDoc.createElement("label");
     pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";
 
-    let tagText = aNode.tagName.toLowerCase();
-    if (aNode.isPseudoElement) {
-      tagText = aNode.isBeforePseudoElement ? "::before" : "::after";
+    let tagText = node.tagName.toLowerCase();
+    if (node.isPseudoElement) {
+      tagText = node.isBeforePseudoElement ? "::before" : "::after";
     }
-    let idText = aNode.id ? ("#" + aNode.id) : "";
+    let idText = node.id ? ("#" + node.id) : "";
     let classesText = "";
 
-    if (aNode.className) {
-      let classList = aNode.className.split(/\s+/);
+    if (node.className) {
+      let classList = node.className.split(/\s+/);
       for (let i = 0; i < classList.length; i++) {
         classesText += "." + classList[i];
       }
     }
 
     // XXX: Until we have pseudoclass lock in the node.
-    for (let pseudo of aNode.pseudoClassLocks) {
+    for (let pseudo of node.pseudoClassLocks) {
 
     }
 
     // Figure out which element (if any) needs ellipsing.
     // Substring for that element, then clear out any extras
     // (except for pseudo elements).
     let maxTagLength = MAX_LABEL_LENGTH;
     let maxIdLength = MAX_LABEL_LENGTH - tagText.length;
@@ -239,340 +222,345 @@ HTMLBreadcrumbs.prototype = {
        classesText = "";
     } else if (classesText.length > maxClassLength) {
       classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
     }
 
     tagLabel.textContent = tagText;
     idLabel.textContent = idText;
     classesLabel.textContent = classesText;
-    pseudosLabel.textContent = aNode.pseudoClassLocks.join("");
+    pseudosLabel.textContent = node.pseudoClassLocks.join("");
 
     fragment.appendChild(tagLabel);
     fragment.appendChild(idLabel);
     fragment.appendChild(classesLabel);
     fragment.appendChild(pseudosLabel);
 
     return fragment;
   },
 
   /**
    * Open the sibling menu.
-   *
-   * @param aButton the button representing the node.
-   * @param aNode the node we want the siblings from.
+   * @param {DOMNode} button the button representing the node.
+   * @param {NodeFront} node the node we want the siblings from.
    */
-  openSiblingMenu: function BC_openSiblingMenu(aButton, aNode)
-  {
+  openSiblingMenu: function(button, node) {
     // We make sure that the targeted node is selected
     // because we want to use the nodemenu that only works
     // for inspector.selection
-    this.selection.setNodeFront(aNode, "breadcrumbs");
+    this.selection.setNodeFront(node, "breadcrumbs");
 
     let title = this.chromeDoc.createElement("menuitem");
     title.setAttribute("label", this.inspector.strings.GetStringFromName("breadcrumbs.siblings"));
     title.setAttribute("disabled", "true");
 
     let separator = this.chromeDoc.createElement("menuseparator");
 
     let items = [title, separator];
 
-    this.walker.siblings(aNode, {
+    this.walker.siblings(node, {
       whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
     }).then(siblings => {
       let nodes = siblings.nodes;
       for (let i = 0; i < nodes.length; i++) {
         let item = this.chromeDoc.createElement("menuitem");
-        if (nodes[i] === aNode) {
+        if (nodes[i] === node) {
           item.setAttribute("disabled", "true");
           item.setAttribute("checked", "true");
         }
 
         item.setAttribute("type", "radio");
         item.setAttribute("label", this.prettyPrintNodeAsText(nodes[i]));
 
         let selection = this.selection;
-        item.onmouseup = (function(aNode) {
+        item.onmouseup = (function(node) {
           return function() {
-            selection.setNodeFront(aNode, "breadcrumbs");
+            selection.setNodeFront(node, "breadcrumbs");
           }
         })(nodes[i]);
 
         items.push(item);
-        this.inspector.showNodeMenu(aButton, "before_start", items);
+        this.inspector.showNodeMenu(button, "before_start", items);
       }
     });
   },
 
   /**
    * Generic event handler.
-   *
-   * @param nsIDOMEvent event
-   *        The DOM event object.
+   * @param {DOMEvent} event.
    */
-  handleEvent: function BC_handleEvent(event)
-  {
+  handleEvent: function(event) {
     if (event.type == "mousedown" && event.button == 0) {
-      // on Click and Hold, open the Siblings menu
-
-      let timer;
-      let container = this.container;
-
-      function openMenu(event) {
-        cancelHold();
-        let target = event.originalTarget;
-        if (target.tagName == "button") {
-          target.onBreadcrumbsHold();
-        }
-      }
-
-      function handleClick(event) {
-        cancelHold();
-        let target = event.originalTarget;
-        if (target.tagName == "button") {
-          target.onBreadcrumbsClick();
-        }
-      }
-
-      let window = this.chromeWin;
-      function cancelHold(event) {
-        window.clearTimeout(timer);
-        container.removeEventListener("mouseout", cancelHold, false);
-        container.removeEventListener("mouseup", handleClick, false);
-      }
-
-      container.addEventListener("mouseout", cancelHold, false);
-      container.addEventListener("mouseup", handleClick, false);
-      timer = window.setTimeout(openMenu, 500, event);
-    }
-
-    if (event.type == "keypress" && this.selection.isElementNode()) {
-      let node = null;
-
-
-      this._keyPromise = this._keyPromise || promise.resolve(null);
-
-      this._keyPromise = (this._keyPromise || promise.resolve(null)).then(() => {
-        switch (event.keyCode) {
-          case this.chromeWin.KeyEvent.DOM_VK_LEFT:
-            if (this.currentIndex != 0) {
-              node = promise.resolve(this.nodeHierarchy[this.currentIndex - 1].node);
-            }
-            break;
-          case this.chromeWin.KeyEvent.DOM_VK_RIGHT:
-            if (this.currentIndex < this.nodeHierarchy.length - 1) {
-              node = promise.resolve(this.nodeHierarchy[this.currentIndex + 1].node);
-            }
-            break;
-          case this.chromeWin.KeyEvent.DOM_VK_UP:
-            node = this.walker.previousSibling(this.selection.nodeFront, {
-              whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-            });
-            break;
-          case this.chromeWin.KeyEvent.DOM_VK_DOWN:
-            node = this.walker.nextSibling(this.selection.nodeFront, {
-              whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
-            });
-            break;
-        }
-
-        return node.then((node) => {
-          if (node) {
-            this.selection.setNodeFront(node, "breadcrumbs");
-          }
-        });
-      });
-      event.preventDefault();
-      event.stopPropagation();
-    }
-
-    if (event.type == "mouseover") {
-      let target = event.originalTarget;
-      if (target.tagName == "button") {
-        target.onBreadcrumbsHover();
-      }
-    }
-
-    if (event.type == "mouseleave") {
-      this.inspector.toolbox.highlighterUtils.unhighlight();
+      this.handleMouseDown(event);
+    } else if (event.type == "keypress" && this.selection.isElementNode()) {
+      this.handleKeyPress(event);
+    } else if (event.type == "mouseover") {
+      this.handleMouseOver(event);
+    } else if (event.type == "mouseleave") {
+      this.handleMouseLeave(event);
     }
   },
 
   /**
-   * Remove nodes and delete properties.
+   * On click and hold, open the siblings menu.
+   * @param {DOMEvent} event.
    */
-  destroy: function BC_destroy()
-  {
+  handleMouseDown: function(event) {
+    let timer;
+    let container = this.container;
+
+    function openMenu(event) {
+      cancelHold();
+      let target = event.originalTarget;
+      if (target.tagName == "button") {
+        target.onBreadcrumbsHold();
+      }
+    }
+
+    function handleClick(event) {
+      cancelHold();
+      let target = event.originalTarget;
+      if (target.tagName == "button") {
+        target.onBreadcrumbsClick();
+      }
+    }
+
+    let window = this.chromeWin;
+    function cancelHold(event) {
+      window.clearTimeout(timer);
+      container.removeEventListener("mouseout", cancelHold, false);
+      container.removeEventListener("mouseup", handleClick, false);
+    }
+
+    container.addEventListener("mouseout", cancelHold, false);
+    container.addEventListener("mouseup", handleClick, false);
+    timer = window.setTimeout(openMenu, 500, event);
+  },
+
+  /**
+   * On mouse over, highlight the corresponding content DOM Node.
+   * @param {DOMEvent} event.
+   */
+  handleMouseOver: function(event) {
+    let target = event.originalTarget;
+    if (target.tagName == "button") {
+      target.onBreadcrumbsHover();
+    }
+  },
+
+  /**
+   * On mouse leave, make sure to unhighlight.
+   * @param {DOMEvent} event.
+   */
+  handleMouseLeave: function(event) {
+    this.inspector.toolbox.highlighterUtils.unhighlight();
+  },
+
+  /**
+   * On key press, navigate the node hierarchy.
+   * @param {DOMEvent} event.
+   */
+  handleKeyPress: function(event) {
+    let node = null;
+    this._keyPromise = this._keyPromise || promise.resolve(null);
+
+    this._keyPromise = (this._keyPromise || promise.resolve(null)).then(() => {
+      switch (event.keyCode) {
+        case this.chromeWin.KeyEvent.DOM_VK_LEFT:
+          if (this.currentIndex != 0) {
+            node = promise.resolve(this.nodeHierarchy[this.currentIndex - 1].node);
+          }
+          break;
+        case this.chromeWin.KeyEvent.DOM_VK_RIGHT:
+          if (this.currentIndex < this.nodeHierarchy.length - 1) {
+            node = promise.resolve(this.nodeHierarchy[this.currentIndex + 1].node);
+          }
+          break;
+        case this.chromeWin.KeyEvent.DOM_VK_UP:
+          node = this.walker.previousSibling(this.selection.nodeFront, {
+            whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
+          });
+          break;
+        case this.chromeWin.KeyEvent.DOM_VK_DOWN:
+          node = this.walker.nextSibling(this.selection.nodeFront, {
+            whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
+          });
+          break;
+      }
+
+      return node.then((node) => {
+        if (node) {
+          this.selection.setNodeFront(node, "breadcrumbs");
+        }
+      });
+    });
+    event.preventDefault();
+    event.stopPropagation();
+  },
+
+  /**
+   * Remove nodes and clean up.
+   */
+  destroy: function() {
     this.selection.off("new-node-front", this.update);
     this.selection.off("pseudoclass", this.updateSelectors);
     this.selection.off("attribute-changed", this.updateSelectors);
     this.inspector.off("markupmutation", this.update);
 
     this.container.removeEventListener("underflow", this.onscrollboxreflow, false);
     this.container.removeEventListener("overflow", this.onscrollboxreflow, false);
-    this.onscrollboxreflow = null;
-
-    this.empty();
     this.container.removeEventListener("mousedown", this, true);
     this.container.removeEventListener("keypress", this, true);
     this.container.removeEventListener("mouseover", this, true);
     this.container.removeEventListener("mouseleave", this, true);
+
+    this.empty();
+    this.separators.remove();
+
+    this.onscrollboxreflow = null;
     this.container = null;
-
-    this.separators.remove();
     this.separators = null;
-
     this.nodeHierarchy = null;
 
     this.isDestroyed = true;
   },
 
   /**
    * Empty the breadcrumbs container.
    */
-  empty: function BC_empty()
-  {
+  empty: function() {
     while (this.container.hasChildNodes()) {
-      this.container.removeChild(this.container.firstChild);
+      this.container.firstChild.remove();
     }
   },
 
   /**
    * Set which button represent the selected node.
-   *
-   * @param aIdx Index of the displayed-button to select
+   * @param {Number} index Index of the displayed-button to select.
    */
-  setCursor: function BC_setCursor(aIdx)
-  {
+  setCursor: function(index) {
     // Unselect the previously selected button
     if (this.currentIndex > -1 && this.currentIndex < this.nodeHierarchy.length) {
       this.nodeHierarchy[this.currentIndex].button.removeAttribute("checked");
     }
-    if (aIdx > -1) {
-      this.nodeHierarchy[aIdx].button.setAttribute("checked", "true");
+    if (index > -1) {
+      this.nodeHierarchy[index].button.setAttribute("checked", "true");
       if (this.hadFocus)
-        this.nodeHierarchy[aIdx].button.focus();
+        this.nodeHierarchy[index].button.focus();
     }
-    this.currentIndex = aIdx;
+    this.currentIndex = index;
   },
 
   /**
    * Get the index of the node in the cache.
-   *
-   * @param aNode
-   * @returns integer the index, -1 if not found
+   * @param {NodeFront} node.
+   * @returns {Number} The index for this node or -1 if not found.
    */
-  indexOf: function BC_indexOf(aNode)
-  {
+  indexOf: function(node) {
     let i = this.nodeHierarchy.length - 1;
     for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
-      if (this.nodeHierarchy[i].node === aNode) {
+      if (this.nodeHierarchy[i].node === node) {
         return i;
       }
     }
     return -1;
   },
 
   /**
-   * Remove all the buttons and their references in the cache
-   * after a given index.
-   *
-   * @param aIdx
+   * Remove all the buttons and their references in the cache after a given
+   * index.
+   * @param {Number} index.
    */
-  cutAfter: function BC_cutAfter(aIdx)
-  {
-    while (this.nodeHierarchy.length > (aIdx + 1)) {
+  cutAfter: function(index) {
+    while (this.nodeHierarchy.length > (index + 1)) {
       let toRemove = this.nodeHierarchy.pop();
       this.container.removeChild(toRemove.button);
     }
   },
 
   /**
    * Build a button representing the node.
-   *
-   * @param aNode The node from the page.
-   * @returns aNode The <button>.
+   * @param {NodeFront} node The node from the page.
+   * @return {DOMNode} The <button> for this node.
    */
-  buildButton: function BC_buildButton(aNode)
-  {
+  buildButton: function(node) {
     let button = this.chromeDoc.createElement("button");
-    button.appendChild(this.prettyPrintNodeAsXUL(aNode));
+    button.appendChild(this.prettyPrintNodeAsXUL(node));
     button.className = "breadcrumbs-widget-item";
 
-    button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(aNode));
+    button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(node));
 
     button.onkeypress = function onBreadcrumbsKeypress(e) {
       if (e.charCode == Ci.nsIDOMKeyEvent.DOM_VK_SPACE ||
           e.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN)
         button.click();
     }
 
     button.onBreadcrumbsClick = () => {
-      this.selection.setNodeFront(aNode, "breadcrumbs");
+      this.selection.setNodeFront(node, "breadcrumbs");
     };
 
     button.onBreadcrumbsHover = () => {
-      this.inspector.toolbox.highlighterUtils.highlightNodeFront(aNode);
+      this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
     };
 
     button.onclick = (function _onBreadcrumbsRightClick(event) {
       button.focus();
       if (event.button == 2) {
-        this.openSiblingMenu(button, aNode);
+        this.openSiblingMenu(button, node);
       }
     }).bind(this);
 
     button.onBreadcrumbsHold = (function _onBreadcrumbsHold() {
-      this.openSiblingMenu(button, aNode);
+      this.openSiblingMenu(button, node);
     }).bind(this);
     return button;
   },
 
   /**
    * Connecting the end of the breadcrumbs to a node.
-   *
-   * @param aNode The node to reach.
+   * @param {NodeFront} node The node to reach.
    */
-  expand: function BC_expand(aNode)
-  {
-      let fragment = this.chromeDoc.createDocumentFragment();
-      let toAppend = aNode;
-      let lastButtonInserted = null;
-      let originalLength = this.nodeHierarchy.length;
-      let stopNode = null;
-      if (originalLength > 0) {
-        stopNode = this.nodeHierarchy[originalLength - 1].node;
+  expand: function(node) {
+    let fragment = this.chromeDoc.createDocumentFragment();
+    let lastButtonInserted = null;
+    let originalLength = this.nodeHierarchy.length;
+    let stopNode = null;
+    if (originalLength > 0) {
+      stopNode = this.nodeHierarchy[originalLength - 1].node;
+    }
+    while (node && node != stopNode) {
+      if (node.tagName) {
+        let button = this.buildButton(node);
+        fragment.insertBefore(button, lastButtonInserted);
+        lastButtonInserted = button;
+        this.nodeHierarchy.splice(originalLength, 0, {
+          node,
+          button,
+          currentPrettyPrintText: this.prettyPrintNodeAsText(node)
+        });
       }
-      while (toAppend && toAppend != stopNode) {
-        if (toAppend.tagName) {
-          let button = this.buildButton(toAppend);
-          fragment.insertBefore(button, lastButtonInserted);
-          lastButtonInserted = button;
-          this.nodeHierarchy.splice(originalLength, 0, {node: toAppend, button: button});
-        }
-        toAppend = toAppend.parentNode();
-      }
-      this.container.appendChild(fragment, this.container.firstChild);
+      node = node.parentNode();
+    }
+    this.container.appendChild(fragment, this.container.firstChild);
   },
 
   /**
-   * Get a child of a node that can be displayed in the breadcrumbs
-   * and that is probably visible. See LOW_PRIORITY_ELEMENTS.
-   *
-   * @param aNode The parent node.
-   * @returns nsIDOMNode|null
+   * Get a child of a node that can be displayed in the breadcrumbs and that is
+   * probably visible. See LOW_PRIORITY_ELEMENTS.
+   * @param {NodeFront} node The parent node.
+   * @return {Promise} Resolves to the NodeFront.
    */
-  getInterestingFirstNode: function BC_getInterestingFirstNode(aNode)
-  {
+  getInterestingFirstNode: function(node) {
     let deferred = promise.defer();
 
-    var fallback = null;
+    let fallback = null;
 
-    var moreChildren = () => {
-      this.walker.children(aNode, {
+    let moreChildren = () => {
+      this.walker.children(node, {
         start: fallback,
         maxNodes: 10,
         whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
       }).then(this.selectionGuard()).then(response => {
         for (let node of response.nodes) {
           if (!(node.tagName in LOW_PRIORITY_ELEMENTS)) {
             deferred.resolve(node);
             return;
@@ -583,47 +571,45 @@ HTMLBreadcrumbs.prototype = {
         }
         if (response.hasLast) {
           deferred.resolve(fallback);
           return;
         } else {
           moreChildren();
         }
       }).then(null, this.selectionGuardEnd);
-    }
+    };
+
     moreChildren();
     return deferred.promise;
   },
 
   /**
    * Find the "youngest" ancestor of a node which is already in the breadcrumbs.
-   *
-   * @param aNode
-   * @returns Index of the ancestor in the cache
+   * @param {NodeFront} node.
+   * @return {Number} Index of the ancestor in the cache, or -1 if not found.
    */
-  getCommonAncestor: function BC_getCommonAncestor(aNode)
-  {
-    let node = aNode;
+  getCommonAncestor: function(node) {
     while (node) {
       let idx = this.indexOf(node);
       if (idx > -1) {
         return idx;
       } else {
         node = node.parentNode();
       }
     }
     return -1;
   },
 
   /**
    * Make sure that the latest node in the breadcrumbs is not the selected node
    * if the selected node still has children.
+   * @return {Promise}
    */
-  ensureFirstChild: function BC_ensureFirstChild()
-  {
+  ensureFirstChild: function() {
     // If the last displayed node is the selected node
     if (this.currentIndex == this.nodeHierarchy.length - 1) {
       let node = this.nodeHierarchy[this.currentIndex].node;
       return this.getInterestingFirstNode(node).then(child => {
         // If the node has a child and we've not been destroyed in the meantime
         if (child && !this.isDestroyed) {
           // Show this child
           this.expand(child);
@@ -632,62 +618,111 @@ HTMLBreadcrumbs.prototype = {
     }
 
     return resolveNextTick(true);
   },
 
   /**
    * Ensure the selected node is visible.
    */
-  scroll: function BC_scroll()
-  {
+  scroll: function() {
     // FIXME bug 684352: make sure its immediate neighbors are visible too.
 
     let scrollbox = this.container;
     let element = this.nodeHierarchy[this.currentIndex].button;
 
     // Repeated calls to ensureElementIsVisible would interfere with each other
     // and may sometimes result in incorrect scroll positions.
     this.chromeWin.clearTimeout(this._ensureVisibleTimeout);
     this._ensureVisibleTimeout = this.chromeWin.setTimeout(function() {
       scrollbox.ensureElementIsVisible(element);
     }, ENSURE_SELECTION_VISIBLE_DELAY);
   },
 
-  updateSelectors: function BC_updateSelectors()
-  {
+  /**
+   * Update all button outputs.
+   */
+  updateSelectors: function() {
     if (this.isDestroyed) {
       return;
     }
 
     for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
-      let crumb = this.nodeHierarchy[i];
-      let button = crumb.button;
+      let {node, button, currentPrettyPrintText} = this.nodeHierarchy[i];
 
-      while(button.hasChildNodes()) {
-        button.removeChild(button.firstChild);
+      // If the output of the node doesn't change, skip the update.
+      let textOutput = this.prettyPrintNodeAsText(node);
+      if (currentPrettyPrintText === textOutput) {
+        continue;
       }
-      button.appendChild(this.prettyPrintNodeAsXUL(crumb.node));
-      button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(crumb.node));
+
+      // Otherwise, update the whole markup for the button.
+      while (button.hasChildNodes()) {
+        button.firstChild.remove();
+      }
+      button.appendChild(this.prettyPrintNodeAsXUL(node));
+      button.setAttribute("tooltiptext", textOutput);
+
+      this.nodeHierarchy[i].currentPrettyPrintText = textOutput;
     }
   },
 
   /**
+   * Given a list of mutation changes (passed by the markupmutation event),
+   * decide whether or not they are "interesting" to the current state of the
+   * breadcrumbs widget, i.e. at least one of them should cause part of the
+   * widget to be updated.
+   * @param {Array} mutations The mutations array.
+   * @return {Boolean}
+   */
+  _hasInterestingMutations: function(mutations) {
+    if (!mutations || !mutations.length) {
+      return false;
+    }
+
+    for (let {type, added, removed, target, attributeName} of mutations) {
+      if (type === "childList") {
+        // Only interested in childList mutations if the added or removed
+        // nodes are currently displayed, or if it impacts the last element in
+        // the breadcrumbs.
+        return added.some(node => this.indexOf(node) > -1) ||
+               removed.some(node => this.indexOf(node) > -1) ||
+               this.indexOf(target) === this.nodeHierarchy.length - 1;
+      } else if (type === "attributes" && this.indexOf(target) > -1) {
+        // Only interested in attributes mutations if the target is
+        // currently displayed, and the attribute is either id or class.
+        return attributeName === "class" || attributeName === "id";
+      }
+    }
+
+    // Catch all return in case the mutations array was empty, or in case none
+    // of the changes iterated above were interesting.
+    return false;
+  },
+
+  /**
    * Update the breadcrumbs display when a new node is selected.
+   * @param {String} reason The reason for the update, if any.
+   * @param {Array} mutations An array of mutations in case this was called as
+   * the "markupmutation" event listener.
    */
-  update: function BC_update(reason)
-  {
+  update: function(reason, mutations) {
     if (this.isDestroyed) {
       return;
     }
 
     if (reason !== "markupmutation") {
       this.inspector.hideNodeMenu();
     }
 
+    let hasInterestingMutations = this._hasInterestingMutations(mutations);
+    if (reason === "markupmutation" && !hasInterestingMutations) {
+      return;
+    }
+
     let cmdDispatcher = this.chromeDoc.commandDispatcher;
     this.hadFocus = (cmdDispatcher.focusedElement &&
                      cmdDispatcher.focusedElement.parentNode == this.container);
 
     if (!this.selection.isConnected()) {
       this.cutAfter(-1); // remove all the crumbs
       return;
     }
@@ -696,17 +731,17 @@ HTMLBreadcrumbs.prototype = {
       this.setCursor(-1); // no selection
       return;
     }
 
     let idx = this.indexOf(this.selection.nodeFront);
 
     // Is the node already displayed in the breadcrumbs?
     // (and there are no mutations that need re-display of the crumbs)
-    if (idx > -1 && reason !== "markupmutation") {
+    if (idx > -1 && !hasInterestingMutations) {
       // Yes. We select it.
       this.setCursor(idx);
     } else {
       // No. Is the breadcrumbs display empty?
       if (this.nodeHierarchy.length > 0) {
         // No. We drop all the element that are not direct ancestors
         // of the selection
         let parent = this.selection.nodeFront.parentNode();
@@ -739,11 +774,22 @@ HTMLBreadcrumbs.prototype = {
       });
     }).then(null, err => {
       doneUpdating(this.selection.nodeFront);
       this.selectionGuardEnd(err);
     });
   }
 };
 
-XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
-  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
-});
+/**
+ * Returns a promise that resolves at the next main thread tick.
+ */
+function resolveNextTick(value) {
+  let deferred = promise.defer();
+  Services.tm.mainThread.dispatch(() => {
+    try {
+      deferred.resolve(value);
+    } catch(e) {
+      deferred.reject(e);
+    }
+  }, Ci.nsIThread.DISPATCH_NORMAL);
+  return deferred.promise;
+}
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/inspector/test/browser.ini
--- a/browser/devtools/inspector/test/browser.ini	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/inspector/test/browser.ini	Thu Apr 09 14:59:51 2015 +0200
@@ -24,16 +24,17 @@ support-files =
   doc_inspector_search.html
   doc_inspector_search-suggestions.html
   doc_inspector_select-last-selected-01.html
   doc_inspector_select-last-selected-02.html
   head.js
 
 [browser_inspector_breadcrumbs.js]
 [browser_inspector_breadcrumbs_highlight_hover.js]
+[browser_inspector_breadcrumbs_mutations.js]
 [browser_inspector_delete-selected-node-01.js]
 [browser_inspector_delete-selected-node-02.js]
 [browser_inspector_delete-selected-node-03.js]
 [browser_inspector_destroy-after-navigation.js]
 [browser_inspector_destroy-before-ready.js]
 [browser_inspector_gcli-inspect-command.js]
 skip-if = e10s # GCLI isn't e10s compatible. See bug 1128988.
 [browser_inspector_highlighter-01.js]
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/inspector/test/browser_inspector_breadcrumbs_mutations.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/devtools/inspector/test/browser_inspector_breadcrumbs_mutations.js	Thu Apr 09 14:59:51 2015 +0200
@@ -0,0 +1,193 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Test that the breadcrumbs widget refreshes correctly when there are markup
+// mutations (and that it doesn't refresh when those mutations don't change its
+// output).
+
+const TEST_URI = TEST_URL_ROOT + "doc_inspector_breadcrumbs.html";
+
+// Each item in the TEST_DATA array is a test case that should contain the
+// following properties:
+// - desc {String} A description of this test case (will be logged).
+// - setup {Function*} A generator function (can yield promises) that sets up
+//   the test case. Useful for selecting a node before starting the test.
+// - run {Function*} A generator function (can yield promises) that runs the
+//   actual test case, i.e, mutates the content DOM to cause the breadcrumbs
+//   to refresh, or not.
+// - shouldRefresh {Boolean} Once the `run` function has completed, and the test
+//   has detected that the page has changed, this boolean instructs the test to
+//   verify if the breadcrumbs has refreshed or not.
+// - output {Array} A list of strings for the text that should be found in each
+//   button after the test has run.
+const TEST_DATA = [{
+  desc: "Adding a child at the end of the chain should refresh and show it",
+  setup: function*(inspector) {
+    yield selectNode("#i1111", inspector);
+  },
+  run: function*({walker, selection}) {
+    yield walker.setInnerHTML(selection.nodeFront, "<b>test</b>");
+  },
+  shouldRefresh: true,
+  output: ["html", "body", "article#i1", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Updating an ID to an displayed element should refresh",
+  setup: function*() {},
+  run: function*({walker}) {
+    let node = yield walker.querySelector(walker.rootNode, "#i1");
+    yield node.modifyAttributes([{
+      attributeName: "id",
+      newValue: "i1-changed"
+    }]);
+  },
+  shouldRefresh: true,
+  output: ["html", "body", "article#i1-changed", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Updating an class to a displayed element should refresh",
+  setup: function*() {},
+  run: function*({walker}) {
+    let node = yield walker.querySelector(walker.rootNode, "body");
+    yield node.modifyAttributes([{
+      attributeName: "class",
+      newValue: "test-class"
+    }]);
+  },
+  shouldRefresh: true,
+  output: ["html", "body.test-class", "article#i1-changed", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Updating a non id/class attribute to a displayed element should not refresh",
+  setup: function*() {},
+  run: function*({walker}) {
+    let node = yield walker.querySelector(walker.rootNode, "#i11");
+    yield node.modifyAttributes([{
+      attributeName: "name",
+      newValue: "value"
+    }]);
+  },
+  shouldRefresh: false,
+  output: ["html", "body.test-class", "article#i1-changed", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Moving a child in an element that's not displayed should not refresh",
+  setup: function*() {},
+  run: function*({walker}) {
+    // Re-append #i1211 as a last child of #i2.
+    let parent = yield walker.querySelector(walker.rootNode, "#i2");
+    let child = yield walker.querySelector(walker.rootNode, "#i211");
+    yield walker.insertBefore(child, parent);
+  },
+  shouldRefresh: false,
+  output: ["html", "body.test-class", "article#i1-changed", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Moving an undisplayed child in a displayed element should not refresh",
+  setup: function*() {},
+  run: function*({walker}) {
+    // Re-append #i2 in body (move it to the end).
+    let parent = yield walker.querySelector(walker.rootNode, "body");
+    let child = yield walker.querySelector(walker.rootNode, "#i2");
+    yield walker.insertBefore(child, parent);
+  },
+  shouldRefresh: false,
+  output: ["html", "body.test-class", "article#i1-changed", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Updating attributes on an element that's not displayed should not refresh",
+  setup: function*() {},
+  run: function*({walker}) {
+    let node = yield walker.querySelector(walker.rootNode, "#i2");
+    yield node.modifyAttributes([{
+      attributeName: "id",
+      newValue: "i2-changed"
+    }, {
+      attributeName: "class",
+      newValue: "test-class"
+    }]);
+  },
+  shouldRefresh: false,
+  output: ["html", "body.test-class", "article#i1-changed", "div#i11", "div#i111", "div#i1111", "b"]
+}, {
+  desc: "Removing the currently selected node should refresh",
+  setup: function*(inspector) {
+    yield selectNode("#i2-changed", inspector);
+  },
+  run: function*({walker, selection}) {
+    yield walker.removeNode(selection.nodeFront);
+  },
+  shouldRefresh: true,
+  output: ["html", "body.test-class", "article#i1-changed"]
+}, {
+  desc: "Changing the class of the currently selected node should refresh",
+  setup: function*() {},
+  run: function*({selection}) {
+    yield selection.nodeFront.modifyAttributes([{
+      attributeName: "class",
+      newValue: "test-class-changed"
+    }]);
+  },
+  shouldRefresh: true,
+  output: ["html", "body.test-class-changed", "article#i1-changed"]
+}, {
+  desc: "Changing the id of the currently selected node should refresh",
+  setup: function*() {},
+  run: function*({selection}) {
+    yield selection.nodeFront.modifyAttributes([{
+      attributeName: "id",
+      newValue: "new-id"
+    }]);
+  },
+  shouldRefresh: true,
+  output: ["html", "body#new-id.test-class-changed", "article#i1-changed"]
+}];
+
+add_task(function*() {
+  let {inspector} = yield openInspectorForURL(TEST_URI);
+  let container = inspector.panelDoc.getElementById("inspector-breadcrumbs");
+  let win = container.ownerDocument.defaultView;
+
+  for (let {desc, setup, run, shouldRefresh, output} of TEST_DATA) {
+    info("Running test case: " + desc);
+
+    info("Listen to markupmutation events from the inspector to know when a " +
+         "test case has completed");
+    let onContentMutation = inspector.once("markupmutation");
+
+    info("Running setup");
+    yield setup(inspector);
+
+    info("Listen to mutations on the breadcrumbs container");
+    let hasBreadcrumbsMutated = false;
+    let observer = new win.MutationObserver(() => {
+      hasBreadcrumbsMutated = true;
+    });
+    observer.observe(container, {
+      attributes: true,
+      characterData: true,
+      childList: true,
+      subtree: true
+    });
+
+    info("Running the test case");
+    yield run(inspector);
+
+    info("Wait until the page has mutated");
+    yield onContentMutation;
+
+    if (shouldRefresh) {
+      info("The breadcrumbs is expected to refresh, so wait for it");
+      yield inspector.once("inspector-updated");
+    } else {
+      ok(!inspector._updateProgress,
+        "The breadcrumbs widget is not currently updating");
+    }
+
+    is(shouldRefresh, hasBreadcrumbsMutated, "Has the breadcrumbs refreshed?");
+    observer.disconnect();
+
+    info("Check the output of the breadcrumbs widget");
+    is(container.childNodes.length, output.length, "Correct number of buttons");
+    for (let i = 0; i < container.childNodes.length; i ++) {
+      is(output[i], container.childNodes[i].textContent,
+        "Text content for button " + i + " is correct");
+    }
+  }
+});
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/inspector/test/browser_inspector_highlighter-hover_01.js
--- a/browser/devtools/inspector/test/browser_inspector_highlighter-hover_01.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-hover_01.js	Thu Apr 09 14:59:51 2015 +0200
@@ -21,21 +21,19 @@ add_task(function*() {
 
   info("selecting the <p> line by clicking in the markup-view");
   yield clickContainer("p", inspector);
 
   p.textContent = "wait for it ....";
   info("wait and see if the highlighter stays visible even after the node was selected");
   yield waitForTheBrieflyShowBoxModelTimeout();
 
-  let updated = inspector.once("inspector-updated");
   p.textContent = "dary!!!!";
   isVisible = yield isHighlighting(toolbox);
   ok(isVisible, "the highlighter is still visible");
-  yield updated;
 });
 
 function waitForTheBrieflyShowBoxModelTimeout() {
   let deferred = promise.defer();
   // Note that the current timeout is 1 sec and is neither configurable nor
   // exported anywhere we can access, so hard-coding the timeout
   content.setTimeout(deferred.resolve, 1500);
   return deferred.promise;
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/layoutview/test/head.js
--- a/browser/devtools/layoutview/test/head.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/layoutview/test/head.js	Thu Apr 09 14:59:51 2015 +0200
@@ -219,26 +219,21 @@ let openLayoutView = Task.async(function
   return {
     toolbox: toolbox,
     inspector: inspector,
     view: inspector.sidebar.getWindowForTab("layoutview")["layoutview"]
   };
 });
 
 /**
- * Wait for the layoutview-updated event and for all of the inspector's panels
- * to update too.
- * Use this to make sure the inspector is updated and ready after a change was
- * made in one of the layout-view editable fields.
+ * Wait for the layoutview-updated event.
  * @return a promise
  */
 function waitForUpdate(inspector) {
-  let onLayoutView = inspector.once("layoutview-updated");
-  let onInspector = inspector.once("inspector-updated");
-  return promise.all([onLayoutView, onInspector]);
+  return inspector.once("layoutview-updated");
 }
 
 /**
  * The addTest/runTests function couple provides a simple way to define
  * subsequent test cases in a test file. Example:
  *
  * addTest("what this test does", function*() {
  *   ... actual code for the test ...
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/markupview/test/browser_markupview_css_completion_style_attribute.js
--- a/browser/devtools/markupview/test/browser_markupview_css_completion_style_attribute.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/markupview/test/browser_markupview_css_completion_style_attribute.js	Thu Apr 09 14:59:51 2015 +0200
@@ -79,18 +79,16 @@ add_task(function*() {
   for (let i = 0; i < TEST_DATA.length; i ++) {
     yield enterData(i, editor, inspector);
     yield checkData(i, editor, inspector);
   }
 
   while (inspector.markup.undo.canUndo()) {
     yield undoChange(inspector);
   }
-
-  yield inspector.once("inspector-updated");
 });
 
 function enterData(index, editor, inspector) {
   let [key] = TEST_DATA[index];
   info("Entering test data " + index + ": " + key + ", expecting: [" + TEST_DATA[index].slice(1) + "]");
 
   let def = promise.defer();
 
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/markupview/test/browser_markupview_mutation_01.js
--- a/browser/devtools/markupview/test/browser_markupview_mutation_01.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/markupview/test/browser_markupview_mutation_01.js	Thu Apr 09 14:59:51 2015 +0200
@@ -174,20 +174,19 @@ add_task(function*() {
 
   info("Expanding all markup-view nodes");
   yield inspector.markup.expandAll();
 
   for (let {desc, test, check} of TEST_DATA) {
     info("Starting test: " + desc);
 
     info("Executing the test markup mutation");
-    let onUpdated = inspector.once("inspector-updated");
     let onMutation = inspector.once("markupmutation");
     test();
-    yield onUpdated.then(onMutation);
+    yield onMutation;
 
     info("Expanding all markup-view nodes to make sure new nodes are imported");
     yield inspector.markup.expandAll();
 
     info("Checking the markup-view content");
     yield check(inspector);
   }
 });
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/markupview/test/browser_markupview_mutation_02.js
--- a/browser/devtools/markupview/test/browser_markupview_mutation_02.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/markupview/test/browser_markupview_mutation_02.js	Thu Apr 09 14:59:51 2015 +0200
@@ -81,34 +81,30 @@ add_task(function*() {
   info("Selecting the last element of the root node before starting");
   yield selectNode(".list .item:nth-child(2)", inspector);
 
   for (let {mutate, flashedNode, desc, attribute} of TEST_DATA) {
     info("Starting test: " + desc);
 
     info("Mutating the DOM and listening for markupmutation event");
     let mutated = inspector.once("markupmutation");
-    let updated = inspector.once("inspector-updated");
     mutate(content.document, rootNode);
     yield mutated;
 
     info("Asserting that the correct markup-container is flashing");
     let flashingNodeFront = rootNodeFront;
     if (flashedNode) {
       flashingNodeFront = yield getNodeFront(flashedNode, inspector);
     }
 
     if (attribute) {
       yield assertAttributeFlashing(flashingNodeFront, attribute, inspector);
     } else {
       yield assertNodeFlashing(flashingNodeFront, inspector);
     }
-
-    // Making sure the inspector has finished updating before moving on
-    yield updated;
   }
 });
 
 function* assertNodeFlashing(nodeFront, inspector) {
   let container = getContainerForNodeFront(nodeFront, inspector);
   ok(container, "Markup container for node found");
   ok(container.tagState.classList.contains("theme-bg-contrast"),
     "Markup container for node is flashing");
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/markupview/test/browser_markupview_textcontent_edit_01.js
--- a/browser/devtools/markupview/test/browser_markupview_textcontent_edit_01.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/markupview/test/browser_markupview_textcontent_edit_01.js	Thu Apr 09 14:59:51 2015 +0200
@@ -23,11 +23,9 @@ add_task(function*() {
   info("Listening to the markupmutation event");
   let onMutated = inspector.once("markupmutation");
   let container = yield getContainerForSelector(".node6", inspector);
   let field = container.elt.querySelector("pre");
   setEditableFieldValue(field, "New text", inspector);
   yield onMutated;
 
   is(node.nodeValue, "New text", "Test test node's text content has changed");
-
-  yield inspector.once("inspector-updated");
 });
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/markupview/test/helper_attributes_test_runner.js
--- a/browser/devtools/markupview/test/helper_attributes_test_runner.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/markupview/test/helper_attributes_test_runner.js	Thu Apr 09 14:59:51 2015 +0200
@@ -21,18 +21,16 @@ function runAddAttributesTests(tests, no
   info("Running " + tests.length + " add-attributes tests");
   return Task.spawn(function*() {
     info("Selecting the test node");
     yield selectNode("div", inspector);
 
     for (let test of tests) {
       yield runAddAttributesTest(test, "div", inspector);
     }
-
-    yield inspector.once("inspector-updated");
   });
 }
 
 /**
  * Run a single add-attribute test.
  * See runAddAttributesTests for a description.
  * @param {Object} test A test object should contain the following properties:
  *        - desc {String} a textual description for that test, to help when
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_add-property_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_add-property_02.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_add-property_02.js	Thu Apr 09 14:59:51 2015 +0200
@@ -19,17 +19,16 @@ add_task(function*() {
     ".testclass, .unmatched {" +
     "  background-color: green;" +
     "}";
   let styleNode = addStyle(content.document, style);
   content.document.body.innerHTML = "<div id='testid' class='testclass'>Styled Node</div>" +
                                     "<div id='testid2'>Styled Node</div>";
 
   yield testCreateNew(inspector, view);
-  yield inspector.once("inspector-updated");
 });
 
 function* testCreateNew(inspector, ruleView) {
   // Create a new property.
   let elementRuleEditor = getRuleViewRuleEditor(ruleView, 0);
   let editor = yield focusEditableField(elementRuleEditor.closeBrace);
 
   is(inplaceEditor(elementRuleEditor.newPropSpan), editor,
@@ -55,16 +54,17 @@ function* testCreateNew(inspector, ruleV
 
   editor = inplaceEditor(ruleView.doc.activeElement);
 
   is(elementRuleEditor.rule.textProps.length,  1, "Should have created a new text property.");
   is(elementRuleEditor.propertyList.children.length, 1, "Should have created a property editor.");
   let textProp = elementRuleEditor.rule.textProps[0];
   is(editor, inplaceEditor(textProp.editor.valueSpan), "Should be editing the value span now.");
 
+  let onMutated = inspector.once("markupmutation");
   editor.input.value = "purple";
   let onBlur = once(editor.input, "blur");
   EventUtils.sendKey("return", ruleView.doc.defaultView);
   yield onBlur;
-  yield elementRuleEditor.rule._applyingModifications;
+  yield onMutated;
 
   is(textProp.value, "purple", "Text prop should have been changed.");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-duplicates.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-duplicates.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-duplicates.js	Thu Apr 09 14:59:51 2015 +0200
@@ -18,18 +18,20 @@ add_task(function*() {
   content.document.body.appendChild(newElement);
   yield selectNode("div", inspector);
   let ruleEditor = getRuleViewRuleEditor(view, 0);
 
   yield testCreateNewMultiDuplicates(inspector, ruleEditor);
 });
 
 function* testCreateNewMultiDuplicates(inspector, ruleEditor) {
+  let onMutation = inspector.once("markupmutation");
   yield createNewRuleViewProperty(ruleEditor,
     "color:red;color:orange;color:yellow;color:green;color:blue;color:indigo;color:violet;");
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 7, "Should have created new text properties.");
   is(ruleEditor.propertyList.children.length, 8, "Should have created new property editors.");
 
   is(ruleEditor.rule.textProps[0].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[0].value, "red", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[1].name, "color", "Should have correct property name");
@@ -44,11 +46,9 @@ function* testCreateNewMultiDuplicates(i
   is(ruleEditor.rule.textProps[4].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[4].value, "blue", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[5].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[5].value, "indigo", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[6].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[6].value, "violet", "Should have correct property value");
-
-  yield inspector.once("inspector-updated");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-priority.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-priority.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-priority.js	Thu Apr 09 14:59:51 2015 +0200
@@ -18,25 +18,25 @@ add_task(function*() {
   content.document.body.appendChild(newElement);
   yield selectNode("div", inspector);
   let ruleEditor = getRuleViewRuleEditor(view, 0);
 
   yield testCreateNewMultiPriority(inspector, ruleEditor);
 });
 
 function* testCreateNewMultiPriority(inspector, ruleEditor) {
+  let onMutation = inspector.once("markupmutation");
   yield createNewRuleViewProperty(ruleEditor,
     "color:red;width:100px;height: 100px;");
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 3, "Should have created new text properties.");
   is(ruleEditor.propertyList.children.length, 4, "Should have created new property editors.");
 
   is(ruleEditor.rule.textProps[0].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[0].value, "red", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[1].name, "width", "Should have correct property name");
   is(ruleEditor.rule.textProps[1].value, "100px", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[2].name, "height", "Should have correct property name");
   is(ruleEditor.rule.textProps[2].value, "100px", "Should have correct property value");
-
-  yield inspector.once("inspector-updated");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-unfinished_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-unfinished_01.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-unfinished_01.js	Thu Apr 09 14:59:51 2015 +0200
@@ -18,18 +18,20 @@ add_task(function*() {
   content.document.body.appendChild(newElement);
   yield selectNode("div", inspector);
   let ruleEditor = getRuleViewRuleEditor(view, 0);
 
   yield testCreateNewMultiUnfinished(inspector, ruleEditor, view);
 });
 
 function* testCreateNewMultiUnfinished(inspector, ruleEditor, view) {
+  let onMutation = inspector.once("markupmutation");
   yield createNewRuleViewProperty(ruleEditor,
     "color:blue;background : orange   ; text-align:center; border-color: ");
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 4, "Should have created new text properties.");
   is(ruleEditor.propertyList.children.length, 4, "Should have created property editors.");
 
   for (let ch of "red") {
     EventUtils.sendChar(ch, view.doc.defaultView);
   }
   EventUtils.synthesizeKey("VK_RETURN", {}, view.doc.defaultView);
@@ -43,11 +45,9 @@ function* testCreateNewMultiUnfinished(i
   is(ruleEditor.rule.textProps[1].name, "background", "Should have correct property name");
   is(ruleEditor.rule.textProps[1].value, "orange", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[2].name, "text-align", "Should have correct property name");
   is(ruleEditor.rule.textProps[2].value, "center", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[3].name, "border-color", "Should have correct property name");
   is(ruleEditor.rule.textProps[3].value, "red", "Should have correct property value");
-
-  yield inspector.once("inspector-updated");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-unfinished_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-unfinished_02.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple-properties-unfinished_02.js	Thu Apr 09 14:59:51 2015 +0200
@@ -18,35 +18,37 @@ add_task(function*() {
   content.document.body.appendChild(newElement);
   yield selectNode("div", inspector);
   let ruleEditor = getRuleViewRuleEditor(view, 0);
 
   yield testCreateNewMultiPartialUnfinished(inspector, ruleEditor, view);
 });
 
 function* testCreateNewMultiPartialUnfinished(inspector, ruleEditor, view) {
+  let onMutation = inspector.once("markupmutation");
   yield createNewRuleViewProperty(ruleEditor, "width: 100px; heig");
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 2, "Should have created a new text property.");
   is(ruleEditor.propertyList.children.length, 2, "Should have created a property editor.");
 
   // Value is focused, lets add multiple rules here and make sure they get added
+  onMutation = inspector.once("markupmutation");
   let valueEditor = ruleEditor.propertyList.children[1].querySelector("input");
   valueEditor.value = "10px;background:orangered;color: black;";
   EventUtils.synthesizeKey("VK_RETURN", {}, view.doc.defaultView);
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 4, "Should have added the changed value.");
   is(ruleEditor.propertyList.children.length, 5, "Should have added the changed value editor.");
 
   is(ruleEditor.rule.textProps[0].name, "width", "Should have correct property name");
   is(ruleEditor.rule.textProps[0].value, "100px", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[1].name, "heig", "Should have correct property name");
   is(ruleEditor.rule.textProps[1].value, "10px", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[2].name, "background", "Should have correct property name");
   is(ruleEditor.rule.textProps[2].value, "orangered", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[3].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[3].value, "black", "Should have correct property value");
-
-  yield inspector.once("inspector-updated");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_multiple_properties_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties_01.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties_01.js	Thu Apr 09 14:59:51 2015 +0200
@@ -18,28 +18,28 @@ add_task(function*() {
   content.document.body.appendChild(newElement);
   yield selectNode("div", inspector);
   let ruleEditor = getRuleViewRuleEditor(view, 0);
 
   yield testCreateNewMulti(inspector, ruleEditor);
 });
 
 function* testCreateNewMulti(inspector, ruleEditor) {
+  let onMutation = inspector.once("markupmutation");
   yield createNewRuleViewProperty(ruleEditor,
     "color:blue;background : orange   ; text-align:center; border-color: green;");
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 4, "Should have created a new text property.");
   is(ruleEditor.propertyList.children.length, 5, "Should have created a new property editor.");
 
   is(ruleEditor.rule.textProps[0].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[0].value, "blue", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[1].name, "background", "Should have correct property name");
   is(ruleEditor.rule.textProps[1].value, "orange", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[2].name, "text-align", "Should have correct property name");
   is(ruleEditor.rule.textProps[2].value, "center", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[3].name, "border-color", "Should have correct property name");
   is(ruleEditor.rule.textProps[3].value, "green", "Should have correct property value");
-
-  yield inspector.once("inspector-updated");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_multiple_properties_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties_02.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_multiple_properties_02.js	Thu Apr 09 14:59:51 2015 +0200
@@ -24,26 +24,26 @@ add_task(function*() {
 
 function* testMultiValues(inspector, ruleEditor, view) {
   yield createNewRuleViewProperty(ruleEditor, "width:");
 
   is(ruleEditor.rule.textProps.length, 1, "Should have created a new text property.");
   is(ruleEditor.propertyList.children.length, 1, "Should have created a property editor.");
 
   // Value is focused, lets add multiple rules here and make sure they get added
+  let onMutation = inspector.once("markupmutation");
   let valueEditor = ruleEditor.propertyList.children[0].querySelector("input");
   valueEditor.value = "height: 10px;color:blue"
   EventUtils.synthesizeKey("VK_RETURN", {}, view.doc.defaultView);
+  yield onMutation;
 
   is(ruleEditor.rule.textProps.length, 2, "Should have added the changed value.");
   is(ruleEditor.propertyList.children.length, 3, "Should have added the changed value editor.");
 
   EventUtils.synthesizeKey("VK_ESCAPE", {}, view.doc.defaultView);
   is(ruleEditor.propertyList.children.length, 2, "Should have removed the value editor.");
 
   is(ruleEditor.rule.textProps[0].name, "width", "Should have correct property name");
   is(ruleEditor.rule.textProps[0].value, "height: 10px", "Should have correct property value");
 
   is(ruleEditor.rule.textProps[1].name, "color", "Should have correct property name");
   is(ruleEditor.rule.textProps[1].value, "blue", "Should have correct property value");
-
-  yield inspector.once("inspector-updated");
 }
diff -r 87f15ce8266d -r c5e71ed867ad browser/devtools/styleinspector/test/browser_ruleview_override.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_override.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/styleinspector/test/browser_ruleview_override.js	Thu Apr 09 14:59:51 2015 +0200
@@ -20,16 +20,22 @@ function* createTestContent(inspector, s
   let onMutated = inspector.once("markupmutation");
   let styleNode = addStyle(content.document, style);
   content.document.body.innerHTML = '<div id="testid" class="testclass">Styled Node</div>';
   yield onMutated;
   yield selectNode("#testid", inspector);
   return styleNode;
 }
 
+function* removeTestContent(inspector, node) {
+  let onMutated = inspector.once("markupmutation");
+  node.remove();
+  yield onMutated;
+}
+
 function* simpleOverride(inspector, view) {
   let styleNode = yield createTestContent(inspector, '' +
     '#testid {' +
     '  background-color: blue;' +
     '} ' +
     '.testclass {' +
     '  background-color: green;' +
     '}');
@@ -52,17 +58,17 @@ function* simpleOverride(inspector, view
   yield elementRule._applyingModifications;
 
   let elementProp = elementRule.textProps[0];
   is(classProp.name, "background-color", "First element prop should now be background-color");
   ok(!elementProp.overridden, "Element style property should not be overridden");
   ok(idProp.overridden, "ID property should be overridden");
   ok(classProp.overridden, "Class property should be overridden");
 
-  styleNode.remove();
+  yield removeTestContent(inspector, styleNode);
 }
 
 function* partialOverride(inspector, view) {
   let styleNode = yield createTestContent(inspector, '' +
     // Margin shorthand property...
     '.testclass {' +
     '  margin: 2px;' +
     '}' +
@@ -81,17 +87,17 @@ function* partialOverride(inspector, vie
   for (let computed of classProp.computed) {
     if (computed.name.indexOf("margin-left") == 0) {
       ok(computed.overridden, "margin-left props should be overridden.");
     } else {
       ok(!computed.overridden, "Non-margin-left props should not be overridden.");
     }
   }
 
-  styleNode.remove();
+  yield removeTestContent(inspector, styleNode);
 }
 
 function* importantOverride(inspector, view) {
   let styleNode = yield createTestContent(inspector, '' +
     // Margin shorthand property...
     '.testclass {' +
     '  background-color: green !important;' +
     '}' +
@@ -105,17 +111,17 @@ function* importantOverride(inspector, v
   let idRule = elementStyle.rules[1];
   let idProp = idRule.textProps[0];
   ok(idProp.overridden, "Not-important rule should be overridden.");
 
   let classRule = elementStyle.rules[2];
   let classProp = classRule.textProps[0];
   ok(!classProp.overridden, "Important rule should not be overridden.");
 
-  styleNode.remove();
+  yield removeTestContent(inspector, styleNode);
 
   let elementRule = elementStyle.rules[0];
   let elementProp = elementRule.createProperty("background-color", "purple", "important");
   yield elementRule._applyingModifications;
 
   ok(classProp.overridden, "New important prop should override class property.");
   ok(!elementProp.overridden, "New important prop should not be overriden.");
 }
@@ -136,11 +142,10 @@ function* disableOverride(inspector, vie
 
   idProp.setEnabled(false);
   yield idRule._applyingModifications;
 
   let classRule = elementStyle.rules[2];
   let classProp = classRule.textProps[0];
   ok(!classProp.overridden, "Class prop should not be overridden after id prop was disabled.");
 
-  styleNode.remove();
-  yield inspector.once("inspector-updated");
+  yield removeTestContent(inspector, styleNode);
 }
