diff --git a/devtools/client/definitions.js b/devtools/client/definitions.js
--- a/devtools/client/definitions.js
+++ b/devtools/client/definitions.js
@@ -98,16 +98,19 @@ Tools.inspector = {
   inMenu: true,
   commands: [
     "devtools/client/responsivedesign/resize-commands",
     "devtools/client/inspector/inspector-commands",
     "devtools/client/eyedropper/commands.js"
   ],
 
   preventClosingOnKey: true,
+  onkey: function(panel, toolbox) {
+    toolbox.highlighterUtils.togglePicker();
+  },
 
   isTargetSupported: function(target) {
     return target.hasActor("inspector");
   },
 
   build: function(iframeWindow, toolbox) {
     return new InspectorPanel(iframeWindow, toolbox);
   }
diff --git a/devtools/client/framework/test/browser_keybindings_01.js b/devtools/client/framework/test/browser_keybindings_01.js
--- a/devtools/client/framework/test/browser_keybindings_01.js
+++ b/devtools/client/framework/test/browser_keybindings_01.js
@@ -55,35 +55,38 @@ function test()
 
   function setupKeyBindingsTest()
   {
     for (let win of gDevToolsBrowser._trackedBrowserWindows) {
       buildDevtoolsKeysetMap(win.document.getElementById("devtoolsKeyset"));
     }
 
     gDevTools.once("toolbox-ready", (e, toolbox) => {
-      // The inspector is already selected at this point, but we wait
-      // for the signal here to avoid confusing ourselves when we wait
-      // for the next select-tool-command signal.
-      gDevTools.once("select-tool-command", () => {
-        inspectorShouldBeSelected(toolbox.getCurrentPanel(), toolbox);
-      });
+      inspectorShouldBeOpenAndHighlighting(toolbox.getCurrentPanel(), toolbox);
     });
 
     keysetMap.inspector.synthesizeKey();
   }
 
-  function inspectorShouldBeSelected(aInspector, aToolbox)
+  function inspectorShouldBeOpenAndHighlighting(aInspector, aToolbox)
   {
     is (aToolbox.currentToolId, "inspector", "Correct tool has been loaded");
 
-    gDevTools.once("select-tool-command", (x, toolId) => {
-      webconsoleShouldBeSelected(aToolbox);
+    aToolbox.once("picker-started", () => {
+      ok(true, "picker-started event received, highlighter started");
+      keysetMap.inspector.synthesizeKey();
+
+      aToolbox.once("picker-stopped", () => {
+        ok(true, "picker-stopped event received, highlighter stopped");
+        gDevTools.once("select-tool-command", () => {
+          webconsoleShouldBeSelected(aToolbox);
+        });
+        keysetMap.webconsole.synthesizeKey();
+      });
     });
-    keysetMap.webconsole.synthesizeKey();
   }
 
   function webconsoleShouldBeSelected(aToolbox)
   {
       is (aToolbox.currentToolId, "webconsole", "webconsole should be selected.");
 
       gDevTools.once("select-tool-command", () => {
         jsdebuggerShouldBeSelected(aToolbox);
diff --git a/devtools/server/actors/highlighters.js b/devtools/server/actors/highlighters.js
--- a/devtools/server/actors/highlighters.js
+++ b/devtools/server/actors/highlighters.js
@@ -349,17 +349,16 @@ var HighlighterActor = exports.Highlight
       }
 
       // Store currently attached element
       this._currentNode = this._walker.attachElement(currentNode);
       this._highlighter.show(this._currentNode.node.rawNode);
       events.emit(this._walker, "picker-node-hovered", this._currentNode);
     };
 
-    this._tabActor.window.focus();
     this._startPickerListeners();
 
     return null;
   }),
 
   _findAndAttachElement: function(event) {
     // originalTarget allows access to the "real" element before any retargeting
     // is applied, such as in the case of XBL anonymous elements.  See also

