diff -r 3257b096219c -r 4f269c9cc65a browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js	Wed May 20 17:21:16 2015 -0700
+++ b/browser/devtools/inspector/inspector-panel.js	Thu May 21 15:41:53 2015 +0200
@@ -446,18 +446,17 @@ InspectorPanel.prototype = {
     this.cancelLayoutChange();
 
     // Wait for all the known tools to finish updating and then let the
     // client know.
     let selection = this.selection.nodeFront;
 
     // On any new selection made by the user, store the unique css selector
     // of the selected node so it can be restored after reload of the same page
-    if (reason !== "navigateaway" &&
-        this.canGetUniqueSelector &&
+    if (this.canGetUniqueSelector &&
         this.selection.isElementNode()) {
       selection.getUniqueSelector().then(selector => {
         this.selectionCssSelector = selector;
       }).then(null, e => {
         // Only log this as an error if the panel hasn't been destroyed in the
         // meantime.
         if (!this._panelDestroyer) {
           console.error(e);
diff -r 3257b096219c -r 4f269c9cc65a browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js	Wed May 20 17:21:16 2015 -0700
+++ b/browser/devtools/markupview/markup-view.js	Thu May 21 15:41:53 2015 +0200
@@ -414,55 +414,81 @@ MarkupView.prototype = {
   _shouldNewSelectionBeHighlighted: function() {
     let reason = this._inspector.selection.reason;
     let unwantedReasons = ["inspector-open", "navigateaway", "nodeselected", "test"];
     let isHighlitNode = this._hoveredNode === this._inspector.selection.nodeFront;
     return !isHighlitNode && reason && unwantedReasons.indexOf(reason) === -1;
   },
 
   /**
-   * Highlight the inspector selected node.
+   * React to new-node-front selection events.
+   * Highlights the node if needed, and make sure it is shown and selected in
+   * the view.
    */
   _onNewSelection: function() {
     let selection = this._inspector.selection;
+    let reason = selection.reason;
 
     this.htmlEditor.hide();
     if (this._hoveredNode && this._hoveredNode !== selection.nodeFront) {
       this.getContainer(this._hoveredNode).hovered = false;
       this._hoveredNode = null;
     }
 
+    if (!selection.isNode()) {
+      this.unmarkSelectedNode();
+      return;
+    }
+
     let done = this._inspector.updating("markup-view");
-    if (selection.isNode()) {
-      if (this._shouldNewSelectionBeHighlighted()) {
-        this._brieflyShowBoxModel(selection.nodeFront);
+
+    // Highlight the element briefly if needed.
+    if (this._shouldNewSelectionBeHighlighted()) {
+      this._brieflyShowBoxModel(selection.nodeFront);
+    }
+
+    this.showNode(selection.nodeFront).then(() => {
+      // We could be destroyed by now.
+      if (this._destroyer) {
+        return promise.reject("markupview destroyed");
       }
 
-      this.showNode(selection.nodeFront).then(() => {
-        if (this._destroyer) {
-          return promise.reject("markupview destroyed");
-        }
-        if (selection.reason !== "treepanel") {
-          this.markNodeAsSelected(selection.nodeFront);
-        }
-        done();
-      }).then(null, e => {
-        if (!this._destroyer) {
-          console.error(e);
-        }Â else {
-          console.warn("Could not mark node as selected, the markup-view was " +
-            "destroyed while showing the node.");
-        }
-
-        done();
-      });
-    } else {
-      this.unmarkSelectedNode();
+      // Mark the node as selected.
+      this.markNodeAsSelected(selection.nodeFront);
+
+      // Make sure the new selection receives focus so the keyboard can be used.
+      this.maybeFocusNewSelection();
+
       done();
+    }).catch(e => {
+      if (!this._destroyer) {
+        console.error(e);
+      } else {
+        console.warn("Could not mark node as selected, the markup-view was " +
+          "destroyed while showing the node.");
+      }
+
+      done();
+    });
+  },
+
+  /**
+   * Focus the current node selection's MarkupContainer if the selection
+   * happened because the user picked an element using the element picker or
+   * browser context menu.
+   */
+  maybeFocusNewSelection: function() {
+    let {reason, nodeFront} = this._inspector.selection;
+
+    if (reason !== "browser-context-menu" &&
+        reason !== "picker-node-picked") {
+      return;
     }
+
+    this.getContainer(nodeFront).focus();
   },
 
   /**
    * Create a TreeWalker to find the next/previous
    * node for selection.
    */
   _selectionWalker: function(aStart) {
     let walker = this.doc.createTreeWalker(
@@ -1150,32 +1176,43 @@ MarkupView.prototype = {
     } else {
       this.collapseNode(aNode);
     }
   },
 
   /**
    * Mark the given node selected, and update the inspector.selection
    * object's NodeFront to keep consistent state between UI and selection.
-   * @param aNode The NodeFront to mark as selected.
+   * @param {NodeFront} aNode The NodeFront to mark as selected.
+   * @param {String} reason The reason for marking the node as selected.
+   * @return {Boolean} False if the node is already marked as selected, true
+   * otherwise.
    */
-  markNodeAsSelected: function(aNode, reason) {
-    let container = this.getContainer(aNode);
+  markNodeAsSelected: function(node, reason) {
+    let container = this.getContainer(node);
     if (this._selectedContainer === container) {
       return false;
     }
+
+    // Un-select the previous container.
     if (this._selectedContainer) {
       this._selectedContainer.selected = false;
     }
+
+    // Select the new container.
     this._selectedContainer = container;
-    if (aNode) {
+    if (node) {
       this._selectedContainer.selected = true;
     }
 
-    this._inspector.selection.setNodeFront(aNode, reason || "nodeselected");
+    // Change the current selection if needed.
+    if (this._inspector.selection.nodeFront !== node) {
+      this._inspector.selection.setNodeFront(node, reason || "nodeselected");
+    }
+
     return true;
   },
 
   /**
    * Make sure that every ancestor of the selection are updated
    * and included in the list of visible children.
    */
   _ensureVisible: function(node) {
diff -r 3257b096219c -r 4f269c9cc65a browser/devtools/markupview/test/browser.ini
--- a/browser/devtools/markupview/test/browser.ini	Wed May 20 17:21:16 2015 -0700
+++ b/browser/devtools/markupview/test/browser.ini	Thu May 21 15:41:53 2015 +0200
@@ -78,16 +78,17 @@ skip-if = e10s # Bug 1040751 - CodeMirro
 [browser_markupview_load_01.js]
 [browser_markupview_html_edit_01.js]
 [browser_markupview_html_edit_02.js]
 [browser_markupview_html_edit_03.js]
 [browser_markupview_image_tooltip.js]
 [browser_markupview_keybindings_01.js]
 [browser_markupview_keybindings_02.js]
 [browser_markupview_keybindings_03.js]
+[browser_markupview_keybindings_04.js]
 [browser_markupview_mutation_01.js]
 [browser_markupview_mutation_02.js]
 [browser_markupview_navigation.js]
 [browser_markupview_node_not_displayed_01.js]
 [browser_markupview_node_not_displayed_02.js]
 [browser_markupview_pagesize_01.js]
 [browser_markupview_pagesize_02.js]
 [browser_markupview_remove_xul_attributes.js]
diff -r 3257b096219c -r 4f269c9cc65a browser/devtools/markupview/test/browser_markupview_keybindings_04.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/devtools/markupview/test/browser_markupview_keybindings_04.js	Thu May 21 15:41:53 2015 +0200
@@ -0,0 +1,80 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* global nsContextMenu*/
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that selecting a node using the browser context menu (inspect element)
+// or the element picker focuses that node so that the keyboard can be used
+// immediately.
+
+const TEST_URL = "data:text/html;charset=utf8,<div>test element</div>";
+
+add_task(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  info("Select the test node with the browser ctx menu");
+  yield selectWithBrowserMenu(inspector);
+  assertNodeSelected(inspector, "div");
+
+  info("Press arrowUp to focus <body> " +
+       "(which works if the node was focused properly)");
+  EventUtils.synthesizeKey("VK_UP", {});
+  yield waitForChildrenUpdated(inspector);
+  assertNodeSelected(inspector, "body");
+
+  info("Select the test node with the element picker");
+  yield selectWithElementPicker(inspector);
+  assertNodeSelected(inspector, "div");
+
+  info("Press arrowUp to focus <body> " +
+       "(which works if the node was focused properly)");
+  EventUtils.synthesizeKey("VK_UP", {});
+  yield waitForChildrenUpdated(inspector);
+  assertNodeSelected(inspector, "body");
+});
+
+function assertNodeSelected(inspector, tagName) {
+  is(inspector.selection.nodeFront.tagName.toLowerCase(), tagName,
+    `The <${tagName}> node is selected`);
+}
+
+function* selectWithBrowserMenu(inspector) {
+  yield executeInContent("Test:SynthesizeMouse", {
+    center: true,
+    selector: "div",
+    options: {type: "contextmenu", button: 2}
+  });
+
+  // nsContextMenu also requires the popupNode to be set, but we can't set it to
+  // node under e10s as it's a CPOW, not a DOM node. But under e10s,
+  // nsContextMenu won't use the property anyway, so just try/catching is ok.
+  try {
+    document.popupNode = getNode("div");
+  } catch (e) {}
+
+  let contentAreaContextMenu = document.querySelector("#contentAreaContextMenu");
+  let contextMenu = new nsContextMenu(contentAreaContextMenu);
+  yield contextMenu.inspectNode();
+
+  contentAreaContextMenu.hidden = true;
+  contentAreaContextMenu.hidePopup();
+  contextMenu.hiding();
+
+  yield inspector.once("inspector-updated");
+}
+
+function* selectWithElementPicker(inspector) {
+  yield inspector.toolbox.highlighterUtils.startPicker();
+  yield executeInContent("Test:SynthesizeMouse", {
+    center: true,
+    selector: "div",
+    options: {type: "mousemove"}
+  });
+  executeInContent("Test:SynthesizeKey", {
+    key: "VK_RETURN",
+    options: {}
+  }, false);
+  yield inspector.once("inspector-updated");
+}
