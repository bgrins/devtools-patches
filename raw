diff -r 905ec194fbba -r 39ba75e331b8 toolkit/devtools/gcli/commands/screenshot.js
--- a/toolkit/devtools/gcli/commands/screenshot.js	Fri Apr 24 14:29:05 2015 -0400
+++ b/toolkit/devtools/gcli/commands/screenshot.js	Fri Apr 24 15:26:55 2015 -0500
@@ -175,82 +175,77 @@ exports.items = [
     exec: function(args, context) {
       if (args.chrome && args.selector) {
         // Node screenshot with chrome option does not work as intended
         // Refer https://bugzilla.mozilla.org/show_bug.cgi?id=659268#c7
         // throwing for now.
         throw new Error(l10n.lookup("screenshotSelectorChromeConflict"));
       }
 
+      let capture;
       if (!args.chrome) {
         // Re-execute the command on the server
         const command = context.typed.replace(/^screenshot/, "screenshot_server");
-        return context.updateExec(command).then(output => {
+        capture = context.updateExec(command).then(output => {
           return output.error ? Promise.reject(output.data) : output.data;
         });
+      } else {
+        capture = captureScreenshot(args, context.environment.chromeDocument);
       }
 
-      return processScreenshot(args, context.environment.chromeDocument);
+      return capture.then(saveScreenshot.bind(null, args, context));
     },
   },
   {
     item: "command",
     runAt: "server",
     name: "screenshot_server",
     hidden: true,
     returnType: "imageSummary",
     params: [ filenameParam, standardParams ],
     exec: function(args, context) {
-      return processScreenshot(args, context.environment.document);
+      return captureScreenshot(args, context.environment.document);
     },
   }
 ];
 
 /**
  * This function simply handles the --delay argument before calling
- * processScreenshotNow
+ * createScreenshotData
  */
-function processScreenshot(args, document) {
+function captureScreenshot(args, document) {
   if (args.delay > 0) {
     return new Promise((resolve, reject) => {
       document.defaultView.setTimeout(() => {
-        processScreenshotNow(args, document).then(resolve, reject);
+        createScreenshotData(document, args).then(resolve, reject);
       }, args.delay * 1000);
     });
   }
   else {
-    return processScreenshotNow(args, document);
+    return createScreenshotData(document, args);
   }
 }
 
 /**
  * There are several possible destinations for the screenshot, SKIP is used
- * in processScreenshotNow() whenever one of them is not used
+ * in saveScreenshot() whenever one of them is not used
  */
 const SKIP = Promise.resolve();
 
 /**
- * This is just like exec, except the 'delay' has been handled already so
- * this is where we do that actual work of process the screenshot
+ * Save the captured screenshot to one of several destinations.
  */
-function processScreenshotNow(args, document) {
-  const reply = createScreenshotData(document, args);
-
-  const loadContext = document.defaultView
-                            .QueryInterface(Ci.nsIInterfaceRequestor)
-                            .getInterface(Ci.nsIWebNavigation)
-                            .QueryInterface(Ci.nsILoadContext);
-
+function saveScreenshot(args, context, reply) {
   const fileNeeded = args.filename != FILENAME_DEFAULT_VALUE ||
                       (!args.imgur && !args.clipboard);
 
   return Promise.all([
-    args.clipboard ? saveToClipboard(loadContext, reply) : SKIP,
-    args.imgur     ? uploadToImgur(reply)                : SKIP,
-    fileNeeded     ? saveToFile(loadContext, reply)      : SKIP,
+    args.clipboard ? saveToClipboard(context, reply) : SKIP,
+    args.imgur     ? uploadToImgur(reply)            : SKIP,
+    fileNeeded     ? saveToFile(context, reply)      : SKIP,
   ]).then(() => reply);
 }
 
 /**
  * This does the dirty work of creating a base64 string out of an
  * area of the browser window
  */
 function createScreenshotData(document, args) {
@@ -295,23 +290,23 @@ function createScreenshotData(document, 
   ctx.drawWindow(window, left, top, width, height, "#fff");
   const data = canvas.toDataURL("image/png", "");
 
   // See comment above on bug 961832
   if (args.fullpage) {
     window.scrollTo(currentX, currentY);
   }
 
-  return {
+  return Promise.resolve({
     destinations: [],
     data: data,
     height: height,
     width: width,
     filename: getFilename(args.filename),
-  };
+  });
 }
 
 /**
  * We may have a filename specified in args, or we might have to generate
  * one.
  */
 function getFilename(defaultName) {
   // Create a name for the file if not present
@@ -334,18 +329,22 @@ function getFilename(defaultName) {
                            [ dateString, timeString ]) + ".png";
 }
 
 /**
  * Save the image data to the clipboard. This returns a promise, so it can
  * be treated exactly like imgur / file processing, but it's really sync
  * for now.
  */
-function saveToClipboard(loadContext, reply) {
+function saveToClipboard(context, reply) {
   try {
+    const loadContext = context.environment.chromeWindow
+                               .QueryInterface(Ci.nsIInterfaceRequestor)
+                               .getInterface(Ci.nsIWebNavigation)
+                               .QueryInterface(Ci.nsILoadContext);
     const io = Cc["@mozilla.org/network/io-service;1"]
                   .getService(Ci.nsIIOService);
     const channel = io.newChannel2(reply.data, null, null,
                                    null,      // aLoadingNode
                                    Services.scriptSecurityManager.getSystemPrincipal(),
                                    null,      // aTriggeringPrincipal
                                    Ci.nsILoadInfo.SEC_NORMAL,
                                    Ci.nsIContentPolicy.TYPE_IMAGE);
@@ -417,47 +416,31 @@ function uploadToImgur(reply) {
     }
   });
 }
 
 /**
  * Save the screenshot data to disk, returning a promise which
  * is resolved on completion
  */
-function saveToFile(loadContext, reply) {
+function saveToFile(context, reply) {
   return Task.spawn(function*() {
     try {
+      let document = context.environment.chromeDocument;
+      let window = context.environment.chromeWindow;
+
       let filename = reply.filename;
       // Check there is a .png extension to filename
       if (!filename.match(/.png$/i)) {
         filename += ".png";
       }
 
-      // If the filename is relative, tack it onto the download directory
-      if (!filename.match(/[\\\/]/)) {
-        const preferredDir = yield Downloads.getPreferredDownloadsDirectory();
-        filename = OS.Path.join(preferredDir, filename);
-        reply.filename = filename;
-      }
-
-      const file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
-      file.initWithPath(filename);
-
-      const ioService = Cc["@mozilla.org/network/io-service;1"]
-                        .getService(Ci.nsIIOService);
-
-      const Persist = Ci.nsIWebBrowserPersist;
-      const persist = Cc["@mozilla.org/embedding/browser/nsWebBrowserPersist;1"]
-                      .createInstance(Persist);
-      persist.persistFlags = Persist.PERSIST_FLAGS_REPLACE_EXISTING_FILES |
-                             Persist.PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION;
-
-      // TODO: UTF8? For an image?
-      const source = ioService.newURI(reply.data, "UTF8", null);
-      persist.saveURI(source, null, null, 0, null, null, file, loadContext);
+      window.saveURL(reply.data, filename, null,
+                     true /* aShouldBypassCache */, true /* aSkipPrompt */,
+                     document.documentURIObject, document);
 
       reply.destinations.push(l10n.lookup("screenshotSavedToFile") + " \"" + filename + "\"");
     }
     catch (ex) {
       console.error(ex);
       reply.destinations.push(l10n.lookup("screenshotErrorSavingToFile") + " " + filename);
     }
   });
