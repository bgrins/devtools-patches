diff -r 87f15ce8266d -r e7d3ac809ea8 browser/devtools/inspector/selector-search.js
--- a/browser/devtools/inspector/selector-search.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/inspector/selector-search.js	Thu Apr 09 17:11:06 2015 +0200
@@ -178,16 +178,30 @@ SelectorSearch.prototype = {
   },
 
   _selectResult: function(index) {
     return this._searchResults.item(index).then(node => {
       this.inspector.selection.setNodeFront(node, "selectorsearch");
     });
   },
 
+  _queryNodes: Task.async(function*(query) {
+    if (typeof this.hasMultiFrameSearch === "undefined") {
+      let target = this.inspector.toolbox.target;
+      this.hasMultiFrameSearch = yield target.actorHasMethod("domwalker",
+        "multiFrameQuerySelectorAll");
+    }
+
+    if (this.hasMultiFrameSearch) {
+      return yield this.walker.multiFrameQuerySelectorAll(query);
+    } else {
+      return yield this.walker.querySelectorAll(this.walker.rootNode, query);
+    }
+  }),
+
   /**
    * The command callback for the input box. This function is automatically
    * invoked as the user is typing if the input box type is search.
    */
   _onHTMLSearch: function() {
     let query = this.searchBox.value;
     if (query == this._lastSearched) {
       this.emit("processing-done");
@@ -206,17 +220,17 @@ SelectorSearch.prototype = {
       }
       this.emit("processing-done");
       return;
     }
 
     this.searchBox.setAttribute("filled", true);
     let queryList = null;
 
-    this._lastQuery = this.walker.querySelectorAll(this.walker.rootNode, query).then(list => {
+    this._lastQuery = this._queryNodes(query).then(list => {
       return list;
     }, (err) => {
       // Failures are ok here, just use a null item list;
       return null;
     }).then(queryList => {
       // Value has changed since we started this request, we're done.
       if (query != this.searchBox.value) {
         if (queryList) {
diff -r 87f15ce8266d -r e7d3ac809ea8 browser/devtools/inspector/test/browser.ini
--- a/browser/devtools/inspector/test/browser.ini	Thu Apr 09 14:30:18 2015 +0200
+++ b/browser/devtools/inspector/test/browser.ini	Thu Apr 09 17:11:06 2015 +0200
@@ -86,13 +86,15 @@ skip-if = e10s # GCLI isn't e10s compati
 [browser_inspector_reload-01.js]
 [browser_inspector_reload-02.js]
 [browser_inspector_remove-iframe-during-load.js]
 [browser_inspector_scrolling.js]
 skip-if = e10s # Test synthesize scrolling events in content. Also, see bug 1035661.
 [browser_inspector_search-01.js]
 [browser_inspector_search-02.js]
 [browser_inspector_search-03.js]
+[browser_inspector_search-04.js]
+[browser_inspector_search-05.js]
 [browser_inspector_select-docshell.js]
 [browser_inspector_select-last-selected.js]
 [browser_inspector_search-navigation.js]
 [browser_inspector_sidebarstate.js]
 [browser_inspector_switch-to-inspector-on-pick.js]
diff -r 87f15ce8266d -r e7d3ac809ea8 browser/devtools/inspector/test/browser_inspector_search-04.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/devtools/inspector/test/browser_inspector_search-04.js	Thu Apr 09 17:11:06 2015 +0200
@@ -0,0 +1,105 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Testing that searching for elements inside iframes does work.
+
+const IFRAME_SRC = "doc_inspector_search.html";
+const TEST_URL = "data:text/html;charset=utf-8," +
+                 "<div class=\"c1 c2\">" +
+                 "<iframe src=\"" + TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>" +
+                 "<iframe src=\"" + TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>";
+
+// An array of (key, suggestions) pairs where key is a key to press and
+// suggestions is an array of suggestions that should be shown in the popup.
+// Suggestion is an object with label of the entry and optional count
+// (defaults to 1)
+let TEST_DATA = [
+  {
+    key: "d",
+    suggestions: [{label: "div", count: 5}]
+  },
+  {
+    key: "i",
+    suggestions: [{label: "div", count: 5}]
+  },
+  {
+    key: "v",
+    suggestions: []
+  },
+  {
+    key: "VK_BACK_SPACE",
+    suggestions: [{label: "div", count: 5}]
+  },
+  {
+    key: "VK_BACK_SPACE",
+    suggestions: [{label: "div", count: 5}]
+  },
+  {
+    key: "VK_BACK_SPACE",
+    suggestions: []
+  },
+  {
+    key: ".",
+    suggestions: [
+      {label: ".c1", count: 7},
+      {label: ".c2", count: 3}
+    ]
+  },
+  {
+    key: "VK_BACK_SPACE",
+    suggestions: []
+  },
+  {
+    key: "#",
+    suggestions: [
+      {label: "#b1", count: 2},
+      {label: "#d1", count: 2},
+      {label: "#d2", count: 2},
+      {label: "#p1", count: 2},
+      {label: "#p2", count: 2},
+      {label: "#p3", count: 2},
+      {label: "#s1", count: 2},
+      {label: "#s2", count: 2}
+    ]
+  },
+];
+
+add_task(function* () {
+  let {inspector} = yield openInspectorForURL(TEST_URL);
+  let searchBox = inspector.searchBox;
+  let popup = inspector.searchSuggestions.searchPopup;
+
+  yield focusSearchBoxUsingShortcut(inspector.panelWin);
+
+  for (let {key, suggestions} of TEST_DATA) {
+    info("Pressing " + key + " to get " + formatSuggestions(suggestions));
+
+    let command = once(searchBox, "command");
+    EventUtils.synthesizeKey(key, {}, inspector.panelWin);
+    yield command;
+
+    info("Waiting for search query to complete");
+    yield inspector.searchSuggestions._lastQuery;
+
+    info("Query completed. Performing checks for input '" + searchBox.value + "'");
+    let actualSuggestions = popup.getItems().reverse();
+
+    is(popup.isOpen ? actualSuggestions.length: 0, suggestions.length,
+       "There are expected number of suggestions.");
+
+    for (let i = 0; i < suggestions.length; i++) {
+      is(suggestions[i].label, actualSuggestions[i].label,
+         "The suggestion at " + i + "th index is correct.");
+      is(suggestions[i].count || 1, actualSuggestions[i].count,
+         "The count for suggestion at " + i + "th index is correct.");
+    }
+  }
+});
+
+function formatSuggestions(suggestions) {
+  return "[" + suggestions
+                .map(s => "'" + s.label + "' (" + s.count || 1 + ")")
+                .join(", ") + "]";
+}
diff -r 87f15ce8266d -r e7d3ac809ea8 browser/devtools/inspector/test/browser_inspector_search-05.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/devtools/inspector/test/browser_inspector_search-05.js	Thu Apr 09 17:11:06 2015 +0200
@@ -0,0 +1,64 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+// Testing that when search results contain suggestions for nodes in other
+// frames, selecting these suggestions actually selects the right nodes.
+
+const IFRAME_SRC = "doc_inspector_search.html";
+const TEST_URL = "data:text/html;charset=utf-8," +
+                 "<iframe id=\"iframe-1\" src=\"" +
+                 TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>" +
+                 "<iframe id=\"iframe-2\" src=\"" +
+                 TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>";
+
+add_task(function* () {
+  let {inspector} = yield openInspectorForURL(TEST_URL);
+  let {walker} = inspector;
+
+  let searchBox = inspector.searchBox;
+  let popup = inspector.searchSuggestions.searchPopup;
+
+  info("Focus the search box");
+  yield focusSearchBoxUsingShortcut(inspector.panelWin);
+
+  info("Enter # to search for all ids");
+  let command = once(searchBox, "command");
+  EventUtils.synthesizeKey("#", {}, inspector.panelWin);
+  yield command;
+
+  info("Wait for search query to complete");
+  yield inspector.searchSuggestions._lastQuery;
+
+  info("Press tab to fill the search input with the first suggestion and " +
+    "expect a new selection");
+  let onSelect = inspector.once("inspector-updated");
+  EventUtils.synthesizeKey("VK_TAB", {}, inspector.panelWin);
+  yield onSelect;
+
+  let node = inspector.selection.nodeFront;
+  ok(node.id, "b1", "The selected node is #b1");
+  ok(node.tagName.toLowerCase(), "button",
+    "The selected node is <button>");
+
+  let selectedNodeDoc = yield walker.document(node);
+  let iframe1 = yield walker.querySelector(walker.rootNode, "#iframe-1");
+  let iframe1Doc = (yield walker.children(iframe1)).nodes[0];
+  is(selectedNodeDoc, iframe1Doc, "The selected node is in iframe 1");
+
+  info("Press enter to cycle through multiple nodes matching this suggestion");
+  onSelect = inspector.once("inspector-updated");
+  EventUtils.synthesizeKey("VK_RETURN", {}, inspector.panelWin);
+  yield onSelect;
+
+  node = inspector.selection.nodeFront;
+  ok(node.id, "b1", "The selected node is #b1 again");
+  ok(node.tagName.toLowerCase(), "button",
+    "The selected node is <button> again");
+
+  selectedNodeDoc = yield walker.document(node);
+  let iframe2 = yield walker.querySelector(walker.rootNode, "#iframe-2");
+  let iframe2Doc = (yield walker.children(iframe2)).nodes[0];
+  is(selectedNodeDoc, iframe2Doc, "The selected node is in iframe 2");
+});
diff -r 87f15ce8266d -r e7d3ac809ea8 toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js	Thu Apr 09 14:30:18 2015 +0200
+++ b/toolkit/devtools/server/actors/inspector.js	Thu Apr 09 17:11:06 2015 +0200
@@ -1782,46 +1782,83 @@ var WalkerActor = protocol.ActorClass({
       selector: Arg(1)
     },
     response: {
       list: RetVal("domnodelist")
     }
   }),
 
   /**
+   * Get a list of nodes that match the given selector in all known frames of
+   * the current content page.
+   * @param {String} selector.
+   * @return {Array}
+   */
+  _multiFrameQuerySelectorAll: function(selector) {
+    let nodes = [];
+
+    for (let {document} of this.tabActor.windows) {
+      try {
+        nodes = [...nodes, ...document.querySelectorAll(selector)];
+      } catch(e) {
+        // Bad selector. Do nothing as the selector can come from a searchbox.
+      }
+    }
+
+    return nodes;
+  },
+
+  /**
+   * Return a NodeListActor with all nodes that match the given selector in all
+   * frames of the current content page.
+   * @param {String} selector
+   */
+  multiFrameQuerySelectorAll: method(function(selector) {
+    return new NodeListActor(this, this._multiFrameQuerySelectorAll(selector));
+  }, {
+    request: {
+      selector: Arg(0)
+    },
+    response: {
+      list: RetVal("domnodelist")
+    }
+  }),
+
+  /**
    * Returns a list of matching results for CSS selector autocompletion.
    *
    * @param string query
    *        The selector query being completed
    * @param string completing
    *        The exact token being completed out of the query
    * @param string selectorState
    *        One of "pseudo", "id", "tag", "class", "null"
    */
   getSuggestionsForQuery: method(function(query, completing, selectorState) {
     let sugs = {
       classes: new Map,
-      tags: new Map
+      tags: new Map,
+      ids: new Map
     };
     let result = [];
     let nodes = null;
     // Filtering and sorting the results so that protocol transfer is miminal.
     switch (selectorState) {
       case "pseudo":
         result = PSEUDO_SELECTORS.filter(item => {
           return item[0].startsWith(":" + completing);
         });
         break;
 
       case "class":
         if (!query) {
-          nodes = this.rootDoc.querySelectorAll("[class]");
+          nodes = this._multiFrameQuerySelectorAll("[class]");
         }
         else {
-          nodes = this.rootDoc.querySelectorAll(query);
+          nodes = this._multiFrameQuerySelectorAll(query);
         }
         for (let node of nodes) {
           for (let className of node.className.split(" ")) {
             sugs.classes.set(className, (sugs.classes.get(className)|0) + 1);
           }
         }
         sugs.classes.delete("");
         // Editing the style editor may make the stylesheet have errors and
@@ -1833,59 +1870,65 @@ var WalkerActor = protocol.ActorClass({
           if (className.startsWith(completing)) {
             result.push(["." + className, count]);
           }
         }
         break;
 
       case "id":
         if (!query) {
-          nodes = this.rootDoc.querySelectorAll("[id]");
+          nodes = this._multiFrameQuerySelectorAll("[id]");
         }
         else {
-          nodes = this.rootDoc.querySelectorAll(query);
+          nodes = this._multiFrameQuerySelectorAll(query);
         }
         for (let node of nodes) {
-          if (node.id.startsWith(completing)) {
-            result.push(["#" + node.id, 1]);
+          sugs.ids.set(node.id, (sugs.ids.get(node.id)|0) + 1);
+        }
+        for (let [id, count] of sugs.ids) {
+          if (id.startsWith(completing)) {
+            result.push(["#" + id, count]);
           }
         }
         break;
 
       case "tag":
         if (!query) {
-          nodes = this.rootDoc.getElementsByTagName("*");
+          nodes = this._multiFrameQuerySelectorAll("*");
         }
         else {
-          nodes = this.rootDoc.querySelectorAll(query);
+          nodes = this._multiFrameQuerySelectorAll(query);
         }
         for (let node of nodes) {
           let tag = node.tagName.toLowerCase();
           sugs.tags.set(tag, (sugs.tags.get(tag)|0) + 1);
         }
         for (let [tag, count] of sugs.tags) {
           if ((new RegExp("^" + completing + ".*", "i")).test(tag)) {
             result.push([tag, count]);
           }
         }
         break;
 
       case "null":
-        nodes = this.rootDoc.querySelectorAll(query);
+        nodes = this._multiFrameQuerySelectorAll(query);
         for (let node of nodes) {
-          node.id && result.push(["#" + node.id, 1]);
+          sugs.ids.set(node.id, (sugs.ids.get(node.id)|0) + 1);
           let tag = node.tagName.toLowerCase();
           sugs.tags.set(tag, (sugs.tags.get(tag)|0) + 1);
           for (let className of node.className.split(" ")) {
             sugs.classes.set(className, (sugs.classes.get(className)|0) + 1);
           }
         }
         for (let [tag, count] of sugs.tags) {
           tag && result.push([tag, count]);
         }
+        for (let [id, count] of sugs.ids) {
+          id && result.push(["#" + id, count]);
+        }
         sugs.classes.delete("");
         // Editing the style editor may make the stylesheet have errors and
         // thus the page's elements' styles start changing with a transition.
         // That transition comes from the `moz-styleeditor-transitioning` class.
         sugs.classes.delete("moz-styleeditor-transitioning");
         sugs.classes.delete(HIDDEN_CLASS);
         for (let [className, count] of sugs.classes) {
           className && result.push(["." + className, count]);
