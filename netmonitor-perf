# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  cd5b4e44e260a2f8bdbd7f1f4505443702e48ff9
Bug 1143224 - more scroll debugging

diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -57,16 +57,19 @@ const GENERIC_VARIABLES_VIEW_SETTINGS = 
   editableNameTooltip: "",
   preventDisableOnChange: true,
   preventDescriptorModifiers: true,
   eval: () => {}
 };
 const NETWORK_ANALYSIS_PIE_CHART_DIAMETER = 200; // px
 const FREETEXT_FILTER_SEARCH_DELAY = 200; // ms
 
+XPCOMUtils.defineLazyModuleGetter(this, "DeferredTask",
+  "resource://gre/modules/DeferredTask.jsm");
+
 /**
  * Object defining the network monitor view components.
  */
 let NetMonitorView = {
   /**
    * Initializes the network monitor view.
    */
   initialize: function() {
@@ -501,57 +504,73 @@ RequestsMenuView.prototype = Heritage.ex
    * @param string aUrl
    *        Specifies the request's url.
    * @param boolean aIsXHR
    *        True if this request was initiated via XHR.
    * @param boolean aFromCache
    *        Indicates if the result came from the browser cache
    */
   addRequest: function(aId, aStartedDateTime, aMethod, aUrl, aIsXHR, aFromCache) {
-    // Convert the received date/time string to a unix timestamp.
-    let unixTime = Date.parse(aStartedDateTime);
-
-    // Create the element node for the network request item.
-    let menuView = this._createMenuView(aMethod, aUrl);
-
-    // Remember the first and last event boundaries.
-    this._registerFirstRequestStart(unixTime);
-    this._registerLastRequestEnd(unixTime);
-
-    // Append a network request item to this container.
-    let requestItem = this.push([menuView, aId], {
-      attachment: {
-        startedDeltaMillis: unixTime - this._firstRequestStartedMillis,
-        startedMillis: unixTime,
-        method: aMethod,
-        url: aUrl,
-        isXHR: aIsXHR,
-        fromCache: aFromCache
+    if (!this._requests) {
+      this._requests = [];
+    }
+    this._requests.push({aId, aStartedDateTime, aMethod, aUrl, aIsXHR, aFromCache});
+
+    if (!this._queuedRequestHandler) {
+      this._queuedRequestHandler = new DeferredTask(this.addQueuedRequests.bind(this),
+                                                 100);
+    }
+    this._queuedRequestHandler.arm();
+  },
+
+  addQueuedRequests: function() {
+    for (let {aId, aStartedDateTime, aMethod, aUrl, aIsXHR, aFromCache} of this._requests) {
+      // Convert the received date/time string to a unix timestamp.
+      let unixTime = Date.parse(aStartedDateTime);
+
+      // Create the element node for the network request item.
+      let menuView = this._createMenuView(aMethod, aUrl);
+
+      // Remember the first and last event boundaries.
+      this._registerFirstRequestStart(unixTime);
+      this._registerLastRequestEnd(unixTime);
+
+      // Append a network request item to this container.
+      let requestItem = this.push([menuView, aId], {
+        attachment: {
+          startedDeltaMillis: unixTime - this._firstRequestStartedMillis,
+          startedMillis: unixTime,
+          method: aMethod,
+          url: aUrl,
+          isXHR: aIsXHR,
+          fromCache: aFromCache
+        }
+      });
+
+      // Create a tooltip for the newly appended network request item.
+      let requestTooltip = requestItem.attachment.tooltip = new Tooltip(document, {
+        closeOnEvents: [{
+          emitter: $("#requests-menu-contents"),
+          event: "scroll",
+          useCapture: true
+        }]
+      });
+
+      $("#details-pane-toggle").disabled = false;
+      $("#requests-menu-empty-notice").hidden = true;
+
+      this.refreshSummary();
+      this.refreshZebra();
+      this.refreshTooltip(requestItem);
+
+      if (aId == this._preferredItemId) {
+        this.selectedItem = requestItem;
       }
-    });
-
-    // Create a tooltip for the newly appended network request item.
-    let requestTooltip = requestItem.attachment.tooltip = new Tooltip(document, {
-      closeOnEvents: [{
-        emitter: $("#requests-menu-contents"),
-        event: "scroll",
-        useCapture: true
-      }]
-    });
-
-    $("#details-pane-toggle").disabled = false;
-    $("#requests-menu-empty-notice").hidden = true;
-
-    this.refreshSummary();
-    this.refreshZebra();
-    this.refreshTooltip(requestItem);
-
-    if (aId == this._preferredItemId) {
-      this.selectedItem = requestItem;
     }
+    this._requests = [];
   },
 
   /**
    * Opens selected item in a new tab.
    */
   openRequestInTab: function() {
     let win = Services.wm.getMostRecentWindow("navigator:browser");
     let selected = this.selectedItem.attachment;
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -6,16 +6,17 @@
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
 
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
@@ -98,20 +99,31 @@ SideMenuWidget.prototype = {
    *        Some attached primitive/object. Custom options supported:
    *          - group: a string specifying the group to place this item into
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
+    // let cwu = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+    //                 .getInterface(Ci.nsIDOMWindowUtils);
+
+    // if (this._list.lastElementChild) {
+    // let rect = cwu.getBoundsWithoutFlushing(this._list.lastElementChild);
+    // let rect2 = cwu.getBoundsWithoutFlushing(this._list);
+
+    // console.log(rect, rect2);
+
+    // }
+    // console.trace();
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
     // needlessly expensive operations that may cause reflows):
-    let maintainScrollAtBottom =
+    let maintainScrollAtBottom = false &&
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
       // 4. The list should already be scrolled at the bottom.
       (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
