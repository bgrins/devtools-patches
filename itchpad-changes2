# HG changeset patch
# Parent 871245408f214c7d03aa7f1a0c8ac0663c005eef
# User Brian Grinstead <bgrinstead@mozilla.com>
test

diff --git a/browser/devtools/itchpad/chrome/content/itchpad-loader.js b/browser/devtools/itchpad/chrome/content/itchpad-loader.js
--- a/browser/devtools/itchpad/chrome/content/itchpad-loader.js
+++ b/browser/devtools/itchpad/chrome/content/itchpad-loader.js
@@ -25,18 +25,18 @@ window.addEventListener("DOMContentLoade
 
 
   itchpad.on("onEditorCreated", (editor) => {
     console.log("editor created: " + editor);
   });
   itchpad.on("onEditorDestroyed", (editor) => {
     console.log("editor destroyed: " + editor);
   });
-  itchpad.on("onEditorSave", (editor) => {
-    console.log("editor saved: " + editor);
+  itchpad.on("onEditorSave", (editor, resource) => {
+    console.log("editor saved: " + editor, resource.path);
   });
   itchpad.on("onEditorLoad", (editor) => {
     console.log("editor loaded: " + editor);
   });
   itchpad.on("onEditorActivated", (editor) => {
     console.log("editor focused: " + editor);
   });
   itchpad.on("onEditorDeactivated", (editor) => {
@@ -54,21 +54,17 @@ window.addEventListener("DOMContentLoade
 
   itchpad.load(iframe).then(() => {
     itchpad.setProjectToSinglePath(SAMPLE_PATH, {
       name: SAMPLE_NAME,
       version: SAMPLE_VERSION,
       iconUrl: SAMPLE_ICON,
       projectOverviewURL: SAMPLE_PROJECT_URL
     }).then(() => {
-
-      // let containers = [...itchpad.projectTree._containers].map(z=>z[0]);
-      // containers.forEach(function(container) {
-      //   itchpad.projectTree.select(container);
-      // });
+      console.log("All resources have been loaded", [...itchpad.project.allResources()]);
     });
 
   });
 
 }, true);
 
 
 /**
diff --git a/browser/devtools/itchpad/lib/editors.js b/browser/devtools/itchpad/lib/editors.js
--- a/browser/devtools/itchpad/lib/editors.js
+++ b/browser/devtools/itchpad/lib/editors.js
@@ -70,16 +70,24 @@ var ItchEditor = Class({
    *          A promise that is resolved once the editor has loaded the contents
    *          of the resource.
    */
   load: function(resource) {
     return promise.resolve();
   },
 
   /**
+   * Clean up the editor.  This can have different meanings
+   * depending on the type of editor.
+   */
+  destroy: function() {
+
+  },
+
+  /**
    * Give focus to the editor.  This can have different meanings
    * depending on the type of editor.
    *
    * @returns Promise
    *          A promise that is resolved once the editor has been focused.
    */
   focus: function() {
     return promise.resolve();
@@ -143,16 +151,25 @@ var TextEditor = Class({
     this.editor.on("cursorActivity", (...args) => {
       this.emit("cursorActivity", ...args);
     });
 
     this.appended = this.editor.appendTo(this.elt);
   },
 
   /**
+   * Clean up the editor.  This can have different meanings
+   * depending on the type of editor.
+   */
+  destroy: function() {
+    this.editor.destroy();
+    this.editor = null;
+  },
+
+  /**
    * Load a single resource into the text editor.
    *
    * @param Resource resource
    *        The single file / item that is being dealt with (see stores/base)
    * @returns Promise
    *          A promise that is resolved once the text editor has loaded the
    *          contents of the resource.
    */
diff --git a/browser/devtools/itchpad/lib/itchpad.js b/browser/devtools/itchpad/lib/itchpad.js
--- a/browser/devtools/itchpad/lib/itchpad.js
+++ b/browser/devtools/itchpad/lib/itchpad.js
@@ -67,18 +67,16 @@ require("itchpad/plugins/status-bar/lib/
   *    onCommand: When a command happens
   *    onEditorDestroyed: When editor is destroyed
   *
   */
 var Itchpad = Class({
   extends: EventTarget,
 
   initialize: function(options = {}) {
-    this.project = options.project;
-    this.stores = new Set();
     this._onNodeSelection = this._onNodeSelection.bind(this);
     this._onEditorCreated = this._onEditorCreated.bind(this);
     this._onEditorActivated = this._onEditorActivated.bind(this);
     this._updateEditorMenuItems = this._updateEditorMenuItems.bind(this);
   },
 
   /**
    * Load the instance inside of a specified iframe
@@ -123,25 +121,24 @@ var Itchpad = Class({
     this.shells.on("editor-activated", this._onEditorActivated);
 
     let shellContainer = this.document.querySelector("#shells-deck-container");
     shellContainer.appendChild(this.shells.elt);
 
     let popup = this.document.querySelector("#edit-menu-popup");
     popup.addEventListener("popupshowing", this.updateEditorMenuItems);
 
-    if (!this.project) {
-      this.project = new Project({
-        id: "Test",
-        name: "App",
-        directories: [],
-        openFiles: []
-      });
-    }
-    this.setProject(this.project);
+    // We are not allowing preset projects for now - rebuild a fresh one
+    // each time.
+    this.setProject(new Project({
+      id: "",
+      name: "",
+      directories: [],
+      openFiles: []
+    }));
 
     this._initCommands();
     this._initPlugins();
   },
 
 
   /**
    * Create the project tree sidebar that lists files.
@@ -205,52 +202,72 @@ var Itchpad = Class({
     commands.forEach(this.window.goUpdateCommand);
   },
 
   /**
    * Destroy all objects on the iframe unload event.
    */
   destroy: function() {
     this._plugins.forEach(plugin => { plugin.destroy(); });
+
+    [...this.project.allResources()].forEach((resource) => {
+      let editor = this.editorFor(resource);
+      if (editor) {
+        editor.destroy();
+      }
+    });
+
+    forget(this, this.project);
+    this.project.destroy();
+    this.project = null;
     this.projectTree.destroy();
     this.projectTree = null;
   },
 
   /**
    * Set the current project viewed by the itchpad.
    *
    * @param Project project
    *        The project to set.
    */
   setProject: function(project) {
+    if (this.project) {
+      forget(this, this.project);
+    }
     this.project = project;
     this.projectTree.setProject(project);
+
+    // Whenever a store gets removed, clean up any editors that
+    // exist for resources within it.
+    on(this, project, "store-removed", (store) => {
+      [...store.allResources()].forEach((resource) => {
+        let editor = this.editorFor(resource);
+        if (editor) {
+          editor.destroy();
+        }
+      });
+    });
   },
 
   /**
    * Set the current project viewed by the itchpad.
    *
    * @param string path
    *               The file path to set
    * @param Object opts
    *               Custom options used by the project. See plugins/app-manager.
    * @param Promise
    *        Promise that is resolved once the project is ready to be used.
    */
   setProjectToSinglePath: function(path, opts = {}) {
     this.project.customOpts = opts;
     this.project.projectType = "APP_MANAGER";
     this.project.removeAllPaths();
-    let localStore = this.project.addPath(path);
-
-    let defer = promise.defer();
-    on(this, localStore, "ready", () => {
-      defer.resolve();
-    });
-    return defer.promise;
+    this.project.addPath(path);
+    return this.project.refresh();
   },
 
   /**
    * Open a resource in a particular shell.
    *
    * @param Resource resource
    *                 The file to be opened.
    */
@@ -484,17 +501,17 @@ var Itchpad = Class({
    * Returns a resource for the given editor
    *
    * @param Editor editor
    *               The editor to check
    * @returns Resource
    *          The resource associated with this editor
    */
   resourceFor: function(editor) {
-    return editor.shell.project;
+    return editor.shell.resource;
   },
 
   /**
    * Decide whether a given resource should be hidden in the tree.
    *
    * @param Resource resource
    *                 The resource in the tree
    * @returns Boolean
diff --git a/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js b/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
--- a/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
+++ b/browser/devtools/itchpad/lib/plugins/dirty/lib/dirty.js
@@ -10,26 +10,27 @@ const { emit } = require("sdk/event/core
 
 var DirtyPlugin = Class({
   extends: Plugin,
 
   onEditorSave: function(editor) { this.onEditorChange(editor); },
   onEditorLoad: function(editor) { this.onEditorChange(editor); },
 
   onEditorChange: function(editor) {
+    // Only run on a TextEditor
     if (!editor || !editor.editor) {
       return;
     }
-    let tree = this.host.tree;
 
     // Dont' force a refresh unless the dirty state has changed...
     let priv = this.priv(editor);
     let clean = editor.editor.isClean();
     if (priv.isClean !== clean) {
-      let resource = editor.shell.project;
+
+      let resource = editor.shell.resource;
       emit(resource, "label-change", resource);
       priv.isClean = clean;
     }
   },
 
   onAnnotate: function(resource, editor, elt) {
     if (editor && editor.editor && !editor.editor.isClean()) {
       elt.textContent = '*' + resource.displayName;
diff --git a/browser/devtools/itchpad/lib/plugins/save/lib/save.js b/browser/devtools/itchpad/lib/plugins/save/lib/save.js
--- a/browser/devtools/itchpad/lib/plugins/save/lib/save.js
+++ b/browser/devtools/itchpad/lib/plugins/save/lib/save.js
@@ -62,38 +62,26 @@ var SavePlugin = Class({
       return this.saveResource(editor, resource);
     }).then(() => {
       this.host.openResource(resource);
     }).then(null, console.error);
   },
 
   save: function() {
     let editor = this.host.currentEditor;
-    let project = this.host.resourceFor(editor);
-    if (!project) {
+    let resource = this.host.resourceFor(editor);
+    if (!resource) {
       return this.saveAs();
     }
 
-    return this.saveResource(editor, project);
+    return this.saveResource(editor, resource);
   },
 
   createResource: function(path) {
     return this.host.project.resourceFor(path, { create: true })
   },
 
   saveResource: function(editor, resource) {
-    // If this wasn't a project editor, update the project
-    // editor.
-    let shell = this.host.shellFor(resource);
-    let projectEditor = shell ? shell.editor.project : null;
-    let text = -1;
-    if (projectEditor && projectEditor !== editor) {
-      text = editor.editor.getText();
-    }
-    return editor.save(resource).then(() => {
-      if (text != -1) {
-        projectEditor.editor.setText(text);
-      }
-    });
+    return editor.save(resource);
   }
 })
 exports.SavePlugin = SavePlugin;
 registerPlugin(SavePlugin);
diff --git a/browser/devtools/itchpad/lib/project.js b/browser/devtools/itchpad/lib/project.js
--- a/browser/devtools/itchpad/lib/project.js
+++ b/browser/devtools/itchpad/lib/project.js
@@ -27,44 +27,70 @@ function emptyProject() {
   };
 }
 
 // A project holds a list of local folders and maintains LocalStore objects
 // representing them.
 var Project = Class({
   extends: EventTarget,
 
-  initialize: function(info) {
-    this.stores = new Set();
+  /**
+   * Intialize the project object
+   *
+   * @param Object options
+   *               Options to be passed into Project.load function
+   */
+  initialize: function(options) {
     this.localStores = new Map();
 
-    this.load(info);
+    this.load(options);
+  },
+
+  destroy: function() {
+    [...this.allStores()].forEach((store) => {
+      this.removeLocalStore(store);
+    });
   },
 
   toString: function() {
     return "[Project] " + this.name;
   },
 
-  load: function(data) {
-    this.id = data.id;
-    this.name = data.name || "Untitled";
+  /**
+   * Load a project given metadata
+   *
+   * @param Object options
+   *               Information about the project, containing:
+   *                id: An ID (currently unused, but could be used for saving)
+   *                name: The display name of the project
+   *                directories: An array of path strings to load
+   */
+  load: function(options) {
+    this.id = options.id;
+    this.name = options.name || "Untitled";
 
-    let paths = new Set(data.directories.map(name => OS.Path.normalize(name)));
+    let paths = new Set(options.directories.map(name => OS.Path.normalize(name)));
 
     for (let [path, store] of this.localStores) {
       if (!paths.has(path)) {
         this.removePath(path);
       }
     }
 
     for (let path of paths) {
       this.addPath(path);
     }
   },
 
+  /**
+   * Refresh all project stores from disk
+   *
+   * @returns Promise
+   *          A promise that resolves when everything has been refreshed.
+   */
   refresh: function() {
     return Task.spawn(function*() {
       for (let [path, store] of this.localStores) {
         yield store.refresh();
       }
     }.bind(this));
   },
 
@@ -80,17 +106,17 @@ var Project = Class({
    *          A promise that resolves with the Resource.
    */
   resourceFor: function(path, options) {
     let store = this.storeContaining(path);
     return store.resourceFor(path, options);
   },
 
   allResources: function*() {
-    for (let store of this.stores) {
+    for (let [path, store] of this.localStores) {
       for (let [key, resource] of store.resources) {
         yield resource;
       }
     }
   },
 
   allStores: function*() {
     for (let [path, store] of this.localStores) {
@@ -133,41 +159,36 @@ var Project = Class({
   removePaths: function(paths) {
     for (let path of paths) {
       this.removePath(path);
     }
   },
 
   removePath: function(path) {
     this.removeLocalStore(this.localStores.get(path));
-    this.localStores.delete(path);
   },
 
   addLocalStore: function(store) {
     store.canPair = true;
     this.localStores.set(store.path, store);
 
     // Originally StoreCollection.addStore
-    this.stores.add(store);
     on(this, store, "resource-added", (resource) => {
       emit(this, "resource-added", resource);
     });
     on(this, store, "resource-removed", (resource) => {
       emit(this, "resource-removed", resource);
     })
 
     emit(this, "store-added", store);
   },
 
   removeLocalStore: function(store) {
     if (store) {
       this.localStores.delete(store.path);
-
-      // Originally StoreCollection.removeStore
-      store.destroy();
-      this.stores.delete(store);
       forget(this, store);
       emit(this, "store-removed", store);
+      store.destroy();
     }
   }
 });
 exports.Project = Project;
 
diff --git a/browser/devtools/itchpad/lib/shells.js b/browser/devtools/itchpad/lib/shells.js
--- a/browser/devtools/itchpad/lib/shells.js
+++ b/browser/devtools/itchpad/lib/shells.js
@@ -12,17 +12,17 @@ const { EditorTypeForResource } = requir
 const NetworkHelper = require("devtools/toolkit/webconsole/network-helper");
 
 var Shell = Class({
   extends: EventTarget,
 
   initialize: function(host, selectedResource) {
     this.host = host;
     this.doc = host.document;
-    this.project = selectedResource;
+    this.resource = selectedResource;
     this.elt = this.doc.createElement("vbox");
     this.elt.shell = this;
 
     this.editor = null;
 
     this._ensureEditor();
   },
 
@@ -30,23 +30,23 @@ var Shell = Class({
     if (this.editor) {
       let editor = this.editor;
       editor.appended.then(() => {
         emit(this, "editor-activated", editor);
       });
       return;
     }
 
-    let project = this.project;
-    let constructor = EditorTypeForResource(project);
+    let resource = this.resource;
+    let constructor = EditorTypeForResource(resource);
 
     if (this.host.plugins) {
       this.host.plugins.forEach(plugin => {
         if (plugin.editorForResource) {
-          let pluginEditor = plugin.editorForResource(project);
+          let pluginEditor = plugin.editorForResource(resource);
           if (pluginEditor) {
             constructor = pluginEditor;
           }
         }
       });
     }
 
     let editor = constructor(this.doc, this.host);
@@ -54,17 +54,17 @@ var Shell = Class({
     editor.shell = this;
 
     this.elt.appendChild(editor.elt);
 
     editor.appended.then(() => {
       emit(this, "editor-created", editor);
       emit(this, "editor-activated", editor);
     });
-    editor.load(project);
+    editor.load(resource);
   }
 });
 
 var ShellDeck = Class({
   extends: EventTarget,
 
   initialize: function(document, host) {
     this.doc = document;
@@ -74,17 +74,17 @@ var ShellDeck = Class({
     this.elt = this.deck;
 
     this.shells = new Map();
 
     this._deactivateEditor = null;
   },
 
   open: function(defaultResource) {
-    let shell = this.shells.get(defaultResource);
+    let shell = this.shellFor(defaultResource);
     if (!shell) {
       shell = this.createShell(defaultResource);
       this.shells.set(defaultResource, shell);
     }
     this.selectShell(shell);
     return shell;
   },
 
@@ -120,17 +120,17 @@ var ShellDeck = Class({
   get currentEditor() {
     let shell = this.currentShell;
     return shell ? shell.editor : shell;
   },
 
   createShell: function(defaultResource) {
     let shell = Shell(this.host, defaultResource);
     shell.on("editor-created", (editor) => {
-      this.shells.set(shell.project, editor);
+      this.shells.set(shell.resource, shell);
       emit(this, "editor-created", editor);
     });
     shell.on("editor-activated", () => {
       if (this.currentShell === shell) {
         this.selectShell(shell);
       }
     });
 
diff --git a/browser/devtools/itchpad/lib/tree.js b/browser/devtools/itchpad/lib/tree.js
--- a/browser/devtools/itchpad/lib/tree.js
+++ b/browser/devtools/itchpad/lib/tree.js
@@ -101,16 +101,17 @@ var Container = Class({
   update: function() {
     let visible = this.tree.options.resourceVisible ?
       this.tree.options.resourceVisible(this.resource) :
       true;
 
     this.elt.hidden = !visible;
 
     this.tree.options.resourceFormatter(this.resource, this.label);
+
     this.icon.className = "file-icon";
 
     let contentCategory = this.resource.contentCategory;
     let baseName = this.resource.basename || "";
 
     if (!this.resource.parent) {
       this.icon.classList.add("icon-none");
     } else if (this.resource.isDir) {
@@ -262,21 +263,24 @@ var TreeView = Class({
     });
   },
 
   removeModel: function(model) {
     this.models.delete(model);
     this.removeResource(model.root);
   },
 
+  getViewContainer: function(resource) {
+    return this._containers.get(resource);
+  },
+
   /*
     this.containers._get(resource) is a Container
    */
   select: function(resource) {
-    console.log("Tree Select requested", resource, [...this._containers]);
     this.selectContainer(this._containers.get(resource));
   },
 
   selectContainer: function(container) {
     if (this.selectedContainer === container) {
       return;
     }
     if (this.selectedContainer) {
diff --git a/browser/devtools/itchpad/test/browser_itchpad_init_custom.js b/browser/devtools/itchpad/test/browser_itchpad_init_custom.js
--- a/browser/devtools/itchpad/test/browser_itchpad_init_custom.js
+++ b/browser/devtools/itchpad/test/browser_itchpad_init_custom.js
@@ -27,38 +27,16 @@ let test = asyncTest(function*() {
     iconUrl: "chrome://browser/skin/devtools/tool-options.svg",
     projectOverviewURL: SAMPLE_WEBAPP_URL
   });
 
   let editor = yield editorCreated;
   yield runTests(itchpad);
 });
 
-function whenEditorCreated(itchpad) {
-  let def = promise.defer();
-  itchpad.once("onEditorCreated", (editor) => {
-    def.resolve(editor);
-  });
-  return def.promise;
-}
-function whenEditorLoad(itchpad) {
-  let def = promise.defer();
-  itchpad.once("onEditorLoad", (editor) => {
-    def.resolve(editor);
-  });
-  return def.promise;
-}
-function whenEditorSave(itchpad) {
-  let def = promise.defer();
-  itchpad.once("onEditorSave", (resource) => {
-    def.resolve(resource);
-  });
-  return def.promise;
-}
-
 function* runTests(itchpad) {
   var defer = promise.defer();
 
   ok (itchpad.currentEditor, "There is an editor for itchpad");
   let containers = [...itchpad.projectTree._containers].map(z=>z[0]);
 
   yield selectFile(itchpad, containers[1]);
   yield selectFile(itchpad, containers[2]);
@@ -84,16 +62,40 @@ function* runTests(itchpad) {
   is ([...itchpad.project.allPaths()].length, 0, "No paths are remaining");
 
   // itchpad.window.setTimeout(() => {
   defer.resolve();
   // }, 5000);
   return defer.promise;
 }
 
+function whenEditorCreated(itchpad) {
+  let def = promise.defer();
+  itchpad.once("onEditorCreated", (editor) => {
+    def.resolve(editor);
+  });
+  return def.promise;
+}
+
+function whenEditorLoad(itchpad) {
+  let def = promise.defer();
+  itchpad.once("onEditorLoad", (editor) => {
+    def.resolve(editor);
+  });
+  return def.promise;
+}
+
+function whenEditorSave(itchpad) {
+  let def = promise.defer();
+  itchpad.once("onEditorSave", (editor, resource) => {
+    def.resolve(resource);
+  });
+  return def.promise;
+}
+
 function* selectFile(itchpad, container) {
   ok (container && container.path, "A valid container has been passed in for selection " + (container && container.path));
   itchpad.projectTree.select(container);
 
   if (container.isDir) {
     return;
   }
 
@@ -102,27 +104,39 @@ function* selectFile(itchpad, container)
     whenEditorLoad(itchpad)
   ]);
 
   is (editorCreated, itchpad.currentEditor,  "Editor has been created for " + container.path);
   is (editorLoaded, itchpad.currentEditor,  "Editor has been loaded for " + container.path);
 }
 
 function* testEditFile(itchpad, filePath, newData) {
+  info ("Testing file editing for: " + filePath);
 
-  info ("Testing edit for: " + filePath);
   let initialData = yield getFileData(filePath);
   let editor = itchpad.currentEditor;
   let resource = itchpad.resourceFor(editor);
+  let viewContainer= itchpad.projectTree.getViewContainer(resource);
+  let originalTreeLabel = viewContainer.label.textContent;
 
   is (resource.path, filePath, "Resource path is set correctly");
   is (editor.editor.getText(), initialData, "Editor is loaded with correct file contents");
 
+  info ("Setting text in the editor and doing checks before saving");
+
   editor.editor.setText(newData);
   is (editor.editor.getText(), newData, "Editor has been filled with new data");
+  is (viewContainer.label.textContent, "*" + originalTreeLabel, "Label is marked as changed");
+
+  info ("Saving the editor and checking to make sure the file gets saved on disk");
 
   editor.save(resource);
 
   let savedResource = yield whenEditorSave(itchpad);
+  is (viewContainer.label.textContent, originalTreeLabel, "Label is unmarked as changed");
+  is (savedResource.path, filePath, "The saved resouce path matches the original");
+
   let savedData = yield getFileData(filePath);
+  is (savedData, newData, "Data has been correctly saved to disk");
 
-  is (savedData, newData, "Data has been correctly saved to disk");
+  info ("Finished checking saving for " + filePath);
+
 }
