# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1534219323 25200
#      Mon Aug 13 21:02:03 2018 -0700
# Node ID e99ab1bd8e2d587001b8da33aab614f9b78e65a3
# Parent  6296ed36532a887f88dfe4c6299f34811e694220
Bug 1479538 - Rewrite non-test callers of document.createElementNS(XUL_NS, ...) to use document.createXULElement(...)

Differential Revision: https://phabricator.services.mozilla.com/D3275

diff --git a/browser/base/content/browser-gestureSupport.js b/browser/base/content/browser-gestureSupport.js
--- a/browser/base/content/browser-gestureSupport.js
+++ b/browser/base/content/browser-gestureSupport.js
@@ -762,14 +762,13 @@ var gHistorySwipeAnimation = {
    *
    * @param aID
    *        An identifier to create the element with.
    * @param aTagName
    *        The name of the tag to create the element for.
    * @return the newly created element.
    */
   _createElement: function HSA__createElement(aID, aTagName) {
-    let XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-    let element = document.createElementNS(XULNS, aTagName);
+    let element = document.createXULElement(aTagName);
     element.id = aID;
     return element;
   },
 };
diff --git a/browser/base/content/browser-plugins.js b/browser/base/content/browser-plugins.js
--- a/browser/base/content/browser-plugins.js
+++ b/browser/base/content/browser-plugins.js
@@ -648,18 +648,17 @@ var gPluginHandler = {
 
       buttons.push(submitButton);
     }
 
     notification = notificationBox.appendNotification(messageString, "plugin-crashed",
                                                       iconURL, priority, buttons);
 
     // Add the "learn more" link.
-    let XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-    let link = notification.ownerDocument.createElementNS(XULNS, "label");
+    let link = notification.ownerDocument.createXULElement("label");
     link.className = "text-link";
     link.setAttribute("value", gNavigatorBundle.getString("crashedpluginsMessage.learnMore"));
     let crashurl = formatURL("app.support.baseURL", true);
     crashurl += "plugin-crashed-notificationbar";
     link.href = crashurl;
     let description = notification.ownerDocument.getAnonymousElementByAttribute(notification, "anonid", "messageText");
     description.appendChild(link);
   },
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -8071,18 +8071,17 @@ TabModalPromptBox.prototype = {
         allowFocusCheckbox.checked) {
       Services.perms.addFromPrincipal(principalToAllowFocusFor, "focus-tab-by-prompt",
                                       Services.perms.ALLOW_ACTION);
     }
     onCloseCallback.apply(this, args);
   },
 
   appendPrompt(args, onCloseCallback) {
-    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-    let newPrompt = document.createElementNS(XUL_NS, "tabmodalprompt");
+    let newPrompt = document.createXULElement("tabmodalprompt");
     let browser = this.browser;
     browser.parentNode.insertBefore(newPrompt, browser.nextElementSibling);
     browser.setAttribute("tabmodalPromptShowing", true);
 
     newPrompt.clientTop; // style flush to assure binding is attached
 
     let prompts = this.listPrompts();
     if (prompts.length > 1) {
@@ -8094,19 +8093,19 @@ TabModalPromptBox.prototype = {
     delete this._allowTabFocusByPromptPrincipal;
 
     let allowFocusCheckbox; // Define outside the if block so we can bind it into the callback.
     let hostForAllowFocusCheckbox = "";
     try {
       hostForAllowFocusCheckbox = principalToAllowFocusFor.URI.host;
     } catch (ex) { /* Ignore exceptions for host-less URIs */ }
     if (hostForAllowFocusCheckbox) {
-      let allowFocusRow = document.createElementNS(XUL_NS, "row");
-      allowFocusCheckbox = document.createElementNS(XUL_NS, "checkbox");
-      let spacer = document.createElementNS(XUL_NS, "spacer");
+      let allowFocusRow = document.createXULElement("row");
+      allowFocusCheckbox = document.createXULElement("checkbox");
+      let spacer = document.createXULElement("spacer");
       allowFocusRow.appendChild(spacer);
       let label = gTabBrowserBundle.formatStringFromName("tabs.allowTabFocusByPromptForSite",
                                                       [hostForAllowFocusCheckbox], 1);
       allowFocusCheckbox.setAttribute("label", label);
       allowFocusRow.appendChild(allowFocusCheckbox);
       newPrompt.appendChild(allowFocusRow);
     }
 
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -253,17 +253,17 @@ window._gBrowser = {
   },
 
   get popupAnchor() {
     if (this.selectedTab._popupAnchor) {
       return this.selectedTab._popupAnchor;
     }
     let stack = this.selectedBrowser.parentNode;
     // Create an anchor for the popup
-    let popupAnchor = document.createElementNS(this._XUL_NS, "hbox");
+    let popupAnchor = document.createXULElement("hbox");
     popupAnchor.className = "popup-anchor";
     popupAnchor.hidden = true;
     stack.appendChild(popupAnchor);
     return this.selectedTab._popupAnchor = popupAnchor;
   },
 
   set selectedTab(val) {
     if (gNavToolbox.collapsed && !this._allowTabChange) {
@@ -508,17 +508,17 @@ window._gBrowser = {
   },
 
   /**
    * Create a findbar instance.
    * @param aTab the tab to create the find bar for.
    * @return the created findbar, or null if the window or tab is closed/closing.
    */
   async _createFindBar(aTab) {
-    let findBar = document.createElementNS(this._XUL_NS, "findbar");
+    let findBar = document.createXULElement("findbar");
     let browser = this.getBrowserForTab(aTab);
     let browserContainer = this.getBrowserContainer(browser);
     browserContainer.appendChild(findBar);
 
     await new Promise(r => requestAnimationFrame(r));
     delete aTab._pendingFindBar;
     if (window.closed || aTab.closing) {
       return null;
@@ -1794,17 +1794,17 @@ window._gBrowser = {
     openerWindow,
     recordExecution,
     remoteType,
     replayExecution,
     sameProcessAsFrameLoader,
     uriIsAboutBlank,
     userContextId,
   } = {}) {
-    let b = document.createElementNS(this._XUL_NS, "browser");
+    let b = document.createXULElement("browser");
     b.permanentKey = {};
 
     for (let attribute in this._defaultBrowserAttributes) {
       b.setAttribute(attribute, this._defaultBrowserAttributes[attribute]);
     }
 
     if (userContextId) {
       b.setAttribute("usercontextid", userContextId);
@@ -1869,35 +1869,35 @@ window._gBrowser = {
     // window.
     if (name) {
       // XXX: The `name` property is special in HTML and XUL. Should
       // we use a different attribute name for this?
       b.setAttribute("name", name);
     }
 
     // Create the browserStack container
-    let stack = document.createElementNS(this._XUL_NS, "stack");
+    let stack = document.createXULElement("stack");
     stack.className = "browserStack";
     stack.appendChild(b);
     stack.setAttribute("flex", "1");
 
     // Create the browserContainer
-    let browserContainer = document.createElementNS(this._XUL_NS, "vbox");
+    let browserContainer = document.createXULElement("vbox");
     browserContainer.className = "browserContainer";
     browserContainer.appendChild(stack);
     browserContainer.setAttribute("flex", "10000");
 
     // Create the sidebar container
-    let browserSidebarContainer = document.createElementNS(this._XUL_NS, "hbox");
+    let browserSidebarContainer = document.createXULElement("hbox");
     browserSidebarContainer.className = "browserSidebarContainer";
     browserSidebarContainer.appendChild(browserContainer);
     browserSidebarContainer.setAttribute("flex", "10000");
 
     // Add the Message and the Browser to the box
-    let notificationbox = document.createElementNS(this._XUL_NS, "notificationbox");
+    let notificationbox = document.createXULElement("notificationbox");
     notificationbox.setAttribute("flex", "1");
     notificationbox.setAttribute("notificationside", "top");
     notificationbox.appendChild(browserSidebarContainer);
 
     // Prevent the superfluous initial load of a blank document
     // if we're going to load something other than about:blank.
     if (!uriIsAboutBlank) {
       b.setAttribute("nodefaultsrc", "true");
@@ -2228,17 +2228,17 @@ window._gBrowser = {
     // undefined if the tab is opened from an external application or
     // bookmark (i.e. somewhere other than an existing tab).
     if (relatedToCurrent == null) {
       relatedToCurrent = !!referrerURI;
     }
     let openerTab = ((openerBrowser && this.getTabForBrowser(openerBrowser)) ||
       (relatedToCurrent && this.selectedTab));
 
-    var t = document.createElementNS(this._XUL_NS, "tab");
+    var t = document.createXULElement("tab");
 
     t.openerTab = openerTab;
 
     aURI = aURI || "about:blank";
     let aURIObject = null;
     try {
       aURIObject = Services.io.newURI(aURI);
     } catch (ex) { /* we'll try to fix up this URL later */ }
diff --git a/browser/base/content/urlbarBindings.xml b/browser/base/content/urlbarBindings.xml
--- a/browser/base/content/urlbarBindings.xml
+++ b/browser/base/content/urlbarBindings.xml
@@ -2637,19 +2637,17 @@ file, You can obtain one at http://mozil
           for (let anonid of this._addonIframeHiddenAnonids) {
             let child = document.getAnonymousElementByAttribute(
               this, "anonid", anonid
             );
             this._addonIframeHiddenDisplaysByAnonid[anonid] =
               child.style.display;
             child.style.display = "none";
           }
-          let XUL_NS =
-            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-          let iframe = document.createElementNS(XUL_NS, "iframe");
+          let iframe = document.createXULElement("iframe");
           iframe.setAttribute("type", "content");
           iframe.setAttribute("flex", "1");
           iframe.style.transition = "height 100ms";
           this.appendChild(iframe);
           return iframe;
         ]]></body>
       </method>
 
diff --git a/browser/base/content/webext-panels.js b/browser/base/content/webext-panels.js
--- a/browser/base/content/webext-panels.js
+++ b/browser/base/content/webext-panels.js
@@ -20,20 +20,20 @@ var {
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 function getBrowser(sidebar) {
   let browser = document.getElementById("webext-panels-browser");
   if (browser) {
     return Promise.resolve(browser);
   }
 
-  let stack = document.createElementNS(XUL_NS, "stack");
+  let stack = document.createXULElement("stack");
   stack.setAttribute("flex", "1");
 
-  browser = document.createElementNS(XUL_NS, "browser");
+  browser = document.createXULElement("browser");
   browser.setAttribute("id", "webext-panels-browser");
   browser.setAttribute("type", "content");
   browser.setAttribute("flex", "1");
   browser.setAttribute("disableglobalhistory", "true");
   browser.setAttribute("webextension-view-type", "sidebar");
   browser.setAttribute("context", "contentAreaContextMenu");
   browser.setAttribute("tooltip", "aHTMLTooltip");
   browser.setAttribute("autocompletepopup", "PopupAutoComplete");
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -23,18 +23,16 @@ XPCOMUtils.defineLazyModuleGetters(this,
 XPCOMUtils.defineLazyGetter(this, "gWidgetsBundle", function() {
   const kUrl = "chrome://browser/locale/customizableui/customizableWidgets.properties";
   return Services.strings.createBundle(kUrl);
 });
 
 XPCOMUtils.defineLazyServiceGetter(this, "gELS",
   "@mozilla.org/eventlistenerservice;1", "nsIEventListenerService");
 
-const kNSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 const kSpecialWidgetPfx = "customizableui-special-";
 
 const kPrefCustomizationState        = "browser.uiCustomization.state";
 const kPrefCustomizationAutoAdd      = "browser.uiCustomization.autoAdd";
 const kPrefCustomizationDebug        = "browser.uiCustomization.debug";
 const kPrefDrawInTitlebar            = "browser.tabs.drawInTitlebar";
 const kPrefExtraDragSpace            = "browser.tabs.extraDragSpace";
 const kPrefUIDensity                 = "browser.uidensity";
@@ -1359,17 +1357,17 @@ var CustomizableUIInternal = {
       // Ids are differentiated through a unique count suffix.
       return kSpecialWidgetPfx + aId + (++gNewElementCount);
     }
     return aId;
   },
 
   createSpecialWidget(aId, aDocument) {
     let nodeName = "toolbar" + aId.match(/spring|spacer|separator/)[0];
-    let node = aDocument.createElementNS(kNSXUL, nodeName);
+    let node = aDocument.createXULElement(nodeName);
     node.className = "chromeclass-toolbar-additional";
     node.id = this.ensureSpecialWidgetId(aId);
     return node;
   },
 
   /* Find a XUL-provided widget in a window. Don't try to use this
    * for an API-provided widget or a special widget.
    */
@@ -1454,17 +1452,17 @@ var CustomizableUIInternal = {
         node = aWidget.onBuild(aDocument);
       }
       if (!node || !(node instanceof aDocument.defaultView.XULElement))
         log.error("Custom widget with id " + aWidget.id + " does not return a valid node");
     } else {
       if (aWidget.onBeforeCreated) {
         aWidget.onBeforeCreated(aDocument);
       }
-      node = aDocument.createElementNS(kNSXUL, "toolbarbutton");
+      node = aDocument.createXULElement("toolbarbutton");
 
       node.setAttribute("id", aWidget.id);
       node.setAttribute("widget-id", aWidget.id);
       node.setAttribute("widget-type", aWidget.type);
       if (aWidget.disabled) {
         node.setAttribute("disabled", true);
       }
       node.setAttribute("removable", aWidget.removable);
@@ -3901,19 +3899,19 @@ var CustomizableUI = {
 
       let subviewItem;
       if (menuChild.localName == "menuseparator") {
         // Don't insert duplicate or leading separators. This can happen if there are
         // menus (which we don't copy) above the separator.
         if (!fragment.lastElementChild || fragment.lastElementChild.localName == "menuseparator") {
           continue;
         }
-        subviewItem = doc.createElementNS(kNSXUL, "menuseparator");
+        subviewItem = doc.createXULElement("menuseparator");
       } else if (menuChild.localName == "menuitem") {
-        subviewItem = doc.createElementNS(kNSXUL, "toolbarbutton");
+        subviewItem = doc.createXULElement("toolbarbutton");
         CustomizableUI.addShortcut(menuChild, subviewItem);
 
         let item = menuChild;
         if (!item.hasAttribute("onclick")) {
           subviewItem.addEventListener("click", event => {
             let newEvent = new doc.defaultView.MouseEvent(event.type, event);
             item.dispatchEvent(newEvent);
           });
diff --git a/browser/components/customizableui/CustomizableWidgets.jsm b/browser/components/customizableui/CustomizableWidgets.jsm
--- a/browser/components/customizableui/CustomizableWidgets.jsm
+++ b/browser/components/customizableui/CustomizableWidgets.jsm
@@ -21,17 +21,16 @@ XPCOMUtils.defineLazyModuleGetters(this,
   SyncedTabs: "resource://services-sync/SyncedTabs.jsm",
 });
 
 XPCOMUtils.defineLazyGetter(this, "CharsetBundle", function() {
   const kCharsetBundle = "chrome://global/locale/charsetMenu.properties";
   return Services.strings.createBundle(kCharsetBundle);
 });
 
-const kNSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const kPrefCustomizationDebug = "browser.uiCustomization.debug";
 
 XPCOMUtils.defineLazyGetter(this, "log", () => {
   let scope = {};
   ChromeUtils.import("resource://gre/modules/Console.jsm", scope);
   let debug = Services.prefs.getBoolPref(kPrefCustomizationDebug, false);
   let consoleOptions = {
     maxLogLevel: debug ? "all" : "log",
@@ -191,20 +190,20 @@ const CustomizableWidgets = [
     tooltiptext: "sidebar-button.tooltiptext2",
     onCommand(aEvent) {
       let win = aEvent.target.ownerGlobal;
       win.SidebarUI.toggle();
     },
     onCreated(aNode) {
       // Add an observer so the button is checked while the sidebar is open
       let doc = aNode.ownerDocument;
-      let obChecked = doc.createElementNS(kNSXUL, "observes");
+      let obChecked = doc.createXULElement("observes");
       obChecked.setAttribute("element", "sidebar-box");
       obChecked.setAttribute("attribute", "checked");
-      let obPosition = doc.createElementNS(kNSXUL, "observes");
+      let obPosition = doc.createXULElement("observes");
       obPosition.setAttribute("element", "sidebar-box");
       obPosition.setAttribute("attribute", "positionend");
 
       aNode.appendChild(obChecked);
       aNode.appendChild(obPosition);
     }
   }, {
     id: "add-ons-button",
@@ -239,29 +238,29 @@ const CustomizableWidgets = [
         command: "cmd_fullZoomEnlarge",
         closemenu: "none",
         label: true,
         tooltiptext: "tooltiptext2",
         shortcutId: "key_fullZoomEnlarge",
         "class": "toolbarbutton-1 toolbarbutton-combined",
       }];
 
-      let node = aDocument.createElementNS(kNSXUL, "toolbaritem");
+      let node = aDocument.createXULElement("toolbaritem");
       node.setAttribute("id", "zoom-controls");
       node.setAttribute("label", CustomizableUI.getLocalizedProperty(this, "label"));
       node.setAttribute("title", CustomizableUI.getLocalizedProperty(this, "tooltiptext"));
       // Set this as an attribute in addition to the property to make sure we can style correctly.
       node.setAttribute("removable", "true");
       node.classList.add("chromeclass-toolbar-additional");
       node.classList.add("toolbaritem-combined-buttons");
 
       buttons.forEach(function(aButton, aIndex) {
         if (aIndex != 0)
-          node.appendChild(aDocument.createElementNS(kNSXUL, "separator"));
-        let btnNode = aDocument.createElementNS(kNSXUL, "toolbarbutton");
+          node.appendChild(aDocument.createXULElement("separator"));
+        let btnNode = aDocument.createXULElement("toolbarbutton");
         setAttributes(btnNode, aButton);
         node.appendChild(btnNode);
       });
       return node;
     }
   }, {
     id: "edit-controls",
     type: "custom",
@@ -285,29 +284,29 @@ const CustomizableWidgets = [
         id: "paste-button",
         command: "cmd_paste",
         label: true,
         tooltiptext: "tooltiptext2",
         shortcutId: "key_paste",
         "class": "toolbarbutton-1 toolbarbutton-combined",
       }];
 
-      let node = aDocument.createElementNS(kNSXUL, "toolbaritem");
+      let node = aDocument.createXULElement("toolbaritem");
       node.setAttribute("id", "edit-controls");
       node.setAttribute("label", CustomizableUI.getLocalizedProperty(this, "label"));
       node.setAttribute("title", CustomizableUI.getLocalizedProperty(this, "tooltiptext"));
       // Set this as an attribute in addition to the property to make sure we can style correctly.
       node.setAttribute("removable", "true");
       node.classList.add("chromeclass-toolbar-additional");
       node.classList.add("toolbaritem-combined-buttons");
 
       buttons.forEach(function(aButton, aIndex) {
         if (aIndex != 0)
-          node.appendChild(aDocument.createElementNS(kNSXUL, "separator"));
-        let btnNode = aDocument.createElementNS(kNSXUL, "toolbarbutton");
+          node.appendChild(aDocument.createXULElement("separator"));
+        let btnNode = aDocument.createXULElement("toolbarbutton");
         setAttributes(btnNode, aButton);
         node.appendChild(btnNode);
       });
 
       let listener = {
         onWidgetInstanceRemoved: (aWidgetId, aDoc) => {
           if (aWidgetId != this.id || aDoc != aDocument)
             return;
@@ -381,17 +380,17 @@ const CustomizableWidgets = [
     populateList(aDocument, aContainerId, aSection) {
       let containerElem = aDocument.getElementById(aContainerId);
 
       containerElem.addEventListener("command", this.onCommand);
 
       let list = this.charsetInfo[aSection];
 
       for (let item of list) {
-        let elem = aDocument.createElementNS(kNSXUL, "toolbarbutton");
+        let elem = aDocument.createXULElement("toolbarbutton");
         elem.setAttribute("label", item.label);
         elem.setAttribute("type", "checkbox");
         elem.section = aSection;
         elem.value = item.value;
         elem.setAttribute("class", "subviewbutton");
         containerElem.appendChild(elem);
       }
     },
@@ -639,17 +638,17 @@ if (Services.prefs.getBoolPref("identity
         this.setDeckIndex(this.deckIndices.DECKINDEX_TABS);
         this._clearTabList();
         SyncedTabs.sortTabClientsByLastUsed(clients);
         let fragment = doc.createDocumentFragment();
 
         for (let client of clients) {
           // add a menu separator for all clients other than the first.
           if (fragment.lastElementChild) {
-            let separator = doc.createElementNS(kNSXUL, "menuseparator");
+            let separator = doc.createXULElement("menuseparator");
             fragment.appendChild(separator);
           }
           if (paginationInfo && paginationInfo.clientId == client.id) {
             this._appendClient(client, fragment, paginationInfo.maxTabs);
           } else {
             this._appendClient(client, fragment);
           }
         }
@@ -673,25 +672,25 @@ if (Services.prefs.getBoolPref("identity
       this._appendMessageLabel("notabslabel");
     },
     _appendMessageLabel(messageAttr, appendTo = null) {
       if (!appendTo) {
         appendTo = this._tabsList;
       }
       let message = this._tabsList.getAttribute(messageAttr);
       let doc = this._tabsList.ownerDocument;
-      let messageLabel = doc.createElementNS(kNSXUL, "label");
+      let messageLabel = doc.createXULElement("label");
       messageLabel.textContent = message;
       appendTo.appendChild(messageLabel);
       return messageLabel;
     },
     _appendClient(client, attachFragment, maxTabs = this.TABS_PER_PAGE) {
       let doc = attachFragment.ownerDocument;
       // Create the element for the remote client.
-      let clientItem = doc.createElementNS(kNSXUL, "label");
+      let clientItem = doc.createXULElement("label");
       clientItem.setAttribute("itemtype", "client");
       let window = doc.defaultView;
       clientItem.setAttribute("tooltiptext",
         window.gSync.formatLastSyncDate(new Date(client.lastModified)));
       clientItem.textContent = client.name;
 
       attachFragment.appendChild(clientItem);
 
@@ -721,17 +720,17 @@ if (Services.prefs.getBoolPref("identity
                                                        nextPageIsLastPage ?
                                                        Infinity :
                                                        maxTabs + this.TABS_PER_PAGE);
           attachFragment.appendChild(showAllEnt);
         }
       }
     },
     _createTabElement(doc, tabInfo) {
-      let item = doc.createElementNS(kNSXUL, "toolbarbutton");
+      let item = doc.createXULElement("toolbarbutton");
       let tooltipText = (tabInfo.title ? tabInfo.title + "\n" : "") + tabInfo.url;
       item.setAttribute("itemtype", "tab");
       item.setAttribute("class", "subviewbutton");
       item.setAttribute("targetURI", tabInfo.url);
       item.setAttribute("label", tabInfo.title != "" ? tabInfo.title : tabInfo.url);
       item.setAttribute("image", tabInfo.icon);
       item.setAttribute("tooltiptext", tooltipText);
       // We need to use "click" instead of "command" here so openUILink
@@ -753,17 +752,17 @@ if (Services.prefs.getBoolPref("identity
       let labelAttr, tooltipAttr;
       if (showCount === Infinity) {
         labelAttr = "showAllLabel";
         tooltipAttr = "showAllTooltipText";
       } else {
         labelAttr = "showMoreLabel";
         tooltipAttr = "showMoreTooltipText";
       }
-      let showAllItem = doc.createElementNS(kNSXUL, "toolbarbutton");
+      let showAllItem = doc.createXULElement("toolbarbutton");
       showAllItem.setAttribute("itemtype", "showmorebutton");
       showAllItem.setAttribute("class", "subviewbutton");
       let label = this._tabsList.getAttribute(labelAttr);
       showAllItem.setAttribute("label", label);
       let tooltipText = this._tabsList.getAttribute(tooltipAttr);
       showAllItem.setAttribute("tooltiptext", tooltipText);
       showAllItem.addEventListener("click", e => {
         e.preventDefault();
diff --git a/browser/components/customizableui/content/panelUI.js b/browser/components/customizableui/content/panelUI.js
--- a/browser/components/customizableui/content/panelUI.js
+++ b/browser/components/customizableui/content/panelUI.js
@@ -618,30 +618,29 @@ const PanelUI = {
 
   _onHelpViewShow(aEvent) {
     // Call global menu setup function
     buildHelpMenu();
 
     let helpMenu = document.getElementById("menu_HelpPopup");
     let items = this.getElementsByTagName("vbox")[0];
     let attrs = ["oncommand", "onclick", "label", "key", "disabled"];
-    let NSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     // Remove all buttons from the view
     while (items.firstChild) {
       items.firstChild.remove();
     }
 
     // Add the current set of menuitems of the Help menu to this view
     let menuItems = Array.prototype.slice.call(helpMenu.getElementsByTagName("menuitem"));
     let fragment = document.createDocumentFragment();
     for (let node of menuItems) {
       if (node.hidden)
         continue;
-      let button = document.createElementNS(NSXUL, "toolbarbutton");
+      let button = document.createXULElement("toolbarbutton");
       // Copy specific attributes from a menuitem of the Help menu
       for (let attrName of attrs) {
         if (!node.hasAttribute(attrName))
           continue;
         button.setAttribute(attrName, node.getAttribute(attrName));
       }
       button.setAttribute("class", "subviewbutton");
       fragment.appendChild(button);
diff --git a/browser/components/extensions/ExtensionPopups.jsm b/browser/components/extensions/ExtensionPopups.jsm
--- a/browser/components/extensions/ExtensionPopups.jsm
+++ b/browser/components/extensions/ExtensionPopups.jsm
@@ -28,18 +28,16 @@ var {
 
 const {
   makeWidgetId,
 } = ExtensionCommon;
 
 
 const POPUP_LOAD_TIMEOUT_MS = 200;
 
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 function promisePopupShown(popup) {
   return new Promise(resolve => {
     if (popup.state == "open") {
       resolve();
     } else {
       popup.addEventListener("popupshown", function(event) {
         resolve();
       }, {once: true});
@@ -234,20 +232,20 @@ class BasePopup {
         }
         break;
     }
   }
 
   createBrowser(viewNode, popupURL = null) {
     let document = viewNode.ownerDocument;
 
-    let stack = document.createElementNS(XUL_NS, "stack");
+    let stack = document.createXULElement("stack");
     stack.setAttribute("class", "webextension-popup-stack");
 
-    let browser = document.createElementNS(XUL_NS, "browser");
+    let browser = document.createXULElement("browser");
     browser.setAttribute("type", "content");
     browser.setAttribute("disableglobalhistory", "true");
     browser.setAttribute("transparent", "true");
     browser.setAttribute("class", "webextension-popup-browser");
     browser.setAttribute("webextension-view-type", "popup");
     browser.setAttribute("tooltip", "aHTMLTooltip");
     browser.setAttribute("contextmenu", "contentAreaContextMenu");
     browser.setAttribute("autocompletepopup", "PopupAutoComplete");
diff --git a/browser/components/extensions/parent/ext-browserAction.js b/browser/components/extensions/parent/ext-browserAction.js
--- a/browser/components/extensions/parent/ext-browserAction.js
+++ b/browser/components/extensions/parent/ext-browserAction.js
@@ -26,18 +26,16 @@ var {
 } = ExtensionParent;
 
 XPCOMUtils.defineLazyGlobalGetters(this, ["InspectorUtils"]);
 
 const POPUP_PRELOAD_TIMEOUT_MS = 200;
 const POPUP_OPEN_MS_HISTOGRAM = "WEBEXT_BROWSERACTION_POPUP_OPEN_MS";
 const POPUP_RESULT_HISTOGRAM = "WEBEXT_BROWSERACTION_POPUP_PRELOAD_RESULT_COUNT";
 
-var XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 // WeakMap[Extension -> BrowserAction]
 const browserActionMap = new WeakMap();
 
 XPCOMUtils.defineLazyGetter(this, "browserAreas", () => {
   return {
     "navbar": CustomizableUI.AREA_NAVBAR,
     "menupanel": CustomizableUI.AREA_FIXED_OVERFLOW_PANEL,
     "tabstrip": CustomizableUI.AREA_TABSTRIP,
@@ -138,17 +136,17 @@ this.browserAction = class extends Exten
       tooltiptext: this.defaults.title || "",
       defaultArea: this.defaults.area,
 
       // Don't attempt to load properties from the built-in widget string
       // bundle.
       localized: false,
 
       onBeforeCreated: document => {
-        let view = document.createElementNS(XUL_NS, "panelview");
+        let view = document.createXULElement("panelview");
         view.id = this.viewId;
         view.setAttribute("flex", "1");
         view.setAttribute("extension", true);
 
         document.getElementById("appMenu-viewCache").appendChild(view);
 
         if (this.extension.hasPermission("menus") ||
             this.extension.hasPermission("contextMenus")) {
diff --git a/browser/components/extensions/parent/ext-commands.js b/browser/components/extensions/parent/ext-commands.js
--- a/browser/components/extensions/parent/ext-commands.js
+++ b/browser/components/extensions/parent/ext-commands.js
@@ -7,18 +7,16 @@ ChromeUtils.defineModuleGetter(this, "Ex
 ChromeUtils.defineModuleGetter(this, "ExtensionSettingsStore",
                                "resource://gre/modules/ExtensionSettingsStore.jsm");
 
 var {
   chromeModifierKeyMap,
   ExtensionError,
 } = ExtensionUtils;
 
-var XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 const EXECUTE_PAGE_ACTION = "_execute_page_action";
 const EXECUTE_BROWSER_ACTION = "_execute_browser_action";
 const EXECUTE_SIDEBAR_ACTION = "_execute_sidebar_action";
 
 function normalizeShortcut(shortcut) {
   return shortcut ? shortcut.replace(/\s+/g, "") : null;
 }
 
@@ -149,17 +147,17 @@ this.commands = class extends ExtensionA
 
   /**
    * Registers the commands to a document.
    * @param {ChromeWindow} window The XUL window to insert the Keyset.
    * @param {Map} commands The commands to be set.
    */
   registerKeysToDocument(window, commands) {
     let doc = window.document;
-    let keyset = doc.createElementNS(XUL_NS, "keyset");
+    let keyset = doc.createXULElement("keyset");
     keyset.id = `ext-keyset-id-${this.id}`;
     if (this.keysetsMap.has(window)) {
       this.keysetsMap.get(window).remove();
     }
     let sidebarKey;
     commands.forEach((command, name) => {
       if (command.shortcut) {
         let keyElement = this.buildKey(doc, name, command.shortcut);
@@ -227,17 +225,17 @@ this.commands = class extends ExtensionA
    * @param {Document} doc The XUL document.
    * @param {string} name The name of the shortcut.
    * @param {string} shortcut The shortcut provided in the manifest.
    *
    * @see https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/key
    * @returns {Document} The newly created Key element.
    */
   buildKeyFromShortcut(doc, name, shortcut) {
-    let keyElement = doc.createElementNS(XUL_NS, "key");
+    let keyElement = doc.createXULElement("key");
 
     let parts = shortcut.split("+");
 
     // The key is always the last element.
     let chromeKey = parts.pop();
 
     // The modifiers are the remaining elements.
     keyElement.setAttribute("modifiers", this.getModifiersAttribute(parts));
diff --git a/browser/components/extensions/parent/ext-devtools-panels.js b/browser/components/extensions/parent/ext-devtools-panels.js
--- a/browser/components/extensions/parent/ext-devtools-panels.js
+++ b/browser/components/extensions/parent/ext-devtools-panels.js
@@ -11,18 +11,16 @@ var {
   IconDetails,
   watchExtensionProxyContextLoad,
 } = ExtensionParent;
 
 var {
   promiseEvent,
 } = ExtensionUtils;
 
-var XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 /**
  * Represents an addon devtools panel in the main process.
  *
  * @param {ExtensionChildProxyContext} context
  *        A devtools extension proxy context running in a main process.
  * @param {object} options
  * @param {string} options.id
  *        The id of the addon devtools panel.
@@ -213,23 +211,23 @@ class ParentDevToolsPanel {
     const {document} = window;
 
     // TODO Bug 1442601: Refactor ext-devtools-panels.js to reuse the helpers
     // functions defined in webext-panels.xul (e.g. create the browser element
     // using an helper function defined in webext-panels.js and shared with the
     // extension sidebar pages).
     let stack = document.getElementById("webext-panels-stack");
     if (!stack) {
-      stack = document.createElementNS(XUL_NS, "stack");
+      stack = document.createXULElement("stack");
       stack.setAttribute("flex", "1");
       stack.setAttribute("id", "webext-panels-stack");
       document.documentElement.appendChild(stack);
     }
 
-    const browser = document.createElementNS(XUL_NS, "browser");
+    const browser = document.createXULElement("browser");
     browser.setAttribute("id", "webext-panels-browser");
     browser.setAttribute("type", "content");
     browser.setAttribute("disableglobalhistory", "true");
     browser.setAttribute("flex", "1");
     browser.setAttribute("class", "webextension-devtoolsPanel-browser");
     browser.setAttribute("webextension-view-type", "devtools_panel");
     // TODO Bug 1442604: Add additional tests for the select and autocompletion
     // popups used in an extension devtools panels (in oop and non-oop mode).
diff --git a/browser/components/extensions/parent/ext-sidebarAction.js b/browser/components/extensions/parent/ext-sidebarAction.js
--- a/browser/components/extensions/parent/ext-sidebarAction.js
+++ b/browser/components/extensions/parent/ext-sidebarAction.js
@@ -7,18 +7,16 @@ ChromeUtils.import("resource://gre/modul
 var {
   ExtensionError,
 } = ExtensionUtils;
 
 var {
   IconDetails,
 } = ExtensionParent;
 
-var XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 // WeakMap[Extension -> SidebarAction]
 let sidebarActionMap = new WeakMap();
 
 const sidebarURL = "chrome://browser/content/webext-panels.xul";
 
 /**
  * Responsible for the sidebar_action section of the manifest as well
  * as the associated sidebar browser.
@@ -144,17 +142,17 @@ this.sidebarAction = class extends Exten
     }
   }
 
   createMenuItem(window, details) {
     let {document, SidebarUI} = window;
 
     // Use of the broadcaster allows browser-sidebar.js to properly manage the
     // checkmarks in the menus.
-    let broadcaster = document.createElementNS(XUL_NS, "broadcaster");
+    let broadcaster = document.createXULElement("broadcaster");
     broadcaster.setAttribute("id", this.id);
     broadcaster.setAttribute("autoCheck", "false");
     broadcaster.setAttribute("type", "checkbox");
     broadcaster.setAttribute("group", "sidebar");
     broadcaster.setAttribute("label", details.title);
     broadcaster.setAttribute("sidebarurl", sidebarURL);
     broadcaster.setAttribute("panel", details.panel);
     if (this.browserStyle) {
@@ -167,24 +165,24 @@ this.sidebarAction = class extends Exten
     // oncommand gets attached to menuitem, so we use the observes attribute to
     // get the command id we pass to SidebarUI.
     broadcaster.setAttribute("oncommand", "SidebarUI.toggle(this.getAttribute('observes'))");
 
     let header = document.getElementById("sidebar-switcher-target");
     header.addEventListener("SidebarShown", this.updateHeader);
 
     // Insert a menuitem for View->Show Sidebars.
-    let menuitem = document.createElementNS(XUL_NS, "menuitem");
+    let menuitem = document.createXULElement("menuitem");
     menuitem.setAttribute("id", this.menuId);
     menuitem.setAttribute("observes", this.id);
     menuitem.setAttribute("class", "menuitem-iconic webextension-menuitem");
     this.setMenuIcon(menuitem, details);
 
     // Insert a toolbarbutton for the sidebar dropdown selector.
-    let toolbarbutton = document.createElementNS(XUL_NS, "toolbarbutton");
+    let toolbarbutton = document.createXULElement("toolbarbutton");
     toolbarbutton.setAttribute("id", this.buttonId);
     toolbarbutton.setAttribute("observes", this.id);
     toolbarbutton.setAttribute("class", "subviewbutton subviewbutton-iconic webextension-menuitem");
     this.setMenuIcon(toolbarbutton, details);
 
     document.getElementById("mainBroadcasterSet").appendChild(broadcaster);
     document.getElementById("viewSidebarMenu").appendChild(menuitem);
     let separator = document.getElementById("sidebar-extensions-separator");
diff --git a/browser/components/newtab/lib/AboutPreferences.jsm b/browser/components/newtab/lib/AboutPreferences.jsm
--- a/browser/components/newtab/lib/AboutPreferences.jsm
+++ b/browser/components/newtab/lib/AboutPreferences.jsm
@@ -122,17 +122,17 @@ this.AboutPreferences = class AboutPrefe
 
   /**
    * Render preferences to an about:preferences content window with the provided
    * strings and preferences structure.
    */
   renderPreferences({document, Preferences, gHomePane}, strings, prefStructure) {
     // Helper to create a new element and append it
     const createAppend = (tag, parent) => parent.appendChild(
-      document.createElementNS(XUL_NS, tag));
+      document.createXULElement(tag));
 
     // Helper to get strings and format with values if necessary
     const formatString = id => {
       if (typeof id !== "object") {
         return strings[id] || id;
       }
       let string = strings[id.id] || JSON.stringify(id);
       if (id.values) {
diff --git a/browser/components/search/content/search.xml b/browser/components/search/content/search.xml
--- a/browser/components/search/content/search.xml
+++ b/browser/components/search/content/search.xml
@@ -525,49 +525,47 @@
         } catch (ex) { }
       ]]></destructor>
 
       // Add items to context menu and attach controller to handle them the
       // first time the context menu is opened.
       <method name="initContextMenu">
         <parameter name="aMenu"/>
         <body><![CDATA[
-          const kXULNS =
-            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
           let stringBundle = document.getBindingParent(this)._stringBundle;
 
           let pasteAndSearch, suggestMenuItem;
           let element, label, akey;
 
-          element = document.createElementNS(kXULNS, "menuseparator");
+          element = document.createXULElement("menuseparator");
           aMenu.appendChild(element);
 
           let insertLocation = aMenu.firstElementChild;
           while (insertLocation.nextElementSibling &&
                  insertLocation.getAttribute("cmd") != "cmd_paste")
             insertLocation = insertLocation.nextElementSibling;
           if (insertLocation) {
-            element = document.createElementNS(kXULNS, "menuitem");
+            element = document.createXULElement("menuitem");
             label = stringBundle.getString("cmd_pasteAndSearch");
             element.setAttribute("label", label);
             element.setAttribute("anonid", "paste-and-search");
             element.setAttribute("oncommand", "BrowserSearch.pasteAndSearch(event)");
             aMenu.insertBefore(element, insertLocation.nextElementSibling);
             pasteAndSearch = element;
           }
 
-          element = document.createElementNS(kXULNS, "menuitem");
+          element = document.createXULElement("menuitem");
           label = stringBundle.getString("cmd_clearHistory");
           akey = stringBundle.getString("cmd_clearHistory_accesskey");
           element.setAttribute("label", label);
           element.setAttribute("accesskey", akey);
           element.setAttribute("cmd", "cmd_clearhistory");
           aMenu.appendChild(element);
 
-          element = document.createElementNS(kXULNS, "menuitem");
+          element = document.createXULElement("menuitem");
           label = stringBundle.getString("cmd_showSuggestions");
           akey = stringBundle.getString("cmd_showSuggestions_accesskey");
           element.setAttribute("anonid", "toggle-suggest-item");
           element.setAttribute("label", label);
           element.setAttribute("accesskey", akey);
           element.setAttribute("cmd", "cmd_togglesuggest");
           element.setAttribute("type", "checkbox");
           element.setAttribute("autocheck", "false");
@@ -1503,23 +1501,20 @@
           let height = rowCount * 33; // 32px per row, 1px border.
           this.buttons.setAttribute("height", height + "px");
 
           // Ensure we can refer to the settings buttons by ID:
           let origin = this.telemetryOrigin;
           this.settingsButton.id = origin + "-anon-search-settings";
           this.settingsButtonCompact.id = origin + "-anon-search-settings-compact";
 
-          const kXULNS =
-            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
           let dummyItems = enginesPerRow - (oneOffCount % enginesPerRow || enginesPerRow);
           for (let i = 0; i < engines.length; ++i) {
             let engine = engines[i];
-            let button = document.createElementNS(kXULNS, "button");
+            let button = document.createXULElement("button");
             button.id = this._buttonIDForEngine(engine);
             let uri = "chrome://browser/skin/search-engine-placeholder.png";
             if (engine.iconURI) {
               uri = engine.iconURI.spec;
             }
             button.setAttribute("image", uri);
             button.setAttribute("class", "searchbar-engine-one-off-item");
             button.setAttribute("tooltiptext", engine.name);
@@ -1535,17 +1530,17 @@
             if (i >= oneOffCount + dummyItems - enginesPerRow)
               button.classList.add("last-row");
 
             this.buttons.insertBefore(button, this.settingsButtonCompact);
           }
 
           let hasDummyItems = !!dummyItems;
           while (dummyItems) {
-            let button = document.createElementNS(kXULNS, "button");
+            let button = document.createXULElement("button");
             button.setAttribute("class", "searchbar-engine-one-off-item dummy last-row");
             button.setAttribute("width", buttonWidth);
 
             if (!--dummyItems)
               button.classList.add("last-of-row");
 
             this.buttons.insertBefore(button, this.settingsButtonCompact);
           }
@@ -1584,25 +1579,22 @@
         // The popup isn't designed to handle too many (by scrolling for
         // example), so a page could break the popup by offering too many.
         // Instead, add a single menu button with a submenu of all the engines.
 
         if (!gBrowser.selectedBrowser.engines) {
           return;
         }
 
-        const kXULNS =
-          "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
         let engines = gBrowser.selectedBrowser.engines;
         let tooManyEngines = engines.length > this._addEngineMenuThreshold;
 
         if (tooManyEngines) {
           // Make the top-level menu button.
-          let button = document.createElementNS(kXULNS, "toolbarbutton");
+          let button = document.createXULElement("toolbarbutton");
           list.appendChild(button);
           button.classList.add("addengine-item", "badged-button");
           button.setAttribute("anonid", "addengine-menu-button");
           button.setAttribute("type", "menu");
           button.setAttribute("label",
             this.bundle.GetStringFromName("cmd_addFoundEngineMenu"));
           button.setAttribute("crop", "end");
           button.setAttribute("pack", "start");
@@ -1611,17 +1603,17 @@
           // offered engines may have differing images, so there's no perfect
           // choice here.
           let engine = engines[0];
           if (engine.icon) {
             button.setAttribute("image", engine.icon);
           }
 
           // Now make the button's child menupopup.
-          list = document.createElementNS(kXULNS, "menupopup");
+          list = document.createXULElement("menupopup");
           button.appendChild(list);
           list.setAttribute("anonid", "addengine-menu");
           list.setAttribute("position", "topright topleft");
 
           // Events from child menupopups bubble up to the autocomplete binding,
           // which breaks it, so prevent these events from propagating.
           let suppressEventTypes = [
             "popupshowing",
@@ -1638,17 +1630,17 @@
 
         // Finally, add the engines to the list.  If there aren't too many
         // engines, the list is the add-engines vbox.  Otherwise it's the
         // menupopup created earlier.  In the latter case, create menuitem
         // elements instead of buttons, because buttons don't get keyboard
         // handling for free inside menupopups.
         let eltType = tooManyEngines ? "menuitem" : "toolbarbutton";
         for (let engine of engines) {
-          let button = document.createElementNS(kXULNS, eltType);
+          let button = document.createXULElement(eltType);
           button.classList.add("addengine-item");
           if (!tooManyEngines) {
             button.classList.add("badged-button");
           }
           button.id = this.telemetryOrigin + "-add-engine-" +
                       this._fixUpEngineNameForID(engine.title);
           let label = this.bundle.formatStringFromName("cmd_addFoundEngine",
                                                        [engine.title], 1);
diff --git a/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm b/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm
--- a/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm
+++ b/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm
@@ -1,16 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 var EXPORTED_SYMBOLS = ["RecentlyClosedTabsAndWindowsMenuUtils"];
 
-const kNSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 ChromeUtils.defineModuleGetter(this, "PluralForm",
                                "resource://gre/modules/PluralForm.jsm");
 ChromeUtils.defineModuleGetter(this, "SessionStore",
                                "resource:///modules/sessionstore/SessionStore.jsm");
 
 var navigatorBundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
@@ -133,17 +131,17 @@ function setImage(aItem, aElement) {
  *        a document that can be used to create the entry
  * @param aMenuLabel
  *        the label the created entry will have
  * @param aFragment
  *        the fragment the created entry will be in
  */
 function createEntry(aTagName, aIsWindowsFragment, aIndex, aClosedTab,
                      aDocument, aMenuLabel, aFragment) {
-  let element = aDocument.createElementNS(kNSXUL, aTagName);
+  let element = aDocument.createXULElement(aTagName);
 
   element.setAttribute("label", aMenuLabel);
   if (aClosedTab.image) {
     setImage(aClosedTab, element);
   }
   if (!aIsWindowsFragment) {
     element.setAttribute("value", aIndex);
   }
@@ -191,21 +189,21 @@ function createEntry(aTagName, aIsWindow
  * @param aEntryCount
  *        the number of elements to be restored by this entry
  * @param aTagName
  *        the tag name that will be used when creating the UI entry
  */
 function createRestoreAllEntry(aDocument, aFragment, aPrefixRestoreAll,
                                 aIsWindowsFragment, aRestoreAllLabel,
                                 aEntryCount, aTagName) {
-  let restoreAllElements = aDocument.createElementNS(kNSXUL, aTagName);
+  let restoreAllElements = aDocument.createXULElement(aTagName);
   restoreAllElements.classList.add("restoreallitem");
   restoreAllElements.setAttribute("label", navigatorBundle.GetStringFromName(aRestoreAllLabel));
   restoreAllElements.setAttribute("oncommand",
                                   "for (var i = 0; i < " + aEntryCount + "; i++) undoClose" +
                                     (aIsWindowsFragment ? "Window" : "Tab") + "();");
   if (aPrefixRestoreAll) {
     aFragment.insertBefore(restoreAllElements, aFragment.firstChild);
   } else {
-    aFragment.appendChild(aDocument.createElementNS(kNSXUL, "menuseparator"));
+    aFragment.appendChild(aDocument.createXULElement("menuseparator"));
     aFragment.appendChild(restoreAllElements);
   }
 }
diff --git a/browser/extensions/formautofill/FormAutofillPreferences.jsm b/browser/extensions/formautofill/FormAutofillPreferences.jsm
--- a/browser/extensions/formautofill/FormAutofillPreferences.jsm
+++ b/browser/extensions/formautofill/FormAutofillPreferences.jsm
@@ -10,17 +10,16 @@
 
 var EXPORTED_SYMBOLS = ["FormAutofillPreferences"];
 
 // Add addresses enabled flag in telemetry environment for recording the number of
 // users who disable/enable the address autofill feature.
 const BUNDLE_URI = "chrome://formautofill/locale/formautofill.properties";
 const MANAGE_ADDRESSES_URL = "chrome://formautofill/content/manageAddresses.xhtml";
 const MANAGE_CREDITCARDS_URL = "chrome://formautofill/content/manageCreditCards.xhtml";
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://formautofill/FormAutofill.jsm");
 ChromeUtils.import("resource://formautofill/FormAutofillUtils.jsm");
 
 const {
   ENABLED_AUTOFILL_ADDRESSES_PREF,
   ENABLED_AUTOFILL_CREDITCARDS_PREF,
@@ -63,27 +62,27 @@ FormAutofillPreferences.prototype = {
 
   /**
    * Create Form Autofill preference group
    *
    * @param  {XULDocument} document
    */
   createPreferenceGroup(document) {
     let learnMoreURL = Services.urlFormatter.formatURLPref("app.support.baseURL") + "autofill-card-address";
-    let formAutofillGroup = document.createElementNS(XUL_NS, "vbox");
-    let addressAutofill = document.createElementNS(XUL_NS, "hbox");
-    let addressAutofillCheckboxGroup = document.createElementNS(XUL_NS, "hbox");
-    let addressAutofillCheckbox = document.createElementNS(XUL_NS, "checkbox");
-    let addressAutofillCheckboxLabel = document.createElementNS(XUL_NS, "label");
-    let addressAutofillCheckboxLabelSpacer = document.createElementNS(XUL_NS, "spacer");
-    let addressAutofillLearnMore = document.createElementNS(XUL_NS, "label");
-    let savedAddressesBtn = document.createElementNS(XUL_NS, "button");
+    let formAutofillGroup = document.createXULElement("vbox");
+    let addressAutofill = document.createXULElement("hbox");
+    let addressAutofillCheckboxGroup = document.createXULElement("hbox");
+    let addressAutofillCheckbox = document.createXULElement("checkbox");
+    let addressAutofillCheckboxLabel = document.createXULElement("label");
+    let addressAutofillCheckboxLabelSpacer = document.createXULElement("spacer");
+    let addressAutofillLearnMore = document.createXULElement("label");
+    let savedAddressesBtn = document.createXULElement("button");
     // Wrappers are used to properly compute the search tooltip positions
-    let savedAddressesBtnWrapper = document.createElementNS(XUL_NS, "hbox");
-    let savedCreditCardsBtnWrapper = document.createElementNS(XUL_NS, "hbox");
+    let savedAddressesBtnWrapper = document.createXULElement("hbox");
+    let savedCreditCardsBtnWrapper = document.createXULElement("hbox");
 
     savedAddressesBtn.className = "accessory-button";
     addressAutofillCheckboxLabelSpacer.className = "tail-with-learn-more";
     addressAutofillLearnMore.className = "learnMore text-link";
 
     formAutofillGroup.id = "formAutofillGroup";
     addressAutofill.id = "addressAutofill";
     addressAutofillLearnMore.id = "addressAutofillLearnMore";
@@ -124,23 +123,23 @@ FormAutofillPreferences.prototype = {
     this.refs = {
       formAutofillGroup,
       addressAutofillCheckbox,
       addressAutofillCheckboxLabel,
       savedAddressesBtn,
     };
 
     if (FormAutofill.isAutofillCreditCardsAvailable) {
-      let creditCardAutofill = document.createElementNS(XUL_NS, "hbox");
-      let creditCardAutofillCheckboxGroup = document.createElementNS(XUL_NS, "hbox");
-      let creditCardAutofillCheckbox = document.createElementNS(XUL_NS, "checkbox");
-      let creditCardAutofillCheckboxLabel = document.createElementNS(XUL_NS, "label");
-      let creditCardAutofillCheckboxLabelSpacer = document.createElementNS(XUL_NS, "spacer");
-      let creditCardAutofillLearnMore = document.createElementNS(XUL_NS, "label");
-      let savedCreditCardsBtn = document.createElementNS(XUL_NS, "button");
+      let creditCardAutofill = document.createXULElement("hbox");
+      let creditCardAutofillCheckboxGroup = document.createXULElement("hbox");
+      let creditCardAutofillCheckbox = document.createXULElement("checkbox");
+      let creditCardAutofillCheckboxLabel = document.createXULElement("label");
+      let creditCardAutofillCheckboxLabelSpacer = document.createXULElement("spacer");
+      let creditCardAutofillLearnMore = document.createXULElement("label");
+      let savedCreditCardsBtn = document.createXULElement("button");
       savedCreditCardsBtn.className = "accessory-button";
       creditCardAutofillCheckboxLabelSpacer.className = "tail-with-learn-more";
       creditCardAutofillLearnMore.className = "learnMore text-link";
 
       creditCardAutofill.id = "creditCardAutofill";
       creditCardAutofillLearnMore.id = "creditCardAutofillLearnMore";
 
       creditCardAutofill.setAttribute("data-subcategory", "credit-card-autofill");
diff --git a/browser/modules/TabsList.jsm b/browser/modules/TabsList.jsm
--- a/browser/modules/TabsList.jsm
+++ b/browser/modules/TabsList.jsm
@@ -3,17 +3,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 ChromeUtils.defineModuleGetter(this, "PanelMultiView",
                                "resource:///modules/PanelMultiView.jsm");
 
 var EXPORTED_SYMBOLS = ["TabsPanel"];
-const NSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 function setAttributes(element, attrs) {
   for (let [name, value] of Object.entries(attrs)) {
     if (value) {
       element.setAttribute(name, value);
     } else {
       element.removeAttribute(name);
     }
@@ -211,34 +210,34 @@ class TabsPanel extends TabsListBase {
 
   _cleanupListeners() {
     super._cleanupListeners();
     this.panelMultiView.removeEventListener(TABS_PANEL_EVENTS.hide, this);
   }
 
   _createRow(tab) {
     let {doc} = this;
-    let row = doc.createElementNS(NSXUL, "toolbaritem");
+    let row = doc.createXULElement("toolbaritem");
     row.setAttribute("class", "all-tabs-item");
     if (this.className) {
       row.classList.add(this.className);
     }
     row.tab = tab;
     row.addEventListener("command", this);
     this.tabToElement.set(tab, row);
 
-    let button = doc.createElementNS(NSXUL, "toolbarbutton");
+    let button = doc.createXULElement("toolbarbutton");
     button.setAttribute("class", "all-tabs-button subviewbutton subviewbutton-iconic");
     button.setAttribute("flex", "1");
     button.setAttribute("crop", "right");
     button.tab = tab;
 
     row.appendChild(button);
 
-    let secondaryButton = doc.createElementNS(NSXUL, "toolbarbutton");
+    let secondaryButton = doc.createXULElement("toolbarbutton");
     secondaryButton.setAttribute(
       "class", "all-tabs-secondary-button subviewbutton subviewbutton-iconic");
     secondaryButton.setAttribute("closemenu", "none");
     secondaryButton.setAttribute("toggle-mute", "true");
     secondaryButton.tab = tab;
     row.appendChild(secondaryButton);
 
     this._setRowAttributes(row, tab);
diff --git a/devtools/client/framework/menu.js b/devtools/client/framework/menu.js
--- a/devtools/client/framework/menu.js
+++ b/devtools/client/framework/menu.js
@@ -1,17 +1,16 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const EventEmitter = require("devtools/shared/event-emitter");
 const { getCurrentZoom } = require("devtools/shared/layout/utils");
 
 /**
  * A partial implementation of the Menu API provided by electron:
  * https://github.com/electron/electron/blob/master/docs/api/menu.md.
  *
  * Extra features:
@@ -79,29 +78,29 @@ Menu.prototype.popupWithZoom = function(
  * @param Toolbox toolbox (non standard)
  *        Needed so we in which window to inject XUL
  */
 Menu.prototype.popup = function(screenX, screenY, toolbox) {
   const doc = toolbox.doc;
 
   let popupset = doc.querySelector("popupset");
   if (!popupset) {
-    popupset = doc.createElementNS(XUL_NS, "popupset");
+    popupset = doc.createXULElement("popupset");
     doc.documentElement.appendChild(popupset);
   }
   // See bug 1285229, on Windows, opening the same popup multiple times in a
   // row ends up duplicating the popup. The newly inserted popup doesn't
   // dismiss the old one. So remove any previously displayed popup before
   // opening a new one.
   let popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
   if (popup) {
     popup.hidePopup();
   }
 
-  popup = doc.createElementNS(XUL_NS, "menupopup");
+  popup = doc.createXULElement("menupopup");
   popup.setAttribute("menu-api", "true");
   popup.setAttribute("consumeoutsideclicks", "true");
 
   if (this.id) {
     popup.id = this.id;
   }
   this._createMenuItems(popup);
 
@@ -126,28 +125,28 @@ Menu.prototype.popup = function(screenX,
 Menu.prototype._createMenuItems = function(parent) {
   const doc = parent.ownerDocument;
   this.menuitems.forEach(item => {
     if (!item.visible) {
       return;
     }
 
     if (item.submenu) {
-      const menupopup = doc.createElementNS(XUL_NS, "menupopup");
+      const menupopup = doc.createXULElement("menupopup");
       item.submenu._createMenuItems(menupopup);
 
-      const menu = doc.createElementNS(XUL_NS, "menu");
+      const menu = doc.createXULElement("menu");
       menu.appendChild(menupopup);
       applyItemAttributesToNode(item, menu);
       parent.appendChild(menu);
     } else if (item.type === "separator") {
-      const menusep = doc.createElementNS(XUL_NS, "menuseparator");
+      const menusep = doc.createXULElement("menuseparator");
       parent.appendChild(menusep);
     } else {
-      const menuitem = doc.createElementNS(XUL_NS, "menuitem");
+      const menuitem = doc.createXULElement("menuitem");
       applyItemAttributesToNode(item, menuitem);
 
       menuitem.addEventListener("command", () => {
         item.click();
       });
       menuitem.addEventListener("DOMMenuItemActive", () => {
         item.hover();
       });
diff --git a/devtools/client/framework/sidebar.js b/devtools/client/framework/sidebar.js
--- a/devtools/client/framework/sidebar.js
+++ b/devtools/client/framework/sidebar.js
@@ -6,18 +6,16 @@
 
 var Services = require("Services");
 var EventEmitter = require("devtools/shared/event-emitter");
 var Telemetry = require("devtools/client/shared/telemetry");
 
 const {LocalizationHelper} = require("devtools/shared/l10n");
 const L10N = new LocalizationHelper("devtools/client/locales/toolbox.properties");
 
-const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 /**
  * ToolSidebar provides methods to register tabs in the sidebar.
  * It's assumed that the sidebar contains a xul:tabbox.
  * Typically, you'll want the tabbox parameter to be a XUL tabbox like this:
  *
  * <tabbox id="inspector-sidebar" handleCtrlTab="false" class="devtools-sidebar-tabs">
  *   <tabs/>
  *   <tabpanels flex="1"/>
@@ -113,36 +111,36 @@ ToolSidebar.prototype = {
   addAllTabsMenu: function() {
     if (this._allTabsBtn) {
       return;
     }
 
     const tabs = this._tabbox.tabs;
 
     // Create a container and insert it first in the tabbox
-    const allTabsContainer = this._panelDoc.createElementNS(XULNS, "stack");
+    const allTabsContainer = this._panelDoc.createXULElement("stack");
     this._tabbox.insertBefore(allTabsContainer, tabs);
 
     // Move the tabs inside and make them flex
     allTabsContainer.appendChild(tabs);
     tabs.setAttribute("flex", "1");
 
     // Create the dropdown menu next to the tabs
-    this._allTabsBtn = this._panelDoc.createElementNS(XULNS, "toolbarbutton");
+    this._allTabsBtn = this._panelDoc.createXULElement("toolbarbutton");
     this._allTabsBtn.setAttribute("class", "devtools-sidebar-alltabs");
     this._allTabsBtn.setAttribute("end", "0");
     this._allTabsBtn.setAttribute("top", "0");
     this._allTabsBtn.setAttribute("width", "15");
     this._allTabsBtn.setAttribute("type", "menu");
     this._allTabsBtn.setAttribute("tooltiptext",
       L10N.getStr("sidebar.showAllTabs.tooltip"));
     this._allTabsBtn.setAttribute("hidden", "true");
     allTabsContainer.appendChild(this._allTabsBtn);
 
-    const menuPopup = this._panelDoc.createElementNS(XULNS, "menupopup");
+    const menuPopup = this._panelDoc.createXULElement("menupopup");
     this._allTabsBtn.appendChild(menuPopup);
 
     // Listening to tabs overflow event to toggle the alltabs button
     tabs.addEventListener("overflow", this._onTabBoxOverflow);
     tabs.addEventListener("underflow", this._onTabBoxUnderflow);
 
     // Add menuitems to the alltabs menu if there are already tabs in the
     // sidebar
@@ -184,17 +182,17 @@ ToolSidebar.prototype = {
   /**
    * Add an item in the allTabs menu for a given tab.
    */
   _addItemToAllTabsMenu: function(id, tab, options) {
     if (!this._allTabsBtn) {
       return;
     }
 
-    const item = this._panelDoc.createElementNS(XULNS, "menuitem");
+    const item = this._panelDoc.createXULElement("menuitem");
     const idPrefix = "sidebar-alltabs-item-";
     item.setAttribute("id", idPrefix + id);
     item.setAttribute("label", tab.getAttribute("label"));
     item.setAttribute("type", "checkbox");
     if (options.selected) {
       item.setAttribute("checked", true);
     }
     // The auto-checking of menuitems in this menu doesn't work, so let's do
@@ -225,24 +223,24 @@ ToolSidebar.prototype = {
    * @param {string} id The unique id for this tab.
    * @param {string} url The URL of the document to load in this new tab.
    * @param {Object} options A set of options for this new tab:
    * - {Boolean} selected Set to true to make this new tab selected by default.
    * - {String} insertBefore By default, the new tab is appended at the end of the
    * tabbox, pass the ID of an existing tab to insert it before that tab instead.
    */
   addTab: function(id, url, options = {}) {
-    const iframe = this._panelDoc.createElementNS(XULNS, "iframe");
+    const iframe = this._panelDoc.createXULElement("iframe");
     iframe.className = "iframe-" + id;
     iframe.setAttribute("flex", "1");
     iframe.setAttribute("src", url);
     iframe.tooltip = "aHTMLTooltip";
 
     // Creating the tab and adding it to the tabbox
-    const tab = this._panelDoc.createElementNS(XULNS, "tab");
+    const tab = this._panelDoc.createXULElement("tab");
 
     tab.setAttribute("id", this.TAB_ID_PREFIX + id);
     tab.setAttribute("crop", "end");
     // Avoid showing "undefined" while the tab is loading
     tab.setAttribute("label", "");
 
     if (options.insertBefore) {
       const referenceTab = this.getTab(options.insertBefore);
@@ -267,28 +265,28 @@ ToolSidebar.prototype = {
       if ("setPanel" in win) {
         win.setPanel(this._toolPanel, iframe);
       }
       this.emit(id + "-ready");
     };
 
     iframe.addEventListener("load", onIFrameLoaded, true);
 
-    const tabpanel = this._panelDoc.createElementNS(XULNS, "tabpanel");
+    const tabpanel = this._panelDoc.createXULElement("tabpanel");
     tabpanel.setAttribute("id", this.TABPANEL_ID_PREFIX + id);
     tabpanel.appendChild(iframe);
 
     if (options.insertBefore) {
       const referenceTabpanel = this.getTabPanel(options.insertBefore);
       this._tabbox.tabpanels.insertBefore(tabpanel, referenceTabpanel);
     } else {
       this._tabbox.tabpanels.appendChild(tabpanel);
     }
 
-    this._tooltip = this._panelDoc.createElementNS(XULNS, "tooltip");
+    this._tooltip = this._panelDoc.createXULElement("tooltip");
     this._tooltip.id = "aHTMLTooltip";
     tabpanel.appendChild(this._tooltip);
     this._tooltip.page = true;
 
     tab.linkedPanel = this.TABPANEL_ID_PREFIX + id;
 
     // We store the index of this tab.
     this._tabs.set(id, tab);
diff --git a/devtools/client/shared/widgets/TableWidget.js b/devtools/client/shared/widgets/TableWidget.js
--- a/devtools/client/shared/widgets/TableWidget.js
+++ b/devtools/client/shared/widgets/TableWidget.js
@@ -7,17 +7,16 @@ const EventEmitter = require("devtools/s
 loader.lazyRequireGetter(this, "setNamedTimeout",
   "devtools/client/shared/widgets/view-helpers", true);
 loader.lazyRequireGetter(this, "clearNamedTimeout",
   "devtools/client/shared/widgets/view-helpers", true);
 loader.lazyRequireGetter(this, "naturalSortCaseInsensitive",
   "devtools/client/shared/natural-sort", true);
 const {KeyCodes} = require("devtools/client/shared/keycodes");
 
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const AFTER_SCROLL_DELAY = 100;
 
 // Different types of events emitted by the Various components of the
 // TableWidget.
 const EVENTS = {
   CELL_EDIT: "cell-edit",
   COLUMN_SORTED: "column-sorted",
@@ -72,25 +71,25 @@ function TableWidget(node, options = {})
   this.emptyText = emptyText || "";
   this.uniqueId = uniqueId || "name";
   this.wrapTextInElements = wrapTextInElements || false;
   this.firstColumn = firstColumn || "";
   this.highlightUpdated = highlightUpdated || false;
   this.removableColumns = removableColumns !== false;
   this.cellContextMenuId = cellContextMenuId;
 
-  this.tbody = this.document.createElementNS(XUL_NS, "hbox");
+  this.tbody = this.document.createXULElement("hbox");
   this.tbody.className = "table-widget-body theme-body";
   this.tbody.setAttribute("flex", "1");
   this.tbody.setAttribute("tabindex", "0");
   this._parent.appendChild(this.tbody);
   this.afterScroll = this.afterScroll.bind(this);
   this.tbody.addEventListener("scroll", this.onScroll.bind(this));
 
-  this.placeholder = this.document.createElementNS(XUL_NS, "label");
+  this.placeholder = this.document.createXULElement("label");
   this.placeholder.className = "plain table-widget-empty-text";
   this.placeholder.setAttribute("flex", "1");
   this._parent.appendChild(this.placeholder);
 
   this.items = new Map();
   this.columns = new Map();
 
   // Setup the column headers context menu to allow users to hide columns at
@@ -639,21 +638,21 @@ TableWidget.prototype = {
   /**
    * Prepares the context menu for the headers of the table columns. This
    * context menu allows users to toggle various columns, only with an exception
    * of the unique columns and when only two columns are visible in the table.
    */
   setupHeadersContextMenu: function() {
     let popupset = this.document.getElementsByTagName("popupset")[0];
     if (!popupset) {
-      popupset = this.document.createElementNS(XUL_NS, "popupset");
+      popupset = this.document.createXULElement("popupset");
       this.document.documentElement.appendChild(popupset);
     }
 
-    this.menupopup = this.document.createElementNS(XUL_NS, "menupopup");
+    this.menupopup = this.document.createXULElement("menupopup");
     this.menupopup.id = "table-widget-column-select";
     this.menupopup.addEventListener("command", this.onPopupCommand);
     popupset.appendChild(this.menupopup);
     this.populateMenuPopup();
   },
 
   /**
    * Populates the header context menu with the names of the columns along with
@@ -673,17 +672,17 @@ TableWidget.prototype = {
       this.menupopup.firstChild.remove();
     }
 
     for (const column of this.columns.values()) {
       if (privateColumns.includes(column.id)) {
         continue;
       }
 
-      const menuitem = this.document.createElementNS(XUL_NS, "menuitem");
+      const menuitem = this.document.createXULElement("menuitem");
       menuitem.setAttribute("label", column.header.getAttribute("value"));
       menuitem.setAttribute("data-id", column.id);
       menuitem.setAttribute("type", "checkbox");
       menuitem.setAttribute("checked", !column.wrapper.getAttribute("hidden"));
       if (column.id == this.uniqueId) {
         menuitem.setAttribute("disabled", "true");
       }
       this.menupopup.appendChild(menuitem);
@@ -1040,32 +1039,32 @@ function Column(table, id, header) {
   this.table = table;
   this.cells = [];
   this.items = {};
 
   this.highlightUpdated = table.highlightUpdated;
 
   // This wrapping element is required solely so that position:sticky works on
   // the headers of the columns.
-  this.wrapper = this.document.createElementNS(XUL_NS, "vbox");
+  this.wrapper = this.document.createXULElement("vbox");
   this.wrapper.className = "table-widget-wrapper";
   this.wrapper.setAttribute("flex", "1");
   this.wrapper.setAttribute("tabindex", "0");
   this.tbody.appendChild(this.wrapper);
 
-  this.splitter = this.document.createElementNS(XUL_NS, "splitter");
+  this.splitter = this.document.createXULElement("splitter");
   this.splitter.className = "devtools-side-splitter";
   this.tbody.appendChild(this.splitter);
 
   this.column = this.document.createElementNS(HTML_NS, "div");
   this.column.id = id;
   this.column.className = "table-widget-column";
   this.wrapper.appendChild(this.column);
 
-  this.header = this.document.createElementNS(XUL_NS, "label");
+  this.header = this.document.createXULElement("label");
   this.header.className = "devtools-toolbar table-widget-column-header";
   this.header.setAttribute("value", header);
   this.column.appendChild(this.header);
   if (table.headersContextMenu) {
     this.header.setAttribute("context", table.headersContextMenu);
   }
   this.toggleColumn = this.toggleColumn.bind(this);
   this.table.on(EVENTS.HEADER_CONTEXT_MENU, this.toggleColumn);
@@ -1560,17 +1559,17 @@ Column.prototype = {
  * @param {Cell} nextCell
  *        The cell object which is next to this cell. null if this cell is last
  *        cell of the column
  */
 function Cell(column, item, nextCell) {
   const document = column.document;
 
   this.wrapTextInElements = column.wrapTextInElements;
-  this.label = document.createElementNS(XUL_NS, "label");
+  this.label = document.createXULElement("label");
   this.label.setAttribute("crop", "end");
   this.label.className = "plain table-widget-cell";
 
   if (nextCell) {
     column.column.insertBefore(this.label, nextCell.label);
   } else {
     column.column.appendChild(this.label);
   }
@@ -1732,17 +1731,17 @@ EditableFieldsEngine.prototype = {
 
   get isEditing() {
     return this.root && !this.textbox.hidden;
   },
 
   get textbox() {
     if (!this._textbox) {
       const doc = this.root.ownerDocument;
-      this._textbox = doc.createElementNS(XUL_NS, "textbox");
+      this._textbox = doc.createXULElement("textbox");
       this._textbox.id = this.INPUT_ID;
 
       this._textbox.setAttribute("flex", "1");
 
       this.onKeydown = this.onKeydown.bind(this);
       this._textbox.addEventListener("keydown", this.onKeydown);
 
       this.completeEdit = this.completeEdit.bind(this);
diff --git a/devtools/client/shared/widgets/tooltip/HTMLTooltip.js b/devtools/client/shared/widgets/tooltip/HTMLTooltip.js
--- a/devtools/client/shared/widgets/tooltip/HTMLTooltip.js
+++ b/devtools/client/shared/widgets/tooltip/HTMLTooltip.js
@@ -873,17 +873,17 @@ HTMLTooltip.prototype = {
   /**
    * Check if the tooltip's owner document is a XUL document.
    */
   _isXUL: function() {
     return this.doc.documentElement.namespaceURI === XUL_NS;
   },
 
   _createXulPanelWrapper: function() {
-    const panel = this.doc.createElementNS(XUL_NS, "panel");
+    const panel = this.doc.createXULElement("panel");
 
     // XUL panel is only a way to display DOM elements outside of the document viewport,
     // so disable all features that impact the behavior.
     panel.setAttribute("animate", false);
     panel.setAttribute("consumeoutsideclicks", false);
     panel.setAttribute("noautofocus", true);
     panel.setAttribute("ignorekeys", true);
     panel.setAttribute("tooltip", "aHTMLTooltip");
diff --git a/toolkit/components/gfx/SanityTest.js b/toolkit/components/gfx/SanityTest.js
--- a/toolkit/components/gfx/SanityTest.js
+++ b/toolkit/components/gfx/SanityTest.js
@@ -202,17 +202,17 @@ var listener = {
     switch (message.name) {
       case "gfxSanity:ContentLoaded":
         this.runSanityTest();
         break;
     }
   },
 
   onWindowLoaded() {
-    let browser = this.win.document.createElementNS(XUL_NS, "browser");
+    let browser = this.win.document.createXULElement("browser");
     browser.setAttribute("type", "content");
     browser.setAttribute("disableglobalhistory", "true");
 
     let remoteBrowser = Services.appinfo.browserTabsRemoteAutostart;
     browser.setAttribute("remote", remoteBrowser);
 
     browser.style.width = PAGE_WIDTH + "px";
     browser.style.height = PAGE_HEIGHT + "px";
diff --git a/toolkit/components/printing/content/printUtils.js b/toolkit/components/printing/content/printUtils.js
--- a/toolkit/components/printing/content/printUtils.js
+++ b/toolkit/components/printing/content/printUtils.js
@@ -538,20 +538,17 @@ var PrintUtils = {
       if (this._listener.activateBrowser) {
         this._listener.activateBrowser(this._sourceBrowser);
       } else {
         this._sourceBrowser.docShellIsActive = true;
       }
 
       // show the toolbar after we go into print preview mode so
       // that we can initialize the toolbar with total num pages
-      const XUL_NS =
-        "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
-      printPreviewTB = document.createElementNS(XUL_NS, "toolbar",
+      printPreviewTB = document.createXULElement("toolbar",
         { is: "printpreview-toolbar" });
       printPreviewTB.setAttribute("fullscreentoolbar", true);
       printPreviewTB.id = "print-preview-toolbar";
 
       let navToolbox = this._listener.getNavToolbox();
       navToolbox.parentNode.insertBefore(printPreviewTB, navToolbox);
       printPreviewTB.initialize(ppBrowser);
 
diff --git a/toolkit/components/thumbnails/BackgroundPageThumbs.jsm b/toolkit/components/thumbnails/BackgroundPageThumbs.jsm
--- a/toolkit/components/thumbnails/BackgroundPageThumbs.jsm
+++ b/toolkit/components/thumbnails/BackgroundPageThumbs.jsm
@@ -7,18 +7,16 @@ const EXPORTED_SYMBOLS = [
 ];
 
 const DEFAULT_CAPTURE_TIMEOUT = 30000; // ms
 const DESTROY_BROWSER_TIMEOUT = 60000; // ms
 const FRAME_SCRIPT_URL = "chrome://global/content/backgroundPageThumbsContent.js";
 
 const TELEMETRY_HISTOGRAM_ID_PREFIX = "FX_THUMBNAILS_BG_";
 
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 const ABOUT_NEWTAB_SEGREGATION_PREF = "privacy.usercontext.about_newtab_segregation.enabled";
 
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm", this);
 ChromeUtils.import("resource://gre/modules/PageThumbs.jsm");
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 // possible FX_THUMBNAILS_BG_CAPTURE_DONE_REASON_2 telemetry values
 const TEL_CAPTURE_DONE_OK = 0;
@@ -251,17 +249,17 @@ const BackgroundPageThumbs = {
    */
   _ensureBrowser() {
     if (this._thumbBrowser && !this._renewThumbBrowser)
       return;
 
     this._destroyBrowser();
     this._renewThumbBrowser = false;
 
-    let browser = this._parentWin.document.createElementNS(XUL_NS, "browser");
+    let browser = this._parentWin.document.createXULElement("browser");
     browser.setAttribute("type", "content");
     browser.setAttribute("remote", "true");
     browser.setAttribute("disableglobalhistory", "true");
 
     if (Services.prefs.getBoolPref(ABOUT_NEWTAB_SEGREGATION_PREF)) {
       // Use the private container for thumbnails.
       let privateIdentity =
         ContextualIdentityService.getPrivateIdentity("userContextIdInternal.thumbnail");
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -974,17 +974,17 @@
               ];
               // Reuse the item when its style is exactly equal to the previous style or
               // neither of their style are in the UNREUSEABLE_STYLES.
               reusable = originalType === style ||
                 !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
 
             } else {
               // need to create a new item
-              item = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "richlistitem");
+              item = document.createXULElement("richlistitem");
             }
 
             item.setAttribute("dir", this.style.direction);
             item.setAttribute("ac-image", image);
             item.setAttribute("ac-value", value);
             item.setAttribute("ac-label", label);
             item.setAttribute("ac-comment", comment);
             item.setAttribute("ac-text", trimmedSearchString);
diff --git a/toolkit/content/widgets/browser.xml b/toolkit/content/widgets/browser.xml
--- a/toolkit/content/widgets/browser.xml
+++ b/toolkit/content/widgets/browser.xml
@@ -1108,18 +1108,17 @@
             }
          ]]>
        </body>
      </method>
 
       <method name="_createAutoScrollPopup">
         <body>
           <![CDATA[
-            const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-            var popup = document.createElementNS(XUL_NS, "panel");
+            var popup = document.createXULElement("panel");
             popup.className = "autoscroller";
             // We set this attribute on the element so that mousemove
             // events can be handled by browser-content.js.
             popup.setAttribute("mousethrough", "always");
             popup.setAttribute("consumeoutsideclicks", "true");
             popup.setAttribute("rolluponmousewheel", "true");
             popup.setAttribute("hidden", "true");
             return popup;
diff --git a/toolkit/content/widgets/menu.xml b/toolkit/content/widgets/menu.xml
--- a/toolkit/content/widgets/menu.xml
+++ b/toolkit/content/widgets/menu.xml
@@ -59,26 +59,23 @@
         ]]></getter>
       </property>
 
       <!-- nsIDOMXULContainerElement interface -->
       <method name="appendItem">
         <parameter name="aLabel"/>
         <parameter name="aValue"/>
         <body>
-          const XUL_NS =
-            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
           var menupopup = this.menupopup;
           if (!menupopup) {
-            menupopup = this.ownerDocument.createElementNS(XUL_NS, "menupopup");
+            menupopup = this.ownerDocument.createXULElement("menupopup");
             this.appendChild(menupopup);
           }
 
-          var menuitem = this.ownerDocument.createElementNS(XUL_NS, "menuitem");
+          var menuitem = this.ownerDocument.createXULElement("menuitem");
           menuitem.setAttribute("label", aLabel);
           menuitem.setAttribute("value", aValue);
 
           return menupopup.appendChild(menuitem);
         </body>
       </method>
 
       <property name="itemCount" readonly="true">
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -313,20 +313,19 @@
       </method>
 
       <method name="appendItem">
         <parameter name="label"/>
         <parameter name="value"/>
         <parameter name="description"/>
         <body>
         <![CDATA[
-          const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
           var popup = this.menupopup ||
-                      this.appendChild(document.createElementNS(XULNS, "menupopup"));
-          var item = document.createElementNS(XULNS, "menuitem");
+                      this.appendChild(document.createXULElement("menupopup"));
+          var item = document.createXULElement("menuitem");
           item.setAttribute("label", label);
           item.setAttribute("value", value);
           if (description)
             item.setAttribute("description", description);
 
           popup.appendChild(item);
           return item;
         ]]>
diff --git a/toolkit/content/widgets/notification.xml b/toolkit/content/widgets/notification.xml
--- a/toolkit/content/widgets/notification.xml
+++ b/toolkit/content/widgets/notification.xml
@@ -107,18 +107,17 @@
             var notifications = this.allNotifications;
             var insertPos = null;
             for (var n = notifications.length - 1; n >= 0; n--) {
               if (notifications[n].priority < aPriority)
                 break;
               insertPos = notifications[n];
             }
 
-            const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-            var newitem = document.createElementNS(XULNS, "notification");
+            var newitem = document.createXULElement("notification");
             // Can't use instanceof in case this was created from a different document:
             let labelIsDocFragment = aLabel && typeof aLabel == "object" && aLabel.nodeType &&
                                      aLabel.nodeType == aLabel.DOCUMENT_FRAGMENT_NODE;
             if (!labelIsDocFragment)
               newitem.setAttribute("label", aLabel);
             newitem.setAttribute("value", aValue);
             if (aImage)
               newitem.setAttribute("image", aImage);
@@ -128,17 +127,17 @@
               // The notification-button-default class is added to the button
               // with isDefault set to true. If there is no such button, it is
               // added to the first button (unless that button has isDefault
               // set to false). There cannot be multiple default buttons.
               var defaultElem;
 
               for (var b = 0; b < aButtons.length; b++) {
                 var button = aButtons[b];
-                var buttonElem = document.createElementNS(XULNS, "button");
+                var buttonElem = document.createXULElement("button");
                 buttonElem.setAttribute("label", button.label);
                 if (typeof button.accessKey == "string")
                   buttonElem.setAttribute("accesskey", button.accessKey);
                 if (typeof button.type == "string") {
                   buttonElem.setAttribute("type", button.type);
                   if ((button.type == "menu-button" || button.type == "menu") &&
                       "popup" in button) {
                     buttonElem.appendChild(button.popup);
diff --git a/toolkit/content/widgets/radio.xml b/toolkit/content/widgets/radio.xml
--- a/toolkit/content/widgets/radio.xml
+++ b/toolkit/content/widgets/radio.xml
@@ -301,18 +301,17 @@
         </body>
       </method>
 
       <method name="appendItem">
         <parameter name="label"/>
         <parameter name="value"/>
         <body>
         <![CDATA[
-          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-          var radio = document.createElementNS(XULNS, "radio");
+          var radio = document.createXULElement("radio");
           radio.setAttribute("label", label);
           radio.setAttribute("value", value);
           this.appendChild(radio);
           this._radioChildren = null;
           return radio;
         ]]>
         </body>
       </method>
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -112,24 +112,21 @@
         ]]>
         </body>
       </method>
 
       <method name="appendItem">
         <parameter name="aLabel"/>
         <parameter name="aValue"/>
         <body>
-          const XULNS =
-            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
           var item =
-            this.ownerDocument.createElementNS(XULNS, "richlistitem");
+            this.ownerDocument.createXULElement("richlistitem");
           item.setAttribute("value", aValue);
 
-          var label = this.ownerDocument.createElementNS(XULNS, "label");
+          var label = this.ownerDocument.createXULElement("label");
           label.setAttribute("value", aLabel);
           label.setAttribute("flex", "1");
           label.setAttribute("crop", "end");
           item.appendChild(label);
 
           this.appendChild(item);
 
           return item;
diff --git a/toolkit/content/widgets/tabbox.xml b/toolkit/content/widgets/tabbox.xml
--- a/toolkit/content/widgets/tabbox.xml
+++ b/toolkit/content/widgets/tabbox.xml
@@ -501,18 +501,17 @@
         </body>
       </method>
 
       <method name="appendItem">
         <parameter name="label"/>
         <parameter name="value"/>
         <body>
         <![CDATA[
-          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-          var tab = document.createElementNS(XULNS, "tab");
+          var tab = document.createXULElement("tab");
           tab.setAttribute("label", label);
           tab.setAttribute("value", value);
           this.appendChild(tab);
           return tab;
         ]]>
         </body>
       </method>
     </implementation>
diff --git a/toolkit/modules/PopupNotifications.jsm b/toolkit/modules/PopupNotifications.jsm
--- a/toolkit/modules/PopupNotifications.jsm
+++ b/toolkit/modules/PopupNotifications.jsm
@@ -782,32 +782,30 @@ PopupNotifications.prototype = {
     text.name = n.options.name || "";
     text.end = array[1] || "";
     return text;
   },
 
   _refreshPanel: function PopupNotifications_refreshPanel(notificationsToShow) {
     this._clearPanel();
 
-    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
     notificationsToShow.forEach(function(n) {
       let doc = this.window.document;
 
       // Append "-notification" to the ID to try to avoid ID conflicts with other stuff
       // in the document.
       let popupnotificationID = n.id + "-notification";
 
       // If the chrome document provides a popupnotification with this id, use
       // that. Otherwise create it ad-hoc.
       let popupnotification = doc.getElementById(popupnotificationID);
       if (popupnotification)
         gNotificationParents.set(popupnotification, popupnotification.parentNode);
       else
-        popupnotification = doc.createElementNS(XUL_NS, "popupnotification");
+        popupnotification = doc.createXULElement("popupnotification");
 
       // Create the notification description element.
       let desc = this._formatDescriptionMessage(n);
       popupnotification.setAttribute("label", desc.start);
       popupnotification.setAttribute("name", desc.name);
       popupnotification.setAttribute("endlabel", desc.end);
 
       popupnotification.setAttribute("id", popupnotificationID);
@@ -879,17 +877,17 @@ PopupNotifications.prototype = {
 
         let secondaryAction = n.secondaryActions[0];
         popupnotification.setAttribute("secondarybuttonlabel", secondaryAction.label);
         popupnotification.setAttribute("secondarybuttonaccesskey", secondaryAction.accessKey);
         popupnotification.setAttribute("secondarybuttoncommand", "PopupNotifications._onButtonEvent(event, 'secondarybuttoncommand');");
 
         for (let i = 1; i < n.secondaryActions.length; i++) {
           let action = n.secondaryActions[i];
-          let item = doc.createElementNS(XUL_NS, "menuitem");
+          let item = doc.createXULElement("menuitem");
           item.setAttribute("label", action.label);
           item.setAttribute("accesskey", action.accessKey);
           item.notification = n;
           item.action = action;
 
           popupnotification.appendChild(item);
 
           // We can only record a limited number of actions in telemetry. If
diff --git a/toolkit/mozapps/update/content/history.js b/toolkit/mozapps/update/content/history.js
--- a/toolkit/mozapps/update/content/history.js
+++ b/toolkit/mozapps/update/content/history.js
@@ -1,15 +1,13 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-const NS_XUL  = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 var gUpdateHistory = {
   _view: null,
 
   /**
    * Initialize the User Interface
    */
   onLoad() {
     this._view = document.getElementById("historyItems");
@@ -30,17 +28,17 @@ var gUpdateHistory = {
         if (!update || !update.name)
           continue;
 
         // Don't display updates that are downloading since they don't have
         // valid statusText for the UI (bug 485493).
         if (!update.statusText)
           continue;
 
-        var element = document.createElementNS(NS_XUL, "richlistitem");
+        var element = document.createXULElement("richlistitem");
         element.className = "update";
         this._view.appendChild(element);
         element.name = bundle.getFormattedString("updateFullName",
           [update.name, update.buildID]);
         element.installDate = this._formatDate(update.installDate);
         if (update.detailsURL)
           element.detailsURL = update.detailsURL;
         else
