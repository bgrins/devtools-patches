# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  38b3c1d03a594664c6b32c35533734283c258f43
Bug 1392352 - Part 1 - Interpose gBrowser

diff --git a/browser/base/content/test/general/browser.ini b/browser/base/content/test/general/browser.ini
--- a/browser/base/content/test/general/browser.ini
+++ b/browser/base/content/test/general/browser.ini
@@ -462,16 +462,17 @@ skip-if = (os == "mac" && !e10s) # Bug 1
 support-files =
   close_beforeunload_opens_second_tab.html
   close_beforeunload.html
 # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
 [browser_tabs_isActive.js]
 # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
 [browser_tabs_owner.js]
 # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
+[browser_test_interposition.js]
 [browser_testOpenNewRemoteTabsFromNonRemoteBrowsers.js]
 run-if = e10s
 # DO NOT ADD MORE TESTS HERE. USE A TOPICAL DIRECTORY INSTEAD.
 [browser_trackingUI_1.js]
 tags = trackingprotection
 support-files =
   trackingPage.html
   benignPage.html
diff --git a/browser/base/content/test/general/browser_test_interposition.js b/browser/base/content/test/general/browser_test_interposition.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/test/general/browser_test_interposition.js
@@ -0,0 +1,17 @@
+
+window.eval(`
+window.TabBrowser = function() {
+    this.requiresAddonInterpositions = true;
+  }
+`);
+
+add_task(async function() {
+  window.foo = new TabBrowser();
+  dump("Accessing foo\n");
+  foo.bar;
+  dump("Done accessing foo\n");
+
+  delete window.foo;
+  delete window.TabBrowser;
+  ok(true);
+});
diff --git a/js/xpconnect/wrappers/AddonWrapper.cpp b/js/xpconnect/wrappers/AddonWrapper.cpp
--- a/js/xpconnect/wrappers/AddonWrapper.cpp
+++ b/js/xpconnect/wrappers/AddonWrapper.cpp
@@ -34,29 +34,48 @@ ReportASCIIErrorWithId(JSContext* cx, co
         return;
     JSAutoByteString bytes;
     if (!bytes.encodeUtf8(cx, idstr))
         return;
     JS_ReportErrorUTF8(cx, msg, bytes.ptr());
 }
 
 bool
+RequiresInterpositions(JSContext* cx, HandleObject target)
+{
+    bool requiresAddonInterpositions;
+
+    RootedObject unwrapped(cx, UncheckedUnwrap(target));
+    JSAutoCompartment ac(cx, unwrapped);
+
+    if (!JS_HasOwnProperty(cx, unwrapped, "requiresAddonInterpositions", &requiresAddonInterpositions)) {
+        return false;
+    }
+
+    // printf("Class: '%s' requiresAddonInterpositions: %d\n", JS_GetClass(unwrapped.get())->name, requiresAddonInterpositions);
+
+    return !requiresAddonInterpositions;
+}
+
+bool
 InterposeProperty(JSContext* cx, HandleObject target, const nsIID* iid, HandleId id,
                   MutableHandle<PropertyDescriptor> descriptor)
 {
-    // We only want to do interpostion on DOM instances and
-    // wrapped natives.
+    // We only want to do interpostion on DOM instances,
+    // wrapped natives, or if the object explicitly requests it.
     RootedObject unwrapped(cx, UncheckedUnwrap(target));
     const js::Class* clasp = js::GetObjectClass(unwrapped);
     bool isCPOW = jsipc::IsWrappedCPOW(unwrapped);
+
     if (!mozilla::dom::IsDOMClass(clasp) &&
         !IS_WN_CLASS(clasp) &&
         !IS_PROTO_CLASS(clasp) &&
         clasp != &OuterWindowProxyClass &&
-        !isCPOW) {
+        !isCPOW &&
+        !RequiresInterpositions(cx, target)) {
         return true;
     }
 
     XPCWrappedNativeScope* scope = ObjectScope(CurrentGlobalOrNull(cx));
     MOZ_ASSERT(scope->HasInterposition());
 
     nsCOMPtr<nsIAddonInterposition> interp = scope->GetInterposition();
     InterpositionWhitelist* wl = XPCWrappedNativeScope::GetInterpositionWhitelist(interp);
