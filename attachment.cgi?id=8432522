# HG changeset patch
# Parent 6d1665a6dfe5078647f901f3388a4bc408caf253
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 1014547 - part 4 - Add a css transform highlighter

diff --git a/browser/base/content/highlighter.css b/browser/base/content/highlighter.css
--- a/browser/base/content/highlighter.css
+++ b/browser/base/content/highlighter.css
@@ -65,8 +65,15 @@ html|*.highlighter-nodeinfobar-tagname {
 
 .highlighter-nodeinfobar-positioner[disabled] {
   visibility: hidden;
 }
 
 html|*.highlighter-nodeinfobar-tagname {
   text-transform: lowercase;
 }
+
+/*
+ * Css transform highlighter
+ */
+svg|svg.css-transform-root[hidden] {
+  display: none;
+}
diff --git a/browser/devtools/framework/toolbox-highlighter-utils.js b/browser/devtools/framework/toolbox-highlighter-utils.js
--- a/browser/devtools/framework/toolbox-highlighter-utils.js
+++ b/browser/devtools/framework/toolbox-highlighter-utils.js
@@ -194,17 +194,22 @@ exports.getHighlighterUtils = function(t
   });
 
   /**
    * If the main, box-model, highlighter isn't enough, or if multiple
    * highlighters are needed in parallel, this method can be used to return a
    * new instance of a highlighter actor, given a type.
    * The type of the highlighter passed must be known by the server.
    * The highlighter actor returned will have the show(nodeFront) and hide()
-   * methods and needs to be released by the consumer when not needed anymore
+   * methods and needs to be released by the consumer when not needed anymore.
+   * @return a promise that resolves to the highlighter
    */
   let getHighlighterByType = exported.getHighlighterByType = requireInspector(
   function*(typeName) {
-    return yield toolbox.inspector.getHighlighterByType(typeName);
+    if (toolbox._target.client.traits.hasCustomHighlighters) {
+      return yield toolbox.inspector.getHighlighterByType(typeName);
+    } else {
+      throw "The target doesn't support creating highlighters by type";
+    }
   });
 
   return exported;
 };
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -101,16 +101,20 @@ InspectorPanel.prototype = {
   get isOuterHTMLEditable() {
     return this._target.client.traits.editOuterHTML;
   },
 
   get hasUrlToImageDataResolver() {
     return this._target.client.traits.urlToImageDataResolver;
   },
 
+  get hasCustomHighlighters() {
+    return this._target.client.traits.hasCustomHighlighters;
+  },
+
   _deferredOpen: function(defaultSelection) {
     let deferred = promise.defer();
 
     this.onNewRoot = this.onNewRoot.bind(this);
     this.walker.on("new-root", this.onNewRoot);
 
     this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
     this.lastNodemenuItem = this.nodemenu.lastChild;
diff --git a/browser/devtools/inspector/test/browser_inspector_invalidate.js b/browser/devtools/inspector/test/browser_inspector_invalidate.js
--- a/browser/devtools/inspector/test/browser_inspector_invalidate.js
+++ b/browser/devtools/inspector/test/browser_inspector_invalidate.js
@@ -13,24 +13,32 @@ function test() {
 
     openInspector(aInspector => {
       inspector = aInspector;
       inspector.toolbox.highlighter.showBoxModel(getNodeFront(div)).then(runTest);
     });
   }
 
   function runTest() {
+    info("Checking that the highlighter has the right size");
     let rect = getSimpleBorderRect();
     is(rect.width, 100, "outline has the right width");
 
+    info("Changing the test element's size");
     div.style.width = "200px";
-    inspector.toolbox.once("highlighter-ready", testRectWidth);
+
+    info("Waiting for the next MozAfterPaint event to let the highlighter update");
+    addEventListener("MozAfterPaint", function onRepaint() {
+      removeEventListener("MozAfterPaint", onRepaint);
+      testRectWidth();
+    });
   }
 
   function testRectWidth() {
+    info("Checking that the highlighter has the right size after update");
     let rect = getSimpleBorderRect();
     is(rect.width, 200, "outline updated");
     finishUp();
   }
 
   function finishUp() {
     inspector.toolbox.highlighter.hideBoxModel().then(() => {
       doc = div = inspector = null;
diff --git a/browser/devtools/styleinspector/computed-view.js b/browser/devtools/styleinspector/computed-view.js
--- a/browser/devtools/styleinspector/computed-view.js
+++ b/browser/devtools/styleinspector/computed-view.js
@@ -14,16 +14,17 @@ const {EventEmitter} = require("devtools
 const {OutputParser} = require("devtools/output-parser");
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const {PrefObserver, PREF_ORIG_SOURCES} = require("devtools/styleeditor/utils");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
+Cu.import("resource://gre/modules/Task.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PluralForm",
                                   "resource://gre/modules/PluralForm.jsm");
 
 const FILTER_CHANGED_TIMEOUT = 300;
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
@@ -181,16 +182,21 @@ function CssHtmlTree(aStyleInspector, aP
 
   // Properties preview tooltip
   this.tooltip = new Tooltip(this.styleInspector.inspector.panelDoc);
   this.tooltip.startTogglingOnHover(this.propertyContainer,
     this._onTooltipTargetHover.bind(this));
 
   this._buildContextMenu();
   this.createStyleViews();
+
+  if (this.styleInspector.inspector.hasCustomHighlighters) {
+    // Initialize the css transform highlighter
+    this._initTransformHighlighter();
+  }
 }
 
 /**
  * Memoized lookup of a l10n string from a string bundle.
  * @param {string} aName The key to lookup.
  * @returns A localized version of the given key.
  */
 CssHtmlTree.l10n = function CssHtmlTree_l10n(aName)
@@ -508,16 +514,75 @@ CssHtmlTree.prototype = {
    */
   focusWindow: function(aEvent)
   {
     let win = this.styleDocument.defaultView;
     win.focus();
   },
 
   /**
+   * Get the css transform highlighter front, initializing it if needed
+   * @param a promise that resolves to the highlighter
+   */
+  getTransformHighlighter: function() {
+    if (this.transformHighlighterPromise) {
+      return this.transformHighlighterPromise;
+    }
+
+    let utils = this.styleInspector.inspector.toolbox.highlighterUtils;
+    this.transformHighlighterPromise =
+    utils.getHighlighterByType("CssTransformHighlighter").then(highlighter => {
+      this.transformHighlighter = highlighter;
+      return this.transformHighlighter;
+    });
+
+    return this.transformHighlighterPromise;
+  },
+
+  _initTransformHighlighter: function() {
+    this.isTransformHighlighterShown = false;
+
+    this._onMouseMove = this._onMouseMove.bind(this);
+    this._onMouseLeave = this._onMouseLeave.bind(this);
+
+    this.propertyContainer.addEventListener("mousemove", this._onMouseMove, false);
+    this.propertyContainer.addEventListener("mouseleave", this._onMouseLeave, false);
+  },
+
+  _onMouseMove: function(event) {
+    if (event.target === this._lastHovered) {
+      return;
+    }
+
+    if (this.isTransformHighlighterShown) {
+      this.isTransformHighlighterShown = false;
+      this.getTransformHighlighter().then(highlighter => highlighter.hide());
+    }
+
+    this._lastHovered = event.target;
+    if (this._lastHovered.classList.contains("property-value")) {
+      let propName = this._lastHovered.parentNode.querySelector(".property-name");
+
+      if (propName.textContent === "transform") {
+        this.isTransformHighlighterShown = true;
+        let node = this.styleInspector.inspector.selection.nodeFront;
+        this.getTransformHighlighter().then(highlighter => highlighter.show(node));
+      }
+    }
+  },
+
+  _onMouseLeave: function(event) {
+    this._lastHovered = null;
+    if (this.isTransformHighlighterShown) {
+      this.isTransformHighlighterShown = false;
+      this.getTransformHighlighter().then(highlighter => highlighter.hide());
+    }
+  },
+
+  /**
    * Executed by the tooltip when the pointer hovers over an element of the view.
    * Used to decide whether the tooltip should be shown or not and to actually
    * put content in it.
    * Checks if the hovered target is a css value we support tooltips for.
    */
   _onTooltipTargetHover: function(target)
   {
     let inspector = this.styleInspector.inspector;
@@ -749,16 +814,26 @@ CssHtmlTree.prototype = {
       this._contextmenu.removeEventListener("popupshowing", this._contextMenuUpdate);
       this._contextmenu.parentNode.removeChild(this._contextmenu);
       this._contextmenu = null;
     }
 
     this.tooltip.stopTogglingOnHover(this.propertyContainer);
     this.tooltip.destroy();
 
+    if (this.transformHighlighter) {
+      this.transformHighlighter.finalize();
+      this.transformHighlighter = null;
+
+      this.propertyContainer.removeEventListener("mousemove", this._onMouseMove, false);
+      this.propertyContainer.removeEventListener("mouseleave", this._onMouseLeave, false);
+
+      this._lastHovered = null;
+    }
+
     // Remove bound listeners
     this.styleDocument.removeEventListener("contextmenu", this._onContextMenu);
     this.styleDocument.removeEventListener("copy", this._onCopy);
     this.styleDocument.removeEventListener("mousedown", this.focusWindow);
 
     // Nodes used in templating
     delete this.root;
     delete this.propertyContainer;
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1025,17 +1025,16 @@ TextProperty.prototype = {
     this.updateEditor();
   },
 
   remove: function() {
     this.rule.removeProperty(this);
   }
 };
 
-
 /**
  * View hierarchy mostly follows the model hierarchy.
  *
  * CssRuleView:
  *   Owns an ElementStyle and creates a list of RuleEditors for its
  *    Rules.
  * RuleEditor:
  *   Owns a Rule object and creates a list of TextPropertyEditors
@@ -1105,16 +1104,21 @@ function CssRuleView(aInspector, aDoc, a
     this._onTooltipTargetHover.bind(this));
 
   // Also create a more complex tooltip for editing colors with the spectrum
   // color picker
   this.colorPicker = new SwatchColorPickerTooltip(this.inspector.panelDoc);
 
   this._buildContextMenu();
   this._showEmpty();
+
+  if (this.inspector.hasCustomHighlighters) {
+    // Initialize the css transform highlighter
+    this._initTransformHighlighter();
+  }
 }
 
 exports.CssRuleView = CssRuleView;
 
 CssRuleView.prototype = {
   // The element that we're inspecting.
   _viewedElement: null,
 
@@ -1149,16 +1153,73 @@ CssRuleView.prototype = {
       popupset = doc.createElementNS(XUL_NS, "popupset");
       doc.documentElement.appendChild(popupset);
     }
 
     popupset.appendChild(this._contextmenu);
   },
 
   /**
+   * Get the css transform highlighter front, initializing it if needed
+   * @param a promise that resolves to the highlighter
+   */
+  getTransformHighlighter: function() {
+    if (this.transformHighlighterPromise) {
+      return this.transformHighlighterPromise;
+    }
+
+    let utils = this.inspector.toolbox.highlighterUtils;
+    this.transformHighlighterPromise =
+    utils.getHighlighterByType("CssTransformHighlighter").then(highlighter => {
+      this.transformHighlighter = highlighter;
+      return this.transformHighlighter;
+    });
+
+    return this.transformHighlighterPromise;
+  },
+
+  _initTransformHighlighter: function() {
+    this.isTransformHighlighterShown = false;
+
+    this._onMouseMove = this._onMouseMove.bind(this);
+    this._onMouseLeave = this._onMouseLeave.bind(this);
+
+    this.element.addEventListener("mousemove", this._onMouseMove, false);
+    this.element.addEventListener("mouseleave", this._onMouseLeave, false);
+  },
+
+  _onMouseMove: function(event) {
+    if (event.target === this._lastHovered) {
+      return;
+    }
+
+    if (this.isTransformHighlighterShown) {
+      this.isTransformHighlighterShown = false;
+      this.getTransformHighlighter().then(highlighter => highlighter.hide());
+    }
+
+    this._lastHovered = event.target;
+    let prop = event.target.textProperty;
+
+    if (prop && prop.name === "transform" && prop.enabled && !prop.overridden) {
+      this.isTransformHighlighterShown = true;
+      let node = this.inspector.selection.nodeFront;
+      this.getTransformHighlighter().then(highlighter => highlighter.show(node));
+    }
+  },
+
+  _onMouseLeave: function(event) {
+    this._lastHovered = null;
+    if (this.isTransformHighlighterShown) {
+      this.isTransformHighlighterShown = false;
+      this.getTransformHighlighter().then(highlighter => highlighter.hide());
+    }
+  },
+
+  /**
    * Which type of hover-tooltip should be shown for the given element?
    * This depends on the element: does it contain a URL, a font-family, ...
    * @param {DOMNode} el The element to test
    * @return {String} The type of hover-tooltip
    */
   _getHoverTooltipTypeForTarget: function(el) {
     let prop = el.textProperty;
 
@@ -1401,24 +1462,35 @@ CssRuleView.prototype = {
 
     // We manage the popupNode ourselves so we also need to destroy it.
     this.doc.popupNode = null;
 
     this.previewTooltip.stopTogglingOnHover(this.element);
     this.previewTooltip.destroy();
     this.colorPicker.destroy();
 
+    if (this.transformHighlighter) {
+      this.transformHighlighter.finalize();
+      this.transformHighlighter = null;
+
+      this.element.removeEventListener("mousemove", this._onMouseMove, false);
+      this.element.removeEventListener("mouseleave", this._onMouseLeave, false);
+
+      this._lastHovered = null;
+    }
+
     if (this.element.parentNode) {
       this.element.parentNode.removeChild(this.element);
     }
 
     if (this.elementStyle) {
       this.elementStyle.destroy();
     }
 
+
     this.popup.destroy();
   },
 
   /**
    * Update the highlighted element.
    *
    * @param {NodeActor} aElement
    *        The node whose style rules we'll inspect.
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -91,8 +91,12 @@ skip-if = os == "win" && debug # bug 963
 [browser_styleinspector_csslogic-specificity.js]
 [browser_styleinspector_inplace-editor.js]
 [browser_styleinspector_output-parser.js]
 [browser_styleinspector_tooltip-background-image.js]
 [browser_styleinspector_tooltip-closes-on-new-selection.js]
 [browser_styleinspector_tooltip-longhand-fontfamily.js]
 [browser_styleinspector_tooltip-shorthand-fontfamily.js]
 [browser_styleinspector_tooltip-size.js]
+[browser_styleinspector_transform-highlighter-01.js]
+[browser_styleinspector_transform-highlighter-02.js]
+[browser_styleinspector_transform-highlighter-03.js]
+[browser_styleinspector_transform-highlighter-04.js]
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-01.js b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-01.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-01.js
@@ -0,0 +1,38 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the css transform highlighter is created only when asked
+
+const PAGE_CONTENT = [
+  '<style type="text/css">',
+  '  body {',
+  '    transform: skew(16deg);',
+  '  }',
+  '</style>',
+  'Test the css transform highlighter'
+].join("\n");
+
+let test = asyncTest(function*() {
+  yield addTab("data:text/html," + PAGE_CONTENT);
+
+  let {view: rView} = yield openRuleView();
+
+  ok(!rView.transformHighlighter, "No highlighter exists in the rule-view");
+  let h = yield rView.getTransformHighlighter();
+  ok(rView.transformHighlighter, "The highlighter has been created in the rule-view");
+  is(h, rView.transformHighlighter, "The right highlighter has been created");
+  let h2 = yield rView.getTransformHighlighter();
+  is(h, h2, "The same instance of highlighter is returned everytime in the rule-view");
+
+  let {view: cView} = yield openComputedView();
+
+  ok(!cView.transformHighlighter, "No highlighter exists in the computed-view");
+  let h = yield cView.getTransformHighlighter();
+  ok(cView.transformHighlighter, "The highlighter has been created in the computed-view");
+  is(h, cView.transformHighlighter, "The right highlighter has been created");
+  let h2 = yield cView.getTransformHighlighter();
+  is(h, h2, "The same instance of highlighter is returned everytime in the computed-view");
+});
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-02.js b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-02.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-02.js
@@ -0,0 +1,54 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the css transform highlighter is created when hovering over a
+// transform property
+
+const PAGE_CONTENT = [
+  '<style type="text/css">',
+  '  body {',
+  '    transform: skew(16deg);',
+  '    color: yellow;',
+  '  }',
+  '</style>',
+  'Test the css transform highlighter'
+].join("\n");
+
+let test = asyncTest(function*() {
+  yield addTab("data:text/html," + PAGE_CONTENT);
+
+  let {view: rView} = yield openRuleView();
+  ok(!rView.transformHighlighter, "No highlighter exists in the rule-view (1)");
+
+  info("Faking a mousemove on a non-transform property");
+  let {valueSpan} = getRuleViewProperty(rView, "body", "color");
+  rView._onMouseMove({target: valueSpan});
+  ok(!rView.transformHighlighter, "No highlighter exists in the rule-view (2)");
+  ok(!rView.transformHighlighterPromise, "No highlighter is being initialized");
+
+  info("Faking a mousemove on a transform property");
+  let {valueSpan} = getRuleViewProperty(rView, "body", "transform");
+  rView._onMouseMove({target: valueSpan});
+  ok(rView.transformHighlighterPromise, "The highlighter is being initialized");
+  let h = yield rView.transformHighlighterPromise;
+  is(h, rView.transformHighlighter, "The initialized highlighter is the right one");
+
+  let {view: cView} = yield openComputedView();
+  ok(!cView.transformHighlighter, "No highlighter exists in the computed-view (1)");
+
+  info("Faking a mousemove on a non-transform property");
+  let {valueSpan} = getComputedViewProperty(cView, "color");
+  cView._onMouseMove({target: valueSpan});
+  ok(!cView.transformHighlighter, "No highlighter exists in the computed-view (2)");
+  ok(!cView.transformHighlighterPromise, "No highlighter is being initialized");
+
+  info("Faking a mousemove on a transform property");
+  let {valueSpan} = getComputedViewProperty(cView, "transform");
+  cView._onMouseMove({target: valueSpan});
+  ok(cView.transformHighlighterPromise, "The highlighter is being initialized");
+  let h = yield cView.transformHighlighterPromise;
+  is(h, cView.transformHighlighter, "The initialized highlighter is the right one");
+});
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-03.js b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-03.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-03.js
@@ -0,0 +1,89 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the css transform highlighter is shown when hovering over transform
+// properties
+
+// Note that in this test, we mock the highlighter front, merely testing the
+// behavior of the style-inspector UI for now
+
+const PAGE_CONTENT = [
+  '<style type="text/css">',
+  '  html {',
+  '    transform: scale(.9);',
+  '  }',
+  '  body {',
+  '    transform: skew(16deg);',
+  '    color: purple;',
+  '  }',
+  '</style>',
+  'Test the css transform highlighter'
+].join("\n");
+
+let test = asyncTest(function*() {
+  yield addTab("data:text/html," + PAGE_CONTENT);
+
+  let {inspector, view: rView} = yield openRuleView();
+
+  // Mock the highlighter front to get the reference of the NodeFront
+  let HighlighterFront = {
+    isShown: false,
+    nodeFront: null,
+    nbOfTimesShown: 0,
+    show: function(nodeFront) {
+      this.nodeFront = nodeFront;
+      this.isShown = true;
+      this.nbOfTimesShown ++;
+    },
+    hide: function() {
+      this.nodeFront = null;
+      this.isShown = false;
+    }
+  };
+
+  // Inject the mock highlighter in the rule-view
+  rView.transformHighlighterPromise = {
+    then: function(cb) {
+      cb(HighlighterFront);
+    }
+  };
+
+  let {valueSpan} = getRuleViewProperty(rView, "body", "transform");
+
+  info("Checking that the HighlighterFront's show/hide methods are called");
+  rView._onMouseMove({target: valueSpan});
+  ok(HighlighterFront.isShown, "The highlighter is shown");
+  rView._onMouseLeave();
+  ok(!HighlighterFront.isShown, "The highlighter is hidden");
+
+  info("Checking that hovering several times over the same property doesn't" +
+    " show the highlighter several times");
+  let nb = HighlighterFront.nbOfTimesShown;
+  rView._onMouseMove({target: valueSpan});
+  is(HighlighterFront.nbOfTimesShown, nb + 1, "The highlighter was shown once");
+  rView._onMouseMove({target: valueSpan});
+  rView._onMouseMove({target: valueSpan});
+  is(HighlighterFront.nbOfTimesShown, nb + 1,
+    "The highlighter was shown once, after several mousemove");
+
+  info("Checking that the right NodeFront reference is passed");
+  yield selectNode(content.document.documentElement, inspector);
+  let {valueSpan} = getRuleViewProperty(rView, "html", "transform");
+  rView._onMouseMove({target: valueSpan});
+  is(HighlighterFront.nodeFront.tagName, "HTML",
+    "The right NodeFront is passed to the highlighter (1)");
+
+  yield selectNode("body", inspector);
+  let {valueSpan} = getRuleViewProperty(rView, "body", "transform");
+  rView._onMouseMove({target: valueSpan});
+  is(HighlighterFront.nodeFront.tagName, "BODY",
+    "The right NodeFront is passed to the highlighter (2)");
+
+  info("Checking that the highlighter gets hidden when hovering a non-transform property");
+  let {valueSpan} = getRuleViewProperty(rView, "body", "color");
+  rView._onMouseMove({target: valueSpan});
+  ok(!HighlighterFront.isShown, "The highlighter is hidden");
+});
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-04.js b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-04.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_transform-highlighter-04.js
@@ -0,0 +1,58 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the css transform highlighter is shown only when hovering over a
+// transform declaration that isn't overriden or disabled
+
+// Note that unlike the other browser_styleinspector_transform-highlighter-N.js
+// tests, this one only tests the rule-view as only this view features disabled
+// and overriden properties
+
+const PAGE_CONTENT = [
+  '<style type="text/css">',
+  '  div {',
+  '    background: purple;',
+  '    width:300px;height:300px;',
+  '    transform: rotate(16deg);',
+  '  }',
+  '  .test {',
+  '    transform: skew(25deg);',
+  '  }',
+  '</style>',
+  '<div class="test"></div>'
+].join("\n");
+
+let test = asyncTest(function*() {
+  yield addTab("data:text/html," + PAGE_CONTENT);
+
+  let {view: rView, inspector} = yield openRuleView();
+  yield selectNode(".test", inspector);
+
+  info("Faking a mousemove on the overriden property");
+  let {valueSpan} = getRuleViewProperty(rView, "div", "transform");
+  rView._onMouseMove({target: valueSpan});
+  ok(!rView.transformHighlighter, "No highlighter was created for the overriden property");
+  ok(!rView.transformHighlighterPromise, "And no highlighter is being initialized either");
+
+  info("Disabling the applied property");
+  let classRuleEditor = rView.element.children[1]._ruleEditor;
+  let propEditor = classRuleEditor.rule.textProps[0].editor;
+  propEditor.enable.click();
+  yield classRuleEditor.rule._applyingModifications;
+
+  info("Faking a mousemove on the disabled property");
+  let {valueSpan} = getRuleViewProperty(rView, ".test", "transform");
+  rView._onMouseMove({target: valueSpan});
+  ok(!rView.transformHighlighter, "No highlighter was created for the disabled property");
+  ok(!rView.transformHighlighterPromise, "And no highlighter is being initialized either");
+
+  info("Faking a mousemove on the now unoverriden property");
+  let {valueSpan} = getRuleViewProperty(rView, "div", "transform");
+  rView._onMouseMove({target: valueSpan});
+  ok(rView.transformHighlighterPromise, "The highlighter is being initialized now");
+  let h = yield rView.transformHighlighterPromise;
+  is(h, rView.transformHighlighter, "The initialized highlighter is the right one");
+});
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -10,17 +10,17 @@ let {devtools} = Cu.import("resource://g
 let TargetFactory = devtools.TargetFactory;
 let {CssHtmlTree} = devtools.require("devtools/styleinspector/computed-view");
 let {CssRuleView, _ElementStyle} = devtools.require("devtools/styleinspector/rule-view");
 let {CssLogic, CssSelector} = devtools.require("devtools/styleinspector/css-logic");
 let {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 let {editableField, getInplaceEditorForSpan: inplaceEditor} = devtools.require("devtools/shared/inplace-editor");
 let {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 
-// All test are asynchronous
+// All tests are asynchronous
 waitForExplicitFinish();
 
 const TEST_URL_ROOT = "http://example.com/browser/browser/devtools/styleinspector/test/";
 const TEST_URL_ROOT_SSL = "https://example.com/browser/browser/devtools/styleinspector/test/";
 
 // Auto clean-up when a test ends
 registerCleanupFunction(() => {
   try {
@@ -31,16 +31,17 @@ registerCleanupFunction(() => {
   }
   while (gBrowser.tabs.length > 1) {
     gBrowser.removeCurrentTab();
   }
 });
 
 // Uncomment to log events
 // Services.prefs.setBoolPref("devtools.dump.emit", true);
+// Services.prefs.setBoolPref("devtools.debugger.log", true);
 
 // Set the testing flag on gDevTools and reset it when the test ends
 gDevTools.testing = true;
 registerCleanupFunction(() => gDevTools.testing = false);
 
 // Clean-up all prefs that might have been changed during a test run
 // (safer here because if the test fails, then the pref is never reverted)
 registerCleanupFunction(() => {
diff --git a/browser/themes/shared/devtools/highlighter.inc.css b/browser/themes/shared/devtools/highlighter.inc.css
--- a/browser/themes/shared/devtools/highlighter.inc.css
+++ b/browser/themes/shared/devtools/highlighter.inc.css
@@ -1,15 +1,16 @@
 %if 0
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 %endif
 
 /* Box model highlighter */
+
 svg|g.box-model-container {
   opacity: 0.4;
 }
 
 svg|polygon.box-model-content {
   fill: #80d4ff;
 }
 
@@ -95,8 +96,28 @@ html|*.highlighter-nodeinfobar-pseudo-cl
   margin-top: -8px;
   margin-bottom: 8px;
   background-image: linear-gradient(to bottom left, transparent 50%, hsl(210,2%,22%) 50%);
 }
 
 .highlighter-nodeinfobar-container[hide-arrow] > .highlighter-nodeinfobar {
   margin: 7px 0;
 }
+
+/* Css transform highlighter */
+
+svg|polygon.css-transform-transformed {
+  fill: #80d4ff;
+  opacity: 0.8;
+}
+
+svg|polygon.css-transform-untransformed {
+  fill: #66cc52;
+  opacity: 0.8;
+}
+
+svg|polygon.css-transform-transformed,
+svg|polygon.css-transform-untransformed,
+svg|line.css-transform-line {
+  stroke: #08C;
+  stroke-dasharray: 5 3;
+  stroke-width: 2;
+}
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -40,17 +40,17 @@ LayoutHelpers.prototype = {
     let [quads] = node.getBoxQuads({
       box: region
     });
 
     if (!quads) {
       return;
     }
 
-    let [xOffset, yOffset] = this._getNodeOffsets(node);
+    let [xOffset, yOffset] = this.getNodeOffsets(node);
     let scale = this.calculateScale(node);
 
     return {
       p1: {
         w: quads.p1.w * scale,
         x: quads.p1.x * scale + xOffset,
         y: quads.p1.y * scale + yOffset,
         z: quads.p1.z * scale
@@ -374,17 +374,17 @@ LayoutHelpers.prototype = {
   },
 
   /**
    * Get the x and y offsets for a node taking iframes into account.
    *
    * @param {DOMNode} node
    *        The node for which we are to get the offset
    */
-  _getNodeOffsets: function(node) {
+  getNodeOffsets: function(node) {
     let xOffset = 0;
     let yOffset = 0;
     let frameWin = node.ownerDocument.defaultView;
     let scale = this.calculateScale(node);
 
     while (true) {
       // Are we in the top-level window?
       if (this.isTopLevelWindow(frameWin)) {
@@ -415,17 +415,17 @@ LayoutHelpers.prototype = {
 
 
 
   /********************************************************************
    * GetBoxQuads POLYFILL START TODO: Remove this when bug 917755 is fixed.
    ********************************************************************/
   _getBoxQuadsFromRect: function(rect, node) {
     let scale = this.calculateScale(node);
-    let [xOffset, yOffset] = this._getNodeOffsets(node);
+    let [xOffset, yOffset] = this.getNodeOffsets(node);
 
     let out = {
       p1: {
         x: rect.left * scale + xOffset,
         y: rect.top * scale + yOffset
       },
       p2: {
         x: (rect.left + rect.width) * scale + xOffset,
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -4,16 +4,17 @@
 
 "use strict";
 
 const {Cu, Cc, Ci} = require("chrome");
 const Services = require("Services");
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method} = protocol;
 const events = require("sdk/event/core");
+const Heritage = require("sdk/core/heritage");
 
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const GUIDE_STROKE_WIDTH = 1;
 
 // Make sure the domnode type is known here
 require("devtools/server/actors/inspector");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
@@ -26,17 +27,18 @@ let HELPER_SHEET = ".__fx-devtools-hide-
 HELPER_SHEET += ":-moz-devtools-highlighted { outline: 2px dashed #F06!important; outline-offset: -2px!important } ";
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const SVG_NS = "http://www.w3.org/2000/svg";
 const HIGHLIGHTER_PICKED_TIMER = 1000;
 const INFO_BAR_OFFSET = 5;
 
 // All possible highlighter classes
 const HIGHLIGHTER_CLASSES = {
-  "BoxModelHighlighter": BoxModelHighlighter
+  "BoxModelHighlighter": BoxModelHighlighter,
+  "CssTransformHighlighter": CssTransformHighlighter
 };
 
 /**
  * The Highlighter is the server-side entry points for any tool that wishes to
  * highlight elements in some way in the content document.
  *
  * A little bit of vocabulary:
  * - <something>HighlighterActor classes are the actors that can be used from
@@ -107,17 +109,17 @@ let HighlighterActor = exports.Highlight
    * method several times won't display several highlighters, it will just move
    * the highlighter instance to these nodes.
    *
    * @param NodeActor The node to be highlighted
    * @param Options See the request part for existing options. Note that not
    * all options may be supported by all types of highlighters.
    */
   showBoxModel: method(function(node, options={}) {
-    if (node && isNodeValidForHighlighting(node.rawNode)) {
+    if (node && isNodeValid(node.rawNode)) {
       this._boxModelHighlighter.show(node.rawNode, options);
     } else {
       this._boxModelHighlighter.hide();
     }
   }, {
     request: {
       node: Arg(0, "domnode"),
       region: Option(1)
@@ -260,72 +262,189 @@ let CustomHighlighterActor = exports.Cus
   /**
    * Create a highlighter instance given its typename
    * The typename must be one of HIGHLIGHTER_CLASSES and the class must
    * implement constructor(tab, inspector), show(node), hide(), destroy()
    */
   initialize: function(inspector, typeName) {
     protocol.Actor.prototype.initialize.call(this, null);
 
+    this._inspector = inspector;
+
     let constructor = HIGHLIGHTER_CLASSES[typeName];
     if (!constructor) {
-      throw new Error(typeName + " isn't a valid highlighter class");
+      throw new Error(typeName + " isn't a valid highlighter class (" +
+        Object.keys(HIGHLIGHTER_CLASSES) + ")");
       return;
     }
 
     // The assumption is that all custom highlighters need a XUL parent in the
     // browser to append their elements
     if (supportXULBasedHighlighter(inspector.tabActor)) {
       this._highlighter = new constructor(inspector.tabActor, inspector);
     }
   },
 
   get conn() this._inspector && this._inspector.conn,
 
   destroy: function() {
     protocol.Actor.prototype.destroy.call(this);
-    if (this._highlighter) {
-      this._boxModelHighlighter.destroy();
-      this._boxModelHighlighter = null;
-    }
+    this.finalize();
   },
 
   /**
    * Display the highlighter on a given NodeActor.
    * @param NodeActor The node to be highlighted
-   * @param Options Passed to the highlighter's show function
    */
-  show: method(function(node, options={}) {
-    if (!node || !isNodeValidForHighlighting(node.rawNode) || !this._highlighter) {
+  show: method(function(node) {
+    if (!node || !isNodeValid(node.rawNode) || !this._highlighter) {
       return;
     }
 
-    this._highlighter.show(node.rawNode, options);
+    this._highlighter.show(node.rawNode);
   }, {
     request: {
-      node: Arg(0, "domnode"),
-      options: Arg(1, "json")
+      node: Arg(0, "domnode")
     }
   }),
 
   /**
    * Hide the highlighter if it was shown before
    */
   hide: method(function() {
     if (this._highlighter) {
       this._highlighter.hide();
     }
   }, {
     request: {}
+  }),
+
+  /**
+   * Kill this actor. This method is called automatically just before the actor
+   * is destroyed.
+   */
+  finalize: method(function() {
+    if (this._highlighter) {
+      this._highlighter.destroy();
+      this._highlighter = null;
+    }
+  }, {
+    oneway: true
   })
 });
 
 let CustomHighlighterFront = protocol.FrontClass(CustomHighlighterActor, {});
 
 /**
+ * Parent class for XUL-based complex highlighter that are inserted in the
+ * parent browser structure
+ */
+function XULBasedHighlighter(tabActor, inspector) {
+  this._inspector = inspector;
+
+  this.browser = tabActor.browser;
+  this.win = tabActor.window;
+  this.chromeDoc = this.browser.ownerDocument;
+  this.currentNode = null;
+
+  this.update = this.update.bind(this);
+}
+
+XULBasedHighlighter.prototype = {
+  /**
+   * Show the highlighter on a given node
+   * @param {DOMNode} node
+   */
+  show: function(node) {
+    if (!isNodeValid(node) || node === this.currentNode) {
+      return;
+    }
+
+    this._detachPageListeners();
+    this.currentNode = node;
+    this._attachPageListeners();
+    this._show();
+  },
+
+  /**
+   * Hide the highlighter
+   */
+  hide: function() {
+    if (!isNodeValid(this.currentNode)) {
+      return;
+    }
+
+    this._hide();
+    this._detachPageListeners();
+    this.currentNode = null;
+  },
+
+  /**
+   * Update the highlighter while shown
+   */
+  update: function() {
+    if (isNodeValid(this.currentNode)) {
+      this._update();
+    }
+  },
+
+  _show: function() {
+    // To be implemented by sub classes
+    // When called, sub classes should actually show the highlighter for
+    // this.currentNode
+  },
+
+  _update: function() {
+    // To be implemented by sub classes
+    // When called, sub classes should update the highlighter shown for
+    // this.currentNode
+    // This is called as a result of a page scroll, zoom or repaint
+  },
+
+  _hide: function() {
+    // To be implemented by sub classes
+    // When called, sub classes should actually hide the highlighter
+  },
+
+  /**
+   * Listen to changes on the content page to update the highlighter
+   */
+  _attachPageListeners: function() {
+    if (isNodeValid(this.currentNode)) {
+      let win = this.currentNode.ownerDocument.defaultView;
+      win.addEventListener("scroll", this.update, false);
+      win.addEventListener("resize", this.update, false);
+      this.browser.addEventListener("MozAfterPaint", this.update, false);
+    }
+  },
+
+  /**
+   * Stop listening to page changes
+   */
+  _detachPageListeners: function() {
+    if (isNodeValid(this.currentNode)) {
+      let win = this.currentNode.ownerDocument.defaultView;
+      win.removeEventListener("scroll", this.update, false);
+      win.removeEventListener("resize", this.update, false);
+      this.browser.removeEventListener("MozAfterPaint", this.update, false);
+    }
+  },
+
+  destroy: function() {
+    this.hide();
+
+    this.win = null;
+    this.browser = null;
+    this.chromeDoc = null;
+    this._inspector = null;
+    this.currentNode = null;
+  }
+};
+
+/**
  * The BoxModelHighlighter is the class that actually draws the the box model
  * regions on top of a node.
  * It is used by the HighlighterActor.
  *
  * Usage example:
  *
  * let h = new BoxModelHighlighter(browser);
  * h.show(node);
@@ -358,36 +477,23 @@ let CustomHighlighterFront = protocol.Fr
  *         </hbox>
  *       </hbox>
  *       <box class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-bottom"/>
  *     </box>
  *   </box>
  * </stack>
  */
 function BoxModelHighlighter(tabActor, inspector) {
-  this.browser = tabActor.browser;
-  this.win = tabActor.window;
-  this.chromeDoc = this.browser.ownerDocument;
-  this.chromeWin = this.chromeDoc.defaultView;
-  this._inspector = inspector;
-
+  XULBasedHighlighter.call(this, tabActor, inspector);
   this.layoutHelpers = new LayoutHelpers(this.win);
-  this.chromeLayoutHelper = new LayoutHelpers(this.chromeWin);
-
-  this.transitionDisabler = null;
-  this.pageEventsMuter = null;
-  this._update = this._update.bind(this);
-  this.handleEvent = this.handleEvent.bind(this);
-  this.currentNode = null;
-
+  this._initMarkup();
   EventEmitter.decorate(this);
-  this._initMarkup();
 }
 
-BoxModelHighlighter.prototype = {
+BoxModelHighlighter.prototype = Heritage.extend(XULBasedHighlighter.prototype, {
   get zoom() {
     return this.win.QueryInterface(Ci.nsIInterfaceRequestor)
                .getInterface(Ci.nsIDOMWindowUtils).fullZoom;
   },
 
   _initMarkup: function() {
     let stack = this.browser.parentNode;
 
@@ -495,49 +601,33 @@ BoxModelHighlighter.prototype = {
 
     return node;
   },
 
   /**
    * Destroy the nodes. Remove listeners.
    */
   destroy: function() {
-    this.hide();
-
-    this.chromeWin.clearTimeout(this.transitionDisabler);
-    this.chromeWin.clearTimeout(this.pageEventsMuter);
-
-    this.nodeInfo = null;
+    XULBasedHighlighter.prototype.destroy.call(this);
 
     this._highlighterContainer.remove();
     this._highlighterContainer = null;
 
+    this.nodeInfo = null;
     this.rect = null;
-    this.win = null;
-    this.browser = null;
-    this.chromeDoc = null;
-    this.chromeWin = null;
-    this.currentNode = null;
   },
 
   /**
    * Show the highlighter on a given node
-   *
-   * @param {DOMNode} node
    * @param {Object} options
    *        Object used for passing options
    */
-  show: function(node, options={}) {
-    this.currentNode = node;
-
-    this._showInfobar();
-    this._detachPageListeners();
-    this._attachPageListeners();
+  _show: function(options={}) {
     this._update();
-    this._trackMutations();
+    this.emit("ready");
   },
 
   _trackMutations: function() {
     if (this.currentNode) {
       let win = this.currentNode.ownerDocument.defaultView;
       this.currentNodeObserver = new win.MutationObserver(() => {
         this._update();
       });
@@ -563,39 +653,33 @@ BoxModelHighlighter.prototype = {
    * passed as an argument to show(node)).
    * Should be called whenever node size or attributes change
    * @param {Object} options
    *        Object used for passing options. Valid options are:
    *          - box: "content", "padding", "border" or "margin." This specifies
    *            the box that the guides should outline. Default is content.
    */
   _update: function(options={}) {
-    if (this.currentNode) {
-      if (this._highlightBoxModel(options)) {
-        this._showInfobar();
-      } else {
-        // Nothing to highlight (0px rectangle like a <script> tag for instance)
-        this.hide();
-      }
-      this.emit("ready");
+    if (this._updateBoxModel(options)) {
+      this._showInfobar();
+      this._showBoxModel();
+      this._trackMutations();
+    } else {
+      // Nothing to highlight (0px rectangle like a <script> tag for instance)
+      this._hide();
     }
   },
 
   /**
    * Hide the highlighter, the outline and the infobar.
    */
-  hide: function() {
-    if (this.currentNode) {
-      this._untrackMutations();
-      this.currentNode = null;
-      this._hideBoxModel();
-      this._hideInfobar();
-      this._detachPageListeners();
-    }
-    this.emit("hide");
+  _hide: function() {
+    this._untrackMutations();
+    this._hideBoxModel();
+    this._hideInfobar();
   },
 
   /**
    * Hide the infobar
    */
   _hideInfobar: function() {
     this.nodeInfo.positioner.setAttribute("hidden", "true");
   },
@@ -618,68 +702,55 @@ BoxModelHighlighter.prototype = {
   /**
    * Show the box model
    */
   _showBoxModel: function() {
     this._svgRoot.removeAttribute("hidden");
   },
 
   /**
-   * Highlight the box model.
+   * Update the box model as per the current node
    *
    * @param {Object} options
    *        Object used for passing options. Valid options are:
    *          - region: "content", "padding", "border" or "margin." This specifies
    *            the region that the guides should outline. Default is content.
    * @return {boolean}
-   *         True if the rectangle was highlighted, false otherwise.
+   *         True if the current node has a box model to be highlighted
    */
-  _highlightBoxModel: function(options) {
-    let isShown = false;
-
+  _updateBoxModel: function(options) {
     options.region = options.region || "content";
 
     // TODO: Remove this polyfill
     this.rect =
       this.layoutHelpers.getAdjustedQuadsPolyfill(this.currentNode, "margin");
 
-    if (!this.rect) {
-      return null;
+    if (!this.rect ||
+        (this.rect.bounds.width <= 0 && this.rect.bounds.height <= 0)) {
+      return false;
     }
 
-    if (this.rect.bounds.width > 0 && this.rect.bounds.height > 0) {
-      for (let boxType in this._boxModelNodes) {
-        // TODO: Remove this polyfill
-        let {p1, p2, p3, p4} = boxType === "margin" ? this.rect :
-          this.layoutHelpers.getAdjustedQuadsPolyfill(this.currentNode, boxType);
+    for (let boxType in this._boxModelNodes) {
+      // TODO: Remove this polyfill
+      let {p1, p2, p3, p4} = boxType === "margin" ? this.rect :
+        this.layoutHelpers.getAdjustedQuadsPolyfill(this.currentNode, boxType);
 
-        let boxNode = this._boxModelNodes[boxType];
-        boxNode.setAttribute("points",
-                             p1.x + "," + p1.y + " " +
-                             p2.x + "," + p2.y + " " +
-                             p3.x + "," + p3.y + " " +
-                             p4.x + "," + p4.y);
+      let boxNode = this._boxModelNodes[boxType];
+      boxNode.setAttribute("points",
+                           p1.x + "," + p1.y + " " +
+                           p2.x + "," + p2.y + " " +
+                           p3.x + "," + p3.y + " " +
+                           p4.x + "," + p4.y);
 
-        if (boxType === options.region) {
-          this._showGuides(p1, p2, p3, p4);
-        }
-      }
-
-      isShown = true;
-      this._showBoxModel();
-    } else {
-      // Only return false if the element really is invisible.
-      // A height of 0 and a non-0 width corresponds to a visible element that
-      // is below the fold for instance
-      if (this.rect.width > 0 || this.rect.height > 0) {
-        isShown = true;
-        this._hideBoxModel();
+      if (boxType === options.region) {
+        this._showGuides(p1, p2, p3, p4);
       }
     }
-    return isShown;
+
+    return true;
   },
 
   /**
    * We only want to show guides for horizontal and vertical edges as this helps
    * to line them up. This method finds these edges and displays a guide there.
    *
    * @param  {DOMPoint} p1
    *                    Point 1
@@ -831,54 +902,220 @@ BoxModelHighlighter.prototype = {
       }
       this.nodeInfo.positioner.style.left = left + "px";
     } else {
       this.nodeInfo.positioner.style.left = "0";
       this.nodeInfo.positioner.style.top = "0";
       this.nodeInfo.positioner.setAttribute("position", "top");
       this.nodeInfo.positioner.setAttribute("hide-arrow", "true");
     }
+  }
+});
+
+/**
+ * The CssTransformHighlighter is the class that draws an outline around a
+ * transformed element and an outline around where it would be if untransformed
+ * as well as arrows connecting the 2 outlines' corners.
+ */
+function CssTransformHighlighter(tabActor, inspector) {
+  XULBasedHighlighter.call(this, tabActor, inspector);
+
+  this.layoutHelpers = new LayoutHelpers(tabActor.window);
+  this._initMarkup();
+}
+
+let MARKER_COUNTER = 1;
+
+CssTransformHighlighter.prototype = Heritage.extend(XULBasedHighlighter.prototype, {
+  _initMarkup: function() {
+    let stack = this.browser.parentNode;
+
+    this._container = this.chromeDoc.createElement("stack");
+    this._container.className = "highlighter-container";
+
+    this._svgRoot = this._createSVGNode("root", "svg", this._container);
+    this._svgRoot.setAttribute("hidden", "true");
+
+    // Add a marker tag to the svg root for the arrow tip
+    let marker = this.chromeDoc.createElementNS(SVG_NS, "marker");
+    let markerId = "css-transform-arrow-marker-" + MARKER_COUNTER;
+    MARKER_COUNTER ++;
+    marker.setAttribute("id", markerId);
+    marker.setAttribute("markerWidth", "10");
+    marker.setAttribute("markerHeight", "5");
+    marker.setAttribute("orient", "auto");
+    marker.setAttribute("markerUnits", "strokeWidth");
+    marker.setAttribute("refX", "0");
+    marker.setAttribute("refY", "5");
+    marker.setAttribute("viewBox", "0 0 10 10");
+    let path = this.chromeDoc.createElementNS(SVG_NS, "path");
+    path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
+    path.setAttribute("fill", "#08C");
+    marker.appendChild(path);
+    this._svgRoot.appendChild(marker);
+
+    // Create the 2 polygons (transformed and unstransformed)
+    let shapesGroup = this._createSVGNode("container", "g", this._svgRoot);
+    this._shapes = {
+      untransformed: this._createSVGNode("untransformed", "polygon", shapesGroup),
+      transformed: this._createSVGNode("transformed", "polygon", shapesGroup)
+    };
+
+    // Create the arrows
+    for (let nb of ["1", "2", "3", "4"]) {
+      let line = this._createSVGNode("line", "line", shapesGroup);
+      line.setAttribute("marker-end", "url(#" + markerId + ")");
+      this._shapes["line" + nb] = line;
+    }
+
+    this._container.appendChild(this._svgRoot);
+
+    // Insert the highlighter right after the browser
+    stack.insertBefore(this._container, stack.childNodes[1]);
   },
 
-  _attachPageListeners: function() {
-    if (this.currentNode) {
-      let win = this.currentNode.ownerGlobal;
+  _createSVGNode: function(classPostfix, nodeType, parent) {
+    let node = this.chromeDoc.createElementNS(SVG_NS, nodeType);
+    node.setAttribute("class", "css-transform-" + classPostfix);
 
-      win.addEventListener("scroll", this, false);
-      win.addEventListener("resize", this, false);
-      win.addEventListener("MozAfterPaint", this, false);
+    parent.appendChild(node);
+    return node;
+  },
+
+  /**
+   * Destroy the nodes. Remove listeners.
+   */
+  destroy: function() {
+    XULBasedHighlighter.prototype.destroy.call(this);
+
+    this._container.remove();
+    this._container = null;
+  },
+
+  /**
+   * Show the highlighter on a given node
+   * @param {DOMNode} node
+   */
+  _show: function() {
+    // Bail out if the node isn't transformed
+    let transform = this.currentNode.ownerDocument.defaultView
+      .getComputedStyle(this.currentNode).transform;
+    if (transform === "none") {
+      return;
+    }
+
+    this._update();
+  },
+
+  _setPolygonPoints: function(quad, poly) {
+    let points = [];
+    for (let point of ["p1","p2", "p3", "p4"]) {
+      points.push(quad[point].x + "," + quad[point].y);
+    }
+    poly.setAttribute("points", points.join(" "));
+  },
+
+  _setLinePoints: function(p1, p2, line) {
+    line.setAttribute("x1", p1.x);
+    line.setAttribute("y1", p1.y);
+    line.setAttribute("x2", p2.x);
+    line.setAttribute("y2", p2.y);
+  },
+
+  /**
+   * Update the highlighter on the current highlighted node (the one that was
+   * passed as an argument to show(node)).
+   * Should be called whenever node size or attributes change
+   */
+  _update: function() {
+    // Getting the points for the transformed shape
+    let quad = this.layoutHelpers.getAdjustedQuads(this.currentNode, "border");
+    if (!quad) {
+      return null;
+    }
+
+    // Getting the points for the untransformed shape
+    let untransformedQuad = this._getUntransformedQuad();
+
+    if (quad.bounds.width > 0 && quad.bounds.height > 0) {
+      this._setPolygonPoints(quad, this._shapes.transformed);
+      this._setPolygonPoints(untransformedQuad, this._shapes.untransformed);
+
+      for (let nb of ["1", "2", "3", "4"]) {
+        this._setLinePoints(untransformedQuad["p" + nb], quad["p" + nb],
+          this._shapes["line" + nb]);
+      }
+
+      this._showShapes();
+    } else {
+      this._hideShapes();
     }
   },
 
-  _detachPageListeners: function() {
-    if (this.currentNode) {
-      let win = this.currentNode.ownerGlobal;
+  _getUntransformedQuad: function() {
+    if (!this.currentNode) {
+      return;
+    }
 
-      win.removeEventListener("scroll", this, false);
-      win.removeEventListener("resize", this, false);
-      win.removeEventListener("MozAfterPaint", this, false);
+    // For transformed elements, only offsetWidth/Height/Top/Left will give us
+    // the right untransformed coordinates
+
+    // Find out the offset of the node in its current frame
+    let offsetLeft = 0;
+    let offsetTop = 0;
+    let node = this.currentNode;
+    while (node && node.parentNode) {
+      offsetLeft += node.offsetLeft;
+      offsetTop += node.offsetTop;
+      node = node.offsetParent;
     }
+
+    let node = this.currentNode;
+    while (node && node.parentNode) {
+      if (node.scrollTop) {
+        offsetTop -= node.scrollTop;
+      }
+      if (node.scrollLeft) {
+        offsetLeft -= node.scrollLeft;
+      }
+      node = node.parentNode;
+    }
+
+    // Add the potential frame offset if it is nested
+    let [xOffset, yOffset] = this.layoutHelpers.getNodeOffsets(this.currentNode);
+    xOffset += offsetLeft;
+    yOffset += offsetTop;
+
+    // Get the width and height
+    let width = this.currentNode.offsetWidth;
+    let height = this.currentNode.offsetHeight;
+
+    return {
+      p1: {x: xOffset, y: yOffset},
+      p2: {x: xOffset + width, y: yOffset},
+      p3: {x: xOffset + width, y: yOffset + height},
+      p4: {x: xOffset, y: yOffset + height}
+    };
   },
 
   /**
-   * Generic event handler.
-   *
-   * @param nsIDOMEvent aEvent
-   *        The DOM event object.
+   * Hide the highlighter, the outline and the infobar.
    */
-  handleEvent: function(event) {
-    switch (event.type) {
-      case "resize":
-      case "MozAfterPaint":
-      case "scroll":
-        this._update();
-        break;
-    }
+  _hide: function() {
+    this._hideShapes();
   },
-};
+
+  _hideShapes: function() {
+    this._svgRoot.setAttribute("hidden", "true");
+  },
+
+  _showShapes: function() {
+    this._svgRoot.removeAttribute("hidden");
+  }
+});
 
 /**
  * The SimpleOutlineHighlighter is a class that has the same API than the
  * BoxModelHighlighter, but adds a pseudo-class on the target element itself
  * to draw a simple outline.
  * It is used by the HighlighterActor too, but in case the more complex
  * BoxModelHighlighter can't be attached (which is the case for FirefoxOS and
  * Fennec targets for instance).
@@ -946,30 +1183,31 @@ SimpleOutlineHighlighter.prototype = {
 function supportXULBasedHighlighter(tabActor) {
   // Note that <browser>s on Fennec also have a XUL parentNode but the box
   // model highlighter doesn't display correctly on Fennec (bug 993190)
   return tabActor.browser &&
          !!tabActor.browser.parentNode &&
          Services.appinfo.ID !== "{aa3c5121-dab2-40e2-81ca-7ea25febc110}";
 }
 
-function isNodeValidForHighlighting(node) {
+function isNodeValid(node) {
   // Is it null or dead?
-  let isNotDead = node && !Cu.isDeadWrapper(node);
+  if(!node || Cu.isDeadWrapper(node)) {
+    return false;
+  }
 
   // Is it connected to the document?
-  let isConnected = false;
-  try {
-    let doc = node.ownerDocument;
-    isConnected = (doc && doc.defaultView && doc.documentElement.contains(node));
-  } catch (e) {
-    // "can't access dead object" error
+  let doc = node.ownerDocument;
+  if (!doc || !doc.defaultView || !doc.documentElement.contains(node)) {
+    return false;
   }
 
   // Is it an element node
-  let isElementNode = node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE;
+  if (node.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
+    return false;
+  }
 
-  return isNotDead && isConnected && isElementNode;
+  return true;
 }
 
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
 });
diff --git a/toolkit/devtools/server/actors/root.js b/toolkit/devtools/server/actors/root.js
--- a/toolkit/devtools/server/actors/root.js
+++ b/toolkit/devtools/server/actors/root.js
@@ -96,19 +96,19 @@ function RootActor(aConnection, aParamet
 
 RootActor.prototype = {
   constructor: RootActor,
   applicationType: "browser",
 
   traits: {
     sources: true,
     editOuterHTML: true,
-    // Whether the server-side highlighter actor exists and can be used to
-    // remotely highlight nodes (see server/actors/highlighter.js)
-    highlightable: true,
+    // Whether the server-side highlighter actor supports custom highlighters
+    // (see server/actors/highlighter.js)
+    hasCustomHighlighters: true,
     // Whether the inspector actor implements the getImageDataFromURL
     // method that returns data-uris for image URLs. This is used for image
     // tooltips for instance
     urlToImageDataResolver: true,
     networkMonitor: true,
     // Whether the storage inspector actor to inspect cookies, etc.
     storageInspector: true,
     // Whether storage inspector is read only
diff --git a/toolkit/devtools/server/tests/mochitest/chrome.ini b/toolkit/devtools/server/tests/mochitest/chrome.ini
--- a/toolkit/devtools/server/tests/mochitest/chrome.ini
+++ b/toolkit/devtools/server/tests/mochitest/chrome.ini
@@ -16,16 +16,18 @@ support-files =
 [test_Debugger.Source.prototype.introductionType.html]
 [test_Debugger.Source.prototype.element.html]
 [test_Debugger.Script.prototype.global.html]
 [test_connection-manager.html]
 [test_css-logic.html]
 [test_device.html]
 [test_framerate_01.html]
 [test_framerate_02.html]
+[test_highlighter-csstransform_01.html]
+[test_highlighter-csstransform_02.html]
 [test_inspector-changeattrs.html]
 [test_inspector-changevalue.html]
 [test_inspector-hide.html]
 [test_inspector-insert.html]
 [test_inspector-mutations-attr.html]
 [test_inspector-mutations-childlist.html]
 [test_inspector-mutations-frameload.html]
 [test_inspector-mutations-value.html]
diff --git a/toolkit/devtools/server/tests/mochitest/test_highlighter-csstransform_01.html b/toolkit/devtools/server/tests/mochitest/test_highlighter-csstransform_01.html
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/mochitest/test_highlighter-csstransform_01.html
@@ -0,0 +1,111 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Bug 1014547 - CSS transforms highlighter
+Test the high level API of the highlighters
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Framerate actor test</title>
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+</head>
+<body>
+<pre id="test">
+<script type="application/javascript;version=1.8">
+
+window.onload = function() {
+  var Cu = Components.utils;
+  var Cc = Components.classes;
+  var Ci = Components.interfaces;
+
+  Cu.import("resource://gre/modules/Services.jsm");
+  Cu.import("resource://gre/modules/devtools/Loader.jsm");
+  Cu.import("resource://gre/modules/devtools/dbg-client.jsm");
+  Cu.import("resource://gre/modules/devtools/dbg-server.jsm");
+  Cu.import("resource://gre/modules/Task.jsm");
+
+  SimpleTest.waitForExplicitFinish();
+
+  var {InspectorFront} = devtools.require("devtools/server/actors/inspector");
+
+  DebuggerServer.init(() => true);
+  DebuggerServer.addBrowserActors();
+
+  var client = new DebuggerClient(DebuggerServer.connectPipe());
+  client.connect(() => {
+    client.listTabs(response => {
+      var form = response.tabs[response.selected];
+      var front = InspectorFront(client, form);
+
+      Task.spawn(function*() {
+        yield onlyOneInstanceOfMainHighlighter(front);
+        yield manyInstancesOfCustomHighlighters(front);
+        yield showHideMethodsAreAvailable(front);
+        yield unknownHighlighterTypeShouldntBeAccepted(front);
+      }).then(null, ok.bind(null, false)).then(() => {
+        client.close(() => {
+          DebuggerServer.destroy();
+          SimpleTest.finish();
+        });
+      });
+    });
+  });
+
+  function* onlyOneInstanceOfMainHighlighter(inspectorFront) {
+    info("Check that the inspector always sends back the same main highlighter");
+
+    let h1 = yield inspectorFront.getHighlighter(false);
+    let h2 = yield inspectorFront.getHighlighter(false);
+    is(h1, h2, "The same highlighter front was returned");
+
+    is(h1.typeName, "mainhighlighter", "The right front type was returned");
+  }
+
+  function* manyInstancesOfCustomHighlighters(inspectorFront) {
+    let h1 = yield inspectorFront.getHighlighterByType("BoxModelHighlighter");
+    let h2 = yield inspectorFront.getHighlighterByType("BoxModelHighlighter");
+    ok(h1 !== h2, "getHighlighterByType returns new instances every time (1)");
+
+    let h3 = yield inspectorFront.getHighlighterByType("CssTransformHighlighter");
+    let h4 = yield inspectorFront.getHighlighterByType("CssTransformHighlighter");
+    ok(h3 !== h4, "getHighlighterByType returns new instances every time (2)");
+    ok(h3 !== h1 && h3 !== h2,
+      "getHighlighterByType returns new instances every time (3)");
+    ok(h4 !== h1 && h4 !== h2,
+      "getHighlighterByType returns new instances every time (4)");
+
+    yield h1.finalize();
+    yield h2.finalize();
+    yield h3.finalize();
+    yield h4.finalize();
+  }
+
+  function* showHideMethodsAreAvailable(inspectorFront) {
+    let h1 = yield inspectorFront.getHighlighterByType("BoxModelHighlighter");
+    let h2 = yield inspectorFront.getHighlighterByType("CssTransformHighlighter");
+
+    ok("show" in h1, "Show method is present on the front API");
+    ok("show" in h2, "Show method is present on the front API");
+    ok("hide" in h1, "Hide method is present on the front API");
+    ok("hide" in h2, "Hide method is present on the front API");
+
+    yield h1.finalize();
+    yield h2.finalize();
+  }
+
+  function* unknownHighlighterTypeShouldntBeAccepted(inspectorFront) {
+    let hasThrown = false;
+    try {
+      let h = yield inspectorFront.getHighlighterByType("whatever");
+    } catch (e) {
+      hasThrown = true;
+    }
+
+    ok(hasThrown, "An exception was thrown for the invalid highlighter type");
+  }
+}
+</script>
+</pre>
+</body>
+</html>
diff --git a/toolkit/devtools/server/tests/mochitest/test_highlighter-csstransform_02.html b/toolkit/devtools/server/tests/mochitest/test_highlighter-csstransform_02.html
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/mochitest/test_highlighter-csstransform_02.html
@@ -0,0 +1,144 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Bug 1014547 - CSS transforms highlighter
+Test the creation of the SVG highlighter elements in the browser
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Framerate actor test</title>
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+</head>
+<body>
+  <div id="transformed" style="border:1px solid red;width:100px;height:100px;transform:skew(13deg);"></div>
+  <div id="untransformed" style="border:1px solid blue;width:100px;height:100px;"></div>
+<pre id="test">
+<script type="application/javascript;version=1.8">
+
+window.onload = function() {
+  var Cu = Components.utils;
+  var Cc = Components.classes;
+  var Ci = Components.interfaces;
+
+  Cu.import("resource://gre/modules/Services.jsm");
+  Cu.import("resource://gre/modules/devtools/Loader.jsm");
+  Cu.import("resource://gre/modules/devtools/dbg-client.jsm");
+  Cu.import("resource://gre/modules/devtools/dbg-server.jsm");
+  Cu.import("resource://gre/modules/Task.jsm");
+  const promise = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
+
+  SimpleTest.waitForExplicitFinish();
+
+  var {InspectorFront} = devtools.require("devtools/server/actors/inspector");
+
+  DebuggerServer.init(() => true);
+  DebuggerServer.addBrowserActors();
+
+  var client = new DebuggerClient(DebuggerServer.connectPipe());
+  client.connect(() => {
+    client.listTabs(response => {
+      var form = response.tabs[response.selected];
+      var front = InspectorFront(client, form);
+
+      Task.spawn(function*() {
+        let walkerFront = yield front.getWalker();
+        let highlighterFront = yield front.getHighlighterByType(
+          "CssTransformHighlighter");
+
+        let gBrowser = Services.wm.getMostRecentWindow("navigator:browser").gBrowser;
+        let container =
+          gBrowser.selectedBrowser.parentNode.querySelector(".highlighter-container");
+        ok(container, "The highlighter container was found");
+
+        yield isHiddenByDefault(container);
+        yield has2PolygonsAnd4Lines(container);
+        yield isVisibleWhenShown(highlighterFront, walkerFront, container);
+        yield isNotShownForUntransformed(highlighterFront, walkerFront, container);
+        yield linesLinkThePolygons(highlighterFront, walkerFront, container);
+
+        yield highlighterFront.finalize();
+      }).then(null, ok.bind(null, false)).then(() => {
+        client.close(() => {
+          DebuggerServer.destroy();
+          SimpleTest.finish();
+        });
+      });
+    });
+  });
+
+  function* isHiddenByDefault(container) {
+    let svg = container.querySelector("svg");
+    ok(svg.hasAttribute("hidden"), "The highlighter is hidden by default");
+  }
+
+  function* has2PolygonsAnd4Lines(container) {
+    is(container.querySelectorAll("polygon").length, 2, "Found 2 polygons");
+    is(container.querySelectorAll("line").length, 4, "Found 4 lines");
+  }
+
+  function* isVisibleWhenShown(highlighterFront, walkerFront, container) {
+    let rawNode = document.getElementById("transformed");
+    let node = walkerFront.frontForRawNode(rawNode);
+
+    info("Asking to show the highlighter on the test node");
+    yield highlighterFront.show(node);
+    let svg = container.querySelector("svg");
+    ok(!svg.hasAttribute("hidden"), "The highlighter is visible");
+
+    info("Hiding the highlighter");
+    yield highlighterFront.hide();
+    ok(svg.hasAttribute("hidden"), "The highlighter is hidden");
+  }
+
+  function* isNotShownForUntransformed(highlighterFront, walkerFront, container) {
+    let rawNode = document.getElementById("untransformed");
+    let node = walkerFront.frontForRawNode(rawNode);
+
+    info("Asking to show the highlighter on the untransformed test node");
+    yield highlighterFront.show(node);
+    let svg = container.querySelector("svg");
+    ok(svg.hasAttribute("hidden"), "The highlighter is still hidden");
+  }
+
+  function* linesLinkThePolygons(highlighterFront, walkerFront, container) {
+    let rawNode = document.getElementById("transformed");
+    let node = walkerFront.frontForRawNode(rawNode);
+
+    info("Showing the highlighter on the transformed node");
+    yield highlighterFront.show(node);
+
+    info("Checking that the 4 lines do link the 2 shape's corners");
+    let lines = [...container.querySelectorAll("line")];
+
+    let polygon1 = container.querySelector(".css-transform-untransformed");
+    let points1 = polygon1.getAttribute("points").split(" ");
+
+    let polygon2 = container.querySelector(".css-transform-transformed");
+    let points2 = polygon2.getAttribute("points").split(" ");
+
+    for (let i = 0; i < lines.length; i++) {
+      info("Checking line nb " + i);
+      let line = lines[i];
+
+      let p1 = points1[i].split(",");
+      let x1 = line.getAttribute("x1");
+      let y1 = line.getAttribute("y1");
+      is(p1[0], x1, "line " + i + "'s first point matches the untransformed x coordinate");
+      is(p1[1], y1, "line " + i + "'s first point matches the untransformed y coordinate");
+
+      let p2 = points2[i].split(",");
+      let x2 = line.getAttribute("x2");
+      let y2 = line.getAttribute("y2");
+      is(p2[0], x2, "line " + i + "'s first point matches the transformed x coordinate");
+      is(p2[1], y2, "line " + i + "'s first point matches the transformed y coordinate");
+    }
+
+    yield highlighterFront.hide();
+  }
+
+}
+</script>
+</pre>
+</body>
+</html>
