# vim: se ft=diff :
# HG changeset patch
# User Tom Tromey <tromey@mozilla.com>
# Date 2015-09-11 12:51
Bug 984880 - as-authored styles in the rule view

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
index 084f650..f63d596 100644
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1383,17 +1383,17 @@ pref("devtools.inspector.showUserAgentStyles", false);
 // Show all native anonymous content (like controls in <video> tags)
 pref("devtools.inspector.showAllAnonymousContent", false);
 // Enable the MDN docs tooltip
 pref("devtools.inspector.mdnDocsTooltip.enabled", true);
 // Show the new animation inspector UI
 pref("devtools.inspector.animationInspectorV3", false);
 
 // DevTools default color unit
-pref("devtools.defaultColorUnit", "hex");
+pref("devtools.defaultColorUnit", "authored");
 
 // Enable the Responsive UI tool
 pref("devtools.responsiveUI.no-reload-notification", false);
 
 // Enable the Debugger
 pref("devtools.debugger.enabled", true);
 pref("devtools.debugger.chrome-debugging-host", "localhost");
 pref("devtools.debugger.chrome-debugging-port", 6080);
diff --git a/browser/devtools/framework/toolbox-options.xul b/browser/devtools/framework/toolbox-options.xul
index 9a9641f..3162c5a 100644
--- a/browser/devtools/framework/toolbox-options.xul
+++ b/browser/devtools/framework/toolbox-options.xul
@@ -50,16 +50,17 @@
           <description>
             <label control="defaultColorUnitMenuList"
                    accesskey="&options.defaultColorUnit.accesskey;"
             >&options.defaultColorUnit.label;</label>
             <hbox>
               <menulist id="defaultColorUnitMenuList"
                         data-pref="devtools.defaultColorUnit">
                 <menupopup>
+                  <menuitem label="&options.defaultColorUnit.authored;" value="authored"/>
                   <menuitem label="&options.defaultColorUnit.hex;" value="hex"/>
                   <menuitem label="&options.defaultColorUnit.hsl;" value="hsl"/>
                   <menuitem label="&options.defaultColorUnit.rgb;" value="rgb"/>
                   <menuitem label="&options.defaultColorUnit.name;" value="name"/>
                 </menupopup>
               </menulist>
             </hbox>
           </description>
diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
index f0c1516..06959e0 100644
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -91,37 +91,37 @@ EditingSession.prototype = {
 
     for (let property of properties) {
       if (!this._modifications.has(property.name)) {
         this._modifications.set(property.name,
           this.getPropertyFromRule(this._rules[0], property.name));
       }
 
       if (property.value == "") {
-        modifications.removeProperty(property.name);
+        modifications.removeProperty(-1, property.name);
       } else {
-        modifications.setProperty(property.name, property.value, "");
+        modifications.setProperty(-1, property.name, property.value, "");
       }
     }
 
     return modifications.apply().then(null, console.error);
   },
 
   /**
    * Reverts all of the property changes made by this instance. Returns a
    * promise that will be resolved when complete.
    */
   revert: function() {
     let modifications = this._rules[0].startModifyingProperties();
 
     for (let [property, value] of this._modifications) {
       if (value != "") {
-        modifications.setProperty(property, value, "");
+        modifications.setProperty(-1, property, value, "");
       } else {
-        modifications.removeProperty(property);
+        modifications.removeProperty(-1, property);
       }
     }
 
     return modifications.apply().then(null, console.error);
   },
 
   destroy: function() {
     this._doc = null;
diff --git a/browser/devtools/shared/test/browser_outputparser.js b/browser/devtools/shared/test/browser_outputparser.js
index 3735100..1895746 100644
--- a/browser/devtools/shared/test/browser_outputparser.js
+++ b/browser/devtools/shared/test/browser_outputparser.js
@@ -28,82 +28,78 @@ function* performTest() {
 
 // Class name used in color swatch.
 let COLOR_TEST_CLASS = "test-class";
 
 // Create a new CSS color-parsing test.  |name| is the name of the CSS
 // property.  |value| is the CSS text to use.  |segments| is an array
 // describing the expected result.  If an element of |segments| is a
 // string, it is simply appended to the expected string.  Otherwise,
-// it must be an object with a |value| property and a |name| property.
-// These describe the color and are both used in the generated
-// expected output -- |name| is the color name as it appears in the
-// input (e.g., "red"); and |value| is the hash-style numeric value
-// for the color, which parseCssProperty emits in some spots (e.g.,
-// "#F00").
+// it must be an object with a |value| property, which is the color
+// name as it appears in the input.
 //
 // This approach is taken to reduce boilerplate and to make it simpler
 // to modify the test when the parseCssProperty output changes.
 function makeColorTest(name, value, segments) {
   let result = {
     name,
     value,
     expected: ""
   };
 
   for (let segment of segments) {
     if (typeof (segment) === "string") {
       result.expected += segment;
     } else {
-      result.expected += "<span data-color=\"" + segment.value + "\">" +
+      result.expected += "<span data-color=\"" + segment.name + "\">" +
         "<span style=\"background-color:" + segment.name +
         "\" class=\"" + COLOR_TEST_CLASS + "\"></span><span>" +
-        segment.value + "</span></span>";
+        segment.name + "</span></span>";
     }
   }
 
   result.desc = "Testing " + name + ": " + value;
 
   return result;
 }
 
 function testParseCssProperty(doc, parser) {
   let tests = [
     makeColorTest("border", "1px solid red",
-                  ["1px solid ", {name: "red", value: "#F00"}]),
+                  ["1px solid ", {name: "red"}]),
 
     makeColorTest("background-image",
                   "linear-gradient(to right, #F60 10%, rgba(0,0,0,1))",
-                  ["linear-gradient(to right, ", {name: "#F60", value: "#F60"},
-                   " 10%, ", {name: "rgba(0,0,0,1)", value: "#000"},
+                  ["linear-gradient(to right, ", {name: "#F60"},
+                   " 10%, ", {name: "rgba(0,0,0,1)"},
                    ")"]),
 
     // In "arial black", "black" is a font, not a color.
     makeColorTest("font-family", "arial black", ["arial black"]),
 
     makeColorTest("box-shadow", "0 0 1em red",
-                  ["0 0 1em ", {name: "red", value: "#F00"}]),
+                  ["0 0 1em ", {name: "red"}]),
 
     makeColorTest("box-shadow",
                   "0 0 1em red, 2px 2px 0 0 rgba(0,0,0,.5)",
-                  ["0 0 1em ", {name: "red", value: "#F00"},
+                  ["0 0 1em ", {name: "red"},
                    ", 2px 2px 0 0 ",
-                   {name: "rgba(0,0,0,.5)", value: "rgba(0,0,0,.5)"}]),
+                   {name: "rgba(0,0,0,.5)"}]),
 
     makeColorTest("content", "\"red\"", ["\"red\""]),
 
     // Invalid property names should not cause exceptions.
     makeColorTest("hellothere", "'red'", ["'red'"]),
 
     makeColorTest("filter",
                   "blur(1px) drop-shadow(0 0 0 blue) url(red.svg#blue)",
                   ["<span data-filters=\"blur(1px) drop-shadow(0 0 0 blue) ",
                    "url(red.svg#blue)\"><span>",
                    "blur(1px) drop-shadow(0 0 0 ",
-                   {name: "blue", value: "#00F"},
+                   {name: "blue"},
                    ") url(red.svg#blue)</span></span>"]),
 
     makeColorTest("color", "currentColor", ["currentColor"]),
   ];
 
   let target = doc.querySelector("div");
   ok(target, "captain, we have the div");
 
diff --git a/browser/devtools/shared/widgets/Tooltip.js b/browser/devtools/shared/widgets/Tooltip.js
index 0aff12b..69d7833 100644
--- a/browser/devtools/shared/widgets/Tooltip.js
+++ b/browser/devtools/shared/widgets/Tooltip.js
@@ -1143,16 +1143,18 @@ SwatchColorPickerTooltip.prototype = Heritage.extend(SwatchBasedEditorTooltip.pr
    * color.
    */
   show: function() {
     // Call then parent class' show function
     SwatchBasedEditorTooltip.prototype.show.call(this);
     // Then set spectrum's color and listen to color changes to preview them
     if (this.activeSwatch) {
       this.currentSwatchColor = this.activeSwatch.nextSibling;
+      this._colorUnit =
+        colorUtils.classifyColor(this.currentSwatchColor.textContent);
       let color = this.activeSwatch.style.backgroundColor;
       this.spectrum.then(spectrum => {
         spectrum.off("changed", this._onSpectrumColorChange);
         spectrum.rgb = this._colorToRgba(color);
         spectrum.on("changed", this._onSpectrumColorChange);
         spectrum.updateUI();
       });
     }
@@ -1220,16 +1222,17 @@ SwatchColorPickerTooltip.prototype = Heritage.extend(SwatchBasedEditorTooltip.pr
   _colorToRgba: function(color) {
     color = new colorUtils.CssColor(color);
     let rgba = color._getRGBATuple();
     return [rgba.r, rgba.g, rgba.b, rgba.a];
   },
 
   _toDefaultType: function(color) {
     let colorObj = new colorUtils.CssColor(color);
+    colorObj.colorUnit = this._colorUnit;
     return colorObj.toString();
   },
 
   destroy: function() {
     SwatchBasedEditorTooltip.prototype.destroy.call(this);
     this.currentSwatchColor = null;
     this.spectrum.then(spectrum => {
       spectrum.off("changed", this._onSpectrumColorChange);
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
index 06f8204..4729c75 100644
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -108,17 +108,17 @@ function createDummyDocument() {
  * ElementStyle:
  *   Responsible for keeping track of which properties are overridden.
  *   Maintains a list of Rule objects that apply to the element.
  * Rule:
  *   Manages a single style declaration or rule.
  *   Responsible for applying changes to the properties in a rule.
  *   Maintains a list of TextProperty objects.
  * TextProperty:
- *   Manages a single property from the cssText attribute of the
+ *   Manages a single property from the authoredText attribute of the
  *     relevant declaration.
  *   Maintains a list of computed properties that come from this
  *     property declaration.
  *   Changes to the TextProperty are sent to its related Rule for
  *     application.
  */
 
 /**
@@ -371,16 +371,26 @@ ElementStyle.prototype = {
     //   If the new property is a lower or equal priority, mark it as
     //   overridden.
     //
     // _overriddenDirty will be set on each prop, indicating whether its
     // dirty status changed during this pass.
     let taken = {};
     for (let computedProp of computedProps) {
       let earlier = taken[computedProp.name];
+
+      // Prevent -webkit-gradient from being selected after unchecking
+      // linear-gradient in this case:
+      //  -moz-linear-gradient: ...;
+      //  -webkit-linear-gradient: ...;
+      //  linear-gradient: ...;
+      if (!computedProp.textProp.isKnownProperty()) {
+        computedProp.overridden = true;
+        continue;
+      }
       let overridden;
       if (earlier &&
           computedProp.priority === "important" &&
           earlier.priority !== "important") {
         // New property is higher priority.  Mark the earlier property
         // overridden (which will reverse its dirty state).
         earlier._overriddenDirty = !earlier._overriddenDirty;
         earlier.overridden = true;
@@ -460,17 +470,17 @@ function Rule(elementStyle, options) {
   this.inherited = options.inherited || null;
   this.keyframes = options.keyframes || null;
   this._modificationDepth = 0;
 
   if (this.domRule && this.domRule.mediaText) {
     this.mediaText = this.domRule.mediaText;
   }
 
-  // Populate the text properties with the style's current cssText
+  // Populate the text properties with the style's current authoredText
   // value, and add in any disabled properties from the store.
   this.textProps = this._getTextProperties();
   this.textProps = this.textProps.concat(this._getDisabledProperties());
 }
 
 Rule.prototype = {
   mediaText: "",
 
@@ -592,69 +602,76 @@ Rule.prototype = {
    * @param {String} priority
    *        The property's priority (either "important" or an empty string).
    * @param {TextProperty} siblingProp
    *        Optional, property next to which the new property will be added.
    */
   createProperty: function(name, value, priority, siblingProp) {
     let prop = new TextProperty(this, name, value, priority);
 
+    let ind;
     if (siblingProp) {
-      let ind = this.textProps.indexOf(siblingProp);
-      this.textProps.splice(ind + 1, 0, prop);
+      ind = this.textProps.indexOf(siblingProp) + 1;
+      this.textProps.splice(ind, 0, prop);
     } else {
+      ind = this.textProps.length;
       this.textProps.push(prop);
     }
 
-    this.applyProperties();
+    let deferred = promise.defer();
+    let modifications = this.style.startModifyingProperties();
+    modifications.getDefaultIndentation().then((indent) => {
+      modifications.createProperty(ind, name, value, priority, indent);
+      this.internalApplyProperties(modifications).then(() => {
+        deferred.resolve(null);
+      });
+    });
+    this.updateAfterApplyingProperties(deferred.promise);
     return prop;
   },
 
   /**
-   * Reapply all the properties in this rule, and update their
-   * computed styles. Store disabled properties in the element
-   * style's store. Will re-mark overridden properties.
+   * Helper function for applyProperties that is called when the actor
+   * does not support as-authored styles.  Store disabled properties
+   * in the element style's store.
    */
-  applyProperties: function(modifications) {
+  _applyPropertiesNoAuthored: function(modifications) {
     this.elementStyle.markOverriddenAll();
 
-    if (!modifications) {
-      modifications = this.style.startModifyingProperties();
-    }
     let disabledProps = [];
 
     for (let prop of this.textProps) {
       if (!prop.enabled) {
         disabledProps.push({
           name: prop.name,
           value: prop.value,
           priority: prop.priority
         });
         continue;
       }
       if (prop.value.trim() === "") {
         continue;
       }
 
-      modifications.setProperty(prop.name, prop.value, prop.priority);
+      modifications.setProperty(-1, prop.name, prop.value, prop.priority);
 
       prop.updateComputed();
     }
 
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
-    let modificationsPromise = modifications.apply().then(() => {
+    return modifications.apply().then(() => {
       let cssProps = {};
-      for (let cssProp of parseDeclarations(this.style.cssText)) {
+      for (let cssProp of parseDeclarations(this.style.authoredText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
         if (!textProp.enabled) {
           continue;
         }
         let cssProp = cssProps[textProp.name];
@@ -664,46 +681,78 @@ Rule.prototype = {
             name: textProp.name,
             value: "",
             priority: ""
           };
         }
 
         textProp.priority = cssProp.priority;
       }
+    });
+  },
 
+  internalApplyProperties: function(modifications) {
+    let modificationsPromise;
+    if (this.style.canSetRuleText) {
+      modificationsPromise = modifications.apply().then(() => {
+        // The rewriting may have required some other property values
+        // to change, e.g., to insert some needed terminators.  Update
+        // the relevant properties here.
+        for (let index in modifications.changedDeclarations) {
+          let newValue = modifications.changedDeclarations[index];
+          this.textProps[index].noticeNewValue(newValue);
+        }
+      });
+    } else {
+      modificationsPromise = this._applyPropertiesNoAuthored(modifications);
+    }
+    return modificationsPromise;
+  },
+
+  updateAfterApplyingProperties: function(modificationsPromise) {
+    let resultPromise = modificationsPromise.then(() => {
       this.elementStyle.markOverriddenAll();
 
-      if (modificationsPromise === this._applyingModifications) {
+      if (resultPromise === this._applyingModifications) {
         this._applyingModifications = null;
       }
 
       this.elementStyle._changed();
     }).then(null, promiseWarn);
 
-    this._applyingModifications = modificationsPromise;
-    return modificationsPromise;
+    this._applyingModifications = resultPromise;
+    return resultPromise;
+  },
+
+  /**
+   * Reapply all the properties in this rule, and update their
+   * computed styles.  Will re-mark overridden properties.
+   */
+  applyProperties: function(modifications) {
+    let modificationsPromise = this.internalApplyProperties(modifications);
+    this.updateAfterApplyingProperties(modificationsPromise);
   },
 
   /**
    * Renames a property.
    *
    * @param {TextProperty} property
    *        The property to rename.
    * @param {String} name
    *        The new property name (such as "background" or "border-top").
    */
   setPropertyName: function(property, name) {
     if (name === property.name) {
       return;
     }
     let modifications = this.style.startModifyingProperties();
-    modifications.removeProperty(property.name);
+    modifications.renameProperty(this.textProps.indexOf(property),
+                                 property.name, name);
     property.name = name;
-    this.applyProperties(modifications, name);
+    this.applyProperties(modifications);
   },
 
   /**
    * Sets the value and priority of a property, then reapply all properties.
    *
    * @param {TextProperty} property
    *        The property to manipulate.
    * @param {String} value
@@ -713,88 +762,105 @@ Rule.prototype = {
    */
   setPropertyValue: function(property, value, priority) {
     if (value === property.value && priority === property.priority) {
       return;
     }
 
     property.value = value;
     property.priority = priority;
-    this.applyProperties(null, property.name);
+
+    let index = this.textProps.indexOf(property);
+    let deferred = promise.defer();
+    let modifications = this.style.startModifyingProperties();
+    modifications.getDefaultIndentation().then((indent) => {
+      modifications.setProperty(index, property.name, value, priority, indent);
+      this.internalApplyProperties(modifications).then(() => {
+        deferred.resolve(null);
+      });
+    });
+    this.updateAfterApplyingProperties(deferred.promise);
   },
 
   /**
    * Just sets the value and priority of a property, in order to preview its
    * effect on the content document.
    *
    * @param {TextProperty} property
    *        The property which value will be previewed
    * @param {String} value
    *        The value to be used for the preview
    * @param {String} priority
    *        The property's priority (either "important" or an empty string).
    */
   previewPropertyValue: function(property, value, priority) {
     let modifications = this.style.startModifyingProperties();
-    modifications.setProperty(property.name, value, priority);
+    modifications.setProperty(this.textProps.indexOf(property),
+                              property.name, value, priority);
     modifications.apply().then(() => {
       // Ensure dispatching a ruleview-changed event
       // also for previews
       this.elementStyle._changed();
     });
   },
 
   /**
    * Disables or enables given TextProperty.
    *
    * @param {TextProperty} property
    *        The property to enable/disable
    * @param {Boolean} value
    */
   setPropertyEnabled: function(property, value) {
+    if (property.enabled === !!value) {
+      // Wow.
+      this.elementStyle._changed();
+      return;
+    }
     property.enabled = !!value;
     let modifications = this.style.startModifyingProperties();
-    if (!property.enabled) {
-      modifications.removeProperty(property.name);
-    }
+    modifications.setPropertyEnabled(this.textProps.indexOf(property),
+                                     property.name, property.enabled);
     this.applyProperties(modifications);
   },
 
   /**
    * Remove a given TextProperty from the rule and update the rule
    * accordingly.
    *
    * @param {TextProperty} property
    *        The property to be removed
    */
   removeProperty: function(property) {
-    this.textProps = this.textProps.filter(prop => prop !== property);
+    let index = this.textProps.indexOf(property);
+    this.textProps.splice(index, 1);
     let modifications = this.style.startModifyingProperties();
-    modifications.removeProperty(property.name);
+    modifications.removeProperty(index, property.name);
     // Need to re-apply properties in case removing this TextProperty
     // exposes another one.
     this.applyProperties(modifications);
   },
 
   /**
    * Get the list of TextProperties from the style. Needs
-   * to parse the style's cssText.
+   * to parse the style's authoredText.
    */
   _getTextProperties: function() {
     let textProps = [];
     let store = this.elementStyle.store;
-    let props = parseDeclarations(this.style.cssText);
+    let props = parseDeclarations(this.style.authoredText, true);
     for (let prop of props) {
       let name = prop.name;
       if (this.inherited && !domUtils.isInheritedProperty(name)) {
         continue;
       }
       let value = store.userProperties.getProperty(this.style, name,
                                                    prop.value);
-      let textProp = new TextProperty(this, name, value, prop.priority);
+      let textProp = new TextProperty(this, name, value, prop.priority,
+                                      !("commentOffsets" in prop));
       textProps.push(textProp);
     }
 
     return textProps;
   },
 
   /**
    * Return the list of disabled properties from the store for this rule.
@@ -861,33 +927,33 @@ Rule.prototype = {
     // Refresh the editor if one already exists.
     if (this.editor) {
       this.editor.populate();
     }
   },
 
   /**
    * Update the current TextProperties that match a given property
-   * from the cssText.  Will choose one existing TextProperty to update
+   * from the authoredText.  Will choose one existing TextProperty to update
    * with the new property's value, and will disable all others.
    *
    * When choosing the best match to reuse, properties will be chosen
    * by assigning a rank and choosing the highest-ranked property:
    *   Name, value, and priority match, enabled. (6)
    *   Name, value, and priority match, disabled. (5)
    *   Name and value match, enabled. (4)
    *   Name and value match, disabled. (3)
    *   Name matches, enabled. (2)
    *   Name matches, disabled. (1)
    *
    * If no existing properties match the property, nothing happens.
    *
    * @param {TextProperty} newProp
    *        The current version of the property, as parsed from the
-   *        cssText in Rule._getTextProperties().
+   *        authoredText in Rule._getTextProperties().
    * @return {Boolean} true if a property was updated, false if no properties
    *         were updated.
    */
   _updateTextProperty: function(newProp) {
     let match = { rank: 0, prop: null };
 
     for (let prop of this.textProps) {
       if (prop.name !== newProp.name) {
@@ -983,33 +1049,35 @@ Rule.prototype = {
       cssText += "\t" + textProp.stringifyProperty() + terminator;
     }
 
     return selectorText + " {" + terminator + cssText + "}";
   }
 };
 
 /**
- * A single property in a rule's cssText.
+ * A single property in a rule's authoredText.
  *
  * @param {Rule} rule
  *        The rule this TextProperty came from.
  * @param {String} name
  *        The text property name (such as "background" or "border-top").
  * @param {String} value
  *        The property's value (not including priority).
  * @param {String} priority
  *        The property's priority (either "important" or an empty string).
+ * @param {Boolean} enabled
+ *        Whether the property is enabled.
  */
-function TextProperty(rule, name, value, priority) {
+function TextProperty(rule, name, value, priority, enabled = true) {
   this.rule = rule;
   this.name = name;
   this.value = value;
   this.priority = priority;
-  this.enabled = true;
+  this.enabled = !!enabled;
   this.updateComputed();
 }
 
 TextProperty.prototype = {
   /**
    * Update the editor associated with this text property,
    * if any.
    */
@@ -1084,16 +1152,27 @@ TextProperty.prototype = {
     if (this.editor && value !== this.editor.committed.value || force) {
       store.userProperties.setProperty(this.rule.style, this.name, value);
     }
 
     this.rule.setPropertyValue(this, value, priority);
     this.updateEditor();
   },
 
+  /**
+   * Called when the property's value has been updated externally, and
+   * the property and editor should update.
+   */
+  noticeNewValue: function(value) {
+    if (value !== this.value) {
+      this.value = value;
+      this.updateEditor();
+    }
+  },
+
   setName: function(name) {
     let store = this.rule.elementStyle.store;
 
     if (name !== this.name) {
       store.userProperties.setProperty(this.rule.style, name,
                                        this.editor.committed.value);
     }
 
@@ -1119,16 +1198,33 @@ TextProperty.prototype = {
       ";";
 
     // Comment out property declarations that are not enabled
     if (!this.enabled) {
       declaration = "/* " + escapeCSSComment(declaration) + " */";
     }
 
     return declaration;
+  },
+
+  /**
+   * See whether this property's name is known.
+   *
+   * @return {Boolean} true if the property name is valid, false otherwise.
+   */
+  isKnownProperty: function() {
+    try {
+      // If the property name is invalid, the cssPropertyIsShorthand
+      // will throw an exception.  But if it is valid, no exception will
+      // be thrown; so we just ignore the return value.
+      domUtils.cssPropertyIsShorthand(this.name);
+      return true;
+    } catch (e) {
+      return false;
+    }
   }
 };
 
 /**
  * View hierarchy mostly follows the model hierarchy.
  *
  * CssRuleView:
  *   Owns an ElementStyle and creates a list of RuleEditors for its
@@ -3169,17 +3265,18 @@ TextPropertyEditor.prototype = {
       this.enable.removeAttribute("checked");
     }
 
     this.warning.hidden = this.editing || this.isValid();
     this.filterProperty.hidden = this.editing ||
                                  !this.isValid() ||
                                  !this.prop.overridden;
 
-    if (this.prop.overridden || !this.prop.enabled) {
+    if (this.prop.overridden || !this.prop.enabled ||
+        !this.prop.isKnownProperty()) {
       this.element.classList.add("ruleview-overridden");
     } else {
       this.element.classList.remove("ruleview-overridden");
     }
 
     let name = this.prop.name;
     this.nameSpan.textContent = name;
 
@@ -3552,17 +3649,17 @@ TextPropertyEditor.prototype = {
     this._previewValue(this.valueSpan.textContent);
   },
 
   /**
    * Called when the swatch editor closes from an ESC. Revert to the original
    * value of this property before editing.
    */
   _onSwatchRevert: function() {
-    this.rule.setPropertyEnabled(this.prop, this.prop.enabled);
+    this._previewValue(this.prop.value);
     this.update();
   },
 
   /**
    * Parse a value string and break it into pieces, starting with the
    * first value, and into an array of additional properties (if any).
    *
    * Example: Calling with "red; width: 100px" would return
diff --git a/browser/devtools/styleinspector/test/browser.ini b/browser/devtools/styleinspector/test/browser.ini
index c0818c4..106d295 100644
--- a/browser/devtools/styleinspector/test/browser.ini
+++ b/browser/devtools/styleinspector/test/browser.ini
@@ -55,16 +55,17 @@ support-files =
 [browser_ruleview_add-property_01.js]
 [browser_ruleview_add-property_02.js]
 [browser_ruleview_add-property-svg.js]
 [browser_ruleview_add-rule_01.js]
 [browser_ruleview_add-rule_02.js]
 [browser_ruleview_add-rule_03.js]
 [browser_ruleview_add-rule_04.js]
 [browser_ruleview_add-rule_pseudo_class.js]
+[browser_ruleview_authored.js]
 [browser_ruleview_colorpicker-and-image-tooltip_01.js]
 [browser_ruleview_colorpicker-and-image-tooltip_02.js]
 [browser_ruleview_colorpicker-appears-on-swatch-click.js]
 [browser_ruleview_colorpicker-commit-on-ENTER.js]
 [browser_ruleview_colorpicker-edit-gradient.js]
 [browser_ruleview_colorpicker-hides-on-tooltip.js]
 [browser_ruleview_colorpicker-multiple-changes.js]
 [browser_ruleview_colorpicker-release-outside-frame.js]
diff --git a/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js b/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js
index 0125b46..1675372 100644
--- a/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_cycle_color.js
@@ -29,17 +29,23 @@ add_task(function*() {
   checkColorCycling(container, inspector);
 });
 
 function checkColorCycling(container, inspector) {
   let swatch = container.querySelector(".computedview-colorswatch");
   let valueNode = container.querySelector(".computedview-color");
   let win = inspector.sidebar.getWindowForTab("computedview");
 
-  // Hex (default)
+  // "Authored" (default; currently the computed value)
+  is(valueNode.textContent, "rgb(255, 0, 0)",
+                            "Color displayed as an RGB value.");
+
+  // Hex
+  EventUtils.synthesizeMouseAtCenter(swatch,
+                                     {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "#F00", "Color displayed as a hex value.");
 
   // HSL
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "hsl(0, 100%, 50%)",
                             "Color displayed as an HSL value.");
 
@@ -50,20 +56,14 @@ function checkColorCycling(container, inspector) {
                             "Color displayed as an RGB value.");
 
   // Color name
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "red",
                             "Color displayed as a color name.");
 
-  // "Authored" (currently the computed value)
+  // Back to "Authored"
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "rgb(255, 0, 0)",
                             "Color displayed as an RGB value.");
-
-  // Back to hex
-  EventUtils.synthesizeMouseAtCenter(swatch,
-                                     {type: "mousedown", shiftKey: true}, win);
-  is(valueNode.textContent, "#F00",
-                            "Color displayed as hex again.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js b/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js
index 0efa17b..f86328b 100644
--- a/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_getNodeInfo.js
@@ -70,30 +70,30 @@ const TEST_DATA = [
     getHoveredNode: function*(view) {
       return getComputedViewProperty(view, "color").nameSpan;
     },
     assertNodeInfo: function(nodeInfo) {
       is(nodeInfo.type, VIEW_NODE_PROPERTY_TYPE);
       ok("property" in nodeInfo.value);
       ok("value" in nodeInfo.value);
       is(nodeInfo.value.property, "color");
-      is(nodeInfo.value.value, "#F00");
+      is(nodeInfo.value.value, "rgb(255, 0, 0)");
     }
   },
   {
     desc: "Testing a property value",
     getHoveredNode: function*(view) {
       return getComputedViewProperty(view, "color").valueSpan;
     },
     assertNodeInfo: function(nodeInfo) {
       is(nodeInfo.type, VIEW_NODE_VALUE_TYPE);
       ok("property" in nodeInfo.value);
       ok("value" in nodeInfo.value);
       is(nodeInfo.value.property, "color");
-      is(nodeInfo.value.value, "#F00");
+      is(nodeInfo.value.value, "rgb(255, 0, 0)");
     }
   },
   {
     desc: "Testing an image url",
     getHoveredNode: function*(view) {
       let {valueSpan} = getComputedViewProperty(view, "background-image");
       return valueSpan.querySelector(".theme-link");
     },
@@ -144,17 +144,17 @@ const TEST_DATA = [
     desc: "Testing a matched rule value",
     getHoveredNode: function*(view) {
       let content = yield getComputedViewMatchedRules(view, "color");
       return content.querySelector(".other-property-value");
     },
     assertNodeInfo: function(nodeInfo) {
       is(nodeInfo.type, VIEW_NODE_VALUE_TYPE);
       is(nodeInfo.value.property, "color");
-      is(nodeInfo.value.value, "#F00");
+      is(nodeInfo.value.value, "red");
     }
   },
   {
     desc: "Testing a matched rule stylesheet link",
     getHoveredNode: function*(view) {
       let content = yield getComputedViewMatchedRules(view, "color");
       return content.querySelector(".rule-link .theme-link");
     },
diff --git a/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js b/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js
index af951f8..abd9e6f8 100644
--- a/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_refresh-on-style-change_01.js
@@ -20,10 +20,10 @@ add_task(function*() {
   info("Changing the node's style and waiting for the update");
   let onUpdated = inspector.once("computed-view-refreshed");
   getNode("#testdiv").style.cssText = "font-size: 15px; color: red;";
   yield onUpdated;
 
   fontSize = getComputedViewPropertyValue(view, "font-size");
   is(fontSize, "15px", "The computed view shows the updated font-size");
   let color = getComputedViewPropertyValue(view, "color");
-  is(color, "#F00", "The computed view also shows the color now");
+  is(color, "rgb(255, 0, 0)", "The computed view also shows the color now");
 });
diff --git a/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js b/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js
index 82aa095..48b58b7 100644
--- a/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js
+++ b/browser/devtools/styleinspector/test/browser_computedview_select-and-copy-styles.js
@@ -76,17 +76,17 @@ function checkSelectAll(view) {
   info("Testing select-all copy");
 
   let contentDoc = view.styleDocument;
   let prop = contentDoc.querySelector(".property-view");
 
   info("Checking that _onSelectAll() then copy returns the correct " +
     "clipboard value");
   view._contextmenu._onSelectAll();
-  let expectedPattern = "color: #FF0;[\\r\\n]+" +
+  let expectedPattern = "color: rgb\\(255, 255, 0\\);[\\r\\n]+" +
                         "font-family: helvetica,sans-serif;[\\r\\n]+" +
                         "font-size: 16px;[\\r\\n]+" +
                         "font-variant-caps: small-caps;[\\r\\n]*";
 
   return waitForClipboard(() => {
     fireCopyEvent(prop);
   }, () => {
     return checkClipboardData(expectedPattern);
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_authored.js b/browser/devtools/styleinspector/test/browser_ruleview_authored.js
new file mode 100644
index 0000000..5c67bab
--- /dev/null
+++ b/browser/devtools/styleinspector/test/browser_ruleview_authored.js
@@ -0,0 +1,143 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test for as-authored styles.
+
+add_task(function*() {
+  yield addTab("data:text/html;charset=utf-8,browser_ruleview_authored.js");
+  let {inspector, view} = yield openRuleView();
+
+  yield basicTest(inspector, view);
+  yield overrideTest(inspector, view);
+  yield colorEditingTest(inspector, view);
+});
+
+function* createTestContent(inspector, style) {
+  let onMutated = inspector.once("markupmutation");
+  let styleNode = addStyle(content.document, style);
+  content.document.body.innerHTML =
+    '<div id="testid" class="testclass">Styled Node</div>';
+  yield onMutated;
+  yield selectNode("#testid", inspector);
+  return styleNode;
+}
+
+function* removeTestContent(inspector, node) {
+  let onMutated = inspector.once("markupmutation");
+  node.remove();
+  yield onMutated;
+}
+
+function* basicTest(inspector, view) {
+  let styleNode = yield createTestContent(inspector, "" +
+                                          "#testid {" +
+                                          // Invalid property.
+                                          "  something: random;" +
+                                          // Invalid value.
+                                          "  color: orang;" +
+                                          // Override.
+                                          "  background-color: blue;" +
+                                          "  background-color: #f0c;" +
+                                          "} ");
+
+  let elementStyle = view._elementStyle;
+
+  let expected = [
+    {name: "something", overridden: true},
+    {name: "color", overridden: true},
+    {name: "background-color", overridden: true},
+    {name: "background-color", overridden: false}
+  ];
+
+  let rule = elementStyle.rules[1];
+
+  for (let i = 0; i < expected.length; ++i) {
+    let prop = rule.textProps[i];
+    is(prop.name, expected[i].name, "test name for prop " + i);
+    is(prop.overridden, expected[i].overridden,
+       "test overridden for prop " + i);
+  }
+
+  yield removeTestContent(inspector, styleNode);
+}
+
+function* overrideTest(inspector, view) {
+  let gradientText = "(45deg, rgba(255,255,255,0.2) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.2) 75%, transparent 75%, transparent);";
+
+  let styleNode =
+      yield createTestContent(inspector, "" +
+                              "#testid {" +
+                              "  background-image: -moz-linear-gradient" +
+                              gradientText +
+                              "  background-image: -webkit-linear-gradient" +
+                              gradientText +
+                              "  background-image: linear-gradient" +
+                              gradientText +
+                              "} ");
+
+  let elementStyle = view._elementStyle;
+  let rule = elementStyle.rules[1];
+
+  // Initially the last property should be active.
+  for (let i = 0; i < 3; ++i) {
+    let prop = rule.textProps[i];
+    is(prop.name, "background-image", "check the property name");
+    is(prop.overridden, i !== 2, "check overridden for " + i);
+  }
+
+  rule.textProps[2].setEnabled(false);
+  yield rule._applyingModifications;
+
+  // Now the first property should be active.
+  for (let i = 0; i < 3; ++i) {
+    let prop = rule.textProps[i];
+    is(prop.overridden || !prop.enabled, i !== 0,
+       "post-change check overridden for " + i);
+  }
+
+  yield removeTestContent(inspector, styleNode);
+}
+
+function* colorEditingTest(inspector, view) {
+  let colors = [
+    {name: "hex", text: "#f0c", result: "#0F0"},
+    {name: "rgb", text: "rgb(0,128,250)", result: "rgb(0, 255, 0)"}
+  ];
+
+  Services.prefs.setCharPref("devtools.defaultColorUnit", "authored");
+
+  for (let color of colors) {
+    let styleNode = yield createTestContent(inspector, "" +
+                                            "#testid {" +
+                                            "  color: " + color.text + ";" +
+                                            "} ");
+
+    let cPicker = view.tooltips.colorPicker;
+    let swatch = getRuleViewProperty(view, "#testid", "color").valueSpan
+        .querySelector(".ruleview-colorswatch");
+    let onShown = cPicker.tooltip.once("shown");
+    swatch.click();
+    yield onShown;
+
+    let testNode = yield getNode("#testid");
+
+    yield simulateColorPickerChange(view, cPicker, [0, 255, 0, 1], {
+      element: testNode,
+      name: "color",
+      value: "rgb(0, 255, 0)"
+    });
+
+    let spectrum = yield cPicker.spectrum;
+    let onHidden = cPicker.tooltip.once("hidden");
+    EventUtils.sendKey("RETURN", spectrum.element.ownerDocument.defaultView);
+    yield onHidden;
+
+    is(getRuleViewPropertyValue(view, "#testid", "color"), color.result,
+       "changing the color preserved the unit for " + color.name);
+
+    yield removeTestContent(inspector, styleNode);
+  }
+}
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js
index 86cf550..3454205 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_01.js
@@ -16,17 +16,17 @@ const TEST_URI = `
   </style>
   Testing the color picker tooltip!
 `;
 
 add_task(function*() {
   yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
   let {view} = yield openRuleView();
   let value = getRuleViewProperty(view, "body", "background").valueSpan;
-  let swatch = value.querySelectorAll(".ruleview-colorswatch")[1];
+  let swatch = value.querySelectorAll(".ruleview-colorswatch")[0];
   let url = value.querySelector(".theme-link");
   yield testImageTooltipAfterColorChange(swatch, url, view);
 });
 
 function* testImageTooltipAfterColorChange(swatch, url, ruleView) {
   info("First, verify that the image preview tooltip works");
   let anchor = yield isHoverTooltipTarget(ruleView.tooltips.previewTooltip,
                                           url);
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js
index 2fdcc37..dd2f3ce 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-and-image-tooltip_02.js
@@ -56,12 +56,12 @@ function* testColorChangeIsntRevertedWhenOtherTooltipIsShown(ruleView) {
   onShown = ruleView.tooltips.previewTooltip.once("shown");
   let anchor = yield isHoverTooltipTarget(ruleView.tooltips.previewTooltip,
                                           url);
   ruleView.tooltips.previewTooltip.show(anchor);
   yield onShown;
 
   info("Image tooltip is shown, verify that the swatch is still correct");
   swatch = value.querySelector(".ruleview-colorswatch");
-  is(swatch.style.backgroundColor, "rgb(0, 0, 0)",
+  is(swatch.style.backgroundColor, "black",
     "The swatch's color is correct");
-  is(swatch.nextSibling.textContent, "#000", "The color name is correct");
+  is(swatch.nextSibling.textContent, "black", "The color name is correct");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js
index 6e24c9c..d161f27 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_colorpicker-edit-gradient.js
@@ -34,17 +34,17 @@ function testColorParsing(view) {
   let swatchEls = ruleEl.valueSpan.querySelectorAll(".ruleview-colorswatch");
   ok(swatchEls, "The color swatch elements were found");
   is(swatchEls.length, 3, "There are 3 color swatches");
 
   let colorEls = ruleEl.valueSpan.querySelectorAll(".ruleview-color");
   ok(colorEls, "The color elements were found");
   is(colorEls.length, 3, "There are 3 color values");
 
-  let colors = ["#F06", "#333", "#000"];
+  let colors = ["#f06", "#333", "#000"];
   for (let i = 0; i < colors.length; i++) {
     is(colorEls[i].textContent, colors[i], "The right color value was found");
   }
 }
 
 function* testPickingNewColor(view) {
   // Grab the first color swatch and color in the gradient
   let ruleEl = getRuleViewProperty(view, "body", "background-image");
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js b/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js
index 8c1eb82..24e4917 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_cycle-color.js
@@ -22,17 +22,17 @@ add_task(function*() {
   checkColorCycling(container, inspector);
 });
 
 function checkColorCycling(container, inspector) {
   let swatch = container.querySelector(".ruleview-colorswatch");
   let valueNode = container.querySelector(".ruleview-color");
   let win = inspector.sidebar.getWindowForTab("ruleview");
 
-  // Hex (default)
+  // Hex
   is(valueNode.textContent, "#F00", "Color displayed as a hex value.");
 
   // HSL
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "hsl(0, 100%, 50%)",
                             "Color displayed as an HSL value.");
 
@@ -43,20 +43,14 @@ function checkColorCycling(container, inspector) {
                             "Color displayed as an RGB value.");
 
   // Color name
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "red",
                             "Color displayed as a color name.");
 
-  // "Authored" (currently the computed value)
-  EventUtils.synthesizeMouseAtCenter(swatch,
-                                     {type: "mousedown", shiftKey: true}, win);
-  is(valueNode.textContent, "rgb(255, 0, 0)",
-                            "Color displayed as an RGB value.");
-
-  // Back to hex
+  // "Authored"
   EventUtils.synthesizeMouseAtCenter(swatch,
                                      {type: "mousedown", shiftKey: true}, win);
   is(valueNode.textContent, "#F00",
-                            "Color displayed as hex again.");
+                            "Color displayed as an authored value.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js b/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
index 9984999..576c8e9 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
@@ -19,12 +19,11 @@ add_task(function*() {
   let _strings = Services.strings
     .createBundle("chrome://global/locale/devtools/styleinspector.properties");
 
   let inline = _strings.GetStringFromName("rule.sourceInline");
 
   is(elementStyle.rules.length, 3, "Should have 3 rules.");
   is(elementStyle.rules[0].title, inline, "check rule 0 title");
   is(elementStyle.rules[1].title, inline +
-    ":15 @media screen and (min-width: 1px)", "check rule 1 title");
-  is(elementStyle.rules[2].title, inline + ":8", "check rule 2 title");
+    ":9 @media screen and (min-width: 1px)", "check rule 1 title");
+  is(elementStyle.rules[2].title, inline + ":2", "check rule 2 title");
 });
-
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
index f7d267f..7546e29 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_pseudo-element_01.js
@@ -161,27 +161,27 @@ function* testParagraph(inspector, view) {
     firstLetterRulesNb: 1,
     selectionRulesNb: 1
   });
 
   assertGutters(view);
 
   let elementFirstLineRule = rules.firstLineRules[0];
   is(convertTextPropsToString(elementFirstLineRule.textProps),
-     "background: blue none repeat scroll 0% 0%",
+     "background: blue",
      "Paragraph first-line properties are correct");
 
   let elementFirstLetterRule = rules.firstLetterRules[0];
   is(convertTextPropsToString(elementFirstLetterRule.textProps),
      "color: red; font-size: 130%",
      "Paragraph first-letter properties are correct");
 
   let elementSelectionRule = rules.selectionRules[0];
   is(convertTextPropsToString(elementSelectionRule.textProps),
-     "color: white; background: black none repeat scroll 0% 0%",
+     "color: white; background: black",
      "Paragraph first-letter properties are correct");
 }
 
 function* testBody(inspector, view) {
   yield testNode("body", inspector, view);
 
   let gutters = getGutters(view);
   is(gutters.length, 0, "There are no gutter headings");
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js b/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js
index 06370ef..be8bc12 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_refresh-on-attribute-change_02.js
@@ -126,30 +126,28 @@ function* testPropertyChange6(inspector, ruleView, testElement) {
     "url(\"chrome://branding/content/about-logo.png\") repeat scroll 0% 0%",
     inspector);
 
   let rule = ruleView._elementStyle.rules[0];
   is(rule.editor.element.querySelectorAll(".ruleview-property").length, 5,
     "Added a property");
   validateTextProp(rule.textProps[4], true, "background",
                    "red url(\"chrome://branding/content/about-logo.png\") repeat scroll 0% 0%",
-                   "shortcut property correctly set",
-                   "#F00 url(\"chrome://branding/content/about-logo.png\") repeat scroll 0% 0%");
+                   "shortcut property correctly set");
 }
 
 function* changeElementStyle(testElement, style, inspector) {
   let onRefreshed = inspector.once("rule-view-refreshed");
   testElement.setAttribute("style", style);
   yield onRefreshed;
 }
 
-function validateTextProp(aProp, aEnabled, aName, aValue, aDesc,
-    valueSpanText) {
+function validateTextProp(aProp, aEnabled, aName, aValue, aDesc) {
   is(aProp.enabled, aEnabled, aDesc + ": enabled.");
   is(aProp.name, aName, aDesc + ": name.");
   is(aProp.value, aValue, aDesc + ": value.");
 
   is(aProp.editor.enable.hasAttribute("checked"), aEnabled,
     aDesc + ": enabled checkbox.");
   is(aProp.editor.nameSpan.textContent, aName, aDesc + ": name span.");
   is(aProp.editor.valueSpan.textContent,
-    valueSpanText || aValue, aDesc + ": value span.");
+    aValue, aDesc + ": value span.");
 }
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js b/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js
index 5db4a42..910d92a 100644
--- a/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_context-menu-copy-color_01.js
@@ -80,17 +80,17 @@ function testIsColorPopupOnNode(view, node) {
   info("Testing node " + node);
   view.styleDocument.popupNode = node;
   view._contextmenu._colorToCopy = "";
 
   let result = view._contextmenu._isColorPopup();
   let correct = isColorValueNode(node);
 
   is(result, correct, "_isColorPopup returned the expected value " + correct);
-  is(view._contextmenu._colorToCopy, (correct) ? "#123ABC" : "",
+  is(view._contextmenu._colorToCopy, (correct) ? "rgb(18, 58, 188)" : "",
      "_colorToCopy was set to the expected value");
 }
 
 /**
  * Check if a node is part of color value i.e. it has parent with a 'data-color'
  * attribute.
  */
 function isColorValueNode(node) {
diff --git a/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js b/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js
index 08f3caf..4a1f965 100644
--- a/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js
+++ b/browser/devtools/styleinspector/test/browser_styleinspector_refresh_when_active.js
@@ -11,17 +11,17 @@ const TEST_URI = `
   <div id="two" style="color:blue;">two</div>
 `;
 
 add_task(function*() {
   yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
   let {inspector, view} = yield openRuleView();
   yield selectNode("#one", inspector);
 
-  is(getRuleViewPropertyValue(view, "element", "color"), "#F00",
+  is(getRuleViewPropertyValue(view, "element", "color"), "red",
     "The rule-view shows the properties for test node one");
 
   let cView = inspector.sidebar.getWindowForTab("computedview")
     .computedview.view;
   let prop = getComputedViewProperty(cView, "color");
   ok(!prop, "The computed-view doesn't show the properties for test node one");
 
   info("Switching to the computed-view");
@@ -33,11 +33,11 @@ add_task(function*() {
     "The computed-view shows the properties for test node one");
 
   info("Selecting test node two");
   yield selectNode("#two", inspector);
 
   ok(getComputedViewPropertyValue(cView, "color"), "#00F",
     "The computed-view shows the properties for test node two");
 
-  is(getRuleViewPropertyValue(view, "element", "color"), "#F00",
+  is(getRuleViewPropertyValue(view, "element", "color"), "red",
     "The rule-view doesn't the properties for test node two");
 });
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
index 953f488..c44a6b3 100644
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
@@ -64,16 +64,20 @@ values from browser.dtd.  -->
   -  This label is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.label "Default color unit">
 
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.accesskey): This is the access
   -  key for a dropdown list that controls the default color unit used in the
   -  inspector. This is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.accesskey "U">
 
+<!-- LOCALIZATION NOTE (options.defaultColorUnit.authored): This is used in the
+  -  'Default color unit' dropdown list and is visible in the options panel. -->
+<!ENTITY options.defaultColorUnit.authored "As Authored">
+
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.hex): This is used in the
   -  'Default color unit' dropdown list and is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.hex "Hex">
 
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.hsl): This is used in the
   -  'Default color unit' dropdown list and is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.hsl "HSL(A)">
 
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
index b56da16..eb5b192 100644
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -850,17 +850,17 @@ pref("devtools.debugger.force-local", true);
 // Display a prompt when a new connection starts to accept/reject it
 pref("devtools.debugger.prompt-connection", true);
 // Block tools from seeing / interacting with certified apps
 pref("devtools.debugger.forbid-certified-apps", true);
 // List of permissions that a sideloaded app can't ask for
 pref("devtools.apps.forbidden-permissions", "embed-apps,engineering-mode,embed-widgets");
 
 // DevTools default color unit
-pref("devtools.defaultColorUnit", "hex");
+pref("devtools.defaultColorUnit", "authored");
 
 // Used for devtools debugging
 pref("devtools.dump.emit", false);
 
 // Disable device discovery logging
 pref("devtools.discovery.log", false);
 // Whether to scan for DevTools devices via WiFi
 pref("devtools.remote.wifi.scan", true);
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
index fcb3d2f..4c5ce35 100644
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -19,16 +19,20 @@ require("devtools/server/actors/stylesheets");
 
 loader.lazyGetter(this, "CssLogic", () => {
   return require("devtools/styleinspector/css-logic").CssLogic;
 });
 loader.lazyGetter(this, "DOMUtils", () => {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
 });
 
+loader.lazyGetter(this, "RuleRewriter", () => {
+  return require("devtools/styleinspector/css-parsing-utils").RuleRewriter;
+});
+
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
 // Not included since these are uneditable by the user.
 // See https://hg.mozilla.org/mozilla-central/file/696a4ad5d011/layout/style/nsCSSPseudoElementList.h#l74
@@ -504,26 +508,31 @@ let PageStyleActor = protocol.ActorClass({
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSelectors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
-  getApplied: method(function(node, options) {
+  getApplied: method(Task.async(function*(node, options) {
     if (!node) {
       return {entries: [], rules: [], sheets: []};
     }
 
     this.cssLogic.highlight(node.rawNode);
     let entries = [];
     entries = entries.concat(this._getAllElementRules(node, undefined, options));
-    return this.getAppliedProps(node, entries, options);
-  }, {
+
+    let result = this.getAppliedProps(node, entries, options);
+    for (let rule of result.rules) {
+      yield rule.getAuthoredCssText();
+    }
+    return result;
+  }), {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
     response: RetVal("appliedStylesReturn")
   }),
@@ -997,18 +1006,18 @@ let StyleRuleActor = protocol.ActorClass({
     this.pageStyle = pageStyle;
     this.rawStyle = item.style;
 
     if (item instanceof (Ci.nsIDOMCSSRule)) {
       this.type = item.type;
       this.rawRule = item;
       if ((this.rawRule instanceof Ci.nsIDOMCSSStyleRule ||
            this.rawRule instanceof Ci.nsIDOMMozCSSKeyframeRule) &&
-           this.rawRule.parentStyleSheet) {
-        this.line = DOMUtils.getRuleLine(this.rawRule);
+          this.rawRule.parentStyleSheet) {
+        this.line = DOMUtils.getRelativeRuleLine(this.rawRule);
         this.column = DOMUtils.getRuleColumn(this.rawRule);
       }
     } else {
       // Fake a rule
       this.type = ELEMENT_STYLE;
       this.rawNode = item;
       this.rawRule = {
         style: item.style,
@@ -1054,16 +1063,19 @@ let StyleRuleActor = protocol.ActorClass({
       actor: this.actorID,
       type: this.type,
       line: this.line || undefined,
       column: this.column,
       traits: {
         // Whether the style rule actor implements the modifySelector2 method
         // that allows for unmatched rule to be added
         modifySelectorUnmatched: true,
+        // Whether the style rule actor implements the setRuleText
+        // method.
+        canSetRuleText: !!this._parentSheet,
       }
     };
 
     if (this.rawRule.parentRule) {
       form.parentRule = this.pageStyle._styleRef(this.rawRule.parentRule).actorID;
 
       // CSS rules that we call media rules are STYLE_RULES that are children
       // of MEDIA_RULEs. We need to check the parentRule to check if a rule is
@@ -1075,16 +1087,17 @@ let StyleRuleActor = protocol.ActorClass({
           form.media.push(this.rawRule.parentRule.media.item(i));
         }
       }
     }
     if (this.rawRule.parentStyleSheet) {
       form.parentStyleSheet = this.pageStyle._sheetRef(this.rawRule.parentStyleSheet).actorID;
     }
 
+    form.authoredText = this.authoredText;
     switch (this.type) {
       case Ci.nsIDOMCSSRule.STYLE_RULE:
         form.selectors = CssLogic.getSelectors(this.rawRule);
         form.cssText = this.rawStyle.cssText || "";
         break;
       case ELEMENT_STYLE:
         // Elements don't have a parent stylesheet, and therefore
         // don't have an associated URI.  Provide a URI for
@@ -1108,17 +1121,69 @@ let StyleRuleActor = protocol.ActorClass({
         form.keyText = this.rawRule.keyText || "";
         break;
     }
 
     return form;
   },
 
   /**
-   * Modify a rule's properties.  Passed an array of modifications:
+   * Return the authored form of a rule's text.  This will include
+   * invalid and otherwise ignored properties.
+   */
+  getAuthoredCssText: function*() {
+    if (this.type !== Ci.nsIDOMCSSRule.STYLE_RULE ||
+        !this.rawRule.parentStyleSheet) {
+      return "";
+    }
+
+    if (typeof this.authoredText === "string") {
+      return this.authoredText;
+    }
+
+    let parentStyleSheet =
+        this.pageStyle._sheetRef(this.rawRule.parentStyleSheet);
+    let {str: cssText} = yield parentStyleSheet.getText();
+    let {text} = getRuleText(cssText, this.line, this.column);
+
+    // Cache the result on the rule actor to avoid parsing again next time
+    this.authoredText = text;
+    return this.authoredText;
+  },
+
+  /**
+   * Set the contents of the rule.  This rewrites the rule in the
+   * stylesheet and causes it to be re-evaluated.
+   *
+   * @param {String} newText the new text of the rule
+   * @returns the rule with updated properties
+   */
+  setRuleText: method(Task.async(function*(newText) {
+    if (this.type === Ci.nsIDOMCSSRule.STYLE_RULE &&
+        this.rawRule.parentStyleSheet) {
+      let parentStyleSheet =
+          this.pageStyle._sheetRef(this.rawRule.parentStyleSheet);
+      let {str: cssText} = yield parentStyleSheet.getText();
+
+      let {offset, text} = getRuleText(cssText, this.line, this.column);
+      cssText = cssText.substring(0, offset) + newText +
+        cssText.substring(offset + text.length);
+
+      this.authoredText = newText;
+      yield parentStyleSheet.update(cssText, false);
+
+      return this;
+    }
+  }), {
+    request: { modification: Arg(0, "string") },
+    response: { rule: RetVal("domstylerule") }
+  }),
+
+  /**
+   * Modify a rule's properties. Passed an array of modifications:
    * {
    *   type: "set",
    *   name: <string>,
    *   value: <string>,
    *   priority: <optional string>
    * }
    *  or
    * {
@@ -1315,34 +1380,43 @@ let StyleRuleFront = protocol.FrontClass(StyleRuleActor, {
     this.actorID = form.actor;
     this._form = form;
     if (this._mediaText) {
       this._mediaText = null;
     }
   },
 
   /**
-   * Return a new RuleModificationList for this node.
+   * Return a new RuleModificationList or RuleRewriter for this node.
+   * A RuleRewriter will be returned when the rule's canSetRuleText
+   * trait is true; otherwise a RuleModificationList will be
+   * returned.
    */
   startModifyingProperties: function() {
+    if (this.canSetRuleText) {
+      return new RuleRewriter(this, this.authoredText);
+    }
     return new RuleModificationList(this);
   },
 
   get type() {
     return this._form.type;
   },
   get line() {
     return this._form.line || -1;
   },
   get column() {
     return this._form.column || -1;
   },
   get cssText() {
     return this._form.cssText;
   },
+  get authoredText() {
+    return this._form.authoredText || this._form.cssText;
+  },
   get keyText() {
     return this._form.keyText;
   },
   get name() {
     return this._form.name;
   },
   get selectors() {
     return this._form.selectors;
@@ -1385,16 +1459,20 @@ let StyleRuleFront = protocol.FrontClass(StyleRuleActor, {
     let sheet = this.parentStyleSheet;
     return sheet ? sheet.nodeHref : "";
   },
 
   get supportsModifySelectorUnmatched() {
     return this._form.traits && this._form.traits.modifySelectorUnmatched;
   },
 
+  get canSetRuleText() {
+    return this._form.traits && this._form.traits.canSetRuleText;
+  },
+
   get location() {
     return {
       source: this.parentStyleSheet,
       href: this.href,
       line: this.line,
       column: this.column
     };
   },
@@ -1447,65 +1525,144 @@ let StyleRuleFront = protocol.FrontClass(StyleRuleActor, {
 });
 
 /**
  * Convenience API for building a list of attribute modifications
  * for the `modifyProperties` request.  A RuleModificationList holds a
  * list of modifications that will be applied to a StyleRuleActor.
  * The modifications are processed in the order in which they are
  * added to the RuleModificationList.
+ *
+ * Objects of this type expose the same API as @see RuleRewriter.
+ * This lets the inspector use (mostly) the same code, regardless of
+ * whether the server implements setRuleText.
  */
 let RuleModificationList = Class({
   /**
    * Initialize a RuleModificationList.
    * @param {StyleRuleFront} rule the associated rule
    */
   initialize: function(rule) {
     this.rule = rule;
     this.modifications = [];
   },
 
   /**
+   * Return a promise that resolves to the default indentation for
+   * this rule's style sheet.  This implementation always resolves to
+   * null, because |setRuleText| is not available.
+   *
+   * @return {Promise} A promise resolving to null.
+   */
+  getDefaultIndentation: function() {
+    return promise.resolve(null);
+  },
+
+  /**
    * Apply the modifications in this object to the associated rule.
    *
    * @return {Promise} A promise which will be resolved when the modifications
    *         are complete; @see StyleRuleActor.modifyProperties.
    */
   apply: function() {
     return this.rule.modifyProperties(this.modifications);
   },
 
   /**
    * Add a "set" entry to the modification list.
    *
-   * @param {string} name the property's name
-   * @param {string} value the property's value
-   * @param {string} priority the property's priority, either the empty
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name the property's name
+   * @param {String} value the property's value
+   * @param {String} priority the property's priority, either the empty
    *                          string or "important"
    */
-  setProperty: function(name, value, priority) {
+  setProperty: function(index, name, value, priority) {
     this.modifications.push({
       type: "set",
       name: name,
       value: value,
       priority: priority
     });
   },
 
   /**
    * Add a "remove" entry to the modification list.
    *
-   * @param {string} name the name of the property to remove
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name the name of the property to remove
    */
-  removeProperty: function(name) {
+  removeProperty: function(index, name) {
     this.modifications.push({
       type: "remove",
       name: name
     });
-  }
+  },
+
+  /**
+   * Rename a property.  This implementation acts like
+   * |removeProperty|, because |setRuleText| is not available.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name current name of the property
+   * @param {String} newName new name of the property
+   */
+  renameProperty: function(index, name, newName) {
+    this.removeProperty(index, name);
+  },
+
+  /**
+   * Enable or disable a property.  This implementation acts like
+   * |removeProperty| when disabling, or a no-op when enabling,
+   * because |setRuleText| is not available.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name current name of the property
+   * @param {Boolean} isEnabled true if the property should be enabled;
+   *                        false if it should be disabled
+   */
+  setPropertyEnabled: function(index, name, isEnabled) {
+    if (!isEnabled) {
+      this.removeProperty(index, name);
+    }
+  },
+
+  /**
+   * Create a new property.  This implementation does nothing, because
+   * |setRuleText| is not available.
+   *
+   * @param {Number} index index of the property in the rule.
+   *                       This can be -1 in the case where
+   *                       the rule does not support setRuleText;
+   *                       generally for setting properties
+   *                       on an element's style.
+   * @param {String} name name of the new property
+   * @param {String} value value of the new property
+   * @param {String} priority priority of the new property; either
+   *                          the empty string or "important"
+   */
+  createProperty: function(index, name, value, priority) {
+    // Nothing.
+  },
 });
 
 /**
  * Helper function for getting an image preview of the given font.
  *
  * @param font {string}
  *        Name of font to preview
  * @param doc {Document}
