# HG changeset patch
# Parent 551f52f65baf1c51ab68d5a34a36c82bc4a761df

diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -2612,93 +2612,55 @@ exports._documentWalker = documentWalker
 
 function nodeDocument(node) {
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
  * Similar to a TreeWalker, except will dig in to iframes and it doesn't
  * implement the good methods like previousNode and nextNode.
+ * XXX: if deep-tree-walker really does show subdocuments as it claims, this
+ * might be able to go away entirely.
  *
  * See TreeWalker documentation for explanations of the methods.
  */
 function DocumentWalker(aNode, aRootWin, aShow, aFilter, aExpandEntityReferences) {
-  let doc = nodeDocument(aNode);
-  this.layoutHelpers = new LayoutHelpers(aRootWin);
-  this.walker = doc.createTreeWalker(doc,
-    aShow, aFilter, aExpandEntityReferences);
+  let doc = aRootWin.document;
+
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.init(doc, aShow);
   this.walker.currentNode = aNode;
-  this.filter = aFilter;
 }
 
 DocumentWalker.prototype = {
   get node() this.walker.node,
   get whatToShow() this.walker.whatToShow,
   get expandEntityReferences() this.walker.expandEntityReferences,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
 
-  /**
-   * Called when the new node is in a different document than
-   * the current node, creates a new treewalker for the document we've
-   * run in to.
-   */
-  _reparentWalker: function(aNewNode) {
-    if (!aNewNode) {
-      return null;
-    }
-    let doc = nodeDocument(aNewNode);
-    let walker = doc.createTreeWalker(doc,
-      this.whatToShow, this.filter, this.expandEntityReferences);
-    walker.currentNode = aNewNode;
-    this.walker = walker;
-    return aNewNode;
-  },
-
   parentNode: function() {
-    let currentNode = this.walker.currentNode;
-    let parentNode = this.walker.parentNode();
-
-    if (!parentNode) {
-      if (currentNode && currentNode.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE
-          && currentNode.defaultView) {
-
-        let window = currentNode.defaultView;
-        let frame = this.layoutHelpers.getFrameElement(window);
-        if (frame) {
-          return this._reparentWalker(frame);
-        }
-      }
-      return null;
-    }
-
-    return parentNode;
+    return this.walker.parentNode();
   },
 
   firstChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument) {
-      return this._reparentWalker(node.getSVGDocument());
-    }
+
     return this.walker.firstChild();
   },
 
   lastChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
-    if (node.contentDocument) {
-      return this._reparentWalker(node.contentDocument);
-    } else if (node.getSVGDocument) {
-      return this._reparentWalker(node.getSVGDocument());
-    }
+
     return this.walker.lastChild();
   },
 
   previousSibling: function DW_previousSibling() this.walker.previousSibling(),
   nextSibling: function DW_nextSibling() this.walker.nextSibling()
 };
 
 /**
diff --git a/toolkit/devtools/server/dbg-server.jsm b/toolkit/devtools/server/dbg-server.jsm
--- a/toolkit/devtools/server/dbg-server.jsm
+++ b/toolkit/devtools/server/dbg-server.jsm
@@ -17,9 +17,21 @@ const Cu = Components.utils;
 
 const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 
 this.EXPORTED_SYMBOLS = ["DebuggerServer", "ActorPool"];
 
 let server = devtools.require("devtools/server/main");
 
 this.DebuggerServer = server.DebuggerServer;
+
+let realConnectionChange;
+this.DebuggerServer.setConnectionChange = function(fn)  {
+  realConnectionChange = fn;
+}
+
+this.DebuggerServer.onConnectionChange = function(detail) {
+  if (realConnectionChange) {
+    realConnectionChange(detail);
+  }
+}
+
 this.ActorPool = server.ActorPool;
diff --git a/toolkit/devtools/server/protocol.js b/toolkit/devtools/server/protocol.js
--- a/toolkit/devtools/server/protocol.js
+++ b/toolkit/devtools/server/protocol.js
@@ -6,16 +6,46 @@
 
 let {Cu} = require("chrome");
 let Services = require("Services");
 let promise = require("devtools/toolkit/deprecated-sync-thenables");
 let {Class} = require("sdk/core/heritage");
 let {EventTarget} = require("sdk/event/target");
 let events = require("sdk/event/core");
 let object = require("sdk/util/object");
+let {PrefsTarget} = require("sdk/preferences/event-target");
+
+
+
+
+let gActorLogTypes;
+let gFrontLogTypes;
+function updateLogging()
+{
+  let typeNames = require("sdk/preferences/service").get("devtools.log-actors", "").split(",");
+  gActorLogTypes = new Set();
+  for (let name of typeNames) {
+    gActorLogTypes.add(name);
+  }
+
+  typeNames = require("sdk/preferences/service").get("devtools.log-fronts", "").split(",");
+  gFrontLogTypes = new Set();
+  for (let name of typeNames) {
+    gFrontLogTypes.add(name);
+  }
+};
+updateLogging();
+
+let logTarget = PrefsTarget({ branchName: "devtools." });
+logTarget.on("log-actors", name => {
+  updateLogging();
+});
+logTarget.on("log-fronts", name => {
+  updateLogging();
+});
 
 // Waiting for promise.done() to be added, see bug 851321
 function promiseDone(err) {
   console.error(err);
   return promise.reject(err);
 }
 
 /**
@@ -819,25 +849,32 @@ let Actor = Class({
         let sendEvent = this._sendEvent.bind(this, name)
         this.on(name, (...args) => {
           sendEvent.apply(null, args);
         });
       }
     }
   },
 
+  _sendPacket: function(packet) {
+    if (gActorLogTypes.has(this.typeName)) {
+      console.log("ACTOR SEND:" + this.actorID + ":" + JSON.stringify(packet, null, 2));
+    }
+    this.conn.send(packet);
+  },
+
   _sendEvent: function(name, ...args) {
     if (!this._actorSpec.events.has(name)) {
       // It's ok to emit events that don't go over the wire.
       return;
     }
     let request = this._actorSpec.events.get(name);
     let packet = request.write(args, this);
     packet.from = packet.from || this.actorID;
-    this.conn.send(packet);
+    this._sendPacket(packet);
   },
 
   destroy: function() {
     Pool.prototype.destroy.call(this);
     this.actorID = null;
   },
 
   /**
@@ -850,17 +887,17 @@ let Actor = Class({
     return { actor: this.actorID }
   },
 
   writeError: function(err) {
     console.error(err);
     if (err.stack) {
       dump(err.stack);
     }
-    this.conn.send({
+    this._sendPacket({
       from: this.actorID,
       error: "unknownError",
       message: err.toString()
     });
   },
 
   _queueResponse: function(create) {
     let pending = this._pendingResponse || promise.resolve(null);
@@ -932,16 +969,19 @@ let actorProto = function(actorProto) {
       protoSpec.events.set(name, Request(object.merge({type: name}, eventRequest)));
     }
   }
 
   // Generate request handlers for each method definition
   actorProto.requestTypes = Object.create(null);
   protoSpec.methods.forEach(spec => {
     let handler = function(packet, conn) {
+      if (gActorLogTypes.has(this.typeName)) {
+        console.log("ACTOR RECV:" + this.actorID + ":" + JSON.stringify(packet, null, 2));
+      }
       try {
         let args = spec.request.read(packet, this);
 
         let ret = this[spec.name].apply(this, args);
 
         if (spec.oneway) {
           // No need to send a response.
           return;
@@ -955,17 +995,17 @@ let actorProto = function(actorProto) {
             try {
               this.destroy();
             } catch(e) {
               this.writeError(e);
               return;
             }
           }
 
-          conn.send(response);
+          this._sendPacket(response);
         };
 
         this._queueResponse(p => {
           return p
             .then(() => ret)
             .then(sendReturn)
             .then(null, this.writeError.bind(this));
         })
@@ -1052,26 +1092,33 @@ let Front = Class({
   toString: function() { return "[Front for " + this.typeName + "/" + this.actorID + "]" },
 
   /**
    * Update the actor from its representation.
    * Subclasses should override this.
    */
   form: function(form) {},
 
+  _sendPacket: function(packet) {
+    if (gFrontLogTypes.has(this.typeName)) {
+      console.log("FRONT SEND:" + this.actorID + ":" + JSON.stringify(packet, null, 2));
+    }
+    this.conn._transport.send(packet);
+  },
+
   /**
    * Send a packet on the connection.
    */
   send: function(packet) {
     if (packet.to) {
-      this.conn._transport.send(packet);
+      this._sendPacket(packet);
     } else {
       this.actor().then(actorID => {
         packet.to = actorID;
-        this.conn._transport.send(packet);
+        this._sendPacket(packet);
       });
     }
   },
 
   /**
    * Send a two-way request on the connection.
    */
   request: function(packet) {
@@ -1080,16 +1127,20 @@ let Front = Class({
     this.send(packet);
     return deferred.promise;
   },
 
   /**
    * Handler for incoming packets from the client's actor.
    */
   onPacket: function(packet) {
+    if (gFrontLogTypes.has(this.typeName)) {
+      console.log("FRONT RECV:" + this.actorID + ":" + JSON.stringify(packet, null, 2));
+    }
+
     // Pick off event packets
     if (this._clientSpec.events && this._clientSpec.events.has(packet.type)) {
       let event = this._clientSpec.events.get(packet.type);
       let args = event.request.read(packet, this);
       if (event.pre) {
         event.pre.forEach((pre) => pre.apply(this, args));
       }
       events.emit.apply(null, [this, event.name].concat(args));
