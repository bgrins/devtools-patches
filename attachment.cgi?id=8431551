# HG changeset patch
# Parent 517a797c25339f837d2b1eb5c9100d5b7f878c6d
# User Michael Ratcliffe <mratcliffe@mozilla.com>
# Date 1401443242 -3600

Bug 969306 - Remove getQuads() polyfill now that getQuads has landed r=pbrosset

diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter.js b/browser/devtools/inspector/test/browser_inspector_highlighter.js
--- a/browser/devtools/inspector/test/browser_inspector_highlighter.js
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter.js
@@ -1,16 +1,17 @@
 /* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 let doc;
 let h1;
+let rotated;
 let inspector;
 
 function createDocument() {
   let div = doc.createElement("div");
   h1 = doc.createElement("h1");
   let p1 = doc.createElement("p");
   let p2 = doc.createElement("p");
   let div2 = doc.createElement("div");
@@ -33,83 +34,129 @@ function createDocument() {
     "fugiat nulla pariatur. Excepteur sint occaecat cupidatat non " +
     "proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";
   let div3 = doc.createElement("div");
   div3.id = "checkOutThisWickedSpread";
   div3.setAttribute("style", "position: absolute; top: 20px; right: 20px; height: 20px; width: 20px; background-color: yellow; border: 1px dashed black;");
   let p4 = doc.createElement("p");
   p4.setAttribute("style", "font-weight: 200; font-size: 8px; text-align: center;");
   p4.textContent = "Smörgåsbord!";
+  rotated = doc.createElement("div");
+  rotated.setAttribute("style",
+                       "padding:5px; border:7px solid red; margin: 9px; " +
+                       "transform:rotate(45deg); " +
+                       "position:absolute; top:30px; left:80px;");
   div.appendChild(h1);
   div.appendChild(p1);
   div.appendChild(p2);
   div2.appendChild(p3);
   div3.appendChild(p4);
   doc.body.appendChild(div);
   doc.body.appendChild(div2);
   doc.body.appendChild(div3);
+  doc.body.appendChild(rotated);
 
   openInspector(aInspector => {
     inspector = aInspector;
     inspector.selection.setNode(div, null);
     inspector.once("inspector-updated", () => {
       inspector.toolbox.highlighterUtils.startPicker().then(testMouseOverH1Highlights);
     });
   });
 }
 
 function testMouseOverH1Highlights() {
   inspector.toolbox.once("highlighter-ready", () => {
     ok(isHighlighting(), "Highlighter is shown");
     is(getHighlitNode(), h1, "Highlighter's outline correspond to the selected node");
-    testBoxModelDimensions();
+    testH1BoxModelDimensions();
   });
 
   EventUtils.synthesizeMouse(h1, 2, 2, {type: "mousemove"}, content);
 }
 
-function testBoxModelDimensions() {
+function testH1BoxModelDimensions() {
   let h1Dims = h1.getBoundingClientRect();
   let h1Width = Math.ceil(h1Dims.width);
   let h1Height = Math.ceil(h1Dims.height);
 
   let outlineDims = getSimpleBorderRect();
   let outlineWidth = Math.ceil(outlineDims.width);
   let outlineHeight = Math.ceil(outlineDims.height);
 
   // Disabled due to bug 716245
   is(outlineWidth, h1Width, "outline width matches dimensions of element (no zoom)");
   is(outlineHeight, h1Height, "outline height matches dimensions of element (no zoom)");
 
   // zoom the page by a factor of 2
   let contentViewer = gBrowser.selectedBrowser.docShell.contentViewer
                              .QueryInterface(Ci.nsIMarkupDocumentViewer);
+
   contentViewer.fullZoom = 2;
+  inspector.toolbox.once("highlighter-ready", () => {
+    // simulate the zoomed dimensions of the div element
+    let h1Dims = h1.getBoundingClientRect();
+    // There seems to be some very minor differences in the floats, so let's
+    // floor the values
+    let h1Width = Math.floor(h1Dims.width * contentViewer.fullZoom);
+    let h1Height = Math.floor(h1Dims.height * contentViewer.fullZoom);
 
-  // simulate the zoomed dimensions of the div element
-  let h1Dims = h1.getBoundingClientRect();
-  // There seems to be some very minor differences in the floats, so let's
-  // floor the values
-  let h1Width = Math.floor(h1Dims.width * contentViewer.fullZoom);
-  let h1Height = Math.floor(h1Dims.height * contentViewer.fullZoom);
+    let outlineDims = getSimpleBorderRect();
+    let outlineWidth = Math.floor(outlineDims.width);
+    let outlineHeight = Math.floor(outlineDims.height);
 
-  let outlineDims = getSimpleBorderRect();
-  let outlineWidth = Math.floor(outlineDims.width);
-  let outlineHeight = Math.floor(outlineDims.height);
+    is(outlineWidth, h1Width, "outline width matches dimensions of element (zoomed)");
 
-  is(outlineWidth, h1Width, "outline width matches dimensions of element (zoomed)");
+    is(outlineHeight, h1Height, "outline height matches dimensions of element (zoomed)");
 
-  is(outlineHeight, h1Height, "outline height matches dimensions of element (zoomed)");
+    contentViewer.fullZoom = 1;
+    inspector.toolbox.once("highlighter-ready", testMouseOverRotatedHighlights);
+  });
+}
 
-  executeSoon(finishUp);
+function testMouseOverRotatedHighlights() {
+  inspector.toolbox.once("highlighter-ready", () => {
+    ok(isHighlighting(), "Highlighter is shown");
+    is(getHighlitNode(), rotated, "Highlighter's outline correspond to the rotated div");
+
+    let boxModel = getBoxModelStatus();
+    let {p1:cp1, p2:cp2, p3:cp3, p4:cp4} = boxModel.content.points;
+
+    is(JSON.stringify(cp1), '{"x":101,"y":51}', "content point 1 is correct");
+    is(JSON.stringify(cp2), '{"x":101,"y":51}', "content point 2 is correct");
+    is(JSON.stringify(cp3), '{"x":101,"y":51}', "content point 3 is correct");
+    is(JSON.stringify(cp4), '{"x":101,"y":51}', "content point 4 is correct");
+
+    let {p1:pp1, p2:pp2, p3:pp3, p4:pp4} = boxModel.padding.points;
+    is(JSON.stringify(pp1), '{"x":101,"y":43.928932189941406}', "padding point 1 is correct");
+    is(JSON.stringify(pp2), '{"x":108.0710678100586,"y":51}', "padding point 2 is correct");
+    is(JSON.stringify(pp3), '{"x":101,"y":58.071067810058594}', "padding point 3 is correct");
+    is(JSON.stringify(pp4), '{"x":93.9289321899414,"y":51}', "padding point 4 is correct");
+
+    let {p1:bp1, p2:bp2, p3:bp3, p4:bp4} = boxModel.border.points;
+    is(JSON.stringify(bp1), '{"x":101,"y":34.02943801879883}', "border point 1 is correct");
+    is(JSON.stringify(bp2), '{"x":117.97056579589844,"y":51}', "border point 2 is correct");
+    is(JSON.stringify(bp3), '{"x":101,"y":67.97056579589844}', "border point 3 is correct");
+    is(JSON.stringify(bp4), '{"x":84.02943420410156,"y":51}', "border point 4 is correct");
+
+    let {p1:mp1, p2:mp2, p3:mp3, p4:mp4} = boxModel.margin.points;
+    is(JSON.stringify(mp1), '{"x":101,"y":21.301515579223633}', "margin point 1 is correct");
+    is(JSON.stringify(mp2), '{"x":130.698486328125,"y":51}', "margin point 2 is correct");
+    is(JSON.stringify(mp3), '{"x":101,"y":80.698486328125}', "margin point 3 is correct");
+    is(JSON.stringify(mp4), '{"x":71.301513671875,"y":51}', "margin point 4 is correct");
+
+    executeSoon(finishUp);
+  });
+
+  EventUtils.synthesizeMouseAtCenter(rotated, {type: "mousemove"}, content);
 }
 
 function finishUp() {
   inspector.toolbox.highlighterUtils.stopPicker().then(() => {
-    doc = h1 = inspector = null;
+    doc = h1 = rotated = inspector = null;
     let target = TargetFactory.forTab(gBrowser.selectedTab);
     gDevTools.closeToolbox(target);
     gBrowser.removeCurrentTab();
     finish();
   });
 }
 
 function test() {
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -407,103 +407,9 @@ LayoutHelpers.prototype = {
       xOffset += frameRect.left + offsetLeft;
       yOffset += frameRect.top + offsetTop;
 
       frameWin = this.getParentWindow(frameWin);
     }
 
     return [xOffset * scale, yOffset * scale];
   },
-
-
-
-  /********************************************************************
-   * GetBoxQuads POLYFILL START TODO: Remove this when bug 917755 is fixed.
-   ********************************************************************/
-  _getBoxQuadsFromRect: function(rect, node) {
-    let scale = this.calculateScale(node);
-    let [xOffset, yOffset] = this._getNodeOffsets(node);
-
-    let out = {
-      p1: {
-        x: rect.left * scale + xOffset,
-        y: rect.top * scale + yOffset
-      },
-      p2: {
-        x: (rect.left + rect.width) * scale + xOffset,
-        y: rect.top * scale + yOffset
-      },
-      p3: {
-        x: (rect.left + rect.width) * scale + xOffset,
-        y: (rect.top + rect.height) * scale + yOffset
-      },
-      p4: {
-        x: rect.left * scale + xOffset,
-        y: (rect.top + rect.height) * scale + yOffset
-      }
-    };
-
-    out.bounds = {
-      bottom: out.p4.y,
-      height: out.p4.y - out.p1.y,
-      left: out.p1.x,
-      right: out.p2.x,
-      top: out.p1.y,
-      width: out.p2.x - out.p1.x,
-      x: out.p1.x,
-      y: out.p1.y
-    };
-
-    return out;
-  },
-
-  _parseNb: function(distance) {
-    let nb = parseFloat(distance, 10);
-    return isNaN(nb) ? 0 : nb;
-  },
-
-  getAdjustedQuadsPolyfill: function(node, region) {
-    // Get the border-box rect
-    // Note that this is relative to the node's viewport, so before we can use
-    // it, will need to go back up the frames like getRect
-    let borderRect = node.getBoundingClientRect();
-
-    // If the boxType is border, no need to go any further, we're done
-    if (region === "border") {
-      return this._getBoxQuadsFromRect(borderRect, node);
-    }
-
-    // Else, need to get margin/padding/border distances
-    let style = node.ownerDocument.defaultView.getComputedStyle(node);
-    let camel = s => s.substring(0, 1).toUpperCase() + s.substring(1);
-    let distances = {border:{}, padding:{}, margin: {}};
-
-    for (let side of ["top", "right", "bottom", "left"]) {
-      distances.border[side] = this._parseNb(style["border" + camel(side) + "Width"]);
-      distances.padding[side] = this._parseNb(style["padding" + camel(side)]);
-      distances.margin[side] = this._parseNb(style["margin" + camel(side)]);
-    }
-
-    // From the border-box rect, calculate the content-box, padding-box and
-    // margin-box rects
-    function offsetRect(rect, offsetType, dir=1) {
-      return {
-        top: rect.top + (dir * distances[offsetType].top),
-        left: rect.left + (dir * distances[offsetType].left),
-        width: rect.width - (dir * (distances[offsetType].left + distances[offsetType].right)),
-        height: rect.height - (dir * (distances[offsetType].top + distances[offsetType].bottom))
-      };
-    }
-
-    if (region === "margin") {
-      return this._getBoxQuadsFromRect(offsetRect(borderRect, "margin", -1), node);
-    } else if (region === "padding") {
-      return this._getBoxQuadsFromRect(offsetRect(borderRect, "border"), node);
-    } else if (region === "content") {
-      let paddingRect = offsetRect(borderRect, "border");
-      return this._getBoxQuadsFromRect(offsetRect(paddingRect, "padding"), node);
-    }
-  },
-
-  /********************************************************************
-   * GetBoxQuads POLYFILL END
-   ********************************************************************/
 };
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -577,29 +577,26 @@ BoxModelHighlighter.prototype = {
    * @return {boolean}
    *         True if the rectangle was highlighted, false otherwise.
    */
   _highlightBoxModel: function(options) {
     let isShown = false;
 
     options.region = options.region || "content";
 
-    // TODO: Remove this polyfill
-    this.rect =
-      this.layoutHelpers.getAdjustedQuadsPolyfill(this.currentNode, "margin");
+    this.rect = this.layoutHelpers.getAdjustedQuads(this.currentNode, "margin");
 
     if (!this.rect) {
       return null;
     }
 
     if (this.rect.bounds.width > 0 && this.rect.bounds.height > 0) {
       for (let boxType in this._boxModelNodes) {
-        // TODO: Remove this polyfill
         let {p1, p2, p3, p4} = boxType === "margin" ? this.rect :
-          this.layoutHelpers.getAdjustedQuadsPolyfill(this.currentNode, boxType);
+          this.layoutHelpers.getAdjustedQuads(this.currentNode, boxType);
 
         let boxNode = this._boxModelNodes[boxType];
         boxNode.setAttribute("points",
                              p1.x + "," + p1.y + " " +
                              p2.x + "," + p2.y + " " +
                              p3.x + "," + p3.y + " " +
                              p4.x + "," + p4.y);
 
