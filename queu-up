# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  af70166c484125be653be297e114869bacb957db

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -2,35 +2,58 @@
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
+  let queuedUp = new Set();
+  let rAF = null;
+  function processRAF() {
+    for (let el of queuedUp) {
+      el.formatAccessKey();
+    }
+    queuedUp.clear();
+  }
 
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
   static get observedAttributes() {
     return ["accesskey", "text"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue == newValue) {
       return;
     }
-    this.formatAccessKey();
+
+    queuedUp.add(this);
+    if (!rAF) {
+      rAF = window.requestAnimationFrame(processRAF);
+    }
   }
 
   get needsFormatting() {
-    return this.hasAttribute("control") ||
-           this.classList.contains("radio-label") ||
-           this.classList.contains("checkbox-label") ||
-           this.classList.contains("toolbarbutton-multiline-text");
+    setGlobalAccessKeyFormattingState();
+    if (!gUnderlineAccesskey ||
+      this._lastFormattedAccessKey == this.accessKey ||
+      !this.isConnected ||
+      !this.textContent ||
+      !(
+        this.hasAttribute("control") ||
+        this.classList.contains("radio-label") ||
+        this.classList.contains("checkbox-label") ||
+        this.classList.contains("toolbarbutton-multiline-text")
+      )) {
+    return false;
+    }
+
+    return true;
   }
 
   _onClick(event) {
     if (this.isTextLink) {
       if (event.button == 0 || event.button == 1) {
         this.openLink(event);
       }
       return;
@@ -76,18 +99,20 @@ class MozTextLabel extends MozElementMix
       this.connectedOnce = true;
       this._lastFormattedAccessKey = null;
       this.addEventListener("click", this, true);
       if (this.isTextLink) {
         this.addEventListener("keypress", this);
       }
     }
 
-    setGlobalAccessKeyFormattingState();
-    this.formatAccessKey();
+    queuedUp.add(this);
+    if (!rAF) {
+      rAF = window.requestAnimationFrame(processRAF);
+    }
   }
 
   get isTextLink() {
     return this.classList.contains("text-link") || this.hasAttribute("onClick");
   }
 
   set accessKey(val) {
     this.setAttribute("accesskey", val);
@@ -118,23 +143,20 @@ class MozTextLabel extends MozElementMix
   get href() {
     return this.getAttribute("href");
   }
 
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey() {
     // Skip doing any DOM manipulation whenever possible:
-    let accessKey = this.accessKey;
-    if (!gUnderlineAccesskey ||
-        this._lastFormattedAccessKey == accessKey ||
-        !this.textContent ||
-        !this.needsFormatting) {
+    if (!this.needsFormatting) {
       return;
     }
+    let accessKey = this.accessKey;
     this._lastFormattedAccessKey = accessKey;
 
     if (this.accessKeySpan) { // Clear old accesskey
       mergeElement(this.accessKeySpan);
       this.accessKeySpan = null;
     }
 
     if (this.hiddenColon) {
