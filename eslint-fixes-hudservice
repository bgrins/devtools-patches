# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  22cd936f130422613a28bbe47e2bae201d9f790c

diff --git a/devtools/client/webconsole/hudservice.js b/devtools/client/webconsole/hudservice.js
--- a/devtools/client/webconsole/hudservice.js
+++ b/devtools/client/webconsole/hudservice.js
@@ -26,18 +26,17 @@ const BROWSER_CONSOLE_WINDOW_FEATURES = 
 
 // The preference prefix for all of the Browser Console filters.
 const BROWSER_CONSOLE_FILTER_PREFS_PREFIX = "devtools.browserconsole.filter.";
 
 var gHudId = 0;
 
 // The HUD service
 
-function HUD_SERVICE()
-{
+function HUD_SERVICE() {
   this.consoles = new Map();
   this.lastFinishedRequest = { callback: null };
 }
 
 HUD_SERVICE.prototype =
 {
   _browserConsoleID: null,
   _browserConsoleDefer: null,
@@ -78,18 +77,17 @@ HUD_SERVICE.prototype =
    * @param nsIDOMWindow aIframeWindow
    *        The window where the web console UI is already loaded.
    * @param nsIDOMWindow aChromeWindow
    *        The window of the web console owner.
    * @return object
    *         A promise object for the opening of the new WebConsole instance.
    */
   openWebConsole:
-  function HS_openWebConsole(aTarget, aIframeWindow, aChromeWindow)
-  {
+  function HS_openWebConsole(aTarget, aIframeWindow, aChromeWindow) {
     let hud = new WebConsole(aTarget, aIframeWindow, aChromeWindow);
     this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
    * Open a Browser Console for the given target.
    *
@@ -100,89 +98,83 @@ HUD_SERVICE.prototype =
    * @param nsIDOMWindow aIframeWindow
    *        The window where the browser console UI is already loaded.
    * @param nsIDOMWindow aChromeWindow
    *        The window of the browser console owner.
    * @return object
    *         A promise object for the opening of the new BrowserConsole instance.
    */
   openBrowserConsole:
-  function HS_openBrowserConsole(aTarget, aIframeWindow, aChromeWindow)
-  {
+  function HS_openBrowserConsole(aTarget, aIframeWindow, aChromeWindow) {
     let hud = new BrowserConsole(aTarget, aIframeWindow, aChromeWindow);
     this._browserConsoleID = hud.hudId;
     this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
    * Returns the Web Console object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
    */
-  getHudByWindow: function HS_getHudByWindow(aContentWindow)
-  {
+  getHudByWindow: function HS_getHudByWindow(aContentWindow) {
     for (let [hudId, hud] of this.consoles) {
       let target = hud.target;
       if (target && target.tab && target.window === aContentWindow) {
         return hud;
       }
     }
     return null;
   },
 
   /**
    * Returns the console instance for a given id.
    *
    * @param string aId
    * @returns Object
    */
-  getHudReferenceById: function HS_getHudReferenceById(aId)
-  {
+  getHudReferenceById: function HS_getHudReferenceById(aId) {
     return this.consoles.get(aId);
   },
 
   /**
    * Find if there is a Web Console open for the current tab and return the
    * instance.
    * @return object|null
    *         The WebConsole object or null if the active tab has no open Web
    *         Console.
    */
-  getOpenWebConsole: function HS_getOpenWebConsole()
-  {
+  getOpenWebConsole: function HS_getOpenWebConsole() {
     let tab = this.currentContext().gBrowser.selectedTab;
     if (!tab || !TargetFactory.isKnownTab(tab)) {
       return null;
     }
     let target = TargetFactory.forTab(tab);
     let toolbox = gDevTools.getToolbox(target);
     let panel = toolbox ? toolbox.getPanel("webconsole") : null;
     return panel ? panel.hud : null;
   },
 
   /**
    * Toggle the Browser Console.
    */
-  toggleBrowserConsole: function HS_toggleBrowserConsole()
-  {
+  toggleBrowserConsole: function HS_toggleBrowserConsole() {
     if (this._browserConsoleID) {
       let hud = this.getHudReferenceById(this._browserConsoleID);
       return hud.destroy();
     }
 
     if (this._browserConsoleDefer) {
       return this._browserConsoleDefer.promise;
     }
 
     this._browserConsoleDefer = defer();
 
-    function connect()
-    {
+    function connect() {
       let deferred = defer();
 
       if (!DebuggerServer.initialized) {
         DebuggerServer.init();
         DebuggerServer.addBrowserActors();
       }
       DebuggerServer.allowChromeProcess = true;
 
@@ -192,31 +184,29 @@ HUD_SERVICE.prototype =
         .then(aResponse => {
           // Set chrome:false in order to attach to the target
           // (i.e. send an `attach` request to the chrome actor)
           return { form: aResponse.form, client: client, chrome: false };
         });
     }
 
     let target;
-    function getTarget(aConnection)
-    {
+    function getTarget(aConnection) {
       return TargetFactory.forRemoteTab(aConnection);
     }
-    function openWindow(aTarget)
-    {
+    function openWindow(aTarget) {
       target = aTarget;
       let deferred = defer();
       // Using the old frontend for now in the browser console.  This can be switched to
       // Tools.webConsole.url to use whatever is preffed on.
       let url = Tools.webConsole.oldWebConsoleURL;
       let win = Services.ww.openWindow(null, url, "_blank",
                                        BROWSER_CONSOLE_WINDOW_FEATURES, null);
       win.addEventListener("DOMContentLoaded", function () {
-          win.document.title = l10n.getStr("browserConsole.title");
+        win.document.title = l10n.getStr("browserConsole.title");
         deferred.resolve(win);
       }, {once: true});
       return deferred.promise;
     }
     connect().then(getTarget).then(openWindow).then((aWindow) => {
       return this.openBrowserConsole(target, aWindow, aWindow)
         .then((aBrowserConsole) => {
           this._browserConsoleDefer.resolve(aBrowserConsole);
@@ -225,42 +215,38 @@ HUD_SERVICE.prototype =
     }, console.error.bind(console));
 
     return this._browserConsoleDefer.promise;
   },
 
   /**
    * Opens or focuses the Browser Console.
    */
-  openBrowserConsoleOrFocus: function HS_openBrowserConsoleOrFocus()
-  {
+  openBrowserConsoleOrFocus: function HS_openBrowserConsoleOrFocus() {
     let hud = this.getBrowserConsole();
     if (hud) {
       hud.iframeWindow.focus();
       return promise.resolve(hud);
     }
-    else {
-      return this.toggleBrowserConsole();
-    }
+
+    return this.toggleBrowserConsole();
   },
 
   /**
    * Get the Browser Console instance, if open.
    *
    * @return object|null
    *         A BrowserConsole instance or null if the Browser Console is not
    *         open.
    */
-  getBrowserConsole: function HS_getBrowserConsole()
-  {
+  getBrowserConsole: function HS_getBrowserConsole() {
     return this.getHudReferenceById(this._browserConsoleID);
   },
 };
 
-
 /**
  * A WebConsole instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
  *
  * This object only wraps the iframe that holds the Web Console UI. This is
  * meant to be an integration point between the Firefox UI and the Web Console
  * UI and features.
@@ -268,18 +254,17 @@ HUD_SERVICE.prototype =
  * @constructor
  * @param object aTarget
  *        The target that the web console will connect to.
  * @param nsIDOMWindow aIframeWindow
  *        The window where the web console UI is already loaded.
  * @param nsIDOMWindow aChromeWindow
  *        The window of the web console owner.
  */
-function WebConsole(aTarget, aIframeWindow, aChromeWindow)
-{
+function WebConsole(aTarget, aIframeWindow, aChromeWindow) {
   this.iframeWindow = aIframeWindow;
   this.chromeWindow = aChromeWindow;
   this.hudId = "hud_" + ++gHudId;
   this.target = aTarget;
   this.browserWindow = this.chromeWindow.top;
   let element = this.browserWindow.document.documentElement;
   if (element.getAttribute("windowtype") != gDevTools.chromeWindowType) {
     this.browserWindow = HUDService.currentContext();
@@ -302,122 +287,111 @@ WebConsole.prototype = {
 
   /**
    * Getter for a function to to listen for every request that completes. Used
    * by unit tests. The callback takes one argument: the HTTP activity object as
    * received from the remote Web Console.
    *
    * @type function
    */
-  get lastFinishedRequestCallback()
-  {
+  get lastFinishedRequestCallback() {
     return HUDService.lastFinishedRequest.callback;
   },
 
   /**
    * Getter for the window that can provide various utilities that the web
    * console makes use of, like opening links, managing popups, etc.  In
    * most cases, this will be |this.browserWindow|, but in some uses (such as
    * the Browser Toolbox), there is no browser window, so an alternative window
    * hosts the utilities there.
    * @type nsIDOMWindow
    */
-  get chromeUtilsWindow()
-  {
+  get chromeUtilsWindow() {
     if (this.browserWindow) {
       return this.browserWindow;
     }
     return this.chromeWindow.top;
   },
 
   /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
-  get mainPopupSet()
-  {
+  get mainPopupSet() {
     return this.chromeUtilsWindow.document.getElementById("mainPopupSet");
   },
 
   /**
    * Getter for the output element that holds messages we display.
    * @type nsIDOMElement
    */
-  get outputNode()
-  {
+  get outputNode() {
     return this.ui ? this.ui.outputNode : null;
   },
 
-  get gViewSourceUtils()
-  {
+  get gViewSourceUtils() {
     return this.chromeUtilsWindow.gViewSourceUtils;
   },
 
   /**
    * Initialize the Web Console instance.
    *
    * @return object
    *         A promise for the initialization.
    */
-  init: function WC_init()
-  {
+  init: function WC_init() {
     return this.ui.init().then(() => this);
   },
 
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
-  getPanelTitle: function WC_getPanelTitle()
-  {
+  getPanelTitle: function WC_getPanelTitle() {
     let url = this.ui ? this.ui.contentLocation : "";
     return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
   },
 
   /**
    * The JSTerm object that manages the console's input.
    * @see webconsole.js::JSTerm
    * @type object
    */
-  get jsterm()
-  {
+  get jsterm() {
     return this.ui ? this.ui.jsterm : null;
   },
 
   /**
    * The clear output button handler.
    * @private
    */
-  _onClearButton: function WC__onClearButton()
-  {
+  _onClearButton: function WC__onClearButton() {
     if (this.target.isLocalTab) {
       gDevToolsBrowser.getDeveloperToolbar(this.browserWindow)
         .resetErrorsCount(this.target.tab);
     }
   },
 
   /**
    * Alias for the WebConsoleFrame.setFilterState() method.
    * @see webconsole.js::WebConsoleFrame.setFilterState()
    */
-  setFilterState: function WC_setFilterState()
-  {
+  setFilterState: function WC_setFilterState() {
     this.ui && this.ui.setFilterState.apply(this.ui, arguments);
   },
 
   /**
    * Open a link in a new tab.
    *
    * @param string aLink
    *        The URL you want to open in a new tab.
    */
-  openLink: function WC_openLink(aLink)
-  {
+  openLink: function WC_openLink(aLink) {
     this.chromeUtilsWindow.openUILinkIn(aLink, "tab");
   },
 
   /**
    * Open a link in Firefox's view source.
    *
    * @param string aSourceURL
    *        The URL of the file.
@@ -500,18 +474,17 @@ WebConsole.prototype = {
    * @return object|null
    *         An object which holds:
    *         - frames: the active ThreadClient.cachedFrames array.
    *         - selected: depth/index of the selected stackframe in the debugger
    *         UI.
    *         If the debugger is not open or if it's not paused, then |null| is
    *         returned.
    */
-  getDebuggerFrames: function WC_getDebuggerFrames()
-  {
+  getDebuggerFrames: function WC_getDebuggerFrames() {
     let toolbox = gDevTools.getToolbox(this.target);
     if (!toolbox) {
       return null;
     }
     let panel = toolbox.getPanel("jsdebugger");
 
     if (!panel) {
       return null;
@@ -526,18 +499,17 @@ WebConsole.prototype = {
    * Console server for the $0 helper.
    *
    * @return object|null
    *         A Selection referring to the currently selected node in the
    *         Inspector.
    *         If the inspector was never opened, or no node was ever selected,
    *         then |null| is returned.
    */
-  getInspectorSelection: function WC_getInspectorSelection()
-  {
+  getInspectorSelection: function WC_getInspectorSelection() {
     let toolbox = gDevTools.getToolbox(this.target);
     if (!toolbox) {
       return null;
     }
     let panel = toolbox.getPanel("inspector");
     if (!panel || !panel.selection) {
       return null;
     }
@@ -546,18 +518,17 @@ WebConsole.prototype = {
 
   /**
    * Destroy the object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    *
    * @return object
    *         A promise object that is resolved once the Web Console is closed.
    */
-  destroy: function WC_destroy()
-  {
+  destroy: function WC_destroy() {
     if (this._destroyer) {
       return this._destroyer.promise;
     }
 
     HUDService.consoles.delete(this.hudId);
 
     this._destroyer = defer();
 
@@ -569,31 +540,29 @@ WebConsole.prototype = {
         panel.hidePopup();
       }
     }
 
     let onDestroy = Task.async(function* () {
       if (!this._browserConsole) {
         try {
           yield this.target.activeTab.focus();
-        }
-        catch (ex) {
+        } catch (ex) {
           // Tab focus can fail if the tab or target is closed.
         }
       }
 
       let id = WebConsoleUtils.supportsString(this.hudId);
       Services.obs.notifyObservers(id, "web-console-destroyed");
       this._destroyer.resolve(null);
     }.bind(this));
 
     if (this.ui) {
       this.ui.destroy().then(onDestroy);
-    }
-    else {
+    } else {
       onDestroy();
     }
 
     return this._destroyer.promise;
   },
 };
 
 /**
@@ -608,18 +577,17 @@ WebConsole.prototype = {
  * @constructor
  * @param object aTarget
  *        The target that the browser console will connect to.
  * @param nsIDOMWindow aIframeWindow
  *        The window where the browser console UI is already loaded.
  * @param nsIDOMWindow aChromeWindow
  *        The window of the browser console owner.
  */
-function BrowserConsole()
-{
+function BrowserConsole() {
   WebConsole.apply(this, arguments);
   this._telemetry = new Telemetry();
 }
 
 BrowserConsole.prototype = extend(WebConsole.prototype, {
   _browserConsole: true,
   _bc_init: null,
   _bc_destroyer: null,
@@ -627,18 +595,17 @@ BrowserConsole.prototype = extend(WebCon
   $init: WebConsole.prototype.init,
 
   /**
    * Initialize the Browser Console instance.
    *
    * @return object
    *         A promise for the initialization.
    */
-  init: function BC_init()
-  {
+  init: function BC_init() {
     if (this._bc_init) {
       return this._bc_init;
     }
 
     this.ui._filterPrefsPrefix = BROWSER_CONSOLE_FILTER_PREFS_PREFIX;
 
     let window = this.iframeWindow;
 
@@ -666,18 +633,17 @@ BrowserConsole.prototype = extend(WebCon
   $destroy: WebConsole.prototype.destroy,
 
   /**
    * Destroy the object.
    *
    * @return object
    *         A promise object that is resolved once the Browser Console is closed.
    */
-  destroy: function BC_destroy()
-  {
+  destroy: function BC_destroy() {
     if (this._bc_destroyer) {
       return this._bc_destroyer.promise;
     }
 
     this._telemetry.toolClosed("browserconsole");
 
     this._bc_destroyer = defer();
 
