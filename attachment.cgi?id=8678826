# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Date 1445866024 -3600
#      Mon Oct 26 14:27:04 2015 +0100
# Node ID d1e71d91017f774814f517b2c59b75d62908b1cf
# Parent  626ba108adf2612f7ba6e009602145db54199189
Bug 1202179 - html/head/body not dragdrop-able and drag starts after move only

diff --git a/devtools/client/markupview/markup-view.css b/devtools/client/markupview/markup-view.css
--- a/devtools/client/markupview/markup-view.css
+++ b/devtools/client/markupview/markup-view.css
@@ -72,36 +72,40 @@ body.dragging .tag-line {
 }
 
 /* Normally this element takes space in the layout even if it's position: relative
  * by adding height: 0 we let surrounding elements to fill the blank space */
 .child.dragging {
   position: relative;
   pointer-events: none;
   opacity: 0.7;
+  z-index: 1;
   height: 0;
 }
 
 /* Indicates a tag-line in the markup-view as being an active drop target by
  * drawing a horizontal line where the dragged element would be inserted if
  * dropped here */
-.tag-line.drop-target::before, .tag-line.drag-target::before {
+.tag-line.drop-target::before,
+.tag-line.drag-target::before {
   content: '';
   position: absolute;
-  left: 0;
   top: 0;
   width: 100%;
+  /* Offset these by 1000px to make sure they cover the full width of the view */
+  padding-left: 1000px;
+  left: -1000px;
 }
 
 .tag-line.drag-target::before {
-  border-top: 2px dashed var(--theme-contrast-background);
+  border-top: 2px solid var(--theme-content-color2);
 }
 
 .tag-line.drop-target::before {
-  border-top: 2px dashed var(--theme-content-color1);
+  border-top: 2px solid var(--theme-contrast-background);
 }
 
 /* In case the indicator is put on the closing .tag-line, the indentation level
  * will become misleading, so we push it forward to match the indentation level */
 ul.children + .tag-line::before {
   margin-left: 14px;
 }
 
diff --git a/devtools/client/markupview/markup-view.js b/devtools/client/markupview/markup-view.js
--- a/devtools/client/markupview/markup-view.js
+++ b/devtools/client/markupview/markup-view.js
@@ -1,13 +1,14 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
 
 const {Cc, Cu, Ci} = require("chrome");
 
 // Page size for pageup/pagedown
 const PAGE_SIZE = 10;
 const DEFAULT_MAX_CHILDREN = 100;
 const COLLAPSE_ATTRIBUTE_LENGTH = 120;
 const COLLAPSE_DATA_URL_REGEX = /^data.+base64/;
@@ -15,34 +16,33 @@ const COLLAPSE_DATA_URL_LENGTH = 60;
 const NEW_SELECTION_HIGHLIGHTER_TIMER = 1000;
 const DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE = 50;
 const DRAG_DROP_MIN_AUTOSCROLL_SPEED = 5;
 const DRAG_DROP_MAX_AUTOSCROLL_SPEED = 15;
 const AUTOCOMPLETE_POPUP_PANEL_ID = "markupview_autoCompletePopup";
 
 const {UndoStack} = require("devtools/client/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/client/shared/inplace-editor");
-const {gDevTools} = Cu.import("resource://devtools/client/framework/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/client/markupview/html-editor");
 const promise = require("promise");
 const {Tooltip} = require("devtools/client/shared/widgets/Tooltip");
 const EventEmitter = require("devtools/shared/event-emitter");
 const Heritage = require("sdk/core/heritage");
 const {setTimeout, clearTimeout, setInterval, clearInterval} = require("sdk/timers");
 const {parseAttribute} = require("devtools/client/shared/node-attribute-parser");
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 const {Task} = require("resource://gre/modules/Task.jsm");
 const {scrollIntoViewIfNeeded} = require("devtools/shared/layout/utils");
 
 Cu.import("resource://devtools/shared/gcli/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
- return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
+  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
 });
 loader.lazyGetter(this, "AutocompletePopup", () => {
   return require("devtools/client/shared/autocomplete-popup").AutocompletePopup;
 });
 
 /**
  * Vocabulary for the purposes of this file:
  *
@@ -70,17 +70,17 @@ function MarkupView(aInspector, aFrame, 
   this._frame = aFrame;
   this.win = this._frame.contentWindow;
   this.doc = this._frame.contentDocument;
   this._elt = this.doc.querySelector("#root");
   this.htmlEditor = new HTMLEditor(this.doc);
 
   try {
     this.maxChildren = Services.prefs.getIntPref("devtools.markup.pagesize");
-  } catch(ex) {
+  } catch (ex) {
     this.maxChildren = DEFAULT_MAX_CHILDREN;
   }
 
   // Creating the popup to be used to show CSS suggestions.
   let options = {
     autoSelect: true,
     theme: "auto",
     // panelId option prevents the markupView autocomplete popup from
@@ -89,142 +89,92 @@ function MarkupView(aInspector, aFrame, 
   };
   this.popup = new AutocompletePopup(this.doc.defaultView.parent.document, options);
 
   this.undo = new UndoStack();
   this.undo.installController(aControllerWindow);
 
   this._containers = new Map();
 
-  this._boundMutationObserver = this._mutationObserver.bind(this);
-  this.walker.on("mutations", this._boundMutationObserver);
-
-  this._boundOnDisplayChange = this._onDisplayChange.bind(this);
-  this.walker.on("display-change", this._boundOnDisplayChange);
-
+  // Binding functions that need to be called in scope.
+  this._mutationObserver = this._mutationObserver.bind(this);
+  this._onDisplayChange = this._onDisplayChange.bind(this);
   this._onMouseClick = this._onMouseClick.bind(this);
-
   this._onMouseUp = this._onMouseUp.bind(this);
+  this._onNewSelection = this._onNewSelection.bind(this);
+  this._onKeyDown = this._onKeyDown.bind(this);
+  this._onCopy = this._onCopy.bind(this);
+  this._onFocus = this._onFocus.bind(this);
+  this._onMouseMove = this._onMouseMove.bind(this);
+  this._onMouseLeave = this._onMouseLeave.bind(this);
+  this._onToolboxPickerHover = this._onToolboxPickerHover.bind(this);
+
+  // Listening to various events.
+  this._elt.addEventListener("click", this._onMouseClick, false);
+  this._elt.addEventListener("mousemove", this._onMouseMove, false);
+  this._elt.addEventListener("mouseleave", this._onMouseLeave, false);
   this.doc.body.addEventListener("mouseup", this._onMouseUp);
-
-  this._boundOnNewSelection = this._onNewSelection.bind(this);
-  this._inspector.selection.on("new-node-front", this._boundOnNewSelection);
+  this.win.addEventListener("keydown", this._onKeyDown, false);
+  this.win.addEventListener("copy", this._onCopy);
+  this._frame.addEventListener("focus", this._onFocus, false);
+  this.walker.on("mutations", this._mutationObserver);
+  this.walker.on("display-change", this._onDisplayChange);
+  this._inspector.selection.on("new-node-front", this._onNewSelection);
+  this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);
+
   this._onNewSelection();
-
-  this._boundKeyDown = this._onKeyDown.bind(this);
-  this._frame.contentWindow.addEventListener("keydown", this._boundKeyDown, false);
-
-  this._onCopy = this._onCopy.bind(this);
-  this._frame.contentWindow.addEventListener("copy", this._onCopy);
-
-  this._boundFocus = this._onFocus.bind(this);
-  this._frame.addEventListener("focus", this._boundFocus, false);
-
-  this._makeTooltipPersistent = this._makeTooltipPersistent.bind(this);
-
   this._initTooltips();
-  this._initHighlighter();
 
   EventEmitter.decorate(this);
 }
 
 exports.MarkupView = MarkupView;
 
 MarkupView.prototype = {
   /**
    * How long does a node flash when it mutates (in ms).
    */
   CONTAINER_FLASHING_DURATION: 500,
-  /**
-   * How long do you have to hold the mouse down before a drag
-   * starts (in ms).
-   */
-  GRAB_DELAY: 400,
 
   _selectedContainer: null,
 
   _initTooltips: function() {
     this.tooltip = new Tooltip(this._inspector.panelDoc);
     this._makeTooltipPersistent(false);
-
-    this._elt.addEventListener("click", this._onMouseClick, false);
-  },
-
-  _initHighlighter: function() {
-    // Show the box model on markup-view mousemove
-    this._onMouseMove = this._onMouseMove.bind(this);
-    this._elt.addEventListener("mousemove", this._onMouseMove, false);
-    this._onMouseLeave = this._onMouseLeave.bind(this);
-    this._elt.addEventListener("mouseleave", this._onMouseLeave, false);
-
-    // Show markup-containers as hovered on toolbox "picker-node-hovered" event
-    // which happens when the "pick" button is pressed
-    this._onToolboxPickerHover = (event, nodeFront) => {
-      this.showNode(nodeFront).then(() => {
-        this._showContainerAsHovered(nodeFront);
-      });
-    };
-    this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);
   },
 
   _makeTooltipPersistent: function(state) {
     if (state) {
       this.tooltip.stopTogglingOnHover();
     } else {
       this.tooltip.startTogglingOnHover(this._elt,
         this._isImagePreviewTarget.bind(this));
     }
   },
 
+  _onToolboxPickerHover: function(event, nodeFront) {
+    this.showNode(nodeFront).then(() => {
+      this._showContainerAsHovered(nodeFront);
+    }, e => console.error(e));
+  },
+
   isDragging: false,
 
   _onMouseMove: function(event) {
+    let target = event.target;
+
+    // Auto-scroll if we're dragging.
     if (this.isDragging) {
       event.preventDefault();
-      this._dragStartEl = event.target;
-
-      let docEl = this.doc.documentElement;
-
-      if (this._scrollInterval) {
-        clearInterval(this._scrollInterval);
-      }
-
-      // Auto-scroll when the mouse approaches top/bottom edge
-      let distanceFromBottom = docEl.clientHeight - event.pageY + this.win.scrollY,
-          distanceFromTop = event.pageY - this.win.scrollY;
-
-      if (distanceFromBottom <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
-        // Map our distance from 0-50 to 5-15 range so the speed is kept
-        // in a range not too fast, not too slow
-        let speed = map(distanceFromBottom, 0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE,
-                        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);
-        // Here, we use minus because the value of speed - 15 is always negative
-        // and it makes the speed relative to the distance between mouse and edge
-        // the closer to the edge, the faster
-        this._scrollInterval = setInterval(() => {
-          docEl.scrollTop -= speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
-        }, 0);
-      }
-
-      if (distanceFromTop <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
-        // refer to bottom edge's comments for more info
-        let speed = map(distanceFromTop, 0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE,
-                        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);
-
-        this._scrollInterval = setInterval(() => {
-          docEl.scrollTop += speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
-        }, 0);
-      }
-
+      this._autoScroll(event);
       return;
-    };
-
-    let target = event.target;
-
-    // Search target for a markupContainer reference, if not found, walk up
+    }
+
+    // Show the current container as hovered and highlight it.
+    // This requires finding the current MarkupContainer (walking up the DOM).
     while (!target.container) {
       if (target.tagName.toLowerCase() === "body") {
         return;
       }
       target = target.parentNode;
     }
 
     let container = target.container;
@@ -233,16 +183,57 @@ MarkupView.prototype = {
         this._showBoxModel(container.node);
       } else {
         this._hideBoxModel();
       }
     }
     this._showContainerAsHovered(container.node);
   },
 
+  /**
+   * Executed on each mouse-move while a node is being dragged in the view.
+   * Auto-scrolls the view to reveal nodes below the fold to drop the dragged
+   * node in.
+   */
+  _autoScroll: function(event) {
+    let docEl = this.doc.documentElement;
+
+    if (this._autoScrollInterval) {
+      clearInterval(this._autoScrollInterval);
+    }
+
+    // Auto-scroll when the mouse approaches top/bottom edge.
+    let fromBottom = docEl.clientHeight - event.pageY + this.win.scrollY;
+    let fromTop = event.pageY - this.win.scrollY;
+
+    if (fromBottom <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
+      // Map our distance from 0-50 to 5-15 range so the speed is kept in a
+      // range not too fast, not too slow.
+      let speed = map(
+        fromBottom,
+        0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE,
+        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);
+
+      this._autoScrollInterval = setInterval(() => {
+        docEl.scrollTop -= speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
+      }, 0);
+    }
+
+    if (fromTop <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
+      let speed = map(
+        fromTop,
+        0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE,
+        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);
+
+      this._autoScrollInterval = setInterval(() => {
+        docEl.scrollTop += speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
+      }, 0);
+    }
+  },
+
   _onMouseClick: function(event) {
     // From the target passed here, let's find the parent MarkupContainer
     // and ask it if the tooltip should be shown
     let parentNode = event.target;
     let container;
     while (parentNode !== this.doc.body) {
       if (parentNode.container) {
         container = parentNode.container;
@@ -256,18 +247,18 @@ MarkupView.prototype = {
       // and decision to show or not the tooltip
       container._buildEventTooltipContent(event.target, this.tooltip);
     }
   },
 
   _onMouseUp: function() {
     this.indicateDropTarget(null);
     this.indicateDragTarget(null);
-    if (this._scrollInterval) {
-      clearInterval(this._scrollInterval);
+    if (this._autoScrollInterval) {
+      clearInterval(this._autoScrollInterval);
     }
   },
 
   cancelDragging: function() {
     if (!this.isDragging) {
       return;
     }
 
@@ -275,23 +266,21 @@ MarkupView.prototype = {
       if (container.isDragging) {
         container.cancelDragging();
         break;
       }
     }
 
     this.indicateDropTarget(null);
     this.indicateDragTarget(null);
-    if (this._scrollInterval) {
-      clearInterval(this._scrollInterval);
+    if (this._autoScrollInterval) {
+      clearInterval(this._autoScrollInterval);
     }
   },
 
-
-
   _hoveredNode: null,
 
   /**
    * Show a NodeFront's container as being hovered
    * @param {NodeFront} nodeFront The node to show as hovered
    */
   _showContainerAsHovered: function(nodeFront) {
     if (this._hoveredNode === nodeFront) {
@@ -302,20 +291,22 @@ MarkupView.prototype = {
       this.getContainer(this._hoveredNode).hovered = false;
     }
 
     this.getContainer(nodeFront).hovered = true;
     this._hoveredNode = nodeFront;
   },
 
   _onMouseLeave: function() {
-    if (this._scrollInterval) {
-      clearInterval(this._scrollInterval);
+    if (this._autoScrollInterval) {
+      clearInterval(this._autoScrollInterval);
     }
-    if (this.isDragging) return;
+    if (this.isDragging) {
+      return;
+    }
 
     this._hideBoxModel(true);
     if (this._hoveredNode) {
       this.getContainer(this._hoveredNode).hovered = false;
     }
     this._hoveredNode = null;
   },
 
@@ -452,17 +443,16 @@ MarkupView.prototype = {
 
   /**
    * React to new-node-front selection events.
    * Highlights the node if needed, and make sure it is shown and selected in
    * the view.
    */
   _onNewSelection: function() {
     let selection = this._inspector.selection;
-    let reason = selection.reason;
 
     this.htmlEditor.hide();
     if (this._hoveredNode && this._hoveredNode !== selection.nodeFront) {
       this.getContainer(this._hoveredNode).hovered = false;
       this._hoveredNode = null;
     }
 
     if (!selection.isNode()) {
@@ -1232,17 +1222,17 @@ MarkupView.prototype = {
       let container = this.getContainer(aNode);
       if (!container) {
         return;
       }
       this.htmlEditor.show(container.tagLine, oldValue);
       this.htmlEditor.once("popuphidden", (e, aCommit, aValue) => {
         // Need to focus the <html> element instead of the frame / window
         // in order to give keyboard focus back to doc (from editor).
-        this._frame.contentDocument.documentElement.focus();
+        this.doc.documentElement.focus();
 
         if (aCommit) {
           this.updateNodeOuterHTML(aNode, aValue, oldValue);
         }
       });
     });
   },
 
@@ -1522,70 +1512,42 @@ MarkupView.prototype = {
     if (this._destroyer) {
       return this._destroyer;
     }
 
     this._destroyer = promise.resolve();
 
     this._clearBriefBoxModelTimer();
 
-    this._elt.removeEventListener("click", this._onMouseClick, false);
-
     this._hoveredNode = null;
-    this._inspector.toolbox.off("picker-node-hovered", this._onToolboxPickerHover);
 
     this.htmlEditor.destroy();
     this.htmlEditor = null;
 
     this.undo.destroy();
     this.undo = null;
 
     this.popup.destroy();
     this.popup = null;
 
-    this._frame.removeEventListener("focus", this._boundFocus, false);
-    this._boundFocus = null;
-
-    if (this._boundUpdatePreview) {
-      this._frame.contentWindow.removeEventListener("scroll",
-        this._boundUpdatePreview, true);
-      this._boundUpdatePreview = null;
-    }
-
-    if (this._boundResizePreview) {
-      this._frame.contentWindow.removeEventListener("resize",
-        this._boundResizePreview, true);
-      this._frame.contentWindow.removeEventListener("overflow",
-        this._boundResizePreview, true);
-      this._frame.contentWindow.removeEventListener("underflow",
-        this._boundResizePreview, true);
-      this._boundResizePreview = null;
-    }
-
-    this._frame.contentWindow.removeEventListener("keydown",
-      this._boundKeyDown, false);
-    this._boundKeyDown = null;
-
-    this._frame.contentWindow.removeEventListener("copy", this._onCopy);
-    this._onCopy = null;
-
-    this._inspector.selection.off("new-node-front", this._boundOnNewSelection);
-    this._boundOnNewSelection = null;
-
-    this.walker.off("mutations", this._boundMutationObserver);
-    this._boundMutationObserver = null;
-
-    this.walker.off("display-change", this._boundOnDisplayChange);
-    this._boundOnDisplayChange = null;
-
+    this._elt.removeEventListener("click", this._onMouseClick, false);
     this._elt.removeEventListener("mousemove", this._onMouseMove, false);
     this._elt.removeEventListener("mouseleave", this._onMouseLeave, false);
+    this.doc.body.removeEventListener("mouseup", this._onMouseUp);
+    this.win.removeEventListener("keydown", this._onKeyDown, false);
+    this.win.removeEventListener("copy", this._onCopy);
+    this._frame.removeEventListener("focus", this._onFocus, false);
+    this.walker.off("mutations", this._mutationObserver);
+    this.walker.off("display-change", this._onDisplayChange);
+    this._inspector.selection.off("new-node-front", this._onNewSelection);
+    this._inspector.toolbox.off("picker-node-hovered", this._onToolboxPickerHover);
+
     this._elt = null;
 
-    for (let [key, container] of this._containers) {
+    for (let [, container] of this._containers) {
       container.destroy();
     }
     this._containers = null;
 
     this.tooltip.destroy();
     this.tooltip = null;
 
     this.win = null;
@@ -1593,55 +1555,69 @@ MarkupView.prototype = {
 
     this._lastDropTarget = null;
     this._lastDragTarget = null;
 
     return this._destroyer;
   },
 
   /**
+   * Find the closest element with class tag-line. These are used to indicate
+   * drag and drop targets.
+   * @param {DOMNode} el
+   * @return {DOMNode}
+   */
+  findClosestDragDropTarget: function(el) {
+    return el.classList.contains("tag-line")
+           ? el
+           : el.querySelector(".tag-line") || el.closest(".tag-line");
+  },
+
+  /**
    * Takes an element as it's only argument and marks the element
    * as the drop target
    */
   indicateDropTarget: function(el) {
     if (this._lastDropTarget) {
       this._lastDropTarget.classList.remove("drop-target");
     }
 
-    if (!el) return;
-
-    let target = el.classList.contains("tag-line") ?
-                 el : el.querySelector(".tag-line") || el.closest(".tag-line");
-    if (!target) return;
-
-    target.classList.add("drop-target");
-    this._lastDropTarget = target;
+    if (!el) {
+      return;
+    }
+
+    let target = this.findClosestDragDropTarget(el);
+    if (target) {
+      target.classList.add("drop-target");
+      this._lastDropTarget = target;
+    }
   },
 
   /**
    * Takes an element to mark it as indicator of dragging target's initial place
    */
   indicateDragTarget: function(el) {
     if (this._lastDragTarget) {
       this._lastDragTarget.classList.remove("drag-target");
     }
 
-    if (!el) return;
-
-    let target = el.classList.contains("tag-line") ?
-                 el : el.querySelector(".tag-line") || el.closest(".tag-line");
-
-    if (!target) return;
-
-    target.classList.add("drag-target");
-    this._lastDragTarget = target;
+    if (!el) {
+      return;
+    }
+
+    let target = this.findClosestDragDropTarget(el);
+    if (target) {
+      target.classList.add("drag-target");
+      this._lastDragTarget = target;
+    }
   },
 
   /**
-   * Used to get the nodes required to modify the markup after dragging the element (parent/nextSibling)
+   * Used to get the nodes required to modify the markup after dragging the
+   * element (parent/nextSibling).
    */
   get dropTargetNodes() {
     let target = this._lastDropTarget;
 
     if (!target) {
       return null;
     }
 
@@ -1681,17 +1657,16 @@ MarkupView.prototype = {
  * This should not be instantiated directly, instead use one of:
  *    MarkupReadOnlyContainer
  *    MarkupTextContainer
  *    MarkupElementContainer
  */
 function MarkupContainer() { }
 
 MarkupContainer.prototype = {
-
   /*
    * Initialize the MarkupContainer.  Should be called while one
    * of the other contain classes is instantiated.
    *
    * @param MarkupView markupView
    *        The markup view that owns this container.
    * @param NodeFront node
    *        The node to display.
@@ -1738,19 +1713,19 @@ MarkupContainer.prototype = {
   isPreviewable: function() {
     if (this.node.tagName && !this.node.isPseudoElement) {
       let tagName = this.node.tagName.toLowerCase();
       let srcAttr = this.editor.getAttributeElement("src");
       let isImage = tagName === "img" && srcAttr;
       let isCanvas = tagName === "canvas";
 
       return isImage || isCanvas;
-    } else {
-      return false;
     }
+
+    return false;
   },
 
   /**
    * Show the element has displayed or not
    */
   set isDisplayed(isDisplayed) {
     this.elt.classList.remove("not-displayed");
     if (!isDisplayed) {
@@ -1863,17 +1838,16 @@ MarkupContainer.prototype = {
       this.expander.removeAttribute("open");
     }
   },
 
   parentContainer: function() {
     return this.elt.parentNode ? this.elt.parentNode.container : null;
   },
 
-  _isMouseDown: false,
   _isDragging: false,
   _dragStartY: 0,
 
   set isDragging(isDragging) {
     this._isDragging = isDragging;
     this.markup.isDragging = isDragging;
 
     if (isDragging) {
@@ -1887,122 +1861,122 @@ MarkupContainer.prototype = {
 
   get isDragging() {
     return this._isDragging;
   },
 
   /**
    * Check if element is draggable
    */
-  isDraggable: function(target) {
-    return this._isMouseDown &&
-           this.markup._dragStartEl === target &&
-           !this.node.isPseudoElement &&
+  isDraggable: function() {
+    let tagName = this.node.tagName.toLowerCase();
+
+    return !this.node.isPseudoElement &&
            !this.node.isAnonymous &&
+           !this.node.isDocumentElement &&
+           tagName !== "body" &&
+           tagName !== "head" &&
            this.win.getSelection().isCollapsed &&
            this.node.parentNode().tagName !== null;
   },
 
   _onMouseDown: function(event) {
-    let target = event.target;
-
-    // The "show more nodes" button (already has its onclick).
+    let {target, button, metaKey, ctrlKey} = event;
+    let isLeftClick = button === 0;
+    let isMiddleClick = button === 1;
+    let isMetaClick = isLeftClick && (metaKey || ctrlKey);
+
+    // The "show more nodes" button already has its onclick, so early return.
     if (target.nodeName === "button") {
       return;
     }
 
     // target is the MarkupContainer itself.
-    this._isMouseDown = true;
     this.hovered = false;
     this.markup.navigate(this);
     event.stopPropagation();
 
     // Preventing the default behavior will avoid the body to gain focus on
     // mouseup (through bubbling) when clicking on a non focusable node in the
     // line. So, if the click happened outside of a focusable element, do
     // prevent the default behavior, so that the tagname or textcontent gains
     // focus.
     if (!target.closest(".editor [tabindex]")) {
       event.preventDefault();
     }
 
-    let isMiddleClick = event.button === 1;
-    let isMetaClick = event.button === 0 && (event.metaKey || event.ctrlKey);
-
+    // Follow attribute links if middle or meta click.
     if (isMiddleClick || isMetaClick) {
       let link = target.dataset.link;
       let type = target.dataset.type;
       this.markup._inspector.followAttributeLink(type, link);
       return;
     }
 
-    // Start dragging the container after a delay.
-    this.markup._dragStartEl = target;
-    setTimeout(() => {
-      // Make sure the mouse is still down and on target.
-      if (!this.isDraggable(target)) {
-        return;
-      }
-      this.isDragging = true;
-
+    // Start node drag & drop (if the mouse moved, see _onMouseMove).
+    if (isLeftClick && this.isDraggable()) {
+      this._isPreDragging = true;
       this._dragStartY = event.pageY;
-      this.markup.indicateDropTarget(this.elt);
-
-      // If this is the last child, use the closing <div.tag-line> of parent as indicator
-      this.markup.indicateDragTarget(this.elt.nextElementSibling ||
-                                     this.markup.getContainer(this.node.parentNode()).closeTagLine);
-    }, this.markup.GRAB_DELAY);
+    }
   },
 
   /**
    * On mouse up, stop dragging.
    */
   _onMouseUp: Task.async(function*() {
-    this._isMouseDown = false;
-
-    if (!this.isDragging) {
-      return;
+    this._isPreDragging = false;
+
+    if (this.isDragging) {
+      this.cancelDragging();
+
+      let dropTargetNodes = this.markup.dropTargetNodes;
+
+      if (!dropTargetNodes) {
+        return;
+      }
+
+      yield this.markup.walker.insertBefore(this.node, dropTargetNodes.parent,
+                                            dropTargetNodes.nextSibling);
+      this.markup.emit("drop-completed");
     }
-
-    this.cancelDragging();
-
-    let dropTargetNodes = this.markup.dropTargetNodes;
-
-    if (!dropTargetNodes) {
-      return;
-    }
-
-    yield this.markup.walker.insertBefore(this.node, dropTargetNodes.parent,
-                                          dropTargetNodes.nextSibling);
-    this.markup.emit("drop-completed");
   }),
 
   /**
-   * On mouse move, move the dragged element if any and indicate the drop target.
+   * On mouse move, move the dragged element and indicate the drop target.
    */
   _onMouseMove: function(event) {
-    if (!this.isDragging) {
-      return;
+    // If this is the first move after mousedown, indicate the start position.
+    if (this._isPreDragging) {
+      this._isPreDragging = false;
+      this.isDragging = true;
+
+      // If this is the last child, use the closing <div.tag-line> of parent as
+      // indicator.
+      let position = this.elt.nextElementSibling ||
+                     this.markup.getContainer(this.node.parentNode())
+                                .closeTagLine;
+      this.markup.indicateDragTarget(position);
     }
 
-    let diff = event.pageY - this._dragStartY;
-    this.elt.style.top = diff + "px";
-
-    let el = this.markup.doc.elementFromPoint(event.pageX - this.win.scrollX,
-                                              event.pageY - this.win.scrollY);
-
-    this.markup.indicateDropTarget(el);
+    if (this.isDragging) {
+      let diff = event.pageY - this._dragStartY;
+      this.elt.style.top = diff + "px";
+
+      let el = this.markup.doc.elementFromPoint(event.pageX - this.win.scrollX,
+                                                event.pageY - this.win.scrollY);
+      this.markup.indicateDropTarget(el);
+    }
   },
 
   cancelDragging: function() {
     if (!this.isDragging) {
       return;
     }
 
-    this._isMouseDown = false;
+    this._isPreDragging = false;
     this.isDragging = false;
     this.elt.style.removeProperty("top");
   },
 
   /**
    * Temporarily flash the container to attract attention.
    * Used for markup mutations.
    */
diff --git a/devtools/client/markupview/test/browser.ini b/devtools/client/markupview/test/browser.ini
--- a/devtools/client/markupview/test/browser.ini
+++ b/devtools/client/markupview/test/browser.ini
@@ -44,19 +44,17 @@ skip-if = e10s # scratchpad.xul is not l
 [browser_markupview_anonymous_03.js]
 [browser_markupview_anonymous_04.js]
 [browser_markupview_copy_image_data.js]
 [browser_markupview_css_completion_style_attribute.js]
 [browser_markupview_dragdrop_autoscroll.js]
 [browser_markupview_dragdrop_dragRootNode.js]
 [browser_markupview_dragdrop_escapeKeyPress.js]
 [browser_markupview_dragdrop_invalidNodes.js]
-[browser_markupview_dragdrop_isDragging.js]
 [browser_markupview_dragdrop_reorder.js]
-[browser_markupview_dragdrop_textSelection.js]
 [browser_markupview_events.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_form.js]
 # [browser_markupview_events-overflow.js]
 # skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 # disabled - See bug 1177550
 [browser_markupview_events_jquery_1.0.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_autoscroll.js b/devtools/client/markupview/test/browser_markupview_dragdrop_autoscroll.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_autoscroll.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_autoscroll.js
@@ -1,65 +1,67 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test: Dragging nodes near top/bottom edges of inspector
-// should auto-scroll
+// Test that dragging a node near the top or bottom edge of the markup-view
+// auto-scrolls the view.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop_autoscroll.html";
-const GRAB_DELAY = 400;
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let markup = inspector.markup;
+  let viewHeight = markup.doc.documentElement.clientHeight;
 
-  let markup = inspector.markup;
+  info("Pretend the markup-view is dragging");
+  markup.isDragging = true;
 
-  let container = yield getContainerForSelector("#first", inspector);
-  let rect = container.elt.getBoundingClientRect();
+  info("Simulate a mousemove on the view, at the bottom, and expect scrolling");
+  let onScrolled = waitForViewScroll(markup);
 
-  info("Simulating mouseDown on #first");
-  container._onMouseDown({
-    target: container.tagLine,
-    pageX: 10,
-    pageY: rect.top,
-    stopPropagation: function() {},
-    preventDefault: function() {}
+  markup._onMouseMove({
+    preventDefault: () => {},
+    target: markup.doc.body,
+    pageY: viewHeight
   });
 
-  yield wait(GRAB_DELAY + 1);
+  let bottomScrollPos = yield onScrolled;
+  ok(bottomScrollPos > 0, "The view was scrolled down");
 
-  let clientHeight = markup.doc.documentElement.clientHeight;
-  info("Simulating mouseMove on #first with pageY: " + clientHeight);
+  info("Simulate a mousemove at the top and expect more scrolling");
+  onScrolled = waitForViewScroll(markup);
 
-  let ev = {
-    target: container.tagLine,
-    pageX: 10,
-    pageY: clientHeight,
-    preventDefault: function() {}
-  };
+  markup._onMouseMove({
+    preventDefault: () => {},
+    target: markup.doc.body,
+    pageY: 0
+  });
 
-  info("Listening on scroll event");
-  let scroll = onScroll(markup.win);
+  let topScrollPos = yield onScrolled;
+  ok(topScrollPos < bottomScrollPos, "The view was scrolled up");
+  is(topScrollPos, 0, "The view was scrolled up to the top");
 
-  markup._onMouseMove(ev);
-
-  yield scroll;
-
-  let dropCompleted = once(markup, "drop-completed");
-
-  container._onMouseUp(ev);
-  markup._onMouseUp(ev);
-
-  yield dropCompleted;
-
-  ok("Scroll event fired");
+  info("Simulate a mouseup to stop dragging");
+  markup._onMouseUp();
 });
 
-function onScroll(win) {
-  return new Promise((resolve, reject) => {
-    win.onscroll = function(e) {
-      resolve(e);
-    }
+function waitForViewScroll(markup) {
+  let el = markup.doc.documentElement;
+  let startPos = el.scrollTop;
+
+  return new Promise(resolve => {
+    let isDone = () => {
+      if (el.scrollTop === startPos) {
+        resolve(el.scrollTop);
+      } else {
+        startPos = el.scrollTop;
+        // Continue checking every 50ms.
+        setTimeout(isDone, 50);
+      }
+    };
+
+    // Start checking if the view scrolled after 500ms.
+    setTimeout(isDone, 500);
   });
-};
+}
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_dragRootNode.js b/devtools/client/markupview/test/browser_markupview_dragdrop_dragRootNode.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_dragRootNode.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_dragRootNode.js
@@ -1,30 +1,22 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test if html root node is draggable
+// Test that the root node isn't draggable (as well as head and body).
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 400;
+const TEST_DATA = ["html", "head", "body"];
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
-  let el = yield getContainerForSelector("html", inspector);
-  let rect = el.tagLine.getBoundingClientRect();
+  for (let selector of TEST_DATA) {
+    info("Try to drag/drop node " + selector);
+    yield simulateNodeDrag(inspector, selector);
 
-  info("Simulating mouseDown on html root node");
-  el._onMouseDown({
-    target: el.tagLine,
-    pageX: rect.x,
-    pageY: rect.y,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
-
-  info("Waiting for a little bit more than the markup-view grab delay");
-  yield wait(GRAB_DELAY + 1);
-  is(el.isDragging, false, "isDragging is false");
+    let container = yield getContainerForSelector(selector, inspector);
+    ok(!container.isDragging, "The container hasn't been marked as dragging");
+  }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_escapeKeyPress.js b/devtools/client/markupview/test/browser_markupview_dragdrop_escapeKeyPress.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_escapeKeyPress.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_escapeKeyPress.js
@@ -1,34 +1,33 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test whether ESCAPE keypress cancels dragging of an element
+// Test whether ESCAPE keypress cancels dragging of an element.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 400;
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {markup} = inspector;
 
-  let el = yield getContainerForSelector("#test", inspector);
-  let rect = el.tagLine.getBoundingClientRect();
+  info("Get a test container");
+  let container = yield getContainerForSelector("#test", inspector);
 
-  info("Simulating mouseDown on #test");
-  el._onMouseDown({
-    target: el.tagLine,
-    pageX: rect.x,
-    pageY: rect.y,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
+  info("Simulate a drag/drop on this container");
+  yield simulateNodeDrag(inspector, "#test");
 
-  info("Waiting for a little bit more than the markup-view grab delay");
-  yield wait(GRAB_DELAY + 1);
-  ok(el.isDragging, "isDragging true after mouseDown");
+  ok(container.isDragging && markup.isDragging,
+     "The container is being dragged");
+  ok(markup.doc.body.classList.contains("dragging"),
+     "The dragging css class was added");
 
-  info("Simulating ESCAPE keypress");
+  info("Simulate ESCAPE keypress");
   EventUtils.sendKey("escape", inspector.panelWin);
-  is(el.isDragging, false, "isDragging false after ESCAPE keypress");
+
+  ok(!container.isDragging && !markup.isDragging,
+     "The dragging has stopped");
+  ok(!markup.doc.body.classList.contains("dragging"),
+     "The dragging css class was removed");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_invalidNodes.js b/devtools/client/markupview/test/browser_markupview_dragdrop_invalidNodes.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_invalidNodes.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_invalidNodes.js
@@ -1,58 +1,45 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test: pseudo-elements and anonymous nodes should not be draggable
+// Check that pseudo-elements and anonymous nodes are not draggable.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 400;
 
 add_task(function*() {
   Services.prefs.setBoolPref("devtools.inspector.showAllAnonymousContent", true);
 
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
-  info("Expanding #test");
+  info("Expanding nodes below #test");
   let parentFront = yield getNodeFront("#test", inspector);
   yield inspector.markup.expandNode(parentFront);
   yield waitForMultipleChildrenUpdates(inspector);
 
+  info("Getting the ::before pseudo element");
   let parentContainer = yield getContainerForNodeFront(parentFront, inspector);
   let beforePseudo = parentContainer.elt.children[1].firstChild.container;
-
   parentContainer.elt.scrollIntoView(true);
 
-  info("Simulating mouseDown on #test::before");
-  beforePseudo._onMouseDown({
-    target: beforePseudo.tagLine,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
+  info("Simulate dragging the ::before pseudo element");
+  yield simulateNodeDrag(inspector, beforePseudo);
 
-  info("Waiting " + (GRAB_DELAY + 1) + "ms")
-  yield wait(GRAB_DELAY + 1);
-  is(beforePseudo.isDragging, false, "[pseudo-element] isDragging is false after GRAB_DELAY has passed");
+  ok(!beforePseudo.isDragging, "::before pseudo element isn't dragging");
 
+  info("Expanding nodes below #anonymousParent");
   let inputFront = yield getNodeFront("#anonymousParent", inspector);
-
   yield inspector.markup.expandNode(inputFront);
   yield waitForMultipleChildrenUpdates(inspector);
 
+  info("Getting the anonymous node");
   let inputContainer = yield getContainerForNodeFront(inputFront, inspector);
   let anonymousDiv = inputContainer.elt.children[1].firstChild.container;
-
   inputContainer.elt.scrollIntoView(true);
 
-  info("Simulating mouseDown on input#anonymousParent div");
-  anonymousDiv._onMouseDown({
-    target: anonymousDiv.tagLine,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
+  info("Simulate dragging the anonymous node");
+  yield simulateNodeDrag(inspector, anonymousDiv);
 
-  info("Waiting " + (GRAB_DELAY + 1) + "ms")
-  yield wait(GRAB_DELAY + 1);
-  is(anonymousDiv.isDragging, false, "[anonymous element] isDragging is false after GRAB_DELAY has passed");
+  ok(!anonymousDiv.isDragging, "anonymous node isn't dragging");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_isDragging.js b/devtools/client/markupview/test/browser_markupview_dragdrop_isDragging.js
deleted file mode 100644
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_isDragging.js
+++ /dev/null
@@ -1,65 +0,0 @@
-/* vim: set ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
- http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-// Test drag mode's delay, it shouldn't enable dragging before
-// GRAB_DELAY = 400 has passed
-
-const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 400;
-
-add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
-
-  let el = yield getContainerForSelector("#test", inspector);
-  let rect = el.tagLine.getBoundingClientRect();
-
-  info("Simulating mouseDown on #test");
-  el._onMouseDown({
-    target: el.tagLine,
-    pageX: rect.x,
-    pageY: rect.y,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
-
-  ok(!el.isDragging, "isDragging should not be set to true immediately");
-
-  info("Waiting for 10ms");
-  yield wait(10);
-  ok(!el.isDragging, "isDragging should not be set to true after a brief wait");
-
-  info("Waiting " + (GRAB_DELAY + 1) + "ms");
-  yield wait(GRAB_DELAY + 1);
-  ok(el.isDragging, "isDragging true after GRAB_DELAY has passed");
-
-  let dropCompleted = once(inspector.markup, "drop-completed");
-
-  info("Simulating mouseUp on #test");
-  el._onMouseUp({
-    target: el.tagLine,
-    pageX: rect.x,
-    pageY: rect.y
-  });
-
-  yield dropCompleted;
-
-  ok(!el.isDragging, "isDragging false after mouseUp");
-
-  info("Simulating middle click on #test");
-  el._onMouseDown({
-    target: el.tagLine,
-    button: 1,
-    pageX: rect.x,
-    pageY: rect.y,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
-  ok(!el.isDragging, "isDragging should not be set to true immediately");
-
-  info("Waiting " + (GRAB_DELAY + 1) + "ms");
-  yield wait(GRAB_DELAY + 1);
-  ok(!el.isDragging, "isDragging never starts after middle click after mouseUp");
-});
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js b/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
@@ -1,138 +1,107 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test different kinds of drag and drop node re-ordering
+// Test different kinds of drag and drop node re-ordering.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 5;
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  inspector.markup.GRAB_DELAY = GRAB_DELAY;
+  let ids;
 
-  info("Expanding #test");
+  info("Expand #test node");
   let parentFront = yield getNodeFront("#test", inspector);
-  let parent = yield getNode("#test");
-  let parentContainer = yield getContainerForNodeFront(parentFront, inspector);
-
   yield inspector.markup.expandNode(parentFront);
   yield waitForMultipleChildrenUpdates(inspector);
 
+  info("Scroll #test into view");
+  let parentContainer = yield getContainerForNodeFront(parentFront, inspector);
   parentContainer.elt.scrollIntoView(true);
 
-  info("Testing putting an element back in it's original place");
+  info("Test putting an element back at its original place");
   yield dragElementToOriginalLocation("#firstChild", inspector);
-  is(parent.children[0].id, "firstChild", "#firstChild is still the first child of #test");
-  is(parent.children[1].id, "middleChild", "#middleChild is still the second child of #test");
+  ids = yield getChildrenIDsOf(parentFront, inspector);
+  is(ids[0], "firstChild",
+     "#firstChild is still the first child of #test");
+  is(ids[1], "middleChild",
+     "#middleChild is still the second child of #test");
 
   info("Testing switching elements inside their parent");
   yield moveElementDown("#firstChild", "#middleChild", inspector);
-
-  is(parent.children[0].id, "middleChild", "#firstChild is now the second child of #test");
-  is(parent.children[1].id, "firstChild", "#middleChild is now the first child of #test");
+  ids = yield getChildrenIDsOf(parentFront, inspector);
+  is(ids[0], "middleChild",
+     "#firstChild is now the second child of #test");
+  is(ids[1], "firstChild",
+     "#middleChild is now the first child of #test");
 
   info("Testing switching elements with a last child");
   yield moveElementDown("#firstChild", "#lastChild", inspector);
-
-  is(parent.children[1].id, "lastChild", "#lastChild is now the second child of #test");
-  is(parent.children[2].id, "firstChild", "#firstChild is now the last child of #test");
+  ids = yield getChildrenIDsOf(parentFront, inspector);
+  is(ids[1], "lastChild",
+     "#lastChild is now the second child of #test");
+  is(ids[2], "firstChild",
+     "#firstChild is now the last child of #test");
 
   info("Testing appending element to a parent");
   yield moveElementDown("#before", "#test", inspector);
-
-  is(parent.children.length, 4, "New element appended to #test");
-  is(parent.children[0].id, "before", "New element is appended at the right place (currently first child)");
+  ids = yield getChildrenIDsOf(parentFront, inspector);
+  is(ids.length, 4,
+     "New element appended to #test");
+  is(ids[0], "before",
+     "New element is appended at the right place (currently first child)");
 
   info("Testing moving element to after it's parent");
   yield moveElementDown("#firstChild", "#test", inspector);
-
-  is(parent.children.length, 3, "#firstChild is no longer #test's child");
-  is(parent.nextElementSibling.id, "firstChild", "#firstChild is now #test's nextElementSibling");
+  ids = yield getChildrenIDsOf(parentFront, inspector);
+  is(ids.length, 3,
+     "#firstChild is no longer #test's child");
+  let siblingFront = yield inspector.walker.nextSibling(parentFront);
+  is(siblingFront.id, "firstChild",
+     "#firstChild is now #test's nextElementSibling");
 });
 
-function* dragContainer(selector, targetOffset, inspector) {
-  info("Dragging the markup-container for node " + selector);
-
-  let container = yield getContainerForSelector(selector, inspector);
-
-  let updated = inspector.once("inspector-updated");
-
-  let rect = {
-    x: container.tagLine.offsetLeft,
-    y: container.tagLine.offsetTop
-  };
-
-  info("Simulating mouseDown on " + selector);
-  container._onMouseDown({
-    target: container.tagLine,
-    pageX: rect.x,
-    pageY: rect.y,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
-
-  let targetX = rect.x + targetOffset.x,
-      targetY = rect.y + targetOffset.y;
-
-  setTimeout(() => {
-    info("Simulating mouseMove on " + selector +
-         " with pageX: " + targetX + " pageY: " + targetY);
-    container._onMouseMove({
-      target: container.tagLine,
-      pageX: targetX,
-      pageY: targetY
-    });
-
-    info("Simulating mouseUp on " + selector +
-         " with pageX: " + targetX + " pageY: " + targetY);
-    container._onMouseUp({
-      target: container.tagLine,
-      pageX: targetX,
-      pageY: targetY
-    });
-
-    container.markup._onMouseUp();
-  }, GRAB_DELAY+1);
-
-  return updated;
-};
-
 function* dragElementToOriginalLocation(selector, inspector) {
-  let el = yield getContainerForSelector(selector, inspector);
-  let height = el.tagLine.getBoundingClientRect().height;
-
   info("Picking up and putting back down " + selector);
 
   function onMutation() {
     ok(false, "Mutation received from dragging a node back to its location");
   }
   inspector.on("markupmutation", onMutation);
-  yield dragContainer(selector, {x: 0, y: 0}, inspector);
+  yield simulateNodeDragAndDrop(inspector, selector, 0, 0);
 
   // Wait a bit to make sure the event never fires.
   // This doesn't need to catch *all* cases, since the mutation
   // will cause failure later in the test when it checks element ordering.
-  yield new Promise(resolve => {
-    setTimeout(resolve, 500);
-  });
+  yield wait(500);
   inspector.off("markupmutation", onMutation);
 }
 
 function* moveElementDown(selector, next, inspector) {
+  info("Switching " + selector + " with " + next);
+
+  let container = yield getContainerForSelector(next, inspector);
+  let height = container.tagLine.getBoundingClientRect().height;
+
   let onMutated = inspector.once("markupmutation");
   let uiUpdate = inspector.once("inspector-updated");
 
-  let el = yield getContainerForSelector(next, inspector);
-  let height = el.tagLine.getBoundingClientRect().height;
-
-  info("Switching " + selector + ' with ' + next);
-
-  yield dragContainer(selector, {x: 0, y: Math.round(height) + 2}, inspector);
+  yield simulateNodeDragAndDrop(inspector, selector, 0, Math.round(height) + 2);
 
   let mutations = yield onMutated;
-  is(mutations.length, 2, "2 mutations");
   yield uiUpdate;
-};
\ No newline at end of file
+
+  is(mutations.length, 2, "2 mutations were received");
+}
+
+function* getChildrenIDsOf(parentFront, {walker}) {
+  let {nodes} = yield walker.children(parentFront);
+  // Filter out non-element nodes since children also returns pseudo-elements.
+  return nodes.filter(node => {
+    return !node.isPseudoElement;
+  }).map(node => {
+    return node.id;
+  });
+}
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_textSelection.js b/devtools/client/markupview/test/browser_markupview_dragdrop_textSelection.js
deleted file mode 100644
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_textSelection.js
+++ /dev/null
@@ -1,48 +0,0 @@
-/* vim: set ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
- http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-// Test: Nodes should not be draggable if there is a text selected
-// (trying to move selected text around shouldn't trigger node drag and drop)
-
-const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
-const GRAB_DELAY = 400;
-
-add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  let markup = inspector.markup;
-
-  info("Expanding span#before");
-  let spanFront = yield getNodeFront("#before", inspector);
-  let spanContainer = yield getContainerForNodeFront(spanFront, inspector);
-  let span = yield getNode("#before");
-
-  yield inspector.markup.expandNode(spanFront);
-  yield waitForMultipleChildrenUpdates(inspector);
-
-  spanContainer.elt.scrollIntoView(true);
-
-  info("Selecting #before's text content");
-
-  let textContent = spanContainer.elt.children[1].firstChild.container;
-
-  let selectRange = markup.doc.createRange();
-  selectRange.selectNode(textContent.editor.elt.querySelector('[tabindex]'));
-  markup.doc.getSelection().addRange(selectRange);
-
-  info("Simulating mouseDown on #before");
-
-  spanContainer._onMouseDown({
-    pageX: 0,
-    pageY: 0,
-    target: spanContainer.tagLine,
-    stopPropagation: function() {},
-    preventDefault: function() {}
-  });
-
-  yield wait(GRAB_DELAY + 1);
-
-  is(spanContainer.isDragging, false, "isDragging should be false if there is a text selected");
-});
\ No newline at end of file
diff --git a/devtools/client/markupview/test/head.js b/devtools/client/markupview/test/head.js
--- a/devtools/client/markupview/test/head.js
+++ b/devtools/client/markupview/test/head.js
@@ -771,8 +771,78 @@ function registerTabActor(client, option
  * @returns A promise that is resolved when the unregistration
  * has finished.
  */
 function unregisterActor(registrar, front) {
   return front.detach().then(() => {
     return registrar.unregister();
   });
 }
+
+/**
+ * Simulate dragging a MarkupContainer by calling its mousedown and mousemove
+ * handlers.
+ * @param {InspectorPanel} inspector The current inspector-panel instance.
+ * @param {String|MarkupContainer} selector The selector to identify the node or
+ * the MarkupContainer for this node.
+ * @param {Number} xOffset Optional x offset to drag by.
+ * @param {Number} yOffset Optional y offset to drag by.
+ */
+function* simulateNodeDrag(inspector, selector, xOffset = 10, yOffset = 10) {
+  let container = typeof selector === "string"
+                  ? yield getContainerForSelector(selector, inspector)
+                  : selector;
+  let rect = container.tagLine.getBoundingClientRect();
+  let scrollX = inspector.markup.doc.documentElement.scrollLeft;
+  let scrollY = inspector.markup.doc.documentElement.scrollTop;
+
+  info("Simulate mouseDown on element " + selector);
+  container._onMouseDown({
+    target: container.tagLine,
+    button: 0,
+    pageX: scrollX + rect.x,
+    pageY: scrollY + rect.y,
+    stopPropagation: () => {},
+    preventDefault: () => {}
+  });
+
+  // _onMouseDown selects the node, so make sure to wait for the
+  // inspector-updated event if the current selection was different.
+  if (inspector.selection.nodeFront !== container.node) {
+    yield inspector.once("inspector-updated");
+  }
+
+  info("Simulate mouseMove on element " + selector);
+  container._onMouseMove({
+    pageX: scrollX + rect.x + xOffset,
+    pageY: scrollY + rect.y + yOffset
+  });
+}
+
+/**
+ * Simulate dropping a MarkupContainer by calling its mouseup handler. This is
+ * meant to be called after simulateNodeDrag has been called.
+ * @param {InspectorPanel} inspector The current inspector-panel instance.
+ * @param {String|MarkupContainer} selector The selector to identify the node or
+ * the MarkupContainer for this node.
+ */
+function* simulateNodeDrop(inspector, selector) {
+  info("Simulate mouseUp on element " + selector);
+  let container = typeof selector === "string"
+                  ? yield getContainerForSelector(selector, inspector)
+                  : selector;
+  container._onMouseUp();
+  inspector.markup._onMouseUp();
+}
+
+/**
+ * Simulate drag'n'dropping a MarkupContainer by calling its mousedown,
+ * mousemove and mouseup handlers.
+ * @param {InspectorPanel} inspector The current inspector-panel instance.
+ * @param {String|MarkupContainer} selector The selector to identify the node or
+ * the MarkupContainer for this node.
+ * @param {Number} xOffset Optional x offset to drag by.
+ * @param {Number} yOffset Optional y offset to drag by.
+ */
+function* simulateNodeDragAndDrop(inspector, selector, xOffset, yOffset) {
+  yield simulateNodeDrag(inspector, selector, xOffset, yOffset);
+  yield simulateNodeDrop(inspector, selector);
+}
