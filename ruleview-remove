# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  3453ddf59f6d68eaff73301df9f027675e25a8c2
Bug 1150780 - Simplify element removal in rule-view.js;r=pbrosset

diff --git a/devtools/client/styleinspector/rule-view.js b/devtools/client/styleinspector/rule-view.js
--- a/devtools/client/styleinspector/rule-view.js
+++ b/devtools/client/styleinspector/rule-view.js
@@ -1681,17 +1681,17 @@ CssRuleView.prototype = {
       this.menuitemCopyColor.removeEventListener("command", this._onCopyColor);
       this.menuitemCopyColor = null;
 
       this.menuitemSources.removeEventListener("command", this._onToggleOrigSources);
       this.menuitemSources = null;
 
       // Destroy the context menu.
       this._contextmenu.removeEventListener("popupshowing", this._contextMenuUpdate);
-      this._contextmenu.parentNode.removeChild(this._contextmenu);
+      this._contextmenu.remove();
       this._contextmenu = null;
     }
 
     // We manage the popupNode ourselves so we also need to destroy it.
     this.doc.popupNode = null;
 
     this.tooltips.destroy();
     this.highlighters.destroy();
@@ -1701,19 +1701,17 @@ CssRuleView.prototype = {
     this.element.removeEventListener("contextmenu", this._onContextMenu);
     this.searchField.removeEventListener("input", this._onFilterStyles);
     this.searchField.removeEventListener("contextmenu",
       this._onFilterTextboxContextMenu);
     this.searchClearButton.removeEventListener("click", this._onClearSearch);
     this.searchField = null;
     this.searchClearButton = null;
 
-    if (this.element.parentNode) {
-      this.element.parentNode.removeChild(this.element);
-    }
+    this.element.remove();
 
     if (this._elementStyle) {
       this._elementStyle.destroy();
     }
 
     this.popup.destroy();
   },
 
@@ -1805,19 +1803,17 @@ CssRuleView.prototype = {
       textContent: CssLogic.l10n("rule.empty")
     });
   },
 
   /**
    * Clear the rules.
    */
   _clearRules: function() {
-    while (this.element.hasChildNodes()) {
-      this.element.removeChild(this.element.lastChild);
-    }
+    this.element.innerHTML = "";
   },
 
   /**
    * Clear the rule view.
    */
   clear: function() {
     this.lastSelectorIcon = null;
 
@@ -2281,19 +2277,17 @@ RuleEditor.prototype = {
     }
   },
 
   /**
    * Update the rule editor with the contents of the rule.
    */
   populate: function() {
     // Clear out existing viewers.
-    while (this.selectorText.hasChildNodes()) {
-      this.selectorText.removeChild(this.selectorText.lastChild);
-    }
+    this.selectorText.innerHTML = "";
 
     // If selector text comes from a css rule, highlight selectors that
     // actually match.  For custom selector text (such as for the 'element'
     // style, just show the text directly.
     if (this.rule.domRule.type === ELEMENT_STYLE) {
       this.selectorText.textContent = this.rule.selectorText;
     } else if (this.rule.domRule.type === Ci.nsIDOMCSSRule.KEYFRAME_RULE) {
       this.selectorText.textContent = this.rule.domRule.keyText;
@@ -2458,17 +2452,17 @@ RuleEditor.prototype = {
    * This is where the properties (type TextProperty) are actually being
    * added, since we want to wait until after the inplace editor `destroy`
    * event has been fired to keep consistent UI state.
    */
   _newPropertyDestroy: function() {
     // We're done, make the close brace focusable again.
     this.closeBrace.setAttribute("tabindex", "0");
 
-    this.propertyList.removeChild(this.newPropItem);
+    this.newPropItem.remove();
     delete this.newPropItem;
     delete this.newPropSpan;
 
     // If properties were added, we want to focus the proper element.
     // If the last new property has no value, focus the value on it.
     // Otherwise, start a new property and focus that field.
     if (this.multipleAddedProperties && this.multipleAddedProperties.length) {
       this.addProperties(this.multipleAddedProperties);
@@ -2859,19 +2853,17 @@ TextPropertyEditor.prototype = {
     this._previewValue(this.prop.value);
   },
 
   /**
    * Populate the list of computed styles.
    */
   _updateComputed: function () {
     // Clear out existing viewers.
-    while (this.computed.hasChildNodes()) {
-      this.computed.removeChild(this.computed.lastChild);
-    }
+    this.computed.innerHTML = "";
 
     let showExpander = false;
     for each (let computed in this.prop.computed) {
       // Don't bother to duplicate information already
       // shown in the text property.
       if (computed.name === this.prop.name) {
         continue;
       }
@@ -2982,17 +2974,17 @@ TextPropertyEditor.prototype = {
    */
   remove: function() {
     if (this._colorSwatchSpans && this._colorSwatchSpans.length) {
       for (let span of this._colorSwatchSpans) {
         this.ruleEditor.ruleView.tooltips.colorPicker.removeSwatch(span);
       }
     }
 
-    this.element.parentNode.removeChild(this.element);
+    this.element.remove();
     this.ruleEditor.rule.editClosestTextProperty(this.prop);
     this.nameSpan.textProperty = null;
     this.valueSpan.textProperty = null;
     this.prop.remove();
   },
 
   /**
    * Called when a value editor closes.  If the user pressed escape,
