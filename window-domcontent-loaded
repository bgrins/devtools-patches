# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  97208b5251d7e86cb4051711609b6236a944981e
Bug 1496425 - WIP - Provide a mechanism for Custom Elements to delay connectedCallback until after DOMContentLoaded

There are two reasons for this:
1) It's faster than running the connectedCallback in the middle of document parse, at least for
   <radiogroups> in about:preferences
2) It provides a construction sequence more similar to XBL, so the translation from XBL <constructor>
   to CE connectedCallback is more likely to be sound. This is because when there is markup like:
       <parent-ce><child-ce></child-ce></parent-ce>
   the parent-ce node is empty during the first connectedCallback. If we wait for DOMContentLoaded
   then the parent-ce has the child-ce node below it.

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -8,21 +8,64 @@
 
 // This is loaded into chrome windows with the subscript loader. Wrap in
 // a block to prevent accidentally leaking globals onto `window`.
 {
 
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 
+// The listener of DOMContentLoaded must be set on window, rather than
+// document, because the window can go away before the event is fired.
+// In that case, we don't want to initialize anything, otherwise we
+// may be leaking things because they will never be destroyed after.
+let gDOMReady = false;
+let gPendingConnectionCallbacks = new Set();
+window.addEventListener("DOMContentLoaded", () => {
+  // console.log(`DOM ready with ${gPendingConnectionCallbacks.size} elements in ${document.documentURI}`);
+  gDOMReady = true;
+  for (let el of gPendingConnectionCallbacks) {
+    if (el.isConnected && el.connectedCallback) {
+      el.connectedCallback();
+    }
+  }
+  gPendingConnectionCallbacks.clear();
+}, { once: true });
+
+
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 class MozXULElement extends XULElement {
   /**
+   * Sometimes an element may not want to run connectedCallback logic during
+   * parse. This could be because we don't want to initialize the element before
+   * the element's contents have been fully parsed, or for performance reasons.
+   * If you'd like to opt-in to this, then add this to the beginning of your
+   * `connectedCallback` and `disconnectedCallback`:
+   *
+   *    if (this.waitForDOMReady()) { return }
+   *
+   * And this at the beginning of your `attributeChangedCallback`
+   *
+   *    if (!this.isConnectedAndReady) { return; }
+   */
+  waitForDOMReady() {
+    if (gDOMReady) {
+      return false;
+    }
+    gPendingConnectionCallbacks.add(this);
+    return true;
+  }
+
+  get isConnectedAndReady() {
+    return gDOMReady && this.isConnected;
+  }
+
+  /**
    * Allows eager deterministic construction of XUL elements with XBL attached, by
    * parsing an element tree and returning a DOM fragment to be inserted in the
    * document before any of the inner elements is referenced by JavaScript.
    *
    * This process is required instead of calling the createElement method directly
    * because bindings get attached when:
    *
    * 1. the node gets a layout frame constructed, or
diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -107,17 +107,27 @@ class MozRadiogroup extends MozBaseContr
         return;
       }
       this.removeAttribute("focused");
       this.focusedItem = null;
     });
   }
 
   connectedCallback() {
+    if (this.waitForDOMReady()) {
+      return;
+    }
+
+    // While <radio> is XBL, the <constructor> for each radio will generally
+    // fire as a result of collecting radio children. To avoid churn where we
+    // keep appending each radio one-by-one, keep track of whether they should
+    // be appended with a bit.
+    this.connecting = true;
     this.init();
+    this.connecting = false;
     if (!this.value) {
       this.selectedIndex = 0;
     }
   }
 
   init() {
     this._radioChildren = null;
 
@@ -145,17 +155,21 @@ class MozRadiogroup extends MozBaseContr
    * construction (see Bug 1496137), or just due to normal DOM appending after
    * the <radiogroup> is created. When this happens, reinitialize the UI if
    * necessary to make sure the state is consistent.
    *
    * @param {DOMNode} child
    *                  The <radio> element that got added
    */
   radioChildConstructed(child) {
-    if (!this._radioChildren || !this._radioChildren.includes(child)) {
+    if (this.connecting || !this._radioChildren) {
+      return;
+    }
+
+    if (!this._radioChildren.includes(child)) {
       this.init();
     }
   }
 
   set value(val) {
     this.setAttribute("value", val);
     var children = this._getRadioChildren();
     for (var i = 0; i < children.length; i++) {
