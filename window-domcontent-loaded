# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  97208b5251d7e86cb4051711609b6236a944981e

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -8,20 +8,65 @@
 
 // This is loaded into chrome windows with the subscript loader. Wrap in
 // a block to prevent accidentally leaking globals onto `window`.
 {
 
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
 
+// The listener of DOMContentLoaded must be set on window, rather than
+// document, because the window can go away before the event is fired.
+// In that case, we don't want to initialize anything, otherwise we
+// may be leaking things because they will never be destroyed after.
+let gDOMReady = false;
+let gPendingConnectionCallbacks = new Set();
+window.addEventListener("DOMContentLoaded", () => {
+  // console.log(`DOM ready with ${gPendingConnectionCallbacks.size} elements in ${document.documentURI}`);
+  gDOMReady = true;
+  for (let el of gPendingConnectionCallbacks) {
+    if (el.isConnected && el.connectedCallback) {
+      el.connectedCallback();
+    }
+  }
+  gPendingConnectionCallbacks.clear();
+}, { once: true });
+
+
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 class MozXULElement extends XULElement {
+
+
+  /**
+   * Sometimes an element may not want to run connectedCallback logic during
+   * parse. This could be because we don't want to initialize the element before
+   * the element's contents have been fully parsed, or for performance reasons.
+   * If you'd like to opt-in to this, then add this to the beginning of your
+   * `connectedCallback` and `disconnectedCallback`:
+   *
+   *    if (this.waitForDOMReady()) { return }
+   *
+   * And this at the beginning of your `attributeChangedCallback`
+   *
+   *    if (!this.isConnectedAndReady) { return; }
+   */
+  waitForDOMReady() {
+    if (gDOMReady) {
+      return false;
+    }
+    gPendingConnectionCallbacks.add(this);
+    return true;
+  }
+
+  get isConnectedAndReady() {
+    return gDOMReady && this.isConnected;
+  }
+
   /**
    * Allows eager deterministic construction of XUL elements with XBL attached, by
    * parsing an element tree and returning a DOM fragment to be inserted in the
    * document before any of the inner elements is referenced by JavaScript.
    *
    * This process is required instead of calling the createElement method directly
    * because bindings get attached when:
    *
diff --git a/toolkit/content/widgets/progressmeter.js b/toolkit/content/widgets/progressmeter.js
--- a/toolkit/content/widgets/progressmeter.js
+++ b/toolkit/content/widgets/progressmeter.js
@@ -64,28 +64,40 @@ class MozProgressmeter extends MozXULEle
     return val;
   }
 
   isUndetermined() {
     return this.getAttribute("mode") == "undetermined";
   }
 
   connectedCallback() {
+    if (this.waitForDOMReady()) {
+     return;
+    }
+
     this._initUI();
   }
 
   disconnectedCallback() {
+    if (this.waitForDOMReady()) {
+      return;
+    }
+
     this.runAnimation = false;
   }
 
   static get observedAttributes() {
     return [ "mode" ];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady) {
+      return;
+    }
+
     if (name === "mode" && oldValue != newValue) {
       this._initUI();
     }
   }
 
   _initUI() {
     let isUndetermined = this.isUndetermined();
     let content = isUndetermined ?
diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -107,23 +107,30 @@ class MozRadiogroup extends MozBaseContr
         return;
       }
       this.removeAttribute("focused");
       this.focusedItem = null;
     });
   }
 
   connectedCallback() {
+    if (this.waitForDOMReady()) {
+      console.log("EARLY RETURN");
+      return;
+    }
+
     this.init();
     if (!this.value) {
       this.selectedIndex = 0;
     }
   }
 
   init() {
+    console.log("Radio init");
+    console.trace();
     this._radioChildren = null;
 
     if (this.getAttribute("disabled") == "true")
       this.disabled = true;
 
     var children = this._getRadioChildren();
     var length = children.length;
     for (var i = 0; i < length; i++) {
