# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  159bdd9ca2fc480aa586135f697fee1c0581a58b

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -88,27 +88,29 @@ function instrumentIndividualClass(c) {
     return function() {
       if (!data[name]) {
         data[name] = {time: 0, calls: 0};
       }
       data[name].calls++;
       let n = performance.now();
       let r = fn.apply(this, arguments);
       data[name].time += performance.now() - n;
-      if (name == "attributeChangedCallback") {
-        console.log("Calling", c.name, arguments, name, data[name].calls, r);
-
+      if (name == "inheritAttributes") {
+        console.log("Calling inheritAttributes", this, c.name);
+      }
+      if (name == "attributeChangedCallback") {// ||name =="inheritAttributes"||name=="inheritedAttributes") {
+        console.log("Calling", c.name, this, arguments, name, data[name].calls, r);
       }
       return r;
     };
   }
   function wrapPropertyDescriptor(obj, name) {
     let prop = Object.getOwnPropertyDescriptor(obj, name);
-    if (name == "attributeChangedCallback") {
-      console.log("Warpping", prop, name);
+    if (name == "inheritAttributes") {
+      console.log("Warpping", c.name, prop, prop.writable, prop.value,name);
 
     }
     if (prop.get) {
       prop.get = wrapFunction(`<get> ${name}`, prop.get);
     }
     if (prop.set) {
       prop.set = wrapFunction(`<set> ${name}`, prop.set);
     }
@@ -120,17 +122,17 @@ function instrumentIndividualClass(c) {
 
   // Handle static properties
   for (let name of Object.getOwnPropertyNames((c))) {
     wrapPropertyDescriptor(c, name);
   }
 
   // Handle instance properties
   for (let name of Object.getOwnPropertyNames(c.prototype)) {
-    wrapPropertyDescriptor(c.prototype, name);
+    // wrapPropertyDescriptor(c.prototype, name);
   }
 
   Object.defineProperty(c, "stats", {
     enumerable: false,
     configurable: false,
     get() {
       if (!Object.keys(data).length) {
         return null;
@@ -219,17 +221,17 @@ MozElements.MozElementMixin = Base => {
   /*
    * Provide default lifecycle callback for attribute changes that will inherit attributes
    * based on the static `inheritedAttributes` Object. This can be overridden by callers.
    */
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue === newValue || !this.inheritedAttributesCache) {
       return;
     }
-
+console.log("Calling attributeChangedCallback and about to call inheritAttributes")
     this.inheritAttributes();
   }
 
   /*
   * After setting content, calling this will cache the elements from selectors in the
   * static `inheritedAttributes` Object. It'll also do an initial call to `this.inheritAttributes()`,
   * so in the simple case, this is the only function you need to call.
   *
@@ -266,16 +268,19 @@ MozElements.MozElementMixin = Base => {
 
   /*
    * Loop through the static `inheritedAttributes` Map and inherit attributes to child elements.
    *
    * This usually won't need to be called directly - `this.initializeAttributeInheritance()` and
    * `this.attributeChangedCallback` will call it for you when appropriate.
    */
   inheritAttributes() {
+    // if (this.tagName == "checkbox") {
+      console.log("Calling inheritAttributes on", this);
+    // }
     let {inheritedAttributes} = this.constructor;
     if (!inheritedAttributes) {
       return;
     }
 
     if (!this.inheritedAttributesCache) {
      console.error(`You must call this.initializeAttributeInheritance() for ${this.tagName}`);
      return;
