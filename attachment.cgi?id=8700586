# HG changeset patch
# User Matteo Ferretti <mferretti@mozilla.com>

Bug 1139187 - Allow moving and resizing elements in content; r=pbrosset

diff --git a/devtools/client/inspector/test/browser.ini b/devtools/client/inspector/test/browser.ini
index 792676a..2dc1ad5 100644
--- a/devtools/client/inspector/test/browser.ini
+++ b/devtools/client/inspector/test/browser.ini
@@ -50,16 +50,17 @@ skip-if = e10s # GCLI isn't e10s compatible. See bug 1128988.
 [browser_inspector_highlighter-comments.js]
 [browser_inspector_highlighter-csstransform_01.js]
 [browser_inspector_highlighter-csstransform_02.js]
 [browser_inspector_highlighter-geometry_01.js]
 [browser_inspector_highlighter-geometry_02.js]
 [browser_inspector_highlighter-geometry_03.js]
 [browser_inspector_highlighter-geometry_04.js]
 [browser_inspector_highlighter-geometry_05.js]
+[browser_inspector_highlighter-geometry_06.js]
 [browser_inspector_highlighter-hover_01.js]
 [browser_inspector_highlighter-hover_02.js]
 [browser_inspector_highlighter-hover_03.js]
 [browser_inspector_highlighter-iframes.js]
 [browser_inspector_highlighter-inline.js]
 [browser_inspector_highlighter-keybinding_01.js]
 [browser_inspector_highlighter-keybinding_02.js]
 [browser_inspector_highlighter-keybinding_03.js]
diff --git a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_01.js b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_01.js
index 651fedc..99ba523 100644
--- a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_01.js
+++ b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_01.js
@@ -1,95 +1,112 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+ /* Globals defined in: devtools/client/inspector/test/head.js */
+ /* global openInspectorForURL, getHighlighterHelperFor */
+
 "use strict";
 
 // Test the creation of the geometry highlighter elements.
 
 const TEST_URL = "data:text/html;charset=utf-8," +
                  "<span id='inline'></span>" +
                  "<div id='positioned' style='background:yellow;position:absolute;left:5rem;top:30px;right:300px;bottom:10em;'></div>" +
                  "<div id='sized' style='background:red;width:5em;height:50%;'></div>";
+
+const HIGHLIGHTER_TYPE = "GeometryEditorHighlighter";
+
 const ID = "geometry-editor-";
 const SIDES = ["left", "right", "top", "bottom"];
 const SIZES = ["width", "height"];
 
 add_task(function*() {
-  let {inspector, testActor} = yield openInspectorForURL(TEST_URL);
-  let front = inspector.inspector;
+  let helper = yield openInspectorForURL(TEST_URL)
+                       .then(getHighlighterHelperFor(HIGHLIGHTER_TYPE));
 
-  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  let { finalize } = helper;
 
-  yield hasArrowsAndLabels(highlighter, inspector, testActor);
-  yield isHiddenForNonPositionedNonSizedElement(highlighter, inspector, testActor);
-  yield sideArrowsAreDisplayedForPositionedNode(highlighter, inspector, testActor);
-  yield sizeLabelIsDisplayedForSizedNode(highlighter, inspector, testActor);
+  helper.prefix = ID;
 
-  yield highlighter.finalize();
+  yield hasArrowsAndLabelsAndHandlers(helper);
+  yield isHiddenForNonPositionedNonSizedElement(helper);
+  yield sideArrowsAreDisplayedForPositionedNode(helper);
+  yield sizeLabelIsDisplayedForSizedNode(helper);
+
+  finalize();
 });
 
-function* hasArrowsAndLabels(highlighterFront, inspector, testActor) {
+function* hasArrowsAndLabelsAndHandlers({getElementAttribute}) {
   info("Checking that the highlighter has the expected arrows and labels");
 
   for (let name of [...SIDES]) {
-    let value = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, "class", highlighterFront);
+    let value = yield getElementAttribute("arrow-" + name, "class");
     is(value, ID + "arrow " + name, "The " + name + " arrow exists");
 
-    value = yield testActor.getHighlighterNodeAttribute(ID + "label-text-" + name, "class", highlighterFront);
+    value = yield getElementAttribute("label-text-" + name, "class");
     is(value, ID + "label-text", "The " + name + " label exists");
+
+    value = yield getElementAttribute("handler-" + name, "class");
+    is(value, ID + "handler-" + name, "The " + name + " handler exists");
   }
 
-  let value = yield testActor.getHighlighterNodeAttribute(ID + "label-text-size", "class", highlighterFront);
+  let value = yield getElementAttribute("label-text-size", "class");
   is(value, ID + "label-text", "The size label exists");
 }
 
-function* isHiddenForNonPositionedNonSizedElement(highlighterFront, inspector, testActor) {
+function* isHiddenForNonPositionedNonSizedElement({show, hide, isElementHidden}) {
   info("Asking to show the highlighter on an inline, non positioned element");
 
-  let node = yield getNodeFront("#inline", inspector);
-  yield highlighterFront.show(node);
+  yield show("#inline");
 
   for (let name of [...SIDES]) {
-    let hidden = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, "hidden", highlighterFront);
-    is(hidden, "true", "The " + name + " arrow is hidden");
+    let hidden = yield isElementHidden("arrow-" + name);
+    ok(hidden, "The " + name + " arrow is hidden");
+
+    hidden = yield isElementHidden("handler-" + name);
+    ok(hidden, "The " + name + " handler is hidden");
   }
 
-  let hidden = yield testActor.getHighlighterNodeAttribute(ID + "label-size", "hidden", highlighterFront);
-  is(hidden, "true", "The size label is hidden");
+  let hidden = yield isElementHidden("label-size");
+  ok(hidden, "The size label is hidden");
 }
 
-function* sideArrowsAreDisplayedForPositionedNode(highlighterFront, inspector, testActor) {
+function* sideArrowsAreDisplayedForPositionedNode({show, hide, isElementHidden}) {
   info("Asking to show the highlighter on the positioned node");
 
-  let node = yield getNodeFront("#positioned", inspector);
-  yield highlighterFront.show(node);
+  yield show("#positioned");
 
   for (let name of SIDES) {
-    let hidden = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, "hidden", highlighterFront);
+    let hidden = yield isElementHidden("arrow-" + name);
     ok(!hidden, "The " + name + " arrow is visible for the positioned node");
+
+    hidden = yield isElementHidden("handler-" + name);
+    ok(!hidden, "The " + name + " handler is visible for the positioned node");
   }
 
-  let hidden = yield testActor.getHighlighterNodeAttribute(ID + "label-size", "hidden", highlighterFront);
-  is(hidden, "true", "The size label is hidden");
+  let hidden = yield isElementHidden("label-size");
+  ok(hidden, "The size label is hidden");
 
   info("Hiding the highlighter");
-  yield highlighterFront.hide();
+  yield hide();
 }
 
-function* sizeLabelIsDisplayedForSizedNode(highlighterFront, inspector, testActor) {
+function* sizeLabelIsDisplayedForSizedNode({show, hide, isElementHidden}) {
   info("Asking to show the highlighter on the sized node");
 
-  let node = yield getNodeFront("#sized", inspector);
-  yield highlighterFront.show(node);
+  yield show("#sized");
 
-  let hidden = yield testActor.getHighlighterNodeAttribute(ID + "label-size", "hidden", highlighterFront);
+  let hidden = yield isElementHidden("label-size");
   ok(!hidden, "The size label is visible");
 
   for (let name of SIDES) {
-    let hidden = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, "hidden", highlighterFront);
-    is(hidden, "true", "The " + name + " arrow is hidden for the sized node");
+    hidden = yield isElementHidden("arrow-" + name);
+    ok(hidden, "The " + name + " arrow is hidden for the sized node");
+
+    hidden = yield isElementHidden("handler-" + name);
+    ok(hidden, "The " + name + " handler is hidden for the sized node");
   }
 
   info("Hiding the highlighter");
-  yield highlighterFront.hide();
+  yield hide();
 }
diff --git a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_02.js b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_02.js
index efd637d..26a8e59 100644
--- a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_02.js
+++ b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_02.js
@@ -1,24 +1,28 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+ /* Globals defined in: devtools/client/inspector/test/head.js */
+ /* global openInspectorForURL, getHighlighterHelperFor */
+
 "use strict";
 
 // Test that the geometry highlighter labels are correct.
 
 const TEST_URL = "data:text/html;charset=utf-8," +
                  "<div id='positioned' style='background:yellow;position:absolute;left:5rem;top:30px;right:300px;bottom:10em;'></div>" +
                  "<div id='positioned2' style='background:blue;position:absolute;right:10%;top:5vmin;'>test element</div>" +
                  "<div id='relative' style='background:green;position:relative;top:10px;left:20px;bottom:30px;right:40px;width:100px;height:100px;'></div>" +
                  "<div id='relative2' style='background:grey;position:relative;top:0;bottom:-50px;height:3em;'>relative</div>" +
                  "<div id='sized' style='background:red;width:5em;height:50%;'></div>" +
                  "<div id='sized2' style='background:orange;width:40px;position:absolute;right:0;bottom:0'>wow</div>";
 const ID = "geometry-editor-";
+const HIGHLIGHTER_TYPE = "GeometryEditorHighlighter";
 
 const POSITIONED_ELEMENT_TESTS = [{
   selector: "#positioned",
   expectedLabels: [
     {side: "left", visible: true, label: "5rem"},
     {side: "top", visible: true, label: "30px"},
     {side: "right", visible: true, label: "300px"},
     {side: "bottom", visible: true, label: "10em"}
@@ -74,69 +78,75 @@ const SIZED_ELEMENT_TESTS = [{
   expected: "\u2195 3em"
 }, {
   selector: "#sized2",
   visible: true,
   expected: "\u2194 40px"
 }];
 
 add_task(function*() {
-  let {inspector, testActor} = yield openInspectorForURL(TEST_URL);
-  let front = inspector.inspector;
+  let helper = yield openInspectorForURL(TEST_URL)
+                       .then(getHighlighterHelperFor(HIGHLIGHTER_TYPE));
 
-  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  helper.prefix = ID;
 
-  yield positionLabelsAreCorrect(highlighter, inspector, testActor);
-  yield sizeLabelIsCorrect(highlighter, inspector, testActor);
+  let { finalize } = helper;
 
-  yield highlighter.finalize();
+  yield positionLabelsAreCorrect(helper);
+  yield sizeLabelIsCorrect(helper);
+
+  yield finalize();
 });
 
-function* positionLabelsAreCorrect(highlighterFront, inspector, testActor) {
+function* positionLabelsAreCorrect(
+  {show, hide, isElementHidden, getElementTextContent}
+) {
   info("Highlight nodes and check position labels");
 
   for (let {selector, expectedLabels} of POSITIONED_ELEMENT_TESTS) {
     info("Testing node " + selector);
-    let node = yield getNodeFront(selector, inspector);
-    yield highlighterFront.show(node);
+
+    yield show(selector);
 
     for (let {side, visible, label} of expectedLabels) {
-      let id = ID + "label-" + side;
+      let id = "label-" + side;
 
-      let hidden = yield testActor.getHighlighterNodeAttribute(id, "hidden", highlighterFront);
+      let hidden = yield isElementHidden(id);
       if (visible) {
         ok(!hidden, "The " + side + " label is visible");
 
-        let value = yield testActor.getHighlighterNodeTextContent(id, highlighterFront);
+        let value = yield getElementTextContent(id);
         is(value, label, "The " + side + " label textcontent is correct");
       } else {
-        is(hidden, "true", "The " + side + " label is hidden");
+        ok(hidden, "The " + side + " label is hidden");
       }
     }
 
     info("Hiding the highlighter");
-    yield highlighterFront.hide();
+    yield hide();
   }
 }
 
-function* sizeLabelIsCorrect(highlighterFront, inspector, testActor) {
+function* sizeLabelIsCorrect(
+  {show, hide, isElementHidden, getElementTextContent}
+) {
   info("Highlight nodes and check size labels");
 
-  let id = ID + "label-size";
+  let id = "label-size";
   for (let {selector, visible, expected} of SIZED_ELEMENT_TESTS) {
     info("Testing node " + selector);
-    let node = yield getNodeFront(selector, inspector);
-    yield highlighterFront.show(node);
 
-    let hidden = yield testActor.getHighlighterNodeAttribute(id, "hidden", highlighterFront);
+    yield show(selector);
+
+    let hidden = yield isElementHidden(id);
     if (!visible) {
-      is(hidden, "true", "The size label is hidden");
+      ok(hidden, "The size label is hidden");
     } else {
       ok(!hidden, "The size label is visible");
 
-      let label = yield testActor.getHighlighterNodeTextContent(id, highlighterFront);
+      let label = yield getElementTextContent(id);
       is(label, expected, "The size label textcontent is correct");
     }
 
     info("Hiding the highlighter");
-    yield highlighterFront.hide();
+    yield hide();
   }
 }
diff --git a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_03.js b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_03.js
index 7754a6c..fb04e8c 100644
--- a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_03.js
+++ b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_03.js
@@ -1,60 +1,69 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+/* Globals defined in: devtools/client/inspector/test/head.js */
+/* global openInspectorForURL, getHighlighterHelperFor, TEST_URL_ROOT */
+
 "use strict";
 
 // Test that the right arrows/labels are shown even when the css properties are
 // in several different css rules.
 
 const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
 const ID = "geometry-editor-";
+const HIGHLIGHTER_TYPE = "GeometryEditorHighlighter";
 const PROPS = ["left", "right", "top", "bottom"];
 
 add_task(function*() {
-  let {inspector, testActor} = yield openInspectorForURL(TEST_URL);
-  let front = inspector.inspector;
+  let helper = yield openInspectorForURL(TEST_URL)
+                       .then(getHighlighterHelperFor(HIGHLIGHTER_TYPE));
 
-  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  helper.prefix = ID;
 
-  yield checkArrowsLabels("#node1", ["size"],
-                          highlighter, inspector, testActor);
+  let { finalize } = helper;
 
-  yield checkArrowsLabels("#node2", ["top", "left", "bottom", "right"],
-                          highlighter, inspector, testActor);
+  yield checkArrowsLabelsAndHandlers("#node1", ["size"], helper);
 
-  yield checkArrowsLabels("#node3", ["top", "left", "size"],
-                          highlighter, inspector, testActor);
+  yield checkArrowsLabelsAndHandlers(
+    "#node2", ["top", "left", "bottom", "right"],
+     helper);
 
-  yield highlighter.finalize();
+  yield checkArrowsLabelsAndHandlers("#node3", ["top", "left", "size"], helper);
+
+  yield finalize();
 });
 
-function* checkArrowsLabels(selector, expectedProperties, highlighterFront, inspector, testActor) {
+function* checkArrowsLabelsAndHandlers(selector, expectedProperties,
+  {show, hide, isElementHidden,}
+) {
   info("Getting node " + selector + " from the page");
-  let node = yield getNodeFront(selector, inspector);
 
-  info("Highlighting the node");
-  yield highlighterFront.show(node);
+  yield show(selector);
 
   for (let name of expectedProperties) {
     let hidden;
     if (name === "size") {
-      hidden = yield testActor.getHighlighterNodeAttribute(ID + "label-size", "hidden", highlighterFront);
+      hidden = yield isElementHidden("label-size");
     } else {
-      hidden = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, "hidden", highlighterFront);
+      hidden = (yield isElementHidden("arrow-" + name)) &&
+               (yield isElementHidden("handler-" + name));
     }
-    ok(!hidden, "The " + name + " arrow/label is visible for node " + selector);
+    ok(!hidden,
+      "The " + name + " label/arrow & handler is visible for node " + selector);
   }
 
   // Testing that the other arrows are hidden
   for (let name of PROPS) {
     if (expectedProperties.indexOf(name) !== -1) {
       continue;
     }
-    let hidden = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, "hidden", highlighterFront);
-    is(hidden, "true", "The " + name + " arrow is hidden for node " + selector);
+    let hidden = (yield isElementHidden("arrow-" + name)) &&
+                 (yield isElementHidden("handler-" + name));
+    ok(hidden,
+      "The " + name + " arrow & handler is hidden for node " + selector);
   }
 
   info("Hiding the highlighter");
-  yield highlighterFront.hide();
+  yield hide();
 }
diff --git a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_04.js b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_04.js
index de64491..5eeb7f8 100644
--- a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_04.js
+++ b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_04.js
@@ -1,56 +1,86 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+ /* Globals defined in: devtools/client/inspector/test/head.js */
+ /* global openInspectorForURL, getHighlighterHelperFor, TEST_URL_ROOT */
+
 "use strict";
 
-// Test that the arrows are positioned correctly and have the right size.
+// Test that the arrows and handlers are positioned correctly and have the right
+// size.
 
 const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
 const ID = "geometry-editor-";
+const HIGHLIGHTER_TYPE = "GeometryEditorHighlighter";
+
+const handlerMap = {
+  "top": {"cx": "x2", "cy": "y2"},
+  "bottom": {"cx": "x2", "cy": "y2"},
+  "left": {"cx": "x2", "cy": "y2"},
+  "right": {"cx": "x2", "cy": "y2"}
+};
 
 add_task(function*() {
-  let {inspector, testActor} = yield openInspectorForURL(TEST_URL);
-  let front = inspector.inspector;
+  let helper = yield openInspectorForURL(TEST_URL)
+                       .then(getHighlighterHelperFor(HIGHLIGHTER_TYPE));
 
-  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  helper.prefix = ID;
 
-  yield checkArrows(highlighter, inspector, testActor, ".absolute-all-4", {
-   "top": {x1: 506, y1: 51, x2: 506, y2: 61},
-   "bottom": {x1: 506, y1: 451, x2: 506, y2: 251},
-   "left": {x1: 401, y1: 156, x2: 411, y2: 156},
-   "right": {x1: 901, y1: 156, x2: 601, y2: 156}
+  let { hide, finalize } = helper;
+
+  yield checkArrowsAndHandlers(helper, ".absolute-all-4", {
+    "top": {x1: 506, y1: 51, x2: 506, y2: 61},
+    "bottom": {x1: 506, y1: 451, x2: 506, y2: 251},
+    "left": {x1: 401, y1: 156, x2: 411, y2: 156},
+    "right": {x1: 901, y1: 156, x2: 601, y2: 156}
   });
 
-  yield checkArrows(highlighter, inspector, testActor, ".relative", {
-   "top": {x1: 901, y1: 51, x2: 901, y2: 91},
-   "left": {x1: 401, y1: 97, x2: 651, y2: 97}
+  yield checkArrowsAndHandlers(helper, ".relative", {
+    "top": {x1: 901, y1: 51, x2: 901, y2: 91},
+    "left": {x1: 401, y1: 97, x2: 651, y2: 97}
   });
 
-  yield checkArrows(highlighter, inspector, testActor, ".fixed", {
-   "top": {x1: 25, y1: 0, x2: 25, y2: 400},
-   "left": {x1: 0, y1: 425, x2: 0, y2: 425}
+  yield checkArrowsAndHandlers(helper, ".fixed", {
+    "top": {x1: 25, y1: 0, x2: 25, y2: 400},
+    "left": {x1: 0, y1: 425, x2: 0, y2: 425}
   });
 
   info("Hiding the highlighter");
-  yield highlighter.hide();
-  yield highlighter.finalize();
+  yield hide();
+  yield finalize();
 });
 
-function* checkArrows(highlighter, inspector, testActor, selector, arrows) {
+function* checkArrowsAndHandlers(helper, selector, arrows) {
   info("Highlighting the test node " + selector);
-  let node = yield getNodeFront(selector, inspector);
-  yield highlighter.show(node);
+
+  yield helper.show(selector);
 
   for (let side in arrows) {
-    yield checkArrow(highlighter, testActor, side, arrows[side]);
+    yield checkArrowAndHandler(helper, side, arrows[side]);
   }
 }
 
-function* checkArrow(highlighter, testActor, name, expectedCoordinates) {
-  for (let coordinate in expectedCoordinates) {
-    let value = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + name, coordinate, highlighter);
-    is(Math.floor(value), expectedCoordinates[coordinate],
+function* checkArrowAndHandler({getElementAttribute}, name, expectedCoords) {
+  info("Checking " + name + "arrow and handler coordinates are correct");
+
+  let handlerX = yield getElementAttribute("handler-" + name, "cx");
+  let handlerY = yield getElementAttribute("handler-" + name, "cy");
+
+  let expectedHandlerX = yield getElementAttribute("arrow-" + name,
+                                handlerMap[name].cx);
+  let expectedHandlerY = yield getElementAttribute("arrow-" + name,
+                                handlerMap[name].cy);
+
+  is(handlerX, expectedHandlerX,
+    "coordinate X for handler " + name + " is correct.");
+  is(handlerY, expectedHandlerY,
+    "coordinate Y for handler " + name + " is correct.");
+
+  for (let coordinate in expectedCoords) {
+    let value = yield getElementAttribute("arrow-" + name, coordinate);
+
+    is(Math.floor(value), expectedCoords[coordinate],
       coordinate + " coordinate for arrow " + name + " is correct");
   }
 }
diff --git a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_05.js b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_05.js
index 5e1d50b..a8b4176 100644
--- a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_05.js
+++ b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_05.js
@@ -1,134 +1,135 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+ /* Globals defined in: devtools/client/inspector/test/head.js */
+ /* global openInspectorForURL, getHighlighterHelperFor, TEST_URL_ROOT */
+
 "use strict";
 
-// Test that the arrows and offsetparent and currentnode elements of the
-// geometry highlighter only appear when needed.
+// Test that the arrows/handlers and offsetparent and currentnode elements of
+// the geometry highlighter only appear when needed.
 
 const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_02.html";
 const ID = "geometry-editor-";
+const HIGHLIGHTER_TYPE = "GeometryEditorHighlighter";
 
 const TEST_DATA = [{
   selector: "body",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: false,
-  hasVisibleArrows: false,
+  hasVisibleArrowsAndHandlers: false,
   isSizeVisible: false
 }, {
   selector: "h1",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: false,
-  hasVisibleArrows: false,
+  hasVisibleArrowsAndHandlers: false,
   isSizeVisible: false
 }, {
   selector: ".absolute",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: true,
+  hasVisibleArrowsAndHandlers: true,
   isSizeVisible: false
 }, {
   selector: "#absolute-container",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: false,
+  hasVisibleArrowsAndHandlers: false,
   isSizeVisible: true
 }, {
   selector: ".absolute-bottom-right",
   isOffsetParentVisible: true,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: true,
+  hasVisibleArrowsAndHandlers: true,
   isSizeVisible: false
 }, {
   selector: ".absolute-width-margin",
   isOffsetParentVisible: true,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: true,
+  hasVisibleArrowsAndHandlers: true,
   isSizeVisible: true
 }, {
   selector: ".absolute-all-4",
   isOffsetParentVisible: true,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: true,
+  hasVisibleArrowsAndHandlers: true,
   isSizeVisible: false
 }, {
   selector: ".relative",
   isOffsetParentVisible: true,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: true,
+  hasVisibleArrowsAndHandlers: true,
   isSizeVisible: false
 }, {
   selector: ".static",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: false,
-  hasVisibleArrows: false,
+  hasVisibleArrowsAndHandlers: false,
   isSizeVisible: false
 }, {
   selector: ".static-size",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: false,
+  hasVisibleArrowsAndHandlers: false,
   isSizeVisible: true
 }, {
   selector: ".fixed",
   isOffsetParentVisible: false,
   isCurrentNodeVisible: true,
-  hasVisibleArrows: true,
+  hasVisibleArrowsAndHandlers: true,
   isSizeVisible: false
 }];
 
 add_task(function*() {
-  let {inspector, testActor} = yield openInspectorForURL(TEST_URL);
-  let front = inspector.inspector;
+  let helper = yield openInspectorForURL(TEST_URL)
+                       .then(getHighlighterHelperFor(HIGHLIGHTER_TYPE));
 
-  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  helper.prefix = ID;
+
+  let { hide, finalize } = helper;
 
   for (let data of TEST_DATA) {
-    yield testNode(inspector, highlighter, testActor, data);
+    yield testNode(helper, data);
   }
 
   info("Hiding the highlighter");
-  yield highlighter.hide();
-  yield highlighter.finalize();
+  yield hide();
+  yield finalize();
 });
 
-function* testNode(inspector, highlighter, testActor, data) {
-  info("Highlighting the test node " + data.selector);
-  let node = yield getNodeFront(data.selector, inspector);
-  yield highlighter.show(node);
+function* testNode(helper, data) {
+  yield helper.show(data.selector);
 
-  is((yield isOffsetParentVisible(highlighter, testActor)), data.isOffsetParentVisible,
+  is((yield isOffsetParentVisible(helper)), data.isOffsetParentVisible,
     "The offset-parent highlighter visibility is correct for node " + data.selector);
-  is((yield isCurrentNodeVisible(highlighter, testActor)), data.isCurrentNodeVisible,
+  is((yield isCurrentNodeVisible(helper)), data.isCurrentNodeVisible,
     "The current-node highlighter visibility is correct for node " + data.selector);
-  is((yield hasVisibleArrows(highlighter, testActor)), data.hasVisibleArrows,
+  is((yield hasVisibleArrowsAndHandlers(helper)), data.hasVisibleArrowsAndHandlers,
     "The arrows visibility is correct for node " + data.selector);
-  is((yield isSizeVisible(highlighter, testActor)), data.isSizeVisible,
+  is((yield isSizeVisible(helper)), data.isSizeVisible,
     "The size label visibility is correct for node " + data.selector);
 }
 
-function* isOffsetParentVisible(highlighter, testActor) {
-  let hidden = yield testActor.getHighlighterNodeAttribute(ID + "offset-parent", "hidden", highlighter);
-  return !hidden;
+function* isOffsetParentVisible({isElementHidden}) {
+  return !(yield isElementHidden("offset-parent"));
 }
 
-function* isCurrentNodeVisible(highlighter, testActor) {
-  let hidden = yield testActor.getHighlighterNodeAttribute(ID + "current-node", "hidden", highlighter);
-  return !hidden;
+function* isCurrentNodeVisible({isElementHidden}) {
+  return !(yield isElementHidden("current-node"));
 }
 
-function* hasVisibleArrows(highlighter, testActor) {
+function* hasVisibleArrowsAndHandlers({isElementHidden}) {
   for (let side of ["top", "left", "bottom", "right"]) {
-    let hidden = yield testActor.getHighlighterNodeAttribute(ID + "arrow-" + side, "hidden", highlighter);
+    let hidden = yield isElementHidden("arrow-" + side);
     if (!hidden) {
-      return true;
+      return !(yield isElementHidden("handler-" + side));
     }
   }
   return false;
 }
 
-function* isSizeVisible(highlighter, testActor) {
-  let hidden = yield testActor.getHighlighterNodeAttribute(ID + "label-size", "hidden", highlighter);
-  return !hidden;
+function* isSizeVisible({isElementHidden}) {
+  return !(yield isElementHidden("label-size"));
 }
diff --git a/devtools/client/inspector/test/browser_inspector_highlighter-geometry_06.js b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_06.js
new file mode 100644
index 0000000..494a95c
--- /dev/null
+++ b/devtools/client/inspector/test/browser_inspector_highlighter-geometry_06.js
@@ -0,0 +1,179 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+ /* Globals defined in: devtools/client/inspector/test/head.js */
+ /* global openInspectorForURL, getHighlighterHelperFor, TEST_URL_ROOT */
+
+"use strict";
+
+// Test that the arrows/handlers and offsetparent and currentnode elements of
+// the geometry highlighter only appear when needed.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+const HIGHLIGHTER_TYPE = "GeometryEditorHighlighter";
+
+const SIDES = ["top", "right", "bottom", "left"];
+
+const TESTS = {
+  "Drag top's handler along x and y, south-est direction": {
+    "expects": "Only y axis is used to updated the top's element value",
+    "steps": {
+      "drag": "top",
+      "by": {x: 10, y: 10},
+    }
+  },
+  "Drag right's handler along x and y, south-est direction": {
+    "expects": "Only x axis is used to updated the right's element value",
+    "steps": {
+      "drag": "right",
+      "by": {x: 10, y: 10},
+    }
+  },
+  "Drag bottom's handler along x and y, south-est direction": {
+    "expects": "Only y axis is used to updated the bottom's element value",
+    "steps": {
+      "drag": "bottom",
+      "by": {x: 10, y: 10},
+    }
+  },
+  "Drag left's handler along x and y, south-est direction": {
+    "expects": "Only y axis is used to updated the left's element value",
+    "steps": {
+      "drag": "left",
+      "by": {x: 10, y: 10},
+    }
+  },
+  "Drag top's handler along x and y, north-west direction": {
+    "expects": "Only y axis is used to updated the top's element value",
+    "steps": {
+      "drag": "top",
+      "by": {x: -20, y: -20},
+    }
+  },
+  "Drag right's handler along x and y, north-west direction": {
+    "expects": "Only x axis is used to updated the right's element value",
+    "steps": {
+      "drag": "right",
+      "by": {x: -20, y: -20},
+    }
+  },
+  "Drag bottom's handler along x and y, north-west direction": {
+    "expects": "Only y axis is used to updated the bottom's element value",
+    "steps": {
+      "drag": "bottom",
+      "by": {x: -20, y: -20},
+    }
+  },
+  "Drag left's handler along x and y, north-west direction": {
+    "expects": "Only y axis is used to updated the left's element value",
+    "steps": {
+      "drag": "left",
+      "by": {x: -20, y: -20},
+    }
+  }
+};
+
+add_task(function*() {
+  let inspector = yield openInspectorForURL(TEST_URL);
+  let helper = yield getHighlighterHelperFor(HIGHLIGHTER_TYPE)(inspector);
+
+  helper.prefix = ID;
+
+  let { show, hide, finalize } = helper;
+
+  info("Showing the highlighter");
+  yield show("#node2");
+
+  for (let desc in TESTS) {
+    yield executeTest(helper, desc, TESTS[desc]);
+  }
+
+  info("Hiding the highlighter");
+  yield hide();
+  yield finalize();
+});
+
+function* executeTest(helper, desc, data) {
+  info(desc);
+
+  ok((yield areMovingStepsCorrect(helper, data.steps)), data.expects);
+}
+
+function* areMovingStepsCorrect(helper, steps) {
+  let { mouse, highlightedNode } = helper;
+  let side = steps.drag;
+
+  let {x, y} = yield getHandlerCoords(helper, side);
+
+  let dx = x + steps.by.x;
+  let dy = y + steps.by.y;
+
+  let beforeDragStyle = yield highlightedNode.getComputedStyle();
+
+  // simulate drag & drop
+  yield mouse.down(x, y);
+  yield mouse.move(dx, dy);
+  yield mouse.up();
+
+  info(`Checking ${side} handler is moved correctly`);
+  yield isHandlerPositionUpdated(helper, side, x, y, steps.by);
+
+  let delta = (side === "left" || side === "right") ? steps.by.x : steps.by.y;
+  delta = delta * ((side === "right" || side === "bottom") ? -1 : 1);
+
+  info(`Checking element's sides are correct after drag & drop`);
+  return yield areElementSideValuesCorrect(highlightedNode, beforeDragStyle,
+                                           side, delta);
+}
+
+function* isHandlerPositionUpdated(helper, name, x, y, by) {
+  let {x: afterDragX, y: afterDragY} = yield getHandlerCoords(helper, name);
+
+  if (name === "left" || name === "right") {
+    is(afterDragX, x + by.x,
+      `${name} handler's x axis updated.`);
+    is(afterDragY, y,
+      `${name} handler's y axis unchanged.`);
+  } else {
+    is(afterDragX, x,
+      `${name} handler's x axis unchanged.`);
+    is(afterDragY, y + by.y,
+      `${name} handler's y axis updated.`);
+  }
+}
+
+function* areElementSideValuesCorrect(node, beforeDragStyle, name, delta) {
+  let afterDragStyle = yield node.getComputedStyle();
+  let isSideCorrect = true;
+
+  for (let side of SIDES) {
+    let afterValue = Math.round(parseFloat(afterDragStyle[side].value));
+    let beforeValue = Math.round(parseFloat(beforeDragStyle[side].value));
+
+    if (side === name) {
+      // `isSideCorrect` is used only as test's return value, not to perform
+      // the actual test, because with `is` instead of `ok` we gather more
+      // information in case of failure
+      isSideCorrect = isSideCorrect && (afterValue === beforeValue + delta);
+
+      is(afterValue, beforeValue + delta,
+        `${side} is updated.`);
+    } else {
+      isSideCorrect = isSideCorrect && (afterValue === beforeValue);
+
+      is(afterValue, beforeValue,
+        `${side} is unchaged.`);
+    }
+  }
+
+  return isSideCorrect;
+}
+
+function* getHandlerCoords({getElementAttribute}, side) {
+  return {
+    x: Math.round(yield getElementAttribute("handler-" + side, "cx")),
+    y: Math.round(yield getElementAttribute("handler-" + side, "cy"))
+  };
+}
diff --git a/devtools/client/inspector/test/head.js b/devtools/client/inspector/test/head.js
index faaa798..b0b04f6 100644
--- a/devtools/client/inspector/test/head.js
+++ b/devtools/client/inspector/test/head.js
@@ -523,24 +523,45 @@ function* getNodeFrontForSelector(selector, inspector) {
  */
 const getHighlighterHelperFor = (type) => Task.async(
   function*({inspector, testActor}) {
     let front = inspector.inspector;
     let highlighter = yield front.getHighlighterByType(type);
 
     let prefix = "";
 
+    // internals for mouse events
+    let _x, _y;
+
+    // node highlighted
+    let _node = null;
+
     return {
       set prefix(value) {
         prefix = value;
       },
+      get highlightedNode() {
+        if (!_node) {
+          return null;
+        }
+
+        return {
+          getComputedStyle: function*(options = {}) {
+            return yield inspector.pageStyle.getComputed(_node, options);
+          }
+        };
+      },
 
       show: function*(selector = ":root") {
-        let node = yield getNodeFront(selector, inspector);
-        yield highlighter.show(node);
+        _node = yield getNodeFront(selector, inspector);
+        return yield highlighter.show(_node);
+      },
+
+      hide: function*() {
+        yield highlighter.hide();
       },
 
       isElementHidden: function*(id) {
         return (yield testActor.getHighlighterNodeAttribute(
           prefix + id, "hidden", highlighter)) === "true";
       },
 
       getElementTextContent: function*(id) {
@@ -549,20 +570,32 @@ const getHighlighterHelperFor = (type) => Task.async(
       },
 
       getElementAttribute: function*(id, name) {
         return yield testActor.getHighlighterNodeAttribute(
           prefix + id, name, highlighter);
       },
 
       synthesizeMouse: function*(options) {
+        options = Object.assign({selector: ":root"}, options);
         yield testActor.synthesizeMouse(options);
       },
 
+      mouse: new Proxy({}, {
+        get: (target, name) =>
+          function*(x = _x, y = _y) {
+            _x = x;
+            _y = y;
+            yield testActor.synthesizeMouse({
+              selector: ":root", x, y, options: {type: "mouse" + name}});
+          }
+      }),
+
       finalize: function*() {
+        _node = null;
         yield highlighter.finalize();
       }
     };
   }
 );
 
 // The expand all operation of the markup-view calls itself recursively and
 // there's not one event we can wait for to know when it's done
diff --git a/devtools/client/jar.mn b/devtools/client/jar.mn
index a4f60e5..006f173 100644
--- a/devtools/client/jar.mn
+++ b/devtools/client/jar.mn
@@ -229,16 +229,17 @@ devtools.jar:
     skin/images/itemToggle@2x.png (themes/images/itemToggle@2x.png)
     skin/images/itemArrow-dark-rtl.svg (themes/images/itemArrow-dark-rtl.svg)
     skin/images/itemArrow-dark-ltr.svg (themes/images/itemArrow-dark-ltr.svg)
     skin/images/itemArrow-rtl.svg (themes/images/itemArrow-rtl.svg)
     skin/images/itemArrow-ltr.svg (themes/images/itemArrow-ltr.svg)
     skin/images/noise.png (themes/images/noise.png)
     skin/images/dropmarker.svg (themes/images/dropmarker.svg)
     skin/layoutview.css (themes/layoutview.css)
+    skin/images/geometry-editor.svg (themes/images/geometry-editor.svg)
     skin/images/debugger-collapse.png (themes/images/debugger-collapse.png)
     skin/images/debugger-collapse@2x.png (themes/images/debugger-collapse@2x.png)
     skin/images/debugger-expand.png (themes/images/debugger-expand.png)
     skin/images/debugger-expand@2x.png (themes/images/debugger-expand@2x.png)
     skin/images/debugger-pause.png (themes/images/debugger-pause.png)
     skin/images/debugger-pause@2x.png (themes/images/debugger-pause@2x.png)
     skin/images/debugger-play.png (themes/images/debugger-play.png)
     skin/images/debugger-play@2x.png (themes/images/debugger-play@2x.png)
diff --git a/devtools/client/layoutview/view.js b/devtools/client/layoutview/view.js
index 51abdcb..86e88b0 100644
--- a/devtools/client/layoutview/view.js
+++ b/devtools/client/layoutview/view.js
@@ -1,14 +1,15 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+/* global window, document */
 "use strict";
 
 var {utils: Cu, interfaces: Ci, classes: Cc} = Components;
 
 Cu.import("resource://gre/modules/Task.jsm");
 const {require} = Cu.import("resource://devtools/shared/Loader.jsm", {});
 Cu.import("resource://gre/modules/Console.jsm");
 Cu.import("resource://devtools/client/shared/widgets/ViewHelpers.jsm");
@@ -137,16 +138,18 @@ EditingSession.prototype = {
  */
 function LayoutView(inspector, win) {
   this.inspector = inspector;
 
   this.doc = win.document;
   this.sizeLabel = this.doc.querySelector(".size > span");
   this.sizeHeadingLabel = this.doc.getElementById("element-size");
 
+  this._geometryEditorHighlighter = null;
+
   this.init();
 }
 
 LayoutView.prototype = {
   init: function() {
     this.update = this.update.bind(this);
 
     this.onNewSelection = this.onNewSelection.bind(this);
@@ -391,16 +394,21 @@ LayoutView.prototype = {
       }
 
       let node = this.inspector.selection.nodeFront;
       let layout = yield this.inspector.pageStyle.getLayout(node, {
         autoMargins: this.isActive
       });
       let styleEntries = yield this.inspector.pageStyle.getApplied(node, {});
 
+      let isEditable = yield this.inspector.pageStyle.isPositionEditable(node);
+      let nodeGeometryEditor = this.doc.querySelector("[for=geometry-editor]");
+
+      nodeGeometryEditor.style.visibility = isEditable ? "visible" : "hidden";
+
       // If a subsequent request has been made, wait for that one instead.
       if (this._lastRequest != lastRequest) {
         return this._lastRequest;
       }
 
       this._lastRequest = null;
       let width = layout.width;
       let height = layout.height;
@@ -528,16 +536,44 @@ LayoutView.prototype = {
    * Hide the box-model highlighter on the currently selected element
    */
   hideBoxModel: function() {
     let toolbox = this.inspector.toolbox;
 
     toolbox.highlighterUtils.unhighlight();
   },
 
+  /**
+   * Show the box-model highlighter on the currently selected element
+   * @param {Object} options Options passed to the highlighter actor
+   */
+  showGeometryEditor: function(options = {}) {
+    if (this._geometryEditorHighlighter) {
+      this._geometryEditorHighlighter.hide();
+    }
+
+    let toolbox = this.inspector.toolbox;
+    let nodeFront = this.inspector.selection.nodeFront;
+
+    toolbox.highlighterUtils.getHighlighterByType("GeometryEditorHighlighter")
+      .then(highlighter => {
+        highlighter.show(nodeFront, options);
+        this._geometryEditorHighlighter = highlighter;
+      });
+  },
+
+  /**
+   * Hide the box-model highlighter on the currently selected element
+   */
+  hideGeometryEditor: function() {
+    if (this._geometryEditorHighlighter) {
+      this._geometryEditorHighlighter.hide();
+    }
+  },
+
   manageOverflowingText: function(span) {
     let classList = span.parentNode.classList;
 
     if (classList.contains("left") || classList.contains("right")) {
       let force = span.textContent.length > LONG_TEXT_ROTATE_LIMIT;
       classList.toggle("rotate", force);
     }
   }
@@ -577,16 +613,26 @@ window.setPanel = function(panel) {
   }
 
   // Mark document as RTL or LTR:
   let chromeReg = Cc["@mozilla.org/chrome/chrome-registry;1"]
                   .getService(Ci.nsIXULChromeRegistry);
   let dir = chromeReg.isLocaleRTL("global");
   document.body.setAttribute("dir", dir ? "rtl" : "ltr");
 
+  document.getElementById("geometry-editor").addEventListener("click", (e) => {
+    let {target} = e;
+
+    if (target.checked) {
+      this.layoutview.showGeometryEditor();
+    } else {
+      this.layoutview.hideGeometryEditor();
+    }
+  });
+
   window.parent.postMessage("layoutview-ready", "*");
 };
 
 window.onunload = function() {
   if (this.layoutview) {
     this.layoutview.destroy();
   }
   if (elts) {
diff --git a/devtools/client/layoutview/view.xhtml b/devtools/client/layoutview/view.xhtml
index 6bda485..14ea4c8 100644
--- a/devtools/client/layoutview/view.xhtml
+++ b/devtools/client/layoutview/view.xhtml
@@ -19,17 +19,23 @@
 
     <link rel="stylesheet" href="chrome://devtools/skin/common.css" type="text/css"/>
     <link rel="stylesheet" href="chrome://devtools/skin/layoutview.css" type="text/css"/>
 
   </head>
   <body class="theme-sidebar devtools-monospace">
 
     <p id="header">
-      <span id="element-size"></span><span id="element-position"></span>
+      <span id="element-size"></span>
+
+      <section id="position-group">
+        <input type="checkbox" id="geometry-editor"/>
+        <label for="geometry-editor" title="&geometry.button.tooltip;"></label>
+        <span id="element-position"></span>
+      </section>
     </p>
 
     <div id="main">
 
       <span class="legend" data-box="margin" title="&margin.tooltip;">&margin.tooltip;</span>
       <div id="margins" data-box="margin" title="&margin.tooltip;">
         <span class="legend" data-box="border" title="&border.tooltip;">&border.tooltip;</span>
         <div id="borders" data-box="border" title="&border.tooltip;">
diff --git a/devtools/client/locales/en-US/layoutview.dtd b/devtools/client/locales/en-US/layoutview.dtd
index a8cb405..7ebfbba 100644
--- a/devtools/client/locales/en-US/layoutview.dtd
+++ b/devtools/client/locales/en-US/layoutview.dtd
@@ -11,13 +11,17 @@
   - You want to make that choice consistent across the developer tools.
   - A good criteria is the language in which you'd find the best
   - documentation on web development on the web. -->
 
 <!-- LOCALIZATION NOTE (*.tooltip): These tooltips are not regular tooltips.
   -  The text appears on the bottom right corner of the layout view when
   -  the corresponding box is hovered. -->
 
-<!ENTITY title                  "Box Model">
-<!ENTITY margin.tooltip         "margin">
-<!ENTITY border.tooltip         "border">
-<!ENTITY padding.tooltip        "padding">
-<!ENTITY content.tooltip        "content">
+<!ENTITY title                    "Box Model">
+<!ENTITY margin.tooltip           "margin">
+<!ENTITY border.tooltip           "border">
+<!ENTITY padding.tooltip          "padding">
+<!ENTITY content.tooltip          "content">
+
+<!-- LOCALIZATION NOTE: The tooltip below appears as tooltip when the
+  - geometry editor button is hovered -->
+<!ENTITY geometry.button.tooltip  "Edit layout">
diff --git a/devtools/client/themes/images/geometry-editor.svg b/devtools/client/themes/images/geometry-editor.svg
new file mode 100644
index 0000000..c2746f0
--- /dev/null
+++ b/devtools/client/themes/images/geometry-editor.svg
@@ -0,0 +1,10 @@
+<svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
+    <g fill="none" fill-rule="evenodd">
+        <path stroke="#f5f5f5" d="M3 3.048h9v8.928H3z"/>
+        <ellipse fill="#f5f5f5" cx="3.538" cy="7.526" rx="1.538" ry="1.526"/>
+        <path d="M10 7.538c0 .85.683 1.54 1.526 1.54s1.526-.69 1.526-1.54c0-.85-.683-1.538-1.526-1.538S10 6.69 10 7.538z" fill="#f5f5f5"/>
+        <ellipse fill="#f5f5f5" cx="7.538" cy="3.526" rx="1.538" ry="1.526"/>
+        <ellipse fill="#f5f5f5" cx="7.538" cy="11.526" rx="1.538" ry="1.526"/>
+        <path d="M7.5.5v3m-7 4h3m11 0h-3m-4 7v-3m-1-11h2m6 6v2m-8 6h2m-8-8v2" stroke="#f5f5f5" stroke-linecap="square"/>
+    </g>
+</svg>
diff --git a/devtools/client/themes/layoutview.css b/devtools/client/themes/layoutview.css
index 642e89c..367cafc 100644
--- a/devtools/client/themes/layoutview.css
+++ b/devtools/client/themes/layoutview.css
@@ -16,34 +16,36 @@ body {
 }
 
 /* Header: contains the position and size of the element */
 
 #header {
   box-sizing: border-box;
   width: 100%;
   padding: 4px 14px;
-  display: -moz-box;
+  display: flex;
   vertical-align: top;
+  align-items: center;
 }
 
+#position-group:-moz-dir(rtl),
 #header:-moz-dir(rtl) {
-  -moz-box-direction: reverse;
+  flex-direction: row-reverse;
 }
 
 #header > span {
   display: -moz-box;
 }
 
 #element-size {
-  -moz-box-flex: 1;
+  flex: 1;
 }
 
 #element-size:-moz-dir(rtl) {
-  -moz-box-pack: end;
+  text-align: right;
 }
 
 @media (max-height: 228px) {
   #header {
     padding-top: 0;
     padding-bottom: 0;
     margin-top: 10px;
     margin-bottom: 8px;
@@ -332,8 +334,43 @@ body {
 
 /* Hide all values when the view is inactive */
 
 body.inactive > #header > #element-position,
 body.inactive > #header > #element-size,
 body.inactive > #main > p {
    visibility: hidden;
 }
+
+#position-group {
+  display: flex;
+  align-items: center;
+}
+
+#geometry-editor {
+  position: absolute;
+  left: -1000em;
+}
+
+#geometry-editor + label {
+  display: inline-block;
+  width: 19px;
+  height: 19px;
+  background: url(images/geometry-editor.svg) no-repeat center center / 16px 16px;
+  -moz-user-select: none;
+  margin: 0 4px;
+  visibility: hidden;
+  border-radius: 2px;
+  opacity: 0.6;
+}
+
+.theme-light #geometry-editor:not(:checked) + label {
+  filter: invert(1);
+}
+
+#geometry-editor + label:hover {
+  opacity: 1;
+}
+
+#geometry-editor:checked + label {
+  opacity: 1;
+  background-color: var(--theme-selection-background);
+}
diff --git a/devtools/server/actors/highlighters.css b/devtools/server/actors/highlighters.css
index 1c82c28..87b55f1 100644
--- a/devtools/server/actors/highlighters.css
+++ b/devtools/server/actors/highlighters.css
@@ -24,16 +24,20 @@
      'pointer-events:auto;' on its container element. */
   pointer-events: none;
 }
 
 :-moz-native-anonymous .highlighter-container [hidden] {
   display: none;
 }
 
+:-moz-native-anonymous .highlighter-container [dragging] {
+  cursor: grabbing;
+}
+
 /* Box model highlighter */
 
 :-moz-native-anonymous .box-model-regions {
   opacity: 0.6;
 }
 
 /* Box model regions can be faded (see the onlyRegionArea option in
    highlighters.js) in order to only display certain regions. */
@@ -191,16 +195,17 @@
 }
 
 /* Element geometry highlighter */
 
 :-moz-native-anonymous .geometry-editor-root {
   /* The geometry editor can be interacted with, so it needs to react to
      pointer events */
   pointer-events: auto;
+  -moz-user-select: none;
 }
 
 :-moz-native-anonymous .geometry-editor-offset-parent {
   stroke: #08c;
   shape-rendering: crispEdges;
   stroke-dasharray: 5 3;
   fill: transparent;
 }
@@ -212,16 +217,40 @@
   opacity: 0.6;
 }
 
 :-moz-native-anonymous .geometry-editor-arrow {
   stroke: #08c;
   shape-rendering: crispEdges;
 }
 
+:-moz-native-anonymous .geometry-editor-root circle {
+  stroke: #08c;
+  fill: #87ceeb;
+}
+
+:-moz-native-anonymous .geometry-editor-handler-top,
+:-moz-native-anonymous .geometry-editor-handler-bottom {
+  cursor: ns-resize;
+}
+
+:-moz-native-anonymous .geometry-editor-handler-right,
+:-moz-native-anonymous .geometry-editor-handler-left {
+  cursor: ew-resize;
+}
+
+:-moz-native-anonymous [dragging] .geometry-editor-handler-top,
+:-moz-native-anonymous [dragging] .geometry-editor-handler-right,
+:-moz-native-anonymous [dragging] .geometry-editor-handler-bottom,
+:-moz-native-anonymous [dragging] .geometry-editor-handler-left {
+  cursor: grabbing;
+}
+
+
+
 :-moz-native-anonymous .geometry-editor-label-bubble {
   fill: hsl(214,13%,24%);
   shape-rendering: crispEdges;
 }
 
 :-moz-native-anonymous .geometry-editor-label-text {
   fill: hsl(216,33%,97%);
   font: message-box;
diff --git a/devtools/server/actors/highlighters/geometry-editor.js b/devtools/server/actors/highlighters/geometry-editor.js
index 5a8138f..b47cc2b 100644
--- a/devtools/server/actors/highlighters/geometry-editor.js
+++ b/devtools/server/actors/highlighters/geometry-editor.js
@@ -10,16 +10,21 @@ const {
   CanvasFrameAnonymousContentHelper, getCSSStyleRules, getComputedStyle,
   createSVGNode, createNode } = require("./utils/markup");
 
 const { setIgnoreLayoutChanges,
   getAdjustedQuads } = require("devtools/shared/layout/utils");
 
 const GEOMETRY_LABEL_SIZE = 6;
 
+// List of all DOM Events used by the geometry editor highlighter
+const DOM_EVENTS = ["mousedown", "mouseup", "mousemove", "pagehide"];
+
+const _dragging = Symbol("geometry/dragging");
+
 /**
  * Element geometry properties helper that gives names of position and size
  * properties.
  */
 var GeoProp = {
   SIDES: ["top", "right", "bottom", "left"],
   SIZES: ["width", "height"],
 
@@ -108,16 +113,82 @@ function getOffsetParent(node) {
 
   return {
     element: offsetParent,
     dimension: {width, height}
   };
 }
 
 /**
+ * Get the list of geometry properties that are actually set on the node given.
+ *
+ * @param {nsIDOMNode} node The node to analyze.
+ * @return {Map} A map indexed by property name and where the value is an
+ * object having the cssRule property.
+ */
+function getDefinedGeometryProperties(node) {
+  let props = new Map();
+  if (!node) {
+    return props;
+  }
+
+  // Get the list of css rules applying to the current node.
+  let cssRules = getCSSStyleRules(node);
+  for (let i = 0; i < cssRules.Count(); i++) {
+    let rule = cssRules.GetElementAt(i);
+    for (let name of GeoProp.allProps()) {
+      let value = rule.style.getPropertyValue(name);
+      if (value && value !== "auto") {
+        // getCSSStyleRules returns rules ordered from least to most specific
+        // so just override any previous properties we have set.
+        props.set(name, {
+          cssRule: rule
+        });
+      }
+    }
+  }
+
+  // Go through the inline styles last.
+  for (let name of GeoProp.allProps()) {
+    let value = node.style.getPropertyValue(name);
+    if (value && value !== "auto") {
+      props.set(name, {
+        // There's no cssRule to store here, so store the node instead since
+        // node.style exists.
+        cssRule: node
+      });
+    }
+  }
+
+  // Post-process the list for invalid properties. This is done after the fact
+  // because of cases like relative positioning with both top and bottom where
+  // only top will actually be used, but both exists in css rules and computed
+  // styles.
+  for (let [name] of props) {
+    let pos = getComputedStyle(node).position;
+
+    // Top/left/bottom/right on static positioned elements have no effect.
+    if (pos === "static" && GeoProp.SIDES.indexOf(name) !== -1) {
+      props.delete(name);
+    }
+
+    // Bottom/right on relative positioned elements are only used if top/left
+    // are not defined.
+    let hasRightAndLeft = name === "right" && props.has("left");
+    let hasBottomAndTop = name === "bottom" && props.has("top");
+    if (pos === "relative" && (hasRightAndLeft || hasBottomAndTop)) {
+      props.delete(name);
+    }
+  }
+
+  return props;
+}
+exports.getDefinedGeometryProperties = getDefinedGeometryProperties;
+
+/**
  * The GeometryEditor highlights an elements's top, left, bottom, right, width
  * and height dimensions, when they are set.
  *
  * To determine if an element has a set size and position, the highlighter lists
  * the CSS rules that apply to the element and checks for the top, left, bottom,
  * right, width and height properties.
  * The highlighter won't be shown if the element doesn't have any of these
  * properties set, but will be shown when at least 1 property is defined.
@@ -133,16 +204,21 @@ function getOffsetParent(node) {
 function GeometryEditorHighlighter(highlighterEnv) {
   AutoRefreshHighlighter.call(this, highlighterEnv);
 
   // The list of element geometry properties that can be set.
   this.definedProperties = new Map();
 
   this.markup = new CanvasFrameAnonymousContentHelper(highlighterEnv,
     this._buildMarkup.bind(this));
+
+  let { pageListenerTarget } = highlighterEnv;
+
+  // register the geometry editor instance to all events we're interested in.
+  DOM_EVENTS.forEach(type => pageListenerTarget.addEventListener(type, this));
 }
 
 GeometryEditorHighlighter.prototype = extend(AutoRefreshHighlighter.prototype, {
   typeName: "GeometryEditorHighlighter",
 
   ID_CLASS_PREFIX: "geometry-editor-",
 
   _buildMarkup: function() {
@@ -189,29 +265,41 @@ GeometryEditorHighlighter.prototype = extend(AutoRefreshHighlighter.prototype, {
       attributes: {
         "class": "current-node",
         "id": "current-node",
         "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
-    // Build the 4 side arrows and labels.
+    // Build the 4 side arrows, handlers and labels.
     for (let name of GeoProp.SIDES) {
       createSVGNode(this.win, {
         nodeType: "line",
         parent: svg,
         attributes: {
           "class": "arrow " + name,
           "id": "arrow-" + name,
           "hidden": "true"
         },
         prefix: this.ID_CLASS_PREFIX
       });
 
+      createSVGNode(this.win, {
+        nodeType: "circle",
+        parent: svg,
+        attributes: {
+          "class": "handler-" + name,
+          "id": "handler-" + name,
+          "r": "4",
+          "hidden": "true"
+        },
+        prefix: this.ID_CLASS_PREFIX
+      });
+
       // Labels are positioned by using a translated <g>. This group contains
       // a path and text that are themselves positioned using another translated
       // <g>. This is so that the label arrow points at the 0,0 coordinates of
       // parent <g>.
       let labelG = createSVGNode(this.win, {
         nodeType: "g",
         parent: svg,
         attributes: {
@@ -296,24 +384,106 @@ GeometryEditorHighlighter.prototype = extend(AutoRefreshHighlighter.prototype, {
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     return container;
   },
 
   destroy: function() {
+    let { pageListenerTarget } = this.highlighterEnv;
+
+    DOM_EVENTS.forEach(type =>
+      pageListenerTarget.removeEventListener(type, this));
+
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
     this.definedProperties.clear();
     this.definedProperties = null;
     this.offsetParent = null;
   },
 
+  handleEvent(event) {
+    const { originalTarget, type, pageX, pageY } = event;
+
+    switch (type) {
+      case "pagehide":
+        this.destroy();
+        break;
+      case "mousedown":
+        // The mousedown event stars the drag & drop, so ignore everything else
+        // but handlers
+        if (originalTarget.tagName !== "circle") {
+          event.stopPropagation();
+          event.preventDefault();
+          return false;
+        }
+
+        // Get the side from the handler's id
+        let m = originalTarget.id.match(/[^-]+$/);
+
+        if (m[0]) {
+          let side = m[0];
+          let sideProp = this.definedProperties.get(side);
+
+          if (!sideProp) {
+            return false;
+          }
+
+          let value = sideProp.cssRule.style.getPropertyValue(side);
+          let computedValue = this.computedStyle.getPropertyValue(side);
+
+          let [unit] = value.match(/[^\d]+$/) || [""];
+
+          value = parseFloat(value);
+
+          let ratio = (value / parseFloat(computedValue)) || 1;
+          let dir = GeoProp.isInverted(side) ? -1 : 1;
+
+          // Store all the initial values needed for drag & drop
+          this[_dragging] = {
+            side,
+            value,
+            unit,
+            x: pageX,
+            y: pageY,
+            inc: ratio * dir
+          };
+        }
+
+        this.getElement("root").setAttribute("dragging", "true");
+        break;
+      case "mouseup":
+        // If we're dragging, drop it.
+        if (this[_dragging]) {
+          this.getElement("root").removeAttribute("dragging");
+          this[_dragging] = null;
+        }
+        break;
+      case "mousemove":
+        if (!this[_dragging]) {
+          return false;
+        }
+
+        let { side, x, y, value, unit, inc } = this[_dragging];
+        let sideProps = this.definedProperties.get(side);
+
+        if (!sideProps) {
+          return false;
+        }
+
+        let delta = (GeoProp.isHorizontal(side) ? pageX - x : pageY - y) * inc;
+
+        sideProps.cssRule.style.setProperty(side, (value + delta) + unit);
+
+        break;
+    }
+  },
+
   getElement: function(id) {
     return this.markup.getElement(this.ID_CLASS_PREFIX + id);
   },
 
   /**
    * Get the list of geometry properties that are actually set on the current
    * node.
    * @return {Map} A map indexed by property name and where the value is an
@@ -408,19 +578,20 @@ GeometryEditorHighlighter.prototype = extend(AutoRefreshHighlighter.prototype, {
 
     // Update the highlighters and arrows.
     this.updateOffsetParent();
     this.updateCurrentNode();
     this.updateArrows();
     this.updateSize();
 
     // Avoid zooming the arrows when content is zoomed.
-    this.markup.scaleRootElement(this.currentNode, this.ID_CLASS_PREFIX + "root");
+    let node = this.currentNode;
+    this.markup.scaleRootElement(node, this.ID_CLASS_PREFIX + "root");
 
-    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+    setIgnoreLayoutChanges(false, node.ownerDocument.documentElement);
     return true;
   },
 
   /**
    * Update the offset parent rectangle.
    * There are 3 different cases covered here:
    * - the node is absolutely/fixed positioned, and an offsetParent is defined
    *   (i.e. it's not just positioned in the viewport): the offsetParent node
@@ -483,30 +654,33 @@ GeometryEditorHighlighter.prototype = extend(AutoRefreshHighlighter.prototype, {
                p4.x + "," + p4.y;
     box.setAttribute("points", attr);
     box.removeAttribute("hidden");
   },
 
   _hide: function() {
     setIgnoreLayoutChanges(true);
 
+    this.getElement("root").setAttribute("hidden", "true");
     this.getElement("current-node").setAttribute("hidden", "true");
     this.getElement("offset-parent").setAttribute("hidden", "true");
     this.hideArrows();
     this.hideSize();
 
     this.definedProperties.clear();
 
-    setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
+    setIgnoreLayoutChanges(false,
+      this.currentNode.ownerDocument.documentElement);
   },
 
   hideArrows: function() {
     for (let side of GeoProp.SIDES) {
       this.getElement("arrow-" + side).setAttribute("hidden", "true");
       this.getElement("label-" + side).setAttribute("hidden", "true");
+      this.getElement("handler-" + side).setAttribute("hidden", "true");
     }
   },
 
   hideSize: function() {
     this.getElement("label-size").setAttribute("hidden", "true");
   },
 
   updateSize: function() {
@@ -595,27 +769,32 @@ GeometryEditorHighlighter.prototype = extend(AutoRefreshHighlighter.prototype, {
                        sideProp.cssRule.style.getPropertyValue(side));
     }
   },
 
   updateArrow: function(side, mainStart, mainEnd, crossPos, labelValue) {
     let arrowEl = this.getElement("arrow-" + side);
     let labelEl = this.getElement("label-" + side);
     let labelTextEl = this.getElement("label-text-" + side);
+    let handlerEl = this.getElement("handler-" + side);
 
     // Position the arrow <line>.
     arrowEl.setAttribute(GeoProp.axis(side) + "1", mainStart);
     arrowEl.setAttribute(GeoProp.crossAxis(side) + "1", crossPos);
     arrowEl.setAttribute(GeoProp.axis(side) + "2", mainEnd);
     arrowEl.setAttribute(GeoProp.crossAxis(side) + "2", crossPos);
     arrowEl.removeAttribute("hidden");
 
+    handlerEl.setAttribute("c" + GeoProp.axis(side), mainEnd);
+    handlerEl.setAttribute("c" + GeoProp.crossAxis(side), crossPos);
+    handlerEl.removeAttribute("hidden");
+
     // Position the label <text> in the middle of the arrow (making sure it's
     // not hidden below the fold).
-    let capitalize = str => str.substring(0, 1).toUpperCase() + str.substring(1);
+    let capitalize = str => str[0].toUpperCase() + str.substring(1);
     let winMain = this.win["inner" + capitalize(GeoProp.mainAxisSize(side))];
     let labelMain = mainStart + (mainEnd - mainStart) / 2;
     if ((mainStart > 0 && mainStart < winMain) ||
         (mainEnd > 0 && mainEnd < winMain)) {
       if (labelMain < GEOMETRY_LABEL_SIZE) {
         labelMain = GEOMETRY_LABEL_SIZE;
       } else if (labelMain > winMain - GEOMETRY_LABEL_SIZE) {
         labelMain = winMain - GEOMETRY_LABEL_SIZE;
diff --git a/devtools/server/actors/styles.js b/devtools/server/actors/styles.js
index cbebe16..cae31b3d 100644
--- a/devtools/server/actors/styles.js
+++ b/devtools/server/actors/styles.js
@@ -6,16 +6,19 @@
 
 const {Cc, Ci, Cu} = require("chrome");
 const promise = require("promise");
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method, RetVal, types} = protocol;
 const events = require("sdk/event/core");
 const {Class} = require("sdk/core/heritage");
 const {LongStringActor} = require("devtools/server/actors/string");
+const {
+  getDefinedGeometryProperties
+} = require("devtools/server/actors/highlighters/geometry-editor");
 
 // This will also add the "stylesheet" actor type for protocol.js to recognize
 const {UPDATE_PRESERVING_RULES, UPDATE_GENERAL} =
       require("devtools/server/actors/stylesheets");
 
 loader.lazyRequireGetter(this, "CSS", "CSS");
 
 loader.lazyGetter(this, "CssLogic", () => {
@@ -591,16 +594,34 @@ var PageStyleActor = protocol.ActorClass({
   }),
 
   _hasInheritedProps: function(style) {
     return Array.prototype.some.call(style, prop => {
       return DOMUtils.isInheritedProperty(prop);
     });
   },
 
+  isPositionEditable: method(Task.async(function*(node) {
+    if (!node) {
+      return false;
+    }
+
+    let props = getDefinedGeometryProperties(node.rawNode);
+
+    // elements with only `width` and `height` are currently not considered
+    // editable
+    return props.has("top") ||
+          props.has("right") ||
+          props.has("left") ||
+          props.has("bottom");
+  }), {
+    request: { node: Arg(0, "domnode")},
+    response: { value: RetVal("boolean") }
+  }),
+
   /**
    * Helper function for getApplied, gets all the rules from a given
    * element. See getApplied for documentation on parameters.
    * @param NodeActor node
    * @param bool inherited
    * @param object options
 
    * @return Array The rules for a given element. Each item in the
