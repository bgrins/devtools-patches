# HG changeset patch
# Parent 35046df9df1faafc1d711f9c4d1f15d51bdac5d4
# User Florent Fayolle <fayolle-florent@orange.fr>
Bug 1143497 - Offer a way to extend WebConsole commands, r=bgrins

diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -27,18 +27,18 @@ XPCOMUtils.defineLazyGetter(this, "Conso
   return require("devtools/toolkit/webconsole/network-monitor")
          .ConsoleProgressListener;
 });
 XPCOMUtils.defineLazyGetter(this, "events", () => {
   return require("sdk/event/core");
 });
 
 for (let name of ["WebConsoleUtils", "ConsoleServiceListener",
-                  "ConsoleAPIListener", "JSTermHelpers", "JSPropertyProvider",
-                  "ConsoleReflowListener"]) {
+    "ConsoleAPIListener", "addWebConsoleCommands", "JSPropertyProvider",
+    "ConsoleReflowListener"]) {
   Object.defineProperty(this, name, {
     get: function(prop) {
       if (prop == "WebConsoleUtils") {
         prop = "Utils";
       }
       return require("devtools/toolkit/webconsole/utils")[prop];
     }.bind(null, name),
     configurable: true,
@@ -290,21 +290,21 @@ WebConsoleActor.prototype =
   consoleProgressListener: null,
 
   /**
    * The ConsoleReflowListener instance.
    */
   consoleReflowListener: null,
 
   /**
-   * The JSTerm Helpers names cache.
+   * The Web Console Commands names cache.
    * @private
    * @type array
    */
-  _jstermHelpersCache: null,
+  _webConsoleCommandsCache: null,
 
   actorPrefix: "console",
 
   grip: function WCA_grip()
   {
     return { actor: this.actorID };
   },
 
@@ -353,17 +353,17 @@ WebConsoleActor.prototype =
     events.off(this.parentActor, "changed-toplevel-document", this._onChangedToplevelDocument);
     this.conn.removeActorPool(this._actorPool);
     if (this.parentActor.isRootActor) {
       Services.obs.removeObserver(this._onObserverNotification,
                                   "last-pb-context-exited");
     }
     this._actorPool = null;
 
-    this._jstermHelpersCache = null;
+    this._webConsoleCommandsCache = null;
     this._lastConsoleInputEvaluation = null;
     this._evalWindow = null;
     this._netEvents.clear();
     this.dbg.enabled = false;
     this.dbg = null;
     this.conn = null;
   },
 
@@ -877,24 +877,26 @@ WebConsoleActor.prototype =
                                     aRequest.cursor, frameActorId) || {};
     let matches = result.matches || [];
     let reqText = aRequest.text.substr(0, aRequest.cursor);
 
     // We consider '$' as alphanumerc because it is used in the names of some
     // helper functions.
     let lastNonAlphaIsDot = /[.][a-zA-Z0-9$]*$/.test(reqText);
     if (!lastNonAlphaIsDot) {
-      if (!this._jstermHelpersCache) {
+      if (!this._webConsoleCommandsCache) {
         let helpers = {
           sandbox: Object.create(null)
         };
-        JSTermHelpers(helpers);
-        this._jstermHelpersCache = Object.getOwnPropertyNames(helpers.sandbox);
+        addWebConsoleCommands(helpers);
+        this._webConsoleCommandsCache =
+          Object.getOwnPropertyNames(helpers.sandbox);
       }
-      matches = matches.concat(this._jstermHelpersCache.filter(n => n.startsWith(result.matchProp)));
+      matches = matches.concat(this._webConsoleCommandsCache
+          .filter(n => n.startsWith(result.matchProp)));
     }
 
     return {
       from: this.actorID,
       matches: matches.sort(),
       matchProp: result.matchProp,
     };
   },
@@ -961,34 +963,34 @@ WebConsoleActor.prototype =
   /**
    * Create an object with the API we expose to the Web Console during
    * JavaScript evaluation.
    * This object inherits properties and methods from the Web Console actor.
    *
    * @private
    * @param object aDebuggerGlobal
    *        A Debugger.Object that wraps a content global. This is used for the
-   *        JSTerm helpers.
+   *        Web Console Commands.
    * @return object
    *         The same object as |this|, but with an added |sandbox| property.
    *         The sandbox holds methods and properties that can be used as
    *         bindings during JS evaluation.
    */
-  _getJSTermHelpers: function WCA__getJSTermHelpers(aDebuggerGlobal)
+  _getWebConsoleCommands: function(aDebuggerGlobal)
   {
     let helpers = {
       window: this.evalWindow,
       chromeWindow: this.chromeWindow.bind(this),
       makeDebuggeeValue: aDebuggerGlobal.makeDebuggeeValue.bind(aDebuggerGlobal),
       createValueGrip: this.createValueGrip.bind(this),
       sandbox: Object.create(null),
       helperResult: null,
       consoleActor: this,
     };
-    JSTermHelpers(helpers);
+    addWebConsoleCommands(helpers);
 
     let evalWindow = this.evalWindow;
     function maybeExport(obj, name) {
       if (typeof obj[name] != "function") {
         return;
       }
 
       // By default, chrome-implemented functions that are exposed to content
@@ -1032,19 +1034,19 @@ WebConsoleActor.prototype =
    * user-selected stack frame.
    *
    * For the above to work we need the debugger and the Web Console to share
    * a connection, otherwise the Web Console actor will not find the frame
    * actor.
    *
    * The Debugger.Frame comes from the jsdebugger's Debugger instance, which
    * is different from the Web Console's Debugger instance. This means that
-   * for evaluation to work, we need to create a new instance for the jsterm
-   * helpers - they need to be Debugger.Objects coming from the jsdebugger's
-   * Debugger instance.
+   * for evaluation to work, we need to create a new instance for the Web
+   * Console Commands helpers - they need to be Debugger.Objects coming from the
+   * jsdebugger's Debugger instance.
    *
    * When |bindObjectActor| is used objects can come from different iframes,
    * from different domains. To avoid permission-related errors when objects
    * come from a different window, we also determine the object's own global,
    * such that evaluation happens in the context of that global. This means that
    * evaluation will happen in the object's iframe, rather than the top level
    * window.
    *
@@ -1064,17 +1066,18 @@ WebConsoleActor.prototype =
    *        node, like $0.
    * @return object
    *         An object that holds the following properties:
    *         - dbg: the debugger where the string was evaluated.
    *         - frame: (optional) the frame where the string was evaluated.
    *         - window: the Debugger.Object for the global where the string was
    *         evaluated.
    *         - result: the result of the evaluation.
-   *         - helperResult: any result coming from a JSTerm helper function.
+   *         - helperResult: any result coming from a Web Console commands
+   *         function.
    *         - url: the url to evaluate the script as. Defaults to
    *         "debugger eval code".
    */
   evalWithDebugger: function WCA_evalWithDebugger(aString, aOptions = {})
   {
     let trimmedString = aString.trim();
     // The help function needs to be easy to guess, so we make the () optional.
     if (trimmedString == "help" || trimmedString == "?") {
@@ -1120,32 +1123,33 @@ WebConsoleActor.prototype =
         // that is, without wrappers. The evalWithBindings call will then wrap
         // jsObj appropriately for the evaluation compartment.
         let global = Cu.getGlobalForObject(jsObj);
         dbgWindow = dbg.makeGlobalObjectReference(global);
         bindSelf = dbgWindow.makeDebuggeeValue(jsObj);
       }
     }
 
-    // Get the JSTerm helpers for the given debugger window.
-    let helpers = this._getJSTermHelpers(dbgWindow);
+    // Get the Web Console commands for the given debugger window.
+    let helpers = this._getWebConsoleCommands(dbgWindow);
     let bindings = helpers.sandbox;
     if (bindSelf) {
       bindings._self = bindSelf;
     }
 
     if (aOptions.selectedNodeActor) {
       let actor = this.conn.getActor(aOptions.selectedNodeActor);
       if (actor) {
         helpers.selectedNode = actor.rawNode;
       }
     }
 
     // Check if the Debugger.Frame or Debugger.Object for the global include
-    // $ or $$. We will not overwrite these functions with the jsterm helpers.
+    // $ or $$. We will not overwrite these functions with the Web Console
+    // commands.
     let found$ = false, found$$ = false;
     if (frame) {
       let env = frame.environment;
       if (env) {
         found$ = !!env.find("$");
         found$$ = !!env.find("$$");
       }
     }
diff --git a/toolkit/devtools/webconsole/test/chrome.ini b/toolkit/devtools/webconsole/test/chrome.ini
--- a/toolkit/devtools/webconsole/test/chrome.ini
+++ b/toolkit/devtools/webconsole/test/chrome.ini
@@ -6,16 +6,17 @@ support-files =
   data.json
   data.json^headers^
   network_requests_iframe.html
   sandboxed_iframe.html
 
 [test_basics.html]
 [test_bug819670_getter_throws.html]
 [test_cached_messages.html]
+[test_commands_registration.html]
 [test_consoleapi.html]
 [test_consoleapi_innerID.html]
 [test_file_uri.html]
 [test_reflow.html]
 [test_jsterm.html]
 [test_jsterm_cd_iframe.html]
 [test_jsterm_last_result.html]
 [test_network_get.html]
diff --git a/toolkit/devtools/webconsole/test/test_commands_registration.html b/toolkit/devtools/webconsole/test/test_commands_registration.html
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/webconsole/test/test_commands_registration.html
@@ -0,0 +1,160 @@
+<!DOCTYPE HTML>
+<html lang="en">
+<head>
+  <meta charset="utf8">
+  <title>Test for Web Console commands registration.</title>
+  <script type="text/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript;version=1.8" src="common.js"></script>
+  <!-- Any copyright is dedicated to the Public Domain.
+     - http://creativecommons.org/publicdomain/zero/1.0/ -->
+</head>
+<body>
+<p>Test for Web Console commands registration.</p>
+<p id="quack"></p>
+
+<script class="testbody" type="text/javascript;version=1.8">
+SimpleTest.waitForExplicitFinish();
+
+let gState;
+let tests;
+
+let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+let { WebConsoleCommands } = devtools.require("devtools/toolkit/webconsole/utils");
+
+let evaluatingSync = true;
+function evaluateJS(input) {
+  return new Promise((resolve) => gState.client.evaluateJS(input, resolve));
+}
+
+function startTest()
+{
+  removeEventListener("load", startTest);
+
+  attachConsole(["PageError"], onAttach, true);
+}
+
+function onAttach(aState, aResponse)
+{
+  gState = aState;
+
+  runTests(tests, testEnd);
+}
+
+tests = [
+  Task.async(function* registerNewCommand() {
+    let win;
+    WebConsoleCommands.register("setFoo", (owner, value) => {
+      owner.window.foo = value;
+      return "ok";
+    });
+
+    ok(WebConsoleCommands.hasCommand("setFoo"),
+        "The command should be registered");
+
+    let command = "setFoo('bar')";
+    let response = yield evaluateJS(command);
+
+    checkObject(response, {
+      from: gState.actor,
+      input: command,
+      result: "ok"
+    });
+    is(top.foo, "bar", "top.foo should equal to 'bar'");
+    nextTest();
+  }),
+
+  Task.async(function* wrapCommand() {
+    let origKeys = WebConsoleCommands.getCommand("keys");
+
+    let newKeys = (...args) => {
+      let [owner, arg0] = args;
+      if (arg0 === ">o_/") {
+        return "bang!";
+      }
+      else {
+        return origKeys(...args);
+      }
+    };
+
+    WebConsoleCommands.register("keys", newKeys);
+    is(WebConsoleCommands.getCommand("keys"), newKeys,
+        "the keys() command should have been replaced");
+
+    let response = yield evaluateJS("keys('>o_/')");
+    checkObject(response, {
+      from: gState.actor,
+      result: "bang!"
+    });
+
+    response = yield evaluateJS("keys({foo: 'bar'})");
+    checkObject(response, {
+      from: gState.actor,
+      result: {
+        class: "Array",
+        preview: {
+          items: ["foo"]
+        }
+      }
+    });
+
+    WebConsoleCommands.register("keys", origKeys);
+    is(WebConsoleCommands.getCommand("keys"), origKeys,
+      "the keys() command should be restored");
+    nextTest();
+  }),
+
+  Task.async(function* unregisterCommand() {
+    WebConsoleCommands.unregister("setFoo");
+
+    let response = yield evaluateJS("setFoo");
+
+    checkObject(response, {
+      from: gState.actor,
+      input: "setFoo",
+      result: {
+        type: "undefined"
+      },
+      exceptionMessage: /setFoo is not defined/
+    });
+    nextTest();
+  }),
+
+  Task.async(function* registerAccessor() {
+    WebConsoleCommands.register("$foo", {
+      get(owner) {
+        let foo = owner.window.frames[0].window.document.getElementById("quack");
+        return owner.makeDebuggeeValue(foo);
+      }
+    });
+    let command = "$foo.textContent = '>o_/'";
+    let response = yield evaluateJS(command);
+
+    checkObject(response, {
+      from: gState.actor,
+      input: command,
+      result: ">o_/"
+    });
+    is(document.getElementById("quack").textContent, ">o_/",
+        "#foo textContent should equal to \">o_/\"");
+    WebConsoleCommands.unregister("$foo");
+    ok(!WebConsoleCommands.hasCommand("$foo"), "$foo should be unregistered");
+    nextTest();
+  })
+];
+
+function testEnd()
+{
+  // If this is the first run, reload the page and do it again.
+  // Otherwise, end the test.
+  delete top.foo;
+  closeDebugger(gState, function() {
+    gState = null;
+    SimpleTest.finish();
+  });
+}
+
+addEventListener("load", startTest);
+</script>
+</body>
+</html>
+
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -9,17 +9,17 @@
 const {Cc, Ci, Cu, components} = require("chrome");
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyImporter(this, "Services", "resource://gre/modules/Services.jsm");
 loader.lazyImporter(this, "LayoutHelpers", "resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 // TODO: Bug 842672 - toolkit/ imports modules from browser/.
-// Note that these are only used in JSTermHelpers, see $0 and pprint().
+// Note that these are only used in WebConsoleCommands, see $0 and pprint().
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "devtools", "resource://gre/modules/devtools/Loader.jsm");
 loader.lazyImporter(this, "VariablesView", "resource:///modules/devtools/VariablesView.jsm");
 loader.lazyImporter(this, "DevToolsUtils", "resource://gre/modules/devtools/DevToolsUtils.jsm");
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
@@ -27,17 +27,17 @@ loader.lazyImporter(this, "DevToolsUtils
 // function foobar2(a) { ...
 // function() { ...
 const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;
 
 // Match the function arguments from the result of toString() or toSource().
 const REGEX_MATCH_FUNCTION_ARGS = /^\(?function\s*[^\s(]*\s*\((.+?)\)/;
 
 // Number of terminal entries for the self-xss prevention to go away
-const CONSOLE_ENTRY_THRESHOLD = 5
+const CONSOLE_ENTRY_THRESHOLD = 5;
 
 // Provide an easy way to bail out of even attempting an autocompletion
 // if an object has way too many properties. Protects against large objects
 // with numeric values that wouldn't be tallied towards MAX_AUTOCOMPLETIONS.
 const MAX_AUTOCOMPLETE_ATTEMPTS = exports.MAX_AUTOCOMPLETE_ATTEMPTS = 100000;
 
 // Prevent iterating over too many properties during autocomplete suggestions.
 const MAX_AUTOCOMPLETIONS = exports.MAX_AUTOCOMPLETIONS = 1500;
@@ -545,17 +545,17 @@ let WebConsoleUtils = {
    * Value of devtools.selfxss.count preference
    *
    * @type number
    * @private
    */
   _usageCount: 0,
   get usageCount() {
     if (WebConsoleUtils._usageCount < CONSOLE_ENTRY_THRESHOLD) {
-      WebConsoleUtils._usageCount = Services.prefs.getIntPref("devtools.selfxss.count")
+      WebConsoleUtils._usageCount = Services.prefs.getIntPref("devtools.selfxss.count");
       if (Services.prefs.getBoolPref("devtools.chrome.enabled")) {
         WebConsoleUtils.usageCount = CONSOLE_ENTRY_THRESHOLD;
       }
     }
     return WebConsoleUtils._usageCount;
   },
   set usageCount(newUC) {
     if (newUC <= CONSOLE_ENTRY_THRESHOLD) {
@@ -907,17 +907,17 @@ function JSPropertyProvider(aDbgObject, 
   // We get the rest of the properties recursively starting from the Debugger.Object
   // that wraps the first property
   for (let prop of properties) {
     prop = prop.trim();
     if (!prop) {
       return null;
     }
 
-    if (/\[\d+\]$/.test(prop)) {
+    if (/\[\d+\]$/.test(prop)) {
       // The property to autocomplete is a member of array. For example
       // list[i][j]..[n]. Traverse the array to get the actual element.
       obj = getArrayMemberProperty(obj, prop);
     }
     else {
       obj = DevToolsUtils.getProperty(obj, prop);
     }
 
@@ -1502,317 +1502,416 @@ ConsoleAPIListener.prototype =
    */
   destroy: function CAL_destroy()
   {
     Services.obs.removeObserver(this, "console-api-log-event");
     this.window = this.owner = null;
   },
 };
 
+/**
+ * WebConsole commands manager.
+ *
+ * Defines a set of functions /variables ("commands") that are available from
+ * the Web Console but not from the web page.
+ *
+ */
+let WebConsoleCommands = {
+  _registeredCommands: new Map(),
 
+  /**
+   * Register a new command.
+   * @param {string} name The command name (exemple: "$")
+   * @param {(function|object)} command The command to register.
+   *  It can be a function so the command is a function (like "$()"),
+   *  or it can also be a property descriptor to describe a getter / value (like
+   *  "$0").
+   *
+   *  The command function or the command getter are passed a owner object as
+   *  their first parameter (see the example below).
+   *
+   *  Note that setters don't work currently and "enumerable" and "configurable"
+   *  are forced to true.
+   *
+   * @example
+   *
+   *   WebConsoleCommands.register("$", function JSTH_$(aOwner, aSelector)
+   *   {
+   *     return aOwner.window.document.querySelector(aSelector);
+   *   });
+   *
+   *   WebConsoleCommands.register("$0", {
+   *     get: function(aOwner) {
+   *       return aOwner.makeDebuggeeValue(aOwner.selectedNode);
+   *     }
+   *   });
+   */
+  register: function(name, command) {
+    this._registeredCommands.set(name, command);
+  },
+
+  /**
+   * Unregister a command.
+   *
+   * @param {string} name The name of the command
+   */
+  unregister: function(name) {
+    this._registeredCommands.delete(name);
+  },
+
+  /**
+   * Returns a command by its name.
+   *
+   * @param {string} name The name of the command.
+   *
+   * @return {(function|object)} The command.
+   */
+  getCommand: function(name) {
+    return this._registeredCommands.get(name);
+  },
+
+  /**
+   * Returns true if a command is registered with the given name.
+   *
+   * @param {string} name The name of the command.
+   *
+   * @return {boolean} True if the command is registered.
+   */
+  hasCommand: function(name) {
+    return this._registeredCommands.has(name);
+  },
+};
+
+exports.WebConsoleCommands = WebConsoleCommands;
+
+
+/*
+ * Built-in commands.
+  *
+  * A list of helper functions used by Firebug can be found here:
+  *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ */
 
 /**
- * JSTerm helper functions.
+ * Find a node by ID.
  *
- * Defines a set of functions ("helper functions") that are available from the
- * Web Console but not from the web page.
+ * @param string aId
+ *        The ID of the element you want.
+ * @return nsIDOMNode or null
+ *         The result of calling document.querySelector(aSelector).
+ */
+WebConsoleCommands.register("$", function JSTH_$(aOwner, aSelector)
+{
+  return aOwner.window.document.querySelector(aSelector);
+});
+
+/**
+ * Find the nodes matching a CSS selector.
  *
- * A list of helper functions used by Firebug can be found here:
- *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ * @param string aSelector
+ *        A string that is passed to window.document.querySelectorAll.
+ * @return nsIDOMNodeList
+ *         Returns the result of document.querySelectorAll(aSelector).
+ */
+WebConsoleCommands.register("$$", function JSTH_$$(aOwner, aSelector)
+{
+  return aOwner.window.document.querySelectorAll(aSelector);
+});
+
+/**
+ * Returns the result of the last console input evaluation
  *
- * @param object aOwner
- *        The owning object.
+ * @return object|undefined
+ * Returns last console evaluation or undefined
  */
-function JSTermHelpers(aOwner)
+WebConsoleCommands.register("$_", {
+  get: function(aOwner) {
+    return aOwner.consoleActor.getLastConsoleInputEvaluation();
+  }
+});
+
+
+/**
+ * Runs an xPath query and returns all matched nodes.
+ *
+ * @param string aXPath
+ *        xPath search query to execute.
+ * @param [optional] nsIDOMNode aContext
+ *        Context to run the xPath query on. Uses window.document if not set.
+ * @return array of nsIDOMNode
+ */
+WebConsoleCommands.register("$x", function JSTH_$x(aOwner, aXPath, aContext)
 {
-  /**
-   * Find a node by ID.
-   *
-   * @param string aId
-   *        The ID of the element you want.
-   * @return nsIDOMNode or null
-   *         The result of calling document.querySelector(aSelector).
-   */
-  aOwner.sandbox.$ = function JSTH_$(aSelector)
-  {
-    return aOwner.window.document.querySelector(aSelector);
+  let nodes = new aOwner.window.wrappedJSObject.Array();
+  let doc = aOwner.window.document;
+  aContext = aContext || doc;
+
+  let results = doc.evaluate(aXPath, aContext, null,
+                             Ci.nsIDOMXPathResult.ANY_TYPE, null);
+  let node;
+  while ((node = results.iterateNext())) {
+    nodes.push(node);
+  }
+
+  return nodes;
+});
+
+/**
+ * Returns the currently selected object in the highlighter.
+ *
+ * @return Object representing the current selection in the
+ *         Inspector, or null if no selection exists.
+ */
+WebConsoleCommands.register("$0", {
+  get: function(aOwner) {
+    return aOwner.makeDebuggeeValue(aOwner.selectedNode);
+  }
+});
+
+/**
+ * Clears the output of the WebConsole.
+ */
+WebConsoleCommands.register("clear", function JSTH_clear(aOwner)
+{
+  aOwner.helperResult = {
+    type: "clearOutput",
   };
+});
 
-  /**
-   * Find the nodes matching a CSS selector.
-   *
-   * @param string aSelector
-   *        A string that is passed to window.document.querySelectorAll.
-   * @return nsIDOMNodeList
-   *         Returns the result of document.querySelectorAll(aSelector).
-   */
-  aOwner.sandbox.$$ = function JSTH_$$(aSelector)
-  {
-    return aOwner.window.document.querySelectorAll(aSelector);
+/**
+ * Clears the input history of the WebConsole.
+ */
+WebConsoleCommands.register("clearHistory", function JSTH_clearHistory(aOwner)
+{
+  aOwner.helperResult = {
+    type: "clearHistory",
   };
+});
 
-  /**
-   * Returns the result of the last console input evaluation
-   *
-   * @return object|undefined
-   * Returns last console evaluation or undefined
-   */
-  Object.defineProperty(aOwner.sandbox, "$_", {
-    get: function() {
-      return aOwner.consoleActor.getLastConsoleInputEvaluation();
-    },
-    enumerable: true,
-    configurable: true
-  });
+/**
+ * Returns the result of Object.keys(aObject).
+ *
+ * @param object aObject
+ *        Object to return the property names from.
+ * @return array of strings
+ */
+WebConsoleCommands.register("keys", function JSTH_keys(aOwner, aObject)
+{
+  return aOwner.window.wrappedJSObject.Object.keys(WebConsoleUtils.unwrap(aObject));
+});
 
-  /**
-   * Runs an xPath query and returns all matched nodes.
-   *
-   * @param string aXPath
-   *        xPath search query to execute.
-   * @param [optional] nsIDOMNode aContext
-   *        Context to run the xPath query on. Uses window.document if not set.
-   * @return array of nsIDOMNode
-   */
-  aOwner.sandbox.$x = function JSTH_$x(aXPath, aContext)
-  {
-    let nodes = new aOwner.window.wrappedJSObject.Array();
-    let doc = aOwner.window.document;
-    aContext = aContext || doc;
+/**
+ * Returns the values of all properties on aObject.
+ *
+ * @param object aObject
+ *        Object to display the values from.
+ * @return array of string
+ */
+WebConsoleCommands.register("values", function JSTH_values(aOwner, aObject)
+{
+  let arrValues = new aOwner.window.wrappedJSObject.Array();
+  let obj = WebConsoleUtils.unwrap(aObject);
 
-    let results = doc.evaluate(aXPath, aContext, null,
-                               Ci.nsIDOMXPathResult.ANY_TYPE, null);
-    let node;
-    while ((node = results.iterateNext())) {
-      nodes.push(node);
+  for (let prop in obj) {
+    arrValues.push(obj[prop]);
+  }
+
+  return arrValues;
+});
+
+/**
+ * Opens a help window in MDN.
+ */
+WebConsoleCommands.register("help", function JSTH_help(aOwner)
+{
+  aOwner.helperResult = { type: "help" };
+});
+
+/**
+ * Change the JS evaluation scope.
+ *
+ * @param DOMElement|string|window aWindow
+ *        The window object to use for eval scope. This can be a string that
+ *        is used to perform document.querySelector(), to find the iframe that
+ *        you want to cd() to. A DOMElement can be given as well, the
+ *        .contentWindow property is used. Lastly, you can directly pass
+ *        a window object. If you call cd() with no arguments, the current
+ *        eval scope is cleared back to its default (the top window).
+ */
+WebConsoleCommands.register("cd", function JSTH_cd(aOwner, aWindow)
+{
+  if (!aWindow) {
+    aOwner.consoleActor.evalWindow = null;
+    aOwner.helperResult = { type: "cd" };
+    return;
+  }
+
+  if (typeof aWindow == "string") {
+    aWindow = aOwner.window.document.querySelector(aWindow);
+  }
+  if (aWindow instanceof Ci.nsIDOMElement && aWindow.contentWindow) {
+    aWindow = aWindow.contentWindow;
+  }
+  if (!(aWindow instanceof Ci.nsIDOMWindow)) {
+    aOwner.helperResult = { type: "error", message: "cdFunctionInvalidArgument" };
+    return;
+  }
+
+  aOwner.consoleActor.evalWindow = aWindow;
+  aOwner.helperResult = { type: "cd" };
+});
+
+/**
+ * Inspects the passed aObject. This is done by opening the PropertyPanel.
+ *
+ * @param object aObject
+ *        Object to inspect.
+ */
+WebConsoleCommands.register("inspect", function JSTH_inspect(aOwner, aObject)
+{
+  let dbgObj = aOwner.makeDebuggeeValue(aObject);
+  let grip = aOwner.createValueGrip(dbgObj);
+  aOwner.helperResult = {
+    type: "inspectObject",
+    input: aOwner.evalInput,
+    object: grip,
+  };
+});
+
+/**
+ * Prints aObject to the output.
+ *
+ * @param object aObject
+ *        Object to print to the output.
+ * @return string
+ */
+WebConsoleCommands.register("pprint", function JSTH_pprint(aOwner, aObject)
+{
+  if (aObject === null || aObject === undefined || aObject === true ||
+      aObject === false) {
+    aOwner.helperResult = {
+      type: "error",
+      message: "helperFuncUnsupportedTypeError",
+    };
+    return null;
+  }
+
+  aOwner.helperResult = { rawOutput: true };
+
+  if (typeof aObject == "function") {
+    return aObject + "\n";
+  }
+
+  let output = [];
+
+  let obj = WebConsoleUtils.unwrap(aObject);
+  for (let name in obj) {
+    let desc = WebConsoleUtils.getPropertyDescriptor(obj, name) || {};
+    if (desc.get || desc.set) {
+      // TODO: Bug 842672 - toolkit/ imports modules from browser/.
+      let getGrip = VariablesView.getGrip(desc.get);
+      let setGrip = VariablesView.getGrip(desc.set);
+      let getString = VariablesView.getString(getGrip);
+      let setString = VariablesView.getString(setGrip);
+      output.push(name + ":", "  get: " + getString, "  set: " + setString);
     }
+    else {
+      let valueGrip = VariablesView.getGrip(obj[name]);
+      let valueString = VariablesView.getString(valueGrip);
+      output.push(name + ": " + valueString);
+    }
+  }
 
-    return nodes;
+  return "  " + output.join("\n  ");
+});
+
+/**
+ * Print the String representation of a value to the output, as-is.
+ *
+ * @param any aValue
+ *        A value you want to output as a string.
+ * @return void
+ */
+WebConsoleCommands.register("print", function JSTH_print(aOwner, aValue)
+{
+  aOwner.helperResult = { rawOutput: true };
+  if (typeof aValue === "symbol") {
+    return Symbol.prototype.toString.call(aValue);
+  }
+  // Waiving Xrays here allows us to see a closer representation of the
+  // underlying object. This may execute arbitrary content code, but that
+  // code will run with content privileges, and the result will be rendered
+  // inert by coercing it to a String.
+  return String(Cu.waiveXrays(aValue));
+});
+
+/**
+ * Copy the String representation of a value to the clipboard.
+ *
+ * @param any aValue
+ *        A value you want to copy as a string.
+ * @return void
+ */
+WebConsoleCommands.register("copy", function JSTH_copy(aOwner, aValue)
+{
+  let payload;
+  try {
+    if (aValue instanceof Ci.nsIDOMElement) {
+      payload = aValue.outerHTML;
+    } else if (typeof aValue == "string") {
+      payload = aValue;
+    } else {
+      payload = JSON.stringify(aValue, null, "  ");
+    }
+  } catch (ex) {
+    payload = "/* " + ex  + " */";
+  }
+  aOwner.helperResult = {
+    type: "copyValueToClipboard",
+    value: payload,
   };
+});
 
-  /**
-   * Returns the currently selected object in the highlighter.
-   *
-   * @return Object representing the current selection in the
-   *         Inspector, or null if no selection exists.
-   */
-  Object.defineProperty(aOwner.sandbox, "$0", {
-    get: function() {
-      return aOwner.makeDebuggeeValue(aOwner.selectedNode)
-    },
-    enumerable: true,
-    configurable: true
-  });
 
-  /**
-   * Clears the output of the JSTerm.
-   */
-  aOwner.sandbox.clear = function JSTH_clear()
-  {
-    aOwner.helperResult = {
-      type: "clearOutput",
-    };
-  };
+/**
+ * (Internal only) Add the bindings to |owner.sandbox|.
+ * This is intended to be used by the WebConsole actor only.
+  *
+  * @param object aOwner
+  *        The owning object.
+  */
+function addWebConsoleCommands(owner) {
+  if (!owner) {
+    throw new Error("The owner is required");
+  }
+  for (let [name, command] of WebConsoleCommands._registeredCommands) {
+    if (typeof command === "function") {
+      owner.sandbox[name] = command.bind(undefined, owner);
+    }
+    else if (typeof command === "object") {
+      let clone = Object.assign({}, command, {
+        // We force the enumerability and the configurability (so the
+        // WebConsoleActor can reconfigure the property).
+        enumerable: true,
+        configurable: true
+      });
 
-  /**
-   * Clears the input history of the JSTerm.
-   */
-  aOwner.sandbox.clearHistory = function JSTH_clearHistory()
-  {
-    aOwner.helperResult = {
-      type: "clearHistory",
-    };
-  };
+      if (typeof command.get === "function") {
+        clone.get = command.get.bind(undefined, owner);
+      }
+      if (typeof command.set === "function") {
+        clone.set = command.set.bind(undefined, owner);
+      }
 
-  /**
-   * Returns the result of Object.keys(aObject).
-   *
-   * @param object aObject
-   *        Object to return the property names from.
-   * @return array of strings
-   */
-  aOwner.sandbox.keys = function JSTH_keys(aObject)
-  {
-    return aOwner.window.wrappedJSObject.Object.keys(WebConsoleUtils.unwrap(aObject));
-  };
+      Object.defineProperty(owner.sandbox, name, clone);
+    }
+  }
+}
 
-  /**
-   * Returns the values of all properties on aObject.
-   *
-   * @param object aObject
-   *        Object to display the values from.
-   * @return array of string
-   */
-  aOwner.sandbox.values = function JSTH_values(aObject)
-  {
-    let arrValues = new aOwner.window.wrappedJSObject.Array();
-    let obj = WebConsoleUtils.unwrap(aObject);
-
-    for (let prop in obj) {
-      arrValues.push(obj[prop]);
-    }
-
-    return arrValues;
-  };
-
-  /**
-   * Opens a help window in MDN.
-   */
-  aOwner.sandbox.help = function JSTH_help()
-  {
-    aOwner.helperResult = { type: "help" };
-  };
-
-  /**
-   * Change the JS evaluation scope.
-   *
-   * @param DOMElement|string|window aWindow
-   *        The window object to use for eval scope. This can be a string that
-   *        is used to perform document.querySelector(), to find the iframe that
-   *        you want to cd() to. A DOMElement can be given as well, the
-   *        .contentWindow property is used. Lastly, you can directly pass
-   *        a window object. If you call cd() with no arguments, the current
-   *        eval scope is cleared back to its default (the top window).
-   */
-  aOwner.sandbox.cd = function JSTH_cd(aWindow)
-  {
-    if (!aWindow) {
-      aOwner.consoleActor.evalWindow = null;
-      aOwner.helperResult = { type: "cd" };
-      return;
-    }
-
-    if (typeof aWindow == "string") {
-      aWindow = aOwner.window.document.querySelector(aWindow);
-    }
-    if (aWindow instanceof Ci.nsIDOMElement && aWindow.contentWindow) {
-      aWindow = aWindow.contentWindow;
-    }
-    if (!(aWindow instanceof Ci.nsIDOMWindow)) {
-      aOwner.helperResult = { type: "error", message: "cdFunctionInvalidArgument" };
-      return;
-    }
-
-    aOwner.consoleActor.evalWindow = aWindow;
-    aOwner.helperResult = { type: "cd" };
-  };
-
-  /**
-   * Inspects the passed aObject. This is done by opening the PropertyPanel.
-   *
-   * @param object aObject
-   *        Object to inspect.
-   */
-  aOwner.sandbox.inspect = function JSTH_inspect(aObject)
-  {
-    let dbgObj = aOwner.makeDebuggeeValue(aObject);
-    let grip = aOwner.createValueGrip(dbgObj);
-    aOwner.helperResult = {
-      type: "inspectObject",
-      input: aOwner.evalInput,
-      object: grip,
-    };
-  };
-
-  /**
-   * Prints aObject to the output.
-   *
-   * @param object aObject
-   *        Object to print to the output.
-   * @return string
-   */
-  aOwner.sandbox.pprint = function JSTH_pprint(aObject)
-  {
-    if (aObject === null || aObject === undefined || aObject === true ||
-        aObject === false) {
-      aOwner.helperResult = {
-        type: "error",
-        message: "helperFuncUnsupportedTypeError",
-      };
-      return null;
-    }
-
-    aOwner.helperResult = { rawOutput: true };
-
-    if (typeof aObject == "function") {
-      return aObject + "\n";
-    }
-
-    let output = [];
-
-    let obj = WebConsoleUtils.unwrap(aObject);
-    for (let name in obj) {
-      let desc = WebConsoleUtils.getPropertyDescriptor(obj, name) || {};
-      if (desc.get || desc.set) {
-        // TODO: Bug 842672 - toolkit/ imports modules from browser/.
-        let getGrip = VariablesView.getGrip(desc.get);
-        let setGrip = VariablesView.getGrip(desc.set);
-        let getString = VariablesView.getString(getGrip);
-        let setString = VariablesView.getString(setGrip);
-        output.push(name + ":", "  get: " + getString, "  set: " + setString);
-      }
-      else {
-        let valueGrip = VariablesView.getGrip(obj[name]);
-        let valueString = VariablesView.getString(valueGrip);
-        output.push(name + ": " + valueString);
-      }
-    }
-
-    return "  " + output.join("\n  ");
-  };
-
-  /**
-   * Print the String representation of a value to the output, as-is.
-   *
-   * @param any aValue
-   *        A value you want to output as a string.
-   * @return void
-   */
-  aOwner.sandbox.print = function JSTH_print(aValue)
-  {
-    aOwner.helperResult = { rawOutput: true };
-    if (typeof aValue === "symbol") {
-      return Symbol.prototype.toString.call(aValue);
-    }
-    // Waiving Xrays here allows us to see a closer representation of the
-    // underlying object. This may execute arbitrary content code, but that
-    // code will run with content privileges, and the result will be rendered
-    // inert by coercing it to a String.
-    return String(Cu.waiveXrays(aValue));
-  };
-
-  /**
-   * Copy the String representation of a value to the clipboard.
-   *
-   * @param any aValue
-   *        A value you want to copy as a string.
-   * @return void
-   */
-  aOwner.sandbox.copy = function JSTH_copy(aValue)
-  {
-    let payload;
-    try {
-      if (aValue instanceof Ci.nsIDOMElement) {
-        payload = aValue.outerHTML;
-      } else if (typeof aValue == "string") {
-        payload = aValue;
-      } else {
-        payload = JSON.stringify(aValue, null, "  ");
-      }
-    } catch (ex) {
-      payload = "/* " + ex  + " */";
-    }
-    aOwner.helperResult = {
-      type: "copyValueToClipboard",
-      value: payload,
-    };
-  };
-}
-exports.JSTermHelpers = JSTermHelpers;
-
+exports.addWebConsoleCommands = addWebConsoleCommands;
 
 /**
  * A ReflowObserver that listens for reflow events from the page.
  * Implements nsIReflowObserver.
  *
  * @constructor
  * @param object aWindow
  *        The window for which we need to track reflow.
