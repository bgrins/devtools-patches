diff --git a/devtools/client/debugger/test/mochitest/browser_dbg_worker-console-02.js b/devtools/client/debugger/test/mochitest/browser_dbg_worker-console-02.js
index de4e473..b6e8d12 100644
--- a/devtools/client/debugger/test/mochitest/browser_dbg_worker-console-02.js
+++ b/devtools/client/debugger/test/mochitest/browser_dbg_worker-console-02.js
@@ -38,19 +38,18 @@ add_task(function* testWhilePaused() {
 
   info("Trying to get the result of command2");
   executed = yield command2;
   ok(executed.textContent.includes("10003"),
       "command2 executed successfully");
 
   info("Trying to get the result of command3");
   executed = yield command3;
-  // XXXworkers This is failing until Bug 1215120 is resolved.
-  todo(executed.textContent.includes("ReferenceError: foobar is not defined"),
-      "command3 executed successfully");
+  ok(executed.textContent.includes("ReferenceError: foobar is not defined"),
+     "command3 executed successfully");
 
   let onceResumed = gTarget.once("thread-resumed");
   EventUtils.sendMouseEvent({ type: "mousedown" }, gResumeButton, gDebugger);
   yield onceResumed;
 
   terminateWorkerInTab(tab, WORKER_URL);
   yield waitForWorkerClose(workerClient);
   yield gDevTools.closeToolbox(TargetFactory.forWorker(workerClient));
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
index 0d5583a..41b992d 100644
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -892,27 +892,31 @@ WebConsoleActor.prototype =
     let result, errorDocURL, errorMessage, errorGrip = null;
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
         let error = evalResult.throw;
+
         errorGrip = this.createValueGrip(error);
-        // XXXworkers: Calling unsafeDereference() returns an object with no
-        // toString method in workers. See Bug 1215120.
-        let unsafeDereference = error && (typeof error === "object") &&
-                                error.unsafeDereference();
-        errorMessage = unsafeDereference && unsafeDereference.toString
-          ? unsafeDereference.toString()
-          : String(error);
-
-          // It is possible that we won't have permission to unwrap an
-          // object and retrieve its errorMessageName.
+
+        errorMessage = String(error);
+        if (typeof error === "object" && error !== null) {
+          try {
+            errorMessage = DevToolsUtils.callPropertyOnObject(error, "toString");
+          } catch (e) {
+            // If we failed to call the "toString" property on the object, we
+            // can just leave the error message unchanged.
+          }
+        }
+
+        // It is possible that we won't have permission to unwrap an
+        // object and retrieve its errorMessageName.
         try {
           errorDocURL = ErrorDocs.GetURL(error);
         } catch (ex) {}
       }
     }
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
diff --git a/devtools/shared/DevToolsUtils.js b/devtools/shared/DevToolsUtils.js
index 10e6bcc..b32f6cd 100644
--- a/devtools/shared/DevToolsUtils.js
+++ b/devtools/shared/DevToolsUtils.js
@@ -613,8 +613,48 @@ function errorOnFlag(exports, name) {
       throw new Error(msg);
     }
   });
 }
 
 errorOnFlag(exports, "testing");
 errorOnFlag(exports, "wantLogging");
 errorOnFlag(exports, "wantVerbose");
+
+// Calls the property with the given `name` on the given `object`, where
+// `name` is a string, and `object` a Debugger.Object instance.
+///
+// This function uses only the Debugger.Object API to call the property. It
+// avoids the use of unsafeDeference. This is useful for example in workers,
+// where unsafeDereference will return an opaque security wrapper to the
+// referent.
+function callPropertyOnObject(object, name) {
+  // Find the property.
+  let descriptor;
+  let proto = object;
+  do {
+    descriptor = proto.getOwnPropertyDescriptor(name);
+    if (descriptor !== undefined) {
+      break;
+    }
+    proto = proto.proto;
+  } while (proto !== null);
+  if (descriptor === undefined) {
+    throw new Error("No such property");
+  }
+  let value = descriptor.value;
+  if (typeof value !== "object" || value === null || !("callable" in value)) {
+    throw new Error("Not a callable object.");
+  }
+
+  // Call the property.
+  let result = value.call(object);
+  if (result === null) {
+    throw new Error("Code was terminated.");
+  }
+  if ("throw" in result) {
+    throw result.throw;
+  }
+  return result.return;
+}
+
+
+exports.callPropertyOnObject = callPropertyOnObject;
