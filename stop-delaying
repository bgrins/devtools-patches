# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7a4bbe6968f8f36ebc7e10feba5c31f2d473768b

diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -21,17 +21,17 @@ class MozBrowser extends MozElementMixin
   static get observedAttributes() {
     return ["remote"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     // When we have already been set up via connectedCallback and the
     // and the [remote] value changes, we need to start over. This used
     // to happen due to a XBL binding change.
-    if (name === "remote" && oldValue != newValue && this.isConnectedAndReady) {
+    if (name === "remote" && oldValue != newValue && this.isConnected) {
       this.destroy();
       this.construct();
     }
   }
 
   constructor() {
     super();
 
@@ -296,23 +296,16 @@ class MozBrowser extends MozElementMixin
     this._autoScrollScrollId = null;
 
     this._autoScrollPresShellId = null;
 
     this._permitUnloadId = 0;
   }
 
   connectedCallback() {
-    // We typically use this to avoid running JS that triggers a layout during parse
-    // (see comment on the delayConnectedCallback implementation). In this case, we
-    // are using it to avoid a leak - see https://bugzilla.mozilla.org/show_bug.cgi?id=1441935#c20.
-    if (this.delayConnectedCallback()) {
-      return;
-    }
-
     this.construct();
   }
 
   disconnectedCallback() {
     this.destroy();
   }
 
   get autoscrollEnabled() {
