# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1536773841 25200
#      Wed Sep 12 10:37:21 2018 -0700
# Node ID 19b3a5ff951d1e1b03936e56e084d942aca389e9
# Parent  0b1de782bd32ee277ad609c2bbe7e35b8a003ee7
Bug 1448213 - Migrate label-control to a Custom Element

Differential Revision: https://phabricator.services.mozilla.com/D5686

diff --git a/dom/tests/mochitest/chrome/test_elements_proto.xul b/dom/tests/mochitest/chrome/test_elements_proto.xul
--- a/dom/tests/mochitest/chrome/test_elements_proto.xul
+++ b/dom/tests/mochitest/chrome/test_elements_proto.xul
@@ -11,21 +11,19 @@
 
   <script type="application/javascript">
   <![CDATA[
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     SimpleTest.waitForExplicitFinish();
 
     addLoadEvent(() => {
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "label")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "label") instanceof XULTextElement,
         `<label> should be of XULTextElement type`);
 
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "description")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "description") instanceof XULTextElement,
         `<description> should be of XULTextElement type`);
 
       SimpleTest.finish();
     });
   ]]>
   </script>
 </window>
diff --git a/layout/reftests/xul/reftest.list b/layout/reftests/xul/reftest.list
--- a/layout/reftests/xul/reftest.list
+++ b/layout/reftests/xul/reftest.list
@@ -1,17 +1,17 @@
 == css-flex-1.xul css-flex-1-ref.html
 
 == menuitem-key.xul menuitem-key-ref.xul
 # these random-if(Android) are due to differences between Android Native & Xul, see bug 732569
 random-if(Android) == menulist-shrinkwrap-1.xul menulist-shrinkwrap-1-ref.xul
 random-if(Android) == menulist-shrinkwrap-2.xul menulist-shrinkwrap-2-ref.xul
 == textbox-overflow-1.xul textbox-overflow-1-ref.xul # for bug 749658
-# accesskeys are not normally displayed on Mac, so skip this test
-skip-if(cocoaWidget) == accesskey.xul accesskey-ref.xul
+# accesskeys are not normally displayed on Mac, so set a pref to enable them
+pref(ui.key.menuAccessKey,18) == chrome://reftest/content/xul/accesskey.xul accesskey-ref.xul
 pref(layout.css.xul-tree-pseudos.content.enabled,true) fuzzy-if(xulRuntime.widgetToolkit=="gtk3",0-1,0-11) == tree-row-outline-1.xul tree-row-outline-1-ref.xul # win8: bug 1254832
 skip-if(!cocoaWidget) fails-if(webrender&&cocoaWidget) == mac-tab-toolbar.xul mac-tab-toolbar-ref.xul
 pref(layout.css.xul-tree-pseudos.content.enabled,true) != tree-row-outline-1.xul tree-row-outline-1-notref.xul
 == text-crop.xul text-crop-ref.xul
 random-if(/^Windows\x20NT\x206\.1/.test(http.oscpu)) == text-small-caps-1.xul text-small-caps-1-ref.xul
 fuzzy-if(skiaContent,0-1,0-60) fuzzy-if(cocoaWidget&&browserIsRemote&&!skiaContent,0-1,0-31) fuzzy-if(winWidget&&browserIsRemote&&layersGPUAccelerated,0-1,0-50) fuzzy-if(webrender,0-1,350-1050) == inactive-fixed-bg-bug1205630.xul inactive-fixed-bg-bug1205630-ref.html
 fuzzy-if(skiaContent,0-1,0-60) fuzzy-if(cocoaWidget&&browserIsRemote&&!skiaContent,0-1,0-31) fuzzy-if(winWidget&&browserIsRemote&&layersGPUAccelerated,0-1,0-50) fuzzy-if(webrender,0-1,450-1100) == inactive-fixed-bg-bug1272525.xul inactive-fixed-bg-bug1272525-ref.html
 
diff --git a/layout/tools/reftest/jar.mn b/layout/tools/reftest/jar.mn
--- a/layout/tools/reftest/jar.mn
+++ b/layout/tools/reftest/jar.mn
@@ -1,11 +1,12 @@
 reftest.jar:
   content/moz-bool-pref.css (../../../layout/reftests/css-parsing/moz-bool-pref.css)
   content/osx-theme (../../../toolkit/themes/osx/reftests/*)
+  content/xul (../../../layout/reftests/xul/*)
   content/reftest.xul (reftest.xul)
 
   res/globals.jsm (globals.jsm)
   res/reftest-content.js (reftest-content.js)
   res/AsyncSpellCheckTestHelper.jsm (../../../editor/AsyncSpellCheckTestHelper.jsm)
   res/httpd.jsm (../../../netwerk/test/httpserver/httpd.js)
   res/StructuredLog.jsm (../../../testing/modules/StructuredLog.jsm)
   res/PerTestCoverageUtils.jsm (../../../tools/code-coverage/PerTestCoverageUtils.jsm)
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -773,17 +773,17 @@ nscoord nsTextBoxFrame::CalculateTitleFo
 
 // the following block is to append the accesskey to mTitle if there is an
 // accesskey but the mTitle doesn't have the character
 void nsTextBoxFrame::UpdateAccessTitle() {
   /*
    * Note that if you change appending access key label spec,
    * you need to maintain same logic in following methods. See bug 324159.
    * toolkit/components/prompts/src/CommonDialog.jsm (setLabelForNode)
-   * toolkit/content/widgets/text.xml (formatAccessKey)
+   * toolkit/content/widgets/text.js (formatAccessKey)
    */
   int32_t menuAccessKey;
   nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
   if (!menuAccessKey || mAccessKey.IsEmpty()) return;
 
   if (!AlwaysAppendAccessKey() &&
       FindInReadable(mAccessKey, mTitle, nsCaseInsensitiveStringComparator()))
     return;
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -335,20 +335,16 @@ MozElements.MozElementMixin = Base => {
       if (el) {
         if (attr == "text") {
           el.textContent = value;
         } else if (value) {
           el.setAttribute(attr, value);
         } else {
           el.removeAttribute(attr);
         }
-
-        if (attr == "accesskey" && el.formatAccessKey) {
-          el.formatAccessKey(false);
-        }
       }
     }
   }
 
   /**
    * Sometimes an element may not want to run connectedCallback logic during
    * parse. This could be because we don't want to initialize the element before
    * the element's contents have been fully parsed, or for performance reasons.
@@ -644,28 +640,28 @@ if (!isDummyDocument) {
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/popupnotification.js",
     "chrome://global/content/elements/radio.js",
     "chrome://global/content/elements/richlistbox.js",
     "chrome://global/content/elements/autocomplete-popup.js",
     "chrome://global/content/elements/autocomplete-richlistitem.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
+    "chrome://global/content/elements/text.js",
     "chrome://global/content/elements/tree.js",
     "chrome://global/content/elements/wizard.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
   for (let [tag, script] of [
     ["findbar", "chrome://global/content/elements/findbar.js"],
     ["menulist", "chrome://global/content/elements/menulist.js"],
     ["stringbundle", "chrome://global/content/elements/stringbundle.js"],
     ["printpreview-toolbar", "chrome://global/content/printPreviewToolbar.js"],
     ["editor", "chrome://global/content/elements/editor.js"],
-    ["text-link", "chrome://global/content/elements/text.js"],
   ]) {
     customElements.setElementCreationCallback(tag, () => {
       Services.scriptloader.loadSubScript(script, window);
     });
   }
 }
 })();
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -70,18 +70,16 @@ toolkit.jar:
 *  content/global/bindings/dialog.xml          (widgets/dialog.xml)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/menu.xml            (widgets/menu.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
    content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
-   content/global/bindings/text.xml            (widgets/text.xml)
-   content/global/elements/text.js             (widgets/text.js)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/autocomplete-popup.js              (widgets/autocomplete-popup.js)
    content/global/elements/autocomplete-richlistitem.js       (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
@@ -97,16 +95,17 @@ toolkit.jar:
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
    content/global/elements/marquee.js          (widgets/marquee.js)
    content/global/elements/menulist.js         (widgets/menulist.js)
    content/global/elements/popupnotification.js  (widgets/popupnotification.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
+   content/global/elements/text.js             (widgets/text.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
    content/global/elements/wizard.js           (widgets/wizard.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -3,18 +3,265 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
+const MozXULTextElement = MozElements.MozElementMixin(XULTextElement);
+const textContentDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, "textContent");
 
-class MozTextLink extends MozElements.MozElementMixin(XULTextElement) {
+let gInsertSeparator = false;
+let gAlwaysAppendAccessKey = false;
+let gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+if (gUnderlineAccesskey) {
+  try {
+    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
+    const prefNameInsertSeparator =
+      "intl.menuitems.insertseparatorbeforeaccesskeys";
+    const prefNameAlwaysAppendAccessKey =
+      "intl.menuitems.alwaysappendaccesskeys";
+
+    let val = Services.prefs.getComplexValue(prefNameInsertSeparator,
+      nsIPrefLocalizedString).data;
+    gInsertSeparator = val == "true";
+
+    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+      nsIPrefLocalizedString).data;
+    gAlwaysAppendAccessKey = val == "true";
+  } catch (e) {
+    gInsertSeparator = gAlwaysAppendAccessKey = true;
+  }
+}
+
+class MozTextLabel extends MozXULTextElement {
+  constructor() {
+    super();
+    this._lastFormattedAccessKey = null;
+    this.addEventListener("click", this._onClick);
+  }
+
+  static get observedAttributes() {
+    return ["accesskey", "text"];
+  }
+
+  set textContent(val) {
+    textContentDescriptor.set.call(this, val);
+    this._lastFormattedAccessKey = null;
+    this.formatAccessKey();
+  }
+
+  get textContent() {
+    return textContentDescriptor.get.call(this);
+  }
+
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady || oldValue == newValue) {
+      return;
+    }
+
+    // As long as we are still hosted within XBL anonymous content and the [text]
+    // attribute inheritance, we need to handle changes this way, in addition to textContent:
+    if (name == "text") {
+      this._lastFormattedAccessKey = null;
+    }
+
+    // console.log(name, oldValue, newValue, this.textContent);
+    this.formatAccessKey();
+  }
+
+  _onClick(event) {
+    let controlElement = this.labeledControlElement;
+    if (!controlElement || this.disabled) {
+      return;
+    }
+    controlElement.focus();
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+    if (controlElement.namespaceURI != XUL_NS) {
+      return;
+    }
+
+    if ((controlElement.localName == "checkbox" ||
+         controlElement.localName == "radio") &&
+        controlElement.getAttribute("disabled") == "true") {
+      return;
+    }
+
+    if (controlElement.localName == "checkbox") {
+      controlElement.checked = !controlElement.checked;
+    } else if (controlElement.localName == "radio") {
+      controlElement.control.selectedItem = controlElement;
+    }
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    this.formatAccessKey();
+  }
+
+  set accessKey(val) {
+    this.setAttribute("accesskey", val);
+    var control = this.labeledControlElement;
+    if (control) {
+      control.setAttribute("accesskey", val);
+    }
+  }
+
+  get accessKey() {
+    let accessKey = this.getAttribute("accesskey");
+    return accessKey ? accessKey[0] : null;
+  }
+
+  get labeledControlElement() {
+    let control = this.control;
+    return control ? document.getElementById(control) : null;
+  }
+
+  set control(val) {
+    this.setAttribute("control", val);
+  }
+
+  get control() {
+    return this.getAttribute("control");
+  }
+
+  // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
+  // label uses [value]). So this is just for when we have textContent.
+  formatAccessKey() {
+    // Skip doing any DOM manipulation whenever possible:
+    let accessKey = this.accessKey;
+    if (!gUnderlineAccesskey ||
+        !this.isConnectedAndReady ||
+        this._lastFormattedAccessKey == accessKey ||
+        !this.textContent) {
+      return;
+    }
+    this._lastFormattedAccessKey = accessKey;
+    if (this.accessKeySpan) { // Clear old accesskey
+      mergeElement(this.accessKeySpan);
+      this.accessKeySpan = null;
+    }
+
+    if (this.hiddenColon) {
+      mergeElement(this.hiddenColon);
+      this.hiddenColon = null;
+    }
+
+    if (this.accessKeyParens) {
+      this.accessKeyParens.remove();
+      this.accessKeyParens = null;
+    }
+
+    // If we used to have an accessKey but not anymore, we're done here
+    if (!accessKey) {
+      return;
+    }
+
+    let labelText = this.textContent;
+    let accessKeyIndex = -1;
+    if (!gAlwaysAppendAccessKey) {
+      accessKeyIndex = labelText.indexOf(accessKey);
+      if (accessKeyIndex < 0) { // Try again in upper case
+        accessKeyIndex =
+          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+      }
+    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+    }
+
+    const HTML_NS = "http://www.w3.org/1999/xhtml";
+    this.accessKeySpan = document.createElementNS(HTML_NS, "span");
+    this.accessKeySpan.className = "accesskey";
+
+    // Note that if you change the following code, see the comment of
+    // nsTextBoxFrame::UpdateAccessTitle.
+
+    // If accesskey is in the string, underline it:
+    if (accessKeyIndex >= 0) {
+      wrapChar(this, this.accessKeySpan, accessKeyIndex);
+      return;
+    }
+
+    // If accesskey is not in string, append in parentheses
+    // If end is colon, we should insert before colon.
+    // i.e., "label:" -> "label(X):"
+    let colonHidden = false;
+    if (/:$/.test(labelText)) {
+      labelText = labelText.slice(0, -1);
+      this.hiddenColon = document.createElementNS(HTML_NS, "span");
+      this.hiddenColon.className = "hiddenColon";
+      this.hiddenColon.style.display = "none";
+      // Hide the last colon by using span element.
+      // I.e., label<span style="display:none;">:</span>
+      wrapChar(this, this.hiddenColon, labelText.length);
+      colonHidden = true;
+    }
+    // If end is space(U+20),
+    // we should not add space before parentheses.
+    let endIsSpace = false;
+    if (/ $/.test(labelText)) {
+      endIsSpace = true;
+    }
+
+    this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+    this.appendChild(this.accessKeyParens);
+    if (gInsertSeparator && !endIsSpace)
+      this.accessKeyParens.textContent = " (";
+    else
+      this.accessKeyParens.textContent = "(";
+    this.accessKeySpan.textContent = accessKey.toUpperCase();
+    this.accessKeyParens.appendChild(this.accessKeySpan);
+    if (!colonHidden) {
+      this.accessKeyParens.appendChild(document.createTextNode(")"));
+    } else {
+      this.accessKeyParens.appendChild(document.createTextNode("):"));
+    }
+  }
+}
+
+customElements.define("label", MozTextLabel);
+
+function mergeElement(element) {
+  // If the element has been removed already, return:
+  if (!element.isConnected) {
+    return;
+  }
+  if (element.previousSibling instanceof Text) {
+    element.previousSibling.appendData(element.textContent);
+  } else {
+    element.parentNode.insertBefore(element.firstChild, element);
+  }
+  element.remove();
+}
+
+function wrapChar(parent, element, index) {
+  let treeWalker = document.createNodeIterator(parent, NodeFilter.SHOW_TEXT, null);
+  let node = treeWalker.nextNode();
+  while (index >= node.length) {
+    index -= node.length;
+    node = treeWalker.nextNode();
+  }
+  if (index) {
+    node = node.splitText(index);
+  }
+
+  node.parentNode.insertBefore(element, node);
+  if (node.length > 1) {
+    node.splitText(1);
+  }
+  element.appendChild(node);
+}
+
+class MozTextLink extends MozXULTextElement {
   constructor() {
     super();
 
     this.addEventListener("click", (event) => {
       if (event.button == 0 || event.button == 1) {
         this.open(event);
       }
     }, true);
diff --git a/toolkit/content/widgets/text.xml b/toolkit/content/widgets/text.xml
deleted file mode 100644
--- a/toolkit/content/widgets/text.xml
+++ /dev/null
@@ -1,240 +0,0 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-
-<bindings id="textBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:html="http://www.w3.org/1999/xhtml">
-
-  <binding id="label-control">
-    <content>
-      <children/><html:span anonid="accessKeyParens"></html:span>
-    </content>
-    <implementation>
-      <constructor>
-        <![CDATA[
-          this.formatAccessKey(true);
-        ]]>
-      </constructor>
-
-      <method name="formatAccessKey">
-        <parameter name="firstTime"/>
-        <body>
-          <![CDATA[
-            var accessKey = this.accessKey;
-            // No need to remove existing formatting the first time.
-            if (firstTime && !accessKey)
-              return;
-
-            if (this.mInsertSeparator === undefined) {
-              try {
-                var prefs = Cc["@mozilla.org/preferences-service;1"].
-                                       getService(Ci.nsIPrefBranch);
-                this.mUnderlineAccesskey = (prefs.getIntPref("ui.key.menuAccessKey") != 0);
-
-                const nsIPrefLocalizedString =
-                  Ci.nsIPrefLocalizedString;
-
-                const prefNameInsertSeparator =
-                  "intl.menuitems.insertseparatorbeforeaccesskeys";
-                const prefNameAlwaysAppendAccessKey =
-                  "intl.menuitems.alwaysappendaccesskeys";
-
-                var val = prefs.getComplexValue(prefNameInsertSeparator,
-                                                nsIPrefLocalizedString).data;
-                this.mInsertSeparator = (val == "true");
-
-                val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
-                                            nsIPrefLocalizedString).data;
-                this.mAlwaysAppendAccessKey = (val == "true");
-              } catch (e) {
-                this.mInsertSeparator = true;
-              }
-            }
-
-            if (!this.mUnderlineAccesskey)
-              return;
-
-            var afterLabel = document.getAnonymousElementByAttribute(this, "anonid", "accessKeyParens");
-            afterLabel.textContent = "";
-
-            var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
-            if (oldAccessKey) { // Clear old accesskey
-              this.mergeElement(oldAccessKey);
-            }
-
-            var oldHiddenSpan =
-              this.getElementsByAttribute("class", "hiddenColon").item(0);
-            if (oldHiddenSpan) {
-              this.mergeElement(oldHiddenSpan);
-            }
-
-            var labelText = this.textContent;
-            if (!accessKey || !labelText) {
-              return;
-            }
-            var accessKeyIndex = -1;
-            if (!this.mAlwaysAppendAccessKey) {
-              accessKeyIndex = labelText.indexOf(accessKey);
-              if (accessKeyIndex < 0) { // Try again in upper case
-                accessKeyIndex =
-                  labelText.toUpperCase().indexOf(accessKey.toUpperCase());
-              }
-            } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
-              accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
-            }
-
-            const HTML_NS = "http://www.w3.org/1999/xhtml";
-            var span = document.createElementNS(HTML_NS, "span");
-            span.className = "accesskey";
-
-            // Note that if you change the following code, see the comment of
-            // nsTextBoxFrame::UpdateAccessTitle.
-
-            // If accesskey is not in string, append in parentheses
-            if (accessKeyIndex < 0) {
-              // If end is colon, we should insert before colon.
-              // i.e., "label:" -> "label(X):"
-              var colonHidden = false;
-              if (/:$/.test(labelText)) {
-                labelText = labelText.slice(0, -1);
-                var hiddenSpan = document.createElementNS(HTML_NS, "span");
-                hiddenSpan.className = "hiddenColon";
-                hiddenSpan.style.display = "none";
-                // Hide the last colon by using span element.
-                // I.e., label<span style="display:none;">:</span>
-                this.wrapChar(hiddenSpan, labelText.length);
-                colonHidden = true;
-              }
-              // If end is space(U+20),
-              // we should not add space before parentheses.
-              var endIsSpace = false;
-              if (/ $/.test(labelText)) {
-                endIsSpace = true;
-              }
-              if (this.mInsertSeparator && !endIsSpace)
-                afterLabel.textContent = " (";
-              else
-                afterLabel.textContent = "(";
-              span.textContent = accessKey.toUpperCase();
-              afterLabel.appendChild(span);
-              if (!colonHidden)
-                afterLabel.appendChild(document.createTextNode(")"));
-              else
-                afterLabel.appendChild(document.createTextNode("):"));
-              return;
-            }
-            this.wrapChar(span, accessKeyIndex);
-          ]]>
-        </body>
-      </method>
-
-      <method name="wrapChar">
-        <parameter name="element"/>
-        <parameter name="index"/>
-        <body>
-          <![CDATA[
-             var treeWalker = document.createTreeWalker(this,
-                                                        NodeFilter.SHOW_TEXT,
-                                                        null);
-             var node = treeWalker.nextNode();
-             while (index >= node.length) {
-               index -= node.length;
-               node = treeWalker.nextNode();
-             }
-             if (index) {
-               node = node.splitText(index);
-             }
-             node.parentNode.insertBefore(element, node);
-             if (node.length > 1) {
-               node.splitText(1);
-             }
-             element.appendChild(node);
-          ]]>
-        </body>
-      </method>
-
-      <method name="mergeElement">
-        <parameter name="element"/>
-        <body>
-          <![CDATA[
-            if (element.previousSibling instanceof Text) {
-              element.previousSibling.appendData(element.textContent);
-            } else {
-              element.parentNode.insertBefore(element.firstChild, element);
-            }
-            element.remove();
-          ]]>
-        </body>
-      </method>
-
-      <field name="mUnderlineAccesskey">
-        !/Mac/.test(navigator.platform)
-      </field>
-      <field name="mInsertSeparator"/>
-      <field name="mAlwaysAppendAccessKey">false</field>
-
-      <property name="accessKey">
-        <getter>
-          <![CDATA[
-            return this.getAttribute("accesskey");
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            this.setAttribute("accesskey", val);
-            var control = this.labeledControlElement;
-            if (control) {
-              control.setAttribute("accesskey", val);
-            }
-            this.formatAccessKey(false);
-            return val;
-          ]]>
-        </setter>
-      </property>
-
-      <property name="labeledControlElement" readonly="true"
-                onget="var control = this.control; return control ? document.getElementById(control) : null;" />
-
-      <property name="control" onget="return this.getAttribute('control');">
-        <setter>
-          <![CDATA[
-            this.setAttribute("control", val);
-            return val;
-          ]]>
-        </setter>
-      </property>
-    </implementation>
-
-    <handlers>
-      <handler event="click"><![CDATA[
-        if (this.disabled) {
-          return;
-        }
-        var controlElement = this.labeledControlElement;
-        if (!controlElement) {
-          return;
-        }
-        controlElement.focus();
-        const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
-        if (controlElement.namespaceURI != XUL_NS) {
-          return;
-        }
-        if ((controlElement.localName == "checkbox" ||
-             controlElement.localName == "radio") &&
-            controlElement.getAttribute("disabled") == "true") {
-          return;
-        }
-        if (controlElement.localName == "checkbox") {
-          controlElement.checked = !controlElement.checked;
-        } else if (controlElement.localName == "radio") {
-          controlElement.control.selectedItem = controlElement;
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
-</bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -92,24 +92,18 @@ page {
 
 /******** box *******/
 
 vbox {
   -moz-box-orient: vertical;
 }
 
 /********** label **********/
-
 label.text-link, label[onclick] {
   -moz-user-focus: normal;
-  -moz-binding: none;
-}
-
-label[control], label.radio-label, label.checkbox-label, label.toolbarbutton-multiline-text {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#label-control");
 }
 
 label html|span.accesskey {
   text-decoration: underline;
 }
 
 /********** button **********/
 
