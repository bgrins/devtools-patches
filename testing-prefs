# HG changeset patch
# Parent af571b8e561da08cbaf3ee156f2e40eb1e044793
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1098343 - Whitelist devedition prefs to not clear user value when setting to default value

diff --git a/modules/libpref/prefapi.cpp b/modules/libpref/prefapi.cpp
--- a/modules/libpref/prefapi.cpp
+++ b/modules/libpref/prefapi.cpp
@@ -472,17 +472,16 @@ bool PREF_HasUserPref(const char *pref_n
     if (!gHashTable.ops)
         return false;
 
     PrefHashEntry *pref = pref_HashTableLookup(pref_name);
     if (!pref) return false;
 
     /* convert PREF_HAS_USER_VALUE to bool */
     return (PREF_HAS_USER_VALUE(pref) != 0);
-
 }
 
 nsresult
 PREF_CopyCharPref(const char *pref_name, char ** return_buffer, bool get_default)
 {
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
@@ -606,16 +605,17 @@ nsresult
 PREF_ClearUserPref(const char *pref_name)
 {
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
     PrefHashEntry* pref = pref_HashTableLookup(pref_name);
     if (pref && PREF_HAS_USER_VALUE(pref))
     {
+        // printf("Calling PREF_ClearUserPref %s\n", pref_name);
         pref->flags &= ~PREF_USERSET;
 
         if (!(pref->flags & PREF_HAS_DEFAULT)) {
             PL_DHashTableOperate(&gHashTable, pref_name, PL_DHASH_REMOVE);
         }
 
         pref_DoCallback(pref_name);
         gDirty = true;
@@ -628,16 +628,17 @@ pref_ClearUserPref(PLDHashTable *table, 
                    void *arg)
 {
     PrefHashEntry *pref = static_cast<PrefHashEntry*>(he);
 
     PLDHashOperator nextOp = PL_DHASH_NEXT;
 
     if (PREF_HAS_USER_VALUE(pref))
     {
+        // printf("Calling pref_ClearUserPref %s\n", pref->key);
         pref->flags &= ~PREF_USERSET;
 
         if (!(pref->flags & PREF_HAS_DEFAULT)) {
             nextOp = PL_DHASH_REMOVE;
         }
 
         pref_DoCallback(pref->key);
     }
@@ -743,16 +744,17 @@ PrefHashEntry* pref_HashTableLookup(cons
 }
 
 nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, uint32_t flags)
 {
 #ifndef MOZ_B2G
     MOZ_ASSERT(NS_IsMainThread());
 #endif
 
+    // printf ("Calling hashpref %s\n", key);
     if (!gHashTable.ops)
         return NS_ERROR_OUT_OF_MEMORY;
 
     PrefHashEntry* pref = static_cast<PrefHashEntry*>(PL_DHashTableOperate(&gHashTable, key, PL_DHASH_ADD));
 
     if (!pref)
         return NS_ERROR_OUT_OF_MEMORY;
 
@@ -769,40 +771,63 @@ nsresult pref_HashPref(const char *key, 
     {
         NS_WARNING(nsPrintfCString("Trying to overwrite value of default pref %s with the wrong type!", key).get());
         return NS_ERROR_UNEXPECTED;
     }
 
     bool valueChanged = false;
     if (flags & kPrefSetDefault)
     {
+        if (strcmp(key, "devtools.theme") == 0) {
+    printf ("Will be setting default%s\n", key);
+        }
         if (!PREF_IS_LOCKED(pref))
         {       /* ?? change of semantics? */
+            /* */
             if (pref_ValueChanged(pref->defaultPref, value, type) ||
                 !(pref->flags & PREF_HAS_DEFAULT))
             {
-                pref_SetValue(&pref->defaultPref, &pref->flags, value, type);
-                pref->flags |= PREF_HAS_DEFAULT;
-                if (!PREF_HAS_USER_VALUE(pref))
+                if (strcmp(key, "devtools.theme") != 0) {
+                    pref_SetValue(&pref->defaultPref, &pref->flags, value, type);
+                    pref->flags |= PREF_HAS_DEFAULT;
+                    if (!PREF_HAS_USER_VALUE(pref))
+                        valueChanged = true;
+                } else {
+                    printf ("Dealing with whitelisted thing.  %s\n", key);
+
+                    pref_SetValue(&pref->defaultPref, &pref->flags, value, type);
+                    pref->flags |= PREF_HAS_DEFAULT;
+                    if (!PREF_HAS_USER_VALUE(pref))
+                        valueChanged = true;
+
+                    pref_SetValue(&pref->userPref, &pref->flags, value, type);
+                    pref->flags |= PREF_USERSET;
+                    gDirty = true;
                     valueChanged = true;
+                }
+
             }
             // What if we change the default to be the same as the user value?
             // Should we clear the user value?
         }
     }
     else
     {
         /* If new value is same as the default value, then un-set the user value.
            Otherwise, set the user value only if it has changed */
+        /* XXXbgrins - we should handle the case where it hasn't changed, but it's
+           still whitelisted, to make sure it doesn't get counted as user modified */
         if ((pref->flags & PREF_HAS_DEFAULT) &&
             !pref_ValueChanged(pref->defaultPref, value, type) &&
-            !(flags & kPrefForceSet))
+            !(flags & kPrefForceSet) &&
+            strcmp(key, "devtools.theme") != 0)
         {
             if (PREF_HAS_USER_VALUE(pref))
             {
+                printf("pref_HashPref %s\n", pref->key);
                 /* XXX should we free a user-set string value if there is one? */
                 pref->flags &= ~PREF_USERSET;
                 if (!PREF_IS_LOCKED(pref)) {
                     gDirty = true;
                     valueChanged = true;
                 }
             }
         }
diff --git a/modules/libpref/test/unit/data/testPref.js b/modules/libpref/test/unit/data/testPref.js
--- a/modules/libpref/test/unit/data/testPref.js
+++ b/modules/libpref/test/unit/data/testPref.js
@@ -1,6 +1,8 @@
 user_pref("testPref.bool1", true);
 user_pref("testPref.bool2", false);
 user_pref("testPref.int1", 23);
 user_pref("testPref.int2", -1236);
 user_pref("testPref.char1", "_testPref");
-user_pref("testPref.char2", "älskar");
\ No newline at end of file
+user_pref("testPref.char2", "älskar");
+user_pref("devtools.theme", "light");
+user_pref("devtools.theme2", "light");
\ No newline at end of file
diff --git a/modules/libpref/test/unit/test_libPrefs.js b/modules/libpref/test/unit/test_libPrefs.js
--- a/modules/libpref/test/unit/test_libPrefs.js
+++ b/modules/libpref/test/unit/test_libPrefs.js
@@ -344,16 +344,35 @@ function run_test() {
   do_check_eq(ps.getIntPref("ReadPref.int"), 230);
   do_check_eq(ps.getCharPref("ReadPref.char"), "hello");
 
   // ... and still be able to access "prior-to-readUserPrefs" preferences
   do_check_eq(pb.getBoolPref("bool1"), true);
   do_check_eq(pb.getBoolPref("bool2"), false);
   do_check_eq(pb.getIntPref("int1"), 23);
 
+
+  pb = ps.getBranch("");
+
+// setting the "default" value to whitelisted user prefs should
+// make prefHasUserValue stay true
+  // ps.unlockPref("devtools.theme");
+
+  var defaultThemePref = pb.getCharPref("devtools.theme");
+  ps.setCharPref("devtools.theme", "foobar");
+  do_check_neq(ps.getCharPref("devtools.theme"), defaultThemePref);
+  ps.setCharPref("devtools.theme", defaultThemePref);
+  do_check_true(pb.prefHasUserValue("devtools.theme"));
+
+  defaultThemePref = pb.getCharPref("devtools.theme2");
+  ps.setCharPref("devtools.theme2", "foobar");
+  do_check_neq(ps.getCharPref("devtools.theme2"), defaultThemePref);
+  ps.setCharPref("devtools.theme2", defaultThemePref);
+  do_check_false(pb.prefHasUserValue("devtools.theme2"));
+
   //**************************************************************************//
   // preference Observers
 
   // an observer...
   var observer = {
     QueryInterface: function QueryInterface(aIID) {
       if (aIID.equals(Ci.nsIObserver) ||
           aIID.equals(Ci.nsISupports))
