# HG changeset patch
# Parent f8d88012c24b1d22c57fabedca02fb91f5f2d966
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1098343 - Whitelist devedition prefs to not clear user value when setting to default value

diff --git a/modules/libpref/nsPrefBranch.cpp b/modules/libpref/nsPrefBranch.cpp
--- a/modules/libpref/nsPrefBranch.cpp
+++ b/modules/libpref/nsPrefBranch.cpp
@@ -480,24 +480,26 @@ NS_IMETHODIMP nsPrefBranch::SetComplexVa
   }
 
   NS_WARNING("nsPrefBranch::SetComplexValue - Unsupported interface type");
   return NS_NOINTERFACE;
 }
 
 NS_IMETHODIMP nsPrefBranch::ClearUserPref(const char *aPrefName)
 {
+  // printf("ClearUserPref!!! %s\n", aPrefName);
   ENSURE_MAIN_PROCESS("Cannot ClearUserPref from content process:", aPrefName);
   NS_ENSURE_ARG(aPrefName);
   const char *pref = getPrefName(aPrefName);
   return PREF_ClearUserPref(pref);
 }
 
 NS_IMETHODIMP nsPrefBranch::PrefHasUserValue(const char *aPrefName, bool *_retval)
 {
+  // printf("PrefHasUserValue!!! %s\n", aPrefName);
   NS_ENSURE_ARG_POINTER(_retval);
   NS_ENSURE_ARG(aPrefName);
   const char *pref = getPrefName(aPrefName);
   *_retval = PREF_HasUserPref(pref);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsPrefBranch::LockPref(const char *aPrefName)
diff --git a/modules/libpref/prefapi.cpp b/modules/libpref/prefapi.cpp
--- a/modules/libpref/prefapi.cpp
+++ b/modules/libpref/prefapi.cpp
@@ -321,33 +321,40 @@ pref_SetPref(const dom::PrefSetting& aPr
     return rv;
 }
 
 PLDHashOperator
 pref_savePref(PLDHashTable *table, PLDHashEntryHdr *heh, uint32_t i, void *arg)
 {
     pref_saveArgs *argData = static_cast<pref_saveArgs *>(arg);
     PrefHashEntry *pref = static_cast<PrefHashEntry *>(heh);
-
     PR_ASSERT(pref);
     if (!pref)
         return PL_DHASH_NEXT;
 
     nsAutoCString prefValue;
     nsAutoCString prefPrefix;
     prefPrefix.AssignLiteral("user_pref(\"");
 
     // where we're getting our pref from
     PrefValue* sourcePref;
 
+    if (strcmp(pref->key, "devtools.theme") == 0) {
+        printf ("Saving pref %s\n", pref->key);
+    }
+
+    // If this is a user pref that is either from the default value,
+    // missing a default value, or part of a whitelisted set, then
+    // get the pref from userPref.
     if (PREF_HAS_USER_VALUE(pref) &&
         (pref_ValueChanged(pref->defaultPref,
                            pref->userPref,
                            (PrefType) PREF_TYPE(pref)) ||
-         !(PREF_HAS_DEFAULT_VALUE(pref)))) {
+         !(PREF_HAS_DEFAULT_VALUE(pref)) ||
+         strcmp(pref->key, "devtools.theme") == 0)) {
         sourcePref = &pref->userPref;
     } else {
         if (argData->saveTypes == SAVE_ALL_AND_DEFAULTS) {
             prefPrefix.AssignLiteral("pref(\"");
             sourcePref = &pref->defaultPref;
         }
         else
             // do not save default prefs that haven't changed
@@ -472,17 +479,16 @@ bool PREF_HasUserPref(const char *pref_n
     if (!gHashTable.ops)
         return false;
 
     PrefHashEntry *pref = pref_HashTableLookup(pref_name);
     if (!pref) return false;
 
     /* convert PREF_HAS_USER_VALUE to bool */
     return (PREF_HAS_USER_VALUE(pref) != 0);
-
 }
 
 nsresult
 PREF_CopyCharPref(const char *pref_name, char ** return_buffer, bool get_default)
 {
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
@@ -606,16 +612,17 @@ nsresult
 PREF_ClearUserPref(const char *pref_name)
 {
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
     PrefHashEntry* pref = pref_HashTableLookup(pref_name);
     if (pref && PREF_HAS_USER_VALUE(pref))
     {
+        printf("Calling PREF_ClearUserPref %s\n", pref_name);
         pref->flags &= ~PREF_USERSET;
 
         if (!(PREF_HAS_DEFAULT_VALUE(pref))) {
             PL_DHashTableOperate(&gHashTable, pref_name, PL_DHASH_REMOVE);
         }
 
         pref_DoCallback(pref_name);
         gDirty = true;
@@ -628,16 +635,17 @@ pref_ClearUserPref(PLDHashTable *table, 
                    void *arg)
 {
     PrefHashEntry *pref = static_cast<PrefHashEntry*>(he);
 
     PLDHashOperator nextOp = PL_DHASH_NEXT;
 
     if (PREF_HAS_USER_VALUE(pref))
     {
+        printf("Calling pref_ClearUserPref %s\n", pref->key);
         pref->flags &= ~PREF_USERSET;
 
         if (!(PREF_HAS_DEFAULT_VALUE(pref))) {
             nextOp = PL_DHASH_REMOVE;
         }
 
         pref_DoCallback(pref->key);
     }
@@ -743,16 +751,17 @@ PrefHashEntry* pref_HashTableLookup(cons
 }
 
 nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, uint32_t flags)
 {
 #ifndef MOZ_B2G
     MOZ_ASSERT(NS_IsMainThread());
 #endif
 
+    // printf ("Calling hashpref %s\n", key);
     if (!gHashTable.ops)
         return NS_ERROR_OUT_OF_MEMORY;
 
     PrefHashEntry* pref = static_cast<PrefHashEntry*>(PL_DHashTableOperate(&gHashTable, key, PL_DHASH_ADD));
 
     if (!pref)
         return NS_ERROR_OUT_OF_MEMORY;
 
@@ -766,43 +775,69 @@ nsresult pref_HashPref(const char *key, 
         memset(&pref->userPref, 0, sizeof(pref->userPref));
     }
     else if ((PREF_HAS_DEFAULT_VALUE(pref)) && PREF_TYPE(pref) != type)
     {
         NS_WARNING(nsPrintfCString("Trying to overwrite value of default pref %s with the wrong type!", key).get());
         return NS_ERROR_UNEXPECTED;
     }
 
+    if (strcmp(key, "devtools.theme") == 0) {
+        printf ("Inside pref_HashPref%s\n", key);
+    }
     bool valueChanged = false;
     if (flags & kPrefSetDefault)
     {
+        if (strcmp(key, "devtools.theme") == 0) {
+    printf ("Will be setting default%s\n", key);
+        }
         if (!PREF_IS_LOCKED(pref))
         {       /* ?? change of semantics? */
+            /* */
             if (pref_ValueChanged(pref->defaultPref, value, type) ||
                 !(PREF_HAS_DEFAULT_VALUE(pref)))
             {
-                pref_SetValue(&pref->defaultPref, &pref->flags, value, type);
-                pref->flags |= PREF_HAS_DEFAULT;
-                if (!PREF_HAS_USER_VALUE(pref))
+                if (true || strcmp(key, "devtools.theme") != 0) {
+                    pref_SetValue(&pref->defaultPref, &pref->flags, value, type);
+                    pref->flags |= PREF_HAS_DEFAULT;
+                    if (!PREF_HAS_USER_VALUE(pref))
+                        valueChanged = true;
+                } else {
+                    printf ("Dealing with whitelisted thing.  %s\n", key);
+
+                    pref_SetValue(&pref->defaultPref, &pref->flags, value, type);
+                    pref->flags |= PREF_HAS_DEFAULT;
+                    if (!PREF_HAS_USER_VALUE(pref))
+                        valueChanged = true;
+
+                    pref_SetValue(&pref->userPref, &pref->flags, value, type);
+                    pref->flags |= PREF_USERSET;
+                    gDirty = true;
                     valueChanged = true;
+                }
+
             }
             // What if we change the default to be the same as the user value?
             // Should we clear the user value?
         }
     }
     else
     {
         /* If new value is same as the default value, then un-set the user value.
            Otherwise, set the user value only if it has changed */
+        /* XXXbgrins - we should handle the case where it hasn't changed, but it's
+           still whitelisted, to make sure it doesn't get counted as user modified */
         if ((PREF_HAS_DEFAULT_VALUE(pref)) &&
             !pref_ValueChanged(pref->defaultPref, value, type) &&
-            !(flags & kPrefForceSet))
+            !(flags & kPrefForceSet) &&
+            strcmp(key, "devtools.theme") != 0)
         {
             if (PREF_HAS_USER_VALUE(pref))
             {
+                printf("pref_HashPref %s\n", pref->key);
                 /* XXX should we free a user-set string value if there is one? */
                 pref->flags &= ~PREF_USERSET;
                 if (!PREF_IS_LOCKED(pref)) {
                     gDirty = true;
                     valueChanged = true;
                 }
             }
         }
diff --git a/modules/libpref/test/unit/data/testPref.js b/modules/libpref/test/unit/data/testPref.js
--- a/modules/libpref/test/unit/data/testPref.js
+++ b/modules/libpref/test/unit/data/testPref.js
@@ -1,6 +1,8 @@
 user_pref("testPref.bool1", true);
 user_pref("testPref.bool2", false);
 user_pref("testPref.int1", 23);
 user_pref("testPref.int2", -1236);
 user_pref("testPref.char1", "_testPref");
-user_pref("testPref.char2", "älskar");
\ No newline at end of file
+user_pref("testPref.char2", "älskar");
+user_pref("devtools.theme", "light");
+user_pref("devtools.theme2", "light");
\ No newline at end of file
diff --git a/modules/libpref/test/unit/test_libPrefs.js b/modules/libpref/test/unit/test_libPrefs.js
--- a/modules/libpref/test/unit/test_libPrefs.js
+++ b/modules/libpref/test/unit/test_libPrefs.js
@@ -344,16 +344,35 @@ function run_test() {
   do_check_eq(ps.getIntPref("ReadPref.int"), 230);
   do_check_eq(ps.getCharPref("ReadPref.char"), "hello");
 
   // ... and still be able to access "prior-to-readUserPrefs" preferences
   do_check_eq(pb.getBoolPref("bool1"), true);
   do_check_eq(pb.getBoolPref("bool2"), false);
   do_check_eq(pb.getIntPref("int1"), 23);
 
+
+  pb = ps.getBranch("");
+
+// setting the "default" value to whitelisted user prefs should
+// make prefHasUserValue stay true
+  // ps.unlockPref("devtools.theme");
+
+  var defaultThemePref = pb.getCharPref("devtools.theme");
+  ps.setCharPref("devtools.theme", "foobar");
+  do_check_neq(ps.getCharPref("devtools.theme"), defaultThemePref);
+  ps.setCharPref("devtools.theme", defaultThemePref);
+  do_check_true(pb.prefHasUserValue("devtools.theme"));
+
+  defaultThemePref = pb.getCharPref("devtools.theme2");
+  ps.setCharPref("devtools.theme2", "foobar");
+  do_check_neq(ps.getCharPref("devtools.theme2"), defaultThemePref);
+  ps.setCharPref("devtools.theme2", defaultThemePref);
+  do_check_false(pb.prefHasUserValue("devtools.theme2"));
+
   //**************************************************************************//
   // preference Observers
 
   // an observer...
   var observer = {
     QueryInterface: function QueryInterface(aIID) {
       if (aIID.equals(Ci.nsIObserver) ||
           aIID.equals(Ci.nsISupports))
