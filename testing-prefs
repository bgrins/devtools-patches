# HG changeset patch
# Parent 6e48186fe18424a6606d2e4ff58178e950b70b83
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1098343 - Whitelist devedition prefs to not clear user value when setting to default value

diff --git a/modules/libpref/prefapi.cpp b/modules/libpref/prefapi.cpp
--- a/modules/libpref/prefapi.cpp
+++ b/modules/libpref/prefapi.cpp
@@ -472,17 +472,16 @@ bool PREF_HasUserPref(const char *pref_n
     if (!gHashTable.ops)
         return false;
 
     PrefHashEntry *pref = pref_HashTableLookup(pref_name);
     if (!pref) return false;
 
     /* convert PREF_HAS_USER_VALUE to bool */
     return (PREF_HAS_USER_VALUE(pref) != 0);
-
 }
 
 nsresult
 PREF_CopyCharPref(const char *pref_name, char ** return_buffer, bool get_default)
 {
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
@@ -789,17 +788,18 @@ nsresult pref_HashPref(const char *key, 
         }
     }
     else
     {
         /* If new value is same as the default value, then un-set the user value.
            Otherwise, set the user value only if it has changed */
         if ((pref->flags & PREF_HAS_DEFAULT) &&
             !pref_ValueChanged(pref->defaultPref, value, type) &&
-            !(flags & kPrefForceSet))
+            !(flags & kPrefForceSet) &&
+            strcmp(key, "devtools.theme") != 0)
         {
             if (PREF_HAS_USER_VALUE(pref))
             {
                 /* XXX should we free a user-set string value if there is one? */
                 pref->flags &= ~PREF_USERSET;
                 if (!PREF_IS_LOCKED(pref)) {
                     gDirty = true;
                     valueChanged = true;
diff --git a/modules/libpref/test/unit/data/testPref.js b/modules/libpref/test/unit/data/testPref.js
--- a/modules/libpref/test/unit/data/testPref.js
+++ b/modules/libpref/test/unit/data/testPref.js
@@ -1,6 +1,8 @@
 user_pref("testPref.bool1", true);
 user_pref("testPref.bool2", false);
 user_pref("testPref.int1", 23);
 user_pref("testPref.int2", -1236);
 user_pref("testPref.char1", "_testPref");
-user_pref("testPref.char2", "älskar");
\ No newline at end of file
+user_pref("testPref.char2", "älskar");
+user_pref("devtools.theme", "light");
+user_pref("devtools.theme2", "light");
\ No newline at end of file
diff --git a/modules/libpref/test/unit/test_libPrefs.js b/modules/libpref/test/unit/test_libPrefs.js
--- a/modules/libpref/test/unit/test_libPrefs.js
+++ b/modules/libpref/test/unit/test_libPrefs.js
@@ -344,16 +344,35 @@ function run_test() {
   do_check_eq(ps.getIntPref("ReadPref.int"), 230);
   do_check_eq(ps.getCharPref("ReadPref.char"), "hello");
 
   // ... and still be able to access "prior-to-readUserPrefs" preferences
   do_check_eq(pb.getBoolPref("bool1"), true);
   do_check_eq(pb.getBoolPref("bool2"), false);
   do_check_eq(pb.getIntPref("int1"), 23);
 
+
+  pb = ps.getBranch("");
+
+// setting the "default" value to whitelisted user prefs should
+// make prefHasUserValue stay true
+  // ps.unlockPref("devtools.theme");
+
+  var defaultThemePref = pb.getCharPref("devtools.theme");
+  ps.setCharPref("devtools.theme", "foobar");
+  do_check_neq(ps.getCharPref("devtools.theme"), defaultThemePref);
+  ps.setCharPref("devtools.theme", defaultThemePref);
+  do_check_true(pb.prefHasUserValue("devtools.theme"));
+
+  defaultThemePref = pb.getCharPref("devtools.theme2");
+  ps.setCharPref("devtools.theme2", "foobar");
+  do_check_neq(ps.getCharPref("devtools.theme2"), defaultThemePref);
+  ps.setCharPref("devtools.theme2", defaultThemePref);
+  do_check_false(pb.prefHasUserValue("devtools.theme2"));
+
   //**************************************************************************//
   // preference Observers
 
   // an observer...
   var observer = {
     QueryInterface: function QueryInterface(aIID) {
       if (aIID.equals(Ci.nsIObserver) ||
           aIID.equals(Ci.nsISupports))
