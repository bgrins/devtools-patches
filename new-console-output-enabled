# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  6ab68ad466f827d191765cfaf30305fc43059dbd
Bug 1454012 - Part 2 - Remove NEW_CONSOLE_OUTPUT_ENABLED since it's now always true;r=nchevobbe

MozReview-Commit-ID: 2PaXZqDGMOi

diff --git a/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js b/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
--- a/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
+++ b/browser/components/extensions/test/browser/browser_ext_devtools_inspectedWindow_eval_bindings.js
@@ -115,69 +115,56 @@ add_task(async function test_devtools_in
 
   info("Test inspectedWindow.eval inspect() binding called for a JS object");
 
   const splitPanelOpenedPromise = (async () => {
     await toolbox.once("split-console");
     const {hud} = toolbox.getPanel("webconsole");
     let {jsterm} = hud;
 
-    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1386221.
-    if (jsterm.hud.NEW_CONSOLE_OUTPUT_ENABLED === true) {
-      // Wait for the message to appear on the console.
-      const messageNode = await new Promise(resolve => {
-        jsterm.hud.on("new-messages", function onThisMessage(messages) {
-          for (let m of messages) {
-            resolve(m.node);
-            jsterm.hud.off("new-messages", onThisMessage);
-            return;
-          }
-        });
+    // Wait for the message to appear on the console.
+    const messageNode = await new Promise(resolve => {
+      jsterm.hud.on("new-messages", function onThisMessage(messages) {
+        for (let m of messages) {
+          resolve(m.node);
+          jsterm.hud.off("new-messages", onThisMessage);
+          return;
+        }
       });
-      let objectInspectors = [...messageNode.querySelectorAll(".tree")];
-      is(objectInspectors.length, 1, "There is the expected number of object inspectors");
-
-      // We need to wait for the object to be expanded so we don't call the server on a closed connection.
-      const [oi] = objectInspectors;
-      let nodes = oi.querySelectorAll(".node");
-
-      ok(nodes.length >= 1, "The object preview is rendered as expected");
+    });
+    let objectInspectors = [...messageNode.querySelectorAll(".tree")];
+    is(objectInspectors.length, 1, "There is the expected number of object inspectors");
 
-      // The tree can still be collapsed since the properties are fetched asynchronously.
-      if (nodes.length === 1) {
-        info("Waiting for the object properties to be displayed");
-        // If this is the case, we wait for the properties to be fetched and displayed.
-        await new Promise(resolve => {
-          const observer = new MutationObserver(mutations => {
-            resolve();
-            observer.disconnect();
-          });
-          observer.observe(oi, {childList: true});
-        });
+    // We need to wait for the object to be expanded so we don't call the server on a closed connection.
+    const [oi] = objectInspectors;
+    let nodes = oi.querySelectorAll(".node");
+
+    ok(nodes.length >= 1, "The object preview is rendered as expected");
 
-        // Retrieve the new nodes.
-        nodes = oi.querySelectorAll(".node");
-      }
-
-      // We should have 3 nodes :
-      //   ▼ Object { testkey: "testvalue" }
-      //   |  testkey: "testvalue"
-      //   |  ▶︎ __proto__: Object { … }
-      is(nodes.length, 3, "The object preview has the expected number of nodes");
-    } else {
-      const options = await new Promise(resolve => {
-        jsterm.once("variablesview-open", (view, options) => resolve(options));
+    // The tree can still be collapsed since the properties are fetched asynchronously.
+    if (nodes.length === 1) {
+      info("Waiting for the object properties to be displayed");
+      // If this is the case, we wait for the properties to be fetched and displayed.
+      await new Promise(resolve => {
+        const observer = new MutationObserver(mutations => {
+          resolve();
+          observer.disconnect();
+        });
+        observer.observe(oi, {childList: true});
       });
 
-      const objectType = options.objectActor.type;
-      const objectPreviewProperties = options.objectActor.preview.ownProperties;
-      is(objectType, "object", "The inspected object has the expected type");
-      Assert.deepEqual(Object.keys(objectPreviewProperties), ["testkey"],
-                       "The inspected object has the expected preview properties");
+      // Retrieve the new nodes.
+      nodes = oi.querySelectorAll(".node");
     }
+
+    // We should have 3 nodes :
+    //   ▼ Object { testkey: "testvalue" }
+    //   |  testkey: "testvalue"
+    //   |  ▶︎ __proto__: Object { … }
+    is(nodes.length, 3, "The object preview has the expected number of nodes");
   })();
 
   const inspectJSObjectPromise = extension.awaitMessage(`inspectedWindow-eval-result`);
   extension.sendMessage(`inspectedWindow-eval-request`, "inspect({testkey: 'testvalue'})");
   await inspectJSObjectPromise;
 
   info("Wait for the split console to be opened and the JS object inspected");
   await splitPanelOpenedPromise;
diff --git a/devtools/client/webconsole/new-webconsole.js b/devtools/client/webconsole/new-webconsole.js
--- a/devtools/client/webconsole/new-webconsole.js
+++ b/devtools/client/webconsole/new-webconsole.js
@@ -39,17 +39,16 @@ const PREF_SIDEBAR_ENABLED = "devtools.w
  * @constructor
  * @param object webConsoleOwner
  *        The WebConsole owner object.
  */
 function NewWebConsoleFrame(webConsoleOwner) {
   this.owner = webConsoleOwner;
   this.hudId = this.owner.hudId;
   this.isBrowserConsole = this.owner._browserConsole;
-  this.NEW_CONSOLE_OUTPUT_ENABLED = true;
   this.window = this.owner.iframeWindow;
 
   this._onToolboxPrefChanged = this._onToolboxPrefChanged.bind(this);
   this._onPanelSelected = this._onPanelSelected.bind(this);
 
   EventEmitter.decorate(this);
 }
 NewWebConsoleFrame.prototype = {
diff --git a/devtools/client/webconsole/webconsole-connection-proxy.js b/devtools/client/webconsole/webconsole-connection-proxy.js
--- a/devtools/client/webconsole/webconsole-connection-proxy.js
+++ b/devtools/client/webconsole/webconsole-connection-proxy.js
@@ -269,21 +269,17 @@ WebConsoleConnectionProxy.prototype = {
       // connection attempt is successful, nonetheless.
       console.error("Web Console getCachedMessages error: invalid state.");
     }
 
     let messages =
       response.messages.concat(...this.webConsoleClient.getNetworkEvents());
     messages.sort((a, b) => a.timeStamp - b.timeStamp);
 
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      this.dispatchMessagesAdd(messages);
-    } else {
-      this.webConsoleFrame.displayCachedMessages(messages);
-    }
+    this.dispatchMessagesAdd(messages);
     if (!this._hasNativeConsoleAPI) {
       this.webConsoleFrame.logWarningAboutReplacedAPI();
     }
 
     this.connected = true;
     this._connectDefer.resolve(this);
   },
 
@@ -296,128 +292,93 @@ WebConsoleConnectionProxy.prototype = {
    *        Message type.
    * @param object packet
    *        The message received from the server.
    */
   _onPageError: function(type, packet) {
     if (!this.webConsoleFrame || packet.from != this._consoleActor) {
       return;
     }
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      this.dispatchMessageAdd(packet);
-    } else {
-      this.webConsoleFrame.handlePageError(packet.pageError);
-    }
+    this.dispatchMessageAdd(packet);
   },
   /**
    * The "logMessage" message type handler. We redirect any message to the UI
    * for displaying.
    *
    * @private
    * @param string type
    *        Message type.
    * @param object packet
    *        The message received from the server.
    */
   _onLogMessage: function(type, packet) {
     if (!this.webConsoleFrame || packet.from != this._consoleActor) {
       return;
     }
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      this.dispatchMessageAdd(packet);
-    } else {
-      this.webConsoleFrame.handleLogMessage(packet);
-    }
+    this.dispatchMessageAdd(packet);
   },
   /**
    * The "consoleAPICall" message type handler. We redirect any message to
    * the UI for displaying.
    *
    * @private
    * @param string type
    *        Message type.
    * @param object packet
    *        The message received from the server.
    */
   _onConsoleAPICall: function(type, packet) {
     if (!this.webConsoleFrame || packet.from != this._consoleActor) {
       return;
     }
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      this.dispatchMessageAdd(packet);
-    } else {
-      this.webConsoleFrame.handleConsoleAPICall(packet.message);
-    }
+    this.dispatchMessageAdd(packet);
   },
   /**
    * The "networkEvent" message type handler. We redirect any message to
    * the UI for displaying.
    *
    * @private
    * @param object networkInfo
    *        The network request information.
    */
   _onNetworkEvent: function(networkInfo) {
     if (!this.webConsoleFrame) {
       return;
     }
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      this.dispatchMessageAdd(networkInfo);
-    } else {
-      this.webConsoleFrame.handleNetworkEvent(networkInfo);
-    }
+    this.dispatchMessageAdd(networkInfo);
   },
   /**
    * The "networkEventUpdate" message type handler. We redirect any message to
    * the UI for displaying.
    *
    * @private
    * @param object response
    *        The update response received from the server.
    */
   _onNetworkEventUpdate: function(response) {
     if (!this.webConsoleFrame) {
       return;
     }
-    let { packet, networkInfo } = response;
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      this.dispatchMessageUpdate(networkInfo, response);
-    } else {
-      this.webConsoleFrame.handleNetworkEventUpdate(networkInfo, packet);
-    }
+    this.dispatchMessageUpdate(response.networkInfo, response);
   },
   /**
    * The "fileActivity" message type handler. We redirect any message to
    * the UI for displaying.
    *
    * @private
    * @param string type
    *        Message type.
    * @param object packet
    *        The message received from the server.
    */
   _onFileActivity: function(type, packet) {
-    if (!this.webConsoleFrame || packet.from != this._consoleActor) {
-      return;
-    }
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      // TODO: Implement for new console
-    } else {
-      this.webConsoleFrame.handleFileActivity(packet.uri);
-    }
+    // TODO: Implement for new console
   },
   _onReflowActivity: function(type, packet) {
-    if (!this.webConsoleFrame || packet.from != this._consoleActor) {
-      return;
-    }
-    if (this.webConsoleFrame.NEW_CONSOLE_OUTPUT_ENABLED) {
-      // TODO: Implement for new console
-    } else {
-      this.webConsoleFrame.handleReflowActivity(packet);
-    }
+    // TODO: Implement for new console
   },
   /**
    * The "lastPrivateContextExited" message type handler. When this message is
    * received the Web Console UI is cleared.
    *
    * @private
    * @param string type
    *        Message type.
