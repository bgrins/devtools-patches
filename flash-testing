# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  20bb8fec6bad03a2c512bc6132533484f71abcca

diff --git a/devtools/client/markupview/markup-view.js b/devtools/client/markupview/markup-view.js
--- a/devtools/client/markupview/markup-view.js
+++ b/devtools/client/markupview/markup-view.js
@@ -1092,16 +1092,17 @@ MarkupView.prototype = {
       this._removedNodeObserver = null;
 
       // Don't select the new node if the user has already changed the current
       // selection.
       if (this._inspector.selection.nodeFront === parentContainer.node ||
           (this._inspector.selection.nodeFront === removedNode && isHTMLTag)) {
         let childContainers = parentContainer.getChildContainers();
         if (childContainers && childContainers[childIndex]) {
+        console.log("RESELECTING ON REMOVAL", childContainers[childIndex]);
           this.markNodeAsSelected(childContainers[childIndex].node, reason);
           if (childContainers[childIndex].hasChildren) {
             this.expandNode(childContainers[childIndex].node);
           }
           this.emit("reselectedonremoved");
         }
       }
     };
@@ -1819,16 +1820,17 @@ MarkupContainer.prototype = {
         if (!this.closeTagLine) {
           let line = this.markup.doc.createElement("div");
           line.classList.add("tag-line");
 
           let tagState = this.markup.doc.createElement("div");
           tagState.classList.add("tag-state");
           line.appendChild(tagState);
 
+          let clonedTag = closingTag.cloneNode(true);
           line.appendChild(closingTag.cloneNode(true));
 
           this.closeTagLine = line;
         }
         this.elt.appendChild(this.closeTagLine);
       }
 
       this.elt.classList.remove("collapsed");
@@ -1990,16 +1992,17 @@ MarkupContainer.prototype = {
     if (!this.selected) {
       let contentWin = this.win;
       flashElementOn(this.tagState, this.editor.elt);
       if (this._flashMutationTimer) {
         clearTimeout(this._flashMutationTimer);
         this._flashMutationTimer = null;
       }
       this._flashMutationTimer = setTimeout(() => {
+        console.log("Flasmutation timer", this.tagState, this.closeTag);
         flashElementOff(this.tagState, this.editor.elt);
       }, this.markup.CONTAINER_FLASHING_DURATION);
     }
   },
 
   _hovered: false,
 
   /**
@@ -2528,21 +2531,21 @@ ElementEditor.prototype = {
     }
   },
 
   flashAttribute: function(attrName) {
     if (this.animationTimers[attrName]) {
       clearTimeout(this.animationTimers[attrName]);
     }
 
-    flashElementOn(this.getAttributeElement(attrName));
-
-    this.animationTimers[attrName] = setTimeout(() => {
-      flashElementOff(this.getAttributeElement(attrName));
-    }, this.markup.CONTAINER_FLASHING_DURATION);
+    // flashElementOn(this.getAttributeElement(attrName));
+
+    // this.animationTimers[attrName] = setTimeout(() => {
+    //   flashElementOff(this.getAttributeElement(attrName));
+    // }, this.markup.CONTAINER_FLASHING_DURATION);
   },
 
   /**
    * Update the state of the editor from the node.
    */
   update: function() {
     let nodeAttributes = this.node.attributes || [];
 
@@ -2969,16 +2972,17 @@ function parseAttributeValues(attr, doc)
  *
  * @param  {Node} backgroundElt
  *         The element to set the highlighted background color on.
  * @param  {Node} foregroundElt
  *         The element to set the matching foreground color on.
  *         Optional.  This will equal backgroundElt if not set.
  */
 function flashElementOn(backgroundElt, foregroundElt=backgroundElt) {
+  console.log("flashElementOn", backgroundElt, foregroundElt);
   if (!backgroundElt || !foregroundElt) {
     return;
   }
 
   // Make sure the animation class is not here
   backgroundElt.classList.remove("flash-out");
 
   // Change the background
@@ -2997,16 +3001,17 @@ function flashElementOn(backgroundElt, f
  *
  * @param  {Node} backgroundElt
  *         The element to reomve the highlighted background color on.
  * @param  {Node} foregroundElt
  *         The element to remove the matching foreground color on.
  *         Optional.  This will equal backgroundElt if not set.
  */
 function flashElementOff(backgroundElt, foregroundElt=backgroundElt) {
+  console.log("flashElementff", backgroundElt, foregroundElt);
   if (!backgroundElt || !foregroundElt) {
     return;
   }
 
   // Add the animation class to smoothly remove the background
   backgroundElt.classList.add("flash-out");
 
   // Remove the background
