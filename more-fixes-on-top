# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a644f01ddf08be3f1288ad9ef9461461099db1c4
Bug 1479125 - Fixes on top of the scripted change

diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -125,18 +125,18 @@ var gXPInstallObserver = {
 
     options.eventCallback = (aEvent) => {
       switch (aEvent) {
         case "removed":
           cancelInstallation();
           break;
         case "shown":
           let addonList = document.getElementById("addon-install-confirmation-content");
-          while (addonList.firstElementChild)
-            addonList.firstElementChild.remove();
+          while (addonList.firstChild)
+            addonList.firstChild.remove();
 
           for (let install of installInfo.installs) {
             let container = document.createXULElement("hbox");
 
             let name = document.createXULElement("label");
             name.setAttribute("value", install.addon.name);
             name.setAttribute("class", "addon-install-confirmation-name");
             container.appendChild(name);
@@ -496,18 +496,18 @@ var gExtensionsNotifications = {
   },
 
   updateAlerts() {
     let sideloaded = ExtensionsUI.sideloaded;
     let updates = ExtensionsUI.updates;
 
     let container = PanelUI.addonNotificationContainer;
 
-    while (container.firstElementChild) {
-      container.firstElementChild.remove();
+    while (container.firstChild) {
+      container.firstChild.remove();
     }
 
     let items = 0;
     for (let update of updates) {
       if (++items > 4) {
         break;
       }
       let text = gNavigatorBundle.getFormattedString("webextPerms.updateMenuItem", [update.addon.name]);
diff --git a/browser/base/content/browser-pageActions.js b/browser/base/content/browser-pageActions.js
--- a/browser/base/content/browser-pageActions.js
+++ b/browser/base/content/browser-pageActions.js
@@ -1132,18 +1132,18 @@ BrowserPageActions.addSearchEngine = {
     button.classList.add("badged-button");
     button.setAttribute("image", this.engines[0].icon);
     button.setAttribute("uri", this.engines[0].uri);
     button.setAttribute("crop", "center");
   },
 
   onSubviewShowing(panelViewNode) {
     let body = panelViewNode.querySelector(".panel-subview-body");
-    while (body.firstElementChild) {
-      body.firstElementChild.remove();
+    while (body.firstChild) {
+      body.firstChild.remove();
     }
     for (let engine of this.engines) {
       let button = document.createXULElement("toolbarbutton");
       button.classList.add("subviewbutton", "subviewbutton-iconic");
       button.setAttribute("label", engine.title);
       button.setAttribute("image", engine.icon);
       button.setAttribute("uri", engine.uri);
       button.addEventListener("command", event => {
@@ -1251,18 +1251,18 @@ BrowserPageActions.shareURL = {
     });
 
     let item = document.createElement("toolbarbutton");
     item.setAttribute("label", BrowserPageActions.panelNode.getAttribute("shareMore-label"));
     item.classList.add("subviewbutton", "subviewbutton-iconic", "share-more-button");
     item.addEventListener("command", onCommand);
     fragment.appendChild(item);
 
-    while (bodyNode.firstElementChild) {
-      bodyNode.firstElementChild.remove();
+    while (bodyNode.firstChild) {
+      bodyNode.firstChild.remove();
     }
     bodyNode.appendChild(fragment);
     this._cached = true;
   }
 };
 
 // Attach sharingService here so tests can override the implementation
 XPCOMUtils.defineLazyServiceGetter(BrowserPageActions.shareURL,
diff --git a/browser/base/content/contentSearchUI.js b/browser/base/content/contentSearchUI.js
--- a/browser/base/content/contentSearchUI.js
+++ b/browser/base/content/contentSearchUI.js
@@ -722,18 +722,18 @@ ContentSearchUIController.prototype = {
       this._sendMsg("GetSuggestions", {
         engineName: this.defaultEngine.name,
         searchString: this.input.value,
       });
     }
   },
 
   _clearSuggestionRows() {
-    while (this._suggestionsList.firstElementChild) {
-      this._suggestionsList.firstElementChild.remove();
+    while (this._suggestionsList.firstChild) {
+      this._suggestionsList.firstChild.remove();
     }
   },
 
   _hideSuggestions() {
     this.input.setAttribute("aria-expanded", "false");
     this.selectedIndex = -1;
     this.selectedButtonIndex = -1;
     this._currentEngineIndex = -1;
diff --git a/browser/base/content/utilityOverlay.js b/browser/base/content/utilityOverlay.js
--- a/browser/base/content/utilityOverlay.js
+++ b/browser/base/content/utilityOverlay.js
@@ -601,17 +601,17 @@ function checkForMiddleClick(node, event
 // by onpopupshowing passing the event as first argument.
 function createUserContextMenu(event, {
                                         isContextMenu = false,
                                         excludeUserContextId = 0,
                                         showDefaultTab = false,
                                         useAccessKeys = true
                                       } = {}) {
   while (event.target.hasChildNodes()) {
-    event.target.firstElementChild.remove();
+    event.target.firstChild.remove();
   }
 
   let bundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
   let docfrag = document.createDocumentFragment();
 
   // If we are excluding a userContextId, we want to add a 'no-container' item.
   if (excludeUserContextId || showDefaultTab) {
     let menuitem = document.createElement("menuitem");
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -3951,18 +3951,18 @@ var CustomizableUI = {
    * @param aSubview the subview to clear.
    */
   clearSubview(aSubview) {
     let parent = aSubview.parentNode;
     // We'll take the container out of the document before cleaning it out
     // to avoid reflowing each time we remove something.
     parent.removeChild(aSubview);
 
-    while (aSubview.firstElementChild) {
-      aSubview.firstElementChild.remove();
+    while (aSubview.firstChild) {
+      aSubview.firstChild.remove();
     }
 
     parent.appendChild(aSubview);
   },
 };
 Object.freeze(this.CustomizableUI);
 Object.freeze(this.CustomizableUI.windows);
 
diff --git a/browser/components/customizableui/CustomizableWidgets.jsm b/browser/components/customizableui/CustomizableWidgets.jsm
--- a/browser/components/customizableui/CustomizableWidgets.jsm
+++ b/browser/components/customizableui/CustomizableWidgets.jsm
@@ -660,18 +660,18 @@ if (Services.prefs.getBoolPref("identity
         Cu.reportError(err);
       }).then(() => {
         // an observer for tests.
         Services.obs.notifyObservers(null, "synced-tabs-menu:test:tabs-updated");
       });
     },
     _clearTabList() {
       let list = this._tabsList;
-      while (list.lastElementChild) {
-        list.lastElementChild.remove();
+      while (list.lastChild) {
+        list.lastChild.remove();
       }
     },
     _showNoClientMessage() {
       this._appendMessageLabel("notabslabel");
     },
     _appendMessageLabel(messageAttr, appendTo = null) {
       if (!appendTo) {
         appendTo = this._tabsList;
diff --git a/browser/components/customizableui/CustomizeMode.jsm b/browser/components/customizableui/CustomizeMode.jsm
--- a/browser/components/customizableui/CustomizeMode.jsm
+++ b/browser/components/customizableui/CustomizeMode.jsm
@@ -2596,18 +2596,18 @@ CustomizeMode.prototype = {
 
     function uninit() {
       document.removeEventListener("keydown", onkeydown);
       document.removeEventListener("keyup", onkeyup);
       if (rAFHandle) {
         window.cancelAnimationFrame(rAFHandle);
       }
       let arena = elements.arena;
-      while (arena.firstElementChild) {
-        arena.firstElementChild.remove();
+      while (arena.firstChild) {
+        arena.firstChild.remove();
       }
       arena.removeAttribute("score");
       arena.removeAttribute("lives");
       arena.removeAttribute("kcode");
       arena.style.removeProperty("background-image");
       arena.style.removeProperty("background-position");
       arena.style.removeProperty("background-repeat");
       arena.style.removeProperty("background-size");
diff --git a/browser/components/customizableui/content/panelUI.js b/browser/components/customizableui/content/panelUI.js
--- a/browser/components/customizableui/content/panelUI.js
+++ b/browser/components/customizableui/content/panelUI.js
@@ -539,18 +539,18 @@ const PanelUI = {
     }
   },
 
   /**
    * Remove all the nodes from the 'Recent Highlights' section and hide it as well.
    */
   clearLibraryRecentHighlights() {
     let container = this.libraryRecentHighlights;
-    while (container.firstElementChild) {
-      container.firstElementChild.remove();
+    while (container.firstChild) {
+      container.firstChild.remove();
     }
     container.hidden = container.previousElementSibling.hidden =
       container.previousElementSibling.previousElementSibling.hidden = true;
   },
 
   /**
    * Event handler; invoked when an item of the Recent Highlights is clicked.
    *
@@ -621,18 +621,18 @@ const PanelUI = {
     buildHelpMenu();
 
     let helpMenu = document.getElementById("menu_HelpPopup");
     let items = this.getElementsByTagName("vbox")[0];
     let attrs = ["oncommand", "onclick", "label", "key", "disabled"];
     let NSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     // Remove all buttons from the view
-    while (items.firstElementChild) {
-      items.firstElementChild.remove();
+    while (items.firstChild) {
+      items.firstChild.remove();
     }
 
     // Add the current set of menuitems of the Help menu to this view
     let menuItems = Array.prototype.slice.call(helpMenu.getElementsByTagName("menuitem"));
     let fragment = document.createDocumentFragment();
     for (let node of menuItems) {
       if (node.hidden)
         continue;
diff --git a/browser/components/downloads/DownloadsSubview.jsm b/browser/components/downloads/DownloadsSubview.jsm
--- a/browser/components/downloads/DownloadsSubview.jsm
+++ b/browser/components/downloads/DownloadsSubview.jsm
@@ -39,18 +39,18 @@ class DownloadsSubview extends Downloads
     super();
     this.document = panelview.ownerDocument;
     this.window = panelview.ownerGlobal;
 
     this.context = "panelDownloadsContextMenu";
 
     this.panelview = panelview;
     this.container = this.document.getElementById("panelMenu_downloadsMenu");
-    while (this.container.lastElementChild) {
-      this.container.lastElementChild.remove();
+    while (this.container.lastChild) {
+      this.container.lastChild.remove();
     }
     this.panelview.addEventListener("click", DownloadsSubview.onClick);
     this.panelview.addEventListener("ViewHiding", DownloadsSubview.onViewHiding);
 
     this._viewItemsForDownloads = new WeakMap();
 
     let contextMenu = this.document.getElementById(this.context);
     if (!contextMenu) {
diff --git a/browser/components/extensions/test/browser/browser_ext_tabs_hide.js b/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
--- a/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
+++ b/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
@@ -198,17 +198,17 @@ add_task(async function test_tabs_showhi
   // hidden.  The rest of the tabs should be hidden at this point.  Hidden
   // status was already validated inside the extension, this double checks
   // from chrome code.
   let otherwin;
   for (let win of BrowserWindowIterator()) {
     if (win != window) {
       otherwin = win;
     }
-    let tabs = Array.from(win.gBrowser.tabs.values());
+    let tabs = Array.from(win.gBrowser.tabs);
     ok(!tabs[0].hidden, "first tab not hidden");
     for (let i = 1; i < tabs.length; i++) {
       ok(tabs[i].hidden, "tab hidden value is correct");
       let id = SessionStore.getCustomTabValue(tabs[i], "hiddenBy");
       is(id, extension.id, "tab hiddenBy value is correct");
       await TabStateFlusher.flush(tabs[i].linkedBrowser);
     }
 
@@ -217,17 +217,17 @@ add_task(async function test_tabs_showhi
   }
 
   // Close the other window then restore it to test that the tabs are
   // restored with proper hidden state, and the correct extension id.
   await BrowserTestUtils.closeWindow(otherwin);
 
   otherwin = SessionStore.undoCloseWindow(0);
   await BrowserTestUtils.waitForEvent(otherwin, "load");
-  let tabs = Array.from(otherwin.gBrowser.tabs.values());
+  let tabs = Array.from(otherwin.gBrowser.tabs);
   ok(!tabs[0].hidden, "first tab not hidden");
   for (let i = 1; i < tabs.length; i++) {
     ok(tabs[i].hidden, "tab hidden value is correct");
     let id = SessionStore.getCustomTabValue(tabs[i], "hiddenBy");
     is(id, extension.id, "tab hiddenBy value is correct");
   }
 
   // Test closing the last visible tab, the next tab which is hidden should become
@@ -237,17 +237,17 @@ add_task(async function test_tabs_showhi
   ok(!otherwin.gBrowser.selectedTab.hidden, "tab was unhidden");
 
   // Showall will unhide any remaining hidden tabs.
   extension.sendMessage("showall");
   await extension.awaitMessage("shown");
 
   // Check from chrome code that all tabs are visible again.
   for (let win of BrowserWindowIterator()) {
-    let tabs = Array.from(win.gBrowser.tabs.values());
+    let tabs = Array.from(win.gBrowser.tabs);
     for (let i = 0; i < tabs.length; i++) {
       ok(!tabs[i].hidden, "tab hidden value is correct");
     }
   }
 
   // Close second window.
   await BrowserTestUtils.closeWindow(otherwin);
 
diff --git a/browser/components/places/content/browserPlacesViews.js b/browser/components/places/content/browserPlacesViews.js
--- a/browser/components/places/content/browserPlacesViews.js
+++ b/browser/components/places/content/browserPlacesViews.js
@@ -1038,17 +1038,17 @@ PlacesToolbar.prototype = {
   async _rebuild() {
     // Clear out references to existing nodes, since they will be removed
     // and re-added.
     if (this._overFolder.elt)
       this._clearOverFolder();
 
     this._openedMenuButton = null;
     while (this._rootElt.hasChildNodes()) {
-      this._rootElt.firstElementChild.remove();
+      this._rootElt.firstChild.remove();
     }
 
     let cc = this._resultNode.childCount;
     if (cc > 0) {
       // There could be a lot of nodes, but we only want to build the ones that
       // are more likely to be shown, not all of them.
       // We also don't want to wait for reflows at every node insertion, to
       // calculate a precise number of visible items, thus we guess a size from
@@ -2115,17 +2115,17 @@ PlacesPanelMenuView.prototype = {
 
   invalidateContainer: function PAMV_invalidateContainer(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     if (elt != this._rootElt)
       return;
 
     // Container is the toolbar itself.
     while (this._rootElt.hasChildNodes()) {
-      this._rootElt.firstElementChild.remove();
+      this._rootElt.firstChild.remove();
     }
 
     let fragment = document.createDocumentFragment();
     for (let i = 0; i < this._resultNode.childCount; ++i) {
       this._insertNewItem(this._resultNode.getChild(i), fragment);
     }
     this._rootElt.appendChild(fragment);
   }
diff --git a/browser/components/syncedtabs/TabListView.js b/browser/components/syncedtabs/TabListView.js
--- a/browser/components/syncedtabs/TabListView.js
+++ b/browser/components/syncedtabs/TabListView.js
@@ -172,18 +172,18 @@ TabListView.prototype = {
   },
 
   _createTab() {
     return this._doc.importNode(this._tabTemplate.content, true).firstElementChild;
   },
 
   _clearChilden(node) {
     let parent = node || this.container;
-    while (parent.firstElementChild) {
-      parent.firstElementChild.remove();
+    while (parent.firstChild) {
+      parent.firstChild.remove();
     }
   },
 
   // These listeners are attached only once, when we initialize the view
   _attachFixedListeners() {
     this.tabsFilter.addEventListener("input", this.onFilter.bind(this));
     this.tabsFilter.addEventListener("focus", this.onFilterFocus.bind(this));
     this.tabsFilter.addEventListener("blur", this.onFilterBlur.bind(this));
diff --git a/browser/components/uitour/UITour.jsm b/browser/components/uitour/UITour.jsm
--- a/browser/components/uitour/UITour.jsm
+++ b/browser/components/uitour/UITour.jsm
@@ -1132,18 +1132,18 @@ var UITour = {
         tooltip.hidePopup();
       }
 
       tooltipTitle.textContent = aTitle || "";
       tooltipDesc.textContent = aDescription || "";
       tooltipIcon.src = aIconURL || "";
       tooltipIcon.hidden = !aIconURL;
 
-      while (tooltipButtons.firstElementChild)
-        tooltipButtons.firstElementChild.remove();
+      while (tooltipButtons.firstChild)
+        tooltipButtons.firstChild.remove();
 
       for (let button of aButtons) {
         let isButton = button.style != "text";
         let el = document.createElement(isButton ? "button" : "label");
         el.setAttribute(isButton ? "label" : "value", button.label);
 
         if (isButton) {
           if (button.iconURL)
@@ -1230,18 +1230,18 @@ var UITour = {
   },
 
   _hideInfoElement(aWindow) {
     let document = aWindow.document;
     let tooltip = document.getElementById("UITourTooltip");
     this._removeAnnotationPanelMutationObserver(tooltip);
     tooltip.hidePopup();
     let tooltipButtons = document.getElementById("UITourTooltipButtons");
-    while (tooltipButtons.firstElementChild)
-      tooltipButtons.firstElementChild.remove();
+    while (tooltipButtons.firstChild)
+      tooltipButtons.firstChild.remove();
   },
 
   hideInfo(aWindow) {
     this._hideInfoElement(aWindow);
     this._setMenuStateForAnnotation(aWindow, false, "appMenu");
     this._setMenuStateForAnnotation(aWindow, false, "pageActionPanel");
   },
 
diff --git a/browser/modules/ExtensionsUI.jsm b/browser/modules/ExtensionsUI.jsm
--- a/browser/modules/ExtensionsUI.jsm
+++ b/browser/modules/ExtensionsUI.jsm
@@ -284,18 +284,18 @@ var ExtensionsUI = {
           textEl.textContent = strings.text;
           textEl.hidden = !strings.text;
 
           let listIntroEl = doc.getElementById("addon-webext-perm-intro");
           listIntroEl.textContent = strings.listIntro;
           listIntroEl.hidden = (strings.msgs.length == 0);
 
           let list = doc.getElementById("addon-webext-perm-list");
-          while (list.firstElementChild) {
-            list.firstElementChild.remove();
+          while (list.firstChild) {
+            list.firstChild.remove();
           }
 
           for (let msg of strings.msgs) {
             let item = doc.createElementNS(HTML_NS, "li");
             item.textContent = msg;
             list.appendChild(item);
           }
         } else if (topic == "swapping") {
diff --git a/browser/modules/webrtcUI.jsm b/browser/modules/webrtcUI.jsm
--- a/browser/modules/webrtcUI.jsm
+++ b/browser/modules/webrtcUI.jsm
@@ -945,18 +945,18 @@ function getGlobalIndicator() {
         item.addEventListener("command", indicator._command);
         this.appendChild(item);
       }
 
       return true;
     },
 
     _popupHiding(aEvent) {
-      while (this.firstElementChild)
-        this.firstElementChild.remove();
+      while (this.firstChild)
+        this.firstChild.remove();
     },
 
     _setIndicatorState(aName, aState) {
       let field = "_" + aName.toLowerCase();
       if (aState && !this[field]) {
         let menu = this._hiddenDoc.createElement("menu");
         menu.setAttribute("id", "webRTC-sharing" + aName + "-menu");
 
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -581,17 +581,17 @@
         </body>
       </method>
 
       <property name="children" readonly="true">
         <getter>
           <![CDATA[
             let iface = Ci.nsIDOMXULSelectControlItemElement;
             let children = Array.from(this.childNodes)
-                                .filter(node => node instanceof iface);
+                                .filter(node => node.nodeType == 1 && node instanceof iface);
             if (this.dir == "reverse" && this._mayReverse) {
               children.reverse();
             }
             return children;
           ]]>
         </getter>
       </property>
 
