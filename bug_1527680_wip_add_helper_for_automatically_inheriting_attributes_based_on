# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1550090013 28800
#      Wed Feb 13 12:33:33 2019 -0800
# Node ID 4063b414c806918997b9d53294761fce19ac7389
# Parent  0a9a4f8d79e97d6de743d4a95c915388906dde3b
Bug 1527680 - WIP - Add helper for automatically inheriting attributes based on a map of selectors to attributes

Differential Revision: https://phabricator.services.mozilla.com/D19702

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -42,16 +42,75 @@ window.addEventListener("DOMContentLoade
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 const MozElements = {};
 
 const MozElementMixin = Base => class MozElement extends Base {
+  static get inheritedAttributesSelectorMap() {
+    return null;
+  }
+
+  static get observedAttributes() {
+    let {inheritedAttributesSelectorMap} = this;
+    if (!inheritedAttributesSelectorMap) {
+      return [];
+    }
+
+    let allAttributes = new Set();
+    for (let attrStr of inheritedAttributesSelectorMap.values()) {
+      for (let attrName of attrStr.split(",")) {
+        let split = attrName.split("=");
+        if (split.length == 2) {
+          attrName = split[1];
+        }
+        allAttributes.add(attrName);
+      }
+    }
+    return [...allAttributes];
+  }
+
+  inheritAttributes() {
+    let {inheritedAttributesSelectorMap} = this.constructor;
+    if (!inheritedAttributesSelectorMap) {
+      return;
+    }
+
+    // Loop through the list of selectors and cache them into element references
+    // so we don't need to do this on every attribute change. The element can
+    // invalidate the cache by setting `this.inheritedAttributesElementMap = null`.
+    if (!this.inheritedAttributesElementMap) {
+      this.inheritedAttributesElementMap = new Map();
+      for (let [selector, attr] of inheritedAttributesSelectorMap) {
+        let el = this.querySelector(selector);
+        if (this.inheritedAttributesElementMap.has(el)) {
+          console.error(`Error: duplicate element encountered with ${selector}`);
+        }
+
+        this.inheritedAttributesElementMap.set(el, attr);
+      }
+    }
+
+    for (let [ el, attrs ] of this.inheritedAttributesElementMap.entries()) {
+      for (let attr of attrs.split(",")) {
+        this.inheritAttribute(el, attr);
+      }
+    }
+  }
+
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady || oldValue === newValue) {
+      return;
+    }
+
+    this.inheritAttributes();
+  }
+
   /*
    * Implements attribute inheritance by a child element. Uses XBL @inherit
    * syntax of |to=from|.
    *
    * @param {element} child
    *        A child element that inherits an attribute.
    * @param {string} attr
    *        An attribute to inherit. Optionally in the form of |to=from|, where
@@ -69,23 +128,23 @@ const MozElementMixin = Base => class Mo
       attrNewName = split[0];
     }
     let hasAttr = this.hasAttribute(attrName);
     let attrValue = this.getAttribute(attrName);
 
     // If our attribute hasn't changed since we last inherited, we don't want to
     // propagate it down to the child. This prevents overriding an attribute that's
     // been changed on the child (for instance, [checked]).
-    if (!this._inheritedAttributesMap) {
-      this._inheritedAttributesMap = new WeakMap();
+    if (!this._inheritedAttributesCacheMap) {
+      this._inheritedAttributesCacheMap = new WeakMap();
     }
-    if (!this._inheritedAttributesMap.has(child)) {
-      this._inheritedAttributesMap.set(child, {});
+    if (!this._inheritedAttributesCacheMap.has(child)) {
+      this._inheritedAttributesCacheMap.set(child, {});
     }
-    let lastInheritedAttributes = this._inheritedAttributesMap.get(child);
+    let lastInheritedAttributes = this._inheritedAttributesCacheMap.get(child);
 
     if ((hasAttr && attrValue === lastInheritedAttributes[attrName]) ||
         (!hasAttr && !lastInheritedAttributes.hasOwnProperty(attrName))) {
       // We got a request to inherit an unchanged attribute - bail.
       return;
     }
 
     // Store the value we're about to pass down to the child.
diff --git a/toolkit/content/widgets/autocomplete-richlistitem.js b/toolkit/content/widgets/autocomplete-richlistitem.js
--- a/toolkit/content/widgets/autocomplete-richlistitem.js
+++ b/toolkit/content/widgets/autocomplete-richlistitem.js
@@ -56,66 +56,39 @@ MozElements.MozAutocompleteRichlistitem 
 
   connectedCallback() {
     if (this.delayConnectedCallback()) {
       return;
     }
 
     this.textContent = "";
     this.appendChild(MozXULElement.parseXULToFragment(this._markup));
+    this.inheritedAttributesElementMap = null;
 
     this._boundaryCutoff = null;
     this._inOverflow = false;
 
-    this._updateAttributes();
+    this.inheritAttributes();
     this._adjustAcItem();
   }
 
-  static get observedAttributes() {
-    return [
-      "actiontype",
-      "current",
-      "selected",
-      "image",
-      "type",
-    ];
-  }
-
-  get inheritedAttributeMap() {
-    if (!this.__inheritedAttributeMap) {
-      this.__inheritedAttributeMap = new Map([
-        [ this.querySelector(".ac-type-icon"), [ "selected", "current", "type" ] ],
-        [ this.querySelector(".ac-site-icon"), [ "src=image", "selected", "type" ] ],
-        [ this.querySelector(".ac-title"), [ "selected" ] ],
-        [ this.querySelector(".ac-title-text"), [ "selected" ] ],
-        [ this.querySelector(".ac-tags"), [ "selected" ] ],
-        [ this.querySelector(".ac-tags-text"), [ "selected" ] ],
-        [ this.querySelector(".ac-separator"), [ "selected", "actiontype", "type" ] ],
-        [ this.querySelector(".ac-url"), [ "selected", "actiontype" ] ],
-        [ this.querySelector(".ac-url-text"), [ "selected" ] ],
-        [ this.querySelector(".ac-action"), [ "selected", "actiontype" ] ],
-        [ this.querySelector(".ac-action-text"), [ "selected" ] ],
-      ]);
-    }
-    return this.__inheritedAttributeMap;
-  }
-
-  attributeChangedCallback(name, oldValue, newValue) {
-    if (this.isConnectedAndReady && oldValue != newValue &&
-        this.constructor.observedAttributes.includes(name)) {
-      this._updateAttributes();
-    }
-  }
-
-  _updateAttributes() {
-    for (let [ el, attrs ] of this.inheritedAttributeMap.entries()) {
-      for (let attr of attrs) {
-        this.inheritAttribute(el, attr);
-      }
-    }
+  static get inheritedAttributesSelectorMap() {
+    return new Map([
+      [".ac-type-icon", "selected,current,type"],
+      [".ac-site-icon", "src=image,selected,type"],
+      [".ac-title", "selected"],
+      [".ac-title-text", "selected"],
+      [".ac-tags", "selected"],
+      [".ac-tags-text", "selected"],
+      [".ac-separator", "selected,actiontype,type"],
+      [".ac-url", "selected,actiontype"],
+      [".ac-url-text", "selected"],
+      [".ac-action", "selected,actiontype"],
+      [".ac-action-text", "selected"],
+    ]);
   }
 
   get _markup() {
     return `
       <image class="ac-type-icon"></image>
       <image class="ac-site-icon"></image>
       <hbox class="ac-title" align="center">
         <description class="ac-text-overflow-container">
@@ -937,41 +910,28 @@ class MozAutocompleteRichlistitemInsecur
     super.connectedCallback();
 
     // Unlike other autocomplete items, the height of the insecure warning
     // increases by wrapping. So "forceHandleUnderflow" is for container to
     // recalculate an item's height and width.
     this.classList.add("forceHandleUnderflow");
   }
 
-  static get observedAttributes() {
-    return [
-      "actiontype",
-      "current",
-      "selected",
-      "image",
-      "type",
-    ];
-  }
-
-  get inheritedAttributeMap() {
-    if (!this.__inheritedAttributeMap) {
-      this.__inheritedAttributeMap = new Map([
-        [ this.querySelector(".ac-type-icon"), [ "selected", "current", "type" ] ],
-        [ this.querySelector(".ac-site-icon"), [ "src=image", "selected", "type" ] ],
-        [ this.querySelector(".ac-title-text"), [ "selected" ] ],
-        [ this.querySelector(".ac-tags-text"), [ "selected" ] ],
-        [ this.querySelector(".ac-separator"), [ "selected", "actiontype", "type" ] ],
-        [ this.querySelector(".ac-url"), [ "selected", "actiontype" ] ],
-        [ this.querySelector(".ac-url-text"), [ "selected" ] ],
-        [ this.querySelector(".ac-action"), [ "selected", "actiontype" ] ],
-        [ this.querySelector(".ac-action-text"), [ "selected" ] ],
-      ]);
-    }
-    return this.__inheritedAttributeMap;
+  static get inheritedAttributesSelectorMap() {
+    return new Map([
+      [".ac-type-icon", "selected,current,type"],
+      [".ac-site-icon", "src=image,selected,type"],
+      [".ac-title-text", "selected"],
+      [".ac-tags-text", "selected"],
+      [".ac-separator", "selected,actiontype,type"],
+      [".ac-url", "selected,actiontype"],
+      [".ac-url-text", "selected"],
+      [".ac-action", "selected,actiontype"],
+      [".ac-action-text", "selected"],
+    ]);
   }
 
   get _markup() {
     return `
       <image class="ac-type-icon"></image>
       <image class="ac-site-icon"></image>
       <vbox class="ac-title" align="left">
         <description class="ac-text-overflow-container">
diff --git a/toolkit/content/widgets/popupnotification.js b/toolkit/content/widgets/popupnotification.js
--- a/toolkit/content/widgets/popupnotification.js
+++ b/toolkit/content/widgets/popupnotification.js
@@ -3,73 +3,44 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 class MozPopupNotification extends MozXULElement {
-  static get observedAttributes() {
-    return [
-      "buttonaccesskey",
-      "buttoncommand",
-      "buttonhighlight",
-      "buttonlabel",
-      "closebuttoncommand",
-      "closebuttonhidden",
-      "dropmarkerhidden",
-      "dropmarkerpopupshown",
-      "endlabel",
-      "icon",
-      "iconclass",
-      "label",
-      "learnmoreclick",
-      "learnmoreurl",
-      "mainactiondisabled",
-      "menucommand",
-      "name",
-      "origin",
-      "origin",
-      "popupid",
-      "secondarybuttonaccesskey",
-      "secondarybuttoncommand",
-      "secondarybuttonhidden",
-      "secondarybuttonlabel",
-      "secondendlabel",
-      "secondname",
-      "warninghidden",
-      "warninglabel",
-    ];
-  }
-
-  _updateAttributes() {
-    for (let [ el, attrs ] of this._inheritedAttributeMap.entries()) {
-      for (let attr of attrs) {
-        this.inheritAttribute(el, attr);
-      }
-    }
-  }
-
-  get _inheritedAttributeMap() {
-    if (!this.__inheritedAttributeMap) {
-      this.__inheritedAttributeMap = new Map();
-      for (let el of this.querySelectorAll("[inherits]")) {
-        this.__inheritedAttributeMap.set(el, el.getAttribute("inherits").split(","));
-      }
-    }
-    return this.__inheritedAttributeMap;
+  static get inheritedAttributesSelectorMap() {
+    return new Map([
+      [".popup-notification-icon", "popupid,src=icon,class=iconclass"],
+      [".popup-notification-origin", "value=origin,tooltiptext=origin"],
+      [".popup-notification-description", "popupid"],
+      [".popup-notification-description > span:first-of-type", "text=label,popupid"],
+      [".popup-notification-description > b:first-of-type", "text=name,popupid"],
+      [".popup-notification-description > span:nth-of-type(2)", "text=endlabel,popupid"],
+      [".popup-notification-description > b:last-of-type", "text=secondname,popupid"],
+      [".popup-notification-description > span:last-of-type", "secondendlabel,popupid"],
+      [".popup-notification-closebutton", "oncommand=closebuttoncommand,hidden=closebuttonhidden"],
+      [".popup-notification-learnmore-link", "onclick=learnmoreclick,href=learnmoreurl"],
+      [".popup-notification-warning", "hidden=warninghidden,text=warninglabel"],
+      [".popup-notification-button-container > .popup-notification-secondary-button",
+          "oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden"],
+      [".popup-notification-button-container > toolbarseparator", "hidden=dropmarkerhidden"],
+      [".popup-notification-dropmarker", "onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden"],
+      [".popup-notification-dropmarker > menupopup", "oncommand=menucommand"],
+      [".popup-notification-primary-button", "oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,default=buttonhighlight,disabled=mainactiondisabled"],
+    ]);
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
-    if (!this._hasSlotted || oldValue === newValue) {
+    if (!this._hasSlotted) {
       return;
     }
 
-    this._updateAttributes();
+    super.attributeChangedCallback(name, oldValue, newValue);
   }
 
   show() {
     this.slotContents();
 
     if (this.checkboxState) {
       this.checkbox.checked = this.checkboxState.checked;
       this.checkbox.setAttribute("label", this.checkboxState.label);
@@ -135,17 +106,17 @@ class MozPopupNotification extends MozXU
     if (popupnotificationheader) {
       this.querySelector(".popup-notification-header-container").append(popupnotificationheader);
     }
 
     for (let popupnotificationcontent of this.querySelectorAll("popupnotificationcontent")) {
       this.appendNotificationContent(popupnotificationcontent);
     }
 
-    this._updateAttributes();
+    this.inheritAttributes();
   }
 
   appendNotificationContent(el) {
     let nextSibling = this.querySelector(".popup-notification-body > .popup-notification-learnmore-link");
     nextSibling.before(el);
   }
 }
 
