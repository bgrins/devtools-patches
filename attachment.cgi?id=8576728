# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Date 1426177791 -3600
#      Thu Mar 12 17:29:51 2015 +0100
# Node ID 02995ef7f469eb19e36a13418f17009d10f42fef
# Parent  cfd723d60ab67c70c8f03c0fac372276f1d3a965
Bug 1139187 - 1 - Add drag/drop support to the GeometryHighlighter to move positioned elements in content

diff --git a/browser/devtools/inspector/test/browser.ini b/browser/devtools/inspector/test/browser.ini
--- a/browser/devtools/inspector/test/browser.ini
+++ b/browser/devtools/inspector/test/browser.ini
@@ -43,16 +43,18 @@ skip-if = e10s # GCLI isn't e10s compati
 [browser_inspector_highlighter-comments.js]
 [browser_inspector_highlighter-csstransform_01.js]
 [browser_inspector_highlighter-csstransform_02.js]
 [browser_inspector_highlighter-geometry_01.js]
 [browser_inspector_highlighter-geometry_02.js]
 [browser_inspector_highlighter-geometry_03.js]
 [browser_inspector_highlighter-geometry_04.js]
 [browser_inspector_highlighter-geometry_05.js]
+[browser_inspector_highlighter-geometry_06.js]
+[browser_inspector_highlighter-geometry_07.js]
 [browser_inspector_highlighter-hover_01.js]
 [browser_inspector_highlighter-hover_02.js]
 [browser_inspector_highlighter-hover_03.js]
 [browser_inspector_highlighter-iframes.js]
 [browser_inspector_highlighter-keybinding_01.js]
 [browser_inspector_highlighter-keybinding_02.js]
 [browser_inspector_highlighter-keybinding_03.js]
 [browser_inspector_highlighter-options.js]
diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_06.js b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_06.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_06.js
@@ -0,0 +1,107 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Test that elements positioned with at least one of top, right, bottom, left
+// can be moved in content by drag/dropping with the GeometryEditorHighlighter.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+
+const TEST_DATA = [{
+  desc: "Moving a top/left absolute positioned element along x and y",
+  selector: "#absolute-container",
+  arrowsBefore: {
+   "top": {x1: 651, y1: 0, x2: 651, y2: 50},
+   "left": {x1: 0, y1: 251, x2: 400, y2: 251}
+  },
+  dragFrom: {x:410, y:60},
+  dragTo: {x:510, y:110},
+  arrowsAfter: {
+   "top": {x1: 751, y1: 0, x2: 751, y2: 100},
+   "left": {x1: 0, y1: 301, x2: 500, y2: 301}
+  }
+}, {
+  desc: "Moving a top/bottom absolute positioned element should only move along y",
+  selector: ".absolute-top-bottom",
+  arrowsBefore: {
+   "top": {x1: 546, y1: 101, x2: 546, y2: 321},
+   "bottom": {x1: 546, y1: 501, x2: 546, y2: 471}
+  },
+  dragFrom: {x:510, y:330},
+  dragTo: {x:600, y:360},
+  arrowsAfter: {
+   "top": {x1: 546, y1: 101, x2: 546, y2: 351},
+   "bottom": {x1: 546, y1: 501, x2: 546, y2: 501}
+  }
+}, {
+  desc: "Moving a right absolute positioned element should only move along x",
+  selector: ".absolute-right",
+  arrowsBefore: {
+   "right": {x1: 1001, y1: 188, x2: 951, y2: 188}
+  },
+  dragFrom: {x:930, y:230},
+  dragTo: {x:530, y:500},
+  arrowsAfter: {
+   "right": {x1: 1001, y1: 188, x2: 551, y2: 188}
+  }
+}];
+
+add_task(function*() {
+  let {inspector, toolbox} = yield openInspectorForURL(TEST_URL);
+  let front = inspector.inspector;
+  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+
+  for (let data of TEST_DATA) {
+    info("Running test case: " + data.desc);
+
+    info("Highlighting the test node " + data.selector);
+    let node = yield getNodeFront(data.selector, inspector);
+    yield highlighter.show(node);
+
+    info("Checking the arrow coordinates before dragging");
+    yield checkArrows(highlighter, data.arrowsBefore);
+
+    info("Moving the node by dragging the highlighter");
+    yield dragDrop(highlighter, data.dragFrom, data.dragTo);
+
+    info("Checking the new arrow coordinates");
+    yield checkArrows(highlighter, data.arrowsAfter);
+
+    info("Hiding the highlighter");
+    yield highlighter.hide();
+  }
+
+  yield highlighter.finalize();
+});
+
+function* dragDrop(highlighter, from, to) {
+  info("Simulating drag and drop from " +
+    from.x + "/" + from.y + " to " + to.x + "/" + to.y);
+
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: from.x, y: from.y, options: {type: "mousedown"}});
+  let onUpdated = waitForHighlighterEvent("updated", highlighter);
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mousemove"}});
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mouseup"}});
+
+  yield onUpdated;
+}
+
+function* checkArrows(highlighter, arrows) {
+  for (let side in arrows) {
+    yield checkArrow(highlighter, side, arrows[side]);
+  }
+}
+
+function* checkArrow(highlighter, name, expectedCoordinates) {
+  for (let coordinate in expectedCoordinates) {
+    let value = yield getHighlighterNodeAttribute(highlighter, ID + "arrow-" + name, coordinate);
+    is(Math.floor(value), expectedCoordinates[coordinate],
+      coordinate + " coordinate for arrow " + name + " is correct");
+  }
+}
diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_07.js b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_07.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_07.js
@@ -0,0 +1,80 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Test that when DOM elements change, the highlighter changes too.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+
+add_task(function*() {
+  let {inspector, toolbox} = yield openInspectorForURL(TEST_URL);
+  let front = inspector.inspector;
+
+  info("Getting the test node");
+  let node = yield getNodeFront("#absolute-container", inspector);
+
+  info("Highlighting the node");
+  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  yield highlighter.show(node);
+
+  info("Checking the arrow coordinates before updating the node");
+  yield checkArrows(highlighter, {
+   "top": {x1: 651, y1: 0, x2: 651, y2: 50},
+   "left": {x1: 0, y1: 251, x2: 400, y2: 251},
+  });
+
+  info("Modifying the node's top and left positions");
+  yield setHighlightedNodeStyle(highlighter, "top: 100px; left: 300px;");
+
+  info("Checking the arrow coordinates now that the node has changed");
+  yield checkArrows(highlighter, {
+   "top": {x1: 551, y1: 0, x2: 551, y2: 100},
+   "left": {x1: 0, y1: 301, x2: 300, y2: 301},
+  });
+
+  info("Checking the size label before changing the node's size");
+  yield checkSizeLabel(highlighter, "500px", "400px");
+
+  info("Modifying the node's width and height");
+  yield setHighlightedNodeStyle(highlighter,
+    "top: 100px; left: 300px; width: 100px; height: 200px;");
+
+  info("Checking the size label now that the node's size has changed");
+  yield checkSizeLabel(highlighter, "100px", "200px");
+
+  info("Hiding the highlighter");
+  yield highlighter.hide();
+  yield highlighter.finalize();
+});
+
+function* checkSizeLabel(highlighter, width, height) {
+  let str = yield getHighlighterNodeTextContent(highlighter, ID + "label-text-size");
+  ok(str.contains(width) && str.contains(height), "The size label string is correct");
+}
+
+function* checkArrows(highlighter, arrows) {
+  for (let side in arrows) {
+    yield checkArrow(highlighter, side, arrows[side]);
+  }
+}
+
+function* checkArrow(highlighter, name, expectedCoordinates) {
+  for (let coordinate in expectedCoordinates) {
+    let value = yield getHighlighterNodeAttribute(highlighter, ID + "arrow-" + name, coordinate);
+    is(Math.floor(value), expectedCoordinates[coordinate],
+      coordinate + " coordinate for arrow " + name + " is correct");
+  }
+}
+
+function* setHighlightedNodeStyle(highlighter, style) {
+  let {actorID, connPrefix} = getHighlighterActorID(highlighter);
+  yield executeInContent("Test:ChangeHighlightedNodeWaitForUpdate", {
+    name: "style",
+    value: style,
+    actorID,
+    connPrefix
+  });
+}
diff --git a/browser/devtools/inspector/test/doc_frame_script.js b/browser/devtools/inspector/test/doc_frame_script.js
--- a/browser/devtools/inspector/test/doc_frame_script.js
+++ b/browser/devtools/inspector/test/doc_frame_script.js
@@ -248,20 +248,22 @@ addMessageListener("Test:GetAllAdjustedQ
 addMessageListener("Test:SynthesizeMouse", function(msg) {
   let {x, y, center, options, selector} = msg.data;
   let {node} = msg.objects;
 
   if (!node && selector) {
     node = content.document.querySelector(selector);
   }
 
-  if (center) {
+  if (center && node) {
     EventUtils.synthesizeMouseAtCenter(node, options, node.ownerDocument.defaultView);
+  } else if (node) {
+    EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
   } else {
-    EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
+    EventUtils.synthesizeMouseAtPoint(x, y, options, content);
   }
 
   // Most consumers won't need to listen to this message, unless they want to
   // wait for the mouse event to be synthesized and don't have another event
   // to listen to instead.
   sendAsyncMessage("Test:SynthesizeMouse");
 });
 
diff --git a/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html b/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html
--- a/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html
+++ b/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html
@@ -57,16 +57,33 @@
     .relative {
       position: relative;
       top: 10%;
       left: 50%;
       height: 10px;
       border: 1px solid blue;
     }
 
+    .absolute-top-bottom {
+      position: absolute;
+      top: 220px;
+      bottom: 30px;
+      width: 90px;
+      background: red;
+    }
+
+    .absolute-right {
+      position: absolute;
+      right: 50px;
+      width: 50px;
+      height: 50px;
+      background: green;
+      margin-top: 100px;
+    }
+
     .fixed {
       position: fixed;
       top: 400px;
       left: 0;
       width: 50px;
       height: 50px;
       border-radius: 50%;
       background: green;
@@ -78,13 +95,15 @@
     <div id="node2" class="positioned-child pos-top-left pos-bottom-right">
       <div id="node3" class="inline-positioned positioned-child pos-top-left" style="width:50px;height:50px;"></div>
     </div>
   </div>
 
   <div id="absolute-container">
     <div class="absolute-all-4"></div>
     <div class="relative"></div>
+    <div class="absolute-top-bottom"></div>
+    <div class="absolute-right"></div>
   </div>
 
   <div class="fixed"></div>
 </body>
 </html>
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -198,17 +198,17 @@
   stroke-dasharray: 5 3;
   fill: transparent;
 }
 
 :-moz-native-anonymous .geometry-editor-current-node {
   stroke: #08c;
   shape-rendering: crispEdges;
   fill: #87ceeb;
-  opacity: 0.6;
+  opacity: 0.4;
 }
 
 :-moz-native-anonymous .geometry-editor-arrow {
   stroke: #08c;
   shape-rendering: crispEdges;
 }
 
 :-moz-native-anonymous .geometry-editor-label-bubble {
@@ -217,9 +217,10 @@
 }
 
 :-moz-native-anonymous .geometry-editor-label-text {
   fill: hsl(216,33%,97%);
   font: message-box;
   font-size: 10px;
   text-anchor: middle;
   dominant-baseline: middle;
+  -moz-user-select: none;
 }
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -2021,16 +2021,20 @@ let GeoProp = {
 function GeometryEditorHighlighter(tabActor) {
   AutoRefreshHighlighter.call(this, tabActor);
 
   // The list of element geometry properties that can be set.
   this.definedProperties = new Map();
 
   this.markup = new CanvasFrameAnonymousContentHelper(tabActor,
     this._buildMarkup.bind(this));
+
+  this.onCurrentNodeMouseDown = this.onCurrentNodeMouseDown.bind(this);
+  this.onCurrentNodeMouseUp = this.onCurrentNodeMouseUp.bind(this);
+  this.onCurrentNodeMouseMove = this.onCurrentNodeMouseMove.bind(this);
 }
 
 GeometryEditorHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
   typeName: "GeometryEditorHighlighter",
 
   ID_CLASS_PREFIX: "geometry-editor-",
 
   _buildMarkup: function() {
@@ -2048,17 +2052,18 @@ GeometryEditorHighlighter.prototype = He
     });
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: root,
       attributes: {
         "id": "elements",
         "width": "100%",
-        "height": "100%"
+        "height": "100%",
+        "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     // Offset parent node highlighter.
     createSVGNode(this.win, {
       nodeType: "polygon",
       parent: svg,
@@ -2260,29 +2265,44 @@ GeometryEditorHighlighter.prototype = He
       if (pos === "relative" && (hasRightAndLeft || hasBottomAndTop)) {
         props.delete(name);
       }
     }
 
     return props;
   },
 
+  get hasAtLeastOneSide() {
+    return GeoProp.containsSide([...this.definedProperties.keys()]) &&
+           this.computedStyle.position !== "static";
+  },
+
+  get hasAtLeastOneSize() {
+    return GeoProp.containsSize([...this.definedProperties.keys()])
+  },
+
   _show: function() {
     this.computedStyle = CssLogic.getComputedStyle(this.currentNode);
     let pos = this.computedStyle.position;
     // XXX: sticky positioning is ignored for now. To be implemented next.
     if (pos === "sticky") {
       this.hide();
       return;
     }
 
     let hasUpdated = this._update();
     if (!hasUpdated) {
       this.hide();
     }
+
+    // Make the current node movable if the defined properties allow it.
+    if (this.hasAtLeastOneSide) {
+      let box = this.getElement("current-node");
+      box.addNoPropagationEventListener("mousedown", this.onCurrentNodeMouseDown);
+    }
   },
 
   _update: function() {
     // At each update, the position or/and size may have changed, so get the
     // list of defined properties, and re-position the arrows and highlighters.
     this.definedProperties = this.getDefinedGeometryProperties();
 
     let isStatic = this.computedStyle.position === "static";
@@ -2290,16 +2310,18 @@ GeometryEditorHighlighter.prototype = He
 
     if (!this.definedProperties.size) {
       console.warn("The element does not have editable geometry properties");
       return false;
     }
 
     setIgnoreLayoutChanges(true);
 
+    svg.removeAttribute("hidden");
+
     // Update the highlighters and arrows.
     this.updateOffsetParent();
     this.updateCurrentNode();
     this.updateArrows();
     this.updateSize();
 
     // Avoid zooming the arrows when content is zoomed.
     this.markup.scaleRootElement(this.currentNode, this.ID_CLASS_PREFIX + "root");
@@ -2374,19 +2396,25 @@ GeometryEditorHighlighter.prototype = He
     box.removeAttribute("hidden");
   },
 
   _hide: function() {
     setIgnoreLayoutChanges(true);
 
     this.getElement("current-node").setAttribute("hidden", "true");
     this.getElement("offset-parent").setAttribute("hidden", "true");
+    this.getElement("elements").setAttribute("hidden", "true");
     this.hideArrows();
     this.hideSize();
 
+    if (this.hasAtLeastOneSide) {
+      let box = this.getElement("current-node");
+      box.removeNoPropagationEventListener("mousedown", this.onCurrentNodeMouseDown);
+    }
+
     this.definedProperties.clear();
 
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   hideArrows: function() {
     for (let side of GeoProp.SIDES) {
       this.getElement("arrow-" + side).setAttribute("hidden", "true");
@@ -2517,16 +2545,81 @@ GeometryEditorHighlighter.prototype = He
       }
     }
     let labelCross = crossPos;
     labelEl.setAttribute("transform", GeoProp.isHorizontal(side)
                          ? "translate(" + labelMain + " " + labelCross + ")"
                          : "translate(" + labelCross + " " + labelMain + ")");
     labelEl.removeAttribute("hidden");
     labelTextEl.setTextContent(labelValue);
+  },
+
+  onCurrentNodeMouseDown: function(e) {
+    if (this.isMovingCurrentNode) {
+      return;
+    }
+
+    let target = getPageListenerTarget(this.tabActor);
+    target.addEventListener("mouseup", this.onCurrentNodeMouseUp);
+    target.addEventListener("mousemove", this.onCurrentNodeMouseMove);
+
+    this.nodeStartPos = {x: e.clientX, y: e.clientY};
+    this.isMovingCurrentNode = true;
+  },
+
+  onCurrentNodeMouseUp: function(e) {
+    if (!this.isMovingCurrentNode) {
+      return;
+    }
+
+    let target = getPageListenerTarget(this.tabActor);
+    target.removeEventListener("mouseup", this.onCurrentNodeMouseUp);
+    target.removeEventListener("mousemove", this.onCurrentNodeMouseMove);
+
+    this.isMovingCurrentNode = false;
+  },
+
+  onCurrentNodeMouseMove: function(e) {
+    if (!this.isMovingCurrentNode) {
+      return;
+    }
+
+    let delta = {
+      x: e.clientX - this.nodeStartPos.x,
+      y: e.clientY - this.nodeStartPos.y
+    };
+
+    // Decide how to move the node depending on which properties are set.
+    for (let side of GeoProp.SIDES) {
+      this.updateProperty(side, delta);
+    }
+
+    this.nodeStartPos = {x: e.clientX, y: e.clientY};
+  },
+
+  updateProperty: function(name, delta={x:0, y:0}) {
+    let prop = this.definedProperties.get(name);
+    if (!prop) {
+      return;
+    }
+
+    let moveBy = delta[GeoProp.axis(name)];
+    if (GeoProp.isInverted(name)) {
+      moveBy *= -1;
+    }
+
+    let value = prop.cssRule.style.getPropertyValue(name);
+    let computedValue = this.computedStyle.getPropertyValue(name);
+    let [unit] = /[^\d.-]+/g.exec(value) || [""];
+    let ratio = parseFloat(value) / parseFloat(computedValue);
+
+    moveBy *= ratio || 1;
+    let newValue = (parseFloat(value) + moveBy) + unit;
+
+    prop.cssRule.style.setProperty(name, newValue);
   }
 });
 register(GeometryEditorHighlighter);
 exports.GeometryEditorHighlighter = GeometryEditorHighlighter;
 
 /**
  * The SimpleOutlineHighlighter is a class that has the same API than the
  * BoxModelHighlighter, but adds a pseudo-class on the target element itself
