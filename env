# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  46f8bf113210ab4936d1498bfaed49b737b4afd5

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -18,48 +18,54 @@ if (window.MozXULElement) {
   return;
 }
 
 const MozElements = {};
 window.MozElements = MozElements;
 
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
-const instrumentClasses = true; // Flip this to get logging for perf data at startup
+const env = Cc["@mozilla.org/process/environment;1"].getService(Ci.nsIEnvironment);
+const instrumentClasses = !!env.get("MOZ_INSTRUMENT_CUSTOM_ELEMENTS");
 const instrumentedClasses = new Set();
 const baseClasses = new WeakSet();
 
 // Wrap the normal customElements.define to give us a chance to modify the
 // class so we can instrument function calls in local development:
-let define = window.customElements.define;
-window.customElements.define = function(name, c, opts) {
-  instrumentCustomElementClass(c);
-  return define.call(this, name, c, opts);
-};
+
+if (instrumentClasses) {
+  let define = window.customElements.define;
+  window.customElements.define = function(name, c, opts) {
+    instrumentCustomElementClass(c);
+    return define.call(this, name, c, opts);
+  };
+}
 
 MozElements.printInstrumentation = function(collapsed) {
-  if (instrumentedClasses.size) {
+  let summaries = [];
+  for (let c of instrumentedClasses) {
+    let summary = c.__instrumentation_summary__;
+    if (summary) {
+      summaries.push(summary);
+    }
+  }
+  if (summaries.length) {
     let groupName = `Instrumentation data for custom elements in ${document.documentURI}`;
     console[collapsed ? "groupCollapsed" : "group"](groupName);
-    for (let c of instrumentedClasses) {
-      let stats = c.stats;
-      if (stats) {
-        console.log(`${c.name}`);
-        console.table(stats);
+    for (let summary of summaries) {
+      console.log(`${summary.name} (# instances: ${summary.instances})`);
+      if (Object.keys(summary.data).length > 1) {
+        console.table(summary.data);
       }
     }
     console.groupEnd(groupName);
   }
 };
 
 function instrumentCustomElementClass(c) {
-  if (!instrumentClasses) {
-    return;
-  }
-
   // Climb up prototype chain to see if we inherit from a MozElement.
   // Keep track of classes to instrument, for example:
   //   MozMenuCaption->MozMenuBase->BaseText->BaseControl->MozXULElement
   let inheritsFromBase = baseClasses.has(c);
   let classesToInstrument = [c];
   let proto = Object.getPrototypeOf(c);
   while (proto) {
     classesToInstrument.push(proto);
@@ -77,17 +83,17 @@ function instrumentCustomElementClass(c)
   }
 }
 
 function instrumentIndividualClass(c) {
   if (instrumentedClasses.has((c))) {
     return;
   }
   instrumentedClasses.add((c));
-  let data = {};
+  let data = { instances: 0 };
 
   function wrapFunction(name, fn) {
     return function() {
       if (!data[name]) {
         data[name] = {time: 0, calls: 0};
       }
       data[name].calls++;
       let n = performance.now();
@@ -119,39 +125,46 @@ function instrumentIndividualClass(c) {
   }
 
   // Handle instance properties
 
   for (let name of Object.getOwnPropertyNames(c.prototype)) {
     wrapPropertyDescriptor(c.prototype, name);
   }
 
-  Object.defineProperty(c, "stats", {
+  c.__instrumentation_data__ = data;
+  Object.defineProperty(c, "__instrumentation_summary__", {
     enumerable: false,
     configurable: false,
     get() {
-      if (!Object.keys(data).length) {
+      // let keys = Object.keys(data);
+      if (data.instances == 0) {
         return null;
       }
 
       let clonedData = JSON.parse(JSON.stringify(data));
+      delete clonedData.instances;
       let totalCalls = 0;
       let totalTime = 0;
       for (let d in clonedData) {
         let {time, calls} = clonedData[d];
         totalCalls += calls;
         totalTime += time;
         clonedData[d]["time (ms)"] = time;
         delete clonedData[d].time;
         clonedData[d].timePerCall = time / calls;
       }
 
       // Add a spaced-out final row with summed up totals
       clonedData["\ntotals"]  = { "time (ms)": `\n${totalTime}`, calls: `\n${totalCalls}`, timePerCall: `\n${totalTime / totalCalls}` };
-      return clonedData;
+      return {
+        instances: data.instances,
+        data: clonedData,
+        name: c.name,
+      };
     },
   });
 }
 
 // The listener of DOMContentLoaded must be set on window, rather than
 // document, because the window can go away before the event is fired.
 // In that case, we don't want to initialize anything, otherwise we
 // may be leaking things because they will never be destroyed after.
@@ -172,16 +185,27 @@ window.addEventListener("DOMContentLoade
   MozElements.printInstrumentation(true);
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 MozElements.MozElementMixin = Base => {
   let MozElementBase = class extends Base {
+  constructor() {
+    super();
+
+    if (instrumentClasses) {
+      let proto = this.constructor;
+      while (proto && proto != Base) {
+        proto.__instrumentation_data__.instances++;
+        proto = Object.getPrototypeOf(proto);
+      }
+    }
+  }
   /*
    * A declarative way to wire up attribute inheritance and automatically generate
    * the `observedAttributes` getter.  For example, if you returned:
    *    {
    *      ".foo": "bar,baz=bat"
    *    }
    *
    * Then the base class will automatically return ["bar", "bat"] from `observedAttributes`,
