# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c5173820ea08a8810c52d3812acf6c9ca18f1ca4
Bug 1479125 - Scripted rewrite of callers

perl -p -i -e 's/\.childNodes/.children/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js,richlistbox.xml} --exclude=browser//components/newtab/** --exclude=**/vendor/** ".childNodes" browser/ toolkit/`
perl -p -i -e 's/\.firstChild/.firstElementChild/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js,richlistbox.xml} --exclude=browser//components/newtab/** --exclude=**/vendor/** ".firstChild" browser/ toolkit/`
perl -p -i -e 's/\.lastChild/.lastElementChild/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js,richlistbox.xml} --exclude=browser//components/newtab/** --exclude=**/vendor/** ".lastChild" browser/ toolkit/`
perl -p -i -e 's/\.nextSibling/.nextElementSibling/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js,richlistbox.xml} --exclude=browser//components/newtab/** --exclude=**/vendor/** ".nextSibling" browser/ toolkit/`
perl -p -i -e 's/\.previousSibling/.previousElementSibling/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js,richlistbox.xml} --exclude=browser//components/newtab/** --exclude=**/vendor/** ".previousSibling" browser/ toolkit/`

diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -125,18 +125,18 @@ var gXPInstallObserver = {
 
     options.eventCallback = (aEvent) => {
       switch (aEvent) {
         case "removed":
           cancelInstallation();
           break;
         case "shown":
           let addonList = document.getElementById("addon-install-confirmation-content");
-          while (addonList.firstChild)
-            addonList.firstChild.remove();
+          while (addonList.firstElementChild)
+            addonList.firstElementChild.remove();
 
           for (let install of installInfo.installs) {
             let container = document.createXULElement("hbox");
 
             let name = document.createXULElement("label");
             name.setAttribute("value", install.addon.name);
             name.setAttribute("class", "addon-install-confirmation-name");
             container.appendChild(name);
@@ -319,17 +319,17 @@ var gXPInstallObserver = {
       messageString = PluralForm.get(installInfo.installs.length, messageString);
       messageString = messageString.replace("#1", installInfo.installs.length);
       options.installs = installInfo.installs;
       options.contentWindow = browser.contentWindow;
       options.sourceURI = browser.currentURI;
       options.eventCallback = function(aEvent) {
         switch (aEvent) {
           case "shown":
-            let notificationElement = [...this.owner.panel.childNodes]
+            let notificationElement = [...this.owner.panel.children]
                                       .find(n => n.notification == this);
             if (notificationElement) {
               if (Services.prefs.getBoolPref("xpinstall.customConfirmationUI", false)) {
                 notificationElement.setAttribute("mainactiondisabled", "true");
               } else {
                 notificationElement.button.hidden = true;
               }
             }
@@ -496,18 +496,18 @@ var gExtensionsNotifications = {
   },
 
   updateAlerts() {
     let sideloaded = ExtensionsUI.sideloaded;
     let updates = ExtensionsUI.updates;
 
     let container = PanelUI.addonNotificationContainer;
 
-    while (container.firstChild) {
-      container.firstChild.remove();
+    while (container.firstElementChild) {
+      container.firstElementChild.remove();
     }
 
     let items = 0;
     for (let update of updates) {
       if (++items > 4) {
         break;
       }
       let text = gNavigatorBundle.getFormattedString("webextPerms.updateMenuItem", [update.addon.name]);
diff --git a/browser/base/content/browser-ctrlTab.js b/browser/base/content/browser-ctrlTab.js
--- a/browser/base/content/browser-ctrlTab.js
+++ b/browser/base/content/browser-ctrlTab.js
@@ -260,18 +260,18 @@ var ctrlTab = {
   },
 
   updatePreview: function ctrlTab_updatePreview(aPreview, aTab) {
     if (aPreview == this.showAllButton)
       return;
 
     aPreview._tab = aTab;
 
-    if (aPreview._canvas.firstChild) {
-      aPreview._canvas.firstChild.remove();
+    if (aPreview._canvas.firstElementChild) {
+      aPreview._canvas.firstElementChild.remove();
     }
 
     if (aTab) {
       aPreview._canvas.appendChild(tabPreviews.get(aTab));
       aPreview._label.setAttribute("value", aTab.label);
       aPreview.setAttribute("tooltiptext", aTab.label);
       if (aTab.image) {
         aPreview._favicon.setAttribute("src", aTab.image);
diff --git a/browser/base/content/browser-customization.js b/browser/base/content/browser-customization.js
--- a/browser/base/content/browser-customization.js
+++ b/browser/base/content/browser-customization.js
@@ -25,17 +25,17 @@ var CustomizationHandler = {
 
   isCustomizing() {
     return document.documentElement.hasAttribute("customizing");
   },
 
   _customizationStarting() {
     // Disable the toolbar context menu items
     let menubar = document.getElementById("main-menubar");
-    for (let childNode of menubar.childNodes)
+    for (let childNode of menubar.children)
       childNode.setAttribute("disabled", true);
 
     let cmd = document.getElementById("cmd_CustomizeToolbars");
     cmd.setAttribute("disabled", "true");
 
     UpdateUrlbarSearchSplitterState();
 
     PlacesToolbarHelper.customizeStart();
@@ -64,16 +64,16 @@ var CustomizationHandler = {
     UpdateUrlbarSearchSplitterState();
 
     // Update the urlbar
     URLBarSetURI();
     XULBrowserWindow.asyncUpdateUI();
 
     // Re-enable parts of the UI we disabled during the dialog
     let menubar = document.getElementById("main-menubar");
-    for (let childNode of menubar.childNodes)
+    for (let childNode of menubar.children)
       childNode.setAttribute("disabled", false);
     let cmd = document.getElementById("cmd_CustomizeToolbars");
     cmd.removeAttribute("disabled");
 
     gBrowser.selectedBrowser.focus();
   }
 };
diff --git a/browser/base/content/browser-feeds.js b/browser/base/content/browser-feeds.js
--- a/browser/base/content/browser-feeds.js
+++ b/browser/base/content/browser-feeds.js
@@ -135,18 +135,18 @@ var FeedHandler = {
       // set (because it thinks it's already open).  onpopupshowing gets
       // called after the attribute is unset, and it doesn't get unset
       // if we return false.  so we unset it here; otherwise, the menu
       // refuses to work past this point.
       container.parentNode.removeAttribute("open");
       return false;
     }
 
-    for (let i = container.childNodes.length - 1; i >= 0; --i) {
-      let node = container.childNodes[i];
+    for (let i = container.children.length - 1; i >= 0; --i) {
+      let node = container.children[i];
       if (isSubview && node.localName == "label")
         continue;
       container.removeChild(node);
     }
 
     if (!feeds || feeds.length <= 1)
       return false;
 
diff --git a/browser/base/content/browser-pageActions.js b/browser/base/content/browser-pageActions.js
--- a/browser/base/content/browser-pageActions.js
+++ b/browser/base/content/browser-pageActions.js
@@ -1018,17 +1018,17 @@ BrowserPageActions.sendToDevice = {
     notReady.classList.add(
       "subviewbutton",
       "subviewbutton-iconic",
       "pageAction-sendToDevice-notReady"
     );
     notReady.setAttribute("label", "sendToDevice-notReadyTitle");
     notReady.setAttribute("disabled", "true");
     bodyNode.appendChild(notReady);
-    for (let node of bodyNode.childNodes) {
+    for (let node of bodyNode.children) {
       BrowserPageActions.takeNodeAttributeFromPanel(node, "title");
       BrowserPageActions.takeNodeAttributeFromPanel(node, "shortcut");
     }
   },
 
   onLocationChange() {
     let action = PageActions.actionForID("sendToDevice");
     let browser = gBrowser.selectedBrowser;
@@ -1132,18 +1132,18 @@ BrowserPageActions.addSearchEngine = {
     button.classList.add("badged-button");
     button.setAttribute("image", this.engines[0].icon);
     button.setAttribute("uri", this.engines[0].uri);
     button.setAttribute("crop", "center");
   },
 
   onSubviewShowing(panelViewNode) {
     let body = panelViewNode.querySelector(".panel-subview-body");
-    while (body.firstChild) {
-      body.firstChild.remove();
+    while (body.firstElementChild) {
+      body.firstElementChild.remove();
     }
     for (let engine of this.engines) {
       let button = document.createXULElement("toolbarbutton");
       button.classList.add("subviewbutton", "subviewbutton-iconic");
       button.setAttribute("label", engine.title);
       button.setAttribute("image", engine.icon);
       button.setAttribute("uri", engine.uri);
       button.addEventListener("command", event => {
@@ -1213,17 +1213,17 @@ BrowserPageActions.shareURL = {
     BrowserPageActions.takeActionTitleFromPanel(action);
   },
 
   onShowingSubview(panelViewNode) {
     let bodyNode = panelViewNode.querySelector(".panel-subview-body");
 
     // We cache the providers + the UI if the user selects the share
     // panel multiple times while the panel is open.
-    if (this._cached && bodyNode.childNodes.length > 0) {
+    if (this._cached && bodyNode.children.length > 0) {
       return;
     }
 
     let sharingService = this._sharingService;
     let url = gBrowser.selectedBrowser.currentURI;
     let currentURI = gURLBar.makeURIReadable(url).displaySpec;
     let shareProviders = sharingService.getSharingProviders(currentURI);
     let fragment = document.createDocumentFragment();
@@ -1251,18 +1251,18 @@ BrowserPageActions.shareURL = {
     });
 
     let item = document.createElement("toolbarbutton");
     item.setAttribute("label", BrowserPageActions.panelNode.getAttribute("shareMore-label"));
     item.classList.add("subviewbutton", "subviewbutton-iconic", "share-more-button");
     item.addEventListener("command", onCommand);
     fragment.appendChild(item);
 
-    while (bodyNode.firstChild) {
-      bodyNode.firstChild.remove();
+    while (bodyNode.firstElementChild) {
+      bodyNode.firstElementChild.remove();
     }
     bodyNode.appendChild(fragment);
     this._cached = true;
   }
 };
 
 // Attach sharingService here so tests can override the implementation
 XPCOMUtils.defineLazyServiceGetter(BrowserPageActions.shareURL,
diff --git a/browser/base/content/browser-places.js b/browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js
+++ b/browser/base/content/browser-places.js
@@ -624,21 +624,21 @@ HistoryMenu.prototype = {
     else
       this.undoTabMenu.removeAttribute("disabled");
   },
 
   /**
    * Populate when the history menu is opened
    */
   populateUndoSubmenu: function PHM_populateUndoSubmenu() {
-    var undoPopup = this.undoTabMenu.firstChild;
+    var undoPopup = this.undoTabMenu.firstElementChild;
 
     // remove existing menu items
     while (undoPopup.hasChildNodes())
-      undoPopup.firstChild.remove();
+      undoPopup.firstElementChild.remove();
 
     // no restorable tabs, so make sure menu is disabled, and return
     if (this._getClosedTabCount() == 0) {
       this.undoTabMenu.setAttribute("disabled", true);
       return;
     }
 
     // enable menu
@@ -657,21 +657,21 @@ HistoryMenu.prototype = {
     else
       this.undoWindowMenu.removeAttribute("disabled");
   },
 
   /**
    * Populate when the history menu is opened
    */
   populateUndoWindowSubmenu: function PHM_populateUndoWindowSubmenu() {
-    let undoPopup = this.undoWindowMenu.firstChild;
+    let undoPopup = this.undoWindowMenu.firstElementChild;
 
     // remove existing menu items
     while (undoPopup.hasChildNodes())
-      undoPopup.firstChild.remove();
+      undoPopup.firstElementChild.remove();
 
     // no restorable windows, so make sure menu is disabled, and return
     if (SessionStore.getClosedWindowCount() == 0) {
       this.undoWindowMenu.setAttribute("disabled", true);
       return;
     }
 
     // enable menu
@@ -883,17 +883,17 @@ var PlacesMenuDNDHandler = {
     // we should ensure that we do not close:
     if (this._closeTimer && this._closingTimerNode === event.currentTarget) {
       this._closeTimer.cancel();
       this._closingTimerNode = null;
       this._closeTimer = null;
     }
 
     PlacesControllerDragHelper.currentDropTarget = event.target;
-    let popup = event.target.lastChild;
+    let popup = event.target.lastElementChild;
     if (this._loadTimer || popup.state === "showing" || popup.state === "open")
       return;
 
     this._loadTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
     this._loadTimer.initWithCallback(() => {
       this._loadTimer = null;
       popup.setAttribute("autoopened", "true");
       popup.openPopup();
@@ -912,17 +912,17 @@ var PlacesMenuDNDHandler = {
          event.relatedTarget.parentNode === event.currentTarget))
       return;
 
     // Closing menus in a Places popup is handled by the view itself.
     if (!this._isStaticContainer(event.target))
       return;
 
     PlacesControllerDragHelper.currentDropTarget = null;
-    let popup = event.target.lastChild;
+    let popup = event.target.lastElementChild;
 
     if (this._loadTimer) {
       this._loadTimer.cancel();
       this._loadTimer = null;
     }
     this._closeTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
     this._closingTimerNode = event.currentTarget;
     this._closeTimer.initWithCallback(function() {
@@ -945,18 +945,18 @@ var PlacesMenuDNDHandler = {
    * Determines if a XUL element represents a static container.
    * @returns true if the element is a container element (menu or
    *`         menu-toolbarbutton), false otherwise.
    */
   _isStaticContainer: function PMDH__isContainer(node) {
     let isMenu = node.localName == "menu" ||
                  (node.localName == "toolbarbutton" &&
                   node.getAttribute("type") == "menu");
-    let isStatic = !("_placesNode" in node) && node.lastChild &&
-                   node.lastChild.hasAttribute("placespopup") &&
+    let isStatic = !("_placesNode" in node) && node.lastElementChild &&
+                   node.lastElementChild.hasAttribute("placespopup") &&
                    !node.parentNode.hasAttribute("placespopup");
     return isMenu && isStatic;
   },
 
   /**
    * Called when the user drags over the <menu> element.
    * @param   event
    *          The DragOver event.
diff --git a/browser/base/content/browser-sidebar.js b/browser/base/content/browser-sidebar.js
--- a/browser/base/content/browser-sidebar.js
+++ b/browser/base/content/browser-sidebar.js
@@ -165,17 +165,17 @@ var SidebarUI = {
 
   /**
    * Read the positioning pref and position the sidebar and the splitter
    * appropriately within the browser container.
    */
   setPosition() {
     // First reset all ordinals to match DOM ordering.
     let browser = document.getElementById("browser");
-    [...browser.childNodes].forEach((node, i) => {
+    [...browser.children].forEach((node, i) => {
       node.ordinal = i + 1;
     });
 
     if (!this._positionStart) {
       // DOM ordering is:     |  sidebar-box  | splitter |   appcontent  |
       // Want to display as:  |   appcontent  | splitter |  sidebar-box  |
       // So we just swap box and appcontent ordering
       let appcontent = document.getElementById("appcontent");
diff --git a/browser/base/content/browser-siteIdentity.js b/browser/base/content/browser-siteIdentity.js
--- a/browser/base/content/browser-siteIdentity.js
+++ b/browser/base/content/browser-siteIdentity.js
@@ -902,17 +902,17 @@ var gIdentityHandler = {
 
     if (!this._permissionList.hasChildNodes()) {
       this._permissionEmptyHint.removeAttribute("hidden");
     }
   },
 
   updateSitePermissions() {
     while (this._permissionList.hasChildNodes())
-      this._permissionList.removeChild(this._permissionList.lastChild);
+      this._permissionList.removeChild(this._permissionList.lastElementChild);
 
     let permissions =
       SitePermissions.getAllPermissionDetailsForBrowser(gBrowser.selectedBrowser);
 
     if (this._sharingState) {
       // If WebRTC device or screen permissions are in use, we need to find
       // the associated permission item to set the sharingState field.
       for (let id of ["camera", "microphone", "screen"]) {
diff --git a/browser/base/content/browser-sync.js b/browser/base/content/browser-sync.js
--- a/browser/base/content/browser-sync.js
+++ b/browser/base/content/browser-sync.js
@@ -368,18 +368,18 @@ var gSync = {
     if (!createDeviceNodeFn) {
       createDeviceNodeFn = (clientId, name, clientType, lastModified) => {
         let eltName = name ? "menuitem" : "menuseparator";
         return document.createXULElement(eltName);
       };
     }
 
     // remove existing menu items
-    for (let i = devicesPopup.childNodes.length - 1; i >= 0; --i) {
-      let child = devicesPopup.childNodes[i];
+    for (let i = devicesPopup.children.length - 1; i >= 0; --i) {
+      let child = devicesPopup.children[i];
       if (child.classList.contains("sync-menuitem")) {
         child.remove();
       }
     }
 
     if (gSync.syncConfiguredAndLoading) {
       // We can only be in this case in the page action menu.
       return;
@@ -471,17 +471,17 @@ var gSync = {
     signInItem.setAttribute("label", signInToSync);
     // Show an icon if opened in the page action panel:
     if (signInItem.classList.contains("subviewbutton")) {
       signInItem.classList.add("subviewbutton-iconic", "signintosync");
     }
     signInItem.addEventListener("command", () => {
       this.openPrefs("sendtab");
     });
-    fragment.insertBefore(signInItem, fragment.lastChild);
+    fragment.insertBefore(signInItem, fragment.lastElementChild);
   },
 
   _appendSendTabInfoItems(fragment, createDeviceNodeFn, statusLabel, actions) {
     const status = createDeviceNodeFn(null, statusLabel, null);
     status.setAttribute("label", statusLabel);
     status.setAttribute("disabled", true);
     status.classList.add("sync-menuitem");
     fragment.appendChild(status);
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -393,17 +393,17 @@ const gClickAndHoldListenersOnElement = 
 
   _mousedownHandler(aEvent) {
     if (aEvent.button != 0 ||
         aEvent.currentTarget.open ||
         aEvent.currentTarget.disabled)
       return;
 
     // Prevent the menupopup from opening immediately
-    aEvent.currentTarget.firstChild.hidden = true;
+    aEvent.currentTarget.firstElementChild.hidden = true;
 
     aEvent.currentTarget.addEventListener("mouseout", this);
     aEvent.currentTarget.addEventListener("mouseup", this);
     this._timers.set(aEvent.currentTarget, setTimeout((b) => this._openMenu(b), 500, aEvent.currentTarget));
   },
 
   _clickHandler(aEvent) {
     if (aEvent.button == 0 &&
@@ -420,17 +420,17 @@ const gClickAndHoldListenersOnElement = 
       // dom.click() triggers a command even if there is a click handler
       // however this can now be prevented with preventDefault().
       aEvent.preventDefault();
     }
   },
 
   _openMenu(aButton) {
     this._cancelHold(aButton);
-    aButton.firstChild.hidden = false;
+    aButton.firstElementChild.hidden = false;
     aButton.open = true;
   },
 
   _mouseoutHandler(aEvent) {
     let buttonRect = aEvent.currentTarget.getBoundingClientRect();
     if (aEvent.clientX >= buttonRect.left &&
         aEvent.clientX <= buttonRect.right &&
         aEvent.clientY >= buttonRect.bottom)
@@ -748,19 +748,19 @@ var gPopupBlockerObserver = {
       // Show the separator if we added any
       // showable popup addresses to the menu.
       if (foundUsablePopupURI)
         blockedPopupsSeparator.removeAttribute("hidden");
     }, null);
   },
 
   onPopupHiding(aEvent) {
-    let item = aEvent.target.lastChild;
+    let item = aEvent.target.lastElementChild;
     while (item && item.id != "blockedPopupsSeparator") {
-      let next = item.previousSibling;
+      let next = item.previousElementSibling;
       item.remove();
       item = next;
     }
   },
 
   showBlockedPopup(aEvent) {
     var target = aEvent.target;
     var popupReportIndex = target.getAttribute("popupReportIndex");
@@ -2762,26 +2762,26 @@ function UpdateUrlbarSearchSplitterState
     if (splitter) {
       splitter.remove();
     }
     return;
   }
 
   // If the splitter is already in the right place, we don't need to do anything:
   if (splitter &&
-      ((splitter.nextSibling == searchbar && splitter.previousSibling == urlbar) ||
-       (splitter.nextSibling == urlbar && splitter.previousSibling == searchbar))) {
+      ((splitter.nextElementSibling == searchbar && splitter.previousElementSibling == urlbar) ||
+       (splitter.nextElementSibling == urlbar && splitter.previousElementSibling == searchbar))) {
     return;
   }
 
   var ibefore = null;
   if (urlbar && searchbar) {
-    if (urlbar.nextSibling == searchbar)
+    if (urlbar.nextElementSibling == searchbar)
       ibefore = searchbar;
-    else if (searchbar.nextSibling == urlbar)
+    else if (searchbar.nextElementSibling == urlbar)
       ibefore = urlbar;
   }
 
   if (ibefore) {
     if (!splitter) {
       splitter = document.createXULElement("splitter");
       splitter.id = "urlbar-search-splitter";
       splitter.setAttribute("resizebefore", "flex");
@@ -4115,17 +4115,17 @@ function FillHistoryMenu(aParent) {
     aParent.addEventListener("DOMMenuItemInactive", function() {
       XULBrowserWindow.setOverLink("");
     });
 
     aParent.hasStatusListener = true;
   }
 
   // Remove old entries if any
-  let children = aParent.childNodes;
+  let children = aParent.children;
   for (var i = children.length - 1; i >= 0; --i) {
     if (children[i].hasAttribute("index"))
       aParent.removeChild(children[i]);
   }
 
   const MAX_HISTORY_MENU_ITEMS = 15;
 
   const tooltipBack = gNavigatorBundle.getString("tabHistory.goBack");
@@ -4199,17 +4199,17 @@ function FillHistoryMenu(aParent) {
       }
 
       existingIndex++;
     }
 
     if (!initial) {
       let existingLength = children.length;
       while (existingIndex < existingLength) {
-        aParent.removeChild(aParent.lastChild);
+        aParent.removeChild(aParent.lastElementChild);
         existingIndex++;
       }
     }
   }
 
   let sessionHistory = SessionStore.getSessionHistory(gBrowser.selectedTab, updateSessionHistory);
   if (!sessionHistory)
     return false;
@@ -5506,25 +5506,25 @@ nsBrowserAccess.prototype = {
 };
 
 function onViewToolbarsPopupShowing(aEvent, aInsertPoint) {
   var popup = aEvent.target;
   if (popup != aEvent.currentTarget)
     return;
 
   // Empty the menu
-  for (var i = popup.childNodes.length - 1; i >= 0; --i) {
-    var deadItem = popup.childNodes[i];
+  for (var i = popup.children.length - 1; i >= 0; --i) {
+    var deadItem = popup.children[i];
     if (deadItem.hasAttribute("toolbarId"))
       popup.removeChild(deadItem);
   }
 
-  var firstMenuItem = aInsertPoint || popup.firstChild;
-
-  let toolbarNodes = gNavToolbox.childNodes;
+  var firstMenuItem = aInsertPoint || popup.firstElementChild;
+
+  let toolbarNodes = gNavToolbox.children;
 
   for (let toolbar of toolbarNodes) {
     if (!toolbar.hasAttribute("toolbarname")) {
       continue;
     }
 
     let menuItem = document.createXULElement("menuitem");
     let hidingAttribute = toolbar.getAttribute("type") == "menubar" ?
@@ -5550,17 +5550,17 @@ function onViewToolbarsPopupShowing(aEve
   if (!moveToPanel || !removeFromToolbar) {
     return;
   }
 
   // triggerNode can be a nested child element of a toolbaritem.
   let toolbarItem = popup.triggerNode;
 
   if (toolbarItem && toolbarItem.localName == "toolbarpaletteitem") {
-    toolbarItem = toolbarItem.firstChild;
+    toolbarItem = toolbarItem.firstElementChild;
   } else if (toolbarItem && toolbarItem.localName != "toolbar") {
     while (toolbarItem && toolbarItem.parentNode) {
       let parent = toolbarItem.parentNode;
       if (parent.nodeType !== Node.ELEMENT_NODE ||
           (parent.classList && parent.classList.contains("customization-target")) ||
           parent.getAttribute("overflowfortoolbar") || // Needs to work in the overflow list as well.
           parent.localName == "toolbarpaletteitem" ||
           parent.localName == "toolbar")
@@ -6234,17 +6234,17 @@ function onDownloadsAutoHideChange(event
   let autoHide = event.target.getAttribute("checked") == "true";
   Services.prefs.setBoolPref("browser.download.autohideButton", autoHide);
 }
 
 function getUnwrappedTriggerNode(popup) {
   // Toolbar buttons are wrapped in customize mode. Unwrap if necessary.
   let {triggerNode} = popup;
   if (triggerNode && gCustomizeMode.isWrappedToolbarItem(triggerNode)) {
-    return triggerNode.firstChild;
+    return triggerNode.firstElementChild;
   }
   return triggerNode;
 }
 
 function UpdateManageExtension(popup) {
   let checkbox = popup.querySelector(".customize-context-manageExtension");
   let separator = checkbox.nextElementSibling;
   let node = getUnwrappedTriggerNode(popup);
@@ -6331,21 +6331,21 @@ var gPageStyleMenu = {
       };
     }
 
     return data;
   },
 
   fillPopup(menuPopup) {
     let styleSheetInfo = this._getStyleSheetInfo(gBrowser.selectedBrowser);
-    var noStyle = menuPopup.firstChild;
-    var persistentOnly = noStyle.nextSibling;
-    var sep = persistentOnly.nextSibling;
-    while (sep.nextSibling)
-      menuPopup.removeChild(sep.nextSibling);
+    var noStyle = menuPopup.firstElementChild;
+    var persistentOnly = noStyle.nextElementSibling;
+    var sep = persistentOnly.nextElementSibling;
+    while (sep.nextElementSibling)
+      menuPopup.removeChild(sep.nextElementSibling);
 
     let styleSheets = styleSheetInfo.filteredStyleSheets;
     var currentStyleSheets = {};
     var styleDisabled = styleSheetInfo.authorStyleDisabled;
     var haveAltSheets = false;
     var altStyleSelected = false;
 
     for (let currentStyleSheet of styleSheets) {
@@ -8071,17 +8071,17 @@ TabModalPromptBox.prototype = {
     }
     onCloseCallback.apply(this, args);
   },
 
   appendPrompt(args, onCloseCallback) {
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
     let newPrompt = document.createElementNS(XUL_NS, "tabmodalprompt");
     let browser = this.browser;
-    browser.parentNode.insertBefore(newPrompt, browser.nextSibling);
+    browser.parentNode.insertBefore(newPrompt, browser.nextElementSibling);
     browser.setAttribute("tabmodalPromptShowing", true);
 
     newPrompt.clientTop; // style flush to assure binding is attached
 
     let prompts = this.listPrompts();
     if (prompts.length > 1) {
       // Let's hide ourself behind the current prompt.
       newPrompt.hidden = true;
diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -424,17 +424,17 @@
       <menuitem id="blockedPopupDontShowMessage"
                 accesskey="&dontShowMessage.accesskey;"
                 type="checkbox"
                 oncommand="gPopupBlockerObserver.dontShowMessage();"/>
       <menuseparator id="blockedPopupsSeparator"/>
     </menupopup>
 
     <menupopup id="autohide-context"
-           onpopupshowing="FullScreen.getAutohide(this.firstChild);">
+           onpopupshowing="FullScreen.getAutohide(this.firstElementChild);">
       <menuitem type="checkbox" label="&fullScreenAutohide.label;"
                 accesskey="&fullScreenAutohide.accesskey;"
                 oncommand="FullScreen.setAutohide();"/>
       <menuseparator/>
       <menuitem label="&fullScreenExit.label;"
                 accesskey="&fullScreenExit.accesskey;"
                 oncommand="BrowserFullScreen();"/>
     </menupopup>
diff --git a/browser/base/content/contentSearchUI.js b/browser/base/content/contentSearchUI.js
--- a/browser/base/content/contentSearchUI.js
+++ b/browser/base/content/contentSearchUI.js
@@ -132,17 +132,17 @@ ContentSearchUIController.prototype = {
     let allElts = [...this._suggestionsList.children,
                    ...this._oneOffButtons,
                    document.getElementById("contentSearchSettingsButton")];
     // If we are selecting a suggestion and a one-off is selected, don't deselect it.
     let excludeIndex = idx < this.numSuggestions && this.selectedButtonIndex > -1 ?
                        this.numSuggestions + this.selectedButtonIndex : -1;
     for (let i = 0; i < allElts.length; ++i) {
       let elt = allElts[i];
-      let ariaSelectedElt = i < this.numSuggestions ? elt.firstChild : elt;
+      let ariaSelectedElt = i < this.numSuggestions ? elt.firstElementChild : elt;
       if (i == idx) {
         elt.classList.add("selected");
         ariaSelectedElt.setAttribute("aria-selected", "true");
         this.input.setAttribute("aria-activedescendant", ariaSelectedElt.id);
       } else if (i != excludeIndex) {
         elt.classList.remove("selected");
         ariaSelectedElt.setAttribute("aria-selected", "false");
       }
@@ -616,22 +616,22 @@ ContentSearchUIController.prototype = {
     // We only show the engines icon for default engines, otherwise show
     // a default; default engines have an identifier
     let icon = eng.identifier ? this.defaultEngine.icon : DEFAULT_INPUT_ICON;
     document.body.style.setProperty("--newtab-search-icon", "url(" + icon + ")");
   },
 
   _updateDefaultEngineHeader() {
     let header = document.getElementById("contentSearchDefaultEngineHeader");
-    header.firstChild.setAttribute("src", this.defaultEngine.icon);
+    header.firstElementChild.setAttribute("src", this.defaultEngine.icon);
     if (!this._strings) {
       return;
     }
-    while (header.firstChild.nextSibling) {
-      header.firstChild.nextSibling.remove();
+    while (header.firstElementChild.nextElementSibling) {
+      header.firstElementChild.nextElementSibling.remove();
     }
     header.appendChild(document.createTextNode(
       this._strings.searchHeader.replace("%S", this.defaultEngine.name)));
   },
 
   _updateSearchWithHeader() {
     if (!this._strings) {
       return;
@@ -829,18 +829,18 @@ ContentSearchUIController.prototype = {
 
   _setUpOneOffButtons() {
     // Sometimes we receive a CurrentEngine message from the ContentSearch service
     // before we've received a State message - i.e. before we have our engines.
     if (!this._engines) {
       return;
     }
 
-    while (this._oneOffsTable.firstChild.nextSibling) {
-      this._oneOffsTable.firstChild.nextSibling.remove();
+    while (this._oneOffsTable.firstElementChild.nextElementSibling) {
+      this._oneOffsTable.firstElementChild.nextElementSibling.remove();
     }
 
     this._oneOffButtons = [];
 
     let engines = this._engines.filter(aEngine => aEngine.name != this.defaultEngine.name)
                                .filter(aEngine => !aEngine.hidden);
     if (!engines.length) {
       this._oneOffsTable.hidden = true;
diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -1386,21 +1386,21 @@ nsContextMenu.prototype = {
   },
 
   // Determines whether or not the separator with the specified ID should be
   // shown or not by determining if there are any non-hidden items between it
   // and the previous separator.
   shouldShowSeparator(aSeparatorID) {
     var separator = document.getElementById(aSeparatorID);
     if (separator) {
-      var sibling = separator.previousSibling;
+      var sibling = separator.previousElementSibling;
       while (sibling && sibling.localName != "menuseparator") {
         if (!sibling.hidden)
           return true;
-        sibling = sibling.previousSibling;
+        sibling = sibling.previousElementSibling;
       }
     }
     return false;
   },
 
   addDictionaries() {
     var uri = formatURL("browser.dictionaries.download.url", true);
 
diff --git a/browser/base/content/pageinfo/pageInfo.js b/browser/base/content/pageinfo/pageInfo.js
--- a/browser/base/content/pageinfo/pageInfo.js
+++ b/browser/base/content/pageinfo/pageInfo.js
@@ -406,18 +406,18 @@ function resetPageInfo(args) {
     Services.obs.removeObserver(imagePermissionObserver, "perm-changed");
     mediaTab.hidden = true;
   }
   gImageView.clear();
   gImageHash = {};
 
   /* Reset Feeds Tab */
   var feedListbox = document.getElementById("feedListbox");
-  while (feedListbox.firstChild)
-    feedListbox.firstChild.remove();
+  while (feedListbox.firstElementChild)
+    feedListbox.firstElementChild.remove();
 
   /* Call registered overlay reset functions */
   onResetRegistry.forEach(function(func) { func(); });
 
   /* Rebuild the data */
   loadTab(args);
 }
 
@@ -582,17 +582,17 @@ function addImage(imageViewRow) {
         gImageElement.imageText == elem.imageText) {
       gImageView.data[i][COL_IMAGE_NODE] = elem;
     }
   }
 }
 
 // Link Stuff
 function openURL(target) {
-  var url = target.parentNode.childNodes[2].value;
+  var url = target.parentNode.children[2].value;
   window.open(url, "_blank", "chrome");
 }
 
 function onBeginLinkDrag(event, urlField, descField) {
   if (event.originalTarget.localName != "treechildren")
     return;
 
   var tree = event.target;
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -204,17 +204,17 @@ window._gBrowser = {
 
   get tabContainer() {
     delete this.tabContainer;
     return this.tabContainer = document.getElementById("tabbrowser-tabs");
   },
 
   get tabs() {
     delete this.tabs;
-    return this.tabs = this.tabContainer.childNodes;
+    return this.tabs = this.tabContainer.children;
   },
 
   get tabbox() {
     delete this.tabbox;
     return this.tabbox = document.getElementById("tabbrowser-tabbox");
   },
 
   get tabpanels() {
@@ -312,17 +312,17 @@ window._gBrowser = {
     for (let attribute in this._defaultBrowserAttributes) {
       this._defaultBrowserAttributes[attribute] = browser.getAttribute(attribute);
     }
 
     let tab = this.tabs[0];
     this._selectedTab = tab;
 
     let uniqueId = this._generateUniquePanelID();
-    this.tabpanels.childNodes[0].id = uniqueId;
+    this.tabpanels.children[0].id = uniqueId;
     tab.linkedPanel = uniqueId;
     tab.permanentKey = browser.permanentKey;
     tab._tPos = 0;
     tab._fullyOpen = true;
     tab.linkedBrowser = browser;
     this._tabForBrowser.set(browser, tab);
 
     // Hook the browser up with a progress listener.
@@ -534,17 +534,17 @@ window._gBrowser = {
     aTab.dispatchEvent(event);
 
     return findBar;
   },
 
   _appendStatusPanel() {
     let browser = this.selectedBrowser;
     let browserContainer = this.getBrowserContainer(browser);
-    browserContainer.insertBefore(StatusPanel.panel, browser.parentNode.nextSibling);
+    browserContainer.insertBefore(StatusPanel.panel, browser.parentNode.nextElementSibling);
   },
 
   _updateTabBarForPinnedTabs() {
     this.tabContainer._unlockTabSizing();
     this.tabContainer._positionPinnedTabs();
     this.tabContainer._updateCloseButtons();
   },
 
@@ -3021,24 +3021,24 @@ window._gBrowser = {
       remainingTabs = Array.filter(this.tabs, function(tab) {
         return !tab.closing;
       }, this);
     }
 
     // Try to find a remaining tab that comes after the given tab
     let tab = aTab;
     do {
-      tab = tab.nextSibling;
+      tab = tab.nextElementSibling;
     } while (tab && !remainingTabs.includes(tab));
 
     if (!tab) {
       tab = aTab;
 
       do {
-        tab = tab.previousSibling;
+        tab = tab.previousElementSibling;
       } while (tab && !remainingTabs.includes(tab));
     }
 
     return tab;
   },
 
   _blurTab(aTab) {
     this.selectedTab = this._findTabToBlurTo(aTab);
@@ -3557,19 +3557,19 @@ window._gBrowser = {
     this.tabContainer._setPositionalAttributes();
 
     var evt = document.createEvent("UIEvents");
     evt.initUIEvent("TabMove", true, false, window, oldPosition);
     aTab.dispatchEvent(evt);
   },
 
   moveTabForward() {
-    let nextTab = this.selectedTab.nextSibling;
+    let nextTab = this.selectedTab.nextElementSibling;
     while (nextTab && nextTab.hidden)
-      nextTab = nextTab.nextSibling;
+      nextTab = nextTab.nextElementSibling;
 
     if (nextTab)
       this.moveTabTo(this.selectedTab, nextTab._tPos);
     else if (this.arrowKeysShouldWrap)
       this.moveTabToStart();
   },
 
   /**
@@ -3624,19 +3624,19 @@ window._gBrowser = {
       // for our new tab after we've done swapBrowsersAndCloseOther.
       this.updateCurrentBrowser(true);
     }
 
     return newTab;
   },
 
   moveTabBackward() {
-    let previousTab = this.selectedTab.previousSibling;
+    let previousTab = this.selectedTab.previousElementSibling;
     while (previousTab && previousTab.hidden)
-      previousTab = previousTab.previousSibling;
+      previousTab = previousTab.previousElementSibling;
 
     if (previousTab)
       this.moveTabTo(this.selectedTab, previousTab._tPos);
     else if (this.arrowKeysShouldWrap)
       this.moveTabToEnd();
   },
 
   moveTabToStart() {
diff --git a/browser/base/content/test/forms/browser_selectpopup.js b/browser/base/content/test/forms/browser_selectpopup.js
--- a/browser/base/content/test/forms/browser_selectpopup.js
+++ b/browser/base/content/test/forms/browser_selectpopup.js
@@ -134,20 +134,20 @@ async function doSelectTests(contentType
   let menulist = document.getElementById("ContentSelectDropdown");
   let selectPopup = menulist.menupopup;
 
   await openSelectPopup(selectPopup);
 
   let isWindows = navigator.platform.includes("Win");
 
   is(menulist.selectedIndex, 1, "Initial selection");
-  is(selectPopup.firstChild.localName, "menucaption", "optgroup is caption");
-  is(selectPopup.firstChild.getAttribute("label"), "First Group", "optgroup label");
-  is(selectPopup.childNodes[1].localName, "menuitem", "option is menuitem");
-  is(selectPopup.childNodes[1].getAttribute("label"), "One", "option label");
+  is(selectPopup.firstElementChild.localName, "menucaption", "optgroup is caption");
+  is(selectPopup.firstElementChild.getAttribute("label"), "First Group", "optgroup label");
+  is(selectPopup.children[1].localName, "menuitem", "option is menuitem");
+  is(selectPopup.children[1].getAttribute("label"), "One", "option label");
 
   EventUtils.synthesizeKey("KEY_ArrowDown");
   is(menulist.menuBoxObject.activeChild, menulist.getItemAtIndex(2), "Select item 2");
   is(menulist.selectedIndex, isWindows ? 2 : 1, "Select item 2 selectedIndex");
 
   EventUtils.synthesizeKey("KEY_ArrowDown");
   is(menulist.menuBoxObject.activeChild, menulist.getItemAtIndex(3), "Select item 3");
   is(menulist.selectedIndex, isWindows ? 3 : 1, "Select item 3 selectedIndex");
@@ -211,18 +211,18 @@ async function doSelectTests(contentType
   is((await getChangeEvents()), isWindows ? 2 : 1, "Open and close with change - number of change events");
   is((await getClickEvents()), 2, "Open and close with change - number of click events");
   EventUtils.synthesizeKey("KEY_Tab");
   EventUtils.synthesizeKey("KEY_Tab", {shiftKey: true});
   is((await getInputEvents()), isWindows ? 2 : 1, "Tab away from select with change - number of input events");
   is((await getChangeEvents()), isWindows ? 2 : 1, "Tab away from select with change - number of change events");
   is((await getClickEvents()), 2, "Tab away from select with change - number of click events");
 
-  is(selectPopup.lastChild.previousSibling.label, "Seven", "Spaces collapsed");
-  is(selectPopup.lastChild.label, "\xA0\xA0Eight\xA0\xA0", "Non-breaking spaces not collapsed");
+  is(selectPopup.lastElementChild.previousElementSibling.label, "Seven", "Spaces collapsed");
+  is(selectPopup.lastElementChild.label, "\xA0\xA0Eight\xA0\xA0", "Non-breaking spaces not collapsed");
 
   BrowserTestUtils.removeTab(tab);
 }
 
 add_task(async function setup() {
   await SpecialPowers.pushPrefEnv({
     "set": [
       ["dom.select_popup_in_parent.enabled", true],
@@ -485,17 +485,17 @@ async function performLargePopupTests(wi
   scrollPos = selectPopup.scrollBox.scrollTop;
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 25, { type: "mouseup" }, win);
   is(selectPopup.scrollBox.scrollTop, scrollPos, "scroll position at mouseup should not change");
 
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" }, win);
   is(selectPopup.scrollBox.scrollTop, scrollPos, "scroll position at mousemove after mouseup should not change");
 
   // Now check dragging with a mousedown on an item
-  let menuRect = selectPopup.childNodes[51].getBoundingClientRect();
+  let menuRect = selectPopup.children[51].getBoundingClientRect();
   EventUtils.synthesizeMouseAtPoint(menuRect.left + 5, menuRect.top + 5, { type: "mousedown" }, win);
 
   // Dragging below the popup scrolls it down.
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" }, win);
   ok(selectPopup.scrollBox.scrollTop > scrollPos + 5, "scroll position at drag down from option");
 
   // Dragging above the popup scrolls it up.
   EventUtils.synthesizeMouseAtPoint(popupRect.left + 20, popupRect.top - 20, { type: "mousemove" }, win);
@@ -535,17 +535,17 @@ async function performLargePopupTests(wi
         // 61st child, since the first child is now the search input field.
         selectedOption = 61;
       }
       // Some of the styles applied to the menuitems are percentages, meaning
       // that the final layout calculations returned by getBoundingClientRect()
       // might return floating point values. We don't care about sub-pixel
       // accuracy, and only care about the final pixel value, so we add a
       // fuzz-factor of 1.
-      SimpleTest.isfuzzy(selectPopup.childNodes[selectedOption].getBoundingClientRect().bottom,
+      SimpleTest.isfuzzy(selectPopup.children[selectedOption].getBoundingClientRect().bottom,
                          selectPopup.getBoundingClientRect().bottom - bpBottom,
                          1, "Popup scroll at correct position " + bpBottom);
     }
 
     await hideSelectPopup(selectPopup, "enter", win);
 
     position = positions.shift();
 
@@ -620,45 +620,45 @@ async function performSelectSearchTests(
 
   let selectPopup = win.document.getElementById("ContentSelectDropdown").menupopup;
   await openSelectPopup(selectPopup, false, "select", win);
 
   let searchElement = selectPopup.querySelector("textbox");
   searchElement.focus();
 
   EventUtils.synthesizeKey("O", {}, win);
-  is(selectPopup.childNodes[2].hidden, false, "First option should be visible");
-  is(selectPopup.childNodes[3].hidden, false, "Second option should be visible");
+  is(selectPopup.children[2].hidden, false, "First option should be visible");
+  is(selectPopup.children[3].hidden, false, "Second option should be visible");
 
   EventUtils.synthesizeKey("3", {}, win);
-  is(selectPopup.childNodes[2].hidden, true, "First option should be hidden");
-  is(selectPopup.childNodes[3].hidden, true, "Second option should be hidden");
-  is(selectPopup.childNodes[4].hidden, false, "Third option should be visible");
+  is(selectPopup.children[2].hidden, true, "First option should be hidden");
+  is(selectPopup.children[3].hidden, true, "Second option should be hidden");
+  is(selectPopup.children[4].hidden, false, "Third option should be visible");
 
   EventUtils.synthesizeKey("Z", {}, win);
-  is(selectPopup.childNodes[4].hidden, true, "Third option should be hidden");
-  is(selectPopup.childNodes[1].hidden, true, "First group header should be hidden");
+  is(selectPopup.children[4].hidden, true, "Third option should be hidden");
+  is(selectPopup.children[1].hidden, true, "First group header should be hidden");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[4].hidden, false, "Third option should be visible");
+  is(selectPopup.children[4].hidden, false, "Third option should be visible");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[5].hidden, false, "Second group header should be visible");
+  is(selectPopup.children[5].hidden, false, "Second group header should be visible");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
   EventUtils.synthesizeKey("O", {}, win);
   EventUtils.synthesizeKey("5", {}, win);
-  is(selectPopup.childNodes[5].hidden, false, "Second group header should be visible");
-  is(selectPopup.childNodes[1].hidden, true, "First group header should be hidden");
+  is(selectPopup.children[5].hidden, false, "Second group header should be visible");
+  is(selectPopup.children[1].hidden, true, "First group header should be hidden");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[1].hidden, false, "First group header should be shown");
+  is(selectPopup.children[1].hidden, false, "First group header should be shown");
 
   EventUtils.synthesizeKey("KEY_Backspace", {}, win);
-  is(selectPopup.childNodes[8].hidden, true, "Option hidden by content should remain hidden");
+  is(selectPopup.children[8].hidden, true, "Option hidden by content should remain hidden");
 
   await hideSelectPopup(selectPopup, "escape", win);
 }
 
 // This test checks the functionality of search in select elements with groups
 // and a large number of options.
 add_task(async function test_select_search() {
   await SpecialPowers.pushPrefEnv({
@@ -689,17 +689,17 @@ add_task(async function test_mousemove_c
   await popupShownPromise;
 
   await new Promise(resolve => {
     window.addEventListener("mousemove", function(event) {
       is(event.target.localName.indexOf("menu"), 0, "mouse over menu");
       resolve();
     }, {capture: true, once: true});
 
-    EventUtils.synthesizeMouseAtCenter(selectPopup.firstChild, { type: "mousemove" });
+    EventUtils.synthesizeMouseAtCenter(selectPopup.firstElementChild, { type: "mousemove" });
   });
 
   await BrowserTestUtils.synthesizeMouseAtCenter("#one", { type: "mouseup" }, gBrowser.selectedBrowser);
 
   await hideSelectPopup(selectPopup);
 
   // The popup should be closed when fullscreen mode is entered or exited.
   for (let steps = 0; steps < 2; steps++) {
@@ -721,28 +721,28 @@ add_task(async function test_somehidden(
 
   let selectPopup = document.getElementById("ContentSelectDropdown").menupopup;
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(selectPopup, "popupshown");
   await BrowserTestUtils.synthesizeMouseAtCenter("#one", { type: "mousedown" }, gBrowser.selectedBrowser);
   await popupShownPromise;
 
   // The exact number is not needed; just ensure the height is larger than 4 items to accomodate any popup borders.
-  ok(selectPopup.getBoundingClientRect().height >= selectPopup.lastChild.getBoundingClientRect().height * 4, "Height contains at least 4 items");
-  ok(selectPopup.getBoundingClientRect().height < selectPopup.lastChild.getBoundingClientRect().height * 5, "Height doesn't contain 5 items");
+  ok(selectPopup.getBoundingClientRect().height >= selectPopup.lastElementChild.getBoundingClientRect().height * 4, "Height contains at least 4 items");
+  ok(selectPopup.getBoundingClientRect().height < selectPopup.lastElementChild.getBoundingClientRect().height * 5, "Height doesn't contain 5 items");
 
   // The label contains the substring 'Visible' for items that are visible.
   // Otherwise, it is expected to be display: none.
   is(selectPopup.parentNode.itemCount, 9, "Correct number of items");
-  let child = selectPopup.firstChild;
+  let child = selectPopup.firstElementChild;
   let idx = 1;
   while (child) {
     is(getComputedStyle(child).display, child.label.indexOf("Visible") > 0 ? "-moz-box" : "none",
        "Item " + (idx++) + " is visible");
-    child = child.nextSibling;
+    child = child.nextElementSibling;
   }
 
   await hideSelectPopup(selectPopup, "escape");
   BrowserTestUtils.removeTab(tab);
 });
 
 // This test checks that the popup is closed when the select element is blurred.
 add_task(async function test_blur_hides_popup() {
diff --git a/browser/base/content/test/forms/browser_selectpopup_colors.js b/browser/base/content/test/forms/browser_selectpopup_colors.js
--- a/browser/base/content/test/forms/browser_selectpopup_colors.js
+++ b/browser/base/content/test/forms/browser_selectpopup_colors.js
@@ -240,17 +240,17 @@ async function testSelectColors(select, 
     let value = options.waitForComputedStyle.value;
     await BrowserTestUtils.waitForCondition(() => {
       info(`<select> has ${property}: ${getComputedStyle(selectPopup)[property]}`);
       return getComputedStyle(selectPopup)[property] == value;
     }, `Waiting for <select> to have ${property}: ${value}`);
   }
 
   is(selectPopup.parentNode.itemCount, itemCount, "Correct number of items");
-  let child = selectPopup.firstChild;
+  let child = selectPopup.firstElementChild;
   let idx = 1;
 
   if (!options.skipSelectColorTest) {
     is(getComputedStyle(selectPopup).color, options.selectColor,
       "popup has expected foreground color");
 
     if (options.selectTextShadow) {
       is(getComputedStyle(selectPopup).textShadow, options.selectTextShadow,
@@ -284,17 +284,17 @@ async function testSelectColors(select, 
         "popup has expected background color");
     }
   }
 
   ok(!child.selected, "The first child should not be selected");
   while (child) {
     testOptionColors(idx, child, menulist);
     idx++;
-    child = child.nextSibling;
+    child = child.nextElementSibling;
   }
 
   if (!options.leaveOpen) {
     await hideSelectPopup(selectPopup, "escape");
     BrowserTestUtils.removeTab(tab);
   }
 }
 
diff --git a/browser/base/content/test/forms/head.js b/browser/base/content/test/forms/head.js
--- a/browser/base/content/test/forms/head.js
+++ b/browser/base/content/test/forms/head.js
@@ -5,13 +5,13 @@ function hideSelectPopup(selectPopup, mo
     return ContentTaskUtils.waitForCondition(() => !SelectContentHelper.open);
   });
 
   if (mode == "escape") {
     EventUtils.synthesizeKey("KEY_Escape", {}, win);
   } else if (mode == "enter") {
     EventUtils.synthesizeKey("KEY_Enter", {}, win);
   } else if (mode == "click") {
-    EventUtils.synthesizeMouseAtCenter(selectPopup.lastChild, { }, win);
+    EventUtils.synthesizeMouseAtCenter(selectPopup.lastElementChild, { }, win);
   }
 
   return selectClosedPromise;
 }
diff --git a/browser/base/content/test/general/browser_accesskeys.js b/browser/base/content/test/general/browser_accesskeys.js
--- a/browser/base/content/test/general/browser_accesskeys.js
+++ b/browser/base/content/test/general/browser_accesskeys.js
@@ -108,17 +108,17 @@ add_task(async function() {
 
   gBrowser.removeTab(tab4);
 
   newButton.remove();
 });
 
 function childHandleFocus() {
   var sent = false;
-  content.document.body.firstChild.addEventListener("focus", function focused(event) {
+  content.document.body.firstElementChild.addEventListener("focus", function focused(event) {
     sent = true;
     let focusedElement = content.document.activeElement;
     focusedElement.blur();
     sendAsyncMessage("Test:FocusFromAccessKey", { focus: focusedElement.id });
   }, true);
   content.document.body.addEventListener("keydown", function keydown(event) {
     sent = false;
   }, true);
diff --git a/browser/base/content/test/general/browser_bug1299667.js b/browser/base/content/test/general/browser_bug1299667.js
--- a/browser/base/content/test/general/browser_bug1299667.js
+++ b/browser/base/content/test/general/browser_bug1299667.js
@@ -24,22 +24,22 @@ add_task(async function() {
 
   ok(true, "history menu opened");
 
   // Wait for the session data to be flushed before continuing the test
   await new Promise(resolve => SessionStore.getSessionHistory(gBrowser.selectedTab, resolve));
 
   is(event.target.children.length, 2, "Two history items");
 
-  let node = event.target.firstChild;
+  let node = event.target.firstElementChild;
   is(node.getAttribute("uri"), "http://example.com/2.html", "first item uri");
   is(node.getAttribute("index"), "1", "first item index");
   is(node.getAttribute("historyindex"), "0", "first item historyindex");
 
-  node = event.target.lastChild;
+  node = event.target.lastElementChild;
   is(node.getAttribute("uri"), "http://example.com/", "second item uri");
   is(node.getAttribute("index"), "0", "second item index");
   is(node.getAttribute("historyindex"), "-1", "second item historyindex");
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(contextMenu, "popuphidden");
   event.target.hidePopup();
   await popupHiddenPromise;
   info("Hidden popup");
diff --git a/browser/base/content/test/general/browser_bug417483.js b/browser/base/content/test/general/browser_bug417483.js
--- a/browser/base/content/test/general/browser_bug417483.js
+++ b/browser/base/content/test/general/browser_bug417483.js
@@ -3,17 +3,17 @@ add_task(async function() {
   const htmlContent = "data:text/html, <iframe src='data:text/html,text text'></iframe>";
   gBrowser.loadURI(htmlContent);
   await loadedPromise;
 
   await ContentTask.spawn(gBrowser.selectedBrowser, { }, async function(arg) {
     let frame = content.frames[0];
     let sel = frame.getSelection();
     let range = frame.document.createRange();
-    let tn = frame.document.body.childNodes[0];
+    let tn = frame.document.body.children[0];
     range.setStart(tn, 4);
     range.setEnd(tn, 5);
     sel.addRange(range);
     frame.focus();
   });
 
   let contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
 
diff --git a/browser/base/content/test/general/browser_bug423833.js b/browser/base/content/test/general/browser_bug423833.js
--- a/browser/base/content/test/general/browser_bug423833.js
+++ b/browser/base/content/test/general/browser_bug423833.js
@@ -24,17 +24,17 @@ function test1Setup() {
   if (content.frames.length < 2 ||
       content.frames[1].location != invalidPage)
     // The error frame hasn't loaded yet
     return;
 
   gBrowser.selectedBrowser.removeEventListener("load", test1Setup, true);
 
   var badFrame = content.frames[1];
-  document.popupNode = badFrame.document.firstChild;
+  document.popupNode = badFrame.document.firstElementChild;
 
   var contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
   var contextMenu = new nsContextMenu(contentAreaContextMenu);
 
   // We'd like to use another load listener here, but error pages don't fire load events
   contextMenu.showOnlyThisFrame();
   intervalID = setInterval(testShowOnlyThisFrame, 3000);
 }
@@ -61,17 +61,17 @@ function test2Setup() {
     // The error frame hasn't loaded yet
     return;
 
   gBrowser.removeEventListener("load", test2Setup, true);
 
   // Now let's do the whole thing again, but this time for "Open frame in new tab"
   var badFrame = content.frames[1];
 
-  document.popupNode = badFrame.document.firstChild;
+  document.popupNode = badFrame.document.firstElementChild;
 
   var contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
   var contextMenu = new nsContextMenu(contentAreaContextMenu);
 
   gBrowser.tabContainer.addEventListener("TabOpen", function listener(event) {
     test2tab = event.target;
     gBrowser.tabContainer.removeEventListener("TabOpen", listener);
   });
@@ -97,17 +97,17 @@ function testOpenFrameInTab() {
   gBrowser.removeCurrentTab();
 
   test3Setup();
 }
 
 function test3Setup() {
   // One more time, for "Open frame in new window"
   var badFrame = content.frames[1];
-  document.popupNode = badFrame.document.firstChild;
+  document.popupNode = badFrame.document.firstElementChild;
 
   var contentAreaContextMenu = document.getElementById("contentAreaContextMenu");
   var contextMenu = new nsContextMenu(contentAreaContextMenu);
 
   Services.ww.registerNotification(function notification(aSubject, aTopic, aData) {
     if (aTopic == "domwindowopened")
       test3window = aSubject;
     Services.ww.unregisterNotification(notification);
diff --git a/browser/base/content/test/general/browser_bug427559.js b/browser/base/content/test/general/browser_bug427559.js
--- a/browser/base/content/test/general/browser_bug427559.js
+++ b/browser/base/content/test/general/browser_bug427559.js
@@ -4,17 +4,17 @@
  * Test bug 427559 to make sure focused elements that are no longer on the page
  * will have focus transferred to the window when changing tabs back to that
  * tab with the now-gone element.
  */
 
 // Default focus on a button and have it kill itself on blur.
 const URL = "data:text/html;charset=utf-8," +
             '<body><button onblur="this.remove()">' +
-            "<script>document.body.firstChild.focus()</script></body>";
+            "<script>document.body.firstElementChild.focus()</script></body>";
 
 function getFocusedLocalName(browser) {
   return ContentTask.spawn(browser, null, async function() {
     return content.document.activeElement.localName;
   });
 }
 
 add_task(async function() {
diff --git a/browser/base/content/test/general/browser_bug462673.js b/browser/base/content/test/general/browser_bug462673.js
--- a/browser/base/content/test/general/browser_bug462673.js
+++ b/browser/base/content/test/general/browser_bug462673.js
@@ -1,28 +1,28 @@
 add_task(async function() {
   var win = openDialog(AppConstants.BROWSER_CHROME_URL, "_blank", "chrome,all,dialog=no");
   await SimpleTest.promiseFocus(win);
 
-  let tab = win.gBrowser.tabContainer.firstChild;
+  let tab = win.gBrowser.tabContainer.firstElementChild;
   await promiseTabLoadEvent(tab, getRootDirectory(gTestPath) + "test_bug462673.html");
 
   is(win.gBrowser.browsers.length, 2, "test_bug462673.html has opened a second tab");
-  is(win.gBrowser.selectedTab, tab.nextSibling, "dependent tab is selected");
+  is(win.gBrowser.selectedTab, tab.nextElementSibling, "dependent tab is selected");
   win.gBrowser.removeTab(tab);
 
   // Closing a tab will also close its parent chrome window, but async
   await BrowserTestUtils.domWindowClosed(win);
 });
 
 add_task(async function() {
   var win = openDialog(AppConstants.BROWSER_CHROME_URL, "_blank", "chrome,all,dialog=no");
   await SimpleTest.promiseFocus(win);
 
-  let tab = win.gBrowser.tabContainer.firstChild;
+  let tab = win.gBrowser.tabContainer.firstElementChild;
   await promiseTabLoadEvent(tab, getRootDirectory(gTestPath) + "test_bug462673.html");
 
   var newTab = win.gBrowser.addTab();
   var newBrowser = newTab.linkedBrowser;
   win.gBrowser.removeTab(tab);
   ok(!win.closed, "Window stays open");
   if (!win.closed) {
     is(win.gBrowser.tabContainer.childElementCount, 1, "Window has one tab");
diff --git a/browser/base/content/test/general/browser_bug647886.js b/browser/base/content/test/general/browser_bug647886.js
--- a/browser/base/content/test/general/browser_bug647886.js
+++ b/browser/base/content/test/general/browser_bug647886.js
@@ -20,21 +20,21 @@ add_task(async function() {
 
   ok(true, "history menu opened");
 
   // Wait for the session data to be flushed before continuing the test
   await new Promise(resolve => SessionStore.getSessionHistory(gBrowser.selectedTab, resolve));
 
   is(event.target.children.length, 2, "Two history items");
 
-  let node = event.target.firstChild;
+  let node = event.target.firstElementChild;
   is(node.getAttribute("uri"), "http://example.com/2.html", "first item uri");
   is(node.getAttribute("index"), "1", "first item index");
   is(node.getAttribute("historyindex"), "0", "first item historyindex");
 
-  node = event.target.lastChild;
+  node = event.target.lastElementChild;
   is(node.getAttribute("uri"), "http://example.com/", "second item uri");
   is(node.getAttribute("index"), "0", "second item index");
   is(node.getAttribute("historyindex"), "-1", "second item historyindex");
 
   event.target.hidePopup();
   gBrowser.removeTab(gBrowser.selectedTab);
 });
diff --git a/browser/base/content/test/general/browser_bug734076.js b/browser/base/content/test/general/browser_bug734076.js
--- a/browser/base/content/test/general/browser_bug734076.js
+++ b/browser/base/content/test/general/browser_bug734076.js
@@ -42,17 +42,17 @@ add_task(async function() {
       element: "img",
       go() {
         return ContentTask.spawn(gBrowser.selectedBrowser, { writeDomainURL }, async function(arg) {
           let doc = content.document;
           let img = doc.createElement("img");
           img.height = 100;
           img.width = 100;
           img.setAttribute("src", arg.writeDomainURL);
-          doc.body.insertBefore(img, doc.body.firstChild);
+          doc.body.insertBefore(img, doc.body.firstElementChild);
 
           return "context-viewimage";
         });
       },
       verify() {
         return ContentTask.spawn(gBrowser.selectedBrowser, null, async function(arg) {
           Assert.ok(!content.document.body.textContent,
             "no domain was inherited for view image");
@@ -63,17 +63,17 @@ add_task(async function() {
       name: "show only this frame",
       url: "http://mochi.test:8888/",
       element: "iframe",
       go() {
         return ContentTask.spawn(gBrowser.selectedBrowser, { writeDomainURL }, async function(arg) {
           let doc = content.document;
           let iframe = doc.createElement("iframe");
           iframe.setAttribute("src", arg.writeDomainURL);
-          doc.body.insertBefore(iframe, doc.body.firstChild);
+          doc.body.insertBefore(iframe, doc.body.firstElementChild);
 
           // Wait for the iframe to load.
           return new Promise(resolve => {
             iframe.addEventListener("load", function() {
               resolve("context-showonlythisframe");
             }, {capture: true, once: true});
           });
         });
diff --git a/browser/base/content/test/general/browser_contextmenu_childprocess.js b/browser/base/content/test/general/browser_contextmenu_childprocess.js
--- a/browser/base/content/test/general/browser_contextmenu_childprocess.js
+++ b/browser/base/content/test/general/browser_contextmenu_childprocess.js
@@ -27,17 +27,17 @@ function checkItems(menuitem, arr) {
   for (let i = 0; i < arr.length; i += 2) {
     let str = arr[i];
     let details = arr[i + 1];
     if (str == "---") {
       is(menuitem.localName, "menuseparator", "menuseparator");
     } else if ("children" in details) {
       is(menuitem.localName, "menu", "submenu");
       is(menuitem.getAttribute("label"), str, str + " label");
-      checkItems(menuitem.firstChild.firstChild, details.children);
+      checkItems(menuitem.firstElementChild.firstElementChild, details.children);
     } else {
       is(menuitem.localName, "menuitem", str + " menuitem");
 
       is(menuitem.getAttribute("label"), str, str + " label");
       is(menuitem.getAttribute("type"), details.type, str + " type");
       is(menuitem.getAttribute("image"), details.icon ? gBaseURL + details.icon : "", str + " icon");
 
       if (details.checked)
@@ -46,17 +46,17 @@ function checkItems(menuitem, arr) {
         ok(!menuitem.hasAttribute("checked"), str + " checked");
 
       if (details.disabled)
         is(menuitem.getAttribute("disabled"), "true", str + " disabled");
       else
         ok(!menuitem.hasAttribute("disabled"), str + " disabled");
     }
 
-    menuitem = menuitem.nextSibling;
+    menuitem = menuitem.nextElementSibling;
   }
 }
 
 function checkMenu(contextMenu) {
   let items = [ "Plain item",          {type: "", icon: "", checked: false, disabled: false},
                 "Disabled item",       {type: "", icon: "", checked: false, disabled: true},
                 "Item w/ textContent", {type: "", icon: "", checked: false, disabled: false},
                 "---",                  null,
@@ -71,10 +71,10 @@ function checkMenu(contextMenu) {
                 "---",                  null,
                 "Submenu",  { children:
                   ["Radio1",             {type: "checkbox", icon: "", checked: false, disabled: false},
                    "Radio2",             {type: "checkbox", icon: "", checked: true, disabled: false},
                    "Radio3",             {type: "checkbox", icon: "", checked: false, disabled: false},
                    "---",                 null,
                    "Checkbox",           {type: "checkbox", icon: "", checked: false, disabled: false}] }
                ];
-  checkItems(contextMenu.childNodes[2], items);
+  checkItems(contextMenu.children[2], items);
 }
diff --git a/browser/base/content/test/general/browser_ctrlTab.js b/browser/base/content/test/general/browser_ctrlTab.js
--- a/browser/base/content/test/general/browser_ctrlTab.js
+++ b/browser/base/content/test/general/browser_ctrlTab.js
@@ -86,22 +86,22 @@ add_task(async function() {
        "Ctrl+Tab*2 -> Ctrl+W removes the second most recently selected tab");
 
     await pressCtrlTab(true);
     await pressCtrlTab(true);
     await releaseCtrl();
     ok(selectedTab.selected,
        "Ctrl+Tab*2 -> Ctrl+W -> Ctrl+Shift+Tab*2 keeps the selected tab");
   }
-  gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+  gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
   checkTabs(2);
 
   await ctrlTabTest([1], 1, 0);
 
-  gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+  gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
   checkTabs(1);
 
   { // test for bug 445768
     let focusedWindow = document.commandDispatcher.focusedWindow;
     let eventConsumed = true;
     let detectKeyEvent = function(event) {
       eventConsumed = event.defaultPrevented;
     };
diff --git a/browser/base/content/test/general/browser_decoderDoctor.js b/browser/base/content/test/general/browser_decoderDoctor.js
--- a/browser/base/content/test/general/browser_decoderDoctor.js
+++ b/browser/base/content/test/general/browser_decoderDoctor.js
@@ -45,17 +45,17 @@ async function test_decoder_doctor_notif
       ok(false, ex);
       return;
     }
     ok(notification, "Got decoder-doctor-notification notification");
 
     is(notification.getAttribute("label"), notificationMessage,
        "notification message should match expectation");
 
-    let button = notification.childNodes[0];
+    let button = notification.children[0];
     if (!label) {
       ok(!button, "There should not be button");
       return;
     }
 
     is(button.getAttribute("label"),
        label,
        `notification button should be '${label}'`);
diff --git a/browser/base/content/test/general/browser_page_style_menu.js b/browser/base/content/test/general/browser_page_style_menu.js
--- a/browser/base/content/test/general/browser_page_style_menu.js
+++ b/browser/base/content/test/general/browser_page_style_menu.js
@@ -35,18 +35,18 @@ add_task(async function() {
   await BrowserTestUtils.loadURI(browser, PAGE);
   await promiseStylesheetsUpdated(browser);
 
   let menupopup = document.getElementById("pageStyleMenu").menupopup;
   gPageStyleMenu.fillPopup(menupopup);
 
   var items = [];
   var current = menupopup.getElementsByTagName("menuseparator")[0];
-  while (current.nextSibling) {
-    current = current.nextSibling;
+  while (current.nextElementSibling) {
+    current = current.nextElementSibling;
     items.push(current);
   }
 
   items = items.map(el => ({
     label: el.getAttribute("label"),
     checked: el.getAttribute("checked") == "true",
   }));
 
diff --git a/browser/base/content/test/general/browser_plainTextLinks.js b/browser/base/content/test/general/browser_plainTextLinks.js
--- a/browser/base/content/test/general/browser_plainTextLinks.js
+++ b/browser/base/content/test/general/browser_plainTextLinks.js
@@ -44,41 +44,41 @@ add_task(async function() {
     p3.textContent = "main.example.com";
     div2.appendChild(p3);
     mainDiv.appendChild(div);
     mainDiv.appendChild(div2);
     doc.body.appendChild(mainDiv);
 
     function setSelection(el1, el2, index1, index2) {
       while (el1.nodeType != el1.TEXT_NODE)
-        el1 = el1.firstChild;
+        el1 = el1.firstElementChild;
       while (el2.nodeType != el1.TEXT_NODE)
-        el2 = el2.firstChild;
+        el2 = el2.firstElementChild;
 
       selection.removeAllRanges();
       range.setStart(el1, index1);
       range.setEnd(el2, index2);
       selection.addRange(range);
 
       return range;
     }
 
     // Each of these tests creates a selection and returns a range within it.
     content.tests = [
-      () => setSelection(span1.firstChild, span2.firstChild, 0, 11),
-      () => setSelection(span1.firstChild, span2.firstChild, 7, 11),
-      () => setSelection(span1.firstChild, span2.firstChild, 8, 11),
-      () => setSelection(span2.firstChild, span2.firstChild, 0, 11),
-      () => setSelection(span2.firstChild, span2.firstChild, 11, 23),
-      () => setSelection(span2.firstChild, span2.firstChild, 0, 10),
-      () => setSelection(span2.firstChild, span3.firstChild, 12, 7),
-      () => setSelection(span2.firstChild, span2.firstChild, 12, 19),
-      () => setSelection(p1.firstChild, p1.firstChild, 0, 15),
-      () => setSelection(p1.firstChild, p1.firstChild, 16, 31),
-      () => setSelection(p2.firstChild, p2.firstChild, 0, 14),
+      () => setSelection(span1.firstElementChild, span2.firstElementChild, 0, 11),
+      () => setSelection(span1.firstElementChild, span2.firstElementChild, 7, 11),
+      () => setSelection(span1.firstElementChild, span2.firstElementChild, 8, 11),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 0, 11),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 11, 23),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 0, 10),
+      () => setSelection(span2.firstElementChild, span3.firstElementChild, 12, 7),
+      () => setSelection(span2.firstElementChild, span2.firstElementChild, 12, 19),
+      () => setSelection(p1.firstElementChild, p1.firstElementChild, 0, 15),
+      () => setSelection(p1.firstElementChild, p1.firstElementChild, 16, 31),
+      () => setSelection(p2.firstElementChild, p2.firstElementChild, 0, 14),
       () => {
         selection.selectAllChildren(div2);
         return selection.getRangeAt(0);
       },
       () => {
         selection.selectAllChildren(span4);
         return selection.getRangeAt(0);
       },
diff --git a/browser/base/content/test/general/contentSearchUI.js b/browser/base/content/test/general/contentSearchUI.js
--- a/browser/base/content/test/general/contentSearchUI.js
+++ b/browser/base/content/test/general/contentSearchUI.js
@@ -80,17 +80,17 @@ var messageHandlers = {
   waitForSearchSettings() {
     waitForContentSearchEvent("ManageEngines",
                               aData => ack("waitForSearchSettings", aData));
   },
 
   mousemove(itemIndex) {
     let row;
     if (itemIndex == -1) {
-      row = gController._table.firstChild;
+      row = gController._table.firstElementChild;
     } else {
       let allElts = [...gController._suggestionsList.children,
                      ...gController._oneOffButtons,
                      content.document.getElementById("contentSearchSettingsButton")];
       row = allElts[itemIndex];
     }
     let event = {
       type: "mousemove",
@@ -101,17 +101,17 @@ var messageHandlers = {
     }, {once: true});
     content.synthesizeMouseAtCenter(row, event);
   },
 
   click(arg) {
     let eltIdx = typeof(arg) == "object" ? arg.eltIdx : arg;
     let row;
     if (eltIdx == -1) {
-      row = gController._table.firstChild;
+      row = gController._table.firstElementChild;
     } else {
       let allElts = [...gController._suggestionsList.children,
                      ...gController._oneOffButtons,
                      content.document.getElementById("contentSearchSettingsButton")];
       row = allElts[eltIdx];
     }
     let event = arg.modifiers || {};
     // synthesizeMouseAtCenter defaults to sending a mousedown followed by a
diff --git a/browser/base/content/test/general/contextmenu_common.js b/browser/base/content/test/general/contextmenu_common.js
--- a/browser/base/content/test/general/contextmenu_common.js
+++ b/browser/base/content/test/general/contextmenu_common.js
@@ -31,18 +31,18 @@ function openContextMenuFor(element, shi
 
 function closeContextMenu() {
     contextMenu.hidePopup();
 }
 
 function getVisibleMenuItems(aMenu, aData) {
     var items = [];
     var accessKeys = {};
-    for (var i = 0; i < aMenu.childNodes.length; i++) {
-        var item = aMenu.childNodes[i];
+    for (var i = 0; i < aMenu.children.length; i++) {
+        var item = aMenu.children[i];
         if (item.hidden)
             continue;
 
         var key = item.accessKey;
         if (key)
             key = key.toLowerCase();
 
         var isPageMenuItem = item.hasAttribute("generateditemid");
diff --git a/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js b/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
--- a/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
+++ b/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
@@ -100,17 +100,17 @@ add_task(async function() {
 
   // First, we'll check that the first tab is actually scrolled
   // at least partially out of view.
   Assert.ok(arrowScrollbox.scrollPosition > 0,
             "First tab should be partially scrolled out of view.");
 
   // Now switch to the first tab. We shouldn't flush layout at all.
   await withPerfObserver(async function() {
-    let firstTab = gBrowser.tabContainer.firstChild;
+    let firstTab = gBrowser.tabContainer.firstElementChild;
     await BrowserTestUtils.switchTab(gBrowser, firstTab);
     await BrowserTestUtils.waitForCondition(() => {
       return gBrowser.tabContainer.arrowScrollbox.hasAttribute("scrolledtostart");
     });
   }, {expectedReflows: [], frames: ignoreTabstripRects});
 
   // Okay, now close the last tab. The tabstrip should stay overflowed, but removing
   // one more after that should underflow it.
diff --git a/browser/base/content/test/performance/browser_urlbar_search.js b/browser/base/content/test/performance/browser_urlbar_search.js
--- a/browser/base/content/test/performance/browser_urlbar_search.js
+++ b/browser/base/content/test/performance/browser_urlbar_search.js
@@ -138,17 +138,17 @@ add_task(async function() {
     URLBar.controller.startSearch(URLBar.value);
     await BrowserTestUtils.waitForEvent(URLBar.popup, "popupshown");
     await BrowserTestUtils.waitForCondition(() => {
       return URLBar.controller.searchStatus >=
         Ci.nsIAutoCompleteController.STATUS_COMPLETE_NO_MATCH;
     });
     let matchCount = URLBar.popup.matchCount;
     await BrowserTestUtils.waitForCondition(() => {
-      return URLBar.popup.richlistbox.childNodes.length == matchCount;
+      return URLBar.popup.richlistbox.children.length == matchCount;
     });
 
     URLBar.controller.stopSearch();
     // There are several setTimeout(fn, 0); calls inside autocomplete.xml
     // that we need to wait for. Since those have higher priority than
     // idle callbacks, we can be sure they will have run once this
     // idle callback is called. The timeout seems to be required in
     // automation - presumably because the machines can be pretty busy
diff --git a/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js b/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js
--- a/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js
+++ b/browser/base/content/test/permissions/browser_canvas_fingerprinting_resistance.js
@@ -75,17 +75,17 @@ function extractCanvasData(grantPermissi
         "privacy.resistFingerprinting = true, permission denied, canvas data == placeholderdata");
   } else {
     is(canvasData, contentWindow.kPlaceholderData,
         "privacy.resistFingerprinting = true, requesting permission, canvas data == placeholderdata");
   }
 }
 
 function triggerCommand(button) {
-  let notifications = PopupNotifications.panel.childNodes;
+  let notifications = PopupNotifications.panel.children;
   let notification = notifications[0];
   EventUtils.synthesizeMouseAtCenter(notification[button], {});
 }
 
 function triggerMainCommand() {
   triggerCommand("button");
 }
 
diff --git a/browser/base/content/test/permissions/browser_permissions.js b/browser/base/content/test/permissions/browser_permissions.js
--- a/browser/base/content/test/permissions/browser_permissions.js
+++ b/browser/base/content/test/permissions/browser_permissions.js
@@ -16,17 +16,17 @@ function closeIdentityPopup() {
   let promise = BrowserTestUtils.waitForEvent(gIdentityHandler._identityPopup, "popuphidden");
   gIdentityHandler._identityPopup.hidePopup();
   return promise;
 }
 
 add_task(async function testMainViewVisible() {
   await BrowserTestUtils.withNewTab(PERMISSIONS_PAGE, async function() {
     let permissionsList = document.getElementById("identity-popup-permission-list");
-    let emptyLabel = permissionsList.nextSibling.nextSibling;
+    let emptyLabel = permissionsList.nextElementSibling.nextElementSibling;
 
     await openIdentityPopup();
 
     ok(!BrowserTestUtils.is_hidden(emptyLabel), "List of permissions is empty");
 
     await closeIdentityPopup();
 
     SitePermissions.set(gBrowser.currentURI, "camera", SitePermissions.ALLOW);
@@ -82,17 +82,17 @@ add_task(async function testIdentityIcon
     SitePermissions.remove(gBrowser.currentURI, "camera");
     SitePermissions.remove(gBrowser.currentURI, "cookie");
   });
 });
 
 add_task(async function testCancelPermission() {
   await BrowserTestUtils.withNewTab(PERMISSIONS_PAGE, async function() {
     let permissionsList = document.getElementById("identity-popup-permission-list");
-    let emptyLabel = permissionsList.nextSibling.nextSibling;
+    let emptyLabel = permissionsList.nextElementSibling.nextElementSibling;
 
     SitePermissions.set(gBrowser.currentURI, "geo", SitePermissions.ALLOW);
     SitePermissions.set(gBrowser.currentURI, "camera", SitePermissions.BLOCK);
 
     await openIdentityPopup();
 
     ok(BrowserTestUtils.is_hidden(emptyLabel), "List of permissions is not empty");
 
diff --git a/browser/base/content/test/permissions/browser_reservedkey.js b/browser/base/content/test/permissions/browser_reservedkey.js
--- a/browser/base/content/test/permissions/browser_reservedkey.js
+++ b/browser/base/content/test/permissions/browser_reservedkey.js
@@ -40,17 +40,17 @@ add_task(async function test_reserved_sh
 
   keyset.appendChild(key1);
   keyset.appendChild(key2);
   keyset.appendChild(key3);
   let container = document.createElement("box");
   container.appendChild(keyset);
   document.documentElement.appendChild(container);
 
-  const pageUrl = "data:text/html,<body onload='document.body.firstChild.focus();'><div onkeydown='event.preventDefault();' tabindex=0>Test</div></body>";
+  const pageUrl = "data:text/html,<body onload='document.body.firstElementChild.focus();'><div onkeydown='event.preventDefault();' tabindex=0>Test</div></body>";
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, pageUrl);
 
   EventUtils.sendString("OPQ");
 
   is(document.getElementById("kt_reserved").getAttribute("count"), "1", "reserved='true' with preference off");
   is(document.getElementById("kt_notreserved").getAttribute("count"), "0", "reserved='false' with preference off");
   is(document.getElementById("kt_reserveddefault").getAttribute("count"), "0", "default reserved with preference off");
 
diff --git a/browser/base/content/test/permissions/browser_temporary_permissions.js b/browser/base/content/test/permissions/browser_temporary_permissions.js
--- a/browser/base/content/test/permissions/browser_temporary_permissions.js
+++ b/browser/base/content/test/permissions/browser_temporary_permissions.js
@@ -52,17 +52,17 @@ add_task(async function testTempPermissi
         frameDoc.getElementById("geo").click();
       });
     });
 
     await popupshown;
 
     let popuphidden = BrowserTestUtils.waitForEvent(PopupNotifications.panel, "popuphidden");
 
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     EventUtils.synthesizeMouseAtCenter(notification.secondaryButton, {});
 
     await popuphidden;
 
     Assert.deepEqual(SitePermissions.get(uri, id, browser), {
       state: SitePermissions.BLOCK,
       scope: SitePermissions.SCOPE_TEMPORARY,
     });
diff --git a/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js b/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js
--- a/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js
+++ b/browser/base/content/test/permissions/browser_temporary_permissions_expiry.js
@@ -52,17 +52,17 @@ add_task(async function testTempPermissi
       await BrowserTestUtils.synthesizeMouseAtCenter(`#${id}`, {}, browser);
 
       await popupshown;
 
       ok(!blockedIcon.hasAttribute("showing"), "blocked permission icon is not shown");
 
       let popuphidden = BrowserTestUtils.waitForEvent(PopupNotifications.panel, "popuphidden");
 
-      let notification = PopupNotifications.panel.firstChild;
+      let notification = PopupNotifications.panel.firstElementChild;
       EventUtils.synthesizeMouseAtCenter(notification.secondaryButton, {});
 
       await popuphidden;
 
       SitePermissions.remove(uri, id, browser);
     });
   }
 });
diff --git a/browser/base/content/test/plugins/browser_CTP_context_menu.js b/browser/base/content/test/plugins/browser_CTP_context_menu.js
--- a/browser/base/content/test/plugins/browser_CTP_context_menu.js
+++ b/browser/base/content/test/plugins/browser_CTP_context_menu.js
@@ -52,17 +52,17 @@ add_task(async function() {
   await promiseForCondition(() => document.getElementById("context-ctp-play"));
 
   let actMenuItem = document.getElementById("context-ctp-play");
   ok(actMenuItem, "Should have a context menu entry for activating the plugin");
 
   // Activate the plugin via the context menu
   EventUtils.synthesizeMouseAtCenter(actMenuItem, {});
 
-  await promiseForCondition(() => !PopupNotifications.panel.dismissed && PopupNotifications.panel.firstChild);
+  await promiseForCondition(() => !PopupNotifications.panel.dismissed && PopupNotifications.panel.firstElementChild);
 
   // Activate the plugin
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   // check plugin state
   pluginInfo = await promiseForPluginInfo("test", gBrowser.selectedBrowser);
   ok(pluginInfo.activated, "plugin should not be activated");
 });
diff --git a/browser/base/content/test/plugins/browser_CTP_crashreporting.js b/browser/base/content/test/plugins/browser_CTP_crashreporting.js
--- a/browser/base/content/test/plugins/browser_CTP_crashreporting.js
+++ b/browser/base/content/test/plugins/browser_CTP_crashreporting.js
@@ -70,17 +70,17 @@ add_task(async function() {
     await promiseUpdatePluginBindings(browser);
 
     let pluginInfo = await promiseForPluginInfo("test", browser);
     ok(!pluginInfo.activated, "Plugin should not be activated");
 
     // Simulate clicking the "Allow Always" button.
     let notification = PopupNotifications.getNotification("click-to-play-plugins", browser);
     await promiseForNotificationShown(notification, browser);
-    PopupNotifications.panel.firstChild.button.click();
+    PopupNotifications.panel.firstElementChild.button.click();
 
     // Prepare a crash report topic observer that only returns when
     // the crash report has been successfully sent.
     let crashReportChecker = (subject, data) => {
       return (data == "success");
     };
     let crashReportPromise = TestUtils.topicObserved("crash-report-status",
                                                      crashReportChecker);
diff --git a/browser/base/content/test/plugins/browser_CTP_drag_drop.js b/browser/base/content/test/plugins/browser_CTP_drag_drop.js
--- a/browser/base/content/test/plugins/browser_CTP_drag_drop.js
+++ b/browser/base/content/test/plugins/browser_CTP_drag_drop.js
@@ -77,19 +77,19 @@ add_task(async function() {
     let bounds = plugin.getBoundingClientRect();
     let left = (bounds.left + bounds.right) / 2;
     let top = (bounds.top + bounds.bottom) / 2;
     let utils = content.windowUtils;
     utils.sendMouseEvent("mousedown", left, top, 0, 1, 0, false, 0, 0);
     utils.sendMouseEvent("mouseup", left, top, 0, 1, 0, false, 0, 0);
   });
 
-  let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gNewWindow.gBrowser.selectedBrowser).dismissed && gNewWindow.PopupNotifications.panel.firstChild;
+  let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gNewWindow.gBrowser.selectedBrowser).dismissed && gNewWindow.PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
 });
 
 add_task(async function() {
   // Click the activate button on doorhanger to make sure it works
-  gNewWindow.PopupNotifications.panel.firstChild.button.click();
+  gNewWindow.PopupNotifications.panel.firstElementChild.button.click();
 
   let pluginInfo = await promiseForPluginInfo("test", gNewWindow.gBrowser.selectedBrowser);
   ok(pluginInfo.activated, "plugin should be activated");
 });
diff --git a/browser/base/content/test/plugins/browser_CTP_notificationBar.js b/browser/base/content/test/plugins/browser_CTP_notificationBar.js
--- a/browser/base/content/test/plugins/browser_CTP_notificationBar.js
+++ b/browser/base/content/test/plugins/browser_CTP_notificationBar.js
@@ -137,16 +137,16 @@ add_task(async function() {
   await promisePopupNotification("click-to-play-plugins");
 
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
   ok(notification, "Test 6, Should have a click-to-play notification");
 
   // simulate "always allow"
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   let notificationBox = gBrowser.getNotificationBox(gTestBrowser);
   await promiseForCondition(() => notificationBox.getNotificationWithValue("plugin-hidden") === null);
 
   let pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 7, plugin should be activated");
 });
diff --git a/browser/base/content/test/plugins/browser_blocking.js b/browser/base/content/test/plugins/browser_blocking.js
--- a/browser/base/content/test/plugins/browser_blocking.js
+++ b/browser/base/content/test/plugins/browser_blocking.js
@@ -129,17 +129,17 @@ add_task(async function() {
     let updateLink = doc.getAnonymousElementByAttribute(plugin, "anonid", "checkForUpdatesLink");
     Assert.ok(updateLink && updateLink.style.display != "block",
       "Test 18c, Plugin should not have an update link");
   });
 
   // check that click "Allow" works with blocked plugins
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   is(pluginInfo.pluginFallbackType, Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_NO_UPDATE,
      "Test 18c, plugin fallback type should be PLUGIN_VULNERABLE_NO_UPDATE");
   ok(pluginInfo.activated, "Test 18c, Plugin should be activated");
   let enabledState = getTestPluginEnabledState();
   ok(enabledState, "Test 18c, Plugin enabled state should be STATE_CLICKTOPLAY");
 });
@@ -219,17 +219,17 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   is(pluginInfo.pluginFallbackType, Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY,
      "Test 24a, plugin fallback type should be PLUGIN_CLICK_TO_PLAY");
   ok(!pluginInfo.activated, "Test 24a, Plugin should not be active.");
 
   // simulate "allow"
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 24a, Plugin should be active.");
 
   await asyncSetAndUpdateBlocklist(gTestRoot + "blockPluginVulnerableUpdatable.xml", gTestBrowser);
 });
 
 // the plugin is now blocklisted, so it should not automatically load
@@ -245,17 +245,17 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   is(pluginInfo.pluginFallbackType, Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE,
      "Test 24b, plugin fallback type should be PLUGIN_VULNERABLE_UPDATABLE");
   ok(!pluginInfo.activated, "Test 24b, Plugin should not be active.");
 
   // simulate "allow"
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 24b, Plugin should be active.");
 
   clearAllPluginPermissions();
 
   await asyncSetAndUpdateBlocklist(gTestRoot + "blockNoPlugins.xml", gTestBrowser);
 });
diff --git a/browser/base/content/test/plugins/browser_bug743421.js b/browser/base/content/test/plugins/browser_bug743421.js
--- a/browser/base/content/test/plugins/browser_bug743421.js
+++ b/browser/base/content/test/plugins/browser_bug743421.js
@@ -53,17 +53,17 @@ add_task(async function() {
     Assert.ok(!objLoadingContent.activated, "Test 1b, Plugin should not be activated");
   });
 
   // Click the activate button on doorhanger to make sure it works
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
 
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   await ContentTask.spawn(gTestBrowser, {}, async function() {
     let plugin = content.document.getElementsByTagName("embed")[0];
     let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
     Assert.ok(objLoadingContent.activated, "Test 1b, Plugin should be activated");
   });
 });
 
diff --git a/browser/base/content/test/plugins/browser_bug787619.js b/browser/base/content/test/plugins/browser_bug787619.js
--- a/browser/base/content/test/plugins/browser_bug787619.js
+++ b/browser/base/content/test/plugins/browser_bug787619.js
@@ -47,18 +47,18 @@ add_task(async function() {
   });
   await promise;
 
   // check plugin state
   pluginInfo = await promiseForPluginInfo("plugin");
   ok(!pluginInfo.activated, "1b plugin should not be activated");
 
   let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser).dismissed &&
-    PopupNotifications.panel.firstChild;
+    PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   // check plugin state
   pluginInfo = await promiseForPluginInfo("plugin");
   ok(pluginInfo.activated, "plugin should be activated");
 
   is(gWrapperClickCount, 0, "wrapper should not have received any clicks");
 });
diff --git a/browser/base/content/test/plugins/browser_pluginnotification.js b/browser/base/content/test/plugins/browser_pluginnotification.js
--- a/browser/base/content/test/plugins/browser_pluginnotification.js
+++ b/browser/base/content/test/plugins/browser_pluginnotification.js
@@ -63,25 +63,25 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   ok(!pluginInfo.activated, "Plugin should not be activated");
 
   // Simulate clicking the "Allow" button.
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
 
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Plugin should be activated");
 
   // Simulate clicking the "Block" button.
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.secondaryButton.click();
+  PopupNotifications.panel.firstElementChild.secondaryButton.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(!pluginInfo.activated, "Plugin should not be activated");
 
   let browserLoaded = BrowserTestUtils.browserLoaded(gTestBrowser);
   gTestBrowser.reload();
   await browserLoaded;
   notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
@@ -139,17 +139,17 @@ add_task(async function() {
   let pluginInfo = await promiseForPluginInfo("test");
   ok(!pluginInfo.activated, "Test 12a, Plugin should not be activated");
 
   // Simulate clicking the "Allow" button.
   let notification = PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser);
 
   await promiseForNotificationShown(notification);
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 12a, Plugin should be activated");
 });
 
 // Test that the "Always" permission, when set for just the Test plugin,
 // does not also allow the Second Test plugin.
 add_task(async function() {
@@ -288,19 +288,19 @@ add_task(async function() {
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let utils = content.windowUtils;
     utils.sendMouseEvent("mousedown", 50, 50, 0, 1, 0, false, 0, 0);
     utils.sendMouseEvent("mouseup", 50, 50, 0, 1, 0, false, 0, 0);
   });
 
   let condition = () => !PopupNotifications.getNotification("click-to-play-plugins", gTestBrowser).dismissed &&
-    PopupNotifications.panel.firstChild;
+    PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 19e, Plugin should not be activated");
 
   clearAllPluginPermissions();
 });
 
 // Tests that a plugin in a div that goes from style="display: none" to
@@ -368,19 +368,19 @@ add_task(async function() {
     let bounds = plugin.getBoundingClientRect();
     let left = (bounds.left + bounds.right) / 2;
     let top = (bounds.top + bounds.bottom) / 2;
     let utils = content.windowUtils;
     utils.sendMouseEvent("mousedown", left, top, 0, 1, 0, false, 0, 0);
     utils.sendMouseEvent("mouseup", left, top, 0, 1, 0, false, 0, 0);
   });
 
-  let condition = () => !notification.dismissed && !!PopupNotifications.panel.firstChild;
+  let condition = () => !notification.dismissed && !!PopupNotifications.panel.firstElementChild;
   await promiseForCondition(condition);
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   pluginInfo = await promiseForPluginInfo("test");
   ok(pluginInfo.activated, "Test 20c, plugin should be activated");
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let doc = content.document;
     let plugin = doc.getElementById("test");
     let overlayRect = doc.getAnonymousElementByAttribute(plugin, "anonid", "main").getBoundingClientRect();
diff --git a/browser/base/content/test/plugins/browser_private_clicktoplay.js b/browser/base/content/test/plugins/browser_private_clicktoplay.js
--- a/browser/base/content/test/plugins/browser_private_clicktoplay.js
+++ b/browser/base/content/test/plugins/browser_private_clicktoplay.js
@@ -62,17 +62,17 @@ add_task(async function test1b() {
   });
 
   // Check the button status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
 
   await promiseShown;
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.checkbox.hidden, true, "'Remember' checkbox should be hidden in private windows");
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.checkbox.hidden, true, "'Remember' checkbox should be hidden in private windows");
 
   gPrivateWindow.close();
   BrowserTestUtils.loadURI(gTestBrowser, gHttpTestRoot + "plugin_test.html");
   await BrowserTestUtils.browserLoaded(gTestBrowser);
 });
 
 add_task(async function test2a() {
   // enable test plugin on this site
@@ -86,17 +86,17 @@ add_task(async function test2a() {
   });
 
   // Simulate clicking the "Allow Now" button.
   let promiseShown = BrowserTestUtils.waitForEvent(PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
 
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let plugin = content.document.getElementById("test");
     let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
     let condition = () => objLoadingContent.activated;
     await ContentTaskUtils.waitForCondition(condition, "Test 2a, Waited too long for plugin to activate");
   });
 });
@@ -115,19 +115,19 @@ add_task(async function test2c() {
     ok(objLoadingContent.activated, "Test 2c, Plugin should be activated");
   });
 
   // Check the button status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.secondaryButton.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.secondaryButton.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Block' button.");
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.checkbox.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.checkbox.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Remember' checkbox.");
 
   clearAllPluginPermissions();
   gPrivateWindow.close();
 
   BrowserTestUtils.loadURI(gTestBrowser, gHttpTestRoot + "plugin_test.html");
   await BrowserTestUtils.browserLoaded(gTestBrowser);
 });
@@ -143,17 +143,17 @@ add_task(async function test3a() {
     ok(!objLoadingContent.activated, "Test 3a, Plugin should not be activated");
   });
 
   // Simulate clicking the "Allow" button.
   let promiseShown = BrowserTestUtils.waitForEvent(PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
-  PopupNotifications.panel.firstChild.button.click();
+  PopupNotifications.panel.firstElementChild.button.click();
 
   await ContentTask.spawn(gTestBrowser, null, async function() {
     let plugin = content.document.getElementById("test");
     let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
     let condition = () => objLoadingContent.activated;
     await ContentTaskUtils.waitForCondition(condition, "Test 3a, Waited too long for plugin to activate");
   });
 });
@@ -166,36 +166,36 @@ add_task(async function test3c() {
   let popupNotification = gPrivateWindow.PopupNotifications.getNotification("click-to-play-plugins", gPrivateBrowser);
   ok(popupNotification, "Test 3c, Should have a click-to-play notification");
 
   // Check the button status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.secondaryButton.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.secondaryButton.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Block' button.");
-  is(gPrivateWindow.PopupNotifications.panel.firstChild.checkbox.hidden, true,
+  is(gPrivateWindow.PopupNotifications.panel.firstElementChild.checkbox.hidden, true,
      "Test 2c, Activated plugin in a private window should not have visible 'Remember' checkbox.");
 
   BrowserTestUtils.loadURI(gPrivateBrowser, gHttpTestRoot + "plugin_two_types.html");
   await BrowserTestUtils.browserLoaded(gPrivateBrowser);
 });
 
 add_task(async function test3d() {
   let popupNotification = gPrivateWindow.PopupNotifications.getNotification("click-to-play-plugins", gPrivateBrowser);
   ok(popupNotification, "Test 3d, Should have a click-to-play notification");
 
   // Check the list item status
   let promiseShown = BrowserTestUtils.waitForEvent(gPrivateWindow.PopupNotifications.panel,
                                                    "Shown");
   popupNotification.reshow();
   await promiseShown;
   let doc = gPrivateWindow.document;
-  for (let item of gPrivateWindow.PopupNotifications.panel.firstChild.childNodes) {
+  for (let item of gPrivateWindow.PopupNotifications.panel.firstElementChild.children) {
     let allowalways = doc.getAnonymousElementByAttribute(item, "anonid", "allowalways");
     ok(allowalways, "Test 3d, should have list item for allow always");
     let allownow = doc.getAnonymousElementByAttribute(item, "anonid", "allownow");
     ok(allownow, "Test 3d, should have list item for allow now");
     let block = doc.getAnonymousElementByAttribute(item, "anonid", "block");
     ok(block, "Test 3d, should have list item for block");
 
     if (item.action.pluginName === "Test") {
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification.js b/browser/base/content/test/popupNotifications/browser_popupNotification.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification.js
@@ -184,22 +184,22 @@ var tests = [
       this.testNotif1.message += " 1";
       showNotification(this.testNotif1);
       this.testNotif2 = new BasicNotification(this.id);
       this.testNotif2.message += " 2";
       this.testNotif2.id += "-2";
       showNotification(this.testNotif2);
     },
     onShown(popup) {
-      is(popup.childNodes.length, 2, "two notifications are shown");
+      is(popup.children.length, 2, "two notifications are shown");
       // Trigger the main command for the first notification, and the secondary
       // for the second. Need to do mainCommand first since the secondaryCommand
       // triggering is async.
       triggerMainCommand(popup);
-      is(popup.childNodes.length, 1, "only one notification left");
+      is(popup.children.length, 1, "only one notification left");
       triggerSecondaryCommand(popup, 0);
     },
     onHidden(popup) {
       ok(this.testNotif1.mainActionClicked, "main action #1 was clicked");
       ok(!this.testNotif1.secondaryActionClicked, "secondary action #1 wasn't clicked");
       ok(!this.testNotif1.dismissalCallbackTriggered, "dismissal callback #1 wasn't called");
 
       ok(!this.testNotif2.mainActionClicked, "main action #2 wasn't clicked");
@@ -212,17 +212,17 @@ var tests = [
   { id: "Test#9",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.mainAction = null;
       this.notifyObj.secondaryActions = null;
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       is(notification.getAttribute("buttonhighlight"), "true", "default action is highlighted");
       triggerMainCommand(popup);
     },
     onHidden(popup) {
       ok(!this.notifyObj.mainActionClicked, "mainAction was not clicked");
       ok(!this.notifyObj.dismissalCallbackTriggered, "dismissal callback wasn't triggered");
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
     }
@@ -232,17 +232,17 @@ var tests = [
   // and ignore the passed secondaryActions.
   { id: "Test#10",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.mainAction = null;
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       is(notification.getAttribute("secondarybuttonhidden"), "true", "secondary button is hidden");
       is(notification.getAttribute("buttonhighlight"), "true", "default action is highlighted");
       triggerMainCommand(popup);
     },
     onHidden(popup) {
       ok(!this.notifyObj.mainActionClicked, "mainAction was not clicked");
       ok(!this.notifyObj.dismissalCallbackTriggered, "dismissal callback wasn't triggered");
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_2.js b/browser/base/content/test/popupNotifications/browser_popupNotification_2.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_2.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_2.js
@@ -200,17 +200,17 @@ var tests = [
   // Test notification close button
   { id: "Test#9",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       EventUtils.synthesizeMouseAtCenter(notification.closebutton, {});
     },
     onHidden(popup) {
       ok(this.notifyObj.dismissalCallbackTriggered, "dismissal callback triggered");
       this.notification.remove();
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
       ok(!this.notifyObj.secondaryActionClicked, "secondary action not clicked");
     }
@@ -220,17 +220,17 @@ var tests = [
   { id: "Test#10",
     run() {
       Services.prefs.setBoolPref("privacy.permissionPrompts.showCloseButton", true);
       this.notifyObj = new BasicNotification(this.id);
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       EventUtils.synthesizeMouseAtCenter(notification.closebutton, {});
     },
     onHidden(popup) {
       ok(!this.notifyObj.dismissalCallbackTriggered, "dismissal callback not triggered");
       ok(this.notifyObj.secondaryActionClicked, "secondary action clicked");
       Services.prefs.clearUserPref("privacy.permissionPrompts.showCloseButton");
       this.notification.remove();
       ok(this.notifyObj.removedCallbackTriggered, "removed callback triggered");
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_3.js b/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
@@ -284,17 +284,17 @@ var tests = [
         info("notifyObj2.options.eventCallback: " + eventName);
         if (eventName == "dismissed") {
           throw new Error("Oops 2!");
         }
       };
       this.notification2 = showNotification(this.testNotif2);
     },
     onShown(popup) {
-      is(popup.childNodes.length, 2, "two notifications are shown");
+      is(popup.children.length, 2, "two notifications are shown");
       dismissNotification(popup);
     },
     onHidden() {
       this.notification1.remove();
       this.notification2.remove();
     }
   }
 ];
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_4.js b/browser/base/content/test/popupNotifications/browser_popupNotification_4.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_4.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_4.js
@@ -106,17 +106,17 @@ var tests = [
       await shown;
 
       let promiseWin = BrowserTestUtils.waitForNewWindow();
       gBrowser.replaceTabWithWindow(gBrowser.selectedTab);
       let win = await promiseWin;
 
       let anchor = win.document.getElementById("default-notification-icon");
       win.PopupNotifications._reshowNotifications(anchor);
-      ok(win.PopupNotifications.panel.childNodes.length == 0,
+      ok(win.PopupNotifications.panel.children.length == 0,
          "no notification displayed in new window");
       ok(notifyObj.swappingCallbackTriggered, "the swapping callback was triggered");
       ok(notifyObj.removedCallbackTriggered, "the removed callback was triggered");
 
       await BrowserTestUtils.closeWindow(win);
       await waitForWindowReadyForPopupNotifications(window);
 
       goNext();
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_5.js b/browser/base/content/test/popupNotifications/browser_popupNotification_5.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_5.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_5.js
@@ -161,17 +161,17 @@ var tests = [
       gBrowser.removeTab(gBrowser.selectedTab);
       gBrowser.selectedTab = this.oldSelectedTab;
     }
   },
   // Second part of the previous test that compensates for the limitation in
   // runNextTest that expects a single onShown/onHidden invocation per test.
   { id: "Test#6b",
     run() {
-      let id = PopupNotifications.panel.firstChild.getAttribute("popupid");
+      let id = PopupNotifications.panel.firstElementChild.getAttribute("popupid");
       ok(id.endsWith("Test#6a"), "Should have found the notification from Test6a");
       ok(PopupNotifications.isPanelOpen, "Should have shown the popup again after getting back to the tab");
       gNotification.remove();
       gNotification = null;
       goNext();
     }
   },
   // Test that persistent panels are still open after switching to another
@@ -198,23 +198,23 @@ var tests = [
       let timeShown = this.notification.timeShown;
 
       let promiseWin = BrowserTestUtils.waitForNewWindow();
       gBrowser.replaceTabWithWindow(firstTab);
       let win = await promiseWin;
 
       let anchor = win.document.getElementById("default-notification-icon");
       win.PopupNotifications._reshowNotifications(anchor);
-      ok(win.PopupNotifications.panel.childNodes.length == 0,
+      ok(win.PopupNotifications.panel.children.length == 0,
          "no notification displayed in new window");
 
       await BrowserTestUtils.closeWindow(win);
       await waitForWindowReadyForPopupNotifications(window);
 
-      let id = PopupNotifications.panel.firstChild.getAttribute("popupid");
+      let id = PopupNotifications.panel.firstElementChild.getAttribute("popupid");
       ok(id.endsWith("Test#7"), "Should have found the notification from Test7");
       ok(PopupNotifications.isPanelOpen,
          "Should have kept the popup on the first window");
       ok(!notifyObj.dismissalCallbackTriggered,
          "Should not have triggered a dismissed event");
       ok(!notifyObj.shownCallbackTriggered,
          "Should not have triggered a second shown event");
       ok(!notifyObj.showingCallbackTriggered,
@@ -272,17 +272,17 @@ var tests = [
       this.notifyObj3.id += "_3";
       this.notifyObj3.anchorID = "default-notification-icon";
       this.notifyObj3.options.persistent = true;
       this.notification3 = showNotification(this.notifyObj3);
 
       PopupNotifications._update();
     },
     onShown(popup) {
-      let notifications = popup.childNodes;
+      let notifications = popup.children;
       is(notifications.length, 2, "two notifications displayed");
       let [notification1, notification2] = notifications;
       is(notification1.id, this.notifyObj1.id + "-notification", "id 1 matches");
       is(notification2.id, this.notifyObj3.id + "-notification", "id 2 matches");
 
       this.notification1.remove();
       this.notification2.remove();
       this.notification3.remove();
@@ -312,22 +312,22 @@ var tests = [
       this.notifyObj3.anchorID = "geo-notification-icon";
       this.notifyObj3.options.persistent = true;
       this.notifyObj3.options.hideClose = false;
       this.notification3 = showNotification(this.notifyObj3);
 
       PopupNotifications._update();
     },
     onShown(popup) {
-      let notifications = popup.childNodes;
+      let notifications = popup.children;
       is(notifications.length, 3, "three notifications displayed");
       EventUtils.synthesizeMouseAtCenter(notifications[1].closebutton, {});
     },
     onHidden(popup) {
-      let notifications = popup.childNodes;
+      let notifications = popup.children;
       is(notifications.length, 2, "two notifications displayed");
 
       ok(this.notification1.options.persistent, "notification 1 is persistent");
       ok(!this.notification2.options.persistent, "notification 2 is not persistent");
       ok(this.notification3.options.persistent, "notification 3 is persistent");
 
       this.notification1.remove();
       this.notification2.remove();
@@ -363,17 +363,17 @@ var tests = [
          "Should not have dismissed the notification");
       notifyObj1.shownCallbackTriggered = false;
       notifyObj1.showingCallbackTriggered = false;
 
       // Click the anchor. This should focus the closebutton
       // (because it's the first focusable element), but not
       // call event callbacks on the notification object.
       clickAnchor(notifyObj1);
-      is(document.activeElement, popup.childNodes[0].closebutton);
+      is(document.activeElement, popup.children[0].closebutton);
       ok(!notifyObj1.dismissalCallbackTriggered,
          "Should not have dismissed the notification");
       ok(!notifyObj1.shownCallbackTriggered,
          "Should have triggered the shown event again");
       ok(!notifyObj1.showingCallbackTriggered,
          "Should have triggered the showing event again");
 
       // Add another notification.
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js b/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_checkbox.js
@@ -41,17 +41,17 @@ var tests = [
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       checkCheckbox(notification.checkbox, "This is a checkbox");
       triggerMainCommand(popup);
     },
     onHidden() { }
   },
 
   // Test checkbox being checked by default
   { id: "checkbox_checked",
@@ -60,17 +60,17 @@ var tests = [
       this.notifyObj.options.checkbox = {
         label: "Check this",
         checked: true,
       };
       gNotification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       checkCheckbox(notification.checkbox, "Check this", true);
       triggerMainCommand(popup);
     },
     onHidden() { }
   },
 
   // Test checkbox passing the checkbox state on mainAction
   { id: "checkbox_passCheckboxChecked_mainAction",
@@ -79,17 +79,17 @@ var tests = [
       this.notifyObj.mainAction.callback = ({checkboxChecked}) => this.mainActionChecked = checkboxChecked;
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox");
       await promiseElementVisible(checkbox);
       EventUtils.synthesizeMouseAtCenter(checkbox, {});
       checkCheckbox(checkbox, "This is a checkbox", true);
       triggerMainCommand(popup);
     },
     onHidden() {
@@ -108,17 +108,17 @@ var tests = [
       }];
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox");
       await promiseElementVisible(checkbox);
       EventUtils.synthesizeMouseAtCenter(checkbox, {});
       checkCheckbox(checkbox, "This is a checkbox", true);
       triggerSecondaryCommand(popup, 0);
     },
     onHidden() {
@@ -136,46 +136,46 @@ var tests = [
           disableMainAction: true,
           warningLabel: "Testing disable",
         },
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox");
       await promiseElementVisible(checkbox);
       EventUtils.synthesizeMouseAtCenter(checkbox, {});
       dismissNotification(popup);
     },
     async onHidden(popup) {
       let icon = document.getElementById("default-notification-icon");
       let shown = waitForNotificationPanel();
       EventUtils.synthesizeMouseAtCenter(icon, {});
       await shown;
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       let checkbox = notification.checkbox;
       checkCheckbox(checkbox, "This is a checkbox", true);
       checkMainAction(notification, true);
       gNotification.remove();
     }
   },
 
   // Test no checkbox hides warning label
   { id: "no_checkbox",
     run() {
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.options.checkbox = null;
       gNotification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       checkCheckbox(notification.checkbox, "", false, true);
       checkMainAction(notification);
       triggerMainCommand(popup);
     },
     onHidden() { },
   },
 ];
 
@@ -193,17 +193,17 @@ var tests = [
               disableMainAction: true,
               warningLabel: "Testing disable",
             },
           };
           gNotification = showNotification(this.notifyObj);
         },
         async onShown(popup) {
           checkPopup(popup, this.notifyObj);
-          let notification = popup.childNodes[0];
+          let notification = popup.children[0];
           let checkbox = notification.checkbox;
           let disabled = (state === "checkedState" && checked) ||
                          (state === "uncheckedState" && !checked);
 
           checkCheckbox(checkbox, "This is a checkbox", checked);
           checkMainAction(notification, disabled);
           await promiseElementVisible(checkbox);
           EventUtils.synthesizeMouseAtCenter(checkbox, {});
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js b/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_keyboard.js
@@ -66,17 +66,17 @@ var tests = [
       this.notification = showNotification(this.notifyObj);
     },
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
       let anchor = document.getElementById(this.notifyObj.anchorID);
       anchor.focus();
       is(document.activeElement, anchor);
       EventUtils.sendString(" ");
-      is(document.activeElement, popup.childNodes[0].closebutton);
+      is(document.activeElement, popup.children[0].closebutton);
       this.notification.remove();
     },
     onHidden(popup) { }
   },
   // Test that you can switch between active notifications with the space key
   // and that the notification is focused on selection.
   { id: "Test#4",
     async run() {
@@ -111,28 +111,28 @@ var tests = [
       let anchor = document.getElementById(notifyObj1.anchorID);
       anchor.focus();
       is(document.activeElement, anchor);
       opened = waitForNotificationPanel();
       EventUtils.sendString(" ");
       popup = await opened;
       checkPopup(popup, notifyObj1);
 
-      is(document.activeElement, popup.childNodes[0].checkbox);
+      is(document.activeElement, popup.children[0].checkbox);
 
       // Activate the anchor for notification 2 and wait until it's shown.
       anchor = document.getElementById(notifyObj2.anchorID);
       anchor.focus();
       is(document.activeElement, anchor);
       opened = waitForNotificationPanel();
       EventUtils.sendString(" ");
       popup = await opened;
       checkPopup(popup, notifyObj2);
 
-      is(document.activeElement, popup.childNodes[0].closebutton);
+      is(document.activeElement, popup.children[0].closebutton);
 
       notification1.remove();
       notification2.remove();
       goNext();
     },
   },
   // Test that passing the autofocus option will focus an opened notification.
   { id: "Test#5",
@@ -147,17 +147,17 @@ var tests = [
     onShown(popup) {
       checkPopup(popup, this.notifyObj);
 
       // Initial focus on open is null because a panel itself
       // can not be focused, next tab focus will be inside the panel.
       is(Services.focus.focusedElement, null);
 
       EventUtils.synthesizeKey("KEY_Tab");
-      is(Services.focus.focusedElement, popup.childNodes[0].closebutton);
+      is(Services.focus.focusedElement, popup.children[0].closebutton);
       dismissNotification(popup);
     },
     async onHidden() {
       // Focus the urlbar to check that it stays focused.
       gURLBar.focus();
 
       // Show another notification and make sure it's not autofocused.
       let notifyObj = new BasicNotification(this.id);
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js b/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_selection_required.js
@@ -28,17 +28,17 @@ var tests = [
       this.notifyObj = new BasicNotification(this.id);
       this.notifyObj.options.checkbox = {
         label: "This is a checkbox",
       };
       gNotification = showNotification(this.notifyObj);
     },
     async onShown(popup) {
       checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+      let notification = popup.children[0];
       notification.setAttribute("invalidselection", true);
       await promiseElementVisible(notification.checkbox);
       EventUtils.synthesizeMouseAtCenter(notification.checkbox, {});
       ok(notification.button.disabled, "should be disabled when invalidselection");
       notification.removeAttribute("invalidselection");
       EventUtils.synthesizeMouseAtCenter(notification.checkbox, {});
       ok(!notification.button.disabled, "should not be disabled when invalidselection is not present");
       triggerMainCommand(popup);
diff --git a/browser/base/content/test/popupNotifications/head.js b/browser/base/content/test/popupNotifications/head.js
--- a/browser/base/content/test/popupNotifications/head.js
+++ b/browser/base/content/test/popupNotifications/head.js
@@ -97,17 +97,17 @@ function showNotification(notifyObj) {
                                  notifyObj.message,
                                  notifyObj.anchorID,
                                  notifyObj.mainAction,
                                  notifyObj.secondaryActions,
                                  notifyObj.options);
 }
 
 function dismissNotification(popup) {
-  info("Dismissing notification " + popup.childNodes[0].id);
+  info("Dismissing notification " + popup.children[0].id);
   executeSoon(() => EventUtils.synthesizeKey("KEY_Escape"));
 }
 
 function BasicNotification(testId) {
   this.browser = gBrowser.selectedBrowser;
   this.id = "test-notification-" + testId;
   this.message = testId + ": Will you allow <> to perform this action?";
   this.anchorID = null;
@@ -173,17 +173,17 @@ function ErrorNotification(testId) {
 ErrorNotification.prototype = BasicNotification.prototype;
 
 function checkPopup(popup, notifyObj) {
   info("Checking notification " + notifyObj.id);
 
   ok(notifyObj.showingCallbackTriggered, "showing callback was triggered");
   ok(notifyObj.shownCallbackTriggered, "shown callback was triggered");
 
-  let notifications = popup.childNodes;
+  let notifications = popup.children;
   is(notifications.length, 1, "one notification displayed");
   let notification = notifications[0];
   if (!notification)
     return;
   let icon = document.getAnonymousElementByAttribute(notification, "class",
                                                      "popup-notification-icon");
   if (notifyObj.id == "geolocation") {
     isnot(icon.boxObject.width, 0, "icon for geo displayed");
@@ -213,17 +213,17 @@ function checkPopup(popup, notifyObj) {
     let secondaryAction = notifyObj.secondaryActions[0];
     is(notification.getAttribute("secondarybuttonlabel"), secondaryAction.label,
        "secondary action label matches");
     is(notification.getAttribute("secondarybuttonaccesskey"),
        secondaryAction.accessKey, "secondary action accesskey matches");
   }
   // Additional secondary actions appear as menu items.
   let actualExtraSecondaryActions =
-    Array.filter(notification.childNodes, child => child.nodeName == "menuitem");
+    Array.filter(notification.children, child => child.nodeName == "menuitem");
   let extraSecondaryActions = notifyObj.secondaryActions ? notifyObj.secondaryActions.slice(1) : [];
   is(actualExtraSecondaryActions.length, extraSecondaryActions.length,
      "number of extra secondary actions matches");
   extraSecondaryActions.forEach(function(a, i) {
     is(actualExtraSecondaryActions[i].getAttribute("label"), a.label,
        "label for extra secondary action " + i + " matches");
     is(actualExtraSecondaryActions[i].getAttribute("accesskey"), a.accessKey,
        "accessKey for extra secondary action " + i + " matches");
@@ -265,36 +265,36 @@ function waitForNotificationPanelHidden(
   return new Promise(resolve => {
     onPopupEvent("popuphidden", function() {
       resolve(this);
     });
   });
 }
 
 function triggerMainCommand(popup) {
-  let notifications = popup.childNodes;
+  let notifications = popup.children;
   ok(notifications.length > 0, "at least one notification displayed");
   let notification = notifications[0];
   info("Triggering main command for notification " + notification.id);
   EventUtils.synthesizeMouseAtCenter(notification.button, {});
 }
 
 function triggerSecondaryCommand(popup, index) {
-  let notifications = popup.childNodes;
+  let notifications = popup.children;
   ok(notifications.length > 0, "at least one notification displayed");
   let notification = notifications[0];
   info("Triggering secondary command for notification " + notification.id);
 
   if (index == 0) {
     EventUtils.synthesizeMouseAtCenter(notification.secondaryButton, {});
     return;
   }
 
   // Extra secondary actions appear in a menu.
-  notification.secondaryButton.nextSibling.nextSibling.focus();
+  notification.secondaryButton.nextElementSibling.nextElementSibling.focus();
 
   popup.addEventListener("popupshown", function() {
     info("Command popup open for notification " + notification.id);
     // Press down until the desired command is selected. Decrease index by one
     // since the secondary action was handled above.
     for (let i = 0; i <= index - 1; i++) {
       EventUtils.synthesizeKey("KEY_ArrowDown");
     }
diff --git a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js
--- a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js
+++ b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab.js
@@ -22,19 +22,19 @@ function startNewTabTestCase(aTestNumber
                                     startNewTabTestCase);
     });
 
     let menu = gTestWindow.document.getElementById("context-openlinkinusercontext-menu");
 
     let menupopup = menu.menupopup;
     menu.addEventListener("popupshown", function() {
       is(menupopup.nodeType, Node.ELEMENT_NODE, "We have a menupopup.");
-      ok(menupopup.firstChild, "We have a first container entry.");
+      ok(menupopup.firstElementChild, "We have a first container entry.");
 
-      let firstContext = menupopup.firstChild;
+      let firstContext = menupopup.firstElementChild;
       is(firstContext.nodeType, Node.ELEMENT_NODE, "We have a first container entry.");
       ok(firstContext.hasAttribute("data-usercontextid"), "We have a usercontextid value.");
 
       aContextMenu.addEventListener("popuphidden", function() {
         firstContext.doCommand();
       }, {once: true});
 
       aContextMenu.hidePopup();
diff --git a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js
--- a/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js
+++ b/browser/base/content/test/referrer/browser_referrer_open_link_in_container_tab3.js
@@ -17,19 +17,19 @@ function startNewTabTestCase(aTestNumber
                                     startNewTabTestCase, { userContextId: 2 });
     });
 
     let menu = gTestWindow.document.getElementById("context-openlinkinusercontext-menu");
 
     let menupopup = menu.menupopup;
     menu.addEventListener("popupshown", function() {
       is(menupopup.nodeType, Node.ELEMENT_NODE, "We have a menupopup.");
-      ok(menupopup.firstChild, "We have a first container entry.");
+      ok(menupopup.firstElementChild, "We have a first container entry.");
 
-      let firstContext = menupopup.firstChild;
+      let firstContext = menupopup.firstElementChild;
       is(firstContext.nodeType, Node.ELEMENT_NODE, "We have a first container entry.");
       ok(firstContext.hasAttribute("data-usercontextid"), "We have a usercontextid value.");
       is("0", firstContext.getAttribute("data-usercontextid"), "We have the right usercontextid value.");
 
       aContextMenu.addEventListener("popuphidden", function() {
         firstContext.doCommand();
       }, {once: true});
 
diff --git a/browser/base/content/test/sidebar/browser_sidebar_move.js b/browser/base/content/test/sidebar/browser_sidebar_move.js
--- a/browser/base/content/test/sidebar/browser_sidebar_move.js
+++ b/browser/base/content/test/sidebar/browser_sidebar_move.js
@@ -17,17 +17,17 @@ const EXPECTED_END_ORDINALS = [
   ["sidebar-box", 4],
   ["sidebar-splitter", 3],
   ["appcontent", 2],
   ["browser-border-end", 5],
 ];
 
 function getBrowserChildrenWithOrdinals() {
   let browser = document.getElementById("browser");
-  return [...browser.childNodes].map(node => {
+  return [...browser.children].map(node => {
     return [node.id, node.ordinal];
   });
 }
 
 add_task(async function() {
   await SidebarUI.show("viewBookmarksSidebar");
   SidebarUI.showSwitcherPanel();
 
diff --git a/browser/base/content/test/tabs/browser_overflowScroll.js b/browser/base/content/test/tabs/browser_overflowScroll.js
--- a/browser/base/content/test/tabs/browser_overflowScroll.js
+++ b/browser/base/content/test/tabs/browser_overflowScroll.js
@@ -69,17 +69,17 @@ add_task(async function() {
 
   element = nextLeftElement();
   EventUtils.synthesizeMouseAtCenter(upButton, {});
   await waitForNextFrame();
   isLeft(element, "Scrolled one tab to the left with a single click");
 
   let elementPoint = left(scrollbox) - width(scrollbox);
   element = elementFromPoint(elementPoint);
-  element = element.nextSibling;
+  element = element.nextElementSibling;
 
   EventUtils.synthesizeMouseAtCenter(upButton, {clickCount: 2});
   await waitForNextFrame();
   await BrowserTestUtils.waitForCondition(() =>
     !gBrowser.tabContainer.arrowScrollbox._isScrolling);
   isLeft(element, "Scrolled one page of tabs with a double click");
 
   EventUtils.synthesizeMouseAtCenter(upButton, {clickCount: 3});
diff --git a/browser/base/content/test/urlbar/browser_action_keyword.js b/browser/base/content/test/urlbar/browser_action_keyword.js
--- a/browser/base/content/test/urlbar/browser_action_keyword.js
+++ b/browser/base/content/test/urlbar/browser_action_keyword.js
@@ -1,12 +1,12 @@
 async function promise_first_result(inputText) {
   await promiseAutocompleteResultPopup(inputText);
 
-  let firstResult = gURLBar.popup.richlistbox.firstChild;
+  let firstResult = gURLBar.popup.richlistbox.firstElementChild;
   return firstResult;
 }
 
 const TEST_URL = "http://mochi.test:8888/browser/browser/base/content/test/urlbar/print_postdata.sjs";
 
 add_task(async function setup() {
   await PlacesUtils.keywords.insert({ keyword: "get",
                                       url: TEST_URL + "?q=%s" });
diff --git a/browser/base/content/test/urlbar/browser_locationBarCommand.js b/browser/base/content/test/urlbar/browser_locationBarCommand.js
--- a/browser/base/content/test/urlbar/browser_locationBarCommand.js
+++ b/browser/base/content/test/urlbar/browser_locationBarCommand.js
@@ -83,17 +83,17 @@ add_task(async function shift_accel_left
 
   // Check the load occurred in a new background tab.
   info("URL should be loaded in a new background tab");
   is(gURLBar.value, "", "Urlbar reverted to original value");
   ok(!gURLBar.focused, "Urlbar is no longer focused after urlbar command");
   is(gBrowser.selectedTab, tab, "Focus did not change to the new tab");
 
   // Select the new background tab
-  gBrowser.selectedTab = gBrowser.selectedTab.nextSibling;
+  gBrowser.selectedTab = gBrowser.selectedTab.nextElementSibling;
   is(gURLBar.value, TEST_VALUE, "New URL is loaded in new tab");
 
   // Cleanup.
   gBrowser.removeCurrentTab();
   gBrowser.removeCurrentTab();
 });
 
 add_task(async function load_in_current_tab_test() {
diff --git a/browser/base/content/test/urlbar/browser_page_action_menu.js b/browser/base/content/test/urlbar/browser_page_action_menu.js
--- a/browser/base/content/test/urlbar/browser_page_action_menu.js
+++ b/browser/base/content/test/urlbar/browser_page_action_menu.js
@@ -750,20 +750,20 @@ function promiseSyncReady() {
   });
 }
 
 function checkSendToDeviceItems(expectedItems, forUrlbar = false) {
   let bodyID =
     BrowserPageActions._panelViewNodeIDForActionID("sendToDevice", forUrlbar) +
     "-body";
   let body = document.getElementById(bodyID);
-  Assert.equal(body.childNodes.length, expectedItems.length);
+  Assert.equal(body.children.length, expectedItems.length);
   for (let i = 0; i < expectedItems.length; i++) {
     let expected = expectedItems[i];
-    let actual = body.childNodes[i];
+    let actual = body.children[i];
     if (!expected) {
       Assert.equal(actual.localName, "toolbarseparator");
       continue;
     }
     if ("id" in expected) {
       Assert.equal(actual.id, expected.id);
     }
     if ("className" in expected) {
@@ -787,12 +787,12 @@ function checkSendToDeviceItems(expected
         Assert.equal(attrVal, expected.attrs[name]);
       }
     }
   }
 }
 
 function collectContextMenuItems() {
   let contextMenu = document.getElementById("pageActionContextMenu");
-  return Array.filter(contextMenu.childNodes, node => {
+  return Array.filter(contextMenu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 }
diff --git a/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js b/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js
--- a/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js
+++ b/browser/base/content/test/urlbar/browser_page_action_menu_add_search_engine.js
@@ -113,59 +113,59 @@ add_task(async function many() {
     EventUtils.synthesizeMouseAtCenter(button, {});
     let view = await viewPromise;
     let viewID =
        BrowserPageActions._panelViewNodeIDForActionID("addSearchEngine", false);
     Assert.equal(view.id, viewID, "View ID");
     let bodyID = viewID + "-body";
     let body = document.getElementById(bodyID);
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the first engine to install it.
     let enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_0");
     let hiddenPromise = promisePageActionPanelHidden();
     let feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     let engines = [];
     let engine = await enginePromise;
     engines.push(engine);
     let feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Open the panel and show the subview again.  The installed engine should
     // be gone.
     await promisePageActionPanelOpen();
     viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(button, {});
     await viewPromise;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the next engine to install it.
     enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_1");
     hiddenPromise = promisePageActionPanelHidden();
     feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     engine = await enginePromise;
     engines.push(engine);
     feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Open the panel again.  This time the action button should show the one
     // remaining engine.
@@ -245,17 +245,17 @@ add_task(async function many() {
     Assert.equal(button.label, expectedTitle, "Button label");
     Assert.equal(button.classList.contains("subviewbutton-nav"), true,
                  "Button should expand into a subview");
     viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(button, {});
     await viewPromise;
     body = document.getElementById(bodyID);
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
       ],
       "Subview children"
     );
     EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
     await promisePageActionPanelHidden();
@@ -267,17 +267,17 @@ add_task(async function many() {
     await enginePromise;
 
     // Open the panel again and check the subview.
     await promisePageActionPanelOpen();
     viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(button, {});
     await viewPromise;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
     EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
@@ -361,61 +361,61 @@ add_task(async function urlbarMany() {
 
     // Click the action's button.  The activated-action panel should open, and
     // it should contain the addSearchEngine subview.
     EventUtils.synthesizeMouseAtCenter(button, {});
     let view = await waitForActivatedActionPanel();
     let viewID =
        BrowserPageActions._panelViewNodeIDForActionID("addSearchEngine", true);
     Assert.equal(view.id, viewID, "View ID");
-    let body = view.firstChild;
+    let body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the first engine to install it.
     let enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_0");
     let hiddenPromise =
       promisePanelHidden(BrowserPageActions.activatedActionPanelNode);
     let feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     let engines = [];
     let engine = await enginePromise;
     engines.push(engine);
     let feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Open the panel again.  The installed engine should be gone.
     EventUtils.synthesizeMouseAtCenter(button, {});
     view = await waitForActivatedActionPanel();
-    body = view.firstChild;
+    body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
     // Click the next engine to install it.
     enginePromise =
       promiseEngine("engine-added", "page_action_menu_add_search_engine_1");
     hiddenPromise =
       promisePanelHidden(BrowserPageActions.activatedActionPanelNode);
     feedbackPromise = promiseFeedbackPanelShownAndHidden();
-    EventUtils.synthesizeMouseAtCenter(body.childNodes[0], {});
+    EventUtils.synthesizeMouseAtCenter(body.children[0], {});
     await hiddenPromise;
     engine = await enginePromise;
     engines.push(engine);
     feedbackText = await feedbackPromise;
     Assert.equal(feedbackText, "Search engine added!", "Feedback text");
 
     // Now there's only one engine left, so clicking the button should simply
     // install it instead of opening the activated-action panel.
@@ -454,19 +454,19 @@ add_task(async function urlbarMany() {
       promiseEngine("engine-removed", "page_action_menu_add_search_engine_1");
     Services.search.removeEngine(engines.shift());
     await enginePromise;
 
     // Open the panel again and check the subview.  The subview should be
     // present now that there are two offered engines again.
     EventUtils.synthesizeMouseAtCenter(button, {});
     view = await waitForActivatedActionPanel();
-    body = view.firstChild;
+    body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
       ],
       "Subview children"
     );
 
     // Hide the panel.
@@ -479,19 +479,19 @@ add_task(async function urlbarMany() {
     enginePromise =
       promiseEngine("engine-removed", "page_action_menu_add_search_engine_2");
     Services.search.removeEngine(engines.shift());
     await enginePromise;
 
     // Open the panel again and check the subview.
     EventUtils.synthesizeMouseAtCenter(button, {});
     view = await waitForActivatedActionPanel();
-    body = view.firstChild;
+    body = view.firstElementChild;
     Assert.deepEqual(
-      Array.map(body.childNodes, n => n.label),
+      Array.map(body.children, n => n.label),
       [
         "page_action_menu_add_search_engine_0",
         "page_action_menu_add_search_engine_1",
         "page_action_menu_add_search_engine_2",
       ],
       "Subview children"
     );
 
diff --git a/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js b/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js
--- a/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js
+++ b/browser/base/content/test/urlbar/browser_page_action_menu_share_mac.js
@@ -52,18 +52,18 @@ add_task(async function shareURL() {
     let shareURLButton = document.getElementById("pageAction-panel-shareURL");
     let viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(shareURLButton, {});
 
     let view = await viewPromise;
     let body = document.getElementById(view.id + "-body");
 
     // We should see 1 receiver and one extra node for the "More..." button
-    Assert.equal(body.childNodes.length, 2, "Has correct share receivers");
-    let shareButton = body.childNodes[0];
+    Assert.equal(body.children.length, 2, "Has correct share receivers");
+    let shareButton = body.children[0];
     Assert.equal(shareButton.label, mockShareData[0].menuItemTitle);
     let hiddenPromise = promisePageActionPanelHidden();
     // Click on share, panel should hide and sharingService should be
     // given the title of service to share with
     EventUtils.synthesizeMouseAtCenter(shareButton, {});
     await hiddenPromise;
 
     Assert.equal(serviceName, mockShareData[0].name,
@@ -106,17 +106,17 @@ add_task(async function shareURLAddressB
     let shareButton = document.getElementById("pageAction-urlbar-shareURL");
     let viewPromise = promisePageActionPanelShown();
     EventUtils.synthesizeMouseAtCenter(shareButton, {});
     await viewPromise;
 
     // Ensure we have share providers
     let panel = document.getElementById("pageAction-urlbar-shareURL-subview-body");
     // We should see 1 receiver and one extra node for the "More..." button
-    Assert.equal(panel.childNodes.length, 2, "Has correct share receivers");
+    Assert.equal(panel.children.length, 2, "Has correct share receivers");
 
     // Remove the Share URL button from the Address bar so we dont interfere
     // with future tests
     contextMenuPromise = promisePanelShown("pageActionContextMenu");
     EventUtils.synthesizeMouseAtCenter(shareButton, {
       type: "contextmenu",
       button: 2,
     });
@@ -139,18 +139,18 @@ add_task(async function openSharingPrefe
     let shareURLButton = document.getElementById("pageAction-panel-shareURL");
     let viewPromise = promisePageActionViewShown();
     EventUtils.synthesizeMouseAtCenter(shareURLButton, {});
 
     let view = await viewPromise;
     let body = document.getElementById(view.id + "-body");
 
     // We should see 1 receiver and one extra node for the "More..." button
-    Assert.equal(body.childNodes.length, 2, "Has correct share receivers");
-    let moreButton = body.childNodes[1];
+    Assert.equal(body.children.length, 2, "Has correct share receivers");
+    let moreButton = body.children[1];
     let hiddenPromise = promisePageActionPanelHidden();
     // Click on the "more" button,  panel should hide and we should call
     // the sharingService function to open preferences
     EventUtils.synthesizeMouseAtCenter(moreButton, {});
     await hiddenPromise;
 
     Assert.equal(sharingPreferencesCalled, true,
                  "We called openSharingPreferences");
diff --git a/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js b/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js
--- a/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js
+++ b/browser/base/content/test/urlbar/browser_urlbarAboutHomeLoading.js
@@ -96,17 +96,17 @@ add_task(async function dontTemporarilyS
       is(win.gURLBar.value, "", "URL bar value should stay empty.");
     },
   };
   win.gBrowser.addProgressListener(wpl);
 
   if (win.gBrowser.visibleTabs.length < 2) {
     await BrowserTestUtils.waitForEvent(gBrowser.tabContainer, "TabOpen");
   }
-  let otherTab = win.gBrowser.selectedTab.previousSibling;
+  let otherTab = win.gBrowser.selectedTab.previousElementSibling;
   let tabLoaded = BrowserTestUtils.browserLoaded(otherTab.linkedBrowser, false, "about:home");
   await BrowserTestUtils.switchTab(win.gBrowser, otherTab);
   await tabLoaded;
   win.gBrowser.removeProgressListener(wpl);
   is(win.gURLBar.value, "", "URL bar value should be empty.");
 
   await BrowserTestUtils.closeWindow(win);
 });
diff --git a/browser/base/content/test/urlbar/browser_urlbarDecode.js b/browser/base/content/test/urlbar/browser_urlbarDecode.js
--- a/browser/base/content/test/urlbar/browser_urlbarDecode.js
+++ b/browser/base/content/test/urlbar/browser_urlbarDecode.js
@@ -60,17 +60,17 @@ add_task(async function actionURILossles
   gURLBar.value = "";
   gURLBar.handleRevert();
   gURLBar.blur();
 });
 
 async function checkInput(inputStr) {
   await promiseAutocompleteResultPopup(inputStr);
 
-  let item = gURLBar.popup.richlistbox.firstChild;
+  let item = gURLBar.popup.richlistbox.firstElementChild;
   Assert.ok(item, "Should have a result");
 
   // visiturl matches have their param.urls fixed up.
   let fixupInfo = Services.uriFixup.getFixupURIInfo(inputStr,
     Ci.nsIURIFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS |
     Ci.nsIURIFixup.FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
   );
   let expectedVisitURL = fixupInfo.fixedURI.spec;
diff --git a/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js b/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js
--- a/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js
+++ b/browser/base/content/test/urlbar/browser_urlbarKeepStateAcrossTabSwitches.js
@@ -12,17 +12,17 @@ add_task(async function() {
   // load events fire.
   await BrowserTestUtils.waitForCondition(() => browser.contentDocumentAsCPOW && !browser.contentDocumentAsCPOW.hidden);
   let errorPageLoaded = BrowserTestUtils.waitForErrorPage(tab.linkedBrowser);
   gURLBar.value = input;
   gURLBar.select();
   EventUtils.sendKey("return");
   await errorPageLoaded;
   is(gURLBar.textValue, input, "Text is still in URL bar");
-  await BrowserTestUtils.switchTab(gBrowser, tab.previousSibling);
+  await BrowserTestUtils.switchTab(gBrowser, tab.previousElementSibling);
   await BrowserTestUtils.switchTab(gBrowser, tab);
   is(gURLBar.textValue, input, "Text is still in URL bar after tab switch");
   BrowserTestUtils.removeTab(tab);
 });
 
 /**
  * Invalid URIs fail differently (that is, immediately, in the loadURI call)
  * if keyword searches are turned off. Test that this works, too.
@@ -37,15 +37,15 @@ add_task(async function() {
   await BrowserTestUtils.waitForCondition(() => browser.contentDocumentAsCPOW && !browser.contentDocumentAsCPOW.hidden);
   let errorPageLoaded = BrowserTestUtils.waitForErrorPage(tab.linkedBrowser);
   gURLBar.value = input;
   gURLBar.select();
   EventUtils.sendKey("return");
   await errorPageLoaded;
   is(gURLBar.textValue, input, "Text is still in URL bar");
   is(tab.linkedBrowser.userTypedValue, input, "Text still stored on browser");
-  await BrowserTestUtils.switchTab(gBrowser, tab.previousSibling);
+  await BrowserTestUtils.switchTab(gBrowser, tab.previousElementSibling);
   await BrowserTestUtils.switchTab(gBrowser, tab);
   is(gURLBar.textValue, input, "Text is still in URL bar after tab switch");
   is(tab.linkedBrowser.userTypedValue, input, "Text still stored on browser");
   BrowserTestUtils.removeTab(tab);
 });
 
diff --git a/browser/base/content/test/urlbar/browser_urlbarOneOffs.js b/browser/base/content/test/urlbar/browser_urlbarOneOffs.js
--- a/browser/base/content/test/urlbar/browser_urlbarOneOffs.js
+++ b/browser/base/content/test/urlbar/browser_urlbarOneOffs.js
@@ -158,17 +158,17 @@ add_task(async function() {
 // Checks that "Search with Current Search Engine" items are updated to "Search
 // with One-Off Engine" when a one-off is selected.
 add_task(async function searchWith() {
   let typedValue = "foo";
   await promiseAutocompleteResultPopup(typedValue);
   await waitForAutocompleteResultAt(0);
   assertState(0, -1, typedValue);
 
-  let item = gURLBar.popup.richlistbox.firstChild;
+  let item = gURLBar.popup.richlistbox.firstElementChild;
   Assert.equal(item._actionText.textContent,
                "Search with " + Services.search.currentEngine.name,
                "Sanity check: first result's action text");
 
   // Alt+Down to the first one-off.  Now the first result and the first one-off
   // should both be selected.
   EventUtils.synthesizeKey("KEY_ArrowDown", { altKey: true });
   assertState(0, 0, typedValue);
diff --git a/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js b/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js
--- a/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js
+++ b/browser/base/content/test/urlbar/browser_urlbar_search_speculative_connect_mousedown.js
@@ -56,18 +56,18 @@ add_task(async function popup_mousedown_
   // Check if the first result is with type "searchengine"
   let controller = gURLBar.popup.input.controller;
   // The first item should be 'Search with ...' thus we wan the second.
   let value = controller.getFinalCompleteValueAt(1);
   info(`The value of the second item is ${value}`);
   is(value, test.completeValue, "The second item has the url we visited.");
 
   await BrowserTestUtils.waitForCondition(() => {
-    return !!gURLBar.popup.richlistbox.childNodes[1] &&
-           BrowserTestUtils.is_visible(gURLBar.popup.richlistbox.childNodes[1]);
+    return !!gURLBar.popup.richlistbox.children[1] &&
+           BrowserTestUtils.is_visible(gURLBar.popup.richlistbox.children[1]);
   }, "the node is there.");
 
-  let listitem = gURLBar.popup.richlistbox.childNodes[1];
+  let listitem = gURLBar.popup.richlistbox.children[1];
   EventUtils.synthesizeMouse(listitem, 10, 10, {type: "mousedown"}, window);
   is(gURLBar.popup.richlistbox.selectedIndex, 1, "The second item is selected");
   await promiseSpeculativeConnection(gHttpServer);
   is(gHttpServer.connectionNumber, 1, `${gHttpServer.connectionNumber} speculative connection has been setup.`);
 });
diff --git a/browser/base/content/test/urlbar/head.js b/browser/base/content/test/urlbar/head.js
--- a/browser/base/content/test/urlbar/head.js
+++ b/browser/base/content/test/urlbar/head.js
@@ -273,17 +273,17 @@ function promisePageActionViewShown() {
   return BrowserTestUtils.waitForEvent(BrowserPageActions.panelNode, "ViewShown").then(async event => {
     let panelViewNode = event.originalTarget;
     await promisePageActionViewChildrenVisible(panelViewNode);
     return panelViewNode;
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
-  return promiseNodeVisible(panelViewNode.firstChild.firstChild);
+  return promiseNodeVisible(panelViewNode.firstElementChild.firstElementChild);
 }
 
 function promiseNodeVisible(node) {
   info(`promiseNodeVisible waiting, node.id=${node.id} node.localeName=${node.localName}\n`);
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
     let bounds = dwu.getBoundsWithoutFlushing(node);
     if (bounds.width > 0 && bounds.height > 0) {
diff --git a/browser/base/content/test/webextensions/head.js b/browser/base/content/test/webextensions/head.js
--- a/browser/base/content/test/webextensions/head.js
+++ b/browser/base/content/test/webextensions/head.js
@@ -26,17 +26,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 /**
  * Wait for a specific install event to fire for a given addon
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media.js b/browser/base/content/test/webrtc/browser_devices_get_user_media.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media.js
@@ -16,22 +16,22 @@ var gTests = [
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(true, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("camera-icon"), "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true, video: true});
@@ -46,22 +46,22 @@ var gTests = [
     await promiseRequestDevice(true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareMicrophone-notification-icon", "anchored to mic icon");
     checkDeviceSelectors(true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("microphone-icon"), "panel using microphone icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true});
@@ -76,22 +76,22 @@ var gTests = [
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("camera-icon"), "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
@@ -152,17 +152,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -198,17 +198,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -491,17 +491,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
@@ -544,17 +544,17 @@ var gTests = [
     // because the connection isn't secure.
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     // Ensure that checking the 'Remember this decision' checkbox disables
     // 'Allow'.
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let checkbox = notification.checkbox;
     ok(!!checkbox, "checkbox is present");
     ok(!checkbox.checked, "checkbox is not checked");
     checkbox.click();
     ok(checkbox.checked, "checkbox now checked");
     ok(notification.button.disabled, "Allow button is disabled");
     ok(!notification.hasAttribute("warninghidden"), "warning message is shown");
 
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_anim.js
@@ -9,17 +9,17 @@ var gTests = [
     async function getStreamAndCheckBackgroundAnim(aAudio, aVideo, aSharing) {
       // Get a stream
       let popupPromise = promisePopupNotificationShown("webRTC-shareDevices");
       await promiseRequestDevice(aAudio, aVideo);
       await popupPromise;
       await expectObserverCalled("getUserMedia:request");
 
       await promiseMessage("ok", () => {
-        PopupNotifications.panel.firstChild.button.click();
+        PopupNotifications.panel.firstElementChild.button.click();
       });
       await expectObserverCalled("getUserMedia:response:allow");
       await expectObserverCalled("recording-device-events");
       let expected = {};
       if (aVideo)
         expected.video = true;
       if (aAudio)
         expected.audio = true;
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_default_permissions.js
@@ -34,22 +34,22 @@ var gTests = [
     await promiseRequestDevice(true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareMicrophone-notification-icon", "anchored to mic icon");
     checkDeviceSelectors(true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("microphone-icon"), "panel using microphone icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true});
@@ -108,22 +108,22 @@ var gTests = [
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("camera-icon"), "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_in_frame.js
@@ -10,22 +10,22 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
     checkDeviceSelectors(true, true);
-    is(PopupNotifications.panel.firstChild.getAttribute("popupid"),
+    is(PopupNotifications.panel.firstElementChild.getAttribute("popupid"),
        "webRTC-shareDevices", "panel using devices icon");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true, video: true});
@@ -80,17 +80,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -138,17 +138,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -158,17 +158,17 @@ var gTests = [
     // doesn't override sharing UI.
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, "frame2");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await checkSharingUI({video: true, audio: true});
 
@@ -198,17 +198,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: false});
@@ -216,17 +216,17 @@ var gTests = [
 
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame2");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await checkSharingUI({video: true, audio: true});
     await expectNoObserverCalled();
@@ -252,17 +252,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_multi_process.js
@@ -17,17 +17,17 @@ var gTests = [
     await promiseRequestDevice(true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
 
     await indicator;
     await checkSharingUI({audio: true});
@@ -63,17 +63,17 @@ var gTests = [
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(false, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
 
     await checkSharingUI({video: true}, window, {audio: true, video: true});
 
     ok(webrtcUI.showGlobalIndicator, "webrtcUI wants the global indicator shown");
     ok(webrtcUI.showCameraIndicator, "webrtcUI wants the camera indicator shown");
@@ -122,17 +122,17 @@ var gTests = [
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(false, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
 
     await indicator;
     await checkSharingUI({video: true});
@@ -168,17 +168,17 @@ var gTests = [
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     checkDeviceSelectors(false, true);
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
 
     await checkSharingUI({video: true}, window, {video: true});
 
     ok(webrtcUI.showGlobalIndicator, "webrtcUI wants the global indicator shown");
     ok(webrtcUI.showCameraIndicator, "webrtcUI wants the camera indicator shown");
@@ -229,17 +229,17 @@ var gTests = [
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
 
     // Select the first screen so that we can have a stream.
     document.getElementById("webRTC-selectWindow-menulist").getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
@@ -281,17 +281,17 @@ var gTests = [
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
 
     // Select the first screen so that we can have a stream.
     document.getElementById("webRTC-selectWindow-menulist").getItemAtIndex(2).doCommand();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
 
     await checkSharingUI({screen: "Screen"}, window, {screen: "Screen"});
 
     ok(webrtcUI.showGlobalIndicator, "webrtcUI wants the global indicator shown");
     ok(webrtcUI.showScreenSharingIndicator, "webrtcUI wants the screen sharing indicator shown");
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_paused.js
@@ -56,17 +56,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
     await indicator;
     await checkSharingUI({
       video: STATE_CAPTURE_ENABLED,
@@ -132,17 +132,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
     await indicator;
     await checkSharingUI({
       video: STATE_CAPTURE_ENABLED,
@@ -217,27 +217,27 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     menulist.getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_queue_request.js
@@ -17,17 +17,17 @@ var gTests = [
     await promiseRequestDevice(true, false);
     await promise;
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     checkDeviceSelectors(false, true);
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await indicator;
     await checkSharingUI({audio: false, video: true});
@@ -67,17 +67,17 @@ var gTests = [
 
     await promise;
     checkDeviceSelectors(false, true);
     await expectObserverCalled("getUserMedia:request");
 
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await indicator;
     await checkSharingUI({audio: false, video: true});
@@ -98,28 +98,28 @@ var gTests = [
     await promise;
     promise = promisePopupNotificationShown("webRTC-shareDevices");
 
     checkDeviceSelectors(false, true);
 
     await expectObserverCalled("getUserMedia:request");
 
     await promiseMessage(badDeviceError, () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
 
     await promise;
     checkDeviceSelectors(true, false);
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
     await indicator;
     await checkSharingUI({audio: true, video: false});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_screen.js
@@ -25,17 +25,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Screen' item, a separator and at least one screen");
@@ -81,17 +81,17 @@ var gTests = [
     ok(document.getElementById("webRTC-preview").hidden,
        "the preview area is hidden");
 
     // Select the first screen again so that we can have a stream.
     menulist.getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
@@ -122,17 +122,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "window");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Window' item, a separator and at least one window");
@@ -195,17 +195,17 @@ var gTests = [
       info("no non-scary window available on this test slave");
 
       // Select the first window again so that we can have a stream.
       menulist.getItemAtIndex(scaryIndex).doCommand();
     }
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Window"},
                      "expected window to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Window"});
@@ -231,17 +231,17 @@ var gTests = [
       return;
     }
 
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(false, false, true);
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     let iconclass = notification.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Application' item, a separator and at least one application");
@@ -280,17 +280,17 @@ var gTests = [
     await TestUtils.waitForCondition(() => !document.getElementById("webRTC-preview").hidden);
     ok(!document.getElementById("webRTC-preview").hidden,
        "the preview area is visible");
     ok(document.getElementById("webRTC-previewWarning").hidden,
        "the scary warning is hidden");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Application"},
                      "expected application to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Application"});
@@ -310,17 +310,17 @@ var gTests = [
     await promiseRequestDevice(true, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareScreen-notification-icon", "anchored to device icon");
     checkDeviceSelectors(true, false, true);
     let iconclass =
-      PopupNotifications.panel.firstChild.getAttribute("iconclass");
+      PopupNotifications.panel.firstElementChild.getAttribute("iconclass");
     ok(iconclass.includes("screen-icon"), "panel using screen icon");
 
     let menulist =
       document.getElementById("webRTC-selectWindow-menulist");
     let count = menulist.itemCount;
     ok(count >= 3,
        "There should be the 'Select Screen' item, a separator and at least one screen");
 
@@ -331,17 +331,17 @@ var gTests = [
     await TestUtils.waitForCondition(() => !document.getElementById("webRTC-preview").hidden);
     ok(!document.getElementById("webRTC-preview").hidden,
        "the preview area is visible");
     ok(!document.getElementById("webRTC-previewWarning").hidden,
        "the scary warning is visible");
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()),
                      {audio: true, screen: "Screen"},
                      "expected screen and microphone to be shared");
 
     await indicator;
@@ -386,17 +386,17 @@ var gTests = [
       await promise;
       await expectObserverCalled("getUserMedia:request");
       checkDeviceSelectors(audio, video, screen);
       if (screen) {
         document.getElementById("webRTC-selectWindow-menulist")
                 .getItemAtIndex(2).doCommand();
       }
       await promiseMessage("ok", () => {
-        PopupNotifications.panel.firstChild.button.click();
+        PopupNotifications.panel.firstElementChild.button.click();
       });
       await expectObserverCalled("getUserMedia:response:allow");
       await expectObserverCalled("recording-device-events");
     }
 
     async function check(expected = {}) {
       let shared = Object.keys(expected).join(" and ");
       if (shared) {
@@ -448,17 +448,17 @@ var gTests = [
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, false, true);
     document.getElementById("webRTC-selectWindow-menulist")
             .getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
 
     await indicator;
     await checkSharingUI({screen: "Screen"});
@@ -475,17 +475,17 @@ var gTests = [
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, false, true);
     document.getElementById("webRTC-selectWindow-menulist")
             .getItemAtIndex(2).doCommand();
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {screen: "Screen"},
                      "expected screen to be shared");
     await indicator;
     await checkSharingUI({screen: "Screen"});
 
@@ -523,17 +523,17 @@ var gTests = [
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, false, true);
     document.getElementById("webRTC-selectWindow-menulist")
             .getItemAtIndex(2).doCommand();
 
     // Ensure that checking the 'Remember this decision' checkbox disables
     // 'Allow'.
-    let notification = PopupNotifications.panel.firstChild;
+    let notification = PopupNotifications.panel.firstElementChild;
     ok(notification.hasAttribute("warninghidden"), "warning message is hidden");
     let checkbox = notification.checkbox;
     ok(!!checkbox, "checkbox is present");
     ok(!checkbox.checked, "checkbox is not checked");
     checkbox.click();
     ok(checkbox.checked, "checkbox now checked");
     ok(notification.button.disabled, "Allow button is disabled");
     ok(!notification.hasAttribute("warninghidden"), "warning message is shown");
@@ -563,17 +563,17 @@ var gTests = [
 
     // Request devices and expect a prompt despite the saved 'Allow' permission.
     promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true, null, "screen");
     await promise;
     await expectObserverCalled("getUserMedia:request");
 
     // The 'remember' checkbox shouldn't be checked anymore.
-    notification = PopupNotifications.panel.firstChild;
+    notification = PopupNotifications.panel.firstElementChild;
     ok(notification.hasAttribute("warninghidden"), "warning message is hidden");
     checkbox = notification.checkbox;
     ok(!!checkbox, "checkbox is present");
     ok(!checkbox.checked, "checkbox is not checked");
 
     // Deny the request to cleanup...
     await promiseMessage(permissionError, () => {
       activateSecondaryAction(kActionDeny);
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_tear_off_tab.js
@@ -10,17 +10,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access.js
@@ -12,17 +12,17 @@ var gTests = [
   run: async function checkAudioVideoWhileLiveTracksExist_audio_camera() {
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
     await indicator;
     await checkSharingUI({audio: true, video: true});
@@ -87,17 +87,17 @@ var gTests = [
   run: async function checkAudioVideoWhileLiveTracksExist_camera() {
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await indicator;
     await checkSharingUI({audio: false, video: true});
@@ -178,17 +178,17 @@ var gTests = [
   run: async function checkAudioVideoWhileLiveTracksExist_audio() {
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, false);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true},
                      "expected microphone to be shared");
     await indicator;
     await checkSharingUI({audio: true, video: false});
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_in_frame.js
@@ -13,17 +13,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -67,17 +67,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -112,17 +112,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true, "frame1");
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
@@ -165,17 +165,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
     let indicator = promiseIndicatorWindow();
 
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
 
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_queue_request.js
@@ -9,17 +9,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(false, true);
     await promiseRequestDevice(false, true);
     await promise;
     checkDeviceSelectors(false, true);
     await expectObserverCalled("getUserMedia:request");
 
     let promiseOK = promiseSpecificMessageReceived("ok", 2);
-    PopupNotifications.panel.firstChild.button.click();
+    PopupNotifications.panel.firstElementChild.button.click();
     await promiseOK;
 
     await promiseNoPopupNotification("webRTC-shareDevices");
     await expectObserverCalled("getUserMedia:request");
     await expectObserverCalled("getUserMedia:response:allow", 2);
     Assert.deepEqual((await getMediaCaptureState()), {video: true},
                      "expected camera to be shared");
     await expectObserverCalled("recording-device-events", 2);
diff --git a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js
--- a/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js
+++ b/browser/base/content/test/webrtc/browser_devices_get_user_media_unprompted_access_tear_off_tab.js
@@ -10,17 +10,17 @@ var gTests = [
     let promise = promisePopupNotificationShown("webRTC-shareDevices");
     await promiseRequestDevice(true, true);
     await promise;
     await expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     let indicator = promiseIndicatorWindow();
     await promiseMessage("ok", () => {
-      PopupNotifications.panel.firstChild.button.click();
+      PopupNotifications.panel.firstElementChild.button.click();
     });
     await expectObserverCalled("getUserMedia:response:allow");
     await expectObserverCalled("recording-device-events");
     Assert.deepEqual((await getMediaCaptureState()), {audio: true, video: true},
                      "expected camera and microphone to be shared");
 
     await indicator;
     await checkSharingUI({video: true, audio: true});
diff --git a/browser/base/content/test/webrtc/head.js b/browser/base/content/test/webrtc/head.js
--- a/browser/base/content/test/webrtc/head.js
+++ b/browser/base/content/test/webrtc/head.js
@@ -295,17 +295,17 @@ function promiseMessage(aMessage, aActio
 }
 
 function promisePopupNotificationShown(aName, aAction) {
   return new Promise(resolve => {
 
     PopupNotifications.panel.addEventListener("popupshown", function() {
       ok(!!PopupNotifications.getNotification(aName), aName + " notification shown");
       ok(PopupNotifications.isPanelOpen, "notification panel open");
-      ok(!!PopupNotifications.panel.firstChild, "notification panel populated");
+      ok(!!PopupNotifications.panel.firstElementChild, "notification panel populated");
 
       executeSoon(resolve);
     }, {once: true});
 
     if (aAction)
       aAction();
 
   });
@@ -338,17 +338,17 @@ function promiseNoPopupNotification(aNam
   });
 }
 
 const kActionAlways = 1;
 const kActionDeny = 2;
 const kActionNever = 3;
 
 function activateSecondaryAction(aAction) {
-  let notification = PopupNotifications.panel.firstChild;
+  let notification = PopupNotifications.panel.firstElementChild;
   switch (aAction) {
     case kActionNever:
       notification.checkbox.setAttribute("checked", true); // fallthrough
     case kActionDeny:
       notification.secondaryButton.click();
       break;
     case kActionAlways:
       notification.checkbox.setAttribute("checked", true);
diff --git a/browser/base/content/utilityOverlay.js b/browser/base/content/utilityOverlay.js
--- a/browser/base/content/utilityOverlay.js
+++ b/browser/base/content/utilityOverlay.js
@@ -601,17 +601,17 @@ function checkForMiddleClick(node, event
 // by onpopupshowing passing the event as first argument.
 function createUserContextMenu(event, {
                                         isContextMenu = false,
                                         excludeUserContextId = 0,
                                         showDefaultTab = false,
                                         useAccessKeys = true
                                       } = {}) {
   while (event.target.hasChildNodes()) {
-    event.target.firstChild.remove();
+    event.target.firstElementChild.remove();
   }
 
   let bundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
   let docfrag = document.createDocumentFragment();
 
   // If we are excluding a userContextId, we want to add a 'no-container' item.
   if (excludeUserContextId || showDefaultTab) {
     let menuitem = document.createElement("menuitem");
@@ -720,17 +720,17 @@ function eventMatchesKey(aEvent, aKey) {
     return modifiers.every(modifier => keyModifiers.includes(modifier) == aEvent.getModifierState(modifier));
   }
   return true;
 }
 
 // Gather all descendent text under given document node.
 function gatherTextUnder(root) {
   var text = "";
-  var node = root.firstChild;
+  var node = root.firstElementChild;
   var depth = 1;
   while ( node && depth > 0 ) {
     // See if this node is text.
     if ( node.nodeType == Node.TEXT_NODE ) {
       // Add this text to our collection.
       text += " " + node.data;
     } else if ( node instanceof HTMLImageElement) {
       // If it has an "alt" attribute, add that.
@@ -738,26 +738,26 @@ function gatherTextUnder(root) {
       if ( altText && altText != "" ) {
         text += " " + altText;
       }
     }
     // Find next node to test.
     // First, see if this node has children.
     if ( node.hasChildNodes() ) {
       // Go to first child.
-      node = node.firstChild;
+      node = node.firstElementChild;
       depth++;
     } else {
       // No children, try next sibling (or parent next sibling).
-      while ( depth > 0 && !node.nextSibling ) {
+      while ( depth > 0 && !node.nextElementSibling ) {
         node = node.parentNode;
         depth--;
       }
-      if ( node.nextSibling ) {
-        node = node.nextSibling;
+      if ( node.nextElementSibling ) {
+        node = node.nextElementSibling;
       }
     }
   }
   // Strip leading and tailing whitespace.
   text = text.trim();
   // Compress remaining whitespace.
   text = text.replace( /\s+/g, " " );
   return text;
diff --git a/browser/base/content/webrtcIndicator.js b/browser/base/content/webrtcIndicator.js
--- a/browser/base/content/webrtcIndicator.js
+++ b/browser/base/content/webrtcIndicator.js
@@ -108,18 +108,18 @@ function onPopupMenuShowing(event) {
     item.setAttribute("tooltiptext", stream.uri);
     item.stream = stream;
     popup.appendChild(item);
   }
 }
 
 function onPopupMenuHiding(event) {
   let popup = event.target;
-  while (popup.firstChild)
-    popup.firstChild.remove();
+  while (popup.firstElementChild)
+    popup.firstElementChild.remove();
 }
 
 function onPopupMenuCommand(event) {
   webrtcUI.showSharingDoorhanger(event.target.stream);
 }
 
 function onFirefoxButtonClick(event) {
   event.target.blur();
diff --git a/browser/components/contextualidentity/test/browser/browser_windowName.js b/browser/components/contextualidentity/test/browser/browser_windowName.js
--- a/browser/components/contextualidentity/test/browser/browser_windowName.js
+++ b/browser/components/contextualidentity/test/browser/browser_windowName.js
@@ -47,18 +47,18 @@ add_task(async function test() {
 
   is(browser1.contentTitle, "?old", "Tab1 title must be 'old'");
   is(browser1.contentPrincipal.userContextId, 1, "Tab1 UCI must be 1");
 
   is(browser2.contentTitle, "?old", "Tab2 title must be 'old'");
   is(browser2.contentPrincipal.userContextId, 2, "Tab2 UCI must be 2");
 
   let found = false;
-  for (let i = 0; i < gBrowser.tabContainer.childNodes.length; ++i) {
-    let tab = gBrowser.tabContainer.childNodes[i];
+  for (let i = 0; i < gBrowser.tabContainer.children.length; ++i) {
+    let tab = gBrowser.tabContainer.children[i];
     let browser = gBrowser.getBrowserForTab(tab);
     if (browser.contentTitle == "?new") {
       is(browser.contentPrincipal.userContextId, 1, "Tab3 UCI must be 1");
       isnot(browser, browser1, "Tab3 is not browser 1");
       isnot(browser, browser2, "Tab3 is not browser 2");
       gBrowser.removeTab(tab);
       found = true;
       break;
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -786,30 +786,30 @@ var CustomizableUIInternal = {
     // through a migration path (bug 938980) or an add-on.
     if (aArea == CustomizableUI.AREA_NAVBAR) {
       aAreaNode.collapsed = false;
     }
 
     this.beginBatchUpdate();
 
     try {
-      let currentNode = container.firstChild;
+      let currentNode = container.firstElementChild;
       let placementsToRemove = new Set();
       for (let id of aPlacements) {
         while (currentNode && currentNode.getAttribute("skipintoolbarset") == "true") {
-          currentNode = currentNode.nextSibling;
+          currentNode = currentNode.nextElementSibling;
         }
 
         // Fix ids for specials and continue, for correctly placed specials.
         if (currentNode && (!currentNode.id || CustomizableUI.isSpecialWidget(currentNode)) &&
             this.matchingSpecials(id, currentNode)) {
           currentNode.id = id;
         }
         if (currentNode && currentNode.id == id) {
-          currentNode = currentNode.nextSibling;
+          currentNode = currentNode.nextElementSibling;
           continue;
         }
 
         if (this.isSpecialWidget(id) && areaIsPanel) {
           placementsToRemove.add(id);
           continue;
         }
 
@@ -849,20 +849,20 @@ var CustomizableUIInternal = {
           this.notifyListeners("onWidgetReset", node, container);
         } else if (gUndoResetting) {
           this.notifyListeners("onWidgetUndoMove", node, container);
         }
       }
 
       if (currentNode) {
         let palette = aAreaNode.toolbox ? aAreaNode.toolbox.palette : null;
-        let limit = currentNode.previousSibling;
-        let node = container.lastChild;
+        let limit = currentNode.previousElementSibling;
+        let node = container.lastElementChild;
         while (node && node != limit) {
-          let previousSibling = node.previousSibling;
+          let previousSibling = node.previousElementSibling;
           // Nodes opt-in to removability. If they're removable, and we haven't
           // seen them in the placements array, then we toss them into the palette
           // if one exists. If no palette exists, we just remove the node. If the
           // node is not removable, we leave it where it is. However, we can only
           // safely touch elements that have an ID - both because we depend on
           // IDs (or are specials), and because such elements are not intended to
           // be widgets (eg, titlebar-placeholder elements).
           if ((node.id || this.isSpecialWidget(node)) &&
@@ -3898,17 +3898,17 @@ var CustomizableUI = {
     for (let menuChild of aMenuItems) {
       if (menuChild.hidden)
         continue;
 
       let subviewItem;
       if (menuChild.localName == "menuseparator") {
         // Don't insert duplicate or leading separators. This can happen if there are
         // menus (which we don't copy) above the separator.
-        if (!fragment.lastChild || fragment.lastChild.localName == "menuseparator") {
+        if (!fragment.lastElementChild || fragment.lastElementChild.localName == "menuseparator") {
           continue;
         }
         subviewItem = doc.createElementNS(kNSXUL, "menuseparator");
       } else if (menuChild.localName == "menuitem") {
         subviewItem = doc.createElementNS(kNSXUL, "toolbarbutton");
         CustomizableUI.addShortcut(menuChild, subviewItem);
 
         let item = menuChild;
@@ -3951,18 +3951,18 @@ var CustomizableUI = {
    * @param aSubview the subview to clear.
    */
   clearSubview(aSubview) {
     let parent = aSubview.parentNode;
     // We'll take the container out of the document before cleaning it out
     // to avoid reflowing each time we remove something.
     parent.removeChild(aSubview);
 
-    while (aSubview.firstChild) {
-      aSubview.firstChild.remove();
+    while (aSubview.firstElementChild) {
+      aSubview.firstElementChild.remove();
     }
 
     parent.appendChild(aSubview);
   },
 };
 Object.freeze(this.CustomizableUI);
 Object.freeze(this.CustomizableUI.windows);
 
@@ -4435,39 +4435,39 @@ OverflowableToolbar.prototype = {
    *        in some cases (e.g. when we run this method after overflow handling
    *        is re-enabled from customize mode, to ensure correct handling of
    *        initial overflow).
    */
   async onOverflow(aEvent) {
     if (!this._enabled)
       return;
 
-    let child = this._target.lastChild;
+    let child = this._target.lastElementChild;
 
     let thisOverflowResponse = ++this._lastOverflowCounter;
 
     let win = this._target.ownerGlobal;
     let [scrollLeftMin, scrollLeftMax] = await win.promiseDocumentFlushed(() => {
       return [this._target.scrollLeftMin, this._target.scrollLeftMax];
     });
     if (win.closed || this._lastOverflowCounter != thisOverflowResponse) {
       return;
     }
 
     while (child && scrollLeftMin != scrollLeftMax) {
-      let prevChild = child.previousSibling;
+      let prevChild = child.previousElementSibling;
 
       if (child.getAttribute("overflows") != "false") {
         this._collapsed.set(child.id, this._target.clientWidth);
         child.setAttribute("overflowedItem", true);
         child.setAttribute("cui-anchorid", this._chevron.id);
         CustomizableUIInternal.ensureButtonContextMenu(child, this._toolbar, true);
         CustomizableUIInternal.notifyListeners("onWidgetOverflow", child, this._target);
 
-        this._list.insertBefore(child, this._list.firstChild);
+        this._list.insertBefore(child, this._list.firstElementChild);
         if (!this._addedListener) {
           CustomizableUI.addListener(this);
         }
         if (!CustomizableUI.isSpecialWidget(child.id)) {
           this._toolbar.setAttribute("overflowing", "true");
         }
       }
       child = prevChild;
@@ -4508,18 +4508,18 @@ OverflowableToolbar.prototype = {
    *        While there are items in the list, this width won't change, and so
    *        we can avoid flushing layout by providing it and/or caching it.
    *        Note that if `shouldMoveAllItems` is true, we never need the width
    *        anyway.
    */
   _moveItemsBackToTheirOrigin(shouldMoveAllItems, targetWidth) {
     let placements = gPlacements.get(this._toolbar.id);
     let win = this._target.ownerGlobal;
-    while (this._list.firstChild) {
-      let child = this._list.firstChild;
+    while (this._list.firstElementChild) {
+      let child = this._list.firstElementChild;
       let minSize = this._collapsed.get(child.id);
 
       if (!shouldMoveAllItems && minSize) {
         if (!targetWidth) {
           let dwu = win.windowUtils;
           targetWidth = Math.floor(dwu.getBoundsWithoutFlushing(this._target).width);
         }
         if (targetWidth <= minSize) {
@@ -4603,26 +4603,26 @@ OverflowableToolbar.prototype = {
     if (aContainer != this._target && aContainer != this._list) {
       return;
     }
     // When we (re)move an item, update all the items that come after it in the list
     // with the minsize *of the item before the to-be-removed node*. This way, we
     // ensure that we try to move items back as soon as that's possible.
     if (aNode.parentNode == this._list) {
       let updatedMinSize;
-      if (aNode.previousSibling) {
-        updatedMinSize = this._collapsed.get(aNode.previousSibling.id);
+      if (aNode.previousElementSibling) {
+        updatedMinSize = this._collapsed.get(aNode.previousElementSibling.id);
       } else {
         // Force (these) items to try to flow back into the bar:
         updatedMinSize = 1;
       }
-      let nextItem = aNode.nextSibling;
+      let nextItem = aNode.nextElementSibling;
       while (nextItem) {
         this._collapsed.set(nextItem.id, updatedMinSize);
-        nextItem = nextItem.nextSibling;
+        nextItem = nextItem.nextElementSibling;
       }
     }
   },
 
   onWidgetAfterDOMChange(aNode, aNextNode, aContainer) {
     if (aContainer != this._target && aContainer != this._list) {
       return;
     }
@@ -4632,17 +4632,17 @@ OverflowableToolbar.prototype = {
     let wasOverflowed = this._collapsed.has(aNode.id);
 
     // If this wasn't overflowed before...
     if (!wasOverflowed) {
       // ... but it is now, then we added to the overflow panel. Exciting stuff:
       if (nowOverflowed) {
         // NB: we're guaranteed that it has a previousSibling, because if it didn't,
         // we would have added it to the toolbar instead. See getOverflowedNextNode.
-        let prevId = aNode.previousSibling.id;
+        let prevId = aNode.previousElementSibling.id;
         let minSize = this._collapsed.get(prevId);
         this._collapsed.set(aNode.id, minSize);
         aNode.setAttribute("cui-anchorid", this._chevron.id);
         aNode.setAttribute("overflowedItem", true);
         CustomizableUIInternal.ensureButtonContextMenu(aNode, aContainer, true);
         CustomizableUIInternal.notifyListeners("onWidgetOverflow", aNode, this._target);
       } else if (!nowInBar) {
         // If it is not overflowed and not in the toolbar, and was not overflowed
@@ -4664,19 +4664,19 @@ OverflowableToolbar.prototype = {
       let collapsedWidgetIds = Array.from(this._collapsed.keys());
       if (collapsedWidgetIds.every(w => CustomizableUI.isSpecialWidget(w))) {
         this._toolbar.removeAttribute("overflowing");
       }
       if (this._addedListener && !this._collapsed.size) {
         CustomizableUI.removeListener(this);
         this._addedListener = false;
       }
-    } else if (aNode.previousSibling) {
+    } else if (aNode.previousElementSibling) {
       // but if it still is, it must have changed places. Bookkeep:
-      let prevId = aNode.previousSibling.id;
+      let prevId = aNode.previousElementSibling.id;
       let minSize = this._collapsed.get(prevId);
       this._collapsed.set(aNode.id, minSize);
     } else {
       // If it's now the first item in the overflow list,
       // maybe we can return it:
       this._moveItemsBackToTheirOrigin(false);
     }
   },
@@ -4740,17 +4740,17 @@ OverflowableToolbar.prototype = {
   _hideTimeoutId: null,
   _showWithTimeout() {
     this.show().then(() => {
       let window = this._toolbar.ownerGlobal;
       if (this._hideTimeoutId) {
         window.clearTimeout(this._hideTimeoutId);
       }
       this._hideTimeoutId = window.setTimeout(() => {
-        if (!this._panel.firstChild.matches(":hover")) {
+        if (!this._panel.firstElementChild.matches(":hover")) {
           PanelMultiView.hidePopup(this._panel);
         }
       }, OVERFLOW_PANEL_HIDE_DELAY_MS);
     });
   },
 };
 
 CustomizableUIInternal.initialize();
diff --git a/browser/components/customizableui/CustomizableWidgets.jsm b/browser/components/customizableui/CustomizableWidgets.jsm
--- a/browser/components/customizableui/CustomizableWidgets.jsm
+++ b/browser/components/customizableui/CustomizableWidgets.jsm
@@ -142,17 +142,17 @@ const CustomizableWidgets = [
       if (!elementCount)
         return;
 
       let body = document.createElement("vbox");
       body.className = "panel-subview-body";
       body.appendChild(fragment);
       let footer;
       while (--elementCount >= 0) {
-        let element = body.childNodes[elementCount];
+        let element = body.children[elementCount];
         CustomizableUI.addShortcut(element);
         element.classList.add("subviewbutton");
         if (element.classList.contains("restoreallitem")) {
           footer = element;
           element.classList.add("panel-subview-footer");
         } else {
           element.classList.add("subviewbutton-iconic", "bookmark-item");
         }
@@ -396,29 +396,29 @@ const CustomizableWidgets = [
       }
     },
     updateCurrentCharset(aDocument) {
       let currentCharset = aDocument.defaultView.gBrowser.selectedBrowser.characterSet;
       currentCharset = CharsetMenu.foldCharset(currentCharset);
 
       let pinnedContainer = aDocument.getElementById("PanelUI-characterEncodingView-pinned");
       let charsetContainer = aDocument.getElementById("PanelUI-characterEncodingView-charsets");
-      let elements = [...(pinnedContainer.childNodes), ...(charsetContainer.childNodes)];
+      let elements = [...(pinnedContainer.children), ...(charsetContainer.children)];
 
       this._updateElements(elements, currentCharset);
     },
     updateCurrentDetector(aDocument) {
       let detectorContainer = aDocument.getElementById("PanelUI-characterEncodingView-autodetect");
       let currentDetector;
       try {
         currentDetector = Services.prefs.getComplexValue(
           "intl.charset.detector", Ci.nsIPrefLocalizedString).data;
       } catch (e) {}
 
-      this._updateElements(detectorContainer.childNodes, currentDetector);
+      this._updateElements(detectorContainer.children, currentDetector);
     },
     _updateElements(aElements, aCurrentItem) {
       if (!aElements.length) {
         return;
       }
       let disabled = this.maybeDisableMenu(aElements[0].ownerDocument);
       for (let elem of aElements) {
         if (disabled) {
@@ -638,17 +638,17 @@ if (Services.prefs.getBoolPref("identity
 
         this.setDeckIndex(this.deckIndices.DECKINDEX_TABS);
         this._clearTabList();
         SyncedTabs.sortTabClientsByLastUsed(clients);
         let fragment = doc.createDocumentFragment();
 
         for (let client of clients) {
           // add a menu separator for all clients other than the first.
-          if (fragment.lastChild) {
+          if (fragment.lastElementChild) {
             let separator = doc.createElementNS(kNSXUL, "menuseparator");
             fragment.appendChild(separator);
           }
           if (paginationInfo && paginationInfo.clientId == client.id) {
             this._appendClient(client, fragment, paginationInfo.maxTabs);
           } else {
             this._appendClient(client, fragment);
           }
@@ -660,18 +660,18 @@ if (Services.prefs.getBoolPref("identity
         Cu.reportError(err);
       }).then(() => {
         // an observer for tests.
         Services.obs.notifyObservers(null, "synced-tabs-menu:test:tabs-updated");
       });
     },
     _clearTabList() {
       let list = this._tabsList;
-      while (list.lastChild) {
-        list.lastChild.remove();
+      while (list.lastElementChild) {
+        list.lastElementChild.remove();
       }
     },
     _showNoClientMessage() {
       this._appendMessageLabel("notabslabel");
     },
     _appendMessageLabel(messageAttr, appendTo = null) {
       if (!appendTo) {
         appendTo = this._tabsList;
diff --git a/browser/components/customizableui/CustomizeMode.jsm b/browser/components/customizableui/CustomizeMode.jsm
--- a/browser/components/customizableui/CustomizeMode.jsm
+++ b/browser/components/customizableui/CustomizeMode.jsm
@@ -436,17 +436,17 @@ CustomizeMode.prototype = {
       // And drop all area references.
       this.areas.clear();
 
       // Let everybody in this window know that we're starting to
       // exit customization mode.
       CustomizableUI.dispatchToolboxEvent("customizationending", {}, window);
 
       window.PanelUI.menuButton.disabled = false;
-      let overflowContainer = document.getElementById("widget-overflow-mainView").firstChild;
+      let overflowContainer = document.getElementById("widget-overflow-mainView").firstElementChild;
       overflowContainer.appendChild(window.PanelUI.overflowFixedList);
       document.getElementById("nav-bar-overflow-button").disabled = false;
       let panelContextMenu = document.getElementById(kPanelItemContextMenu);
       this._previousPanelContextMenuParent.appendChild(panelContextMenu);
 
       // We need to set this._customizing to false before removing the tab
       // or the TabSelect event handler will think that we are exiting
       // customization mode for a second time.
@@ -579,18 +579,18 @@ CustomizeMode.prototype = {
           animationNode.addEventListener("animationend", cleanupWidgetAnimationEnd);
         });
       });
     });
   },
 
   async addToToolbar(aNode) {
     aNode = this._getCustomizableChildForNode(aNode);
-    if (aNode.localName == "toolbarpaletteitem" && aNode.firstChild) {
-      aNode = aNode.firstChild;
+    if (aNode.localName == "toolbarpaletteitem" && aNode.firstElementChild) {
+      aNode = aNode.firstElementChild;
     }
     let widgetAnimationPromise = this._promiseWidgetAnimationOut(aNode);
     if (widgetAnimationPromise) {
       await widgetAnimationPromise;
     }
 
     let widgetToAdd = aNode.id;
     if (CustomizableUI.isSpecialWidget(widgetToAdd) && aNode.closest("#customization-palette")) {
@@ -616,18 +616,18 @@ CustomizeMode.prototype = {
       } else {
         aNode.classList.remove("animate-out");
       }
     }
   },
 
   async addToPanel(aNode) {
     aNode = this._getCustomizableChildForNode(aNode);
-    if (aNode.localName == "toolbarpaletteitem" && aNode.firstChild) {
-      aNode = aNode.firstChild;
+    if (aNode.localName == "toolbarpaletteitem" && aNode.firstElementChild) {
+      aNode = aNode.firstElementChild;
     }
     let widgetAnimationPromise = this._promiseWidgetAnimationOut(aNode);
     if (widgetAnimationPromise) {
       await widgetAnimationPromise;
     }
 
     let panel = CustomizableUI.AREA_FIXED_OVERFLOW_PANEL;
     CustomizableUI.addWidgetToArea(aNode.id, panel);
@@ -664,18 +664,18 @@ CustomizeMode.prototype = {
           }
         });
       });
     }
   },
 
   async removeFromArea(aNode) {
     aNode = this._getCustomizableChildForNode(aNode);
-    if (aNode.localName == "toolbarpaletteitem" && aNode.firstChild) {
-      aNode = aNode.firstChild;
+    if (aNode.localName == "toolbarpaletteitem" && aNode.firstElementChild) {
+      aNode = aNode.firstElementChild;
     }
     let widgetAnimationPromise = this._promiseWidgetAnimationOut(aNode);
     if (widgetAnimationPromise) {
       await widgetAnimationPromise;
     }
 
     CustomizableUI.removeWidgetFromArea(aNode.id);
     if (!this._customizing) {
@@ -741,21 +741,21 @@ CustomizeMode.prototype = {
     let wrapper = this.createOrUpdateWrapper(widgetNode, aPlace);
     wrapper.appendChild(widgetNode);
     return wrapper;
   },
 
   depopulatePalette() {
     return (async () => {
       this.visiblePalette.hidden = true;
-      let paletteChild = this.visiblePalette.firstChild;
+      let paletteChild = this.visiblePalette.firstElementChild;
       let nextChild;
       while (paletteChild) {
         nextChild = paletteChild.nextElementSibling;
-        let itemId = paletteChild.firstChild.id;
+        let itemId = paletteChild.firstElementChild.id;
         if (CustomizableUI.isSpecialWidget(itemId)) {
           this.visiblePalette.removeChild(paletteChild);
         } else {
           // XXXunf Currently this doesn't destroy the (now unused) node in the
           //       API provider case. It would be good to do so, but we need to
           //       keep strong refs to it in CustomizableUI (can't iterate of
           //       WeakMaps), and there's the question of what behavior
           //       wrappers should have if consumers keep hold of them.
@@ -920,17 +920,17 @@ CustomizeMode.prototype = {
     if (aWrapper.nodeName != "toolbarpaletteitem") {
       return aWrapper;
     }
     aWrapper.removeEventListener("mousedown", this);
     aWrapper.removeEventListener("mouseup", this);
 
     let place = aWrapper.getAttribute("place");
 
-    let toolbarItem = aWrapper.firstChild;
+    let toolbarItem = aWrapper.firstElementChild;
     if (!toolbarItem) {
       log.error("no toolbarItem child for " + aWrapper.tagName + "#" + aWrapper.id);
       aWrapper.remove();
       return null;
     }
 
     if (aWrapper.hasAttribute("itemobserves")) {
       toolbarItem.setAttribute("observes", aWrapper.getAttribute("itemobserves"));
@@ -1454,27 +1454,27 @@ CustomizeMode.prototype = {
         LightweightThemeManager.setLocalTheme(button.theme);
         recommendedThemes = recommendedThemes.filter((aTheme) => { return aTheme.id != button.theme.id; });
         lwthemePrefs.setStringPref("recommendedThemes",
                                    JSON.stringify(recommendedThemes));
         onThemeSelected(panel);
       });
       panel.insertBefore(button, footer);
     }
-    let hideRecommendedLabel = (footer.previousSibling == recommendedLabel);
+    let hideRecommendedLabel = (footer.previousElementSibling == recommendedLabel);
     recommendedLabel.hidden = hideRecommendedLabel;
   },
 
   _clearLWThemesMenu(panel) {
     let footer = this.$("customization-lwtheme-menu-footer");
     let recommendedLabel = this.$("customization-lwtheme-menu-recommended");
     for (let element of [footer, recommendedLabel]) {
-      while (element.previousSibling &&
-             element.previousSibling.localName == "toolbarbutton") {
-        element.previousSibling.remove();
+      while (element.previousElementSibling &&
+             element.previousElementSibling.localName == "toolbarbutton") {
+        element.previousElementSibling.remove();
       }
     }
 
     // Workaround for bug 1059934
     panel.removeAttribute("height");
   },
 
   _onUIChange() {
@@ -1662,17 +1662,17 @@ CustomizeMode.prototype = {
     while (item && item.localName != "toolbarpaletteitem") {
       if (item.localName == "toolbar" || item.id == kPaletteId ||
           item.id == "customization-panelHolder") {
         return;
       }
       item = item.parentNode;
     }
 
-    let draggedItem = item.firstChild;
+    let draggedItem = item.firstElementChild;
     let placeForItem = CustomizableUI.getPlaceForItem(item);
 
     let dt = aEvent.dataTransfer;
     let documentId = aEvent.target.ownerDocument.documentElement.id;
 
     dt.mozSetDataAt(kDragDataTypePrefix + documentId, draggedItem.id, 0);
     dt.effectAllowed = "move";
 
@@ -1695,22 +1695,22 @@ CustomizeMode.prototype = {
     this._initializeDragAfterMove = () => {
       // For automated tests, we sometimes start exiting customization mode
       // before this fires, which leaves us with placeholders inserted after
       // we've exited. So we need to check that we are indeed customizing.
       if (this._customizing && !this._transitioning) {
         item.hidden = true;
         DragPositionManager.start(this.window);
         let canUsePrevSibling = placeForItem == "toolbar" || placeForItem == "menu-panel";
-        if (item.nextSibling) {
-          this._setDragActive(item.nextSibling, "before", draggedItem.id, placeForItem);
-          this._dragOverItem = item.nextSibling;
-        } else if (canUsePrevSibling && item.previousSibling) {
-          this._setDragActive(item.previousSibling, "after", draggedItem.id, placeForItem);
-          this._dragOverItem = item.previousSibling;
+        if (item.nextElementSibling) {
+          this._setDragActive(item.nextElementSibling, "before", draggedItem.id, placeForItem);
+          this._dragOverItem = item.nextElementSibling;
+        } else if (canUsePrevSibling && item.previousElementSibling) {
+          this._setDragActive(item.previousElementSibling, "after", draggedItem.id, placeForItem);
+          this._dragOverItem = item.previousElementSibling;
         }
         let currentArea = this._getCustomizableParent(item);
         currentArea.setAttribute("draggingover", "true");
       }
       this._initializeDragAfterMove = null;
       this.window.clearTimeout(this._dragInitializeTimeout);
     };
     this._dragInitializeTimeout = this.window.setTimeout(this._initializeDragAfterMove, 0);
@@ -1760,27 +1760,27 @@ CustomizeMode.prototype = {
 
     // We need to determine the place that the widget is being dropped in
     // the target.
     let dragOverItem, dragValue;
     if (targetNode == targetArea.customizationTarget) {
       // We'll assume if the user is dragging directly over the target, that
       // they're attempting to append a child to that target.
       dragOverItem = (targetAreaType == "toolbar"
-                        ? this._findVisiblePreviousSiblingNode(targetNode.lastChild)
-                        : targetNode.lastChild) ||
+                        ? this._findVisiblePreviousSiblingNode(targetNode.lastElementChild)
+                        : targetNode.lastElementChild) ||
                      targetNode;
       dragValue = "after";
     } else {
       let targetParent = targetNode.parentNode;
       let position = Array.indexOf(targetParent.children, targetNode);
       if (position == -1) {
         dragOverItem = (targetAreaType == "toolbar"
-                          ? this._findVisiblePreviousSiblingNode(targetNode.lastChild)
-                          : targetNode.lastChild);
+                          ? this._findVisiblePreviousSiblingNode(targetNode.lastElementChild)
+                          : targetNode.lastElementChild);
         dragValue = "after";
       } else {
         dragOverItem = targetParent.children[position];
         if (targetAreaType == "toolbar") {
           // Check if the aDraggedItem is hovered past the first half of dragOverItem
           let itemRect = this._getBoundsWithoutFlushing(dragOverItem);
           let dropTargetCenter = itemRect.left + (itemRect.width / 2);
           let existingDir = dragOverItem.getAttribute("dragover");
@@ -1846,24 +1846,24 @@ CustomizeMode.prototype = {
     // Do nothing if the target area or origin area are not customizable.
     if (!targetArea || !originArea) {
       return;
     }
     let targetNode = this._dragOverItem;
     let dropDir = targetNode.getAttribute("dragover");
     // Need to insert *after* this node if we promised the user that:
     if (targetNode != targetArea && dropDir == "after") {
-      if (targetNode.nextSibling) {
-        targetNode = targetNode.nextSibling;
+      if (targetNode.nextElementSibling) {
+        targetNode = targetNode.nextElementSibling;
       } else {
         targetNode = targetArea;
       }
     }
     if (targetNode.tagName == "toolbarpaletteitem") {
-      targetNode = targetNode.firstChild;
+      targetNode = targetNode.firstElementChild;
     }
 
     this._cancelDragActive(this._dragOverItem, null, true);
 
     try {
       this._applyDrop(aEvent, targetArea, originArea, draggedItemId, targetNode);
     } catch (ex) {
       log.error(ex, ex.stack);
@@ -1954,24 +1954,24 @@ CustomizeMode.prototype = {
     // We need to determine the place that the widget is being dropped in
     // the target.
     let placement;
     let itemForPlacement = aTargetNode;
     // Skip the skipintoolbarset items when determining the place of the item:
     while (itemForPlacement && itemForPlacement.getAttribute("skipintoolbarset") == "true" &&
            itemForPlacement.parentNode &&
            itemForPlacement.parentNode.nodeName == "toolbarpaletteitem") {
-      itemForPlacement = itemForPlacement.parentNode.nextSibling;
+      itemForPlacement = itemForPlacement.parentNode.nextElementSibling;
       if (itemForPlacement && itemForPlacement.nodeName == "toolbarpaletteitem") {
-        itemForPlacement = itemForPlacement.firstChild;
+        itemForPlacement = itemForPlacement.firstElementChild;
       }
     }
     if (itemForPlacement) {
       let targetNodeId = (itemForPlacement.nodeName == "toolbarpaletteitem") ?
-                            itemForPlacement.firstChild && itemForPlacement.firstChild.id :
+                            itemForPlacement.firstElementChild && itemForPlacement.firstElementChild.id :
                             itemForPlacement.id;
       placement = CustomizableUI.getPlacementOfWidget(targetNodeId);
     }
     if (!placement) {
       log.debug("Could not get a position for " + aTargetNode.nodeName + "#" + aTargetNode.id + "." + aTargetNode.className);
     }
     let position = placement ? placement.position : null;
 
@@ -2188,17 +2188,17 @@ CustomizeMode.prototype = {
     let currentArea = this._getCustomizableParent(aDraggedItem);
     // Return the size for this target from cache, if it exists.
     let size = itemMap.get(targetArea);
     if (size)
       return size;
 
     // Calculate size of the item when it'd be dropped in this position.
     let currentParent = aDraggedItem.parentNode;
-    let currentSibling = aDraggedItem.nextSibling;
+    let currentSibling = aDraggedItem.nextElementSibling;
     const kAreaType = "cui-areatype";
     let areaType, currentType;
 
     if (targetArea != currentArea) {
       // Move the widget temporarily next to the placeholder.
       aDragOverNode.parentNode.insertBefore(aDraggedItem, aDragOverNode);
       // Update the node's areaType.
       areaType = CustomizableUI.getAreaType(targetArea.id);
@@ -2317,18 +2317,18 @@ CustomizeMode.prototype = {
       aElement = aElement.parentNode;
     }
     return aElement;
   },
 
   _findVisiblePreviousSiblingNode(aReferenceNode) {
     while (aReferenceNode &&
            aReferenceNode.localName == "toolbarpaletteitem" &&
-           aReferenceNode.firstChild.hidden) {
-      aReferenceNode = aReferenceNode.previousSibling;
+           aReferenceNode.firstElementChild.hidden) {
+      aReferenceNode = aReferenceNode.previousElementSibling;
     }
     return aReferenceNode;
   },
 
   onPaletteContextMenuShowing(event) {
    let isFlexibleSpace = event.target.triggerNode.id.includes("wrapper-customizableui-special-spring");
    event.target.querySelector(".customize-context-addToPanel").disabled = isFlexibleSpace;
  },
@@ -2596,18 +2596,18 @@ CustomizeMode.prototype = {
 
     function uninit() {
       document.removeEventListener("keydown", onkeydown);
       document.removeEventListener("keyup", onkeyup);
       if (rAFHandle) {
         window.cancelAnimationFrame(rAFHandle);
       }
       let arena = elements.arena;
-      while (arena.firstChild) {
-        arena.firstChild.remove();
+      while (arena.firstElementChild) {
+        arena.firstElementChild.remove();
       }
       arena.removeAttribute("score");
       arena.removeAttribute("lives");
       arena.removeAttribute("kcode");
       arena.style.removeProperty("background-image");
       arena.style.removeProperty("background-position");
       arena.style.removeProperty("background-repeat");
       arena.style.removeProperty("background-size");
diff --git a/browser/components/customizableui/DragPositionManager.jsm b/browser/components/customizableui/DragPositionManager.jsm
--- a/browser/components/customizableui/DragPositionManager.jsm
+++ b/browser/components/customizableui/DragPositionManager.jsm
@@ -86,17 +86,17 @@ AreaPositionManager.prototype = {
       let targetBounds = this._lazyStoreGet(closest);
       let farSide = this._dir == "ltr" ? "right" : "left";
       let outsideX = targetBounds[farSide];
       // Check if we're closer to the next target than to this one:
       // Only move if we're not targeting a node in a different row:
       if (aY > targetBounds.top && aY < targetBounds.bottom) {
         if ((this._dir == "ltr" && aX > outsideX) ||
             (this._dir == "rtl" && aX < outsideX)) {
-          return closest.nextSibling || aContainer;
+          return closest.nextElementSibling || aContainer;
         }
       }
     }
     return closest;
   },
 
   /**
    * "Insert" a "placeholder" by shifting the subsequent children out of the
@@ -123,20 +123,20 @@ AreaPositionManager.prototype = {
         }
         // Determine the CSS transform based on the next node:
         child.style.transform = this._diffWithNext(child, aSize);
       } else {
         // If we're not shifting this node, reset the transform
         child.style.transform = "";
       }
     }
-    if (aContainer.lastChild && aIsFromThisArea &&
+    if (aContainer.lastElementChild && aIsFromThisArea &&
         !this._lastPlaceholderInsertion) {
       // Flush layout:
-      aContainer.lastChild.getBoundingClientRect();
+      aContainer.lastElementChild.getBoundingClientRect();
       // then remove all the [notransition]
       for (let child of aContainer.children) {
         child.removeAttribute("notransition");
       }
     }
     this._lastPlaceholderInsertion = aBefore;
   },
 
diff --git a/browser/components/customizableui/PanelMultiView.jsm b/browser/components/customizableui/PanelMultiView.jsm
--- a/browser/components/customizableui/PanelMultiView.jsm
+++ b/browser/components/customizableui/PanelMultiView.jsm
@@ -567,19 +567,19 @@ var PanelMultiView = class extends Assoc
    * sure they will not be removed together with the <panelmultiview> element.
    */
   _moveOutKids() {
     let viewCacheId = this.node.getAttribute("viewCacheId");
     if (!viewCacheId) {
       return;
     }
 
-    // Node.children and Node.childNodes is live to DOM changes like the
+    // Node.children and Node.children is live to DOM changes like the
     // ones we're about to do, so iterate over a static copy:
-    let subviews = Array.from(this._viewStack.childNodes);
+    let subviews = Array.from(this._viewStack.children);
     let viewCache = this.document.getElementById(viewCacheId);
     for (let subview of subviews) {
       viewCache.appendChild(subview);
     }
   }
 
   /**
    * Slides in the specified view as a subview.
@@ -870,17 +870,17 @@ var PanelMultiView = class extends Assoc
       // getter also provides an indication that the view node shouldn't be
       // moved around, otherwise the state of the browser would get disrupted.
       let width = prevPanelView.knownWidth;
       let height = prevPanelView.knownHeight;
       viewRect = Object.assign({height, width}, viewNode.customRectGetter());
       nextPanelView.visible = true;
       // Until the header is visible, it has 0 height.
       // Wait for layout before measuring it
-      let header = viewNode.firstChild;
+      let header = viewNode.firstElementChild;
       if (header && header.classList.contains("panel-header")) {
         viewRect.height += await window.promiseDocumentFlushed(() => {
           return this._dwu.getBoundsWithoutFlushing(header).height;
         });
       }
       await nextPanelView.descriptionHeightWorkaround();
     } else {
       this._offscreenViewStack.style.minHeight = olderView.knownHeight + "px";
@@ -1198,17 +1198,17 @@ var PanelView = class extends Associated
     }
   }
 
   /**
    * Adds a header with the given title, or removes it if the title is empty.
    */
   set headerText(value) {
     // If the header already exists, update or remove it as requested.
-    let header = this.node.firstChild;
+    let header = this.node.firstElementChild;
     if (header && header.classList.contains("panel-header")) {
       if (value) {
         header.querySelector("label").setAttribute("value", value);
       } else {
         header.remove();
       }
       return;
     }
diff --git a/browser/components/customizableui/content/panelUI.js b/browser/components/customizableui/content/panelUI.js
--- a/browser/components/customizableui/content/panelUI.js
+++ b/browser/components/customizableui/content/panelUI.js
@@ -94,17 +94,17 @@ const PanelUI = {
     for (let event of this.kEvents) {
       this.notificationPanel.addEventListener(event, this);
     }
 
     // We do this sync on init because in order to have the overflow button show up
     // we need to know whether anything is in the permanent panel area.
     this.overflowFixedList.hidden = false;
     // Also unhide the separator. We use CSS to hide/show it based on the panel's content.
-    this.overflowFixedList.previousSibling.hidden = false;
+    this.overflowFixedList.previousElementSibling.hidden = false;
     CustomizableUI.registerMenuPanel(this.overflowFixedList, CustomizableUI.AREA_FIXED_OVERFLOW_PANEL);
     this.updateOverflowStatus();
 
     Services.obs.notifyObservers(null, "appMenu-notifications-request", "refresh");
 
     this._initialized = true;
   },
 
@@ -503,18 +503,18 @@ const PanelUI = {
     // panel is shown, so their space is reserved. The part of this function
     // that adds the elements is the least expensive anyways.
     this.clearLibraryRecentHighlights();
     if (!highlights.length) {
       return;
     }
 
     let container = this.libraryRecentHighlights;
-    container.hidden = container.previousSibling.hidden =
-      container.previousSibling.previousSibling.hidden = false;
+    container.hidden = container.previousElementSibling.hidden =
+      container.previousElementSibling.previousElementSibling.hidden = false;
     let fragment = document.createDocumentFragment();
     for (let highlight of highlights) {
       let button = document.createElement("toolbarbutton");
       button.classList.add("subviewbutton", "highlight", "subviewbutton-iconic", "bookmark-item");
       let title = highlight.title || highlight.url;
       button.setAttribute("label", title);
       button.setAttribute("tooltiptext", title);
       button.setAttribute("type", "highlight-" + highlight.type);
@@ -539,21 +539,21 @@ const PanelUI = {
     }
   },
 
   /**
    * Remove all the nodes from the 'Recent Highlights' section and hide it as well.
    */
   clearLibraryRecentHighlights() {
     let container = this.libraryRecentHighlights;
-    while (container.firstChild) {
-      container.firstChild.remove();
+    while (container.firstElementChild) {
+      container.firstElementChild.remove();
     }
-    container.hidden = container.previousSibling.hidden =
-      container.previousSibling.previousSibling.hidden = true;
+    container.hidden = container.previousElementSibling.hidden =
+      container.previousElementSibling.previousElementSibling.hidden = true;
   },
 
   /**
    * Event handler; invoked when an item of the Recent Highlights is clicked.
    *
    * @param {MouseEvent} event Click event, originating from the Highlight.
    */
   onLibraryHighlightClick(event) {
@@ -621,18 +621,18 @@ const PanelUI = {
     buildHelpMenu();
 
     let helpMenu = document.getElementById("menu_HelpPopup");
     let items = this.getElementsByTagName("vbox")[0];
     let attrs = ["oncommand", "onclick", "label", "key", "disabled"];
     let NSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     // Remove all buttons from the view
-    while (items.firstChild) {
-      items.firstChild.remove();
+    while (items.firstElementChild) {
+      items.firstElementChild.remove();
     }
 
     // Add the current set of menuitems of the Help menu to this view
     let menuItems = Array.prototype.slice.call(helpMenu.getElementsByTagName("menuitem"));
     let fragment = document.createDocumentFragment();
     for (let node of menuItems) {
       if (node.hidden)
         continue;
diff --git a/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js b/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js
--- a/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js
+++ b/browser/components/customizableui/test/browser_1007336_lwthemes_in_customize_mode.js
@@ -31,42 +31,42 @@ add_task(async function() {
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a second time");
   await popupShownPromise;
 
   let header = document.getElementById("customization-lwtheme-menu-header");
   let recommendedHeader = document.getElementById("customization-lwtheme-menu-recommended");
 
-  is(header.nextSibling.nextSibling.nextSibling.nextSibling, recommendedHeader,
+  is(header.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling, recommendedHeader,
      "There should only be three themes (default, light, dark) in the 'My Themes' section by default");
-  is(header.nextSibling.theme.id, DEFAULT_THEME_ID,
+  is(header.nextElementSibling.theme.id, DEFAULT_THEME_ID,
      "The first theme should be the default theme");
-  is(header.nextSibling.nextSibling.theme.id, LIGHT_THEME_ID,
+  is(header.nextElementSibling.nextElementSibling.theme.id, LIGHT_THEME_ID,
      "The second theme should be the light theme");
-  is(header.nextSibling.nextSibling.nextSibling.theme.id, DARK_THEME_ID,
+  is(header.nextElementSibling.nextElementSibling.nextElementSibling.theme.id, DARK_THEME_ID,
      "The third theme should be the dark theme");
 
   let themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
-  header.nextSibling.nextSibling.doCommand(); // Select light theme
+  header.nextElementSibling.nextElementSibling.doCommand(); // Select light theme
   info("Clicked on light theme");
   await themeChangedPromise;
 
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a third time");
   await popupShownPromise;
 
   let activeThemes = popup.querySelectorAll("toolbarbutton.customization-lwtheme-menu-theme[active]");
   is(activeThemes.length, 1, "Exactly 1 theme should be selected");
   if (activeThemes.length > 0) {
     is(activeThemes[0].theme.id, LIGHT_THEME_ID, "Light theme should be selected");
   }
 
-  let firstLWTheme = recommendedHeader.nextSibling;
+  let firstLWTheme = recommendedHeader.nextElementSibling;
   let firstLWThemeId = firstLWTheme.theme.id;
   themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
   firstLWTheme.doCommand();
   info("Clicked on first theme");
   await themeChangedPromise;
 
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
@@ -74,43 +74,43 @@ add_task(async function() {
   await popupShownPromise;
 
   activeThemes = popup.querySelectorAll("toolbarbutton.customization-lwtheme-menu-theme[active]");
   is(activeThemes.length, 1, "Exactly 1 theme should be selected");
   if (activeThemes.length > 0) {
     is(activeThemes[0].theme.id, firstLWThemeId, "First theme should be selected");
   }
 
-  is(header.nextSibling.theme.id, DEFAULT_THEME_ID, "The first theme should be the Default theme");
-  let installedThemeId = header.nextSibling.nextSibling.nextSibling.nextSibling.theme.id;
+  is(header.nextElementSibling.theme.id, DEFAULT_THEME_ID, "The first theme should be the Default theme");
+  let installedThemeId = header.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.theme.id;
   ok(installedThemeId.startsWith(firstLWThemeId),
      "The second theme in the 'My Themes' section should be the newly installed theme: " +
      "Installed theme id: " + installedThemeId + "; First theme ID: " + firstLWThemeId);
   let themeCount = 0;
   let iterNode = header;
-  while (iterNode.nextSibling && iterNode.nextSibling.theme) {
+  while (iterNode.nextElementSibling && iterNode.nextElementSibling.theme) {
     themeCount++;
-    iterNode = iterNode.nextSibling;
+    iterNode = iterNode.nextElementSibling;
   }
   is(themeCount, 4,
      "There should be four themes in the 'My Themes' section");
 
-  let defaultTheme = header.nextSibling;
+  let defaultTheme = header.nextElementSibling;
   defaultTheme.doCommand();
   await new Promise(SimpleTest.executeSoon);
   is(Services.prefs.getCharPref("lightweightThemes.selectedThemeID"),
      DEFAULT_THEME_ID, "Default theme should be selected");
 
   // ensure current theme isn't set to "Default"
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a fourth time");
   await popupShownPromise;
 
-  firstLWTheme = recommendedHeader.nextSibling;
+  firstLWTheme = recommendedHeader.nextElementSibling;
   themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
   firstLWTheme.doCommand();
   info("Clicked on first theme again");
   await themeChangedPromise;
 
   // check that "Restore Defaults" button resets theme
   await gCustomizeMode.reset();
   is(LightweightThemeManager.currentTheme.id, DEFAULT_THEME_ID, "Current theme reset to default");
@@ -121,33 +121,33 @@ add_task(async function() {
   info("Removed all recommended themes");
   await startCustomizing();
   popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button a fifth time");
   await popupShownPromise;
   header = document.getElementById("customization-lwtheme-menu-header");
   is(header.hidden, false, "Header should never be hidden");
-  let themeNode = header.nextSibling;
+  let themeNode = header.nextElementSibling;
   is(themeNode.theme.id, DEFAULT_THEME_ID, "The first theme should be the Default theme");
   is(themeNode.hidden, false, "The default theme should never be hidden");
 
-  themeNode = themeNode.nextSibling;
+  themeNode = themeNode.nextElementSibling;
   is(themeNode.theme.id, LIGHT_THEME_ID, "The second theme should be the Light theme");
   is(themeNode.hidden, false, "The light theme should never be hidden");
 
-  themeNode = themeNode.nextSibling;
+  themeNode = themeNode.nextElementSibling;
   is(themeNode.theme.id, DARK_THEME_ID, "The third theme should be the Dark theme");
   is(themeNode.hidden, false, "The dark theme should never be hidden");
 
   recommendedHeader = document.getElementById("customization-lwtheme-menu-recommended");
-  is(themeNode.nextSibling, recommendedHeader,
+  is(themeNode.nextElementSibling, recommendedHeader,
      "There should only be three themes (default, light, dark) in the 'My Themes' section now");
   let footer = document.getElementById("customization-lwtheme-menu-footer");
-  is(recommendedHeader.nextSibling.id, footer.id, "There should be no recommended themes in the menu");
+  is(recommendedHeader.nextElementSibling.id, footer.id, "There should be no recommended themes in the menu");
   is(recommendedHeader.hidden, true, "The recommendedHeader should be hidden since there are no recommended themes");
 });
 
 add_task(async function asyncCleanup() {
   await endCustomizing();
 
   Services.prefs.clearUserPref("lightweightThemes.usedThemes");
   Services.prefs.clearUserPref("lightweightThemes.recommendedThemes");
diff --git a/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js b/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js
--- a/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js
+++ b/browser/components/customizableui/test/browser_876926_customize_mode_wrapping.js
@@ -63,27 +63,27 @@ var move = {
       return CustomizableUI.removeWidgetFromArea(id);
     }
     return CustomizableUI.addWidgetToArea(id, target, null);
   }
 };
 
 function isLast(containerId, defaultPlacements, id) {
   assertAreaPlacements(containerId, defaultPlacements.concat([id]));
-  is(document.getElementById(containerId).customizationTarget.lastChild.firstChild.id, id,
+  is(document.getElementById(containerId).customizationTarget.lastElementChild.firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in customizing window.");
-  is(otherWin.document.getElementById(containerId).customizationTarget.lastChild.id, id,
+  is(otherWin.document.getElementById(containerId).customizationTarget.lastElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in other window.");
 }
 
 function getLastVisibleNodeInToolbar(containerId, win = window) {
   let container = win.document.getElementById(containerId).customizationTarget;
-  let rv = container.lastChild;
-  while (rv && (rv.getAttribute("hidden") == "true" || (rv.firstChild && rv.firstChild.getAttribute("hidden") == "true"))) {
-    rv = rv.previousSibling;
+  let rv = container.lastElementChild;
+  while (rv && (rv.getAttribute("hidden") == "true" || (rv.firstElementChild && rv.firstElementChild.getAttribute("hidden") == "true"))) {
+    rv = rv.previousElementSibling;
   }
   return rv;
 }
 
 function isLastVisibleInToolbar(containerId, defaultPlacements, id) {
   let newPlacements;
   for (let i = defaultPlacements.length - 1; i >= 0; i--) {
     let el = document.getElementById(defaultPlacements[i]);
@@ -93,27 +93,27 @@ function isLastVisibleInToolbar(containe
       break;
     }
   }
   if (!newPlacements) {
     assertAreaPlacements(containerId, defaultPlacements.concat([id]));
   } else {
     assertAreaPlacements(containerId, newPlacements);
   }
-  is(getLastVisibleNodeInToolbar(containerId).firstChild.id, id,
+  is(getLastVisibleNodeInToolbar(containerId).firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in customizing window.");
   is(getLastVisibleNodeInToolbar(containerId, otherWin).id, id,
      "Widget " + id + " should be in " + containerId + " in other window.");
 }
 
 function isFirst(containerId, defaultPlacements, id) {
   assertAreaPlacements(containerId, [id].concat(defaultPlacements));
-  is(document.getElementById(containerId).customizationTarget.firstChild.firstChild.id, id,
+  is(document.getElementById(containerId).customizationTarget.firstElementChild.firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in customizing window.");
-  is(otherWin.document.getElementById(containerId).customizationTarget.firstChild.id, id,
+  is(otherWin.document.getElementById(containerId).customizationTarget.firstElementChild.id, id,
      "Widget " + id + " should be in " + containerId + " in other window.");
 }
 
 async function checkToolbar(id, method) {
   // Place at start of the toolbar:
   let toolbarPlacements = getAreaWidgetIds(kToolbar);
   await move[method](id, kToolbar);
   if (method == "dragToItem") {
@@ -138,17 +138,17 @@ async function checkPanel(id, method) {
   // penultimate item. We can't well use the first item because the panel has complicated
   // rules about rearranging wide items (which, by default, the first two items are).
   if (method == "dragToItem") {
     newPlacements.pop();
     newPlacements.splice(panelPlacements.length - 1, 0, id);
     position = -2;
   }
   assertAreaPlacements(kPanel, newPlacements);
-  is(children[children.length + position].firstChild.id, id,
+  is(children[children.length + position].firstElementChild.id, id,
      "Widget " + id + " should be in " + kPanel + " in customizing window.");
   is(otherChildren[otherChildren.length + position].id, id,
      "Widget " + id + " should be in " + kPanel + " in other window.");
   checkWrapper(id);
 }
 
 async function checkPalette(id, method) {
   // Move back to palette:
@@ -156,17 +156,17 @@ async function checkPalette(id, method) 
   ok(CustomizableUI.inDefaultState, "Should end in default state");
   let visibleChildren = gCustomizeMode.visiblePalette.children;
   let expectedChild = method == "dragToItem" ? visibleChildren[0] : visibleChildren[visibleChildren.length - 1];
   // Items dragged to the end of the palette should be the final item. That they're the penultimate
   // item when dragged is tracked in bug 1395950. Once that's fixed, this hack can be removed.
   if (method == "drag") {
     expectedChild = expectedChild.previousElementSibling;
   }
-  is(expectedChild.firstChild.id, id, "Widget " + id + " was moved using " + method + " and should now be wrapped in palette in customizing window.");
+  is(expectedChild.firstElementChild.id, id, "Widget " + id + " was moved using " + method + " and should now be wrapped in palette in customizing window.");
   if (id == kXULWidgetId) {
     ok(otherWin.gNavToolbox.palette.querySelector("#" + id), "Widget " + id + " should be in invisible palette in other window.");
   }
   checkWrapper(id);
 }
 
 // This test needs a XUL button that's in the palette by default. No such
 // button currently exists, so we create a simple one.
diff --git a/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js b/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js
--- a/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js
+++ b/browser/components/customizableui/test/browser_876944_customize_mode_create_destroy.js
@@ -9,17 +9,17 @@ const kTestWidget1 = "test-customize-mod
 // Creating and destroying a widget should correctly wrap/unwrap stuff
 add_task(async function testWrapUnwrap() {
   await startCustomizing();
   CustomizableUI.createWidget({id: kTestWidget1, label: "Pretty label", tooltiptext: "Pretty tooltip"});
   let elem = document.getElementById(kTestWidget1);
   let wrapper = document.getElementById("wrapper-" + kTestWidget1);
   ok(elem, "There should be an item");
   ok(wrapper, "There should be a wrapper");
-  is(wrapper.firstChild.id, kTestWidget1, "Wrapper should have test widget");
+  is(wrapper.firstElementChild.id, kTestWidget1, "Wrapper should have test widget");
   is(wrapper.parentNode.id, "customization-palette", "Wrapper should be in palette");
   CustomizableUI.destroyWidget(kTestWidget1);
   wrapper = document.getElementById("wrapper-" + kTestWidget1);
   ok(!wrapper, "There should be a wrapper");
   let item = document.getElementById(kTestWidget1);
   ok(!item, "There should no longer be an item");
 });
 
diff --git a/browser/components/customizableui/test/browser_887438_currentset_shim.js b/browser/components/customizableui/test/browser_887438_currentset_shim.js
--- a/browser/components/customizableui/test/browser_887438_currentset_shim.js
+++ b/browser/components/customizableui/test/browser_887438_currentset_shim.js
@@ -6,22 +6,22 @@
 
 var navbar = document.getElementById("nav-bar");
 var navbarCT = navbar.customizationTarget;
 var overflowPanelList = document.getElementById("widget-overflow-list");
 
 // Reading currentset
 add_task(function() {
   let nodeIds = [];
-  for (let node of navbarCT.childNodes) {
+  for (let node of navbarCT.children) {
     if (node.getAttribute("skipintoolbarset") != "true") {
       nodeIds.push(node.id);
     }
   }
-  for (let node of overflowPanelList.childNodes) {
+  for (let node of overflowPanelList.children) {
     if (node.getAttribute("skipintoolbarset") != "true") {
       nodeIds.push(node.id);
     }
   }
   let currentSet = navbar.currentSet;
   is(currentSet.split(",").length, nodeIds.length, "Should be just as many nodes as there are.");
   is(currentSet, nodeIds.join(","), "Current set and node IDs should match.");
 });
diff --git a/browser/components/customizableui/test/browser_913972_currentset_overflow.js b/browser/components/customizableui/test/browser_913972_currentset_overflow.js
--- a/browser/components/customizableui/test/browser_913972_currentset_overflow.js
+++ b/browser/components/customizableui/test/browser_913972_currentset_overflow.js
@@ -23,17 +23,17 @@ add_task(async function() {
   await waitForCondition(() => !navbar.hasAttribute("overflowing"));
   ok(!navbar.hasAttribute("overflowing"), "Should no longer have an overflowing toolbar.");
   is(navbar.currentSet, oldCurrentSet, "Currentset should still be the same now we're no longer overflowing.");
   ok(CustomizableUI.inDefaultState, "Should still be in default state now we're no longer overflowing.");
 
   // Verify actual physical placements match those of the placement array:
   let placementCounter = 0;
   let placements = CustomizableUI.getWidgetIdsInArea(CustomizableUI.AREA_NAVBAR);
-  for (let node of navbar.customizationTarget.childNodes) {
+  for (let node of navbar.customizationTarget.children) {
     if (node.getAttribute("skipintoolbarset") == "true") {
       continue;
     }
     is(placements[placementCounter++], node.id, "Nodes should match after overflow");
   }
   is(placements.length, placementCounter, "Should have as many nodes as expected");
   is(navbar.customizationTarget.childElementCount, oldChildCount, "Number of nodes should match");
 });
diff --git a/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js b/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js
--- a/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js
+++ b/browser/components/customizableui/test/browser_914138_widget_API_overflowable_toolbar.js
@@ -32,17 +32,17 @@ add_task(async function() {
   ok(sidebarBtnNode && sidebarBtnNode.getAttribute("overflowedItem") == "true", "Sidebar button should have overflowedItem attribute");
 
   let placementOfSidebarButton = CustomizableUI.getWidgetIdsInArea(navbar.id).indexOf(kSidebarBtn);
   CustomizableUI.addWidgetToArea(kTestBtn1, navbar.id, placementOfSidebarButton);
   ok(!navbar.querySelector("#" + kTestBtn1), "New button should not be in the navbar");
   let newButtonNode = overflowList.querySelector("#" + kTestBtn1);
   ok(newButtonNode, "New button should be overflowing");
   ok(newButtonNode && newButtonNode.getAttribute("overflowedItem") == "true", "New button should have overflowedItem attribute");
-  let nextEl = newButtonNode && newButtonNode.nextSibling;
+  let nextEl = newButtonNode && newButtonNode.nextElementSibling;
   is(nextEl && nextEl.id, kSidebarBtn, "Test button should be next to sidebar button.");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
   await waitForCondition(() => !navbar.hasAttribute("overflowing"));
   ok(!navbar.hasAttribute("overflowing"), "Should not have an overflowing toolbar.");
   ok(navbar.querySelector("#" + kSidebarBtn), "Sidebar button should be in the navbar");
   ok(sidebarBtnNode && (sidebarBtnNode.getAttribute("overflowedItem") != "true"), "Sidebar button should no longer have overflowedItem attribute");
   ok(!overflowList.querySelector("#" + kSidebarBtn), "Sidebar button should no longer be overflowing");
diff --git a/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js b/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js
--- a/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js
+++ b/browser/components/customizableui/test/browser_918049_skipintoolbarset_dnd.js
@@ -18,21 +18,21 @@ add_task(async function() {
   navbar.customizationTarget.appendChild(skippedItem);
   let libraryButton = document.getElementById("library-button");
   await startCustomizing();
   await waitForElementShown(skippedItem);
   ok(CustomizableUI.inDefaultState, "Should still be in default state");
   simulateItemDrag(skippedItem, libraryButton, "start");
   ok(CustomizableUI.inDefaultState, "Should still be in default state");
   let skippedItemWrapper = skippedItem.parentNode;
-  is(skippedItemWrapper.nextSibling && skippedItemWrapper.nextSibling.id,
+  is(skippedItemWrapper.nextElementSibling && skippedItemWrapper.nextElementSibling.id,
      libraryButton.parentNode.id, "Should be next to library button");
   simulateItemDrag(libraryButton, skippedItem, "start");
   let libraryWrapper = libraryButton.parentNode;
-  is(libraryWrapper.nextSibling && libraryWrapper.nextSibling.id,
+  is(libraryWrapper.nextElementSibling && libraryWrapper.nextElementSibling.id,
      skippedItem.parentNode.id, "Should be next to skipintoolbarset item");
   ok(CustomizableUI.inDefaultState, "Should still be in default state");
 });
 
 add_task(async function asyncCleanup() {
   await endCustomizing();
   skippedItem.remove();
   await resetCustomization();
diff --git a/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js b/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js
--- a/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js
+++ b/browser/components/customizableui/test/browser_942581_unregisterArea_keeps_placements.js
@@ -81,17 +81,17 @@ add_task(async function() {
     } else {
       CustomizableUI.destroyWidget(widget);
     }
   }
 });
 
 function checkAbstractAndRealPlacements(aNode, aExpectedPlacements) {
   assertAreaPlacements(kToolbarName, aExpectedPlacements);
-  let physicalWidgetIds = Array.from(aNode.childNodes, (node) => node.id);
+  let physicalWidgetIds = Array.from(aNode.children, (node) => node.id);
   placementArraysEqual(aNode.id, physicalWidgetIds, aExpectedPlacements);
 }
 
 function checkWidgetFates(aWidgetIds) {
   for (let widget of aWidgetIds) {
     ok(!CustomizableUI.getPlacementOfWidget(widget), "Widget should be in palette");
     ok(!document.getElementById(widget), "Widget should not be in the DOM");
     let widgetInPalette = !!gNavToolbox.palette.querySelector("#" + widget);
diff --git a/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js b/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js
--- a/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js
+++ b/browser/components/customizableui/test/browser_968565_insert_before_hidden_items.js
@@ -44,13 +44,13 @@ add_task(async function() {
   // Drag an item and drop it onto the nav-bar customization target, but
   // not over a particular item.
   await startCustomizing();
   let homeButton = document.getElementById("home-button");
   simulateItemDrag(homeButton, navbar.customizationTarget, "end");
 
   await endCustomizing();
 
-  is(homeButton.previousSibling.id, lastVisible.id,
+  is(homeButton.previousElementSibling.id, lastVisible.id,
      "The downloads button should be placed after the last visible item.");
 
   await resetCustomization();
 });
diff --git a/browser/components/customizableui/test/browser_970511_undo_restore_default.js b/browser/components/customizableui/test/browser_970511_undo_restore_default.js
--- a/browser/components/customizableui/test/browser_970511_undo_restore_default.js
+++ b/browser/components/customizableui/test/browser_970511_undo_restore_default.js
@@ -19,17 +19,17 @@ add_task(async function() {
   let themesButton = document.getElementById("customization-lwtheme-button");
   let popup = document.getElementById("customization-lwtheme-menu");
   let popupShownPromise = popupShown(popup);
   EventUtils.synthesizeMouseAtCenter(themesButton, {});
   info("Clicked on themes button");
   await popupShownPromise;
 
   let recommendedHeader = document.getElementById("customization-lwtheme-menu-recommended");
-  let firstLWTheme = recommendedHeader.nextSibling;
+  let firstLWTheme = recommendedHeader.nextElementSibling;
   let firstLWThemeId = firstLWTheme.theme.id;
   let themeChangedPromise = promiseObserverNotified("lightweight-theme-changed");
   firstLWTheme.doCommand();
   info("Clicked on first theme");
   await themeChangedPromise;
 
   is(LightweightThemeManager.currentTheme.id, firstLWThemeId, "Theme changed to first option");
 
diff --git a/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js b/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js
--- a/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js
+++ b/browser/components/customizableui/test/browser_976792_insertNodeInWindow.js
@@ -29,17 +29,17 @@ add_task(async function() {
   assertAreaPlacements(kToolbarName, widgetIds);
 
   let btnId = kTestWidgetPrefix + 1;
   let btn = createDummyXULButton(btnId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(btnId, window);
 
   is(btn.parentNode.id, kToolbarName, "New XUL widget should be placed inside new toolbar");
 
-  is(btn.previousSibling.id, toolbarNode.firstChild.id,
+  is(btn.previousElementSibling.id, toolbarNode.firstElementChild.id,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   btn.remove();
   removeCustomToolbars();
   await resetCustomization();
 });
 
@@ -73,19 +73,19 @@ add_task(async function() {
   let testWidgetId = kTestWidgetPrefix + 3;
 
   CustomizableUI.destroyWidget(testWidgetId);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 2,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 2,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 4,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 4,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -123,19 +123,19 @@ add_task(async function() {
 
   CustomizableUI.destroyWidget(kTestWidgetPrefix + 2);
   CustomizableUI.destroyWidget(testWidgetId);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 1,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 1,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 4,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 4,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -174,19 +174,19 @@ add_task(async function() {
   CustomizableUI.destroyWidget(kTestWidgetPrefix + 2);
   CustomizableUI.destroyWidget(testWidgetId);
   CustomizableUI.destroyWidget(kTestWidgetPrefix + 4);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 1,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 1,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling, null,
+  is(btn.nextElementSibling, null,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -227,32 +227,32 @@ add_task(async function() {
   let originalWindowWidth = window.outerWidth;
   window.resizeTo(kForceOverflowWidthPx, window.outerHeight);
   // Wait for all the widgets to overflow. We can't just wait for the
   // `overflowing` attribute because we leave time for layout flushes
   // inbetween, so it's possible for the timeout to run before the
   // navbar has "settled"
   await waitForCondition(() => {
     return navbar.hasAttribute("overflowing") &&
-      navbar.customizationTarget.lastChild.getAttribute("overflows") == "false";
+      navbar.customizationTarget.lastElementChild.getAttribute("overflows") == "false";
   });
 
   // Find last widget that doesn't allow overflowing
-  let nonOverflowing = navbar.customizationTarget.lastChild;
+  let nonOverflowing = navbar.customizationTarget.lastElementChild;
   is(nonOverflowing.getAttribute("overflows"), "false", "Last child is expected to not allow overflowing");
   isnot(nonOverflowing.getAttribute("skipintoolbarset"), "true", "Last child is expected to not be skipintoolbarset");
 
   let testWidgetId = kTestWidgetPrefix + 10;
   CustomizableUI.destroyWidget(testWidgetId);
 
   let btn = createDummyXULButton(testWidgetId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(testWidgetId, window);
 
   is(btn.parentNode.id, navbar.overflowable._list.id, "New XUL widget should be placed inside overflow of toolbar");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 11,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 11,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
 
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   CustomizableUI.removeWidgetFromArea(btn.id, kToolbarName);
   btn.remove();
   await resetCustomization();
@@ -297,19 +297,19 @@ add_task(async function() {
   await waitForCondition(() => toolbarNode.hasAttribute("overflowing") && !toolbarNode.querySelector("#" + widgetIds[1]));
   ok(toolbarNode.hasAttribute("overflowing"), "Should have an overflowing toolbar.");
 
   let btnId = kTestWidgetPrefix + missingId;
   let btn = createDummyXULButton(btnId, "test");
   CustomizableUI.ensureWidgetPlacedInWindow(btnId, window);
 
   is(btn.parentNode.id, kToolbarName + "-overflow-list", "New XUL widget should be placed inside new toolbar's overflow");
-  is(btn.previousSibling.id, kTestWidgetPrefix + 1,
+  is(btn.previousElementSibling.id, kTestWidgetPrefix + 1,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
-  is(btn.nextSibling.id, kTestWidgetPrefix + 4,
+  is(btn.nextElementSibling.id, kTestWidgetPrefix + 4,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
   await waitForCondition(() => !toolbarNode.hasAttribute("overflowing"));
 
   btn.remove();
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   removeCustomToolbars();
@@ -398,17 +398,17 @@ add_task(async function() {
   ok(toolbarNode.hasAttribute("overflowing"), "Should have an overflowing toolbar.");
 
   let btnId = kTestWidgetPrefix + missingId;
   let btn = createDummyXULButton(btnId, "test");
   btn.setAttribute("overflows", false);
   CustomizableUI.ensureWidgetPlacedInWindow(btnId, window);
 
   is(btn.parentNode.id, kToolbarName + "-target", "New XUL widget should be placed inside new toolbar");
-  is(btn.nextSibling, null,
+  is(btn.nextElementSibling, null,
      "insertNodeInWindow should have placed new XUL widget in correct place in DOM according to placements");
 
   window.resizeTo(originalWindowWidth, window.outerHeight);
   await waitForCondition(() => !toolbarNode.hasAttribute("overflowing"));
 
   btn.remove();
   widgetIds.forEach(id => CustomizableUI.destroyWidget(id));
   removeCustomToolbars();
diff --git a/browser/components/customizableui/test/browser_981305_separator_insertion.js b/browser/components/customizableui/test/browser_981305_separator_insertion.js
--- a/browser/components/customizableui/test/browser_981305_separator_insertion.js
+++ b/browser/components/customizableui/test/browser_981305_separator_insertion.js
@@ -3,17 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 var tempElements = [];
 
 function insertTempItemsIntoMenu(parentMenu) {
   // Last element is null to insert at the end:
-  let beforeEls = [parentMenu.firstChild, parentMenu.lastChild, null];
+  let beforeEls = [parentMenu.firstElementChild, parentMenu.lastElementChild, null];
   for (let i = 0; i < beforeEls.length; i++) {
     let sep = document.createElement("menuseparator");
     tempElements.push(sep);
     parentMenu.insertBefore(sep, beforeEls[i]);
     let menu = document.createElement("menu");
     tempElements.push(menu);
     parentMenu.insertBefore(menu, beforeEls[i]);
     // And another separator for good measure:
@@ -35,23 +35,23 @@ function checkSeparatorInsertion(menuId,
 
     await document.getElementById("nav-bar").overflowable.show();
 
     let subview = document.getElementById(subviewId);
     let button = document.getElementById(buttonId);
     button.click();
     await BrowserTestUtils.waitForEvent(subview, "ViewShown");
 
-    let subviewBody = subview.firstChild;
-    ok(subviewBody.firstChild, "Subview should have a kid");
-    is(subviewBody.firstChild.localName, "toolbarbutton", "There should be no separators to start with");
+    let subviewBody = subview.firstElementChild;
+    ok(subviewBody.firstElementChild, "Subview should have a kid");
+    is(subviewBody.firstElementChild.localName, "toolbarbutton", "There should be no separators to start with");
 
     for (let kid of subviewBody.children) {
       if (kid.localName == "menuseparator") {
-        ok(kid.previousSibling && kid.previousSibling.localName != "menuseparator",
+        ok(kid.previousElementSibling && kid.previousElementSibling.localName != "menuseparator",
            "Separators should never have another separator next to them, and should never be the first node.");
       }
     }
 
     let panelHiddenPromise = promiseOverflowHidden(window);
     PanelUI.overflowPanel.hidePopup();
     await panelHiddenPromise;
 
diff --git a/browser/components/customizableui/test/browser_989751_subviewbutton_class.js b/browser/components/customizableui/test/browser_989751_subviewbutton_class.js
--- a/browser/components/customizableui/test/browser_989751_subviewbutton_class.js
+++ b/browser/components/customizableui/test/browser_989751_subviewbutton_class.js
@@ -31,17 +31,17 @@ function checkSubviewButtonClass(menuId,
 
     await document.getElementById("nav-bar").overflowable.show();
 
     let button = document.getElementById(buttonId);
     button.click();
 
     await BrowserTestUtils.waitForEvent(PanelUI.overflowPanel, "ViewShown");
     let subview = document.getElementById(subviewId);
-    ok(subview.firstChild, "Subview should have a kid");
+    ok(subview.firstElementChild, "Subview should have a kid");
     let subviewchildren = subview.querySelectorAll("toolbarbutton");
     for (let i = 0; i < subviewchildren.length; i++) {
       let item = subviewchildren[i];
       let itemReadable = "Item '" + item.label + "' (classes: " + item.className + ")";
       ok(item.classList.contains("subviewbutton"), itemReadable + " should have the subviewbutton class.");
       if (i == 0) {
         ok(item.classList.contains(kCustomClass), itemReadable + " should still have its own class, too.");
       }
diff --git a/browser/components/customizableui/test/browser_synced_tabs_menu.js b/browser/components/customizableui/test/browser_synced_tabs_menu.js
--- a/browser/components/customizableui/test/browser_synced_tabs_menu.js
+++ b/browser/components/customizableui/test/browser_synced_tabs_menu.js
@@ -254,62 +254,62 @@ add_task(async function() {
       },
     ]);
   };
   await updateTabsPanel();
 
   // The UI should be showing tabs!
   is(deck.selectedIndex, DECKINDEX_TABS, "no-clients deck entry is visible");
   let tabList = document.getElementById("PanelUI-remotetabs-tabslist");
-  let node = tabList.firstChild;
+  let node = tabList.firstElementChild;
   // First entry should be the client with the most-recent tab.
   is(node.getAttribute("itemtype"), "client", "node is a client entry");
   is(node.textContent, "My Desktop", "correct client");
   // Next entry is the most-recent tab
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/10");
 
   // Next entry is the next-most-recent tab
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/5");
 
   // Next entry is the least-recent tab from the first client.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/1");
 
   // Next is a menuseparator between the clients.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.nodeName, "menuseparator");
 
   // Next is the client with 1 tab.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "client", "node is a client entry");
   is(node.textContent, "My Other Desktop", "correct client");
   // Its single tab
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "tab", "node is a tab");
   is(node.getAttribute("label"), "http://example.com/6");
 
   // Next is a menuseparator between the clients.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.nodeName, "menuseparator");
 
   // Next is the client with no tab.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.getAttribute("itemtype"), "client", "node is a client entry");
   is(node.textContent, "My Phone", "correct client");
   // There is a single node saying there's no tabs for the client.
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node.nodeName, "label", "node is a label");
   is(node.getAttribute("itemtype"), "", "node is neither a tab nor a client");
 
-  node = node.nextSibling;
+  node = node.nextElementSibling;
   is(node, null, "no more entries");
 
   let didSync = false;
   let oldDoSync = gSync.doSync;
   gSync.doSync = function() {
     didSync = true;
     gSync.doSync = oldDoSync;
   };
@@ -361,40 +361,40 @@ add_task(async function() {
   ok(syncPanel.getAttribute("visible"), "Sync Panel is in view");
   let subpanel = document.getElementById("PanelUI-remotetabs-main");
   ok(!subpanel.hidden, "main pane is visible");
   let deck = document.getElementById("PanelUI-remotetabs-deck");
   is(deck.selectedIndex, DECKINDEX_TABS, "we should be showing tabs");
 
   function checkTabsPage(tabsShownCount, showMoreLabel) {
     let tabList = document.getElementById("PanelUI-remotetabs-tabslist");
-    let node = tabList.firstChild;
+    let node = tabList.firstElementChild;
     is(node.getAttribute("itemtype"), "client", "node is a client entry");
     is(node.textContent, "My Desktop", "correct client");
     for (let i = 0; i < tabsShownCount; i++) {
-      node = node.nextSibling;
+      node = node.nextElementSibling;
       is(node.getAttribute("itemtype"), "tab", "node is a tab");
       is(node.getAttribute("label"), "Tab #" + (i + 1), "the tab is the correct one");
       is(node.getAttribute("targetURI"), SAMPLE_TAB_URL, "url is the correct one");
     }
     let showMoreButton;
     if (showMoreLabel) {
-      node = showMoreButton = node.nextSibling;
+      node = showMoreButton = node.nextElementSibling;
       is(node.getAttribute("itemtype"), "showmorebutton", "node is a show more button");
       is(node.getAttribute("label"), showMoreLabel);
     }
-    node = node.nextSibling;
+    node = node.nextElementSibling;
     is(node, null, "no more entries");
 
     return showMoreButton;
   }
 
   async function checkCanOpenURL() {
     let tabList = document.getElementById("PanelUI-remotetabs-tabslist");
-    let node = tabList.firstChild.nextSibling;
+    let node = tabList.firstElementChild.nextElementSibling;
     let promiseTabOpened = BrowserTestUtils.waitForLocationChange(gBrowser, SAMPLE_TAB_URL);
     node.click();
     await promiseTabOpened;
   }
 
   let showMoreButton;
   function clickShowMoreButton() {
     let promise = promiseObserverNotified("synced-tabs-menu:test:tabs-updated");
diff --git a/browser/components/customizableui/test/head.js b/browser/components/customizableui/test/head.js
--- a/browser/components/customizableui/test/head.js
+++ b/browser/components/customizableui/test/head.js
@@ -439,17 +439,17 @@ function promisePopupEvent(aPopup, aEven
 
     aPopup.addEventListener(eventType, onPopupEvent);
   });
 }
 
 // This is a simpler version of the context menu check that
 // exists in contextmenu_common.js.
 function checkContextMenu(aContextMenu, aExpectedEntries, aWindow = window) {
-  let childNodes = [...aContextMenu.childNodes];
+  let childNodes = [...aContextMenu.children];
   // Ignore hidden nodes:
   childNodes = childNodes.filter((n) => !n.hidden);
 
   for (let i = 0; i < childNodes.length; i++) {
     let menuitem = childNodes[i];
     try {
       if (aExpectedEntries[i][0] == "---") {
         is(menuitem.localName, "menuseparator", "menuseparator expected");
diff --git a/browser/components/downloads/DownloadsSubview.jsm b/browser/components/downloads/DownloadsSubview.jsm
--- a/browser/components/downloads/DownloadsSubview.jsm
+++ b/browser/components/downloads/DownloadsSubview.jsm
@@ -39,18 +39,18 @@ class DownloadsSubview extends Downloads
     super();
     this.document = panelview.ownerDocument;
     this.window = panelview.ownerGlobal;
 
     this.context = "panelDownloadsContextMenu";
 
     this.panelview = panelview;
     this.container = this.document.getElementById("panelMenu_downloadsMenu");
-    while (this.container.lastChild) {
-      this.container.lastChild.remove();
+    while (this.container.lastElementChild) {
+      this.container.lastElementChild.remove();
     }
     this.panelview.addEventListener("click", DownloadsSubview.onClick);
     this.panelview.addEventListener("ViewHiding", DownloadsSubview.onViewHiding);
 
     this._viewItemsForDownloads = new WeakMap();
 
     let contextMenu = this.document.getElementById(this.context);
     if (!contextMenu) {
@@ -58,17 +58,17 @@ class DownloadsSubview extends Downloads
       contextMenu.setAttribute("closemenu", "none");
       contextMenu.setAttribute("id", this.context);
       contextMenu.removeAttribute("onpopupshown");
       contextMenu.setAttribute("onpopupshowing",
         "DownloadsSubview.updateContextMenu(document.popupNode, this);");
       contextMenu.setAttribute("onpopuphidden", "DownloadsSubview.onContextMenuHidden(this);");
       let clearButton = contextMenu.querySelector("menuitem[command='downloadsCmd_clearDownloads']");
       clearButton.hidden = false;
-      clearButton.previousSibling.hidden = true;
+      clearButton.previousElementSibling.hidden = true;
       contextMenu.querySelector("menuitem[command='cmd_delete']")
         .setAttribute("command", "downloadsCmd_delete");
     }
     this.panelview.appendChild(contextMenu);
     this.container.setAttribute("context", this.context);
 
     this._downloadsData = DownloadsCommon.getData(this.window, true, true, true);
     this._downloadsData.addView(this);
@@ -96,17 +96,17 @@ class DownloadsSubview extends Downloads
    * downloads.
    */
   onDownloadBatchEnded() {
     let {window} = this;
     window.clearTimeout(this._batchTimeout);
     let waitForMs = 200;
     if (this.batchFragment.childElementCount) {
       // Prepend the batch fragment.
-      this.container.insertBefore(this.batchFragment, this.container.firstChild || null);
+      this.container.insertBefore(this.batchFragment, this.container.firstElementChild || null);
       waitForMs = 0;
     }
     // Wait a wee bit to dispatch the event, because another batch may start
     // right away.
     this._batchTimeout = window.setTimeout(() => {
       this._updateStatsFromDisk();
       this.panelview.dispatchEvent(new window.CustomEvent("DownloadsLoaded"));
     }, waitForMs);
@@ -169,17 +169,17 @@ class DownloadsSubview extends Downloads
       let idleOptions = { timeout: kMaxWaitForIdleMs };
       // Start with getting an idle moment to (maybe) refresh the list of downloads.
       await new Promise(resolve => this.window.requestIdleCallback(resolve), idleOptions);
       // In the meantime, this instance could have been destroyed, so take note.
       if (this.destroyed)
         return;
 
       let count = 0;
-      for (let button of this.container.childNodes) {
+      for (let button of this.container.children) {
         if (this.destroyed)
           return;
         if (!button._shell)
           continue;
 
         await button._shell.refresh();
 
         // Make sure to request a new idle moment every `kRefreshBatchSize` buttons.
diff --git a/browser/components/downloads/DownloadsViewUI.jsm b/browser/components/downloads/DownloadsViewUI.jsm
--- a/browser/components/downloads/DownloadsViewUI.jsm
+++ b/browser/components/downloads/DownloadsViewUI.jsm
@@ -36,17 +36,17 @@ var DownloadsViewUI = {
 };
 
 this.DownloadsViewUI.BaseView = class {
   canClearDownloads(nodeContainer) {
     // Downloads can be cleared if there's at least one removable download in
     // the list (either a history download or a completed session download).
     // Because history downloads are always removable and are listed after the
     // session downloads, check from bottom to top.
-    for (let elt = nodeContainer.lastChild; elt; elt = elt.previousSibling) {
+    for (let elt = nodeContainer.lastElementChild; elt; elt = elt.previousElementSibling) {
       // Stopped, paused, and failed downloads with partial data are removed.
       let download = elt._shell.download;
       if (download.stopped && !(download.canceled && download.hasPartialData)) {
         return true;
       }
     }
     return false;
   }
diff --git a/browser/components/downloads/content/allDownloadsView.js b/browser/components/downloads/content/allDownloadsView.js
--- a/browser/components/downloads/content/allDownloadsView.js
+++ b/browser/components/downloads/content/allDownloadsView.js
@@ -249,23 +249,23 @@ DownloadsPlacesView.prototype = {
     this._active = val;
     if (this._active)
       this._ensureVisibleElementsAreActive();
     return this._active;
   },
 
   _ensureVisibleElementsAreActive() {
     if (!this.active || this._ensureVisibleTimer ||
-        !this._richlistbox.firstChild) {
+        !this._richlistbox.firstElementChild) {
       return;
     }
 
     this._ensureVisibleTimer = setTimeout(() => {
       delete this._ensureVisibleTimer;
-      if (!this._richlistbox.firstChild) {
+      if (!this._richlistbox.firstElementChild) {
         return;
       }
 
       let rlbRect = this._richlistbox.getBoundingClientRect();
       let winUtils = window.windowUtils;
       let nodes = winUtils.nodesFromRect(rlbRect.left, rlbRect.top,
                                          0, rlbRect.width, rlbRect.height, 0,
                                          true, false);
@@ -283,23 +283,23 @@ DownloadsPlacesView.prototype = {
             lastVisibleNode = node;
           }
         }
       }
 
       // Also activate the first invisible nodes in both boundaries (that is,
       // above and below the visible area) to ensure proper keyboard navigation
       // in both directions.
-      let nodeBelowVisibleArea = lastVisibleNode && lastVisibleNode.nextSibling;
+      let nodeBelowVisibleArea = lastVisibleNode && lastVisibleNode.nextElementSibling;
       if (nodeBelowVisibleArea && nodeBelowVisibleArea._shell) {
         nodeBelowVisibleArea._shell.ensureActive();
       }
 
       let nodeAboveVisibleArea = firstVisibleNode &&
-                                 firstVisibleNode.previousSibling;
+                                 firstVisibleNode.previousElementSibling;
       if (nodeAboveVisibleArea && nodeAboveVisibleArea._shell) {
         nodeAboveVisibleArea._shell.ensureActive();
       }
     }, 10);
   },
 
   _place: "",
   get place() {
@@ -332,17 +332,17 @@ DownloadsPlacesView.prototype = {
     return this._richlistbox.controller;
   },
 
   get searchTerm() {
     return this._searchTerm;
   },
   set searchTerm(aValue) {
     if (this._searchTerm != aValue) {
-      for (let element of this._richlistbox.childNodes) {
+      for (let element of this._richlistbox.children) {
         element.hidden = !element._shell.matchesSearchTerm(aValue);
       }
       this._ensureVisibleElementsAreActive();
     }
     return this._searchTerm = aValue;
   },
 
   /**
@@ -358,17 +358,17 @@ DownloadsPlacesView.prototype = {
    * We work around this by attempting to select the first element twice,
    * once after the places data is loaded and once when the session downloads
    * data is done loading.  However, if the selection has changed in-between,
    * we assume the user has already started using the view and give up.
    */
   _ensureInitialSelection() {
     // Either they're both null, or the selection has not changed in between.
     if (this._richlistbox.selectedItem == this._initiallySelectedElement) {
-      let firstDownloadElement = this._richlistbox.firstChild;
+      let firstDownloadElement = this._richlistbox.firstElementChild;
       if (firstDownloadElement != this._initiallySelectedElement) {
         // We may be called before _ensureVisibleElementsAreActive,
         // or before the download binding is attached. Therefore, ensure the
         // first item is activated, and pass the item to the richlistbox
         // setters only at a point we know for sure the binding is attached.
         firstDownloadElement._shell.ensureActive();
         Services.tm.dispatchToMainThread(() => {
           this._richlistbox.selectedItem = firstDownloadElement;
@@ -418,17 +418,17 @@ DownloadsPlacesView.prototype = {
     let xblFields = new Map();
     for (let key of Object.getOwnPropertyNames(this._richlistbox)) {
       let value = this._richlistbox[key];
       xblFields.set(key, value);
     }
 
     let oldActiveElement = document.activeElement;
     let parentNode = this._richlistbox.parentNode;
-    let nextSibling = this._richlistbox.nextSibling;
+    let nextSibling = this._richlistbox.nextElementSibling;
     parentNode.removeChild(this._richlistbox);
     this._richlistbox.prepend(this.batchFragment);
     parentNode.insertBefore(this._richlistbox, nextSibling);
     if (oldActiveElement && oldActiveElement != document.activeElement) {
       oldActiveElement.focus();
     }
 
     for (let [key, value] of xblFields) {
@@ -464,22 +464,22 @@ DownloadsPlacesView.prototype = {
     this._viewItemsForDownloads.get(download).onChanged();
   },
 
   onDownloadRemoved(download) {
     let element = this._viewItemsForDownloads.get(download).element;
 
     // If the element was selected exclusively, select its next
     // sibling first, if not, try for previous sibling, if any.
-    if ((element.nextSibling || element.previousSibling) &&
+    if ((element.nextElementSibling || element.previousElementSibling) &&
         this._richlistbox.selectedItems &&
         this._richlistbox.selectedItems.length == 1 &&
         this._richlistbox.selectedItems[0] == element) {
-      this._richlistbox.selectItem(element.nextSibling ||
-                                   element.previousSibling);
+      this._richlistbox.selectItem(element.nextElementSibling ||
+                                   element.previousElementSibling);
     }
 
     this._richlistbox.removeItemFromSelection(element);
     element.remove();
 
     // Don't update commands and visible elements during a batch change.
     if (!this.batchFragment) {
       this._ensureVisibleElementsAreActive();
diff --git a/browser/components/downloads/content/downloads.js b/browser/components/downloads/content/downloads.js
--- a/browser/components/downloads/content/downloads.js
+++ b/browser/components/downloads/content/downloads.js
@@ -396,17 +396,17 @@ var DownloadsPanel = {
       }
       aEvent.preventDefault();
       return;
     }
 
     if (aEvent.keyCode == aEvent.DOM_VK_DOWN) {
       // If the last element in the list is selected, or the footer is already
       // focused, focus the footer.
-      if (richListBox.selectedItem === richListBox.lastChild ||
+      if (richListBox.selectedItem === richListBox.lastElementChild ||
           document.activeElement.parentNode.id === "downloadsFooter") {
         DownloadsFooter.focus();
         aEvent.preventDefault();
         return;
       }
     }
 
     // Pass keypress events to the richlistbox view when it's focused.
@@ -420,19 +420,19 @@ var DownloadsPanel = {
    * as the the accel-V "paste" event, which initiates a file download if the
    * pasted item can be resolved to a URI.
    */
   _onKeyDown(aEvent) {
     // If the footer is focused and the downloads list has at least 1 element
     // in it, focus the last element in the list when going up.
     if (aEvent.keyCode == aEvent.DOM_VK_UP &&
         document.activeElement.parentNode.id === "downloadsFooter" &&
-        DownloadsView.richListBox.firstChild) {
+        DownloadsView.richListBox.firstElementChild) {
       DownloadsView.richListBox.focus();
-      DownloadsView.richListBox.selectedItem = DownloadsView.richListBox.lastChild;
+      DownloadsView.richListBox.selectedItem = DownloadsView.richListBox.lastElementChild;
       aEvent.preventDefault();
       return;
     }
 
     let pasting = aEvent.keyCode == aEvent.DOM_VK_V &&
                   aEvent.getModifierState("Accel");
 
     if (!pasting) {
@@ -723,17 +723,17 @@ var DownloadsView = {
     DownloadsCommon.log("Adding a new DownloadsViewItem to the downloads list.",
                         "aNewest =", aNewest);
 
     let element = document.createElement("richlistitem");
     let viewItem = new DownloadsViewItem(download, element);
     this._visibleViewItems.set(download, viewItem);
     this._itemsForElements.set(element, viewItem);
     if (aNewest) {
-      this.richListBox.insertBefore(element, this.richListBox.firstChild);
+      this.richListBox.insertBefore(element, this.richListBox.firstElementChild);
     } else {
       this.richListBox.appendChild(element);
     }
   },
 
   /**
    * Removes the view item associated with the specified data item.
    */
diff --git a/browser/components/downloads/test/browser/browser_downloads_panel_block.js b/browser/components/downloads/test/browser/browser_downloads_panel_block.js
--- a/browser/components/downloads/test/browser/browser_downloads_panel_block.js
+++ b/browser/components/downloads/test/browser/browser_downloads_panel_block.js
@@ -12,17 +12,17 @@ add_task(async function mainTest() {
   await task_addDownloads(verdicts.map(v => makeDownload(v)));
 
   // Check that the richlistitem for each download is correct.
   for (let i = 0; i < verdicts.length; i++) {
     await openPanel();
 
     // The current item is always the first one in the listbox since each
     // iteration of this loop removes the item at the end.
-    let item = DownloadsView.richListBox.firstChild;
+    let item = DownloadsView.richListBox.firstElementChild;
 
     // Open the panel and click the item to show the subview.
     let viewPromise = promiseViewShown(DownloadsBlockedSubview.subview);
     EventUtils.sendMouseEvent({ type: "click" }, item);
     await viewPromise;
 
     // Items are listed in newest-to-oldest order, so e.g. the first item's
     // verdict is the last element in the verdicts array.
diff --git a/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js b/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js
--- a/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js
+++ b/browser/components/enterprisepolicies/tests/browser/browser_policy_search_engine.js
@@ -33,22 +33,22 @@ async function test_opensearch(shouldWor
   await promiseSearchPopupShown;
   let oneOffsContainer = document.getAnonymousElementByAttribute(searchPopup,
                                                                  "anonid",
                                                                  "search-one-off-buttons");
   let engineListElement = document.getAnonymousElementByAttribute(oneOffsContainer,
                                                                   "anonid",
                                                                   "add-engines");
   if (shouldWork) {
-    ok(engineListElement.firstChild,
+    ok(engineListElement.firstElementChild,
        "There should be search engines available to add");
     ok(searchBar.getAttribute("addengines"),
        "Search bar should have addengines attribute");
   } else {
-    is(engineListElement.firstChild, null,
+    is(engineListElement.firstElementChild, null,
        "There should be no search engines available to add");
     ok(!searchBar.getAttribute("addengines"),
        "Search bar should not have addengines attribute");
   }
   await BrowserTestUtils.removeTab(tab);
 }
 
 add_task(async function test_install_and_set_default() {
diff --git a/browser/components/extensions/parent/ext-menus.js b/browser/components/extensions/parent/ext-menus.js
--- a/browser/components/extensions/parent/ext-menus.js
+++ b/browser/components/extensions/parent/ext-menus.js
@@ -71,32 +71,32 @@ var gMenuBuilder = {
     const children = this.buildChildren(root, contextData);
     const visible = children.slice(0, ACTION_MENU_TOP_LEVEL_LIMIT);
 
     this.xulMenu = menu;
     menu.addEventListener("popuphidden", this);
 
     if (visible.length) {
       const separator = menu.ownerDocument.createElement("menuseparator");
-      menu.insertBefore(separator, menu.firstChild);
+      menu.insertBefore(separator, menu.firstElementChild);
       this.itemsToCleanUp.add(separator);
 
       for (const child of visible) {
         this.itemsToCleanUp.add(child);
         menu.insertBefore(child, separator);
       }
     }
     this.afterBuildingMenu(contextData);
   },
 
   buildElementWithChildren(item, contextData) {
     const element = this.buildSingleElement(item, contextData);
     const children = this.buildChildren(item, contextData);
     if (children.length) {
-      element.firstChild.append(...children);
+      element.firstElementChild.append(...children);
     }
     return element;
   },
 
   buildChildren(item, contextData) {
     let groupName;
     let children = [];
     for (let child of item.children) {
@@ -113,17 +113,17 @@ var gMenuBuilder = {
         children.push(this.buildElementWithChildren(child, contextData));
       }
     }
     return children;
   },
 
   createTopLevelElement(root, contextData) {
     let rootElement = this.buildElementWithChildren(root, contextData);
-    if (!rootElement.firstChild || !rootElement.firstChild.childNodes.length) {
+    if (!rootElement.firstElementChild || !rootElement.firstElementChild.children.length) {
       // If the root has no visible children, there is no reason to show
       // the root menu item itself either.
       return null;
     }
     rootElement.setAttribute("ext-type", "top-level-menu");
     rootElement = this.removeTopLevelMenuIfNeeded(rootElement);
 
     // Display the extension icon on the root element.
@@ -151,19 +151,19 @@ var gMenuBuilder = {
       separator.remove();
       this.itemsToCleanUp.clear();
     }
   },
 
   removeTopLevelMenuIfNeeded(element) {
     // If there is only one visible top level element we don't need the
     // root menu element for the extension.
-    let menuPopup = element.firstChild;
-    if (menuPopup && menuPopup.childNodes.length == 1) {
-      let onlyChild = menuPopup.firstChild;
+    let menuPopup = element.firstElementChild;
+    if (menuPopup && menuPopup.children.length == 1) {
+      let onlyChild = menuPopup.firstElementChild;
 
       // Keep single checkbox items in the submenu on Linux since
       // the extension icon overlaps the checkbox otherwise.
       if (AppConstants.platform === "linux" && onlyChild.getAttribute("type") === "checkbox") {
         return element;
       }
 
       onlyChild.remove();
diff --git a/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js b/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js
--- a/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js
+++ b/browser/components/extensions/test/browser/browser_ext_browserAction_popup_resize.js
@@ -148,17 +148,17 @@ async function testPopupSize(standardsMo
   }
 
 
   // Test the PanelUI panel for a menu panel button.
   let widget = getBrowserActionWidget(extension);
   CustomizableUI.addWidgetToArea(widget.id, getCustomizableUIPanelID());
 
   let panel = browserWin.PanelUI.overflowPanel;
-  let panelMultiView = panel.firstChild;
+  let panelMultiView = panel.firstElementChild;
   let widgetId = makeWidgetId(extension.id);
   // The 'ViewShown' event is the only way to correctly determine when the extensions'
   // panelview has finished transitioning and is fully in view.
   let shownPromise = BrowserTestUtils.waitForEvent(panelMultiView, "ViewShown",
                                                    e => (e.originalTarget.id || "").includes(widgetId));
   let browser = await openPanel(extension, browserWin);
   let origPanelRect = panel.getBoundingClientRect();
 
diff --git a/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js b/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js
--- a/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js
+++ b/browser/components/extensions/test/browser/browser_ext_commands_onCommand.js
@@ -256,21 +256,21 @@ add_task(async function test_user_define
 
   let totalTestCommands = Object.keys(testCommands).length;
   let expectedCommandsRegistered = isMac ? totalTestCommands : totalTestCommands - totalMacOnlyCommands;
 
   // Confirm the keysets have been added to both windows.
   let keysetID = `ext-keyset-id-${makeWidgetId(extension.id)}`;
   let keyset = win1.document.getElementById(keysetID);
   ok(keyset != null, "Expected keyset to exist");
-  is(keyset.childNodes.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
+  is(keyset.children.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
 
   keyset = win2.document.getElementById(keysetID);
   ok(keyset != null, "Expected keyset to exist");
-  is(keyset.childNodes.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
+  is(keyset.children.length, expectedCommandsRegistered, "Expected keyset to have the correct number of children");
 
   // Confirm that the commands are registered to both windows.
   await focusWindow(win1);
   await runTest(win1);
 
   await focusWindow(win2);
   await runTest(win2);
 
diff --git a/browser/components/extensions/test/browser/browser_ext_contextMenus.js b/browser/components/extensions/test/browser/browser_ext_contextMenus.js
--- a/browser/components/extensions/test/browser/browser_ext_contextMenus.js
+++ b/browser/components/extensions/test/browser/browser_ext_contextMenus.js
@@ -171,17 +171,17 @@ add_task(async function() {
   is(items.length, 0, "contextMenu item for selection was not found (context=image)");
 
   items = extensionMenuRoot.getElementsByAttribute("label", "parentToDel");
   is(items.length, 0, "contextMenu item for removed parent was not found (context=image)");
 
   items = extensionMenuRoot.getElementsByAttribute("label", "parent");
   is(items.length, 1, "contextMenu item for parent was found (context=image)");
 
-  is(items[0].childNodes[0].childNodes.length, 2, "child items for parent were found (context=image)");
+  is(items[0].children[0].children.length, 2, "child items for parent were found (context=image)");
 
   // Click on ext-image item and check the click results
   await closeExtensionContextMenu(image);
 
   let result = await extension.awaitMessage("onclick");
   checkClickInfo(result);
   result = await extension.awaitMessage("browser.contextMenus.onClicked");
   checkClickInfo(result);
@@ -313,17 +313,17 @@ add_task(async function() {
   checkClickInfo(result);
 
   // Select some text
   await ContentTask.spawn(gBrowser.selectedBrowser, { }, async function(arg) {
     let doc = content.document;
     let range = doc.createRange();
     let selection = content.getSelection();
     selection.removeAllRanges();
-    let textNode = doc.getElementById("img1").previousSibling;
+    let textNode = doc.getElementById("img1").previousElementSibling;
     range.setStart(textNode, 0);
     range.setEnd(textNode, 100);
     selection.addRange(range);
   });
 
   // Bring up context menu again
   extensionMenuRoot = await openExtensionContextMenu();
 
@@ -366,17 +366,17 @@ add_task(async function() {
   checkClickInfo(result);
 
   // Select a lot of text
   await ContentTask.spawn(gBrowser.selectedBrowser, { }, function* (arg) {
     let doc = content.document;
     let range = doc.createRange();
     let selection = content.getSelection();
     selection.removeAllRanges();
-    let textNode = doc.getElementById("longtext").firstChild;
+    let textNode = doc.getElementById("longtext").firstElementChild;
     range.setStart(textNode, 0);
     range.setEnd(textNode, textNode.length);
     selection.addRange(range);
   });
 
   // Bring up context menu again
   extensionMenuRoot = await openExtensionContextMenu("#longtext");
 
diff --git a/browser/components/extensions/test/browser/browser_ext_menus.js b/browser/components/extensions/test/browser/browser_ext_menus.js
--- a/browser/components/extensions/test/browser/browser_ext_menus.js
+++ b/browser/components/extensions/test/browser/browser_ext_menus.js
@@ -82,30 +82,30 @@ add_task(async function test_actionConte
   for (const kind of ["page", "browser"]) {
     const menu = await openActionContextMenu(extension, kind);
     const [submenu, second, , , , last, separator] = menu.children;
 
     is(submenu.tagName, "menu", "Correct submenu type");
     is(submenu.label, "parent", "Correct submenu title");
 
     const popup = await openSubmenu(submenu);
-    is(popup, submenu.firstChild, "Correct submenu opened");
+    is(popup, submenu.firstElementChild, "Correct submenu opened");
     is(popup.children.length, 2, "Correct number of submenu items");
 
     let idPrefix = `${makeWidgetId(extension.id)}-menuitem-_`;
 
     is(second.tagName, "menuitem", "Second menu item type is correct");
     is(second.label, "click 1", "Second menu item title is correct");
     is(second.id, `${idPrefix}1`, "Second menu item id is correct");
 
     is(last.label, "click 5", "Last menu item title is correct");
     is(last.id, `${idPrefix}5`, "Last menu item id is correct");
     is(separator.tagName, "menuseparator", "Separator after last menu item");
 
-    await closeActionContextMenu(popup.firstChild, kind);
+    await closeActionContextMenu(popup.firstElementChild, kind);
     const {info, tab} = await extension.awaitMessage("click");
     is(info.pageUrl, "http://example.com/", "Click info pageUrl is correct");
     is(tab.id, tabId, "Click event tab ID is correct");
   }
 
   BrowserTestUtils.removeTab(tab);
   await extension.unload();
 });
@@ -134,17 +134,17 @@ add_task(async function test_hiddenPageA
 
   const extension = ExtensionTestUtils.loadExtension({manifest, background});
   const tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, "http://example.com/");
 
   await extension.startup();
   await extension.awaitMessage("ready");
 
   const menu = await openContextMenuInPageActionPanel(extension);
-  const menuItems = Array.filter(menu.childNodes, node => {
+  const menuItems = Array.filter(menu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 
   is(menuItems.length, 3, "Correct number of children");
   const [dontShowItem, separator, manageItem] = menuItems;
 
   is(dontShowItem.label, "Don\u2019t Show in Address Bar", "Correct first child");
   is(separator.tagName, "menuseparator", "Correct second child");
@@ -247,17 +247,17 @@ add_task(async function test_tabContextM
   is(submenu.label, "alpha-beta parent", "Correct submenu title");
 
   isnot(gamma.label, "dummy", "`page` context menu item should not appear here");
 
   is(gamma.tagName, "menuitem", "Third menu item type is correct");
   is(gamma.label, "gamma", "Third menu item label is correct");
 
   const popup = await openSubmenu(submenu);
-  is(popup, submenu.firstChild, "Correct submenu opened");
+  is(popup, submenu.firstElementChild, "Correct submenu opened");
   is(popup.children.length, 2, "Correct number of submenu items");
 
   const [alpha, beta] = popup.children;
   is(alpha.tagName, "menuitem", "First menu item type is correct");
   is(alpha.label, "alpha", "First menu item label is correct");
   is(beta.tagName, "menuitem", "Second menu item type is correct");
   is(beta.label, "beta", "Second menu item label is correct");
 
@@ -341,18 +341,18 @@ add_task(async function test_multiple_co
 
   const menu = await openContextMenu();
   const items = menu.getElementsByAttribute("label", "parent");
 
   is(items.length, 1, "Found parent menu item");
   is(items[0].tagName, "menu", "And it has children");
 
   const popup = await openSubmenu(items[0]);
-  is(popup.firstChild.label, "child", "Correct child menu item");
-  await closeExtensionContextMenu(popup.firstChild);
+  is(popup.firstElementChild.label, "child", "Correct child menu item");
+  await closeExtensionContextMenu(popup.firstElementChild);
 
   const info = await extension.awaitMessage("click");
   is(info.menuItemId, "child", "onClicked the correct item");
 
   BrowserTestUtils.removeTab(tab);
   await extension.unload();
 });
 
@@ -392,17 +392,17 @@ add_task(async function test_tools_menu(
   const tabId = await second.awaitMessage("ready");
   const menu = await openToolsMenu();
 
   const [separator, submenu, gamma] = Array.from(menu.children).slice(-3);
   is(separator.tagName, "menuseparator", "Separator before first extension item");
 
   is(submenu.tagName, "menu", "Correct submenu type");
   is(submenu.getAttribute("label"), "Generated extension", "Correct submenu title");
-  is(submenu.firstChild.children.length, 2, "Correct number of submenu items");
+  is(submenu.firstElementChild.children.length, 2, "Correct number of submenu items");
 
   is(gamma.tagName, "menuitem", "Third menu item type is correct");
   is(gamma.getAttribute("label"), "gamma", "Third menu item label is correct");
 
   closeToolsMenu(gamma);
 
   const click = await second.awaitMessage("click");
   is(click.info.pageUrl, "http://example.com/", "Click info pageUrl is correct");
diff --git a/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js b/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js
--- a/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js
+++ b/browser/components/extensions/test/browser/browser_ext_pageAction_popup_resize.js
@@ -47,17 +47,17 @@ add_task(async function testPageActionPo
 
     // Tolerate if it is 1px too wide, as that may happen with the current resizing method.
     ok(Math.abs(dims.window.innerWidth - expected) <= 1, `Panel window should be ${expected}px wide`);
     is(body.clientWidth, body.scrollWidth,
        "Panel body should be wide enough to fit its contents");
   }
 
   function setSize(size) {
-    let elem = content.document.body.firstChild;
+    let elem = content.document.body.firstElementChild;
     elem.style.height = `${size}px`;
     elem.style.width = `${size}px`;
   }
 
   let sizes = [
     200,
     400,
     300,
diff --git a/browser/components/extensions/test/browser/browser_ext_popup_select.js b/browser/components/extensions/test/browser/browser_ext_popup_select.js
--- a/browser/components/extensions/test/browser/browser_ext_popup_select.js
+++ b/browser/components/extensions/test/browser/browser_ext_popup_select.js
@@ -36,17 +36,17 @@ add_task(async function testPopupSelectP
             </div>
           </body>
         </html>`,
     },
   });
 
   await extension.startup();
 
-  let selectPopup = document.getElementById("ContentSelectDropdown").firstChild;
+  let selectPopup = document.getElementById("ContentSelectDropdown").firstElementChild;
 
   async function testPanel(browser) {
     let popupPromise = promisePopupShown(selectPopup);
 
     BrowserTestUtils.synthesizeMouseAtCenter("#select", {}, browser);
 
     await popupPromise;
 
diff --git a/browser/components/extensions/test/browser/browser_ext_user_events.js b/browser/components/extensions/test/browser/browser_ext_user_events.js
--- a/browser/components/extensions/test/browser/browser_ext_user_events.js
+++ b/browser/components/extensions/test/browser/browser_ext_user_events.js
@@ -14,17 +14,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 // Test that different types of events are all considered
 // "handling user input".
diff --git a/browser/components/extensions/test/browser/head.js b/browser/components/extensions/test/browser/head.js
--- a/browser/components/extensions/test/browser/head.js
+++ b/browser/components/extensions/test/browser/head.js
@@ -393,17 +393,17 @@ async function openChromeContextMenu(men
   const menu = win.document.getElementById(menuId);
   const shown = BrowserTestUtils.waitForEvent(menu, "popupshown");
   EventUtils.synthesizeMouseAtCenter(node, {type: "contextmenu"}, win);
   await shown;
   return menu;
 }
 
 async function openSubmenu(submenuItem, win = window) {
-  const submenu = submenuItem.firstChild;
+  const submenu = submenuItem.firstElementChild;
   const shown = BrowserTestUtils.waitForEvent(submenu, "popupshown");
   EventUtils.synthesizeMouseAtCenter(submenuItem, {}, win);
   await shown;
   return submenu;
 }
 
 function closeChromeContextMenu(menuId, itemToSelect, win = window) {
   const menu = win.document.getElementById(menuId);
diff --git a/browser/components/feeds/FeedWriter.js b/browser/components/feeds/FeedWriter.js
--- a/browser/components/feeds/FeedWriter.js
+++ b/browser/components/feeds/FeedWriter.js
@@ -92,17 +92,17 @@ FeedWriter.prototype = {
     }
     return "";
   },
 
   _setContentText(id, text) {
     let element = this._document.getElementById(id);
     let textNode = text.createDocumentFragment(element);
     while (element.hasChildNodes())
-      element.firstChild.remove();
+      element.firstElementChild.remove();
     element.appendChild(textNode);
     if (text.base) {
       element.setAttributeNS(XML_NS, "base", text.base.spec);
     }
   },
 
   /**
    * Safely sets the href attribute on an anchor tag, providing the URI
@@ -506,17 +506,17 @@ FeedWriter.prototype = {
 
       case Ci.nsIFeed.TYPE_AUDIO:
         stringLabel = "subscribeAudioPodcastUsing";
         break;
     }
 
     let subscribeUsing = this._document.getElementById("subscribeUsingDescription");
     let textNode = this._document.createTextNode(this._getString(stringLabel));
-    subscribeUsing.insertBefore(textNode, subscribeUsing.firstChild);
+    subscribeUsing.insertBefore(textNode, subscribeUsing.firstElementChild);
   },
 
   _setAlwaysUseLabel() {
     let checkbox = this._document.getElementById("alwaysUse");
     if (checkbox && this._handlersList) {
       let handlerName = this._handlersList.selectedOptions[0]
                             .textContent;
       let stringLabel = "alwaysUseForFeeds";
@@ -528,18 +528,18 @@ FeedWriter.prototype = {
         case Ci.nsIFeed.TYPE_AUDIO:
           stringLabel = "alwaysUseForAudioPodcasts";
           break;
       }
 
       let label = this._getFormattedString(stringLabel, [handlerName]);
 
       let checkboxText = this._document.getElementById("checkboxText");
-      if (checkboxText.lastChild.nodeType == checkboxText.TEXT_NODE) {
-        checkboxText.lastChild.textContent = label;
+      if (checkboxText.lastElementChild.nodeType == checkboxText.TEXT_NODE) {
+        checkboxText.lastElementChild.textContent = label;
       } else {
         LOG("FeedWriter._setAlwaysUseLabel: Expected textNode as lastChild of alwaysUse label");
         let textNode = this._document.createTextNode(label);
         checkboxText.appendChild(textNode);
       }
     }
   },
 
diff --git a/browser/components/migration/content/migration.js b/browser/components/migration/content/migration.js
--- a/browser/components/migration/content/migration.js
+++ b/browser/components/migration/content/migration.js
@@ -92,29 +92,29 @@ var MigrationWizard = { /* exported Migr
     };
     this._wiz.canRewind = false;
 
     var selectedMigrator = null;
     this._availableMigrators = [];
 
     // Figure out what source apps are are available to import from:
     var group = document.getElementById("importSourceGroup");
-    for (var i = 0; i < group.childNodes.length; ++i) {
-      var migratorKey = group.childNodes[i].id;
+    for (var i = 0; i < group.children.length; ++i) {
+      var migratorKey = group.children[i].id;
       if (migratorKey != "nothing") {
         var migrator = this.spinResolve(MigrationUtils.getMigrator(migratorKey));
         if (migrator) {
           // Save this as the first selectable item, if we don't already have
           // one, or if it is the migrator that was passed to us.
           if (!selectedMigrator || this._source == migratorKey)
-            selectedMigrator = group.childNodes[i];
+            selectedMigrator = group.children[i];
           this._availableMigrators.push([migratorKey, migrator]);
         } else {
           // Hide this option
-          group.childNodes[i].hidden = true;
+          group.children[i].hidden = true;
         }
       }
     }
     if (this.isInitialMigration) {
       Services.telemetry.getHistogramById("FX_STARTUP_MIGRATION_BROWSER_COUNT")
         .add(this._availableMigrators.length);
       let defaultBrowser = MigrationUtils.getMigratorKeyForDefaultBrowser();
       // This will record 0 for unknown default browser IDs.
@@ -191,32 +191,32 @@ var MigrationWizard = { /* exported Migr
   onSelectProfilePageShow() {
     // Disabling this for now, since we ask about import sources in automigration
     // too and don't want to disable the back button
     // if (this._autoMigrate)
     //   document.documentElement.getButton("back").disabled = true;
 
     var profiles = document.getElementById("profiles");
     while (profiles.hasChildNodes())
-      profiles.firstChild.remove();
+      profiles.firstElementChild.remove();
 
     // Note that this block is still reached even if the user chose 'From File'
     // and we canceled the dialog.  When that happens, _migrator will be null.
     if (this._migrator) {
       var sourceProfiles = this.spinResolve(this._migrator.getSourceProfiles());
 
       for (let profile of sourceProfiles) {
         var item = document.createElement("radio");
         item.id = profile.id;
         item.setAttribute("label", profile.name);
         profiles.appendChild(item);
       }
     }
 
-    profiles.selectedItem = this._selectedProfile ? document.getElementById(this._selectedProfile.id) : profiles.firstChild;
+    profiles.selectedItem = this._selectedProfile ? document.getElementById(this._selectedProfile.id) : profiles.firstElementChild;
   },
 
   onSelectProfilePageRewound() {
     var profiles = document.getElementById("profiles");
     let sourceProfiles = this.spinResolve(this._migrator.getSourceProfiles());
     this._selectedProfile = sourceProfiles.find(
       profile => profile.id == profiles.selectedItem.id
     ) || null;
@@ -233,17 +233,17 @@ var MigrationWizard = { /* exported Migr
     if (this._autoMigrate)
       this._wiz.currentPage.next = "migrating";
   },
 
   // 3 - ImportItems
   onImportItemsPageShow() {
     var dataSources = document.getElementById("dataSources");
     while (dataSources.hasChildNodes())
-      dataSources.firstChild.remove();
+      dataSources.firstElementChild.remove();
 
     var items = this.spinResolve(this._migrator.getMigrateData(this._selectedProfile,
                                                                this._autoMigrate));
     for (var i = 0; i < 16; ++i) {
       var itemID = (items >> i) & 0x1 ? Math.pow(2, i) : 0;
       if (itemID > 0) {
         var checkbox = document.createElement("checkbox");
         checkbox.id = itemID;
@@ -259,18 +259,18 @@ var MigrationWizard = { /* exported Migr
   onImportItemsPageRewound() {
     this._wiz.canAdvance = true;
     this.onImportItemsPageAdvanced();
   },
 
   onImportItemsPageAdvanced() {
     var dataSources = document.getElementById("dataSources");
     this._itemsFlags = 0;
-    for (var i = 0; i < dataSources.childNodes.length; ++i) {
-      var checkbox = dataSources.childNodes[i];
+    for (var i = 0; i < dataSources.children.length; ++i) {
+      var checkbox = dataSources.children[i];
       if (checkbox.localName == "checkbox" && checkbox.checked)
         this._itemsFlags |= parseInt(checkbox.id);
     }
   },
 
   onImportItemCommand() {
     var items = document.getElementById("dataSources");
     var checkboxes = items.getElementsByTagName("checkbox");
@@ -320,17 +320,17 @@ var MigrationWizard = { /* exported Migr
         exp++;
       }
     }
   },
 
   _listItems(aID) {
     var items = document.getElementById(aID);
     while (items.hasChildNodes())
-      items.firstChild.remove();
+      items.firstElementChild.remove();
 
     var itemID;
     for (var i = 0; i < 16; ++i) {
       itemID = (this._itemsFlags >> i) & 0x1 ? Math.pow(2, i) : 0;
       if (itemID > 0) {
         var label = document.createElement("label");
         label.id = itemID + "_migrated";
         try {
diff --git a/browser/components/originattributes/test/browser/browser_favicon_firstParty.js b/browser/components/originattributes/test/browser/browser_favicon_firstParty.js
--- a/browser/components/originattributes/test/browser/browser_favicon_firstParty.js
+++ b/browser/components/originattributes/test/browser/browser_favicon_firstParty.js
@@ -271,17 +271,17 @@ async function doTestForAllTabsFavicon(a
   assertIconIsData(tabInfo.tab);
 
   // Make the popup of allTabs showing up and trigger the loading of the favicon.
   let allTabsView = document.getElementById("allTabsMenu-allTabsView");
   let allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   let allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
@@ -300,17 +300,17 @@ async function doTestForAllTabsFavicon(a
 
   assertIconIsData(tabInfo.tab);
 
   // Make the popup of allTabs showing up again.
   allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
diff --git a/browser/components/originattributes/test/browser/browser_favicon_userContextId.js b/browser/components/originattributes/test/browser/browser_favicon_userContextId.js
--- a/browser/components/originattributes/test/browser/browser_favicon_userContextId.js
+++ b/browser/components/originattributes/test/browser/browser_favicon_userContextId.js
@@ -223,17 +223,17 @@ async function doTestForAllTabsFavicon(a
   clearAllImageCaches();
 
   // Make the popup of allTabs showing up and trigger the loading of the favicon.
   let allTabsView = document.getElementById("allTabsMenu-allTabsView");
   let allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   let allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
@@ -249,17 +249,17 @@ async function doTestForAllTabsFavicon(a
   // Clear the image cache again.
   clearAllImageCaches();
 
   // Make the popup of allTabs showing up again.
   allTabsPopupShownPromise = BrowserTestUtils.waitForEvent(allTabsView, "ViewShown");
   gTabsPanel.showAllTabsPanel();
   await allTabsPopupShownPromise;
 
-  assertIconIsData(gTabsPanel.allTabsViewTabs.lastChild.firstChild);
+  assertIconIsData(gTabsPanel.allTabsViewTabs.lastElementChild.firstElementChild);
 
   // Close the popup of allTabs and wait until it's done.
   allTabsPopupHiddenPromise = BrowserTestUtils.waitForEvent(allTabsView.panelMultiView, "PanelMultiViewHidden");
   gTabsPanel.hideAllTabsPanel();
   await allTabsPopupHiddenPromise;
 
   // Close the tab.
   BrowserTestUtils.removeTab(tabInfo.tab);
diff --git a/browser/components/payments/res/containers/order-details.js b/browser/components/payments/res/containers/order-details.js
--- a/browser/components/payments/res/containers/order-details.js
+++ b/browser/components/payments/res/containers/order-details.js
@@ -35,18 +35,18 @@ export default class OrderDetails extend
     return this._footerItemsList;
   }
 
   get totalAmountElem() {
     return this._totalAmount;
   }
 
   static _emptyList(listEl) {
-    while (listEl.lastChild) {
-      listEl.removeChild(listEl.lastChild);
+    while (listEl.lastElementChild) {
+      listEl.removeChild(listEl.lastElementChild);
     }
   }
 
   static _populateList(listEl, items) {
     let fragment = document.createDocumentFragment();
     for (let item of items) {
       let row = new PaymentDetailsItem();
       row.label = item.label;
diff --git a/browser/components/places/PlacesUIUtils.jsm b/browser/components/places/PlacesUIUtils.jsm
--- a/browser/components/places/PlacesUIUtils.jsm
+++ b/browser/components/places/PlacesUIUtils.jsm
@@ -335,18 +335,18 @@ var PlacesUIUtils = {
 
     if (node.localName == "panelview" && node._placesView) {
       return node._placesView;
     }
 
     // The view for a <menu> of which its associated menupopup is a places
     // view, is the menupopup.
     if (node.localName == "menu" && !node._placesNode &&
-        node.lastChild._placesView)
-      return node.lastChild._placesView;
+        node.lastElementChild._placesView)
+      return node.lastElementChild._placesView;
 
     while (Element.isInstance(node)) {
       if (node._placesView)
         return node._placesView;
       if (node.localName == "tree" && node.getAttribute("type") == "places")
         return node;
 
       node = node.parentNode;
diff --git a/browser/components/places/content/browserPlacesViews.js b/browser/components/places/content/browserPlacesViews.js
--- a/browser/components/places/content/browserPlacesViews.js
+++ b/browser/components/places/content/browserPlacesViews.js
@@ -228,47 +228,47 @@ PlacesViewBase.prototype = {
     return this.controller.buildContextMenu(aPopup);
   },
 
   destroyContextMenu: function PVB_destroyContextMenu(aPopup) {
     this._contextMenuShown = null;
   },
 
   clearAllContents(aPopup) {
-    let kid = aPopup.firstChild;
+    let kid = aPopup.firstElementChild;
     while (kid) {
-      let next = kid.nextSibling;
+      let next = kid.nextElementSibling;
       if (!kid.classList.contains("panel-header")) {
         kid.remove();
       }
       kid = next;
     }
     aPopup._emptyMenuitem = aPopup._startMarker = aPopup._endMarker = null;
   },
 
   _cleanPopup: function PVB_cleanPopup(aPopup, aDelay) {
     // Ensure markers are here when `invalidateContainer` is called before the
     // popup is shown, which may the case for panelviews, for example.
     this._ensureMarkers(aPopup);
     // Remove Places nodes from the popup.
     let child = aPopup._startMarker;
-    while (child.nextSibling != aPopup._endMarker) {
-      let sibling = child.nextSibling;
+    while (child.nextElementSibling != aPopup._endMarker) {
+      let sibling = child.nextElementSibling;
       if (sibling._placesNode && !aDelay) {
         aPopup.removeChild(sibling);
       } else if (sibling._placesNode && aDelay) {
         // HACK (bug 733419): the popups originating from the OS X native
         // menubar don't live-update while open, thus we don't clean it
         // until the next popupshowing, to avoid zombie menuitems.
         if (!aPopup._delayedRemovals)
           aPopup._delayedRemovals = [];
         aPopup._delayedRemovals.push(sibling);
-        child = child.nextSibling;
+        child = child.nextElementSibling;
       } else {
-        child = child.nextSibling;
+        child = child.nextElementSibling;
       }
     }
   },
 
   _rebuildPopup: function PVB__rebuildPopup(aPopup) {
     let resultNode = aPopup._placesNode;
     if (!resultNode.containerOpen)
       return;
@@ -317,18 +317,18 @@ PlacesViewBase.prototype = {
       aPopup._emptyMenuitem.className = "bookmark-item";
       if (typeof this.options.extraClasses.entry == "string")
         aPopup._emptyMenuitem.classList.add(this.options.extraClasses.entry);
     }
 
     if (aEmpty) {
       aPopup.setAttribute("emptyplacesresult", "true");
       // Don't add the menuitem if there is static content.
-      if (!aPopup._startMarker.previousSibling &&
-          !aPopup._endMarker.nextSibling)
+      if (!aPopup._startMarker.previousElementSibling &&
+          !aPopup._endMarker.nextElementSibling)
         aPopup.insertBefore(aPopup._emptyMenuitem, aPopup._endMarker);
     } else {
       aPopup.removeAttribute("emptyplacesresult");
       try {
         aPopup.removeChild(aPopup._emptyMenuitem);
       } catch (ex) {}
     }
   },
@@ -480,18 +480,18 @@ PlacesViewBase.prototype = {
     }
 
     if (aStatus == Ci.mozILivemark.STATUS_LOADING ||
         aStatus == Ci.mozILivemark.STATUS_FAILED) {
       // Status has changed, update the cached status menuitem.
       let stringId = aStatus == Ci.mozILivemark.STATUS_LOADING ?
                        "bookmarksLivemarkLoading" : "bookmarksLivemarkFailed";
       statusMenuitem.setAttribute("label", PlacesUIUtils.getString(stringId));
-      if (aPopup._startMarker.nextSibling != statusMenuitem)
-        aPopup.insertBefore(statusMenuitem, aPopup._startMarker.nextSibling);
+      if (aPopup._startMarker.nextElementSibling != statusMenuitem)
+        aPopup.insertBefore(statusMenuitem, aPopup._startMarker.nextElementSibling);
     } else if (aPopup._statusMenuitem.parentNode == aPopup) {
       // The livemark has finished loading.
       aPopup.removeChild(aPopup._statusMenuitem);
     }
   },
 
   toggleCutNode: function PVB_toggleCutNode(aPlacesNode, aValue) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
@@ -592,30 +592,30 @@ PlacesViewBase.prototype = {
       elt = elt.parentNode;
 
     if (parentElt._built) {
       parentElt.removeChild(elt);
 
       // Figure out if we need to show the "<Empty>" menu-item.
       // TODO Bug 517701: This doesn't seem to handle the case of an empty
       // root.
-      if (parentElt._startMarker.nextSibling == parentElt._endMarker)
+      if (parentElt._startMarker.nextElementSibling == parentElt._endMarker)
         this._setEmptyPopupStatus(parentElt, true);
     }
   },
 
   nodeHistoryDetailsChanged:
   function PVB_nodeHistoryDetailsChanged(aPlacesNode, aTime, aCount) {
     if (aPlacesNode.parent &&
         this.controller.hasCachedLivemarkInfo(aPlacesNode.parent)) {
       // Find the node in the parent.
       let popup = this._getDOMNodeForPlacesNode(aPlacesNode.parent);
-      for (let child = popup._startMarker.nextSibling;
+      for (let child = popup._startMarker.nextElementSibling;
            child != popup._endMarker;
-           child = child.nextSibling) {
+           child = child.nextElementSibling) {
         if (child._placesNode && child._placesNode.uri == aPlacesNode.uri) {
           if (aPlacesNode.accessCount)
             child.setAttribute("visited", "true");
           else
             child.removeAttribute("visited");
           break;
         }
       }
@@ -630,20 +630,20 @@ PlacesViewBase.prototype = {
   batching() { },
 
   nodeInserted:
   function PVB_nodeInserted(aParentPlacesNode, aPlacesNode, aIndex) {
     let parentElt = this._getDOMNodeForPlacesNode(aParentPlacesNode);
     if (!parentElt._built)
       return;
 
-    let index = Array.prototype.indexOf.call(parentElt.childNodes, parentElt._startMarker) +
+    let index = Array.prototype.indexOf.call(parentElt.children, parentElt._startMarker) +
                 aIndex + 1;
     this._insertNewItemToPopup(aPlacesNode, parentElt,
-                               parentElt.childNodes[index] || parentElt._endMarker);
+                               parentElt.children[index] || parentElt._endMarker);
     this._setEmptyPopupStatus(parentElt, false);
   },
 
   nodeMoved:
   function PBV_nodeMoved(aPlacesNode,
                          aOldParentPlacesNode, aOldIndex,
                          aNewParentPlacesNode, aNewIndex) {
     // Note: the current implementation of moveItem does not actually
@@ -660,19 +660,19 @@ PlacesViewBase.prototype = {
     // we need to do in that case.
     if (elt == this._rootElt)
       return;
 
     let parentElt = this._getDOMNodeForPlacesNode(aNewParentPlacesNode);
     if (parentElt._built) {
       // Move the node.
       parentElt.removeChild(elt);
-      let index = Array.prototype.indexOf.call(parentElt.childNodes, parentElt._startMarker) +
+      let index = Array.prototype.indexOf.call(parentElt.children, parentElt._startMarker) +
                   aNewIndex + 1;
-      parentElt.insertBefore(elt, parentElt.childNodes[index]);
+      parentElt.insertBefore(elt, parentElt.children[index]);
     }
   },
 
   containerStateChanged:
   function PVB_containerStateChanged(aPlacesNode, aOldState, aNewState) {
     if (aNewState == Ci.nsINavHistoryContainerResultNode.STATE_OPENED ||
         aNewState == Ci.nsINavHistoryContainerResultNode.STATE_CLOSED) {
       this.invalidateContainer(aPlacesNode);
@@ -705,17 +705,17 @@ PlacesViewBase.prototype = {
           }, () => undefined);
       }
     }
   },
 
   _populateLivemarkPopup: function PVB__populateLivemarkPopup(aPopup) {
     this._setLivemarkSiteURIMenuItem(aPopup);
     // Show the loading status only if there are no entries yet.
-    if (aPopup._startMarker.nextSibling == aPopup._endMarker)
+    if (aPopup._startMarker.nextElementSibling == aPopup._endMarker)
       this._setLivemarkStatusMenuItem(aPopup, Ci.mozILivemark.STATUS_LOADING);
 
     PlacesUtils.livemarks.getLivemark({ id: aPopup._placesNode.itemId })
       .then(aLivemark => {
         let placesNode = aPopup._placesNode;
         if (!placesNode.containerOpen)
           return;
 
@@ -805,24 +805,24 @@ PlacesViewBase.prototype = {
       return;
 
     let hasMultipleURIs = false;
 
     // Check if the popup contains at least 2 menuitems with places nodes.
     // We don't currently support opening multiple uri nodes when they are not
     // populated by the result.
     if (aPopup._placesNode.childCount > 0) {
-      let currentChild = aPopup.firstChild;
+      let currentChild = aPopup.firstElementChild;
       let numURINodes = 0;
       while (currentChild) {
         if (currentChild.localName == "menuitem" && currentChild._placesNode) {
           if (++numURINodes == 2)
             break;
         }
-        currentChild = currentChild.nextSibling;
+        currentChild = currentChild.nextElementSibling;
       }
       hasMultipleURIs = numURINodes > 1;
     }
 
     let isLiveMark = false;
     if (this.controller.hasCachedLivemarkInfo(aPopup._placesNode)) {
       hasMultipleURIs = true;
       isLiveMark = true;
@@ -877,34 +877,34 @@ PlacesViewBase.prototype = {
 
   _ensureMarkers: function PVB__ensureMarkers(aPopup) {
     if (aPopup._startMarker)
       return;
 
     // _startMarker is an hidden menuseparator that lives before places nodes.
     aPopup._startMarker = document.createElement("menuseparator");
     aPopup._startMarker.hidden = true;
-    aPopup.insertBefore(aPopup._startMarker, aPopup.firstChild);
+    aPopup.insertBefore(aPopup._startMarker, aPopup.firstElementChild);
 
     // _endMarker is a DOM node that lives after places nodes, specified with
     // the 'insertionPoint' option or will be a hidden menuseparator.
     let node = this.options.insertionPoint ?
                aPopup.querySelector(this.options.insertionPoint) : null;
     if (node) {
       aPopup._endMarker = node;
     } else {
       aPopup._endMarker = document.createElement("menuseparator");
       aPopup._endMarker.hidden = true;
     }
     aPopup.appendChild(aPopup._endMarker);
 
     // Move the markers to the right position.
     let firstNonStaticNodeFound = false;
-    for (let i = 0; i < aPopup.childNodes.length; i++) {
-      let child = aPopup.childNodes[i];
+    for (let i = 0; i < aPopup.children.length; i++) {
+      let child = aPopup.children[i];
       // Menus that have static content at the end, but are initially empty,
       // use a special "builder" attribute to figure out where to start
       // inserting places nodes.
       if (child.getAttribute("builder") == "end") {
         aPopup.insertBefore(aPopup._endMarker, child);
         break;
       }
 
@@ -1038,17 +1038,17 @@ PlacesToolbar.prototype = {
   async _rebuild() {
     // Clear out references to existing nodes, since they will be removed
     // and re-added.
     if (this._overFolder.elt)
       this._clearOverFolder();
 
     this._openedMenuButton = null;
     while (this._rootElt.hasChildNodes()) {
-      this._rootElt.firstChild.remove();
+      this._rootElt.firstElementChild.remove();
     }
 
     let cc = this._resultNode.childCount;
     if (cc > 0) {
       // There could be a lot of nodes, but we only want to build the ones that
       // are more likely to be shown, not all of them.
       // We also don't want to wait for reflows at every node insertion, to
       // calculate a precise number of visible items, thus we guess a size from
@@ -1153,20 +1153,20 @@ PlacesToolbar.prototype = {
     else
       aInsertionNode.appendChild(button);
     return button;
   },
 
   _updateChevronPopupNodesVisibility:
   function PT__updateChevronPopupNodesVisibility() {
     // Note the toolbar by default builds less nodes than the chevron popup.
-    for (let toolbarNode = this._rootElt.firstChild,
-         node = this._chevronPopup._startMarker.nextSibling;
+    for (let toolbarNode = this._rootElt.firstElementChild,
+         node = this._chevronPopup._startMarker.nextElementSibling;
          toolbarNode && node;
-         toolbarNode = toolbarNode.nextSibling, node = node.nextSibling) {
+         toolbarNode = toolbarNode.nextElementSibling, node = node.nextElementSibling) {
       node.hidden = toolbarNode.style.visibility != "hidden";
     }
   },
 
   _onChevronPopupShowing:
   function PT__onChevronPopupShowing(aEvent) {
     // Handle popupshowing only for the chevron popup, not for nested ones.
     if (aEvent.target != this._chevronPopup)
@@ -1287,17 +1287,17 @@ PlacesToolbar.prototype = {
 
     let childOverflowed = false;
 
     // We're about to potentially update a bunch of nodes, so we do it
     // in a requestAnimationFrame so that other JS that's might execute
     // in the same tick can avoid flushing styles and layout for these
     // changes.
     window.requestAnimationFrame(() => {
-      for (let child of this._rootElt.childNodes) {
+      for (let child of this._rootElt.children) {
         // Once a child overflows, all the next ones will.
         if (!childOverflowed) {
           let childRect = dwu.getBoundsWithoutFlushing(child);
           childOverflowed = this.isRTL ? (childRect.left < scrollRect.left)
                                        : (childRect.right > scrollRect.right);
         }
 
         if (childOverflowed) {
@@ -1323,32 +1323,32 @@ PlacesToolbar.prototype = {
 
     this._updatingNodesVisibility = false;
   },
 
   nodeInserted:
   function PT_nodeInserted(aParentPlacesNode, aPlacesNode, aIndex) {
     let parentElt = this._getDOMNodeForPlacesNode(aParentPlacesNode);
     if (parentElt == this._rootElt) { // Node is on the toolbar.
-      let children = this._rootElt.childNodes;
+      let children = this._rootElt.children;
       // Nothing to do if it's a never-visible node, but note it's possible
       // we are appending.
       if (aIndex > children.length)
         return;
 
       // Note that childCount is already accounting for the node being added,
       // thus we must subtract one node from it.
       if (this._resultNode.childCount - 1 > children.length) {
         if (aIndex == children.length) {
           // If we didn't build all the nodes and new node is being appended,
           // we can skip it as well.
           return;
         }
         // Keep the number of built nodes consistent.
-        this._rootElt.removeChild(this._rootElt.lastChild);
+        this._rootElt.removeChild(this._rootElt.lastElementChild);
       }
 
       let button = this._insertNewItem(aPlacesNode, this._rootElt,
                                        children[aIndex] || null);
       let prevSiblingOverflowed = aIndex > 0 && aIndex <= children.length &&
                                   children[aIndex - 1].style.visibility == "hidden";
       if (prevSiblingOverflowed) {
         button.style.visibility = "hidden";
@@ -1374,19 +1374,19 @@ PlacesToolbar.prototype = {
         return;
 
       // Here we need the <menu>.
       if (elt.localName == "menupopup")
         elt = elt.parentNode;
 
       let overflowed = elt.style.visibility == "hidden";
       this._removeChild(elt);
-      if (this._resultNode.childCount > this._rootElt.childNodes.length) {
+      if (this._resultNode.childCount > this._rootElt.children.length) {
         // A new node should be built to keep a coherent number of children.
-        this._insertNewItem(this._resultNode.getChild(this._rootElt.childNodes.length),
+        this._insertNewItem(this._resultNode.getChild(this._rootElt.children.length),
                             this._rootElt);
       }
       if (!overflowed)
         this.updateNodesVisibility();
       return;
     }
 
     PlacesViewBase.prototype.nodeRemoved.apply(this, arguments);
@@ -1394,46 +1394,46 @@ PlacesToolbar.prototype = {
 
   nodeMoved:
   function PT_nodeMoved(aPlacesNode,
                         aOldParentPlacesNode, aOldIndex,
                         aNewParentPlacesNode, aNewIndex) {
     let parentElt = this._getDOMNodeForPlacesNode(aNewParentPlacesNode);
     if (parentElt == this._rootElt) { // Node is on the toolbar.
       // Do nothing if the node will never be visible.
-      let lastBuiltIndex = this._rootElt.childNodes.length - 1;
+      let lastBuiltIndex = this._rootElt.children.length - 1;
       if (aOldIndex > lastBuiltIndex && aNewIndex > lastBuiltIndex + 1)
         return;
 
       let elt = this._getDOMNodeForPlacesNode(aPlacesNode, true);
       if (elt) {
         // Here we need the <menu>.
         if (elt.localName == "menupopup")
           elt = elt.parentNode;
         this._removeChild(elt);
       }
 
       if (aNewIndex > lastBuiltIndex + 1) {
-        if (this._resultNode.childCount > this._rootElt.childNodes.length) {
+        if (this._resultNode.childCount > this._rootElt.children.length) {
           // If the element was built and becomes non built, another node should
           // be built to keep a coherent number of children.
-          this._insertNewItem(this._resultNode.getChild(this._rootElt.childNodes.length),
+          this._insertNewItem(this._resultNode.getChild(this._rootElt.children.length),
                               this._rootElt);
         }
         return;
       }
 
       if (!elt) {
         // The node has not been inserted yet, so we must create it.
-        elt = this._insertNewItem(aPlacesNode, this._rootElt, this._rootElt.childNodes[aNewIndex]);
+        elt = this._insertNewItem(aPlacesNode, this._rootElt, this._rootElt.children[aNewIndex]);
         let icon = aPlacesNode.icon;
         if (icon)
           elt.setAttribute("image", icon);
       } else {
-        this._rootElt.insertBefore(elt, this._rootElt.childNodes[aNewIndex]);
+        this._rootElt.insertBefore(elt, this._rootElt.children[aNewIndex]);
       }
 
       // The chevron view may get nodeMoved after the toolbar.  In such a case,
       // we should ensure (by manually swapping menuitems) that the actual nodes
       // are in the final position before updateNodesVisibility tries to update
       // their visibility, or the chevron may go out of sync.
       // Luckily updateNodesVisibility runs on a timer, so, by the time it updates
       // nodes, the menu has already handled the notification.
@@ -1511,19 +1511,19 @@ PlacesToolbar.prototype = {
                  openTimer: null,
                  hoverTime: 350,
                  closeTimer: null },
 
   _clearOverFolder: function PT__clearOverFolder() {
     // The mouse is no longer dragging over the stored menubutton.
     // Close the menubutton, clear out drag styles, and clear all
     // timers for opening/closing it.
-    if (this._overFolder.elt && this._overFolder.elt.lastChild) {
-      if (!this._overFolder.elt.lastChild.hasAttribute("dragover")) {
-        this._overFolder.elt.lastChild.hidePopup();
+    if (this._overFolder.elt && this._overFolder.elt.lastElementChild) {
+      if (!this._overFolder.elt.lastElementChild.hasAttribute("dragover")) {
+        this._overFolder.elt.lastElementChild.hidePopup();
       }
       this._overFolder.elt.removeAttribute("dragover");
       this._overFolder.elt = null;
     }
     if (this._overFolder.openTimer) {
       this._overFolder.openTimer.cancel();
       this._overFolder.openTimer = null;
     }
@@ -1544,17 +1544,17 @@ PlacesToolbar.prototype = {
     if (!PlacesUtils.nodeIsFolder(this._resultNode))
       return null;
 
     let dropPoint = { ip: null, beforeIndex: null, folderElt: null };
     let elt = aEvent.target;
     if (elt._placesNode && elt != this._rootElt &&
         elt.localName != "menupopup") {
       let eltRect = elt.getBoundingClientRect();
-      let eltIndex = Array.prototype.indexOf.call(this._rootElt.childNodes, elt);
+      let eltIndex = Array.prototype.indexOf.call(this._rootElt.children, elt);
       if (PlacesUtils.nodeIsFolder(elt._placesNode) &&
           !PlacesUIUtils.isFolderReadOnly(elt._placesNode, this)) {
         // This is a folder.
         // If we are in the middle of it, drop inside it.
         // Otherwise, drop before it, with regards to RTL mode.
         let threshold = eltRect.width * 0.25;
         if (this.isRTL ? (aEvent.clientX > eltRect.right - threshold)
                        : (aEvent.clientX < eltRect.left + threshold)) {
@@ -1578,17 +1578,17 @@ PlacesToolbar.prototype = {
               parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),
               tagName
             });
           dropPoint.beforeIndex = eltIndex;
           dropPoint.folderElt = elt;
         } else {
           // Drop after this folder.
           let beforeIndex =
-            (eltIndex == this._rootElt.childNodes.length - 1) ?
+            (eltIndex == this._rootElt.children.length - 1) ?
             -1 : eltIndex + 1;
 
           dropPoint.ip =
             new PlacesInsertionPoint({
               parentId: PlacesUtils.getConcreteItemId(this._resultNode),
               parentGuid: PlacesUtils.getConcreteItemGuid(this._resultNode),
               index: beforeIndex,
               orientation: Ci.nsITreeView.DROP_BEFORE
@@ -1608,17 +1608,17 @@ PlacesToolbar.prototype = {
               parentGuid: PlacesUtils.getConcreteItemGuid(this._resultNode),
               index: eltIndex,
               orientation: Ci.nsITreeView.DROP_BEFORE
             });
           dropPoint.beforeIndex = eltIndex;
         } else {
           // Drop after this bookmark.
           let beforeIndex =
-            eltIndex == this._rootElt.childNodes.length - 1 ?
+            eltIndex == this._rootElt.children.length - 1 ?
             -1 : eltIndex + 1;
           dropPoint.ip =
             new PlacesInsertionPoint({
               parentId: PlacesUtils.getConcreteItemId(this._resultNode),
               parentGuid: PlacesUtils.getConcreteItemGuid(this._resultNode),
               index: beforeIndex,
               orientation: Ci.nsITreeView.DROP_BEFORE
             });
@@ -1653,17 +1653,17 @@ PlacesToolbar.prototype = {
     } else if (aTimer == this._ibTimer) {
       // * Timer to turn off indicator bar.
       this._dropIndicator.collapsed = true;
       this._ibTimer = null;
     } else if (aTimer == this._overFolder.openTimer) {
       // * Timer to open a menubutton that's being dragged over.
       // Set the autoopen attribute on the folder's menupopup so that
       // the menu will automatically close when the mouse drags off of it.
-      this._overFolder.elt.lastChild.setAttribute("autoopened", "true");
+      this._overFolder.elt.lastElementChild.setAttribute("autoopened", "true");
       this._overFolder.elt.open = true;
       this._overFolder.openTimer = null;
     } else if (aTimer == this._overFolder.closeTimer) {
       // * Timer to close a menubutton that's been dragged off of.
       // Close the menubutton if we are not dragging over it or one of
       // its children.  The autoopened attribute will let the menu know to
       // close later if the menu is still being dragged over.
       let currentPlacesNode = PlacesControllerDragHelper.currentDropTarget;
@@ -1723,17 +1723,17 @@ PlacesToolbar.prototype = {
         aEvent.preventDefault();
         // Open the menu.
         draggedElt.open = true;
         return;
       }
 
       // If the menu is open, close it.
       if (draggedElt.open) {
-        draggedElt.lastChild.hidePopup();
+        draggedElt.lastElementChild.hidePopup();
         draggedElt.open = false;
       }
     }
 
     // Activate the view and cache the dragged element.
     this._draggedElt = draggedElt._placesNode;
     this._rootElt.focus();
 
@@ -1777,33 +1777,33 @@ PlacesToolbar.prototype = {
       // show indicator bar and move it to the appropriate drop point.
       let ind = this._dropIndicator;
       ind.parentNode.collapsed = false;
       let halfInd = ind.clientWidth / 2;
       let translateX;
       if (this.isRTL) {
         halfInd = Math.ceil(halfInd);
         translateX = 0 - this._rootElt.getBoundingClientRect().right - halfInd;
-        if (this._rootElt.firstChild) {
+        if (this._rootElt.firstElementChild) {
           if (dropPoint.beforeIndex == -1)
-            translateX += this._rootElt.lastChild.getBoundingClientRect().left;
+            translateX += this._rootElt.lastElementChild.getBoundingClientRect().left;
           else {
-            translateX += this._rootElt.childNodes[dropPoint.beforeIndex]
+            translateX += this._rootElt.children[dropPoint.beforeIndex]
                               .getBoundingClientRect().right;
           }
         }
       } else {
         halfInd = Math.floor(halfInd);
         translateX = 0 - this._rootElt.getBoundingClientRect().left +
                      halfInd;
-        if (this._rootElt.firstChild) {
+        if (this._rootElt.firstElementChild) {
           if (dropPoint.beforeIndex == -1)
-            translateX += this._rootElt.lastChild.getBoundingClientRect().right;
+            translateX += this._rootElt.lastElementChild.getBoundingClientRect().right;
           else {
-            translateX += this._rootElt.childNodes[dropPoint.beforeIndex]
+            translateX += this._rootElt.children[dropPoint.beforeIndex]
                               .getBoundingClientRect().left;
           }
         }
       }
 
       ind.style.transform = "translate(" + Math.round(translateX) + "px)";
       ind.style.marginInlineStart = (-ind.clientWidth) + "px";
       ind.collapsed = false;
@@ -2048,17 +2048,17 @@ PlacesPanelMenuView.prototype = {
   },
 
   nodeInserted:
   function PAMV_nodeInserted(aParentPlacesNode, aPlacesNode, aIndex) {
     let parentElt = this._getDOMNodeForPlacesNode(aParentPlacesNode);
     if (parentElt != this._rootElt)
       return;
 
-    let children = this._rootElt.childNodes;
+    let children = this._rootElt.children;
     this._insertNewItem(aPlacesNode, this._rootElt,
       aIndex < children.length ? children[aIndex] : null);
   },
 
   nodeRemoved:
   function PAMV_nodeRemoved(aParentPlacesNode, aPlacesNode, aIndex) {
     let parentElt = this._getDOMNodeForPlacesNode(aParentPlacesNode);
     if (parentElt != this._rootElt)
@@ -2073,17 +2073,17 @@ PlacesPanelMenuView.prototype = {
                           aOldParentPlacesNode, aOldIndex,
                           aNewParentPlacesNode, aNewIndex) {
     let parentElt = this._getDOMNodeForPlacesNode(aNewParentPlacesNode);
     if (parentElt != this._rootElt)
       return;
 
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     this._removeChild(elt);
-    this._rootElt.insertBefore(elt, this._rootElt.childNodes[aNewIndex]);
+    this._rootElt.insertBefore(elt, this._rootElt.children[aNewIndex]);
   },
 
   nodeAnnotationChanged:
   function PAMV_nodeAnnotationChanged(aPlacesNode, aAnno) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     // There's no UI representation for the root node.
     if (elt == this._rootElt)
       return;
@@ -2115,17 +2115,17 @@ PlacesPanelMenuView.prototype = {
 
   invalidateContainer: function PAMV_invalidateContainer(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     if (elt != this._rootElt)
       return;
 
     // Container is the toolbar itself.
     while (this._rootElt.hasChildNodes()) {
-      this._rootElt.firstChild.remove();
+      this._rootElt.firstElementChild.remove();
     }
 
     let fragment = document.createDocumentFragment();
     for (let i = 0; i < this._resultNode.childCount; ++i) {
       this._insertNewItem(this._resultNode.getChild(i), fragment);
     }
     this._rootElt.appendChild(fragment);
   }
@@ -2265,17 +2265,17 @@ this.PlacesPanelview = class extends Pla
     }
 
     if (empty) {
       panelview.setAttribute("emptyplacesresult", "true");
       // Don't add the menuitem if there is static content.
       // We also support external usage for custom crafted panels - which'll have
       // no markers present.
       if (!panelview._startMarker ||
-          (!panelview._startMarker.previousSibling && !panelview._endMarker.nextSibling)) {
+          (!panelview._startMarker.previousElementSibling && !panelview._endMarker.nextElementSibling)) {
         panelview.insertBefore(panelview._emptyMenuitem, panelview._endMarker);
       }
     } else {
       panelview.removeAttribute("emptyplacesresult");
       try {
         panelview.removeChild(panelview._emptyMenuitem);
       } catch (ex) {}
     }
diff --git a/browser/components/places/content/controller.js b/browser/components/places/content/controller.js
--- a/browser/components/places/content/controller.js
+++ b/browser/components/places/content/controller.js
@@ -559,18 +559,18 @@ PlacesController.prototype = {
   buildContextMenu: function PC_buildContextMenu(aPopup) {
     var metadata = this._buildSelectionMetadata();
     var ip = this._view.insertionPoint;
     var noIp = !ip || ip.isTag;
 
     var separator = null;
     var visibleItemsBeforeSep = false;
     var usableItemCount = 0;
-    for (var i = 0; i < aPopup.childNodes.length; ++i) {
-      var item = aPopup.childNodes[i];
+    for (var i = 0; i < aPopup.children.length; ++i) {
+      var item = aPopup.children[i];
       if (item.getAttribute("ignoreitem") == "true") {
         continue;
       }
       if (item.localName != "menuseparator") {
         // We allow pasting into tag containers, so special case that.
         var hideIfNoIP = item.getAttribute("hideifnoinsertionpoint") == "true" &&
                          noIp && !(ip && ip.isTag && item.id == "placesContext_paste");
         var hideIfPrivate = item.getAttribute("hideifprivatebrowsing") == "true" &&
diff --git a/browser/components/places/content/editBookmark.js b/browser/components/places/content/editBookmark.js
--- a/browser/components/places/content/editBookmark.js
+++ b/browser/components/places/content/editBookmark.js
@@ -355,18 +355,18 @@ var gEditItemOverlay = {
     folderMenuItem.className = "menuitem-iconic folder-icon";
     aMenupopup.appendChild(folderMenuItem);
     return folderMenuItem;
   },
 
   async _initFolderMenuList(aSelectedFolderGuid) {
     // clean up first
     var menupopup = this._folderMenuList.menupopup;
-    while (menupopup.childNodes.length > 6)
-      menupopup.removeChild(menupopup.lastChild);
+    while (menupopup.children.length > 6)
+      menupopup.removeChild(menupopup.lastElementChild);
 
     // Build the static list
     if (!this._staticFoldersListBuilt) {
       let unfiledItem = this._element("unfiledRootItem");
       unfiledItem.label = PlacesUtils.getString("OtherBookmarksFolderTitle");
       unfiledItem.folderGuid = PlacesUtils.bookmarks.unfiledGuid;
       let bmMenuItem = this._element("bmRootItem");
       bmMenuItem.label = PlacesUtils.getString("BookmarksMenuFolderTitle");
@@ -409,17 +409,17 @@ var gEditItemOverlay = {
     var defaultItem = this._getFolderMenuItem(aSelectedFolderGuid, title);
     this._folderMenuList.selectedItem = defaultItem;
 
     // Set a selectedIndex attribute to show special icons
     this._folderMenuList.setAttribute("selectedIndex",
                                       this._folderMenuList.selectedIndex);
 
     // Hide the folders-separator if no folder is annotated as recently-used
-    this._element("foldersSeparator").hidden = (menupopup.childNodes.length <= 6);
+    this._element("foldersSeparator").hidden = (menupopup.children.length <= 6);
     this._folderMenuList.disabled = this.readOnly;
   },
 
   QueryInterface:
   ChromeUtils.generateQI([Ci.nsINavBookmarkObserver]),
 
   _element(aID) {
     return document.getElementById("editBMPanel_" + aID);
@@ -659,23 +659,23 @@ var gEditItemOverlay = {
    *        The identifier of the bookmarks folder.
    * @param aTitle
    *        The title to use in case of menuitem creation.
    * @return handle to the menuitem.
    */
   _getFolderMenuItem(aFolderGuid, aTitle) {
     let menupopup = this._folderMenuList.menupopup;
     let menuItem = Array.prototype.find.call(
-      menupopup.childNodes, item => item.folderGuid === aFolderGuid);
+      menupopup.children, item => item.folderGuid === aFolderGuid);
     if (menuItem !== undefined)
       return menuItem;
 
     // 3 special folders + separator + folder-items-count limit
-    if (menupopup.childNodes.length == 4 + MAX_FOLDER_ITEM_IN_MENU_LIST)
-      menupopup.removeChild(menupopup.lastChild);
+    if (menupopup.children.length == 4 + MAX_FOLDER_ITEM_IN_MENU_LIST)
+      menupopup.removeChild(menupopup.lastElementChild);
 
     return this._appendFolderItemToMenupopup(menupopup, aFolderGuid, aTitle);
   },
 
   async onFolderMenuListCommand(aEvent) {
     // Check for _paneInfo existing as the dialog may be closing but receiving
     // async updates from unresolved promises.
     if (!this._paneInfo) {
@@ -747,17 +747,17 @@ var gEditItemOverlay = {
     if (tagsSelectorRow.collapsed)
       return;
 
     let selectedIndex = tagsSelector.selectedIndex;
     let selectedTag = selectedIndex >= 0 ? tagsSelector.selectedItem.label
                                          : null;
 
     while (tagsSelector.hasChildNodes()) {
-      tagsSelector.removeChild(tagsSelector.lastChild);
+      tagsSelector.removeChild(tagsSelector.lastElementChild);
     }
 
     let tagsInField = this._getTagsArrayFromTagsInputField();
     let allTags = await PlacesUtils.bookmarks.fetchTags();
     let fragment = document.createDocumentFragment();
     for (let i = 0; i < allTags.length; i++) {
       let tag = allTags[i].name;
       let elt = document.createElement("richlistitem");
@@ -945,17 +945,17 @@ var gEditItemOverlay = {
     if (aItemId == this._paneInfo.itemId || aGuid == this._paneInfo.itemGuid) {
       this._paneInfo.title = aNewTitle;
       this._initTextField(this._namePicker, aNewTitle);
     } else if (this._paneInfo.visibleRows.has("folderRow")) {
       // If the title of a folder which is listed within the folders
       // menulist has been changed, we need to update the label of its
       // representing element.
       let menupopup = this._folderMenuList.menupopup;
-      for (let menuitem of menupopup.childNodes) {
+      for (let menuitem of menupopup.children) {
         if ("folderGuid" in menuitem && menuitem.folderGuid == aGuid) {
           menuitem.label = aNewTitle;
           break;
         }
       }
     }
     // We need to also update title of recent folders.
     if (this._recentFolders) {
diff --git a/browser/components/places/content/places.js b/browser/components/places/content/places.js
--- a/browser/components/places/content/places.js
+++ b/browser/components/places/content/places.js
@@ -446,18 +446,18 @@ var PlacesOrganizer = {
     let restorePopup = document.getElementById("fileRestorePopup");
 
     const dtOptions = {
       dateStyle: "long"
     };
     let dateFormatter = new Services.intl.DateTimeFormat(undefined, dtOptions);
 
     // Remove existing menu items.  Last item is the restoreFromFile item.
-    while (restorePopup.childNodes.length > 1)
-      restorePopup.firstChild.remove();
+    while (restorePopup.children.length > 1)
+      restorePopup.firstElementChild.remove();
 
     (async function() {
       let backupFiles = await PlacesBackups.getBackupFiles();
       if (backupFiles.length == 0)
         return;
 
       // Populate menu with backups.
       for (let i = 0; i < backupFiles.length; i++) {
@@ -919,22 +919,22 @@ var ViewMenu = {
       var endElement = null;
       if (endID) {
         endElement = document.getElementById(endID);
         if (endElement.parentNode != popup)
           throw new Error("endElement is not in popup");
         if (!endElement)
           throw new Error("endID does not correspond to an existing element");
       }
-      while (startElement.nextSibling != endElement)
-        popup.removeChild(startElement.nextSibling);
+      while (startElement.nextElementSibling != endElement)
+        popup.removeChild(startElement.nextElementSibling);
       return endElement;
     }
     while (popup.hasChildNodes()) {
-      popup.firstChild.remove();
+      popup.firstElementChild.remove();
     }
     return null;
   },
 
   /**
    * Fills a menupopup with a list of columns
    * @param   event
    *          The popupshowing event that invoked this function.
@@ -1032,17 +1032,17 @@ var ViewMenu = {
   /**
    * Shows/Hides a tree column.
    * @param   element
    *          The menuitem element for the column
    */
   showHideColumn: function VM_showHideColumn(element) {
     var column = element.column;
 
-    var splitter = column.nextSibling;
+    var splitter = column.nextElementSibling;
     if (splitter && splitter.localName != "splitter")
       splitter = null;
 
     if (element.getAttribute("checked") == "true") {
       column.setAttribute("hidden", "false");
       if (splitter)
         splitter.removeAttribute("hidden");
     } else {
@@ -1224,20 +1224,20 @@ var ContentArea = {
   _setupView: function CA__setupView() {
     let options = this.currentViewOptions;
 
     // showDetailsPane.
     let detailsDeck = document.getElementById("detailsDeck");
     detailsDeck.hidden = !options.showDetailsPane;
 
     // toolbarSet.
-    for (let elt of this._toolbar.childNodes) {
+    for (let elt of this._toolbar.children) {
       // On Windows and Linux the menu buttons are menus wrapped in a menubar.
       if (elt.id == "placesMenu") {
-        for (let menuElt of elt.childNodes) {
+        for (let menuElt of elt.children) {
           menuElt.hidden = !options.toolbarSet.includes(menuElt.id);
         }
       } else {
         elt.hidden = !options.toolbarSet.includes(elt.id);
       }
     }
   },
 
diff --git a/browser/components/places/tests/browser/browser_bookmarks_change_title.js b/browser/components/places/tests/browser/browser_bookmarks_change_title.js
--- a/browser/components/places/tests/browser/browser_bookmarks_change_title.js
+++ b/browser/components/places/tests/browser/browser_bookmarks_change_title.js
@@ -2,17 +2,17 @@
  * Tests that the title of a bookmark can be changed from the bookmark star, toolbar, and sidebar.
  */
 "use strict";
 
 const TEST_URL = "about:buildconfig";
 const titleAfterFirstUpdate = "BookmarkStar title";
 
 function getToolbarNodeForItemGuid(aItemGuid) {
-  var children = document.getElementById("PlacesToolbarItems").childNodes;
+  var children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (aItemGuid == child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js b/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
--- a/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
+++ b/browser/components/places/tests/browser/browser_bug631374_tags_selector_scroll.js
@@ -75,30 +75,30 @@ add_task(async function() {
     let scrollTop = tagsSelector.scrollTop;
 
     ok(listItem.hasAttribute("checked"), "Item is checked " + i);
     let selectedTag = listItem.label;
 
     // Uncheck the tag.
     let promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                                 "BookmarkTagsSelectorUpdated");
-    EventUtils.synthesizeMouseAtCenter(listItem.firstChild, {});
+    EventUtils.synthesizeMouseAtCenter(listItem.firstElementChild, {});
     await promise;
     is(scrollTop, tagsSelector.scrollTop, "Scroll position did not change");
 
     // The listbox is rebuilt, so we have to get the new element.
     let newItem = tagsSelector.selectedItem;
     isnot(newItem, null, "Valid new listItem found");
     ok(!newItem.hasAttribute("checked"), "New listItem is unchecked " + i);
     is(newItem.label, selectedTag, "Correct tag is still selected");
 
     // Check the tag.
     promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                             "BookmarkTagsSelectorUpdated");
-    EventUtils.synthesizeMouseAtCenter(newItem.firstChild, {});
+    EventUtils.synthesizeMouseAtCenter(newItem.firstElementChild, {});
     await promise;
     is(scrollTop, tagsSelector.scrollTop, "Scroll position did not change");
   }
 
   // Remove the second bookmark, then nuke some of the tags.
   await PlacesUtils.bookmarks.remove(bm2);
 
   // Doing this backwords tests more interesting paths.
@@ -111,17 +111,17 @@ add_task(async function() {
     let items = [...tagsSelector.children];
     let topTag = items.find(e => scrolledIntoView(e, tagsSelector)).label;
 
     ok(listItem.hasAttribute("checked"), "Item is checked " + i);
 
     // Uncheck the tag.
     let promise = BrowserTestUtils.waitForEvent(tagsSelector,
                                                 "BookmarkTagsSelectorUpdated");
-    EventUtils.synthesizeMouseAtCenter(listItem.firstChild, {});
+    EventUtils.synthesizeMouseAtCenter(listItem.firstElementChild, {});
     await promise;
 
     // The listbox is rebuilt, so we have to get the new element.
     let topItem = [...tagsSelector.children].find(e => e.label == topTag);
     ok(scrolledIntoView(topItem, tagsSelector), "Scroll position is correct");
 
     let newItem = tagsSelector.selectedItem;
     isnot(newItem, null, "Valid new listItem found");
diff --git a/browser/components/places/tests/browser/browser_check_correct_controllers.js b/browser/components/places/tests/browser/browser_check_correct_controllers.js
--- a/browser/components/places/tests/browser/browser_check_correct_controllers.js
+++ b/browser/components/places/tests/browser/browser_check_correct_controllers.js
@@ -37,17 +37,17 @@ add_task(async function test() {
   let controller = PlacesUIUtils.getControllerForCommand(window, "placesCmd_copy");
   let treeController = tree.controllers
                            .getControllerForCommand("placesCmd_copy");
   ok(controller == treeController, "tree controller was returned");
 
   // Open the context menu for a toolbar item, and check if the toolbar's
   // controller is returned.
   let toolbarItems = document.getElementById("PlacesToolbarItems");
-  EventUtils.synthesizeMouse(toolbarItems.childNodes[0],
+  EventUtils.synthesizeMouse(toolbarItems.children[0],
                              4, 4, { type: "contextmenu", button: 2 },
                              window);
   controller = PlacesUIUtils.getControllerForCommand(window, "placesCmd_copy");
   let toolbarController = document.getElementById("PlacesToolbar")
                                   .controllers
                                   .getControllerForCommand("placesCmd_copy");
   ok(controller == toolbarController, "the toolbar controller was returned");
 
diff --git a/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js b/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js
--- a/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js
+++ b/browser/components/places/tests/browser/browser_click_bookmarks_on_toolbar.js
@@ -3,17 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const PREF_LOAD_BOOKMARKS_IN_TABS = "browser.tabs.loadBookmarksInTabs";
 const TEST_PAGES = ["about:mozilla", "about:robots"];
 
 var gBookmarkElements = [];
 
 function getToolbarNodeForItemGuid(aItemGuid) {
-  var children = document.getElementById("PlacesToolbarItems").childNodes;
+  var children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (aItemGuid == child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js b/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js
--- a/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js
+++ b/browser/components/places/tests/browser/browser_drag_bookmarks_on_toolbar.js
@@ -110,17 +110,17 @@ function synthesizeDragWithDirection(aEl
                              startingPoint.x + xIncrement * 9,
                              startingPoint.y + yIncrement * 9,
                              { type: "mousemove" });
 
   return promise;
 }
 
 function getToolbarNodeForItemId(itemGuid) {
-  var children = document.getElementById("PlacesToolbarItems").childNodes;
+  var children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (itemGuid == child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js b/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js
--- a/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js
+++ b/browser/components/places/tests/browser/browser_editBookmark_tags_liveUpdate.js
@@ -1,15 +1,15 @@
 "use strict";
 
 async function checkTagsSelector(aAvailableTags, aCheckedTags) {
   let tags = await PlacesUtils.bookmarks.fetchTags();
   is(tags.length, aAvailableTags.length, "Check tags list");
   let tagsSelector = document.getElementById("editBMPanel_tagsSelector");
-  let children = tagsSelector.childNodes;
+  let children = tagsSelector.children;
   is(children.length, aAvailableTags.length,
       "Found expected number of tags in the tags selector");
 
   Array.prototype.forEach.call(children, function(aChild) {
     let tag = aChild.querySelector("label").getAttribute("value");
     ok(true, "Found tag '" + tag + "' in the selector");
     ok(aAvailableTags.includes(tag), "Found expected tag");
     let checked = aChild.getAttribute("checked") == "true";
diff --git a/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js b/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js
--- a/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js
+++ b/browser/components/places/tests/browser/browser_panelview_bookmarks_delete.js
@@ -26,17 +26,17 @@ add_task(async function test_panelview_b
   await promise;
 
   let bookmarksView = document.getElementById("PanelUI-bookmarks");
   promise = BrowserTestUtils.waitForEvent(bookmarksView, "ViewShown");
   document.getElementById("appMenu-library-bookmarks-button").click();
   await promise;
 
   let list = document.getElementById("panelMenu_bookmarksMenu");
-  let listItem = [...list.childNodes].find(node => node.label == TEST_URL);
+  let listItem = [...list.children].find(node => node.label == TEST_URL);
 
   let placesContext = document.getElementById("placesContext");
   promise = BrowserTestUtils.waitForEvent(placesContext, "popupshown");
   EventUtils.synthesizeMouseAtCenter(listItem, {
     button: 2,
     type: "contextmenu"
   });
   await promise;
diff --git a/browser/components/places/tests/browser/browser_sidebarpanels_click.js b/browser/components/places/tests/browser/browser_sidebarpanels_click.js
--- a/browser/components/places/tests/browser/browser_sidebarpanels_click.js
+++ b/browser/components/places/tests/browser/browser_sidebarpanels_click.js
@@ -86,17 +86,17 @@ add_task(async function test_sidebarpane
 
     await testPlacesPanel(test, () => {
       changeSidebarDirection("rtl");
       info("Running " + test.desc + " in RTL mode");
     });
 
     // Remove tabs created by sub-tests.
     while (gBrowser.tabs.length > 1) {
-      gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+      gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
     }
   }
 });
 
 async function testPlacesPanel(testInfo, preFunc) {
   await testInfo.init();
 
   let promise = new Promise(resolve => {
diff --git a/browser/components/places/tests/browser/browser_stayopenmenu.js b/browser/components/places/tests/browser/browser_stayopenmenu.js
--- a/browser/components/places/tests/browser/browser_stayopenmenu.js
+++ b/browser/components/places/tests/browser/browser_stayopenmenu.js
@@ -1,16 +1,16 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Menus should stay open (if pref is set) after ctrl-click, middle-click,
 // and contextmenu's "Open in a new tab" click.
 
 async function locateBookmarkAndTestCtrlClick(menupopup) {
-  let testMenuitem = [...menupopup.childNodes].find(node => node.label == "Test1");
+  let testMenuitem = [...menupopup.children].find(node => node.label == "Test1");
   ok(testMenuitem, "Found test bookmark.");
   let promiseTabOpened = BrowserTestUtils.waitForNewTab(gBrowser, null);
   EventUtils.synthesizeMouseAtCenter(testMenuitem, {accelKey: true});
   let newTab = await promiseTabOpened;
   ok(true, "Bookmark ctrl-click opened new tab.");
   BrowserTestUtils.removeTab(newTab);
   return testMenuitem;
 }
@@ -183,25 +183,25 @@ add_task(async function testStayopenBook
   BrowserTestUtils.removeTab(newTab);
   ok(BM.open, "Bookmarks Menu's Popup should still be open.");
   promiseEvent = BrowserTestUtils.waitForEvent(BMpopup, "popuphidden");
   BM.open = false;
   await promiseEvent;
 
   // Test Bookmarks Toolbar stayopen clicks - Ctrl-click.
   let BT = document.getElementById("PlacesToolbarItems");
-  let toolbarbutton = BT.firstChild;
+  let toolbarbutton = BT.firstElementChild;
   ok(toolbarbutton, "Folder should be first item on Bookmarks Toolbar.");
-  let buttonMenupopup = toolbarbutton.firstChild;
+  let buttonMenupopup = toolbarbutton.firstElementChild;
   ok(buttonMenupopup.tagName == "menupopup", "Found toolbar button's menupopup.");
   promiseEvent = BrowserTestUtils.waitForEvent(buttonMenupopup, "popupshown");
   EventUtils.synthesizeMouseAtCenter(toolbarbutton, {});
   await promiseEvent;
   ok(true, "Bookmarks toolbar folder's popup is open.");
-  menuitem = buttonMenupopup.firstChild.nextSibling;
+  menuitem = buttonMenupopup.firstElementChild.nextElementSibling;
   promiseTabOpened = BrowserTestUtils.waitForNewTab(gBrowser, null);
   EventUtils.synthesizeMouseAtCenter(menuitem, {ctrlKey: true});
   newTab = await promiseTabOpened;
   ok(true, "Bookmark in folder on bookmark's toolbar ctrl-click opened new tab.");
   ok(toolbarbutton.open, "Popup of folder on bookmark's toolbar should still be open.");
   promiseEvent = BrowserTestUtils.waitForEvent(buttonMenupopup, "popuphidden");
   toolbarbutton.open = false;
   await promiseEvent;
diff --git a/browser/components/places/tests/browser/browser_toolbar_overflow.js b/browser/components/places/tests/browser/browser_toolbar_overflow.js
--- a/browser/components/places/tests/browser/browser_toolbar_overflow.js
+++ b/browser/components/places/tests/browser/browser_toolbar_overflow.js
@@ -37,39 +37,39 @@ add_task(async function setup() {
     await PlacesUtils.bookmarks.eraseEverything();
     await PlacesUtils.history.clear();
   });
 });
 
 add_task(async function test_overflow() {
   // Check that the overflow chevron is visible.
   Assert.ok(!gChevron.collapsed, "The overflow chevron should be visible");
-  Assert.ok(gToolbarContent.childNodes.length < BOOKMARKS_COUNT,
+  Assert.ok(gToolbarContent.children.length < BOOKMARKS_COUNT,
             "Not all the nodes should be built by default");
   let visibleNodes = [];
-  for (let node of gToolbarContent.childNodes) {
+  for (let node of gToolbarContent.children) {
     if (node.style.visibility == "visible")
       visibleNodes.push(node);
   }
-  Assert.ok(visibleNodes.length < gToolbarContent.childNodes.length,
-            `The number of visible nodes (${visibleNodes.length}) should be smaller than the number of built nodes (${gToolbarContent.childNodes.length})`);
+  Assert.ok(visibleNodes.length < gToolbarContent.children.length,
+            `The number of visible nodes (${visibleNodes.length}) should be smaller than the number of built nodes (${gToolbarContent.children.length})`);
 
   await test_index("Node at the last visible index", visibleNodes.length - 1, "visible");
   await test_index("Node at the first invisible index", visibleNodes.length, "hidden");
-  await test_index("First non-built node", gToolbarContent.childNodes.length, undefined);
-  await test_index("Later non-built node", gToolbarContent.childNodes.length + 1, undefined);
+  await test_index("First non-built node", gToolbarContent.children.length, undefined);
+  await test_index("Later non-built node", gToolbarContent.children.length + 1, undefined);
 
   await test_move_index("Move node from last visible to first hidden",
                         visibleNodes.length - 1, visibleNodes.length,
                         "visible", "hidden");
   await test_move_index("Move node from fist visible to last built",
-                        0, gToolbarContent.childNodes.length - 1,
+                        0, gToolbarContent.children.length - 1,
                         "visible", "hidden");
   await test_move_index("Move node from fist visible to first non built",
-                        0, gToolbarContent.childNodes.length,
+                        0, gToolbarContent.children.length,
                         "visible", undefined);
 });
 
 add_task(async function test_separator_first() {
   // Check that if a separator is the first node, we still calculate overflow
   // properly.
   let bm = await PlacesUtils.bookmarks.insert({
     parentGuid: PlacesUtils.bookmarks.toolbarGuid,
@@ -79,17 +79,17 @@ add_task(async function test_separator_f
   // Hide and show the toolbar to cause a rebuild.
   let promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, false);
   await promiseReady;
   promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, true);
   await promiseReady;
 
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   Assert.ok(children.length > 2, "Multiple elements are visible");
   Assert.equal(children[1]._placesNode.uri, "http://test.places.0/", "Found the first bookmark");
   Assert.equal(children[1].style.visibility, "visible", "The first bookmark is visible");
 
   await PlacesUtils.bookmarks.remove(bm);
 });
 
 add_task(async function test_newWindow_noOverflow() {
@@ -107,29 +107,29 @@ add_task(async function test_newWindow_n
   await PlacesTestUtils.addFavicons(new Map([["http://toolbar.overflow/", favicon]]));
 
   let win = await BrowserTestUtils.openNewBrowserWindow();
   try {
     let toolbar = win.document.getElementById("PersonalToolbar");
     Assert.ok(!toolbar.collapsed, "The toolbar is not collapsed");
     let content = win.document.getElementById("PlacesToolbarItems");
     await BrowserTestUtils.waitForCondition(() => {
-      return content.childNodes.length == 1 &&
-             content.childNodes[0].hasAttribute("image");
+      return content.children.length == 1 &&
+             content.children[0].hasAttribute("image");
     });
     let chevron = win.document.getElementById("PlacesChevron");
     Assert.ok(chevron.collapsed, "The chevron should be collapsed");
   } finally {
     await BrowserTestUtils.closeWindow(win);
   }
 });
 
 async function test_index(desc, index, expected) {
   info(desc);
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   let originalLen = children.length;
   let nodeExisted = children.length > index;
   let previousNodeIsVisible = nodeExisted &&
                               children[index - 1].style.visibility == "visible";
   let promiseUpdateVisibility = expected == "visible" || previousNodeIsVisible
     ? BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated")
     : Promise.resolve();
   let bm = await PlacesUtils.bookmarks.insert({
@@ -167,17 +167,17 @@ async function test_index(desc, index, e
                  `The bookmark node should be ${expected}`);
   }
   Assert.equal(children.length, originalLen,
                "Number of built nodes should stay the same");
 }
 
 async function test_move_index(desc, fromIndex, toIndex, original, expected) {
   info(desc);
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   let originalLen = children.length;
   let movedGuid = children[fromIndex]._placesNode.bookmarkGuid;
   let existingGuid = children[toIndex] ?
     children[toIndex]._placesNode.bookmarkGuid : null;
   let existingIndex = fromIndex < toIndex ? toIndex - 1 : toIndex + 1;
 
   Assert.equal(children[fromIndex].style.visibility, original,
                `The bookmark node should be ${original}`);
@@ -253,15 +253,15 @@ add_task(async function test_separator_f
   // Hide and show the toolbar to cause a rebuild.
   let promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, false);
   await promiseReady;
   promiseReady = BrowserTestUtils.waitForEvent(gToolbar, "BookmarksToolbarVisibilityUpdated");
   await promiseSetToolbarVisibility(gToolbar, true);
   await promiseReady;
 
-  let children = gToolbarContent.childNodes;
+  let children = gToolbarContent.children;
   Assert.equal(children.length, 2, "The expected elements are visible");
   Assert.equal(children[0].style.visibility, "visible", "The first bookmark is visible");
   Assert.equal(children[1].style.visibility, "visible", "The second bookmark is visible");
 
   await PlacesUtils.bookmarks.eraseEverything();
 });
diff --git a/browser/components/places/tests/browser/browser_views_iconsupdate.js b/browser/components/places/tests/browser/browser_views_iconsupdate.js
--- a/browser/components/places/tests/browser/browser_views_iconsupdate.js
+++ b/browser/components/places/tests/browser/browser_views_iconsupdate.js
@@ -88,17 +88,17 @@ add_task(async function() {
 /**
  * Get Element for a bookmark in the bookmarks toolbar.
  *
  * @param guid
  *        GUID of the item to search.
  * @returns DOM Node of the element.
  */
 function getNodeForToolbarItem(guid) {
-  return Array.from(document.getElementById("PlacesToolbarItems").childNodes)
+  return Array.from(document.getElementById("PlacesToolbarItems").children)
               .find(child => child._placesNode && child._placesNode.bookmarkGuid == guid);
 }
 
 /**
  * Get a rect for a bookmark in the bookmarks sidebar
  *
  * @param guid
  *        GUID of the item to search.
diff --git a/browser/components/places/tests/browser/browser_views_liveupdate.js b/browser/components/places/tests/browser/browser_views_liveupdate.js
--- a/browser/components/places/tests/browser/browser_views_liveupdate.js
+++ b/browser/components/places/tests/browser/browser_views_liveupdate.js
@@ -263,17 +263,17 @@ function searchItemInView(itemGuid, view
  * @param itemGuid
  *        item guid of the item to search.
  * @returns [node, index] or [null, null] if not found.
  */
 function getNodeForToolbarItem(itemGuid, validator) {
   var placesToolbarItems = document.getElementById("PlacesToolbarItems");
 
   function findNode(aContainer) {
-    var children = aContainer.childNodes;
+    var children = aContainer.children;
     for (var i = 0, staticNodes = 0; i < children.length; i++) {
       var child = children[i];
 
       // Is this a Places node?
       if (!child._placesNode) {
         staticNodes++;
         continue;
       }
@@ -281,17 +281,17 @@ function getNodeForToolbarItem(itemGuid,
       if (child._placesNode.bookmarkGuid == itemGuid) {
         let valid = validator ? validator(child) : true;
         return [child._placesNode, i - staticNodes, valid];
       }
 
       // Don't search in queries, they could contain our item in a
       // different position.  Search only folders
       if (PlacesUtils.nodeIsFolder(child._placesNode)) {
-        var popup = child.lastChild;
+        var popup = child.lastElementChild;
         popup.openPopup();
         var foundNode = findNode(popup);
         popup.hidePopup();
         if (foundNode[0] != null)
           return foundNode;
       }
     }
     return [null, null];
@@ -306,17 +306,17 @@ function getNodeForToolbarItem(itemGuid,
  * @param itemGuid
  *        item guid of the item to search.
  * @returns [node, index] or [null, null] if not found.
  */
 function getNodeForMenuItem(itemGuid, validator) {
   var menu = document.getElementById("bookmarksMenu");
 
   function findNode(aContainer) {
-    var children = aContainer.childNodes;
+    var children = aContainer.children;
     for (var i = 0, staticNodes = 0; i < children.length; i++) {
       var child = children[i];
 
       // Is this a Places node?
       if (!child._placesNode) {
         staticNodes++;
         continue;
       }
@@ -324,29 +324,29 @@ function getNodeForMenuItem(itemGuid, va
       if (child._placesNode.bookmarkGuid == itemGuid) {
         let valid = validator ? validator(child) : true;
         return [child._placesNode, i - staticNodes, valid];
       }
 
       // Don't search in queries, they could contain our item in a
       // different position.  Search only folders
       if (PlacesUtils.nodeIsFolder(child._placesNode)) {
-        var popup = child.lastChild;
+        var popup = child.lastElementChild;
         fakeOpenPopup(popup);
         var foundNode = findNode(popup);
 
         child.open = false;
         if (foundNode[0] != null)
           return foundNode;
       }
     }
     return [null, null, false];
   }
 
-  return findNode(menu.lastChild);
+  return findNode(menu.lastElementChild);
 }
 
 /**
  * Get places node and index for an itemGuid in sidebar tree view.
  *
  * @param itemGuid
  *        item guid of the item to search.
  * @returns [node, index] or [null, null] if not found.
diff --git a/browser/components/places/tests/browser/head.js b/browser/components/places/tests/browser/head.js
--- a/browser/components/places/tests/browser/head.js
+++ b/browser/components/places/tests/browser/head.js
@@ -389,17 +389,17 @@ function promisePopupHidden(popup) {
       resolve();
     };
     popup.addEventListener("popuphidden", onPopupHidden);
   });
 }
 
 // Identify a bookmark node in the Bookmarks Toolbar by its guid.
 function getToolbarNodeForItemGuid(itemGuid) {
-  let children = document.getElementById("PlacesToolbarItems").childNodes;
+  let children = document.getElementById("PlacesToolbarItems").children;
   for (let child of children) {
     if (itemGuid === child._placesNode.bookmarkGuid) {
       return child;
     }
   }
   return null;
 }
 
diff --git a/browser/components/preferences/applicationManager.js b/browser/components/preferences/applicationManager.js
--- a/browser/components/preferences/applicationManager.js
+++ b/browser/components/preferences/applicationManager.js
@@ -36,17 +36,17 @@ var gAppManagerDialog = {
       if (!gMainPane.isValidHandlerApp(app))
         continue;
 
       app.QueryInterface(Ci.nsIHandlerApp);
 
       // Ensure the XBL binding is created eagerly.
       // eslint-disable-next-line no-undef
       list.appendChild(MozXULElement.parseXULToFragment("<richlistitem/>"));
-      var item = list.lastChild;
+      var item = list.lastElementChild;
       item.app = app;
 
       var image = document.createElement("image");
       image.setAttribute("src", gMainPane._getIconURLForHandlerApp(app));
       item.appendChild(image);
 
       var label = document.createElement("label");
       label.setAttribute("value", app.name);
diff --git a/browser/components/preferences/in-content/containers.js b/browser/components/preferences/in-content/containers.js
--- a/browser/components/preferences/in-content/containers.js
+++ b/browser/components/preferences/in-content/containers.js
@@ -21,18 +21,18 @@ let gContainersPane = {
       }
     });
 
     this._rebuildView();
   },
 
   _rebuildView() {
     const containers = ContextualIdentityService.getPublicIdentities();
-    while (this._list.firstChild) {
-      this._list.firstChild.remove();
+    while (this._list.firstElementChild) {
+      this._list.firstElementChild.remove();
     }
     for (let container of containers) {
       let item = document.createElement("richlistitem");
 
       let outer = document.createElement("hbox");
       outer.setAttribute("flex", 1);
       outer.setAttribute("align", "center");
       item.appendChild(outer);
diff --git a/browser/components/preferences/in-content/extensionControlled.js b/browser/components/preferences/in-content/extensionControlled.js
--- a/browser/components/preferences/in-content/extensionControlled.js
+++ b/browser/components/preferences/in-content/extensionControlled.js
@@ -141,18 +141,18 @@ function settingNameToL10nID(settingName
  * @param settingName {String}
  *        If `addon` is set this handled the name of the setting that will be used
  *        to fetch the l10n id for the given message.
  *        If `addon` is set to null, this will be the full l10n-id assigned to the
  *        element.
  */
 function setControllingExtensionDescription(elem, addon, settingName) {
   // Remove the old content from the description.
-  while (elem.firstChild) {
-    elem.firstChild.remove();
+  while (elem.firstElementChild) {
+    elem.firstElementChild.remove();
   }
 
   if (addon === null) {
     document.l10n.setAttributes(elem, settingName);
     return;
   }
 
   let image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
diff --git a/browser/components/preferences/in-content/findInPage.js b/browser/components/preferences/in-content/findInPage.js
--- a/browser/components/preferences/in-content/findInPage.js
+++ b/browser/components/preferences/in-content/findInPage.js
@@ -86,17 +86,17 @@ var gSearchResultsPane = {
    *    DOM element
    * @returns array of text nodes
    */
   textNodeDescendants(node) {
     if (!node) {
       return [];
     }
     let all = [];
-    for (node = node.firstChild; node; node = node.nextSibling) {
+    for (node = node.firstElementChild; node; node = node.nextElementSibling) {
       if (node.nodeType === node.TEXT_NODE) {
         all.push(node);
       } else {
         all = all.concat(this.textNodeDescendants(node));
       }
     }
     return all;
   },
@@ -410,17 +410,17 @@ var gSearchResultsPane = {
     // except the "historyPane" <xul:deck> element.
     if (nodeObject.tagName == "deck" && nodeObject.id != "historyPane") {
       let index = nodeObject.selectedIndex;
       if (index != -1) {
         let result = await this.searchChildNodeIfVisible(nodeObject, index, searchPhrase);
         matchesFound = matchesFound || result;
       }
     } else {
-      for (let i = 0; i < nodeObject.childNodes.length; i++) {
+      for (let i = 0; i < nodeObject.children.length; i++) {
         let result = await this.searchChildNodeIfVisible(nodeObject, i, searchPhrase);
         matchesFound = matchesFound || result;
       }
     }
     return matchesFound;
   },
 
   /**
@@ -431,18 +431,18 @@ var gSearchResultsPane = {
    * @param Number index
    *    The index for the childNode
    * @param String searchPhrase
    * @returns boolean
    *    Returns true when found the specific childNode, false otherwise
    */
   async searchChildNodeIfVisible(nodeObject, index, searchPhrase) {
     let result = false;
-    if (!nodeObject.childNodes[index].hidden && nodeObject.getAttribute("data-hidden-from-search") !== "true") {
-      result = await this.searchWithinNode(nodeObject.childNodes[index], searchPhrase);
+    if (!nodeObject.children[index].hidden && nodeObject.getAttribute("data-hidden-from-search") !== "true") {
+      result = await this.searchWithinNode(nodeObject.children[index], searchPhrase);
       // Creating tooltips for menulist element
       if (result && nodeObject.tagName === "menulist") {
         this.listSearchTooltips.add(nodeObject);
       }
     }
     return result;
   },
 
diff --git a/browser/components/preferences/in-content/main.js b/browser/components/preferences/in-content/main.js
--- a/browser/components/preferences/in-content/main.js
+++ b/browser/components/preferences/in-content/main.js
@@ -1501,18 +1501,18 @@ var gMainPane = {
   },
 
   _rebuildView() {
     let lastSelectedType = this.selectedHandlerListItem &&
                            this.selectedHandlerListItem.handlerInfoWrapper.type;
     this.selectedHandlerListItem = null;
 
     // Clear the list of entries.
-    while (this._list.childNodes.length > 1)
-      this._list.removeChild(this._list.lastChild);
+    while (this._list.children.length > 1)
+      this._list.removeChild(this._list.lastElementChild);
 
     var visibleTypes = this._visibleTypes;
 
     // If the user is filtering the list, then only show matching types.
     if (this._filter.value)
       visibleTypes = visibleTypes.filter(this._matchesFilter, this);
 
     for (let visibleType of visibleTypes) {
@@ -1579,17 +1579,17 @@ var gMainPane = {
   rebuildActionsMenu() {
     var typeItem = this._list.selectedItem;
     var handlerInfo = this.selectedHandlerListItem.handlerInfoWrapper;
     var menu = typeItem.querySelector(".actionsMenu");
     var menuPopup = menu.menupopup;
 
     // Clear out existing items.
     while (menuPopup.hasChildNodes())
-      menuPopup.removeChild(menuPopup.lastChild);
+      menuPopup.removeChild(menuPopup.lastElementChild);
 
     let internalMenuItem;
     // Add the "Preview in Firefox" option for optional internal handlers.
     if (handlerInfo instanceof InternalHandlerInfoWrapper) {
       internalMenuItem = document.createElement("menuitem");
       internalMenuItem.setAttribute("action", Ci.nsIHandlerInfo.handleInternally);
       let label = gMainPane._prefsBundle.getFormattedString("previewInApp",
         [this._brandShortName]);
@@ -1968,17 +1968,17 @@ var gMainPane = {
       // If they picked an app, we want to add the app to the menu and select it.
       // If they canceled, we want to go back to their previous selection.
       this.rebuildActionsMenu();
 
       // If the user picked a new app from the menu, select it.
       if (aHandlerApp) {
         let typeItem = this._list.selectedItem;
         let actionsMenu = typeItem.querySelector(".actionsMenu");
-        let menuItems = actionsMenu.menupopup.childNodes;
+        let menuItems = actionsMenu.menupopup.children;
         for (let i = 0; i < menuItems.length; i++) {
           let menuItem = menuItems[i];
           if (menuItem.handlerApp && menuItem.handlerApp.equals(aHandlerApp)) {
             actionsMenu.selectedIndex = i;
             this.onSelectAction(menuItem);
             break;
           }
         }
@@ -2455,17 +2455,17 @@ class HandlerListItem {
       } else {
         node.removeAttribute(name);
       }
     }
   }
 
   connectAndAppendToList(list) {
     list.appendChild(document.importNode(gHandlerListItemFragment, true));
-    this.node = list.lastChild;
+    this.node = list.lastElementChild;
     gNodeToObjectMap.set(this.node, this);
 
     this.node.querySelector(".actionsMenu").addEventListener("command",
       event => gMainPane.onSelectAction(event.originalTarget));
 
     let typeDescription = this.handlerInfoWrapper.typeDescription;
     this.setOrRemoveAttributes([
       [null, "type", this.handlerInfoWrapper.type],
diff --git a/browser/components/preferences/in-content/preferences.js b/browser/components/preferences/in-content/preferences.js
--- a/browser/components/preferences/in-content/preferences.js
+++ b/browser/components/preferences/in-content/preferences.js
@@ -298,18 +298,18 @@ function scrollAndHighlight(subcategory)
  * If there is no visible second level header it will return first level header,
  * otherwise return second level header.
  * @returns {Element} - The closest displayed header.
  */
 function getClosestDisplayedHeader(element) {
   let header = element.closest("groupbox");
   let searchHeader = header.querySelector("caption.search-header");
   if (searchHeader && searchHeader.hidden &&
-      header.previousSibling.classList.contains("subcategory")) {
-    header = header.previousSibling;
+      header.previousElementSibling.classList.contains("subcategory")) {
+    header = header.previousElementSibling;
   }
   return header;
 }
 
 function scrollContentTo(element) {
   const STICKY_CONTAINER_HEIGHT = document.querySelector(".sticky-container").clientHeight;
   let mainContent = document.querySelector(".main-content");
   let top = element.getBoundingClientRect().top - STICKY_CONTAINER_HEIGHT;
diff --git a/browser/components/preferences/in-content/tests/browser_change_app_handler.js b/browser/components/preferences/in-content/tests/browser_change_app_handler.js
--- a/browser/components/preferences/in-content/tests/browser_change_app_handler.js
+++ b/browser/components/preferences/in-content/tests/browser_change_app_handler.js
@@ -25,45 +25,45 @@ add_task(async function() {
   let ourItem = container.querySelector("richlistitem[type='text/x-test-handler']");
   ok(ourItem, "handlersView is present");
   ourItem.scrollIntoView();
   container.selectItem(ourItem);
   ok(ourItem.selected, "Should be able to select our item.");
 
   let list = ourItem.querySelector(".actionsMenu");
 
-  let chooseItem = list.firstChild.querySelector(".choose-app-item");
+  let chooseItem = list.firstElementChild.querySelector(".choose-app-item");
   let dialogLoadedPromise = promiseLoadSubDialog("chrome://global/content/appPicker.xul");
   let cmdEvent = win.document.createEvent("xulcommandevent");
   cmdEvent.initCommandEvent("command", true, true, win, 0, false, false, false, false, null, 0);
   chooseItem.dispatchEvent(cmdEvent);
 
   let dialog = await dialogLoadedPromise;
   info("Dialog loaded");
 
   let dialogDoc = dialog.document;
   let dialogList = dialogDoc.getElementById("app-picker-listbox");
-  dialogList.selectItem(dialogList.firstChild);
-  let selectedApp = dialogList.firstChild.handlerApp;
+  dialogList.selectItem(dialogList.firstElementChild);
+  let selectedApp = dialogList.firstElementChild.handlerApp;
   dialogDoc.documentElement.acceptDialog();
 
   // Verify results are correct in mime service:
   let mimeInfo = gMimeSvc.getFromTypeAndExtension("text/x-test-handler", null);
   ok(mimeInfo.preferredApplicationHandler.equals(selectedApp), "App should be set as preferred.");
 
   // Check that we display this result:
   ok(list.selectedItem, "Should have a selected item");
   ok(mimeInfo.preferredApplicationHandler.equals(list.selectedItem.handlerApp),
      "App should be visible as preferred item.");
 
 
   // Now try to 'manage' this list:
   dialogLoadedPromise = promiseLoadSubDialog("chrome://browser/content/preferences/applicationManager.xul");
 
-  let manageItem = list.firstChild.querySelector(".manage-app-item");
+  let manageItem = list.firstElementChild.querySelector(".manage-app-item");
   cmdEvent = win.document.createEvent("xulcommandevent");
   cmdEvent.initCommandEvent("command", true, true, win, 0, false, false, false, false, null, 0);
   manageItem.dispatchEvent(cmdEvent);
 
   dialog = await dialogLoadedPromise;
   info("Dialog loaded the second time");
 
   dialogDoc = dialog.document;
diff --git a/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js b/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js
--- a/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js
+++ b/browser/components/preferences/in-content/tests/browser_search_within_preferences_2.js
@@ -17,17 +17,17 @@ add_task(async function() {
  */
 add_task(async function() {
   await openPreferencesViaOpenPreferencesAPI("paneGeneral", {leaveOpen: true});
 
   // Ensure the "Sign Up" button in the hidden child of the <xul:deck>
   // is selected and displayed on the screen.
   let weavePrefsDeck = gBrowser.contentDocument.getElementById("weavePrefsDeck");
   is(weavePrefsDeck.selectedIndex, 0, "Should select the #noFxaAccount child node");
-  let noFxaSignUp = weavePrefsDeck.childNodes[0].querySelector("#noFxaSignUp");
+  let noFxaSignUp = weavePrefsDeck.children[0].querySelector("#noFxaSignUp");
   is(noFxaSignUp.textContent, "Don\u2019t have an account? Get started", "The Sign Up button should exist");
 
   // Performs search.
   let searchInput = gBrowser.contentDocument.getElementById("searchInput");
 
   is(searchInput, gBrowser.contentDocument.activeElement.closest("#searchInput"),
     "Search input should be focused when visiting preferences");
 
@@ -44,17 +44,17 @@ add_task(async function() {
         child.id == "weavePrefsDeck") {
       is_element_visible(child, "Should be in search results");
     } else if (child.id) {
       is_element_hidden(child, "Should not be in search results");
     }
   }
 
   // Ensure the "Remove Account" button exists in the hidden child of the <xul:deck>.
-  let unlinkFxaAccount = weavePrefsDeck.childNodes[1].querySelector("#unverifiedUnlinkFxaAccount");
+  let unlinkFxaAccount = weavePrefsDeck.children[1].querySelector("#unverifiedUnlinkFxaAccount");
   is(unlinkFxaAccount.label, "Remove Account", "The Remove Account button should exist");
 
   // Performs search.
   searchInput.focus();
   query = "Remove Account";
   searchCompletedPromise = BrowserTestUtils.waitForEvent(
       gBrowser.contentWindow, "PreferencesSearchCompleted", evt => evt.detail == query);
   EventUtils.sendString(query);
diff --git a/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js b/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js
--- a/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js
+++ b/browser/components/preferences/in-content/tests/browser_site_autoplay_media_prompt.js
@@ -44,17 +44,17 @@ add_task(async function ensureMenuHidden
 add_task(async function enableBlockingAutoplay() {
 
   Services.prefs.setBoolPref(GESTURES_NEEDED_KEY, true);
 
   await ContentTask.spawn(gBrowser.selectedBrowser, null, function() {
     let doc = content.document;
     let autoplayMenu = doc.getElementById("autoplayMediaPolicyMenu");
     autoplayMenu.click();
-    let askMenuItem = autoplayMenu.childNodes[0].childNodes[1];
+    let askMenuItem = autoplayMenu.children[0].children[1];
     askMenuItem.click();
   });
 
   Assert.equal(Services.prefs.getIntPref(AUTOPLAY_ENABLED_KEY),
                Ci.nsIAutoplay.PROMPT,
                "Ensure we have set autoplay to false");
 });
 
diff --git a/browser/components/preferences/languages.js b/browser/components/preferences/languages.js
--- a/browser/components/preferences/languages.js
+++ b/browser/components/preferences/languages.js
@@ -82,17 +82,17 @@ var gLanguagesDialog = {
 
     await this._buildAvailableLanguageList();
     await this._readAcceptLanguages();
   },
 
   async _buildAvailableLanguageList() {
     var availableLanguagesPopup = document.getElementById("availableLanguagesPopup");
     while (availableLanguagesPopup.hasChildNodes())
-      availableLanguagesPopup.firstChild.remove();
+      availableLanguagesPopup.firstElementChild.remove();
 
     let frag = document.createDocumentFragment();
 
     // Load the UI with the data
     for (var i = 0; i < this._availableLanguagesList.length; ++i) {
       let locale = this._availableLanguagesList[i];
       let localeCode = locale.code;
       if (locale.isVisible &&
@@ -125,17 +125,17 @@ var gLanguagesDialog = {
 
     availableLanguagesPopup.appendChild(frag);
 
     this._availableLanguages.setAttribute("label", this._availableLanguages.getAttribute("placeholder"));
   },
 
   async _readAcceptLanguages() {
     while (this._activeLanguages.hasChildNodes())
-      this._activeLanguages.firstChild.remove();
+      this._activeLanguages.firstElementChild.remove();
 
     var selectedIndex = 0;
     var preference = Preferences.get("intl.accept_languages");
     if (preference.value == "")
       return;
     var languages = preference.value.toLowerCase().split(/\s*,\s*/);
     for (var i = 0; i < languages.length; ++i) {
       var listitem = document.createElement("richlistitem");
@@ -156,17 +156,17 @@ var gLanguagesDialog = {
       this._acceptLanguages[languages[i]] = true;
     }
 
     // We're forcing an early localization here because otherwise
     // the initial sizing of the dialog will happen before it and
     // result in overflow.
     await document.l10n.translateFragment(this._activeLanguages);
 
-    if (this._activeLanguages.childNodes.length > 0) {
+    if (this._activeLanguages.children.length > 0) {
       this._activeLanguages.ensureIndexIsVisible(selectedIndex);
       this._activeLanguages.selectedIndex = selectedIndex;
     }
 
     // Update states of accept-language list and buttons according to
     // privacy.resistFingerprinting and privacy.spoof_english.
     this.readSpoofEnglish();
   },
@@ -203,29 +203,29 @@ var gLanguagesDialog = {
 
     // Rebuild the available list with the added item removed...
     this._buildAvailableLanguageList().catch(Cu.reportError);
   },
 
   removeLanguage() {
     // Build the new preference value string.
     var languagesArray = [];
-    for (var i = 0; i < this._activeLanguages.childNodes.length; ++i) {
-      var item = this._activeLanguages.childNodes[i];
+    for (var i = 0; i < this._activeLanguages.children.length; ++i) {
+      var item = this._activeLanguages.children[i];
       if (!item.selected)
         languagesArray.push(item.id);
       else
         this._acceptLanguages[item.id] = false;
     }
     var string = languagesArray.join(",");
 
     // Get the item to select after the remove operation completes.
     var selection = this._activeLanguages.selectedItems;
     var lastSelected = selection[selection.length - 1];
-    var selectItem = lastSelected.nextSibling || lastSelected.previousSibling;
+    var selectItem = lastSelected.nextElementSibling || lastSelected.previousElementSibling;
     selectItem = selectItem ? selectItem.id : null;
 
     this._selectedItemID = selectItem;
 
     // Update the preference and force a UI rebuild
     var preference = Preferences.get("intl.accept_languages");
     preference.value = string;
 
@@ -239,21 +239,21 @@ var gLanguagesDialog = {
       if (localeCode == this._availableLanguagesList[i].code)
         return this._availableLanguagesList[i].name;
     }
     return "";
   },
 
   moveUp() {
     var selectedItem = this._activeLanguages.selectedItems[0];
-    var previousItem = selectedItem.previousSibling;
+    var previousItem = selectedItem.previousElementSibling;
 
     var string = "";
-    for (var i = 0; i < this._activeLanguages.childNodes.length; ++i) {
-      var item = this._activeLanguages.childNodes[i];
+    for (var i = 0; i < this._activeLanguages.children.length; ++i) {
+      var item = this._activeLanguages.children[i];
       string += (i == 0 ? "" : ",");
       if (item.id == previousItem.id)
         string += selectedItem.id;
       else if (item.id == selectedItem.id)
         string += previousItem.id;
       else
         string += item.id;
     }
@@ -262,21 +262,21 @@ var gLanguagesDialog = {
 
     // Update the preference and force a UI rebuild
     var preference = Preferences.get("intl.accept_languages");
     preference.value = string;
   },
 
   moveDown() {
     var selectedItem = this._activeLanguages.selectedItems[0];
-    var nextItem = selectedItem.nextSibling;
+    var nextItem = selectedItem.nextElementSibling;
 
     var string = "";
-    for (var i = 0; i < this._activeLanguages.childNodes.length; ++i) {
-      var item = this._activeLanguages.childNodes[i];
+    for (var i = 0; i < this._activeLanguages.children.length; ++i) {
+      var item = this._activeLanguages.children[i];
       string += (i == 0 ? "" : ",");
       if (item.id == nextItem.id)
         string += selectedItem.id;
       else if (item.id == selectedItem.id)
         string += nextItem.id;
       else
         string += item.id;
     }
@@ -293,17 +293,17 @@ var gLanguagesDialog = {
     var downButton = document.getElementById("down");
     var removeButton = document.getElementById("remove");
     switch (this._activeLanguages.selectedCount) {
     case 0:
       upButton.disabled = downButton.disabled = removeButton.disabled = true;
       break;
     case 1:
       upButton.disabled = this._activeLanguages.selectedIndex == 0;
-      downButton.disabled = this._activeLanguages.selectedIndex == this._activeLanguages.childNodes.length - 1;
+      downButton.disabled = this._activeLanguages.selectedIndex == this._activeLanguages.children.length - 1;
       removeButton.disabled = false;
       break;
     default:
       upButton.disabled = true;
       downButton.disabled = true;
       removeButton.disabled = false;
     }
   },
@@ -318,17 +318,17 @@ var gLanguagesDialog = {
 
     var spoofEnglish = Preferences.get("privacy.spoof_english").value;
     var activeLanguages = this._activeLanguages;
     var availableLanguages = this._availableLanguages;
     checkbox.hidden = false;
     switch (spoofEnglish) {
     case 1: // don't spoof intl.accept_languages
       activeLanguages.disabled = false;
-      activeLanguages.selectItem(activeLanguages.firstChild);
+      activeLanguages.selectItem(activeLanguages.firstElementChild);
       availableLanguages.disabled = false;
       this.onAvailableLanguageSelect();
       return false;
     case 2: // spoof intl.accept_languages
       activeLanguages.clearSelection();
       activeLanguages.disabled = true;
       availableLanguages.disabled = true;
       this.onAvailableLanguageSelect();
diff --git a/browser/components/search/test/browser_oneOffContextMenu.js b/browser/components/search/test/browser_oneOffContextMenu.js
--- a/browser/components/search/test/browser_oneOffContextMenu.js
+++ b/browser/components/search/test/browser_oneOffContextMenu.js
@@ -38,17 +38,17 @@ add_task(async function telemetry() {
   // Open the popup.
   let promise = promiseEvent(searchPopup, "popupshown");
   info("Opening search panel");
   EventUtils.synthesizeMouseAtCenter(searchIcon, {});
   await promise;
 
   // Get the one-off button for the test engine.
   let oneOffButton;
-  for (let node of oneOffButtons.childNodes) {
+  for (let node of oneOffButtons.children) {
     if (node.engine && node.engine.name == TEST_ENGINE_NAME) {
       oneOffButton = node;
       break;
     }
   }
   Assert.notEqual(oneOffButton, undefined,
                   "One-off for test engine should exist");
 
diff --git a/browser/components/search/test/browser_oneOffContextMenu_setDefault.js b/browser/components/search/test/browser_oneOffContextMenu_setDefault.js
--- a/browser/components/search/test/browser_oneOffContextMenu_setDefault.js
+++ b/browser/components/search/test/browser_oneOffContextMenu_setDefault.js
@@ -156,17 +156,17 @@ async function openPopupAndGetEngineButt
     oneOffBinding, "anonid", "search-one-offs-context-menu"
   );
   const oneOffButtons = document.getAnonymousElementByAttribute(
     oneOffBinding, "anonid", "search-panel-one-offs"
   );
 
   // Get the one-off button for the test engine.
   let oneOffButton;
-  for (let node of oneOffButtons.childNodes) {
+  for (let node of oneOffButtons.children) {
     if (node.engine && node.engine.name == TEST_ENGINE_NAME) {
       oneOffButton = node;
       break;
     }
   }
   Assert.notEqual(oneOffButton, undefined,
                   "One-off for test engine should exist");
   Assert.equal(oneOffButton.getAttribute("tooltiptext"), TEST_ENGINE_NAME,
diff --git a/browser/components/search/test/browser_oneOffHeader.js b/browser/components/search/test/browser_oneOffHeader.js
--- a/browser/components/search/test/browser_oneOffHeader.js
+++ b/browser/components/search/test/browser_oneOffHeader.js
@@ -14,20 +14,20 @@ const searchSettings =
   document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                           "search-settings");
 var header =
   document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                           "search-panel-one-offs-header");
 function getHeaderText() {
   let headerChild = header.selectedPanel;
   while (headerChild.hasChildNodes()) {
-    headerChild = headerChild.firstChild;
+    headerChild = headerChild.firstElementChild;
   }
   let headerStrings = [];
-  for (let label = headerChild; label; label = label.nextSibling) {
+  for (let label = headerChild; label; label = label.nextElementSibling) {
     headerStrings.push(label.value);
   }
   return headerStrings.join("");
 }
 
 const msg = isMac ? 5 : 1;
 const utils = window.windowUtils;
 const scale = utils.screenPixelsPerCSSPixel;
diff --git a/browser/components/search/test/browser_searchbar_keyboard_navigation.js b/browser/components/search/test/browser_searchbar_keyboard_navigation.js
--- a/browser/components/search/test/browser_searchbar_keyboard_navigation.js
+++ b/browser/components/search/test/browser_searchbar_keyboard_navigation.js
@@ -9,17 +9,17 @@ const kValues = ["foo1", "foo2", "foo3"]
 const kUserValue = "foo";
 
 function getOpenSearchItems() {
   let os = [];
 
   let addEngineList =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "add-engines");
-  for (let item = addEngineList.firstChild; item; item = item.nextSibling)
+  for (let item = addEngineList.firstElementChild; item; item = item.nextElementSibling)
     os.push(item);
 
   return os;
 }
 
 let searchbar;
 let textbox;
 
diff --git a/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js b/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js
--- a/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js
+++ b/browser/components/search/test/browser_searchbar_smallpanel_keyboard_navigation.js
@@ -8,17 +8,17 @@ const oneOffsContainer =
 const kValues = ["foo1", "foo2", "foo3"];
 
 function getOpenSearchItems() {
   let os = [];
 
   let addEngineList =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "add-engines");
-  for (let item = addEngineList.firstChild; item; item = item.nextSibling)
+  for (let item = addEngineList.firstElementChild; item; item = item.nextElementSibling)
     os.push(item);
 
   return os;
 }
 
 let searchbar;
 let textbox;
 let searchIcon;
diff --git a/browser/components/search/test/browser_tooManyEnginesOffered.js b/browser/components/search/test/browser_tooManyEnginesOffered.js
--- a/browser/components/search/test/browser_tooManyEnginesOffered.js
+++ b/browser/components/search/test/browser_tooManyEnginesOffered.js
@@ -32,27 +32,27 @@ add_task(async function test() {
 
   // Make sure it has only one add-engine menu button item.
   let items = getOpenSearchItems();
   Assert.equal(items.length, 1, "A single button");
   let menuButton = items[0];
   Assert.equal(menuButton.type, "menu", "A menu button");
 
   // Mouse over the menu button to open it.
-  let buttonPopup = menuButton.firstChild;
+  let buttonPopup = menuButton.firstElementChild;
   promise = promiseEvent(buttonPopup, "popupshown");
   EventUtils.synthesizeMouse(menuButton, 5, 5, { type: "mousemove" });
   await promise;
 
   Assert.ok(menuButton.open, "Submenu should be open");
 
   // Check the engines inside the submenu.
-  Assert.equal(buttonPopup.childNodes.length, 6, "Expected number of engines");
-  for (let i = 0; i < buttonPopup.childNodes.length; i++) {
-    let item = buttonPopup.childNodes[i];
+  Assert.equal(buttonPopup.children.length, 6, "Expected number of engines");
+  for (let i = 0; i < buttonPopup.children.length; i++) {
+    let item = buttonPopup.children[i];
     Assert.equal(item.getAttribute("title"), "engine" + (i + 1),
                  "Expected engine title");
   }
 
   // Mouse out of the menu button to close it.
   promise = promiseEvent(buttonPopup, "popuphidden");
   EventUtils.synthesizeMouse(searchbar, 5, 5, { type: "mousemove" });
   await promise;
@@ -84,13 +84,13 @@ add_task(async function test() {
 });
 
 function getOpenSearchItems() {
   let os = [];
 
   let addEngineList =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "add-engines");
-  for (let item = addEngineList.firstChild; item; item = item.nextSibling)
+  for (let item = addEngineList.firstElementChild; item; item = item.nextElementSibling)
     os.push(item);
 
   return os;
 }
diff --git a/browser/components/search/test/head.js b/browser/components/search/test/head.js
--- a/browser/components/search/test/head.js
+++ b/browser/components/search/test/head.js
@@ -185,17 +185,17 @@ function getOneOffs() {
   let oneOffs = [];
   let searchPopup = document.getElementById("PopupSearchAutoComplete");
   let oneOffsContainer =
     document.getAnonymousElementByAttribute(searchPopup, "anonid",
                                             "search-one-off-buttons");
   let oneOff =
     document.getAnonymousElementByAttribute(oneOffsContainer, "anonid",
                                             "search-panel-one-offs");
-  for (oneOff = oneOff.firstChild; oneOff; oneOff = oneOff.nextSibling) {
+  for (oneOff = oneOff.firstElementChild; oneOff; oneOff = oneOff.nextElementSibling) {
     if (oneOff.nodeType == Node.ELEMENT_NODE) {
       if (oneOff.classList.contains("dummy") ||
           oneOff.classList.contains("search-setting-button-compact"))
         break;
       oneOffs.push(oneOff);
     }
   }
   return oneOffs;
diff --git a/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm b/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm
--- a/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm
+++ b/browser/components/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.jsm
@@ -198,14 +198,14 @@ function createRestoreAllEntry(aDocument
                                 aEntryCount, aTagName) {
   let restoreAllElements = aDocument.createElementNS(kNSXUL, aTagName);
   restoreAllElements.classList.add("restoreallitem");
   restoreAllElements.setAttribute("label", navigatorBundle.GetStringFromName(aRestoreAllLabel));
   restoreAllElements.setAttribute("oncommand",
                                   "for (var i = 0; i < " + aEntryCount + "; i++) undoClose" +
                                     (aIsWindowsFragment ? "Window" : "Tab") + "();");
   if (aPrefixRestoreAll) {
-    aFragment.insertBefore(restoreAllElements, aFragment.firstChild);
+    aFragment.insertBefore(restoreAllElements, aFragment.firstElementChild);
   } else {
     aFragment.appendChild(aDocument.createElementNS(kNSXUL, "menuseparator"));
     aFragment.appendChild(restoreAllElements);
   }
 }
diff --git a/browser/components/syncedtabs/SyncedTabsDeckView.js b/browser/components/syncedtabs/SyncedTabsDeckView.js
--- a/browser/components/syncedtabs/SyncedTabsDeckView.js
+++ b/browser/components/syncedtabs/SyncedTabsDeckView.js
@@ -70,18 +70,18 @@ SyncedTabsDeckView.prototype = {
       } else {
         Array.prototype.map.call(this._doc.getElementsByClassName(panel.id),
                                  item => item.classList.remove("selected"));
       }
     }
   },
 
   _clearChilden() {
-    while (this.container.firstChild) {
-      this.container.firstChild.remove();
+    while (this.container.firstElementChild) {
+      this.container.firstElementChild.remove();
     }
   },
 
   _attachListeners() {
     let syncPrefLinks = this.container.querySelectorAll(".sync-prefs");
     for (let link of syncPrefLinks) {
       link.addEventListener("click", this.props.onSyncPrefClick);
     }
diff --git a/browser/components/syncedtabs/TabListView.js b/browser/components/syncedtabs/TabListView.js
--- a/browser/components/syncedtabs/TabListView.js
+++ b/browser/components/syncedtabs/TabListView.js
@@ -90,18 +90,18 @@ TabListView.prototype = {
     this._clearChilden(this.list);
     for (let client of state.clients) {
       if (state.filter) {
         this._renderFilteredClient(client);
       } else {
         this._renderClient(client);
       }
     }
-    if (this.list.firstChild) {
-      const firstTab = this.list.firstChild.querySelector(".item.tab:first-child .item-title");
+    if (this.list.firstElementChild) {
+      const firstTab = this.list.firstElementChild.querySelector(".item.tab:first-child .item-title");
       if (firstTab) {
         firstTab.setAttribute("tabindex", 2);
       }
     }
   },
 
   destroy() {
     this._teardownContextMenu();
@@ -172,18 +172,18 @@ TabListView.prototype = {
   },
 
   _createTab() {
     return this._doc.importNode(this._tabTemplate.content, true).firstElementChild;
   },
 
   _clearChilden(node) {
     let parent = node || this.container;
-    while (parent.firstChild) {
-      parent.firstChild.remove();
+    while (parent.firstElementChild) {
+      parent.firstElementChild.remove();
     }
   },
 
   // These listeners are attached only once, when we initialize the view
   _attachFixedListeners() {
     this.tabsFilter.addEventListener("input", this.onFilter.bind(this));
     this.tabsFilter.addEventListener("focus", this.onFilterFocus.bind(this));
     this.tabsFilter.addEventListener("blur", this.onFilterBlur.bind(this));
@@ -516,17 +516,17 @@ TabListView.prototype = {
 
     menu.openPopupAtScreen(event.screenX, event.screenY, true, event);
   },
 
   adjustContextMenu(menu) {
     let item = this.container.querySelector(".item.selected");
     let showTabOptions = this._isTab(item);
 
-    let el = menu.firstChild;
+    let el = menu.firstElementChild;
 
     while (el) {
       let show = false;
       if (showTabOptions) {
         if (el.getAttribute("id") == "syncedTabsOpenSelectedInPrivateWindow") {
           show = PrivateBrowsingUtils.enabled;
         } else if (el.getAttribute("id") != "syncedTabsOpenAllInTabs" &&
                    el.getAttribute("id") != "syncedTabsManageDevices") {
@@ -537,17 +537,17 @@ TabListView.prototype = {
         show = tabs.length > 0;
       } else if (el.getAttribute("id") == "syncedTabsRefresh") {
         show = true;
       } else if (el.getAttribute("id") == "syncedTabsManageDevices") {
         show = true;
       }
       el.hidden = !show;
 
-      el = el.nextSibling;
+      el = el.nextElementSibling;
     }
   },
 
   /**
    * Find the parent item element, from a given child element.
    * @param {Element} node - Child element.
    * @return {Element} Element for the item, or null if not found.
    */
@@ -584,25 +584,25 @@ TabListView.prototype = {
     // if the node is not a client, find its position within the parent
     if (parent !== itemNode) {
       childPosition = this._indexOfNode(itemNode.parentNode, itemNode);
     }
     return [parentPosition, childPosition];
   },
 
   _indexOfNode(parent, child) {
-    return Array.prototype.indexOf.call(parent.childNodes, child);
+    return Array.prototype.indexOf.call(parent.children, child);
   },
 
   _isTab(item) {
     return item && item.classList.contains("tab");
   },
 
   _isClient(item) {
     return item && item.classList.contains("client");
   },
 
   _openAllClientTabs(clientNode, where) {
-    const tabs = clientNode.querySelector(".item-tabs-list").childNodes;
+    const tabs = clientNode.querySelector(".item-tabs-list").children;
     const urls = [...tabs].map(tab => tab.dataset.url);
     this.props.onOpenTabs(urls, where);
   }
 };
diff --git a/browser/components/translation/BingTranslator.jsm b/browser/components/translation/BingTranslator.jsm
--- a/browser/components/translation/BingTranslator.jsm
+++ b/browser/components/translation/BingTranslator.jsm
@@ -191,17 +191,17 @@ this.BingTranslator.prototype = {
       // of items (from the number of items submitted), we can't use this chunk
       // because all items would be paired incorrectly.
       return false;
     }
 
     let error = false;
     for (let i = 0; i < len; i++) {
       try {
-        let result = results[i].firstChild.nodeValue;
+        let result = results[i].firstElementChild.nodeValue;
         let root = bingRequest.translationData[i][0];
 
         if (root.isSimpleRoot) {
           // Workaround for Bing's service problem in which "&" chars in
           // plain-text TranslationItems are double-escaped.
           result = result.replace(/&amp;/g, "&");
         }
 
diff --git a/browser/components/translation/TranslationDocument.jsm b/browser/components/translation/TranslationDocument.jsm
--- a/browser/components/translation/TranslationDocument.jsm
+++ b/browser/components/translation/TranslationDocument.jsm
@@ -123,26 +123,26 @@ this.TranslationDocument.prototype = {
    * @returns        A string representation of the TranslationItem.
    */
   generateTextForItem(item) {
     if (item.original) {
       return regenerateTextFromOriginalHelper(item);
     }
 
     if (item.isSimpleRoot) {
-      let text = item.nodeRef.firstChild.nodeValue.trim();
+      let text = item.nodeRef.firstElementChild.nodeValue.trim();
       item.original = [text];
       return text;
     }
 
     let str = "";
     item.original = [];
     let wasLastItemPlaceholder = false;
 
-    for (let child of item.nodeRef.childNodes) {
+    for (let child of item.nodeRef.children) {
       if (child.nodeType == child.TEXT_NODE) {
         let x = child.nodeValue.trim();
         if (x != "") {
           item.original.push(x);
           str += x;
           wasLastItemPlaceholder = false;
         }
         continue;
@@ -297,17 +297,17 @@ TranslationItem.prototype = {
     if (this.isSimpleRoot) {
       this.translation = [result];
       return;
     }
 
     let domParser = new DOMParser();
 
     let doc = domParser.parseFromString(result, "text/html");
-    parseResultNode(this, doc.body.firstChild);
+    parseResultNode(this, doc.body.firstElementChild);
   },
 
   /**
    * This function finds a child TranslationItem
    * with the given id.
    * @param id        The id to look for, in the format "n#"
    * @returns         A TranslationItem with the given id, or null if
    *                  it was not found.
@@ -400,17 +400,17 @@ function regenerateTextFromOriginalHelpe
  * For an element node, we look at its id and find the corresponding
  * TranslationItem that was associated with this node, and then we
  * walk down it repeating the process.
  *
  * For text nodes we simply add it as a string.
  */
 function parseResultNode(item, node) {
   item.translation = [];
-  for (let child of node.childNodes) {
+  for (let child of node.children) {
     if (child.nodeType == child.TEXT_NODE) {
       item.translation.push(child.nodeValue);
     } else if (child.localName == "br") {
       item.translation.push(TranslationItem_NodePlaceholder);
     } else {
       let translationItemChild = item.getChildById(child.id);
 
       if (translationItemChild) {
@@ -516,17 +516,17 @@ function swapTextForItem(item, target) {
     // being iterated (in the for loop below), it should walk together with
     // the array and be pointing to the correct node that needs to modified.
     // If it's not pointing to it, that means some sort of node reordering
     // will be necessary to produce the correct translation.
     // Note that text nodes don't need to be reordered, as we can just replace
     // the content of one text node with another.
     //
     // curNode starts in the firstChild...
-    let curNode = domNode.firstChild;
+    let curNode = domNode.firstElementChild;
 
     // ... actually, let's make curNode start at the first useful node (either
     // a non-blank text node or something else). This is not strictly necessary,
     // as the reordering algorithm would correctly handle this case. However,
     // this better aligns the resulting translation with the DOM content of the
     // page, avoiding cases that would need to be unecessarily reordered.
     //
     // An example of how this helps:
@@ -552,17 +552,17 @@ function swapTextForItem(item, target) {
     //   3 - replace textnode 2 with " Welt."
     //
     // which completely avoids any node reordering, and requires only one
     // text change instead of two (while also leaving the page closer to
     // its original state).
     while (curNode &&
            curNode.nodeType == curNode.TEXT_NODE &&
            curNode.nodeValue.trim() == "") {
-      curNode = curNode.nextSibling;
+      curNode = curNode.nextElementSibling;
     }
 
     // Now let's walk through all items in the `target` array of the
     // TranslationItem. This means either the TranslationItem.original or
     // TranslationItem.translation array.
     for (let targetItem of curItem[target]) {
 
       if (targetItem instanceof TranslationItem) {
@@ -602,25 +602,25 @@ function swapTextForItem(item, target) {
         // elements + empty text nodes to the other side. Even if
         // non-placeholder elements exists inside the jumped block,
         // they will be pulled correctly later in the process when the
         // targetItem for those nodes are handled.
 
         while (curNode &&
                (curNode.nodeType != curNode.TEXT_NODE ||
                 curNode.nodeValue.trim() == "")) {
-          curNode = curNode.nextSibling;
+          curNode = curNode.nextElementSibling;
         }
 
       } else {
         // Finally, if it's a text item, we just need to find the next
         // text node to use. Text nodes don't need to be reordered, so
         // the first one found can be used.
         while (curNode && curNode.nodeType != curNode.TEXT_NODE) {
-          curNode = curNode.nextSibling;
+          curNode = curNode.nextElementSibling;
         }
 
         // If none was found and we reached the end of the child nodes,
         // let's create a new one.
         if (!curNode) {
           // We don't know if the original content had a space or not,
           // so the best bet is to create the text node with " " which
           // will add one space at the beginning and one at the end.
@@ -644,27 +644,27 @@ function swapTextForItem(item, target) {
     }
 
     // And remove any garbage "" nodes left after clearing.
     domNode.normalize();
   }
 }
 
 function getNextSiblingSkippingEmptyTextNodes(startSibling) {
-  let item = startSibling.nextSibling;
+  let item = startSibling.nextElementSibling;
   while (item &&
          item.nodeType == item.TEXT_NODE &&
          item.nodeValue.trim() == "") {
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
   return item;
 }
 
 function clearRemainingNonEmptyTextNodesFromElement(startSibling) {
   let item = startSibling;
   while (item) {
     if (item.nodeType == item.TEXT_NODE &&
         item.nodeValue != "") {
       item.nodeValue = "";
     }
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
 }
diff --git a/browser/components/uitour/UITour.jsm b/browser/components/uitour/UITour.jsm
--- a/browser/components/uitour/UITour.jsm
+++ b/browser/components/uitour/UITour.jsm
@@ -1132,18 +1132,18 @@ var UITour = {
         tooltip.hidePopup();
       }
 
       tooltipTitle.textContent = aTitle || "";
       tooltipDesc.textContent = aDescription || "";
       tooltipIcon.src = aIconURL || "";
       tooltipIcon.hidden = !aIconURL;
 
-      while (tooltipButtons.firstChild)
-        tooltipButtons.firstChild.remove();
+      while (tooltipButtons.firstElementChild)
+        tooltipButtons.firstElementChild.remove();
 
       for (let button of aButtons) {
         let isButton = button.style != "text";
         let el = document.createElement(isButton ? "button" : "label");
         el.setAttribute(isButton ? "label" : "value", button.label);
 
         if (isButton) {
           if (button.iconURL)
@@ -1230,18 +1230,18 @@ var UITour = {
   },
 
   _hideInfoElement(aWindow) {
     let document = aWindow.document;
     let tooltip = document.getElementById("UITourTooltip");
     this._removeAnnotationPanelMutationObserver(tooltip);
     tooltip.hidePopup();
     let tooltipButtons = document.getElementById("UITourTooltipButtons");
-    while (tooltipButtons.firstChild)
-      tooltipButtons.firstChild.remove();
+    while (tooltipButtons.firstElementChild)
+      tooltipButtons.firstElementChild.remove();
   },
 
   hideInfo(aWindow) {
     this._hideInfoElement(aWindow);
     this._setMenuStateForAnnotation(aWindow, false, "appMenu");
     this._setMenuStateForAnnotation(aWindow, false, "pageActionPanel");
   },
 
diff --git a/browser/components/uitour/test/browser_UITour3.js b/browser/components/uitour/test/browser_UITour3.js
--- a/browser/components/uitour/test/browser_UITour3.js
+++ b/browser/components/uitour/test/browser_UITour3.js
@@ -47,38 +47,38 @@ add_UITour_task(async function test_info
 
   let imageURL = getRootDirectory(gTestPath) + "image.png";
   imageURL = imageURL.replace("chrome://mochitests/content/", "https://example.org/");
   is(icon.src, imageURL, "Popup should have correct icon shown");
 
   let buttons = document.getElementById("UITourTooltipButtons");
   is(buttons.childElementCount, 4, "Popup should have four buttons");
 
-  is(buttons.childNodes[0].nodeName, "label", "Text label should be a <label>");
-  is(buttons.childNodes[0].getAttribute("value"), "Regular text", "Text label should have correct value");
-  is(buttons.childNodes[0].getAttribute("image"), "", "Text should have no image");
-  is(buttons.childNodes[0].className, "", "Text should have no class");
+  is(buttons.children[0].nodeName, "label", "Text label should be a <label>");
+  is(buttons.children[0].getAttribute("value"), "Regular text", "Text label should have correct value");
+  is(buttons.children[0].getAttribute("image"), "", "Text should have no image");
+  is(buttons.children[0].className, "", "Text should have no class");
 
-  is(buttons.childNodes[1].nodeName, "button", "Link should be a <button>");
-  is(buttons.childNodes[1].getAttribute("label"), "Link", "Link should have correct label");
-  is(buttons.childNodes[1].getAttribute("image"), "", "Link should have no image");
-  is(buttons.childNodes[1].className, "button-link", "Check link class");
+  is(buttons.children[1].nodeName, "button", "Link should be a <button>");
+  is(buttons.children[1].getAttribute("label"), "Link", "Link should have correct label");
+  is(buttons.children[1].getAttribute("image"), "", "Link should have no image");
+  is(buttons.children[1].className, "button-link", "Check link class");
 
-  is(buttons.childNodes[2].nodeName, "button", "Button 1 should be a <button>");
-  is(buttons.childNodes[2].getAttribute("label"), "Button 1", "First button should have correct label");
-  is(buttons.childNodes[2].getAttribute("image"), "", "First button should have no image");
-  is(buttons.childNodes[2].className, "", "Button 1 should have no class");
+  is(buttons.children[2].nodeName, "button", "Button 1 should be a <button>");
+  is(buttons.children[2].getAttribute("label"), "Button 1", "First button should have correct label");
+  is(buttons.children[2].getAttribute("image"), "", "First button should have no image");
+  is(buttons.children[2].className, "", "Button 1 should have no class");
 
-  is(buttons.childNodes[3].nodeName, "button", "Button 2 should be a <button>");
-  is(buttons.childNodes[3].getAttribute("label"), "Button 2", "Second button should have correct label");
-  is(buttons.childNodes[3].getAttribute("image"), imageURL, "Second button should have correct image");
-  is(buttons.childNodes[3].className, "button-primary", "Check button 2 class");
+  is(buttons.children[3].nodeName, "button", "Button 2 should be a <button>");
+  is(buttons.children[3].getAttribute("label"), "Button 2", "Second button should have correct label");
+  is(buttons.children[3].getAttribute("image"), imageURL, "Second button should have correct image");
+  is(buttons.children[3].className, "button-primary", "Check button 2 class");
 
   let promiseHidden = promisePanelElementHidden(window, popup);
-  EventUtils.synthesizeMouseAtCenter(buttons.childNodes[2], {}, window);
+  EventUtils.synthesizeMouseAtCenter(buttons.children[2], {}, window);
   await promiseHidden;
 
   ok(true, "Popup should close automatically");
 
   let returnValue = await waitForCallbackResultPromise();
   is(returnValue.result, "button1", "Correct callback should have been called");
 });
 
@@ -95,28 +95,28 @@ add_UITour_task(async function test_info
 
   let imageURL = getRootDirectory(gTestPath) + "image.png";
   imageURL = imageURL.replace("chrome://mochitests/content/", "https://example.org/");
   is(icon.src, imageURL, "Popup should have correct icon shown");
 
   let buttons = document.getElementById("UITourTooltipButtons");
   is(buttons.childElementCount, 4, "Popup should have four buttons");
 
-  is(buttons.childNodes[1].getAttribute("label"), "Link", "Link should have correct label");
-  is(buttons.childNodes[1].getAttribute("image"), "", "Link should have no image");
-  ok(buttons.childNodes[1].classList.contains("button-link"), "Link should have button-link class");
+  is(buttons.children[1].getAttribute("label"), "Link", "Link should have correct label");
+  is(buttons.children[1].getAttribute("image"), "", "Link should have no image");
+  ok(buttons.children[1].classList.contains("button-link"), "Link should have button-link class");
 
-  is(buttons.childNodes[2].getAttribute("label"), "Button 1", "First button should have correct label");
-  is(buttons.childNodes[2].getAttribute("image"), "", "First button should have no image");
+  is(buttons.children[2].getAttribute("label"), "Button 1", "First button should have correct label");
+  is(buttons.children[2].getAttribute("image"), "", "First button should have no image");
 
-  is(buttons.childNodes[3].getAttribute("label"), "Button 2", "Second button should have correct label");
-  is(buttons.childNodes[3].getAttribute("image"), imageURL, "Second button should have correct image");
+  is(buttons.children[3].getAttribute("label"), "Button 2", "Second button should have correct label");
+  is(buttons.children[3].getAttribute("image"), imageURL, "Second button should have correct image");
 
   let promiseHidden = promisePanelElementHidden(window, popup);
-  EventUtils.synthesizeMouseAtCenter(buttons.childNodes[3], {}, window);
+  EventUtils.synthesizeMouseAtCenter(buttons.children[3], {}, window);
   await promiseHidden;
 
   ok(true, "Popup should close automatically");
 
   let returnValue = await waitForCallbackResultPromise();
 
   is(returnValue.result, "button2", "Correct callback should have been called");
 }),
diff --git a/browser/components/uitour/test/browser_trackingProtection_tour.js b/browser/components/uitour/test/browser_trackingProtection_tour.js
--- a/browser/components/uitour/test/browser_trackingProtection_tour.js
+++ b/browser/components/uitour/test/browser_trackingProtection_tour.js
@@ -51,17 +51,17 @@ async function checkToggleTarget(targetI
     }, "http-on-opening-request");
   });
 
   await ContentTask.spawn(gBrowser.selectedBrowser, {}, function() {
     let doc = content.document;
     let iframe = doc.createElement("iframe");
     iframe.setAttribute("id", "tracking-element");
     iframe.setAttribute("src", "https://tracking.example.com/");
-    doc.body.insertBefore(iframe, doc.body.firstChild);
+    doc.body.insertBefore(iframe, doc.body.firstElementChild);
   });
 
   await trackerOpened;
 
   let testTargetAvailability = async function(expectedAvailable) {
     let data = await getConfigurationPromise("availableTargets");
     let available = (data.targets.includes(targetID));
     is(available, expectedAvailable, "Target has expected availability.");
diff --git a/browser/extensions/formautofill/FormAutofillHeuristics.jsm b/browser/extensions/formautofill/FormAutofillHeuristics.jsm
--- a/browser/extensions/formautofill/FormAutofillHeuristics.jsm
+++ b/browser/extensions/formautofill/FormAutofillHeuristics.jsm
@@ -323,25 +323,25 @@ var LabelUtils = {
       return this._labelStrings.get(element);
     }
     let strings = [];
     let _extractLabelStrings = (el) => {
       if (this.EXCLUDED_TAGS.includes(el.tagName)) {
         return;
       }
 
-      if (el.nodeType == el.TEXT_NODE || el.childNodes.length == 0) {
+      if (el.nodeType == el.TEXT_NODE || el.children.length == 0) {
         let trimmedText = el.textContent.trim();
         if (trimmedText) {
           strings.push(trimmedText);
         }
         return;
       }
 
-      for (let node of el.childNodes) {
+      for (let node of el.children) {
         let nodeType = node.nodeType;
         if (nodeType != node.ELEMENT_NODE && nodeType != node.TEXT_NODE) {
           continue;
         }
         _extractLabelStrings(node);
       }
     };
     _extractLabelStrings(element);
diff --git a/browser/extensions/formautofill/content/manageDialog.js b/browser/extensions/formautofill/content/manageDialog.js
--- a/browser/extensions/formautofill/content/manageDialog.js
+++ b/browser/extensions/formautofill/content/manageDialog.js
@@ -128,18 +128,18 @@ class ManageRecords {
     }
   }
 
   /**
    * Remove all existing record elements.
    */
   clearRecordElements() {
     let parent = this._elements.records;
-    while (parent.lastChild) {
-      parent.removeChild(parent.lastChild);
+    while (parent.lastElementChild) {
+      parent.removeChild(parent.lastElementChild);
     }
   }
 
   /**
    * Remove records by selected options.
    *
    * @param  {array<DOMElement>} options
    */
diff --git a/browser/extensions/formautofill/test/browser/head.js b/browser/extensions/formautofill/test/browser/head.js
--- a/browser/extensions/formautofill/test/browser/head.js
+++ b/browser/extensions/formautofill/test/browser/head.js
@@ -256,17 +256,17 @@ function removeAddresses(guids) {
 
 function removeCreditCards(guids) {
   info("expecting credit card removed");
   Services.cpmm.sendAsyncMessage("FormAutofill:RemoveCreditCards", {guids});
   return TestUtils.topicObserved("formautofill-storage-changed");
 }
 
 function getNotification(index = 0) {
-  let notifications = PopupNotifications.panel.childNodes;
+  let notifications = PopupNotifications.panel.children;
   ok(notifications.length > 0, "at least one notification displayed");
   ok(true, notifications.length + " notification(s)");
   return notifications[index];
 }
 
 /**
  * Clicks the popup notification button and wait for popup hidden.
  *
diff --git a/browser/extensions/mortar/host/pdf/chrome/js/l20n.js b/browser/extensions/mortar/host/pdf/chrome/js/l20n.js
--- a/browser/extensions/mortar/host/pdf/chrome/js/l20n.js
+++ b/browser/extensions/mortar/host/pdf/chrome/js/l20n.js
@@ -2147,17 +2147,17 @@
   function overlay(sourceElement, translationElement) {
     const result = translationElement.ownerDocument.createDocumentFragment();
     let k, attr;
 
     // take one node from translationElement at a time and check it against
     // the allowed list or try to match it with a corresponding element
     // in the source
     let childElement;
-    while ((childElement = translationElement.childNodes[0])) {
+    while ((childElement = translationElement.children[0])) {
       translationElement.removeChild(childElement);
 
       if (childElement.nodeType === childElement.TEXT_NODE) {
         result.appendChild(childElement);
         continue;
       }
 
       const index = getIndexOfType(childElement);
diff --git a/browser/extensions/mortar/host/pdf/chrome/js/polyfill.js b/browser/extensions/mortar/host/pdf/chrome/js/polyfill.js
--- a/browser/extensions/mortar/host/pdf/chrome/js/polyfill.js
+++ b/browser/extensions/mortar/host/pdf/chrome/js/polyfill.js
@@ -37,17 +37,17 @@ class PolyfillDropdown {
 
     document.body.appendChild(this._polyfill);
 
     let dropdownStyle = getComputedStyle(this._polyfill);
     this._defaultDropdownBorderWidth =
       parseInt(dropdownStyle.getPropertyValue('border-left-width'), 10) +
       parseInt(dropdownStyle.getPropertyValue('border-right-width'), 10);
 
-    let optionStyle = getComputedStyle(this._polyfill.childNodes[0]);
+    let optionStyle = getComputedStyle(this._polyfill.children[0]);
     this._defaultOptionPaddingRight =
       parseInt(optionStyle.getPropertyValue('padding-right'), 10);
 
     this._select.addEventListener('click', this);
     this._select.addEventListener('change', this);
     this._select.addEventListener('blur', this);
     this._select.addEventListener('keydown', this);
   }
@@ -83,17 +83,17 @@ class PolyfillDropdown {
 
     if (this._select.value !== this._currentValue) {
       this._triggerChangeEvent();
     }
   }
 
   _updateOptionStatus() {
     let currentValue = this._select.value;
-    for (let elem of this._polyfill.childNodes) {
+    for (let elem of this._polyfill.children) {
       elem.classList.toggle('toggled', elem.dataset.value === currentValue);
     };
   }
 
   _resize() {
     let rect = this._select.getBoundingClientRect();
     this._polyfill.style.left = rect.left + 'px';
     this._polyfill.style.top = rect.bottom + 'px';
diff --git a/browser/extensions/mortar/host/pdf/chrome/js/toolbar.js b/browser/extensions/mortar/host/pdf/chrome/js/toolbar.js
--- a/browser/extensions/mortar/host/pdf/chrome/js/toolbar.js
+++ b/browser/extensions/mortar/host/pdf/chrome/js/toolbar.js
@@ -210,17 +210,17 @@ class OutlineView extends Sidebar {
 
         if (bookmark.children.length > 0) {
           isMultipleLayer = true;
 
           // Add toogle button
           let toggler = document.createElement('div');
           toggler.className = 'outlineItemToggler';
           toggler.addEventListener('click', this);
-          div.insertBefore(toggler, div.firstChild);
+          div.insertBefore(toggler, div.firstElementChild);
 
           // Add children's container
           let childrenDiv = document.createElement('div');
           childrenDiv.className = 'outlineItems';
           div.appendChild(childrenDiv);
 
           queue.push({ parent: childrenDiv, bookmarks: bookmark.children });
         }
diff --git a/browser/extensions/onboarding/content/Onboarding.jsm b/browser/extensions/onboarding/content/Onboarding.jsm
--- a/browser/extensions/onboarding/content/Onboarding.jsm
+++ b/browser/extensions/onboarding/content/Onboarding.jsm
@@ -537,17 +537,17 @@ class Onboarding {
     this.uiInitialized = true;
     this._tourItems = [];
     this._tourPages = [];
 
     let { body } = this._window.document;
     this._overlayIcon = this._renderOverlayButton();
     this._overlayIcon.addEventListener("click", this);
     this._overlayIcon.addEventListener("keypress", this);
-    body.insertBefore(this._overlayIcon, body.firstChild);
+    body.insertBefore(this._overlayIcon, body.firstElementChild);
 
     this._overlay = this._renderOverlay();
     this._overlay.addEventListener("click", this);
     this._overlay.addEventListener("keydown", this);
     this._overlay.addEventListener("keypress", this);
     body.appendChild(this._overlay);
 
     this._loadJS(TOUR_AGENT_JS_URI);
@@ -690,17 +690,17 @@ class Onboarding {
     return Math.round(this._windowWidth / 50) * 50;
   }
 
   handleClick(target) {
     let { id, classList } = target;
     // Only containers receive pointer events in onboarding tour tab list,
     // actual semantic tab is their first child.
     if (classList.contains("onboarding-tour-item-container")) {
-      ({ id, classList } = target.firstChild);
+      ({ id, classList } = target.firstElementChild);
     }
 
     switch (id) {
       case "onboarding-overlay-button":
         this.telemetry({
           type: "onboarding-logo-click",
           bubble_state: this._bubbleState,
           logo_state: this._logoState,
@@ -822,17 +822,17 @@ class Onboarding {
   }
 
   handleKeydown(event) {
     let { target, key, shiftKey } = event;
 
     // Currently focused item could be tab container if previous navigation was done
     // via mouse.
     if (target.classList.contains("onboarding-tour-item-container")) {
-      target = target.firstChild;
+      target = target.firstElementChild;
     }
     let targetIndex;
     switch (key) {
       case "ArrowUp":
         // Go to and focus on the previous tab if it's available.
         targetIndex = this._tourItems.indexOf(target);
         if (targetIndex > 0) {
           let previous = this._tourItems[targetIndex - 1];
@@ -878,17 +878,17 @@ class Onboarding {
         event.preventDefault();
       }
       return;
     }
 
     // Currently focused item could be tab container if previous navigation was done
     // via mouse.
     if (target.classList.contains("onboarding-tour-item-container")) {
-      target = target.firstChild;
+      target = target.firstElementChild;
     }
     switch (key) {
       case " ":
       case "Enter":
         // Assume that the handle function should be identical for keyboard
         // activation if there is a click handler for the target.
         if (target.classList.contains("onboarding-tour-item")) {
           this.handleClick(target);
diff --git a/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js b/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js
--- a/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js
+++ b/browser/extensions/onboarding/test/browser/browser_onboarding_accessibility.js
@@ -9,26 +9,26 @@ add_task(async function test_onboarding_
 
   info("Wait for onboarding overlay loaded");
   let tab = await openTab(ABOUT_HOME_URL);
   await promiseOnboardingOverlayLoaded(tab.linkedBrowser);
 
   info("Test accessibility and semantics of the overlay button");
   await ContentTask.spawn(tab.linkedBrowser, {}, function() {
     let doc = content.document;
-    let button = doc.body.firstChild;
+    let button = doc.body.firstElementChild;
     is(button.id, "onboarding-overlay-button",
       "First child is an overlay button");
     ok(button.getAttribute("aria-label"),
       "Onboarding button has an accessible label");
     is(button.getAttribute("aria-haspopup"), "true",
       "Onboarding button should indicate that it triggers a popup");
     is(button.getAttribute("aria-controls"), "onboarding-overlay-dialog",
       "Onboarding button semantically controls an overlay dialog");
-    is(button.firstChild.getAttribute("role"), "presentation",
+    is(button.firstElementChild.getAttribute("role"), "presentation",
       "Onboarding button icon should have presentation only semantics");
   });
 
   BrowserTestUtils.removeTab(tab);
 });
 
 add_task(async function test_onboarding_notification_bar() {
   resetOnboardingDefaultState();
diff --git a/browser/extensions/pdfjs/content/build/pdf.js b/browser/extensions/pdfjs/content/build/pdf.js
--- a/browser/extensions/pdfjs/content/build/pdf.js
+++ b/browser/extensions/pdfjs/content/build/pdf.js
@@ -8615,34 +8615,34 @@ class Metadata {
         }
       }
       return '>' + chars;
     });
   }
   _parse(xmlDocument) {
     let rdf = xmlDocument.documentElement;
     if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
-      rdf = rdf.firstChild;
+      rdf = rdf.firstElementChild;
       while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
-        rdf = rdf.nextSibling;
+        rdf = rdf.nextElementSibling;
       }
     }
     let nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
     if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {
       return;
     }
-    let children = rdf.childNodes;
+    let children = rdf.children;
     for (let i = 0, ii = children.length; i < ii; i++) {
       let desc = children[i];
       if (desc.nodeName.toLowerCase() !== 'rdf:description') {
         continue;
       }
-      for (let j = 0, jj = desc.childNodes.length; j < jj; j++) {
-        if (desc.childNodes[j].nodeName.toLowerCase() !== '#text') {
-          let entry = desc.childNodes[j];
+      for (let j = 0, jj = desc.children.length; j < jj; j++) {
+        if (desc.children[j].nodeName.toLowerCase() !== '#text') {
+          let entry = desc.children[j];
           let name = entry.nodeName.toLowerCase();
           this._metadata[name] = entry.textContent.trim();
         }
       }
     }
   }
   get(name) {
     return this._metadata[name] || null;
@@ -8902,32 +8902,32 @@ class SimpleDOMNode {
     this.nodeName = nodeName;
     this.nodeValue = nodeValue;
     Object.defineProperty(this, 'parentNode', {
       value: null,
       writable: true
     });
   }
   get firstChild() {
-    return this.childNodes[0];
+    return this.children[0];
   }
   get nextSibling() {
-    let index = this.parentNode.childNodes.indexOf(this);
-    return this.parentNode.childNodes[index + 1];
+    let index = this.parentNode.children.indexOf(this);
+    return this.parentNode.children[index + 1];
   }
   get textContent() {
-    if (!this.childNodes) {
+    if (!this.children) {
       return this.nodeValue || '';
     }
-    return this.childNodes.map(function (child) {
+    return this.children.map(function (child) {
       return child.textContent;
     }).join('');
   }
   hasChildNodes() {
-    return this.childNodes && this.childNodes.length > 0;
+    return this.children && this.children.length > 0;
   }
 }
 class SimpleXMLParser extends XMLParserBase {
   constructor() {
     super();
     this._currentFragment = null;
     this._stack = null;
     this._errorCode = XMLParserErrorCode.NoError;
@@ -8961,29 +8961,29 @@ class SimpleXMLParser extends XMLParserB
     this._currentFragment.push(node);
   }
   onCdata(text) {
     const node = new SimpleDOMNode('#text', text);
     this._currentFragment.push(node);
   }
   onBeginElement(name, attributes, isEmpty) {
     const node = new SimpleDOMNode(name);
-    node.childNodes = [];
+    node.children = [];
     this._currentFragment.push(node);
     if (isEmpty) {
       return;
     }
     this._stack.push(this._currentFragment);
-    this._currentFragment = node.childNodes;
+    this._currentFragment = node.children;
   }
   onEndElement(name) {
     this._currentFragment = this._stack.pop();
     const lastElement = this._currentFragment[this._currentFragment.length - 1];
-    for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
-      lastElement.childNodes[i].parentNode = lastElement;
+    for (let i = 0, ii = lastElement.children.length; i < ii; i++) {
+      lastElement.children[i].parentNode = lastElement;
     }
   }
   onError(code) {
     this._errorCode = code;
   }
 }
 exports.SimpleXMLParser = SimpleXMLParser;
 
diff --git a/browser/extensions/pdfjs/content/web/debugger.js b/browser/extensions/pdfjs/content/web/debugger.js
--- a/browser/extensions/pdfjs/content/web/debugger.js
+++ b/browser/extensions/pdfjs/content/web/debugger.js
@@ -437,17 +437,17 @@ var Stepper = (function StepperClosure()
   };
   return Stepper;
 })();
 
 var Stats = (function Stats() {
   var stats = [];
   function clear(node) {
     while (node.hasChildNodes()) {
-      node.removeChild(node.lastChild);
+      node.removeChild(node.lastElementChild);
     }
   }
   function getStatIndex(pageNumber) {
     for (var i = 0, ii = stats.length; i < ii; ++i) {
       if (stats[i].pageNumber === pageNumber) {
         return i;
       }
     }
diff --git a/browser/extensions/pdfjs/content/web/viewer.js b/browser/extensions/pdfjs/content/web/viewer.js
--- a/browser/extensions/pdfjs/content/web/viewer.js
+++ b/browser/extensions/pdfjs/content/web/viewer.js
@@ -5284,17 +5284,17 @@ class PDFOutlineViewer {
     toggler.onclick = evt => {
       evt.stopPropagation();
       toggler.classList.toggle('outlineItemsHidden');
       if (evt.shiftKey) {
         let shouldShowAll = !toggler.classList.contains('outlineItemsHidden');
         this._toggleOutlineItem(div, shouldShowAll);
       }
     };
-    div.insertBefore(toggler, div.firstChild);
+    div.insertBefore(toggler, div.firstElementChild);
   }
   _toggleOutlineItem(root, show) {
     this.lastToggleIsShow = show;
     let togglers = root.querySelectorAll('.outlineItemToggler');
     for (let i = 0, ii = togglers.length; i < ii; ++i) {
       togglers[i].classList[show ? 'remove' : 'add']('outlineItemsHidden');
     }
   }
@@ -6088,17 +6088,17 @@ class PDFThumbnailView {
     this.cancelRendering();
     this.pageWidth = this.viewport.width;
     this.pageHeight = this.viewport.height;
     this.pageRatio = this.pageWidth / this.pageHeight;
     this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
     this.scale = this.canvasWidth / this.pageWidth;
     this.div.removeAttribute('data-loaded');
     let ring = this.ring;
-    let childNodes = ring.childNodes;
+    let childNodes = ring.children;
     for (let i = childNodes.length - 1; i >= 0; i--) {
       ring.removeChild(childNodes[i]);
     }
     let borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
     ring.style.width = this.canvasWidth + borderAdjustment + 'px';
     ring.style.height = this.canvasHeight + borderAdjustment + 'px';
     if (this.canvas) {
       this.canvas.width = 0;
@@ -7356,31 +7356,31 @@ class PDFPageView {
     if (this.pdfPage) {
       this.pdfPage.cleanup();
     }
   }
   _resetZoomLayer(removeFromDOM = false) {
     if (!this.zoomLayer) {
       return;
     }
-    let zoomLayerCanvas = this.zoomLayer.firstChild;
+    let zoomLayerCanvas = this.zoomLayer.firstElementChild;
     this.paintedViewportMap.delete(zoomLayerCanvas);
     zoomLayerCanvas.width = 0;
     zoomLayerCanvas.height = 0;
     if (removeFromDOM) {
       this.zoomLayer.remove();
     }
     this.zoomLayer = null;
   }
   reset(keepZoomLayer = false, keepAnnotations = false) {
     this.cancelRendering(keepAnnotations);
     let div = this.div;
     div.style.width = Math.floor(this.viewport.width) + 'px';
     div.style.height = Math.floor(this.viewport.height) + 'px';
-    let childNodes = div.childNodes;
+    let childNodes = div.children;
     let currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;
     let currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null;
     for (let i = childNodes.length - 1; i >= 0; i--) {
       let node = childNodes[i];
       if (currentZoomLayerNode === node || currentAnnotationNode === node) {
         continue;
       }
       div.removeChild(node);
@@ -7446,17 +7446,17 @@ class PDFPageView {
         return;
       }
       if (!this.zoomLayer && !this.canvas.hasAttribute('hidden')) {
         this.zoomLayer = this.canvas.parentNode;
         this.zoomLayer.style.position = 'absolute';
       }
     }
     if (this.zoomLayer) {
-      this.cssTransform(this.zoomLayer.firstChild);
+      this.cssTransform(this.zoomLayer.firstElementChild);
     }
     this.reset(true, true);
   }
   cancelRendering(keepAnnotations = false) {
     if (this.paintTask) {
       this.paintTask.cancel();
       this.paintTask = null;
     }
@@ -8312,17 +8312,17 @@ class PDFSinglePageViewer extends _base_
   _resetView() {
     super._resetView();
     this._previousPageNumber = 1;
     this._shadowViewer = document.createDocumentFragment();
   }
   _ensurePageViewVisible() {
     let pageView = this._pages[this._currentPageNumber - 1];
     let previousPageView = this._pages[this._previousPageNumber - 1];
-    let viewerNodes = this.viewer.childNodes;
+    let viewerNodes = this.viewer.children;
     switch (viewerNodes.length) {
       case 0:
         this.viewer.appendChild(pageView.div);
         break;
       case 1:
         if (viewerNodes[0] !== previousPageView.div) {
           throw new Error('_ensurePageViewVisible: Unexpected previously visible page.');
         }
diff --git a/browser/extensions/pocket/bootstrap.js b/browser/extensions/pocket/bootstrap.js
--- a/browser/extensions/pocket/bootstrap.js
+++ b/browser/extensions/pocket/bootstrap.js
@@ -281,35 +281,35 @@ var PocketContextMenu = {
     if (!menu) {
       menu = createElementWithAttrs(document, "menuitem", {
         "id": "context-pocket",
         "label": gPocketBundle.GetStringFromName("saveToPocketCmd.label"),
         "accesskey": gPocketBundle.GetStringFromName("saveToPocketCmd.accesskey"),
         "oncommand": "Pocket.savePage(gContextMenu.browser, gContextMenu.browser.currentURI.spec, gContextMenu.browser.contentTitle);"
       });
       let sibling = document.getElementById("context-savepage");
-      if (sibling.nextSibling) {
-        sibling.parentNode.insertBefore(menu, sibling.nextSibling);
+      if (sibling.nextElementSibling) {
+        sibling.parentNode.insertBefore(menu, sibling.nextElementSibling);
       } else {
         sibling.parentNode.appendChild(menu);
       }
     }
     menu.hidden = !(canPocket && showSaveCurrentPageToPocket);
 
     menu = document.getElementById("context-savelinktopocket");
     if (!menu) {
       menu = createElementWithAttrs(document, "menuitem", {
         "id": "context-savelinktopocket",
         "label": gPocketBundle.GetStringFromName("saveLinkToPocketCmd.label"),
         "accesskey": gPocketBundle.GetStringFromName("saveLinkToPocketCmd.accesskey"),
         "oncommand": "Pocket.savePage(gContextMenu.browser, gContextMenu.linkURL);"
       });
       let sibling = document.getElementById("context-savelink");
-      if (sibling.nextSibling) {
-        sibling.parentNode.insertBefore(menu, sibling.nextSibling);
+      if (sibling.nextElementSibling) {
+        sibling.parentNode.insertBefore(menu, sibling.nextElementSibling);
       } else {
         sibling.parentNode.appendChild(menu);
       }
     }
     menu.hidden = !showSaveLinkToPocket;
   }
 };
 
diff --git a/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js b/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js
--- a/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js
+++ b/browser/extensions/screenshots/test/browser/browser_screenshots_ui_check.js
@@ -51,18 +51,18 @@ function promisePageActionPanelEvent(eve
     }, { once: true });
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   const dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    const bodyNode = panelViewNode.firstChild;
-    for (const childNode of bodyNode.childNodes) {
+    const bodyNode = panelViewNode.firstElementChild;
+    for (const childNode of bodyNode.children) {
       const bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
diff --git a/browser/extensions/screenshots/webextension/selector/uicontrol.js b/browser/extensions/screenshots/webextension/selector/uicontrol.js
--- a/browser/extensions/screenshots/webextension/selector/uicontrol.js
+++ b/browser/extensions/screenshots/webextension/selector/uicontrol.js
@@ -397,27 +397,27 @@ this.uicontrol = (function() {
         const evenBetter = this.evenBetterElement(node, rect);
         if (evenBetter) {
           node = lastNode = evenBetter;
           rect = Selection.getBoundingClientRect(evenBetter);
           attemptExtend = false;
         }
       }
       if (rect && attemptExtend) {
-        let extendNode = lastNode.nextSibling;
+        let extendNode = lastNode.nextElementSibling;
         while (extendNode) {
           if (extendNode.nodeType === document.ELEMENT_NODE) {
             break;
           }
-          extendNode = extendNode.nextSibling;
+          extendNode = extendNode.nextElementSibling;
           if (!extendNode) {
             const parent = lastNode.parentNode;
-            for (let i = 0; i < parent.childNodes.length; i++) {
-              if (parent.childNodes[i] === lastNode) {
-                extendNode = parent.childNodes[i + 1];
+            for (let i = 0; i < parent.children.length; i++) {
+              if (parent.children[i] === lastNode) {
+                extendNode = parent.children[i + 1];
               }
             }
           }
         }
         if (extendNode) {
           const extendSelection = Selection.getBoundingClientRect(extendNode);
           const extendRect = rect.union(extendSelection);
           if (extendRect.width <= MAX_DETECT_WIDTH && extendRect.height <= MAX_DETECT_HEIGHT) {
diff --git a/browser/extensions/screenshots/webextension/selector/util.js b/browser/extensions/screenshots/webextension/selector/util.js
--- a/browser/extensions/screenshots/webextension/selector/util.js
+++ b/browser/extensions/screenshots/webextension/selector/util.js
@@ -55,18 +55,18 @@ this.util = (function() { // eslint-disa
         // Totally outside of the box
         return;
       }
       if (elBox.bottom > box.bottom + CAPTURE_WIGGLE ||
           elBox.top < box.top - CAPTURE_WIGGLE ||
           elBox.right > box.right + CAPTURE_WIGGLE ||
           elBox.left < box.left - CAPTURE_WIGGLE) {
         // Partially outside the box
-        for (let i = 0; i < el.childNodes.length; i++) {
-          const child = el.childNodes[i];
+        for (let i = 0; i < el.children.length; i++) {
+          const child = el.children[i];
           if (child.nodeType === ELEMENT_NODE) {
             traverse(child);
           }
         }
         return;
       }
       addText(el);
     }
diff --git a/browser/extensions/webcompat-reporter/test/browser/head.js b/browser/extensions/webcompat-reporter/test/browser/head.js
--- a/browser/extensions/webcompat-reporter/test/browser/head.js
+++ b/browser/extensions/webcompat-reporter/test/browser/head.js
@@ -51,18 +51,18 @@ function promisePageActionPanelShown() {
     }, { once: true });
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    let bodyNode = panelViewNode.firstChild;
-    for (let childNode of bodyNode.childNodes) {
+    let bodyNode = panelViewNode.firstElementChild;
+    for (let childNode of bodyNode.children) {
       let bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
diff --git a/browser/modules/AsyncTabSwitcher.jsm b/browser/modules/AsyncTabSwitcher.jsm
--- a/browser/modules/AsyncTabSwitcher.jsm
+++ b/browser/modules/AsyncTabSwitcher.jsm
@@ -409,17 +409,17 @@ class AsyncTabSwitcher {
     if (this.visibleTab !== showTab) {
       this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
       this.visibleTab = showTab;
 
       this.maybeVisibleTabs.add(showTab);
 
       let tabpanels = this.tabbrowser.tabpanels;
       let showPanel = this.tabbrowser.tabContainer.getRelatedElement(showTab);
-      let index = Array.indexOf(tabpanels.childNodes, showPanel);
+      let index = Array.indexOf(tabpanels.children, showPanel);
       if (index != -1) {
         this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
         tabpanels.setAttribute("selectedIndex", index);
         if (showTab === this.requestedTab) {
           if (this._requestingTab) {
             /*
              * If _requestingTab is set, that means that we're switching the
              * visibility of the tab synchronously, and we need to wait for
diff --git a/browser/modules/ContextMenu.jsm b/browser/modules/ContextMenu.jsm
--- a/browser/modules/ContextMenu.jsm
+++ b/browser/modules/ContextMenu.jsm
@@ -324,17 +324,17 @@ class ContextMenu {
            this.context.linkProtocol == "javascript" ||
            this.context.linkProtocol == "news" ||
            this.context.linkProtocol == "snews");
   }
 
   // Gather all descendent text under given document node.
   _gatherTextUnder(root) {
     let text = "";
-    let node = root.firstChild;
+    let node = root.firstElementChild;
     let depth = 1;
     while (node && depth > 0) {
       // See if this node is text.
       if (node.nodeType == node.TEXT_NODE) {
         // Add this text to our collection.
         text += " " + node.data;
       } else if (node instanceof this.content.HTMLImageElement) {
         // If it has an "alt" attribute, add that.
@@ -342,26 +342,26 @@ class ContextMenu {
         if ( altText && altText != "" ) {
           text += " " + altText;
         }
       }
       // Find next node to test.
       // First, see if this node has children.
       if (node.hasChildNodes()) {
         // Go to first child.
-        node = node.firstChild;
+        node = node.firstElementChild;
         depth++;
       } else {
         // No children, try next sibling (or parent next sibling).
-        while (depth > 0 && !node.nextSibling) {
+        while (depth > 0 && !node.nextElementSibling) {
           node = node.parentNode;
           depth--;
         }
-        if (node.nextSibling) {
-          node = node.nextSibling;
+        if (node.nextElementSibling) {
+          node = node.nextElementSibling;
         }
       }
     }
 
     // Strip leading and tailing whitespace.
     text = text.trim();
     // Compress remaining whitespace.
     text = text.replace(/\s+/g, " ");
diff --git a/browser/modules/ExtensionsUI.jsm b/browser/modules/ExtensionsUI.jsm
--- a/browser/modules/ExtensionsUI.jsm
+++ b/browser/modules/ExtensionsUI.jsm
@@ -284,18 +284,18 @@ var ExtensionsUI = {
           textEl.textContent = strings.text;
           textEl.hidden = !strings.text;
 
           let listIntroEl = doc.getElementById("addon-webext-perm-intro");
           listIntroEl.textContent = strings.listIntro;
           listIntroEl.hidden = (strings.msgs.length == 0);
 
           let list = doc.getElementById("addon-webext-perm-list");
-          while (list.firstChild) {
-            list.firstChild.remove();
+          while (list.firstElementChild) {
+            list.firstElementChild.remove();
           }
 
           for (let msg of strings.msgs) {
             let item = doc.createElementNS(HTML_NS, "li");
             item.textContent = msg;
             list.appendChild(item);
           }
         } else if (topic == "swapping") {
diff --git a/browser/modules/FormValidationHandler.jsm b/browser/modules/FormValidationHandler.jsm
--- a/browser/modules/FormValidationHandler.jsm
+++ b/browser/modules/FormValidationHandler.jsm
@@ -99,17 +99,17 @@ var FormValidationHandler =
    *    content is remote, this is relative to the browser, otherwise its
    *    relative to the window.
    *   position - popup positional string constants.
    *   message - the form element validation message text.
    */
   _showPopup(aWindow, aPanelData) {
     let previouslyShown = !!this._panel;
     this._panel = aWindow.document.getElementById("invalid-form-popup");
-    this._panel.firstChild.textContent = aPanelData.message;
+    this._panel.firstElementChild.textContent = aPanelData.message;
     this._panel.hidden = false;
 
     let tabBrowser = aWindow.gBrowser;
     this._anchor = tabBrowser.popupAnchor;
     this._anchor.left = aPanelData.contentRect.left;
     this._anchor.top = aPanelData.contentRect.top;
     this._anchor.width = aPanelData.contentRect.width;
     this._anchor.height = aPanelData.contentRect.height;
diff --git a/browser/modules/PageInfoListener.jsm b/browser/modules/PageInfoListener.jsm
--- a/browser/modules/PageInfoListener.jsm
+++ b/browser/modules/PageInfoListener.jsm
@@ -329,20 +329,20 @@ var PageInfoListener = {
     // Form input elements don't generally contain information that is useful to our callers, so return nothing.
     if (node instanceof content.HTMLInputElement ||
         node instanceof content.HTMLSelectElement ||
         node instanceof content.HTMLTextAreaElement) {
       return valueText;
     }
 
     // Otherwise recurse for each child.
-    let length = node.childNodes.length;
+    let length = node.children.length;
 
     for (let i = 0; i < length; i++) {
-      let childNode = node.childNodes[i];
+      let childNode = node.children[i];
       let nodeType = childNode.nodeType;
 
       // Text nodes are where the goods are.
       if (nodeType == content.Node.TEXT_NODE) {
         valueText += " " + childNode.nodeValue;
       } else if (nodeType == content.Node.ELEMENT_NODE) {
         // And elements can have more text inside them.
         // Images are special, we want to capture the alt text as if the image weren't there.
@@ -360,19 +360,19 @@ var PageInfoListener = {
   // Copied from the Links Panel v2.3, http://segment7.net/mozilla/links/links.html.
   // Traverse the tree in search of an img or area element and grab its alt tag.
   getAltText(node) {
     let altText = "";
 
     if (node.alt) {
       return node.alt;
     }
-    let length = node.childNodes.length;
+    let length = node.children.length;
     for (let i = 0; i < length; i++) {
-      if ((altText = this.getAltText(node.childNodes[i]) != undefined)) { // stupid js warning...
+      if ((altText = this.getAltText(node.children[i]) != undefined)) { // stupid js warning...
         return altText;
       }
     }
     return "";
   },
 
   // Copied from the Links Panel v2.3, http://segment7.net/mozilla/links/links.html.
   // Strip leading and trailing whitespace, and replace multiple consecutive whitespace characters with a single space.
diff --git a/browser/modules/TabsList.jsm b/browser/modules/TabsList.jsm
--- a/browser/modules/TabsList.jsm
+++ b/browser/modules/TabsList.jsm
@@ -114,20 +114,20 @@ class TabsListBase {
     } else if (this.filterFn(tab)) {
       // The tab now matches our criteria, add a row for it.
       this._addTab(tab);
     }
   }
 
   _addTab(newTab) {
     let newRow = this._createRow(newTab);
-    let nextTab = newTab.nextSibling;
+    let nextTab = newTab.nextElementSibling;
 
     while (nextTab && !this.filterFn(nextTab)) {
-      nextTab = nextTab.nextSibling;
+      nextTab = nextTab.nextElementSibling;
     }
 
     if (nextTab) {
       // If we found a tab after this one in the list, insert the new row before it.
       let nextRow = this.tabToElement.get(nextTab);
       nextRow.parentNode.insertBefore(newRow, nextRow);
     } else {
       // If there's no next tab then insert it as usual.
@@ -152,17 +152,17 @@ const TABS_PANEL_EVENTS = {
   show: "ViewShowing",
   hide: "PanelMultiViewHidden",
 };
 
 class TabsPanel extends TabsListBase {
   constructor(opts) {
     super({
       ...opts,
-      containerNode: opts.containerNode || opts.view.firstChild,
+      containerNode: opts.containerNode || opts.view.firstElementChild,
     });
     this.view = opts.view;
     this.view.addEventListener(TABS_PANEL_EVENTS.show, this);
     this.panelMultiView = null;
   }
 
   handleEvent(event) {
     switch (event.type) {
@@ -245,17 +245,17 @@ class TabsPanel extends TabsListBase {
 
     return row;
   }
 
   _setRowAttributes(row, tab) {
     setAttributes(row, {selected: tab.selected});
 
     let busy = tab.getAttribute("busy");
-    let button = row.firstChild;
+    let button = row.firstElementChild;
     setAttributes(button, {
       busy,
       label: tab.label,
       image: !busy && tab.getAttribute("image"),
       iconloadingprincipal: tab.getAttribute("iconloadingprincipal"),
     });
 
     this._setImageAttributes(row, tab);
@@ -264,17 +264,17 @@ class TabsPanel extends TabsListBase {
     setAttributes(secondaryButton, {
       muted: tab.muted,
       soundplaying: tab.soundPlaying,
       hidden: !(tab.muted || tab.soundPlaying),
     });
   }
 
   _setImageAttributes(row, tab) {
-    let button = row.firstChild;
+    let button = row.firstElementChild;
     let image = this.doc.getAnonymousElementByAttribute(
       button, "class", "toolbarbutton-icon") ||
       this.doc.getAnonymousElementByAttribute(
         button, "class", "toolbarbutton-icon tab-throbber-fallback");
 
     if (image) {
       let busy = tab.getAttribute("busy");
       let progress = tab.getAttribute("progress");
diff --git a/browser/modules/test/browser/browser_PageActions.js b/browser/modules/test/browser/browser_PageActions.js
--- a/browser/modules/test/browser/browser_PageActions.js
+++ b/browser/modules/test/browser/browser_PageActions.js
@@ -172,31 +172,31 @@ add_task(async function simple() {
   Assert.deepEqual(PageActions.actionForID(action.id), action,
                    "actionForID should be action");
 
   Assert.ok(PageActions._persistedActions.ids.includes(action.id),
             "PageActions should record action in its list of seen actions");
 
   // The action's panel button should have been created.
   let panelButtonNode =
-    BrowserPageActions.mainViewBodyNode.childNodes[indexInPanel];
+    BrowserPageActions.mainViewBodyNode.children[indexInPanel];
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
   Assert.equal(panelButtonNode.id, panelButtonID, "panelButtonID");
   Assert.equal(panelButtonNode.getAttribute("label"), action.getTitle(),
                "label");
   for (let name in action.nodeAttributes) {
     Assert.ok(panelButtonNode.hasAttribute(name), "Has attribute: " + name);
     Assert.equal(panelButtonNode.getAttribute(name),
                  action.nodeAttributes[name],
                  "Equal attribute: " + name);
   }
 
   // The separator between the built-ins and non-built-ins should exist.
   let sepNode =
-    BrowserPageActions.mainViewBodyNode.childNodes[sepIndex];
+    BrowserPageActions.mainViewBodyNode.children[sepIndex];
   Assert.notEqual(sepNode, null, "sepNode");
   Assert.equal(
     sepNode.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     ),
     "sepNode.id"
   );
@@ -224,19 +224,19 @@ add_task(async function simple() {
     Assert.ok(urlbarButtonNode.hasAttribute(name), name,
               "Has attribute: " + name);
     Assert.equal(urlbarButtonNode.getAttribute(name),
                  action.nodeAttributes[name],
                  "Equal attribute: " + name);
   }
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Disable the action.  The button in the urlbar should be removed, and the
   // button in the panel should be disabled.
   action.setDisabled(true);
   urlbarButtonNode = document.getElementById(urlbarButtonID);
@@ -299,17 +299,17 @@ add_task(async function simple() {
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     )
   );
   if (initialSepIndex < 0) {
     // The separator between the built-in actions and non-built-in actions
     // should be gone now, too.
     Assert.equal(separatorNode, null, "No separator");
     Assert.ok(!BrowserPageActions.mainViewBodyNode
-              .lastChild.localName.includes("separator"),
+              .lastElementChild.localName.includes("separator"),
               "Last child should not be separator");
   } else {
     // The separator should still be present.
     Assert.notEqual(separatorNode, null, "Separator should still exist");
   }
 
   Assert.deepEqual(PageActions.actionsInPanel(window), initialActionsInPanel,
                    "Actions in panel should go back to initial");
@@ -410,19 +410,19 @@ add_task(async function withSubview() {
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The action's urlbar button should have been created.
   let urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Click the action's button in the panel.  The subview should be shown.
   Assert.equal(onSubviewShowingCount, 0,
                "onSubviewShowingCount should remain 0");
   let subviewShownPromise = promisePageActionViewShown();
@@ -523,19 +523,19 @@ add_task(async function withIframe() {
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The action's urlbar button should have been created.
   let urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Open the panel, click the action's button.
   await promiseOpenPageActionPanel();
   Assert.equal(onIframeShowingCount, 0, "onIframeShowingCount should remain 0");
   EventUtils.synthesizeMouseAtCenter(panelButtonNode, {});
@@ -644,24 +644,24 @@ add_task(async function insertBeforeActi
   Assert.equal(newBookmarkSeparatorIndex, initialBookmarkSeparatorIndex + 1,
                "newBookmarkSeparatorIndex");
 
   // The action's panel button should have been created.
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The button's next sibling should be the bookmark separator.
-  Assert.notEqual(panelButtonNode.nextSibling, null,
-                  "panelButtonNode.nextSibling");
+  Assert.notEqual(panelButtonNode.nextElementSibling, null,
+                  "panelButtonNode.nextElementSibling");
   Assert.equal(
-    panelButtonNode.nextSibling.id,
+    panelButtonNode.nextElementSibling.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BOOKMARK_SEPARATOR
     ),
-    "panelButtonNode.nextSibling.id"
+    "panelButtonNode.nextElementSibling.id"
   );
 
   // The separator between the built-in and non-built-in actions should not have
   // been created.
   Assert.equal(
     document.getElementById(
       BrowserPageActions.panelButtonNodeIDForActionID(
         PageActions.ACTION_ID_BUILT_IN_SEPARATOR
@@ -719,33 +719,33 @@ add_task(async function multipleNonBuilt
   await promisePageActionPanelHidden();
 
   // Check the button nodes in the panel.
   let expectedIndex = 1;
   let buttonNode = document.getElementById(
     BrowserPageActions.panelButtonNodeIDForActionID(idPrefix + expectedIndex)
   );
   Assert.notEqual(buttonNode, null, "buttonNode");
-  Assert.notEqual(buttonNode.previousSibling, null,
-                  "buttonNode.previousSibling");
+  Assert.notEqual(buttonNode.previousElementSibling, null,
+                  "buttonNode.previousElementSibling");
   Assert.equal(
-    buttonNode.previousSibling.id,
+    buttonNode.previousElementSibling.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     ),
-    "buttonNode.previousSibling.id"
+    "buttonNode.previousElementSibling.id"
   );
   for (let i = 0; i < actions.length; i++) {
     Assert.notEqual(buttonNode, null, "buttonNode at index: " + i);
     Assert.equal(
       buttonNode.id,
       BrowserPageActions.panelButtonNodeIDForActionID(idPrefix + expectedIndex),
       "buttonNode.id at index: " + i
     );
-    buttonNode = buttonNode.nextSibling;
+    buttonNode = buttonNode.nextElementSibling;
     expectedIndex++;
   }
   Assert.equal(buttonNode, null, "Nothing should come after the last button");
 
   for (let action of actions) {
     action.remove();
   }
 
@@ -778,17 +778,17 @@ add_task(async function nonBuiltFirst() 
   Assert.deepEqual(PageActions.actions.map(a => a.id), [],
                    "PageActions.actions should be empty");
   Assert.deepEqual(PageActions._builtInActions.map(a => a.id), [],
                    "PageActions._builtInActions should be empty");
   Assert.deepEqual(PageActions._nonBuiltInActions.map(a => a.id), [],
                    "PageActions._nonBuiltInActions should be empty");
 
   // Check the panel.
-  Assert.equal(BrowserPageActions.mainViewBodyNode.childNodes.length, 0,
+  Assert.equal(BrowserPageActions.mainViewBodyNode.children.length, 0,
                "All nodes should be gone");
 
   // Add a non-built-in action.
   let action = PageActions.addAction(new PageActions.Action({
     id: "test-nonBuiltFirst",
     title: "Test nonBuiltFirst",
   }));
 
@@ -800,17 +800,17 @@ add_task(async function nonBuiltFirst() 
   Assert.deepEqual(PageActions._nonBuiltInActions.map(a => a.id), [action.id],
                    "Action should be in PageActions._nonBuiltInActions");
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     [BrowserPageActions.panelButtonNodeIDForActionID(action.id)],
     "Action should be in panel"
   );
 
   // Now add back all the actions.
   for (let a of initialActions) {
     PageActions.addAction(a);
   }
@@ -842,17 +842,17 @@ add_task(async function nonBuiltFirst() 
     PageActions.actionsInPanel(window).map(a => a.id),
     initialActionsInPanel.map(a => a.id).concat(
       [PageActions.ACTION_ID_BUILT_IN_SEPARATOR],
       [action.id]
     ),
     "All actions should be in PageActions.actionsInPanel()"
   );
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat(
       [PageActions.ACTION_ID_BUILT_IN_SEPARATOR],
       [action.id]
     ).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Panel should contain all actions"
   );
 
   // Remove the test action.
@@ -880,17 +880,17 @@ add_task(async function nonBuiltFirst() 
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
     PageActions.actionsInPanel(window).map(a => a.id),
     initialActionsInPanel.map(a => a.id),
     "Action should no longer be in PageActions.actionsInPanel()"
   );
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => BrowserPageActions.panelButtonNodeIDForActionID(a.id)),
     "Action should no longer be in panel"
   );
 });
 
 
 // Makes sure that urlbar nodes appear in the correct order in a new window.
 add_task(async function urlbarOrderNewWindow() {
@@ -950,19 +950,19 @@ add_task(async function urlbarOrderNewWi
   // not appear in the new window (or any window at this point).
   ids = ids.filter(id => PageActions.actionForID(id));
 
   // Open the new window.
   let win = await BrowserTestUtils.openNewBrowserWindow();
 
   // Collect its urlbar nodes.
   let actualUrlbarNodeIDs = [];
-  for (let node = win.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = win.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
 
   // Now check that they're in the right order.
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     ids.map(id => win.BrowserPageActions.urlbarButtonNodeIDForActionID(id)),
     "Expected actions in new window's urlbar"
@@ -1030,19 +1030,19 @@ add_task(async function migrate1() {
   let win = await BrowserTestUtils.openNewBrowserWindow();
   await BrowserTestUtils.openNewForegroundTab({
     gBrowser: win.gBrowser,
     url: "http://example.com/",
   });
 
   // Collect its urlbar nodes.
   let actualUrlbarNodeIDs = [];
-  for (let node = win.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = win.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
 
   // Now check that they're in the right order.
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     orderedIDs.map(id => win.BrowserPageActions.urlbarButtonNodeIDForActionID(id)),
     "Expected actions in new window's urlbar"
@@ -1133,32 +1133,32 @@ add_task(async function perWindowState()
   Assert.deepEqual(
     PageActions.actionsInUrlbar(newWindow).map(a => a.id),
     actionsInUrlbar.map(a => a.id).filter(id => id != action.id),
     "PageActions.actionsInUrlbar: new window should have all actions in urlbar except the test action"
   );
 
   // Check the urlbar nodes for the old window.
   let actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     actionsInUrlbar.map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "Old window should have all nodes in urlbar"
   );
 
   // Check the urlbar nodes for the new window.
   actualUrlbarNodeIDs = [];
-  for (let node = newWindow.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = newWindow.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     actionsInUrlbar.filter(a => a.id != action.id).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "New window should have all nodes in urlbar except for the test action's"
   );
 
@@ -1200,19 +1200,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     [testAction].concat(initialActionsInUrlbar).map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order: testAction followed by all initial actions"
   );
 
   // Check the nodes in the urlbar.
   let actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     [testAction].concat(initialActionsInUrlbar).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order: testAction followed by all initial actions"
   );
 
@@ -1223,19 +1223,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     initialActionsInUrlbar.map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order after removing test action: all initial actions"
   );
 
   // Check the nodes in the urlbar.
   actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     initialActionsInUrlbar.map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order after removing test action: all initial actions"
   );
 
@@ -1252,19 +1252,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     [testAction].concat(initialActionsInUrlbar).map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order after re-adding test action: testAction followed by all initial actions"
   );
 
   // Check the nodes in the urlbar.
   actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     [testAction].concat(initialActionsInUrlbar).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order after re-adding test action: testAction followed by all initial actions"
   );
 
@@ -1502,17 +1502,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   Assert.equal(onPlacedInPanelCount, 1,
@@ -1529,17 +1529,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should revert to initial"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel
       .map(a => BrowserPageActions.panelButtonNodeIDForActionID(a.id)),
     "Actions in panel should be correct"
   );
 
   // Enable the action.  It should be added back to the panel.
   action.setDisabled(false, window);
 
@@ -1552,17 +1552,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   Assert.equal(onPlacedInPanelCount, 2,
@@ -1587,17 +1587,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
@@ -1619,17 +1619,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   // Enable the action again.  It should be added back to the panel.
@@ -1646,17 +1646,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
@@ -1744,25 +1744,25 @@ function promisePageActionViewShown() {
     return panelViewNode;
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    let bodyNode = panelViewNode.firstChild;
-    for (let childNode of bodyNode.childNodes) {
+    let bodyNode = panelViewNode.firstElementChild;
+    for (let childNode of bodyNode.children) {
       let bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
 
 function collectContextMenuItems() {
   let contextMenu = document.getElementById("pageActionContextMenu");
-  return Array.filter(contextMenu.childNodes, node => {
+  return Array.filter(contextMenu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 }
diff --git a/browser/modules/test/browser/browser_UsageTelemetry_domains.js b/browser/modules/test/browser/browser_UsageTelemetry_domains.js
--- a/browser/modules/test/browser/browser_UsageTelemetry_domains.js
+++ b/browser/modules/test/browser/browser_UsageTelemetry_domains.js
@@ -109,17 +109,17 @@ add_task(async function test_URIAndDomai
 
   // Check that we only account for top level loads (e.g. we don't count URIs from
   // embedded iframes).
   await ContentTask.spawn(newWin.gBrowser.selectedBrowser, null, async function() {
     let doc = content.document;
     let iframe = doc.createElement("iframe");
     let promiseIframeLoaded = ContentTaskUtils.waitForEvent(iframe, "load", false);
     iframe.src = "https://example.org/test";
-    doc.body.insertBefore(iframe, doc.body.firstChild);
+    doc.body.insertBefore(iframe, doc.body.firstElementChild);
     await promiseIframeLoaded;
   });
   checkCounts({totalURIs: 5, domainCount: 2, totalUnfilteredURIs: 5});
 
   // Check that uncommon protocols get counted in the unfiltered URI probe.
   const TEST_PAGE =
     "data:text/html,<a id='target' href='%23par1'>Click me</a><a name='par1'>The paragraph.</a>";
   await BrowserTestUtils.loadURI(newWin.gBrowser.selectedBrowser, TEST_PAGE);
diff --git a/browser/modules/test/browser/browser_taskbar_preview.js b/browser/modules/test/browser/browser_taskbar_preview.js
--- a/browser/modules/test/browser/browser_taskbar_preview.js
+++ b/browser/modules/test/browser/browser_taskbar_preview.js
@@ -53,21 +53,21 @@ function test() {
   ok(gBrowser.tabs.length == 3, "Successfully closed a tab");
 
   // Select #1
   ok(getPreviewForTab(gBrowser.tabs[0]).controller.onActivate(), "Activation was accepted");
   ok(gBrowser.tabs[0].selected, "Correct tab was selected");
   checkSelectedTab();
 
   // Remove #3 (non active)
-  gBrowser.removeTab(gBrowser.tabContainer.lastChild);
+  gBrowser.removeTab(gBrowser.tabContainer.lastElementChild);
   checkPreviews(2, "Expected number of previews after closing unselected via browser");
 
   // Remove #1 (active)
-  gBrowser.removeTab(gBrowser.tabContainer.firstChild);
+  gBrowser.removeTab(gBrowser.tabContainer.firstElementChild);
   checkPreviews(1, "Expected number of previews after closing selected tab via browser");
 
   // Add a new tab
   BrowserTestUtils.addTab(gBrowser);
   checkPreviews(2);
   // Check default selection
   checkSelectedTab();
 
diff --git a/browser/modules/test/browser/formValidation/browser_form_validation.js b/browser/modules/test/browser/formValidation/browser_form_validation.js
--- a/browser/modules/test/browser/formValidation/browser_form_validation.js
+++ b/browser/modules/test/browser/formValidation/browser_form_validation.js
@@ -142,17 +142,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input required id='i'><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   gBrowser.removeCurrentTab();
 });
 
 /**
  * In this test, we check that, when an invalid form is submitted,
  * the first invalid element is focused and a popup appears.
  */
@@ -161,17 +161,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input><input id='i' required><input required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   gBrowser.removeCurrentTab();
 });
 
 /**
  * In this test, we check that, we hide the popup by interacting with the
  * invalid element if the element becomes valid.
  */
@@ -180,17 +180,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   EventUtils.sendString("a");
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
 });
 
@@ -203,17 +203,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input type='email' id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   await new Promise((resolve, reject) => {
     EventUtils.sendString("a");
     executeSoon(function() {
       checkPopupShow();
       resolve();
     });
   });
@@ -230,17 +230,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   await blurChildElement(browser);
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
 });
 
@@ -252,17 +252,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   EventUtils.synthesizeKey("KEY_Tab");
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
 });
 
@@ -274,17 +274,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser1 = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser1);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser1, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser1, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
 
   let browser2 = await openNewTab("data:text/html,<html></html>");
   await popupHiddenPromise;
 
   gBrowser.removeTab(gBrowser.getTabForBrowser(browser1));
   gBrowser.removeTab(gBrowser.getTabForBrowser(browser2));
@@ -299,17 +299,17 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input id='i' required><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popuphidden");
   await BrowserTestUtils.loadURI(browser, "data:text/html,<div>hello!</div>");
   await BrowserTestUtils.browserLoaded(browser);
 
   await popupHiddenPromise;
 
   gBrowser.removeCurrentTab();
@@ -363,19 +363,19 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input x-moz-errormessage='foo' required id='i'><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
-  is(gInvalidFormPopup.firstChild.textContent, "foo",
+  is(gInvalidFormPopup.firstElementChild.textContent, "foo",
      "The panel should show the author defined error message");
 
   gBrowser.removeCurrentTab();
 });
 
 /**
  * In this test, we check that the message is correctly updated when it changes.
  */
@@ -384,26 +384,26 @@ add_task(async function() {
   let uri = getDocHeader() + "<form target='t' action='data:text/html,'><input type='email' required id='i'><input id='s' type='submit'></form>" + getDocFooter();
   let browser = await openNewTab(uri);
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(gInvalidFormPopup, "popupshown");
   await clickChildElement(browser);
   await popupShownPromise;
 
   checkPopupShow();
-  await checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+  await checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
 
   let inputPromise = BrowserTestUtils.waitForEvent(gBrowser.contentDocument.getElementById("i"), "input");
   EventUtils.sendString("f");
   await inputPromise;
 
   // Now, the element suffers from another error, the message should have
   // been updated.
   await new Promise((resolve, reject) => {
     // XXXndeakin This isn't really going to work when the content is another process
     executeSoon(function() {
-      checkChildFocus(browser, gInvalidFormPopup.firstChild.textContent);
+      checkChildFocus(browser, gInvalidFormPopup.firstElementChild.textContent);
       resolve();
     });
   });
 
   gBrowser.removeCurrentTab();
 });
diff --git a/browser/modules/test/browser/head.js b/browser/modules/test/browser/head.js
--- a/browser/modules/test/browser/head.js
+++ b/browser/modules/test/browser/head.js
@@ -260,17 +260,17 @@ function clickSecondaryAction(actionInde
  * by PopupNotification, and then returns that <xul:popupnotification>.
  *
  * @return {<xul:popupnotification>}
  */
 function getPopupNotificationNode() {
   // PopupNotification is a bit overloaded here, so to be
   // clear, popupNotifications is a list of <xul:popupnotification>
   // nodes.
-  let popupNotifications = PopupNotifications.panel.childNodes;
+  let popupNotifications = PopupNotifications.panel.children;
   Assert.equal(popupNotifications.length, 1,
                "Should be showing a <xul:popupnotification>");
   return popupNotifications[0];
 }
 
 
 /**
  * Disable non-release page actions (that are tested elsewhere).
diff --git a/browser/modules/webrtcUI.jsm b/browser/modules/webrtcUI.jsm
--- a/browser/modules/webrtcUI.jsm
+++ b/browser/modules/webrtcUI.jsm
@@ -522,18 +522,18 @@ function prompt(aBrowser, aRequest) {
                                                windowID: aRequest.windowID,
                                                devices: allowedDevices});
           this.remove();
           return true;
         }
       }
 
       function listDevices(menupopup, devices) {
-        while (menupopup.lastChild)
-          menupopup.removeChild(menupopup.lastChild);
+        while (menupopup.lastElementChild)
+          menupopup.removeChild(menupopup.lastElementChild);
         // Removing the child nodes of the menupopup doesn't clear the value
         // attribute of the menulist. This can have unfortunate side effects
         // when the list is rebuilt with a different content, so we remove
         // the value attribute explicitly.
         menupopup.parentNode.removeAttribute("value");
 
         for (let device of devices)
           addDeviceToList(menupopup, device.name, device.deviceIndex);
@@ -546,18 +546,18 @@ function prompt(aBrowser, aRequest) {
         if (!item || item.hasAttribute("disabled")) {
           notificationElement.setAttribute("invalidselection", "true");
         } else {
           notificationElement.removeAttribute("invalidselection");
         }
       }
 
       function listScreenShareDevices(menupopup, devices) {
-        while (menupopup.lastChild)
-          menupopup.removeChild(menupopup.lastChild);
+        while (menupopup.lastElementChild)
+          menupopup.removeChild(menupopup.lastElementChild);
 
         let type = devices[0].mediaSource;
         let typeName = type.charAt(0).toUpperCase() + type.substr(1);
 
         let label = doc.getElementById("webRTC-selectWindow-label");
         let gumStringId = "getUserMedia.select" + typeName;
         label.setAttribute("value",
                            stringBundle.getString(gumStringId + ".label"));
@@ -945,18 +945,18 @@ function getGlobalIndicator() {
         item.addEventListener("command", indicator._command);
         this.appendChild(item);
       }
 
       return true;
     },
 
     _popupHiding(aEvent) {
-      while (this.firstChild)
-        this.firstChild.remove();
+      while (this.firstElementChild)
+        this.firstElementChild.remove();
     },
 
     _setIndicatorState(aName, aState) {
       let field = "_" + aName.toLowerCase();
       if (aState && !this[field]) {
         let menu = this._hiddenDoc.createElement("menu");
         menu.setAttribute("id", "webRTC-sharing" + aName + "-menu");
 
@@ -1015,18 +1015,18 @@ function onTabSharingMenuPopupShowing(e)
     menuitem.setAttribute("label", bundle.getFormattedString(stringName, [origin]));
     menuitem.stream = streamInfo;
     menuitem.addEventListener("command", onTabSharingMenuPopupCommand);
     e.target.appendChild(menuitem);
   }
 }
 
 function onTabSharingMenuPopupHiding(e) {
-  while (this.lastChild)
-    this.lastChild.remove();
+  while (this.lastElementChild)
+    this.lastElementChild.remove();
 }
 
 function onTabSharingMenuPopupCommand(e) {
   webrtcUI.showSharingDoorhanger(e.target.stream);
 }
 
 function showOrCreateMenuForWindow(aWindow) {
   let document = aWindow.document;
diff --git a/toolkit/components/aboutmemory/content/aboutMemory.js b/toolkit/components/aboutmemory/content/aboutMemory.js
--- a/toolkit/components/aboutmemory/content/aboutMemory.js
+++ b/toolkit/components/aboutmemory/content/aboutMemory.js
@@ -1733,51 +1733,51 @@ function toggle(aEvent) {
   // immediately follow.  Assertions check this.
 
   // |aEvent.target| will be one of the spans.  Get the outer span.
   let outerSpan = aEvent.target.parentNode;
   assertClassListContains(outerSpan, "hasKids");
 
   // Toggle the '++'/'--' separator.
   let isExpansion;
-  let sepSpan = outerSpan.childNodes[2];
+  let sepSpan = outerSpan.children[2];
   assertClassListContains(sepSpan, "mrSep");
   if (sepSpan.textContent === kHideKidsSep) {
     isExpansion = true;
     sepSpan.textContent = kShowKidsSep;
   } else if (sepSpan.textContent === kShowKidsSep) {
     isExpansion = false;
     sepSpan.textContent = kHideKidsSep;
   } else {
     assert(false, "bad sepSpan textContent");
   }
 
   // Toggle visibility of the span containing this node's children.
-  let subTreeSpan = outerSpan.nextSibling;
+  let subTreeSpan = outerSpan.nextElementSibling;
   assertClassListContains(subTreeSpan, "kids");
   subTreeSpan.classList.toggle("hidden");
 
   // Record/unrecord that this sub-tree was toggled.
   let safeTreeId = outerSpan.id;
   if (gShowSubtreesBySafeTreeId[safeTreeId] !== undefined) {
     delete gShowSubtreesBySafeTreeId[safeTreeId];
   } else {
     gShowSubtreesBySafeTreeId[safeTreeId] = isExpansion;
   }
 }
 
 function expandPathToThisElement(aElement) {
   if (aElement.classList.contains("kids")) {
     // Unhide the kids.
     aElement.classList.remove("hidden");
-    expandPathToThisElement(aElement.previousSibling); // hasKids
+    expandPathToThisElement(aElement.previousElementSibling); // hasKids
 
   } else if (aElement.classList.contains("hasKids")) {
     // Change the separator to '--'.
-    let sepSpan = aElement.childNodes[2];
+    let sepSpan = aElement.children[2];
     assertClassListContains(sepSpan, "mrSep");
     sepSpan.textContent = kShowKidsSep;
     expandPathToThisElement(aElement.parentNode); // kids or pre.entries
 
   } else {
     assertClassListContains(aElement, "entries");
   }
 }
diff --git a/toolkit/components/aboutmemory/tests/test_aboutmemory2.xul b/toolkit/components/aboutmemory/tests/test_aboutmemory2.xul
--- a/toolkit/components/aboutmemory/tests/test_aboutmemory2.xul
+++ b/toolkit/components/aboutmemory/tests/test_aboutmemory2.xul
@@ -89,17 +89,17 @@
           // vice versa.
           hiPath  = "explicit/j/k";
           hi2Path = "explicit/j/k2";
           jkPath  = "explicit/h/i";
           jk2Path = "explicit/h/i2";
         }
         node.click();
       } else {
-        node.childNodes[0].click();
+        node.children[0].click();
       }
     }
 
     SimpleTest.executeSoon(function() {
       let mostRecentActual;
       document.getElementById("amFrame").focus();
       SimpleTest.waitForClipboard(
         function(aActual) {
diff --git a/toolkit/components/aboutmemory/tests/test_aboutmemory6.xul b/toolkit/components/aboutmemory/tests/test_aboutmemory6.xul
--- a/toolkit/components/aboutmemory/tests/test_aboutmemory6.xul
+++ b/toolkit/components/aboutmemory/tests/test_aboutmemory6.xul
@@ -44,26 +44,26 @@
       // trigger the log saving
       aLogButton.click();
 
       // mainDiv
       // |-> section
       //        | -> div gc log path
       //        | -> div cc log path
       let mainDiv = frame.contentWindow.document.getElementById("mainDiv");
-      let logNodes = mainDiv.childNodes[0];
+      let logNodes = mainDiv.children[0];
 
       // we expect 2 logs listed
-      let numOfLogs = logNodes.childNodes.length;
+      let numOfLogs = logNodes.children.length;
       ok(numOfLogs == 2, "two log entries generated")
 
       // grab the path portion of the text
-      let gcLogPath = logNodes.childNodes[0].textContent
+      let gcLogPath = logNodes.children[0].textContent
                         .replace("Saved GC log to ", "");
-      let ccLogPath = logNodes.childNodes[1].textContent
+      let ccLogPath = logNodes.children[1].textContent
                         .replace("Saved " + aCCLogType + " CC log to ", "");
 
       // check that the files actually exist
       ok(checkForFileAndRemove(gcLogPath), "GC log file exists");
       ok(checkForFileAndRemove(ccLogPath), "CC log file exists");
     }
 
     // get the log buttons to test
diff --git a/toolkit/components/aboutperformance/content/aboutPerformance.js b/toolkit/components/aboutperformance/content/aboutPerformance.js
--- a/toolkit/components/aboutperformance/content/aboutPerformance.js
+++ b/toolkit/components/aboutperformance/content/aboutPerformance.js
@@ -893,18 +893,18 @@ var View = {
 
     return cachedElements;
   },
 
   _fragment: document.createDocumentFragment(),
   commit() {
     let tbody = document.getElementById("dispatch-tbody");
 
-    while (tbody.firstChild)
-      tbody.firstChild.remove();
+    while (tbody.firstElementChild)
+      tbody.firstElementChild.remove();
     tbody.appendChild(this._fragment);
     this._fragment = document.createDocumentFragment();
   },
   appendRow(name, totalValue, recentValue, classes, image = "") {
     let row = document.createElement("tr");
 
     let elt = document.createElement("td");
     elt.textContent = name;
diff --git a/toolkit/components/contextualidentity/ContextualIdentityService.jsm b/toolkit/components/contextualidentity/ContextualIdentityService.jsm
--- a/toolkit/components/contextualidentity/ContextualIdentityService.jsm
+++ b/toolkit/components/contextualidentity/ContextualIdentityService.jsm
@@ -477,18 +477,18 @@ function _ContextualIdentityService(path
     while (windowList.hasMoreElements()) {
       let win = windowList.getNext();
 
       if (win.closed || !win.gBrowser) {
         continue;
       }
 
       let tabbrowser = win.gBrowser;
-      for (let i = tabbrowser.tabContainer.childNodes.length - 1; i >= 0; --i) {
-        let tab = tabbrowser.tabContainer.childNodes[i];
+      for (let i = tabbrowser.tabContainer.children.length - 1; i >= 0; --i) {
+        let tab = tabbrowser.tabContainer.children[i];
         if (tab.hasAttribute("usercontextid") &&
                   (!userContextId ||
                    parseInt(tab.getAttribute("usercontextid"), 10) == userContextId)) {
           callback(tab, tabbrowser);
         }
       }
     }
   },
diff --git a/toolkit/components/microformats/microformat-shiv.js b/toolkit/components/microformats/microformat-shiv.js
--- a/toolkit/components/microformats/microformat-shiv.js
+++ b/toolkit/components/microformats/microformat-shiv.js
@@ -2873,17 +2873,17 @@ var Microformats; // jshint ignore:line
          *
          *   @param  {DOM Node} node
          *   @return {Int}
          */
         getChildIndex(node) {
             var parent = node.parentNode,
                 i = -1,
                 child;
-            while (parent && (child = parent.childNodes[++i])) {
+            while (parent && (child = parent.children[++i])) {
                  if (child === node) {
                      return i;
                  }
             }
             return -1;
         },
 
 
@@ -2914,17 +2914,17 @@ var Microformats; // jshint ignore:line
          *   @param  {Array} path
          *   @return {DOM Node}
          */
         getNodeByPath(document, path) {
             var node = document.documentElement,
                 i = 0,
                 index;
           while ((index = path[++i]) > -1) {
-              node = node.childNodes[index];
+              node = node.children[index];
           }
           return node;
         },
 
 
         /**
         * get an array/nodeList of child nodes
         *
@@ -3836,19 +3836,19 @@ var Microformats; // jshint ignore:line
             }
 
             // if node is a text node get its text
             if (node.nodeType && node.nodeType === 3) {
                 out += modules.domUtils.getElementText( node );
             }
 
             // get the text of the child nodes
-            if (node.childNodes && node.childNodes.length > 0) {
-                for (j = 0; j < node.childNodes.length; j++) {
-                    var text = this.walkTreeForText( node.childNodes[j] );
+            if (node.children && node.children.length > 0) {
+                for (j = 0; j < node.children.length; j++) {
+                    var text = this.walkTreeForText( node.children[j] );
                     if (text !== undefined) {
                         out += text;
                     }
                 }
             }
 
             // if it's a block level tag add an additional space at the end
             if (node.tagName && this.blockLevelTags.includes( node.tagName.toLowerCase() )) {
@@ -3873,19 +3873,19 @@ var Microformats; // jshint ignore:line
          * @param  {DOM Node} node
          * @return {String}
          */
         parse( node ) {
             var out = "",
                 j = 0;
 
             // we do not want the outer container
-            if (node.childNodes && node.childNodes.length > 0) {
-                for (j = 0; j < node.childNodes.length; j++) {
-                    var text = this.walkTreeForHtml( node.childNodes[j] );
+            if (node.children && node.children.length > 0) {
+                for (j = 0; j < node.children.length; j++) {
+                    var text = this.walkTreeForHtml( node.children[j] );
                     if (text !== undefined) {
                         out += text;
                     }
                 }
             }
 
             return out;
         },
@@ -3920,20 +3920,20 @@ var Microformats; // jshint ignore:line
                     out += " " + attrs[j].name + "=" + '"' + attrs[j].value + '"';
                 }
 
                 if (!this.selfClosingElt.includes(node.tagName.toLowerCase())) {
                     out += ">";
                 }
 
                 // get the text of the child nodes
-                if (node.childNodes && node.childNodes.length > 0) {
-
-                    for (j = 0; j < node.childNodes.length; j++) {
-                        var text = this.walkTreeForHtml( node.childNodes[j] );
+                if (node.children && node.children.length > 0) {
+
+                    for (j = 0; j < node.children.length; j++) {
+                        var text = this.walkTreeForHtml( node.children[j] );
                         if (text !== undefined) {
                             out += text;
                         }
                     }
                 }
 
                 // end tag
                 if (this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1) {
diff --git a/toolkit/components/microformats/test/lib/domutils.js b/toolkit/components/microformats/test/lib/domutils.js
--- a/toolkit/components/microformats/test/lib/domutils.js
+++ b/toolkit/components/microformats/test/lib/domutils.js
@@ -515,17 +515,17 @@ var Modules = (function (modules) {
          *
          *   @param  {DOM Node} node
          *   @return {Int}
          */
         getChildIndex: function (node) {
             var parent = node.parentNode,
                 i = -1,
                 child;
-            while (parent && (child = parent.childNodes[++i])){
+            while (parent && (child = parent.children[++i])){
                  if (child === node){
                      return i;
                  }
             }
             return -1;
         },
 
 
@@ -556,17 +556,17 @@ var Modules = (function (modules) {
          *   @param  {Array} path
          *   @return {DOM Node}
          */
         getNodeByPath: function (document, path) {
             var node = document.documentElement,
                 i = 0,
                 index;
           while ((index = path[++i]) > -1){
-              node = node.childNodes[index];
+              node = node.children[index];
           }
           return node;
         },
 
 
         /**
          * get an array/nodeList of child nodes
          *
diff --git a/toolkit/components/microformats/test/lib/html.js b/toolkit/components/microformats/test/lib/html.js
--- a/toolkit/components/microformats/test/lib/html.js
+++ b/toolkit/components/microformats/test/lib/html.js
@@ -24,19 +24,19 @@ var Modules = (function (modules) {
 		 * @param  {DOM Node} node
 		 * @return {String}
 		 */
 		parse: function( node ){
 			var out = '',
 				j = 0;
 
 			// we do not want the outer container
-			if(node.childNodes && node.childNodes.length > 0){
-				for (j = 0; j < node.childNodes.length; j++) {
-					var text = this.walkTreeForHtml( node.childNodes[j] );
+			if(node.children && node.children.length > 0){
+				for (j = 0; j < node.children.length; j++) {
+					var text = this.walkTreeForHtml( node.children[j] );
 					if(text !== undefined){
 						out += text;
 					}
 				}
 			}
 
 			return out;
 		},
@@ -71,20 +71,20 @@ var Modules = (function (modules) {
 					out += ' ' + attrs[j].name +  '=' + '"' + attrs[j].value + '"';
 				}
 
 				if(!this.selfClosingElt.includes(node.tagName.toLowerCase())){
 					out += '>';
 				}
 
 				// get the text of the child nodes
-				if(node.childNodes && node.childNodes.length > 0){
+				if(node.children && node.children.length > 0){
 
-					for (j = 0; j < node.childNodes.length; j++) {
-						var text = this.walkTreeForHtml( node.childNodes[j] );
+					for (j = 0; j < node.children.length; j++) {
+						var text = this.walkTreeForHtml( node.children[j] );
 						if(text !== undefined){
 							out += text;
 						}
 					}
 				}
 
 				// end tag
 				if(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){
diff --git a/toolkit/components/microformats/test/lib/text.js b/toolkit/components/microformats/test/lib/text.js
--- a/toolkit/components/microformats/test/lib/text.js
+++ b/toolkit/components/microformats/test/lib/text.js
@@ -122,19 +122,19 @@ var Modules = (function (modules) {
 			}
 
 			// if node is a text node get its text
 			if(node.nodeType && node.nodeType === 3){
 				out += modules.domUtils.getElementText( node );
 			}
 
 			// get the text of the child nodes
-			if(node.childNodes && node.childNodes.length > 0){
-				for (j = 0; j < node.childNodes.length; j++) {
-					var text = this.walkTreeForText( node.childNodes[j] );
+			if(node.children && node.children.length > 0){
+				for (j = 0; j < node.children.length; j++) {
+					var text = this.walkTreeForText( node.children[j] );
 					if(text !== undefined){
 						out += text;
 					}
 				}
 			}
 
 			// if it's a block level tag add an additional space at the end
 			if(node.tagName && this.blockLevelTags.includes( node.tagName.toLowerCase() )){
diff --git a/toolkit/components/microformats/test/static/javascript/mocha.js b/toolkit/components/microformats/test/static/javascript/mocha.js
--- a/toolkit/components/microformats/test/static/javascript/mocha.js
+++ b/toolkit/components/microformats/test/static/javascript/mocha.js
@@ -2886,17 +2886,17 @@ function fragment(html) {
 
   div.innerHTML = html.replace(/%([se])/g, function(_, type){
     switch (type) {
       case 's': return String(args[i++]);
       case 'e': return escape(args[i++]);
     }
   });
 
-  return div.firstChild;
+  return div.firstElementChild;
 }
 
 /**
  * Check for suites that do not have elements
  * with `classname`, and hide them.
  */
 
 function hideSuitesWithout(classname) {
diff --git a/toolkit/components/microformats/test/static/javascript/prettify.js b/toolkit/components/microformats/test/static/javascript/prettify.js
--- a/toolkit/components/microformats/test/static/javascript/prettify.js
+++ b/toolkit/components/microformats/test/static/javascript/prettify.js
@@ -506,17 +506,17 @@ var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?
           .getPropertyValue('white-space');
     }
     var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);
 
     function walk(node) {
       switch (node.nodeType) {
         case 1:  // Element
           if (nocode.test(node.className)) { return; }
-          for (var child = node.firstChild; child; child = child.nextSibling) {
+          for (var child = node.firstElementChild; child; child = child.nextElementSibling) {
             walk(child);
           }
           var nodeName = node.nodeName;
           if ('BR' === nodeName || 'LI' === nodeName) {
             chunks[k] = '\n';
             spans[k << 1] = length++;
             spans[(k++ << 1) | 1] = node;
           }
@@ -574,17 +574,17 @@ var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?
    * This is meant to return the CODE element in {@code <pre><code ...>} when
    * there is a single child element that contains all the non-space textual
    * content, but not to return anything where there are multiple child elements
    * as in {@code <pre><code>...</code><code>...</code></pre>} or when there
    * is textual content.
    */
   function childContentWrapper(element) {
     var wrapper = undefined;
-    for (var c = element.firstChild; c; c = c.nextSibling) {
+    for (var c = element.firstElementChild; c; c = c.nextElementSibling) {
       var type = c.nodeType;
       if (type === 1) {
         wrapper = wrapper ? element : c;
       } else if (type === 3) {
         wrapper = notWs.test(c.nodeValue) ? element : wrapper;
       }
     }
     return wrapper === element ? undefined : wrapper;
@@ -920,51 +920,51 @@ var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?
       whitespace = document.defaultView.getComputedStyle(node)
           .getPropertyValue('white-space');
     }
     // If it's preformatted, then we need to split lines on line breaks
     // in addition to <BR>s.
     var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);
 
     var li = document.createElement('LI');
-    while (node.firstChild) {
-      li.appendChild(node.firstChild);
+    while (node.firstElementChild) {
+      li.appendChild(node.firstElementChild);
     }
     // An array of lines.  We split below, so this is initialized to one
     // un-split line.
     var listItems = [li];
 
     function walk(node) {
       switch (node.nodeType) {
         case 1:  // Element
           if (nocode.test(node.className)) { break; }
           if ('BR' === node.nodeName) {
             breakAfter(node);
             // Discard the <BR> since it is now flush against a </LI>.
             if (node.parentNode) {
               node.remove();
             }
           } else {
-            for (var child = node.firstChild; child; child = child.nextSibling) {
+            for (var child = node.firstElementChild; child; child = child.nextElementSibling) {
               walk(child);
             }
           }
           break;
         case 3: case 4:  // Text
           if (isPreformatted) {
             var text = node.nodeValue;
             var match = text.match(lineBreak);
             if (match) {
               var firstLine = text.substring(0, match.index);
               node.nodeValue = firstLine;
               var tail = text.substring(match.index + match[0].length);
               if (tail) {
                 var parent = node.parentNode;
                 parent.insertBefore(
-                    document.createTextNode(tail), node.nextSibling);
+                    document.createTextNode(tail), node.nextElementSibling);
               }
               breakAfter(node);
               if (!firstLine) {
                 // Don't leave blank text nodes in the DOM.
                 node.remove();
               }
             }
           }
@@ -972,44 +972,44 @@ var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?
       }
     }
 
     // Split a line after the given node.
     function breakAfter(lineEndNode) {
       // If there's nothing to the right, then we can skip ending the line
       // here, and move root-wards since splitting just before an end-tag
       // would require us to create a bunch of empty copies.
-      while (!lineEndNode.nextSibling) {
+      while (!lineEndNode.nextElementSibling) {
         lineEndNode = lineEndNode.parentNode;
         if (!lineEndNode) { return; }
       }
 
       function breakLeftOf(limit, copy) {
         // Clone shallowly if this node needs to be on both sides of the break.
         var rightSide = copy ? limit.cloneNode(false) : limit;
         var parent = limit.parentNode;
         if (parent) {
           // We clone the parent chain.
           // This helps us resurrect important styling elements that cross lines.
           // E.g. in <i>Foo<br>Bar</i>
           // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.
           var parentClone = breakLeftOf(parent, 1);
           // Move the clone and everything to the right of the original
           // onto the cloned parent.
-          var next = limit.nextSibling;
+          var next = limit.nextElementSibling;
           parentClone.appendChild(rightSide);
           for (var sibling = next; sibling; sibling = next) {
-            next = sibling.nextSibling;
+            next = sibling.nextElementSibling;
             parentClone.appendChild(sibling);
           }
         }
         return rightSide;
       }
 
-      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);
+      var copiedListItem = breakLeftOf(lineEndNode.nextElementSibling, 0);
 
       // Walk the parent chain until we reach an unattached LI.
       for (var parent;
            // Check nodeType since IE invents document fragments.
            (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {
         copiedListItem = parent;
       }
       // Put it on the list of lines for later processing.
@@ -1032,17 +1032,17 @@ var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?
     ol.className = 'linenums';
     var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;
     for (i = 0, n = listItems.length; i < n; ++i) {
       li = listItems[i];
       // Stick a class on the LIs so that stylesheets can
       // color odd/even rows, or any other row pattern that
       // is co-prime with 10.
       li.className = 'L' + ((i + offset) % 10);
-      if (!li.firstChild) {
+      if (!li.firstElementChild) {
         li.appendChild(document.createTextNode('\xA0'));
       }
       ol.appendChild(li);
     }
 
     node.appendChild(ol);
   }
 
@@ -1135,17 +1135,17 @@ var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?
         span.className = decorations[decorationIndex + 1];
         var parentNode = textNode.parentNode;
         parentNode.replaceChild(span, textNode);
         span.appendChild(textNode);
         if (sourceIndex < spanEnd) {  // Split off a text node.
           spans[spanIndex + 1] = textNode
               // TODO: Possibly optimize by using '' if there's no flicker.
               = document.createTextNode(source.substring(end, spanEnd));
-          parentNode.insertBefore(textNode, span.nextSibling);
+          parentNode.insertBefore(textNode, span.nextElementSibling);
         }
       }
 
       sourceIndex = end;
 
       if (sourceIndex >= spanEnd) {
         spanIndex += 2;
       }
diff --git a/toolkit/components/narrate/Narrator.jsm b/toolkit/components/narrate/Narrator.jsm
--- a/toolkit/components/narrate/Narrator.jsm
+++ b/toolkit/components/narrate/Narrator.jsm
@@ -61,17 +61,17 @@ Narrator.prototype = {
 
           let bb = wu.getBoundsWithoutFlushing(node);
           if (!bb.width || !bb.height) {
             // Skip non-rendered nodes. We don't reject because a zero-sized
             // container can still have visible, "overflowed", content.
             return nf.FILTER_SKIP;
           }
 
-          for (let c = node.firstChild; c; c = c.nextSibling) {
+          for (let c = node.firstElementChild; c; c = c.nextElementSibling) {
             if (c.nodeType == c.TEXT_NODE && /\S/.test(c.textContent)) {
               // If node has a non-empty text child accept it.
               this._matches.add(node);
               return nf.FILTER_ACCEPT;
             }
           }
 
           return nf.FILTER_SKIP;
@@ -410,17 +410,17 @@ Highlighter.prototype = {
         let length = node.data.length;
         if (offset >= i && offset <= i + length) {
           return [node, offset - i];
         }
         i += length;
       } while ((node = treeWalker.nextNode()));
 
       // Offset is out of bounds, return last offset of last node.
-      node = treeWalker.lastChild();
+      node = treeWalker.lastElementChild();
       return [node, node.data.length];
     }
 
     let range = doc.createRange();
     range.setStart(..._findNodeAndOffset(startOffset));
     range.setEnd(..._findNodeAndOffset(endOffset));
 
     return range;
diff --git a/toolkit/components/normandy/lib/Heartbeat.jsm b/toolkit/components/normandy/lib/Heartbeat.jsm
--- a/toolkit/components/normandy/lib/Heartbeat.jsm
+++ b/toolkit/components/normandy/lib/Heartbeat.jsm
@@ -212,17 +212,17 @@ var Heartbeat = class {
 
     // Make sure the stars are not pushed to the right by the spacer.
     const rightSpacer = this.chromeWindow.document.createElement("spacer");
     rightSpacer.flex = 20;
     frag.appendChild(rightSpacer);
 
     // collapse the space before the stars
     this.messageText.flex = 0;
-    const leftSpacer = this.messageText.nextSibling;
+    const leftSpacer = this.messageText.nextElementSibling;
     leftSpacer.flex = 0;
 
     // Add Learn More Link
     if (this.options.learnMoreMessage && this.options.learnMoreUrl) {
       const learnMore = this.chromeWindow.document.createElement("label");
       learnMore.className = "text-link";
       learnMore.href = this.options.learnMoreUrl.toString();
       learnMore.setAttribute("value", this.options.learnMoreMessage);
@@ -331,18 +331,18 @@ var Heartbeat = class {
 
   userEngaged(engagementParams) {
     // Make the heartbeat icon pulse twice
     this.notice.label = this.options.thanksMessage;
     this.messageImage.classList.remove("pulse-onshow");
     this.messageImage.classList.add("pulse-twice");
 
     // Remove all the children of the notice (rating container, and the flex)
-    while (this.notice.firstChild) {
-      this.notice.firstChild.remove();
+    while (this.notice.firstElementChild) {
+      this.notice.firstElementChild.remove();
     }
 
     // Open the engagement tab if we have a valid engagement URL.
     if (this.options.postAnswerUrl) {
       for (const key in engagementParams) {
         this.options.postAnswerUrl.searchParams.append(key, engagementParams[key]);
       }
       // Open the engagement URL in a new tab.
diff --git a/toolkit/components/passwordmgr/nsLoginManagerPrompter.js b/toolkit/components/passwordmgr/nsLoginManagerPrompter.js
--- a/toolkit/components/passwordmgr/nsLoginManagerPrompter.js
+++ b/toolkit/components/passwordmgr/nsLoginManagerPrompter.js
@@ -863,17 +863,17 @@ LoginManagerPrompter.prototype = {
       let label = this._getLocalizedString(msgNames.buttonLabel);
       let accessKey = this._getLocalizedString(msgNames.buttonAccessKey);
 
       // Update the labels for the next time the panel is opened.
       currentNotification.mainAction.label = label;
       currentNotification.mainAction.accessKey = accessKey;
 
       // Update the labels in real time if the notification is displayed.
-      let element = [...currentNotification.owner.panel.childNodes]
+      let element = [...currentNotification.owner.panel.children]
                     .find(n => n.notification == currentNotification);
       if (element) {
         element.setAttribute("buttonlabel", label);
         element.setAttribute("buttonaccesskey", accessKey);
         updateButtonStatus(element);
       }
     };
 
diff --git a/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js b/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js
--- a/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_formless_submit_chrome.js
@@ -61,17 +61,17 @@ add_task(async function test_backButton_
     await BrowserTestUtils.browserLoaded(aBrowser, false,
                                          "https://example.com" + DIRECTORY_PATH +
                                          "formless_basic.html?second");
     await fillTestPage(aBrowser);
 
     let forwardButton = document.getElementById("forward-button");
 
     let forwardTransitionPromise;
-    if (forwardButton.nextSibling == gURLBar) {
+    if (forwardButton.nextElementSibling == gURLBar) {
       // We need to wait for the forward button transition to complete before we
       // can click it, so we hook up a listener to wait for it to be ready.
       forwardTransitionPromise = BrowserTestUtils.waitForEvent(forwardButton, "transitionend");
     }
 
     let backPromise = BrowserTestUtils.browserStopped(aBrowser);
     EventUtils.synthesizeMouseAtCenter(document.getElementById("back-button"), {});
     await backPromise;
diff --git a/toolkit/components/passwordmgr/test/browser/browser_notifications.js b/toolkit/components/passwordmgr/test/browser/browser_notifications.js
--- a/toolkit/components/passwordmgr/test/browser/browser_notifications.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_notifications.js
@@ -43,17 +43,17 @@ add_task(async function test_save_change
       await ContentTask.spawn(browser, [username, password],
         async function([contentUsername, contentPassword]) {
           let doc = content.document;
           doc.getElementById("form-basic-username").value = contentUsername;
           doc.getElementById("form-basic-password").value = contentPassword;
           doc.getElementById("form-basic").submit();
         });
       await promiseShown;
-      let notificationElement = PopupNotifications.panel.childNodes[0];
+      let notificationElement = PopupNotifications.panel.children[0];
       // Style flush to make sure binding is attached
       notificationElement.querySelector("#password-notification-password").clientTop;
 
       // Check the actual content of the popup notification.
       Assert.equal(notificationElement.querySelector("#password-notification-username")
                            .value, username);
       Assert.equal(notificationElement.querySelector("#password-notification-password")
                            .value, password);
diff --git a/toolkit/components/passwordmgr/test/browser/browser_notifications_2.js b/toolkit/components/passwordmgr/test/browser/browser_notifications_2.js
--- a/toolkit/components/passwordmgr/test/browser/browser_notifications_2.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_notifications_2.js
@@ -25,17 +25,17 @@ add_task(async function test_empty_passw
         async function() {
           let doc = content.document;
           doc.getElementById("form-basic-username").value = "username";
           doc.getElementById("form-basic-password").value = "p";
           doc.getElementById("form-basic").submit();
         });
       await promiseShown;
 
-      let notificationElement = PopupNotifications.panel.childNodes[0];
+      let notificationElement = PopupNotifications.panel.children[0];
       let passwordTextbox = notificationElement.querySelector("#password-notification-password");
       let toggleCheckbox = notificationElement.querySelector("#password-notification-visibilityToggle");
 
       // Synthesize input to empty the field
       passwordTextbox.focus();
       await EventUtils.synthesizeKey("KEY_ArrowRight");
       await EventUtils.synthesizeKey("KEY_Backspace");
 
@@ -63,17 +63,17 @@ add_task(async function test_toggle_pass
         async function() {
           let doc = content.document;
           doc.getElementById("form-basic-username").value = "username";
           doc.getElementById("form-basic-password").value = "p";
           doc.getElementById("form-basic").submit();
         });
       await promiseShown;
 
-      let notificationElement = PopupNotifications.panel.childNodes[0];
+      let notificationElement = PopupNotifications.panel.children[0];
       let passwordTextbox = notificationElement.querySelector("#password-notification-password");
       let toggleCheckbox = notificationElement.querySelector("#password-notification-visibilityToggle");
 
       await EventUtils.synthesizeMouseAtCenter(toggleCheckbox, {});
       Assert.ok(toggleCheckbox.checked);
       Assert.equal(passwordTextbox.type, "", "Password textbox changed to plain text");
 
       await EventUtils.synthesizeMouseAtCenter(toggleCheckbox, {});
@@ -103,17 +103,17 @@ add_task(async function test_checkbox_di
       await ContentTask.spawn(browser, null, async function() {
         let doc = content.document;
         doc.getElementById("form-basic-username").value = "username";
         doc.getElementById("form-basic-password").value = "p";
         doc.getElementById("form-basic").submit();
       });
       await promiseShown;
 
-      let notificationElement = PopupNotifications.panel.childNodes[0];
+      let notificationElement = PopupNotifications.panel.children[0];
       let passwordTextbox = notificationElement.querySelector("#password-notification-password");
       let toggleCheckbox = notificationElement.querySelector("#password-notification-visibilityToggle");
 
       Assert.equal(passwordTextbox.type, "password", "Password textbox should show * text");
       Assert.ok(toggleCheckbox.getAttribute("hidden"), "checkbox is hidden when master password is set");
     });
 
   LoginTestUtils.masterPassword.disable();
diff --git a/toolkit/components/passwordmgr/test/browser/browser_notifications_password.js b/toolkit/components/passwordmgr/test/browser/browser_notifications_password.js
--- a/toolkit/components/passwordmgr/test/browser/browser_notifications_password.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_notifications_password.js
@@ -83,17 +83,17 @@ add_task(async function test_edit_passwo
       await ContentTask.spawn(browser, testCase,
         async function(contentTestCase) {
           let doc = content.document;
           doc.getElementById("form-basic-username").value = contentTestCase.usernameInPage;
           doc.getElementById("form-basic-password").value = contentTestCase.passwordInPage;
           doc.getElementById("form-basic").submit();
         });
       await promiseShown;
-      let notificationElement = PopupNotifications.panel.childNodes[0];
+      let notificationElement = PopupNotifications.panel.children[0];
       // Style flush to make sure binding is attached
       notificationElement.querySelector("#password-notification-password").clientTop;
 
       // Modify the username in the dialog if requested.
       if (testCase.usernameChangedTo) {
         notificationElement.querySelector("#password-notification-username")
                 .value = testCase.usernameChangedTo;
       }
diff --git a/toolkit/components/passwordmgr/test/browser/browser_notifications_username.js b/toolkit/components/passwordmgr/test/browser/browser_notifications_username.js
--- a/toolkit/components/passwordmgr/test/browser/browser_notifications_username.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_notifications_username.js
@@ -74,17 +74,17 @@ add_task(async function test_edit_userna
       await ContentTask.spawn(browser, testCase.usernameInPage,
         async function(usernameInPage) {
           let doc = content.document;
           doc.getElementById("form-basic-username").value = usernameInPage;
           doc.getElementById("form-basic-password").value = "password";
           doc.getElementById("form-basic").submit();
         });
       await promiseShown;
-      let notificationElement = PopupNotifications.panel.childNodes[0];
+      let notificationElement = PopupNotifications.panel.children[0];
       // Style flush to make sure binding is attached
       notificationElement.querySelector("#password-notification-password").clientTop;
 
       // Modify the username in the dialog if requested.
       if (testCase.usernameChangedTo) {
         notificationElement.querySelector("#password-notification-username")
                 .value = testCase.usernameChangedTo;
       }
diff --git a/toolkit/components/passwordmgr/test/browser/browser_passwordmgr_sort.js b/toolkit/components/passwordmgr/test/browser/browser_passwordmgr_sort.js
--- a/toolkit/components/passwordmgr/test/browser/browser_passwordmgr_sort.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_passwordmgr_sort.js
@@ -104,18 +104,18 @@ add_task(async function test() {
             setTimeout(runNextTest, 0);
         }
 
         function checkSortMarkers(activeCol) {
             let isOk = true;
             let col = null;
             let hasAttr = false;
             let treecols = activeCol.parentNode;
-            for (let i = 0; i < treecols.childNodes.length; i++) {
-                col = treecols.childNodes[i];
+            for (let i = 0; i < treecols.children.length; i++) {
+                col = treecols.children[i];
                 if (col.nodeName != "treecol")
                     continue;
                 hasAttr = col.hasAttribute("sortDirection");
                 isOk &= col == activeCol ? hasAttr : !hasAttr;
             }
             ok(isOk, "Only " + activeCol.id + " has a sort marker");
         }
 
diff --git a/toolkit/components/passwordmgr/test/browser/head.js b/toolkit/components/passwordmgr/test/browser/head.js
--- a/toolkit/components/passwordmgr/test/browser/head.js
+++ b/toolkit/components/passwordmgr/test/browser/head.js
@@ -106,30 +106,30 @@ function getCaptureDoorhanger(aKind, pop
  *
  * @param {Element} aPopup Popup Notification element
  * @param {Number} aButtonIndex Number indicating which button to click.
  *                              See the constants in this file.
  */
 function clickDoorhangerButton(aPopup, aButtonIndex) {
   ok(true, "Looking for action at index " + aButtonIndex);
 
-  let notifications = aPopup.owner.panel.childNodes;
+  let notifications = aPopup.owner.panel.children;
   ok(notifications.length > 0, "at least one notification displayed");
   ok(true, notifications.length + " notification(s)");
   let notification = notifications[0];
 
   if (aButtonIndex == 0) {
     ok(true, "Triggering main action");
     notification.button.doCommand();
   } else if (aButtonIndex == 1) {
     ok(true, "Triggering secondary action");
     notification.secondaryButton.doCommand();
   } else if (aButtonIndex <= aPopup.secondaryActions.length) {
     ok(true, "Triggering secondary action " + aButtonIndex);
-    notification.childNodes[aButtonIndex - 1].doCommand();
+    notification.children[aButtonIndex - 1].doCommand();
   }
 }
 
 /**
  * Checks the doorhanger's username and password.
  *
  * @param {String} username The username.
  * @param {String} password The password.
diff --git a/toolkit/components/passwordmgr/test/chrome/notification_common.js b/toolkit/components/passwordmgr/test/chrome/notification_common.js
--- a/toolkit/components/passwordmgr/test/chrome/notification_common.js
+++ b/toolkit/components/passwordmgr/test/chrome/notification_common.js
@@ -55,28 +55,28 @@ function getPopup(aPopupNote, aKind) {
 /**
  * @deprecated - Use a browser chrome test instead.
  *
  * Clicks the specified popup notification button.
  */
 function clickPopupButton(aPopup, aButtonIndex) {
     ok(true, "Looking for action at index " + aButtonIndex);
 
-    var notifications = SpecialPowers.wrap(aPopup.owner).panel.childNodes;
+    var notifications = SpecialPowers.wrap(aPopup.owner).panel.children;
     ok(notifications.length > 0, "at least one notification displayed");
     ok(true, notifications.length + " notifications");
     var notification = notifications[0];
 
     if (aButtonIndex == 0) {
         ok(true, "Triggering main action");
         notification.button.doCommand();
     } else if (aButtonIndex <= aPopup.secondaryActions.length) {
         var index = aButtonIndex;
         ok(true, "Triggering secondary action " + index);
-        notification.childNodes[index].doCommand();
+        notification.children[index].doCommand();
     }
 }
 
 const kRememberButton = 0;
 const kNeverButton = 1;
 
 const kChangeButton = 0;
 const kDontChangeButton = 1;
diff --git a/toolkit/components/places/BookmarkHTMLUtils.jsm b/toolkit/components/places/BookmarkHTMLUtils.jsm
--- a/toolkit/components/places/BookmarkHTMLUtils.jsm
+++ b/toolkit/components/places/BookmarkHTMLUtils.jsm
@@ -750,28 +750,28 @@ BookmarkImporter.prototype = {
       switch (current.nodeType) {
         case current.ELEMENT_NODE:
           this._openContainer(current);
           break;
         case current.TEXT_NODE:
           this._appendText(current.data);
           break;
       }
-      if ((next = current.firstChild)) {
+      if ((next = current.firstElementChild)) {
         current = next;
         continue;
       }
       for (;;) {
         if (current.nodeType == current.ELEMENT_NODE) {
           this._closeContainer(current);
         }
         if (current == aDoc) {
           return;
         }
-        if ((next = current.nextSibling)) {
+        if ((next = current.nextElementSibling)) {
           current = next;
           break;
         }
         current = current.parentNode;
       }
     }
   },
 
diff --git a/toolkit/components/places/tests/unit/test_bookmarks_html_escape_entities.js b/toolkit/components/places/tests/unit/test_bookmarks_html_escape_entities.js
--- a/toolkit/components/places/tests/unit/test_bookmarks_html_escape_entities.js
+++ b/toolkit/components/places/tests/unit/test_bookmarks_html_escape_entities.js
@@ -54,17 +54,17 @@ add_task(async function() {
     xhr.open("GET", OS.Path.toFileURI(HTMLFile));
     xhr.responseType = "document";
     xhr.overrideMimeType("text/html");
     xhr.send();
   });
 
   let checksCount = 6;
   for (let current = xml; current;
-    current = current.firstChild || current.nextSibling || current.parentNode.nextSibling) {
+    current = current.firstElementChild || current.nextElementSibling || current.parentNode.nextElementSibling) {
     switch (current.nodeType) {
       case current.ELEMENT_NODE:
         for (let {name, value} of current.attributes) {
           info("Found attribute: " + name);
           // Check tags, keyword, postData and charSet.
           if (["tags", "last_charset", "shortcuturl", "post_data"].includes(name)) {
             Assert.equal(value, unescaped, `Attribute ${name} should be complete`);
             checksCount--;
diff --git a/toolkit/components/printing/content/printPageSetup.js b/toolkit/components/printing/content/printPageSetup.js
--- a/toolkit/components/printing/content/printPageSetup.js
+++ b/toolkit/components/printing/content/printPageSetup.js
@@ -50,20 +50,20 @@ function initDialog() {
   gDialog.fRightOption    = document.getElementById("fRightOption");
 
   gDialog.scalingLabel    = document.getElementById("scalingInput");
   gDialog.scalingInput    = document.getElementById("scalingInput");
 
   gDialog.enabled         = false;
 
   gDialog.strings                        = [];
-  gDialog.strings["marginUnits.inches"]  = document.getElementById("marginUnits.inches").childNodes[0].nodeValue;
-  gDialog.strings["marginUnits.metric"]  = document.getElementById("marginUnits.metric").childNodes[0].nodeValue;
-  gDialog.strings["customPrompt.title"]  = document.getElementById("customPrompt.title").childNodes[0].nodeValue;
-  gDialog.strings["customPrompt.prompt"] = document.getElementById("customPrompt.prompt").childNodes[0].nodeValue;
+  gDialog.strings["marginUnits.inches"]  = document.getElementById("marginUnits.inches").children[0].nodeValue;
+  gDialog.strings["marginUnits.metric"]  = document.getElementById("marginUnits.metric").children[0].nodeValue;
+  gDialog.strings["customPrompt.title"]  = document.getElementById("customPrompt.title").children[0].nodeValue;
+  gDialog.strings["customPrompt.prompt"] = document.getElementById("customPrompt.prompt").children[0].nodeValue;
 
 }
 
 // ---------------------------------------------------
 function isListOfPrinterFeaturesAvailable() {
   return Services.prefs.getBoolPref("print.tmp.printerfeatures." +
     gPrintSettings.printerName + ".has_special_printerfeatures", false);
 }
diff --git a/toolkit/components/printing/content/printPreviewProgress.js b/toolkit/components/printing/content/printPreviewProgress.js
--- a/toolkit/components/printing/content/printPreviewProgress.js
+++ b/toolkit/components/printing/content/printPreviewProgress.js
@@ -111,19 +111,19 @@ function onUnload() {
 }
 
 function getString(stringId) {
   // Check if we've fetched this string already.
   if (!(stringId in dialog.strings)) {
     // Try to get it.
     var elem = document.getElementById( "dialog.strings." + stringId);
     try {
-      if (elem && elem.childNodes && elem.childNodes[0] &&
-          elem.childNodes[0].nodeValue)
-        dialog.strings[stringId] = elem.childNodes[0].nodeValue;
+      if (elem && elem.children && elem.children[0] &&
+          elem.children[0].nodeValue)
+        dialog.strings[stringId] = elem.children[0].nodeValue;
       // If unable to fetch string, use an empty string.
       else
         dialog.strings[stringId] = "";
     } catch (e) { dialog.strings[stringId] = ""; }
   }
   return dialog.strings[stringId];
 }
 
diff --git a/toolkit/components/printing/content/printPreviewToolbar.js b/toolkit/components/printing/content/printPreviewToolbar.js
--- a/toolkit/components/printing/content/printPreviewToolbar.js
+++ b/toolkit/components/printing/content/printPreviewToolbar.js
@@ -92,17 +92,17 @@ customElements.define("printpreview-tool
     this.mPortaitButton = document.getElementById("print-preview-portrait-button");
 
     this.mLandscapeButton = document.getElementById("print-preview-landscape-button");
 
     this.mSimplifyPageCheckbox = document.getElementById("print-preview-simplify");
 
     this.mSimplifyPageNotAllowed = this.mSimplifyPageCheckbox.disabled;
 
-    this.mSimplifyPageToolbarSeparator = this.mSimplifyPageCheckbox.nextSibling;
+    this.mSimplifyPageToolbarSeparator = this.mSimplifyPageCheckbox.nextElementSibling;
 
     this.mPrintPreviewObs = "";
 
     this.mWebProgress = "";
 
     this.mPPBrowser = null;
 
     this.mMessageManager = null;
diff --git a/toolkit/components/printing/content/printProgress.js b/toolkit/components/printing/content/printProgress.js
--- a/toolkit/components/printing/content/printProgress.js
+++ b/toolkit/components/printing/content/printProgress.js
@@ -155,22 +155,22 @@ var progressListener = {
 function getString( stringId ) {
    // Check if we've fetched this string already.
    if (!(stringId in dialog.strings)) {
       // Try to get it.
       var elem = document.getElementById( "dialog.strings." + stringId );
       try {
         if ( elem
            &&
-           elem.childNodes
+           elem.children
            &&
-           elem.childNodes[0]
+           elem.children[0]
            &&
-           elem.childNodes[0].nodeValue ) {
-         dialog.strings[stringId] = elem.childNodes[0].nodeValue;
+           elem.children[0].nodeValue ) {
+         dialog.strings[stringId] = elem.children[0].nodeValue;
         } else {
           // If unable to fetch string, use an empty string.
           dialog.strings[stringId] = "";
         }
       } catch (e) { dialog.strings[stringId] = ""; }
    }
    return dialog.strings[stringId];
 }
diff --git a/toolkit/components/satchel/test/satchel_common.js b/toolkit/components/satchel/test/satchel_common.js
--- a/toolkit/components/satchel/test/satchel_common.js
+++ b/toolkit/components/satchel/test/satchel_common.js
@@ -124,18 +124,18 @@ function checkForSave(name, value, messa
 }
 
 function getFormSubmitButton(formNum) {
   let form = $("form" + formNum); // by id, not name
   ok(form != null, "getting form " + formNum);
 
   // we can't just call form.submit(), because that doesn't seem to
   // invoke the form onsubmit handler.
-  let button = form.firstChild;
-  while (button && button.type != "submit") { button = button.nextSibling; }
+  let button = form.firstElementChild;
+  while (button && button.type != "submit") { button = button.nextElementSibling; }
   ok(button != null, "getting form submit button");
 
   return button;
 }
 
 // Count the number of entries with the given name and value, and call then(number)
 // when done. If name or value is null, then the value of that field does not matter.
 function countEntries(name, value, then = null) {
diff --git a/toolkit/components/search/nsSearchService.js b/toolkit/components/search/nsSearchService.js
--- a/toolkit/components/search/nsSearchService.js
+++ b/toolkit/components/search/nsSearchService.js
@@ -1779,18 +1779,18 @@ Engine.prototype = {
     } catch (ex) {
       FAIL("_parseURL: failed to add " + template + " as a URL",
            Cr.NS_ERROR_FAILURE);
     }
 
     if (aElement.hasAttribute("rel"))
       url.rels = aElement.getAttribute("rel").toLowerCase().split(/\s+/);
 
-    for (var i = 0; i < aElement.childNodes.length; ++i) {
-      var param = aElement.childNodes[i];
+    for (var i = 0; i < aElement.children.length; ++i) {
+      var param = aElement.children[i];
       if (param.localName == "Param") {
         try {
           url.addParam(param.getAttribute("name"), param.getAttribute("value"));
         } catch (ex) {
           // Ignore failure
           LOG("_parseURL: Url element has an invalid param");
         }
       } else if (param.localName == "MozParam" &&
@@ -1860,18 +1860,18 @@ Engine.prototype = {
    * the engine object.
    */
   _parse: function SRCH_ENG_parse() {
     var doc = this._data;
 
     // The OpenSearch spec sets a default value for the input encoding.
     this._queryCharset = OS_PARAM_INPUT_ENCODING_DEF;
 
-    for (var i = 0; i < doc.childNodes.length; ++i) {
-      var child = doc.childNodes[i];
+    for (var i = 0; i < doc.children.length; ++i) {
+      var child = doc.children[i];
       switch (child.localName) {
         case "ShortName":
           this._name = child.textContent;
           break;
         case "Description":
           this._description = child.textContent;
           break;
         case "Url":
diff --git a/toolkit/components/telemetry/tests/browser/browser_HybridContentTelemetry.js b/toolkit/components/telemetry/tests/browser/browser_HybridContentTelemetry.js
--- a/toolkit/components/telemetry/tests/browser/browser_HybridContentTelemetry.js
+++ b/toolkit/components/telemetry/tests/browser/browser_HybridContentTelemetry.js
@@ -230,17 +230,17 @@ add_task(async function test_hybrid_cont
   let iframeUrl = url.replace("chrome://mochitests/content", testHost);
   await ContentTask.spawn(newTab.linkedBrowser,
                           [iframeUrl, TEST_CONTENT_EVENT],
                           async function([iframeUrl, testContentEvent]) {
     let doc = content.document;
     let iframe = doc.createElement("iframe");
     let promiseIframeLoaded = ContentTaskUtils.waitForEvent(iframe, "load", false);
     iframe.src = iframeUrl;
-    doc.body.insertBefore(iframe, doc.body.firstChild);
+    doc.body.insertBefore(iframe, doc.body.firstElementChild);
     await promiseIframeLoaded;
 
     // Call the hybrid content telemetry API.
     let contentWin = Cu.waiveXrays(iframe.contentWindow);
     contentWin.testRegisterEvents(testContentEvent[0], JSON.stringify({}));
 
     // Record from the usual telemetry API a "canary" event.
     Services.telemetry.recordEvent(...testContentEvent);
diff --git a/toolkit/components/tooltiptext/TooltipTextProvider.js b/toolkit/components/tooltiptext/TooltipTextProvider.js
--- a/toolkit/components/tooltiptext/TooltipTextProvider.js
+++ b/toolkit/components/tooltiptext/TooltipTextProvider.js
@@ -106,17 +106,17 @@ TooltipTextProvider.prototype = {
           XLinkTitleText = tipElement.getAttributeNS(XLinkNS, "title");
         }
         if (lookingForSVGTitle &&
             (!(tipElement instanceof defView.SVGElement) ||
              tipElement.parentNode.nodeType == defView.Node.DOCUMENT_NODE)) {
           lookingForSVGTitle = false;
         }
         if (lookingForSVGTitle) {
-          for (let childNode of tipElement.childNodes) {
+          for (let childNode of tipElement.children) {
             if (childNode instanceof defView.SVGTitleElement) {
               SVGTitleText = childNode.textContent;
               break;
             }
           }
         }
 
         usedTipElement = tipElement;
diff --git a/toolkit/components/viewsource/content/viewSource-content.js b/toolkit/components/viewsource/content/viewSource-content.js
--- a/toolkit/components/viewsource/content/viewSource-content.js
+++ b/toolkit/components/viewsource/content/viewSource-content.js
@@ -392,19 +392,19 @@ var ViewSourceContent = {
 
     // The source document is made up of a number of pre elements with
     // id attributes in the format <pre id="line123">, meaning that
     // the first line in the pre element is number 123.
     // Do binary search to find the pre element containing the line.
     // However, in the plain text case, we have only one pre without an
     // attribute, so assume it begins on line 1.
     let pre;
-    for (let lbound = 0, ubound = body.childNodes.length; ; ) {
+    for (let lbound = 0, ubound = body.children.length; ; ) {
       let middle = (lbound + ubound) >> 1;
-      pre = body.childNodes[middle];
+      pre = body.children[middle];
 
       let firstLine = pre.id ? parseInt(pre.id.substring(4)) : 1;
 
       if (lbound == ubound - 1) {
         break;
       }
 
       if (lineNumber >= firstLine) {
@@ -440,17 +440,17 @@ var ViewSourceContent = {
       if (offset < node.data.length) {
         // The same text node spans across the "\n", just focus where we were.
         selection.extend(node, offset);
       } else {
         // There is another tag just after the "\n", hook there. We need
         // to focus a safe point because there are edgy cases such as
         // <span>...\n</span><span>...</span> vs.
         // <span>...\n<span>...</span></span><span>...</span>
-        node = node.nextSibling ? node.nextSibling : node.parentNode.nextSibling;
+        node = node.nextElementSibling ? node.nextElementSibling : node.parentNode.nextElementSibling;
         selection.extend(node, 0);
       }
     }
 
     let selCon = this.selectionController;
     selCon.setDisplaySelection(Ci.nsISelectionController.SELECTION_ON);
     selCon.setCaretVisibilityDuringSelection(true);
 
@@ -494,17 +494,17 @@ var ViewSourceContent = {
     // Walk through each of the text nodes and count newlines.
     let treewalker = content.document
         .createTreeWalker(pre, NodeFilter.SHOW_TEXT, null);
 
     // The column number of the first character in the current text node.
     let firstCol = 1;
 
     let found = false;
-    for (let textNode = treewalker.firstChild();
+    for (let textNode = treewalker.firstElementChild();
          textNode && !found;
          textNode = treewalker.nextNode()) {
 
       // \r is not a valid character in the DOM, so we only check for \n.
       let lineArray = textNode.data.split(/\n/);
       let lastLineInNode = curLine + lineArray.length - 1;
 
       // Check if we can skip the text node without further inspection.
@@ -548,17 +548,17 @@ var ViewSourceContent = {
 
         } else if (curLine == lineNumber && !("range" in result)) {
           result.range = content.document.createRange();
           result.range.setStart(textNode, curPos);
 
           // This will always be overridden later, except when we look for
           // the very last line in the file (this is the only line that does
           // not end with \n).
-          result.range.setEndAfter(pre.lastChild);
+          result.range.setEndAfter(pre.lastElementChild);
 
         } else if (curLine == lineNumber + 1) {
           result.range.setEnd(textNode, curPos - 1);
           found = true;
           break;
         }
       }
     }
diff --git a/toolkit/content/aboutProfiles.js b/toolkit/content/aboutProfiles.js
--- a/toolkit/content/aboutProfiles.js
+++ b/toolkit/content/aboutProfiles.js
@@ -44,18 +44,18 @@ function findCurrentProfile() {
     return ProfileService.selectedProfile;
   } catch (e) {
     return null;
   }
 }
 
 function refreshUI() {
   let parent = document.getElementById("profiles");
-  while (parent.firstChild) {
-    parent.firstChild.remove();
+  while (parent.firstElementChild) {
+    parent.firstElementChild.remove();
   }
 
   let defaultProfile;
   try {
     defaultProfile = ProfileService.defaultProfile;
   } catch (e) {}
 
   let currentProfile = findCurrentProfile();
diff --git a/toolkit/content/aboutSupport.js b/toolkit/content/aboutSupport.js
--- a/toolkit/content/aboutSupport.js
+++ b/toolkit/content/aboutSupport.js
@@ -1010,17 +1010,17 @@ Serializer.prototype = {
     if (elem.localName == "table") {
       this._serializeTable(elem);
       return;
     }
 
     // all other elements
 
     let hasText = false;
-    for (let child of elem.childNodes) {
+    for (let child of elem.children) {
       if (child.nodeType == Node.TEXT_NODE) {
         let text = this._nodeText(child);
         this._appendText(text);
         hasText = hasText || !!text.trim();
       } else if (child.nodeType == Node.ELEMENT_NODE)
         this._serializeElement(child);
     }
 
diff --git a/toolkit/content/aboutTelemetry.js b/toolkit/content/aboutTelemetry.js
--- a/toolkit/content/aboutTelemetry.js
+++ b/toolkit/content/aboutTelemetry.js
@@ -148,17 +148,17 @@ function getMainWindowWithPreferencesPan
   return null;
 }
 
 /**
  * Remove all child nodes of a document node.
  */
 function removeAllChildNodes(node) {
   while (node.hasChildNodes()) {
-    node.removeChild(node.lastChild);
+    node.removeChild(node.lastElementChild);
   }
 }
 
 var Settings = {
   SETTINGS: [
     // data upload
     {
       pref: PREF_FHR_UPLOAD_ENABLED,
@@ -1930,17 +1930,17 @@ function showSubSection(selected) {
     return;
   }
   let current_selection = document.querySelector(".category-subsection.selected");
   if (current_selection)
     current_selection.classList.remove("selected");
   selected.classList.add("selected");
 
   let section = document.getElementById(selected.getAttribute("value"));
-  section.parentElement.childNodes.forEach((element) => {
+  section.parentElement.children.forEach((element) => {
     element.hidden = true;
   });
   section.hidden = false;
 
   let title = selected.parentElement.querySelector(".category-name").textContent;
   let subsection = selected.textContent;
   document.getElementById("sectionTitle").textContent = title + " - " + subsection;
   changeUrlPath(subsection, true);
diff --git a/toolkit/content/aboutUrlClassifier.js b/toolkit/content/aboutUrlClassifier.js
--- a/toolkit/content/aboutUrlClassifier.js
+++ b/toolkit/content/aboutUrlClassifier.js
@@ -59,17 +59,17 @@ var Provider = {
   onBeginUpdate(aSubject, aTopic, aData) {
     this.updatingProvider = aData;
     let p = this.updatingProvider;
 
     // Disable update button for the provider while we are doing update.
     document.getElementById("update-" + p).disabled = true;
 
     let elem = document.getElementById(p + "-col-lastupdateresult");
-    elem.childNodes[0].nodeValue = bundle.GetStringFromName("Updating");
+    elem.children[0].nodeValue = bundle.GetStringFromName("Updating");
   },
 
   onFinishUpdate(aSubject, aTopic, aData) {
     let p = this.updatingProvider;
     this.updatingProvider = "";
 
     // It is possible that we get update-finished event only because
     // about::url-classifier is opened after update-begin event is fired.
@@ -79,25 +79,25 @@ var Provider = {
     }
 
     this.refresh([p]);
 
     document.getElementById("update-" + p).disabled = false;
 
     let elem = document.getElementById(p + "-col-lastupdateresult");
     if (aData.startsWith("success")) {
-      elem.childNodes[0].nodeValue = bundle.GetStringFromName("success");
+      elem.children[0].nodeValue = bundle.GetStringFromName("success");
     } else if (aData.startsWith("update error")) {
-      elem.childNodes[0].nodeValue =
+      elem.children[0].nodeValue =
         bundle.formatStringFromName("updateError", [aData.split(": ")[1]], 1);
     } else if (aData.startsWith("download error")) {
-      elem.childNodes[0].nodeValue =
+      elem.children[0].nodeValue =
         bundle.formatStringFromName("downloadError", [aData.split(": ")[1]], 1);
     } else {
-      elem.childNodes[0].nodeValue = aData;
+      elem.children[0].nodeValue = aData;
     }
   },
 
   register() {
     // Handle begin update
     this.onBeginUpdate = this.onBeginUpdate.bind(this);
     Services.obs.addObserver(this.onBeginUpdate, UPDATE_BEGIN);
 
@@ -108,17 +108,17 @@ var Provider = {
 
   // This should only be called once because we assume number of providers
   // won't change.
   render() {
     let tbody = document.getElementById("provider-table-body");
 
     for (let provider of this.providers) {
       let tr = document.createElement("tr");
-      let cols = document.getElementById("provider-head-row").childNodes;
+      let cols = document.getElementById("provider-head-row").children;
       for (let column of cols) {
         if (!column.id) {
           continue;
         }
         let td = document.createElement("td");
         td.id = provider + "-" + column.id;
 
         if (column.id === "col-update") {
@@ -154,33 +154,33 @@ var Provider = {
 
       let listmanager = Cc["@mozilla.org/url-classifier/listmanager;1"]
                         .getService(Ci.nsIUrlListManager);
       let bot = listmanager.getBackOffTime(provider);
       values["col-backofftime"] = bot ? new Date(bot * 1) : STR_NA;
 
       for (let key of Object.keys(values)) {
         let elem = document.getElementById(provider + "-" + key);
-        elem.childNodes[0].nodeValue = values[key];
+        elem.children[0].nodeValue = values[key];
       }
     }
   },
 
   // Call update for the provider.
   update(provider) {
     let listmanager = Cc["@mozilla.org/url-classifier/listmanager;1"]
                       .getService(Ci.nsIUrlListManager);
 
     let pref = "browser.safebrowsing.provider." + provider + ".lists";
     let tables = Services.prefs.getCharPref(pref, "");
 
     if (!listmanager.forceUpdates(tables)) {
       // This may because of back-off algorithm.
       let elem = document.getElementById(provider + "-col-lastupdateresult");
-      elem.childNodes[0].nodeValue = bundle.GetStringFromName("CannotUpdate");
+      elem.children[0].nodeValue = bundle.GetStringFromName("CannotUpdate");
     }
   },
 
 };
 
 /*
  * Cache
  */
@@ -223,23 +223,23 @@ var Cache = {
 
   refresh() {
     this.clearCacheEntries();
     this.createCacheEntries();
   },
 
   clearCacheEntries() {
     let ctbody = document.getElementById("cache-table-body");
-    while (ctbody.firstChild) {
-      ctbody.firstChild.remove();
+    while (ctbody.firstElementChild) {
+      ctbody.firstElementChild.remove();
     }
 
     let cetbody = document.getElementById("cache-entries-table-body");
-    while (cetbody.firstChild) {
-      cetbody.firstChild.remove();
+    while (cetbody.firstElementChild) {
+      cetbody.firstElementChild.remove();
     }
   },
 
   createCacheEntries() {
     function createRow(tds, body, cols) {
       let tr = document.createElement("tr");
       tds.forEach(function(v, i, a) {
         let td = document.createElement("td");
@@ -400,20 +400,20 @@ var Debug = {
 
     let file = Services.dirsvc.get("TmpD", Ci.nsIFile);
     file.append("safebrowsing.log");
 
     let logFile = document.getElementById("log-file");
     logFile.value = file.path;
 
     let curLog = document.getElementById("cur-log-modules");
-    curLog.childNodes[0].nodeValue = "";
+    curLog.children[0].nodeValue = "";
 
     let curLogFile = document.getElementById("cur-log-file");
-    curLogFile.childNodes[0].nodeValue = "";
+    curLogFile.children[0].nodeValue = "";
   },
 
   refresh() {
     this.refreshJSDebug();
 
     // Disable configure log modules if log modules are already set
     // by environment variable.
     let env = Cc["@mozilla.org/process/environment;1"]
@@ -425,17 +425,17 @@ var Debug = {
 
     if (logModules.length > 0) {
       document.getElementById("set-log-modules").disabled = true;
       for (let module of this.modules) {
         document.getElementById("chk-" + module).disabled = true;
       }
 
       let curLogModules = document.getElementById("cur-log-modules");
-      curLogModules.childNodes[0].nodeValue = logModules;
+      curLogModules.children[0].nodeValue = logModules;
     }
 
     // Disable set log file if log file is already set
     // by environment variable.
     let logFile = env.get("MOZ_LOG_FILE") || env.get("NSPR_LOG_FILE");
     if (logFile.length > 0) {
       document.getElementById("set-log-file").disabled = true;
       document.getElementById("log-file").value = logFile;
@@ -444,17 +444,17 @@ var Debug = {
 
   refreshJSDebug() {
     let enabled = Services.prefs.getBoolPref(JSLOG_PREF, false);
 
     let jsChk = document.getElementById("js-log");
     jsChk.checked = enabled;
 
     let curJSLog = document.getElementById("cur-js-log");
-    curJSLog.childNodes[0].nodeValue = enabled ?
+    curJSLog.children[0].nodeValue = enabled ?
       bundle.GetStringFromName("Enabled") :
       bundle.GetStringFromName("Disabled");
   },
 
   jslog() {
     let enabled = Services.prefs.getBoolPref(JSLOG_PREF, false);
     Services.prefs.setBoolPref(JSLOG_PREF, !enabled);
   },
@@ -471,19 +471,19 @@ var Debug = {
     let value = document.getElementById("log-modules").value;
     let logModules = value.split(",");
     for (let module of logModules) {
       let [key, value] = module.split(":");
       Services.prefs.setIntPref(`logging.${key}`, parseInt(value, 10));
     }
 
     let curLogModules = document.getElementById("cur-log-modules");
-    curLogModules.childNodes[0].nodeValue = value;
+    curLogModules.children[0].nodeValue = value;
   },
 
   logfile() {
     let logFile = document.getElementById("log-file").value.trim();
     Services.prefs.setCharPref("logging.config.LOG_FILE", logFile);
 
     let curLogFile = document.getElementById("cur-log-file");
-    curLogFile.childNodes[0].nodeValue = logFile;
+    curLogFile.children[0].nodeValue = logFile;
   }
 };
diff --git a/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js b/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
--- a/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
+++ b/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
@@ -154,17 +154,17 @@ async function testAutoplayUnknownPermis
     ok(promptShowing(), "Should now be showing permission prompt");
 
     // Click the appropriate doorhanger button.
     if (args.button == "allow") {
       info("Clicking allow button");
       PopupNotifications.panel.firstElementChild.button.click();
     } else if (args.button == "block") {
       info("Clicking block button");
-      PopupNotifications.panel.firstChild.secondaryButton.click();
+      PopupNotifications.panel.firstElementChild.secondaryButton.click();
     } else {
       ok(false, "Invalid button field");
     }
     // Check that the video started playing.
     await checkVideoDidPlay(browser, args);
 
     // Reset permission.
     SitePermissions.remove(browser.currentURI, "autoplay-media");
diff --git a/toolkit/content/tests/browser/browser_bug451286.js b/toolkit/content/tests/browser/browser_bug451286.js
--- a/toolkit/content/tests/browser/browser_bug451286.js
+++ b/toolkit/content/tests/browser/browser_bug451286.js
@@ -46,17 +46,17 @@ add_task(async function() {
   await ContentTask.spawn(tab.linkedBrowser, null, async function() {
     let doc = content.document;
     let win = doc.defaultView;
 
     // Create a manual highlight in the visible iframe to test bug 451286
     let iframe = doc.getElementById("visible");
     let ifBody = iframe.contentDocument.body;
     let range = iframe.contentDocument.createRange();
-    range.selectNodeContents(ifBody.childNodes[0]);
+    range.selectNodeContents(ifBody.children[0]);
     let ifWindow = iframe.contentWindow;
     let ifDocShell = ifWindow.docShell;
 
     let ifController = ifDocShell.QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsISelectionDisplay)
                                  .QueryInterface(Ci.nsISelectionController);
 
     let frameFindSelection =
@@ -70,23 +70,23 @@ add_task(async function() {
     let controller = docShell.QueryInterface(Ci.nsIInterfaceRequestor)
                              .getInterface(Ci.nsISelectionDisplay)
                              .QueryInterface(Ci.nsISelectionController);
 
     let docFindSelection =
       controller.getSelection(ifController.SELECTION_FIND);
 
     range = doc.createRange();
-    range.selectNodeContents(doc.body.childNodes[0]);
+    range.selectNodeContents(doc.body.children[0]);
     docFindSelection.addRange(range);
     range = doc.createRange();
-    range.selectNodeContents(doc.body.childNodes[2]);
+    range.selectNodeContents(doc.body.children[2]);
     docFindSelection.addRange(range);
     range = doc.createRange();
-    range.selectNodeContents(doc.body.childNodes[4]);
+    range.selectNodeContents(doc.body.children[4]);
     docFindSelection.addRange(range);
   });
 
   // Take snapshot of manual highlighting
   let manualSnapshot = snapshotRect(window, contentRect);
   ok(manualSnapshot, "Got manualSnapshot");
 
   // Test 1: Were the matches in iframe correctly highlighted?
diff --git a/toolkit/content/tests/chrome/frame_popupremoving_frame.xul b/toolkit/content/tests/chrome/frame_popupremoving_frame.xul
--- a/toolkit/content/tests/chrome/frame_popupremoving_frame.xul
+++ b/toolkit/content/tests/chrome/frame_popupremoving_frame.xul
@@ -37,21 +37,21 @@
         <menuitem label="L4 Two"/>
         <menuitem label="L4 Three"/>
     </menupopup>
 </menu>
 
 </hbox>
 
 <menu id="nestedmenu1" label="Menu">
-    <menupopup id="nestedpopup1" onpopupshown="if (event.target == this) this.firstChild.open = true">
+    <menupopup id="nestedpopup1" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
       <menu id="nestedmenu2" label="Menu">
-        <menupopup id="nestedpopup2" onpopupshown="if (event.target == this) this.firstChild.open = true">
+        <menupopup id="nestedpopup2" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
           <menu id="nestedmenu3" label="Menu">
-            <menupopup id="nestedpopup3" onpopupshown="if (event.target == this) this.firstChild.open = true">
+            <menupopup id="nestedpopup3" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
               <menu id="nestedmenu4" label="Menu" onpopupshown="parent.popupsOpened()">
                 <menupopup id="nestedpopup4">
                   <menuitem label="Nested One"/>
                   <menuitem label="Nested Two"/>
                   <menuitem label="Nested Three"/>
                 </menupopup>
               </menu>
             </menupopup>
diff --git a/toolkit/content/tests/chrome/test_arrowpanel.xul b/toolkit/content/tests/chrome/test_arrowpanel.xul
--- a/toolkit/content/tests/chrome/test_arrowpanel.xul
+++ b/toolkit/content/tests/chrome/test_arrowpanel.xul
@@ -232,17 +232,17 @@ function checkPanelPosition(panel)
   if (isRTL) {
     var flipLeftRight = val => val == "left" ? "right" : "left";
     expectedAnchorEdge = expectedAnchorEdge.replace(/(left|right)/, flipLeftRight);
     expectedSide = expectedSide.replace(/(left|right)/, flipLeftRight);
   }
 
   var panelRect = panel.getBoundingClientRect();
   var anchorRect = anchor.getBoundingClientRect();
-  var contentBO = panel.firstChild.boxObject;
+  var contentBO = panel.firstElementChild.boxObject;
   var contentRect = { top: contentBO.y,
                       left: contentBO.x,
                       bottom: contentBO.y + contentBO.height,
                       right: contentBO.x + contentBO.width };
   switch (expectedSide) {
     case "top":
       ok(contentRect.top > vwinpos + anchorRect.bottom * zoomFactor + 5, "panel content is below");
       break;
@@ -304,17 +304,17 @@ function checkPanelPosition(panel)
 
 function isWithinHalfPixel(a, b, desc)
 {
   ok(Math.abs(a - b) <= 0.5, desc);
 }
 
 function checkBigPanel(panel)
 {
-  ok(panel.firstChild.getBoundingClientRect().height < 2800, "big panel height");
+  ok(panel.firstElementChild.getBoundingClientRect().height < 2800, "big panel height");
   panel.hidePopup();
 }
 
 SimpleTest.waitForFocus(startTest);
 
 ]]>
 </script>
 
diff --git a/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul b/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul
--- a/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul
+++ b/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul
@@ -133,23 +133,23 @@ function nextTest() {
   currentTest = testcases[test];
   resultText = currentTest.result;
   autocomplete.value = currentTest.search;
   synthesizeKey("KEY_ArrowDown");
 }
 
 function checkSearchCompleted() {
   let autocomplete = $("richautocomplete");
-  let result = autocomplete.popup.richlistbox.firstChild;
+  let result = autocomplete.popup.richlistbox.firstElementChild;
 
   for (let attribute of [result._titleText, result._urlText]) {
-    is(attribute.childNodes.length, currentTest.emphasis.length,
+    is(attribute.children.length, currentTest.emphasis.length,
        "The element should have the expected number of children.");
     for (let i = 0; i < currentTest.emphasis.length; i++) {
-      let node = attribute.childNodes[i];
+      let node = attribute.children[i];
       // Emphasized parts strictly alternate.
       if ((i % 2 == 0) == currentTest.emphasizeFirst) {
         // Check that this part is correctly emphasized.
         is(node.nodeName, "span", ". That child should be a span node");
         ok(node.classList.contains("ac-emphasize-text"), ". That child should be emphasized");
         is(node.textContent, currentTest.emphasis[i], ". That emphasis should be as expected.");
       } else {
         // Check that this part is _not_ emphasized.
diff --git a/toolkit/content/tests/chrome/test_bug570192.xul b/toolkit/content/tests/chrome/test_bug570192.xul
--- a/toolkit/content/tests/chrome/test_bug570192.xul
+++ b/toolkit/content/tests/chrome/test_bug570192.xul
@@ -35,18 +35,18 @@ https://bugzilla.mozilla.org/show_bug.cg
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     addLoadEvent(function() {
       try {
         var content = document.getElementById("content");
         let textbox = document.createElementNS(XUL_NS, "textbox");
         textbox.setAttribute("newlines", "pasteintact");
         content.appendChild(textbox);
-        ok(content.firstChild, "created the textbox");
-        ok(!content.firstChild.editor, "do we have an editor?");
+        ok(content.firstElementChild, "created the textbox");
+        ok(!content.firstElementChild.editor, "do we have an editor?");
       } catch (e) {
         ok(false, "Got an exception: " + e);
       }
       SimpleTest.finish();
     });
     SimpleTest.waitForExplicitFinish();
 
    ]]>
diff --git a/toolkit/content/tests/chrome/test_bug585946.xul b/toolkit/content/tests/chrome/test_bug585946.xul
--- a/toolkit/content/tests/chrome/test_bug585946.xul
+++ b/toolkit/content/tests/chrome/test_bug585946.xul
@@ -29,18 +29,18 @@ function startTest() {
 
   var splitter = document.createElement("splitter");
   splitter.setAttribute("id", "dynsplitter");
   splitter.setAttribute("skipintoolbarset", "true");
 
   toolbar.insertBefore(splitter, $("node2"));
 
   function checkPos() {
-    is($("dynsplitter").previousSibling, $("node1"));
-    is($("dynsplitter").nextSibling, $("node2"));
+    is($("dynsplitter").previousElementSibling, $("node1"));
+    is($("dynsplitter").nextElementSibling, $("node2"));
   }
 
   checkPos();
   toolbar.style.MozBinding = "url(chrome://global/content/bindings/toolbar.xml#toolbar-drag)";
   toolbar.clientTop; // style flush
   checkPos();
 
   SimpleTest.finish();
diff --git a/toolkit/content/tests/chrome/test_bug792324.xul b/toolkit/content/tests/chrome/test_bug792324.xul
--- a/toolkit/content/tests/chrome/test_bug792324.xul
+++ b/toolkit/content/tests/chrome/test_bug792324.xul
@@ -43,17 +43,17 @@ let after_click;
 function clicked(event) {
   after_click(event);
 }
 
 function checkAccessKeyOnPanel(panelid, buttonid, cb) {
   let panel = document.getElementById(panelid);
   panel.addEventListener("popupshown", function onpopupshown() {
     panel.removeEventListener("popupshown", onpopupshown);
-    panel.firstChild.focus();
+    panel.firstElementChild.focus();
     after_click = function(event) {
       is(event.target.id, buttonid, "Accesskey was directed to the button '" + buttonid + "'");
       panel.hidePopup();
       cb();
     }
     sendString("X");
   });
  panel.openPopup(null, "", 100, 100, false, false);
diff --git a/toolkit/content/tests/chrome/test_closemenu_attribute.xul b/toolkit/content/tests/chrome/test_closemenu_attribute.xul
--- a/toolkit/content/tests/chrome/test_closemenu_attribute.xul
+++ b/toolkit/content/tests/chrome/test_closemenu_attribute.xul
@@ -5,19 +5,19 @@
 <window title="Menu closemenu Attribute Tests"
   onload="setTimeout(nextTest, 0);"
   xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>      
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>      
 
 <button id="menu" type="menu" label="Menu" onpopuphidden="popupHidden(event)">
-  <menupopup id="p1" onpopupshown="if (event.target == this) this.firstChild.open = true">
+  <menupopup id="p1" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
     <menu id="l1" label="One">
-      <menupopup id="p2" onpopupshown="if (event.target == this) this.firstChild.open = true">
+      <menupopup id="p2" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
         <menu id="l2" label="Two">
           <menupopup id="p3" onpopupshown="executeMenuItem()">
             <menuitem id="l3" label="Three"/>
           </menupopup>
         </menu>
       </menupopup>
     </menu>
   </menupopup>
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -29,17 +29,17 @@
   function testParseXULToFragment() {
     ok(MozXULElement.parseXULToFragment, "parseXULToFragment helper exists");
 
     let frag = MozXULElement.parseXULToFragment(`<deck id='foo' />`);
     ok(frag instanceof DocumentFragment);
 
     document.documentElement.appendChild(frag);
 
-    let deck = document.documentElement.lastChild;
+    let deck = document.documentElement.lastElementChild;
     ok(deck instanceof MozXULElement, "instance of MozXULElement");
     ok(deck instanceof XULElement, "instance of XULElement");
     is(deck.id, "foo", "attribute set");
     is(deck.selectedIndex, "0", "Custom Element is property attached");
     deck.remove();
   }
 
   function testCustomInterface() {
diff --git a/toolkit/content/tests/chrome/test_deck.xul b/toolkit/content/tests/chrome/test_deck.xul
--- a/toolkit/content/tests/chrome/test_deck.xul
+++ b/toolkit/content/tests/chrome/test_deck.xul
@@ -94,40 +94,40 @@ function test_deck_child_removal()
   // first three, making sure that the selectedIndex is decremented
   // each time.
   deck = $("deck4");
   let expectedIndex = 5;
   is(deck.selectedIndex, String(expectedIndex),
      "Should have the deck element at index " + expectedIndex + " selected");
 
   for (let i = 0; i < 3; ++i) {
-    deck.firstChild.remove();
+    deck.firstElementChild.remove();
     expectedIndex--;
     is(deck.selectedIndex, String(expectedIndex),
        "Should have the deck element at index " + expectedIndex + " selected");
   }
 
   // Check that removing the currently selected node doesn't change
   // behaviour.
-  deck.childNodes[expectedIndex].remove();
+  deck.children[expectedIndex].remove();
   is(deck.selectedIndex, String(expectedIndex),
      "The selectedIndex should not change when removing the node " +
      "at the selected index.");
 
   // Finally, make sure we haven't changed the behaviour when removing
   // nodes at indexes greater than the selected node.
   deck = $("deck5");
   expectedIndex = 2;
   is(deck.selectedIndex, String(expectedIndex),
      "Should have the deck element at index " + expectedIndex + " selected");
 
   // And then remove all of the nodes, starting from last to first, making
   // sure that the selectedIndex does not change.
-  while (deck.lastChild) {
-    deck.lastChild.remove();
+  while (deck.lastElementChild) {
+    deck.lastElementChild.remove();
     is(deck.selectedIndex, String(expectedIndex),
        "Should have the deck element at index " + expectedIndex + " selected");
   }
 }
 ]]>
 </script>
 
 </window>
diff --git a/toolkit/content/tests/chrome/test_menu_hide.xul b/toolkit/content/tests/chrome/test_menu_hide.xul
--- a/toolkit/content/tests/chrome/test_menu_hide.xul
+++ b/toolkit/content/tests/chrome/test_menu_hide.xul
@@ -5,17 +5,17 @@
 <window title="Menu Destruction Test"
   onload="setTimeout(runTests, 0);"
   xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>      
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>      
 
 <menu id="menu">
-  <menupopup onpopupshown="this.firstChild.open = true" onpopuphidden="if (event.target == this) done()">
+  <menupopup onpopupshown="this.firstElementChild.open = true" onpopuphidden="if (event.target == this) done()">
     <menu id="submenu" label="One">
       <menupopup onpopupshown="submenuOpened();">
         <menuitem label="Two"/>
       </menupopup>
     </menu>
   </menupopup>
 </menu>
 
diff --git a/toolkit/content/tests/chrome/test_menuchecks.xul b/toolkit/content/tests/chrome/test_menuchecks.xul
--- a/toolkit/content/tests/chrome/test_menuchecks.xul
+++ b/toolkit/content/tests/chrome/test_menuchecks.xul
@@ -90,17 +90,17 @@
   {
     checkMenus(["statusbar", "history", "bydate", "ascending"], "initial");
     document.getElementById("menu").open = true;
   }
 
   function checkMenus(checkedItems, testname)
   {
     var isok = true;
-    var children = document.getElementById("popup").childNodes;
+    var children = document.getElementById("popup").children;
     for (var c = 0; c < children.length; c++) {
       var child = children[c];
       if ((checkedItems.includes(child.id) && child.getAttribute("checked") != "true") ||
           (!checkedItems.includes(child.id) && child.hasAttribute("checked"))) {
         isok = false;
         break;
       }
     }
diff --git a/toolkit/content/tests/chrome/test_menulist.xul b/toolkit/content/tests/chrome/test_menulist.xul
--- a/toolkit/content/tests/chrome/test_menulist.xul
+++ b/toolkit/content/tests/chrome/test_menulist.xul
@@ -265,20 +265,20 @@ function test_menulist_open(element, scr
                                    deltaMode: WheelEvent.DOM_DELTA_LINE });
   is(scrolled, true, "mousescroll " + element.id);
   is(scroller.scrollTop, 0, "scroll position on mousescroll " + element.id);
   window.removeEventListener("DOMMouseScroll", mouseScrolled, false);
 */
 
   // bug 543065, hovering the mouse over an item should highlight it, not
   // scroll the parent, and not change the selected index.
-  var item = element.menupopup.childNodes[1];
+  var item = element.menupopup.children[1];
 
-  synthesizeMouse(element.menupopup.childNodes[1], 2, 2, { type: "mousemove" });
-  synthesizeMouse(element.menupopup.childNodes[1], 6, 6, { type: "mousemove" });
+  synthesizeMouse(element.menupopup.children[1], 2, 2, { type: "mousemove" });
+  synthesizeMouse(element.menupopup.children[1], 6, 6, { type: "mousemove" });
   is(element.menuBoxObject.activeChild, item, "activeChild after menu highlight " + element.id);
   is(element.selectedIndex, 0, "selectedIndex after menu highlight " + element.id);
   is(scroller.scrollTop, 0, "scroll position after menu highlight " + element.id);
 
   element.open = false;
 }
 
 function checkScrollAndFinish()
@@ -339,17 +339,17 @@ function dragScroll()
     scrollPos = popup.scrollBox.scrollTop;
     synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 25, { type: "mouseup" });
     is(popup.scrollBox.scrollTop, scrollPos, "scroll position at mouseup should not change");
 
     synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" });
     is(popup.scrollBox.scrollTop, scrollPos, "scroll position at mousemove after mouseup should not change");
 
     // Now check dragging with a mousedown on an item
-    let menuRect = popup.childNodes[4].getBoundingClientRect();
+    let menuRect = popup.children[4].getBoundingClientRect();
     synthesizeMouseAtPoint(menuRect.left + 5, menuRect.top + 5, { type: "mousedown" });
 
     // Dragging below the popup scrolls it down.
     synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" });
     ok(popup.scrollBox.scrollTop > scrollPos + 5, "scroll position at drag down from item");
 
     // Dragging above the popup scrolls it up.
     synthesizeMouseAtPoint(popupRect.left + 20, popupRect.top - 20, { type: "mousemove" });
@@ -360,17 +360,17 @@ function dragScroll()
     is(popup.scrollBox.scrollTop, scrollPos, "scroll position at mouseup should not change");
 
     synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" });
     is(popup.scrollBox.scrollTop, scrollPos, "scroll position at mousemove after mouseup should not change");
 
     menulist.open = false;
 
     let mouseMoveTarget = null;
-    popup.childNodes[4].click();
+    popup.children[4].click();
     addEventListener("mousemove", function checkMouseMove(event) {
       mouseMoveTarget = event.target;
     }, {once: true});
     synthesizeMouseAtPoint(popupRect.left + 20, popupRect.bottom + 20, { type: "mousemove" });
     isnot(mouseMoveTarget, popup, "clicking on item when popup closed doesn't start dragging");
 
     SimpleTest.finish();
   });
diff --git a/toolkit/content/tests/chrome/test_menulist_keynav.xul b/toolkit/content/tests/chrome/test_menulist_keynav.xul
--- a/toolkit/content/tests/chrome/test_menulist_keynav.xul
+++ b/toolkit/content/tests/chrome/test_menulist_keynav.xul
@@ -150,17 +150,17 @@ function tabAndScroll()
   }
 
   // now make sure that using a key scrolls the menu correctly
 
   for (let i = 0; i < 65; i++) {
     list.appendItem("Item" + i, "item" + i);
   }
   list.open = true;
-  is(list.getBoundingClientRect().width, list.firstChild.getBoundingClientRect().width,
+  is(list.getBoundingClientRect().width, list.firstElementChild.getBoundingClientRect().width,
      "menu and popup width match");
   var minScrollbarWidth = window.matchMedia("(-moz-overlay-scrollbars)").matches ? 0 : 3;
   ok(list.getBoundingClientRect().width >= list.getItemAtIndex(0).getBoundingClientRect().width + minScrollbarWidth,
      "menuitem width accounts for scrollbar");
   list.open = false;
 
   list.menupopup.maxHeight = 100;
   list.open = true;
diff --git a/toolkit/content/tests/chrome/test_menulist_paging.xul b/toolkit/content/tests/chrome/test_menulist_paging.xul
--- a/toolkit/content/tests/chrome/test_menulist_paging.xul
+++ b/toolkit/content/tests/chrome/test_menulist_paging.xul
@@ -92,17 +92,17 @@ let tests = [
                                    ups: [3, 1, 1] },
   { list: "menulist4", initial: 5, scroll: 2, downs: [], ups: [] }
 ];
 
 function startTest()
 {
   let popup = document.getElementById("menulist-popup1");
   let menupopupHeight = popup.getBoundingClientRect().height;
-  let menuitemHeight = popup.firstChild.getBoundingClientRect().height;
+  let menuitemHeight = popup.firstElementChild.getBoundingClientRect().height;
 
   // First, set the height of each popup to the height of four menuitems plus
   // any padding and border on the menupopup.
   let height = menuitemHeight * 4 + (menupopupHeight - menuitemHeight * 10);
   popup.height = height;
   document.getElementById("menulist-popup2").height = height;
   document.getElementById("menulist-popup3").height = height;
   document.getElementById("menulist-popup4").height = height;
@@ -126,17 +126,17 @@ function menulistShown()
   let menulist = document.getElementById(test.list);
   is(menulist.menuBoxObject.activeChild.label, menulist.getItemAtIndex(test.initial).label, test.list + " initial selection");
 
   let cs = window.getComputedStyle(menulist.menupopup);
   let bpTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
 
   // Skip menulist3 as it has a label that scrolling doesn't need normally deal with.
   if (test.scroll >= 0) {
-    is(menulist.menupopup.childNodes[test.scroll].getBoundingClientRect().top,
+    is(menulist.menupopup.children[test.scroll].getBoundingClientRect().top,
        menulist.menupopup.getBoundingClientRect().top + bpTop,
        "Popup scroll at correct position");
   }
 
   for (let i = 0; i < test.downs.length; i++) {
     sendKey("PAGE_DOWN");
     is(menulist.menuBoxObject.activeChild.label, menulist.getItemAtIndex(test.downs[i]).label, test.list + " page down " + i);
   }
diff --git a/toolkit/content/tests/chrome/test_menulist_position.xul b/toolkit/content/tests/chrome/test_menulist_position.xul
--- a/toolkit/content/tests/chrome/test_menulist_position.xul
+++ b/toolkit/content/tests/chrome/test_menulist_position.xul
@@ -74,17 +74,17 @@ function popupShown()
 }
 
 function popupHidden()
 {
   if (!menulist.selectedItem) {
     SimpleTest.finish();
   }
   else {
-    menulist.selectedItem = menulist.selectedItem.nextSibling;
+    menulist.selectedItem = menulist.selectedItem.nextElementSibling;
     menulist.open = true;
   }
 }
 ]]>
 </script>
 
 <hbox align="center" pack="center" style="margin-top: 140px;">
   <menulist id="menulist" onpopupshown="popupShown();" onpopuphidden="popupHidden();">
diff --git a/toolkit/content/tests/chrome/test_notificationbox.xul b/toolkit/content/tests/chrome/test_notificationbox.xul
--- a/toolkit/content/tests/chrome/test_notificationbox.xul
+++ b/toolkit/content/tests/chrome/test_notificationbox.xul
@@ -202,17 +202,17 @@ var tests =
     result: function(nb, ntf) {
       testtag_notificationbox_State(nb, "append", ntf, 1);
       testtag_notification_State(nb, ntf, "append", "Notification", "note",
                                  "happy.png", nb.PRIORITY_WARNING_LOW);
       var button = ntf.querySelector(".notification-button");
       SimpleTest.is(button.type, "menu-button", "Button type should be set");
       var menuPopup = button.getElementsByTagNameNS(NSXUL, "menupopup");
       SimpleTest.is(menuPopup.length, 1, "There should be a menu attached");
-      var menuItem = menuPopup[0].firstChild;
+      var menuItem = menuPopup[0].firstElementChild;
       SimpleTest.is(menuItem.localName, "menuitem", "There should be a menu item");
       SimpleTest.is(menuItem.getAttribute("label"), "Menu Item", "Label should match");
       // Clean up.
       nb.removeNotification(ntf);
 
       return [1, null];
     }
   },
diff --git a/toolkit/content/tests/chrome/test_panelfrommenu.xul b/toolkit/content/tests/chrome/test_panelfrommenu.xul
--- a/toolkit/content/tests/chrome/test_panelfrommenu.xul
+++ b/toolkit/content/tests/chrome/test_panelfrommenu.xul
@@ -69,42 +69,42 @@ function menuOpened()
   synthesizeKey("KEY_Enter");
 }
 
 function menuClosed()
 {
   // the panel will be open at this point, but the popupshown event
   // still needs to fire
   is($("panel").state, "showing", "panel is open after menu hide");
-  is($("menu").firstChild.state, "closed", "menu is closed after menu hide");
+  is($("menu").firstElementChild.state, "closed", "menu is closed after menu hide");
 }
 
 function panelOpened()
 {
   is($("panel").state, "open", "panel is open");
-  is($("menu").firstChild.state, "closed", "menu is closed");
+  is($("menu").firstElementChild.state, "closed", "menu is closed");
   $("panel").hidePopup();
 }
 
 function panelOnButtonOpened(panel)
 {
   is(panel.state, 'open', 'button panel is open');
   is(document.activeElement, document.documentElement, "focus blurred on panel from button open");
   synthesizeKey("KEY_ArrowDown");
   is(document.activeElement, document.documentElement, "focus not modified on cursor down from button");
-  panel.firstChild.doCommand()
+  panel.firstElementChild.doCommand()
 }
 
 function panelOnToolbarbuttonOpened(panel)
 {
   is(panel.state, 'open', 'toolbarbutton panel is open');
   is(document.activeElement, document.documentElement, "focus blurred on panel from toolbarbutton open");
-  panel.firstChild.focus();
+  panel.firstElementChild.focus();
   synthesizeKey("KEY_ArrowDown");
-  is(document.activeElement, panel.firstChild.inputField, "focus not modified on cursor down from toolbarbutton");
+  is(document.activeElement, panel.firstElementChild.inputField, "focus not modified on cursor down from toolbarbutton");
   panel.parentNode.open = false;
 }
 
 ]]>
 </script>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
 <p id="display">
diff --git a/toolkit/content/tests/chrome/test_popup_coords.xul b/toolkit/content/tests/chrome/test_popup_coords.xul
--- a/toolkit/content/tests/chrome/test_popup_coords.xul
+++ b/toolkit/content/tests/chrome/test_popup_coords.xul
@@ -64,17 +64,17 @@ function popupShowingEventOccurred(event
   var trigger = document.getElementById(event.target.id == "outerpopup" ? "outer" : "inner");
   var rect = trigger.getBoundingClientRect();
   is(event.clientX, Math.round(rect.left + 4), testname + "clientX");
   is(event.clientY, Math.round(rect.top + 5), testname + "clientY");
   // rangeOffset should be just after the trigger element. As rangeOffset
   // considers the zeroth position to be before the first element, the value
   // should be one higher than its index within its parent.
   is(event.rangeParent, trigger.parentNode, testname + "rangeParent");
-  is(event.rangeOffset, Array.indexOf(trigger.parentNode.childNodes, trigger) + 1, testname + "rangeOffset");
+  is(event.rangeOffset, Array.indexOf(trigger.parentNode.children, trigger) + 1, testname + "rangeOffset");
 
   var popuprect = event.target.getBoundingClientRect();
   is(Math.round(popuprect.left), Math.round(rect.left + 4), "popup left");
   is(Math.round(popuprect.top), Math.round(rect.top + 5), "popup top");
   ok(popuprect.width > 0, "popup width");
   ok(popuprect.height > 0, "popup height");
 }
 </script>
diff --git a/toolkit/content/tests/chrome/test_popup_recreate.xul b/toolkit/content/tests/chrome/test_popup_recreate.xul
--- a/toolkit/content/tests/chrome/test_popup_recreate.xul
+++ b/toolkit/content/tests/chrome/test_popup_recreate.xul
@@ -33,17 +33,17 @@ function isWithinHalfPixel(a, b)
   return Math.abs(a - b) <= 0.5;
 }
 
 function recreate()
 {
   if (gState == "before") {
     var element = document.getElementById("menulist");
     while (element.hasChildNodes())
-      element.firstChild.remove();
+      element.firstElementChild.remove();
     element.appendItem("Cat");
     gState = "after";
     document.getElementById("menulist").open = true;
   }
   else {
     SimpleTest.finish();
   }
 }
diff --git a/toolkit/content/tests/chrome/test_popupincontent.xul b/toolkit/content/tests/chrome/test_popupincontent.xul
--- a/toolkit/content/tests/chrome/test_popupincontent.xul
+++ b/toolkit/content/tests/chrome/test_popupincontent.xul
@@ -70,17 +70,17 @@ function nextTest()
       popup.removeAttribute("top");
       for (var i = 0; i < 80; i++)
         menu.appendItem("Test", "");
       synthesizeMouse(menu, 2, 2, { });
       break;
     case "large menu":
       step = "shorter menu again";
       for (var i = 0; i < 80; i++)
-        popup.lastChild.remove();
+        popup.lastElementChild.remove();
       synthesizeMouse(menu, 2, 2, { });
       break;
     case "shorter menu again":
       SimpleTest.finish();
       break;
   }
 }
 
diff --git a/toolkit/content/tests/chrome/test_popupremoving.xul b/toolkit/content/tests/chrome/test_popupremoving.xul
--- a/toolkit/content/tests/chrome/test_popupremoving.xul
+++ b/toolkit/content/tests/chrome/test_popupremoving.xul
@@ -24,21 +24,21 @@
   -->
 
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>      
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>      
 
 <hbox>
 
 <menu id="nestedmenu1" label="1">
-    <menupopup id="nestedpopup1" onpopupshown="if (event.target == this) this.firstChild.open = true">
+    <menupopup id="nestedpopup1" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
       <menu id="nestedmenu2" label="2">
-        <menupopup id="nestedpopup2" onpopupshown="if (event.target == this) this.firstChild.open = true">
+        <menupopup id="nestedpopup2" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
           <menu id="nestedmenu3" label="3">
-            <menupopup id="nestedpopup3" onpopupshown="if (event.target == this) this.firstChild.open = true">
+            <menupopup id="nestedpopup3" onpopupshown="if (event.target == this) this.firstElementChild.open = true">
               <menu id="nestedmenu4" label="4" onpopupshown="removePopups()">
                 <menupopup id="nestedpopup4">
                   <menuitem label="Nested 1"/>
                   <menuitem label="Nested 2"/>
                   <menuitem label="Nested 3"/>
                 </menupopup>
               </menu>
             </menupopup>
diff --git a/toolkit/content/tests/chrome/test_richlist_direction.xul b/toolkit/content/tests/chrome/test_richlist_direction.xul
--- a/toolkit/content/tests/chrome/test_richlist_direction.xul
+++ b/toolkit/content/tests/chrome/test_richlist_direction.xul
@@ -34,18 +34,18 @@ function test_richlistbox()
     80 + (80 - richListBox._scrollbox.clientHeight);
   var height = richListBox._scrollbox.clientHeight;
   var item;
   do {
     item = richListBox.appendItem("Test", "");
     item.height = item.minHeight = item.maxHeight = Math.floor(height / 4);
   } while (item.getBoundingClientRect().bottom < (height * 2))
   richListBox.appendItem("Test", "");
-  richListBox.firstChild.nextSibling.id = "list-box-first";
-  richListBox.lastChild.previousSibling.id = "list-box-last";
+  richListBox.firstElementChild.nextElementSibling.id = "list-box-first";
+  richListBox.lastElementChild.previousElementSibling.id = "list-box-last";
 
   // direction = "reverse", the values here are backwards due to the fact that
   // richlistboxes respond differently when a user initiates a selection
   richListBox.dir = "reverse";
   var count = richListBox.itemCount;
   richListBox.focus();
   richListBox.selectedIndex = count - 1;
   sendKey("DOWN");
@@ -62,32 +62,32 @@ function test_richlistbox()
   is(richListBox.currentIndex, index, "Selection should move to one page down");
   ok(richListBox.currentIndex < currentIndex, "Selection should move downwards");
   sendKey("END");
   currentIndex = richListBox.currentIndex;
   index = getScrollIndexAmount(1);
   sendKey("PAGE_UP");
   is(richListBox.currentIndex, index, "Selection should move to one page up");
   ok(richListBox.currentIndex > currentIndex, "Selection should move upwards");
-  richListBox.selectedItem = richListBox.lastChild;
+  richListBox.selectedItem = richListBox.lastElementChild;
   richListBox.focus();
   synthesizeKey("KEY_ArrowDown", {shiftKey: true}, window);
   let items = [richListBox.selectedItems[0],
                richListBox.selectedItems[1]];
-  is(items[0], richListBox.lastChild, "The last element should still be selected");
-  is(items[1], richListBox.lastChild.previousSibling, "Both elements should now be selected");
+  is(items[0], richListBox.lastElementChild, "The last element should still be selected");
+  is(items[1], richListBox.lastElementChild.previousElementSibling, "Both elements should now be selected");
   richListBox.clearSelection();
-  richListBox.selectedItem = richListBox.lastChild;
+  richListBox.selectedItem = richListBox.lastElementChild;
   sendMouseEvent({type: "click", shiftKey: true, clickCount: 1},
                  "list-box-last",
                  window);
   items = [richListBox.selectedItems[0],
            richListBox.selectedItems[1]];
-  is(items[0], richListBox.lastChild, "The last element should still be selected");
-  is(items[1], richListBox.lastChild.previousSibling, "Both elements should now be selected");
+  is(items[0], richListBox.lastElementChild, "The last element should still be selected");
+  is(items[1], richListBox.lastElementChild.previousElementSibling, "Both elements should now be selected");
   richListBox.addEventListener("keypress", function(aEvent) {
     richListBox.removeEventListener("keypress", arguments.callee, true);
     aEvent.preventDefault();
   }, true);
   richListBox.selectedIndex = 1;
   sendKey("HOME");
   is(richListBox.selectedIndex, 1, "A stopped event should return indexing to normal");
 
@@ -108,31 +108,31 @@ function test_richlistbox()
   is(richListBox.currentIndex, index, "Selection should move to one page down");
   ok(richListBox.currentIndex > currentIndex, "Selection should move downwards");
   sendKey("END");
   currentIndex = richListBox.currentIndex;
   index = richListBox.scrollOnePage(-1) + richListBox.currentIndex;
   sendKey("PAGE_UP");
   is(richListBox.currentIndex, index, "Selection should move to one page up");
   ok(richListBox.currentIndex < currentIndex, "Selection should move upwards");
-  richListBox.selectedItem = richListBox.firstChild;
+  richListBox.selectedItem = richListBox.firstElementChild;
   richListBox.focus();
   synthesizeKey("KEY_ArrowDown", {shiftKey: true}, window);
   items = [richListBox.selectedItems[0],
            richListBox.selectedItems[1]];
-  is(items[0], richListBox.firstChild, "The last element should still be selected");
-  is(items[1], richListBox.firstChild.nextSibling, "Both elements should now be selected");
+  is(items[0], richListBox.firstElementChild, "The last element should still be selected");
+  is(items[1], richListBox.firstElementChild.nextElementSibling, "Both elements should now be selected");
   richListBox.clearSelection();
-  richListBox.selectedItem = richListBox.firstChild;
+  richListBox.selectedItem = richListBox.firstElementChild;
   sendMouseEvent({type: "click", shiftKey: true, clickCount: 1},
                  "list-box-first",
                  window);
   items = [richListBox.selectedItems[0],
            richListBox.selectedItems[1]];
-  is(items[0], richListBox.firstChild, "The last element should still be selected");
-  is(items[1], richListBox.firstChild.nextSibling, "Both elements should now be selected");
+  is(items[0], richListBox.firstElementChild, "The last element should still be selected");
+  is(items[1], richListBox.firstElementChild.nextElementSibling, "Both elements should now be selected");
   SimpleTest.finish();
 }
 
 ]]>
 </script>
 
 </window>
diff --git a/toolkit/content/tests/chrome/test_showcaret.xul b/toolkit/content/tests/chrome/test_showcaret.xul
--- a/toolkit/content/tests/chrome/test_showcaret.xul
+++ b/toolkit/content/tests/chrome/test_showcaret.xul
@@ -68,17 +68,17 @@ function otherWindowFocused()
 {
   otherWindow.removeEventListener("focus", otherWindowFocused, false);
 
   // enable caret browsing temporarily to test caret movement
   var prefs = Cc["@mozilla.org/preferences-service;1"].
                 getService(Ci.nsIPrefBranch);
   prefs.setBoolPref("accessibility.browsewithcaret", true);
 
-  var hbox = otherWindow.document.documentElement.firstChild;
+  var hbox = otherWindow.document.documentElement.firstElementChild;
   hbox.focus();
   is(otherWindow.document.activeElement, hbox, "hbox in other window is focused");
 
   document.commandDispatcher.getControllerForCommand("cmd_lineNext").doCommand("cmd_lineNext");
   is(otherWindow.document.activeElement, hbox, "hbox still focused in other window after down movement");
 
   prefs.setBoolPref("accessibility.browsewithcaret", false);
 
diff --git a/toolkit/content/tests/chrome/test_tabbox.xul b/toolkit/content/tests/chrome/test_tabbox.xul
--- a/toolkit/content/tests/chrome/test_tabbox.xul
+++ b/toolkit/content/tests/chrome/test_tabbox.xul
@@ -77,85 +77,85 @@
 SimpleTest.waitForExplicitFinish();
 
 function test_tabbox()
 {
   var tabbox = document.getElementById("tabbox");
   var tabs = document.getElementById("tabs");
   var tabpanels = document.getElementById("tabpanels");
 
-  test_tabbox_State(tabbox, "tabbox initial", 0, tabs.firstChild, tabpanels.firstChild);
+  test_tabbox_State(tabbox, "tabbox initial", 0, tabs.firstElementChild, tabpanels.firstElementChild);
 
   // check the selectedIndex property
   tabbox.selectedIndex = 1;
-  test_tabbox_State(tabbox, "tabbox selectedIndex 1", 1, tabs.lastChild, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabbox selectedIndex 1", 1, tabs.lastElementChild, tabpanels.lastElementChild);
 
   tabbox.selectedIndex = 2;
-  test_tabbox_State(tabbox, "tabbox selectedIndex 2", 1, tabs.lastChild, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabbox selectedIndex 2", 1, tabs.lastElementChild, tabpanels.lastElementChild);
 
   // tabbox must have a selection, so setting to -1 should do nothing
   tabbox.selectedIndex = -1;
-  test_tabbox_State(tabbox, "tabbox selectedIndex -1", 1, tabs.lastChild, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabbox selectedIndex -1", 1, tabs.lastElementChild, tabpanels.lastElementChild);
 
   // check the selectedTab property
-  tabbox.selectedTab = tabs.firstChild;
-  test_tabbox_State(tabbox, "tabbox selected", 0, tabs.firstChild, tabpanels.firstChild);
+  tabbox.selectedTab = tabs.firstElementChild;
+  test_tabbox_State(tabbox, "tabbox selected", 0, tabs.firstElementChild, tabpanels.firstElementChild);
 
   // setting selectedTab to null should not do anything
   tabbox.selectedTab = null;
-  test_tabbox_State(tabbox, "tabbox selectedTab null", 0, tabs.firstChild, tabpanels.firstChild);
+  test_tabbox_State(tabbox, "tabbox selectedTab null", 0, tabs.firstElementChild, tabpanels.firstElementChild);
 
   // check the selectedPanel property
-  tabbox.selectedPanel = tabpanels.lastChild;
-  test_tabbox_State(tabbox, "tabbox selectedPanel", 0, tabs.firstChild, tabpanels.lastChild);
+  tabbox.selectedPanel = tabpanels.lastElementChild;
+  test_tabbox_State(tabbox, "tabbox selectedPanel", 0, tabs.firstElementChild, tabpanels.lastElementChild);
 
   // setting selectedPanel to null should not do anything
   tabbox.selectedPanel = null;
-  test_tabbox_State(tabbox, "tabbox selectedPanel null", 0, tabs.firstChild, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabbox selectedPanel null", 0, tabs.firstElementChild, tabpanels.lastElementChild);
 
   tabbox.selectedIndex = 0;
   test_tabpanels(tabpanels, tabbox);
 
-  tabs.firstChild.remove();
-  tabs.firstChild.remove();
+  tabs.firstElementChild.remove();
+  tabs.firstElementChild.remove();
 
   test_tabs(tabs);
 
   test_tabbox_focus();
 }
 
 function test_tabpanels(tabpanels, tabbox)
 {
   var tab = tabbox.selectedTab;
 
   // changing the selection on the tabpanels should not affect the tabbox
   // or tabs within
   // check the selectedIndex property
   tabpanels.selectedIndex = 1;
-  test_tabbox_State(tabbox, "tabpanels tabbox selectedIndex 1", 0, tab, tabpanels.lastChild);
-  test_tabpanels_State(tabpanels, "tabpanels selectedIndex 1", 1, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabpanels tabbox selectedIndex 1", 0, tab, tabpanels.lastElementChild);
+  test_tabpanels_State(tabpanels, "tabpanels selectedIndex 1", 1, tabpanels.lastElementChild);
 
   tabpanels.selectedIndex = 0;
-  test_tabbox_State(tabbox, "tabpanels tabbox selectedIndex 2", 0, tab, tabpanels.firstChild);
-  test_tabpanels_State(tabpanels, "tabpanels selectedIndex 2", 0, tabpanels.firstChild);
+  test_tabbox_State(tabbox, "tabpanels tabbox selectedIndex 2", 0, tab, tabpanels.firstElementChild);
+  test_tabpanels_State(tabpanels, "tabpanels selectedIndex 2", 0, tabpanels.firstElementChild);
 
   // setting selectedIndex to -1 should do nothing
   tabpanels.selectedIndex = 1;
   tabpanels.selectedIndex = -1;
-  test_tabbox_State(tabbox, "tabpanels tabbox selectedIndex -1", 0, tab, tabpanels.lastChild);
-  test_tabpanels_State(tabpanels, "tabpanels selectedIndex -1", 1, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabpanels tabbox selectedIndex -1", 0, tab, tabpanels.lastElementChild);
+  test_tabpanels_State(tabpanels, "tabpanels selectedIndex -1", 1, tabpanels.lastElementChild);
 
   // check the tabpanels.selectedPanel property
-  tabpanels.selectedPanel = tabpanels.lastChild;
-  test_tabbox_State(tabbox, "tabpanels tabbox selectedPanel", 0, tab, tabpanels.lastChild);
-  test_tabpanels_State(tabpanels, "tabpanels selectedPanel", 1, tabpanels.lastChild);
+  tabpanels.selectedPanel = tabpanels.lastElementChild;
+  test_tabbox_State(tabbox, "tabpanels tabbox selectedPanel", 0, tab, tabpanels.lastElementChild);
+  test_tabpanels_State(tabpanels, "tabpanels selectedPanel", 1, tabpanels.lastElementChild);
 
   // check setting the tabpanels.selectedPanel property to null
   tabpanels.selectedPanel = null;
-  test_tabbox_State(tabbox, "tabpanels selectedPanel null", 0, tab, tabpanels.lastChild);
+  test_tabbox_State(tabbox, "tabpanels selectedPanel null", 0, tab, tabpanels.lastElementChild);
 }
 
 function test_tabs(tabs)
 {
   test_nsIDOMXULSelectControlElement(tabs, "tab", "tabs");
   // XXXndeakin would test the UI aspect of tabs, but the mouse
   // events on tabs are fired in a timeout causing the generic
   // test_nsIDOMXULSelectControlElement_UI method not to work
diff --git a/toolkit/content/tests/chrome/window_largemenu.xul b/toolkit/content/tests/chrome/window_largemenu.xul
--- a/toolkit/content/tests/chrome/window_largemenu.xul
+++ b/toolkit/content/tests/chrome/window_largemenu.xul
@@ -67,27 +67,27 @@ function nextTest()
   if (gTestIndex == 1) // open with bottom overlap test:
     y -= 100;
   else
     y /= 2;
 
   var popup = document.getElementById("popup");
   if (gTestIndex == 2) {
     // add some more menuitems so that scrolling will be necessary
-    var moreItemCount = Math.round(screen.height / popup.firstChild.getBoundingClientRect().height);
+    var moreItemCount = Math.round(screen.height / popup.firstElementChild.getBoundingClientRect().height);
     for (var t = 1; t <= moreItemCount; t++) {
       var menu = document.createElement("menuitem");
       menu.setAttribute("label", "More" + t);
       popup.appendChild(menu);
     }
   }
   else if (gTestIndex == 4) {
     // remove the items added in test 2 above
-    while (popup.childNodes.length > 15)
-      popup.removeChild(popup.lastChild);
+    while (popup.children.length > 15)
+      popup.removeChild(popup.lastElementChild);
   }
 
   window.requestAnimationFrame(function() {
     setTimeout(
       function() {
         popup.openPopupAtScreen(100, y, false);
       }, 0);
   });
diff --git a/toolkit/content/tests/chrome/window_panel.xul b/toolkit/content/tests/chrome/window_panel.xul
--- a/toolkit/content/tests/chrome/window_panel.xul
+++ b/toolkit/content/tests/chrome/window_panel.xul
@@ -210,17 +210,17 @@ var tests = [
 
       var gotMouseEvent = false;
       function mouseMoved(event)
       {
         is(event.clientY, panelrect.top + 10,
            "popup clientY");
         is(event.screenY, panel.boxObject.screenY + 10,
            "popup screenY");
-        is(event.originalTarget, panel.firstChild, "popup target");
+        is(event.originalTarget, panel.firstElementChild, "popup target");
         gotMouseEvent = true;
       }
 
       panel.addEventListener("mousemove", mouseMoved, true);
       synthesizeMouse(panel, 10, 10, { type: "mousemove" });
       ok(gotMouseEvent, "mouse event on panel");      
       panel.removeEventListener("mousemove", mouseMoved, true);
 
diff --git a/toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul b/toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul
--- a/toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul
+++ b/toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul
@@ -44,17 +44,17 @@ function runTest()
   menu.open = true;
 
   setTimeout(runTestAfterMinimize, 0);
 }
 
 function runTestAfterMinimize()
 {
   var menu = document.getElementById("menu");
-  is(menu.firstChild.state, "closed", "popup not opened when window minimized");
+  is(menu.firstElementChild.state, "closed", "popup not opened when window minimized");
 
   window.restore();
   is(window.windowState, window.STATE_NORMAL, "window is restored");
 
   is(fm.activeWindow, window, "active window after restore");
   is(fm.focusedWindow, window, "focused window after restore");
 
   menu.open = true;
diff --git a/toolkit/content/tests/chrome/window_titlebar.xul b/toolkit/content/tests/chrome/window_titlebar.xul
--- a/toolkit/content/tests/chrome/window_titlebar.xul
+++ b/toolkit/content/tests/chrome/window_titlebar.xul
@@ -136,17 +136,17 @@ function test_titlebar_step2(mousedownLi
 }
 
 function popupshown(panel, anchored)
 {
   var rect = panel.getBoundingClientRect();
 
   // skip this check for non-noautohide panels
   if (panel.id == "panel") {
-    var panellabel = panel.firstChild.firstChild;
+    var panellabel = panel.firstElementChild.firstElementChild;
     synthesizeMouse(panellabel, 2, 2, { type: "mousedown" });
     waitForWindowMove(panellabel, 22, 22, popupshown_step3, rect, panel, anchored);
     return;
   }
 
   // now, try moving the window. If anchored, the popup should move with the
   // window. If not anchored, the popup should remain at its current screen location.
   window.moveBy(10, 10);
@@ -170,17 +170,17 @@ function popupshown_step2(oldrect, panel
 
   // anchored popups should still be at the same offset. Non-anchored popups will
   // now be offset by 10 pixels less.
   SimpleTest.is(newrect.left, oldrect.left - (anchored ? 0 : 10),
                 panel.id + " horizontal after window move");
   SimpleTest.is(newrect.top, oldrect.top - (anchored ? 0 : 10),
                 panel.id + " vertical after window move");
 
-  var panellabel = panel.firstChild.firstChild;
+  var panellabel = panel.firstElementChild.firstElementChild;
   synthesizeMouse(panellabel, 2, 2, { type: "mousedown" });
   waitForWindowMove(panellabel, 22, 22, popupshown_step3, newrect, panel, anchored);
 }
 
 function popupshown_step3(oldrect, panel, anchored)
 {
   // skip this check on Linux for the same window positioning reasons as above
   if (!navigator.platform.includes("Linux") || (panel.id != "panelanchored" && panel.id != "paneltop")) {
diff --git a/toolkit/content/tests/widgets/popup_shared.js b/toolkit/content/tests/widgets/popup_shared.js
--- a/toolkit/content/tests/widgets/popup_shared.js
+++ b/toolkit/content/tests/widgets/popup_shared.js
@@ -270,17 +270,17 @@ function closeMenu(menu, popup) {
       bo.openMenu(false);
     else
       popup.hidePopup();
   }
 }
 
 function checkActive(popup, id, testname) {
   var activeok = true;
-  var children = popup.childNodes;
+  var children = popup.children;
   for (var c = 0; c < children.length; c++) {
     var child = children[c];
     if ((id == child.id && child.getAttribute(menuactiveAttribute) != "true") ||
         (id != child.id && child.hasAttribute(menuactiveAttribute) != "")) {
       activeok = false;
       break;
     }
   }
diff --git a/toolkit/content/tests/widgets/tree_shared.js b/toolkit/content/tests/widgets/tree_shared.js
--- a/toolkit/content/tests/widgets/tree_shared.js
+++ b/toolkit/content/tests/widgets/tree_shared.js
@@ -1296,36 +1296,36 @@ function compareArrays(arr1, arr2) {
   return true;
 }
 
 function convertDOMtoTreeRowInfo(treechildren, level, rowidx) {
   var obj = { rows: [] };
 
   var parentidx = rowidx.value;
 
-  treechildren = treechildren.childNodes;
+  treechildren = treechildren.children;
   for (var r = 0; r < treechildren.length; r++) {
     rowidx.value++;
 
     var treeitem = treechildren[r];
     if (treeitem.hasChildNodes()) {
-      var treerow = treeitem.firstChild;
+      var treerow = treeitem.firstElementChild;
       var cellInfo = [];
-      for (var c = 0; c < treerow.childNodes.length; c++) {
-        var cell = treerow.childNodes[c];
+      for (var c = 0; c < treerow.children.length; c++) {
+        var cell = treerow.children[c];
         cellInfo.push({ label: "" + cell.getAttribute("label"),
                         value: cell.getAttribute("value"),
                         properties: cell.getAttribute("properties"),
                         editable: cell.getAttribute("editable") != "false",
                         selectable: cell.getAttribute("selectable") != "false",
                         image: cell.getAttribute("src"),
                         mode: cell.hasAttribute("mode") ? parseInt(cell.getAttribute("mode")) : 3 });
       }
 
-      var descendants = treeitem.lastChild;
+      var descendants = treeitem.lastElementChild;
       var children = (treerow == descendants) ? null :
                      convertDOMtoTreeRowInfo(descendants, level + 1, rowidx);
       obj.rows.push({ cells: cellInfo,
                       properties: treerow.getAttribute("properties"),
                       container: treeitem.getAttribute("container") == "true",
                       separator: treeitem.localName == "treeseparator",
                       children,
                       level,
diff --git a/toolkit/content/widgets/general.js b/toolkit/content/widgets/general.js
--- a/toolkit/content/widgets/general.js
+++ b/toolkit/content/widgets/general.js
@@ -17,33 +17,33 @@ class MozDeck extends MozXULElement {
   }
 
   get selectedIndex() {
     return this.getAttribute("selectedIndex") || "0";
   }
 
   set selectedPanel(val) {
     var selectedIndex = -1;
-    for (var panel = val; panel != null; panel = panel.previousSibling)
+    for (var panel = val; panel != null; panel = panel.previousElementSibling)
       ++selectedIndex;
     this.selectedIndex = selectedIndex;
     return val;
   }
 
   get selectedPanel() {
-    return this.childNodes[this.selectedIndex];
+    return this.children[this.selectedIndex];
   }
 }
 
 customElements.define("deck", MozDeck);
 
 class MozDropmarker extends MozXULElement {
   connectedCallback() {
     // Only create the image the first time we are connected
-    if (!this.firstChild) {
+    if (!this.firstElementChild) {
       let image = document.createXULElement("image");
       image.classList.add("dropmarker-icon");
       this.appendChild(image);
     }
   }
 }
 
 customElements.define("dropmarker", MozDropmarker);
diff --git a/toolkit/content/widgets/spinner.js b/toolkit/content/widgets/spinner.js
--- a/toolkit/content/widgets/spinner.js
+++ b/toolkit/content/widgets/spinner.js
@@ -208,35 +208,35 @@ function Spinner(props, context) {
         return;
       }
 
       if (diff > 0) {
         // Add more elements if length is greater than current
         let frag = document.createDocumentFragment();
 
         // Remove margin bottom on the last element before appending
-        if (parent.lastChild) {
-          parent.lastChild.style.marginBottom = "";
+        if (parent.lastElementChild) {
+          parent.lastElementChild.style.marginBottom = "";
         }
 
         for (let i = 0; i < diff; i++) {
           let el = document.createElement("div");
           frag.appendChild(el);
           this.elements.itemsViewElements.push(el);
         }
         parent.appendChild(frag);
       } else if (diff < 0) {
         // Remove elements if length is less than current
         for (let i = 0; i < Math.abs(diff); i++) {
-          parent.removeChild(parent.lastChild);
+          parent.removeChild(parent.lastElementChild);
         }
         this.elements.itemsViewElements.splice(diff);
       }
 
-      parent.lastChild.style.marginBottom =
+      parent.lastElementChild.style.marginBottom =
         (ITEM_HEIGHT * this.props.viewportTopOffset) + "rem";
     },
 
     /**
      * Set the display string and class name to the elements.
      *
      * @param {Array<Object>} items
      *        [{
diff --git a/toolkit/content/widgets/textbox.js b/toolkit/content/widgets/textbox.js
--- a/toolkit/content/widgets/textbox.js
+++ b/toolkit/content/widgets/textbox.js
@@ -144,17 +144,17 @@ class MozInputBox extends MozXULElement 
     this._setMenuItemVisibility("spell-dictionaries", enabled && numdicts > 1);
   }
 
   _doPopupItemEnabling(popupNode) {
     if (this.spellcheck) {
       this._doPopupItemEnablingSpell(popupNode);
     }
 
-    var children = popupNode.childNodes;
+    var children = popupNode.children;
     for (var i = 0; i < children.length; i++) {
       var command = children[i].getAttribute("cmd");
       if (command) {
         var controller = document.commandDispatcher.getControllerForCommand(command);
         var enabled = controller.isCommandEnabled(command);
         if (enabled)
           children[i].removeAttribute("disabled");
         else
diff --git a/toolkit/crashreporter/content/crashes.js b/toolkit/crashreporter/content/crashes.js
--- a/toolkit/crashreporter/content/crashes.js
+++ b/toolkit/crashreporter/content/crashes.js
@@ -18,24 +18,24 @@ document.addEventListener("DOMContentLoa
     clearReports().then(null, Cu.reportError);
   });
 });
 
 const buildID = Services.appinfo.appBuildID;
 
 function submitPendingReport(event) {
   let link = event.target;
-  let id = link.firstChild.textContent;
+  let id = link.firstElementChild.textContent;
   link.className = "submitting";
   CrashSubmit.submit(id, { noThrottle: true }).then(
     (remoteCrashID) => {
       link.className = "";
       // Reset the link to point at our new crash report. This way, if the
       // user clicks "Back", the link will be correct.
-      link.firstChild.textContent = remoteCrashID;
+      link.firstElementChild.textContent = remoteCrashID;
       link.setAttribute("id", remoteCrashID);
       link.removeEventListener("click", submitPendingReport, true);
 
       if (reportURL) {
         link.setAttribute("href", reportURL + remoteCrashID);
         // redirect the user to their brand new crash report
         window.location.href = reportURL + remoteCrashID;
       }
diff --git a/toolkit/crashreporter/test/browser/browser_aboutCrashes.js b/toolkit/crashreporter/test/browser/browser_aboutCrashes.js
--- a/toolkit/crashreporter/test/browser/browser_aboutCrashes.js
+++ b/toolkit/crashreporter/test/browser/browser_aboutCrashes.js
@@ -10,16 +10,16 @@ add_task(async function test() {
   await BrowserTestUtils.withNewTab({ gBrowser, url: "about:crashes" }, function(browser) {
     info("about:crashes loaded");
     return ContentTask.spawn(browser, crashes, function(crashes) {
       let doc = content.document;
       let crashlinks = doc.getElementById("submitted").querySelectorAll(".crashReport");
       Assert.equal(crashlinks.length, crashes.length,
         "about:crashes lists correct number of crash reports");
       for (let i = 0; i < crashes.length; i++) {
-        Assert.equal(crashlinks[i].firstChild.textContent, crashes[i].id,
+        Assert.equal(crashlinks[i].firstElementChild.textContent, crashes[i].id,
           i + ": crash ID is correct");
       }
     });
   });
 
   cleanup_fake_appdir();
 });
diff --git a/toolkit/modules/AutoScrollController.jsm b/toolkit/modules/AutoScrollController.jsm
--- a/toolkit/modules/AutoScrollController.jsm
+++ b/toolkit/modules/AutoScrollController.jsm
@@ -57,17 +57,17 @@ class AutoScrollController {
     }
 
     return aNode instanceof content.XULElement;
   }
 
   getXBLNodes(parent, array) {
     let content = parent.ownerGlobal;
     let anonNodes = content.document.getAnonymousNodes(parent);
-    let nodes = Array.from(anonNodes || parent.childNodes || []);
+    let nodes = Array.from(anonNodes || parent.children || []);
     for (let node of nodes) {
       if (node.nodeName == "children") {
         return true;
       }
       if (this.getXBLNodes(node, array)) {
         array.push(node);
         return true;
       }
diff --git a/toolkit/modules/PageMenu.jsm b/toolkit/modules/PageMenu.jsm
--- a/toolkit/modules/PageMenu.jsm
+++ b/toolkit/modules/PageMenu.jsm
@@ -71,17 +71,17 @@ PageMenu.prototype = {
     }
 
     let fragment = aPopup.ownerDocument.createDocumentFragment();
     this.buildXULMenu(aMenu, fragment);
 
     let pos = insertionPoint.getAttribute(this.PAGEMENU_ATTR);
     if (pos == "start") {
       insertionPoint.insertBefore(fragment,
-                                  insertionPoint.firstChild);
+                                  insertionPoint.firstElementChild);
     } else if (pos.startsWith("#")) {
       insertionPoint.insertBefore(fragment, insertionPoint.querySelector(pos));
     } else {
       insertionPoint.appendChild(fragment);
     }
 
     this._browser = aBrowser;
     this._popup = aPopup;
@@ -175,64 +175,64 @@ PageMenu.prototype = {
       this._popup = null;
       this._builder = null;
       this._browser = null;
     }
   },
 
   // Get the first child of the given element with the given tag name.
   getImmediateChild(element, tag) {
-    let child = element.firstChild;
+    let child = element.firstElementChild;
     while (child) {
       if (child.localName == tag) {
         return child;
       }
-      child = child.nextSibling;
+      child = child.nextElementSibling;
     }
     return null;
   },
 
   // Return the location where the generated items should be inserted into the
   // given popup. They should be inserted as the next sibling of the returned
   // element.
   getInsertionPoint(aPopup) {
     if (aPopup.hasAttribute(this.PAGEMENU_ATTR))
       return aPopup;
 
-    let element = aPopup.firstChild;
+    let element = aPopup.firstElementChild;
     while (element) {
       if (element.localName == "menu") {
         let popup = this.getImmediateChild(element, "menupopup");
         if (popup) {
           let result = this.getInsertionPoint(popup);
           if (result) {
             return result;
           }
         }
       }
-      element = element.nextSibling;
+      element = element.nextElementSibling;
     }
 
     return null;
   },
 
   // Remove the generated content from the given popup.
   removeGeneratedContent(aPopup) {
     let ungenerated = [];
     ungenerated.push(aPopup);
 
     let count;
     while (0 != (count = ungenerated.length)) {
       let last = count - 1;
       let element = ungenerated[last];
       ungenerated.splice(last, 1);
 
-      let i = element.childNodes.length;
+      let i = element.children.length;
       while (i-- > 0) {
-        let child = element.childNodes[i];
+        let child = element.children[i];
         if (!child.hasAttribute(this.GENERATEDITEMID_ATTR)) {
           ungenerated.push(child);
           continue;
         }
         element.removeChild(child);
       }
     }
   }
diff --git a/toolkit/modules/PopupNotifications.jsm b/toolkit/modules/PopupNotifications.jsm
--- a/toolkit/modules/PopupNotifications.jsm
+++ b/toolkit/modules/PopupNotifications.jsm
@@ -233,17 +233,17 @@ function PopupNotifications(tabbrowser, 
   // This listener will be attached to the chrome window whenever a notification
   // is showing, to allow the user to dismiss notifications using the escape key.
   this._handleWindowKeyPress = aEvent => {
     if (aEvent.keyCode != aEvent.DOM_VK_ESCAPE) {
       return;
     }
 
     // Esc key cancels the topmost notification, if there is one.
-    let notification = this.panel.firstChild;
+    let notification = this.panel.firstElementChild;
     if (!notification) {
       return;
     }
 
     let doc = this.window.document;
     let focusedElement = Services.focus.focusedElement;
 
     // If the chrome window has a focused element, let it handle the ESC key instead.
@@ -695,18 +695,18 @@ PopupNotifications.prototype = {
     // non-persistent.
     if (event && telemetryReason == TELEMETRY_STAT_DISMISSAL_CLOSE_BUTTON) {
       let notificationEl = getNotificationFromElement(event.target);
       if (notificationEl) {
         notificationEl.notification.options.persistent = false;
       }
     }
 
-    let browser = this.panel.firstChild &&
-                  this.panel.firstChild.notification.browser;
+    let browser = this.panel.firstElementChild &&
+                  this.panel.firstElementChild.notification.browser;
     this.panel.hidePopup();
     if (browser)
       browser.focus();
   },
 
   /**
    * Hides the notification popup.
    */
@@ -723,30 +723,30 @@ PopupNotifications.prototype = {
     return deferred.promise;
   },
 
   /**
    * Removes all notifications from the notification popup.
    */
   _clearPanel() {
     let popupnotification;
-    while ((popupnotification = this.panel.lastChild)) {
+    while ((popupnotification = this.panel.lastElementChild)) {
       this.panel.removeChild(popupnotification);
 
       // If this notification was provided by the chrome document rather than
       // created ad hoc, move it back to where we got it from.
       let originalParent = gNotificationParents.get(popupnotification);
       if (originalParent) {
         popupnotification.notification = null;
 
         // Remove nodes dynamically added to the notification's menu button
         // in _refreshPanel.
-        let contentNode = popupnotification.lastChild;
+        let contentNode = popupnotification.lastElementChild;
         while (contentNode) {
-          let previousSibling = contentNode.previousSibling;
+          let previousSibling = contentNode.previousElementSibling;
           if (contentNode.nodeName == "menuitem" ||
               contentNode.nodeName == "menuseparator")
             popupnotification.removeChild(contentNode);
           contentNode = previousSibling;
         }
 
         // Re-hide the notification such that it isn't rendered in the chrome
         // document. _refreshPanel will unhide it again when needed.
@@ -1022,17 +1022,17 @@ PopupNotifications.prototype = {
       if (notificationsToShow.some(n => n.options.persistent)) {
         this.panel.setAttribute("noautohide", "true");
       } else {
         this.panel.removeAttribute("noautohide");
       }
 
       // On OS X and Linux we need a different panel arrow color for
       // click-to-play plugins, so copy the popupid and use css.
-      this.panel.setAttribute("popupid", this.panel.firstChild.getAttribute("popupid"));
+      this.panel.setAttribute("popupid", this.panel.firstElementChild.getAttribute("popupid"));
       notificationsToShow.forEach(function(n) {
         // Record that the notification was actually displayed on screen.
         // Notifications that were opened a second time or that were originally
         // shown with "options.dismissed" will be recorded in a separate bucket.
         n._recordTelemetryStat(TELEMETRY_STAT_OFFERED);
         // Remember the time the notification was shown for the security delay.
         n.timeShown = this.window.performance.now();
       }, this);
@@ -1410,24 +1410,24 @@ PopupNotifications.prototype = {
     this._dismissOrRemoveCurrentNotifications();
 
     this._clearPanel();
 
     this._update();
   },
 
   _dismissOrRemoveCurrentNotifications() {
-    let browser = this.panel.firstChild &&
-                  this.panel.firstChild.notification.browser;
+    let browser = this.panel.firstElementChild &&
+                  this.panel.firstElementChild.notification.browser;
     if (!browser)
       return;
 
     let notifications = this._getNotificationsForBrowser(browser);
     // Mark notifications as dismissed and call dismissal callbacks
-    Array.forEach(this.panel.childNodes, function(nEl) {
+    Array.forEach(this.panel.children, function(nEl) {
       let notificationObj = nEl.notification;
       // Never call a dismissal handler on a notification that's been removed.
       if (!notifications.includes(notificationObj))
         return;
 
       // Record the time of the first notification dismissal if the main action
       // was not triggered in the meantime.
       let timeSinceShown = this.window.performance.now() - notificationObj.timeShown;
diff --git a/toolkit/modules/SelectParentHelper.jsm b/toolkit/modules/SelectParentHelper.jsm
--- a/toolkit/modules/SelectParentHelper.jsm
+++ b/toolkit/modules/SelectParentHelper.jsm
@@ -140,19 +140,19 @@ var SelectParentHelper = {
     closedWithEnter = false;
     selectRect = rect;
     this._registerListeners(browser, menulist.menupopup);
 
     let win = browser.ownerGlobal;
 
     // Set the maximum height to show exactly MAX_ROWS items.
     let menupopup = menulist.menupopup;
-    let firstItem = menupopup.firstChild;
+    let firstItem = menupopup.firstElementChild;
     while (firstItem && firstItem.hidden) {
-      firstItem = firstItem.nextSibling;
+      firstItem = firstItem.nextElementSibling;
     }
 
     if (firstItem) {
       let itemHeight = firstItem.getBoundingClientRect().height;
 
       // Include the padding and border on the popup.
       let cs = win.getComputedStyle(menupopup);
       let bpHeight = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth) +
@@ -464,39 +464,39 @@ function populateChildren(menulist, opti
       switch (event.key) {
         case "Escape":
           searchbox.parentElement.hidePopup();
           break;
         case "ArrowDown":
         case "Enter":
         case "Tab":
           searchbox.blur();
-          if (searchbox.nextSibling.localName == "menuitem" &&
-              !searchbox.nextSibling.hidden) {
-            menulist.menuBoxObject.activeChild = searchbox.nextSibling;
+          if (searchbox.nextElementSibling.localName == "menuitem" &&
+              !searchbox.nextElementSibling.hidden) {
+            menulist.menuBoxObject.activeChild = searchbox.nextElementSibling;
           } else {
-            var currentOption = searchbox.nextSibling;
+            var currentOption = searchbox.nextElementSibling;
             while (currentOption && (currentOption.localName != "menuitem" ||
                   currentOption.hidden)) {
-              currentOption = currentOption.nextSibling;
+              currentOption = currentOption.nextElementSibling;
             }
             if (currentOption) {
               menulist.menuBoxObject.activeChild = currentOption;
             } else {
               searchbox.focus();
             }
           }
           break;
         default:
           return;
       }
       event.preventDefault();
     }, true);
 
-    element.insertBefore(searchbox, element.childNodes[0]);
+    element.insertBefore(searchbox, element.children[0]);
   }
 
   return nthChildIndex;
 }
 
 function onSearchInput() {
   let searchObj = this;
 
@@ -527,17 +527,17 @@ function onSearchInput() {
       } else if (currentItem.localName == "menucaption") {
         if (prevCaption != null) {
           prevCaption.hidden = allHidden;
         }
         prevCaption = currentItem;
         allHidden = true;
       } else {
         if (!currentItem.classList.contains("contentSelectDropdown-ingroup") &&
-            currentItem.previousSibling.classList.contains("contentSelectDropdown-ingroup")) {
+            currentItem.previousElementSibling.classList.contains("contentSelectDropdown-ingroup")) {
           if (prevCaption != null) {
             prevCaption.hidden = allHidden;
           }
           prevCaption = null;
           allHidden = true;
         }
         if (itemLabel.includes(input) || itemTooltip.includes(input)) {
           currentItem.hidden = false;
diff --git a/toolkit/modules/SelectionSourceContent.jsm b/toolkit/modules/SelectionSourceContent.jsm
--- a/toolkit/modules/SelectionSourceContent.jsm
+++ b/toolkit/modules/SelectionSourceContent.jsm
@@ -30,18 +30,18 @@ var SelectionSourceContent = {
     var n = node;
     var p = n.parentNode;
     if (n == ancestor || !p)
       return null;
     var path = [];
     if (!path)
       return null;
     do {
-      for (var i = 0; i < p.childNodes.length; i++) {
-        if (p.childNodes.item(i) == n) {
+      for (var i = 0; i < p.children.length; i++) {
+        if (p.children.item(i) == n) {
           path.push(i);
           break;
         }
       }
       n = p;
       p = n.parentNode;
     } while (n != ancestor && p);
     return path;
@@ -105,20 +105,20 @@ var SelectionSourceContent = {
     // Only bother with the selection if it can be remapped. Don't mess with
     // leaf elements (such as <isindex>) that secretly use anynomous content
     // for their display appearance.
     var canDrawSelection = ancestorContainer.hasChildNodes();
     var tmpNode;
     if (canDrawSelection) {
       var i;
       for (i = startPath ? startPath.length - 1 : -1; i >= 0; i--) {
-        startContainer = startContainer.childNodes.item(startPath[i]);
+        startContainer = startContainer.children.item(startPath[i]);
       }
       for (i = endPath ? endPath.length - 1 : -1; i >= 0; i--) {
-        endContainer = endContainer.childNodes.item(endPath[i]);
+        endContainer = endContainer.children.item(endPath[i]);
       }
 
       // add special markers to record the extent of the selection
       // note: |startOffset| and |endOffset| are interpreted either as
       // offsets in the text data or as child indices (see the Range spec)
       // (here, munging the end point first to keep the start point safe...)
       if (endContainer.nodeType == Node.TEXT_NODE ||
           endContainer.nodeType == Node.CDATA_SECTION_NODE) {
@@ -131,45 +131,45 @@ var SelectionSourceContent = {
             !endContainer.parentNode || !endContainer.parentNode.parentNode)
           endContainer.insertData(endOffset, MARK_SELECTION_END);
         else {
           tmpNode = dataDoc.createTextNode(MARK_SELECTION_END);
           endContainer = endContainer.parentNode;
           if (endOffset === 0)
             endContainer.parentNode.insertBefore(tmpNode, endContainer);
           else
-            endContainer.parentNode.insertBefore(tmpNode, endContainer.nextSibling);
+            endContainer.parentNode.insertBefore(tmpNode, endContainer.nextElementSibling);
         }
       } else {
         tmpNode = dataDoc.createTextNode(MARK_SELECTION_END);
-        endContainer.insertBefore(tmpNode, endContainer.childNodes.item(endOffset));
+        endContainer.insertBefore(tmpNode, endContainer.children.item(endOffset));
       }
 
       if (startContainer.nodeType == Node.TEXT_NODE ||
           startContainer.nodeType == Node.CDATA_SECTION_NODE) {
         // do some extra tweaks to try to avoid the view-source output to look like
         // ...<tag>[... or ...[</tag>... (where '[' marks the start of the selection).
         // To get a neat output, the idea here is to remap the start point from:
         // 1. ...<tag>[...   to   ...[<tag>...
         // 2. ...[</tag>...  to   ...</tag>[...
         if ((startOffset > 0 && startOffset < startContainer.data.length) ||
             !startContainer.parentNode || !startContainer.parentNode.parentNode ||
-            startContainer != startContainer.parentNode.lastChild)
+            startContainer != startContainer.parentNode.lastElementChild)
           startContainer.insertData(startOffset, MARK_SELECTION_START);
         else {
           tmpNode = dataDoc.createTextNode(MARK_SELECTION_START);
           startContainer = startContainer.parentNode;
           if (startOffset === 0)
             startContainer.parentNode.insertBefore(tmpNode, startContainer);
           else
-            startContainer.parentNode.insertBefore(tmpNode, startContainer.nextSibling);
+            startContainer.parentNode.insertBefore(tmpNode, startContainer.nextElementSibling);
         }
       } else {
         tmpNode = dataDoc.createTextNode(MARK_SELECTION_START);
-        startContainer.insertBefore(tmpNode, startContainer.childNodes.item(startOffset));
+        startContainer.insertBefore(tmpNode, startContainer.children.item(startOffset));
       }
     }
 
     // now extract and display the syntax highlighted source
     tmpNode = dataDoc.createElementNS("http://www.w3.org/1999/xhtml", "div");
     tmpNode.appendChild(ancestorContainer);
 
     return { uri: (isHTML ? "view-source:data:text/html;charset=utf-8," :
diff --git a/toolkit/modules/css-selector.js b/toolkit/modules/css-selector.js
--- a/toolkit/modules/css-selector.js
+++ b/toolkit/modules/css-selector.js
@@ -281,35 +281,35 @@ function getXPath(ele) {
 
   const nodeGlobal = ele.ownerGlobal.Node;
   // Use nodeName (instead of localName) so namespace prefix is included (if any).
   while (ele && ele.nodeType === nodeGlobal.ELEMENT_NODE) {
     let nbOfPreviousSiblings = 0;
     let hasNextSiblings = false;
 
     // Count how many previous same-name siblings the element has.
-    let sibling = ele.previousSibling;
+    let sibling = ele.previousElementSibling;
     while (sibling) {
       // Ignore document type declaration.
       if (sibling.nodeType !== nodeGlobal.DOCUMENT_TYPE_NODE &&
           sibling.nodeName == ele.nodeName) {
         nbOfPreviousSiblings++;
       }
 
-      sibling = sibling.previousSibling;
+      sibling = sibling.previousElementSibling;
     }
 
     // Check if the element has at least 1 next same-name sibling.
-    sibling = ele.nextSibling;
+    sibling = ele.nextElementSibling;
     while (sibling) {
       if (sibling.nodeName == ele.nodeName) {
         hasNextSiblings = true;
         break;
       }
-      sibling = sibling.nextSibling;
+      sibling = sibling.nextElementSibling;
     }
 
     const prefix = ele.prefix ? ele.prefix + ":" : "";
     const nth = nbOfPreviousSiblings || hasNextSiblings
                 ? `[${nbOfPreviousSiblings + 1}]` : "";
 
     parts.push(prefix + ele.localName + nth);
 
diff --git a/toolkit/mozapps/downloads/nsHelperAppDlg.js b/toolkit/mozapps/downloads/nsHelperAppDlg.js
--- a/toolkit/mozapps/downloads/nsHelperAppDlg.js
+++ b/toolkit/mozapps/downloads/nsHelperAppDlg.js
@@ -724,17 +724,17 @@ nsUnknownContentTypeDialog.prototype = {
       defaultOpenHandler.hidden = true;
       // If that's the default, then switch to "save to disk."
       if (isSelected) {
         openHandler.selectedIndex = 1;
         modeGroup.selectedItem = this.dialogElement("save");
       }
     }
 
-    otherHandler.nextSibling.hidden = otherHandler.nextSibling.nextSibling.hidden = false;
+    otherHandler.nextElementSibling.hidden = otherHandler.nextElementSibling.nextElementSibling.hidden = false;
     this.updateOKButton();
   },
 
   // Returns the user-selected application
   helperAppChoice() {
     return this.chosenApp;
   },
 
diff --git a/toolkit/mozapps/extensions/content/blocklist.js b/toolkit/mozapps/extensions/content/blocklist.js
--- a/toolkit/mozapps/extensions/content/blocklist.js
+++ b/toolkit/mozapps/extensions/content/blocklist.js
@@ -58,15 +58,15 @@ function init() {
     var url = Services.urlFormatter.formatURLPref("extensions.blocklist.detailsURL");
     link.setAttribute("href", url);
   }
 }
 
 function finish(shouldRestartNow) {
   gArgs.restart = shouldRestartNow;
   var list = gArgs.list;
-  var items = document.getElementById("addonList").childNodes;
+  var items = document.getElementById("addonList").children;
   for (let i = 0; i < list.length; i++) {
     if (!list[i].blocked)
       list[i].disable = items[i].checked;
   }
   return true;
 }
diff --git a/toolkit/mozapps/extensions/content/extensions.js b/toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js
+++ b/toolkit/mozapps/extensions/content/extensions.js
@@ -1606,21 +1606,21 @@ function sortElements(aElements, aSortBy
     // If we got here, then all values of a and b
     // must have been equal.
     return 0;
 
   });
 }
 
 function sortList(aList, aSortBy, aAscending) {
-  var elements = Array.slice(aList.childNodes, 0);
+  var elements = Array.slice(aList.children, 0);
   sortElements(elements, [aSortBy], aAscending);
 
   while (aList.listChild)
-    aList.removeChild(aList.lastChild);
+    aList.removeChild(aList.lastElementChild);
 
   for (let element of elements)
     aList.appendChild(element);
 }
 
 async function getAddonsAndInstalls(aType, aCallback) {
   let addons = null, installs = null;
   let types = (aType != null) ? [aType] : null;
@@ -1639,21 +1639,21 @@ async function getAddonsAndInstalls(aTyp
   if (addons != null)
     aCallback(addons, installs);
 }
 
 function doPendingUninstalls(aListBox) {
   // Uninstalling add-ons can mutate the list so find the add-ons first then
   // uninstall them
   var items = [];
-  var listitem = aListBox.firstChild;
+  var listitem = aListBox.firstElementChild;
   while (listitem) {
     if (listitem.getAttribute("pending") == "uninstall")
       items.push(listitem.mAddon);
-    listitem = listitem.nextSibling;
+    listitem = listitem.nextElementSibling;
   }
 
   for (let addon of items)
     addon.uninstall();
 }
 
 var gCategories = {
   node: null,
@@ -2273,21 +2273,21 @@ var gLegacyView = {
       this._categoryItem.setAttribute("name", name);
       this._categoryItem.tooltiptext = name;
     } else {
       this._categoryItem.disabled = true;
     }
   },
 
   getListItemForID(aId) {
-    var listitem = this._listBox.firstChild;
+    var listitem = this._listBox.firstElementChild;
     while (listitem) {
       if (listitem.getAttribute("status") == "installed" && listitem.mAddon.id == aId)
         return listitem;
-      listitem = listitem.nextSibling;
+      listitem = listitem.nextElementSibling;
     }
     return null;
   }
 };
 
 var gListView = {
   node: null,
   _listBox: null,
@@ -2390,24 +2390,24 @@ var gListView = {
         for (let element of elements)
           this._listBox.appendChild(element);
       }
 
       this.filterDisabledUnsigned(showOnlyDisabledUnsigned);
       let legacyNotice = document.getElementById("legacy-extensions-notice");
       if (showLegacyInfo) {
         let el = document.getElementById("legacy-extensions-description");
-        if (el.childNodes[0].nodeName == "#text") {
-          el.removeChild(el.childNodes[0]);
+        if (el.children[0].nodeName == "#text") {
+          el.removeChild(el.children[0]);
         }
 
         let descriptionId = (aType == "theme") ?
                             "legacyThemeWarning.description" : "legacyWarning.description";
         let text = gStrings.ext.formatStringFromName(descriptionId, [gStrings.brandShortName], 1) + " ";
-        el.insertBefore(document.createTextNode(text), el.childNodes[0]);
+        el.insertBefore(document.createTextNode(text), el.children[0]);
         legacyNotice.hidden = false;
       } else {
         legacyNotice.hidden = true;
       }
 
       gEventManager.registerInstallListener(this);
       gViewController.updateCommands();
       gViewController.notifyViewChanged();
@@ -2417,17 +2417,17 @@ var gListView = {
   hide() {
     gEventManager.unregisterInstallListener(this);
     doPendingUninstalls(this._listBox);
   },
 
   filterDisabledUnsigned(aFilter = true) {
     let foundDisabledUnsigned = false;
 
-    for (let item of this._listBox.childNodes) {
+    for (let item of this._listBox.children) {
       if (isDisabledUnsigned(item.mAddon)) {
         foundDisabledUnsigned = true;
       } else {
         item.hidden = aFilter;
       }
     }
 
     document.getElementById("show-disabled-unsigned-extensions").hidden =
@@ -2483,51 +2483,51 @@ var gListView = {
   addItem(aObj, aIsInstall) {
     if (aObj.type != this._type)
       return;
 
     if (aIsInstall && aObj.existingAddon)
       return;
 
     let prop = aIsInstall ? "mInstall" : "mAddon";
-    for (let item of this._listBox.childNodes) {
+    for (let item of this._listBox.children) {
       if (item[prop] == aObj)
         return;
     }
 
     let item = createItem(aObj, aIsInstall);
-    this._listBox.insertBefore(item, this._listBox.firstChild);
+    this._listBox.insertBefore(item, this._listBox.firstElementChild);
     this.showEmptyNotice(false);
   },
 
   removeItem(aObj, aIsInstall) {
     let prop = aIsInstall ? "mInstall" : "mAddon";
 
-    for (let item of this._listBox.childNodes) {
+    for (let item of this._listBox.children) {
       if (item[prop] == aObj) {
         this._listBox.removeChild(item);
         this.showEmptyNotice(this._listBox.itemCount == 0);
         return;
       }
     }
   },
 
   getSelectedAddon() {
     var item = this._listBox.selectedItem;
     if (item)
       return item.mAddon;
     return null;
   },
 
   getListItemForID(aId) {
-    var listitem = this._listBox.firstChild;
+    var listitem = this._listBox.firstElementChild;
     while (listitem) {
       if (listitem.getAttribute("status") == "installed" && listitem.mAddon.id == aId)
         return listitem;
-      listitem = listitem.nextSibling;
+      listitem = listitem.nextElementSibling;
     }
     return null;
   }
 };
 
 
 var gDetailView = {
   node: null,
@@ -2915,18 +2915,18 @@ var gDetailView = {
     }
 
     this.node.removeAttribute("loading-extended");
   },
 
   emptySettingsRows() {
     var lastRow = document.getElementById("detail-rating-row");
     var rows = lastRow.parentNode;
-    while (lastRow.nextSibling)
-      rows.removeChild(rows.lastChild);
+    while (lastRow.nextElementSibling)
+      rows.removeChild(rows.lastElementChild);
   },
 
   fillSettingsRows(aScrollToPreferences, aCallback) {
     this.emptySettingsRows();
     if (!hasInlineOptions(this._addon)) {
       if (aCallback)
         aCallback();
       return;
@@ -3265,18 +3265,18 @@ var gUpdatesView = {
     if (!aIsRefresh && gViewController && aRequest &&
         aRequest != gViewController.currentViewRequest)
       return;
 
     if (aIsRefresh) {
       this.showEmptyNotice(false);
       this._updateSelected.hidden = true;
 
-      while (this._listBox.childNodes.length > 0)
-        this._listBox.firstChild.remove();
+      while (this._listBox.children.length > 0)
+        this._listBox.firstElementChild.remove();
     }
 
     var elements = [];
 
     for (let install of aInstallsList) {
       if (!this.isManualUpdate(install))
         continue;
 
@@ -3331,47 +3331,47 @@ var gUpdatesView = {
     this._categoryItem.disabled = gViewController.currentViewId != "addons://updates/available" &&
                                   count == 0;
     this._categoryItem.badgeCount = count;
     if (aInitializing)
       notifyInitialized();
   },
 
   maybeDisableUpdateSelected() {
-    for (let item of this._listBox.childNodes) {
+    for (let item of this._listBox.children) {
       if (item.includeUpdate) {
         this._updateSelected.disabled = false;
         return;
       }
     }
     this._updateSelected.disabled = true;
   },
 
   installSelected() {
-    for (let item of this._listBox.childNodes) {
+    for (let item of this._listBox.children) {
       if (item.includeUpdate)
         item.upgrade();
     }
 
     this._updateSelected.disabled = true;
   },
 
   getSelectedAddon() {
     var item = this._listBox.selectedItem;
     if (item)
       return item.mAddon;
     return null;
   },
 
   getListItemForID(aId) {
-    var listitem = this._listBox.firstChild;
+    var listitem = this._listBox.firstElementChild;
     while (listitem) {
       if (listitem.mAddon.id == aId)
         return listitem;
-      listitem = listitem.nextSibling;
+      listitem = listitem.nextElementSibling;
     }
     return null;
   },
 
   onSortChanged(aSortBy, aAscending) {
     sortList(this._listBox, aSortBy, aAscending);
   },
 
diff --git a/toolkit/mozapps/extensions/content/xpinstallConfirm.js b/toolkit/mozapps/extensions/content/xpinstallConfirm.js
--- a/toolkit/mozapps/extensions/content/xpinstallConfirm.js
+++ b/toolkit/mozapps/extensions/content/xpinstallConfirm.js
@@ -65,17 +65,17 @@ XPInstallConfirm.init = function() {
   }
 
   var introString = bundle.getString("itemWarnIntroSingle");
   if (numItemsToInstall > 4)
     introString = bundle.getFormattedString("itemWarnIntroMultiple", [numItemsToInstall]);
   var textNode = document.createTextNode(introString);
   var introNode = document.getElementById("itemWarningIntro");
   while (introNode.hasChildNodes())
-    introNode.firstChild.remove();
+    introNode.firstElementChild.remove();
   introNode.appendChild(textNode);
 
   var okButton = document.documentElement.getButton("accept");
   okButton.focus();
 
   function okButtonCountdown() {
     _installCountdown -= 1;
 
diff --git a/toolkit/mozapps/extensions/internal/RDFDataSource.jsm b/toolkit/mozapps/extensions/internal/RDFDataSource.jsm
--- a/toolkit/mozapps/extensions/internal/RDFDataSource.jsm
+++ b/toolkit/mozapps/extensions/internal/RDFDataSource.jsm
@@ -168,18 +168,18 @@ function RDF_R(name) {
 }
 
 function renameNode(domnode, namespaceURI, qname) {
   if (isElement(domnode)) {
     var newdomnode = domnode.ownerDocument.createElementNS(namespaceURI, qname);
     if ("listCounter" in domnode)
       newdomnode.listCounter = domnode.listCounter;
     domnode.replaceWith(newdomnode);
-    while (domnode.firstChild)
-      newdomnode.appendChild(domnode.firstChild);
+    while (domnode.firstElementChild)
+      newdomnode.appendChild(domnode.firstElementChild);
     for (let attr of domnode.attributes) {
       domnode.removeAttributeNode(attr);
       newdomnode.setAttributeNode(attr);
     }
     return newdomnode;
   } else if (isAttr(domnode)) {
     if (domnode.ownerElement.hasAttribute(namespaceURI, qname))
       throw new Error("attribute already exists");
@@ -377,17 +377,17 @@ class RDFSubject extends RDFNode {
     // Seek an appropriate reference to this node to add this node under
     var parent = null;
     for (var p in this._backwards) {
       for (let back of this._backwards[p]) {
         // Don't add under an rdf:type
         if (back.getPredicate() == RDF_R("type"))
           continue;
         // The assertion already has a child node, probably one of ours
-        if (back._DOMnode.firstChild)
+        if (back._DOMnode.firstElementChild)
           continue;
         parent = back._DOMnode;
         var element = this._ds._addElement(parent, uri);
         this._removeReferenceFromElement(parent);
         break;
       }
       if (parent)
         break;
@@ -513,17 +513,17 @@ class RDFSubject extends RDFNode {
       var domnode = renameNode(assertion._DOMnode, NS_RDF, "Description");
       if (domnode != assertion._DOMnode) {
         var pos = this._elements.indexOf(assertion._DOMnode);
         this._elements.splice(pos, 1, domnode);
       }
       parent = domnode;
     } else {
       var object = assertion.getObject();
-      if (object instanceof RDFSubject && assertion._DOMnode.firstChild) {
+      if (object instanceof RDFSubject && assertion._DOMnode.firstElementChild) {
         // Object is a subject that has an Element inside this assertion's node.
         for (let element of object._elements) {
           if (element.parentNode == assertion._DOMnode) {
             object._removeElement(element);
             break;
           }
         }
       }
@@ -590,17 +590,17 @@ class RDFSubject extends RDFNode {
       }
       if (!object)
         object = new RDFLiteral(attr.nodeValue);
       assertion = new RDFAssertion(this, attr.namespaceURI + attr.localName, object);
       assertion._DOMnode = attr;
       this._addAssertion(assertion);
     }
 
-    var child = element.firstChild;
+    var child = element.firstElementChild;
     element.listCounter = 1;
     while (child) {
       if (isText(child) && /\S/.test(child.nodeValue)) {
         ERROR(`Text ${child.nodeValue} is not allowed in a subject node`);
         throw new Error("subject nodes cannot contain text content");
       } else if (isElement(child)) {
         object = null;
         var predicate = child.namespaceURI + child.localName;
@@ -652,27 +652,27 @@ class RDFSubject extends RDFNode {
           object = this._ds.getResource(base.resolve(resource));
         } else if (nodeID !== undefined) {
           if (!nodeID.match(XML_NCNAME))
             throw new Error("rdf:nodeID must be a valid XML name");
           object = this._ds.getBlankNode(nodeID);
         } else {
           var hasText = false;
           var childElement = null;
-          var subchild = child.firstChild;
+          var subchild = child.firstElementChild;
           while (subchild) {
             if (isText(subchild) && /\S/.test(subchild.nodeValue)) {
               hasText = true;
             } else if (isElement(subchild)) {
               if (childElement) {
                 new Error(`Multiple object elements found in ${child.nodeName}`);
               }
               childElement = subchild;
             }
-            subchild = subchild.nextSibling;
+            subchild = subchild.nextElementSibling;
           }
 
           if ((resource || nodeID) && (hasText || childElement)) {
             ERROR("Assertion references a resource so should not contain additional contents");
             throw new Error("assertion cannot contain multiple objects");
           }
 
           if (hasText && childElement) {
@@ -694,17 +694,17 @@ class RDFSubject extends RDFNode {
           else
             object = new RDFLiteral(child.textContent);
         }
 
         assertion = new RDFAssertion(this, predicate, object);
         this._addAssertion(assertion);
         assertion._DOMnode = child;
       }
-      child = child.nextSibling;
+      child = child.nextElementSibling;
     }
   }
 
   /**
    * Adds a new assertion to the internal hashes. Should be called for every
    * new assertion parsed or created programmatically.
    */
   _addAssertion(assertion) {
@@ -1223,26 +1223,26 @@ class RDFDataSource {
     }
 
     if (this._document.documentElement.namespaceURI != NS_RDF ||
         this._document.documentElement.localName != "RDF") {
       ERROR(`${this._document.documentElement.nodeName} is not rdf:RDF`);
       throw new Error("document does not appear to be RDF");
     }
 
-    var domnode = this._document.documentElement.firstChild;
+    var domnode = this._document.documentElement.firstElementChild;
     while (domnode) {
       if (isText(domnode) && /\S/.test(domnode.nodeValue)) {
         ERROR("RDF does not allow for text in the root of the document");
         throw new Error("invalid markup in document");
       } else if (isElement(domnode)) {
         var subject = this._getSubjectForElement(domnode);
         subject._parseElement(domnode);
       }
-      domnode = domnode.nextSibling;
+      domnode = domnode.nextElementSibling;
     }
   }
 
   /**
    * Works out a sensible namespace prefix to use for the given uri. node should
    * be the parent of where the element is to be inserted, or the node that an
    * attribute is to be added to. This will recursively walk to the top of the
    * document finding an already registered prefix that matches for the uri.
@@ -1338,66 +1338,66 @@ class RDFDataSource {
   _guessIndent(element) {
     // The indent at document level is 0
     if (!element || isDocument(element))
       return "";
 
     // Check the text immediately preceeding each child node. One could be
     // a valid indent
     var pretext = "";
-    var child = element.firstChild;
+    var child = element.firstElementChild;
     while (child) {
       if (isText(child)) {
         pretext += child.nodeValue;
       } else if (isElement(child)) {
         var result = INDENT.exec(pretext);
         if (result)
           return result[1];
         pretext = "";
       }
-      child = child.nextSibling;
+      child = child.nextElementSibling;
     }
 
     // pretext now contains any trailing text in the element. This can be
     // the indent of the end tag. If so add a little to it.
     result = INDENT.exec(pretext);
     if (result)
       return `${result[1]}  `;
 
     // Check the text immediately before this node
     pretext = "";
-    var sibling = element.previousSibling;
+    var sibling = element.previousElementSibling;
     while (sibling && isText(sibling)) {
       pretext += sibling.nodeValue;
-      sibling = sibling.previousSibling;
+      sibling = sibling.previousElementSibling;
     }
 
     // If there is a sensible indent then just add to it.
     result = INDENT.exec(pretext);
     if (result)
       return `${result[1]}  `;
 
     // Last chance, get the indent level for the tag above and add to it
     return `${this._guessIndent(element.parentNode)}  `;
   }
 
   _addElement(parent, uri) {
     var prefix = this._resolvePrefix(parent, uri);
     var element = this._document.createElementNS(prefix.namespaceURI, prefix.qname);
 
-    if (parent.lastChild) {
+    if (parent.lastElementChild) {
       // We want to insert immediately after the last child element
-      var last = parent.lastChild;
+      var last = parent.lastElementChild;
       while (last && isText(last))
-        last = last.previousSibling;
+        last = last.previousElementSibling;
       // No child elements so insert at the start
       if (!last)
-        last = parent.firstChild;
+        last = parent.firstElementChild;
       else
-        last = last.nextSibling;
+        last = last.nextElementSibling;
 
       let indent = this._guessIndent(parent);
       parent.insertBefore(this._document.createTextNode(`\n${indent}`), last);
       parent.insertBefore(element, last);
     } else {
       // No children, must indent our element and the end tag
       let indent = this._guessIndent(parent.parentNode);
       parent.append(`\n${indent}  `, element, `\n${indent}`);
@@ -1406,38 +1406,38 @@ class RDFDataSource {
   }
 
   /**
    * Removes the element from its parent. Should also remove surrounding
    * white space as appropriate.
    */
   _removeElement(element) {
     var parent = element.parentNode;
-    var sibling = element.previousSibling;
+    var sibling = element.previousElementSibling;
     // Drop any text nodes immediately preceeding the element
     while (sibling && isText(sibling)) {
       var temp = sibling;
-      sibling = sibling.previousSibling;
+      sibling = sibling.previousElementSibling;
       parent.removeChild(temp);
     }
 
-    sibling = element.nextSibling;
+    sibling = element.nextElementSibling;
     // Drop the element
     parent.removeChild(element);
 
     // If the next node after element is now the first child then element was
     // the first child. If there are no other child elements then remove the
     // remaining child nodes.
-    if (parent.firstChild == sibling) {
+    if (parent.firstElementChild == sibling) {
       while (sibling && isText(sibling))
-        sibling = sibling.nextSibling;
+        sibling = sibling.nextElementSibling;
       if (!sibling) {
         // No other child elements
-        while (parent.lastChild)
-          parent.removeChild(parent.lastChild);
+        while (parent.lastElementChild)
+          parent.removeChild(parent.lastElementChild);
       }
     }
   }
 
   /**
    * Requests that a given prefix be used for the namespace where possible.
    * This must be called before any assertions are made using the namespace
    * and the registration will not override any existing prefix used in the
diff --git a/toolkit/mozapps/extensions/test/browser/browser_bug562890.js b/toolkit/mozapps/extensions/test/browser/browser_bug562890.js
--- a/toolkit/mozapps/extensions/test/browser/browser_bug562890.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_bug562890.js
@@ -23,27 +23,27 @@ async function test() {
     id: "test2@tests.mozilla.org",
     name: "Test add-on 2",
     description: "bar",
     optionsURL: addonPrefsURI
   }]);
 
   let aManager = await open_manager("addons://list/extension");
   var addonList = aManager.document.getElementById("addon-list");
-  for (var addonItem of addonList.childNodes) {
+  for (var addonItem of addonList.children) {
     if (addonItem.hasAttribute("name") &&
         addonItem.getAttribute("name") == "Test add-on 1")
       break;
   }
   var prefsBtn = aManager.document.getAnonymousElementByAttribute(addonItem,
                                                                  "anonid",
                                                                  "preferences-btn");
   is(prefsBtn.hidden, true, "Prefs button should be hidden for addon with no optionsURL set");
 
-  for (addonItem of addonList.childNodes) {
+  for (addonItem of addonList.children) {
     if (addonItem.hasAttribute("name") &&
         addonItem.getAttribute("name") == "Test add-on 2")
       break;
   }
   prefsBtn = aManager.document.getAnonymousElementByAttribute(addonItem,
                                                               "anonid",
                                                               "preferences-btn");
   is(prefsBtn.hidden, true, "Prefs button should not be shown for addon with just an optionsURL set");
diff --git a/toolkit/mozapps/extensions/test/browser/browser_bug562899.js b/toolkit/mozapps/extensions/test/browser/browser_bug562899.js
--- a/toolkit/mozapps/extensions/test/browser/browser_bug562899.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_bug562899.js
@@ -39,42 +39,42 @@ async function end_test() {
 add_test(async function() {
   var themeCount = null;
   var pluginCount = null;
   var themeItem = gCategoryUtilities.get("theme");
   var pluginItem = gCategoryUtilities.get("plugin");
   var list = gManagerWindow.document.getElementById("addon-list");
 
   await gCategoryUtilities.open(themeItem);
-  themeCount = list.childNodes.length;
+  themeCount = list.children.length;
   ok(themeCount > 0, "Test is useless if there are no themes");
 
   await gCategoryUtilities.open(pluginItem);
-  pluginCount = list.childNodes.length;
+  pluginCount = list.children.length;
   ok(pluginCount > 0, "Test is useless if there are no plugins");
 
   gCategoryUtilities.open(themeItem);
 
   await gCategoryUtilities.open(pluginItem);
-  is(list.childNodes.length, pluginCount, "Should only see the plugins");
+  is(list.children.length, pluginCount, "Should only see the plugins");
 
-  var item = list.firstChild;
+  var item = list.firstElementChild;
   while (item) {
     is(item.getAttribute("type"), "plugin", "All items should be plugins");
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
 
   // Tests that switching to, from, to the same pane in quick succession
   // still only shows the right number of results
 
   gCategoryUtilities.open(themeItem);
   gCategoryUtilities.open(pluginItem);
   await gCategoryUtilities.open(themeItem);
-  is(list.childNodes.length, themeCount, "Should only see the theme");
+  is(list.children.length, themeCount, "Should only see the theme");
 
-  item = list.firstChild;
+  item = list.firstElementChild;
   while (item) {
     is(item.getAttribute("type"), "theme", "All items should be theme");
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
 
   run_next_test();
 });
diff --git a/toolkit/mozapps/extensions/test/browser/browser_bug567127.js b/toolkit/mozapps/extensions/test/browser/browser_bug567127.js
--- a/toolkit/mozapps/extensions/test/browser/browser_bug567127.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_bug567127.js
@@ -23,17 +23,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 async function checkInstallConfirmation(...names) {
   let notificationCount = 0;
diff --git a/toolkit/mozapps/extensions/test/browser/browser_bug587970.js b/toolkit/mozapps/extensions/test/browser/browser_bug587970.js
--- a/toolkit/mozapps/extensions/test/browser/browser_bug587970.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_bug587970.js
@@ -39,17 +39,17 @@ async function test() {
 
 function end_test() {
   close_manager(gManagerWindow, finish);
 }
 
 
 add_test(function() {
   var list = gManagerWindow.document.getElementById("updates-list");
-  is(list.childNodes.length, 0, "Available updates list should be empty");
+  is(list.children.length, 0, "Available updates list should be empty");
 
   var emptyNotice = gManagerWindow.document.getElementById("empty-availableUpdates-msg");
   is_element_visible(emptyNotice, "Empty notice should be visible");
 
   var updateSelected = gManagerWindow.document.getElementById("update-selected-btn");
   is_element_hidden(updateSelected, "Update Selected button should be hidden");
 
   info("Adding updates");
@@ -63,34 +63,34 @@ add_test(function() {
     existingAddon: gProvider.addons[1]
   }, {
     name: "addon 3",
     version: "3.1",
     existingAddon: gProvider.addons[2]
   }]);
 
   function wait_for_refresh() {
-    if (list.childNodes.length == 3 &&
-        list.childNodes[0].mManualUpdate &&
-        list.childNodes[1].mManualUpdate &&
-        list.childNodes[2].mManualUpdate) {
+    if (list.children.length == 3 &&
+        list.children[0].mManualUpdate &&
+        list.children[1].mManualUpdate &&
+        list.children[2].mManualUpdate) {
       run_next_test();
     } else {
       info("Waiting for pane to refresh");
       setTimeout(wait_for_refresh, 10);
     }
   }
   info("Waiting for pane to refresh");
   setTimeout(wait_for_refresh, 10);
 });
 
 
 add_test(function() {
   var list = gManagerWindow.document.getElementById("updates-list");
-  is(list.childNodes.length, 3, "Available updates list should have 2 items");
+  is(list.children.length, 3, "Available updates list should have 2 items");
 
   var item1 = get_addon_element(gManagerWindow, "addon1@tests.mozilla.org");
   isnot(item1, null, "Item for addon1@tests.mozilla.org should be in list");
   var item2 = get_addon_element(gManagerWindow, "addon2@tests.mozilla.org");
   isnot(item2, null, "Item for addon2@tests.mozilla.org should be in list");
   var item3 = get_addon_element(gManagerWindow, "addon3@tests.mozilla.org");
   isnot(item3, null, "Item for addon3@tests.mozilla.org should be in list");
 
diff --git a/toolkit/mozapps/extensions/test/browser/browser_bug590347.js b/toolkit/mozapps/extensions/test/browser/browser_bug590347.js
--- a/toolkit/mozapps/extensions/test/browser/browser_bug590347.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_bug590347.js
@@ -14,39 +14,39 @@ var gApp = document.getElementById("bund
 var gVersion = Services.appinfo.version;
 
 // Opens the details view of an add-on
 async function open_details(aId, aType, aCallback) {
   requestLongerTimeout(2);
 
   await gCategoryUtilities.openType(aType);
   var list = gManagerWindow.document.getElementById("addon-list");
-  var item = list.firstChild;
+  var item = list.firstElementChild;
   while (item) {
     if ("mAddon" in item && item.mAddon.id == aId) {
       list.ensureElementIsVisible(item);
       EventUtils.synthesizeMouseAtCenter(item, { clickCount: 1 }, gManagerWindow);
       EventUtils.synthesizeMouseAtCenter(item, { clickCount: 2 }, gManagerWindow);
       wait_for_view_load(gManagerWindow, aCallback);
       return;
     }
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
   ok(false, "Should have found the add-on in the list");
 }
 
 function get_list_view_warning_node() {
-  let item = gManagerWindow.document.getElementById("addon-list").firstChild;
+  let item = gManagerWindow.document.getElementById("addon-list").firstElementChild;
   let found = false;
   while (item) {
     if (item.mAddon.name == "Test add-on") {
       found = true;
       break;
     }
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
   ok(found, "Test add-on node should have been found.");
   return item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "warning");
 }
 
 function get_detail_view_warning_node(aManagerWindow) {
   if (aManagerWindow)
     return aManagerWindow.document.getElementById("detail-warning");
diff --git a/toolkit/mozapps/extensions/test/browser/browser_bug591663.js b/toolkit/mozapps/extensions/test/browser/browser_bug591663.js
--- a/toolkit/mozapps/extensions/test/browser/browser_bug591663.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_bug591663.js
@@ -58,19 +58,19 @@ function end_test() {
 function check_list(aItem) {
   // Check state of the empty notice
   let emptyNotice = gManagerWindow.document.getElementById(EMPTY_ID);
   ok(emptyNotice != null, "Should have found the empty notice");
   is(!emptyNotice.hidden, (aItem == null), "Empty notice should be showing if list empty");
 
   // Check the children of the list
   let list = gManagerWindow.document.getElementById(LIST_ID);
-  is(list.childNodes.length, aItem ? 1 : 0, "Should get expected number of items in list");
+  is(list.children.length, aItem ? 1 : 0, "Should get expected number of items in list");
   if (aItem != null) {
-    let itemName = list.firstChild.getAttribute("name");
+    let itemName = list.firstElementChild.getAttribute("name");
     is(itemName, aItem.name, "List item should have correct name");
   }
 }
 
 
 // Test that the empty notice is showing and no items are showing in list
 add_test(function() {
   check_list(null);
diff --git a/toolkit/mozapps/extensions/test/browser/browser_details.js b/toolkit/mozapps/extensions/test/browser/browser_details.js
--- a/toolkit/mozapps/extensions/test/browser/browser_details.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_details.js
@@ -17,26 +17,26 @@ var gVersion = Services.appinfo.version;
 var gDate = new Date(2010, 7, 1);
 var infoURL = Services.urlFormatter.formatURLPref("app.support.baseURL") + "unsigned-addons";
 
 async function open_details(aId, aType, aCallback) {
   requestLongerTimeout(2);
 
   await gCategoryUtilities.openType(aType);
   var list = gManagerWindow.document.getElementById("addon-list");
-  var item = list.firstChild;
+  var item = list.firstElementChild;
   while (item) {
     if ("mAddon" in item && item.mAddon.id == aId) {
       list.ensureElementIsVisible(item);
       EventUtils.synthesizeMouseAtCenter(item, { clickCount: 1 }, gManagerWindow);
       EventUtils.synthesizeMouseAtCenter(item, { clickCount: 2 }, gManagerWindow);
       wait_for_view_load(gManagerWindow, aCallback);
       return;
     }
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
   ok(false, "Should have found the add-on in the list");
 }
 
 function get(aId) {
   return gManagerWindow.document.getElementById(aId);
 }
 
@@ -234,40 +234,40 @@ add_test(function() {
 
     is_element_visible(get("detail-rating-row"), "Rating row should not be hidden");
     is_element_hidden(get("detail-rating"), "Rating should be hidden");
     is_element_visible(get("detail-reviews"), "Reviews should not be hidden");
     is(get("detail-reviews").href, "http://example.com/reviews", "Review URL should be correct");
     is(get("detail-reviews").value, "1 review", "Review text should be correct");
 
     is_element_visible(get("detail-autoUpdate"), "Updates should not be hidden");
-    ok(get("detail-autoUpdate").lastChild.selected, "Updates should be manual");
+    ok(get("detail-autoUpdate").lastElementChild.selected, "Updates should be manual");
     is_element_visible(get("detail-findUpdates-btn"), "Check for updates should be visible");
-    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").childNodes[1], {}, gManagerWindow);
-    ok(get("detail-autoUpdate").childNodes[1].selected, "Updates should be automatic");
+    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").children[1], {}, gManagerWindow);
+    ok(get("detail-autoUpdate").children[1].selected, "Updates should be automatic");
     is_element_hidden(get("detail-findUpdates-btn"), "Check for updates should be hidden");
-    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").lastChild, {}, gManagerWindow);
-    ok(get("detail-autoUpdate").lastChild.selected, "Updates should be manual");
+    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").lastElementChild, {}, gManagerWindow);
+    ok(get("detail-autoUpdate").lastElementChild.selected, "Updates should be manual");
     is_element_visible(get("detail-findUpdates-btn"), "Check for updates should be visible");
 
     info("Setting " + PREF_AUTOUPDATE_DEFAULT + " to true");
     Services.prefs.setBoolPref(PREF_AUTOUPDATE_DEFAULT, true);
-    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").firstChild, {}, gManagerWindow);
-    ok(get("detail-autoUpdate").firstChild.selected, "Updates should be default");
+    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").firstElementChild, {}, gManagerWindow);
+    ok(get("detail-autoUpdate").firstElementChild.selected, "Updates should be default");
     is_element_hidden(get("detail-findUpdates-btn"), "Check for updates should be hidden");
 
     info("Setting " + PREF_AUTOUPDATE_DEFAULT + " to false");
     Services.prefs.setBoolPref(PREF_AUTOUPDATE_DEFAULT, false);
-    ok(get("detail-autoUpdate").firstChild.selected, "Updates should be default");
+    ok(get("detail-autoUpdate").firstElementChild.selected, "Updates should be default");
     is_element_visible(get("detail-findUpdates-btn"), "Check for updates should be visible");
-    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").childNodes[1], {}, gManagerWindow);
-    ok(get("detail-autoUpdate").childNodes[1].selected, "Updates should be automatic");
+    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").children[1], {}, gManagerWindow);
+    ok(get("detail-autoUpdate").children[1].selected, "Updates should be automatic");
     is_element_hidden(get("detail-findUpdates-btn"), "Check for updates should be hidden");
-    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").firstChild, {}, gManagerWindow);
-    ok(get("detail-autoUpdate").firstChild.selected, "Updates should be default");
+    EventUtils.synthesizeMouseAtCenter(get("detail-autoUpdate").firstElementChild, {}, gManagerWindow);
+    ok(get("detail-autoUpdate").firstElementChild.selected, "Updates should be default");
     is_element_visible(get("detail-findUpdates-btn"), "Check for updates should be visible");
     Services.prefs.clearUserPref(PREF_AUTOUPDATE_DEFAULT);
 
     is_element_hidden(get("detail-prefs-btn"), "Preferences button should be hidden");
     is_element_hidden(get("detail-enable-btn"), "Enable button should be hidden");
     is_element_hidden(get("detail-disable-btn"), "Disable button should be hidden");
     is_element_hidden(get("detail-uninstall-btn"), "Remove button should be hidden");
 
diff --git a/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js b/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js
--- a/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_dragdrop.js
@@ -28,17 +28,17 @@ function promisePopupNotificationShown(n
     function popupshown() {
       let notification = PopupNotifications.getNotification(name);
       if (!notification) { return; }
 
       ok(notification, `${name} notification shown`);
       ok(PopupNotifications.isPanelOpen, "notification panel open");
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-      resolve(PopupNotifications.panel.firstChild);
+      resolve(PopupNotifications.panel.firstElementChild);
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 async function checkInstallConfirmation(...names) {
   let notificationCount = 0;
diff --git a/toolkit/mozapps/extensions/test/browser/browser_file_xpi_no_process_switch.js b/toolkit/mozapps/extensions/test/browser/browser_file_xpi_no_process_switch.js
--- a/toolkit/mozapps/extensions/test/browser/browser_file_xpi_no_process_switch.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_file_xpi_no_process_switch.js
@@ -16,17 +16,17 @@ function promiseInstallNotification(aBro
       let notification =
         PopupNotifications.getNotification(ADDON_INSTALL_ID, aBrowser);
       if (!notification) {
         return;
       }
 
       PopupNotifications.panel.removeEventListener("popupshown", popupshown);
       ok(true, `Got ${ADDON_INSTALL_ID} popup for browser`);
-      event.target.firstChild.secondaryButton.click();
+      event.target.firstElementChild.secondaryButton.click();
       resolve();
     }
 
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
 
 function waitForAnyNewTabAndInstallNotification() {
diff --git a/toolkit/mozapps/extensions/test/browser/browser_legacy_pre57.js b/toolkit/mozapps/extensions/test/browser/browser_legacy_pre57.js
--- a/toolkit/mozapps/extensions/test/browser/browser_legacy_pre57.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_legacy_pre57.js
@@ -41,17 +41,17 @@ add_task(async function() {
   let mgrWin = await open_manager(null);
   let catUtils = new CategoryUtilities(mgrWin);
 
   async function check(category, name, isLegacy) {
     await catUtils.openType(category);
 
     let document = mgrWin.document;
     // First find the  entry in the list.
-    let item = Array.from(document.getElementById("addon-list").childNodes)
+    let item = Array.from(document.getElementById("addon-list").children)
                     .find(i => i.getAttribute("name") == name);
 
     ok(item, `Found ${name} in list`);
     item.parentNode.ensureElementIsVisible(item);
 
     // Check the badge
     let badge = document.getAnonymousElementByAttribute(item, "anonid", "legacy");
 
diff --git a/toolkit/mozapps/extensions/test/browser/browser_list.js b/toolkit/mozapps/extensions/test/browser/browser_list.js
--- a/toolkit/mozapps/extensions/test/browser/browser_list.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_list.js
@@ -111,23 +111,23 @@ add_task(async function() {
   gManagerWindow = await open_manager(null);
   gCategoryUtilities = new CategoryUtilities(gManagerWindow);
 });
 
 function get_test_items() {
   var tests = "@tests.mozilla.org";
 
   var items = {};
-  var item = gManagerWindow.document.getElementById("addon-list").firstChild;
+  var item = gManagerWindow.document.getElementById("addon-list").firstElementChild;
 
   while (item) {
     if (item.mAddon.id.substring(item.mAddon.id.length - tests.length) == tests &&
         !BrowserTestUtils.is_hidden(item))
       items[item.mAddon.name] = item;
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
 
   return items;
 }
 
 function get_node(parent, anonid) {
   return parent.ownerDocument.getAnonymousElementByAttribute(parent, "anonid", anonid);
 }
diff --git a/toolkit/mozapps/extensions/test/browser/browser_manualupdates.js b/toolkit/mozapps/extensions/test/browser/browser_manualupdates.js
--- a/toolkit/mozapps/extensions/test/browser/browser_manualupdates.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_manualupdates.js
@@ -91,29 +91,29 @@ add_test(async function() {
   is(gManagerWindow.gViewController.currentViewId, "addons://updates/available", "Available Updates view should be the current view");
   run_next_test();
 });
 
 
 add_test(async function() {
   var list = gManagerWindow.document.getElementById("updates-list");
   is(list.itemCount, 1, "Should be 1 available update listed");
-  var item = list.firstChild;
+  var item = list.firstElementChild;
   is(item.mAddon.id, "addon2@tests.mozilla.org", "Update item should be for the manually updating addon");
 
   // The item in the list will be checking for update information asynchronously
   // so we have to wait for it to complete. Doing the same async request should
   // make our callback be called later.
   await AddonManager.getAllInstalls();
   run_next_test();
 });
 
 add_test(function() {
   var list = gManagerWindow.document.getElementById("updates-list");
-  var item = list.firstChild;
+  var item = list.firstElementChild;
   get_tooltip_info(item).then(({ version }) => {
     is(version, "1.1", "Update item should have version number of the update");
     var postfix = gManagerWindow.document.getAnonymousElementByAttribute(item, "class", "update-postfix");
     is_element_visible(postfix, "'Update' postfix should be visible");
     is_element_visible(item._updateAvailable, "");
     is_element_visible(item._relNotesToggle, "Release notes toggle should be visible");
     is_element_hidden(item._warning, "Incompatible warning should be hidden");
     is_element_hidden(item._error, "Blocklist error should be hidden");
@@ -162,17 +162,17 @@ add_test(function() {
   gAvailableCategory.addEventListener("CategoryBadgeUpdated", function() {
     if (installCompleted)
       run_next_test();
     else
       badgeUpdated = true;
   }, {once: true});
 
   var list = gManagerWindow.document.getElementById("updates-list");
-  var item = list.firstChild;
+  var item = list.firstElementChild;
   var updateBtn = item._updateBtn;
   is_element_visible(updateBtn, "Update button should be visible");
 
   var install = gProvider.installs[0];
   var listener = {
     onInstallStarted() {
       info("Install started");
       is_element_visible(item._installStatus, "Install progress widget should be visible");
diff --git a/toolkit/mozapps/extensions/test/browser/browser_sorting.js b/toolkit/mozapps/extensions/test/browser/browser_sorting.js
--- a/toolkit/mozapps/extensions/test/browser/browser_sorting.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_sorting.js
@@ -183,35 +183,35 @@ async function test() {
 async function end_test() {
   await close_manager(gManagerWindow);
   finish();
 }
 
 function set_order(aSortBy, aAscending) {
   var list = gManagerWindow.document.getElementById("addon-list");
   var elements = [];
-  var node = list.firstChild;
+  var node = list.firstElementChild;
   while (node) {
     elements.push(node);
-    node = node.nextSibling;
+    node = node.nextElementSibling;
   }
   gManagerWindow.sortElements(elements, ["uiState", aSortBy], aAscending);
   for (let element of elements)
     list.appendChild(element);
 }
 
 function check_order(aExpectedOrder) {
   var order = [];
   var list = gManagerWindow.document.getElementById("addon-list");
-  var node = list.firstChild;
+  var node = list.firstElementChild;
   while (node) {
     var id = node.getAttribute("value");
     if (id && id.endsWith("@tests.mozilla.org"))
       order.push(node.getAttribute("value"));
-    node = node.nextSibling;
+    node = node.nextElementSibling;
   }
 
   is(order.toSource(), aExpectedOrder.toSource(), "Should have seen the right order");
 }
 
 // Tests that ascending name ordering was the default
 add_test(function() {
 
diff --git a/toolkit/mozapps/extensions/test/browser/browser_sorting_plugins.js b/toolkit/mozapps/extensions/test/browser/browser_sorting_plugins.js
--- a/toolkit/mozapps/extensions/test/browser/browser_sorting_plugins.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_sorting_plugins.js
@@ -62,22 +62,22 @@ async function test() {
 async function end_test() {
   await close_manager(gManagerWindow);
   finish();
 }
 
 function check_order(aExpectedOrder) {
   var order = [];
   var list = gManagerWindow.document.getElementById("addon-list");
-  var node = list.firstChild;
+  var node = list.firstElementChild;
   while (node) {
     var id = node.getAttribute("value");
     if (id && id.endsWith("@tests.mozilla.org"))
       order.push(node.getAttribute("value"));
-    node = node.nextSibling;
+    node = node.nextElementSibling;
   }
 
   is(order.toSource(), aExpectedOrder.toSource(), "Should have seen the right order");
 }
 
 // Tests that ascending name ordering was the default
 add_test(function() {
 
diff --git a/toolkit/mozapps/extensions/test/browser/browser_types.js b/toolkit/mozapps/extensions/test/browser/browser_types.js
--- a/toolkit/mozapps/extensions/test/browser/browser_types.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_types.js
@@ -55,19 +55,19 @@ add_test(async function() {
   let aWindow = await open_manager(null);
   gManagerWindow = aWindow;
   gCategoryUtilities = new CategoryUtilities(gManagerWindow);
 
   ok(gCategoryUtilities.get("type1"), "Type 1 should be present");
   ok(gCategoryUtilities.get("type2"), "Type 2 should be present");
   ok(!gCategoryUtilities.get("missing1", true), "Missing 1 should be absent");
 
-  is(gCategoryUtilities.get("type1").previousSibling.getAttribute("value"),
+  is(gCategoryUtilities.get("type1").previousElementSibling.getAttribute("value"),
      "addons://list/extension", "Type 1 should be in the right place");
-  is(gCategoryUtilities.get("type2").previousSibling.getAttribute("value"),
+  is(gCategoryUtilities.get("type2").previousElementSibling.getAttribute("value"),
      "addons://list/theme", "Type 2 should be in the right place");
 
   ok(gCategoryUtilities.isTypeVisible("type1"), "Type 1 should be visible");
   ok(!gCategoryUtilities.isTypeVisible("type2"), "Type 2 should be hidden");
 
   run_next_test();
 });
 
@@ -102,19 +102,19 @@ add_test(async function() {
   ok(!gCategoryUtilities.get("missing1", true), "Missing 1 should be absent");
 
   AddonManagerPrivate.registerProvider(gProvider, gTypes);
 
   ok(gCategoryUtilities.get("type1"), "Type 1 should be present");
   ok(gCategoryUtilities.get("type2"), "Type 2 should be present");
   ok(!gCategoryUtilities.get("missing1", true), "Missing 1 should be absent");
 
-  is(gCategoryUtilities.get("type1").previousSibling.getAttribute("value"),
+  is(gCategoryUtilities.get("type1").previousElementSibling.getAttribute("value"),
      "addons://list/extension", "Type 1 should be in the right place");
-  is(gCategoryUtilities.get("type2").previousSibling.getAttribute("value"),
+  is(gCategoryUtilities.get("type2").previousElementSibling.getAttribute("value"),
      "addons://list/theme", "Type 2 should be in the right place");
 
   ok(gCategoryUtilities.isTypeVisible("type1"), "Type 1 should be visible");
   ok(!gCategoryUtilities.isTypeVisible("type2"), "Type 2 should be hidden");
 
   run_next_test();
 });
 
diff --git a/toolkit/mozapps/extensions/test/browser/browser_uninstalling.js b/toolkit/mozapps/extensions/test/browser/browser_uninstalling.js
--- a/toolkit/mozapps/extensions/test/browser/browser_uninstalling.js
+++ b/toolkit/mozapps/extensions/test/browser/browser_uninstalling.js
@@ -63,23 +63,23 @@ async function test() {
 }
 
 async function end_test() {
   await close_manager(gManagerWindow);
   finish();
 }
 
 function get_item_in_list(aId, aList) {
-  var item = aList.firstChild;
+  var item = aList.firstElementChild;
   while (item) {
     if ("mAddon" in item && item.mAddon.id == aId) {
       aList.ensureElementIsVisible(item);
       return item;
     }
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
   return null;
 }
 
 // Tests that uninstalling a restartless add-on from the list view can be undone
 add_test(async function() {
   var ID = "addon2@tests.mozilla.org";
   var list = gDocument.getElementById("addon-list");
diff --git a/toolkit/mozapps/extensions/test/browser/head.js b/toolkit/mozapps/extensions/test/browser/head.js
--- a/toolkit/mozapps/extensions/test/browser/head.js
+++ b/toolkit/mozapps/extensions/test/browser/head.js
@@ -278,43 +278,43 @@ function get_current_view(aManager) {
   }
   is(view, aManager.gViewController.displayedView, "view controller is tracking the displayed view correctly");
   return view;
 }
 
 function get_test_items_in_list(aManager) {
   var tests = "@tests.mozilla.org";
 
-  let item = aManager.document.getElementById("addon-list").firstChild;
+  let item = aManager.document.getElementById("addon-list").firstElementChild;
   let items = [];
 
   while (item) {
     if (item.localName != "richlistitem") {
-      item = item.nextSibling;
+      item = item.nextElementSibling;
       continue;
     }
 
     if (!item.mAddon || item.mAddon.id.substring(item.mAddon.id.length - tests.length) == tests)
       items.push(item);
-    item = item.nextSibling;
+    item = item.nextElementSibling;
   }
 
   return items;
 }
 
 function check_all_in_list(aManager, aIds, aIgnoreExtras) {
   var doc = aManager.document;
   var list = doc.getElementById("addon-list");
 
   var inlist = [];
-  var node = list.firstChild;
+  var node = list.firstElementChild;
   while (node) {
     if (node.value)
       inlist.push(node.value);
-    node = node.nextSibling;
+    node = node.nextElementSibling;
   }
 
   for (let id of aIds) {
     if (!inlist.includes(id))
       ok(false, "Should find " + id + " in the list");
   }
 
   if (aIgnoreExtras)
@@ -329,21 +329,21 @@ function check_all_in_list(aManager, aId
 function get_addon_element(aManager, aId) {
   var doc = aManager.document;
   var view = get_current_view(aManager);
   var listid = "addon-list";
   if (view.id == "updates-view")
     listid = "updates-list";
   var list = doc.getElementById(listid);
 
-  var node = list.firstChild;
+  var node = list.firstElementChild;
   while (node) {
     if (node.value == aId)
       return node;
-    node = node.nextSibling;
+    node = node.nextElementSibling;
   }
   return null;
 }
 
 function wait_for_view_load(aManagerWindow, aCallback, aForceWait, aLongerTimeout) {
   let p = new Promise(resolve => {
     requestLongerTimeout(aLongerTimeout ? aLongerTimeout : 2);
 
@@ -1384,15 +1384,15 @@ function promiseNotification(id = "addon
     return Promise.resolve();
   }
 
   return new Promise(resolve => {
     function popupshown() {
       let notification = PopupNotifications.getNotification(id);
       if (notification) {
         PopupNotifications.panel.removeEventListener("popupshown", popupshown);
-        PopupNotifications.panel.firstChild.button.click();
+        PopupNotifications.panel.firstElementChild.button.click();
         resolve();
       }
     }
     PopupNotifications.panel.addEventListener("popupshown", popupshown);
   });
 }
diff --git a/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js b/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
--- a/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
+++ b/toolkit/mozapps/extensions/test/xpinstall/browser_doorhanger_installs.js
@@ -64,19 +64,19 @@ async function waitForProgressNotificati
   }
 
   await observerPromise;
   await panelEventPromise;
   await waitForTick();
 
   info("Saw a notification");
   ok(PopupNotifications.isPanelOpen, "Panel should be open");
-  is(PopupNotifications.panel.childNodes.length, aExpectedCount, "Should be the right number of notifications");
-  if (PopupNotifications.panel.childNodes.length) {
-    let nodes = Array.from(PopupNotifications.panel.childNodes);
+  is(PopupNotifications.panel.children.length, aExpectedCount, "Should be the right number of notifications");
+  if (PopupNotifications.panel.children.length) {
+    let nodes = Array.from(PopupNotifications.panel.children);
     let notification = nodes.find(n => n.id == notificationId + "-notification");
     ok(notification, `Should have seen the right notification`);
     is(notification.button.hasAttribute("disabled"), wantDisabled,
        "The install button should be disabled?");
   }
 
   return PopupNotifications.panel;
 }
@@ -113,19 +113,19 @@ async function waitForNotification(aId, 
   });
 
   await observerPromise;
   await panelEventPromise;
   await waitForTick();
 
   info("Saw a " + aId + " notification");
   ok(PopupNotifications.isPanelOpen, "Panel should be open");
-  is(PopupNotifications.panel.childNodes.length, aExpectedCount, "Should be the right number of notifications");
-  if (PopupNotifications.panel.childNodes.length) {
-    let nodes = Array.from(PopupNotifications.panel.childNodes);
+  is(PopupNotifications.panel.children.length, aExpectedCount, "Should be the right number of notifications");
+  if (PopupNotifications.panel.children.length) {
+    let nodes = Array.from(PopupNotifications.panel.children);
     let notification = nodes.find(n => n.id == aId + "-notification");
     ok(notification, "Should have seen the " + aId + " notification");
   }
 
   return PopupNotifications.panel;
 }
 
 function waitForNotificationClose() {
@@ -134,17 +134,17 @@ function waitForNotificationClose() {
     PopupNotifications.panel.addEventListener("popuphidden", function() {
       resolve();
     }, {once: true});
   });
 }
 
 async function waitForInstallDialog(id = "addon-webext-permissions") {
   let panel = await waitForNotification(id);
-  return panel.childNodes[0];
+  return panel.children[0];
 }
 
 function removeTabAndWaitForNotificationClose() {
   let closePromise = waitForNotificationClose();
   BrowserTestUtils.removeTab(gBrowser.selectedTab);
   return closePromise;
 }
 
@@ -152,17 +152,17 @@ function acceptInstallDialog(installDial
   installDialog.button.click();
 }
 
 function cancelInstallDialog(installDialog) {
   installDialog.secondaryButton.click();
 }
 
 async function waitForSingleNotification(aCallback) {
-  while (PopupNotifications.panel.childNodes.length != 1) {
+  while (PopupNotifications.panel.children.length != 1) {
     await new Promise(resolve => executeSoon(resolve));
 
     info("Waiting for single notification");
     // Notification should never close while we wait
     ok(PopupNotifications.isPanelOpen, "Notification should still be open");
   }
 }
 
@@ -183,17 +183,17 @@ async function test_disabledInstall() {
 
   let notificationPromise = waitForNotification("xpinstall-disabled");
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "amosigned.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   let panel = await notificationPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   is(notification.button.label, "Enable", "Should have seen the right button");
   is(notification.getAttribute("label"),
      "Software installation is currently disabled. Click Enable and try again.");
 
   let closePromise = waitForNotificationClose();
   // Click on Enable
   EventUtils.synthesizeMouseAtCenter(notification.button, {});
   await closePromise;
@@ -212,30 +212,30 @@ async function test_disabledInstall() {
 async function test_blockedInstall() {
   let notificationPromise = waitForNotification("addon-install-blocked");
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "amosigned.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   let panel = await notificationPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   is(notification.button.label, "Allow", "Should have seen the right button");
   is(notification.getAttribute("origin"), "example.com",
      "Should have seen the right origin host");
   is(notification.getAttribute("label"),
      gApp + " prevented this site from asking you to install software on your computer.",
      "Should have seen the right message");
 
   let dialogPromise = waitForInstallDialog();
   // Click on Allow
   EventUtils.synthesizeMouse(notification.button, 20, 10, {});
   // Notification should have changed to progress notification
   ok(PopupNotifications.isPanelOpen, "Notification should still be open");
-  notification = panel.childNodes[0];
+  notification = panel.children[0];
   is(notification.id, "addon-progress-notification", "Should have seen the progress notification");
 
   let installDialog = await dialogPromise;
 
   notificationPromise = waitForNotification("addon-installed");
   installDialog.button.click();
   panel = await notificationPromise;
 
@@ -291,17 +291,17 @@ async function test_failedDownload() {
   let failPromise = waitForNotification("addon-install-failed");
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "missing.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   await progressPromise;
   let panel = await failPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   is(notification.getAttribute("label"),
      "The add-on could not be downloaded because of a connection failure.",
      "Should have seen the right message");
 
   Services.perms.remove(makeURI("http://example.com/"), "install");
   await removeTabAndWaitForNotificationClose();
 },
 
@@ -313,17 +313,17 @@ async function test_corruptFile() {
   let failPromise = waitForNotification("addon-install-failed");
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "corrupt.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   await progressPromise;
   let panel = await failPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   is(notification.getAttribute("label"),
      "The add-on downloaded from this site could not be installed " +
      "because it appears to be corrupt.",
      "Should have seen the right message");
 
   Services.perms.remove(makeURI("http://example.com/"), "install");
   await removeTabAndWaitForNotificationClose();
 },
@@ -336,17 +336,17 @@ async function test_incompatible() {
   let failPromise = waitForNotification("addon-install-failed");
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "incompatible.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   await progressPromise;
   let panel = await failPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   is(notification.getAttribute("label"),
      "The add-on downloaded from this site could not be installed " +
      "because it appears to be corrupt.",
      "Should have seen the right message");
 
   Services.perms.remove(makeURI("http://example.com/"), "install");
   await removeTabAndWaitForNotificationClose();
 },
@@ -395,61 +395,61 @@ async function test_sequential() {
     "Restartless XPI": "restartless.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   await progressPromise;
   let installDialog = await dialogPromise;
 
   // Should see the right add-on
   let container = document.getElementById("addon-install-confirmation-content");
-  is(container.childNodes.length, 1, "Should be one item listed");
-  is(container.childNodes[0].firstChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
+  is(container.children.length, 1, "Should be one item listed");
+  is(container.children[0].firstElementChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
 
   progressPromise = waitForProgressNotification(true, 2);
   triggers = encodeURIComponent(JSON.stringify({
     "Theme XPI": "theme.xpi"
   }));
   gBrowser.loadURI(TESTROOT + "installtrigger.html?" + triggers);
   await progressPromise;
 
   // Should still have the right add-on in the confirmation notification
-  is(container.childNodes.length, 1, "Should be one item listed");
-  is(container.childNodes[0].firstChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
+  is(container.children.length, 1, "Should be one item listed");
+  is(container.children[0].firstElementChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
 
   // Wait for the install to complete, we won't see a new confirmation
   // notification
   await new Promise(resolve => {
     Services.obs.addObserver(function observer() {
       Services.obs.removeObserver(observer, "addon-install-confirmation");
       resolve();
     }, "addon-install-confirmation");
   });
 
   // Make sure browser-addons.js executes first
   await new Promise(resolve => executeSoon(resolve));
 
   // Should have dropped the progress notification
-  is(PopupNotifications.panel.childNodes.length, 1, "Should be the right number of notifications");
-  is(PopupNotifications.panel.childNodes[0].id, "addon-install-confirmation-notification",
+  is(PopupNotifications.panel.children.length, 1, "Should be the right number of notifications");
+  is(PopupNotifications.panel.children[0].id, "addon-install-confirmation-notification",
      "Should only be showing one install confirmation");
 
   // Should still have the right add-on in the confirmation notification
-  is(container.childNodes.length, 1, "Should be one item listed");
-  is(container.childNodes[0].firstChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
+  is(container.children.length, 1, "Should be one item listed");
+  is(container.children[0].firstElementChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
 
   cancelInstallDialog(installDialog);
 
   ok(PopupNotifications.isPanelOpen, "Panel should still be open");
-  is(PopupNotifications.panel.childNodes.length, 1, "Should be the right number of notifications");
-  is(PopupNotifications.panel.childNodes[0].id, "addon-install-confirmation-notification",
+  is(PopupNotifications.panel.children.length, 1, "Should be the right number of notifications");
+  is(PopupNotifications.panel.children[0].id, "addon-install-confirmation-notification",
      "Should still have an install confirmation open");
 
   // Should have the next add-on's confirmation dialog
-  is(container.childNodes.length, 1, "Should be one item listed");
-  is(container.childNodes[0].firstChild.getAttribute("value"), "Theme Test", "Should have the right add-on");
+  is(container.children.length, 1, "Should be one item listed");
+  is(container.children[0].firstElementChild.getAttribute("value"), "Theme Test", "Should have the right add-on");
 
   Services.perms.remove(makeURI("http://example.com"), "install");
   let closePromise = waitForNotificationClose();
   cancelInstallDialog(installDialog);
   await closePromise;
 
   BrowserTestUtils.removeTab(gBrowser.selectedTab);
 },
@@ -473,19 +473,19 @@ async function test_allUnverified() {
   await progressPromise;
   let installDialog = await dialogPromise;
 
   let notification = document.getElementById("addon-install-confirmation-notification");
   let message = notification.getAttribute("label");
   is(message, "Caution: This site would like to install an unverified add-on in " + gApp + ". Proceed at your own risk.");
 
   let container = document.getElementById("addon-install-confirmation-content");
-  is(container.childNodes.length, 1, "Should be one item listed");
-  is(container.childNodes[0].firstChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
-  is(container.childNodes[0].childNodes.length, 1, "Shouldn't have the unverified marker");
+  is(container.children.length, 1, "Should be one item listed");
+  is(container.children[0].firstElementChild.getAttribute("value"), "XPI Test", "Should have the right add-on");
+  is(container.children[0].children.length, 1, "Shouldn't have the unverified marker");
 
   let notificationPromise = waitForNotification("addon-installed");
   acceptInstallDialog(installDialog);
   await notificationPromise;
 
   let addon = await AddonManager.getAddonByID("restartless-xpi@tests.mozilla.org");
   addon.uninstall();
 
@@ -512,17 +512,17 @@ async function test_localFile() {
   gBrowser.selectedTab = BrowserTestUtils.addTab(gBrowser, "about:blank");
   await BrowserTestUtils.browserLoaded(gBrowser.selectedBrowser);
   gBrowser.loadURI(path);
   await failPromise;
 
   // Wait for the browser code to add the failure notification
   await waitForSingleNotification();
 
-  let notification = PopupNotifications.panel.childNodes[0];
+  let notification = PopupNotifications.panel.children[0];
   is(notification.id, "addon-install-failed-notification", "Should have seen the install fail");
   is(notification.getAttribute("label"),
      "This add-on could not be installed because it appears to be corrupt.",
      "Should have seen the right message");
 
   await removeTabAndWaitForNotificationClose();
 },
 
@@ -615,17 +615,17 @@ async function test_wrongHost() {
   await loadedPromise;
 
   let progressPromise = waitForProgressNotification();
   let notificationPromise = waitForNotification("addon-install-failed");
   gBrowser.loadURI(TESTROOT + "corrupt.xpi");
   await progressPromise;
   let panel = await notificationPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   is(notification.getAttribute("label"),
      "The add-on downloaded from this site could not be installed " +
      "because it appears to be corrupt.",
      "Should have seen the right message");
 
   await removeTabAndWaitForNotificationClose();
 },
 
@@ -665,26 +665,26 @@ async function test_cancel() {
 
   let notificationPromise = waitForNotification(PROGRESS_NOTIFICATION);
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "slowinstall.sjs?file=amosigned.xpi"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, TESTROOT + "installtrigger.html?" + triggers);
   let panel = await notificationPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   // Close the notification
   let anchor = document.getElementById("addons-notification-icon");
   anchor.click();
   // Reopen the notification
   anchor.click();
 
   ok(PopupNotifications.isPanelOpen, "Notification should still be open");
-  is(PopupNotifications.panel.childNodes.length, 1, "Should be only one notification");
-  notification = panel.childNodes[0];
+  is(PopupNotifications.panel.children.length, 1, "Should be only one notification");
+  notification = panel.children[0];
   is(notification.id, "addon-progress-notification", "Should have seen the progress notification");
 
   // Cancel the download
   let install = notification.notification.options.installs[0];
   let cancelledPromise = new Promise(resolve => {
     install.addListener({
       onDownloadCancelled() {
         install.removeListener(this);
@@ -714,39 +714,39 @@ async function test_failedSecurity() {
 
   let notificationPromise = waitForNotification("addon-install-blocked");
   let triggers = encodeURIComponent(JSON.stringify({
     "XPI": "redirect.sjs?mode=redirect"
   }));
   BrowserTestUtils.openNewForegroundTab(gBrowser, SECUREROOT + "installtrigger.html?" + triggers);
   let panel = await notificationPromise;
 
-  let notification = panel.childNodes[0];
+  let notification = panel.children[0];
   // Click on Allow
   EventUtils.synthesizeMouse(notification.button, 20, 10, {});
 
   // Notification should have changed to progress notification
   ok(PopupNotifications.isPanelOpen, "Notification should still be open");
-  is(PopupNotifications.panel.childNodes.length, 1, "Should be only one notification");
-  notification = panel.childNodes[0];
+  is(PopupNotifications.panel.children.length, 1, "Should be only one notification");
+  notification = panel.children[0];
   is(notification.id, "addon-progress-notification", "Should have seen the progress notification");
 
   // Wait for it to fail
   await new Promise(resolve => {
     Services.obs.addObserver(function observer() {
       Services.obs.removeObserver(observer, "addon-install-failed");
       resolve();
     }, "addon-install-failed");
   });
 
   // Allow the browser code to add the failure notification and then wait
   // for the progress notification to dismiss itself
   await waitForSingleNotification();
-  is(PopupNotifications.panel.childNodes.length, 1, "Should be only one notification");
-  notification = panel.childNodes[0];
+  is(PopupNotifications.panel.children.length, 1, "Should be only one notification");
+  notification = panel.children[0];
   is(notification.id, "addon-install-failed-notification", "Should have seen the install fail");
 
   Services.prefs.setBoolPref(PREF_INSTALL_REQUIREBUILTINCERTS, true);
   await removeTabAndWaitForNotificationClose();
 }
 ];
 
 var gTestStart = null;
diff --git a/toolkit/mozapps/extensions/test/xpinstall/head.js b/toolkit/mozapps/extensions/test/xpinstall/head.js
--- a/toolkit/mozapps/extensions/test/xpinstall/head.js
+++ b/toolkit/mozapps/extensions/test/xpinstall/head.js
@@ -185,17 +185,17 @@ var Harness = {
       executeSoon(() => callback(count));
   },
 
   // Window open handling
   windowReady(window) {
     if (window.document.location.href == XPINSTALL_URL) {
       if (this.installBlockedCallback)
         ok(false, "Should have been blocked by the whitelist");
-      this.pendingCount = window.document.getElementById("itemList").childNodes.length;
+      this.pendingCount = window.document.getElementById("itemList").children.length;
 
       // If there is a confirm callback then its return status determines whether
       // to install the items or not. If not the test is over.
       let result = true;
       if (this.installConfirmCallback) {
         result = this.installConfirmCallback(window);
         if (result === this.leaveOpen)
           return;
@@ -260,22 +260,22 @@ var Harness = {
       panel.secondaryButton.click();
     } else {
       panel.button.click();
     }
   },
 
   handleEvent(event) {
     if (event.type === "popupshown") {
-      if (event.target.firstChild) {
+      if (event.target.firstElementChild) {
         let popupId = event.target.getAttribute("popupid");
         if (popupId === "addon-webext-permissions") {
-          this.popupReady(event.target.firstChild);
+          this.popupReady(event.target.firstElementChild);
         } else if (popupId === "addon-installed" || popupId === "addon-install-failed") {
-          event.target.firstChild.button.click();
+          event.target.firstElementChild.button.click();
         }
       }
     }
   },
 
   // Install blocked handling
 
   installDisabled(installInfo) {
diff --git a/toolkit/mozapps/handling/content/dialog.js b/toolkit/mozapps/handling/content/dialog.js
--- a/toolkit/mozapps/handling/content/dialog.js
+++ b/toolkit/mozapps/handling/content/dialog.js
@@ -138,17 +138,17 @@ var dialog = {
     }
 
     if (this._handlerInfo.hasDefaultHandler) {
       let elm = document.createElement("richlistitem");
       elm.setAttribute("type", "handler");
       elm.id = "os-default-handler";
       elm.setAttribute("name", this._handlerInfo.defaultDescription);
 
-      items.insertBefore(elm, items.firstChild);
+      items.insertBefore(elm, items.firstElementChild);
       if (this._handlerInfo.preferredAction ==
           Ci.nsIHandlerInfo.useSystemDefault)
           this.selectedItem = elm;
     }
 
     // Add gio handlers
     if (Cc["@mozilla.org/gio-service;1"]) {
       let gIOSvc = Cc["@mozilla.org/gio-service;1"]
@@ -200,32 +200,32 @@ var dialog = {
         let uri = Services.io.newFileURI(fp.file);
 
         let handlerApp = Cc["@mozilla.org/uriloader/local-handler-app;1"].
                          createInstance(Ci.nsILocalHandlerApp);
         handlerApp.executable = fp.file;
 
         // if this application is already in the list, select it and don't add it again
         let parent = document.getElementById("items");
-        for (let i = 0; i < parent.childNodes.length; ++i) {
-          let elm = parent.childNodes[i];
+        for (let i = 0; i < parent.children.length; ++i) {
+          let elm = parent.children[i];
           if (elm.obj instanceof Ci.nsILocalHandlerApp && elm.obj.equals(handlerApp)) {
             parent.selectedItem = elm;
             parent.ensureSelectedElementIsVisible();
             return;
           }
         }
 
         let elm = document.createElement("richlistitem");
         elm.setAttribute("type", "handler");
         elm.setAttribute("name", fp.file.leafName);
         elm.setAttribute("image", "moz-icon://" + uri.spec + "?size=32");
         elm.obj = handlerApp;
 
-        parent.selectedItem = parent.insertBefore(elm, parent.firstChild);
+        parent.selectedItem = parent.insertBefore(elm, parent.firstElementChild);
         parent.ensureSelectedElementIsVisible();
       }
     });
   },
 
  /**
   * Function called when the OK button is pressed.
   */
diff --git a/toolkit/mozapps/preferences/fontbuilder.js b/toolkit/mozapps/preferences/fontbuilder.js
--- a/toolkit/mozapps/preferences/fontbuilder.js
+++ b/toolkit/mozapps/preferences/fontbuilder.js
@@ -16,17 +16,17 @@ var FontBuilder = {
     return this._enumerator;
   },
 
   _allFonts: null,
   _langGroupSupported: false,
   async buildFontList(aLanguage, aFontType, aMenuList) {
     // Reset the list
     while (aMenuList.hasChildNodes())
-      aMenuList.firstChild.remove();
+      aMenuList.firstElementChild.remove();
 
     let defaultFont = null;
     // Load Font Lists
     let fonts = await this.enumerator.EnumerateFontsAsync(aLanguage, aFontType);
     if (fonts.length > 0)
       defaultFont = this.enumerator.getDefaultFont(aLanguage, aFontType);
     else {
       fonts = await this.enumerator.EnumerateFontsAsync(aLanguage, "");
@@ -64,30 +64,30 @@ var FontBuilder = {
     }
 
     // Build the UI for the remaining fonts.
     if (this._allFonts.length > fonts.length) {
       this._langGroupSupported = true;
       // Both lists are sorted, and the Fonts-By-Type list is a subset of the
       // All-Fonts list, so walk both lists side-by-side, skipping values we've
       // already created menu items for.
-      let builtItem = separator ? separator.nextSibling : popup.firstChild;
+      let builtItem = separator ? separator.nextElementSibling : popup.firstElementChild;
       let builtItemValue = builtItem ? builtItem.getAttribute("value") : null;
 
       separator = document.createElement("menuseparator");
       popup.appendChild(separator);
 
       for (let font of this._allFonts) {
         if (font != builtItemValue) {
           const menuitem = document.createElement("menuitem");
           menuitem.setAttribute("value", font);
           menuitem.setAttribute("label", font);
           popup.appendChild(menuitem);
         } else {
-          builtItem = builtItem.nextSibling;
+          builtItem = builtItem.nextElementSibling;
           builtItemValue = builtItem ? builtItem.getAttribute("value") : null;
         }
       }
     }
     aMenuList.appendChild(popup);
   },
 
   readFontSelection(aElement) {
diff --git a/toolkit/mozapps/update/content/history.js b/toolkit/mozapps/update/content/history.js
--- a/toolkit/mozapps/update/content/history.js
+++ b/toolkit/mozapps/update/content/history.js
@@ -15,17 +15,17 @@ var gUpdateHistory = {
     this._view = document.getElementById("historyItems");
 
     var um =
         Cc["@mozilla.org/updates/update-manager;1"].
         getService(Ci.nsIUpdateManager);
     var uc = um.updateCount;
     if (uc) {
       while (this._view.hasChildNodes())
-        this._view.firstChild.remove();
+        this._view.firstElementChild.remove();
 
       var bundle = document.getElementById("updateBundle");
 
       for (var i = 0; i < uc; ++i) {
         var update = um.getUpdateAt(i);
 
         if (!update || !update.name)
           continue;
diff --git a/toolkit/mozapps/update/content/updates.js b/toolkit/mozapps/update/content/updates.js
--- a/toolkit/mozapps/update/content/updates.js
+++ b/toolkit/mozapps/update/content/updates.js
@@ -284,17 +284,17 @@ var gUpdates = {
     this.wiz = document.documentElement;
 
     gLogEnabled = Services.prefs.getBoolPref(PREF_APP_UPDATE_LOG, false);
 
     this.strings = document.getElementById("updateStrings");
     var brandStrings = document.getElementById("brandStrings");
     this.brandName = brandStrings.getString("brandShortName");
 
-    var pages = this.wiz.childNodes;
+    var pages = this.wiz.children;
     for (var i = 0; i < pages.length; ++i) {
       var page = pages[i];
       if (page.localName == "wizardpage")
         // eslint-disable-next-line no-eval
         this._pages[page.pageid] = eval(page.getAttribute("object"));
     }
 
     // Cache the standard button labels in case we need to restore them
@@ -775,17 +775,17 @@ var gDownloadingPage = {
    * Updates the text status message
    */
   _setStatus(status) {
     // Don't bother setting the same text more than once. This can happen
     // due to the asynchronous behavior of the downloader.
     if (this._downloadStatus.textContent == status)
       return;
     while (this._downloadStatus.hasChildNodes())
-      this._downloadStatus.firstChild.remove();
+      this._downloadStatus.firstElementChild.remove();
     this._downloadStatus.appendChild(document.createTextNode(status));
   },
 
   /**
    * Update download progress status to show time left, speed, and progress.
    * Also updates the status needed for pausing the download.
    *
    * @param aCurr
diff --git a/toolkit/mozapps/update/nsUpdateService.js b/toolkit/mozapps/update/nsUpdateService.js
--- a/toolkit/mozapps/update/nsUpdateService.js
+++ b/toolkit/mozapps/update/nsUpdateService.js
@@ -1219,18 +1219,18 @@ function Update(update) {
 
   // Null <update>, assume this is a message container and do no
   // further initialization
   if (!update) {
     return;
   }
 
   let patch;
-  for (let i = 0; i < update.childNodes.length; ++i) {
-    let patchElement = update.childNodes.item(i);
+  for (let i = 0; i < update.children.length; ++i) {
+    let patchElement = update.children.item(i);
     if (patchElement.nodeType != patchElement.ELEMENT_NODE ||
         patchElement.localName != "patch") {
       continue;
     }
 
     try {
       patch = new UpdatePatch(patchElement);
     } catch (e) {
@@ -2578,19 +2578,19 @@ UpdateManager.prototype = {
     var fileStream = Cc["@mozilla.org/network/file-input-stream;1"].
                      createInstance(Ci.nsIFileInputStream);
     fileStream.init(file, FileUtils.MODE_RDONLY, FileUtils.PERMS_FILE, 0);
     try {
       var parser = new DOMParser();
       var doc = parser.parseFromStream(fileStream, "UTF-8",
                                        fileStream.available(), "text/xml");
 
-      var updateCount = doc.documentElement.childNodes.length;
+      var updateCount = doc.documentElement.children.length;
       for (var i = 0; i < updateCount; ++i) {
-        var updateElement = doc.documentElement.childNodes.item(i);
+        var updateElement = doc.documentElement.children.item(i);
         if (updateElement.nodeType != updateElement.ELEMENT_NODE ||
             updateElement.localName != "update")
           continue;
 
         let update;
         try {
           update = new Update(updateElement);
         } catch (e) {
@@ -3017,18 +3017,18 @@ Checker.prototype = {
 
     if (updatesElement.nodeName != "updates") {
       LOG("Checker:_updates get - unexpected node name!");
       throw new Error("Unexpected node name, expected: updates, got: " +
                       updatesElement.nodeName);
     }
 
     var updates = [];
-    for (var i = 0; i < updatesElement.childNodes.length; ++i) {
-      var updateElement = updatesElement.childNodes.item(i);
+    for (var i = 0; i < updatesElement.children.length; ++i) {
+      var updateElement = updatesElement.children.item(i);
       if (updateElement.nodeType != updateElement.ELEMENT_NODE ||
           updateElement.localName != "update")
         continue;
 
       let update;
       try {
         update = new Update(updateElement);
       } catch (e) {
diff --git a/toolkit/profile/content/createProfileWizard.js b/toolkit/profile/content/createProfileWizard.js
--- a/toolkit/profile/content/createProfileWizard.js
+++ b/toolkit/profile/content/createProfileWizard.js
@@ -25,17 +25,17 @@ var gProfileDisplay;
 function initWizard() {
   try {
     gProfileService = C[ToolkitProfileService].getService(I.nsIToolkitProfileService);
     gProfileManagerBundle = document.getElementById("bundle_profileManager");
 
     gDefaultProfileParent = Services.dirsvc.get("DefProfRt", I.nsIFile);
 
     // Initialize the profile location display.
-    gProfileDisplay = document.getElementById("profileDisplay").firstChild;
+    gProfileDisplay = document.getElementById("profileDisplay").firstElementChild;
     setDisplayToDefaultFolder();
   } catch (e) {
     window.close();
     throw (e);
   }
 }
 
 // Called every time the second wizard page is displayed.
@@ -105,24 +105,24 @@ function checkCurrentInput(currentInput)
   var finishText = document.getElementById("finishText");
   var canAdvance;
 
   var errorMessage = checkProfileName(currentInput);
 
   if (!errorMessage) {
     finishText.className = "";
     if (AppConstants.platform == "macosx") {
-      finishText.firstChild.data = gProfileManagerBundle.getString("profileFinishTextMac");
+      finishText.firstElementChild.data = gProfileManagerBundle.getString("profileFinishTextMac");
     } else {
-      finishText.firstChild.data = gProfileManagerBundle.getString("profileFinishText");
+      finishText.firstElementChild.data = gProfileManagerBundle.getString("profileFinishText");
     }
     canAdvance = true;
   } else {
     finishText.className = "error";
-    finishText.firstChild.data = errorMessage;
+    finishText.firstElementChild.data = errorMessage;
     canAdvance = false;
   }
 
   document.documentElement.canAdvance = canAdvance;
   finishButton.disabled = !canAdvance;
 
   updateProfileDisplay();
 
diff --git a/toolkit/profile/content/profileSelection.js b/toolkit/profile/content/profileSelection.js
--- a/toolkit/profile/content/profileSelection.js
+++ b/toolkit/profile/content/profileSelection.js
@@ -192,17 +192,17 @@ function RenameProfile() {
       selectedProfile.name = newName;
     } catch (e) {
       var alTitle = gProfileManagerBundle.getString("profileNameInvalidTitle");
       var alMsg = gProfileManagerBundle.getFormattedString("profileNameInvalid", [newName]);
       Services.prompt.alert(window, alTitle, alMsg);
       return false;
     }
 
-    selectedItem.firstChild.setAttribute("value", newName);
+    selectedItem.firstElementChild.setAttribute("value", newName);
     var tiptext = gProfileManagerBundle.
                   getFormattedString("profileTooltip",
                                      [newName, selectedProfile.rootDir.path]);
     selectedItem.setAttribute("tooltiptext", tiptext);
 
     return true;
   }
 
@@ -247,14 +247,14 @@ function ConfirmDelete() {
     let title = gProfileManagerBundle.getString("profileDeletionFailedTitle");
     let msg = gProfileManagerBundle.getString("profileDeletionFailed");
     Services.prompt.alert(window, title, msg);
 
     return true;
   }
 
   profileList.removeChild(selectedItem);
-  if (profileList.firstChild != undefined) {
-    profileList.selectItem(profileList.firstChild);
+  if (profileList.firstElementChild != undefined) {
+    profileList.selectItem(profileList.firstElementChild);
   }
 
   return true;
 }
diff --git a/toolkit/themes/osx/reftests/baseline.xul b/toolkit/themes/osx/reftests/baseline.xul
--- a/toolkit/themes/osx/reftests/baseline.xul
+++ b/toolkit/themes/osx/reftests/baseline.xul
@@ -135,17 +135,17 @@ function loaded() {
   ["regular", "small"].forEach(function(size) {
     let wrapper = document.querySelectorAll("#wrapper > ." + size)[0];
     allPairs([
       createLabel, createRadio, createCheckbox, createButton, createMenulist, createTextField,
        /* createEditableMenulist, */ /* These don't inherit "color" properly */
     ]).forEach(function(elemList) {
       let newBox = template.cloneNode(true);
       newBox.className = "spacer";
-      let foregroundRow = newBox.firstChild.lastChild;
+      let foregroundRow = newBox.firstElementChild.lastElementChild;
       elemList.forEach(function(creator) {
         foregroundRow.appendChild(creator("______"));
       });
       wrapper.appendChild(newBox);
     });
   });
   document.documentElement.className = "";
 }
diff --git a/toolkit/themes/osx/reftests/nostretch-ref.xul b/toolkit/themes/osx/reftests/nostretch-ref.xul
--- a/toolkit/themes/osx/reftests/nostretch-ref.xul
+++ b/toolkit/themes/osx/reftests/nostretch-ref.xul
@@ -78,17 +78,17 @@ function loaded() {
   let template = document.getElementById("template");
   ["regular", "small"].forEach(function(size) {
     let wrapper = document.querySelectorAll("#wrapper > ." + size)[0];
     allPairs([
       createButton, createMenulist, createTextField, createEditableMenulist,
     ]).forEach(function(elemList) {
       let newBox = template.cloneNode(true);
       newBox.className = "spacer";
-      let foregroundRow = newBox.firstChild;
+      let foregroundRow = newBox.firstElementChild;
       elemList.forEach(function(creator) {
         foregroundRow.appendChild(creator("Label"));
       });
       wrapper.appendChild(newBox);
     });
   });
   document.documentElement.className = "";
 }
diff --git a/toolkit/themes/osx/reftests/nostretch.xul b/toolkit/themes/osx/reftests/nostretch.xul
--- a/toolkit/themes/osx/reftests/nostretch.xul
+++ b/toolkit/themes/osx/reftests/nostretch.xul
@@ -91,17 +91,17 @@ function loaded() {
   let template = document.getElementById("template");
   ["regular", "small"].forEach(function(size) {
     let wrapper = document.querySelectorAll("#wrapper > ." + size)[0];
     allPairs([
       createButton, createMenulist, createTextField, createEditableMenulist,
     ]).forEach(function(elemList) {
       let newBox = template.cloneNode(true);
       newBox.className = "spacer";
-      let foregroundRow = newBox.firstChild;
+      let foregroundRow = newBox.firstElementChild;
       elemList.forEach(function(creator) {
         foregroundRow.appendChild(creator("Label"));
       });
       wrapper.appendChild(newBox);
     });
   });
   document.documentElement.className = "";
 }
