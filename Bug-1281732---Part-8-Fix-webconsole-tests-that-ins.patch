# vim: se ft=diff :
# HG changeset patch
# User Jarda Snajdr <jsnajdr@gmail.com>
# Date 2016-06-27 04:54
Bug 1281732 - Part 8: Fix webconsole tests that inspect the stack frames r=bgrins

diff --git a/devtools/client/webconsole/test/browser_console_addonsdk_loader_exception.js b/devtools/client/webconsole/test/browser_console_addonsdk_loader_exception.js
index 841b607..3eec65d 100644
--- a/devtools/client/webconsole/test/browser_console_addonsdk_loader_exception.js
+++ b/devtools/client/webconsole/test/browser_console_addonsdk_loader_exception.js
@@ -53,17 +53,17 @@ function test() {
       }],
     });
 
     fixToolbox();
 
     let msg = [...result.matched][0];
     ok(msg, "message element found");
     let locationNode = msg
-      .querySelector(".message > .message-location > .frame-link");
+      .querySelector(".message .message-location > .frame-link");
     ok(locationNode, "message location element found");
 
     let url = locationNode.getAttribute("data-url");
     info("location node url: " + url);
     ok(url.indexOf("resource://") === 0, "error comes from a subscript");
 
     let viewSource = browserconsole.viewSource;
     let URL = null;
diff --git a/devtools/client/webconsole/test/browser_console_error_source_click.js b/devtools/client/webconsole/test/browser_console_error_source_click.js
index e6578ff..8f39e89 100644
--- a/devtools/client/webconsole/test/browser_console_error_source_click.js
+++ b/devtools/client/webconsole/test/browser_console_error_source_click.js
@@ -59,17 +59,17 @@ add_task(function* () {
   };
 
   for (let result of results) {
     viewSourceCalled = false;
 
     let msg = [...result.matched][0];
     ok(msg, "message element found for: " + result.text);
     ok(!msg.classList.contains("filtered-by-type"), "message element is not filtered");
-    let selector = ".message > .message-location .frame-link-source";
+    let selector = ".message .message-location .frame-link-source";
     let locationNode = msg.querySelector(selector);
     ok(locationNode, "message location element found");
 
     EventUtils.synthesizeMouse(locationNode, 2, 2, {}, hud.iframeWindow);
 
     ok(viewSourceCalled, "view source opened");
   }
 
diff --git a/devtools/client/webconsole/test/browser_webconsole_console_trace_duplicates.js b/devtools/client/webconsole/test/browser_webconsole_console_trace_duplicates.js
index 8ca3f0f..e1c6f96 100644
--- a/devtools/client/webconsole/test/browser_webconsole_console_trace_duplicates.js
+++ b/devtools/client/webconsole/test/browser_webconsole_console_trace_duplicates.js
@@ -20,31 +20,31 @@ function test() {
     // NB: Now that stack frames include a column number multiple invocations
     //     on the same line are considered unique. ie:
     //       |foo(); foo();|
     //     will generate two distinct trace entries.
     yield waitForMessages({
       webconsole: hud,
       messages: [{
         name: "console.trace output for foo1()",
-        text: "foo1()",
+        text: "foo1",
         consoleTrace: {
           file: "test-bug_939783_console_trace_duplicates.html",
-          fn: "foo3()",
+          fn: "foo3",
         },
       }, {
         name: "console.trace output for foo1()",
-        text: "foo1()",
+        text: "foo1",
         consoleTrace: {
           file: "test-bug_939783_console_trace_duplicates.html",
-          fn: "foo3()",
+          fn: "foo3",
         },
       }, {
         name: "console.trace output for foo1b()",
-        text: "foo1b()",
+        text: "foo1b",
         consoleTrace: {
           file: "test-bug_939783_console_trace_duplicates.html",
-          fn: "foo3()",
+          fn: "foo3",
         },
       }],
     });
   }
 }
diff --git a/devtools/client/webconsole/test/browser_webconsole_jsterm.js b/devtools/client/webconsole/test/browser_webconsole_jsterm.js
index 5afa143..a36398e 100644
--- a/devtools/client/webconsole/test/browser_webconsole_jsterm.js
+++ b/devtools/client/webconsole/test/browser_webconsole_jsterm.js
@@ -144,31 +144,31 @@ function* testJSTerm(hud) {
   yield checkResult("undefined", "undefined is printed");
 
   // check that thrown strings produce error messages,
   // and the message text matches that of a stringified error object
   // bug 1099071
   jsterm.clearOutput();
   yield jsterm.execute("throw '';");
   yield checkResult((node) => {
-    return node.parentNode.getAttribute("severity") === "error" &&
+    return node.closest(".message").getAttribute("severity") === "error" &&
       node.textContent === new Error("").toString();
   }, "thrown empty string generates error message");
 
   jsterm.clearOutput();
   yield jsterm.execute("throw 'tomatoes';");
   yield checkResult((node) => {
-    return node.parentNode.getAttribute("severity") === "error" &&
+    return node.closest(".message").getAttribute("severity") === "error" &&
       node.textContent === new Error("tomatoes").toString();
   }, "thrown non-empty string generates error message");
 
   jsterm.clearOutput();
   yield jsterm.execute("throw { foo: 'bar' };");
   yield checkResult((node) => {
-    return node.parentNode.getAttribute("severity") === "error" &&
+    return node.closest(".message").getAttribute("severity") === "error" &&
       node.textContent === Object.prototype.toString();
   }, "thrown object generates error message");
 
   // check that errors with entires in errordocs.js display links
   // alongside their messages.
   const ErrorDocs = require("devtools/server/actors/errordocs");
 
   const ErrorDocStatements = {
diff --git a/devtools/client/webconsole/test/browser_webconsole_view_source.js b/devtools/client/webconsole/test/browser_webconsole_view_source.js
index 50554d4..e0865ce 100644
--- a/devtools/client/webconsole/test/browser_webconsole_view_source.js
+++ b/devtools/client/webconsole/test/browser_webconsole_view_source.js
@@ -1,54 +1,42 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that source URLs in the Web Console can be clicked to display the
-// standard View Source window.
+// standard View Source window. As JS exceptions and console.log() messages always
+// have their locations opened in Debugger, we need to test a security message in
+// order to have it opened in the standard View Source window.
 
 "use strict";
 
-const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
-                 "test/test-error.html";
+const TEST_URI = "https://example.com/browser/devtools/client/webconsole/" +
+                 "test/test-mixedcontent-securityerrors.html";
 
 add_task(function* () {
   yield loadTab(TEST_URI);
   let hud = yield openConsole(null);
   info("console opened");
 
-
-  // On e10s, the exception is triggered in child process
-  // and is ignored by test harness
-  if (!Services.appinfo.browserTabsRemoteAutostart) {
-    expectUncaughtException();
-  }
-
-  ContentTask.spawn(gBrowser.selectedBrowser, {}, function* () {
-    let button = content.document.querySelector("button");
-    ok(button, "we have the button on the page");
-    button.click();
-  });
-
   let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
-      text: "fooBazBaz is not defined",
-      category: CATEGORY_JS,
+      text: "Blocked loading mixed active content",
+      category: CATEGORY_SECURITY,
       severity: SEVERITY_ERROR,
     }],
   });
 
   let msg = [...result.matched][0];
   ok(msg, "error message");
   let locationNode = msg.querySelector(".message-location .frame-link-filename");
   ok(locationNode, "location node");
 
   let onTabOpen = waitForTab();
 
   EventUtils.sendMouseEvent({ type: "click" }, locationNode);
 
   let tab = yield onTabOpen;
-  ok(true, "the view source tab was opened in response to clicking " +
-           "the location node");
+  ok(true, "the view source tab was opened in response to clicking the location node");
   gBrowser.removeTab(tab);
 });
diff --git a/devtools/client/webconsole/test/head.js b/devtools/client/webconsole/test/head.js
index e50f8ab..8473388 100644
--- a/devtools/client/webconsole/test/head.js
+++ b/devtools/client/webconsole/test/head.js
@@ -1027,17 +1027,17 @@ function waitForMessages(options) {
     if (!location) {
       return false;
     }
 
     if (!checkText(rule.source.url, location.url)) {
       return false;
     }
 
-    if ("line" in rule.source && location.line === rule.source.line) {
+    if ("line" in rule.source && location.line != rule.source.line) {
       return false;
     }
 
     return true;
   }
 
   function checkCollapsible(rule, element) {
     let msg = element._messageObject;
@@ -1045,51 +1045,51 @@ function waitForMessages(options) {
       return false;
     }
 
     return true;
   }
 
   function checkStacktrace(rule, element) {
     let stack = rule.stacktrace;
-    let frames = element.querySelectorAll(".stacktrace > li");
+    let frames = element.querySelectorAll(".stacktrace > .stack-trace > .frame-link");
     if (!frames.length) {
       return false;
     }
 
     for (let i = 0; i < stack.length; i++) {
       let frame = frames[i];
       let expected = stack[i];
       if (!frame) {
         ok(false, "expected frame #" + i + " but didnt find it");
         return false;
       }
 
       if (expected.file) {
-        let url = getRenderedSource(frame).url;
+        let url = frame.getAttribute("data-url");
         if (!checkText(expected.file, url)) {
           ok(false, "frame #" + i + " does not match file name: " +
                     expected.file + " != " + url);
           displayErrorContext(rule, element);
           return false;
         }
       }
 
       if (expected.fn) {
-        let fn = frame.querySelector(".function").textContent;
+        let fn = frame.querySelector(".frame-link-function-display-name").textContent;
         if (!checkText(expected.fn, fn)) {
           ok(false, "frame #" + i + " does not match the function name: " +
                     expected.fn + " != " + fn);
           displayErrorContext(rule, element);
           return false;
         }
       }
 
       if (expected.line) {
-        let line = getRenderedSource(frame).line;
+        let line = frame.getAttribute("data-line");
         if (!checkText(expected.line, line)) {
           ok(false, "frame #" + i + " does not match the line number: " +
                     expected.line + " != " + line);
           displayErrorContext(rule, element);
           return false;
         }
       }
     }

